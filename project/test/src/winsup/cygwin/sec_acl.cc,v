head	1.86;
access;
symbols
	cygwin-1_7_35-release:1.86
	cygwin-1_7_34-release:1.81
	cygwin-1_7_33-release:1.75
	cygwin-1_7_32-release:1.75
	cygwin-1_7_31-release:1.75
	cygwin-1_7_30-release:1.75
	cygwin-1_7_29-release:1.75
	cygwin-1_7_29-release-branchpoint:1.75.0.2
	cygwin-pre-user-db:1.75
	cygwin-1_7_28-release:1.75
	cygwin-1_7_27-release:1.75
	cygwin-1_7_26-release:1.75
	cygwin-1_7_25-release:1.75
	cygwin-1_7_24-release:1.75
	cygwin-1_7_23-release:1.75
	cygwin-1_7_22-release:1.75
	cygwin-1_7_21-release:1.75
	cygwin-1_7_20-release:1.75
	cygwin-1_7_19-release:1.75
	cygwin-64bit-postmerge:1.75
	cygwin-64bit-premerge-branch:1.74.0.2
	cygwin-64bit-premerge:1.74
	cygwin-1_7_18-release:1.74
	post-ptmalloc3:1.72.2.5
	pre-ptmalloc3:1.72.2.5
	cygwin-1_7_17-release:1.72
	cygwin-64bit-branch:1.72.0.2
	cygwin-1_7_16-release:1.72
	cygwin-1_7_15-release:1.72
	cygwin-1_7_14_2-release:1.72
	cygwin-1_7_14-release:1.72
	cygwin-1_7_12-release:1.72
	cygwin-1_7_11-release:1.71
	cygwin-1_7_10-release:1.71
	signal-rewrite:1.70.0.2
	pre-notty:1.70
	cygwin-1_7_9-release:1.65
	cv-post-1_7_9:1.65.0.2
	cygwin-1_7_8-release:1.65
	cygwin-1_7_7-release:1.60
	cygwin-1_7_5-release:1.58
	cygwin-1_7_4-release:1.58
	cygwin-1_7_3-release:1.58
	cygwin-1_7_2-release:1.58
	fifo_doover3:1.57.0.2
	cygwin-1_7_1-release:1.57
	prefifo:1.56
	cv-branch-2:1.56.0.2
	pre-ripout-set_console_state_for_spawn:1.53
	EOL_registry_mounts:1.51
	preoverlapped:1.47
	drop_9x_support_start:1.47
	cr-0x5f1:1.46.0.2
	cv-branch:1.45.0.6
	pre-ptymaster-archetype:1.45
	cr-0x3b58:1.45.0.4
	cr-0x5ef:1.45.0.2
	after-mmap-privanon-noreserve:1.45
	after-mmap-revamp:1.45
	before-mmap-revamp:1.45
	cgf-more-exit-sync:1.45
	post_wait_sig_exit:1.45
	pre_wait_sig_exit:1.45
	reparent-point:1.43
	noreparent:1.43.0.4
	cr-0x5e6:1.43.0.2
	cr-0x9e:1.35.0.6
	cr-0x9d:1.35.0.4
	cgf-deleteme:1.35.0.2
	pre-sigrewrite:1.34
	corinna-01:1.32
	cr-0x9c:1.31.0.6
	cr-0x9b:1.31.0.4
	cr-0x99:1.31
	Z-emcb-cygwin_daemon:1.31.0.2
	w32api-2_2:1.26
	mingw-runtime-2_4:1.26
	pre-cgf-merge:1.31
	cgf-dev-branch:1.24.0.2
	predaemon:1.12
	cygwin_daemon_merge_HEAD:1.12
	pregp02r1:1.11.0.2
	cygnus_cvs_20020108_pre:1.9
	Z-cygwin_daemon_merge-new_HEAD:1.19
	Z-cygwin_daemon_merge_HEAD:1.19
	cygwin_daemon:1.8.0.4;
locks; strict;
comment	@// @;


1.86
date	2015.02.27.14.51.00;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2015.02.27.12.59.09;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2015.02.25.21.30.45;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2015.02.19.14.15.44;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2015.02.12.17.53.23;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2014.09.03.12.46.19;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2014.09.02.20.07.21;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2014.08.31.14.13.01;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2014.08.28.12.38.51;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2014.02.27.12.57.27;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2012.10.27.12.09.38;	author ktietz;	state Exp;
branches;
next	1.72;

1.72
date	2012.03.29.15.01.18;	author corinna;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2011.04.29.10.38.12;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2011.04.28.15.54.47;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2011.04.28.09.53.11;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.28.09.30.36;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.28.08.34.49;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.15.14.11.03;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.08.10.24.20;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.12.19.43.55;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.10.14.53.44;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2010.09.10.09.32.13;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.22.09.54.36;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.15.12.05.15;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.12.10.14.59;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.30.19.58.52;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2009.04.09.09.19.03;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.13.16.01.50;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2008.05.22.12.43.18;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.16.14.46.23;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.14.14.48.52;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2007.07.30.10.58.16;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.20.14.29.43;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.07.12.44.10;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.18.14.11.38;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2005.06.07.19.31.40;	author corinna;	state Exp;
branches
	1.45.6.1;
next	1.44;

1.44
date	2005.05.13.15.46.06;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.14.21.11.45;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.14.20.16.29;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.14.16.36.26;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.14.13.40.07;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.10.20.18.11;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.20.09.13.20;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.07.22.37.12;	author cgf;	state Exp;
branches
	1.35.6.1;
next	1.34;

1.34
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.26.10.52.21;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.10.16.25.48;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.09.20.10.25;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.21.14.29.18;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.05.16.15.22;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.12.11.38.51;	author corinna;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.12.12.03.09.38;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.10.12.43.49;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.25.11.23.21;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.24.18.58.47;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.26.09.56.06;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.02.08.11.15;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.02.06.07.01;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.29.15.04.26;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.28.14.10.51;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.25.17.47.47;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.15.23.39.33;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.15.22.40.07;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.25.09.43.25;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.20.13.02.32;	author corinna;	state Exp;
branches;
next	;

1.72.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2012.10.27.12.11.51;	author ktietz;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2012.11.16.09.41.13;	author corinna;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.72.2.5;

1.72.2.5
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	;

1.45.6.1
date	2006.07.18.14.11.44;	author corinna;	state Exp;
branches;
next	;

1.35.6.1
date	2004.01.20.19.57.29;	author cgf;	state Exp;
branches;
next	;

1.24.2.1
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.24.2.5;

1.24.2.5
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.24.2.6;

1.24.2.6
date	2003.03.19.19.59.55;	author cgf;	state Exp;
branches;
next	1.24.2.7;

1.24.2.7
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.8.4.1
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.02.28.12.53.26;	author rbcollins;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2002.06.13.14.34.10;	author rbcollins;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2002.07.02.10.58.19;	author scottc;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2002.08.26.11.38.14;	author scottc;	state Exp;
branches;
next	1.8.4.6;

1.8.4.6
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.86
log
@	* sec_acl.cc (getacl): Add mask even if all group and secondary account
	permissions are 0.
@
text
@/* sec_acl.cc: Sun compatible ACL functions.

   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012, 2014, 2015 Red Hat, Inc.

   Written by Corinna Vinschen <corinna@@vinschen.de>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <sys/acl.h>
#include <ctype.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "ntdll.h"
#include "tls_pbuf.h"

static int
searchace (aclent_t *aclp, int nentries, int type, uid_t id = ILLEGAL_UID)
{
  int i;

  for (i = 0; i < nentries; ++i)
    if ((aclp[i].a_type == type && (id == ILLEGAL_UID || aclp[i].a_id == id))
	|| !aclp[i].a_type)
      return i;
  return -1;
}

/* This function *requires* an acl list sorted with aclsort{32}. */
int
setacl (HANDLE handle, path_conv &pc, int nentries, aclent_t *aclbufp,
	bool &writable)
{
  security_descriptor sd_ret;
  tmp_pathbuf tp;

  if (get_file_sd (handle, pc, sd_ret, false))
    return -1;

  NTSTATUS status;
  PACL acl;
  BOOLEAN acl_exists, dummy;

  /* Get owner SID. */
  PSID owner_sid;
  status = RtlGetOwnerSecurityDescriptor (sd_ret, &owner_sid, &dummy);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  cygsid owner (owner_sid);

  /* Get group SID. */
  PSID group_sid;
  status = RtlGetGroupSecurityDescriptor (sd_ret, &group_sid, &dummy);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  cygsid group (group_sid);

  /* Search for NULL ACE and store state of SUID, SGID and VTX bits. */
  DWORD null_mask = 0;
  if (NT_SUCCESS (RtlGetDaclSecurityDescriptor (sd_ret, &acl_exists, &acl,
						&dummy)))
    for (USHORT i = 0; i < acl->AceCount; ++i)
      {
	ACCESS_ALLOWED_ACE *ace;
	if (NT_SUCCESS (RtlGetAce (acl, i, (PVOID *) &ace)))
	  {
	    cygpsid ace_sid ((PSID) &ace->SidStart);
	    if (ace_sid == well_known_null_sid)
	      {
		null_mask = ace->Mask;
		break;
	      }
	  }
      }

  /* Initialize local security descriptor. */
  SECURITY_DESCRIPTOR sd;
  RtlCreateSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);

  /* As in alloc_sd, set SE_DACL_PROTECTED to prevent the DACL from being
     modified by inheritable ACEs. */
  RtlSetControlSecurityDescriptor (&sd, SE_DACL_PROTECTED, SE_DACL_PROTECTED);

  status = RtlSetOwnerSecurityDescriptor (&sd, owner, FALSE);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  status = RtlSetGroupSecurityDescriptor (&sd, group, FALSE);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }

  /* Fill access control list. */
  acl = (PACL) tp.w_get ();
  size_t acl_len = sizeof (ACL);
  int ace_off = 0;

  cygsid sid;
  struct passwd *pw;
  struct group *gr;
  int pos;
  cyg_ldap cldap;

  RtlCreateAcl (acl, ACL_MAXIMUM_SIZE, ACL_REVISION);

  writable = false;

  bool *invalid = (bool *) tp.c_get ();
  memset (invalid, 0, nentries * sizeof *invalid);

  /* Pre-compute owner, group, and other permissions to allow creating
     matching deny ACEs as in alloc_sd. */
  DWORD owner_allow = 0, group_allow = 0, other_allow = 0;
  PDWORD allow;
  for (int i = 0; i < nentries; ++i)
    {
      switch (aclbufp[i].a_type)
	{
	case USER_OBJ:
	  allow = &owner_allow;
	  *allow = STANDARD_RIGHTS_ALL
		   | (pc.fs_is_samba () ? 0 : FILE_WRITE_ATTRIBUTES);
	  break;
	case GROUP_OBJ:
	  allow = &group_allow;
	  break;
	case OTHER_OBJ:
	  allow = &other_allow;
	  break;
	default:
	  continue;
	}
      *allow |= STANDARD_RIGHTS_READ | SYNCHRONIZE
		| (pc.fs_is_samba () ? 0 : FILE_READ_ATTRIBUTES);
      if (aclbufp[i].a_perm & S_IROTH)
	*allow |= FILE_GENERIC_READ;
      if (aclbufp[i].a_perm & S_IWOTH)
	{
	  *allow |= FILE_GENERIC_WRITE;
	  writable = true;
	}
      if (aclbufp[i].a_perm & S_IXOTH)
	*allow |= FILE_GENERIC_EXECUTE & ~FILE_READ_ATTRIBUTES;
      /* Keep S_ISVTX rule in sync with alloc_sd. */
      if (pc.isdir ()
	  && (aclbufp[i].a_perm & (S_IWOTH | S_IXOTH)) == (S_IWOTH | S_IXOTH)
	  && (aclbufp[i].a_type == USER_OBJ
	      || !(null_mask & FILE_READ_DATA)))
	*allow |= FILE_DELETE_CHILD;
      invalid[i] = true;
    }
  bool isownergroup = (owner == group);
  DWORD owner_deny = ~owner_allow & (group_allow | other_allow);
  owner_deny &= ~(STANDARD_RIGHTS_READ
		  | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES);
  DWORD group_deny = ~group_allow & other_allow;
  group_deny &= ~(STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES);

  /* Set deny ACE for owner. */
  if (owner_deny
      && !add_access_denied_ace (acl, ace_off++, owner_deny,
				 owner, acl_len, NO_INHERITANCE))
    return -1;
  /* Set deny ACE for group here to respect the canonical order,
     if this does not impact owner */
  if (group_deny && !(group_deny & owner_allow) && !isownergroup
      && !add_access_denied_ace (acl, ace_off++, group_deny,
				 group, acl_len, NO_INHERITANCE))
    return -1;
  /* Set allow ACE for owner. */
  if (!add_access_allowed_ace (acl, ace_off++, owner_allow,
			       owner, acl_len, NO_INHERITANCE))
    return -1;
  /* Set deny ACE for group, if still needed. */
  if (group_deny & owner_allow && !isownergroup
      && !add_access_denied_ace (acl, ace_off++, group_deny,
				 group, acl_len, NO_INHERITANCE))
    return -1;
  /* Set allow ACE for group. */
  if (!isownergroup
      && !add_access_allowed_ace (acl, ace_off++, group_allow,
                                  group, acl_len, NO_INHERITANCE))
    return -1;
  /* Set allow ACE for everyone. */
  if (!add_access_allowed_ace (acl, ace_off++, other_allow,
			       well_known_world_sid, acl_len, NO_INHERITANCE))
    return -1;
  /* If a NULL ACE exists, copy it verbatim. */
  if (null_mask)
    if (!add_access_allowed_ace (acl, ace_off++, null_mask, well_known_null_sid,
				 acl_len, NO_INHERITANCE))
      return -1;
  for (int i = 0; i < nentries; ++i)
    {
      DWORD allow;
      /* Skip invalidated entries. */
      if (invalid[i])
	continue;

      allow = STANDARD_RIGHTS_READ
	      | (pc.fs_is_samba () ? 0 : FILE_READ_ATTRIBUTES);
      if (aclbufp[i].a_perm & S_IROTH)
	allow |= FILE_GENERIC_READ;
      if (aclbufp[i].a_perm & S_IWOTH)
	{
	  allow |= FILE_GENERIC_WRITE;
	  writable = true;
	}
      if (aclbufp[i].a_perm & S_IXOTH)
	allow |= FILE_GENERIC_EXECUTE & ~FILE_READ_ATTRIBUTES;
      /* Keep S_ISVTX rule in sync with alloc_sd. */
      if (pc.isdir ()
	  && (aclbufp[i].a_perm & (S_IWOTH | S_IXOTH)) == (S_IWOTH | S_IXOTH)
	  && !(null_mask & FILE_READ_DATA))
	allow |= FILE_DELETE_CHILD;
      /* Set inherit property. */
      DWORD inheritance = (aclbufp[i].a_type & ACL_DEFAULT)
			  ? (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
			     | INHERIT_ONLY_ACE)
			  : NO_INHERITANCE;
      /*
       * If a specific acl contains a corresponding default entry with
       * identical permissions, only one Windows ACE with proper
       * inheritance bits is created.
       */
      if (!(aclbufp[i].a_type & ACL_DEFAULT)
	  && aclbufp[i].a_type & (USER|GROUP)
	  && (pos = searchace (aclbufp + i + 1, nentries - i - 1,
			       aclbufp[i].a_type | ACL_DEFAULT,
			       (aclbufp[i].a_type & (USER|GROUP))
			       ? aclbufp[i].a_id : ILLEGAL_UID)) >= 0
	  && aclbufp[i].a_perm == aclbufp[i + 1 + pos].a_perm)
	{
	  inheritance = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
	  /* invalidate the corresponding default entry. */
	  invalid[i + 1 + pos] = true;
	}
      switch (aclbufp[i].a_type)
	{
	case DEF_USER_OBJ:
	  allow |= STANDARD_RIGHTS_ALL
		   | (pc.fs_is_samba () ? 0 : FILE_WRITE_ATTRIBUTES);
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
				       well_known_creator_owner_sid, acl_len, inheritance))
	    return -1;
	  break;
	case USER:
	case DEF_USER:
	  if (!(pw = internal_getpwuid (aclbufp[i].a_id, &cldap))
	      || !sid.getfrompw (pw))
	    {
	      set_errno (EINVAL);
	      return -1;
	    }
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
				       sid, acl_len, inheritance))
	    return -1;
	  break;
	case DEF_GROUP_OBJ:
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
				       well_known_creator_group_sid, acl_len, inheritance))
	    return -1;
	  break;
	case GROUP:
	case DEF_GROUP:
	  if (!(gr = internal_getgrgid (aclbufp[i].a_id, &cldap))
	      || !sid.getfromgr (gr))
	    {
	      set_errno (EINVAL);
	      return -1;
	    }
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
				       sid, acl_len, inheritance))
	    return -1;
	  break;
	case DEF_OTHER_OBJ:
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
				       well_known_world_sid,
				       acl_len, inheritance))
	    return -1;
	}
    }
  /* Set AclSize to computed value. */
  acl->AclSize = acl_len;
  debug_printf ("ACL-Size: %u", acl_len);
  /* Create DACL for local security descriptor. */
  status = RtlSetDaclSecurityDescriptor (&sd, TRUE, acl, FALSE);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  /* Make self relative security descriptor in sd_ret. */
  DWORD sd_size = 0;
  RtlAbsoluteToSelfRelativeSD (&sd, sd_ret, &sd_size);
  if (sd_size <= 0)
    {
      __seterrno ();
      return -1;
    }
  if (!sd_ret.realloc (sd_size))
    {
      set_errno (ENOMEM);
      return -1;
    }
  status = RtlAbsoluteToSelfRelativeSD (&sd, sd_ret, &sd_size);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  debug_printf ("Created SD-Size: %u", sd_ret.size ());
  return set_file_sd (handle, pc, sd_ret, false);
}

/* Temporary access denied bits */
#define DENY_R 040000
#define DENY_W 020000
#define DENY_X 010000

static void
getace (aclent_t &acl, int type, int id, DWORD win_ace_mask,
	DWORD win_ace_type)
{
  acl.a_type = type;
  acl.a_id = id;

  if ((win_ace_mask & FILE_READ_BITS) && !(acl.a_perm & (S_IROTH | DENY_R)))
    {
      if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
	acl.a_perm |= S_IROTH;
      else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
	acl.a_perm |= DENY_R;
    }

  if ((win_ace_mask & FILE_WRITE_BITS) && !(acl.a_perm & (S_IWOTH | DENY_W)))
    {
      if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
	acl.a_perm |= S_IWOTH;
      else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
	acl.a_perm |= DENY_W;
    }

  if ((win_ace_mask & FILE_EXEC_BITS) && !(acl.a_perm & (S_IXOTH | DENY_X)))
    {
      if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
	acl.a_perm |= S_IXOTH;
      else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
	acl.a_perm |= DENY_X;
    }
}

int
getacl (HANDLE handle, path_conv &pc, int nentries, aclent_t *aclbufp)
{
  security_descriptor sd;

  if (get_file_sd (handle, pc, sd, false))
    return -1;

  cygpsid owner_sid;
  cygpsid group_sid;
  NTSTATUS status;
  BOOLEAN dummy;
  uid_t uid;
  gid_t gid;
  cyg_ldap cldap;

  status = RtlGetOwnerSecurityDescriptor (sd, (PSID *) &owner_sid, &dummy);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  uid = owner_sid.get_uid (&cldap);

  status = RtlGetGroupSecurityDescriptor (sd, (PSID *) &group_sid, &dummy);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  gid = group_sid.get_gid (&cldap);

  aclent_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (aclent_t));
  lacl[0].a_type = USER_OBJ;
  lacl[0].a_id = uid;
  lacl[1].a_type = GROUP_OBJ;
  lacl[1].a_id = gid;
  lacl[2].a_type = OTHER_OBJ;
  lacl[2].a_id = ILLEGAL_GID;

  PACL acl;
  BOOLEAN acl_exists;

  status = RtlGetDaclSecurityDescriptor (sd, &acl_exists, &acl, &dummy);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }

  int pos, i, types_def = 0;
  int pgrp_pos = 1, def_pgrp_pos = -1;
  bool has_class_perm = false, has_def_class_perm = false;
  mode_t class_perm = 0, def_class_perm = 0;

  if (!acl_exists || !acl)
    for (pos = 0; pos < 3; ++pos)
      lacl[pos].a_perm = S_IROTH | S_IWOTH | S_IXOTH;
  else
    {
      for (i = 0; i < acl->AceCount; ++i)
	{
	  ACCESS_ALLOWED_ACE *ace;

	  if (!NT_SUCCESS (RtlGetAce (acl, i, (PVOID *) &ace)))
	    continue;

	  cygpsid ace_sid ((PSID) &ace->SidStart);
	  int id;
	  int type = 0;

	  if (ace_sid == well_known_null_sid)
	    {
	      /* Simply ignore. */
	      continue;
	    }
	  if (ace_sid == well_known_world_sid)
	    {
	      type = OTHER_OBJ;
	      id = ILLEGAL_GID;
	    }
	  else if (ace_sid == owner_sid)
	    {
	      type = USER_OBJ;
	      id = uid;
	    }
	  else if (ace_sid == group_sid)
	    {
	      type = GROUP_OBJ;
	      id = gid;
	    }
	  else if (ace_sid == well_known_creator_group_sid)
	    {
	      type = DEF_GROUP_OBJ;
	      types_def |= type;
	      id = ILLEGAL_GID;
	    }
	  else if (ace_sid == well_known_creator_owner_sid)
	    {
	      type = DEF_USER_OBJ;
	      types_def |= type;
	      id = ILLEGAL_GID;
	    }
	  else
	    id = ace_sid.get_id (TRUE, &type, &cldap);

	  if (!type)
	    continue;
	  if (!(ace->Header.AceFlags & INHERIT_ONLY_ACE || type & ACL_DEFAULT))
	    {
	      if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
		{
		  getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
		  /* Fix up CLASS_OBJ value. */
		  if (type == USER || type == GROUP)
		    {
		      has_class_perm = true;
		      class_perm |= lacl[pos].a_perm;
		    }
		}
	    }
	  if ((ace->Header.AceFlags
	      & (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE))
	      && pc.isdir ())
	    {
	      if (type == USER_OBJ)
		type = USER;
	      else if (type == GROUP_OBJ)
		type = GROUP;
	      type |= ACL_DEFAULT;
	      types_def |= type;
	      if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
		{
		  getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
		  /* Fix up DEF_CLASS_OBJ value. */
		  if (type == DEF_USER || type == DEF_GROUP)
		    {
		      has_def_class_perm = true;
		      def_class_perm |= lacl[pos].a_perm;
		    }
		  /* And note the position of the DEF_GROUP_OBJ entry. */
		  else if (type == DEF_GROUP_OBJ)
		    def_pgrp_pos = pos;
		}
	    }
	}
      /* If secondary user and group entries exist in the ACL, fake a matching
	 CLASS_OBJ entry. The CLASS_OBJ permissions are the or'ed permissions
	 of the primary group permissions and all secondary user and group
	 permissions. */
      if (has_class_perm && (pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) >= 0)
	{
	  lacl[pos].a_type = CLASS_OBJ;
	  lacl[pos].a_id = ILLEGAL_GID;
	  lacl[pos].a_perm = class_perm | lacl[pgrp_pos].a_perm;
	}
      /* Ensure that the default acl contains at least
      	 DEF_(USER|GROUP|OTHER)_OBJ entries.  */
      if (types_def && (pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) >= 0)
	{
	  if (!(types_def & USER_OBJ))
	    {
	      lacl[pos].a_type = DEF_USER_OBJ;
	      lacl[pos].a_id = uid;
	      lacl[pos].a_perm = lacl[0].a_perm;
	      pos++;
	    }
	  if (!(types_def & GROUP_OBJ) && pos < MAX_ACL_ENTRIES)
	    {
	      lacl[pos].a_type = DEF_GROUP_OBJ;
	      lacl[pos].a_id = gid;
	      lacl[pos].a_perm = lacl[1].a_perm;
	      /* Note the position of the DEF_GROUP_OBJ entry. */
	      def_pgrp_pos = pos;
	      pos++;
	    }
	  if (!(types_def & OTHER_OBJ) && pos < MAX_ACL_ENTRIES)
	    {
	      lacl[pos].a_type = DEF_OTHER_OBJ;
	      lacl[pos].a_id = ILLEGAL_GID;
	      lacl[pos].a_perm = lacl[2].a_perm;
	      pos++;
	    }
	}
      /* If secondary user default and group default entries exist in the ACL,
	 fake a matching DEF_CLASS_OBJ entry. The DEF_CLASS_OBJ permissions are
	 the or'ed permissions of the primary group default permissions and all
	 secondary user and group default permissions. */
      if (has_def_class_perm
	  && (pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) >= 0)
	{
	  lacl[pos].a_type = DEF_CLASS_OBJ;
	  lacl[pos].a_id = ILLEGAL_GID;
	  lacl[pos].a_perm = def_class_perm;
	  if (def_pgrp_pos >= 0)
	    lacl[pos].a_perm |= lacl[def_pgrp_pos].a_perm;
	}
    }
  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) < 0)
    pos = MAX_ACL_ENTRIES;
  if (aclbufp)
    {
#if 0
      /* Disable owner/group permissions equivalence if owner SID == group SID.
	 It's technically not quite correct, but it helps in case a security
	 conscious application checks if a file has too open permissions.  In
	 fact, since owner == group, there's no security issue here. */
      if (owner_sid == group_sid)
	lacl[1].a_perm = lacl[0].a_perm;
#endif
      if (pos > nentries)
	{
	  set_errno (ENOSPC);
	  return -1;
	}
      memcpy (aclbufp, lacl, pos * sizeof (aclent_t));
      for (i = 0; i < pos; ++i)
	aclbufp[i].a_perm &= ~(DENY_R | DENY_W | DENY_X);
      aclsort32 (pos, 0, aclbufp);
    }
  syscall_printf ("%R = getacl(%S)", pos, pc.get_nt_native_path ());
  return pos;
}

extern "C" int
acl32 (const char *path, int cmd, int nentries, aclent_t *aclbufp)
{
  int res = -1;

  fhandler_base *fh = build_fh_name (path, PC_SYM_FOLLOW | PC_KEEP_HANDLE,
				     stat_suffixes);
  if (!fh || !fh->exists ())
    set_errno (ENOENT);
  else if (fh->error ())
    {
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
    }
  else
    res = fh->facl (cmd, nentries, aclbufp);

  delete fh;
  syscall_printf ("%R = acl(%s)", res, path);
  return res;
}

#ifndef __x86_64__
extern "C" int
lacl32 (const char *path, int cmd, int nentries, aclent_t *aclbufp)
{
  /* This call was an accident.  Make it absolutely clear. */
  set_errno (ENOSYS);
  return -1;
}
#endif

extern "C" int
facl32 (int fd, int cmd, int nentries, aclent_t *aclbufp)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    {
      syscall_printf ("-1 = facl (%d)", fd);
      return -1;
    }
  int res = cfd->facl (cmd, nentries, aclbufp);
  syscall_printf ("%R = facl(%s) )", res, cfd->get_name ());
  return res;
}

extern "C" int
aclcheck32 (aclent_t *aclbufp, int nentries, int *which)
{
  bool has_user_obj = false;
  bool has_group_obj = false;
  bool has_other_obj = false;
  bool has_class_obj = false;
  bool has_ug_objs __attribute__ ((unused)) = false;
  bool has_def_objs __attribute__ ((unused)) = false;
  bool has_def_user_obj __attribute__ ((unused)) = false;
  bool has_def_group_obj = false;
  bool has_def_other_obj = false;
  bool has_def_class_obj = false;
  bool has_def_ug_objs __attribute__ ((unused)) = false;
  int pos2;

  for (int pos = 0; pos < nentries; ++pos)
    switch (aclbufp[pos].a_type)
      {
      case USER_OBJ:
	if (has_user_obj)
	  {
	    if (which)
	      *which = pos;
	    return USER_ERROR;
	  }
	has_user_obj = true;
	break;
      case GROUP_OBJ:
	if (has_group_obj)
	  {
	    if (which)
	      *which = pos;
	    return GRP_ERROR;
	  }
	has_group_obj = true;
	break;
      case OTHER_OBJ:
	if (has_other_obj)
	  {
	    if (which)
	      *which = pos;
	    return OTHER_ERROR;
	  }
	has_other_obj = true;
	break;
      case CLASS_OBJ:
	if (has_class_obj)
	  {
	    if (which)
	      *which = pos;
	    return CLASS_ERROR;
	  }
	has_class_obj = true;
	break;
      case USER:
      case GROUP:
	if ((pos2 = searchace (aclbufp + pos + 1, nentries - pos - 1,
			       aclbufp[pos].a_type, aclbufp[pos].a_id)) >= 0)
	  {
	    if (which)
	      *which = pos2;
	    return DUPLICATE_ERROR;
	  }
	has_ug_objs = true;
	break;
      case DEF_USER_OBJ:
	if (has_def_user_obj)
	  {
	    if (which)
	      *which = pos;
	    return USER_ERROR;
	  }
	has_def_objs = has_def_user_obj = true;
	break;
      case DEF_GROUP_OBJ:
	if (has_def_group_obj)
	  {
	    if (which)
	      *which = pos;
	    return GRP_ERROR;
	  }
	has_def_objs = has_def_group_obj = true;
	break;
      case DEF_OTHER_OBJ:
	if (has_def_other_obj)
	  {
	    if (which)
	      *which = pos;
	    return OTHER_ERROR;
	  }
	has_def_objs = has_def_other_obj = true;
	break;
      case DEF_CLASS_OBJ:
	if (has_def_class_obj)
	  {
	    if (which)
	      *which = pos;
	    return CLASS_ERROR;
	  }
	has_def_objs = has_def_class_obj = true;
	break;
      case DEF_USER:
      case DEF_GROUP:
	if ((pos2 = searchace (aclbufp + pos + 1, nentries - pos - 1,
			       aclbufp[pos].a_type, aclbufp[pos].a_id)) >= 0)
	  {
	    if (which)
	      *which = pos2;
	    return DUPLICATE_ERROR;
	  }
	has_def_objs = has_def_ug_objs = true;
	break;
      default:
	return ENTRY_ERROR;
      }
  if (!has_user_obj
      || !has_group_obj
      || !has_other_obj
      || (has_def_objs
	  && (!has_def_user_obj || !has_def_group_obj || !has_def_other_obj))
      || (has_ug_objs && !has_class_obj)
      || (has_def_ug_objs && !has_def_class_obj)
     )
    {
      if (which)
	*which = -1;
      return MISS_ERROR;
    }
  return 0;
}

static int
acecmp (const void *a1, const void *a2)
{
#define ace(i) ((const aclent_t *) a##i)
  int ret = ace (1)->a_type - ace (2)->a_type;
  if (!ret)
    ret = ace (1)->a_id - ace (2)->a_id;
  return ret;
#undef ace
}

extern "C" int
aclsort32 (int nentries, int, aclent_t *aclbufp)
{
  if (aclcheck32 (aclbufp, nentries, NULL))
    {
      set_errno (EINVAL);
      return -1;
    }
  if (!aclbufp || nentries < 1)
    {
      set_errno (EINVAL);
      return -1;
    }
  qsort ((void *) aclbufp, nentries, sizeof (aclent_t), acecmp);
  return 0;
}

extern "C" int
acltomode32 (aclent_t *aclbufp, int nentries, mode_t *modep)
{
  int pos;

  if (!aclbufp || nentries < 1 || !modep)
    {
      set_errno (EINVAL);
      return -1;
    }
  *modep = 0;
  if ((pos = searchace (aclbufp, nentries, USER_OBJ)) < 0
      || !aclbufp[pos].a_type)
    {
      set_errno (EINVAL);
      return -1;
    }
  *modep |= (aclbufp[pos].a_perm & S_IRWXO) << 6;
  if ((pos = searchace (aclbufp, nentries, GROUP_OBJ)) < 0
      || !aclbufp[pos].a_type)
    {
      set_errno (EINVAL);
      return -1;
    }
  *modep |= (aclbufp[pos].a_perm & S_IRWXO) << 3;
  int cpos;
  if ((cpos = searchace (aclbufp, nentries, CLASS_OBJ)) >= 0
      && aclbufp[cpos].a_type == CLASS_OBJ)
    *modep |= ((aclbufp[pos].a_perm & S_IRWXO) & aclbufp[cpos].a_perm) << 3;
  if ((pos = searchace (aclbufp, nentries, OTHER_OBJ)) < 0
      || !aclbufp[pos].a_type)
    {
      set_errno (EINVAL);
      return -1;
    }
  *modep |= aclbufp[pos].a_perm & S_IRWXO;
  return 0;
}

extern "C" int
aclfrommode32 (aclent_t *aclbufp, int nentries, mode_t *modep)
{
  int pos;

  if (!aclbufp || nentries < 1 || !modep)
    {
      set_errno (EINVAL);
      return -1;
    }
  if ((pos = searchace (aclbufp, nentries, USER_OBJ)) < 0
      || !aclbufp[pos].a_type)
    {
      set_errno (EINVAL);
      return -1;
    }
  aclbufp[pos].a_perm = (*modep & S_IRWXU) >> 6;
  if ((pos = searchace (aclbufp, nentries, GROUP_OBJ)) < 0
      || !aclbufp[pos].a_type)
    {
      set_errno (EINVAL);
      return -1;
    }
  aclbufp[pos].a_perm = (*modep & S_IRWXG) >> 3;
  if ((pos = searchace (aclbufp, nentries, CLASS_OBJ)) >= 0
      && aclbufp[pos].a_type == CLASS_OBJ)
    aclbufp[pos].a_perm = (*modep & S_IRWXG) >> 3;
  if ((pos = searchace (aclbufp, nentries, OTHER_OBJ)) < 0
      || !aclbufp[pos].a_type)
    {
      set_errno (EINVAL);
      return -1;
    }
  aclbufp[pos].a_perm = (*modep & S_IRWXO);
  return 0;
}

extern "C" int
acltopbits32 (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return acltomode32 (aclbufp, nentries, pbitsp);
}

extern "C" int
aclfrompbits32 (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return aclfrommode32 (aclbufp, nentries, pbitsp);
}

static char *
permtostr (mode_t perm)
{
  static char pbuf[4];

  pbuf[0] = (perm & S_IROTH) ? 'r' : '-';
  pbuf[1] = (perm & S_IWOTH) ? 'w' : '-';
  pbuf[2] = (perm & S_IXOTH) ? 'x' : '-';
  pbuf[3] = '\0';
  return pbuf;
}

extern "C" char *
acltotext32 (aclent_t *aclbufp, int aclcnt)
{
  if (!aclbufp || aclcnt < 1 || aclcnt > MAX_ACL_ENTRIES
      || aclcheck32 (aclbufp, aclcnt, NULL))
    {
      set_errno (EINVAL);
      return NULL;
    }
  char buf[32000];
  buf[0] = '\0';
  bool first = true;

  for (int pos = 0; pos < aclcnt; ++pos)
    {
      if (!first)
	strcat (buf, ",");
      first = false;
      if (aclbufp[pos].a_type & ACL_DEFAULT)
	strcat (buf, "default");
      switch (aclbufp[pos].a_type & ~ACL_DEFAULT)
	{
	case USER_OBJ:
	  __small_sprintf (buf + strlen (buf), "user::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	case USER:
	  __small_sprintf (buf + strlen (buf), "user:%d:%s",
		   aclbufp[pos].a_id, permtostr (aclbufp[pos].a_perm));
	  break;
	case GROUP_OBJ:
	  __small_sprintf (buf + strlen (buf), "group::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	case GROUP:
	  __small_sprintf (buf + strlen (buf), "group:%d:%s",
		   aclbufp[pos].a_id, permtostr (aclbufp[pos].a_perm));
	  break;
	case CLASS_OBJ:
	  __small_sprintf (buf + strlen (buf), "mask::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	case OTHER_OBJ:
	  __small_sprintf (buf + strlen (buf), "other::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	default:
	  set_errno (EINVAL);
	  return NULL;
	}
    }
  return strdup (buf);
}

static mode_t
permfromstr (char *perm)
{
  mode_t mode = 0;

  if (strlen (perm) != 3)
    return 01000;
  if (perm[0] == 'r')
    mode |= S_IROTH;
  else if (perm[0] != '-')
    return 01000;
  if (perm[1] == 'w')
    mode |= S_IWOTH;
  else if (perm[1] != '-')
    return 01000;
  if (perm[2] == 'x')
    mode |= S_IXOTH;
  else if (perm[2] != '-')
    return 01000;
  return mode;
}

extern "C" aclent_t *
aclfromtext32 (char *acltextp, int *)
{
  if (!acltextp)
    {
      set_errno (EINVAL);
      return NULL;
    }
  char buf[strlen (acltextp) + 1];
  aclent_t lacl[MAX_ACL_ENTRIES];
  memset (lacl, 0, sizeof lacl);
  int pos = 0;
  strcpy (buf, acltextp);
  char *lasts;
  cyg_ldap cldap;
  for (char *c = strtok_r (buf, ",", &lasts);
       c;
       c = strtok_r (NULL, ",", &lasts))
    {
      if (!strncmp (c, "default", 7))
	{
	  lacl[pos].a_type |= ACL_DEFAULT;
	  c += 7;
	}
      if (!strncmp (c, "user:", 5))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= USER_OBJ;
	  else
	    {
	      lacl[pos].a_type |= USER;
	      c += 5;
	      if (isalpha (*c))
		{
		  struct passwd *pw = internal_getpwnam (c, &cldap);
		  if (!pw)
		    {
		      set_errno (EINVAL);
		      return NULL;
		    }
		  lacl[pos].a_id = pw->pw_uid;
		  c = strchrnul (c, ':');
		}
	      else if (isdigit (*c))
		lacl[pos].a_id = strtol (c, &c, 10);
	      if (*c != ':')
		{
		  set_errno (EINVAL);
		  return NULL;
		}
	    }
	}
      else if (!strncmp (c, "group:", 6))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= GROUP_OBJ;
	  else
	    {
	      lacl[pos].a_type |= GROUP;
	      c += 5;
	      if (isalpha (*c))
		{
		  struct group *gr = internal_getgrnam (c, &cldap);
		  if (!gr)
		    {
		      set_errno (EINVAL);
		      return NULL;
		    }
		  lacl[pos].a_id = gr->gr_gid;
		  c = strchrnul (c, ':');
		}
	      else if (isdigit (*c))
		lacl[pos].a_id = strtol (c, &c, 10);
	      if (*c != ':')
		{
		  set_errno (EINVAL);
		  return NULL;
		}
	    }
	}
      else if (!strncmp (c, "mask:", 5))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= CLASS_OBJ;
	  else
	    {
	      set_errno (EINVAL);
	      return NULL;
	    }
	}
      else if (!strncmp (c, "other:", 6))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= OTHER_OBJ;
	  else
	    {
	      set_errno (EINVAL);
	      return NULL;
	    }
	}
      if ((lacl[pos].a_perm = permfromstr (c)) == 01000)
	{
	  set_errno (EINVAL);
	  return NULL;
	}
      ++pos;
    }
  aclent_t *aclp = (aclent_t *) malloc (pos * sizeof (aclent_t));
  if (aclp)
    memcpy (aclp, lacl, pos * sizeof (aclent_t));
  return aclp;
}

#ifdef __x86_64__
EXPORT_ALIAS (acl32, acl)
EXPORT_ALIAS (facl32, facl)
EXPORT_ALIAS (aclcheck32, aclcheck)
EXPORT_ALIAS (aclsort32, aclsort)
EXPORT_ALIAS (acltomode32, acltomode)
EXPORT_ALIAS (aclfrommode32, aclfrommode)
EXPORT_ALIAS (acltopbits32, acltopbits)
EXPORT_ALIAS (aclfrompbits32, aclfrompbits)
EXPORT_ALIAS (acltotext32, acltotext)
EXPORT_ALIAS (aclfromtext32, aclfromtext)
#else
/* __aclent16_t and aclent_t have same size and same member offsets */
static aclent_t *
acl16to32 (__aclent16_t *aclbufp, int nentries)
{
  aclent_t *aclbufp32 = (aclent_t *) aclbufp;
  if (aclbufp32)
    for (int i = 0; i < nentries; i++)
      aclbufp32[i].a_id &= USHRT_MAX;
  return aclbufp32;
}

extern "C" int
acl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
{
  return acl32 (path, cmd, nentries, acl16to32 (aclbufp, nentries));
}

extern "C" int
facl (int fd, int cmd, int nentries, __aclent16_t *aclbufp)
{
  return facl32 (fd, cmd, nentries, acl16to32 (aclbufp, nentries));
}

extern "C" int
lacl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
{
  /* This call was an accident.  Make it absolutely clear. */
  set_errno (ENOSYS);
  return -1;
}

extern "C" int
aclcheck (__aclent16_t *aclbufp, int nentries, int *which)
{
  return aclcheck32 (acl16to32 (aclbufp, nentries), nentries, which);
}

extern "C" int
aclsort (int nentries, int i, __aclent16_t *aclbufp)
{
  return aclsort32 (nentries, i, acl16to32 (aclbufp, nentries));
}


extern "C" int
acltomode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
{
  return acltomode32 (acl16to32 (aclbufp, nentries), nentries, modep);
}

extern "C" int
aclfrommode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
{
  return aclfrommode32 ((aclent_t *)aclbufp, nentries, modep);
}

extern "C" int
acltopbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return acltopbits32 (acl16to32 (aclbufp, nentries), nentries, pbitsp);
}

extern "C" int
aclfrompbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return aclfrompbits32 ((aclent_t *)aclbufp, nentries, pbitsp);
}

extern "C" char *
acltotext (__aclent16_t *aclbufp, int aclcnt)
{
  return acltotext32 (acl16to32 (aclbufp, aclcnt), aclcnt);
}

extern "C" __aclent16_t *
aclfromtext (char *acltextp, int * aclcnt)
{
  return (__aclent16_t *) aclfromtext32 (acltextp, aclcnt);
}
#endif /* !__x86_64__ */
@


1.85
log
@	* sec_acl.cc (setacl): Fix bug which leads to ACE duplication in
	case owner SID == group SID.
	(getacl): Reverse order of SID test against group or owner sid to
	prefer owner attributes over group attributes.  Disable setting group
	permissions equivalent to owner permissions if owner == group.  Add
	comment to explain why.  Fix indentation.
	* security.cc (get_attribute_from_acl): Change type of local variables
	containing permission to mode_t.  Apply deny mask to group if group SID
	== owner SID to avoid Everyone permissions to spill over into group
	permissions.  Disable setting group permissions equivalent to owner
	permissions if owner == group.  Add comment to explain why.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Allow user SID as
	group account if user is a "Microsoft Account".  Explain why.  Drop
	workaround enforcing primary group "Users" for "Microsoft Accounts".
@
text
@d426 1
d489 4
a492 1
		    class_perm |= lacl[pos].a_perm;
d510 4
a513 1
		    def_class_perm |= lacl[pos].a_perm;
d524 1
a524 1
      if (class_perm && (pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) >= 0)
d562 2
a563 1
      if (def_class_perm && (pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) >= 0)
@


1.84
log
@	* sec_acl.cc (setacl): Always grant default owner entry
	STANDARD_RIGHTS_ALL and FILE_WRITE_ATTRIBUTES access, too.
@
text
@d172 1
a172 1
  bool isownergroup = (owner_sid == group_sid);
d182 1
a182 1
				 owner_sid, acl_len, NO_INHERITANCE))
d188 1
a188 1
				 group_sid, acl_len, NO_INHERITANCE))
d192 1
a192 1
			       owner_sid, acl_len, NO_INHERITANCE))
d197 1
a197 1
				 group_sid, acl_len, NO_INHERITANCE))
d202 1
a202 1
                                  group_sid, acl_len, NO_INHERITANCE))
d454 5
a463 5
	  else if (ace_sid == owner_sid)
	    {
	      type = USER_OBJ;
	      id = uid;
	    }
d566 20
a585 13
  if (aclbufp) {
    if (owner_sid == group_sid)
      lacl[0].a_perm = lacl[1].a_perm;
    if (pos > nentries)
      {
	set_errno (ENOSPC);
	return -1;
      }
    memcpy (aclbufp, lacl, pos * sizeof (aclent_t));
    for (i = 0; i < pos; ++i)
      aclbufp[i].a_perm &= ~(DENY_R | DENY_W | DENY_X);
    aclsort32 (pos, 0, aclbufp);
  }
@


1.83
log
@	* sec_acl.cc (setacl): Always grant owner FILE_WRITE_ATTRIBUTES access.
@
text
@d261 2
@


1.82
log
@	* sec_acl.cc (setacl): Introduce bool array "invalid" to note the
	invalidation of incoming acl entries while iterating over them.
@
text
@d4 1
a4 1
   2011, 2012, 2014 Red Hat, Inc.
d141 2
a142 1
	  *allow = STANDARD_RIGHTS_ALL;
@


1.81
log
@	* sec_acl.cc (aclcheck32): Check for required default entries as well.
	Enable check for missing CLASS_OBJ entries, now that setfacl creates
	them.
@
text
@d128 3
d169 1
a169 1
      aclbufp[i].a_type = 0;
d216 1
a216 1
      if (!aclbufp[i].a_type)
d255 1
a255 1
	  aclbufp[i + 1 + pos].a_type = 0;
@


1.80
log
@	* sec_acl.cc (aclsort32): Set errno to EINVAL if aclcheck32 failed.
@
text
@d631 1
d696 1
a696 1
	has_def_user_obj = true;
d705 1
a705 1
	has_def_group_obj = true;
d714 1
a714 1
	has_def_other_obj = true;
d723 1
a723 1
	has_def_class_obj = true;
d734 1
a734 1
	has_def_ug_objs = true;
d742 2
a743 2
#if 0
      /* These checks are not ok yet since CLASS_OBJ isn't fully implemented. */
a745 1
#endif
@


1.79
log
@	* sec_acl.cc (setacl): Add comment.  Handle NULL ACE for SUID, SGID,
	and VTX bits.  Create owner, group, other and NULL entries in the same
	way and in the same order as alloc_sd.
	(getacl): Skip NULL ACE.
@
text
@d770 4
a773 1
    return -1;
@


1.78
log
@	* fhandler.cc (fhandler_base::facl): Drop CLASS_OBJ entry.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Ditto in noacl case.
	* sec_acl.cc (getacl): Compute useful fake CLASS_OBJ and DEF_CLASS_OBJ
	permission bits based on how these values are generated on Linux.
	Add commants to explain what the code is doing.
	* security.cc (get_attribute_from_acl): Compute group permission based
	on the actual primary group permissions and all secondary user and group
	ACCESS_ALLOWED_ACEs to emulate Linux' behaviour more closely.
	(check_access): Fix typos im comment.
	* include/cygwin/acl.h (MIN_ACL_ENTRIES): Redefine as 3.
@
text
@d39 1
d51 2
a52 1
  BOOLEAN dummy;
d74 18
d95 5
d114 1
a114 1
  PACL acl = (PACL) tp.w_get ();
d128 81
d212 6
a217 8
      /* Owner has more standard rights set. */
      if ((aclbufp[i].a_type & ~ACL_DEFAULT) == USER_OBJ)
	allow = STANDARD_RIGHTS_ALL
		| (pc.fs_is_samba ()
		   ? 0 : (FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES));
      else
	allow = STANDARD_RIGHTS_READ
		| (pc.fs_is_samba () ? 0 : FILE_READ_ATTRIBUTES);
d227 4
a230 1
      if ((aclbufp[i].a_perm & (S_IWOTH | S_IXOTH)) == (S_IWOTH | S_IXOTH))
d243 1
a243 1
	  && aclbufp[i].a_type & (USER|GROUP|OTHER_OBJ)
d251 2
a252 2
	  /* This invalidates the corresponding default entry. */
	  aclbufp[i + 1 + pos].a_type = USER|GROUP|ACL_DEFAULT;
a255 5
	case USER_OBJ:
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
					owner, acl_len, inheritance))
	    return -1;
	  break;
a272 5
	case GROUP_OBJ:
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
				       group, acl_len, inheritance))
	    return -1;
	  break;
a289 1
	case OTHER_OBJ:
a294 1
	  break;
d438 5
@


1.77
log
@	* autoload.cc (CheckTokenMembership): Import.
	* external.cc (cygwin_internal): Call get_uid/get_gid instead of get_id.
	* grp.cc (internal_getgrsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_group_from_windows.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_local): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(getgroups32): Rename from internal_getgroups and drop getgroups32 stub.
	Drop srchsid parameter and code handling it.  Add local cyg_ldap
	instance and forward to internal_getgrXXX.
	(getgroups): Call getgroups32.
	(get_groups): Add local cyg_ldap instance and forward to
	internal_getgrXXX.
	(getgrouplist): Ditto.
	(setgroups32): Ditto.
	* ldap.cc (cyg_ldap::open): Don't call close.  Return true if connection
	is already open.
	(cyg_ldap::remap_uid): Forward this to internal_getpwsid.
	(cyg_ldap::remap_gid): Forward this to internal_getgrsid.
	* passwd.cc (internal_getpwsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_user_from_windows.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pg_ent::enumerate_builtin): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.  Forward local cldap instead.
	* pwdgrp.h (internal_getpwsid): Align declaration to above change.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(internal_getgrsid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgroups): Drop declaration.
	(pwdgrp::add_account_from_windows): Align declaration to below change.
	(pwdgrp::add_user_from_windows): Ditto.
	(pwdgrp::add_group_from_windows): Ditto.
	* sec_acl.cc (setacl): Add local cyg_ldap instance and forward to
	internal_getpwuid and internal_getgrgid.
	(getacl): Add local cyg_ldap instance and forward to cygpsid::get_id.
	(aclfromtext32): Add local cyg_ldap instance and forward to
	internal_getpwnam and internal_getgrnam.
	* sec_helper.cc (cygpsid::get_id): Take additional cyg_ldap pointer.
	Forward to internal_getgrsid and internal_getpwsid.
	(get_sids_info): Drop ldap_open.  Forward local cldap to
	internal_getpwsid and internal_getgrXXX.  Call CheckTokenMembership
	rather than internal_getgroups.
	* security.h (cygpsid::get_id): Add cyg_ldap pointer, drop default
	parameter.
	(cygpsid::get_uid): Add cyg_ldap pointer.  Call get_id accordingly.
	(cygpsid::get_gid): Ditto.
	* uinfo.cc (internal_getlogin): Add local cyg_ldap instance and forward
	to internal_getpwXXX and internal_getgrXXX calls.
	(pwdgrp::add_account_from_windows): Take additional cyg_ldap pointer.
	Forward to pwdgrp::fetch_account_from_windows.
	(fetch_posix_offset): Drop ldap_open argument and handling.  Get
	cyg_ldap instance as pointer.
	(pwdgrp::fetch_account_from_windows): Take additional cyg_ldap pointer.
	Use it if it's not NULL, local instance otherwise.  Drop ldap_open.
	Drop fetching extended group arguments from AD for speed.
@
text
@a311 3
  lacl[3].a_type = CLASS_OBJ;
  lacl[3].a_id = ILLEGAL_GID;
  lacl[3].a_perm = S_IROTH | S_IWOTH | S_IXOTH;
d324 2
d328 1
a328 1
    for (pos = 0; pos < 3; ++pos) /* Don't change CLASS_OBJ entry */
d360 1
a360 1
	      type = GROUP_OBJ | ACL_DEFAULT;
d366 1
a366 1
	      type = USER_OBJ | ACL_DEFAULT;
d378 6
a383 1
		getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
d396 9
a404 1
		getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
d407 12
a420 2
	  /* Ensure that the default acl contains at
	     least DEF_(USER|GROUP|OTHER)_OBJ entries.  */
d433 2
d444 12
a455 7
	  /* Include DEF_CLASS_OBJ if any named default ace exists.  */
	  if ((types_def & (USER|GROUP)) && pos < MAX_ACL_ENTRIES)
	    {
	      lacl[pos].a_type = DEF_CLASS_OBJ;
	      lacl[pos].a_id = ILLEGAL_GID;
	      lacl[pos].a_perm = S_IROTH | S_IWOTH | S_IXOTH;
	    }
@


1.76
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d97 1
d161 1
a161 1
	  if (!(pw = internal_getpwuid (aclbufp[i].a_id))
d183 1
a183 1
	  if (!(gr = internal_getgrgid (aclbufp[i].a_id))
d286 1
d294 1
a294 1
  uid = owner_sid.get_uid ();
d302 1
a302 1
  gid = group_sid.get_gid ();
d372 1
a372 1
	    id = ace_sid.get_id (true, &type);
d841 1
d861 1
a861 1
		  struct passwd *pw = internal_getpwnam (c);
d889 1
a889 1
		  struct group *gr = internal_getgrnam (c);
@


1.75
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2011, 2012 Red Hat, Inc.
a24 1
#include "pwdgrp.h"
@


1.74
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d29 1
a29 1
searchace (__aclent32_t *aclp, int nentries, int type, __uid32_t id = ILLEGAL_UID)
d41 1
a41 1
setacl (HANDLE handle, path_conv &pc, int nentries, __aclent32_t *aclbufp,
d96 1
a96 1
  struct __group32 *gr;
d204 1
a204 1
  debug_printf ("ACL-Size: %d", acl_len);
d231 1
a231 1
  debug_printf ("Created SD-Size: %d", sd_ret.size ());
d241 1
a241 1
getace (__aclent32_t &acl, int type, int id, DWORD win_ace_mask,
d273 1
a273 1
getacl (HANDLE handle, path_conv &pc, int nentries, __aclent32_t *aclbufp)
d284 2
a285 2
  __uid32_t uid;
  __gid32_t gid;
d303 2
a304 2
  __aclent32_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (__aclent32_t));
d438 1
a438 1
    memcpy (aclbufp, lacl, pos * sizeof (__aclent32_t));
d448 1
a448 1
acl32 (const char *path, int cmd, int nentries, __aclent32_t *aclbufp)
d469 1
d471 1
a471 1
lacl32 (const char *path, int cmd, int nentries, __aclent32_t *aclbufp)
d477 1
d480 1
a480 1
facl32 (int fd, int cmd, int nentries, __aclent32_t *aclbufp)
d494 1
a494 1
aclcheck32 (__aclent32_t *aclbufp, int nentries, int *which)
d500 2
a501 2
  bool has_ug_objs = false;
  bool has_def_user_obj = false;
d505 1
a505 1
  bool has_def_ug_objs = false;
d628 1
a628 1
#define ace(i) ((const __aclent32_t *) a##i)
d637 1
a637 1
aclsort32 (int nentries, int, __aclent32_t *aclbufp)
d646 1
a646 1
  qsort ((void *) aclbufp, nentries, sizeof (__aclent32_t), acecmp);
d651 1
a651 1
acltomode32 (__aclent32_t *aclbufp, int nentries, mode_t *modep)
d690 1
a690 1
aclfrommode32 (__aclent32_t *aclbufp, int nentries, mode_t *modep)
d727 1
a727 1
acltopbits32 (__aclent32_t *aclbufp, int nentries, mode_t *pbitsp)
d733 1
a733 1
aclfrompbits32 (__aclent32_t *aclbufp, int nentries, mode_t *pbitsp)
d751 1
a751 1
acltotext32 (__aclent32_t *aclbufp, int aclcnt)
d826 1
a826 1
extern "C" __aclent32_t *
d835 1
a835 1
  __aclent32_t lacl[MAX_ACL_ENTRIES];
d887 1
a887 1
		  struct __group32 *gr = internal_getgrnam (c);
d932 1
a932 1
  __aclent32_t *aclp = (__aclent32_t *) malloc (pos * sizeof (__aclent32_t));
d934 1
a934 1
    memcpy (aclp, lacl, pos * sizeof (__aclent32_t));
d938 14
a951 2
/* __aclent16_t and __aclent32_t have same size and same member offsets */
static __aclent32_t *
d954 1
a954 1
  __aclent32_t *aclbufp32 = (__aclent32_t *) aclbufp;
d1003 1
a1003 1
  return aclfrommode32 ((__aclent32_t *)aclbufp, nentries, modep);
d1015 1
a1015 1
  return aclfrompbits32 ((__aclent32_t *)aclbufp, nentries, pbitsp);
d1029 1
@


1.73
log
@        * dcrt0.cc (quoted): Renamed strechr to strchrnul.
        * environ.cc (environ_init): Likewise.
        * sec_acl.cc (aclfromtext32): Likewise.
        * sec_auth.cc (extract_nt_dom_user): Likewise.
        * uinfo.cc (pwdgrp::next_str): Likewise.
        * string.h (strechr): Likewise.
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.72
log
@	* sec_acl.cc (acl32): Fix potnetial crash if build_fh_name returns NULL.
@
text
@d864 1
a864 1
		  c = strechr (c, ':');
d892 1
a892 1
		  c = strechr (c, ':');
@


1.72.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d29 1
a29 1
searchace (__aclent32_t *aclp, int nentries, int type, uid_t id = ILLEGAL_UID)
d96 1
a96 1
  struct group *gr;
d284 2
a285 2
  uid_t uid;
  gid_t gid;
d885 1
a885 1
		  struct group *gr = internal_getgrnam (c);
@


1.72.2.2
log
@        * dcrt0.cc (quoted): Renamed strechr to strchrnul.
        * environ.cc (environ_init): Likewise.
        * sec_acl.cc (aclfromtext32): Likewise.
        * sec_auth.cc (extract_nt_dom_user): Likewise.
        * uinfo.cc (pwdgrp::next_str): Likewise.
        * string.h (strechr): Likewise.
@
text
@d864 1
a864 1
		  c = strchrnul (c, ':');
d892 1
a892 1
		  c = strchrnul (c, ':');
@


1.72.2.3
log
@	* include/cygwin/acl.h (struct __acl32): Drop.  Use struct acl or
	aclent_t throughout instead.
	* sec_acl.cc (aclcheck32): Mark currently unused variables as unused.
	(lacl32): Disable on x86_64.
	(acl): Alias to acl32 on x86_64.
	(facl): Alias to facl32 on x86_64.
	(aclcheck): Alias to aclcheck32 on x86_64.
	(aclsort): Alias to aclsort32 on x86_64.
	(acltomode): Alias to acltomode32 on x86_64.
	(aclfrommode): Alias to aclfrommode32 on x86_64.
	(acltopbits): Alias to acltopbits32 on x86_64.
	(aclfrompbits): Alias to aclfrompbits32 on x86_64.
	(acltotext): Alias to acltotext32 on x86_64.
	(aclfromtext): Alias to aclfromtext32 on x86_64.
	* resource.cc (getrlimit): Use correct cast to rlim_t rather than DWORD.
	* sched.cc (sched_setparam): Drop ThreadPriority and all code setting
	it.
@
text
@d29 1
a29 1
searchace (aclent_t *aclp, int nentries, int type, uid_t id = ILLEGAL_UID)
d41 1
a41 1
setacl (HANDLE handle, path_conv &pc, int nentries, aclent_t *aclbufp,
d241 1
a241 1
getace (aclent_t &acl, int type, int id, DWORD win_ace_mask,
d273 1
a273 1
getacl (HANDLE handle, path_conv &pc, int nentries, aclent_t *aclbufp)
d303 2
a304 2
  aclent_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (aclent_t));
d438 1
a438 1
    memcpy (aclbufp, lacl, pos * sizeof (aclent_t));
d448 1
a448 1
acl32 (const char *path, int cmd, int nentries, aclent_t *aclbufp)
a468 1
#ifndef __x86_64__
d470 1
a470 1
lacl32 (const char *path, int cmd, int nentries, aclent_t *aclbufp)
a475 1
#endif
d478 1
a478 1
facl32 (int fd, int cmd, int nentries, aclent_t *aclbufp)
d492 1
a492 1
aclcheck32 (aclent_t *aclbufp, int nentries, int *which)
d498 2
a499 2
  bool has_ug_objs __attribute__ ((unused)) = false;
  bool has_def_user_obj __attribute__ ((unused)) = false;
d503 1
a503 1
  bool has_def_ug_objs __attribute__ ((unused)) = false;
d626 1
a626 1
#define ace(i) ((const aclent_t *) a##i)
d635 1
a635 1
aclsort32 (int nentries, int, aclent_t *aclbufp)
d644 1
a644 1
  qsort ((void *) aclbufp, nentries, sizeof (aclent_t), acecmp);
d649 1
a649 1
acltomode32 (aclent_t *aclbufp, int nentries, mode_t *modep)
d688 1
a688 1
aclfrommode32 (aclent_t *aclbufp, int nentries, mode_t *modep)
d725 1
a725 1
acltopbits32 (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
d731 1
a731 1
aclfrompbits32 (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
d749 1
a749 1
acltotext32 (aclent_t *aclbufp, int aclcnt)
d824 1
a824 1
extern "C" aclent_t *
d833 1
a833 1
  aclent_t lacl[MAX_ACL_ENTRIES];
d930 1
a930 1
  aclent_t *aclp = (aclent_t *) malloc (pos * sizeof (aclent_t));
d932 1
a932 1
    memcpy (aclp, lacl, pos * sizeof (aclent_t));
d936 2
a937 14
#ifdef __x86_64__
EXPORT_ALIAS (acl32, acl)
EXPORT_ALIAS (facl32, facl)
EXPORT_ALIAS (aclcheck32, aclcheck)
EXPORT_ALIAS (aclsort32, aclsort)
EXPORT_ALIAS (acltomode32, acltomode)
EXPORT_ALIAS (aclfrommode32, aclfrommode)
EXPORT_ALIAS (acltopbits32, acltopbits)
EXPORT_ALIAS (aclfrompbits32, aclfrompbits)
EXPORT_ALIAS (acltotext32, acltotext)
EXPORT_ALIAS (aclfromtext32, aclfromtext)
#else
/* __aclent16_t and aclent_t have same size and same member offsets */
static aclent_t *
d940 1
a940 1
  aclent_t *aclbufp32 = (aclent_t *) aclbufp;
d989 1
a989 1
  return aclfrommode32 ((aclent_t *)aclbufp, nentries, modep);
d1001 1
a1001 1
  return aclfrompbits32 ((aclent_t *)aclbufp, nentries, pbitsp);
a1014 1
#endif /* !__x86_64__ */
@


1.72.2.4
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d204 1
a204 1
  debug_printf ("ACL-Size: %u", acl_len);
d231 1
a231 1
  debug_printf ("Created SD-Size: %u", sd_ret.size ());
@


1.72.2.5
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012 Red Hat, Inc.
@


1.71
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d4 1
a4 1
   2009, 2010, 2011 Red Hat, Inc.
d454 3
a456 1
  if (fh->error ())
a460 2
  else if (!fh->exists ())
    set_errno (ENOENT);
@


1.70
log
@	* advapi32.cc: Add comment.
	(EqualSid): Remove.
	(CopySid): Remove.
	(AddAccessAllowedAce): Remove.
	(AddAccessDeniedAce): Remove.
	(MakeSelfRelativeSD): Remove.
	* flock.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
	* security.h: Ditto.
	(RtlEqualSid): Declare.  Explain why.
	(RtlCopySid): Ditto.
@
text
@d443 1
a443 1
  syscall_printf ("%d = getacl (%S)", pos, pc.get_nt_native_path ());
d465 1
a465 1
  syscall_printf ("%d = acl (%s)", res, path);
d487 1
a487 1
  syscall_printf ("%d = facl (%s) )", res, cfd->get_name ());
@


1.69
log
@	* advapi32.cc (SetSecurityDescriptorDacl): Remove.
	(SetSecurityDescriptorGroup): Remove.
	(SetSecurityDescriptorOwner): Remove.
	* pinfo.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.

	* sec_helper.cc (__sec_user): Remove old comment.
@
text
@d214 1
a214 1
  MakeSelfRelativeSD (&sd, sd_ret, &sd_size);
d225 2
a226 1
  if (!MakeSelfRelativeSD (&sd, sd_ret, &sd_size))
d228 1
a228 1
      __seterrno ();
@


1.68
log
@	* advapi32.cc (GetSecurityDescriptorDacl): Remove.
	(GetSecurityDescriptorGroup): Remove.
	(GetSecurityDescriptorOwner): Remove.
	* sec_acl.cc: Replace above functions throughout with their ntdll.dll
	equivalent.  Remove redundant debug output.
	* sec_auth.cc: Ditto.
	* security.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d76 2
a77 1
  if (!SetSecurityDescriptorOwner (&sd, owner, FALSE))
d79 1
a79 1
      __seterrno ();
d82 2
a83 1
  if (!SetSecurityDescriptorGroup (&sd, group, FALSE))
d85 1
a85 1
      __seterrno ();
d206 2
a207 1
  if (!SetSecurityDescriptorDacl (&sd, TRUE, acl, FALSE))
d209 1
a209 1
      __seterrno ();
@


1.67
log
@	* advapi32.cc (InitializeAcl): Remove.
	(AddAce): Remove.
	(FindFirstFreeAce): Remove.
	(GetAce): Remove.
	(InitializeSecurityDescriptor): Remove.
	(OpenProcessToken): Remove.
	* dcrt0.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* fhandler_tty.cc: Ditto.
	* flock.cc: Ditto.
	* pinfo.cc: Ditto.  Drop unnecessary error handling.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d50 2
a51 1
  BOOL dummy;
d55 2
a56 1
  if (!GetSecurityDescriptorOwner (sd_ret, &owner_sid, &dummy))
d58 1
a58 1
      __seterrno ();
d65 2
a66 1
  if (!GetSecurityDescriptorGroup (sd_ret, &group_sid, &dummy))
d68 1
a68 1
      __seterrno ();
d278 2
a279 1
  BOOL dummy;
d283 2
a284 1
  if (!GetSecurityDescriptorOwner (sd, (PSID *) &owner_sid, &dummy))
d286 1
a286 2
      debug_printf ("GetSecurityDescriptorOwner %E");
      __seterrno ();
d291 2
a292 1
  if (!GetSecurityDescriptorGroup (sd, (PSID *) &group_sid, &dummy))
d294 1
a294 2
      debug_printf ("GetSecurityDescriptorGroup %E");
      __seterrno ();
d312 1
a312 1
  BOOL acl_exists;
d314 2
a315 1
  if (!GetSecurityDescriptorDacl (sd, &acl_exists, &acl, &dummy))
d317 1
a317 2
      __seterrno ();
      debug_printf ("GetSecurityDescriptorDacl %E");
@


1.66
log
@	* advapi32.cc (InitializeSid): Remove.
	(EqualPrefixSid): Remove.
	(GetLengthSid): Remove.
	(GetSidSubAuthority): Remove.
	(GetSidSubAuthorityCount): Remove.
	(GetSidIdentifierAuthority): Remove.
	* fhandler_disk_file.cc: Remove above functions throughout with their
	ntdll.dll equivalent.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d24 1
d72 1
a72 5
  if (!InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION))
    {
      __seterrno ();
      return -1;
    }
d94 1
a94 5
  if (!InitializeAcl (acl, ACL_MAXIMUM_SIZE, ACL_REVISION))
    {
      __seterrno ();
      return -1;
    }
d328 1
a328 1
	  if (!GetAce (acl, i, (PVOID *) &ace))
@


1.65
log
@	* sec_acl.cc (getacl): Ensure that the default acl contains at least
	DEF_(USER|GROUP|OTHER)_OBJ entries.
@
text
@d4 1
a4 1
   2009, 2010 Red Hat, Inc.
@


1.64
log
@	* sec_acl.cc (getacl): Set DEF_CLASS_OBJ permissions to 07 instead
	of 0777.
@
text
@d360 1
d366 1
d393 1
a393 3
      /* Include DEF_CLASS_OBJ if any default ace exists */
      if ((types_def & (USER|GROUP))
	  && ((pos = searchace (lacl, MAX_ACL_ENTRIES, DEF_CLASS_OBJ)) >= 0))
d395 30
a424 3
	  lacl[pos].a_type = DEF_CLASS_OBJ;
	  lacl[pos].a_id = ILLEGAL_GID;
	  lacl[pos].a_perm = S_IROTH | S_IWOTH | S_IXOTH;
@


1.63
log
@	* sec_acl.cc (acl_worker): Remove.
	(acl32): Implement acl_worker functionality here.
	(lacl32): Just return -1 with errno set to ENOSYS.
	(lacl): Ditto.
	* include/cygwin/acl.h (lacl): Remove this call.
@
text
@d397 1
a397 1
	  lacl[pos].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
@


1.62
log
@	* flock.cc (allow_others_to_sync): Define MAX_PROCESS_SD_SIZE.  Use
	instead of ACL_DEFAULT_SIZE.
	* sec_acl.cc (setacl): Use TLS buffer to allow maximum ACL size.
	* security.h (ACL_DEFAULT_SIZE): Drop definition.
	(ACL_MAXIMUM_SIZE): Define.
	(SD_MAXIMUM_SIZE): Define.
	* security.cc (get_file_sd): Allocate security_decscriptor with size
	SD_MAXIMUM_SIZE.
	(alloc_sd): Use TLS buffer to allow maximum ACL size.
@
text
@d419 2
a420 3
static int
acl_worker (const char *path, int cmd, int nentries, __aclent32_t *aclbufp,
	    unsigned fmode)
d423 2
a424 1
  fhandler_base *fh = build_fh_name (path, fmode | PC_KEEP_HANDLE,
a441 6
acl32 (const char *path, int cmd, int nentries, __aclent32_t *aclbufp)
{
  return acl_worker (path, cmd, nentries, aclbufp, PC_SYM_FOLLOW);
}

extern "C" int
d444 3
a446 1
  return acl_worker (path, cmd, nentries, aclbufp, PC_SYM_NOFOLLOW);
d934 3
a936 1
  return lacl32 (path, cmd, nentries, acl16to32 (aclbufp, nentries));
@


1.61
log
@	* security.cc (get_file_sd): Add bool parameter justcreated.  Use
	GetSecurityInfo only if justcreated is true, NtQuerySecurityObject
	otherwise.  Add comment to explain why.  Don't waste time to call
	NtQuerySecurityObject twice, just allocate big enough area.
	(get_file_attribute): Call get_file_sd with justcreated set to false.
	(set_file_attribute): Call get_file_sd with justcreated depending on
	S_JUSTCREATED pseudo file attribute.
	(check_file_access): Call get_file_sd with justcreated set to false.
	* sec_acl.cc (setacl): Ditto.
	(getacl): Ditto.
	* security.h: Convert many functions to regparm functions.
	(get_file_sd): Declare with extra bool parameter.
@
text
@d25 1
d44 1
d88 1
a88 1
  PACL acl = (PACL) alloca (ACL_DEFAULT_SIZE);
d97 1
a97 1
  if (!InitializeAcl (acl, ACL_DEFAULT_SIZE, ACL_REVISION))
@


1.60
log
@	* sec_acl.cc (setacl): Use the long time unused ACL_DEFAULT_SIZE
	instead of a constant value.
	* security.cc (alloc_sd): Ditto.
@
text
@d44 1
a44 1
  if (get_file_sd (handle, pc, sd_ret))
d275 1
a275 1
  if (get_file_sd (handle, pc, sd))
@


1.59
log
@	* dtable.cc (dtable::dup_worker): Reset path_conv handle in duplicated
	fhandler.
	* fhandler.cc (fhandler_base::fstatvfs): Keep handle in created
	path_conv.
	* fhandler.h (fhandler_base::get_stat_access): New method.
	(fhandler_base::get_stat_handle): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use handle
	returned by get_stat_handle.  Only request inode from system if it
	isn't already set in the fhandler, and only for filesystems supporting
	them.
	(fhandler_base::fstat_fs): Use handle returned by get_stat_handle.
	Change the way open_fs is called.  Explain why.
	(fhandler_base::fstat_helper): Use handle returned by get_stat_handle.
	Never use 0 inode number.  Simplify executable recognition by re-using
	get_stat_handle if file could be opened with sufficient rights.
	(fhandler_disk_file::fstatvfs): Use handle returned by get_stat_handle.
	(fhandler_disk_file::facl): Use handle returned by get_stat_handle in
	GETACL and GETACLCNT cases.
	(fhandler_disk_file::link): Use handle returned by get_stat_handle
	instead of opening file here again.  Add comment.
	(readdir_get_ino): Keep handle in created path_conv and drop
	opening file.
	* ntdll.h (wait_pending): New helper function.
	* path.cc (symlink_info::check): Drop unused 'opt' parameter from
	declaration.  Add path_conv_handle argument.
	(path_conv::check): Make sure conv_handle is closed.  Keep
	PC_KEEP_HANDLE flag in pflags_or.  Accommodate call to sym.check to
	new args.
	(path_conv::~path_conv): Close conv_handle.
	(symlink_info::check_shortcut): Don't re-open file here, just use
	incoming handle.  Drop goto's and label out.
	(symlink_info::check_sysfile): Don't re-open file here, just use
	incoming handle.  Keep track of file position to accommodate the fact
	that file has been opened asynchronously in calling function.
	(symlink_info::check_nfs_symlink): Don't re-open file here, just use
	incoming handle.
	(symlink_info::check): Drop unused 'opt' parameter.  Add
	path_conv_handle argument.  Always try to open file with GENERIC_READ
	rights first to allow reading file content w/o having to re-open the
	file.  Drop back to READ_CONTROL | FILE_READ_ATTRIBUTES otherwise.
	Call symlink test functions (except for check_reparse_point) only if
	file could be opened with GENERIC_READ.  Keep file handle open if
	PC_KEEP_HANDLE is set in pflags.
	* path.h (enum pathconv_arg): Add PC_KEEP_HANDLE flag.
	(class path_conv_handle): New class.
	(class path_conv): Add conv_handle member.
	(path_conv::operator =): Duplicate conv_handle.
	(path_conv::handle): New method.
	(path_conv::access): New method.
	(path_conv::reset_conv_handle): New method.
	(path_conv::close_conv_handle): New method.
@
text
@d86 1
a86 1
  PACL acl = (PACL) alloca (3072);
d95 1
a95 1
  if (!InitializeAcl (acl, 3072, ACL_REVISION))
@


1.58
log
@	* dtable.cc (build_fh_name_worker): Remove.  Move all functionality
	back into build_fh_name.
	(build_fh_name): Drop unused HANDLE parameter.  Drop call to pc.fillin.
	Remove disabled build_fh_name with UNICODE_STRING name parameter.
	* dtable.h (build_fh_name): Drop HANDLE parameter from declaration.
	Remove declaration for build_fh_name with UNICODE_STRING name parameter.
	* path.cc (path_conv::fillin): Remove.
	(symlink_info::check): Fix comment.
	* path.h (path_conv::fillin): Remove declaration.
	* dir.cc: Accommodate change in build_fh_name parameters throughout.
	* sec_acl.cc: Ditto.
	* syscalls.cc: Ditto.

	* ntea.cc (getxattr_worker): Fix debug output.
	(setxattr_worker): Ditto.
	* times.cc (utimens_worker): Ditto.
@
text
@d422 2
a423 1
  fhandler_base *fh = build_fh_name (path, fmode, stat_suffixes);
@


1.57
log
@	* sec_helper.cc (security_descriptor::free): If sd_size is 0, call
	LocalFree instead of ::free.

	* sec_acl.cc: Throughout replace old ACE flag definitions with current
	definitions as used in MSDN man pages.
	* security.cc: Ditto.

	* fhandler.cc (fhandler_base::open): Make sure file has really been
	just created before fixing file permissions.  Add S_JUSTCREATED
	attribute to set_file_attribute call.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Always create dir
	with default security descriptor and fix descriptor afterwards.
	Add S_JUSTCREATED flag to set_file_attribute call.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Call GetSecurityInfo rather than
	NtQuerySecurityObject.  Explain why.  Change error handling accordingly.
	(alloc_sd): Skip non-inherited, non-standard entries in ACL if
	S_JUSTCREATED attribute is set.  Explain why.  Minor format fixes.
	* security.h (S_JUSTCREATED): New define.
	(security_descriptor::operator=): New operator.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Red Hat, Inc.
d422 1
a422 1
  fhandler_base *fh = build_fh_name (path, NULL, fmode, stat_suffixes);
@


1.56
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Catch an
	error when changing the user account on a standalone Samba server.
	Explain why.
	* sec_acl.cc (setacl): Accommodate additional parameter to set_file_sd.
	* sec_helper.cc (SECURITY_SAMBA_UNIX_AUTHORITY): Define.
	(well_known_samba_unix_user_fake_sid): Define.
	* security.cc (set_file_sd): Take additional parameter if ownership
	should be changed.  Restrict requested permissions accordingly.
	(set_file_attribute): Accommodate additional parameter to set_file_sd.
	* security.h (well_known_samba_unix_user_fake_sid): Declare.
	(set_file_sd): Align declaration to above change.
@
text
@d126 2
a127 1
			  ? (SUB_CONTAINERS_AND_OBJECTS_INHERIT | INHERIT_ONLY)
d142 1
a142 1
	  inheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
d369 1
a369 1
	  if (!(ace->Header.AceFlags & INHERIT_ONLY || type & ACL_DEFAULT))
d374 2
a375 1
	  if ((ace->Header.AceFlags & SUB_CONTAINERS_AND_OBJECTS_INHERIT)
@


1.55
log
@	* sec_acl.cc (setacl): Align standard owner and group permissions
	with alloc_sd.  Strip FILE_READ_ATTRIBUTES fromn setting
	FILE_GENERIC_EXECUTE permissions same as in alloc_sd.
	* security.cc (alloc_sd): Reformat expression.  Strip EA permission
	bits from owner_deny and group_deny computation.
@
text
@d228 1
a228 1
  return set_file_sd (handle, pc, sd_ret);
@


1.54
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d107 3
a109 1
	allow = STANDARD_RIGHTS_ALL | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA;
d111 2
a112 1
	allow = STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d117 1
a117 1
	  allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE;
d121 1
a121 1
	allow |= FILE_GENERIC_EXECUTE;
@


1.53
log
@	* sec_acl.cc (setacl): Set errno to EINVAL if user or group don't exist.
@
text
@d241 6
a246 4
    if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
      acl.a_perm |= S_IROTH;
    else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
      acl.a_perm |= DENY_R;
d249 6
a254 4
    if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
      acl.a_perm |= S_IWOTH;
    else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
      acl.a_perm |= DENY_W;
d257 6
a262 4
    if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
      acl.a_perm |= S_IXOTH;
    else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
      acl.a_perm |= DENY_X;
@


1.52
log
@Remove unneeded header files from source files throughout.
@
text
@d157 7
a163 3
	      || !sid.getfrompw (pw)
	      || !add_access_allowed_ace (acl, ace_off++, allow,
					  sid, acl_len, inheritance))
d179 7
a185 3
	      || !sid.getfromgr (gr)
	      || !add_access_allowed_ace (acl, ace_off++, allow,
					  sid, acl_len, inheritance))
@


1.51
log
@	* dir.cc (readdir_worker): Convert w32name to PUNICODE_STRING.
	* sec_acl.cc (getacl): Convert debug output to print native NT path.
	* security.cc (set_file_attribute): Ditto.
	* syscalls.cc (try_to_bin): Ditto and fix buggy debug statement.
@
text
@a21 1
#include "pinfo.h"
@


1.50
log
@	* fhandler.h (fhandler_base::pc): Make public.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Drop extern
	declaration of stat_suffixes.  Use NT native path in debug output.
	(fhandler_base::utimes_fs): Simplify closeit case.  Use close_fs
	to close newly opened file handle.
	(fhandler_base::open_fs): Use NT native path in debug output.
	* path.cc: Throughout drop extern declaration of stat_suffixes.
	* path.h (stat_suffixes): Declare.
	* sec_acl.cc (acl_worker): Drop extern declaration of stat_suffixes.
	* times.cc (utimes_worker): Take path_conv as parameter instead of
	single-byte pathnam, drop nofollow argument, accommodate throughout.
	Compare UNICODE paths when enumerating file descriptors.  Fix
	formatting.  Use NT native path in debug output.
@
text
@d394 1
a394 1
  syscall_printf ("%d = getacl (%s)", pos, pc.get_win32 ());
@


1.49
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): If file can't be
	opened for reading the ACLs, fall back to faking them.
	* sec_acl.cc (acl_worker): Handle non-existing files.
	* security.cc (get_file_attribute): Return ILLEGAL_UID/ILLEGAL_GID
	as owner/group for non-readable ACLs on file systems supporting them.
@
text
@a401 1
  extern suffix_info stat_suffixes[];
@


1.48
log
@	* fhandler.cc (fhandler_base::fhaccess): Accommodate interface changes
	of access control functions throughout.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* sec_acl.cc: Drop unnecessary includes.
	(setacl): Take path_conv instead of file name as parameter.
	Accommodate interface changes of access control functions.
	(getacl): Ditto.
	* sec_auth.cc: New file, taking over all authentication related
	functions from security.cc.
	* sec_helper.cc: Drop unnecessary includes.
	* security.cc: Ditto.  Move all authentication related functions to
	sec_auth.cc.
	(ALL_SECURITY_INFORMATION): New define.  Use throughout.
	(set_file_sd): New function, replacing read_sd and the file related
	part of get_nt_object_security.
	(get_reg_sd): Rename from get_reg_security.  Drop type parameter.
	(get_reg_attribute): New function, replacing the registry related part
	of get_nt_object_security.
	(get_file_attribute): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(set_file_attribute): Ditto plus new set_file_sd.  Drop unnecessary
	implementation without uid/gid parameters.
	(check_file_access): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(check_registry_access): Use new get_reg_sd call.
	* security.h: Accommodate above interface changes.
@
text
@d410 2
@


1.47
log
@	* security.h (setacl): Add parameter for writability flag.
	* sec_acl.cc (setacl): Ditto.  Set to true if any ACE with write
	permissions is created.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Reset
	FILE_ATTRIBUTE_READONLY if ACL contains an ACE with write permissions.
@
text
@a13 3
#include <grp.h>
#include <pwd.h>
#include <unistd.h>
a14 3
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
a16 2
#include <wingdi.h>
#include <winuser.h>
d39 1
a39 1
setacl (HANDLE handle, const char *file, int nentries, __aclent32_t *aclbufp,
d44 2
a45 6
  if ((!handle || get_nt_object_security (handle, SE_FILE_OBJECT, sd_ret))
      && read_sd (file, sd_ret) <= 0)
    {
      debug_printf ("read_sd %E");
      return -1;
    }
d218 1
a218 1
  return write_sd (handle, file, sd_ret);
d253 1
a253 2
getacl (HANDLE handle, const char *file, DWORD attr, int nentries,
	__aclent32_t *aclbufp)
d257 2
a258 6
  if ((!handle || get_nt_object_security (handle, SE_FILE_OBJECT, sd))
      && read_sd (file, sd) <= 0)
    {
      debug_printf ("read_sd %E");
      return -1;
    }
d358 1
a358 1
	      && (attr & FILE_ATTRIBUTE_DIRECTORY))
d394 1
a394 1
  syscall_printf ("%d = getacl (%s)", pos, file);
@


1.46
log
@	* sec_acl.cc (acltotext32): Add missing handling of default ACL entry
	types.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d47 2
a48 1
setacl (HANDLE handle, const char *file, int nentries, __aclent32_t *aclbufp)
d112 3
d126 4
a129 1
	allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE;
@


1.45
log
@	* pinfo.cc (pinfo::init): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	(pinfo::set_acl): Replace sa_buf by dynamically allocated acl_buf.
	* sec_acl.cc (setacl): Allocate acl dynamically.
	* sec_helper.cc (sec_acl): Add test for alignment of acl when
	DEBUGGING is defined.
	(__sec_user): Same for sa_buf.
	* security.cc (verify_token): Define sd_buf as PSECURITY_DESCRIPTOR
	and allocate dynamically.
	(alloc_sd): Allocate acl dynamically.
	security.h (sec_user_nih): Change first parameter to
	SECURITY_ATTRIBUTES *.
	(sec_user): Ditto.
	* sigproc.cc (wait_sig): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	* syscalls.cc (seteuid32): Define dacl_buf as PACL and allocate
	dynamically.
	* uinfo.cc (cygheap_user::init): Define sa_buf as PSECURITY_ATTRIBUTES
	and allocate dynamically.
	* winbase.h (ilockincr): Mark first argument of inline assembly as
	earlyclobber.
	(ilockdecr): Ditto.
@
text
@d731 1
a731 1
      switch (aclbufp[pos].a_type)
@


1.45.6.1
log
@	* sec_acl.cc (acltotext32): Add missing handling of default ACL entry
	types.
@
text
@d731 1
a731 1
      switch (aclbufp[pos].a_type & ~ACL_DEFAULT)
@


1.44
log
@Remove PC_FULL from path_conv usage throughout.
* path.h (enum pathconv_arg): Change PC_FULL to PC_NOUILL.
* path.cc (path_conv::check): Test for PC_NOFULL rather than !PC_FULL.
(cygwin_conv_to_win32_path): Use PC_NOFULL to force non-absolute path.
@
text
@d97 1
a97 2
  char acl_buf[3072];
  PACL acl = (PACL) acl_buf;
@


1.43
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d415 1
a415 2
  fhandler_base *fh = build_fh_name (path, NULL, fmode | PC_FULL,
				     stat_suffixes);
@


1.42
log
@	* ntdll.h: Fix copyright date.
	* sec_acl.cc (acl_worker): delete allocated fhandler.
	* syscalls.cc (chown_worker): Ditto.
	(chmod): Ditto.
	(stat_worker): Use get_namehash instead of hash_path_name.
@
text
@d264 1
a264 1
  if (!handle || get_nt_object_security (handle, SE_FILE_OBJECT, sd)
@


1.41
log
@	* sec_acl.cc (getacl): Avoid compiler warning.
	* security.cc (write_sd): Ditto.  Fix error handling.
@
text
@d424 2
@


1.40
log
@	* fhandler.cc (fhandler_base::open): Simplify access evaluation
	expression.
	(fhandler_base::facl): New method.
	* fhandler.h: Declare facl method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): New method.
	* fhandler_virtual.cc (fhandler_virtual::facl): New method.
	* sec_acl.cc: Remove forward declaration for aclsort32 and acl32.
	(setacl): Remove static.  Add and use handle parameter.
	(getacl): Ditto.
	(acl_worker): Reorganize to call fhandler's facl method eventually.
	(facl32): Ditto.
	* security.cc (get_nt_object_security): Remove static.
	* security.h: Add extern declarations for get_nt_object_security,
	aclsort32, acl32, getacl and setacl.


	Apply missing syscalls.cc patch and ChangeLog of previous check in.
	* syscalls.cc (chown_worker): Reorganize to call fhandler's fchown
	method eventually.
	(fchown): Ditto.
@
text
@a263 1
  int ret;
d265 1
a265 1
      && (ret = read_sd (file, sd)) <= 0)
d268 1
a268 1
      return ret;
@


1.39
log
@	* fhandler.cc (fhandler_base::open): Accomodate query_write_control
	query_state.
	(fhandler_base::fchown): New method.
	* fhandler.h: Declare fchown method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	(enum query_state): Add query_write_control.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Set query_state
	to query_write_control.  Only remove FILE_ATTRIBUTE_READONLY if not
	setting security descriptor.
	(fhandler_disk_file::fchown): New method.
	* fhandler_virtual.cc (fhandler_virtual::fchown): New method.
	* sec_acl.cc (setacl): Call write_sd with additional handle attribute.
	* security.cc (write_sd): Take handle argument.  Only request owner
	if getting SE_RESTORE_NAME privilege failed.  Only open file if
	NtSetSecurityObject failed or handle is NULL.
	(set_nt_attribute): Call write_sd with additional handle attribute.
	* security.h (write_sd): Declare with additional handle argument.
@
text
@a33 3
extern "C" int aclsort32 (int nentries, int, __aclent32_t *aclbufp);
extern "C" int acl32 (const char *path, int cmd, int nentries, __aclent32_t *aclbufp);

d46 2
a47 2
static int
setacl (const char *file, int nentries, __aclent32_t *aclbufp)
d51 2
a52 1
  if (read_sd (file, sd_ret) <= 0)
d224 1
a224 1
  return write_sd (NULL, file, sd_ret);
d258 3
a260 2
static int
getacl (const char *file, DWORD attr, int nentries, __aclent32_t *aclbufp)
d265 2
a266 1
  if ((ret = read_sd (file, sd)) <= 0)
d412 1
a412 1
	    int nofollow)
d415 4
a418 2
  path_conv real_path (path, (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW) | PC_FULL, stat_suffixes);
  if (real_path.error)
d420 2
a421 3
      set_errno (real_path.error);
      syscall_printf ("-1 = acl (%s)", path);
      return -1;
d423 4
a426 65
  if (!real_path.has_acls () || !allow_ntsec)
    {
      struct __stat64 st;
      int ret = -1;

      switch (cmd)
	{
	case SETACL:
	  set_errno (ENOSYS);
	  break;
	case GETACL:
	  if (!aclbufp)
	    set_errno(EFAULT);
	  else if (nentries < MIN_ACL_ENTRIES)
	    set_errno (ENOSPC);
	  else if ((nofollow && !lstat64 (path, &st))
		   || (!nofollow && !stat64 (path, &st)))
	    {
	      aclbufp[0].a_type = USER_OBJ;
	      aclbufp[0].a_id = st.st_uid;
	      aclbufp[0].a_perm = (st.st_mode & S_IRWXU) >> 6;
	      aclbufp[1].a_type = GROUP_OBJ;
	      aclbufp[1].a_id = st.st_gid;
	      aclbufp[1].a_perm = (st.st_mode & S_IRWXG) >> 3;
	      aclbufp[2].a_type = OTHER_OBJ;
	      aclbufp[2].a_id = ILLEGAL_GID;
	      aclbufp[2].a_perm = st.st_mode & S_IRWXO;
	      aclbufp[3].a_type = CLASS_OBJ;
	      aclbufp[3].a_id = ILLEGAL_GID;
	      aclbufp[3].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
	      ret = MIN_ACL_ENTRIES;
	    }
	  break;
	case GETACLCNT:
	  ret = MIN_ACL_ENTRIES;
	  break;
	}
      syscall_printf ("%d = acl (%s)", ret, path);
      return ret;
    }
  switch (cmd)
    {
      case SETACL:
	if (!aclsort32 (nentries, 0, aclbufp))
	  return setacl (real_path.get_win32 (),
			 nentries, aclbufp);
	break;
      case GETACL:
	if (!aclbufp)
	  set_errno(EFAULT);
	else
	  return getacl (real_path.get_win32 (),
			 real_path.file_attributes (),
			 nentries, aclbufp);
	break;
      case GETACLCNT:
	return getacl (real_path.get_win32 (),
		       real_path.file_attributes (),
		       0, NULL);
      default:
	set_errno (EINVAL);
	break;
    }
  syscall_printf ("-1 = acl (%s)", path);
  return -1;
d432 1
a432 1
  return acl_worker (path, cmd, nentries, aclbufp, 0);
d438 1
a438 1
  return acl_worker (path, cmd, nentries, aclbufp, 1);
d450 3
a452 9
  const char *path = cfd->get_name ();
  if (path == NULL)
    {
      syscall_printf ("-1 = facl (%d) (no name)", fd);
      set_errno (ENOSYS);
      return -1;
    }
  syscall_printf ("facl (%d): calling acl (%s)", fd, path);
  return acl_worker (path, cmd, nentries, aclbufp, 0);
@


1.38
log
@	* sec_acl.cc (setacl): Use correct offset when trying to combine
	standard and default entry of same type.
@
text
@d226 1
a226 1
  return write_sd (file, sd_ret);
@


1.37
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d145 1
a145 1
	  && aclbufp[i].a_perm == aclbufp[pos].a_perm)
d149 1
a149 1
	  aclbufp[pos].a_type = USER|GROUP|ACL_DEFAULT;
@


1.36
log
@	* sec_acl.cc (setacl): Make sure sd_ret is large enough.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.35
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d215 5
@


1.35.6.1
log
@merge from trunk.
@
text
@a214 5
  if (!sd_ret.realloc (sd_size))
    {
      set_errno (ENOMEM);
      return -1;
    }
@


1.34
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@d355 1
a355 1
	    id = ace_sid.get_id (TRUE, &type);
d519 10
a528 10
  BOOL has_user_obj = FALSE;
  BOOL has_group_obj = FALSE;
  BOOL has_other_obj = FALSE;
  BOOL has_class_obj = FALSE;
  BOOL has_ug_objs = FALSE;
  BOOL has_def_user_obj = FALSE;
  BOOL has_def_group_obj = FALSE;
  BOOL has_def_other_obj = FALSE;
  BOOL has_def_class_obj = FALSE;
  BOOL has_def_ug_objs = FALSE;
d541 1
a541 1
	has_user_obj = TRUE;
d550 1
a550 1
	has_group_obj = TRUE;
d559 1
a559 1
	has_other_obj = TRUE;
d568 1
a568 1
	has_class_obj = TRUE;
d579 1
a579 1
	has_ug_objs = TRUE;
d588 1
a588 1
	has_def_user_obj = TRUE;
d597 1
a597 1
	has_def_group_obj = TRUE;
d606 1
a606 1
	has_def_other_obj = TRUE;
d615 1
a615 1
	has_def_class_obj = TRUE;
d626 1
a626 1
	has_def_ug_objs = TRUE;
d784 1
a784 1
  BOOL first = TRUE;
d790 1
a790 1
      first = FALSE;
@


1.33
log
@	* sec_acl.h (getace): Use FILE_*_BITS as permission mask.
	* security.cc (get_attribute_from_acl): Ditto.
	* security.h (FILE_READ_BITS): Define to match also GENERIC bits.
	(FILE_WRITE_BITS): Ditto.
	(FILE_EXEC_BITS): Ditto.
@
text
@d52 1
a52 3
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;
d54 1
a54 1
  if (read_sd (file, psd, &sd_size) <= 0)
d64 1
a64 1
  if (!GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
d73 1
a73 1
  if (!GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
d207 3
a209 3
  /* Make self relative security descriptor in psd. */
  sd_size = 0;
  MakeSelfRelativeSD (&sd, psd, &sd_size);
d215 1
a215 1
  if (!MakeSelfRelativeSD (&sd, psd, &sd_size))
d220 2
a221 2
  debug_printf ("Created SD-Size: %d", sd_size);
  return write_sd (file, psd, sd_size);
d258 1
a258 3
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;
d261 1
a261 1
  if ((ret = read_sd (file, psd, &sd_size)) <= 0)
d273 1
a273 1
  if (!GetSecurityDescriptorOwner (psd, (PSID *) &owner_sid, &dummy))
d281 1
a281 1
  if (!GetSecurityDescriptorGroup (psd, (PSID *) &group_sid, &dummy))
d304 1
a304 1
  if (!GetSecurityDescriptorDacl (psd, &acl_exists, &acl, &dummy))
@


1.32
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d238 1
a238 1
  if ((win_ace_mask & FILE_READ_DATA) && !(acl.a_perm & (S_IROTH | DENY_R)))
d244 1
a244 1
  if ((win_ace_mask & FILE_WRITE_DATA) && !(acl.a_perm & (S_IWOTH | DENY_W)))
d250 1
a250 1
  if ((win_ace_mask & FILE_EXECUTE) && !(acl.a_perm & (S_IXOTH | DENY_X)))
@


1.31
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d27 1
a28 1
#include "path.h"
@


1.30
log
@	* sec_acl.cc (setacl): Don't handle DELETE flag specially.
	* security.cc (alloc_sd): Ditto.
@
text
@a17 1
#include <errno.h>
@


1.29
log
@whitespace cleanup
@
text
@d122 1
a122 2
	allow = (STANDARD_RIGHTS_ALL & ~DELETE)
		| FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA;
d128 1
a128 6
	{
	  allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE;
	  /* Owner gets DELETE right, too. */
	  if ((aclbufp[i].a_type & ~ACL_DEFAULT) == USER_OBJ)
	    allow |= DELETE;
	}
@


1.28
log
@Do some minor reformatting of 'extern "C"' use throughout.
* autoload.cc (GetSystemTimes): Define new autoload function.
* fhandler_proc.cc (proc_listing): Add cpuinfo and partitions entries.
(fhandler_proc::fill_filebuf): Add PROC_CPUINFO and PROC_PARTITIONS cases.
(format_proc_uptime): Use GetSystemTimes if available.
(read_value): New macro.
(print): New macro.
(cpuid): New function.
(can_set_flag): New function.
(format_proc_cpuinfo): New function.
(format_proc_partitions): New function.
@
text
@d129 1
a129 1
        {
@


1.27
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@d416 1
a416 2
static
int
d495 1
a495 2
extern "C"
int
d501 1
a501 2
extern "C"
int
d507 1
a507 2
extern "C"
int
d527 1
a527 2
extern "C"
int
d659 2
a660 2
static
int acecmp (const void *a1, const void *a2)
d670 1
a670 2
extern "C"
int
d684 1
a684 2
extern "C"
int
d723 1
a723 2
extern "C"
int
d760 1
a760 2
extern "C"
int
d766 1
a766 2
extern "C"
int
d784 1
a784 2
extern "C"
char *
d860 1
a860 2
extern "C"
__aclent32_t *
d983 1
a983 2
extern "C"
int
d989 1
a989 2
extern "C"
int
d995 1
a995 2
extern "C"
int
d1001 1
a1001 2
extern "C"
int
d1007 1
a1007 2
extern "C"
int
d1014 1
a1014 2
extern "C"
int
d1020 1
a1020 2
extern "C"
int
d1026 1
a1026 2
extern "C"
int
d1032 1
a1032 2
extern "C"
int
d1038 1
a1038 2
extern "C"
char *
d1044 1
a1044 2
extern "C"
__aclent16_t *
@


1.26
log
@	* sec_acl.cc (setacl): Move all permission settings to beginning of
	loop.  Set default rights to same values as in alloc_sd().  Set DELETE
	for owner and default owner only if S_IWOTH is given.

	* sec_acl.cc: Change all  __aclent16_t to  __aclent32_t except in
	wrapper function definitions. Replace call to the aclXYZ functions by
	calls aclXYZ32.
	(searchace): Change type of third argument to __uid32_t and use
	ILLEGAL_UID instead of -1;
	(setacl): Remove some initializations. Only give STANDARD_RIGHTS_WRITE
	for S_IWOTH. Replace -1 by ILLEGAL_UID.
	(getacl): Change type of owner_sid, group_sid and ace_sid to cygpsid.
	In last else clause, suppress second call to ace_sid.get_id and use
	TRUE in first call. Replace EqualSid by ==.
	(acl_access): Call internal_getgroups in USER and GROUP cases.
	(acecmp: Define static.
	(acl32): Create from 16 bit type.
	(facl32): Ditto.
	(lacl32): Ditto.
	(aclcheck32): Ditto.
	(aclsort32): Ditto.
	(acltomode32): Ditto.
	(aclfrommode32): Ditto.
	(acltopbits32): Ditto.
	(aclfrompbits32): Ditto.
	(acltotext32): Ditto.
	(aclfromtext32): Ditto, and use strechr.
	(acl16to32): Create.
	(acl): Make it a wrapper function.
	(facl): Ditto.
	(lacl): Ditto.
	(aclcheck): Ditto.
	(aclsort): Ditto.
	(acltomode): Ditto.
	(aclfrommode): Ditto.
	(acltopbits): Ditto.
	(aclfrompbits): Ditto.
	(acltotext): Ditto.
	(aclfromtext): Ditto.
	* security.cc (write_sd): Call set_process_privilege and check
	ownership.
	(alloc_sd): Remove call to set_process_privilege and the owner check.
@
text
@a415 63
int
acl_access (const char *path, int flags)
{
  __aclent32_t acls[MAX_ACL_ENTRIES];
  int cnt;

  if ((cnt = acl32 (path, GETACL, MAX_ACL_ENTRIES, acls)) < 1)
    return -1;

  /* Only check existence. */
  if (!(flags & (R_OK | W_OK | X_OK)))
    return 0;

  for (int i = 0; i < cnt; ++i)
    {
      switch (acls[i].a_type)
	{
	case USER_OBJ:
	case USER:
	  if (acls[i].a_id != myself->uid)
	    {
	      /*
	       * Check if user is a NT group:
	       * Take SID from passwd, search SID in token groups
	       */
	      cygsid owner;
	      struct passwd *pw;

	      if ((pw = internal_getpwuid (acls[i].a_id)) != NULL
		  && owner.getfrompw (pw)
		  && internal_getgroups (0, NULL, &owner) > 0)
		break;
	      continue;
	    }
	  break;
	case GROUP_OBJ:
	case GROUP:
	  if (acls[i].a_id != myself->gid)
            {
	      cygsid group;
	      struct __group32 *gr = NULL;

	      if ((gr = internal_getgrgid (acls[i].a_id)) != NULL
		  && group.getfromgr (gr)
		  && internal_getgroups (0, NULL, &group) > 0)
		break;
	      continue;
	    }
	  break;
	case OTHER_OBJ:
	  break;
	default:
	  continue;
	}
      if ((!(flags & R_OK) || (acls[i].a_perm & S_IROTH))
	  && (!(flags & W_OK) || (acls[i].a_perm & S_IWOTH))
	  && (!(flags & X_OK) || (acls[i].a_perm & S_IXOTH)))
	return 0;
    }
  set_errno (EACCES);
  return -1;
}

@


1.25
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d35 2
a36 2
extern "C" int aclsort (int nentries, int, __aclent16_t *aclbufp);
extern "C" int acl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp);
d39 1
a39 1
searchace (__aclent16_t *aclp, int nentries, int type, int id = -1)
d44 1
a44 1
    if ((aclp[i].a_type == type && (id == -1 || aclp[i].a_id == id))
d51 1
a51 1
setacl (const char *file, int nentries, __aclent16_t *aclbufp)
d66 1
a66 1
  PSID owner_sid = NULL;
d75 1
a75 1
  PSID group_sid = NULL;
d95 1
a95 2
  if (group
      && !SetSecurityDescriptorGroup (&sd, group, FALSE))
d119 7
a125 2
      DWORD allow = STANDARD_RIGHTS_READ
		    | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d129 6
a134 1
	allow |= STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE;
d153 1
a153 1
			       ? aclbufp[i].a_id : -1)) >= 0
a162 1
	  allow |= STANDARD_RIGHTS_ALL & ~DELETE;
a167 1
	  allow |= STANDARD_RIGHTS_ALL & ~DELETE;
d177 1
a177 1
					   sid, acl_len, inheritance))
d182 1
a182 1
					group, acl_len, inheritance))
d195 1
a195 1
					   sid, acl_len, inheritance))
d239 1
a239 1
getace (__aclent16_t &acl, int type, int id, DWORD win_ace_mask,
d265 1
a265 1
getacl (const char *file, DWORD attr, int nentries, __aclent16_t *aclbufp)
d278 2
a279 2
  PSID owner_sid;
  PSID group_sid;
d284 1
a284 1
  if (!GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
d290 1
a290 1
  uid = cygsid (owner_sid).get_uid ();
d292 1
a292 1
  if (!GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
d298 1
a298 1
  gid = cygsid (group_sid).get_gid ();
d300 2
a301 2
  __aclent16_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (__aclent16_t));
d336 1
a336 1
	  cygsid ace_sid ((PSID) &ace->SidStart);
d366 2
a367 13
	    {
	      id = ace_sid.get_id (FALSE, &type);
	      if (type != GROUP)
		{
		  int type2 = 0;
		  int id2 = ace_sid.get_id (TRUE, &type2);
		  if (type2 == GROUP)
		    {
		      id = id2;
		      type = GROUP;
		    }
		}
	    }
d400 1
a400 1
    if (EqualSid (owner_sid, group_sid))
d407 1
a407 1
    memcpy (aclbufp, lacl, pos * sizeof (__aclent16_t));
d410 1
a410 1
    aclsort (pos, 0, aclbufp);
d419 1
a419 1
  __aclent16_t acls[MAX_ACL_ENTRIES];
d422 1
a422 1
  if ((cnt = acl (path, GETACL, MAX_ACL_ENTRIES, acls)) < 1)
d425 1
a425 1
  /* Only check existance. */
d439 1
a439 1
	       * Take SID from passwd, search SID in group, check is_grp_member.
a442 1
	      struct __group32 *gr = NULL;
d446 1
a446 2
		  && (gr = internal_getgrsid (owner))
		  && is_grp_member (myself->uid, gr->gr_gid))
d453 11
a463 3
	  if (acls[i].a_id != myself->gid &&
	      !is_grp_member (myself->uid, acls[i].a_id))
	    continue;
d481 1
a481 1
acl_worker (const char *path, int cmd, int nentries, __aclent16_t *aclbufp,
d535 1
a535 1
	if (!aclsort (nentries, 0, aclbufp))
d561 1
a561 1
acl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
d568 1
a568 1
lacl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
d575 1
a575 1
facl (int fd, int cmd, int nentries, __aclent16_t *aclbufp)
d596 1
a596 1
aclcheck (__aclent16_t *aclbufp, int nentries, int *which)
d727 1
a727 1
extern "C"
d730 1
a730 1
#define ace(i) ((const __aclent16_t *) a##i)
d740 1
a740 1
aclsort (int nentries, int, __aclent16_t *aclbufp)
d742 1
a742 1
  if (aclcheck (aclbufp, nentries, NULL))
d749 1
a749 1
  qsort ((void *) aclbufp, nentries, sizeof (__aclent16_t), acecmp);
d755 1
a755 1
acltomode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
d795 1
a795 1
aclfrommode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
d833 1
a833 1
acltopbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
d835 1
a835 1
  return acltomode (aclbufp, nentries, pbitsp);
d840 1
a840 1
aclfrompbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
d842 1
a842 1
  return aclfrommode (aclbufp, nentries, pbitsp);
d859 1
a859 1
acltotext (__aclent16_t *aclbufp, int aclcnt)
d862 1
a862 1
      || aclcheck (aclbufp, aclcnt, NULL))
d935 2
a936 2
__aclent16_t *
aclfromtext (char *acltextp, int *)
d944 1
a944 1
  __aclent16_t lacl[MAX_ACL_ENTRIES];
d975 1
a975 1
		  c = strchr (c, ':');
d979 1
a979 1
	      if (!c || *c != ':')
d1003 1
a1003 1
		  c = strchr (c, ':');
d1007 1
a1007 1
	      if (!c || *c != ':')
d1041 1
a1041 1
  __aclent16_t *aclp = (__aclent16_t *) malloc (pos * sizeof (__aclent16_t));
d1043 1
a1043 1
    memcpy (aclp, lacl, pos * sizeof (__aclent16_t));
d1047 88
@


1.24
log
@	* sec_acl.cc (search_ace): Use id == -1, instead of < 0, as wildcard.
	(setacl): Start the search for a matching default at the next entry.
	Invalidate the type of merged entries instead of clearing it.
	Use well_known_creator for default owner and owning group and do
	not try to merge non-default and default entries in these cases.
	(getacl): Recognize well_known_creator for default owner and group.
	(acl_worker): Improve errno settings and streamline the nontsec case.
	* security.cc (write_sd): Remove the call to set_process_privilege.
	(alloc_sd): If the owner changes, call set_process_privilege and return
	immediately on failure. Change inheritance rules: on new directories add
	inherit only allow ACEs for creator_owner, creator_group and everyone.
	Preserve all inheritances through chmod and chown calls. Introduce
	isownergroup to implement the uid == gid case, to keep the inheritance
	code simple. Do not initialize owner_sid and group_sid and stop using
	the variable psd.
@
text
@d141 1
a141 1
          && (pos = searchace (aclbufp + i + 1, nentries - i - 1,
d148 2
a149 2
          /* This invalidates the corresponding default entry. */
          aclbufp[pos].a_type = USER|GROUP|ACL_DEFAULT;
d233 1
a233 1
        DWORD win_ace_type)
d408 1
a408 1
        set_errno (ENOSPC);
@


1.24.2.1
log
@merge from trunk
@
text
@d141 1
a141 1
	  && (pos = searchace (aclbufp + i + 1, nentries - i - 1,
d148 2
a149 2
	  /* This invalidates the corresponding default entry. */
	  aclbufp[pos].a_type = USER|GROUP|ACL_DEFAULT;
d233 1
a233 1
	DWORD win_ace_type)
d408 1
a408 1
	set_errno (ENOSPC);
@


1.24.2.2
log
@merge from trunk
@
text
@d35 2
a36 2
extern "C" int aclsort32 (int nentries, int, __aclent32_t *aclbufp);
extern "C" int acl32 (const char *path, int cmd, int nentries, __aclent32_t *aclbufp);
d39 1
a39 1
searchace (__aclent32_t *aclp, int nentries, int type, __uid32_t id = ILLEGAL_UID)
d44 1
a44 1
    if ((aclp[i].a_type == type && (id == ILLEGAL_UID || aclp[i].a_id == id))
d51 1
a51 1
setacl (const char *file, int nentries, __aclent32_t *aclbufp)
d66 1
a66 1
  PSID owner_sid;
d75 1
a75 1
  PSID group_sid;
d95 2
a96 1
  if (!SetSecurityDescriptorGroup (&sd, group, FALSE))
d120 2
a121 7
      DWORD allow;
      /* Owner has more standard rights set. */
      if ((aclbufp[i].a_type & ~ACL_DEFAULT) == USER_OBJ)
	allow = (STANDARD_RIGHTS_ALL & ~DELETE)
		| FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA;
      else
	allow = STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d125 1
a125 6
        {
	  allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE;
	  /* Owner gets DELETE right, too. */
	  if ((aclbufp[i].a_type & ~ACL_DEFAULT) == USER_OBJ)
	    allow |= DELETE;
	}
d144 1
a144 1
			       ? aclbufp[i].a_id : ILLEGAL_UID)) >= 0
d154 1
d160 1
d170 1
a170 1
					  sid, acl_len, inheritance))
d175 1
a175 1
				       group, acl_len, inheritance))
d188 1
a188 1
					  sid, acl_len, inheritance))
d232 1
a232 1
getace (__aclent32_t &acl, int type, int id, DWORD win_ace_mask,
d258 1
a258 1
getacl (const char *file, DWORD attr, int nentries, __aclent32_t *aclbufp)
d271 2
a272 2
  cygpsid owner_sid;
  cygpsid group_sid;
d277 1
a277 1
  if (!GetSecurityDescriptorOwner (psd, (PSID *) &owner_sid, &dummy))
d283 1
a283 1
  uid = owner_sid.get_uid ();
d285 1
a285 1
  if (!GetSecurityDescriptorGroup (psd, (PSID *) &group_sid, &dummy))
d291 1
a291 1
  gid = group_sid.get_gid ();
d293 2
a294 2
  __aclent32_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (__aclent32_t));
d329 1
a329 1
	  cygpsid ace_sid ((PSID) &ace->SidStart);
d359 13
a371 2
	    id = ace_sid.get_id (TRUE, &type);

d404 1
a404 1
    if (owner_sid == group_sid)
d411 1
a411 1
    memcpy (aclbufp, lacl, pos * sizeof (__aclent32_t));
d414 1
a414 1
    aclsort32 (pos, 0, aclbufp);
d423 1
a423 1
  __aclent32_t acls[MAX_ACL_ENTRIES];
d426 1
a426 1
  if ((cnt = acl32 (path, GETACL, MAX_ACL_ENTRIES, acls)) < 1)
d429 1
a429 1
  /* Only check existence. */
d443 1
a443 1
	       * Take SID from passwd, search SID in token groups
d447 1
d451 2
a452 1
		  && internal_getgroups (0, NULL, &owner) > 0)
d459 3
a461 11
	  if (acls[i].a_id != myself->gid)
            {
	      cygsid group;
	      struct __group32 *gr = NULL;

	      if ((gr = internal_getgrgid (acls[i].a_id)) != NULL
		  && group.getfromgr (gr)
		  && internal_getgroups (0, NULL, &group) > 0)
		break;
	      continue;
	    }
d479 1
a479 1
acl_worker (const char *path, int cmd, int nentries, __aclent32_t *aclbufp,
d533 1
a533 1
	if (!aclsort32 (nentries, 0, aclbufp))
d559 1
a559 1
acl32 (const char *path, int cmd, int nentries, __aclent32_t *aclbufp)
d566 1
a566 1
lacl32 (const char *path, int cmd, int nentries, __aclent32_t *aclbufp)
d573 1
a573 1
facl32 (int fd, int cmd, int nentries, __aclent32_t *aclbufp)
d594 1
a594 1
aclcheck32 (__aclent32_t *aclbufp, int nentries, int *which)
d725 1
a725 1
static
d728 1
a728 1
#define ace(i) ((const __aclent32_t *) a##i)
d738 1
a738 1
aclsort32 (int nentries, int, __aclent32_t *aclbufp)
d740 1
a740 1
  if (aclcheck32 (aclbufp, nentries, NULL))
d747 1
a747 1
  qsort ((void *) aclbufp, nentries, sizeof (__aclent32_t), acecmp);
d753 1
a753 1
acltomode32 (__aclent32_t *aclbufp, int nentries, mode_t *modep)
d793 1
a793 1
aclfrommode32 (__aclent32_t *aclbufp, int nentries, mode_t *modep)
d831 1
a831 1
acltopbits32 (__aclent32_t *aclbufp, int nentries, mode_t *pbitsp)
d833 1
a833 1
  return acltomode32 (aclbufp, nentries, pbitsp);
d838 1
a838 1
aclfrompbits32 (__aclent32_t *aclbufp, int nentries, mode_t *pbitsp)
d840 1
a840 1
  return aclfrommode32 (aclbufp, nentries, pbitsp);
d857 1
a857 1
acltotext32 (__aclent32_t *aclbufp, int aclcnt)
d860 1
a860 1
      || aclcheck32 (aclbufp, aclcnt, NULL))
d933 2
a934 2
__aclent32_t *
aclfromtext32 (char *acltextp, int *)
d942 1
a942 1
  __aclent32_t lacl[MAX_ACL_ENTRIES];
d973 1
a973 1
		  c = strechr (c, ':');
d977 1
a977 1
	      if (*c != ':')
d1001 1
a1001 1
		  c = strechr (c, ':');
d1005 1
a1005 1
	      if (*c != ':')
d1039 1
a1039 1
  __aclent32_t *aclp = (__aclent32_t *) malloc (pos * sizeof (__aclent32_t));
d1041 1
a1041 1
    memcpy (aclp, lacl, pos * sizeof (__aclent32_t));
a1044 88
/* __aclent16_t and __aclent32_t have same size and same member offsets */
static __aclent32_t *
acl16to32 (__aclent16_t *aclbufp, int nentries)
{
  __aclent32_t *aclbufp32 = (__aclent32_t *) aclbufp;
  if (aclbufp32)
    for (int i = 0; i < nentries; i++)
      aclbufp32[i].a_id &= USHRT_MAX;
  return aclbufp32;
}

extern "C"
int
acl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
{
  return acl32 (path, cmd, nentries, acl16to32 (aclbufp, nentries));
}

extern "C"
int
facl (int fd, int cmd, int nentries, __aclent16_t *aclbufp)
{
  return facl32 (fd, cmd, nentries, acl16to32 (aclbufp, nentries));
}

extern "C"
int
lacl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
{
  return lacl32 (path, cmd, nentries, acl16to32 (aclbufp, nentries));
}

extern "C"
int
aclcheck (__aclent16_t *aclbufp, int nentries, int *which)
{
  return aclcheck32 (acl16to32 (aclbufp, nentries), nentries, which);
}

extern "C"
int
aclsort (int nentries, int i, __aclent16_t *aclbufp)
{
  return aclsort32 (nentries, i, acl16to32 (aclbufp, nentries));
}


extern "C"
int
acltomode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
{
  return acltomode32 (acl16to32 (aclbufp, nentries), nentries, modep);
}

extern "C"
int
aclfrommode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
{
  return aclfrommode32 ((__aclent32_t *)aclbufp, nentries, modep);
}

extern "C"
int
acltopbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return acltopbits32 (acl16to32 (aclbufp, nentries), nentries, pbitsp);
}

extern "C"
int
aclfrompbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return aclfrompbits32 ((__aclent32_t *)aclbufp, nentries, pbitsp);
}

extern "C"
char *
acltotext (__aclent16_t *aclbufp, int aclcnt)
{
  return acltotext32 (acl16to32 (aclbufp, aclcnt), aclcnt);
}

extern "C"
__aclent16_t *
aclfromtext (char *acltextp, int * aclcnt)
{
  return (__aclent16_t *) aclfromtext32 (acltextp, aclcnt);
}
@


1.24.2.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d28 1
a29 1
#include "fhandler.h"
@


1.24.2.4
log
@merge from trunk
@
text
@d416 63
@


1.24.2.5
log
@merge from trunk
@
text
@d129 1
a129 1
	{
d416 2
a417 1
static int
d496 2
a497 1
extern "C" int
d503 2
a504 1
extern "C" int
d510 2
a511 1
extern "C" int
d531 2
a532 1
extern "C" int
d664 2
a665 2
static int
acecmp (const void *a1, const void *a2)
d675 2
a676 1
extern "C" int
d690 2
a691 1
extern "C" int
d730 2
a731 1
extern "C" int
d768 2
a769 1
extern "C" int
d775 2
a776 1
extern "C" int
d794 2
a795 1
extern "C" char *
d871 2
a872 1
extern "C" __aclent32_t *
d995 2
a996 1
extern "C" int
d1002 2
a1003 1
extern "C" int
d1009 2
a1010 1
extern "C" int
d1016 2
a1017 1
extern "C" int
d1023 2
a1024 1
extern "C" int
d1031 2
a1032 1
extern "C" int
d1038 2
a1039 1
extern "C" int
d1045 2
a1046 1
extern "C" int
d1052 2
a1053 1
extern "C" int
d1059 2
a1060 1
extern "C" char *
d1066 2
a1067 1
extern "C" __aclent16_t *
@


1.24.2.6
log
@merge from trunk
@
text
@d122 2
a123 1
	allow = STANDARD_RIGHTS_ALL | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA;
d129 6
a134 1
	allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE;
@


1.24.2.7
log
@merge from trunk
@
text
@d18 1
@


1.23
log
@whitespace
@
text
@d1 1
a1 1
/* secacl.cc: Sun compatible ACL functions.
d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc.
d44 1
a44 1
    if ((aclp[i].a_type == type && (id < 0 || aclp[i].a_id == id))
d140 2
a141 1
	  && (pos = searchace (aclbufp, nentries,
a144 1
	  && aclbufp[pos].a_type
d148 2
a149 2
	  /* This eliminates the corresponding default entry. */
	  aclbufp[pos].a_type = 0;
d154 5
d162 1
a162 1
					owner, acl_len, inheritance))
d174 4
d180 1
a180 1
					group, acl_len, inheritance))
d348 10
d374 1
a374 1
	  if (!(ace->Header.AceFlags & INHERIT_ONLY))
d382 4
d501 4
a504 2
	  if (nentries < 1)
	    set_errno (EINVAL);
d508 13
a520 30
	      __aclent16_t lacl[4];
	      if (nentries > 0)
		{
		  lacl[0].a_type = USER_OBJ;
		  lacl[0].a_id = st.st_uid;
		  lacl[0].a_perm = (st.st_mode & S_IRWXU) >> 6;
		}
	      if (nentries > 1)
		{
		  lacl[1].a_type = GROUP_OBJ;
		  lacl[1].a_id = st.st_gid;
		  lacl[1].a_perm = (st.st_mode & S_IRWXG) >> 3;
		}
	      if (nentries > 2)
		{
		  lacl[2].a_type = OTHER_OBJ;
		  lacl[2].a_id = ILLEGAL_GID;
		  lacl[2].a_perm = st.st_mode & S_IRWXO;
		}
	      if (nentries > 3)
		{
		  lacl[3].a_type = CLASS_OBJ;
		  lacl[3].a_id = ILLEGAL_GID;
		  lacl[3].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
		}
	      if (nentries > 4)
		nentries = 4;
	      if (aclbufp)
		memcpy (aclbufp, lacl, nentries * sizeof (__aclent16_t));
	      ret = nentries;
d524 1
a524 1
	  ret = 4;
d538 7
a544 5
	if (nentries < 1)
	  break;
	return getacl (real_path.get_win32 (),
		       real_path.file_attributes (),
		       nentries, aclbufp);
d550 1
a552 1
  set_errno (EINVAL);
@


1.22
log
@2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* pwdgrp.h (pwdgrp_check::pwdgrp_state): Replace by
	pwdgrp_check::isinitializing ().
	(pwdgrp_check::isinitializing): Create.
	* passwd.cc (grab_int): Change type to unsigned, use strtoul and
	set the pointer content to 0 if the field is invalid.
	(parse_pwd): Move validity test after getting pw_gid.
	(read_etc_passwd): Replace "passwd_state <= " by
	passwd_state::isinitializing ().
	(internal_getpwuid): Ditto.
	(internal_getpwnam): Ditto.
	(getpwent): Ditto.
	(getpass): Ditto.
	* grp.cc (parse_grp): Use strtoul for gr_gid and verify the validity.
	(read_etc_group): Replace "group_state <= " by
	group_state::isinitializing ().
	(internal_getgrgid): Ditto.
	(getgrent32): Ditto.
	(internal_getgrent): Ditto.

2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h: Move declarations of internal_getgrent,
	internal_getpwsid and internal_getgrsid to pwdgrp.h.
	* pwdgrp.h: Declare internal_getpwsid, internal_getpwnam,
	internal_getpwuid, internal_getgrsid, internal_getgrgid,
	internal_getgrnam, internal_getgrent and internal_getgroups.
	Delete "emulated" from enum pwdgrp_state.
	(pwdgrp_check::isuninitialized): Create.
	(pwdgrp_check::pwdgrp_state): Change state to initializing
	rather than to uninitialized.
	(pwdgrp_read::gets): Remove trailing CRs.
	* passwd.cc (grab_string): Don't look for NLs.
	(grab_int): Ditto.
	(parse_pwd): Don't look for CRs. Return 0 if entry is too short.
	(search_for): Delete.
	(read_etc_passwd): Simplify tests to actually read the file.
	Set state to loaded before making internal_getpwXX calls.
	Replace search_for calls by equivalent internal_pwgetXX calls.
	(internal_getpwsid): Use passwd_state.isuninitialized to decide
	to call read_etc_passwd.
	(internal_getpwuid): Create.
	(internal_getpwnam): Create.
	(getpwuid32): Simply call internal_getpwuid.
	(getpwuid_r32): Call internal_getpwuid.
	(getpwnam): Simply call internal_getpwnam.
	(getpwnam_r): Call internal_getpwnam.
	* grp.cc (parse_grp): Don't look for CRs. Adjust blank space.
	(add_grp_line): Adjust blank space.
	(class group_lock): Ditto.
	(read_etc_group): Simplify tests to actually read the file.
	Set state to loaded before making internal_getgrXX calls.
	Replace getgrXX calls by equivalent internal calls.
	(internal_getgrsid): Use group_state.isuninitialized to decide
	to call read_etc_group.
	(internal_getgrgid): Create.
	(internal_getgrnam): Create.
	(getgroups32): Simply call internal_getgrgid.
	(getgrnam32): Simply call internal_getgrnam.
	(internal_getgrent): Call group_state.isuninitialized.
	(internal_getgroups): Create from the former getgroups32, using
	two of the four arguments. Set gid to myself->gid and username
	to cygheap->user.name ().
	(getgroups32): Simply call internal_getgroup.
	(getgroups): Call internal_getgroup instead of getgroups32.
	(setgroups32): Call internal versions of get{pw,gr}XX.
	* sec_helper.cc: Include pwdgrp.h.
	(is_grp_member): Call internal versions of get{pw,gr}XX.
	* security.cc: Include pwdgrp.h.
	(alloc_sd): Call internal versions of get{pw,gr}XX.
	* syscalls.cc: Include pwdgrp.h.
	(seteuid32): Call internal versions of get{pw,gr}XX.
	(setegid32): Ditto.
	* uinfo.cc: Include pwdgrp.h.
	(internal_getlogin): Call internal versions of get{pw,gr}XX.
	(cygheap_user::ontherange): Ditto.
	* sec_acl.cc: Include pwdgrp.h.
	(setacl): Call internal versions of get{pw,gr}XX.
	(acl_access): Ditto and simplify logic.
	(aclfromtext): Ditto.
@
text
@d316 1
a316 1
	  
d370 1
a370 1
      if ((types_def & (USER|GROUP)) 
d381 1
a381 1
    if (EqualSid (owner_sid, group_sid)) 
@


1.21
log
@	* sec_acl.cc (getacl): Set errno to ENOSPC if command is GETACL and
	nentries is less than the number of entries in the file's ACL.
@
text
@d33 1
d162 1
a162 1
	  if (!(pw = getpwuid32 (aclbufp[i].a_id))
d176 1
a176 1
	  if (!(gr = getgrgid32 (aclbufp[i].a_id))
a422 1
	      cygsid group;
d426 6
a431 11
	      if ((pw = getpwuid32 (acls[i].a_id)) != NULL
		  && owner.getfrompw (pw))
		{
		  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
		    if (group.getfromgr (gr)
			&& owner == group
			&& is_grp_member (myself->uid, gr->gr_gid))
		      break;
		}
	      if (!gr)
		continue;
d956 1
a956 1
		  struct passwd *pw = getpwnam (c);
d984 1
a984 1
		  struct __group32 *gr = getgrnam32 (c);
@


1.20
log
@2002-11-24  Corinna Vinschen  <corinna@@vinschen.de>

	* sec_acl.cc: Fix some formatting.  Only set and check `other' bits in
	a_perm throughout.  Use ILLEGAL_GID id for all entries having no id.
	(setacl): Fix inheritance condition.
	(getacl): Set all permission bits in CLASS_OBJ and DEF_CLASS_OBJ
	entries.  Remove DENY bits before returning to calling function.
	(acltomode): Fix usage of searchace().  If available, use CLASS_OBJ
	to mask GROUP_OBJ permissions.
	(aclfrommode): Fix usage of searchace().  If available, set CLASS_OBJ
	permissions to same value as GROUP_OBJ permissions.

2002-11-24  Pierre Humblet <pierre.humblet@@ieee.org>

	* sec_acl.cc (getace): Fix the behavior when allow and
	deny entries are present in arbitrary order.
	(getacl): Report the actual number of entries when
	aclbufp is NULL, even if nentries is zero. Fix the mask
	reporting, handle the case where the owner and group sids
	are equal and streamline the code.
	(acl_worker): Take allow_ntsec into account.
@
text
@d383 4
a386 1
      pos = nentries;
@


1.19
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d143 1
a143 1
	  && pos < nentries
d216 5
d222 2
a223 1
getace (__aclent16_t &acl, int type, int id, DWORD win_ace_mask, DWORD win_ace_type)
d228 1
a228 1
  if (win_ace_mask & FILE_READ_DATA)
d230 1
a230 1
      acl.a_perm |= (acl.a_perm & S_IRGRP) ? 0 : S_IRUSR;
d232 1
a232 1
      acl.a_perm &= ~S_IRGRP;
d234 1
a234 1
  if (win_ace_mask & FILE_WRITE_DATA)
d236 1
a236 1
      acl.a_perm |= (acl.a_perm & S_IWGRP) ? 0 : S_IWUSR;
d238 1
a238 1
      acl.a_perm &= ~S_IWGRP;
d240 1
a240 1
  if (win_ace_mask & FILE_EXECUTE)
d242 1
a242 1
      acl.a_perm |= (acl.a_perm & S_IXGRP) ? 0 : S_IXUSR;
d244 1
a244 1
      acl.a_perm &= ~S_IXGRP;
d290 4
d305 1
a305 1
  int pos, i;
d308 10
a317 7
    {
      for (pos = 0; pos < MIN_ACL_ENTRIES; ++pos)
	lacl[pos].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
      pos = nentries < MIN_ACL_ENTRIES ? nentries : MIN_ACL_ENTRIES;
      memcpy (aclbufp, lacl, pos * sizeof (__aclent16_t));
      return pos;
    }
d319 3
a321 3
  for (i = 0; i < acl->AceCount && (!nentries || i < nentries); ++i)
    {
      ACCESS_ALLOWED_ACE *ace;
d323 16
a338 26
      if (!GetAce (acl, i, (PVOID *) &ace))
	continue;

      cygsid ace_sid ((PSID) &ace->SidStart);
      int id;
      int type = 0;

      if (ace_sid == well_known_world_sid)
	{
	  type = OTHER_OBJ;
	  id = 0;
	}
      else if (ace_sid == owner_sid)
	{
	  type = USER_OBJ;
	  id = uid;
	}
      else if (ace_sid == group_sid)
	{
	  type = GROUP_OBJ;
	  id = gid;
	}
      else
	{
	  id = ace_sid.get_id (FALSE, &type);
	  if (type != GROUP)
d340 2
a341 3
	      int type2 = 0;
	      int id2 = ace_sid.get_id (TRUE, &type2);
	      if (type2 == GROUP)
d343 7
a349 2
		  id = id2;
		  type = GROUP;
d352 15
d368 7
a374 13
      if (!type)
	continue;
      if (!(ace->Header.AceFlags & INHERIT_ONLY))
	{
	  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
	    getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
	}
      if ((ace->Header.AceFlags & SUB_CONTAINERS_AND_OBJECTS_INHERIT)
	  && (attr & FILE_ATTRIBUTE_DIRECTORY))
	{
	  type |= ACL_DEFAULT;
	  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
	    getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
d379 5
a383 30
  for (i = 0; i < pos; ++i)
    {
      lacl[i].a_perm = (lacl[i].a_perm & S_IRWXU)
		       & ~((lacl[i].a_perm & S_IRWXG) << 3);
      lacl[i].a_perm |= (lacl[i].a_perm & S_IRWXU) >> 3
			| (lacl[i].a_perm & S_IRWXU) >> 6;
    }
  if ((searchace (lacl, MAX_ACL_ENTRIES, USER) >= 0
       || searchace (lacl, MAX_ACL_ENTRIES, GROUP) >= 0)
      && (pos = searchace (lacl, MAX_ACL_ENTRIES, CLASS_OBJ)) >= 0)
    {
      lacl[pos].a_type = CLASS_OBJ;
      lacl[pos].a_perm =
	  lacl[searchace (lacl, MAX_ACL_ENTRIES, GROUP_OBJ)].a_perm;
    }
  int dgpos;
  if ((searchace (lacl, MAX_ACL_ENTRIES, DEF_USER) >= 0
       || searchace (lacl, MAX_ACL_ENTRIES, DEF_GROUP) >= 0)
      && (dgpos = searchace (lacl, MAX_ACL_ENTRIES, DEF_GROUP_OBJ)) >= 0
      && (pos = searchace (lacl, MAX_ACL_ENTRIES, DEF_CLASS_OBJ)) >= 0
      && (attr & FILE_ATTRIBUTE_DIRECTORY))
    {
      lacl[pos].a_type = DEF_CLASS_OBJ;
      lacl[pos].a_perm = lacl[dgpos].a_perm;
    }
  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) < 0)
    pos = MAX_ACL_ENTRIES;
  if (pos > nentries)
    pos = nentries;
  if (aclbufp)
d385 4
a388 1
  aclsort (pos, 0, aclbufp);
d403 1
a403 1
  if (!(flags & (R_OK|W_OK|X_OK)))
d447 3
a449 3
      if ((!(flags & R_OK) || (acls[i].a_perm & S_IREAD))
	  && (!(flags & W_OK) || (acls[i].a_perm & S_IWRITE))
	  && (!(flags & X_OK) || (acls[i].a_perm & S_IEXEC)))
d469 1
a469 1
  if (!real_path.has_acls ())
d490 1
a490 3
		  lacl[0].a_perm = (st.st_mode & S_IRWXU)
				   | (st.st_mode & S_IRWXU) >> 3
				   | (st.st_mode & S_IRWXU) >> 6;
d496 1
a496 3
		  lacl[1].a_perm = (st.st_mode & S_IRWXG)
				   | (st.st_mode & S_IRWXG) << 3
				   | (st.st_mode & S_IRWXG) >> 3;
d501 2
a502 4
		  lacl[2].a_id = 0;
		  lacl[2].a_perm = (st.st_mode & S_IRWXO)
				   | (st.st_mode & S_IRWXO) << 6
				   | (st.st_mode & S_IRWXO) << 3;
d507 2
a508 4
		  lacl[3].a_id = 0;
		  lacl[3].a_perm = (st.st_mode & S_IRWXG)
				   | (st.st_mode & S_IRWXG) << 3
				   | (st.st_mode & S_IRWXG) >> 3;
d755 2
a756 1
  if ((pos = searchace (aclbufp, nentries, USER_OBJ)) < 0)
d761 3
a763 2
  *modep |= aclbufp[pos].a_perm & S_IRWXU;
  if ((pos = searchace (aclbufp, nentries, GROUP_OBJ)) < 0)
d768 7
a774 4
  if (searchace (aclbufp, nentries, CLASS_OBJ) < 0)
    pos = searchace (aclbufp, nentries, CLASS_OBJ);
  *modep |= (aclbufp[pos].a_perm & S_IRWXU) >> 3;
  if ((pos = searchace (aclbufp, nentries, OTHER_OBJ)) < 0)
d779 1
a779 1
  *modep |= (aclbufp[pos].a_perm & S_IRWXU) >> 6;
d794 2
a795 1
  if ((pos = searchace (aclbufp, nentries, USER_OBJ)) < 0)
d800 3
a802 4
  aclbufp[pos].a_perm = (*modep & S_IRWXU)
			| (*modep & S_IRWXU) >> 3
			| (*modep & S_IRWXU) >> 6;
  if ((pos = searchace (aclbufp, nentries, GROUP_OBJ)) < 0)
d807 6
a812 6
  if (searchace (aclbufp, nentries, CLASS_OBJ) < 0)
    pos = searchace (aclbufp, nentries, CLASS_OBJ);
  aclbufp[pos].a_perm = (*modep & S_IRWXG)
			| (*modep & S_IRWXG) << 3
			| (*modep & S_IRWXG) >> 3;
  if ((pos = searchace (aclbufp, nentries, OTHER_OBJ)) < 0)
d817 1
a817 3
  aclbufp[pos].a_perm = (*modep & S_IRWXO)
			| (*modep & S_IRWXO) << 6
			| (*modep & S_IRWXO) << 3;
d840 3
a842 3
  pbuf[0] = (perm & S_IREAD) ? 'r' : '-';
  pbuf[1] = (perm & S_IWRITE) ? 'w' : '-';
  pbuf[2] = (perm & S_IEXEC) ? 'x' : '-';
d910 1
a910 1
    mode |= S_IRUSR | S_IRGRP | S_IROTH;
d914 1
a914 1
    mode |= S_IWUSR | S_IWGRP | S_IWOTH;
d918 1
a918 1
    mode |= S_IXUSR | S_IXGRP | S_IXOTH;
@


1.18
log
@	* sec_acl.cc (getacl): Check ace_sid == well_known_world_sid
	before owner_sid and group_sid so that well_known_world_sid
	means "other" even when owner_sid and/or group_sid are Everyone.
	* security.cc (get_attribute_from_acl): Created from code common
	to get_nt_attribute() and get_nt_object_attribute(), with same
	reordering as in getacl() above.
	(get_nt_attribute): Call get_attribute_from_acl().
	(get_nt_object_attribute): Ditto.
@
text
@d89 1
a89 1
  if (!SetSecurityDescriptorOwner(&sd, owner, FALSE))
d95 1
a95 1
      && !SetSecurityDescriptorGroup(&sd, group, FALSE))
d541 1
a541 1
	if (!aclsort(nentries, 0, aclbufp))
d735 1
a735 1
  int ret = ace(1)->a_type - ace(2)->a_type;
d737 1
a737 1
    ret = ace(1)->a_id - ace(2)->a_id;
d753 1
a753 1
  qsort((void *) aclbufp, nentries, sizeof (__aclent16_t), acecmp);
d794 1
a794 1
aclfrommode(__aclent16_t *aclbufp, int nentries, mode_t *modep)
@


1.17
log
@	* security.h (DONT_INHERIT): Eliminate definition.
	(INHERIT_ALL): Ditto.
	(INHERIT_ONLY): Ditto.
	* sec_acl.cc: Use appropriate defines from accctrl.h instead of the
	above throughout.
	* security.cc: Ditto.
@
text
@d317 6
a322 1
      if (ace_sid == owner_sid)
a330 5
	}
      else if (ace_sid == well_known_world_sid)
	{
	  type = OTHER_OBJ;
	  id = 0;
@


1.16
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d131 2
a132 1
			  ? INHERIT_ONLY : DONT_INHERIT;
d146 1
a146 1
	  inheritance = INHERIT_ALL;
d348 1
a348 1
      if (!(ace->Header.AceFlags & INHERIT_ONLY_ACE))
d353 1
a353 1
      if ((ace->Header.AceFlags & INHERIT_ALL)
@


1.15
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@a30 1
#include "sigproc.h"
@


1.14
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@d161 1
a161 1
	  if (!(pw = getpwuid (aclbufp[i].a_id))
d258 1
a258 1
  __uid16_t uid;
d429 1
a429 1
	      if ((pw = getpwuid (acls[i].a_id)) != NULL
@


1.13
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d110 1
a110 1
  struct __group16 *gr;
d175 1
a175 1
	  if (!(gr = getgrgid (aclbufp[i].a_id))
d259 1
a259 1
  __gid16_t gid;
d427 1
a427 1
	      struct __group16 *gr = NULL;
d997 1
a997 1
		  struct __group16 *gr = getgrnam (c);
@


1.12
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@a26 1
#include "perprocess.h"
a30 1
#include "sync.h"
@


1.11
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d479 1
a479 1
      struct stat st;
d490 2
a491 2
	  else if ((nofollow && !lstat (path, &st))
		   || (!nofollow && !stat (path, &st)))
@


1.10
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Red Hat, Inc.
@


1.9
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d37 3
d41 1
a41 1
searchace (aclent_t *aclp, int nentries, int type, int id = -1)
d53 1
a53 1
setacl (const char *file, int nentries, aclent_t *aclbufp)
d112 1
a112 1
  struct group *gr;
d219 1
a219 1
getace (aclent_t &acl, int type, int id, DWORD win_ace_mask, DWORD win_ace_type)
d244 1
a244 1
getacl (const char *file, DWORD attr, int nentries, aclent_t *aclbufp)
d260 2
a261 2
  uid_t uid;
  gid_t gid;
d279 2
a280 2
  aclent_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (aclent_t));
d304 1
a304 1
      memcpy (aclbufp, lacl, pos * sizeof (aclent_t));
d395 1
a395 1
    memcpy (aclbufp, lacl, pos * sizeof (aclent_t));
d404 1
a404 1
  aclent_t acls[MAX_ACL_ENTRIES];
d429 1
a429 1
	      struct group *gr = NULL;
d466 1
a466 1
acl_worker (const char *path, int cmd, int nentries, aclent_t *aclbufp,
d493 1
a493 1
	      aclent_t lacl[4];
d529 1
a529 1
		memcpy (aclbufp, lacl, nentries * sizeof (aclent_t));
d567 1
a567 1
acl (const char *path, int cmd, int nentries, aclent_t *aclbufp)
d574 1
a574 1
lacl (const char *path, int cmd, int nentries, aclent_t *aclbufp)
d581 1
a581 1
facl (int fd, int cmd, int nentries, aclent_t *aclbufp)
d602 1
a602 1
aclcheck (aclent_t *aclbufp, int nentries, int *which)
d736 1
a736 1
#define ace(i) ((const aclent_t *) a##i)
d746 1
a746 1
aclsort (int nentries, int, aclent_t *aclbufp)
d755 1
a755 1
  qsort((void *) aclbufp, nentries, sizeof (aclent_t), acecmp);
d761 1
a761 1
acltomode (aclent_t *aclbufp, int nentries, mode_t *modep)
d796 1
a796 1
aclfrommode(aclent_t *aclbufp, int nentries, mode_t *modep)
d836 1
a836 1
acltopbits (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
d843 1
a843 1
aclfrompbits (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
d862 1
a862 1
acltotext (aclent_t *aclbufp, int aclcnt)
d938 1
a938 1
aclent_t *
d947 1
a947 1
  aclent_t lacl[MAX_ACL_ENTRIES];
d999 1
a999 1
		  struct group *gr = getgrnam (c);
d1044 1
a1044 1
  aclent_t *aclp = (aclent_t *) malloc (pos * sizeof (aclent_t));
d1046 1
a1046 1
    memcpy (aclp, lacl, pos * sizeof (aclent_t));
@


1.8
log
@Update copyrights.
@
text
@d580 2
a581 1
  if (cygheap->fdtab.not_open (fd))
a583 1
      set_errno (EBADF);
d586 1
a586 1
  const char *path = cygheap->fdtab[fd]->get_name ();
@


1.8.4.1
log
@Merged changes from HEAD
@
text
@d580 1
a580 2
  cygheap_fdget cfd (fd);
  if (cfd < 0)
d583 1
d586 1
a586 1
  const char *path = cfd->get_name ();
@


1.8.4.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc.
a36 3
extern "C" int aclsort (int nentries, int, __aclent16_t *aclbufp);
extern "C" int acl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp);

d38 1
a38 1
searchace (__aclent16_t *aclp, int nentries, int type, int id = -1)
d50 1
a50 1
setacl (const char *file, int nentries, __aclent16_t *aclbufp)
d109 1
a109 1
  struct __group16 *gr;
d216 1
a216 1
getace (__aclent16_t &acl, int type, int id, DWORD win_ace_mask, DWORD win_ace_type)
d241 1
a241 1
getacl (const char *file, DWORD attr, int nentries, __aclent16_t *aclbufp)
d257 2
a258 2
  __uid16_t uid;
  __gid16_t gid;
d276 2
a277 2
  __aclent16_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (__aclent16_t));
d301 1
a301 1
      memcpy (aclbufp, lacl, pos * sizeof (__aclent16_t));
d392 1
a392 1
    memcpy (aclbufp, lacl, pos * sizeof (__aclent16_t));
d401 1
a401 1
  __aclent16_t acls[MAX_ACL_ENTRIES];
d426 1
a426 1
	      struct __group16 *gr = NULL;
d463 1
a463 1
acl_worker (const char *path, int cmd, int nentries, __aclent16_t *aclbufp,
d476 1
a476 1
      struct __stat64 st;
d487 2
a488 2
	  else if ((nofollow && !lstat64 (path, &st))
		   || (!nofollow && !stat64 (path, &st)))
d490 1
a490 1
	      __aclent16_t lacl[4];
d526 1
a526 1
		memcpy (aclbufp, lacl, nentries * sizeof (__aclent16_t));
d564 1
a564 1
acl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
d571 1
a571 1
lacl (const char *path, int cmd, int nentries, __aclent16_t *aclbufp)
d578 1
a578 1
facl (int fd, int cmd, int nentries, __aclent16_t *aclbufp)
d599 1
a599 1
aclcheck (__aclent16_t *aclbufp, int nentries, int *which)
d733 1
a733 1
#define ace(i) ((const __aclent16_t *) a##i)
d743 1
a743 1
aclsort (int nentries, int, __aclent16_t *aclbufp)
d752 1
a752 1
  qsort((void *) aclbufp, nentries, sizeof (__aclent16_t), acecmp);
d758 1
a758 1
acltomode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
d793 1
a793 1
aclfrommode(__aclent16_t *aclbufp, int nentries, mode_t *modep)
d833 1
a833 1
acltopbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
d840 1
a840 1
aclfrompbits (__aclent16_t *aclbufp, int nentries, mode_t *pbitsp)
d859 1
a859 1
acltotext (__aclent16_t *aclbufp, int aclcnt)
d935 1
a935 1
__aclent16_t *
d944 1
a944 1
  __aclent16_t lacl[MAX_ACL_ENTRIES];
d996 1
a996 1
		  struct __group16 *gr = getgrnam (c);
d1041 1
a1041 1
  __aclent16_t *aclp = (__aclent16_t *) malloc (pos * sizeof (__aclent16_t));
d1043 1
a1043 1
    memcpy (aclp, lacl, pos * sizeof (__aclent16_t));
@


1.8.4.3
log
@Merged changes from HEAD
@
text
@d27 1
d32 2
d112 1
a112 1
  struct __group32 *gr;
d163 1
a163 1
	  if (!(pw = getpwuid32 (aclbufp[i].a_id))
d177 1
a177 1
	  if (!(gr = getgrgid32 (aclbufp[i].a_id))
d260 2
a261 2
  __uid32_t uid;
  __gid32_t gid;
d429 1
a429 1
	      struct __group32 *gr = NULL;
d431 1
a431 1
	      if ((pw = getpwuid32 (acls[i].a_id)) != NULL
d999 1
a999 1
		  struct __group32 *gr = getgrnam32 (c);
@


1.8.4.4
log
@Merged changes from HEAD
@
text
@d131 1
a131 2
			  ? (SUB_CONTAINERS_AND_OBJECTS_INHERIT | INHERIT_ONLY)
			  : NO_INHERITANCE;
d145 1
a145 1
	  inheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
d347 1
a347 1
      if (!(ace->Header.AceFlags & INHERIT_ONLY))
d352 1
a352 1
      if ((ace->Header.AceFlags & SUB_CONTAINERS_AND_OBJECTS_INHERIT)
@


1.8.4.5
log
@Merged changes from HEAD
@
text
@d317 1
a317 6
      if (ace_sid == well_known_world_sid)
	{
	  type = OTHER_OBJ;
	  id = 0;
	}
      else if (ace_sid == owner_sid)
d326 5
@


1.8.4.6
log
@Merged changes from HEAD
@
text
@d89 1
a89 1
  if (!SetSecurityDescriptorOwner (&sd, owner, FALSE))
d95 1
a95 1
      && !SetSecurityDescriptorGroup (&sd, group, FALSE))
d541 1
a541 1
	if (!aclsort (nentries, 0, aclbufp))
d735 1
a735 1
  int ret = ace (1)->a_type - ace (2)->a_type;
d737 1
a737 1
    ret = ace (1)->a_id - ace (2)->a_id;
d753 1
a753 1
  qsort ((void *) aclbufp, nentries, sizeof (__aclent16_t), acecmp);
d794 1
a794 1
aclfrommode (__aclent16_t *aclbufp, int nentries, mode_t *modep)
@


1.7
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Cygnus Solutions.
@


1.6
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d128 1
a128 1
        allow |= FILE_DELETE_CHILD;
d436 1
a436 1
	        }
@


1.5
log
@        Change well_known_admin_sid to well_known_admins_sid throughout.
        * sec_acl.cc (setacl): Never set DELETE permission. Set
        FILE_DELETE_CHILD only on readable and executable directories.
        * sec_helper.cc: Add constructor for `well_known_null_sid'.
        * security.cc (get_nt_attribute): Set S_ISVTX for directories if
        FILE_WRITE_DATA and FILE_EXECUTE but not FILE_DELETE_CHILD is set.
        Add evaluation of S_ISVTX, S_ISGID and S_ISUID from NULL ACE.
        (alloc_sd): Never set DELETE permission. Set FILE_DELETE_CHILD
        only on readable and executable directories.
        Add creation of NULL ACE for S_ISVTX, S_ISGID and S_ISUID permissions.
        * security.h: Add extern declaration for `well_known_null_sid'.
@
text
@d28 1
a35 1
#include "security.h"
@


1.4
log
@forced commit
@
text
@d124 1
a124 2
	allow |= STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE
		 | DELETE | FILE_DELETE_CHILD;
d127 2
@


1.3
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@@


1.2
log
@        * autoload.cc: Add LoadDLLfunc statements for SetTokenInformation@@16.
        * cygheap.cc: Include security.h.
        * grp.cc (internal_getgrent): New function.
        (getgroups): Rearranged using `internal_getgrent' and the new
        `cygsid' class.
        * passwd.cc (internal_getpwent): New function.
        * sec_acl.cc: Use new `cygsid' class throughout.
        (acl_access): Use `internal_getgrent' instead of `getgrent'.
        * sec_helper.cc: Use new `cygsid' class throughout.
        (get_id_from_sid): Use `internal_getgrent' instead of `getgrent'.
        Use `internal_getpwent' instead of `getpwent'.
        * security.cc: Use new `cygsid' class throughout.
        * security.h: Move `MAX_SID_LEN' from winsup.h to here.
        Add extern declarations for `internal_getgrent' and `internal_getpwent'.
        (class cygsid): New class.
        * shared.cc (sec_user): Use new `cygsid' class.
        * syscalls.cc (seteuid): Try to set owner to user and primary group to
        current group in impersonation token before performing impersonation.
        (setegid): Try to set primary group in process token to the new group
        if ntsec is on.
        * uinfo.cc (internal_getlogin): Use new `cygsid' class.
        Try to set owner to user and primary group to current group in process
        token if the process has been started from a non cygwin process.
        (uinfo_init): Set primary group only if the process has been started
        from a non cygwin process.
        * winsup.h: Move define for `MAX_SID_LEN' to security.h.
@
text
@d160 1
a160 1
	      || !get_pw_sid (sid, pw)
d174 1
a174 1
	      || !get_gr_sid (sid, gr)
d182 2
a183 1
					get_world_sid(), acl_len, inheritance))
d265 1
a265 1
  uid = get_uid_from_sid (owner_sid);
d273 1
a273 1
  gid = get_gid_from_sid (group_sid);
d325 1
a325 1
      else if (ace_sid == get_world_sid ())
d332 1
a332 1
	  id = get_id_from_sid (ace_sid, FALSE, &type);
d336 1
a336 1
	      int id2 = get_id_from_sid (ace_sid, TRUE, &type2);
d428 1
a428 1
		  && get_pw_sid (owner, pw))
d431 1
a431 1
		    if (get_gr_sid (group, gr)
@


1.1
log
@        * Makefile.in: Add object files `sec_helper.cc' and `sec_acl.cc'.
        * security.cc: Swap out several functions.
        * sec_acl.cc: New file. Move Sun compatibel ACL functions from
        `security.cc' to here.
        * sec_helper.cc: New file. Move security helper functions from
        `security.cc' to here.
        * security.h: Changed to accomodate the above changes.

        * grp.cc: Replace `group_in_memory_p' by `group_state'.
        Eliminate group_sem throughout.
        (enum grp_state): New enumeration type.
        (read_etc_group): Make race safe.
        * security.cc: Eliminate group_sem throughout.
@
text
@d71 1
a71 7
  char owner_buf[MAX_SID_LEN];
  if (!CopySid (MAX_SID_LEN, (PSID) owner_buf, owner_sid))
    {
      __seterrno ();
      return -1;
    }
  owner_sid = (PSID) owner_buf;
d80 1
a80 7
  char group_buf[MAX_SID_LEN];
  if (!CopySid (MAX_SID_LEN, (PSID) group_buf, group_sid))
    {
      __seterrno ();
      return -1;
    }
  group_sid = (PSID) group_buf;
d89 1
a89 1
  if (!SetSecurityDescriptorOwner(&sd, owner_sid, FALSE))
d94 2
a95 2
  if (group_sid
      && !SetSecurityDescriptorGroup(&sd, group_sid, FALSE))
d107 1
a107 2
  char sidbuf[MAX_SID_LEN];
  PSID sid = (PSID) sidbuf;
d154 1
a154 1
					owner_sid, acl_len, inheritance))
d168 1
a168 1
					group_sid, acl_len, inheritance))
d310 1
a310 1
      PSID ace_sid = (PSID) &ace->SidStart;
d314 1
a314 1
      if (EqualSid (ace_sid, owner_sid))
d319 1
a319 1
      else if (EqualSid (ace_sid, group_sid))
d324 1
a324 1
      else if (EqualSid (ace_sid, get_world_sid ()))
d421 2
a422 4
	      char owner_sidbuf[MAX_SID_LEN];
	      PSID owner_sid = (PSID) owner_sidbuf;
	      char group_sidbuf[MAX_SID_LEN];
	      PSID group_sid = (PSID) group_sidbuf;
d427 1
a427 1
		  && get_pw_sid (owner_sid, pw))
d429 3
a431 3
		  while ((gr = getgrent ()))
		    if (get_gr_sid (group_sid, gr)
			&& EqualSid (owner_sid, group_sid)
d434 1
a434 2
		  endgrent ();
		}
@

