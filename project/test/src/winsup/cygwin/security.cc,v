head	1.277;
access;
symbols
	cygwin-1_7_35-release:1.277
	cygwin-1_7_34-release:1.271
	cygwin-1_7_33-release:1.265.2.1
	cygwin-1_7_32-release:1.265
	cygwin-1_7_31-release:1.265
	cygwin-1_7_30-release:1.265
	cygwin-1_7_29-release:1.265
	cygwin-1_7_29-release-branchpoint:1.265.0.2
	cygwin-pre-user-db:1.265
	cygwin-1_7_28-release:1.265
	cygwin-1_7_27-release:1.265
	cygwin-1_7_26-release:1.265
	cygwin-1_7_25-release:1.265
	cygwin-1_7_24-release:1.265
	cygwin-1_7_23-release:1.265
	cygwin-1_7_22-release:1.265
	cygwin-1_7_21-release:1.265
	cygwin-1_7_20-release:1.265
	cygwin-1_7_19-release:1.265
	cygwin-64bit-postmerge:1.265
	cygwin-64bit-premerge-branch:1.264.0.2
	cygwin-64bit-premerge:1.264
	cygwin-1_7_18-release:1.264
	post-ptmalloc3:1.263.2.4
	pre-ptmalloc3:1.263.2.4
	cygwin-1_7_17-release:1.263
	cygwin-64bit-branch:1.263.0.2
	cygwin-1_7_16-release:1.263
	cygwin-1_7_15-release:1.262
	cygwin-1_7_14_2-release:1.262
	cygwin-1_7_14-release:1.262
	cygwin-1_7_12-release:1.262
	cygwin-1_7_11-release:1.262
	cygwin-1_7_10-release:1.262
	signal-rewrite:1.261.0.2
	pre-notty:1.259
	cygwin-1_7_9-release:1.249
	cv-post-1_7_9:1.249.0.2
	cygwin-1_7_8-release:1.247
	cygwin-1_7_7-release:1.242
	cygwin-1_7_5-release:1.240
	cygwin-1_7_4-release:1.240
	cygwin-1_7_3-release:1.240
	cygwin-1_7_2-release:1.240
	fifo_doover3:1.239.0.2
	cygwin-1_7_1-release:1.239
	prefifo:1.234
	cv-branch-2:1.234.0.2
	pre-ripout-set_console_state_for_spawn:1.227
	EOL_registry_mounts:1.227
	preoverlapped:1.217
	drop_9x_support_start:1.214
	cr-0x5f1:1.194.0.4
	cv-branch:1.194.0.2
	pre-ptymaster-archetype:1.193
	cr-0x3b58:1.190.0.4
	cr-0x5ef:1.190.0.2
	after-mmap-privanon-noreserve:1.190
	after-mmap-revamp:1.190
	before-mmap-revamp:1.190
	cgf-more-exit-sync:1.190
	post_wait_sig_exit:1.190
	pre_wait_sig_exit:1.189
	reparent-point:1.178
	noreparent:1.178.0.2
	cr-0x5e6:1.171.0.2
	cr-0x9e:1.158.0.6
	cr-0x9d:1.158.0.4
	cgf-deleteme:1.158.0.2
	pre-sigrewrite:1.156
	corinna-01:1.154
	cr-0x9c:1.150.0.6
	cr-0x9b:1.150.0.4
	cr-0x99:1.150
	Z-emcb-cygwin_daemon:1.150.0.2
	w32api-2_2:1.136
	mingw-runtime-2_4:1.136
	pre-cgf-merge:1.151
	cgf-dev-branch:1.131.0.2
	predaemon:1.85
	cygwin_daemon_merge_HEAD:1.85
	pregp02r1:1.85.0.2
	cygnus_cvs_20020108_pre:1.80
	Z-cygwin_daemon_merge-new_HEAD:1.123
	Z-cygwin_daemon_merge_HEAD:1.123
	cygwin_daemon:1.74.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.277
date	2015.03.02.10.52.07;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2015.02.27.15.54.15;	author corinna;	state Exp;
branches;
next	1.275;

1.275
date	2015.02.27.12.59.09;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2015.02.25.17.18.13;	author corinna;	state Exp;
branches;
next	1.273;

1.273
date	2015.02.25.11.40.34;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2015.02.25.11.38.48;	author corinna;	state Exp;
branches;
next	1.271;

1.271
date	2014.08.28.12.38.52;	author corinna;	state Exp;
branches;
next	1.270;

1.270
date	2014.08.27.11.42.17;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2014.08.27.09.39.44;	author corinna;	state Exp;
branches;
next	1.268;

1.268
date	2014.08.26.20.47.46;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2014.03.03.12.03.47;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches
	1.265.2.1;
next	1.264;

1.264
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2012.06.03.16.46.53;	author corinna;	state Exp;
branches
	1.263.2.1;
next	1.262;

1.262
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2011.07.26.13.30.41;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2011.07.05.15.42.43;	author corinna;	state Exp;
branches;
next	1.259;

1.259
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2011.05.10.17.19.37;	author chrfranke;	state Exp;
branches;
next	1.257;

1.257
date	2011.04.29.10.38.12;	author corinna;	state Exp;
branches;
next	1.256;

1.256
date	2011.04.29.09.48.25;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2011.04.28.15.54.47;	author corinna;	state Exp;
branches;
next	1.254;

1.254
date	2011.04.28.09.53.11;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2011.04.28.09.30.36;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2011.04.28.08.34.49;	author corinna;	state Exp;
branches;
next	1.251;

1.251
date	2011.04.28.07.27.50;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2011.04.04.12.23.36;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2011.03.08.15.12.58;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2011.03.08.14.26.15;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2010.12.16.10.31.09;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2010.12.15.13.56.32;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2010.09.24.12.41.33;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2010.09.10.14.53.44;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2010.09.10.09.32.13;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2010.06.22.09.54.36;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2010.04.19.19.52.43;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2010.02.26.14.51.59;	author phumblet;	state Exp;
branches;
next	1.239;

1.239
date	2009.11.03.09.31.45;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2009.11.02.20.50.15;	author corinna;	state Exp;
branches;
next	1.237;

1.237
date	2009.10.30.19.58.53;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2009.10.24.08.26.01;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2009.09.25.13.44.45;	author ericb;	state Exp;
branches;
next	1.234;

1.234
date	2009.05.04.09.16.42;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2009.04.09.09.19.03;	author corinna;	state Exp;
branches;
next	1.232;

1.232
date	2009.02.04.15.26.22;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2008.10.13.16.01.50;	author corinna;	state Exp;
branches;
next	1.230;

1.230
date	2008.08.19.09.46.31;	author corinna;	state Exp;
branches;
next	1.229;

1.229
date	2008.08.14.14.05.04;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2008.07.14.20.22.03;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.226;

1.226
date	2007.09.18.14.36.29;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2007.08.16.14.46.23;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2007.07.30.10.58.16;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2007.07.20.14.29.43;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2007.07.19.17.42.11;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2007.07.19.09.06.54;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2007.07.19.08.33.22;	author corinna;	state Exp;
branches;
next	1.219;

1.219
date	2007.07.17.14.39.02;	author corinna;	state Exp;
branches;
next	1.218;

1.218
date	2007.07.16.20.01.15;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2007.03.02.19.54.20;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2007.03.01.15.13.47;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2007.02.23.15.15.49;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2006.12.20.17.14.23;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2006.12.13.09.53.42;	author corinna;	state Exp;
branches;
next	1.211;

1.211
date	2006.12.12.19.18.56;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2006.12.12.18.47.25;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2006.12.12.16.27.32;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2006.11.28.23.15.01;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2006.11.27.12.59.58;	author corinna;	state Exp;
branches;
next	1.206;

1.206
date	2006.11.09.15.24.34;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2006.11.08.11.38.05;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2006.11.01.09.00.14;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2006.10.22.19.31.33;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2006.10.22.14.57.43;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2006.10.21.11.05.32;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2006.10.16.12.26.59;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2006.10.13.11.10.28;	author corinna;	state Exp;
branches;
next	1.198;

1.198
date	2006.10.12.15.38.26;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2006.08.14.11.32.11;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2006.07.25.19.44.17;	author cgf;	state Exp;
branches;
next	1.195;

1.195
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2006.07.03.18.30.08;	author corinna;	state Exp;
branches
	1.194.2.1
	1.194.4.1;
next	1.193;

1.193
date	2006.02.07.15.49.08;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2006.02.02.11.35.52;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2006.02.02.11.22.10;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2005.09.14.14.27.55;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2005.08.12.02.39.12;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2005.08.08.16.30.15;	author corinna;	state Exp;
branches;
next	1.187;

1.187
date	2005.06.21.20.38.05;	author corinna;	state Exp;
branches;
next	1.186;

1.186
date	2005.06.08.10.06.17;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2005.06.07.19.31.40;	author corinna;	state Exp;
branches;
next	1.184;

1.184
date	2005.04.19.10.10.13;	author corinna;	state Exp;
branches;
next	1.183;

1.183
date	2005.04.16.15.21.46;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2005.04.13.16.41.33;	author corinna;	state Exp;
branches;
next	1.181;

1.181
date	2005.04.03.13.06.42;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2005.03.27.01.57.38;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2005.03.16.21.52.05;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2004.10.28.01.46.01;	author phumblet;	state Exp;
branches;
next	1.177;

1.177
date	2004.10.06.01.33.39;	author phumblet;	state Exp;
branches;
next	1.176;

1.176
date	2004.09.12.03.47.57;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2004.09.03.08.18.41;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2004.09.03.01.53.12;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2004.06.17.13.34.26;	author phumblet;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2004.04.14.20.16.29;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2004.04.14.16.36.26;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2004.04.14.13.40.07;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2004.04.14.10.20.25;	author corinna;	state Exp;
branches;
next	1.166;

1.166
date	2004.04.13.20.45.14;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2004.04.13.20.36.58;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2004.04.13.12.14.59;	author corinna;	state Exp;
branches;
next	1.163;

1.163
date	2004.04.09.07.55.56;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2004.04.08.07.57.28;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2004.02.11.17.54.34;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2004.02.05.17.23.19;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2003.12.07.22.37.12;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2003.12.03.16.35.52;	author corinna;	state Exp;
branches;
next	1.156;

1.156
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.155;

1.155
date	2003.11.26.10.52.21;	author corinna;	state Exp;
branches;
next	1.154;

1.154
date	2003.10.16.23.20.41;	author phumblet;	state Exp;
branches;
next	1.153;

1.153
date	2003.09.25.03.51.50;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2003.09.16.00.45.50;	author phumblet;	state Exp;
branches;
next	1.150;

1.150
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2003.07.18.02.14.42;	author phumblet;	state Exp;
branches;
next	1.148;

1.148
date	2003.07.14.17.04.21;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2003.07.02.03.16.00;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2003.04.11.09.38.07;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2003.04.01.17.17.46;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2003.03.27.09.40.25;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2003.03.19.21.34.38;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2003.03.10.16.25.48;	author corinna;	state Exp;
branches;
next	1.139;

1.139
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2003.02.21.14.29.18;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2003.02.10.22.43.29;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2003.02.05.16.15.22;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2003.02.05.13.47.47;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2003.02.04.19.26.01;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2003.02.03.15.55.19;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2003.01.12.11.38.51;	author corinna;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2003.01.09.11.44.17;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2002.12.14.16.57.25;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2002.12.10.12.43.49;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2002.11.20.09.23.20;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2002.10.22.16.22.10;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2002.09.30.04.35.18;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2002.09.30.03.05.13;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2002.09.11.10.37.11;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2002.08.26.09.56.06;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2002.08.02.11.00.18;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2002.07.29.12.51.52;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2002.07.25.17.04.13;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2002.07.23.14.34.27;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2002.07.19.23.48.17;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2002.07.19.15.04.18;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2002.07.15.09.06.44;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2002.07.02.09.02.53;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2002.07.02.08.11.15;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2002.07.02.01.36.15;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2002.07.01.02.36.04;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2002.06.30.13.08.59;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2002.06.24.13.01.50;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2002.06.21.12.57.19;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2002.06.21.12.37.51;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2002.06.21.05.01.16;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2002.06.19.15.27.25;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.13.05.30.49;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2002.06.11.02.08.00;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2002.06.06.11.17.50;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2002.06.03.17.04.03;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2002.06.02.06.07.01;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2002.05.29.15.04.27;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2002.05.28.14.57.37;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2002.05.28.14.10.51;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2002.05.27.11.58.49;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2002.05.24.14.44.05;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2002.05.21.14.50.26;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2002.05.17.09.32.45;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2002.05.16.09.30.47;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2002.04.18.09.11.54;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2002.03.07.14.32.53;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2002.02.19.05.58.44;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2002.01.23.18.35.03;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2002.01.19.16.06.11;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2001.12.30.17.38.24;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2001.12.29.22.03.32;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2001.11.05.06.09.08;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2001.11.03.21.19.50;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2001.10.30.00.02.36;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2001.10.16.14.53.26;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.09.06.03.39.18;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.08.31.19.48.34;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.15.10.21.39;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2001.08.08.10.00.35;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2001.08.07.16.14.59;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2001.08.07.15.09.54;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2001.08.02.16.01.47;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.27.09.17.57;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.18.12.56.26;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2001.07.15.22.40.07;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2001.07.09.09.02.41;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.05.10.45.52;	author duda;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.31.17.35.32;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.31.05.25.46;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.29.20.43.40;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.22.15.59.37;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.20.08.10.47;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.17.13.31.45;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.15.08.15.54;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.14.14.14.19;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2001.04.30.21.19.42;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2001.04.30.18.21.48;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.26.09.21.33;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.25.09.43.25;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.22.22.12.12;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.20.20.36.13;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.20.13.02.32;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.18.21.10.13;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.14.15.32.49;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.02.11.41.09;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.21.22.59.11;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.21.21.49.36;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.20.12.42.43;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.19.19.52.57;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.10.00.45.11;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.15.21.04.02;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.15.00.13.08;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.23.08.02.38;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.22.10.13.30;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.12.22.15.47;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.26.15.44.58;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.21.10.06.13;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.17.19.18.21;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.04.17.03.52;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.02.10.17.44;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.19.17.36.30;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.16.19.36.07;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.24.20.09.43;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.02.09.38.32;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.02.00.25.43;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.25.16.31.14;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.13.06.53.23;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.16.19.35.18;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.265.2.1
date	2014.11.13.12.53.05;	author corinna;	state Exp;
branches;
next	;

1.263.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.263.2.2;

1.263.2.2
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.263.2.3;

1.263.2.3
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.263.2.4;

1.263.2.4
date	2013.02.09.20.38.01;	author corinna;	state Exp;
branches;
next	;

1.194.2.1
date	2006.07.06.13.40.58;	author corinna;	state Exp;
branches;
next	1.194.2.2;

1.194.2.2
date	2006.07.14.13.03.11;	author corinna;	state Exp;
branches;
next	;

1.194.4.1
date	2006.10.16.12.46.34;	author corinna;	state Exp;
branches;
next	1.194.4.2;

1.194.4.2
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	;

1.131.2.1
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.131.2.2;

1.131.2.2
date	2003.02.05.14.25.10;	author cgf;	state Exp;
branches;
next	1.131.2.3;

1.131.2.3
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.131.2.4;

1.131.2.4
date	2003.02.11.03.13.09;	author cgf;	state Exp;
branches;
next	1.131.2.5;

1.131.2.5
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.131.2.6;

1.131.2.6
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.131.2.7;

1.131.2.7
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.131.2.8;

1.131.2.8
date	2003.03.19.19.59.55;	author cgf;	state Exp;
branches;
next	1.131.2.9;

1.131.2.9
date	2003.03.21.15.15.18;	author cgf;	state Exp;
branches;
next	1.131.2.10;

1.131.2.10
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.131.2.11;

1.131.2.11
date	2003.05.10.17.20.54;	author cgf;	state Exp;
branches;
next	1.131.2.12;

1.131.2.12
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.131.2.13;

1.131.2.13
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	;

1.74.2.1
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2002.01.22.04.52.40;	author rbcollins;	state Exp;
branches;
next	1.74.2.3;

1.74.2.3
date	2002.02.28.12.53.26;	author rbcollins;	state Exp;
branches;
next	1.74.2.4;

1.74.2.4
date	2002.06.13.14.34.10;	author rbcollins;	state Exp;
branches;
next	1.74.2.5;

1.74.2.5
date	2002.06.19.20.58.58;	author scottc;	state Exp;
branches;
next	1.74.2.6;

1.74.2.6
date	2002.06.21.12.18.51;	author scottc;	state Exp;
branches;
next	1.74.2.7;

1.74.2.7
date	2002.06.22.09.51.23;	author scottc;	state Exp;
branches;
next	1.74.2.8;

1.74.2.8
date	2002.06.25.10.50.38;	author scottc;	state Exp;
branches;
next	1.74.2.9;

1.74.2.9
date	2002.06.30.13.28.09;	author scottc;	state Exp;
branches;
next	1.74.2.10;

1.74.2.10
date	2002.07.01.13.53.39;	author scottc;	state Exp;
branches;
next	1.74.2.11;

1.74.2.11
date	2002.07.02.10.58.20;	author scottc;	state Exp;
branches;
next	1.74.2.12;

1.74.2.12
date	2002.07.23.03.19.14;	author scottc;	state Exp;
branches;
next	1.74.2.13;

1.74.2.13
date	2002.07.26.19.03.36;	author scottc;	state Exp;
branches;
next	1.74.2.14;

1.74.2.14
date	2002.07.30.13.31.46;	author scottc;	state Exp;
branches;
next	1.74.2.15;

1.74.2.15
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	1.74.2.16;

1.74.2.16
date	2002.08.26.11.38.14;	author scottc;	state Exp;
branches;
next	1.74.2.17;

1.74.2.17
date	2002.09.12.10.07.50;	author scottc;	state Exp;
branches;
next	1.74.2.18;

1.74.2.18
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.74.2.19;

1.74.2.19
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.277
log
@	* security.cc (get_attribute_from_acl): Don't spill Everyone permissions
	into group permissions if owner SID == group SID.
	(alloc_sd): Add parenthesis for clarity.
@
text
@/* security.cc: NT file access control functions

   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

   Originaly written by Gunther Ebert, gunther.ebert@@ixos-leipzig.de
   Completely rewritten by Corinna Vinschen <corinna@@vinschen.de>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <unistd.h>
#include <stdlib.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "pinfo.h"
#include "cygheap.h"
#include "ntdll.h"
#include "tls_pbuf.h"
#include <aclapi.h>

#define ALL_SECURITY_INFORMATION (DACL_SECURITY_INFORMATION \
				  | GROUP_SECURITY_INFORMATION \
				  | OWNER_SECURITY_INFORMATION)

static GENERIC_MAPPING NO_COPY_RO file_mapping = { FILE_GENERIC_READ,
						   FILE_GENERIC_WRITE,
						   FILE_GENERIC_EXECUTE,
						   FILE_ALL_ACCESS };

LONG
get_file_sd (HANDLE fh, path_conv &pc, security_descriptor &sd,
	     bool justcreated)
{
  NTSTATUS status = STATUS_SUCCESS;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  ULONG len = SD_MAXIMUM_SIZE, rlen;

  /* Allocate space for the security descriptor. */
  if (!sd.malloc (len))
    {
      set_errno (ENOMEM);
      return -1;
    }
  /* Try to fetch the security descriptor if the handle is valid. */
  if (fh)
    {
      status = NtQuerySecurityObject (fh, ALL_SECURITY_INFORMATION,
				      sd, len, &rlen);
      if (!NT_SUCCESS (status))
	debug_printf ("NtQuerySecurityObject (%S), status %y",
		      pc.get_nt_native_path (), status);
    }
  /* If the handle was NULL, or fetching with the original handle didn't work,
     try to reopen the file with READ_CONTROL and fetch the security descriptor
     using that handle. */
  if (!fh || !NT_SUCCESS (status))
    {
      status = NtOpenFile (&fh, READ_CONTROL,
			   fh ? pc.init_reopen_attr (attr, fh)
			      : pc.get_object_attr (attr, sec_none_nih),
			   &io, FILE_SHARE_VALID_FLAGS,
			   FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  sd.free ();
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      status = NtQuerySecurityObject (fh, ALL_SECURITY_INFORMATION,
				      sd, len, &rlen);
      NtClose (fh);
      if (!NT_SUCCESS (status))
	{
	  sd.free ();
	  __seterrno_from_nt_status (status);
	  return -1;
	}
    }
  /* Ok, so we have a security descriptor now.  Unfortunately, if you want
     to know if an ACE is inherited from the parent object, you can't just
     call NtQuerySecurityObject once.  The problem is this:

     In the simple case, the SDs control word contains one of the
     SE_DACL_AUTO_INHERITED or SE_DACL_PROTECTED flags, or at least one of
     the ACEs has the INHERITED_ACE flag set.  In all of these cases the
     GetSecurityInfo function calls NtQuerySecurityObject only once, too,
     apparently because it figures that the DACL is self-sufficient, which
     it usually is.  Windows Explorer, for instance, takes great care to
     set these flags in a security descriptor if you change the ACL in the
     GUI property dialog.

     The tricky case is if none of these flags is set in the SD.  That means
     the information whether or not an ACE has been inherited is not available
     in the DACL of the object.  In this case GetSecurityInfo also fetches the
     SD from the parent directory and tests if the object's SD contains
     inherited ACEs from the parent.  The below code is closly emulating the
     behaviour of GetSecurityInfo so we can get rid of this advapi32 dependency.

     However, this functionality is slow, and the extra information is only
     required when the file has been created and the permissions are about
     to be set to POSIX permissions.  Therefore we only use it in case the
     file just got created.

     Note that GetSecurityInfo has a problem on 5.1 and 5.2 kernels.  Sometimes
     it returns ERROR_INVALID_ADDRESS if a former request for the parent
     directories' SD used NtQuerySecurityObject, rather than GetSecurityInfo
     as well.  See http://cygwin.com/ml/cygwin-developers/2011-03/msg00027.html
     for the solution.  This problem does not occur with the below code, so
     the workaround has been removed. */
  if (justcreated)
    {
      SECURITY_DESCRIPTOR_CONTROL ctrl;
      ULONG dummy;
      PACL dacl;
      BOOLEAN exists, def;
      ACCESS_ALLOWED_ACE *ace;
      UNICODE_STRING dirname;
      PSECURITY_DESCRIPTOR psd, nsd;
      tmp_pathbuf tp;

      /* Check SDs control flags.  If SE_DACL_AUTO_INHERITED or
	 SE_DACL_PROTECTED is set we're done. */
      RtlGetControlSecurityDescriptor (sd, &ctrl, &dummy);
      if (ctrl & (SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED))
	return 0;
      /* Otherwise iterate over the ACEs and see if any one of them has the
	 INHERITED_ACE flag set.  If so, we're done. */
      if (NT_SUCCESS (RtlGetDaclSecurityDescriptor (sd, &exists, &dacl, &def))
	  && exists && dacl)
	for (ULONG idx = 0; idx < dacl->AceCount; ++idx)
	  if (NT_SUCCESS (RtlGetAce (dacl, idx, (PVOID *) &ace))
	      && (ace->Header.AceFlags & INHERITED_ACE))
	    return 0;
      /* Otherwise, open the parent directory with READ_CONTROL... */
      RtlSplitUnicodePath (pc.get_nt_native_path (), &dirname, NULL);
      InitializeObjectAttributes (&attr, &dirname, pc.objcaseinsensitive (),
				  NULL, NULL);
      status = NtOpenFile (&fh, READ_CONTROL, &attr, &io,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_OPEN_FOR_BACKUP_INTENT
			   | FILE_OPEN_REPARSE_POINT);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtOpenFile (%S), status %y", &dirname, status);
	  return 0;
	}
      /* ... fetch the parent's security descriptor ... */
      psd = (PSECURITY_DESCRIPTOR) tp.w_get ();
      status = NtQuerySecurityObject (fh, ALL_SECURITY_INFORMATION,
				      psd, len, &rlen);
      NtClose (fh);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtQuerySecurityObject (%S), status %y",
			&dirname, status);
	  return 0;
	}
      /* ... and create a new security descriptor in which all inherited ACEs
	 are marked with the INHERITED_ACE flag.  For a description of the
	 undocumented RtlConvertToAutoInheritSecurityObject function from
	 ntdll.dll see the MSDN man page for the advapi32 function
	 ConvertToAutoInheritPrivateObjectSecurity.  Fortunately the latter
	 is just a shim. */
      status = RtlConvertToAutoInheritSecurityObject (psd, sd, &nsd, NULL,
						      pc.isdir (),
						      &file_mapping);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("RtlConvertToAutoInheritSecurityObject (%S), status %y",
			&dirname, status);
	  return 0;
	}
      /* Eventually copy the new security descriptor into sd and delete the
	 original one created by RtlConvertToAutoInheritSecurityObject from
	 the heap. */
      len = RtlLengthSecurityDescriptor (nsd);
      memcpy ((PSECURITY_DESCRIPTOR) sd, nsd, len);
      RtlDeleteSecurityObject (&nsd);
    }
  return 0;
}

LONG
set_file_sd (HANDLE fh, path_conv &pc, security_descriptor &sd, bool is_chown)
{
  NTSTATUS status = STATUS_SUCCESS;
  int retry = 0;
  int res = -1;

  for (; retry < 2; ++retry)
    {
      if (fh)
	{
	  status = NtSetSecurityObject (fh,
					is_chown ? ALL_SECURITY_INFORMATION
						 : DACL_SECURITY_INFORMATION,
					sd);
	  if (NT_SUCCESS (status))
	    {
	      res = 0;
	      break;
	    }
	}
      if (!retry)
	{
	  OBJECT_ATTRIBUTES attr;
	  IO_STATUS_BLOCK io;
	  status = NtOpenFile (&fh, (is_chown ? WRITE_OWNER  : 0) | WRITE_DAC,
			       fh ? pc.init_reopen_attr (attr, fh)
				  : pc.get_object_attr (attr, sec_none_nih),
			       &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      fh = NULL;
	      break;
	    }
	}
    }
  if (retry && fh)
    NtClose (fh);
  if (!NT_SUCCESS (status))
    __seterrno_from_nt_status (status);
  return res;
}

static void
get_attribute_from_acl (mode_t *attribute, PACL acl, PSID owner_sid,
			PSID group_sid, bool grp_member)
{
  ACCESS_ALLOWED_ACE *ace;
  mode_t allow = 0;
  mode_t deny = 0;
  mode_t *flags, *anti;
  bool isownergroup = RtlEqualSid (owner_sid, group_sid);

  for (DWORD i = 0; i < acl->AceCount; ++i)
    {
      if (!NT_SUCCESS (RtlGetAce (acl, i, (PVOID *) &ace)))
	continue;
      if (ace->Header.AceFlags & INHERIT_ONLY_ACE)
	continue;
      switch (ace->Header.AceType)
	{
	case ACCESS_ALLOWED_ACE_TYPE:
	  flags = &allow;
	  anti = &deny;
	  break;
	case ACCESS_DENIED_ACE_TYPE:
	  flags = &deny;
	  anti = &allow;
	  break;
	default:
	  continue;
	}

      cygpsid ace_sid ((PSID) &ace->SidStart);
      if (ace_sid == well_known_world_sid)
	{
	  if (ace->Mask & FILE_READ_BITS)
	    *flags |= ((!(*anti & S_IROTH)) ? S_IROTH : 0)
		      | ((!isownergroup && !(*anti & S_IRGRP)) ? S_IRGRP : 0)
		      | ((!(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_BITS)
	    *flags |= ((!(*anti & S_IWOTH)) ? S_IWOTH : 0)
		      | ((!isownergroup && !(*anti & S_IWGRP)) ? S_IWGRP : 0)
		      | ((!(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXEC_BITS)
	    *flags |= ((!(*anti & S_IXOTH)) ? S_IXOTH : 0)
		      | ((!isownergroup && !(*anti & S_IXGRP)) ? S_IXGRP : 0)
		      | ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
	  if ((S_ISDIR (*attribute)) &&
	      (ace->Mask & (FILE_WRITE_DATA | FILE_EXECUTE | FILE_DELETE_CHILD))
	      == (FILE_WRITE_DATA | FILE_EXECUTE))
	    *flags |= S_ISVTX;
	}
      else if (ace_sid == well_known_null_sid)
	{
	  /* Read SUID, SGID and VTX bits from NULL ACE. */
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_ISVTX;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_ISGID;
	  if (ace->Mask & FILE_APPEND_DATA)
	    *flags |= S_ISUID;
	}
      else if (ace_sid == owner_sid)
	{
	  if (ace->Mask & FILE_READ_BITS)
	    *flags |= ((!(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_BITS)
	    *flags |= ((!(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXEC_BITS)
	    *flags |= ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
	  /* Apply deny mask to group if group SID == owner SID. */
	  if (group_sid && isownergroup
	      && ace->Header.AceType == ACCESS_DENIED_ACE_TYPE)
	    {
	      if (ace->Mask & FILE_READ_BITS)
		*flags |= ((!(*anti & S_IRUSR)) ? S_IRGRP : 0);
	      if (ace->Mask & FILE_WRITE_BITS)
		*flags |= ((!(*anti & S_IWUSR)) ? S_IWGRP : 0);
	      if (ace->Mask & FILE_EXEC_BITS)
		*flags |= ((!(*anti & S_IXUSR)) ? S_IXGRP : 0);
	    }
	}
      else if (ace_sid == group_sid)
	{
	  if (ace->Mask & FILE_READ_BITS)
	    *flags |= ((!(*anti & S_IRGRP)) ? S_IRGRP : 0)
		      | ((grp_member && !(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_BITS)
	    *flags |= ((!(*anti & S_IWGRP)) ? S_IWGRP : 0)
		      | ((grp_member && !(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXEC_BITS)
	    *flags |= ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
		      | ((grp_member && !(*anti & S_IXUSR)) ? S_IXUSR : 0);
	}
      else if (flags == &allow)
	{
	  /* Simplified computation of additional group permissions based on
	     the CLASS_OBJ value.  CLASS_OBJ represents the or'ed value of
	     the primary group permissions and all secondary user and group
	     permissions.  FIXME: This only takes ACCESS_ALLOWED_ACEs into
	     account.  The computation with additional ACCESS_DENIED_ACE
	     handling is much more complicated. */
	  if (ace->Mask & FILE_READ_BITS)
	    *flags |= S_IRGRP;
	  if (ace->Mask & FILE_WRITE_BITS)
	    *flags |= S_IWGRP;
	  if (ace->Mask & FILE_EXEC_BITS)
	    *flags |= S_IXGRP;
	}
    }
  *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX | S_ISGID | S_ISUID);
#if 0
  /* Disable owner/group permissions equivalence if owner SID == group SID.
     It's technically not quite correct, but it helps in case a security
     conscious application checks if a file has too open permissions.  In
     fact, since owner == group, there's no security issue here. */
  if (owner_sid && group_sid && RtlEqualSid (owner_sid, group_sid)
      /* FIXME: temporary exception for /var/empty */
      && well_known_system_sid != group_sid)
    {
      allow &= ~(S_IRGRP | S_IWGRP | S_IXGRP);
      allow |= (((allow & S_IRUSR) ? S_IRGRP : 0)
		| ((allow & S_IWUSR) ? S_IWGRP : 0)
		| ((allow & S_IXUSR) ? S_IXGRP : 0));
    }
#endif
  *attribute |= allow;
}

static void
get_info_from_sd (PSECURITY_DESCRIPTOR psd, mode_t *attribute,
		  uid_t *uidret, gid_t *gidret)
{
  if (!psd)
    {
      /* If reading the security descriptor failed, treat the object
	 as unreadable. */
      if (attribute)
	*attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO);
      if (uidret)
	*uidret = ILLEGAL_UID;
      if (gidret)
	*gidret = ILLEGAL_GID;
      return;
    }

  cygpsid owner_sid;
  cygpsid group_sid;
  NTSTATUS status;
  BOOLEAN dummy;

  status = RtlGetOwnerSecurityDescriptor (psd, (PSID *) &owner_sid, &dummy);
  if (!NT_SUCCESS (status))
    debug_printf ("RtlGetOwnerSecurityDescriptor: %y", status);
  status = RtlGetGroupSecurityDescriptor (psd, (PSID *) &group_sid, &dummy);
  if (!NT_SUCCESS (status))
    debug_printf ("RtlGetGroupSecurityDescriptor: %y", status);

  uid_t uid;
  gid_t gid;
  bool grp_member = get_sids_info (owner_sid, group_sid, &uid, &gid);
  if (uidret)
    *uidret = uid;
  if (gidret)
    *gidret = gid;

  if (!attribute)
    {
      syscall_printf ("uid %u, gid %u", uid, gid);
      return;
    }

  PACL acl;
  BOOLEAN acl_exists;

  status = RtlGetDaclSecurityDescriptor (psd, &acl_exists, &acl, &dummy);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO);
    }
  else if (!acl_exists || !acl)
    *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
  else
    get_attribute_from_acl (attribute, acl, owner_sid, group_sid, grp_member);

  syscall_printf ("%sACL %y, uid %u, gid %u",
		  (!acl_exists || !acl)?"NO ":"", *attribute, uid, gid);
}

static int
get_reg_sd (HANDLE handle, security_descriptor &sd_ret)
{
  LONG ret;
  DWORD len = 0;

  ret = RegGetKeySecurity ((HKEY) handle, ALL_SECURITY_INFORMATION,
			   sd_ret, &len);
  if (ret == ERROR_INSUFFICIENT_BUFFER)
    {
      if (!sd_ret.malloc (len))
	set_errno (ENOMEM);
      else
	ret = RegGetKeySecurity ((HKEY) handle, ALL_SECURITY_INFORMATION,
				 sd_ret, &len);
    }
  if (ret != ERROR_SUCCESS)
    {
      __seterrno ();
      return -1;
    }
  return 0;
}

int
get_reg_attribute (HKEY hkey, mode_t *attribute, uid_t *uidret,
		   gid_t *gidret)
{
  security_descriptor sd;

  if (!get_reg_sd (hkey, sd))
    {
      get_info_from_sd (sd, attribute, uidret, gidret);
      return 0;
    }
  /* The entries are already set to default values */
  return -1;
}

int
get_file_attribute (HANDLE handle, path_conv &pc,
		    mode_t *attribute, uid_t *uidret, gid_t *gidret)
{
  if (pc.has_acls ())
    {
      security_descriptor sd;

      if (!get_file_sd (handle, pc, sd, false))
	{
	  get_info_from_sd (sd, attribute, uidret, gidret);
	  return 0;
	}
      /* ENOSYS is returned by get_file_sd if fetching the DACL from a remote
	 share returns STATUS_INVALID_NETWORK_RESPONSE, which in turn is
	 converted to ERROR_BAD_NET_RESP.  This potentially occurs when trying
	 to fetch DACLs from a NT4 machine which is not part of the domain of
	 the requesting machine. */
      else if (get_errno () != ENOSYS)
	{
	  if (uidret)
	    *uidret = ILLEGAL_UID;
	  if (gidret)
	    *gidret = ILLEGAL_GID;

	  return -1;
	}
    }

  if (uidret)
    *uidret = myself->uid;
  if (gidret)
    *gidret = myself->gid;

  return -1;
}

bool
add_access_allowed_ace (PACL acl, int offset, DWORD attributes,
			PSID sid, size_t &len_add, DWORD inherit)
{
  NTSTATUS status = RtlAddAccessAllowedAceEx (acl, ACL_REVISION, inherit,
					      attributes, sid);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return false;
    }
  len_add += sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD) + RtlLengthSid (sid);
  return true;
}

bool
add_access_denied_ace (PACL acl, int offset, DWORD attributes,
		       PSID sid, size_t &len_add, DWORD inherit)
{
  NTSTATUS status = RtlAddAccessDeniedAceEx (acl, ACL_REVISION, inherit,
					     attributes, sid);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return false;
    }
  len_add += sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD) + RtlLengthSid (sid);
  return true;
}

static PSECURITY_DESCRIPTOR
alloc_sd (path_conv &pc, uid_t uid, gid_t gid, int attribute,
	  security_descriptor &sd_ret)
{
  NTSTATUS status;
  BOOLEAN dummy;
  tmp_pathbuf tp;

  /* NOTE: If the high bit of attribute is set, we have just created
     a file or directory.  See below for an explanation. */

  debug_printf("uid %u, gid %u, attribute 0%o", uid, gid, attribute);

  /* Get owner and group from current security descriptor. */
  PSID cur_owner_sid = NULL;
  PSID cur_group_sid = NULL;
  status = RtlGetOwnerSecurityDescriptor (sd_ret, &cur_owner_sid, &dummy);
  if (!NT_SUCCESS (status))
    debug_printf ("RtlGetOwnerSecurityDescriptor: %y", status);
  status = RtlGetGroupSecurityDescriptor (sd_ret, &cur_group_sid, &dummy);
  if (!NT_SUCCESS (status))
    debug_printf ("RtlGetGroupSecurityDescriptor: %y", status);

  /* Get SID of owner. */
  cygsid owner_sid;
  /* Check for current user first */
  if (uid == myself->uid)
    owner_sid = cygheap->user.sid ();
  else if (uid == ILLEGAL_UID)
    owner_sid = cur_owner_sid;
  else if (!owner_sid.getfrompw (internal_getpwuid (uid)))
    {
      set_errno (EINVAL);
      return NULL;
    }
  owner_sid.debug_print ("alloc_sd: owner SID =");

  /* Get SID of new group. */
  cygsid group_sid;
  /* Check for current user first */
  if (gid == myself->gid)
    group_sid = cygheap->user.groups.pgsid;
  else if (gid == ILLEGAL_GID)
    group_sid = cur_group_sid;
  else if (!group_sid.getfromgr (internal_getgrgid (gid)))
    {
      set_errno (EINVAL);
      return NULL;
    }
  group_sid.debug_print ("alloc_sd: group SID =");

  /* Initialize local security descriptor. */
  SECURITY_DESCRIPTOR sd;
  RtlCreateSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);

  /* We set the SE_DACL_PROTECTED flag here to prevent the DACL from being
     modified by inheritable ACEs. */
  RtlSetControlSecurityDescriptor (&sd, SE_DACL_PROTECTED, SE_DACL_PROTECTED);

  /* Create owner for local security descriptor. */
  status = RtlSetOwnerSecurityDescriptor (&sd, owner_sid, FALSE);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return NULL;
    }

  /* Create group for local security descriptor. */
  status = RtlSetGroupSecurityDescriptor (&sd, group_sid, FALSE);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return NULL;
    }

  /* Initialize local access control list. */
  PACL acl = (PACL) tp.w_get ();
  RtlCreateAcl (acl, ACL_MAXIMUM_SIZE, ACL_REVISION);

  /* From here fill ACL. */
  size_t acl_len = sizeof (ACL);
  int ace_off = 0;
  /* Only used for sync objects (for ttys).  The admins group should
     always have the right to manipulate the ACL, so we have to make sure
     that the ACL gives the admins group STANDARD_RIGHTS_ALL access. */
  bool saw_admins = false;

  /* Construct allow attribute for owner.
     Don't set FILE_READ/WRITE_ATTRIBUTES unconditionally on Samba, otherwise
     it enforces read permissions.  Same for other's below. */
  DWORD owner_allow = STANDARD_RIGHTS_ALL
		      | (pc.fs_is_samba ()
			 ? 0 : (FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES));
  if (attribute & S_IRUSR)
    owner_allow |= FILE_GENERIC_READ;
  if (attribute & S_IWUSR)
    owner_allow |= FILE_GENERIC_WRITE;
  if (attribute & S_IXUSR)
    owner_allow |= FILE_GENERIC_EXECUTE & ~FILE_READ_ATTRIBUTES;
  if (S_ISDIR (attribute)
      && (attribute & (S_IWUSR | S_IXUSR)) == (S_IWUSR | S_IXUSR))
    owner_allow |= FILE_DELETE_CHILD;
  /* For sync objects note that the owner is admin. */
  if (S_ISCHR (attribute) && owner_sid == well_known_admins_sid)
    saw_admins = true;

  /* Construct allow attribute for group. */
  DWORD group_allow = STANDARD_RIGHTS_READ | SYNCHRONIZE
		      | (pc.fs_is_samba () ? 0 : FILE_READ_ATTRIBUTES);
  if (attribute & S_IRGRP)
    group_allow |= FILE_GENERIC_READ;
  if (attribute & S_IWGRP)
    group_allow |= FILE_GENERIC_WRITE;
  if (attribute & S_IXGRP)
    group_allow |= FILE_GENERIC_EXECUTE & ~FILE_READ_ATTRIBUTES;
  if (S_ISDIR (attribute)
      && (attribute & (S_IWGRP | S_IXGRP)) == (S_IWGRP | S_IXGRP)
      && !(attribute & S_ISVTX))
    group_allow |= FILE_DELETE_CHILD;
  /* For sync objects, add STANDARD_RIGHTS_ALL for admins group. */
  if (S_ISCHR (attribute) && group_sid == well_known_admins_sid)
    {
      group_allow |= STANDARD_RIGHTS_ALL;
      saw_admins = true;
    }

  /* Construct allow attribute for everyone. */
  DWORD other_allow = STANDARD_RIGHTS_READ | SYNCHRONIZE
		      | (pc.fs_is_samba () ? 0 : FILE_READ_ATTRIBUTES);
  if (attribute & S_IROTH)
    other_allow |= FILE_GENERIC_READ;
  if (attribute & S_IWOTH)
    other_allow |= FILE_GENERIC_WRITE;
  if (attribute & S_IXOTH)
    other_allow |= FILE_GENERIC_EXECUTE & ~FILE_READ_ATTRIBUTES;
  if (S_ISDIR (attribute)
      && (attribute & (S_IWOTH | S_IXOTH)) == (S_IWOTH | S_IXOTH)
      && !(attribute & S_ISVTX))
    other_allow |= FILE_DELETE_CHILD;

  /* Construct SUID, SGID and VTX bits in NULL ACE. */
  DWORD null_allow = 0L;
  if (attribute & (S_ISUID | S_ISGID | S_ISVTX))
    {
      if (attribute & S_ISUID)
	null_allow |= FILE_APPEND_DATA;
      if (attribute & S_ISGID)
	null_allow |= FILE_WRITE_DATA;
      if (attribute & S_ISVTX)
	null_allow |= FILE_READ_DATA;
    }

  /* Add owner and group permissions if SIDs are equal
     and construct deny attributes for group and owner. */
  bool isownergroup;
  if ((isownergroup = (owner_sid == group_sid)))
    owner_allow |= group_allow;

  DWORD owner_deny = ~owner_allow & (group_allow | other_allow);
  owner_deny &= ~(STANDARD_RIGHTS_READ
		  | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES);

  DWORD group_deny = ~group_allow & other_allow;
  group_deny &= ~(STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES);

  /* Set deny ACE for owner. */
  if (owner_deny
      && !add_access_denied_ace (acl, ace_off++, owner_deny,
				 owner_sid, acl_len, NO_INHERITANCE))
    return NULL;
  /* Set deny ACE for group here to respect the canonical order,
     if this does not impact owner */
  if (group_deny && !(group_deny & owner_allow) && !isownergroup
      && !add_access_denied_ace (acl, ace_off++, group_deny,
				 group_sid, acl_len, NO_INHERITANCE))
    return NULL;
  /* Set allow ACE for owner. */
  if (!add_access_allowed_ace (acl, ace_off++, owner_allow,
			       owner_sid, acl_len, NO_INHERITANCE))
    return NULL;
  /* Set deny ACE for group, if still needed. */
  if ((group_deny & owner_allow) && !isownergroup
      && !add_access_denied_ace (acl, ace_off++, group_deny,
				 group_sid, acl_len, NO_INHERITANCE))
    return NULL;
  /* Set allow ACE for group. */
  if (!isownergroup
      && !add_access_allowed_ace (acl, ace_off++, group_allow,
				  group_sid, acl_len, NO_INHERITANCE))
    return NULL;

  /* For sync objects, if we didn't see the admins group so far, add entry
     with STANDARD_RIGHTS_ALL access. */
  if (S_ISCHR (attribute) && !saw_admins)
    {
      if (!add_access_allowed_ace (acl, ace_off++, STANDARD_RIGHTS_ALL,
				   well_known_admins_sid, acl_len,
				   NO_INHERITANCE))
	return NULL;
      saw_admins = true;
    }

  /* Set allow ACE for everyone. */
  if (!add_access_allowed_ace (acl, ace_off++, other_allow,
			       well_known_world_sid, acl_len, NO_INHERITANCE))
    return NULL;
  /* Set null ACE for special bits. */
  if (null_allow
      && !add_access_allowed_ace (acl, ace_off++, null_allow,
				  well_known_null_sid, acl_len, NO_INHERITANCE))
    return NULL;

  /* Fill ACL with unrelated ACEs from current security descriptor. */
  PACL oacl;
  BOOLEAN acl_exists = FALSE;
  ACCESS_ALLOWED_ACE *ace;

  status = RtlGetDaclSecurityDescriptor (sd_ret, &acl_exists, &oacl, &dummy);
  if (NT_SUCCESS (status) && acl_exists && oacl)
    for (DWORD i = 0; i < oacl->AceCount; ++i)
      if (NT_SUCCESS (RtlGetAce (oacl, i, (PVOID *) &ace)))
	{
	  cygpsid ace_sid ((PSID) &ace->SidStart);

	  /* Always skip NULL SID as well as admins SID on virtual device files
	     in /proc/sys. */
	  if (ace_sid == well_known_null_sid
	      || (S_ISCHR (attribute) && ace_sid == well_known_admins_sid))
	    continue;
	  /* Check for ACEs which are always created in the preceding code
	     and check for the default inheritence ACEs which will be created
	     for just created directories.  Skip them for just created
	     directories or if they are not inherited.  If they are inherited,
	     make sure they are *only* inherited, so they don't collide with
	     the permissions set in this function. */
	  if ((ace_sid == cur_owner_sid)
	      || (ace_sid == owner_sid)
	      || (ace_sid == cur_group_sid)
	      || (ace_sid == group_sid)
	      || (ace_sid == well_known_creator_owner_sid)
	      || (ace_sid == well_known_creator_group_sid)
	      || (ace_sid == well_known_world_sid))
	    {
	      if ((S_ISDIR (attribute) && (attribute & S_JUSTCREATED))
		  || (ace->Header.AceFlags
		      & (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)) == 0)
		continue;
	      else
		ace->Header.AceFlags |= INHERIT_ONLY_ACE;
	    }
	  if (attribute & S_JUSTCREATED)
	    {
	      /* Since files and dirs are created with a NULL descriptor,
		 inheritence rules kick in.  If no inheritable entries exist
		 in the parent object, Windows will create entries from the
		 user token's default DACL in the file DACL.  These entries
		 are not desired and we drop them silently. */
	      if (!(ace->Header.AceFlags & INHERITED_ACE))
		continue;
	      /* Remove the INHERITED_ACE flag since on POSIX systems
		 inheritance is settled when the file has been created.
		 This also avoids error messages in Windows Explorer when
		 opening a file's security tab.  Explorer complains if
		 inheritable ACEs are preceding non-inheritable ACEs. */
	      ace->Header.AceFlags &= ~INHERITED_ACE;
	      /* However, if the newly created object is a directory,
	         it inherits the default ACL from its parent, so mark
		 all unrelated, inherited ACEs inheritable. */
	      if (S_ISDIR (attribute))
		ace->Header.AceFlags |= CONTAINER_INHERIT_ACE
					| OBJECT_INHERIT_ACE;
	    }
	  else if (uid == ILLEGAL_UID && gid == ILLEGAL_UID
		   && ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE
		   && ace_sid != well_known_creator_group_sid
		   && ace_sid != well_known_creator_owner_sid
		   && ace_sid != well_known_world_sid)
	    {
	      /* FIXME: Temporary workaround for the problem that chmod does
		 not affect the group permissions if other users and groups
		 in the ACL have more permissions than the primary group due
		 to the CLASS_OBJ emulation.  The temporary workaround is to
		 disallow any secondary ACE in the ACL more permissions than
		 the primary group when writing a new ACL via chmod. */
	      ace->Mask &= group_allow;
	    }
	  /* Add unrelated ACCESS_DENIED_ACE to the beginning but behind
	     the owner_deny, ACCESS_ALLOWED_ACE to the end.  FIXME: this
	     would break the order of the inherit-only ACEs. */
	  status = RtlAddAce (acl, ACL_REVISION,
			      ace->Header.AceType == ACCESS_DENIED_ACE_TYPE
			      ?  (owner_deny ? 1 : 0) : MAXDWORD,
			      (LPVOID) ace, ace->Header.AceSize);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      return NULL;
	    }
	  ace_off++;
	  acl_len += ace->Header.AceSize;
	}

  /* Construct appropriate inherit attribute for new directories.  Keep in
     mind that we do this only for the sake of non-Cygwin applications.
     Cygwin applications don't need this. */
  if (S_ISDIR (attribute) && (attribute & S_JUSTCREATED))
    {
      const DWORD inherit = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
			    | INHERIT_ONLY_ACE;
      /* Set allow ACE for owner. */
      if (!add_access_allowed_ace (acl, ace_off++, owner_allow,
				   well_known_creator_owner_sid, acl_len,
				   inherit))
	return NULL;
      /* Set allow ACE for group. */
      if (!add_access_allowed_ace (acl, ace_off++, group_allow,
				   well_known_creator_group_sid, acl_len,
				   inherit))
	return NULL;
      /* Set allow ACE for everyone. */
      if (!add_access_allowed_ace (acl, ace_off++, other_allow,
				   well_known_world_sid, acl_len, inherit))
	return NULL;
    }

  /* Set AclSize to computed value. */
  acl->AclSize = acl_len;
  debug_printf ("ACL-Size: %d", acl_len);

  /* Create DACL for local security descriptor. */
  status = RtlSetDaclSecurityDescriptor (&sd, TRUE, acl, FALSE);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return NULL;
    }

  /* Make self relative security descriptor. */
  DWORD sd_size = 0;
  RtlAbsoluteToSelfRelativeSD (&sd, sd_ret, &sd_size);
  if (sd_size <= 0)
    {
      __seterrno ();
      return NULL;
    }
  if (!sd_ret.malloc (sd_size))
    {
      set_errno (ENOMEM);
      return NULL;
    }
  status = RtlAbsoluteToSelfRelativeSD (&sd, sd_ret, &sd_size);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return NULL;
    }
  debug_printf ("Created SD-Size: %u", sd_ret.size ());

  return sd_ret;
}

void
set_security_attribute (path_conv &pc, int attribute, PSECURITY_ATTRIBUTES psa,
			security_descriptor &sd)
{
  psa->lpSecurityDescriptor = sd.malloc (SECURITY_DESCRIPTOR_MIN_LENGTH);
  RtlCreateSecurityDescriptor ((PSECURITY_DESCRIPTOR) psa->lpSecurityDescriptor,
				SECURITY_DESCRIPTOR_REVISION);
  psa->lpSecurityDescriptor = alloc_sd (pc, geteuid32 (), getegid32 (),
					attribute, sd);
}

int
get_object_sd (HANDLE handle, security_descriptor &sd)
{
  ULONG len = 0;
  NTSTATUS status;

  status = NtQuerySecurityObject (handle, ALL_SECURITY_INFORMATION,
				  sd, len, &len);
  if (status != STATUS_BUFFER_TOO_SMALL)
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  if (!sd.malloc (len))
    {
      set_errno (ENOMEM);
      return -1;
    }
  status = NtQuerySecurityObject (handle, ALL_SECURITY_INFORMATION,
				  sd, len, &len);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  return 0;
}

int
get_object_attribute (HANDLE handle, uid_t *uidret, gid_t *gidret,
		      mode_t *attribute)
{
  security_descriptor sd;

  if (get_object_sd (handle, sd))
    return -1;
  get_info_from_sd (sd, attribute, uidret, gidret);
  return 0;
}

int
create_object_sd_from_attribute (HANDLE handle, uid_t uid, gid_t gid,
				 mode_t attribute, security_descriptor &sd)
{
  path_conv pc;
  if ((handle && get_object_sd (handle, sd))
      || !alloc_sd (pc, uid, gid, attribute, sd))
    return -1;
  return 0;
}

int
set_object_sd (HANDLE handle, security_descriptor &sd, bool chown)
{
  NTSTATUS status;
  status = NtSetSecurityObject (handle, chown ? ALL_SECURITY_INFORMATION
					      : DACL_SECURITY_INFORMATION, sd);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  return 0;
}

int
set_object_attribute (HANDLE handle, uid_t uid, gid_t gid,
		      mode_t attribute)
{
  security_descriptor sd;

  if (create_object_sd_from_attribute (handle, uid, gid, attribute, sd)
      || set_object_sd (handle, sd, uid != ILLEGAL_UID || gid != ILLEGAL_GID))
    return -1;
  return 0;
}

int
set_file_attribute (HANDLE handle, path_conv &pc,
		    uid_t uid, gid_t gid, mode_t attribute)
{
  int ret = -1;

  if (pc.has_acls ())
    {
      security_descriptor sd;

      if (!get_file_sd (handle, pc, sd, (bool)(attribute & S_JUSTCREATED))
	  && alloc_sd (pc, uid, gid, attribute, sd))
	ret = set_file_sd (handle, pc, sd,
			   uid != ILLEGAL_UID || gid != ILLEGAL_GID);
    }
  else
    ret = 0;
  syscall_printf ("%d = set_file_attribute(%S, %d, %d, 0%o)",
		  ret, pc.get_nt_native_path (), uid, gid, attribute);
  return ret;
}

static int
check_access (security_descriptor &sd, GENERIC_MAPPING &mapping,
	      ACCESS_MASK desired, int flags, bool effective)
{
  int ret = -1;
  NTSTATUS status, allow;
  ACCESS_MASK granted;
  DWORD plen = sizeof (PRIVILEGE_SET) + 3 * sizeof (LUID_AND_ATTRIBUTES);
  PPRIVILEGE_SET pset = (PPRIVILEGE_SET) alloca (plen);
  HANDLE tok = ((effective && cygheap->user.issetuid ())
		? cygheap->user.imp_token ()
		: hProcImpToken);

  if (!tok)
    {
      if (!DuplicateTokenEx (hProcToken, MAXIMUM_ALLOWED, NULL,
			    SecurityImpersonation, TokenImpersonation,
			    &hProcImpToken))
	 {
	    __seterrno ();
	    return ret;
	 }
      tok = hProcImpToken;
    }

  status = NtAccessCheck (sd, tok, desired, &mapping, pset, &plen, &granted,
			  &allow);
  if (!NT_SUCCESS (status))
    __seterrno ();
  else if (!NT_SUCCESS (allow))
    {
      /* CV, 2006-10-16: Now, that's really weird.  Imagine a user who has no
	 standard access to a file, but who has backup and restore privileges
	 and these privileges are enabled in the access token.  One would
	 expect that the AccessCheck function takes this into consideration
	 when returning the access status.  Otherwise, why bother with the
	 pset parameter, right?
	 But not so.  AccessCheck actually returns a status of "false" here,
	 even though opening a file with backup resp. restore intent
	 naturally succeeds for this user.  This definitely spoils the results
	 of access(2) for administrative users or the SYSTEM account.  So, in
	 case the access check fails, another check against the user's
	 backup/restore privileges has to be made.  Sigh. */
      int granted_flags = 0;
      BOOLEAN has_priv;

      if (flags & R_OK)
	{
	  pset->PrivilegeCount = 1;
	  pset->Control = 0;
	  pset->Privilege[0].Luid.HighPart = 0L;
	  pset->Privilege[0].Luid.LowPart = SE_BACKUP_PRIVILEGE;
	  pset->Privilege[0].Attributes = 0;
	  status = NtPrivilegeCheck (tok, pset, &has_priv);
	  if (NT_SUCCESS (status) && has_priv)
	    granted_flags |= R_OK;
	}
      if (flags & W_OK)
	{
	  pset->PrivilegeCount = 1;
	  pset->Control = 0;
	  pset->Privilege[0].Luid.HighPart = 0L;
	  pset->Privilege[0].Luid.LowPart = SE_RESTORE_PRIVILEGE;
	  pset->Privilege[0].Attributes = 0;
	  status = NtPrivilegeCheck (tok, pset, &has_priv);
	  if (NT_SUCCESS (status) && has_priv)
	    granted_flags |= W_OK;
	}
      if (granted_flags == flags)
	ret = 0;
      else
	set_errno (EACCES);
    }
  else
    ret = 0;
  return ret;
}

/* Samba override.  Check security descriptor for Samba UNIX user and group
   accounts and check if we have an RFC 2307 mapping to a Windows account.
   Create a new security descriptor with all of the UNIX accounts with
   valid mapping replaced with their Windows counterpart. */
static void
convert_samba_sd (security_descriptor &sd_ret)
{
  NTSTATUS status;
  BOOLEAN dummy;
  PSID sid;
  cygsid owner;
  cygsid group;
  SECURITY_DESCRIPTOR sd;
  cyg_ldap cldap;
  tmp_pathbuf tp;
  PACL acl, oacl;
  size_t acl_len;
  PACCESS_ALLOWED_ACE ace;

  if (!NT_SUCCESS (RtlGetOwnerSecurityDescriptor (sd_ret, &sid, &dummy)))
    return;
  owner = sid;
  if (!NT_SUCCESS (RtlGetGroupSecurityDescriptor (sd_ret, &sid, &dummy)))
    return;
  group = sid;

  if (sid_id_auth (owner) == 22)
    {
      struct passwd *pwd;
      uid_t uid = owner.get_uid (&cldap);
      if (uid < UNIX_POSIX_OFFSET && (pwd = internal_getpwuid (uid)))
      	owner.getfrompw (pwd);
    }
  if (sid_id_auth (group) == 22)
    {
      struct group *grp;
      gid_t gid = group.get_gid (&cldap);
      if (gid < UNIX_POSIX_OFFSET && (grp = internal_getgrgid (gid)))
      	group.getfromgr (grp);
    }

  if (!NT_SUCCESS (RtlGetDaclSecurityDescriptor (sd_ret, &dummy,
						 &oacl, &dummy)))
    return;
  acl = (PACL) tp.w_get ();
  RtlCreateAcl (acl, ACL_MAXIMUM_SIZE, ACL_REVISION);
  acl_len = sizeof (ACL);

  for (DWORD i = 0; i < oacl->AceCount; ++i)
    if (NT_SUCCESS (RtlGetAce (oacl, i, (PVOID *) &ace)))
      {
	cygsid ace_sid ((PSID) &ace->SidStart);
	if (sid_id_auth (ace_sid) == 22)
	  {
	    if (sid_sub_auth (ace_sid, 0) == 1) /* user */
	      {
		struct passwd *pwd;
		uid_t uid = ace_sid.get_uid (&cldap);
		if (uid < UNIX_POSIX_OFFSET && (pwd = internal_getpwuid (uid)))
		  ace_sid.getfrompw (pwd);
	      }
	    else /* group */
	      {
		struct group *grp;
		gid_t gid = ace_sid.get_gid (&cldap);
		if (gid < UNIX_POSIX_OFFSET && (grp = internal_getgrgid (gid)))
		  ace_sid.getfromgr (grp);
	      }
	    if (!add_access_allowed_ace (acl, i, ace->Mask, ace_sid, acl_len,
					 ace->Header.AceFlags))
	      return;
	  }
      }
  acl->AclSize = acl_len;

  RtlCreateSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
  RtlSetControlSecurityDescriptor (&sd, SE_DACL_PROTECTED, SE_DACL_PROTECTED);
  RtlSetOwnerSecurityDescriptor (&sd, owner, FALSE);
  RtlSetGroupSecurityDescriptor (&sd, group, FALSE);

  status = RtlSetDaclSecurityDescriptor (&sd, TRUE, acl, FALSE);
  if (!NT_SUCCESS (status))
    return;
  DWORD sd_size = 0;
  status = RtlAbsoluteToSelfRelativeSD (&sd, sd_ret, &sd_size);
  if (sd_size > 0 && sd_ret.malloc (sd_size))
    RtlAbsoluteToSelfRelativeSD (&sd, sd_ret, &sd_size);
}

int
check_file_access (path_conv &pc, int flags, bool effective)
{
  security_descriptor sd;
  int ret = -1;
  ACCESS_MASK desired = 0;
  if (flags & R_OK)
    desired |= FILE_READ_DATA;
  if (flags & W_OK)
    desired |= FILE_WRITE_DATA;
  if (flags & X_OK)
    desired |= FILE_EXECUTE;
  if (!get_file_sd (pc.handle (), pc, sd, false))
    {
      /* Tweak Samba security descriptor as necessary. */
      if (pc.fs_is_samba ())
	convert_samba_sd (sd);
      ret = check_access (sd, file_mapping, desired, flags, effective);
    }
  debug_printf ("flags %y, ret %d", flags, ret);
  return ret;
}

int
check_registry_access (HANDLE hdl, int flags, bool effective)
{
  security_descriptor sd;
  int ret = -1;
  static GENERIC_MAPPING NO_COPY_RO reg_mapping = { KEY_READ,
						    KEY_WRITE,
						    KEY_EXECUTE,
						    KEY_ALL_ACCESS };
  ACCESS_MASK desired = 0;
  if (flags & R_OK)
    desired |= KEY_ENUMERATE_SUB_KEYS;
  if (flags & W_OK)
    desired |= KEY_SET_VALUE;
  if (flags & X_OK)
    desired |= KEY_QUERY_VALUE;

  if ((HKEY) hdl == HKEY_PERFORMANCE_DATA)
    /* RegGetKeySecurity() always fails with ERROR_INVALID_HANDLE.  */
    ret = 0;
  else if (!get_reg_sd (hdl, sd))
    ret = check_access (sd, reg_mapping, desired, flags, effective);

  /* As long as we can't write the registry... */
  if (flags & W_OK)
    {
      set_errno (EROFS);
      ret = -1;
    }
  debug_printf ("flags %y, ret %d", flags, ret);
  return ret;
}
@


1.276
log
@	* security.cc (alloc_sd): For directories, mark inherited ACEs
	inheritable to better follow POSIX 1003.1e rules.
@
text
@d245 1
d272 1
a272 1
		      | ((!(*anti & S_IRGRP)) ? S_IRGRP : 0)
d276 1
a276 1
		      | ((!(*anti & S_IWGRP)) ? S_IWGRP : 0)
d280 1
a280 1
		      | ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
d306 1
a306 1
	  if (group_sid && RtlEqualSid (owner_sid, group_sid)
d712 1
a712 1
  if (group_deny & owner_allow && !isownergroup
@


1.275
log
@	* sec_acl.cc (setacl): Fix bug which leads to ACE duplication in
	case owner SID == group SID.
	(getacl): Reverse order of SID test against group or owner sid to
	prefer owner attributes over group attributes.  Disable setting group
	permissions equivalent to owner permissions if owner == group.  Add
	comment to explain why.  Fix indentation.
	* security.cc (get_attribute_from_acl): Change type of local variables
	containing permission to mode_t.  Apply deny mask to group if group SID
	== owner SID to avoid Everyone permissions to spill over into group
	permissions.  Disable setting group permissions equivalent to owner
	permissions if owner == group.  Add comment to explain why.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Allow user SID as
	group account if user is a "Microsoft Account".  Explain why.  Drop
	workaround enforcing primary group "Users" for "Microsoft Accounts".
@
text
@d795 6
@


1.274
log
@	* security.cc (alloc_sd): Don't apply temporary workaround for chmod
	to DEF_USER_OBJ, DEF_GROUP_OBJ, and DEF_OTHER_OBJ ACEs.
@
text
@d242 3
a244 3
  int allow = 0;
  int deny = 0;
  int *flags, *anti;
d304 11
d345 5
d359 1
@


1.273
log
@	* security.cc (alloc_sd): Fix comment style.  Remove code unused for
	years.
@
text
@d780 13
a792 8
		   && ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
	  /* FIXME: Temporary workaround for the problem that chmod does
	     not affect the group permissions if other users and groups
	     in the ACL have more permissions than the primary group due
	     to the CLASS_OBJ emulation.  The temporary workaround is to
	     disallow any secondary ACE in the ACL more permissions than
	     the primary group when writing a new ACL via chmod. */
	    ace->Mask &= group_allow;
@


1.272
log
@	* security.cc (alloc_sd): Add temporary workaround which disallows
	any secondary user to have more permissions than the primary group
	in calls to chmod.  Add comment to explain why.
@
text
@d788 3
a790 5
	  /*
	   * Add unrelated ACCESS_DENIED_ACE to the beginning but
	   * behind the owner_deny, ACCESS_ALLOWED_ACE to the end.
	   * FIXME: this would break the order of the inherit-only ACEs
	   */
a810 13
#if 0 /* FIXME: Not done currently as this breaks the canonical order */
      /* Set deny ACE for owner. */
      if (owner_deny
	  && !add_access_denied_ace (acl, ace_off++, owner_deny,
				     well_known_creator_owner_sid, acl_len, inherit))
	return NULL;
      /* Set deny ACE for group here to respect the canonical order,
	 if this does not impact owner */
      if (group_deny && !(group_deny & owner_allow)
	  && !add_access_denied_ace (acl, ace_off++, group_deny,
				     well_known_creator_group_sid, acl_len, inherit))
	return NULL;
#endif
a815 8
#if 0 /* FIXME: Not done currently as this breaks the canonical order and
	 won't be preserved on chown and chmod */
      /* Set deny ACE for group, conflicting with owner_allow. */
      if (group_deny & owner_allow
	  && !add_access_denied_ace (acl, ace_off++, group_deny,
				     well_known_creator_group_sid, acl_len, inherit))
	return NULL;
#endif
@


1.271
log
@	* fhandler.cc (fhandler_base::facl): Drop CLASS_OBJ entry.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Ditto in noacl case.
	* sec_acl.cc (getacl): Compute useful fake CLASS_OBJ and DEF_CLASS_OBJ
	permission bits based on how these values are generated on Linux.
	Add commants to explain what the code is doing.
	* security.cc (get_attribute_from_acl): Compute group permission based
	on the actual primary group permissions and all secondary user and group
	ACCESS_ALLOWED_ACEs to emulate Linux' behaviour more closely.
	(check_access): Fix typos im comment.
	* include/cygwin/acl.h (MIN_ACL_ENTRIES): Redefine as 3.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d779 9
@


1.270
log
@	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.
@
text
@d317 15
d1067 2
a1068 2
   Create a new security descriptor with all of the UNIX acocunts with
   valid mapping replaced with their WIndows counterpart. */
@


1.269
log
@	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.
@
text
@d509 1
a509 1
  debug_printf("uid %u, gid %u, attribute %y", uid, gid, attribute);
d967 1
a967 1
  syscall_printf ("%d = set_file_attribute(%S, %d, %d, %y)",
@


1.268
log
@	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.
@
text
@d42 1
a42 1
  NTSTATUS status;
d59 2
a60 5
	{
	  debug_printf ("NtQuerySecurityObject (%S), status %y",
			pc.get_nt_native_path (), status);
	  fh = NULL;
	}
d65 1
a65 1
  if (!fh)
d68 4
a71 2
			   pc.init_reopen_attr (attr, fh), &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
d218 3
a220 1
			       pc.init_reopen_attr (attr, fh), &io,
@


1.267
log
@	* sec_helper.cc (cygpsid::get_id): Move Samba SID->uid/gid mapping
	from get_sids_info here.
	(get_sids_info): Vice versa.
	* security.cc (convert_samba_sd): New static function to map a Samba
	security descriptor to a security descriptor with UNIX users and groups
	converted to Windows SIDs per RFC 2307 mapping.
	(check_file_access): Call convert_samba_sd on Samba security
	descriptors.
@
text
@d71 1
a71 1
			   pc.get_object_attr (attr, sec_none_nih), &io,
d219 2
a220 2
			       pc.get_object_attr (attr, sec_none_nih),
			       &io, FILE_SHARE_VALID_FLAGS,
@


1.266
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d1049 89
d1151 6
a1156 1
    ret = check_access (sd, file_mapping, desired, flags, effective);
@


1.265
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a25 1
#include "pwdgrp.h"
@


1.265.2.1
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d43 1
a43 1
  NTSTATUS status = STATUS_SUCCESS;
d60 5
a64 2
	debug_printf ("NtQuerySecurityObject (%S), status %y",
		      pc.get_nt_native_path (), status);
d69 1
a69 1
  if (!fh || !NT_SUCCESS (status))
d72 2
a73 4
			   fh ? pc.init_reopen_attr (attr, fh)
			      : pc.get_object_attr (attr, sec_none_nih),
			   &io, FILE_SHARE_VALID_FLAGS,
			   FILE_OPEN_FOR_BACKUP_INTENT);
d220 2
a221 4
			       fh ? pc.init_reopen_attr (attr, fh)
				  : pc.get_object_attr (attr, sec_none_nih),
			       &io,
			       FILE_SHARE_VALID_FLAGS,
d509 1
a509 1
  debug_printf("uid %u, gid %u, attribute 0%o", uid, gid, attribute);
d967 1
a967 1
  syscall_printf ("%d = set_file_attribute(%S, %d, %d, 0%o)",
@


1.264
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d34 4
a37 4
static NO_COPY GENERIC_MAPPING file_mapping = { FILE_GENERIC_READ,
						FILE_GENERIC_WRITE,
						FILE_GENERIC_EXECUTE,
						FILE_ALL_ACCESS };
d61 1
a61 1
	  debug_printf ("NtQuerySecurityObject (%S), status %p",
d155 1
a155 1
	  debug_printf ("NtOpenFile (%S), status %p", &dirname, status);
d165 1
a165 1
	  debug_printf ("NtQuerySecurityObject (%S), status %p",
d180 1
a180 1
	  debug_printf ("RtlConvertToAutoInheritSecurityObject (%S), status %p",
d333 1
a333 1
		  __uid32_t *uidret, __gid32_t *gidret)
d355 1
a355 1
    debug_printf ("RtlGetOwnerSecurityDescriptor: %p", status);
d358 1
a358 1
    debug_printf ("RtlGetGroupSecurityDescriptor: %p", status);
d360 2
a361 2
  __uid32_t uid;
  __gid32_t gid;
d370 1
a370 1
      syscall_printf ("uid %d, gid %d", uid, gid);
d388 1
a388 1
  syscall_printf ("%sACL %x, uid %d, gid %d",
d417 2
a418 2
get_reg_attribute (HKEY hkey, mode_t *attribute, __uid32_t *uidret,
		   __gid32_t *gidret)
d433 1
a433 1
		    mode_t *attribute, __uid32_t *uidret, __gid32_t *gidret)
d499 1
a499 1
alloc_sd (path_conv &pc, __uid32_t uid, __gid32_t gid, int attribute,
d509 1
a509 1
  debug_printf("uid %d, gid %d, attribute %x", uid, gid, attribute);
d516 1
a516 1
    debug_printf ("RtlGetOwnerSecurityDescriptor: %p", status);
d519 1
a519 1
    debug_printf ("RtlGetGroupSecurityDescriptor: %p", status);
d902 1
a902 1
get_object_attribute (HANDLE handle, __uid32_t *uidret, __gid32_t *gidret,
d914 1
a914 1
create_object_sd_from_attribute (HANDLE handle, __uid32_t uid, __gid32_t gid,
d939 1
a939 1
set_object_attribute (HANDLE handle, __uid32_t uid, __gid32_t gid,
d952 1
a952 1
		    __uid32_t uid, __gid32_t gid, mode_t attribute)
d967 1
a967 1
  syscall_printf ("%d = set_file_attribute(%S, %d, %d, %p)",
d1064 1
a1064 1
  debug_printf ("flags %x, ret %d", flags, ret);
d1073 4
a1076 4
  static GENERIC_MAPPING NO_COPY reg_mapping = { KEY_READ,
						 KEY_WRITE,
						 KEY_EXECUTE,
						 KEY_ALL_ACCESS };
d1097 1
a1097 1
  debug_printf ("flags %x, ret %d", flags, ret);
@


1.263
log
@	* globals.cc (ro_u_refs): New R/O unicode string.
	* mount.cc (fs_info::update): Recognize ReFS.
	* mount.h (enum fs_info_type): Add refs.
	(class fs_info): Add refs flag and accessor methods.
	* ntdll.h (RtlAddAccessAllowedAceEx): Declare.
	(RtlAddAccessDeniedAceEx): Declare.
	* path.h (path_conv::fs_is_refs): Define.
	* sec_helper.cc (_recycler_sd): New function to create security
	descriptors suitable for the recycler bin starting with Vista.
	* security.cc (add_access_allowed_ace): Use RtlAddAccessAllowedAceEx
	and drop code to set AceFlags explicitely.
	(add_access_denied_ace): Use RtlAddAccessDeniedAceEx and drop code to
	set AceFlags explicitely.
	* security.h (_recycler_sd): Declare.
	(recycler_sd): Define.
	* syscalls.cc (desktop_ini): Change formatting.
	(desktop_ini_ext): Define third line of recycler desktop.ini file
	since Vista,
	(try_to_bin): Handle ReFS just like NTFS.  Write Vista and later
	Recycler in all uppercase, just like shell32 does when recreating it.
	Fix comments to include ReFS.  Don't implicitely reuse object
	attributes from earlier NtOpenFile call, rather recreate it for safety.
	Use recycler_sd call when creating security descriptor for Recycler
	dirs and files on Vista and later.  Write third line of desktop.ini
	when on Vista and later.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.263.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d333 1
a333 1
		  uid_t *uidret, gid_t *gidret)
d360 2
a361 2
  uid_t uid;
  gid_t gid;
d417 2
a418 2
get_reg_attribute (HKEY hkey, mode_t *attribute, uid_t *uidret,
		   gid_t *gidret)
d433 1
a433 1
		    mode_t *attribute, uid_t *uidret, gid_t *gidret)
d499 1
a499 1
alloc_sd (path_conv &pc, uid_t uid, gid_t gid, int attribute,
d902 1
a902 1
get_object_attribute (HANDLE handle, uid_t *uidret, gid_t *gidret,
d914 1
a914 1
create_object_sd_from_attribute (HANDLE handle, uid_t uid, gid_t gid,
d939 1
a939 1
set_object_attribute (HANDLE handle, uid_t uid, gid_t gid,
d952 1
a952 1
		    uid_t uid, gid_t gid, mode_t attribute)
@


1.263.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d61 1
a61 1
	  debug_printf ("NtQuerySecurityObject (%S), status %y",
d155 1
a155 1
	  debug_printf ("NtOpenFile (%S), status %y", &dirname, status);
d165 1
a165 1
	  debug_printf ("NtQuerySecurityObject (%S), status %y",
d180 1
a180 1
	  debug_printf ("RtlConvertToAutoInheritSecurityObject (%S), status %y",
d355 1
a355 1
    debug_printf ("RtlGetOwnerSecurityDescriptor: %y", status);
d358 1
a358 1
    debug_printf ("RtlGetGroupSecurityDescriptor: %y", status);
d370 1
a370 1
      syscall_printf ("uid %u, gid %u", uid, gid);
d388 1
a388 1
  syscall_printf ("%sACL %y, uid %u, gid %u",
d509 1
a509 1
  debug_printf("uid %u, gid %u, attribute %y", uid, gid, attribute);
d516 1
a516 1
    debug_printf ("RtlGetOwnerSecurityDescriptor: %y", status);
d519 1
a519 1
    debug_printf ("RtlGetGroupSecurityDescriptor: %y", status);
d967 1
a967 1
  syscall_printf ("%d = set_file_attribute(%S, %d, %d, %y)",
d1064 1
a1064 1
  debug_printf ("flags %y, ret %d", flags, ret);
d1097 1
a1097 1
  debug_printf ("flags %y, ret %d", flags, ret);
@


1.263.2.3
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.263.2.4
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d34 4
a37 4
static GENERIC_MAPPING NO_COPY_RO file_mapping = { FILE_GENERIC_READ,
						   FILE_GENERIC_WRITE,
						   FILE_GENERIC_EXECUTE,
						   FILE_ALL_ACCESS };
d1073 4
a1076 4
  static GENERIC_MAPPING NO_COPY_RO reg_mapping = { KEY_READ,
						    KEY_WRITE,
						    KEY_EXECUTE,
						    KEY_ALL_ACCESS };
@


1.262
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d472 2
a473 1
  NTSTATUS status = RtlAddAccessAllowedAce (acl, ACL_REVISION, attributes, sid);
a478 3
  ACCESS_ALLOWED_ACE *ace;
  if (inherit && NT_SUCCESS (RtlGetAce (acl, offset, (PVOID *) &ace)))
    ace->Header.AceFlags |= inherit;
d487 2
a488 1
  NTSTATUS status = RtlAddAccessDeniedAce (acl, ACL_REVISION, attributes, sid);
a493 3
  ACCESS_DENIED_ACE *ace;
  if (inherit && NT_SUCCESS (RtlGetAce (acl, offset, (PVOID *) &ace)))
    ace->Header.AceFlags |= inherit;
@


1.261
log
@	* fhandler_disk_file.cc (__DIR_mounts::eval_ino): Create path_conv
	with PC_KEEP_HANDLE flag.
	* path.h (path_conv::operator =): Duplicate UNICODE path as well.
	* security.cc (check_file_access): Use path_conv handle if available.
	* syscalls.cc (access): Create fhandler with PC_KEEP_HANDLE flag set.
	(euidaccess): Ditto.
	(faccessat): Ditto.
@
text
@d971 1
a971 1
  syscall_printf ("%d = set_file_attribute (%S, %d, %d, %p)",
@


1.260
log
@	* security.cc (get_file_sd): Fix comment.
@
text
@d1066 1
a1066 1
  if (!get_file_sd (NULL, pc, sd, false))
@


1.259
log
@whitespace elimination
@
text
@d120 1
a120 1
     the workaround could be removed. */
@


1.258
log
@	* security.cc (check_registry_access): Handle missing
	security descriptor of HKEY_PERFORMANCE_DATA.
@
text
@d75 1
a75 1
      	{
d170 1
a170 1
         are marked with the INHERITED_ACE flag.  For a description of the
d185 1
a185 1
      	 original one created by RtlConvertToAutoInheritSecurityObject from
d992 1
a992 1
		            SecurityImpersonation, TokenImpersonation,
d994 4
a997 4
         {
            __seterrno ();
            return ret;
         } 
d999 1
a999 1
    } 
@


1.257
log
@	* advapi32.cc: Add comment.
	(EqualSid): Remove.
	(CopySid): Remove.
	(AddAccessAllowedAce): Remove.
	(AddAccessDeniedAce): Remove.
	(MakeSelfRelativeSD): Remove.
	* flock.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
	* security.h: Ditto.
	(RtlEqualSid): Declare.  Explain why.
	(RtlCopySid): Ditto.
@
text
@d1088 5
a1092 1
  if (!get_reg_sd (hdl, sd))
d1094 1
@


1.256
log
@	* advapi32.cc (AccessCheck): Remove.
	(PrivilegeCheck): Remove.
	(OpenThreadToken): Remove.
	* fhandler_tty.cc: Replace above functions throughout with their
	ntdll.dll equivalent.
	* security.cc: Ditto.
@
text
@d319 1
a319 1
  if (owner_sid && group_sid && EqualSid (owner_sid, group_sid)
d472 2
a473 1
  if (!AddAccessAllowedAce (acl, ACL_REVISION, attributes, sid))
d475 1
a475 1
      __seterrno ();
d489 2
a490 1
  if (!AddAccessDeniedAce (acl, ACL_REVISION, attributes, sid))
d492 1
a492 1
      __seterrno ();
d844 1
a844 1
  MakeSelfRelativeSD (&sd, sd_ret, &sd_size);
d855 2
a856 1
  if (!MakeSelfRelativeSD (&sd, sd_ret, &sd_size))
d858 1
a858 1
      __seterrno ();
@


1.255
log
@	* advapi32.cc (SetSecurityDescriptorDacl): Remove.
	(SetSecurityDescriptorGroup): Remove.
	(SetSecurityDescriptorOwner): Remove.
	* pinfo.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.

	* sec_helper.cc (__sec_user): Remove old comment.
@
text
@d975 1
a975 1
	      DWORD desired, int flags, bool effective)
d978 2
a979 2
  BOOL status;
  DWORD granted;
d998 3
a1000 1
  if (!AccessCheck (sd, tok, desired, &mapping, pset, &plen, &granted, &status))
d1002 1
a1002 1
  else if (!status)
d1011 1
a1011 1
	 even though opening a file with backup resp.  restore intent
d1017 2
d1026 2
a1027 1
	  if (PrivilegeCheck (tok, pset, &status) && status)
d1037 2
a1038 1
	  if (PrivilegeCheck (tok, pset, &status) && status)
d1056 1
a1056 1
  DWORD desired = 0;
d1078 1
a1078 1
  DWORD desired = 0;
@


1.254
log
@	* advapi32.cc (GetSecurityDescriptorDacl): Remove.
	(GetSecurityDescriptorGroup): Remove.
	(GetSecurityDescriptorOwner): Remove.
	* sec_acl.cc: Replace above functions throughout with their ntdll.dll
	equivalent.  Remove redundant debug output.
	* sec_auth.cc: Ditto.
	* security.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d560 2
a561 1
  if (!SetSecurityDescriptorOwner (&sd, owner_sid, FALSE))
d563 1
a563 1
      __seterrno ();
d568 2
a569 1
  if (!SetSecurityDescriptorGroup (&sd, group_sid, FALSE))
d571 1
a571 1
      __seterrno ();
d833 2
a834 1
  if (!SetSecurityDescriptorDacl (&sd, TRUE, acl, FALSE))
d836 1
a836 1
      __seterrno ();
@


1.253
log
@	* advapi32.cc (InitializeAcl): Remove.
	(AddAce): Remove.
	(FindFirstFreeAce): Remove.
	(GetAce): Remove.
	(InitializeSecurityDescriptor): Remove.
	(OpenProcessToken): Remove.
	* dcrt0.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* fhandler_tty.cc: Ditto.
	* flock.cc: Ditto.
	* pinfo.cc: Ditto.  Drop unnecessary error handling.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d350 2
a351 1
  BOOL dummy;
d353 6
a358 4
  if (!GetSecurityDescriptorOwner (psd, (PSID *) &owner_sid, &dummy))
    debug_printf ("GetSecurityDescriptorOwner %E");
  if (!GetSecurityDescriptorGroup (psd, (PSID *) &group_sid, &dummy))
    debug_printf ("GetSecurityDescriptorGroup %E");
d375 1
a375 1
  BOOL acl_exists;
d377 2
a378 1
  if (!GetSecurityDescriptorDacl (psd, &acl_exists, &acl, &dummy))
d380 1
a380 2
      __seterrno ();
      debug_printf ("GetSecurityDescriptorDacl %E");
d504 2
a505 1
  BOOL dummy;
d516 6
a521 4
  if (!GetSecurityDescriptorOwner (sd_ret, &cur_owner_sid, &dummy))
    debug_printf ("GetSecurityDescriptorOwner %E");
  if (!GetSecurityDescriptorGroup (sd_ret, &cur_group_sid, &dummy))
    debug_printf ("GetSecurityDescriptorGroup %E");
d712 1
a712 1
  BOOL acl_exists = FALSE;
a713 1
  NTSTATUS status;
d715 2
a716 2
  if (GetSecurityDescriptorDacl (sd_ret, &acl_exists, &oacl, &dummy)
      && acl_exists && oacl)
@


1.252
log
@	* advapi32.cc (InitializeSid): Remove.
	(EqualPrefixSid): Remove.
	(GetLengthSid): Remove.
	(GetSidSubAuthority): Remove.
	(GetSidSubAuthorityCount): Remove.
	(GetSidIdentifierAuthority): Remove.
	* fhandler_disk_file.cc: Remove above functions throughout with their
	ntdll.dll equivalent.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d142 1
a142 1
	  if (RtlGetAce (dacl, idx, (PVOID *) &ace)
d248 1
a248 1
      if (!GetAce (acl, i, (PVOID *) &ace))
d475 1
a475 1
  if (inherit && GetAce (acl, offset, (PVOID *) &ace))
d491 1
a491 1
  if (inherit && GetAce (acl, offset, (PVOID *) &ace))
d547 1
a547 5
  if (!InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION))
    {
      __seterrno ();
      return NULL;
    }
d569 1
a569 5
  if (!InitializeAcl (acl, ACL_MAXIMUM_SIZE, ACL_REVISION))
    {
      __seterrno ();
      return NULL;
    }
d708 2
d713 1
a713 1
      if (GetAce (oacl, i, (PVOID *) &ace))
d764 5
a768 4
	  if (!AddAce (acl, ACL_REVISION,
		       ace->Header.AceType == ACCESS_DENIED_ACE_TYPE
		       ?  (owner_deny ? 1 : 0) : MAXDWORD,
		       (LPVOID) ace, ace->Header.AceSize))
d770 1
a770 1
	      __seterrno ();
d860 1
a860 1
  InitializeSecurityDescriptor ((PSECURITY_DESCRIPTOR)psa->lpSecurityDescriptor,
@


1.251
log
@	* autoload.cc (GetSecurityInfo): Remove.
	* ntdll.h (RtlConvertToAutoInheritSecurityObject): Declare.
	(RtlDeleteSecurityObject): Declare.
	(RtlGetControlSecurityDescriptor): Declare.
	(RtlLengthSecurityDescriptor): Declare.
	* security.cc (file_mapping): New global variable.
	(get_file_sd): Rewrite.  Clean up code.  Get rid of GetSecurityInfo
	call.
	(alloc_sd): Call RtlSetControlSecurityDescriptor to set
	SE_DACL_PROTECTED flag.
	(check_file_access): Remove mapping.  Use file_mapping instead.
	(check_registry_access): Rename mapping to reg_mapping.
	* wincap.cc: Througout, drop use_get_sec_info_on_dirs,
	* wincap.h (struct wincaps): Drop use_get_sec_info_on_dirs.
@
text
@d477 1
a477 1
  len_add += sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD) + GetLengthSid (sid);
d493 1
a493 1
  len_add += sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD) + GetLengthSid (sid);
@


1.250
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d34 5
d43 4
a46 3
  DWORD error = ERROR_SUCCESS;
  int retry = 0;
  int res = -1;
d48 8
a55 1
  for (; retry < 2; ++retry)
d57 107
a163 1
      if (fh)
d165 3
a167 52
	  /* Amazing but true.  If you want to know if an ACE is inherited
	     from the parent object, you can't use the NtQuerySecurityObject
	     function.  In the DACL returned by this functions, the
	     INHERITED_ACE flag is never set.  Only by calling GetSecurityInfo
	     you get this information.
	     
	     However, this functionality is slow, and the extra information is
	     only required when the file has been created and the permissions
	     are about to be set to POSIX permissions.  Therefore we only use
	     it in case the file just got created.  In all other cases we
	     rather call NtQuerySecurityObject directly...
	     
	     ...except that there's a problem on 5.1 and 5.2 kernels.  The
	     GetSecurityInfo call on a file sometimes returns with
	     ERROR_INVALID_ADDRESS if a former request for the SD of the
	     parent directory (or one of the parent directories?) used the
	     NtQuerySecurityObject call, rather than GetSecurityInfo as well.
	     As soon as all directory SDs are fetched using GetSecurityInfo,
	     the problem disappears. */
	  if (justcreated
	      || (pc.isdir () && wincap.use_get_sec_info_on_dirs ()))
	    {
	      PSECURITY_DESCRIPTOR psd;
	      error = GetSecurityInfo (fh, SE_FILE_OBJECT,
				       ALL_SECURITY_INFORMATION,
				       NULL, NULL, NULL, NULL, &psd);
	      if (error == ERROR_SUCCESS)
		{
		  sd = psd;
		  res = 0;
		  break;
		}
	    }
	  else
	    {
	      NTSTATUS status;
	      ULONG len = SD_MAXIMUM_SIZE;

	      if (!sd.malloc (len))
		{
		  set_errno (ENOMEM);
		  break;
		}
	      status = NtQuerySecurityObject (fh, ALL_SECURITY_INFORMATION,
					      sd, len, &len);
	      if (NT_SUCCESS (status))
		{
		  res = 0;
		  break;
		}
	      error = RtlNtStatusToDosError (status);
	    }
d169 10
a178 1
      if (!retry)
d180 3
a182 14
	  OBJECT_ATTRIBUTES attr;
	  IO_STATUS_BLOCK io;
	  NTSTATUS status;

	  status = NtOpenFile (&fh, READ_CONTROL,
			       pc.get_object_attr (attr, sec_none_nih),
			       &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      fh = NULL;
	      error = RtlNtStatusToDosError (status);
	      break;
	    }
d184 6
d191 1
a191 5
  if (retry && fh)
    NtClose (fh);
  if (error != ERROR_SUCCESS)
    __seterrno_from_win_error (error);
  return res;
d555 1
a555 1
  sd.Control |= SE_DACL_PROTECTED;
a1046 4
  static GENERIC_MAPPING NO_COPY mapping = { FILE_GENERIC_READ,
					     FILE_GENERIC_WRITE,
					     FILE_GENERIC_EXECUTE,
					     FILE_ALL_ACCESS };
d1055 1
a1055 1
    ret = check_access (sd, mapping, desired, flags, effective);
d1065 4
a1068 4
  static GENERIC_MAPPING NO_COPY mapping = { KEY_READ,
					     KEY_WRITE,
					     KEY_EXECUTE,
					     KEY_ALL_ACCESS };
d1077 1
a1077 1
    ret = check_access (sd, mapping, desired, flags, effective);
@


1.249
log
@	* security.cc: Fix copyright dates.
@
text
@d484 2
a485 3
   * modified by inheritable ACEs.  This flag is available since Win2K.  */
  if (wincap.has_dacl_protect ())
    sd.Control |= SE_DACL_PROTECTED;
@


1.248
log
@	* fhandler.cc (fhandler_base::open): When creating a file on a
	filesystem supporting ACLs, create the file with WRITE_DAC access.
	Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Always call GetSecurityInfo for directories
	on XP and Server 2003.  Improve comment to explain why.
	(set_file_attribute): Explicitely cast mode_t value to bool in call to
	get_file_sd.
	* wincap.h (wincaps::use_get_sec_info_on_dirs): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
@


1.247
log
@	* security.cc (alloc_sd): Really fix erroneous inheritence entry
	duplication now.  Add more comments for clarity.
@
text
@d46 21
a66 1
	  if (justcreated)
a67 11
	      /* Amazing but true.  If you want to know if an ACE is inherited
		 from the parent object, you can't use the NtQuerySecurityObject
		 function.  In the DACL returned by this functions, the
		 INHERITED_ACE flag is never set.  Only by calling
		 GetSecurityInfo you get this information.
		 
		 This functionality is slow, and the extra information is only
		 required when the file has been created and the permissions
		 are about to be set to POSIX permissions.  Therefore we only
		 use it in case the file just got created.  In all other cases
		 we rather call NtQuerySecurityObject directly. */
d69 2
a70 1
	      error = GetSecurityInfo (fh, SE_FILE_OBJECT, ALL_SECURITY_INFORMATION,
d889 1
a889 1
      if (!get_file_sd (handle, pc, sd, attribute & S_JUSTCREATED)
@


1.246
log
@	* security.cc (alloc_sd): Fix erroneous inheritence entry duplication.
@
text
@d644 2
a645 1
	  /* Check for related ACEs. */
d649 6
d658 4
a661 1
	      || (ace_sid == group_sid))
d663 5
a667 2
	      if (ace->Header.AceFlags
		  & (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE))
a668 2
	      else
		continue;
a669 4
	  else if ((ace_sid == well_known_creator_owner_sid)
		   || (ace_sid == well_known_creator_group_sid)
		   || (ace_sid == well_known_world_sid))
	    continue;
d703 3
a705 1
  /* Construct appropriate inherit attribute for new directories */
@


1.245
log
@	* errno.cc (errmap): Map ERROR_BAD_NET_RESP to ENOSYS.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Handle ENOSYS and
	point to  the explanation.
	* ntdll.h (STATUS_NOT_IMPLEMENTED): Define.
	* path.cc (symlink_info::check): Handle the inability of NT4 to use
	FileNetworkOpenInformation on share root dirs in either direction.
	* path.h (slash_unc_prefix_p): Remove unused declaration.
	* security.cc (get_info_from_sd): Handle ENOSYS from get_file_sd.
	Explain when this happens.
@
text
@d651 1
a651 2
	      || (ace_sid == group_sid)
	      || (ace_sid == well_known_world_sid))
d659 5
a663 1
	  else if (attribute & S_JUSTCREATED)
@


1.244
log
@	* flock.cc (allow_others_to_sync): Define MAX_PROCESS_SD_SIZE.  Use
	instead of ACL_DEFAULT_SIZE.
	* sec_acl.cc (setacl): Use TLS buffer to allow maximum ACL size.
	* security.h (ACL_DEFAULT_SIZE): Drop definition.
	(ACL_MAXIMUM_SIZE): Define.
	(SD_MAXIMUM_SIZE): Define.
	* security.cc (get_file_sd): Allocate security_decscriptor with size
	SD_MAXIMUM_SIZE.
	(alloc_sd): Use TLS buffer to allow maximum ACL size.
@
text
@d361 6
a366 1
      else
@


1.243
log
@	* security.cc (get_file_sd): Add bool parameter justcreated.  Use
	GetSecurityInfo only if justcreated is true, NtQuerySecurityObject
	otherwise.  Add comment to explain why.  Don't waste time to call
	NtQuerySecurityObject twice, just allocate big enough area.
	(get_file_attribute): Call get_file_sd with justcreated set to false.
	(set_file_attribute): Call get_file_sd with justcreated depending on
	S_JUSTCREATED pseudo file attribute.
	(check_file_access): Call get_file_sd with justcreated set to false.
	* sec_acl.cc (setacl): Ditto.
	(getacl): Ditto.
	* security.h: Convert many functions to regparm functions.
	(get_file_sd): Declare with extra bool parameter.
@
text
@d27 1
d72 1
a72 1
	      ULONG len = 32768;
d417 1
d488 2
a489 2
  PACL acl = (PACL) alloca (ACL_DEFAULT_SIZE);
  if (!InitializeAcl (acl, ACL_DEFAULT_SIZE, ACL_REVISION))
@


1.242
log
@	* sec_acl.cc (setacl): Use the long time unused ACL_DEFAULT_SIZE
	instead of a constant value.
	* security.cc (alloc_sd): Ditto.
@
text
@d34 2
a35 1
get_file_sd (HANDLE fh, path_conv &pc, security_descriptor &sd)
d45 1
a45 9
	  /* Amazing but true.  If you want to know if an ACE is inherited
	     from the parent object, you can't use the NtQuerySecurityObject
	     function.  In the DACL returned by this functions, the
	     INHERITED_ACE flag is never set.  Only by calling GetSecurityInfo
	     you get this information.  Oh well. */
	  PSECURITY_DESCRIPTOR psd;
	  error = GetSecurityInfo (fh, SE_FILE_OBJECT, ALL_SECURITY_INFORMATION,
				   NULL, NULL, NULL, NULL, &psd);
	  if (error == ERROR_SUCCESS)
d47 39
a85 3
	      sd = psd;
	      res = 0;
	      break;
d355 1
a355 1
      if (!get_file_sd (handle, pc, sd))
d860 1
a860 1
      if (!get_file_sd (handle, pc, sd)
d960 1
a960 1
  if (!get_file_sd (NULL, pc, sd))
@


1.241
log
@	* autoload.cc (GetNamedPipeClientProcessId): Define.
	* fhandler.h (fhandler_tty_slave::fch_open_handles): Declare private.
	(fhandler_tty_slave::fch_close_handles): Ditto.
	(fhandler_tty_slave::cygserver_attach_tty): Drop declaration.
	(fhandler_tty_slave::fstat): Declare public.
	(fhandler_tty_slave::fchmod): Declare public.
	(fhandler_tty_slave::fchown): Declare public.
	(class fhandler_pty_master): Add master_ctl handle.
	(fhandler_pty_master::pty_master_thread): Declare public.
	* fhandler_termios.cc (fhandler_termios::tcinit): If the process
	is started from a non-Cygwin process, make it tty process group
	leader.
	* fhandler_tty.cc: Throughout accommodate additional security related
	arguments in calls to functions creating or opening objects.
	(close_maybe): Move to start of file to reuse it
	in other methods.
	(struct pipe_request): Define.
	(struct pipe_reply): Define.
	(fhandler_tty_slave::open): Throughout, try to open synchronization
	objects with MAXIMUM_ALLOWED permissions.  Drop call to cygserver.
	Try to duplicate pipe handles via master_ctl pipe if duplicating
	directly doesn't work.
	(fhandler_tty_slave::cygserver_attach_tty): Remove.
	(fhandler_tty_slave::init): Close unused incoming pipe handle.
	(fhandler_pty_master::close): Send exit message to master control
	thread and close master_ctl handle.
	(fhandler_pty_master::pty_master_thread): New method, implementing the
	master control thread.
	(pty_master_thread): Static helper to start master control thread.
	(fhandler_pty_master::setup): Simplify creating pipe inheritance.
	Make sure we're the one creating the input_available_event.  Add
	comment to explain why.  Create master_ctl pipe and start master
	control thread.  Close master_ctl handle in case of error.
	* security.cc (alloc_sd): Add code to handle tty objects.  Add comments
	to explain what exactly is required.
	(get_object_sd): New function.
	(get_object_attribute): New function.
	(create_object_sd_from_attribute): New function.
	(set_object_sd): New function.
	(set_object_attribute): New function.
	(set_file_attribute): Change attribute type to mode_t.
	* security.h (set_file_attribute): Change attribute type to mode_t.
	(get_object_sd): Declare.
	(get_object_attribute): Declare.
	(create_object_sd_from_attribute): Declare.
	(set_object_sd): Declare.
	(set_object_attribute): Declare.
	* tty.cc (tty::slave_alive): Implement directly instead of via alive.
	(tty::exists): Open mutex handle with READ_CONTROL access.
	(tty::alive): Remove.
	(tty::open_output_mutex): Convert to inline method.
	(tty::open_input_mutex): Ditto.
	(tty::open_mutex): Take additional ACCESS_MASK parameter for the
	mutex open access mask.
	(tty::open_inuse): New method.
	(tty::create_inuse): Take PSECURITY_ATTRIBUTES parameter.  Drop fmt
	name parameter.  Always create TTY_SLAVE_ALIVE event.
	(tty::get_event): Take additional PSECURITY_ATTRIBUTES parameter for
	CreateEvent.
	* tty.h (class tty): Change declarations according to aforementioned
	changes.
	(tty::open_output_mutex): Implement as inline method.
	(tty::open_input_mutex): Ditto.
@
text
@d457 2
a458 2
  PACL acl = (PACL) alloca (3072);
  if (!InitializeAcl (acl, 3072, ACL_REVISION))
@


1.240
log
@
2010-02-26  Pierre Humblet <Pierre.Humblet@@ieee.org>

        * security.cc (check_access): Use user.imp_token if appropriate.
        Set errno and return if DuplicateTokenEx fails .
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
d467 4
d487 3
d492 1
a492 1
  DWORD group_allow = STANDARD_RIGHTS_READ
d504 6
d512 1
a512 1
  DWORD other_allow = STANDARD_RIGHTS_READ
d576 11
d609 2
a610 1
	  if (ace_sid == well_known_null_sid)
d745 77
d823 1
a823 1
		    __uid32_t uid, __gid32_t gid, int attribute)
@


1.239
log
@	* security.cc (alloc_sd): Re-introduce setting the SE_DACL_PROTECTED
	flag.  Remove INHERITED_ACE flag from all inherited ACEs.  Add comment.
	Fix ace_off counter in unrelated ACE loop.
	* wincap.cc: Re-add has_dacl_protect throughout.
	* wincap.h: Ditto.
@
text
@d754 11
a764 10
  if (!tok && !DuplicateTokenEx (hProcToken, MAXIMUM_ALLOWED, NULL,
				 SecurityImpersonation, TokenImpersonation,
				 &hProcImpToken))
#ifdef DEBUGGING
	system_printf ("DuplicateTokenEx failed, %E");
#else
	syscall_printf ("DuplicateTokenEx failed, %E");
#endif
  else
    tok = hProcImpToken;
@


1.238
log
@	* security.cc (alloc_sd): Re-enable generating default permission
	entries for directories.
@
text
@d437 5
d599 16
a614 8
	  else if ((attribute & S_JUSTCREATED)
		   && !(ace->Header.AceFlags & INHERITED_ACE))
	    /* Since files and dirs are created with a NULL descriptor,
	       inheritence rules kick in.  However, if no inheritable entries
	       exist in the parent object, Windows will create entries from the
	       user token's default DACL in the file DACL.  These entries are
	       not desired and we drop them silently here. */
	    continue;
d621 2
a622 2
		       ace->Header.AceType == ACCESS_DENIED_ACE_TYPE?
		       (owner_deny ? 1 : 0) : MAXDWORD,
d628 1
a636 1

@


1.237
log
@	* sec_helper.cc (security_descriptor::free): If sd_size is 0, call
	LocalFree instead of ::free.

	* sec_acl.cc: Throughout replace old ACE flag definitions with current
	definitions as used in MSDN man pages.
	* security.cc: Ditto.

	* fhandler.cc (fhandler_base::open): Make sure file has really been
	just created before fixing file permissions.  Add S_JUSTCREATED
	attribute to set_file_attribute call.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Always create dir
	with default security descriptor and fix descriptor afterwards.
	Add S_JUSTCREATED flag to set_file_attribute call.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Call GetSecurityInfo rather than
	NtQuerySecurityObject.  Explain why.  Change error handling accordingly.
	(alloc_sd): Skip non-inherited, non-standard entries in ACL if
	S_JUSTCREATED attribute is set.  Explain why.  Minor format fixes.
	* security.h (S_JUSTCREATED): New define.
	(security_descriptor::operator=): New operator.
@
text
@a617 6
#if 0
  /* CV 2009-02-04: Setting these inherit attributes for new dirs never was
     really POSIX-like but rather a concession for native Win32 processes.
     Disabled for now.  Let's test if that has really a visible negative
     impact. */

a659 1
#endif
@


1.236
log
@	* fhandler.cc (fhandler_base::open): Always create file with default
	security descriptor and fix descriptor afterwards.  Change comment to
	explain why.
	* security.cc (alloc_sd): Drop setting the SE_DACL_PROTECTED flag.
	* wincap.cc: Remove has_dacl_protect throughout.
	* wincap.h: Ditto.
@
text
@d27 1
d36 1
a36 2
  NTSTATUS status = STATUS_SUCCESS;
  ULONG len = 0;
d44 9
a52 13
	  status = NtQuerySecurityObject (fh, ALL_SECURITY_INFORMATION,
					  sd, len, &len);
	  if (status == STATUS_BUFFER_TOO_SMALL)
	    {
	      if (!sd.malloc (len))
		{
		  set_errno (ENOMEM);
		  break;
		}
	      status = NtQuerySecurityObject (fh, ALL_SECURITY_INFORMATION,
					      sd, len, &len);
	    }
	  if (NT_SUCCESS (status))
d54 1
d63 1
d72 1
d79 2
a80 2
  if (!NT_SUCCESS (status))
    __seterrno_from_nt_status (status);
d140 1
a140 1
      if (ace->Header.AceFlags & INHERIT_ONLY)
d388 3
d588 3
a590 2
	      if (ace->Header.AceFlags & SUB_CONTAINERS_AND_OBJECTS_INHERIT)
		ace->Header.AceFlags |= INHERIT_ONLY;
d594 8
d605 1
a605 1
	   * FIXME: this would break the order of the inherit_only ACEs
d625 1
a625 1
  if (S_ISDIR (attribute) && !acl_exists)
d627 2
a628 1
      const DWORD inherit = SUB_CONTAINERS_AND_OBJECTS_INHERIT | INHERIT_ONLY;
d645 2
a646 1
				   well_known_creator_owner_sid, acl_len, inherit))
d658 2
a659 1
				   well_known_creator_group_sid, acl_len, inherit))
@


1.235
log
@Fix faccessat(,0) and access() semantics.

* fhandler.h (fhandler_base::fhaccess): Add parameter.
* security.h (check_file_access, check_registry_access): Likewise.
* security.cc (check_file_access, check_registry_access)
(check_access): Implement new parameter.
* fhandler.cc (fhandler_base::fhaccess): Likewise.
(device_access_denied): Update caller.
* syscalls.cc (access, faccessat): Update callers.
* spawn.cc (find_exec, fixup): Likewise.
@
text
@a434 5
  /* We set the SE_DACL_PROTECTED flag here to prevent the DACL from being
   * modified by inheritable ACEs.  This flag is available since Win2K.  */
  if (wincap.has_dacl_protect ())
    sd.Control |= SE_DACL_PROTECTED;

@


1.234
log
@	* security.cc (set_file_sd): Drop using FILE_OPEN_FOR_RECOVERY flag in
	call to NtOpenFile.
	* exceptions.cc (open_stackdumpfile): Ditto in call to NtCreateFile.
	* fhandler.cc (fhandler_base::open): Ditto.  Simplify setting
	create_options.

	* mount.cc (fs_info::update): Recognize offline storage.
	(fillout_mntent): Report UDF and offline storage.
	* mount.h (class fs_info): Add is_csc_cache status flag.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
d728 1
a728 1
	      DWORD desired, int flags)
d735 3
a737 2
  HANDLE tok = cygheap->user.issetuid () ? cygheap->user.imp_token ()
					 : hProcImpToken;
d798 1
a798 1
check_file_access (path_conv &pc, int flags)
d814 1
a814 1
    ret = check_access (sd, mapping, desired, flags);
d820 1
a820 1
check_registry_access (HANDLE hdl, int flags)
d836 1
a836 1
    ret = check_access (sd, mapping, desired, flags);
@


1.233
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Catch an
	error when changing the user account on a standalone Samba server.
	Explain why.
	* sec_acl.cc (setacl): Accommodate additional parameter to set_file_sd.
	* sec_helper.cc (SECURITY_SAMBA_UNIX_AUTHORITY): Define.
	(well_known_samba_unix_user_fake_sid): Define.
	* security.cc (set_file_sd): Take additional parameter if ownership
	should be changed.  Restrict requested permissions accordingly.
	(set_file_attribute): Accommodate additional parameter to set_file_sd.
	* security.h (well_known_samba_unix_user_fake_sid): Declare.
	(set_file_sd): Align declaration to above change.
@
text
@d113 1
a113 2
			       FILE_OPEN_FOR_BACKUP_INTENT
			       | FILE_OPEN_FOR_RECOVERY);
@


1.232
log
@	* security.cc (alloc_sd): Disable generating default permission entries
	for directories.
@
text
@d86 1
a86 1
set_file_sd (HANDLE fh, path_conv &pc, security_descriptor &sd)
d96 4
a99 1
	  status = NtSetSecurityObject (fh, ALL_SECURITY_INFORMATION, sd);
d110 1
a110 2

	  status = NtOpenFile (&fh, WRITE_OWNER | WRITE_DAC,
d717 2
a718 1
	ret = set_file_sd (handle, pc, sd);
@


1.231
log
@	* sec_acl.cc (setacl): Align standard owner and group permissions
	with alloc_sd.  Strip FILE_READ_ATTRIBUTES fromn setting
	FILE_GENERIC_EXECUTE permissions same as in alloc_sd.
	* security.cc (alloc_sd): Reformat expression.  Strip EA permission
	bits from owner_deny and group_deny computation.
@
text
@d611 6
d656 1
@


1.230
log
@	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Drop fattr variable
	and use FILE_ATTRIBUTE_DIRECTORY directly in call to NtCreateFile.
	* posix_ipc.cc (ipc_mutex_init): Fix format string when creating IPC
	object name.
	(ipc_cond_init): Ditto.
	* security.cc (alloc_sd): Add parentheses to fix setting initial
	owner_allow value.
@
text
@d482 2
a483 2
  DWORD group_allow = STANDARD_RIGHTS_READ |
		      (pc.fs_is_samba () ? 0 : FILE_READ_ATTRIBUTES);
d529 1
a529 2
		  | FILE_READ_ATTRIBUTES | FILE_READ_EA
		  | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA);
d532 1
a532 2
  group_deny &= ~(STANDARD_RIGHTS_READ
		  | FILE_READ_ATTRIBUTES | FILE_READ_EA);
@


1.229
log
@	* external.cc (cygwin_internal): Call set_security_attribute with
	additional path_conv argument.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Never set DOS
	R/O attribute when using ACLs.
	(fhandler_disk_file::mkdir): Ditto.  Set
	security descriptor on remote dirs after creating the dir, same as in
	fhandler_base::open.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for remote AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto. for remote symlinks.
	* security.cc (alloc_sd): Take additional path_conv argument.
	Accommodate throughout.  Drop setting FILE_WRITE_EA/FILE_READ_EA
	flags unconditionally (was only necessary for "ntea"). Don't set
	FILE_READ_ATTRIBUTES and FILE_WRITE_ATTRIBUTES unconditionally on
	Samba.  Add comment to explain.  Drop useless setting of
	STANDARD_RIGHTS_WRITE, it's in FILE_GENERIC_WRITE anyway.
	Remove FILE_READ_ATTRIBUTES bit from FILE_GENERIC_EXECUTE so as not
	to enforce read permissions on Samba.
	(set_security_attribute): Take additional path_conv argument.
	* security.h (set_security_attribute): Change prototype accordingly.
@
text
@d469 2
a470 2
		      | pc.fs_is_samba ()
			? 0 : (FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES);
@


1.228
log
@	Throughout drop allow_ntsec and allow_smbntsec handling.
	* environ.cc (set_ntsec): Remove.
	(set_smbntsec): Remove.
	(known): Remove ntsec and smbntsec options.
	* external.cc (check_ntsec): Return true if no filename is given.
	* mount.cc (oopts): Add "acl" and "noacl" options.  Set MOUNT_NOACL
	flag accordingly.
	(fillout_mntent): Handle MOUNT_NOACL flag.
	* path.h (enum path_types): Add PATH_NOACL.
	* security.cc (allow_ntsec): Remove.
	(allow_smbntsec): Remove.
	* security.h (allow_ntsec): Drop declaration.
	(allow_smbntsec): Drop declaration.
	* include/sys/mount.h (MOUNT_NOACL): Define.
@
text
@d383 1
a383 1
alloc_sd (__uid32_t uid, __gid32_t gid, int attribute,
d465 3
a467 1
  /* Construct allow attribute for owner. */
d469 2
a470 1
		      | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA;
d476 1
a476 1
    owner_allow |= FILE_GENERIC_EXECUTE;
d482 2
a483 2
  DWORD group_allow = STANDARD_RIGHTS_READ
		      | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d487 1
a487 1
    group_allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE;
d489 1
a489 1
    group_allow |= FILE_GENERIC_EXECUTE;
d497 1
a497 1
		      | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d501 1
a501 1
    other_allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE;
d503 1
a503 1
    other_allow |= FILE_GENERIC_EXECUTE;
d688 1
a688 1
set_security_attribute (int attribute, PSECURITY_ATTRIBUTES psa,
d694 1
a694 1
  psa->lpSecurityDescriptor = alloc_sd (geteuid32 (), getegid32 (),
d708 2
a709 1
      if (!get_file_sd (handle, pc, sd) && alloc_sd (uid, gid, attribute, sd))
@


1.227
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@a31 6
/* Set ntsec explicit as default. */
bool allow_ntsec = true;
/* allow_smbntsec is handled exclusively in path.cc (path_conv::check).
   It's defined here because of it's strong relationship to allow_ntsec. */
bool allow_smbntsec;

d307 3
a309 1
  if (allow_ntsec)
d311 2
a312 7
      security_descriptor sd;

      if (!get_reg_sd (hkey, sd))
	{
	  get_info_from_sd (sd, attribute, uidret, gidret);
	  return 0;
	}
d322 1
a322 1
  if (pc.has_acls () && allow_ntsec)
d701 1
a701 1
  if (pc.has_acls () && allow_ntsec)
@


1.226
log
@	* security.cc (set_file_sd): Open file with FILE_OPEN_FOR_BACKUP_INTENT
	too.
@
text
@d58 1
a58 1
	        }
d69 1
a69 1
        {
d101 1
a101 1
        {
d110 1
a110 1
        {
d341 1
a341 1
        {
@


1.225
log
@	* dir.cc (readdir_worker): Convert w32name to PUNICODE_STRING.
	* sec_acl.cc (getacl): Convert debug output to print native NT path.
	* security.cc (set_file_attribute): Ditto.
	* syscalls.cc (try_to_bin): Ditto and fix buggy debug statement.
@
text
@d117 2
a118 1
			       FILE_OPEN_FOR_RECOVERY);
@


1.224
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): If file can't be
	opened for reading the ACLs, fall back to faking them.
	* sec_acl.cc (acl_worker): Handle non-existing files.
	* security.cc (get_file_attribute): Return ILLEGAL_UID/ILLEGAL_GID
	as owner/group for non-readable ACLs on file systems supporting them.
@
text
@d718 2
a719 2
  syscall_printf ("%d = set_file_attribute (%s, %d, %d, %p)",
		  ret, pc.get_win32 (), uid, gid, attribute);
@


1.223
log
@	* fhandler.cc (fhandler_base::fhaccess): Accommodate interface changes
	of access control functions throughout.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* sec_acl.cc: Drop unnecessary includes.
	(setacl): Take path_conv instead of file name as parameter.
	Accommodate interface changes of access control functions.
	(getacl): Ditto.
	* sec_auth.cc: New file, taking over all authentication related
	functions from security.cc.
	* sec_helper.cc: Drop unnecessary includes.
	* security.cc: Ditto.  Move all authentication related functions to
	sec_auth.cc.
	(ALL_SECURITY_INFORMATION): New define.  Use throughout.
	(set_file_sd): New function, replacing read_sd and the file related
	part of get_nt_object_security.
	(get_reg_sd): Rename from get_reg_security.  Drop type parameter.
	(get_reg_attribute): New function, replacing the registry related part
	of get_nt_object_security.
	(get_file_attribute): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(set_file_attribute): Ditto plus new set_file_sd.  Drop unnecessary
	implementation without uid/gid parameters.
	(check_file_access): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(check_registry_access): Use new get_reg_sd call.
	* security.h: Accommodate above interface changes.
@
text
@d339 9
@


1.222
log
@	* security.cc (set_nt_attribute): Remove.
	(set_file_attribute): Do it yourself instead of calling
	set_nt_attribute.
@
text
@d1 1
a1 1
/* security.cc: NT security functions
a15 2
#include <grp.h>
#include <pwd.h>
a17 12
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/acl.h>
#include <ctype.h>
#include <winnls.h>
#include <wingdi.h>
#include <winuser.h>
#include <wininet.h>
#include <ntsecapi.h>
#include <aclapi.h>
#include <dsgetdc.h>
a24 1
#include <ntdef.h>
a25 1
#include "lm.h"
d27 4
a30 2
#include "cyglsa.h"
#include <cygwin/version.h>
d38 2
a39 2
extern "C" void
cygwin_set_impersonation_token (const HANDLE hToken)
d41 4
a44 3
  debug_printf ("set_impersonation_token (%d)", hToken);
  cygheap->user.external_token = hToken == INVALID_HANDLE_VALUE ? NO_IMPERSONATION : hToken;
}
d46 1
a46 60
void
extract_nt_dom_user (const struct passwd *pw, char *domain, char *user)
{
  char *d, *u, *c;

  domain[0] = 0;
  strlcpy (user, pw->pw_name, UNLEN + 1);
  debug_printf ("pw_gecos %x (%s)", pw->pw_gecos, pw->pw_gecos);

  if ((d = strstr (pw->pw_gecos, "U-")) != NULL &&
      (d == pw->pw_gecos || d[-1] == ','))
    {
      c = strechr (d + 2, ',');
      if ((u = strechr (d + 2, '\\')) >= c)
	u = d + 1;
      else if (u - d <= INTERNET_MAX_HOST_NAME_LENGTH + 2)
	strlcpy (domain, d + 2, u - d - 1);
      if (c - u <= UNLEN + 1)
	strlcpy (user, u + 1, c - u);
    }
  if (domain[0])
    return;

  cygsid psid;
  DWORD ulen = UNLEN + 1;
  DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  SID_NAME_USE use;
  if (psid.getfrompw (pw))
    LookupAccountSid (NULL, psid, user, &ulen, domain, &dlen, &use);
}

extern "C" HANDLE
cygwin_logon_user (const struct passwd *pw, const char *password)
{
  if (!pw)
    {
      set_errno (EINVAL);
      return INVALID_HANDLE_VALUE;
    }

  char nt_domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  char nt_user[UNLEN + 1];
  HANDLE hToken;

  extract_nt_dom_user (pw, nt_domain, nt_user);
  debug_printf ("LogonUserA (%s, %s, %s, ...)", nt_user, nt_domain, password);
  /* CV 2005-06-08: LogonUser should run under the primary process token,
     otherwise it returns with ERROR_ACCESS_DENIED on W2K. Don't ask me why. */
  RevertToSelf ();
  if (!LogonUserA (nt_user, *nt_domain ? nt_domain : NULL, (char *) password,
		   LOGON32_LOGON_INTERACTIVE,
		   LOGON32_PROVIDER_DEFAULT,
		   &hToken))
    {
      __seterrno ();
      hToken = INVALID_HANDLE_VALUE;
    }
  else if (!SetHandleInformation (hToken,
				  HANDLE_FLAG_INHERIT,
				  HANDLE_FLAG_INHERIT))
d48 1
a48 115
      __seterrno ();
      CloseHandle (hToken);
      hToken = INVALID_HANDLE_VALUE;
    }
  cygheap->user.reimpersonate ();
  debug_printf ("%d = logon_user(%s,...)", hToken, pw->pw_name);
  return hToken;
}

static void
str2lsa (LSA_STRING &tgt, const char *srcstr)
{
  tgt.Length = strlen (srcstr);
  tgt.MaximumLength = tgt.Length + 1;
  tgt.Buffer = (PCHAR) srcstr;
}

static void
str2buf2lsa (LSA_STRING &tgt, char *buf, const char *srcstr)
{
  tgt.Length = strlen (srcstr);
  tgt.MaximumLength = tgt.Length + 1;
  tgt.Buffer = (PCHAR) buf;
  memcpy (buf, srcstr, tgt.MaximumLength);
}

/* The dimension of buf is assumed to be at least strlen(srcstr) + 1,
   The result will be shorter if the input has multibyte chars */
void
str2buf2uni (UNICODE_STRING &tgt, WCHAR *buf, const char *srcstr)
{
  tgt.Buffer = (PWCHAR) buf;
  tgt.MaximumLength = (strlen (srcstr) + 1) * sizeof (WCHAR);
  tgt.Length = sys_mbstowcs (buf, srcstr, tgt.MaximumLength / sizeof (WCHAR))
	       * sizeof (WCHAR);
  if (tgt.Length)
    tgt.Length -= sizeof (WCHAR);
}

void
str2uni_cat (UNICODE_STRING &tgt, const char *srcstr)
{
  int len = sys_mbstowcs (tgt.Buffer + tgt.Length / sizeof (WCHAR), srcstr,
			  (tgt.MaximumLength - tgt.Length) / sizeof (WCHAR));
  if (len)
    tgt.Length += (len - 1) * sizeof (WCHAR);
  else
    tgt.Length = tgt.MaximumLength = 0;
}

static LSA_HANDLE
open_local_policy ()
{
  LSA_OBJECT_ATTRIBUTES oa = { 0, 0, 0, 0, 0, 0 };
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;

  NTSTATUS ret = LsaOpenPolicy (NULL, &oa, POLICY_EXECUTE, &lsa);
  if (ret != STATUS_SUCCESS)
    __seterrno_from_win_error (LsaNtStatusToWinError (ret));
  return lsa;
}

static void
close_local_policy (LSA_HANDLE &lsa)
{
  if (lsa != INVALID_HANDLE_VALUE)
    LsaClose (lsa);
  lsa = INVALID_HANDLE_VALUE;
}

/* CV, 2006-07-06: Missing in w32api. */
extern "C" DWORD WINAPI DsGetDcNameA (LPCSTR, LPCSTR, GUID *, LPCSTR, ULONG,
				      PDOMAIN_CONTROLLER_INFOA *);
#define DS_FORCE_REDISCOVERY	1

bool
get_logon_server (const char *domain, char *server, WCHAR *wserver,
		  bool rediscovery)
{
  DWORD dret;
  PDOMAIN_CONTROLLER_INFOA pci;
  WCHAR *buf;
  DWORD size = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  WCHAR wdomain[size];

  /* Empty domain is interpreted as local system */
  if ((GetComputerName (server + 2, &size)) &&
      (strcasematch (domain, server + 2) || !domain[0]))
    {
      server[0] = server[1] = '\\';
      if (wserver)
	sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      return true;
    }

  /* Try to get any available domain controller for this domain */
  dret = DsGetDcNameA (NULL, domain, NULL, NULL,
		       rediscovery ? DS_FORCE_REDISCOVERY : 0, &pci);
  if (dret == ERROR_SUCCESS)
    {
      strcpy (server, pci->DomainControllerName);
      sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      NetApiBufferFree (pci);
      debug_printf ("DC: rediscovery: %d, server: %s", rediscovery, server);
      return true;
    }
  else if (dret == ERROR_PROC_NOT_FOUND)
    {
      /* NT4 w/o DSClient */
      sys_mbstowcs (wdomain, domain, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      if (rediscovery)
	dret = NetGetAnyDCName (NULL, wdomain, (LPBYTE *) &buf);
      else
	dret = NetGetDCName (NULL, wdomain, (LPBYTE *) &buf);
      if (dret == NERR_Success)
d50 3
a52 428
	  sys_wcstombs (server, INTERNET_MAX_HOST_NAME_LENGTH + 1, buf);
	  if (wserver)
	    for (WCHAR *ptr1 = buf; (*wserver++ = *ptr1++);)
	      ;
	  NetApiBufferFree (buf);
	  debug_printf ("NT: rediscovery: %d, server: %s", rediscovery, server);
	  return true;
	}
    }
  __seterrno_from_win_error (dret);
  return false;
}

static bool
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user,
		 char *domain)
{
  char dgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
  WCHAR wuser[UNLEN + 1];
  sys_mbstowcs (wuser, user, UNLEN + 1);
  LPGROUP_USERS_INFO_0 buf;
  DWORD cnt, tot, len;
  NET_API_STATUS ret;

  /* Look only on logonserver */
  ret = NetUserGetGroups (wlogonserver, wuser, 0, (LPBYTE *) &buf,
			  MAX_PREFERRED_LENGTH, &cnt, &tot);
  if (ret)
    {
      __seterrno_from_win_error (ret);
      /* It's no error when the user name can't be found. */
      return ret == NERR_UserNotFound;
    }

  len = strlen (domain);
  strcpy (dgroup, domain);
  dgroup[len++] = '\\';

  for (DWORD i = 0; i < cnt; ++i)
    {
      cygsid gsid;
      DWORD glen = MAX_SID_LEN;
      char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      DWORD dlen = sizeof (domain);
      SID_NAME_USE use = SidTypeInvalid;

      sys_wcstombs (dgroup + len, GNLEN + 1, buf[i].grui0_name);
      if (!LookupAccountName (NULL, dgroup, gsid, &glen, domain, &dlen, &use))
	debug_printf ("LookupAccountName(%s), %E", dgroup);
      else if (legal_sid_type (use))
	grp_list += gsid;
      else
	debug_printf ("Global group %s invalid. Domain: %s Use: %d",
		      dgroup, domain, use);
    }

  NetApiBufferFree (buf);
  return true;
}

static bool
is_group_member (WCHAR *wgroup, PSID pusersid, cygsidlist &grp_list)
{
  LPLOCALGROUP_MEMBERS_INFO_1 buf;
  DWORD cnt, tot;
  NET_API_STATUS ret;

  /* Members can be users or global groups */
  ret = NetLocalGroupGetMembers (NULL, wgroup, 1, (LPBYTE *) &buf,
				 MAX_PREFERRED_LENGTH, &cnt, &tot, NULL);
  if (ret)
    return false;

  bool retval = true;
  for (DWORD bidx = 0; bidx < cnt; ++bidx)
    if (EqualSid (pusersid, buf[bidx].lgrmi1_sid))
      goto done;
    else
      {
	/* The extra test for the group being a global group or a well-known
	   group is necessary, since apparently also aliases (for instance
	   Administrators or Users) can be members of local groups, even
	   though MSDN states otherwise.  The GUI refuses to put aliases into
	   local groups, but the CLI interface allows it.  However, a normal
	   logon token does not contain groups, in which the user is only
	   indirectly a member by being a member of an alias in this group.
	   So we also should not put them into the token group list.
	   Note: Allowing those groups in our group list renders external
	   tokens invalid, so that it becomes impossible to logon with
	   password and valid logon token. */
	for (int glidx = 0; glidx < grp_list.count (); ++glidx)
	  if ((buf[bidx].lgrmi1_sidusage == SidTypeGroup
	       || buf[bidx].lgrmi1_sidusage == SidTypeWellKnownGroup)
	      && EqualSid (grp_list.sids[glidx], buf[bidx].lgrmi1_sid))
	    goto done;
      }

  retval = false;
 done:
  NetApiBufferFree (buf);
  return retval;
}

static bool
get_user_local_groups (cygsidlist &grp_list, PSID pusersid)
{
  LPLOCALGROUP_INFO_0 buf;
  DWORD cnt, tot;
  NET_API_STATUS ret;

  ret = NetLocalGroupEnum (NULL, 0, (LPBYTE *) &buf,
			   MAX_PREFERRED_LENGTH, &cnt, &tot, NULL);
  if (ret)
    {
      __seterrno_from_win_error (ret);
      return false;
    }

  char bgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
  char lgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
  DWORD blen, llen;
  SID_NAME_USE use;

  blen = llen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  if (!LookupAccountSid (NULL, well_known_admins_sid, lgroup, &llen, bgroup, &blen, &use)
      || !GetComputerNameA (lgroup, &(llen = INTERNET_MAX_HOST_NAME_LENGTH + 1)))
    {
      __seterrno ();
      return false;
    }
  bgroup[blen++] = lgroup[llen++] = '\\';

  for (DWORD i = 0; i < cnt; ++i)
    if (is_group_member (buf[i].lgrpi0_name, pusersid, grp_list))
      {
	cygsid gsid;
	DWORD glen = MAX_SID_LEN;
	char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
	DWORD dlen = sizeof (domain);

	use = SidTypeInvalid;
	sys_wcstombs (bgroup + blen, GNLEN + 1, buf[i].lgrpi0_name);
	if (!LookupAccountName (NULL, bgroup, gsid, &glen, domain, &dlen, &use))
	  {
	    if (GetLastError () != ERROR_NONE_MAPPED)
	      debug_printf ("LookupAccountName(%s), %E", bgroup);
	    strcpy (lgroup + llen, bgroup + blen);
	    if (!LookupAccountName (NULL, lgroup, gsid, &glen,
				    domain, &dlen, &use))
	      debug_printf ("LookupAccountName(%s), %E", lgroup);
	  }
	if (!legal_sid_type (use))
	  debug_printf ("Rejecting local %s. use: %d", bgroup + blen, use);
	grp_list *= gsid;
      }
  NetApiBufferFree (buf);
  return true;
}

static bool
sid_in_token_groups (PTOKEN_GROUPS grps, cygpsid sid)
{
  if (!grps)
    return false;
  for (DWORD i = 0; i < grps->GroupCount; ++i)
    if (sid == grps->Groups[i].Sid)
      return true;
  return false;
}

#if 0				/* Unused */
static BOOL
get_user_primary_group (WCHAR *wlogonserver, const char *user,
			PSID pusersid, cygsid &pgrpsid)
{
  LPUSER_INFO_3 buf;
  WCHAR wuser[UNLEN + 1];
  NET_API_STATUS ret;
  BOOL retval = FALSE;
  UCHAR count = 0;

  if (well_known_system_sid == pusersid)
    {
      pgrpsid = well_known_system_sid;
      return TRUE;
    }

  sys_mbstowcs (wuser, user, UNLEN + 1);
  ret = NetUserGetInfo (wlogonserver, wuser, 3, (LPBYTE *) &buf);
  if (ret)
    {
      __seterrno_from_win_error (ret);
      return FALSE;
    }

  pgrpsid = pusersid;
  if (IsValidSid (pgrpsid)
      && (count = *GetSidSubAuthorityCount (pgrpsid)) > 1)
    {
      *GetSidSubAuthority (pgrpsid, count - 1) = buf->usri3_primary_group_id;
      retval = TRUE;
    }
  NetApiBufferFree (buf);
  return retval;
}
#endif

static void
get_unix_group_sidlist (struct passwd *pw, cygsidlist &grp_list)
{
  struct __group32 *gr;
  cygsid gsid;

  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
    {
      if (gr->gr_gid == (__gid32_t) pw->pw_gid)
	goto found;
      else if (gr->gr_mem)
	for (int gi = 0; gr->gr_mem[gi]; ++gi)
	  if (strcasematch (pw->pw_name, gr->gr_mem[gi]))
	    goto found;
      continue;
    found:
      if (gsid.getfromgr (gr))
	grp_list += gsid;

    }
}

static void
get_token_group_sidlist (cygsidlist &grp_list, PTOKEN_GROUPS my_grps,
			 LUID auth_luid, int &auth_pos)
{
  auth_pos = -1;
  if (my_grps)
    {
      grp_list += well_known_local_sid;
      if (sid_in_token_groups (my_grps, well_known_dialup_sid))
	grp_list *= well_known_dialup_sid;
      if (sid_in_token_groups (my_grps, well_known_network_sid))
	grp_list *= well_known_network_sid;
      if (sid_in_token_groups (my_grps, well_known_batch_sid))
	grp_list *= well_known_batch_sid;
      grp_list *= well_known_interactive_sid;
      if (sid_in_token_groups (my_grps, well_known_service_sid))
	grp_list *= well_known_service_sid;
      if (sid_in_token_groups (my_grps, well_known_this_org_sid))
	grp_list *= well_known_this_org_sid;
    }
  else
    {
      grp_list += well_known_local_sid;
      grp_list *= well_known_interactive_sid;
    }
  if (get_ll (auth_luid) != 999LL) /* != SYSTEM_LUID */
    {
      for (DWORD i = 0; i < my_grps->GroupCount; ++i)
	if (my_grps->Groups[i].Attributes & SE_GROUP_LOGON_ID)
	  {
	    grp_list += my_grps->Groups[i].Sid;
	    auth_pos = grp_list.count () - 1;
	    break;
	  }
    }
}

bool
get_server_groups (cygsidlist &grp_list, PSID usersid, struct passwd *pw)
{
  char user[UNLEN + 1];
  char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  WCHAR wserver[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  char server[INTERNET_MAX_HOST_NAME_LENGTH + 3];

  if (well_known_system_sid == usersid)
    {
      grp_list *= well_known_admins_sid;
      get_unix_group_sidlist (pw, grp_list);
      return true;
    }

  grp_list *= well_known_world_sid;
  grp_list *= well_known_authenticated_users_sid;
  extract_nt_dom_user (pw, domain, user);
  if (get_logon_server (domain, server, wserver, false)
      && !get_user_groups (wserver, grp_list, user, domain)
      && get_logon_server (domain, server, wserver, true))
    get_user_groups (wserver, grp_list, user, domain);
  if (get_user_local_groups (grp_list, usersid))
    {
      get_unix_group_sidlist (pw, grp_list);
      return true;
    }
  return false;
}

static bool
get_initgroups_sidlist (cygsidlist &grp_list,
			PSID usersid, PSID pgrpsid, struct passwd *pw,
			PTOKEN_GROUPS my_grps, LUID auth_luid, int &auth_pos)
{
  grp_list *= well_known_world_sid;
  grp_list *= well_known_authenticated_users_sid;
  if (well_known_system_sid == usersid)
    auth_pos = -1;
  else
    get_token_group_sidlist (grp_list, my_grps, auth_luid, auth_pos);
  if (!get_server_groups (grp_list, usersid, pw))
    return false;

  /* special_pgrp true if pgrpsid is not in normal groups */
  grp_list += pgrpsid;
  return true;
}

static void
get_setgroups_sidlist (cygsidlist &tmp_list, PSID usersid, struct passwd *pw,
		       PTOKEN_GROUPS my_grps, user_groups &groups,
		       LUID auth_luid, int &auth_pos)
{
  tmp_list *= well_known_world_sid;
  tmp_list *= well_known_authenticated_users_sid;
  get_token_group_sidlist (tmp_list, my_grps, auth_luid, auth_pos);
  get_server_groups (tmp_list, usersid, pw);
  for (int gidx = 0; gidx < groups.sgsids.count (); gidx++)
    tmp_list += groups.sgsids.sids[gidx];
  tmp_list += groups.pgsid;
}

static ULONG sys_privs[] = {
  SE_CREATE_TOKEN_PRIVILEGE,
  SE_ASSIGNPRIMARYTOKEN_PRIVILEGE,		
  SE_LOCK_MEMORY_PRIVILEGE,		
  SE_INCREASE_QUOTA_PRIVILEGE,		
  SE_TCB_PRIVILEGE,		
  SE_SECURITY_PRIVILEGE,		
  SE_TAKE_OWNERSHIP_PRIVILEGE,		
  SE_LOAD_DRIVER_PRIVILEGE,		
  SE_SYSTEM_PROFILE_PRIVILEGE,		/* Vista ONLY */
  SE_SYSTEMTIME_PRIVILEGE,		
  SE_PROF_SINGLE_PROCESS_PRIVILEGE,		
  SE_INC_BASE_PRIORITY_PRIVILEGE,		
  SE_CREATE_PAGEFILE_PRIVILEGE,		
  SE_CREATE_PERMANENT_PRIVILEGE,		
  SE_BACKUP_PRIVILEGE,		
  SE_RESTORE_PRIVILEGE,		
  SE_SHUTDOWN_PRIVILEGE,		
  SE_DEBUG_PRIVILEGE,		
  SE_AUDIT_PRIVILEGE,		
  SE_SYSTEM_ENVIRONMENT_PRIVILEGE,		
  SE_CHANGE_NOTIFY_PRIVILEGE,		
  SE_UNDOCK_PRIVILEGE,
  SE_MANAGE_VOLUME_PRIVILEGE,
  SE_IMPERSONATE_PRIVILEGE,
  SE_CREATE_GLOBAL_PRIVILEGE,
  SE_INCREASE_WORKING_SET_PRIVILEGE,
  SE_TIME_ZONE_PRIVILEGE,
  SE_CREATE_SYMBOLIC_LINK_PRIVILEGE
};

#define SYSTEM_PRIVILEGES_COUNT (sizeof sys_privs / sizeof *sys_privs)

static PTOKEN_PRIVILEGES
get_system_priv_list (size_t &size)
{
  ULONG max_idx = 0;
  while (max_idx < SYSTEM_PRIVILEGES_COUNT
  	 && sys_privs[max_idx] != wincap.max_sys_priv ())
    ++max_idx;
  if (max_idx >= SYSTEM_PRIVILEGES_COUNT)
    api_fatal ("Coding error: wincap privilege %u doesn't exist in sys_privs",
	       wincap.max_sys_priv ());
  size = sizeof (ULONG) + (max_idx + 1) * sizeof (LUID_AND_ATTRIBUTES);
  PTOKEN_PRIVILEGES privs = (PTOKEN_PRIVILEGES) malloc (size);
  if (!privs)
    {
      debug_printf ("malloc (system_privs) failed.");
      return NULL;
    }
  privs->PrivilegeCount = 0;
  for (ULONG i = 0; i <= max_idx; ++i)
    {
      privs->Privileges[privs->PrivilegeCount].Luid.HighPart = 0L;
      privs->Privileges[privs->PrivilegeCount].Luid.LowPart = sys_privs[i];
      privs->Privileges[privs->PrivilegeCount].Attributes =
	SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
      ++privs->PrivilegeCount;
    }
  return privs;
}

static PTOKEN_PRIVILEGES
get_priv_list (LSA_HANDLE lsa, cygsid &usersid, cygsidlist &grp_list,
	       size_t &size)
{
  PLSA_UNICODE_STRING privstrs;
  ULONG cnt;
  PTOKEN_PRIVILEGES privs = NULL;
  NTSTATUS ret;
  char buf[INTERNET_MAX_HOST_NAME_LENGTH + 1];

  if (usersid == well_known_system_sid)
    return get_system_priv_list (size);

  for (int grp = -1; grp < grp_list.count (); ++grp)
    {
      if (grp == -1)
	{
	  if ((ret = LsaEnumerateAccountRights (lsa, usersid, &privstrs,
						&cnt)) != STATUS_SUCCESS)
	    continue;
	}
      else if ((ret = LsaEnumerateAccountRights (lsa, grp_list.sids[grp],
						 &privstrs, &cnt))
	       != STATUS_SUCCESS)
	continue;
      for (ULONG i = 0; i < cnt; ++i)
	{
	  LUID priv;
	  PTOKEN_PRIVILEGES tmp;
	  DWORD tmp_count;

	  sys_wcstombs (buf, sizeof (buf),
			privstrs[i].Buffer, privstrs[i].Length / 2);
	  if (!privilege_luid (buf, &priv))
	    continue;

	  if (privs)
d54 7
a60 6
	      DWORD pcnt = privs->PrivilegeCount;
	      LUID_AND_ATTRIBUTES *p = privs->Privileges;
	      for (; pcnt > 0; --pcnt, ++p)
		if (priv.HighPart == p->Luid.HighPart
		    && priv.LowPart == p->Luid.LowPart)
		  goto next_account_right;
d62 1
a62 6

	  tmp_count = privs ? privs->PrivilegeCount : 0;
	  size = sizeof (DWORD)
		 + (tmp_count + 1) * sizeof (LUID_AND_ATTRIBUTES);
	  tmp = (PTOKEN_PRIVILEGES) realloc (privs, size);
	  if (!tmp)
d64 2
a65 5
	      if (privs)
		free (privs);
	      LsaFreeMemory (privstrs);
	      debug_printf ("realloc (privs) failed.");
	      return NULL;
a66 9
	  tmp->PrivilegeCount = tmp_count;
	  privs = tmp;
	  privs->Privileges[privs->PrivilegeCount].Luid = priv;
	  privs->Privileges[privs->PrivilegeCount].Attributes =
	    SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
	  ++privs->PrivilegeCount;

	next_account_right:
	  ;
d68 14
a81 94
      LsaFreeMemory (privstrs);
    }
  return privs;
}

/* Accept a token if
   - the requested usersid matches the TokenUser and
   - if setgroups has been called:
	the token groups that are listed in /etc/group match the union of
	the requested primary and supplementary groups in gsids.
   - else the (unknown) implicitly requested supplementary groups and those
	in the token are the groups associated with the usersid. We assume
	they match and verify only the primary groups.
	The requested primary group must appear in the token.
	The primary group in the token is a group associated with the usersid,
	except if the token is internal and the group is in the token SD
	(see create_token). In that latter case that group must match the
	requested primary group.  */
bool
verify_token (HANDLE token, cygsid &usersid, user_groups &groups, bool *pintern)
{
  DWORD size;
  bool intern = false;

  if (pintern)
    {
      TOKEN_SOURCE ts;
      if (!GetTokenInformation (token, TokenSource,
				&ts, sizeof ts, &size))
	debug_printf ("GetTokenInformation(), %E");
      else
	*pintern = intern = !memcmp (ts.SourceName, "Cygwin.1", 8);
    }
  /* Verify usersid */
  cygsid tok_usersid = NO_SID;
  if (!GetTokenInformation (token, TokenUser,
			    &tok_usersid, sizeof tok_usersid, &size))
    debug_printf ("GetTokenInformation(), %E");
  if (usersid != tok_usersid)
    return false;

  /* For an internal token, if setgroups was not called and if the sd group
     is not well_known_null_sid, it must match pgrpsid */
  if (intern && !groups.issetgroups ())
    {
      const DWORD sd_buf_siz = MAX_SID_LEN + sizeof (SECURITY_DESCRIPTOR);
      PSECURITY_DESCRIPTOR sd_buf = (PSECURITY_DESCRIPTOR) alloca (sd_buf_siz);
      cygpsid gsid (NO_SID);
      if (!GetKernelObjectSecurity (token, GROUP_SECURITY_INFORMATION,
				    sd_buf, sd_buf_siz, &size))
	debug_printf ("GetKernelObjectSecurity(), %E");
      else if (!GetSecurityDescriptorGroup (sd_buf, (PSID *) &gsid,
					    (BOOL *) &size))
	debug_printf ("GetSecurityDescriptorGroup(), %E");
      if (well_known_null_sid != gsid)
	return gsid == groups.pgsid;
    }

  PTOKEN_GROUPS my_grps;
  bool sawpg = false, ret = false;

  if (!GetTokenInformation (token, TokenGroups, NULL, 0, &size) &&
      GetLastError () != ERROR_INSUFFICIENT_BUFFER)
    debug_printf ("GetTokenInformation(token, TokenGroups), %E");
  else if (!(my_grps = (PTOKEN_GROUPS) alloca (size)))
    debug_printf ("alloca (my_grps) failed.");
  else if (!GetTokenInformation (token, TokenGroups, my_grps, size, &size))
    debug_printf ("GetTokenInformation(my_token, TokenGroups), %E");
  else
    {
      if (groups.issetgroups ()) /* setgroups was called */
	{
	  cygsid gsid;
	  struct __group32 *gr;
	  bool saw[groups.sgsids.count ()];
	  memset (saw, 0, sizeof(saw));

	  /* token groups found in /etc/group match the user.gsids ? */
	  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	    if (gsid.getfromgr (gr) && sid_in_token_groups (my_grps, gsid))
	      {
		int pos = groups.sgsids.position (gsid);
		if (pos >= 0)
		  saw[pos] = true;
		else if (groups.pgsid == gsid)
		  sawpg = true;
		else if (gsid != well_known_world_sid
			 && gsid != usersid)
		  goto done;
	      }
	  /* user.sgsids groups must be in the token */
	  for (int gidx = 0; gidx < groups.sgsids.count (); gidx++)
	    if (!saw[gidx] && !sid_in_token_groups (my_grps, groups.sgsids.sids[gidx]))
	      goto done;
a82 4
      /* The primary group must be in the token */
      ret = sawpg
	|| sid_in_token_groups (my_grps, groups.pgsid)
	|| groups.pgsid == usersid;
d84 5
a88 2
done:
  return ret;
d91 2
a92 2
HANDLE
create_token (cygsid &usersid, user_groups &new_groups, struct passwd *pw)
d94 3
a96 2
  NTSTATUS ret;
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;
d98 1
a98 105
  cygsidlist tmp_gsids (cygsidlist_auto, 12);

  SECURITY_QUALITY_OF_SERVICE sqos =
    { sizeof sqos, SecurityImpersonation, SECURITY_STATIC_TRACKING, FALSE };
  OBJECT_ATTRIBUTES oa = { sizeof oa, 0, 0, 0, 0, &sqos };
  LUID auth_luid = SYSTEM_LUID;
  LARGE_INTEGER exp = { QuadPart:INT64_MAX };

  TOKEN_USER user;
  PTOKEN_GROUPS new_tok_gsids = NULL;
  PTOKEN_PRIVILEGES privs = NULL;
  TOKEN_OWNER owner;
  TOKEN_PRIMARY_GROUP pgrp;
  TOKEN_DEFAULT_DACL dacl = {};
  TOKEN_SOURCE source;
  TOKEN_STATISTICS stats;
  memcpy (source.SourceName, "Cygwin.1", 8);
  source.SourceIdentifier.HighPart = 0;
  source.SourceIdentifier.LowPart = 0x0101;

  HANDLE token = INVALID_HANDLE_VALUE;
  HANDLE primary_token = INVALID_HANDLE_VALUE;

  PTOKEN_GROUPS my_tok_gsids = NULL;
  DWORD size;
  size_t psize = 0;

  /* SE_CREATE_TOKEN_NAME privilege needed to call NtCreateToken. */
  push_self_privilege (SE_CREATE_TOKEN_PRIVILEGE, true);

  /* Open policy object. */
  if ((lsa = open_local_policy ()) == INVALID_HANDLE_VALUE)
    goto out;

  /* User, owner, primary group. */
  user.User.Sid = usersid;
  user.User.Attributes = 0;
  owner.Owner = usersid;

  /* Retrieve authentication id and group list from own process. */
  if (hProcToken)
    {
      /* Switching user context to SYSTEM doesn't inherit the authentication
	 id of the user account running current process. */
      if (usersid != well_known_system_sid)
	if (!GetTokenInformation (hProcToken, TokenStatistics,
				  &stats, sizeof stats, &size))
	  debug_printf
	    ("GetTokenInformation(hProcToken, TokenStatistics), %E");
	else
	  auth_luid = stats.AuthenticationId;

      /* Retrieving current processes group list to be able to inherit
	 some important well known group sids. */
      if (!GetTokenInformation (hProcToken, TokenGroups, NULL, 0, &size)
	  && GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(hProcToken, TokenGroups), %E");
      else if (!(my_tok_gsids = (PTOKEN_GROUPS) malloc (size)))
	debug_printf ("malloc (my_tok_gsids) failed.");
      else if (!GetTokenInformation (hProcToken, TokenGroups, my_tok_gsids,
				     size, &size))
	{
	  debug_printf ("GetTokenInformation(hProcToken, TokenGroups), %E");
	  free (my_tok_gsids);
	  my_tok_gsids = NULL;
	}
    }

  /* Create list of groups, the user is member in. */
  int auth_pos;
  if (new_groups.issetgroups ())
    get_setgroups_sidlist (tmp_gsids, usersid, pw, my_tok_gsids, new_groups,
			   auth_luid, auth_pos);
  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid, pw,
				    my_tok_gsids, auth_luid, auth_pos))
    goto out;

  /* Primary group. */
  pgrp.PrimaryGroup = new_groups.pgsid;

  /* Create a TOKEN_GROUPS list from the above retrieved list of sids. */
  new_tok_gsids = (PTOKEN_GROUPS)
		  alloca (sizeof (DWORD) + tmp_gsids.count ()
					   * sizeof (SID_AND_ATTRIBUTES));
  new_tok_gsids->GroupCount = tmp_gsids.count ();
  for (DWORD i = 0; i < new_tok_gsids->GroupCount; ++i)
    {
      new_tok_gsids->Groups[i].Sid = tmp_gsids.sids[i];
      new_tok_gsids->Groups[i].Attributes = SE_GROUP_MANDATORY
					    | SE_GROUP_ENABLED_BY_DEFAULT
					    | SE_GROUP_ENABLED;
    }
  if (auth_pos >= 0)
    new_tok_gsids->Groups[auth_pos].Attributes |= SE_GROUP_LOGON_ID;
  /* Retrieve list of privileges of that user. */
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize)))
    goto out;

  /* Let's be heroic... */
  ret = NtCreateToken (&token, TOKEN_ALL_ACCESS, &oa, TokenImpersonation,
		       &auth_luid, &exp, &user, new_tok_gsids, privs, &owner,
		       &pgrp, &dacl, &source);
  if (ret)
    __seterrno_from_nt_status (ret);
  else if (GetLastError () == ERROR_PROC_NOT_FOUND)
d100 8
a107 12
      __seterrno ();
      debug_printf ("Loading NtCreateToken failed.");
    }
  else
    {
      /* Convert to primary token. */
      if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, &sec_none,
			     SecurityImpersonation, TokenPrimary,
			     &primary_token))
	{
	  __seterrno ();
	  debug_printf ("DuplicateTokenEx %E");
d109 14
a122 241
    }

out:
  pop_self_privilege ();
  if (token != INVALID_HANDLE_VALUE)
    CloseHandle (token);
  if (privs)
    free (privs);
  if (my_tok_gsids)
    free (my_tok_gsids);
  close_local_policy (lsa);

  debug_printf ("0x%x = create_token ()", primary_token);
  return primary_token;
}

HANDLE
lsaauth (cygsid &usersid, user_groups &new_groups, struct passwd *pw)
{
  cygsidlist tmp_gsids (cygsidlist_auto, 12);
  cygpsid pgrpsid;
  LSA_STRING name;
  HANDLE lsa_hdl = NULL, lsa = INVALID_HANDLE_VALUE;
  LSA_OPERATIONAL_MODE sec_mode;
  NTSTATUS ret, ret2;
  ULONG package_id, size;
  LUID auth_luid = SYSTEM_LUID;
  struct {
    LSA_STRING str;
    CHAR buf[16];
  } origin;
  cyglsa_t *authinf = NULL;
  ULONG authinf_size;
  TOKEN_SOURCE ts;
  PCYG_TOKEN_GROUPS gsids = NULL;
  PTOKEN_PRIVILEGES privs = NULL;
  PACL dacl = NULL;
  PVOID profile = NULL;
  LUID luid;
  QUOTA_LIMITS quota;
  size_t psize = 0, gsize = 0, dsize = 0;
  OFFSET offset, sids_offset;
  int tmpidx, non_well_known_cnt;

  HANDLE user_token = NULL;

  push_self_privilege (SE_TCB_PRIVILEGE, true);

  /* Register as logon process. */
  str2lsa (name, "Cygwin");
  SetLastError (0);
  ret = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);
  if (ret != STATUS_SUCCESS)
    {
      debug_printf ("LsaRegisterLogonProcess: %p", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      goto out;
    }
  else if (GetLastError () == ERROR_PROC_NOT_FOUND)
    {
      debug_printf ("Couldn't load Secur32.dll");
      goto out;
    }
  /* Get handle to our own LSA package. */
  str2lsa (name, CYG_LSA_PKGNAME);
  ret = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);
  if (ret != STATUS_SUCCESS)
    {
      debug_printf ("LsaLookupAuthenticationPackage: %p", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      goto out;
    }

  /* Open policy object. */
  if ((lsa = open_local_policy ()) == INVALID_HANDLE_VALUE)
    goto out;

  /* Create origin. */
  str2buf2lsa (origin.str, origin.buf, "Cygwin");
  /* Create token source. */
  memcpy (ts.SourceName, "Cygwin.1", 8);
  ts.SourceIdentifier.HighPart = 0;
  ts.SourceIdentifier.LowPart = 0x0103;

  /* Create list of groups, the user is member in. */
  int auth_pos;
  if (new_groups.issetgroups ())
    get_setgroups_sidlist (tmp_gsids, usersid, pw, NULL, new_groups, auth_luid,
			   auth_pos);
  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid, pw,
				    NULL, auth_luid, auth_pos))
    goto out;
  /* The logon SID entry is not generated automatically on Windows 2000
     and earlier for some reason.  So add fake logon sid here, which is
     filled with logon id values in the authentication package. */
  if (wincap.needs_logon_sid_in_sid_list ())
    tmp_gsids += fake_logon_sid;

  tmp_gsids.debug_print ("tmp_gsids");

  /* Evaluate size of TOKEN_GROUPS list */
  non_well_known_cnt =  tmp_gsids.non_well_known_count ();
  gsize = sizeof (DWORD) + non_well_known_cnt * sizeof (SID_AND_ATTRIBUTES);
  tmpidx = -1;
  for (int i = 0; i < non_well_known_cnt; ++i)
    if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) >= 0)
      gsize += GetLengthSid (tmp_gsids.sids[tmpidx]);

  /* Retrieve list of privileges of that user. */
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize)))
    goto out;

  /* Create DefaultDacl. */
  dsize = sizeof (ACL) + 3 * sizeof (ACCESS_ALLOWED_ACE)
	  + GetLengthSid (usersid)
	  + GetLengthSid (well_known_admins_sid)
	  + GetLengthSid (well_known_system_sid);
  dacl = (PACL) alloca (dsize);
  if (!InitializeAcl (dacl, dsize, ACL_REVISION))
    goto out;
  if (!AddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL, usersid))
    goto out;
  if (!AddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,
			    well_known_admins_sid))
    goto out;
  if (!AddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,
			    well_known_system_sid))
    goto out;

  /* Evaluate authinf size and allocate authinf. */
  authinf_size = (authinf->data - (PBYTE) authinf);
  authinf_size += GetLengthSid (usersid);	    /* User SID */
  authinf_size += gsize;			    /* Groups + Group SIDs */
  /* When trying to define the admins group as primary group on Vista,
     LsaLogonUser fails with error STATUS_INVALID_OWNER.  As workaround
     we define "Local" as primary group here.  First, this adds the otherwise
     missing "Local" group to the group list and second, seteuid32
     sets the primary group to the group set in /etc/passwd anyway. */
  pgrpsid = well_known_local_sid;
  authinf_size += GetLengthSid (pgrpsid);	    /* Primary Group SID */

  authinf_size += psize;			    /* Privileges */
  authinf_size += 0;				    /* Owner SID */
  authinf_size += dsize;			    /* Default DACL */

  authinf = (cyglsa_t *) alloca (authinf_size);
  authinf->inf_size = authinf_size - ((PBYTE) &authinf->inf - (PBYTE) authinf);

  authinf->magic = CYG_LSA_MAGIC;

  extract_nt_dom_user (pw, authinf->domain, authinf->username);

  /* Store stuff in authinf with offset relative to start of "inf" member,
     instead of using pointers. */
  offset = authinf->data - (PBYTE) &authinf->inf;

  authinf->inf.ExpirationTime.LowPart = 0xffffffffL;
  authinf->inf.ExpirationTime.HighPart = 0x7fffffffL;
  /* User SID */
  authinf->inf.User.User.Sid = offset;
  authinf->inf.User.User.Attributes = 0;
  CopySid (GetLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),
	   usersid);
  offset += GetLengthSid (usersid);
  /* Groups */
  authinf->inf.Groups = offset;
  gsids = (PCYG_TOKEN_GROUPS) ((PBYTE) &authinf->inf + offset);
  sids_offset = offset + sizeof (ULONG) + non_well_known_cnt
					  * sizeof (SID_AND_ATTRIBUTES);
  gsids->GroupCount = non_well_known_cnt;
  /* Group SIDs */
  tmpidx = -1;
  for (int i = 0; i < non_well_known_cnt; ++i)
    {
      if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) < 0)
	break;
      gsids->Groups[i].Sid = sids_offset;
      gsids->Groups[i].Attributes = SE_GROUP_MANDATORY
				    | SE_GROUP_ENABLED_BY_DEFAULT
				    | SE_GROUP_ENABLED;
      /* Mark logon SID as logon SID :) */
      if (wincap.needs_logon_sid_in_sid_list ()
	  && tmp_gsids.sids[tmpidx] == fake_logon_sid)
	gsids->Groups[i].Attributes += SE_GROUP_LOGON_ID;
      CopySid (GetLengthSid (tmp_gsids.sids[tmpidx]),
	       (PSID) ((PBYTE) &authinf->inf + sids_offset),
	       tmp_gsids.sids[tmpidx]);
      sids_offset += GetLengthSid (tmp_gsids.sids[tmpidx]);
    }
  offset += gsize;
  /* Primary Group SID */
  authinf->inf.PrimaryGroup.PrimaryGroup = offset;
  CopySid (GetLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),
	   pgrpsid);
  offset += GetLengthSid (pgrpsid);
  /* Privileges */
  authinf->inf.Privileges = offset;
  memcpy ((PBYTE) &authinf->inf + offset, privs, psize);
  offset += psize;
  /* Owner */
  authinf->inf.Owner.Owner = 0;
  /* Default DACL */
  authinf->inf.DefaultDacl.DefaultDacl = offset;
  memcpy ((PBYTE) &authinf->inf + offset, dacl, dsize);

  authinf->checksum = CYGWIN_VERSION_MAGIC (CYGWIN_VERSION_DLL_MAJOR,
					    CYGWIN_VERSION_DLL_MINOR);
  PDWORD csp = (PDWORD) &authinf->username;
  PDWORD csp_end = (PDWORD) ((PBYTE) authinf + authinf_size);
  while (csp < csp_end)
    authinf->checksum += *csp++;

  /* Try to logon... */
  ret = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Interactive, package_id,
		      authinf, authinf_size, NULL, &ts, &profile, &size, &luid,
		      &user_token, &quota, &ret2);
  if (ret != STATUS_SUCCESS)
    {
      debug_printf ("LsaLogonUser: %p", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      goto out;
    }
  if (profile)
    LsaFreeReturnBuffer (profile);

  if (wincap.has_mandatory_integrity_control ())
    {
      typedef struct _TOKEN_LINKED_TOKEN
      {
	HANDLE LinkedToken;
      } TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;
#     define TokenLinkedToken ((TOKEN_INFORMATION_CLASS) 19)

      TOKEN_LINKED_TOKEN linked;

      if (GetTokenInformation (user_token, TokenLinkedToken,
			       (PVOID) &linked, sizeof linked, &size))
	{
	  debug_printf ("Linked Token: %lu", linked.LinkedToken);
	  if (linked.LinkedToken)
	    user_token = linked.LinkedToken;
d125 4
a128 106

out:
  if (privs)
    free (privs);
  close_local_policy (lsa);
  if (lsa_hdl)
    LsaDeregisterLogonProcess (lsa_hdl);
  pop_self_privilege ();

  debug_printf ("0x%x = lsaauth ()", user_token);
  return user_token;
}

/* read_sd reads a security descriptor from a file.
   In case of error, -1 is returned and errno is set.
   If sd_buf is too small, 0 is returned and sd_size
   is set to the needed buffer size.
   On success, 1 is returned.

   GetFileSecurity() is used instead of BackupRead()
   to avoid access denied errors if the caller has
   not the permission to open that file for read.

   Originally the function should return the size
   of the SD on success. Unfortunately NT returns
   0 in `len' on success, while W2K returns the
   correct size!

   2003-11-26: Now the function allocates the space needed by itself so
   it knows the real size and returns it in the security_descriptor object.
*/

LONG
read_sd (const char *file, security_descriptor &sd)
{

  DWORD len = 0;
  const char *pfile = file;
  char fbuf[CYG_MAX_PATH];
  if (current_codepage == oem_cp)
    {
      DWORD fname_len = min (sizeof (fbuf) - 1, strlen (file));
      bzero (fbuf, sizeof (fbuf));
      OemToCharBuff (file, fbuf, fname_len);
      pfile = fbuf;
    }

  if (!GetFileSecurity (pfile,
			OWNER_SECURITY_INFORMATION
			| GROUP_SECURITY_INFORMATION
			| DACL_SECURITY_INFORMATION,
			NULL, 0, &len)
      && GetLastError () != ERROR_INSUFFICIENT_BUFFER)
    {
      debug_printf ("file %s", file);
      __seterrno ();
      return -1;
    }
  debug_printf ("file %s: len %d", file, len);
  if (!sd.malloc (len))
    {
      set_errno (ENOMEM);
      return -1;
    }
  if (!GetFileSecurity (pfile,
			OWNER_SECURITY_INFORMATION
			| GROUP_SECURITY_INFORMATION
			| DACL_SECURITY_INFORMATION,
			sd, len, &len))
    {
      __seterrno ();
      return -1;
    }
  return sd.size ();
}

LONG
write_sd (HANDLE fh, const char *file, security_descriptor &sd)
{
  NTSTATUS ret = STATUS_SUCCESS;
  int retry = 0;
  int res = -1;
  for (; retry < 2; ++retry)
    {
      if (retry && (fh = CreateFile (file, WRITE_OWNER | WRITE_DAC,
				     FILE_SHARE_READ | FILE_SHARE_WRITE,
				     &sec_none_nih, OPEN_EXISTING,
				     FILE_ATTRIBUTE_NORMAL
				     | FILE_FLAG_BACKUP_SEMANTICS,
				     NULL)) == INVALID_HANDLE_VALUE)
	break;
      if (fh && (ret = NtSetSecurityObject (fh,
					    DACL_SECURITY_INFORMATION
					    | GROUP_SECURITY_INFORMATION
					    | OWNER_SECURITY_INFORMATION,
					    sd)) == STATUS_SUCCESS)
	break;
    }
  if (retry && fh != INVALID_HANDLE_VALUE)
    CloseHandle (fh);
  if (fh == INVALID_HANDLE_VALUE)	/* CreateFile failed */
    __seterrno ();
  else if (ret != STATUS_SUCCESS)	/* NtSetSecurityObject failed */
    __seterrno_from_nt_status (ret);
  else					/* Everything's fine. */
    res = 0;
d285 1
a285 1
get_reg_security (HANDLE handle, security_descriptor &sd_ret)
d290 1
a290 4
  ret = RegGetKeySecurity ((HKEY) handle,
			   DACL_SECURITY_INFORMATION
			   | GROUP_SECURITY_INFORMATION
			   | OWNER_SECURITY_INFORMATION,
d297 1
a297 4
	ret = RegGetKeySecurity ((HKEY) handle,
				 DACL_SECURITY_INFORMATION
				 | GROUP_SECURITY_INFORMATION
				 | OWNER_SECURITY_INFORMATION,
d309 2
a310 47
get_nt_object_security (HANDLE handle, SE_OBJECT_TYPE object_type,
			security_descriptor &sd_ret)
{
  NTSTATUS ret;
  ULONG len = 0;

  /* Do not try to use GetSecurityInfo (again), unless we drop NT4 support.
     GetSecurityInfo returns the wrong user information when running in
     a user session using a token created with NtCreateToken under NT4.
     Works fine in 2K and above, but that doesn't help a lot. */

  /* Unfortunately, NtQuerySecurityObject doesn't work on predefined registry
     keys like HKEY_LOCAL_MACHINE.  It fails with "Invalid Handle".  So we
     have to retreat to the Win32 registry functions for registry keys.
     What bugs me is that RegGetKeySecurity is obviously just a wrapper
     around NtQuerySecurityObject, but there seems to be no function to
     convert pseudo HKEY values to real handles. */
  if (object_type == SE_REGISTRY_KEY)
    return get_reg_security (handle, sd_ret);

  ret = NtQuerySecurityObject (handle,
			       DACL_SECURITY_INFORMATION
			       | GROUP_SECURITY_INFORMATION
			       | OWNER_SECURITY_INFORMATION,
			       sd_ret, len, &len);
  if (ret == STATUS_BUFFER_TOO_SMALL)
    {
      if (!sd_ret.malloc (len))
	set_errno (ENOMEM);
      else
	ret = NtQuerySecurityObject (handle,
				     DACL_SECURITY_INFORMATION
				     | GROUP_SECURITY_INFORMATION
				     | OWNER_SECURITY_INFORMATION,
				     sd_ret, len, &len);
    }
  if (ret != STATUS_SUCCESS)
    {
      __seterrno_from_nt_status (ret);
      return -1;
    }
  return 0;
}

int
get_object_attribute (HANDLE handle, SE_OBJECT_TYPE object_type,
		      mode_t *attribute, __uid32_t *uidret, __gid32_t *gidret)
a314 1
      PSECURITY_DESCRIPTOR psd = NULL;
d316 1
a316 1
      if (get_nt_object_security (handle, object_type, sd))
d318 2
a319 2
	  if (object_type == SE_FILE_OBJECT)
	    return -1;
a320 4
      else
	psd = sd;
      get_info_from_sd (psd, attribute, uidret, gidret);
      return 0;
d327 1
a327 1
get_file_attribute (int use_ntsec, HANDLE handle, const char *file,
d330 1
a330 3
  syscall_printf ("file: %s", file);

  if (use_ntsec && allow_ntsec)
d334 5
a338 4
      if (!handle || get_nt_object_security (handle, SE_FILE_OBJECT, sd))
	read_sd (file, sd);
      get_info_from_sd (sd, attribute, uidret, gidret);
      return 0;
d695 1
a695 1
set_file_attribute (bool use_ntsec, HANDLE handle, const char *file,
d700 1
a700 1
  if (use_ntsec && allow_ntsec)
d704 2
a705 4
      if (((handle && !get_nt_object_security (handle, SE_FILE_OBJECT, sd))
	   || read_sd (file, sd) > 0)
	  && alloc_sd (uid, gid, attribute, sd))
	ret = write_sd (handle, file, sd);
d710 1
a710 1
		  ret, file, uid, gid, attribute);
a713 8
int
set_file_attribute (bool use_ntsec, HANDLE handle, const char *file,
		    int attribute)
{
  return set_file_attribute (use_ntsec, handle, file,
			     myself->uid, myself->gid, attribute);
}

d785 1
a785 1
check_file_access (const char *fn, int flags)
d800 1
a800 1
  if (read_sd (fn, sd) > 0)
d822 1
a822 1
  if (!get_nt_object_security (hdl, SE_REGISTRY_KEY, sd))
@


1.221
log
@	* autoload.cc (SetSecurityDescriptorControl): Drop.
	* security.cc (alloc_sd): Set security descriptor control flag without
	calling SetSecurityDescriptorControl function.
	* wincap.h (wincapc::has_dacl_protect): Rename from
	has_security_descriptor_control.
	* wincap.cc: Ditto throughout.
@
text
@a1894 19
static int
set_nt_attribute (HANDLE handle, const char *file,
		  __uid32_t uid, __gid32_t gid, int attribute)
{
  security_descriptor sd;

  if ((!handle || get_nt_object_security (handle, SE_FILE_OBJECT, sd))
      && read_sd (file, sd) <= 0)
    {
      debug_printf ("read_sd %E");
      return -1;
    }

  if (!alloc_sd (uid, gid, attribute, sd))
    return -1;

  return write_sd (handle, file, sd);
}

d1899 2
a1900 1
  int ret;
d1902 8
a1909 1
    ret = set_nt_attribute (handle, file, uid, gid, attribute);
@


1.220
log
@	* cygheap.h (init_cygheap::luid): Remove.
	* mmap.cc (mlock): Accommodate parameter change in call to
	push_thread_privilege.
	(munlock): Ditto.
	* ntdll.h (STATUS_NOT_ALL_ASSIGNED): Define.
	(NtAdjustPrivilegesToken): Declare.
	* sec_helper.cc (cygpriv): Reorder to match numerical privilege order.
	(privilege_luid): Take job of privilege_luid_by_name, using new
	cygpriv.
	(privilege_luid_by_name): Remove.
	(privilege_name): Accommodate new cygpriv array.
	(set_privilege): Call NtAdjustPrivilegesToken to avoid using advapi32.
	Accommodate changes to privilege_name.
	(set_cygwin_privileges): Simplify.  Don't try to set
	SE_CREATE_GLOBAL_PRIVILEGE on systems not supporting it.
	* security.cc (sys_privs): Reorder to match numerical privilege order.
	Use real privilege values as defined in security.h.
	(get_system_priv_list): Drop unused grp_list argument.  Create
	list of privileges according to new wincapc::max_sys_priv value.
	(get_priv_list): Call privilege_luid instead of privilege_luid_by_name.
	Make priv a local value instead of a pointer.
	(create_token): Accommodate parameter change in call to
	push_self_privilege.
	(lsaauth): Ditto.
	(check_access): Use privilege values directly instead of calling
	privilege_luid.
	* security.h: Define real privilege values.
	(cygpriv_idx): Remove.
	(privilege_luid): Change declaration.
	(privilege_luid_by_name): Drop declaration.
	(set_privilege): Change declaration.
	(set_process_privilege): Drop definition.
	(_push_thread_privilege): Accomodate new set_privilege parameters.
	* wincap.h (wincapc::max_sys_priv): New element.
	* wincap.cc: Implement above element throughout.
	(wincap_2000sp4): New wincaps structure.
	(wincap_xpsp1): Ditto.
	(wincap_xpsp2): Ditto.
	(wincapc::init): Use new wincaps.
	(wincapc::max_sys_priv): New element.
@
text
@d1634 4
a1637 8
  /*
   * We set the SE_DACL_PROTECTED flag here to prevent the DACL from being
   * modified by inheritable ACEs.
   * This flag as well as the SetSecurityDescriptorControl call are available
   * only since Win2K.
   */
  if (wincap.has_security_descriptor_control ())
    SetSecurityDescriptorControl (&sd, SE_DACL_PROTECTED, SE_DACL_PROTECTED);
@


1.219
log
@	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.
	* security.cc (check_registry_access): Set errno to EROFS when checking
	for W_OK.
@
text
@d565 29
a593 30
static const cygpriv_idx sys_privs[] = {
  SE_TCB_PRIV,
  SE_ASSIGNPRIMARYTOKEN_PRIV,
  SE_CREATE_TOKEN_PRIV,
  SE_CHANGE_NOTIFY_PRIV,
  SE_SECURITY_PRIV,
  SE_BACKUP_PRIV,
  SE_RESTORE_PRIV,
  SE_SYSTEMTIME_PRIV,
  SE_SHUTDOWN_PRIV,
  SE_REMOTE_SHUTDOWN_PRIV,
  SE_TAKE_OWNERSHIP_PRIV,
  SE_DEBUG_PRIV,
  SE_SYSTEM_ENVIRONMENT_PRIV,
  SE_SYSTEM_PROFILE_PRIV,
  SE_PROF_SINGLE_PROCESS_PRIV,
  SE_INC_BASE_PRIORITY_PRIV,
  SE_LOAD_DRIVER_PRIV,
  SE_CREATE_PAGEFILE_PRIV,
  SE_INCREASE_QUOTA_PRIV,
  SE_LOCK_MEMORY_PRIV,
  SE_CREATE_PERMANENT_PRIV,
  SE_AUDIT_PRIV,
  SE_UNDOCK_PRIV,
  SE_MANAGE_VOLUME_PRIV,
  SE_IMPERSONATE_PRIV,
  SE_CREATE_GLOBAL_PRIV,
  SE_INCREASE_WORKING_SET_PRIV,
  SE_TIME_ZONE_PRIV,
  SE_CREATE_SYMBOLIC_LINK_PRIV
d599 1
a599 1
get_system_priv_list (cygsidlist &grp_list, size_t &size)
d601 8
a608 3
  const LUID *priv;
  size = sizeof (ULONG)
	 + SYSTEM_PRIVILEGES_COUNT * sizeof (LUID_AND_ATTRIBUTES);
d616 8
a623 9

  for (DWORD i = 0; i < SYSTEM_PRIVILEGES_COUNT; ++i)
    if ((priv = privilege_luid (sys_privs[i])))
      {
	privs->Privileges[privs->PrivilegeCount].Luid = *priv;
	privs->Privileges[privs->PrivilegeCount].Attributes =
	  SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
	++privs->PrivilegeCount;
      }
d638 1
a638 1
    return get_system_priv_list (grp_list, size);
d654 1
a654 1
	  const LUID *priv;
d660 1
a660 1
	  if (!(priv = privilege_luid_by_name (buf)))
d668 2
a669 2
		if (priv->HighPart == p->Luid.HighPart
		    && priv->LowPart == p->Luid.LowPart)
d687 1
a687 1
	  privs->Privileges[privs->PrivilegeCount].Luid = *priv;
d833 1
a833 1
  push_self_privilege (SE_CREATE_TOKEN_PRIV, true);
d970 1
a970 1
  push_self_privilege (SE_TCB_PRIV, true);
d1984 2
a1985 1
	  pset->Privilege[0].Luid = *privilege_luid (SE_BACKUP_PRIV);
d1994 2
a1995 1
	  pset->Privilege[0].Luid = *privilege_luid (SE_RESTORE_PRIV);
@


1.218
log
@	* cygheap.h (cygheap_user::curr_imp_token): Rename from current_token.
	Accommodate changge throughout Cygwin.
	(cygheap_user::imp_token): Rename from token.  Accommodate changge
	throughout Cygwin.
	(rcygheap_user::eimpersonate): Use primary token for impersonation.
	* grp.cc (internal_getgroups): Use primary impersonation token when
	impersonated.
	* security.h (_push_thread_privilege): Use primary impersonation token
	when impersonated.
@
text
@d2047 4
a2050 1
    ret = -1;
@


1.217
log
@	* security.cc (get_file_attribute): Avoid compiler warning.
@
text
@d1946 1
a1946 1
  HANDLE tok = cygheap->user.issetuid () ? cygheap->user.token ()
@


1.216
log
@* Makefile (DLL_OFILES): Remove ntea.o
* environ.cc (set_ntea): Delete.
(parse_thing): Delete "ntea" setting.
* fhandler.cc (fhandler_base::open): Remove allow_ntea considerations.
(check_posix_perm): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Ditto.
(fhandler_base::open_fs): Ditto.
(fhandler_disk_file::mkdir): Ditto.
* path.cc (symlink_worker): Ditto.
* security.cc (get_file_attribute): Ditto.
(set_file_attribute): Ditto.
* security.h: Remove allow_ntea declaration.
@
text
@a1526 1
  int res;
@


1.215
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@d1545 1
a1545 14
  if (!attribute)
    return 0;

  if (allow_ntea)
    {
      int oatt = *attribute;
      res = read_ea (handle, file, ".UNIXATTR", (char *)attribute,
		     sizeof (*attribute));
      *attribute |= oatt;
    }
  else
    res = 0;

  return res > 0 ? 0 : -1;
d1920 1
a1920 2
  int ret = 0;

d1923 2
a1924 6
  else if (allow_ntea && !write_ea (handle, file, ".UNIXATTR",
				    (char *) &attribute, sizeof (attribute)))
    {
      __seterrno ();
      ret = -1;
    }
@


1.214
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
d46 2
a47 1
bool allow_ntsec;
a92 5
  if (!wincap.has_security ())
    {
      set_errno (ENOSYS);
      return INVALID_HANDLE_VALUE;
    }
a1913 3
  if (!wincap.has_security ())
    return 0;

@


1.213
log
@	Partially revert change from 2006-10-22.  GetSecurityInfo messes up
	user information on NT4.
	* sec_helper.cc (security_descriptor::malloc): Drop LocalAlloc
	considerations.
	(security_descriptor::realloc): Ditto.
	(security_descriptor::free): Ditto.
	* security.cc (get_reg_security): Reinstantiate.
	(get_nt_object_security): Revert to using NtQuerySecurityObject.
	* security.h (class security_descriptor): Drop type member.
	Accommodate throughout.
	(security_descriptor::size): Constify.
	(security_descriptor::copy): Ditto.
@
text
@d235 1
a235 1
        dret = NetGetAnyDCName (NULL, wdomain, (LPBYTE *) &buf);
d608 1
a608 1
  	 + SYSTEM_PRIVILEGES_COUNT * sizeof (LUID_AND_ATTRIBUTES);
d660 1
a660 1
	  		privstrs[i].Buffer, privstrs[i].Length / 2);
d1100 1
a1100 1
        break;
d1108 1
a1108 1
        gsids->Groups[i].Attributes += SE_GROUP_LOGON_ID;
d1436 4
a1439 4
                           DACL_SECURITY_INFORMATION
                           | GROUP_SECURITY_INFORMATION
                           | OWNER_SECURITY_INFORMATION,
                           sd_ret, &len);
d1441 1
a1441 1
    {       
d1443 1
a1443 1
        set_errno (ENOMEM);
d1445 5
a1449 5
        ret = RegGetKeySecurity ((HKEY) handle,
                                 DACL_SECURITY_INFORMATION
                                 | GROUP_SECURITY_INFORMATION
                                 | OWNER_SECURITY_INFORMATION,
                                 sd_ret, &len);
d1455 1
a1455 1
    } 
d1465 1
a1465 1
  
d1479 1
a1479 1
        
d1481 4
a1484 4
                               DACL_SECURITY_INFORMATION
                               | GROUP_SECURITY_INFORMATION
                               | OWNER_SECURITY_INFORMATION,
                               sd_ret, len, &len);
d1488 1
a1488 1
        set_errno (ENOMEM);
d1490 5
a1494 5
        ret = NtQuerySecurityObject (handle,
                                     DACL_SECURITY_INFORMATION
                                     | GROUP_SECURITY_INFORMATION
                                     | OWNER_SECURITY_INFORMATION,
                                     sd_ret, len, &len);
d1497 1
a1497 1
    {   
@


1.212
log
@	* security.cc (lsaauth): Initialize lsa to INVALID_HANDLE_VALUE to
	avoid potential access violation.
@
text
@d1429 30
d1463 23
a1485 9
  sd_ret.free ();
  /* Don't use NtQuerySecurityObject.  It doesn't recognize predefined
     registry keys. */
  DWORD ret = GetSecurityInfo (handle, object_type,
			       DACL_SECURITY_INFORMATION
			       | GROUP_SECURITY_INFORMATION
			       | OWNER_SECURITY_INFORMATION,
			       NULL, NULL, NULL, NULL, sd_ret);
  if (ret != ERROR_SUCCESS)
d1487 12
a1498 1
      __seterrno_from_win_error (ret);
@


1.211
log
@	* environ.cc (subauth_id_init): Remove.
	(parse_thing): Drop "subauth_id" option.
	* security.cc (get_token_group_sidlist): Drop comments concerning
	subauthentication.
	(create_token): Back out subauthentication related changes.
	(subauth): Remove.
	* security.h (create_token): Remove declaration.
	(subauth): Ditto.
	* syscalls.cc (seteuid32): Drop subauthentication handling entirely.
@
text
@d947 1
a947 1
  HANDLE lsa_hdl = NULL, lsa;
@


1.210
log
@	* environ.cc (set_traverse): Remove.
	(parse_thing): Drop "traverse" option.
	* path.cc (fs_info::update): Don't request SE_CHANGE_NOTIFY_PRIV
	privilege.
	* sec_helper.cc (set_cygwin_privileges): Ditto.
	* security.cc (allow_traverse): Remove.
	(alloc_sd): Drop special allow_traverse code.
	* security.h (allow_traverse): Drop declaration.
	* syscalls.cc (statvfs): Don't request SE_CHANGE_NOTIFY_PRIV privilege.
@
text
@a29 1
#include <subauth.h>
d476 1
a476 4
      /* In Vista the Local SID is missing in a token constructed by
         subauthentication.  We add the group unconditionally now. */
      /*if (sid_in_token_groups (my_grps, well_known_local_sid))*/
	grp_list += well_known_local_sid;
d483 1
a483 6
      /* This is a problem on 2K3 (only domain controllers?!?) which only
         enables tools for selected special groups.  A subauth token is
	 only NETWORK, but NETWORK has no access to these tools.  Therefore
	 we always add INTERACTIVE here. */
      /*if (sid_in_token_groups (my_grps, well_known_interactive_sid))*/
	grp_list *= well_known_interactive_sid;
d801 1
a801 2
create_token (cygsid &usersid, user_groups &new_groups, struct passwd *pw,
	      HANDLE subauth_token)
d824 1
a824 1
  source.SourceIdentifier.LowPart = (subauth_token ? 0x0102 : 0x0101);
d846 1
a846 12
  HANDLE get_token;
  if (subauth_token)
    {
      debug_printf ("get_token = subauth_token");
      get_token = subauth_token;
    }
  else
    {
      debug_printf ("get_token = hProcToken");
      get_token = hProcToken;
    }
  if (get_token)
d851 1
a851 1
	if (!GetTokenInformation (get_token, TokenStatistics,
d854 1
a854 1
	    ("GetTokenInformation(get_token, TokenStatistics), %E");
d860 1
a860 1
      if (!GetTokenInformation (get_token, TokenGroups, NULL, 0, &size)
d862 1
a862 1
	debug_printf ("GetTokenInformation(get_token, TokenGroups), %E");
d865 1
a865 1
      else if (!GetTokenInformation (get_token, TokenGroups, my_tok_gsids,
d868 1
a868 1
	  debug_printf ("GetTokenInformation(get_token, TokenGroups), %E");
a872 16
  if (subauth_token)
    {
      if (!GetTokenInformation (subauth_token, TokenPrivileges, NULL, 0, &size)
	  && GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(subauth_token, TokenPrivileges), %E");
      else if (!(privs = (PTOKEN_PRIVILEGES) malloc (size)))
	debug_printf ("malloc (privs) failed.");
      else if (!GetTokenInformation (subauth_token, TokenPrivileges, privs,
				     size, &size))
	{
	  debug_printf ("GetTokenInformation(subauth_token, TokenPrivileges), %E");
	  free (privs);
	  privs = NULL;
	}
    }
    
d901 1
a901 1
  if (!privs && !(privs = get_priv_list (lsa, usersid, tmp_gsids, psize)))
a940 166
/* Subauthentication gets useless now that real LSA authentication is
   available.  The accompanying code in seteuid32 and environ.cc is
   also disabled.
   TODO: Deprecate and delete code entirely.
   TODO: Delete from documentation. */
#if 0
extern "C"
{
  BOOL WINAPI Wow64DisableWow64FsRedirection (PVOID *);
  BOOL WINAPI Wow64RevertWow64FsRedirection (PVOID);
};

static enum
{
  not_tested,
  not_installed,
  installed
} cygsuba_installed __attribute__((section (".cygwin_dll_common"), shared))
  = not_tested;

int subauth_id = 255;

HANDLE
subauth (struct passwd *pw)
{
  LSA_STRING name;
  HANDLE lsa_hdl = NULL;
  LSA_OPERATIONAL_MODE sec_mode;
  NTSTATUS ret, ret2;
  ULONG package_id, size;
  struct {
    LSA_STRING str;
    CHAR buf[16];
  } origin;
  struct {
    MSV1_0_LM20_LOGON auth;
    WCHAR dombuf[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    WCHAR usrbuf[UNLEN + 1];
    WCHAR wkstbuf[1];
    CHAR authinf1[1];
    CHAR authinf2[1];
  } subbuf;
  TOKEN_SOURCE ts;
  PMSV1_0_LM20_LOGON_PROFILE profile;
  LUID luid;
  QUOTA_LIMITS quota;
  char nt_domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  char nt_user[UNLEN + 1];
  /* Changed from INVALID_HANDLE_VALUE to NULL.  A failed LsaLogonUser
     sets the token to NULL anyway, so starting with NULL simplifies
     the below test before calling CloseHandle. */
  HANDLE user_token = NULL;
  HANDLE primary_token = INVALID_HANDLE_VALUE;

  /* Check to see if cygsuba.dll has been registered and is present.  The
     idea here is to avoid authentication failure messages in the security
     event log for each logon attempt if cygsuba.dll hasn't been installed.
     The test is only made once per DLL life time, since installing and
     registering the subauthentication DLL requires reboot anyway. */
  if (cygsuba_installed == not_installed)
    {
      debug_printf ("subauth not installed, exit subauth");
      return INVALID_HANDLE_VALUE;
    }
  else if (cygsuba_installed == not_tested)
    {
      char auth_path[CYG_MAX_PATH];

      cygsuba_installed = not_installed;
      __small_sprintf (auth_path, "/proc/registry/HKEY_LOCAL_MACHINE/SYSTEM/"
				  "CurrentControlSet/Control/Lsa/MSV1_0/Auth%d",
				  subauth_id);
      if (access (auth_path, F_OK))
	{
	  debug_printf ("%s doesn't exist, exit subauth", auth_path);
	  return INVALID_HANDLE_VALUE;
	}
      /* On 64 bit systems the dll must be installed into the *real* system32
	 directory so we have to switch off file system redirection. */
      PVOID old_fsredir;
      DWORD attr = INVALID_FILE_ATTRIBUTES;
      Wow64DisableWow64FsRedirection (&old_fsredir);
      if (GetSystemDirectory (auth_path, CYG_MAX_PATH))
	{
	  strcat (auth_path, "\\cygsuba.dll");
	  attr = GetFileAttributes (auth_path);
	}
      Wow64RevertWow64FsRedirection (old_fsredir);
      if (attr == INVALID_FILE_ATTRIBUTES)
	{
	  debug_printf ("%s doesn't exist, exit subauth", auth_path);
	  return INVALID_HANDLE_VALUE;
	}
      cygsuba_installed = installed;
    }

  push_self_privilege (SE_TCB_PRIV, true);

  /* Register as logon process. */
  str2lsa (name, "Cygwin");
  SetLastError (0);
  ret = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);
  if (ret != STATUS_SUCCESS)
    {
      debug_printf ("LsaRegisterLogonProcess: %d", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      goto out;
    }
  else if (GetLastError () == ERROR_PROC_NOT_FOUND)
    {
      debug_printf ("Couldn't load Secur32.dll");
      goto out;
    }
  /* Get handle to MSV1_0 package. */
  str2lsa (name, MSV1_0_PACKAGE_NAME);
  ret = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);
  if (ret != STATUS_SUCCESS)
    {
      debug_printf ("LsaLookupAuthenticationPackage: %d", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      goto out;
    }
  /* Create origin. */
  str2buf2lsa (origin.str, origin.buf, "Cygwin");
  /* Create token source. */
  memcpy (ts.SourceName, "Cygwin.1", 8);
  ts.SourceIdentifier.HighPart = 0;
  ts.SourceIdentifier.LowPart = 0x0100;
  /* Get user information. */
  extract_nt_dom_user (pw, nt_domain, nt_user);
  /* Fill subauth with values. */
  subbuf.auth.MessageType = MsV1_0NetworkLogon;
  str2buf2uni (subbuf.auth.LogonDomainName, subbuf.dombuf, nt_domain);
  str2buf2uni (subbuf.auth.UserName, subbuf.usrbuf, nt_user);
  str2buf2uni (subbuf.auth.Workstation, subbuf.wkstbuf, "");
  memcpy (subbuf.auth.ChallengeToClient, "12345678", MSV1_0_CHALLENGE_LENGTH);
  str2buf2lsa (subbuf.auth.CaseSensitiveChallengeResponse, subbuf.authinf1, "");
  str2buf2lsa (subbuf.auth.CaseInsensitiveChallengeResponse,subbuf.authinf2,"");
  subbuf.auth.ParameterControl = 0 | (subauth_id << 24);
  /* Try to logon... */
  ret = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Network,
		      package_id, &subbuf, sizeof subbuf,
		      NULL, &ts, (PVOID *) &profile, &size,
		      &luid, &user_token, &quota, &ret2);
  if (ret != STATUS_SUCCESS)
    {
      debug_printf ("LsaLogonUser: %d", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      goto out;
    }
  LsaFreeReturnBuffer (profile);
  /* Convert to primary token. */
  if (!DuplicateTokenEx (user_token, TOKEN_ALL_ACCESS, &sec_none,
			 SecurityImpersonation, TokenPrimary, &primary_token))
    __seterrno ();

out:
  if (lsa_hdl)
    LsaDeregisterLogonProcess (lsa_hdl);
  pop_self_privilege ();
  if (user_token)
    CloseHandle (user_token);
  return primary_token;
}
#endif

@


1.209
log
@	Partially revert change from 2005-04-03, always running under an
	impersonation token, which collides with Vista UAC.
	* cygheap.h (deimpersonate): revert to self instead of impersonating
	hProcImpToken.
	(reimpersonate): Only impersonate if setuid.
	* dcrt0.cc (dll_crt0_0): Don't initialize hProcImpToken here.
	(dll_crt0_1): Set privileges on hProcToken.
	* fork.cc (frok::child): Set privileges on hProcToken.  Close handle to
	hProcImpToken.
	* grp.cc (internal_getgroups): Use hProcToken instead of hProcImpToken.
	* security.cc (check_access): Create hProcImpToken on demand here.
	* security.h (set_process_privilege): Set privileges on hProcToken.
	(_push_thread_privilege): Use hProcToken instead of hProcImpToken.
	(pop_thread_privilege): If not setuid'ed, revert to self.
	* syscalls.cc (setegid32): Drop setting primary group on hProcImpToken.
	Close handle to hProcImpToken.
	* uinfo.cc (internal_getlogin): Ditto.
	* winsup.h (clear_procimptoken): New inline function.
@
text
@a50 1
bool allow_traverse;
a1834 8
  /* This has nothing to do with traverse checking in the first place, but
     since traverse checking is the setting which switches to POSIX-like
     permission rules, the below is all too similar.  Removing the delete
     bit for a file or directory results in checking the parent directories'
     ACL, if the current user has the FILE_DELETE_CHILD bit set.  This is
     how it is on POSIX systems. */
  if (allow_traverse)
    owner_allow &= ~DELETE;
@


1.208
log
@	* security.cc (create_token): Revert erroneous change to test
	subauth_token for INVAILD_HANDLE_VALUE.
	* syscalls.cc (seteuid32): Set create_token's subauth_token parameter
	back to NULL.
@
text
@d2132 11
@


1.207
log
@	* cyglsa.h: New header file.
	* environ.cc: Disable subauth settings.
	* grp.cc: Accomodate cygsidlist's count now being a method.
	* sec_helper.cc (SECURITY_MANDATORY_INTEGRITY_AUTHORITY): Remove.
	(mandatory_medium_integrity_sid): Remove.
	(mandatory_high_integrity_sid): Remove.
	(mandatory_system_integrity_sid): Remove.
	(fake_logon_sid): Add.
	(cygsid::get_sid): Add well_known parameter.  Set well_known_sid
	accordingly.
	(cygsid::getfromstr): Ditto.
	(cygsidlist::alloc_sids): Move here from security.cc.
	(cygsidlist::free_sids): Ditto.
	(cygsidlist::add): Move here from security.h.  Add well_known parameter.
	Set well_known_sid accordingly.  Don't allow duplicate SIDs.
	* security.cc: Include cyglsa.h and cygwin/version.h.  Throughout
	accomodate cygsidlist's count now being a method.  Throughout drop
	redundant "contains" tests.
	(get_user_local_groups): Add local groups as well known SIDs.
	(get_token_group_sidlist): Add well known groups as well known SIDs.
	(get_server_groups): Ditto.  Only call get_unix_group_sidlist after
	get_user_local_groups to maintain "well_known_sid" attribute.
	(get_initgroups_sidlist): Add well known groups as well known SIDs.
	(get_setgroups_sidlist): Add usersid and struct passwd parameter to
	allow calling get_server_groups from here.
	(get_system_priv_list): Make static.  Return size of TOKEN_PRIVILEGES
	structure.
	(get_priv_list): Ditto.
	(create_token): Accomodate above changes.  Drop misguided attempt to
	add MIC SIDs to created user token.  Print returned token as hex value.
	(subauth): Disable.
	(lsaauth): New function implementing client side of LSA authentication.
	* security.h (class cygsid): Add well_known_sid attribute.  Accomodate
	throughout.  Add *= operator to create a well known SID.
	(class cygsidlist): Rename count to cnt.  Make count a method.
	(cygsidlist::add): Move to sec_helper.cc.
	(cygsidlist::operator *=): New method to add well known SID.
	(cygsidlist::non_well_known_count): New method returning number of
	non well known SIDs in list.
	(cygsidlist::next_non_well_known_sid): New method returning next non
	well known SID by index.
	(mandatory_medium_integrity_sid): Drop declaration.
	(mandatory_high_integrity_sid): Drop declaration.
	(mandatory_system_integrity_sid): Drop declaration.
	(fake_logon_sid): Add declaration.
	(subauth): Disable declaration.
	(lsaauth): Add declaration.
	* syscalls.cc (seteuid32): Disable subauthentication.  Add LSA
	authentication.
	* wincap.h: Define needs_logon_sid_in_sid_list throughout.
	* wincap.cc: Ditto.
@
text
@d835 1
a835 2
  source.SourceIdentifier.LowPart = (subauth_token != INVALID_HANDLE_VALUE
				     ? 0x0102 : 0x0101);
@


1.206
log
@	* autoload.cc (EqualPrefixSid): Define.
	* security.cc (create_token): Drop grps_buf.  Use alloca instead.
	Only add the MIC SID to the TOKEN_GROUPS list for the NtCreateToken
	call.  If the subauthentication token exists, use its MIC SID.
	Set SID Attributes for the MIC SID to 0.
@
text
@d44 2
a52 19
cygsid *
cygsidlist::alloc_sids (int n)
{
  if (n > 0)
    return (cygsid *) cmalloc (HEAP_STR, n * sizeof (cygsid));
  else
    return NULL;
}

void
cygsidlist::free_sids ()
{
  if (sids)
    cfree (sids);
  sids = NULL;
  count = maxcount = 0;
  type = cygsidlist_empty;
}

d332 1
a332 1
	for (int glidx = 0; glidx < grp_list.count; ++glidx)
d395 1
a395 2
	else if (!grp_list.contains (gsid))
	  grp_list += gsid;
d465 1
a465 1
      if (gsid.getfromgr (gr) && !grp_list.contains (gsid))
d483 1
a483 1
	grp_list += well_known_dialup_sid;
d485 1
a485 1
	grp_list += well_known_network_sid;
d487 1
a487 1
	grp_list += well_known_batch_sid;
d493 1
a493 1
	grp_list += well_known_interactive_sid;
d495 1
a495 1
	grp_list += well_known_service_sid;
d497 1
a497 1
	grp_list += well_known_this_org_sid;
d502 1
a502 1
      grp_list += well_known_interactive_sid;
d510 1
a510 1
	    auth_pos = grp_list.count - 1;
d526 1
a526 1
      grp_list += well_known_admins_sid;
d531 2
a532 4
  if (!grp_list.contains (well_known_world_sid))
    grp_list += well_known_world_sid;
  if (!grp_list.contains (well_known_authenticated_users_sid))
    grp_list += well_known_authenticated_users_sid;
d538 6
a543 2
  get_unix_group_sidlist (pw, grp_list);
  return get_user_local_groups (grp_list, usersid);
d551 2
a552 2
  grp_list += well_known_world_sid;
  grp_list += well_known_authenticated_users_sid;
d561 1
a561 2
  if (!grp_list.contains (pgrpsid))
    grp_list += pgrpsid;
d566 3
a568 2
get_setgroups_sidlist (cygsidlist &tmp_list, PTOKEN_GROUPS my_grps,
		       user_groups &groups, LUID auth_luid, int &auth_pos)
d570 2
a571 3
  PSID pgpsid = groups.pgsid;
  tmp_list += well_known_world_sid;
  tmp_list += well_known_authenticated_users_sid;
d573 4
a576 5
  for (int gidx = 0; gidx < groups.sgsids.count; gidx++)
    if (!tmp_list.contains (groups.sgsids.sids[gidx]))
      tmp_list += groups.sgsids.sids[gidx];
  if (!groups.sgsids.contains (pgpsid))
    tmp_list += pgpsid;
d613 2
a614 2
PTOKEN_PRIVILEGES
get_system_priv_list (cygsidlist &grp_list)
d617 3
a619 3
  PTOKEN_PRIVILEGES privs = (PTOKEN_PRIVILEGES)
    malloc (sizeof (ULONG)
	    + SYSTEM_PRIVILEGES_COUNT * sizeof (LUID_AND_ATTRIBUTES));
d638 3
a640 2
PTOKEN_PRIVILEGES
get_priv_list (LSA_HANDLE lsa, cygsid &usersid, cygsidlist &grp_list)
d649 1
a649 1
    return get_system_priv_list (grp_list);
d651 1
a651 1
  for (int grp = -1; grp < grp_list.count; ++grp)
d685 3
a687 3
	  tmp = (PTOKEN_PRIVILEGES)
	    realloc (privs, sizeof (ULONG) +
		     (tmp_count + 1) * sizeof (LUID_AND_ATTRIBUTES));
d780 1
a780 1
	  bool saw[groups.sgsids.count];
d797 1
a797 1
	  for (int gidx = 0; gidx < groups.sgsids.count; gidx++)
d843 1
d916 2
a917 2
    get_setgroups_sidlist (tmp_gsids, my_tok_gsids, new_groups, auth_luid,
			   auth_pos);
d927 1
a927 1
		  alloca (sizeof (ULONG) + (tmp_gsids.count  + 1 )
d929 1
a929 1
  new_tok_gsids->GroupCount = tmp_gsids.count;
a938 34

  /* On systems supporting Mandatory Integrity Control, add a MIC SID. */
  if (wincap.has_mandatory_integrity_control ())
    {
      bool add_mic_sid = true;
      new_tok_gsids->Groups[new_tok_gsids->GroupCount].Attributes = 0;

      /* The subauth token usually contains a MIC SID.  Copy it into our
	 group SID list. */
      if (my_tok_gsids)
	for (DWORD i = 0; i < my_tok_gsids->GroupCount; ++i)
	  if (EqualPrefixSid (mandatory_medium_integrity_sid,
			      my_tok_gsids->Groups[i].Sid))
	    {
	      new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
		= my_tok_gsids->Groups[i].Sid;
	      add_mic_sid = false;
	      break;
	    }
      /* If no MIC SID was available add a matching one for the account type. */
      if (add_mic_sid)
        {
	  if (usersid == well_known_system_sid)
	    new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
	      = mandatory_system_integrity_sid;
	  else if (tmp_gsids.contains (well_known_admins_sid))
	    new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
	      = mandatory_high_integrity_sid;
	  else
	    new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
	      = mandatory_medium_integrity_sid;
	}
    }

d940 1
a940 1
  if (!privs && !(privs = get_priv_list (lsa, usersid, tmp_gsids)))
d976 1
a976 1
  debug_printf ("%d = create_token ()", primary_token);
d980 6
d1006 1
a1006 1
  HANDLE lsa_hdl;
a1099 1
      LsaDeregisterLogonProcess (lsa_hdl);
a1127 1
      LsaDeregisterLogonProcess (lsa_hdl);
d1137 2
d1144 241
@


1.205
log
@	* sec_helper.cc (sid_auth): Remove.
	(well_known_this_org_sid): New well known sid.
	(SECURITY_MANDATORY_INTEGRITY_AUTHORITY): Define.
	(mandatory_medium_integrity_sid): New well known sid.
	(mandatory_high_integrity_sid): Ditto.
	(mandatory_system_integrity_sid): Ditto.
	(cygsid::get_sid): Use local SID_IDENTIFIER_AUTHORITY.  Allow all
	authorities fitting in a UCHAR.
	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.  Add comment.  Add "This Organization" group
	if available in incoming group list.
	(get_server_groups): Only add world and authenticated users groups
	if not already in list.
	(create_token): Add matching mandatory integrity SID to group list
	on systems supporting Mandatory Integrity Control.
	* security.h (well_known_this_org_sid): Define.
	(mandatory_medium_integrity_sid): Define.
	(mandatory_high_integrity_sid): Define.
	(mandatory_system_integrity_sid): Define.
	* wincap.h: Define has_mandatory_integrity_control throughout.
	* wincap.cc: Ditto.
@
text
@a936 9
  if (wincap.has_mandatory_integrity_control ())
    {
      if (usersid == well_known_system_sid)
	tmp_gsids += mandatory_system_integrity_sid;
      else if (tmp_gsids.contains (well_known_admins_sid))
	tmp_gsids += mandatory_high_integrity_sid;
      else
	tmp_gsids += mandatory_medium_integrity_sid;
    }
d942 3
a944 2
  char grps_buf[sizeof (ULONG) + tmp_gsids.count * sizeof (SID_AND_ATTRIBUTES)];
  new_tok_gsids = (PTOKEN_GROUPS) grps_buf;
d949 3
a951 2
      new_tok_gsids->Groups[i].Attributes = SE_GROUP_MANDATORY |
	SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
d956 33
@


1.204
log
@	* security.h (cygpriv_idx): Add privileges new in Vista.
	* security.cc (sys_privs): Ditto.
	* sec_helper.cc (cygpriv): Ditto.  Fix comment.
@
text
@d496 3
a498 1
      if (sid_in_token_groups (my_grps, well_known_local_sid))
d514 2
d549 4
a552 2
  grp_list += well_known_world_sid;
  grp_list += well_known_authenticated_users_sid;
d937 9
@


1.203
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): Fix whitespace.
	* external.cc: Update copyright.
	* fhandler.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.h: Ditto.
	* security.cc: Ditto.
	(check_registry_access): Return -1 if W_OK is requested.
@
text
@d617 4
a620 1
  SE_CREATE_GLOBAL_PRIV
@


1.202
log
@	* external.cc (cygwin_internal): Use security_descriptor::copy method.
	* sec_helper.cc (security_descriptor::malloc): Use own free method.
	Set type.
	(security_descriptor::realloc): Handle the case that psd has been
	allocated using LocalAlloc.  Set type.
	(security_descriptor::free): Ditto.
	* security.cc (get_nt_attribute): Remove.
	(get_reg_security): Remove.
	(get_nt_object_security): Use GetSecurityInfo which handles all
	securable objects.
	(get_nt_object_attribute): Remove.
	(get_object_attribute): Call get_nt_object_security instead of
	get_nt_object_attribute.
	(get_file_attribute): Ditto.
	(check_registry_access): Call get_nt_object_security instead of
	get_reg_security.
	* security.h (cygpsid::operator PSID): Make method const, not the
	result.
	(class security_descriptor): Add type member.  Accomodate throughout.
	(security_descriptor::copy): New method.
	(security_descriptor::operator PSECURITY_DESCRIPTOR *): New operator.
@
text
@d3 2
a4 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
d1977 3
@


1.201
log
@	* fhandler.cc (fhandler_base::fhaccess): Call check_registry_access
	for registry keys/values if ntsec is on.
	* security.cc (check_access): New static function derived from
	check_file_access, but object type agnostic.
	(check_file_access): Only do file specific stuff.  Call check_access.
	(check_registry_access): New access check function for registry keys/
	values.
	* security.h (check_registry_access): Declare.
@
text
@a1391 41
static void
get_nt_attribute (const char *file, mode_t *attribute,
		  __uid32_t *uidret, __gid32_t *gidret)
{
  security_descriptor sd;

  if (read_sd (file, sd) <= 0)
    debug_printf ("read_sd %E");
  get_info_from_sd (sd, attribute, uidret, gidret);
}

static int
get_reg_security (HANDLE handle, security_descriptor &sd_ret)
{
  LONG ret;
  DWORD len = 0;

  ret = RegGetKeySecurity ((HKEY) handle,
			   DACL_SECURITY_INFORMATION
			   | GROUP_SECURITY_INFORMATION
			   | OWNER_SECURITY_INFORMATION,
			   sd_ret, &len);
  if (ret == ERROR_INSUFFICIENT_BUFFER)
    {
      if (!sd_ret.malloc (len))
	set_errno (ENOMEM);
      else
	ret = RegGetKeySecurity ((HKEY) handle,
				 DACL_SECURITY_INFORMATION
				 | GROUP_SECURITY_INFORMATION
				 | OWNER_SECURITY_INFORMATION,
				 sd_ret, &len);
    }
  if (ret != ERROR_SUCCESS)
    {
      __seterrno ();
      return -1;
    }
  return 0;
}

d1396 4
a1399 13
  NTSTATUS ret;
  ULONG len = 0;

  /* Unfortunately, NtQuerySecurityObject doesn't work on predefined registry
     keys like HKEY_LOCAL_MACHINE.  It fails with "Invalid Handle".  So we
     have to retreat to the Win32 registry functions for registry keys.
     What bugs me is that RegGetKeySecurity is obviously just a wrapper
     around NtQuerySecurityObject, but there seems to be no function to
     convert pseudo HKEY values to real handles. */
  if (object_type == SE_REGISTRY_KEY)
    return get_reg_security (handle, sd_ret);

  ret = NtQuerySecurityObject (handle,
d1403 2
a1404 13
			       sd_ret, len, &len);
  if (ret == STATUS_BUFFER_TOO_SMALL)
    {
      if (!sd_ret.malloc (len))
	set_errno (ENOMEM);
      else
	ret = NtQuerySecurityObject (handle,
				     DACL_SECURITY_INFORMATION
				     | GROUP_SECURITY_INFORMATION
				     | OWNER_SECURITY_INFORMATION,
				     sd_ret, len, &len);
    }
  if (ret != STATUS_SUCCESS)
d1406 1
a1406 1
      __seterrno_from_nt_status (ret);
a1411 19
static int
get_nt_object_attribute (HANDLE handle, SE_OBJECT_TYPE object_type,
			 mode_t *attribute, __uid32_t *uidret,
			 __gid32_t *gidret)
{
  security_descriptor sd;
  PSECURITY_DESCRIPTOR psd = NULL;

  if (get_nt_object_security (handle, object_type, sd))
    {
      if (object_type == SE_FILE_OBJECT)
	return -1;
    }
  else
    psd = sd;
  get_info_from_sd (psd, attribute, uidret, gidret);
  return 0;
}

d1418 11
a1428 1
      get_nt_object_attribute (handle, object_type, attribute, uidret, gidret);
d1444 5
a1448 3
      if (!handle || get_nt_object_attribute (handle, SE_FILE_OBJECT,
					      attribute, uidret, gidret))
	get_nt_attribute (file, attribute, uidret, gidret);
d1974 1
a1974 1
  if (!get_reg_security (hdl, sd))
@


1.200
log
@	* autoload.cc (PrivilegeCheck): Define.
	* fhandler.cc (fhandler_base::open): Always try opening with backup
	resp. restore intent.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Always try
	opening with backup intent.
	(fhandler_disk_file::readdir): Ditto when trying to retrieve file id
	explicitely.
	* security.cc (check_file_access): Replace pbuf with correctly
	PPRIVILEGE_SET typed pset.  Check explicitely for backup and/or restore
	privileges when AccessCheck fails, to circumvent AccessCheck
	shortcoming.  Add comment to explain.
@
text
@d1947 3
a1949 2
int
check_file_access (const char *fn, int flags)
a1951 4

  security_descriptor sd;

  HANDLE hToken;
d1953 5
a1957 9
  DWORD desired = 0, granted;
  DWORD plength = sizeof (PRIVILEGE_SET) + 3 * sizeof (LUID_AND_ATTRIBUTES);
  PPRIVILEGE_SET pset = (PPRIVILEGE_SET) alloca (plength);
  static GENERIC_MAPPING NO_COPY mapping = { FILE_GENERIC_READ,
					     FILE_GENERIC_WRITE,
					     FILE_GENERIC_EXECUTE,
					     FILE_ALL_ACCESS };
  if (read_sd (fn, sd) <= 0)
    goto done;
d1959 1
a1959 13
  if (cygheap->user.issetuid ())
    hToken = cygheap->user.token ();
  else
    hToken = hProcImpToken;

  if (flags & R_OK)
    desired |= FILE_READ_DATA;
  if (flags & W_OK)
    desired |= FILE_WRITE_DATA;
  if (flags & X_OK)
    desired |= FILE_EXECUTE;
  if (!AccessCheck (sd, hToken, desired, &mapping,
		    pset, &plength, &granted, &status))
d1977 1
a1977 1
        {
d1982 1
a1982 1
	  if (PrivilegeCheck (hToken, pset, &status) && status)
d1986 1
a1986 1
        {
d1991 1
a1991 1
	  if (PrivilegeCheck (hToken, pset, &status) && status)
d1995 1
a1995 1
        ret = 0;
d2001 43
a2043 1
 done:
@


1.199
log
@	* autoload.cc (Wow64DisableWow64FsRedirection): Define.
	(Wow64RevertWow64FsRedirection): Define.
	* security.cc (cygsuba_installed): New shared variable to store result
	of cygsuba.dll installation test.
	(subauth): Check if cygsuba.dll has been installed and registered
	before issuing the (sub)authentication.
@
text
@d1956 3
a1958 2
  char pbuf[sizeof (PRIVILEGE_SET) + 3 * sizeof (LUID_AND_ATTRIBUTES)];
  DWORD desired = 0, granted, plength = sizeof pbuf;
d1978 1
a1978 1
		    (PPRIVILEGE_SET) pbuf, &plength, &granted, &status))
d1981 37
a2017 1
    set_errno (EACCES);
@


1.198
log
@	* security.cc (create_token): Fix condition for source identifier.
@
text
@d985 14
d1033 42
@


1.197
log
@	* security.cc (subauth): Initialize user_token to NULL.  Add comment.
@
text
@d842 2
a843 1
  source.SourceIdentifier.LowPart = (subauth_token ? 0x0102 : 0x0101);
@


1.196
log
@* security.cc (get_logon_server): Remove nret and use dret for everything to
avoid a g++ warning.
@
text
@d1012 4
a1015 1
  HANDLE user_token = INVALID_HANDLE_VALUE;
d1082 1
a1082 1
  if (user_token != INVALID_HANDLE_VALUE)
@


1.195
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@a222 1
  NET_API_STATUS nret;
d253 1
a253 1
        nret = NetGetAnyDCName (NULL, wdomain, (LPBYTE *) &buf);
d255 2
a256 2
	nret = NetGetDCName (NULL, wdomain, (LPBYTE *) &buf);
      if (nret == NERR_Success)
d267 1
a267 1
  __seterrno_from_win_error (nret);
@


1.194
log
@	* autoload.cc (NtQueryEaFile): Define.
	(NtSetEaFile): Define.
	* fhandler.cc (fhandler_base::open): Use appropriate open flags
	in query case when allow_ntea is set.
	* ntdll.h (struct _FILE_GET_EA_INFORMATION): Define.
	(struct _FILE_FULL_EA_INFORMATION): Define.
	(NtQueryEaFile): Declare.
	(NtSetEaFile): Declare.
	* ntea.cc (read_ea): Rename from NTReadEA and rewrite using
	NtQueryEaFile.
	(write_ea): Rename from NTWriteEA and rewrite using NtSetEaFile.
	* path.cc (get_symlink_ea): Make static.  Add handle parameter to
	accomodate new read_ea call.
	(set_symlink_ea): Make static.  Add handle parameter to accomodate new
	write_ea call.
	(symlink_worker): Call set_symlink_ea while file is still open.
	(symlink_info::check): Call get_symlink_ea after file has been opened.
	* security.cc (get_file_attribute): Accomodate new read_ea call.
	(set_file_attribute): Accomodate new write_ea call.
	* security.h (read_ea): Change declaration accordingly.
	(write_ea): Ditto.
@
text
@d31 1
d212 5
d218 2
a219 1
get_logon_server (const char *domain, char *server, WCHAR *wserver)
d221 3
a223 2
  WCHAR wdomain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  NET_API_STATUS ret;
d226 1
d238 12
a249 3
  /* Try to get the primary domain controller for the domain */
  sys_mbstowcs (wdomain, domain, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  if ((ret = NetGetDCName (NULL, wdomain, (LPBYTE *) &buf)) == STATUS_SUCCESS)
d251 16
a266 6
      sys_wcstombs (server, INTERNET_MAX_HOST_NAME_LENGTH + 1, buf);
      if (wserver)
	for (WCHAR *ptr1 = buf; (*wserver++ = *ptr1++);)
	  ;
      NetApiBufferFree (buf);
      return true;
d268 1
a268 1
  __seterrno_from_win_error (ret);
d504 5
a508 1
      if (sid_in_token_groups (my_grps, well_known_interactive_sid))
d520 7
a526 5
      char buf[64];
      __small_sprintf (buf, "S-1-5-5-%u-%u", auth_luid.HighPart,
		       auth_luid.LowPart);
      grp_list += buf;
      auth_pos = grp_list.count - 1;
d548 3
a550 1
  if (get_logon_server (domain, server, wserver))
d819 2
a820 1
create_token (cygsid &usersid, user_groups &new_groups, struct passwd *pw)
d843 1
a843 1
  source.SourceIdentifier.LowPart = 0x0101;
d864 12
a875 1
  if (hProcToken)
d880 1
a880 1
	if (!GetTokenInformation (hProcToken, TokenStatistics,
d883 1
a883 1
	    ("GetTokenInformation(hProcToken, TokenStatistics), %E");
d889 3
a891 3
      if (!GetTokenInformation (hProcToken, TokenGroups, NULL, 0, &size) &&
	  GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(hProcToken, TokenGroups), %E");
d894 1
a894 1
      else if (!GetTokenInformation (hProcToken, TokenGroups, my_tok_gsids,
d897 1
a897 1
	  debug_printf ("GetTokenInformation(hProcToken, TokenGroups), %E");
d902 16
d945 1
a945 1
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids)))
d1366 1
a1366 1
  if (ret != STATUS_SUCCESS)
@


1.194.4.1
log
@	* include/asm/byteorder.h: Fix copyright dates.

	* autoload.cc (PrivilegeCheck): Define.
	* fhandler.cc (fhandler_base::open): Always try opening with backup
	resp. restore intent.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Always try
	opening with backup intent.
	(fhandler_disk_file::readdir): Ditto when trying to retrieve file id
	explicitely.
	* security.cc (check_file_access): Replace pbuf with correctly
	PPRIVILEGE_SET typed pset.  Check explicitely for backup and/or restore
	privileges when AccessCheck fails, to circumvent AccessCheck
	shortcoming.  Add comment to explain.

	* include/asm/byteorder.h: Correct typo.

	* include/asm/byteorder.h: Don't #define n* macros if -fnoinline is
	specified.

	* environ.cc (build_env): Don't put an empty environment variable into
	the environment.  Optimize use of "len".
	* errno.cc (ERROR_MORE_DATA): Translate to EMSGSIZE rather than EAGAIN.
@
text
@d1833 2
a1834 3
  DWORD desired = 0, granted;
  DWORD plength = sizeof (PRIVILEGE_SET) + 3 * sizeof (LUID_AND_ATTRIBUTES);
  PPRIVILEGE_SET pset = (PPRIVILEGE_SET) alloca (plength);
d1854 1
a1854 1
		    pset, &plength, &granted, &status))
d1857 1
a1857 37
    {
      /* CV, 2006-10-16: Now, that's really weird.  Imagine a user who has no
	 standard access to a file, but who has backup and restore privileges
	 and these privileges are enabled in the access token.  One would
	 expect that the AccessCheck function takes this into consideration
	 when returning the access status.  Otherwise, why bother with the
	 pset parameter, right?
	 But not so.  AccessCheck actually returns a status of "false" here,
	 even though opening a file with backup resp.  restore intent
	 naturally succeeds for this user.  This definitely spoils the results
	 of access(2) for administrative users or the SYSTEM account.  So, in
	 case the access check fails, another check against the user's
	 backup/restore privileges has to be made.  Sigh. */
      int granted_flags = 0;
      if (flags & R_OK)
        {
	  pset->PrivilegeCount = 1;
	  pset->Control = 0;
	  pset->Privilege[0].Luid = *privilege_luid (SE_BACKUP_PRIV);
	  pset->Privilege[0].Attributes = 0;
	  if (PrivilegeCheck (hToken, pset, &status) && status)
	    granted_flags |= R_OK;
	}
      if (flags & W_OK)
        {
	  pset->PrivilegeCount = 1;
	  pset->Control = 0;
	  pset->Privilege[0].Luid = *privilege_luid (SE_RESTORE_PRIV);
	  pset->Privilege[0].Attributes = 0;
	  if (PrivilegeCheck (hToken, pset, &status) && status)
	    granted_flags |= W_OK;
	}
      if (granted_flags == flags)
        ret = 0;
      else
	set_errno (EACCES);
    }
@


1.194.4.2
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d468 2
a469 1
      grp_list += well_known_local_sid;
d476 2
a477 1
      grp_list += well_known_interactive_sid;
d488 5
a492 7
      for (DWORD i = 0; i < my_grps->GroupCount; ++i)
	if (my_grps->Groups[i].Attributes & SE_GROUP_LOGON_ID)
	  {
	    grp_list += my_grps->Groups[i].Sid;
	    auth_pos = grp_list.count - 1;
	    break;
	  }
@


1.194.2.1
log
@	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@a30 1
#include <dsgetdc.h>
a210 5
/* CV, 2006-07-06: Missing in w32api. */
extern "C" DWORD WINAPI DsGetDcNameA (LPCSTR, LPCSTR, GUID *, LPCSTR, ULONG,
				      PDOMAIN_CONTROLLER_INFOA *);
#define DS_FORCE_REDISCOVERY	1

d212 1
a212 2
get_logon_server (const char *domain, char *server, WCHAR *wserver,
		  bool rediscovery)
d214 2
a215 3
  DWORD dret;
  PDOMAIN_CONTROLLER_INFOA pci;
  NET_API_STATUS nret;
a217 1
  WCHAR wdomain[size];
d229 9
a237 9
  /* Try to get any available domain controller for this domain */
  dret = DsGetDcNameA (NULL, domain, NULL, NULL,
		       rediscovery ? DS_FORCE_REDISCOVERY : 0, &pci);
  if (dret == ERROR_SUCCESS)
    {
      strcpy (server, pci->DomainControllerName);
      sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      NetApiBufferFree (pci);
      debug_printf ("DC: rediscovery: %d, server: %s", rediscovery, server);
d240 1
a240 20
  else if (dret == ERROR_PROC_NOT_FOUND)
    {
      /* NT4 w/o DSClient */
      sys_mbstowcs (wdomain, domain, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      if (rediscovery)
        nret = NetGetAnyDCName (NULL, wdomain, (LPBYTE *) &buf);
      else
	nret = NetGetDCName (NULL, wdomain, (LPBYTE *) &buf);
      if (nret == NERR_Success)
	{
	  sys_wcstombs (server, INTERNET_MAX_HOST_NAME_LENGTH + 1, buf);
	  if (wserver)
	    for (WCHAR *ptr1 = buf; (*wserver++ = *ptr1++);)
	      ;
	  NetApiBufferFree (buf);
	  debug_printf ("NT: rediscovery: %d, server: %s", rediscovery, server);
	  return true;
	}
    }
  __seterrno_from_win_error (nret);
d514 1
a514 3
  if (get_logon_server (domain, server, wserver, false)
      && !get_user_groups (wserver, grp_list, user, domain)
      && get_logon_server (domain, server, wserver, true))
d1302 1
a1302 1
  if (ret != ERROR_SUCCESS)
@


1.194.2.2
log
@	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.
@
text
@d504 1
a504 5
      /* This is a problem on 2K3 (only domain controllers?!?) which only
         enables tools for selected special groups.  A subauth token is
	 only NETWORK, but NETWORK has no access to these tools.  Therefore
	 we always add INTERACTIVE here. */
      /*if (sid_in_token_groups (my_grps, well_known_interactive_sid))*/
d516 5
a520 7
      for (DWORD i = 0; i < my_grps->GroupCount; ++i)
	if (my_grps->Groups[i].Attributes & SE_GROUP_LOGON_ID)
	  {
	    grp_list += my_grps->Groups[i].Sid;
	    auth_pos = grp_list.count - 1;
	    break;
	  }
d813 1
a813 2
create_token (cygsid &usersid, user_groups &new_groups, struct passwd *pw,
	      HANDLE subauth_token)
d836 1
a836 1
  source.SourceIdentifier.LowPart = (subauth_token ? 0x0102 : 0x0101);
d857 1
a857 12
  HANDLE get_token;
  if (subauth_token)
    {
      debug_printf ("get_token = subauth_token");
      get_token = subauth_token;
    }
  else
    {
      debug_printf ("get_token = hProcToken");
      get_token = hProcToken;
    }
  if (get_token)
d862 1
a862 1
	if (!GetTokenInformation (get_token, TokenStatistics,
d865 1
a865 1
	    ("GetTokenInformation(get_token, TokenStatistics), %E");
d871 3
a873 3
      if (!GetTokenInformation (get_token, TokenGroups, NULL, 0, &size)
	  && GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(get_token, TokenGroups), %E");
d876 1
a876 1
      else if (!GetTokenInformation (get_token, TokenGroups, my_tok_gsids,
d879 1
a879 1
	  debug_printf ("GetTokenInformation(get_token, TokenGroups), %E");
a883 16
  if (subauth_token)
    {
      if (!GetTokenInformation (subauth_token, TokenPrivileges, NULL, 0, &size)
	  && GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(subauth_token, TokenPrivileges), %E");
      else if (!(privs = (PTOKEN_PRIVILEGES) malloc (size)))
	debug_printf ("malloc (privs) failed.");
      else if (!GetTokenInformation (subauth_token, TokenPrivileges, privs,
				     size, &size))
	{
	  debug_printf ("GetTokenInformation(subauth_token, TokenPrivileges), %E");
	  free (privs);
	  privs = NULL;
	}
    }
    
d911 1
a911 1
  if (!privs && !(privs = get_priv_list (lsa, usersid, tmp_gsids)))
@


1.193
log
@	* dtable.cc (handle_to_fn): Accomodate new argument order in call to
	sys_wcstombs.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Call sys_wcstombs
	instead of just wcstombs to accomodate OEM codepages.
	* miscfuncs.cc (sys_wcstombs): Split len argument in source and target
	length.  Always 0-terminate result in target string.
	* security.cc (lsa2wchar): Remove unused function.
	(lsa2str): Ditto.
	(get_lsa_srv_inf): Ditto.
	(get_logon_server): Accomodate new argument order in call to
	sys_wcstombs.
	(get_user_groups): Ditto.
	(get_user_local_groups): Ditto.
	(get_priv_list): Call sys_wcstombs directly instead of lsa2str.
	* uinfo.cc (cygheap_user::ontherange): Accomodate new argument order
	in call to sys_wcstombs.
	* winsup.h (sys_wcstombs): Change prototype to match new argument order.
@
text
@d1408 2
a1409 1
      res = NTReadEA (file, ".UNIXATTR", (char *)attribute, sizeof (*attribute));
d1805 2
a1806 2
  else if (allow_ntea && !NTWriteEA (file, ".UNIXATTR", (char *) &attribute,
				     sizeof (attribute)))
@


1.192
log
@	* security.cc (is_group_member): Fix comment.
@
text
@a190 22
#if 0				/* unused */
static void
lsa2wchar (WCHAR *tgt, LSA_UNICODE_STRING &src, int size)
{
  size = (size - 1) * sizeof (WCHAR);
  if (src.Length < size)
    size = src.Length;
  memcpy (tgt, src.Buffer, size);
  size >>= 1;
  tgt[size] = 0;
}
#endif

static void
lsa2str (char *tgt, LSA_UNICODE_STRING &src, int size)
{
  if (src.Length / 2 < size)
    size = src.Length / 2;
  sys_wcstombs (tgt, src.Buffer, size);
  tgt[size] = 0;
}

a210 54
#if 0 /* unused */
static BOOL
get_lsa_srv_inf (LSA_HANDLE lsa, char *logonserver, char *domain)
{
  NET_API_STATUS ret;
  WCHAR *buf;
  char name[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  WCHAR account[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  WCHAR primary[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  PPOLICY_ACCOUNT_DOMAIN_INFO adi;
  PPOLICY_PRIMARY_DOMAIN_INFO pdi;

  if ((ret = LsaQueryInformationPolicy (lsa, PolicyAccountDomainInformation,
					(PVOID *) &adi)) != STATUS_SUCCESS)
    {
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      return FALSE;
    }
  lsa2wchar (account, adi->DomainName, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  LsaFreeMemory (adi);
  if ((ret = LsaQueryInformationPolicy (lsa, PolicyPrimaryDomainInformation,
					(PVOID *) &pdi)) != STATUS_SUCCESS)
    {
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      return FALSE;
    }
  lsa2wchar (primary, pdi->Name, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  LsaFreeMemory (pdi);
  /* If the SID given in the primary domain info is NULL, the machine is
     not member of a domain.  The name in the primary domain info is the
     name of the workgroup then. */
  if (pdi->Sid &&
      (ret =
       NetGetDCName (NULL, primary, (LPBYTE *) &buf)) == STATUS_SUCCESS)
    {
      sys_wcstombs (name, buf, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      strcpy (logonserver, name);
      if (domain)
	sys_wcstombs (domain, primary, INTERNET_MAX_HOST_NAME_LENGTH + 1);
    }
  else
    {
      sys_wcstombs (name, account, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      strcpy (logonserver, "\\\\");
      strcat (logonserver, name);
      if (domain)
	sys_wcstombs (domain, account, INTERNET_MAX_HOST_NAME_LENGTH + 1);
    }
  if (ret == STATUS_SUCCESS)
    NetApiBufferFree (buf);
  return TRUE;
}
#endif

d233 1
a233 1
      sys_wcstombs (server, buf, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d277 1
a277 1
      sys_wcstombs (dgroup + len, buf[i].grui0_name, GNLEN + 1);
d372 1
a372 1
	sys_wcstombs (bgroup + blen, buf[i].lgrpi0_name, GNLEN + 1);
d641 2
a642 1
	  lsa2str (buf, privstrs[i], sizeof (buf) - 1);
@


1.191
log
@	* security.cc (is_group_member): Use local group info type 1.  Test
	group for being a global group or a well-known SID before adding it
	to the group list.  Add comment.
@
text
@d391 6
a396 5
	   logon token does not contain those 2nd order aliases, so we also
	   should not put them into the token group list.
	   Note: Allowing those 2nd order aliases in our group list renders
	   external tokens invalid, so that it becomes impossible to logon
	   with password and valid logon token. */
@


1.190
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d370 1
a370 1
  LPLOCALGROUP_MEMBERS_INFO_0 buf;
d375 1
a375 1
  ret = NetLocalGroupGetMembers (NULL, wgroup, 0, (LPBYTE *) &buf,
d382 1
a382 1
    if (EqualSid (pusersid, buf[bidx].lgrmi0_sid))
d385 17
a401 3
      for (int glidx = 0; glidx < grp_list.count; ++glidx)
	if (EqualSid (grp_list.sids[glidx], buf[bidx].lgrmi0_sid))
	  goto done;
@


1.189
log
@white space
@
text
@a72 1
  return;
a1268 1
  return;
a1326 1
  return;
@


1.188
log
@	* security.cc (get_reg_security): New static function.
	(get_nt_object_security): Call get_reg_security for registry keys
	to circumvent problems with predefined registry keys.
@
text
@d1357 1
a1357 1
        set_errno (ENOMEM);
d1379 1
a1379 1
  
d1382 1
a1382 1
     have to retreat to the Win32 registry functions for registry keys. 
@


1.187
log
@	* security.cc (get_initgroups_sidlist): Drop special_pgrp parameter.
	(get_setgroups_sidlist): Avoid duplicate groups in group list.
	(create_token): Remove special_pgrp local variable.  Accomodate
	change to get_initgroups_sidlist call.
@
text
@d1343 30
d1379 10
@


1.186
log
@	* security.cc (cygwin_logon_user): Run LogonUser in the primary
	process token context.  Fix potential handle leak.
@
text
@d585 1
a585 2
			PTOKEN_GROUPS my_grps, LUID auth_luid, int &auth_pos,
			bool &special_pgrp)
d591 2
a592 2
   else
     get_token_group_sidlist (grp_list, my_grps, auth_luid, auth_pos);
d597 1
a597 1
  if ((special_pgrp = !grp_list.contains (pgrpsid)))
d611 2
a612 1
    tmp_list += groups.sgsids.sids[gidx];
a853 1
  bool special_pgrp = false;
d922 1
a922 2
				    my_tok_gsids, auth_luid, auth_pos,
				    special_pgrp))
@


1.185
log
@	* pinfo.cc (pinfo::init): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	(pinfo::set_acl): Replace sa_buf by dynamically allocated acl_buf.
	* sec_acl.cc (setacl): Allocate acl dynamically.
	* sec_helper.cc (sec_acl): Add test for alignment of acl when
	DEBUGGING is defined.
	(__sec_user): Same for sa_buf.
	* security.cc (verify_token): Define sd_buf as PSECURITY_DESCRIPTOR
	and allocate dynamically.
	(alloc_sd): Allocate acl dynamically.
	security.h (sec_user_nih): Change first parameter to
	SECURITY_ATTRIBUTES *.
	(sec_user): Ditto.
	* sigproc.cc (wait_sig): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	* syscalls.cc (seteuid32): Define dacl_buf as PACL and allocate
	dynamically.
	* uinfo.cc (cygheap_user::init): Define sa_buf as PSECURITY_ATTRIBUTES
	and allocate dynamically.
	* winbase.h (ilockincr): Mark first argument of inline assembly as
	earlyclobber.
	(ilockdecr): Ditto.
@
text
@d127 3
d133 1
a133 4
		   &hToken)
      || !SetHandleInformation (hToken,
				HANDLE_FLAG_INHERIT,
				HANDLE_FLAG_INHERIT))
d136 1
a136 1
      return INVALID_HANDLE_VALUE;
d138 9
@


1.184
log
@	* security.cc (alloc_sd): Remove DELETE bit from user's ACE if
	allow_traverse is set.
@
text
@d775 2
a776 1
      char sd_buf[MAX_SID_LEN + sizeof (SECURITY_DESCRIPTOR)];
d779 1
a779 2
				    (PSECURITY_DESCRIPTOR) sd_buf,
				    sizeof sd_buf, &size))
d781 2
a782 2
      else if (!GetSecurityDescriptorGroup ((PSECURITY_DESCRIPTOR) sd_buf,
					    (PSID *) &gsid, (BOOL *) &size))
d1541 1
a1541 2
  char acl_buf[3072];
  PACL acl = (PACL) acl_buf;
@


1.183
log
@	* security.h (cygsidlist::addfromgr): Allow duplicate entries.
	(get_server_groups): Declare new function.
	* security.cc (is_group_member): Simplify.
	(get_server_groups): New function.
	(get_initgroups_sidlist): Call get_server_groups.
	(verify_token): Allow token when supplementary sids are not in
	/etc/group but are in the token.
	Streamline the code.
	* grp.cc (initgroups32): New implementation.
	(getgroups32): Handle case where the supplementary groups are set.
@
text
@d1556 8
@


1.182
log
@	* cygerrno.h (__seterrno_from_nt_status): Define. Always set Win32
	error code as well as errno. Use throughout where errno is set from
	NT status.
	(set_errno): Evaluate val only once.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fix typo in
	debug output.
	* fhandler_mem.cc (fhandler_dev_mem::open): Rely on
	__seterrno_from_nt_status setting Win32 error code in debug output.
	* fhandler_proc.cc (format_proc_uptime): Ditto.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	* sysconf.cc (sysconf): Ditto.
@
text
@d45 1
a45 2
   It's defined here because of it's strong relationship to allow_ntsec.
   The default is TRUE to reflect the old behaviour. */
a364 1
  bool retval = false;
d372 2
a373 1
  for (DWORD bidx = 0; !retval && bidx < cnt; ++bidx)
d375 1
a375 1
      retval = true;
d377 1
a377 1
      for (int glidx = 0; !retval && glidx < grp_list.count; ++glidx)
d379 1
a379 1
	  retval = true;
d381 2
d549 24
d582 5
a586 11
    {
      auth_pos = -1;
      grp_list += well_known_admins_sid;
      get_unix_group_sidlist (pw, grp_list);
    }
  else
    {
      char user[UNLEN + 1];
      char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      WCHAR wserver[INTERNET_MAX_HOST_NAME_LENGTH + 3];
      char server[INTERNET_MAX_HOST_NAME_LENGTH + 3];
a587 8
      get_token_group_sidlist (grp_list, my_grps, auth_luid, auth_pos);
      extract_nt_dom_user (pw, domain, user);
      if (get_logon_server (domain, server, wserver))
	get_user_groups (wserver, grp_list, user, domain);
      get_unix_group_sidlist (pw, grp_list);
      if (!get_user_local_groups (grp_list, usersid))
	return false;
    }
d789 1
a789 2
  bool saw_buf[NGROUPS_MAX] = {};
  bool *saw = saw_buf, sawpg = false, ret = false;
d798 1
a798 4
  else if (!groups.issetgroups ()) /* setgroups was never called */
    ret = sid_in_token_groups (my_grps, groups.pgsid)
	  || groups.pgsid == usersid;
  else /* setgroups was called */
d800 23
a822 17
      struct __group32 *gr;
      cygsid gsid;
      if (groups.sgsids.count > (int) (sizeof (saw_buf) / sizeof (*saw_buf))
	  && !(saw = (bool *) calloc (groups.sgsids.count, sizeof (bool))))
	goto done;

      /* token groups found in /etc/group match the user.gsids ? */
      for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	if (gsid.getfromgr (gr) && sid_in_token_groups (my_grps, gsid))
	  {
	    int pos = groups.sgsids.position (gsid);
	    if (pos >= 0)
	      saw[pos] = true;
	    else if (groups.pgsid == gsid)
	      sawpg = true;
	    else if (gsid != well_known_world_sid
		     && gsid != usersid)
d824 2
a825 4
	  }
      for (int gidx = 0; gidx < groups.sgsids.count; gidx++)
	if (!saw[gidx])
	  goto done;
d827 2
a828 2
	    || groups.sgsids.contains (groups.pgsid)
	    || groups.pgsid == usersid;
a830 2
  if (saw != saw_buf)
    free (saw);
@


1.181
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d934 1
a934 1
    __seterrno_from_win_error (RtlNtStatusToDosError (ret));
d1156 1
a1156 1
    __seterrno_from_win_error (RtlNtStatusToDosError (ret));
d1351 1
a1351 1
      __seterrno_from_win_error (RtlNtStatusToDosError (ret));
@


1.180
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@d48 1
d597 27
a623 20
static const char *sys_privs[] = {
  SE_TCB_NAME,
  SE_ASSIGNPRIMARYTOKEN_NAME,
  SE_CREATE_TOKEN_NAME,
  SE_CHANGE_NOTIFY_NAME,
  SE_SECURITY_NAME,
  SE_BACKUP_NAME,
  SE_RESTORE_NAME,
  SE_SYSTEMTIME_NAME,
  SE_SHUTDOWN_NAME,
  SE_REMOTE_SHUTDOWN_NAME,
  SE_TAKE_OWNERSHIP_NAME,
  SE_DEBUG_NAME,
  SE_SYSTEM_ENVIRONMENT_NAME,
  SE_SYSTEM_PROFILE_NAME,
  SE_PROF_SINGLE_PROCESS_NAME,
  SE_INC_BASE_PRIORITY_NAME,
  SE_LOAD_DRIVER_NAME,
  SE_CREATE_PAGEFILE_NAME,
  SE_INCREASE_QUOTA_NAME
d626 1
a626 1
#define SYSTEM_PERMISSION_COUNT (sizeof sys_privs / sizeof (const char *))
d631 1
a631 1
  LUID priv;
d633 2
a634 1
    malloc (sizeof (ULONG) + 20 * sizeof (LUID_AND_ATTRIBUTES));
d642 2
a643 2
  for (DWORD i = 0; i < SYSTEM_PERMISSION_COUNT; ++i)
    if (LookupPrivilegeValue (NULL, sys_privs[i], &priv))
d645 1
a645 1
	privs->Privileges[privs->PrivilegeCount].Luid = priv;
d679 1
a679 1
	  LUID priv;
d684 1
a684 1
	  if (!LookupPrivilegeValue (NULL, buf, &priv))
d687 9
a695 3
	  for (DWORD p = 0; privs && p < privs->PrivilegeCount; ++p)
	    if (!memcmp (&priv, &privs->Privileges[p].Luid, sizeof (LUID)))
	      goto next_account_right;
d711 1
a711 1
	  privs->Privileges[privs->PrivilegeCount].Luid = priv;
a829 1
  int old_priv_state;
a835 1
  PSECURITY_ATTRIBUTES psa;
a836 1
  char sa_buf[1024];
a854 1
  HANDLE my_token = INVALID_HANDLE_VALUE;
d859 1
a859 2
  if ((old_priv_state = set_process_privilege (SE_CREATE_TOKEN_NAME)) < 0)
    goto out;
d871 1
a871 3
  if (!OpenProcessToken (hMainProc, TOKEN_QUERY, &my_token))
    debug_printf ("OpenProcessToken(my_token), %E");
  else
d876 1
a876 1
	if (!GetTokenInformation (my_token, TokenStatistics,
d879 1
a879 1
	    ("GetTokenInformation(my_token, TokenStatistics), %E");
d885 1
a885 1
      if (!GetTokenInformation (my_token, TokenGroups, NULL, 0, &size) &&
d887 1
a887 1
	debug_printf ("GetTokenInformation(my_token, TokenGroups), %E");
d890 1
a890 1
      else if (!GetTokenInformation (my_token, TokenGroups, my_tok_gsids,
d893 1
a893 1
	  debug_printf ("GetTokenInformation(my_token, TokenGroups), %E");
a896 1
      CloseHandle (my_token);
a941 9
      /* Set security descriptor and primary group */
      psa = sec_user (sa_buf, usersid);
      if (psa->lpSecurityDescriptor &&
	  !SetSecurityDescriptorGroup ((PSECURITY_DESCRIPTOR)
				       psa->lpSecurityDescriptor,
				       special_pgrp ? new_groups.pgsid
						    : well_known_null_sid,
				       FALSE))
	debug_printf ("SetSecurityDescriptorGroup %E");
d943 3
a945 2
      if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, psa, SecurityImpersonation,
			     TokenPrimary, &primary_token))
d953 1
a953 2
  if (old_priv_state >= 0)
    set_process_privilege (SE_CREATE_TOKEN_NAME, old_priv_state);
a993 1
  SECURITY_ATTRIBUTES sa = { sizeof sa, NULL, TRUE };
a995 1
  int old_tcb_state;
d997 1
a997 2
  if ((old_tcb_state = set_process_privilege (SE_TCB_NAME)) < 0)
    return INVALID_HANDLE_VALUE;
d1055 1
a1055 1
  if (!DuplicateTokenEx (user_token, TOKEN_ALL_ACCESS, &sa,
d1060 1
a1060 1
  set_process_privilege (SE_TCB_NAME, old_tcb_state);
d1830 1
a1830 1
  HANDLE hToken, hIToken;
d1843 2
a1844 11
  else if (!OpenProcessToken (hMainProc, TOKEN_DUPLICATE, &hToken))
    {
      __seterrno ();
      goto done;
    }
  if (!(status = DuplicateToken (hToken, SecurityIdentification, &hIToken)))
    __seterrno ();
  if (!cygheap->user.issetuid ())
    CloseHandle (hToken);
  if (!status)
    goto done;
d1852 1
a1852 1
  if (!AccessCheck (sd, hIToken, desired, &mapping,
a1858 1
  CloseHandle (hIToken);
@


1.179
log
@* fhandler_tape.cc (get_ll): This is a generally useful function so move it
* winsup.h (get_ll): to here
* security.cc (get_token_group_sidlist): Use get_ll to figure out the long long
version of the luid since QuadPart is not part of the standard Windows API.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.178
log
@2004-10-28  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.cc (mount_info::from_registry): Deimpersonate while
        accessing HKLM.
        (mount_info::read_cygdrive_info_from_registry): Ditto.
        * cygheap.h: Define NO_IMPERSONATION.
        (cygheap_user::issetuid): Replace INVALID_HANDLE_VALUE by
        NO_IMPERSONATION.
        (cygheap_user::has_impersonation_tokens): Ditto.
        (cygheap_user::close_impersonation_tokens): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
        * syscalls.cc (seteuid32): Ditto.
        * security.cc (set_impersonation_token): Ditto.
@
text
@d537 1
a537 1
  if (auth_luid.QuadPart != 999) /* != SYSTEM_LUID */
@


1.177
log
@2004-10-05  Pierre Humblet <pierre.humblet@@ieee.org>

	* external.cc (check_ntsec): Do not call wincap.has_security.
	* path.cc (path_conv::check): Ditto.
	* security.cc (get_object_attribute): Ditto.
	(get_file_attribute): Ditto.
@
text
@d72 1
a72 1
  cygheap->user.external_token = hToken;
@


1.176
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d1385 1
a1385 1
  if (allow_ntsec && wincap.has_security ())
d1401 1
a1401 1
  if (use_ntsec && allow_ntsec && wincap.has_security ())
@


1.175
log
@	* security.cc: Fix a few more strace_prints.
@
text
@d166 2
a167 2
  tgt.Length = sys_mbstowcs (buf, srcstr, tgt.MaximumLength / sizeof (WCHAR)) 
               * sizeof (WCHAR);
d176 1
a176 1
		          (tgt.MaximumLength - tgt.Length) / sizeof (WCHAR));
@


1.174
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d83 1
a83 1
  debug_printf ("pw_gecos = %x (%s)", pw->pw_gecos, pw->pw_gecos);
d1112 1
a1112 1
      debug_printf ("file = %s", file);
d1116 1
a1116 1
  debug_printf ("file = %s: len=%d", file, len);
d1316 1
a1316 1
  syscall_printf ("%sACL = %x, uid %d, gid %d",
@


1.173
log
@2004-06-17  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.cc (fhandler_base::open_9x): Do not check for null name.
        Move debug_printf to common code line.
        (fhandler_base::open): Ditto. Initialize upath. Remove second argument
        of pc.get_nt_native_path.
        * path.h (path_conv::get_nt_native_path): Remove second argument.
        * path.cc (path_conv::get_nt_native_path): Ditto. Call str2uni_cat.
        * security.h (str2buf2uni_cat): Delete declaration.
        (str2uni_cat): New declaration.
        * security.cc (str2buf2uni): Get length from sys_mbstowcs call.
        (str2buf2uni_cat): Delete function.
        (str2uni_cat): New function.
        * miscfuncs.cc (sys_mbstowcs): Add debug_printf.
@
text
@d347 1
a347 1
	debug_printf ("LookupAccountName(%s): %E", dgroup);
d427 1
a427 1
	      debug_printf ("LookupAccountName(%s): %E", bgroup);
d431 1
a431 1
	      debug_printf ("LookupAccountName(%s): %E", lgroup);
d733 1
a733 1
	debug_printf ("GetTokenInformation(): %E");
d741 1
a741 1
    debug_printf ("GetTokenInformation(): %E");
d754 1
a754 1
	debug_printf ("GetKernelObjectSecurity(): %E");
d757 1
a757 1
	debug_printf ("GetSecurityDescriptorGroup(): %E");
d768 1
a768 1
    debug_printf ("GetTokenInformation(token, TokenGroups): %E");
d772 1
a772 1
    debug_printf ("GetTokenInformation(my_token, TokenGroups): %E");
d862 1
a862 1
    debug_printf ("OpenProcessToken(my_token): %E");
d871 1
a871 1
	    ("GetTokenInformation(my_token, TokenStatistics): %E");
d879 1
a879 1
	debug_printf ("GetTokenInformation(my_token, TokenGroups): %E");
d885 1
a885 1
	  debug_printf ("GetTokenInformation(my_token, TokenGroups): %E");
@


1.172
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d159 2
a163 2
  tgt.Length = strlen (srcstr) * sizeof (WCHAR);
  tgt.MaximumLength = tgt.Length + sizeof (WCHAR);
d165 5
a169 1
  sys_mbstowcs (buf, srcstr, tgt.MaximumLength);
d173 1
a173 1
str2buf2uni_cat (UNICODE_STRING &tgt, const char *srcstr)
d175 6
a180 5
  DWORD len = strlen (srcstr) * sizeof (WCHAR);
  sys_mbstowcs (tgt.Buffer + tgt.Length / sizeof (WCHAR), srcstr,
		len + tgt.MaximumLength);
  tgt.Length += len;
  tgt.MaximumLength += len;
@


1.171
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d1080 1
a1080 1
   
d1145 1
a1145 1
					    DACL_SECURITY_INFORMATION 
d1771 1
a1771 1
  					attribute, sd);
@


1.170
log
@	* sec_acl.cc (getacl): Avoid compiler warning.
	* security.cc (write_sd): Ditto.  Fix error handling.
@
text
@d168 10
a1131 29
  /* Try turning privilege on, may not have WRITE_OWNER or WRITE_DAC access.
     Must have privilege to set different owner, else BackupWrite misbehaves */
  static int NO_COPY saved_res; /* 0: never, 1: failed, 2 & 3: OK */
  int res;
  if (!saved_res || cygheap->user.issetuid ())
    {
      res = 2 + set_process_privilege (SE_RESTORE_NAME, true,
				       cygheap->user.issetuid ());
      if (!cygheap->user.issetuid ())
	saved_res = res;
    }
  else
    res = saved_res;
  if (res == 1)
    {
      BOOL dummy;
      cygpsid owner;

      if (!GetSecurityDescriptorOwner (sd, (PSID *) &owner, &dummy))
	{
	  __seterrno ();
	  return -1;
	}
      if (owner != cygheap->user.sid ())
	{
	  set_errno (EPERM);
	  return -1;
	}
    }
d1134 1
a1134 1
  res = -1;
@


1.169
log
@	* fhandler.cc (fhandler_base::open): Simplify access evaluation
	expression.
	(fhandler_base::facl): New method.
	* fhandler.h: Declare facl method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): New method.
	* fhandler_virtual.cc (fhandler_virtual::facl): New method.
	* sec_acl.cc: Remove forward declaration for aclsort32 and acl32.
	(setacl): Remove static.  Add and use handle parameter.
	(getacl): Ditto.
	(acl_worker): Reorganize to call fhandler's facl method eventually.
	(facl32): Ditto.
	* security.cc (get_nt_object_security): Remove static.
	* security.h: Add extern declarations for get_nt_object_security,
	aclsort32, acl32, getacl and setacl.


	Apply missing syscalls.cc patch and ChangeLog of previous check in.
	* syscalls.cc (chown_worker): Reorganize to call fhandler's fchown
	method eventually.
	(fchown): Ditto.
@
text
@d1151 1
a1151 1
  NTSTATUS ret;
d1153 1
d1172 7
a1178 6
  if (ret != STATUS_SUCCESS)
    {
      __seterrno_from_win_error (RtlNtStatusToDosError (ret));
      return -1;
    }
  return 0;
@


1.168
log
@	* fhandler.cc (fhandler_base::open): Accomodate query_write_control
	query_state.
	(fhandler_base::fchown): New method.
	* fhandler.h: Declare fchown method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	(enum query_state): Add query_write_control.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Set query_state
	to query_write_control.  Only remove FILE_ATTRIBUTE_READONLY if not
	setting security descriptor.
	(fhandler_disk_file::fchown): New method.
	* fhandler_virtual.cc (fhandler_virtual::fchown): New method.
	* sec_acl.cc (setacl): Call write_sd with additional handle attribute.
	* security.cc (write_sd): Take handle argument.  Only request owner
	if getting SE_RESTORE_NAME privilege failed.  Only open file if
	NtSetSecurityObject failed or handle is NULL.
	(set_nt_attribute): Call write_sd with additional handle attribute.
	* security.h (write_sd): Declare with additional handle argument.
@
text
@d1344 1
a1344 1
static int
@


1.167
log
@	* autoload.cc (NtSetSecurityObject): Add.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Only request
	READ_CONTROL rights when opening the file.
	* ntdll.h (NtSetSecurityObject): Add declaration.
	* security.cc (write_sd): Call NtSetSecurityObject instead of
	BackupWrite.
	(get_nt_object_security): Don't free security descriptor here.

	* syscalls.cc (ttyname): Use buffer of length TTY_NAME_MAX + 1.
	* sysconf.cc (sysconf): Handle _SC_TTY_NAME_MAX request.
	* include/limits.h: Define TTY_NAME_MAX and _POSIX_TTY_NAME_MAX.
@
text
@d1120 1
a1120 1
write_sd (const char *file, security_descriptor &sd)
a1121 8
  BOOL dummy;
  cygpsid owner;

  if (!GetSecurityDescriptorOwner (sd, (PSID *) &owner, &dummy))
    {
      __seterrno ();
      return -1;
    }
d1135 1
a1135 1
  if (res == 1 && owner != cygheap->user.sid ())
d1137 13
a1149 2
      set_errno (EPERM);
      return -1;
d1151 3
a1153 8
  HANDLE fh;
  if ((fh = CreateFile (file,
		        WRITE_OWNER | WRITE_DAC,
		        FILE_SHARE_READ | FILE_SHARE_WRITE,
		        &sec_none_nih,
		        OPEN_EXISTING,
		        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
		        NULL)) == INVALID_HANDLE_VALUE)
d1155 13
a1167 2
      __seterrno ();
      return -1;
d1169 2
a1170 6
  NTSTATUS ret = NtSetSecurityObject (fh,
				      DACL_SECURITY_INFORMATION 
				      | GROUP_SECURITY_INFORMATION
				      | OWNER_SECURITY_INFORMATION,
				      sd);
  CloseHandle (fh);
d1810 1
a1810 1
  return write_sd (file, sd);
@


1.166
log
@	* security.cc (set_nt_attribute): Only call get_nt_object_security
	if handle is NULL.
@
text
@d1144 4
a1147 2
    return -1;

d1149 7
a1155 9
  fh = CreateFile (file,
		   WRITE_OWNER | WRITE_DAC,
		   FILE_SHARE_READ | FILE_SHARE_WRITE,
		   &sec_none_nih,
		   OPEN_EXISTING,
		   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
		   NULL);

  if (fh == INVALID_HANDLE_VALUE)
d1160 7
a1166 15

  LPVOID context = NULL;
  DWORD bytes_written = 0;
  WIN32_STREAM_ID header;

  memset (&header, 0, sizeof (header));
  /* write new security info header */
  header.dwStreamId = BACKUP_SECURITY_DATA;
  header.dwStreamAttributes = STREAM_CONTAINS_SECURITY;
  header.Size.HighPart = 0;
  header.Size.LowPart = sd.size ();
  header.dwStreamNameSize = 0;
  if (!BackupWrite (fh, (LPBYTE) &header,
		    3 * sizeof (DWORD) + sizeof (LARGE_INTEGER),
		    &bytes_written, FALSE, TRUE, &context))
d1168 1
a1168 2
      __seterrno ();
      CloseHandle (fh);
a1170 22

  /* write new security descriptor */
  if (!BackupWrite (fh, (LPBYTE) (PSECURITY_DESCRIPTOR) sd,
		    header.Size.LowPart + header.dwStreamNameSize,
		    &bytes_written, FALSE, TRUE, &context))
    {
      /* Samba returns ERROR_NOT_SUPPORTED.
	 FAT returns ERROR_INVALID_SECURITY_DESCR.
	 This shouldn't return as error, but better be ignored. */
      DWORD ret = GetLastError ();
      if (ret != ERROR_NOT_SUPPORTED && ret != ERROR_INVALID_SECURITY_DESCR)
	{
	  __seterrno ();
	  BackupWrite (fh, NULL, 0, &bytes_written, TRUE, TRUE, &context);
	  CloseHandle (fh);
	  return -1;
	}
    }

  /* terminate the restore process */
  BackupWrite (fh, NULL, 0, &bytes_written, TRUE, TRUE, &context);
  CloseHandle (fh);
a1362 1
      sd_ret.free ();
@


1.165
log
@	* dir.cc (mkdir): Call set_file_attribute with additional handle
	argument.
	* fhandler.cc (fhandler_base::fchmod): New method.
	* fhandler.h: Declare fchmod method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): New method.
	(fhandler_base::open_fs): Call set_file_attribute with additional
	handle argument.
	* fhandler_virtual.cc (fhandler_virtual::fchmod): New method.
	* path.cc (symlink_worker): Call set_file_attribute with additional
	handle argument.
	* security.cc (get_nt_object_security): New function.
	(get_nt_object_attribute): Call get_nt_object_security.
	(set_nt_attribute): Add handle argument.  Call get_nt_object_security
	first, read_sd only if that fails.
	(set_file_attribute): Add handle argument.
	* security.h (set_file_attribute): Declare with additional handle
	argument.
	* syscalls.cc (stat_suffixes): Move to beginning of file.
	(chown_worker): Call set_file_attribute with additional handle argument.
	(chmod): Reorganize to call fhandler's fchmod method eventually.
	(fchmod): Ditto.
@
text
@d1827 1
a1827 1
  if (get_nt_object_security (handle, SE_FILE_OBJECT, sd)
@


1.164
log
@	* autoload.cc (NtQuerySecurityObject): Add.
	* ntdll.h (STATUS_BUFFER_TOO_SMALL): Add definition.
	(NtQuerySecurityObject): Add declaration.
	* security.cc (get_nt_object_attribute): Always use
	NtQuerySecurityObject to retrieve security descriptor.
@
text
@d1371 2
a1372 3
get_nt_object_attribute (HANDLE handle, SE_OBJECT_TYPE object_type,
			 mode_t *attribute, __uid32_t *uidret,
			 __gid32_t *gidret)
a1373 3
  security_descriptor sd;
  PSECURITY_DESCRIPTOR psd = NULL;

d1380 1
a1380 1
			       sd, len, &len);
d1383 1
a1383 1
      if (!sd.malloc (len))
d1390 1
a1390 1
				     sd, len, &len);
d1394 1
d1396 15
d1412 1
a1412 1
        return -1;
a1416 1

d1819 2
a1820 2
set_nt_attribute (const char *file, __uid32_t uid, __gid32_t gid,
		  int attribute)
d1827 2
a1828 2
  int ret;
  if ((ret = read_sd (file, sd)) <= 0)
d1841 1
a1841 1
set_file_attribute (int use_ntsec, const char *file,
d1847 1
a1847 1
    ret = set_nt_attribute (file, uid, gid, attribute);
d1860 2
a1861 1
set_file_attribute (int use_ntsec, const char *file, int attribute)
d1863 1
a1863 1
  return set_file_attribute (use_ntsec, file,
@


1.163
log
@	* security.cc (get_file_attribute): Fix conditional.
@
text
@a1376 1
  LONG ret;
d1378 8
a1385 1
  if (object_type == SE_REGISTRY_KEY)
d1387 1
a1387 9
      /* use different code for registry handles, for performance reasons */
      DWORD len = 0;
      if ((ret = RegGetKeySecurity ((HKEY) handle,
				    DACL_SECURITY_INFORMATION
				    | GROUP_SECURITY_INFORMATION
				    | OWNER_SECURITY_INFORMATION,
				    sd, &len)) != ERROR_INSUFFICIENT_BUFFER)
	__seterrno_from_win_error (ret);
      else if (!sd.malloc (len))
a1388 6
      else if ((ret = RegGetKeySecurity ((HKEY) handle,
					 DACL_SECURITY_INFORMATION
					 | GROUP_SECURITY_INFORMATION
					 | OWNER_SECURITY_INFORMATION,
					 sd, &len)) != ERROR_SUCCESS)
	__seterrno_from_win_error (ret);
d1390 5
a1394 2
        psd = sd;
      get_info_from_sd (psd, attribute, uidret, gidret);
d1396 1
a1396 5
  else if ((ret = GetSecurityInfo (handle, object_type,
				   DACL_SECURITY_INFORMATION
				   | GROUP_SECURITY_INFORMATION
				   | OWNER_SECURITY_INFORMATION,
				   NULL, NULL, NULL, NULL, &psd)))
d1398 3
a1400 2
      __seterrno_from_win_error (ret);
      return -1;
d1403 3
a1405 4
    {
      get_info_from_sd (psd, attribute, uidret, gidret);
      LocalFree (psd);
    }
@


1.162
log
@	* fhandler.cc (fhandler_base::open): Set query access mode according
	to query_open setting.
	(fhandler_base::fhandler_base): Initialize query_open.
	* fhandler.h (FH_QUERYOPEN): Drop.
	(enum query_state): Add.
	(class fhandler_base): Add query_open member.
	(fhandler_base::get_query_open): Redefine to use query_open.
	(fhandler_base::set_query_open): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Remove O_DIROPEN
	from open_flags since it's added in open_fs anyway.  Remove
	query_open_already.  Use new query_open settings.  Rearrange slightly.
	(fhandler_base::fstat_helper): Add get_io_handle as parameter to
	get_file_attribute.
	* security.cc (get_nt_object_attribute): Make returning an int.
	Return -1 on error, 0 otherwise.
	(get_file_attribute): Take an object handle as argument. Move down
	to allow calling get_nt_object_attribute in case a non-NULL handle
	is given.
	* security.h (get_file_attribute): Add handle to argument list.
	* syscalls.cc (chown_worker): Accomodate new definition of
	get_file_attribute.
@
text
@d1440 2
a1441 2
      if (handle && get_nt_object_attribute (handle, SE_FILE_OBJECT,
					     attribute, uidret, gidret))
@


1.161
log
@	* security.cc (get_nt_object_attribute): Fix error handling.
@
text
@d1370 1
a1370 34
int
get_file_attribute (int use_ntsec, const char *file,
		    mode_t *attribute, __uid32_t *uidret, __gid32_t *gidret)
{
  int res;
  syscall_printf ("file: %s", file);

  if (use_ntsec && allow_ntsec && wincap.has_security ())
    {
      get_nt_attribute (file, attribute, uidret, gidret);
      return 0;
    }

  if (uidret)
    *uidret = myself->uid;
  if (gidret)
    *gidret = myself->gid;

  if (!attribute)
    return 0;

  if (allow_ntea)
    {
      int oatt = *attribute;
      res = NTReadEA (file, ".UNIXATTR", (char *)attribute, sizeof (*attribute));
      *attribute |= oatt;
    }
  else
    res = 0;

  return res > 0 ? 0 : -1;
}

static void
d1406 4
a1409 1
    __seterrno_from_win_error (ret);
d1415 1
d1429 35
@


1.160
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d1410 1
d1416 7
a1422 10
      if (RegGetKeySecurity ((HKEY) handle,
			     DACL_SECURITY_INFORMATION
			     | GROUP_SECURITY_INFORMATION
			     | OWNER_SECURITY_INFORMATION,
			     sd, &len) != ERROR_INSUFFICIENT_BUFFER)
	{
	  __seterrno ();
	  debug_printf ("RegGetKeySecurity %E");
	}
      if (!sd.malloc (len))
d1424 16
a1439 11
      else if (RegGetKeySecurity ((HKEY) handle,
				  DACL_SECURITY_INFORMATION
				  | GROUP_SECURITY_INFORMATION
				  | OWNER_SECURITY_INFORMATION,
				  sd, &len) != ERROR_SUCCESS)
	{
	  __seterrno ();
	  debug_printf ("RegGetKeySecurity %E");
	}
	get_info_from_sd (sd, attribute, uidret, gidret);
      }
a1441 10
      if (ERROR_SUCCESS != GetSecurityInfo (handle, object_type,
					    DACL_SECURITY_INFORMATION |
					    GROUP_SECURITY_INFORMATION |
					    OWNER_SECURITY_INFORMATION,
					    NULL, NULL, NULL, NULL, &psd))
	{
	  __seterrno ();
	  debug_printf ("GetSecurityInfo %E");
	  psd = NULL;
	}
d1443 1
a1443 2
      if (psd)
	LocalFree (psd);
@


1.159
log
@	* security.h (SID): New macro.
	(well_known_*_sid): Change type to cygpsid.
	(cygsid::init): Delete declaration.
	* sec_helper.cc (well_known_*_sid): Define using above SID macro.
	(cygsid::init): Delete.
	* dcrt0.cc (dll_crt0_0): Do not call cygsid::init.
	* security.cc (get_user_local_groups): Change the second argument type
	to cygpsid.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.158
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d428 1
a428 1
sid_in_token_groups (PTOKEN_GROUPS grps, cygsid &sid)
@


1.157
log
@	Substitute 0x7fffffff and 0xffffffff by INT32_MAX and UINT32_MAX
	throughout, except in assembler code.
@
text
@d264 1
a264 1
BOOL
d279 1
a279 1
      return TRUE;
d291 1
a291 1
      return TRUE;
d294 1
a294 1
  return FALSE;
d297 1
a297 1
static BOOL
d341 1
a341 1
  return TRUE;
d344 1
a344 1
static BOOL
d350 1
a350 1
  BOOL retval = FALSE;
d356 1
a356 1
    return FALSE;
d360 1
a360 1
      retval = TRUE;
d364 1
a364 1
	  retval = TRUE;
d370 1
a370 1
static BOOL
d382 1
a382 1
      return FALSE;
d395 1
a395 1
      return FALSE;
d424 1
a424 1
  return TRUE;
d427 1
a427 1
static BOOL
d431 1
a431 1
    return FALSE;
d434 2
a435 2
      return TRUE;
  return FALSE;
d532 1
a532 1
static BOOL
d536 1
a536 1
			BOOL &special_pgrp)
d559 1
a559 1
	return FALSE;
d564 1
a564 1
  return TRUE;
d707 2
a708 2
BOOL
verify_token (HANDLE token, cygsid &usersid, user_groups &groups, BOOL *pintern)
d711 1
a711 1
  BOOL intern = FALSE;
d728 1
a728 1
    return FALSE;
d808 1
a808 1
  BOOL special_pgrp = FALSE;
d1207 1
a1207 1
			PSID group_sid, BOOL grp_member)
d1328 1
a1328 1
  BOOL grp_member = get_sids_info (owner_sid, group_sid, &uid, &gid);
d1468 1
a1468 1
BOOL
d1475 1
a1475 1
      return FALSE;
d1481 1
a1481 1
  return TRUE;
d1484 1
a1484 1
BOOL
d1491 1
a1491 1
      return FALSE;
d1497 1
a1497 1
  return TRUE;
d1643 1
a1643 1
  BOOL isownergroup;
@


1.156
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@d811 1
a811 1
  LARGE_INTEGER exp = { QuadPart:0x7fffffffffffffffLL };
@


1.155
log
@	* sec_acl.h (getace): Use FILE_*_BITS as permission mask.
	* security.cc (get_attribute_from_acl): Ditto.
	* security.h (FILE_READ_BITS): Define to match also GENERIC bits.
	(FILE_WRITE_BITS): Ditto.
	(FILE_EXEC_BITS): Ditto.
@
text
@d1070 3
d1076 1
a1076 1
read_sd (const char *file, PSECURITY_DESCRIPTOR sd_buf, LPDWORD sd_size)
a1077 8
  /* Check parameters */
  if (!sd_size)
    {
      set_errno (EINVAL);
      return -1;
    }

  debug_printf ("file = %s", file);
d1081 1
a1081 1
  char fbuf[PATH_MAX];
d1094 2
a1095 1
			sd_buf, *sd_size, &len))
d1097 1
d1102 1
a1102 1
  if (len > *sd_size)
d1104 11
a1114 2
      *sd_size = len;
      return 0;
d1116 1
a1116 1
  return 1;
d1120 1
a1120 1
write_sd (const char *file, PSECURITY_DESCRIPTOR sd_buf, DWORD sd_size)
a1121 7
  /* Check parameters */
  if (!sd_buf || !sd_size)
    {
      set_errno (EINVAL);
      return -1;
    }

d1125 1
a1125 1
  if (!GetSecurityDescriptorOwner (sd_buf, (PSID *) &owner, &dummy))
d1170 1
a1170 1
  header.Size.LowPart = sd_size;
d1182 1
a1182 1
  if (!BackupWrite (fh, (LPBYTE) sd_buf,
d1363 1
a1363 10
  /* Yeah, sounds too much, but I've seen SDs of 2100 bytes! */
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;

  if (read_sd (file, psd, &sd_size) <= 0)
    {
      debug_printf ("read_sd %E");
      psd = NULL;
    }
d1365 3
a1367 2
  get_info_from_sd (psd, attribute, uidret, gidret);
  return;
d1405 2
a1406 1
			 mode_t *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1408 2
a1409 2
  PSECURITY_DESCRIPTOR psd;
  char sd_buf[4096];
d1414 17
a1430 7
      psd = (PSECURITY_DESCRIPTOR) & sd_buf[0];
      DWORD len = sizeof (sd_buf);
      if (ERROR_SUCCESS != RegGetKeySecurity ((HKEY) handle,
					      DACL_SECURITY_INFORMATION |
					      GROUP_SECURITY_INFORMATION |
					      OWNER_SECURITY_INFORMATION,
					      psd, &len))
a1433 1
	  psd = NULL;
d1435 1
d1449 3
a1452 6

  get_info_from_sd (psd, attribute, uidret, gidret);
  if (psd != (PSECURITY_DESCRIPTOR) & sd_buf[0])
    LocalFree (psd);

  return;
d1500 1
a1500 1
PSECURITY_DESCRIPTOR
d1502 1
a1502 1
	  PSECURITY_DESCRIPTOR sd_ret, DWORD *sd_size_ret)
a1506 5
  if (!sd_ret || !sd_size_ret)
    {
      set_errno (EINVAL);
      return NULL;
    }
d1785 3
a1787 3
  *sd_size_ret = 0;
  MakeSelfRelativeSD (&sd, sd_ret, sd_size_ret);
  if (*sd_size_ret <= 0)
d1792 6
a1797 1
  if (!MakeSelfRelativeSD (&sd, sd_ret, sd_size_ret))
d1802 1
a1802 1
  debug_printf ("Created SD-Size: %d", *sd_size_ret);
d1809 1
a1809 1
			void *sd_buf, DWORD sd_buf_size)
d1811 2
a1812 2
  psa->lpSecurityDescriptor = sd_buf;
  InitializeSecurityDescriptor ((PSECURITY_DESCRIPTOR) sd_buf,
d1814 2
a1815 3
  psa->lpSecurityDescriptor = alloc_sd (geteuid32 (), getegid32 (), attribute,
					(PSECURITY_DESCRIPTOR) sd_buf,
					&sd_buf_size);
d1825 1
a1825 3
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;
d1828 1
a1828 1
  if ((ret = read_sd (file, psd, &sd_size)) <= 0)
d1834 1
a1834 2
  sd_size = 4096;
  if (!(psd = alloc_sd (uid, gid, attribute, psd, &sd_size)))
d1837 1
a1837 1
  return write_sd (file, psd, sd_size);
d1870 3
a1872 3
  char sd_buf[4096];
  DWORD sd_size = sizeof sd_buf;
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;
d1881 1
a1881 1
  if (read_sd (fn, psd, &sd_size) <= 0)
d1904 1
a1904 1
  if (!AccessCheck (psd, hIToken, desired, &mapping,
@


1.154
log
@2003-10-16  Pierre Humblet  <pierre.humblet@@ieee.org>

	* syscalls.cc (seteuid32): Always construct a default DACL including
	the new sid, Admins and SYSTEM and copy it to the new thread token.
	* security.cc (create_token): Use a NULL default DACL in NtCreateToken.
@
text
@d1238 1
a1238 1
	  if (ace->Mask & FILE_READ_DATA)
d1242 1
a1242 1
	  if (ace->Mask & FILE_WRITE_DATA)
d1246 1
a1246 1
	  if (ace->Mask & FILE_EXECUTE)
d1267 1
a1267 1
	  if (ace->Mask & FILE_READ_DATA)
d1269 1
a1269 1
	  if (ace->Mask & FILE_WRITE_DATA)
d1271 1
a1271 1
	  if (ace->Mask & FILE_EXECUTE)
d1276 1
a1276 1
	  if (ace->Mask & FILE_READ_DATA)
d1279 1
a1279 1
	  if (ace->Mask & FILE_WRITE_DATA)
d1282 1
a1282 1
	  if (ace->Mask & FILE_EXECUTE)
@


1.153
log
@* include/tzfile.h: Add some missing entries.
@
text
@d818 1
a818 2
  char acl_buf[MAX_DACL_LEN (5)];
  TOKEN_DEFAULT_DACL dacl;
a905 7

  /* Create default dacl. */
  if (!sec_acl ((PACL) acl_buf, false, false,
		tmp_gsids.contains (well_known_admins_sid) ?
		well_known_admins_sid : usersid))
    goto out;
  dacl.DefaultDacl = (PACL) acl_buf;
@


1.152
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d1748 1
a1748 1
  if (S_ISDIR (attribute) && !acl_exists )
@


1.151
log
@2003-09-15  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h (__sec_user): Add "access2" argument.
	(sec_acl): Add "original" and "access2" arguments.
	(sec_user): Add "sid2" and "access2" argument. Remove dependence on
	allow_ntsec.
	(sec_user_nih): Ditto.
	* sec_helper.cc (__sec_user): Add "has_security" test.
	Call sec_acl with new arguments, letting it handle original_sid.
	(sec_acl): Add "original" and "access2" arguments. Handle original_sid
	depending on flag but avoiding duplicates. Use "access2" for sid2.
	* pinfo.cc (pinfo::init): Use security attributes created by sec_user
	when creating the mapping.
	* security.cc (create_token): Adjust arguments in call to sec_acl.
	Call sec_user instead of __sec_user.
	* syscall.cc (seteuid32):  Adjust arguments in call to sec_acl. Remove
	now unnecessary test. Remove useless conversions to psid.
	* dcrt0.cc (dll_crt0_1): Call cygsid::init before pinfo_init.
@
text
@d33 1
a34 1
#include "path.h"
@


1.150
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d909 1
a909 1
  if (!sec_acl ((PACL) acl_buf, FALSE,
d929 1
a929 1
      psa = __sec_user (sa_buf, usersid, TRUE);
@


1.149
log
@2003-07-18  Pierre Humblet  <pierre.humblet@@ieee.org>

        * security.cc (verify_token): Fix white space and style.
        Use type bool instead of BOOL and char. Use alloca
        instead of malloc and free for my_grps.
@
text
@d760 1
a760 1
          || groups.pgsid == usersid;
d1433 9
a1441 9
                                              DACL_SECURITY_INFORMATION |
                                              GROUP_SECURITY_INFORMATION |
                                              OWNER_SECURITY_INFORMATION,
                                              psd, &len))
        {
          __seterrno ();
          debug_printf ("RegGetKeySecurity %E");
          psd = NULL;
        }
d1450 1
a1450 1
        {
@


1.148
log
@	* cygheap.h (class cygheap_user): Use INVALID_HANDLE_VALUE as invalid
	value for tokens.
	* syscalls.cc (seteuid32): Ditto.  Set new_token to process token if
	process token is suitable.
	* uinfo.cc (uinfo_init): Initialize tokens in cygheap user info
	to INVALID_HANDLE_VALUE.

	* cygheap.h (enum impersonation): Delete.
	(cygheap_user::impersonation_state): Delete.
	(cygheap_user::current_token): New.
	(cygheap_user::issetuid): Modify to use current_token.
	(cygheap_user::token): Ditto.
	(cygheap_user::deimpersonate): Ditto.
	(cygheap_user::reimpersonate): Ditto.
	(cygheap_user::has_impersonation_tokens): Ditto.
	(cygheap_user::close_impersonation_tokens): Ditto.
	* security.cc (cygwin_set_impersonation_token): Always set the token.
	(verify_token): Change type of gsid to cygpsid.
	(get_file_attribute): Use the effective ids.
	* syscalls.cc (seteuid32): Modify to use cygheap_user::current_token.
	* uinfo.cc (uinfo_init) Do not set cygheap->user.impersonation_state.
@
text
@d747 3
a749 4
  PTOKEN_GROUPS my_grps = NULL;
  BOOL ret = FALSE;
  char saw_buf[NGROUPS_MAX] = {};
  char *saw = saw_buf, sawpg = FALSE;
d754 2
a755 2
  else if (!(my_grps = (PTOKEN_GROUPS) malloc (size)))
    debug_printf ("malloc (my_grps) failed.");
d759 2
a760 5
    {
      ret = sid_in_token_groups (my_grps, groups.pgsid);
      if (ret == FALSE)
	ret = (groups.pgsid == tok_usersid);
    }
d765 2
a766 2
      if (groups.sgsids.count > (int) sizeof (saw_buf) &&
	  !(saw = (char *) calloc (groups.sgsids.count, sizeof (char))))
d775 1
a775 1
	      saw[pos] = TRUE;
d777 3
a779 3
	      sawpg = TRUE;
	   else if (gsid != well_known_world_sid &&
		    gsid != usersid)
d785 3
a787 4
      if (sawpg ||
	  groups.sgsids.contains (groups.pgsid) ||
	  groups.pgsid == usersid)
	ret = TRUE;
a789 2
  if (my_grps)
    free (my_grps);
@


1.147
log
@* Makefile.in: Remove cygserver stuff.
* acconfig.h: Add USE_CYGSERVER define.
* config.h.in: Regenerate.
* configure.in: Add --enable-server setting.
* configure: Regenerate.
* fhandler_tty.cc (fhandler_tty_slave::open): Conditionalize compilation of
cygserver stuff.
* fork.cc (fork_child): Ditto.
* shm.cc: Ditto.
* tty.cc (tty::common_init): Ditto.
* dcrt0.cc: Use bool rather than BOOL for CYGWIN environment variable
definitions.
* environ.cc: Ditto.
* ntea.cc: Ditto.
* security.cc: Ditto.
* security.h: Ditto.
* syscalls.cc (check_posix_perm): Remove externs that were already declared in
a header.
* winsup.h: Ditto.  Declare _MT_SAFE here.  Delete it someday since cygwin
should always be _MT_SAFE.
@
text
@d72 2
a73 11
  if (cygheap->user.impersonation_state == IMP_EXTERNAL
      && cygheap->user.external_token != hToken)
    {
      set_errno (EPERM);
      return;
    }
  else
    {
      cygheap->user.external_token = hToken;
      return;
    }
d735 1
a735 1
      PSID gsid = NO_SID;
d741 1
a741 1
					    &gsid, (BOOL *) &size))
d1408 1
a1408 1
    *uidret = getuid32 ();
d1410 1
a1410 1
    *gidret = getgid32 ();
@


1.146
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@d43 1
a43 2
extern BOOL allow_ntea;
BOOL allow_ntsec;
d47 1
a47 1
BOOL allow_smbntsec;
@


1.145
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d73 2
a74 1
  if (cygheap->user.token != hToken)
d76 7
a82 2
      cygheap->user.token = hToken;
      cygheap->user.impersonated = FALSE;
d726 1
a726 1
      if (!GetTokenInformation (cygheap->user.token, TokenSource,
d1915 1
a1915 1
    hToken = cygheap->user.token;
d1923 1
a1923 1
  if (hToken != cygheap->user.token)
@


1.144
log
@	* security.cc (get_info_from_sd): New function.
	(get_nt_attribute): Only call read_sd and get_info_from_sd.
	Return void.
	(get_file_attribute): Move sd error handling to get_info_from_sd.
	and symlink handling to fhandler_disk_file::fstat_helper.
	(get_nt_object_attribute): Only call read_sd and get_info_from_sd.
	Return void.
	(get_object_attribute): Remove symlink handling and simply return -1
	when ntsec is off.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): For
	symlinks set the attribute, call get_file_attribute to get the ids
	and return.  In the normal case call get_file_attribute with the
	addresses of the buffer ids and do not recheck if the file is a socket.
@
text
@a18 1
#include <errno.h>
@


1.143
log
@	* fhandler.cc (fhandler_base::fstat): Set the uid and gid fields
	from the current effective ids.
	* fhandler_socket.cc (fhandler_socket::fstat): Keep the uid and gid set
	by fhandler_base::fstat.
	* security.cc (get_nt_attribute): Do not test wincap.has_security ().
	(get_nt_object_attribute): Ditto.
	(get_file_attribute): Add test for wincap.has_security ().
	(get_object_attribute): Ditto.
@
text
@d1321 2
a1322 2
static int
get_nt_attribute (const char *file, mode_t *attribute,
d1325 1
a1325 9
  syscall_printf ("file: %s", file);

  /* Yeah, sounds too much, but I've seen SDs of 2100 bytes! */
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;

  int ret;
  if ((ret = read_sd (file, psd, &sd_size)) <= 0)
d1327 9
a1335 2
      debug_printf ("read_sd %E");
      return -1;
a1346 10
  PACL acl;
  BOOL acl_exists;

  if (!GetSecurityDescriptorDacl (psd, &acl_exists, &acl, &dummy))
    {
      __seterrno ();
      debug_printf ("GetSecurityDescriptorDacl %E");
      return -1;
    }

d1357 12
a1368 2
      syscall_printf ("file: %s uid %d, gid %d", file, uid, gid);
      return 0;
d1370 9
d1380 10
a1389 1
  if (!acl_exists || !acl)
d1391 2
a1392 4
      *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
      syscall_printf ("file: %s No ACL = %x, uid %d, gid %d",
		      file, *attribute, uid, gid);
      return 0;
a1393 1
  get_attribute_from_acl (attribute, acl, owner_sid, group_sid, grp_member);
d1395 2
a1396 2
  syscall_printf ("file: %s %x, uid %d, gid %d", file, *attribute, uid, gid);
  return 0;
d1404 1
d1408 1
a1408 13
      res = get_nt_attribute (file, attribute, uidret, gidret);
      if (res)
	{
	  /* If reading the security descriptor failed, treat the file
	     as unreadable. */
	  *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO);
	  if (uidret)
	    *uidret = ILLEGAL_UID;
	  if (gidret)
	    *gidret = ILLEGAL_GID;
	}
      else if (attribute && S_ISLNK (*attribute))
	*attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
a1428 4
  /* symlinks are everything for everyone! */
  if (S_ISLNK (*attribute))
    *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;

d1432 1
a1432 1
static int
d1436 2
a1437 4
  PSECURITY_DESCRIPTOR psd = NULL;
  cygpsid owner_sid;
  cygpsid group_sid;
  PACL acl = NULL;
d1441 2
a1442 3
      // use different code for registry handles, for performance reasons
      char sd_buf[4096];
      PSECURITY_DESCRIPTOR psd2 = (PSECURITY_DESCRIPTOR) & sd_buf[0];
d1448 1
a1448 1
                                              psd2, &len))
d1452 1
a1452 1
          return -1;
d1454 1
a1454 35

      BOOL bDaclPresent;
      BOOL bDaclDefaulted;
      if (!GetSecurityDescriptorDacl (psd2,
                                      &bDaclPresent, &acl, &bDaclDefaulted))
        {
          __seterrno ();
          debug_printf ("GetSecurityDescriptorDacl %E");
          return -1;
        }
      if (!bDaclPresent)
        {
          acl = NULL;
        }

      BOOL bGroupDefaulted;
      if (!GetSecurityDescriptorGroup (psd2,
                                       (PSID *) & group_sid,
                                       &bGroupDefaulted))
        {
          __seterrno ();
          debug_printf ("GetSecurityDescriptorGroup %E");
          return -1;
        }

      BOOL bOwnerDefaulted;
      if (!GetSecurityDescriptorOwner (psd2,
                                       (PSID *) & owner_sid,
                                       &bOwnerDefaulted))
        {
          __seterrno ();
          debug_printf ("GetSecurityDescriptorOwner %E");
          return -1;
        }
    }
d1458 9
a1466 35
                                            DACL_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION |
                                            OWNER_SECURITY_INFORMATION,
                                            (PSID *) & owner_sid,
                                            (PSID *) & group_sid,
                                            &acl, NULL, &psd))
        {
          __seterrno ();
          debug_printf ("GetSecurityInfo %E");
          return -1;
        }
    }

  __uid32_t uid;
  __gid32_t gid;
  BOOL grp_member = get_sids_info (owner_sid, group_sid, &uid, &gid);

  if (uidret)
    *uidret = uid;
  if (gidret)
    *gidret = gid;

  if (!attribute)
    {
      syscall_printf ("uid %d, gid %d", uid, gid);
      LocalFree (psd);
      return 0;
    }

  if (!acl)
    {
      *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
      syscall_printf ("No ACL = %x, uid %d, gid %d", *attribute, uid, gid);
      LocalFree (psd);
      return 0;
d1469 3
a1471 3
  get_attribute_from_acl (attribute, acl, owner_sid, group_sid, grp_member);

  LocalFree (psd);
d1473 1
a1473 2
  syscall_printf ("%x, uid %d, gid %d", *attribute, uid, gid);
  return 0;
d1482 2
a1483 5
      int res = get_nt_object_attribute (handle, object_type, attribute,
					 uidret, gidret);
      if (attribute && S_ISLNK (*attribute))
	*attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
      return res;
d1485 2
a1486 14

  if (uidret)
    *uidret = getuid32 ();
  if (gidret)
    *gidret = getgid32 ();

  if (!attribute)
    return 0;

  /* symlinks are everything for everyone! */
  if (S_ISLNK (*attribute))
    *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;

  return 0;
@


1.142
log
@	* autoload.cc: added RegGetKeySecurity()
	* security.cc (get_nt_object_attribute): use RegGetKeySecurity() for
	performance.
@
text
@a1324 3
  if (!wincap.has_security ())
    return 0;

d1391 1
a1391 1
  if (use_ntsec && allow_ntsec)
a1436 3
  if (!wincap.has_security ())
    return 0;

d1545 1
a1545 1
  if (allow_ntsec)
@


1.141
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Fix
	wrong usage of S_IFDIR.
	* security.cc (get_attribute_from_acl): Ditto.
	(get_file_attribute): Fix wrong usage of S_IFLNK.
	(get_object_attribute): Ditto.
	(alloc_sd): Fix wrong usage of S_IFDIR.
	* syscalls.cc (chmod): Allow chmod'ing of socket files.
@
text
@d1446 1
a1446 1
  PACL acl;
d1448 1
a1448 7
  if (ERROR_SUCCESS != GetSecurityInfo (handle, object_type,
					DACL_SECURITY_INFORMATION |
					GROUP_SECURITY_INFORMATION |
					OWNER_SECURITY_INFORMATION,
					(PSID *) &owner_sid,
					(PSID *) &group_sid,
					&acl, NULL, &psd))
d1450 63
a1512 3
      __seterrno ();
      debug_printf ("GetSecurityInfo %E");
      return -1;
@


1.140
log
@	* sec_acl.cc (setacl): Don't handle DELETE flag specially.
	* security.cc (alloc_sd): Ditto.
@
text
@d1270 1
a1270 1
	  if ((*attribute & S_IFDIR) &&
d1407 1
a1407 1
      else if (attribute && (*attribute & S_IFLNK) == S_IFLNK)
d1430 1
a1430 1
  if ((*attribute & S_IFLNK) == S_IFLNK)
d1501 1
a1501 1
      if (attribute && (*attribute & S_IFLNK) == S_IFLNK)
d1515 1
a1515 1
  if ((*attribute & S_IFLNK) == S_IFLNK)
d1655 2
a1656 2
  if ((attribute & (S_IFDIR | S_IWUSR | S_IXUSR))
      == (S_IFDIR | S_IWUSR | S_IXUSR))
d1668 3
a1670 2
  if ((attribute & (S_IFDIR | S_IWGRP | S_IXGRP))
      == (S_IFDIR | S_IWGRP | S_IXGRP) && !(attribute & S_ISVTX))
d1682 2
a1683 2
  if ((attribute & (S_IFDIR | S_IWOTH | S_IXOTH))
      == (S_IFDIR | S_IWOTH | S_IXOTH)
d1792 1
a1792 1
  if (attribute & S_IFDIR && !acl_exists )
@


1.139
log
@whitespace cleanup
@
text
@d1647 1
a1647 1
  DWORD owner_allow = (STANDARD_RIGHTS_ALL & ~DELETE)
d1652 1
a1652 1
    owner_allow |= FILE_GENERIC_WRITE | DELETE;
@


1.138
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@d99 1
a99 1
        strlcpy (user, u + 1, c - u);
@


1.137
log
@* include/cygwin/in.h (in_attr_t): Define new type.
* include/arpa/inet.h (inet_addr): Change return type to in_addr_t.
(inet_lnaof): Ditto.
(inet_netof): Ditto.
(inet_network): Ditto.
* include/cygwin/types.h: Move many *_t typedefs here.  Protect them with
ifdefs.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Change ntsec_atts to
mode_t.
* security.cc (get_attribute_from_acl): Accept mode_t attribute.
(get_nt_attribute): Ditto.
(get_file_attribute): Ditto.
(get_nt_object_attribute): Ditto.
(get_object_attribute): Ditto.
* security.h: Reflect above changes.
* syscalls.cc (chown_worker): Change attrib to mode_t.
@
text
@d1921 51
@


1.136
log
@	* sec_acl.cc (setacl): Move all permission settings to beginning of
	loop.  Set default rights to same values as in alloc_sd().  Set DELETE
	for owner and default owner only if S_IWOTH is given.

	* sec_acl.cc: Change all  __aclent16_t to  __aclent32_t except in
	wrapper function definitions. Replace call to the aclXYZ functions by
	calls aclXYZ32.
	(searchace): Change type of third argument to __uid32_t and use
	ILLEGAL_UID instead of -1;
	(setacl): Remove some initializations. Only give STANDARD_RIGHTS_WRITE
	for S_IWOTH. Replace -1 by ILLEGAL_UID.
	(getacl): Change type of owner_sid, group_sid and ace_sid to cygpsid.
	In last else clause, suppress second call to ace_sid.get_id and use
	TRUE in first call. Replace EqualSid by ==.
	(acl_access): Call internal_getgroups in USER and GROUP cases.
	(acecmp: Define static.
	(acl32): Create from 16 bit type.
	(facl32): Ditto.
	(lacl32): Ditto.
	(aclcheck32): Ditto.
	(aclsort32): Ditto.
	(acltomode32): Ditto.
	(aclfrommode32): Ditto.
	(acltopbits32): Ditto.
	(aclfrompbits32): Ditto.
	(acltotext32): Ditto.
	(aclfromtext32): Ditto, and use strechr.
	(acl16to32): Create.
	(acl): Make it a wrapper function.
	(facl): Ditto.
	(lacl): Ditto.
	(aclcheck): Ditto.
	(aclsort): Ditto.
	(acltomode): Ditto.
	(aclfrommode): Ditto.
	(acltopbits): Ditto.
	(aclfrompbits): Ditto.
	(acltotext): Ditto.
	(aclfromtext): Ditto.
	* security.cc (write_sd): Call set_process_privilege and check
	ownership.
	(alloc_sd): Remove call to set_process_privilege and the owner check.
@
text
@d1227 1
a1227 1
get_attribute_from_acl (int * attribute, PACL acl, PSID owner_sid,
d1322 1
a1322 1
get_nt_attribute (const char *file, int *attribute,
d1390 1
a1390 1
		    int *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1438 1
a1438 1
			 int *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1495 1
a1495 1
		      int *attribute, __uid32_t *uidret, __gid32_t *gidret)
@


1.135
log
@	* sec_helper.cc (get_sids_info): New function.
	* security.cc (extract_nt_dom_user): Simplify with strechr.
	(get_user_groups): Initialize glen to MAX_SID_LEN.
	(get_user_local_groups): Ditto.
	(get_attribute_from_acl): Define ace_sid as cygpsid.
	(get_nt_attribute): Define owner_sid and group_sid as cygpsid.
	Call get_sids_info instead of cygsid.get_{u,g}id and is_grp_member.
	(get_nt_object_attribute): Ditto.
	(alloc_sd): Define ace_sid as cygpsid.
@
text
@d1143 24
a1586 16

  /* Try turning privilege on, may not have WRITE_OWNER or WRITE_DAC access.
     Must have privilege to set different owner, else BackupWrite misbehaves */
  static int NO_COPY saved_res; /* 0: never, 1: failed, 2 & 3: OK */
  int res;
  if (!saved_res || cygheap->user.issetuid ())
    {
      res = 2 + set_process_privilege (SE_RESTORE_NAME, true,
				       cygheap->user.issetuid ());
      if (!cygheap->user.issetuid ())
	saved_res = res;
    }
  else
    res = saved_res;
  if (res == 1 && owner_sid != cygheap->user.sid ())
    return NULL;
@


1.134
log
@	* path.cc (symlink): Create security attributes so that only the
	user can modify the symlink.
	* security.cc (set_security_attribute): Remove symlink special
	handling.
@
text
@d93 2
a94 2
      c = strchr (d + 2, ',');
      if ((u = strchr (d + 2, '\\')) == NULL || (c != NULL && u > c))
a97 2
      if (c == NULL)
	c = u + UNLEN + 1;
d99 1
a99 1
	strlcpy (user, u + 1, c - u);
d330 1
a330 1
      DWORD glen = sizeof (gsid);
d408 1
a408 1
	DWORD glen = sizeof (gsid);
d1231 1
a1231 1
      cygsid ace_sid ((PSID) &ace->SidStart);
d1318 2
a1319 2
  PSID owner_sid;
  PSID group_sid;
d1322 1
a1322 1
  if (!GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
d1324 1
a1324 1
  if (!GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
d1337 3
a1339 2
  __uid32_t uid = cygsid (owner_sid).get_uid ();
  __gid32_t gid = cygsid (group_sid).get_gid ();
a1350 2
  BOOL grp_member = is_grp_member (uid, gid);

d1420 2
a1421 2
  PSID owner_sid;
  PSID group_sid;
d1428 2
a1429 1
					&owner_sid, &group_sid,
d1437 4
a1440 2
  __uid32_t uid = cygsid (owner_sid).get_uid ();
  __gid32_t gid = cygsid (group_sid).get_gid ();
a1452 2
  BOOL grp_member = is_grp_member (uid, gid);

d1750 2
a1751 1
	  cygsid ace_sid ((PSID) &ace->SidStart);
@


1.133
log
@	* security.h: Add third argument to set_process_privilege.
	* autoload.cc: Add OpenThreadToken.
	* sec_helper.cc (set_process_privilege): Add and use use_thread
	argument.
	* security.cc (alloc_sd): Modify call to set_process_privilege.
	Remember the result in each process. If failed and file owner is not
	the user, fail.
@
text
@a1855 4
  /* symlinks are anything for everyone! */
  if ((attribute & S_IFLNK) == S_IFLNK)
    attribute |= S_IRWXU | S_IRWXG | S_IRWXO;

@


1.132
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d1566 14
a1579 3
  /* Must have SE_RESTORE_NAME privilege to change owner */
  if (cur_owner_sid && owner_sid != cur_owner_sid
      && set_process_privilege (SE_RESTORE_NAME) < 0 )
@


1.131
log
@	* sec_acl.cc (search_ace): Use id == -1, instead of < 0, as wildcard.
	(setacl): Start the search for a matching default at the next entry.
	Invalidate the type of merged entries instead of clearing it.
	Use well_known_creator for default owner and owning group and do
	not try to merge non-default and default entries in these cases.
	(getacl): Recognize well_known_creator for default owner and group.
	(acl_worker): Improve errno settings and streamline the nontsec case.
	* security.cc (write_sd): Remove the call to set_process_privilege.
	(alloc_sd): If the owner changes, call set_process_privilege and return
	immediately on failure. Change inheritance rules: on new directories add
	inherit only allow ACEs for creator_owner, creator_group and everyone.
	Preserve all inheritances through chmod and chown calls. Introduce
	isownergroup to implement the uid == gid case, to keep the inheritance
	code simple. Do not initialize owner_sid and group_sid and stop using
	the variable psd.
@
text
@d1246 2
a1247 2
	              | ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
	              | ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
d1377 1
a1377 1
        {
@


1.131.2.1
log
@merge from trunk
@
text
@d1246 2
a1247 2
		      | ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
		      | ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
d1377 1
a1377 1
	{
@


1.131.2.2
log
@merge from trunk
@
text
@d93 2
a94 2
      c = strechr (d + 2, ',');
      if ((u = strechr (d + 2, '\\')) >= c)
d98 2
d101 1
a101 1
        strlcpy (user, u + 1, c - u);
d332 1
a332 1
      DWORD glen = MAX_SID_LEN;
d410 1
a410 1
	DWORD glen = MAX_SID_LEN;
d1233 1
a1233 1
      cygpsid ace_sid ((PSID) &ace->SidStart);
d1320 2
a1321 2
  cygpsid owner_sid;
  cygpsid group_sid;
d1324 1
a1324 1
  if (!GetSecurityDescriptorOwner (psd, (PSID *) &owner_sid, &dummy))
d1326 1
a1326 1
  if (!GetSecurityDescriptorGroup (psd, (PSID *) &group_sid, &dummy))
d1339 2
a1340 3
  __uid32_t uid;
  __gid32_t gid;
  BOOL grp_member = get_sids_info (owner_sid, group_sid, &uid, &gid);
d1352 2
d1423 2
a1424 2
  cygpsid owner_sid;
  cygpsid group_sid;
d1431 1
a1431 2
					(PSID *) &owner_sid,
					(PSID *) &group_sid,
d1439 2
a1440 4
  __uid32_t uid;
  __gid32_t gid;
  BOOL grp_member = get_sids_info (owner_sid, group_sid, &uid, &gid);

d1453 2
d1566 3
a1568 14
  /* Try turning privilege on, may not have WRITE_OWNER or WRITE_DAC access.
     Must have privilege to set different owner, else BackupWrite misbehaves */
  static int NO_COPY saved_res; /* 0: never, 1: failed, 2 & 3: OK */
  int res;
  if (!saved_res || cygheap->user.issetuid ())
    {
      res = 2 + set_process_privilege (SE_RESTORE_NAME, true,
				       cygheap->user.issetuid ());
      if (!cygheap->user.issetuid ())
	saved_res = res;
    }
  else
    res = saved_res;
  if (res == 1 && owner_sid != cygheap->user.sid ())
d1741 1
a1741 2
	  cygpsid ace_sid ((PSID) &ace->SidStart);

d1845 4
@


1.131.2.3
log
@merge from trunk
@
text
@a1142 24
  BOOL dummy;
  cygpsid owner;

  if (!GetSecurityDescriptorOwner (sd_buf, (PSID *) &owner, &dummy))
    {
      __seterrno ();
      return -1;
    }
  /* Try turning privilege on, may not have WRITE_OWNER or WRITE_DAC access.
     Must have privilege to set different owner, else BackupWrite misbehaves */
  static int NO_COPY saved_res; /* 0: never, 1: failed, 2 & 3: OK */
  int res;
  if (!saved_res || cygheap->user.issetuid ())
    {
      res = 2 + set_process_privilege (SE_RESTORE_NAME, true,
				       cygheap->user.issetuid ());
      if (!cygheap->user.issetuid ())
	saved_res = res;
    }
  else
    res = saved_res;
  if (res == 1 && owner != cygheap->user.sid ())
    return -1;

d1563 16
@


1.131.2.4
log
@merge from trunk
@
text
@d1227 1
a1227 1
get_attribute_from_acl (mode_t *attribute, PACL acl, PSID owner_sid,
d1322 1
a1322 1
get_nt_attribute (const char *file, mode_t *attribute,
d1390 1
a1390 1
		    mode_t *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1438 1
a1438 1
			 mode_t *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1495 1
a1495 1
		      mode_t *attribute, __uid32_t *uidret, __gid32_t *gidret)
@


1.131.2.5
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d34 1
a35 1
#include "fhandler.h"
@


1.131.2.6
log
@merge from trunk
@
text
@a1920 51

int
check_file_access (const char *fn, int flags)
{
  int ret = -1;
  char sd_buf[4096];
  DWORD sd_size = sizeof sd_buf;
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;
  HANDLE hToken, hIToken;
  BOOL status;
  char pbuf[sizeof (PRIVILEGE_SET) + 3 * sizeof (LUID_AND_ATTRIBUTES)];
  DWORD desired = 0, granted, plength = sizeof pbuf;
  static GENERIC_MAPPING NO_COPY mapping = { FILE_GENERIC_READ,
					     FILE_GENERIC_WRITE,
					     FILE_GENERIC_EXECUTE,
					     FILE_ALL_ACCESS };
  if (read_sd (fn, psd, &sd_size) <= 0)
    goto done;

  if (cygheap->user.issetuid ())
    hToken = cygheap->user.token;
  else if (!OpenProcessToken (hMainProc, TOKEN_DUPLICATE, &hToken))
    {
      __seterrno ();
      goto done;
    }
  if (!(status = DuplicateToken (hToken, SecurityIdentification, &hIToken)))
    __seterrno ();
  if (hToken != cygheap->user.token)
    CloseHandle (hToken);
  if (!status)
    goto done;

  if (flags & R_OK)
    desired |= FILE_READ_DATA;
  if (flags & W_OK)
    desired |= FILE_WRITE_DATA;
  if (flags & X_OK)
    desired |= FILE_EXECUTE;
  if (!AccessCheck (psd, hIToken, desired, &mapping,
		    (PPRIVILEGE_SET) pbuf, &plength, &granted, &status))
    __seterrno ();
  else if (!status)
    set_errno (EACCES);
  else
    ret = 0;
  CloseHandle (hIToken);
 done:
  debug_printf ("flags %x, ret %d", flags, ret);
  return ret;
}
@


1.131.2.7
log
@merge from trunk
@
text
@d99 1
a99 1
	strlcpy (user, u + 1, c - u);
@


1.131.2.8
log
@merge from trunk
@
text
@d1647 1
a1647 1
  DWORD owner_allow = STANDARD_RIGHTS_ALL
d1652 1
a1652 1
    owner_allow |= FILE_GENERIC_WRITE;
@


1.131.2.9
log
@merge from trunk
@
text
@d1270 1
a1270 1
	  if ((S_ISDIR (*attribute)) &&
d1407 1
a1407 1
      else if (attribute && S_ISLNK (*attribute))
d1430 1
a1430 1
  if (S_ISLNK (*attribute))
d1501 1
a1501 1
      if (attribute && S_ISLNK (*attribute))
d1515 1
a1515 1
  if (S_ISLNK (*attribute))
d1655 2
a1656 2
  if (S_ISDIR (attribute)
      && (attribute & (S_IWUSR | S_IXUSR)) == (S_IWUSR | S_IXUSR))
d1668 2
a1669 3
  if (S_ISDIR (attribute)
      && (attribute & (S_IWGRP | S_IXGRP)) == (S_IWGRP | S_IXGRP)
      && !(attribute & S_ISVTX))
d1681 2
a1682 2
  if (S_ISDIR (attribute)
      && (attribute & (S_IWOTH | S_IXOTH)) == (S_IWOTH | S_IXOTH)
d1791 1
a1791 1
  if (S_ISDIR (attribute) && !acl_exists )
@


1.131.2.10
log
@merge from trunk
@
text
@d1325 3
d1394 1
a1394 1
  if (use_ntsec && allow_ntsec && wincap.has_security ())
d1440 3
d1446 1
a1446 1
  PACL acl = NULL;
d1448 7
a1454 1
  if (object_type == SE_REGISTRY_KEY)
d1456 3
a1458 63
      // use different code for registry handles, for performance reasons
      char sd_buf[4096];
      PSECURITY_DESCRIPTOR psd2 = (PSECURITY_DESCRIPTOR) & sd_buf[0];
      DWORD len = sizeof (sd_buf);
      if (ERROR_SUCCESS != RegGetKeySecurity ((HKEY) handle,
                                              DACL_SECURITY_INFORMATION |
                                              GROUP_SECURITY_INFORMATION |
                                              OWNER_SECURITY_INFORMATION,
                                              psd2, &len))
        {
          __seterrno ();
          debug_printf ("RegGetKeySecurity %E");
          return -1;
        }

      BOOL bDaclPresent;
      BOOL bDaclDefaulted;
      if (!GetSecurityDescriptorDacl (psd2,
                                      &bDaclPresent, &acl, &bDaclDefaulted))
        {
          __seterrno ();
          debug_printf ("GetSecurityDescriptorDacl %E");
          return -1;
        }
      if (!bDaclPresent)
        {
          acl = NULL;
        }

      BOOL bGroupDefaulted;
      if (!GetSecurityDescriptorGroup (psd2,
                                       (PSID *) & group_sid,
                                       &bGroupDefaulted))
        {
          __seterrno ();
          debug_printf ("GetSecurityDescriptorGroup %E");
          return -1;
        }

      BOOL bOwnerDefaulted;
      if (!GetSecurityDescriptorOwner (psd2,
                                       (PSID *) & owner_sid,
                                       &bOwnerDefaulted))
        {
          __seterrno ();
          debug_printf ("GetSecurityDescriptorOwner %E");
          return -1;
        }
    }
  else
    {
      if (ERROR_SUCCESS != GetSecurityInfo (handle, object_type,
                                            DACL_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION |
                                            OWNER_SECURITY_INFORMATION,
                                            (PSID *) & owner_sid,
                                            (PSID *) & group_sid,
                                            &acl, NULL, &psd))
        {
          __seterrno ();
          debug_printf ("GetSecurityInfo %E");
          return -1;
        }
d1497 1
a1497 1
  if (allow_ntsec && wincap.has_security ())
@


1.131.2.11
log
@merge from trunk
@
text
@d1321 2
a1322 2
static void
get_info_from_sd (PSECURITY_DESCRIPTOR psd, mode_t *attribute,
d1325 9
a1333 1
  if (!psd)
d1335 2
a1336 9
      /* If reading the security descriptor failed, treat the object
	 as unreadable. */
      if (attribute)
	*attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO);
      if (uidret)
	*uidret = ILLEGAL_UID;
      if (gidret)
	*gidret = ILLEGAL_GID;
      return;
d1348 10
d1368 2
a1369 2
      syscall_printf ("uid %d, gid %d", uid, gid);
      return;
d1372 1
a1372 4
  PACL acl;
  BOOL acl_exists;

  if (!GetSecurityDescriptorDacl (psd, &acl_exists, &acl, &dummy))
d1374 4
a1377 3
      __seterrno ();
      debug_printf ("GetSecurityDescriptorDacl %E");
      *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO);
d1379 1
a1379 4
  else if (!acl_exists || !acl)
    *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
  else
    get_attribute_from_acl (attribute, acl, owner_sid, group_sid, grp_member);
d1381 2
a1382 22
  syscall_printf ("%sACL = %x, uid %d, gid %d",
		  (!acl_exists || !acl)?"NO ":"", *attribute, uid, gid);
  return;
}

static void
get_nt_attribute (const char *file, mode_t *attribute,
		  __uid32_t *uidret, __gid32_t *gidret)
{
  /* Yeah, sounds too much, but I've seen SDs of 2100 bytes! */
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;

  if (read_sd (file, psd, &sd_size) <= 0)
    {
      debug_printf ("read_sd %E");
      psd = NULL;
    }

  get_info_from_sd (psd, attribute, uidret, gidret);
  return;
a1389 1
  syscall_printf ("file: %s", file);
d1393 13
a1405 1
      get_nt_attribute (file, attribute, uidret, gidret);
d1426 4
d1433 1
a1433 1
static void
d1437 4
a1440 2
  PSECURITY_DESCRIPTOR psd;
  char sd_buf[4096];
d1444 3
a1446 2
      /* use different code for registry handles, for performance reasons */
      psd = (PSECURITY_DESCRIPTOR) & sd_buf[0];
d1452 1
a1452 1
                                              psd, &len))
d1456 1
a1456 1
          psd = NULL;
d1458 35
a1492 1
      }
d1496 35
a1530 9
					    DACL_SECURITY_INFORMATION |
					    GROUP_SECURITY_INFORMATION |
					    OWNER_SECURITY_INFORMATION,
					    NULL, NULL, NULL, NULL, &psd))
        {
	  __seterrno ();
	  debug_printf ("GetSecurityInfo %E");
	  psd = NULL;
	}
d1533 3
a1535 3
  get_info_from_sd (psd, attribute, uidret, gidret);
  if (psd != (PSECURITY_DESCRIPTOR) & sd_buf[0])
    LocalFree (psd);
d1537 2
a1538 1
  return;
d1547 5
a1551 2
      get_nt_object_attribute (handle, object_type, attribute, uidret, gidret);
      return 0;
d1553 14
a1566 2
  /* The entries are already set to default values */
  return -1;
@


1.131.2.12
log
@merge from trunk
@
text
@d19 1
d44 2
a45 1
bool allow_ntsec;
d49 1
a49 1
bool allow_smbntsec;
d74 1
a74 2
  if (cygheap->user.impersonation_state == IMP_EXTERNAL
      && cygheap->user.external_token != hToken)
d76 2
a77 7
      set_errno (EPERM);
      return;
    }
  else
    {
      cygheap->user.external_token = hToken;
      return;
d721 1
a721 1
      if (!GetTokenInformation (token, TokenSource,
d1910 1
a1910 1
    hToken = cygheap->user.token ();
d1918 1
a1918 1
  if (!cygheap->user.issetuid ())
@


1.131.2.13
log
@merge from trunk
@
text
@d72 11
a82 2
  cygheap->user.external_token = hToken;
  return;
d744 1
a744 1
      cygpsid gsid (NO_SID);
d750 1
a750 1
					    (PSID *) &gsid, (BOOL *) &size))
d756 4
a759 3
  PTOKEN_GROUPS my_grps;
  bool saw_buf[NGROUPS_MAX] = {};
  bool *saw = saw_buf, sawpg = false, ret = false;
d764 2
a765 2
  else if (!(my_grps = (PTOKEN_GROUPS) alloca (size)))
    debug_printf ("alloca (my_grps) failed.");
d769 5
a773 2
    ret = sid_in_token_groups (my_grps, groups.pgsid)
	  || groups.pgsid == usersid;
d778 2
a779 2
      if (groups.sgsids.count > (int) (sizeof (saw_buf) / sizeof (*saw_buf))
	  && !(saw = (bool *) calloc (groups.sgsids.count, sizeof (bool))))
d788 1
a788 1
	      saw[pos] = true;
d790 3
a792 3
	      sawpg = true;
	    else if (gsid != well_known_world_sid
		     && gsid != usersid)
d798 4
a801 3
      ret = sawpg
	    || groups.sgsids.contains (groups.pgsid)
	    || groups.pgsid == usersid;
d804 2
d1417 1
a1417 1
    *uidret = myself->uid;
d1419 1
a1419 1
    *gidret = myself->gid;
d1449 9
a1457 9
					      DACL_SECURITY_INFORMATION |
					      GROUP_SECURITY_INFORMATION |
					      OWNER_SECURITY_INFORMATION,
					      psd, &len))
	{
	  __seterrno ();
	  debug_printf ("RegGetKeySecurity %E");
	  psd = NULL;
	}
d1466 1
a1466 1
	{
@


1.130
log
@	* security.cc (get_nt_attribute): Always return -1 when read_sd()
	fails.
	(get_file_attribute): Set permissions to 0 and owner/group to -1
	if security descriptor is unreadable.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a1144 8
  /* No need to be thread save. */
  static BOOL first_time = TRUE;
  if (first_time)
    {
      set_process_privilege (SE_RESTORE_NAME);
      first_time = FALSE;
    }

d1553 1
a1553 1
  cygsid owner_sid (NO_SID);
d1566 5
d1572 1
a1572 1
  cygsid group_sid (NO_SID);
a1586 1
  PSECURITY_DESCRIPTOR psd = NULL;
d1683 4
a1686 12
  DWORD group_deny;
  if (owner_sid == group_sid)
    {
      owner_allow |= group_allow;
      group_allow = group_deny = 0L;
    }
  else
    {
      group_deny = ~group_allow & other_allow;
      group_deny &= ~(STANDARD_RIGHTS_READ
		      | FILE_READ_ATTRIBUTES | FILE_READ_EA);
    }
d1692 3
a1694 3
  /* Construct appropriate inherit attribute. */
  DWORD inherit = (attribute & S_IFDIR) ? SUB_CONTAINERS_AND_OBJECTS_INHERIT
					: NO_INHERITANCE;
d1699 1
a1699 1
				 owner_sid, acl_len, inherit))
d1703 4
a1706 7
  if (group_deny && !(owner_allow & group_deny))
    {
      if (!add_access_denied_ace (acl, ace_off++, group_deny,
				 group_sid, acl_len, inherit))
	return NULL;
      group_deny = 0;
    }
d1709 1
a1709 1
			       owner_sid, acl_len, inherit))
d1712 1
a1712 1
  if (group_deny
d1714 1
a1714 1
				 group_sid, acl_len, inherit))
d1717 1
a1717 1
  if (group_allow
d1719 1
a1719 1
				  group_sid, acl_len, inherit))
d1724 1
a1724 1
			       well_known_world_sid, acl_len, inherit))
d1734 1
a1734 1
  BOOL acl_exists;
d1743 2
d1749 7
a1755 3
	      || (ace_sid == well_known_world_sid)
	      || (ace_sid == well_known_null_sid))
	    continue;
d1759 1
d1762 1
a1762 1
		       ace->Header.AceType == ACCESS_DENIED_ACE_TYPE ?
d1772 40
a1835 1
  psd = sd_ret;
d1838 1
a1838 1
  return psd;
@


1.129
log
@	* security.cc (get_user_local_groups): Use LookupAccountSid to find the
	local equivalent of BUILTIN.
@
text
@d1325 1
a1325 1
      return ret;
d1384 11
a1394 1
      if (attribute && (*attribute & S_IFLNK) == S_IFLNK)
d1396 1
a1396 1
      return res;
@


1.128
log
@2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* pwdgrp.h (pwdgrp_check::pwdgrp_state): Replace by
	pwdgrp_check::isinitializing ().
	(pwdgrp_check::isinitializing): Create.
	* passwd.cc (grab_int): Change type to unsigned, use strtoul and
	set the pointer content to 0 if the field is invalid.
	(parse_pwd): Move validity test after getting pw_gid.
	(read_etc_passwd): Replace "passwd_state <= " by
	passwd_state::isinitializing ().
	(internal_getpwuid): Ditto.
	(internal_getpwnam): Ditto.
	(getpwent): Ditto.
	(getpass): Ditto.
	* grp.cc (parse_grp): Use strtoul for gr_gid and verify the validity.
	(read_etc_group): Replace "group_state <= " by
	group_state::isinitializing ().
	(internal_getgrgid): Ditto.
	(getgrent32): Ditto.
	(internal_getgrent): Ditto.

2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h: Move declarations of internal_getgrent,
	internal_getpwsid and internal_getgrsid to pwdgrp.h.
	* pwdgrp.h: Declare internal_getpwsid, internal_getpwnam,
	internal_getpwuid, internal_getgrsid, internal_getgrgid,
	internal_getgrnam, internal_getgrent and internal_getgroups.
	Delete "emulated" from enum pwdgrp_state.
	(pwdgrp_check::isuninitialized): Create.
	(pwdgrp_check::pwdgrp_state): Change state to initializing
	rather than to uninitialized.
	(pwdgrp_read::gets): Remove trailing CRs.
	* passwd.cc (grab_string): Don't look for NLs.
	(grab_int): Ditto.
	(parse_pwd): Don't look for CRs. Return 0 if entry is too short.
	(search_for): Delete.
	(read_etc_passwd): Simplify tests to actually read the file.
	Set state to loaded before making internal_getpwXX calls.
	Replace search_for calls by equivalent internal_pwgetXX calls.
	(internal_getpwsid): Use passwd_state.isuninitialized to decide
	to call read_etc_passwd.
	(internal_getpwuid): Create.
	(internal_getpwnam): Create.
	(getpwuid32): Simply call internal_getpwuid.
	(getpwuid_r32): Call internal_getpwuid.
	(getpwnam): Simply call internal_getpwnam.
	(getpwnam_r): Call internal_getpwnam.
	* grp.cc (parse_grp): Don't look for CRs. Adjust blank space.
	(add_grp_line): Adjust blank space.
	(class group_lock): Ditto.
	(read_etc_group): Simplify tests to actually read the file.
	Set state to loaded before making internal_getgrXX calls.
	Replace getgrXX calls by equivalent internal calls.
	(internal_getgrsid): Use group_state.isuninitialized to decide
	to call read_etc_group.
	(internal_getgrgid): Create.
	(internal_getgrnam): Create.
	(getgroups32): Simply call internal_getgrgid.
	(getgrnam32): Simply call internal_getgrnam.
	(internal_getgrent): Call group_state.isuninitialized.
	(internal_getgroups): Create from the former getgroups32, using
	two of the four arguments. Set gid to myself->gid and username
	to cygheap->user.name ().
	(getgroups32): Simply call internal_getgroup.
	(getgroups): Call internal_getgroup instead of getgroups32.
	(setgroups32): Call internal versions of get{pw,gr}XX.
	* sec_helper.cc: Include pwdgrp.h.
	(is_grp_member): Call internal versions of get{pw,gr}XX.
	* security.cc: Include pwdgrp.h.
	(alloc_sd): Call internal versions of get{pw,gr}XX.
	* syscalls.cc: Include pwdgrp.h.
	(seteuid32): Call internal versions of get{pw,gr}XX.
	(setegid32): Ditto.
	* uinfo.cc: Include pwdgrp.h.
	(internal_getlogin): Call internal versions of get{pw,gr}XX.
	(cygheap_user::ontherange): Ditto.
	* sec_acl.cc: Include pwdgrp.h.
	(setacl): Call internal versions of get{pw,gr}XX.
	(acl_access): Ditto and simplify logic.
	(aclfromtext): Ditto.
@
text
@d392 1
a392 1
  char bgroup[sizeof ("BUILTIN\\") + GNLEN] = "BUILTIN\\";
d394 6
a399 3
  const DWORD blen = sizeof ("BUILTIN\\") - 1;
  DWORD llen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  if (!GetComputerNameA (lgroup, &llen))
d404 1
a404 1
  lgroup[llen++] = '\\';
a412 1
	SID_NAME_USE use = SidTypeInvalid;
d414 1
@


1.127
log
@	* security.cc (get_attribute_from_acl): Always test "anti",
	just in case an access_denied ACE follows an access_allowed.
	Handle the case owner_sid == group_sid, with a FIXME.
	Remove unnecessary tests for non-NULL PSIDs.
	(alloc_sd): Use existing owner and group sids if {ug}id == -1.
	Handle case where owner_sid == group_sid.
	Do not call is_grp_member. Try to preserve canonical ACE order.
	Remove unnecessary tests for non-NULL PSIDs. Reorganize
	debug_printf's.
	(get_initgroups_sidlist): Put well_known_system_sid on left
	side of ==.
	(add_access_denied_ace): Only call GetAce if inherit != 0.
	(add_access_allowed_ace): Ditto. Use appropriate sizeof.
	* syscalls.cc (chown_worker): Pass {ug}id equal to -1 to
	alloc_sd, which removes the need to obtain old_{ug}id.
	(chmod): Remove call to get_file_attribute (), simply pass
	{ug}id equal to -1 to alloc_sd.
@
text
@d42 1
d1554 1
a1554 1
  else if (!owner_sid.getfrompw (getpwuid32 (uid)))
d1568 1
a1568 1
  else if (!group_sid.getfromgr (getgrgid32 (gid)))
@


1.126
log
@* sec_helper.cc (cygsid::get_id): If the sid matches a sid stored in
cygheap->user, return the uid or gid from myself.
* security.cc (alloc_sd): If gid == myself->gid, return the group sid from
cygheap->user.  Remove the test for uid == original_uid, which is
counter-productive.
@
text
@d452 1
a452 1
  if (pusersid == well_known_system_sid)
d543 1
a543 1
  if (usersid == well_known_system_sid)
d1241 1
a1241 1
	    *flags |= S_IROTH
d1245 1
a1245 1
	    *flags |= S_IWOTH
d1249 3
a1251 5
	    {
	      *flags |= S_IXOTH
			| ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
			| ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
	    }
d1267 1
a1267 1
      else if (owner_sid && ace_sid == owner_sid)
d1270 1
a1270 1
	    *flags |= S_IRUSR;
d1272 1
a1272 1
	    *flags |= S_IWUSR;
d1274 1
a1274 1
	    *flags |= S_IXUSR;
d1276 1
a1276 1
      else if (group_sid && ace_sid == group_sid)
d1279 1
a1279 1
	    *flags |= S_IRGRP
d1282 1
a1282 1
	    *flags |= S_IWGRP
d1285 1
a1285 1
	    *flags |= S_IXGRP
d1290 9
a1299 1
  *attribute &= ~deny;
d1503 1
a1503 1
  if (GetAce (acl, offset, (PVOID *) &ace))
d1505 1
a1505 1
  len_add += sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD) + GetLengthSid (sid);
d1519 1
a1519 1
  if (GetAce (acl, offset, (PVOID *) &ace))
d1531 1
a1531 3
  if (!wincap.has_security ())
    return NULL;

d1538 8
d1551 3
a1553 1
  else
d1555 2
a1556 14
      /* Otherwise retrieve user data from /etc/passwd */
      struct passwd *pw = getpwuid32 (uid);
      if (!pw)
	{
	  debug_printf ("no /etc/passwd entry for %d", uid);
	  set_errno (EINVAL);
	  return NULL;
	}
      else if (!owner_sid.getfrompw (pw))
	{
	  debug_printf ("no SID for user %d", uid);
	  set_errno (EINVAL);
	  return NULL;
	}
d1565 9
a1573 8
  else
   {
      struct __group32 *grp = getgrgid32 (gid);
      if (!grp)
	debug_printf ("no /etc/group entry for %d", gid);
      else if (!group_sid.getfromgr (grp))
	debug_printf ("no SID for group %d", gid);
   }
d1600 1
a1600 1
  if (group_sid && !SetSecurityDescriptorGroup (&sd, group_sid, FALSE))
d1671 8
a1678 4
  /* Construct deny attributes for owner and group. */
  DWORD owner_deny = 0;
  if (is_grp_member (uid, gid))
    owner_deny = ~owner_allow & (group_allow | other_allow);
d1680 6
a1685 1
    owner_deny = ~owner_allow & other_allow;
a1688 2
  DWORD group_deny = ~group_allow & other_allow;
  group_deny &= ~(STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_READ_EA);
d1699 9
d1712 1
a1712 1
  /* Set deny ACE for group. */
d1718 3
a1720 2
  if (!add_access_allowed_ace (acl, ace_off++, group_allow,
			       group_sid, acl_len, inherit))
a1732 8
  /* Get owner and group from current security descriptor. */
  PSID cur_owner_sid = NULL;
  PSID cur_group_sid = NULL;
  if (!GetSecurityDescriptorOwner (sd_ret, &cur_owner_sid, &dummy))
    debug_printf ("GetSecurityDescriptorOwner %E");
  if (!GetSecurityDescriptorGroup (sd_ret, &cur_group_sid, &dummy))
    debug_printf ("GetSecurityDescriptorGroup %E");

d1744 4
a1747 4
	  if ((cur_owner_sid && ace_sid == cur_owner_sid)
	      || (owner_sid && ace_sid == owner_sid)
	      || (cur_group_sid && ace_sid == cur_group_sid)
	      || (group_sid && ace_sid == group_sid)
@


1.125
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d1539 1
a1539 3
  else if (uid == cygheap->user.orig_uid)
    owner_sid = cygheap->user.orig_sid ();
  if (!owner_sid)
d1560 11
a1570 6
  struct __group32 *grp = getgrgid32 (gid);
  if (!grp)
    debug_printf ("no /etc/group entry for %d", gid);
  else if (!group_sid.getfromgr (grp))
    debug_printf ("no SID for group %d", gid);

@


1.124
log
@* security.cc (allow_ntsec): Default to zero.
* environ.cc (environ_init): Set allow_ntsec to TRUE by default, assuming OS
allows it.
@
text
@d757 1
a757 1
    debug_printf ("GetTokenInformation(token, TokenGroups): %E\n");
d761 1
a761 1
    debug_printf ("GetTokenInformation(my_token, TokenGroups): %E\n");
d858 1
a858 1
    debug_printf ("OpenProcessToken(my_token): %E\n");
d867 1
a867 1
	    ("GetTokenInformation(my_token, TokenStatistics): %E\n");
d875 1
a875 1
	debug_printf ("GetTokenInformation(my_token, TokenGroups): %E\n");
d881 1
a881 1
	  debug_printf ("GetTokenInformation(my_token, TokenGroups): %E\n");
@


1.123
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d44 1
a44 1
BOOL allow_ntsec = true;
@


1.122
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d1209 2
a1210 2
get_attribute_from_acl(int * attribute, PACL acl, PSID owner_sid,
		       PSID group_sid, BOOL grp_member)
d1390 1
a1390 1
      res = NTReadEA (file, ".UNIXATTR", (char *)attribute, sizeof(*attribute));
@


1.121
log
@	* grp.cc (initgroups): Call groups::clear_supp to free the
	supplementary group sids that may have been set by setgroups.
	* security.cc (cygsidlist::free_sids): Also zero the class members.
	* security.h (groups::clear_supp): New.
	Rename cygsidlist_unknown to cygsidlist_empty.
@
text
@d700 1
a700 1
        the token groups that are listed in /etc/group match the union of
d703 1
a703 1
        in the token are the groups associated with the usersid. We assume
d785 1
a785 1
           else if (gsid != well_known_world_sid &&
d792 1
a792 1
      if (sawpg || 
d862 1
a862 1
         id of the user account running current process. */
d872 1
a872 1
         some important well known group sids. */
d1190 2
a1191 2
         FAT returns ERROR_INVALID_SECURITY_DESCR.
         This shouldn't return as error, but better be ignored. */
d1466 1
a1466 1
      					 uidret, gidret);
@


1.120
log
@	* sec_acl.cc (getacl): Check ace_sid == well_known_world_sid
	before owner_sid and group_sid so that well_known_world_sid
	means "other" even when owner_sid and/or group_sid are Everyone.
	* security.cc (get_attribute_from_acl): Created from code common
	to get_nt_attribute() and get_nt_object_attribute(), with same
	reordering as in getacl() above.
	(get_nt_attribute): Call get_attribute_from_acl().
	(get_nt_object_attribute): Ditto.
@
text
@d64 3
@


1.119
log
@	* security.cc (verify_token): Do not reject a token just because
	the supplementary group list is missing Everyone or a groupsid
	equal to usersid, or because the primary group is not in the token,
	as long as it is equal to the usersid.
	* syscalls.cc (seteuid32): Use common code for all successful returns.
	* grp.cc (getgroups32): Never includes Everyone in the output.
@
text
@d1205 89
d1356 1
a1357 82
  ACCESS_ALLOWED_ACE *ace;
  int allow = 0;
  int deny = 0;
  int *flags, *anti;

  for (DWORD i = 0; i < acl->AceCount; ++i)
    {
      if (!GetAce (acl, i, (PVOID *) &ace))
	continue;
      if (ace->Header.AceFlags & INHERIT_ONLY)
	continue;
      switch (ace->Header.AceType)
	{
	case ACCESS_ALLOWED_ACE_TYPE:
	  flags = &allow;
	  anti = &deny;
	  break;
	case ACCESS_DENIED_ACE_TYPE:
	  flags = &deny;
	  anti = &allow;
	  break;
	default:
	  continue;
	}

      cygsid ace_sid ((PSID) &ace->SidStart);
      if (owner_sid && ace_sid == owner_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRUSR;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWUSR;
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXUSR;
	}
      else if (group_sid && ace_sid == group_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRGRP
		      | ((grp_member && !(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWGRP
		      | ((grp_member && !(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXGRP
		      | ((grp_member && !(*anti & S_IXUSR)) ? S_IXUSR : 0);
	}
      else if (ace_sid == well_known_world_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IROTH
		      | ((!(*anti & S_IRGRP)) ? S_IRGRP : 0)
		      | ((!(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWOTH
		      | ((!(*anti & S_IWGRP)) ? S_IWGRP : 0)
		      | ((!(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    {
	      *flags |= S_IXOTH
			| ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
			| ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
	    }
	  if ((*attribute & S_IFDIR) &&
	      (ace->Mask & (FILE_WRITE_DATA | FILE_EXECUTE | FILE_DELETE_CHILD))
	      == (FILE_WRITE_DATA | FILE_EXECUTE))
	    *flags |= S_ISVTX;
	}
      else if (ace_sid == well_known_null_sid)
	{
	  /* Read SUID, SGID and VTX bits from NULL ACE. */
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_ISVTX;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_ISGID;
	  if (ace->Mask & FILE_APPEND_DATA)
	    *flags |= S_ISUID;
	}
    }
  *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX | S_ISGID | S_ISUID);
  *attribute |= allow;
  *attribute &= ~deny;
d1448 1
a1448 82
  ACCESS_ALLOWED_ACE *ace;
  int allow = 0;
  int deny = 0;
  int *flags, *anti;

  for (DWORD i = 0; i < acl->AceCount; ++i)
    {
      if (!GetAce (acl, i, (PVOID *) & ace))
	continue;
      if (ace->Header.AceFlags & INHERIT_ONLY)
	continue;
      switch (ace->Header.AceType)
	{
	case ACCESS_ALLOWED_ACE_TYPE:
	  flags = &allow;
	  anti = &deny;
	  break;
	case ACCESS_DENIED_ACE_TYPE:
	  flags = &deny;
	  anti = &allow;
	  break;
	default:
	  continue;
	}

      cygsid ace_sid ((PSID) & ace->SidStart);
      if (owner_sid && ace_sid == owner_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRUSR;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWUSR;
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXUSR;
	}
      else if (group_sid && ace_sid == group_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRGRP
		      | ((grp_member && !(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWGRP
		      | ((grp_member && !(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXGRP
		      | ((grp_member && !(*anti & S_IXUSR)) ? S_IXUSR : 0);
	}
      else if (ace_sid == well_known_world_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IROTH
		      | ((!(*anti & S_IRGRP)) ? S_IRGRP : 0)
		      | ((!(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWOTH
		      | ((!(*anti & S_IWGRP)) ? S_IWGRP : 0)
		      | ((!(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    {
	      *flags |= S_IXOTH
			| ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
			| ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
	    }
	  if ((*attribute & S_IFDIR) &&
	      (ace->Mask & (FILE_WRITE_DATA | FILE_EXECUTE | FILE_DELETE_CHILD))
	      == (FILE_WRITE_DATA | FILE_EXECUTE))
	    *flags |= S_ISVTX;
	}
      else if (ace_sid == well_known_null_sid)
	{
	  /* Read SUID, SGID and VTX bits from NULL ACE. */
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_ISVTX;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_ISGID;
	  if (ace->Mask & FILE_APPEND_DATA)
	    *flags |= S_ISUID;
	}
    }
  *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX | S_ISGID | S_ISUID);
  *attribute |= allow;
  *attribute &= ~deny;
@


1.118
log
@	* security.cc: Change some formatting.
	* include/cygwin/version.h: Bump API minor version.

        * cygheap.h (class cygheap_user): Add member groups.
        * security.h (class cygsidlist): Add members type and maxcount,
        methods position, addfromgr, alloc_sids and free_sids and
        operator+= (const PSID psid). Modify contains () to call
        position () and optimize add () to use maxcount.
        (class user_groups): Create.
        Update declarations of verify_token and create_token.
        * security.cc (cygsidlist::alloc_sids): New.
        (cygsidlist::free_sids): New.
        (get_token_group_sidlist): Create from get_group_sidlist.
        (get_initgroups_sidlist): Create from get_group_sidlist.
        (get_group_sidlist): Suppress.
        (get_setgroups_sidlist): Create.
        (verify_token): Modify arguments. Add setgroups case.
        (create_token): Modify arguments. Call get_initgroups_sidlist and
        get_setgroups_sidlist as needed. Set SE_GROUP_LOGON_ID from auth_pos
        outside of the loop. Rename the various group sid lists consistently.
        * syscalls.cc (seteuid32): Modify to use cygheap->user.groups.
        (setegid32): Call cygheap->user.groups.update_pgrp.
        * grp.cc (setgroups): Create.
        (setgroups32): Create.
        * uinfo.cc (internal_getlogin): Initialize and update user.groups.pgsid.
        * cygwin.din: Add setgroups and setgroups32.
@
text
@d782 2
a783 1
	    else
d789 3
a791 1
      if (sawpg || groups.sgsids.contains (groups.pgsid))
@


1.117
log
@* security.cc (allow_ntsec): Default to on.
(allow_smbntsec): Default to off.
@
text
@d50 16
d83 1
a83 1
  strlcpy (user, pw->pw_name, UNLEN+1);
d93 1
a93 1
	strlcpy(domain, d + 2, u - d - 1);
d97 1
a97 1
	strlcpy(user, u + 1, c - u);
d131 3
a133 3
		    LOGON32_LOGON_INTERACTIVE,
		    LOGON32_PROVIDER_DEFAULT,
		    &hToken)
d171 1
a171 1
#if 0 //unused
d213 1
a213 1
#if 0 // unused
d245 2
a246 1
      (ret = NetGetDCName (NULL, primary, (LPBYTE *) &buf)) == STATUS_SUCCESS)
d291 2
a292 1
	for (WCHAR *ptr1 = buf; (*wserver++ = *ptr1++); ) {}
d301 2
a302 1
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user, char *domain)
d335 1
a335 1
	  debug_printf ("LookupAccountName(%s): %E", dgroup);
d337 4
a340 3
	  grp_list += gsid;
      else debug_printf ("Global group %s invalid. Domain: %s Use: %d",
			dgroup, domain, use);
d392 1
a392 1
  if (!GetComputerNameA(lgroup, & llen))
d394 2
a395 2
       __seterrno ();
       return FALSE;
d412 1
a412 1
              debug_printf ("LookupAccountName(%s): %E", bgroup);
d416 1
a416 1
              debug_printf ("LookupAccountName(%s): %E", lgroup);
d438 1
a438 1
#if 0 /* Unused */
d464 2
a465 1
  if (IsValidSid (pgrpsid) && (count = *GetSidSubAuthorityCount (pgrpsid)) > 1)
d497 4
a500 12
static BOOL
get_group_sidlist (cygsidlist &grp_list,
		   cygsid &usersid, cygsid &pgrpsid, struct passwd *pw,
		   PTOKEN_GROUPS my_grps, LUID auth_luid, int &auth_pos,
		   BOOL *special_pgrp)
{
  char user[UNLEN + 1];
  char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  WCHAR wserver[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  char server[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  cygsidlist sup_list;

d502 29
d532 6
d542 1
d548 6
a553 28
      if (my_grps)
	{
	  if (sid_in_token_groups (my_grps, well_known_local_sid))
	    grp_list += well_known_local_sid;
	  if (sid_in_token_groups (my_grps, well_known_dialup_sid))
	    grp_list += well_known_dialup_sid;
	  if (sid_in_token_groups (my_grps, well_known_network_sid))
	    grp_list += well_known_network_sid;
	  if (sid_in_token_groups (my_grps, well_known_batch_sid))
	    grp_list += well_known_batch_sid;
	  if (sid_in_token_groups (my_grps, well_known_interactive_sid))
	    grp_list += well_known_interactive_sid;
	  if (sid_in_token_groups (my_grps, well_known_service_sid))
	    grp_list += well_known_service_sid;
	}
      else
	{
	  grp_list += well_known_local_sid;
	  grp_list += well_known_interactive_sid;
	}
      if (auth_luid.QuadPart != 999) /* != SYSTEM_LUID */
	{
	  char buf[64];
	  __small_sprintf (buf, "S-1-5-5-%u-%u", auth_luid.HighPart,
						 auth_luid.LowPart);
	  grp_list += buf;
	  auth_pos = grp_list.count - 1;
	}
d561 3
a563 7
  /* special_pgrp true if pgrpsid is not null and not in normal groups */
  *special_pgrp = FALSE;
  if (pgrpsid && !grp_list.contains (pgrpsid))
    {
       *special_pgrp = TRUE;
       grp_list += pgrpsid;
    }
d567 14
d609 2
a610 2
  PTOKEN_PRIVILEGES privs = (PTOKEN_PRIVILEGES) malloc (sizeof (ULONG) +
					    20 * sizeof (LUID_AND_ATTRIBUTES));
d623 1
a623 1
		      SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
d645 2
a646 2
	  if ((ret = LsaEnumerateAccountRights (lsa, usersid, &privstrs, &cnt))
	      != STATUS_SUCCESS)
d669 2
a670 2
		realloc (privs, sizeof (ULONG) +
				(tmp_count + 1) * sizeof (LUID_AND_ATTRIBUTES));
d683 1
a683 1
		      SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
d694 13
d708 1
a708 1
verify_token (HANDLE token, cygsid &usersid, cygsid &pgrpsid, BOOL *pintern)
d719 2
a720 1
      else *pintern = intern = !memcmp (ts.SourceName, "Cygwin.1", 8);
d726 3
a728 2
      debug_printf ("GetTokenInformation(): %E");
  if (usersid != tok_usersid) return FALSE;
d730 7
a736 7
  /* In an internal token, if the sd group is not well_known_null_sid,
     it must match pgrpsid */
  if (intern)
    {
       char sd_buf[MAX_SID_LEN + sizeof (SECURITY_DESCRIPTOR)];
       PSID gsid = NO_SID;
       if (!GetKernelObjectSecurity (token, GROUP_SECURITY_INFORMATION,
d739 2
a740 2
	   debug_printf ("GetKernelObjectSecurity(): %E");
       else if (!GetSecurityDescriptorGroup ((PSECURITY_DESCRIPTOR) sd_buf,
d742 3
a744 2
	   debug_printf ("GetSecurityDescriptorGroup(): %E");
       if (well_known_null_sid != gsid) return pgrpsid == gsid;
d746 1
a746 1
  /* See if the pgrpsid is the tok_usersid in the token groups */
d749 2
a751 2
  if ( pgrpsid == tok_usersid)
    return TRUE;
d759 33
a791 2
  else
    ret = sid_in_token_groups (my_grps, pgrpsid);
d794 2
d800 1
a800 1
create_token (cygsid &usersid, cygsid &pgrpsid, struct passwd *pw)
d806 1
a806 1
  cygsidlist grpsids;
d810 1
a810 2
  OBJECT_ATTRIBUTES oa =
    { sizeof oa, 0, 0, 0, 0, &sqos };
d812 1
a812 1
  BOOL special_pgrp;
d815 1
a815 1
  LARGE_INTEGER exp = { QuadPart:0x7fffffffffffffffLL  };
d818 1
a818 1
  PTOKEN_GROUPS grps = NULL;
d822 1
a822 1
  char acl_buf[MAX_DACL_LEN(5)];
d834 1
a834 1
  PTOKEN_GROUPS my_grps = NULL;
d856 1
a856 1
	 id of the user account running current process. */
d860 2
a861 1
	  debug_printf ("GetTokenInformation(my_token, TokenStatistics): %E\n");
d866 1
a866 1
	 some important well known group sids. */
d870 3
a872 3
      else if (!(my_grps = (PTOKEN_GROUPS) malloc (size)))
	debug_printf ("malloc (my_grps) failed.");
      else if (!GetTokenInformation (my_token, TokenGroups, my_grps,
d876 2
a877 2
	  free (my_grps);
	  my_grps = NULL;
d884 6
a889 2
  if (!get_group_sidlist (grpsids, usersid, pgrpsid, pw,
			  my_grps, auth_luid, auth_pos, &special_pgrp))
d893 1
a893 1
  pgrp.PrimaryGroup = pgrpsid;
d896 8
a903 11
  char grps_buf[sizeof (ULONG) + grpsids.count * sizeof (SID_AND_ATTRIBUTES)];
  grps = (PTOKEN_GROUPS) grps_buf;
  grps->GroupCount = grpsids.count;
  for (DWORD i = 0; i < grps->GroupCount; ++i)
    {
      grps->Groups[i].Sid = grpsids.sids[i];
      grps->Groups[i].Attributes = SE_GROUP_MANDATORY |
				   SE_GROUP_ENABLED_BY_DEFAULT |
				   SE_GROUP_ENABLED;
      if (auth_pos >= 0 && i == (DWORD) auth_pos)
	grps->Groups[i].Attributes |= SE_GROUP_LOGON_ID;
d905 2
d909 1
a909 1
  if (!(privs = get_priv_list (lsa, usersid, grpsids)))
d914 2
a915 1
		grpsids.contains (well_known_admins_sid)?well_known_admins_sid:usersid))
d921 2
a922 2
		       &auth_luid, &exp, &user, grps, privs, &owner, &pgrp,
		       &dacl, &source);
d935 6
a940 4
	  !SetSecurityDescriptorGroup (
	      (PSECURITY_DESCRIPTOR) psa->lpSecurityDescriptor,
	      special_pgrp ? pgrpsid : well_known_null_sid, FALSE))
	  debug_printf ("SetSecurityDescriptorGroup %E");
d942 2
a943 2
      if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, psa,
			     SecurityImpersonation, TokenPrimary, &primary_token))
d957 2
a958 2
  if (my_grps)
    free (my_grps);
d1041 1
a1041 1
  str2buf2lsa (subbuf.auth.CaseInsensitiveChallengeResponse, subbuf.authinf2,"");
d1045 3
a1047 3
		     package_id, &subbuf, sizeof subbuf,
		     NULL, &ts, (PVOID *)&profile, &size,
		     &luid, &user_token, &quota, &ret2);
d1058 1
a1058 2
			 SecurityImpersonation, TokenPrimary,
			 &primary_token))
d1098 1
a1098 1
  char fbuf [PATH_MAX];
d1109 3
a1111 3
			 | GROUP_SECURITY_INFORMATION
			 | DACL_SECURITY_INFORMATION,
			 sd_buf, *sd_size, &len))
d1184 2
a1185 2
	 FAT returns ERROR_INVALID_SECURITY_DESCR.
	 This shouldn't return as error, but better be ignored. */
d1211 1
a1211 1
  /* Yeah, sounds too much, but I've seen SDs of 2100 bytes!*/
d1376 1
a1376 1
      res = NTReadEA (file, ".UNIXATTR", (char *) attribute, sizeof (*attribute));
d1382 1
a1382 1
  /* symlinks are everything for everyone!*/
d1390 2
a1391 2
get_nt_object_attribute (HANDLE handle, SE_OBJECT_TYPE object_type, int *attribute,
		  __uid32_t *uidret, __gid32_t *gidret)
d1402 9
a1410 12
                                        DACL_SECURITY_INFORMATION |
                                        GROUP_SECURITY_INFORMATION |
                                        OWNER_SECURITY_INFORMATION,
                                        &owner_sid,
                                        &group_sid,
                                        &acl,
                                        NULL,
                                        &psd))
	{
	  __seterrno ();
	  debug_printf ("GetSecurityInfo %E");
	  return -1;
d1432 1
a1432 2
      syscall_printf ("No ACL = %x, uid %d, gid %d",
		      *attribute, uid, gid);
d1444 1
a1444 1
      if (!GetAce (acl, i, (PVOID *) &ace))
d1462 1
a1462 1
      cygsid ace_sid ((PSID) &ace->SidStart);
d1528 1
a1528 1
		    int *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1532 2
a1533 1
      int res = get_nt_object_attribute (handle, object_type, attribute, uidret, gidret);
d1547 1
a1547 1
  /* symlinks are everything for everyone!*/
d1566 1
a1566 2
  len_add += sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD)
	     + GetLengthSid (sid);
d1582 1
a1582 2
  len_add += sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD)
	     + GetLengthSid (sid);
d1703 1
a1703 2
      == (S_IFDIR | S_IWGRP | S_IXGRP)
      && !(attribute & S_ISVTX))
d1746 1
a1746 1
  					: NO_INHERITANCE;
d1751 1
a1751 1
				  owner_sid, acl_len, inherit))
d1755 1
a1755 1
				owner_sid, acl_len, inherit))
d1760 1
a1760 1
				  group_sid, acl_len, inherit))
d1764 1
a1764 1
				group_sid, acl_len, inherit))
d1769 1
a1769 1
				well_known_world_sid, acl_len, inherit))
d1852 1
a1852 1
  /* symlinks are anything for everyone!*/
d1857 1
a1857 1
  InitializeSecurityDescriptor ((PSECURITY_DESCRIPTOR)sd_buf,
d1859 2
a1860 2
  psa->lpSecurityDescriptor = alloc_sd (geteuid32 (), getegid32 (),
					attribute, (PSECURITY_DESCRIPTOR)sd_buf,
d1891 1
a1891 2
		    __uid32_t uid, __gid32_t gid,
		    int attribute)
d1912 1
a1912 2
			     myself->uid, myself->gid,
			     attribute);
@


1.116
log
@	* security.cc (get_group_sidlist): Create group list from /etc files
	even if DC is available but access fails.
@
text
@d44 1
a44 1
BOOL allow_ntsec;
d48 1
a48 1
BOOL allow_smbntsec = TRUE;
@


1.115
log
@white space
@
text
@d528 2
a529 4
      /* Fail silently if DC is not reachable */
      if (get_logon_server (domain, server, wserver) &&
	  !get_user_groups (wserver, grp_list, user, domain))
	return FALSE;
@


1.114
log
@	* security.cc (get_unix_group_sidlist): Create.
	(get_supplementary_group_sidlist): Evolve into get_unix_group_sidlist.
	(get_user_local_groups): Add check for duplicates.
	(get_user_primary_group): Suppress.
	(get_group_sidlist): Silently ignore PDC unavailability.
	Call get_unix_group_sidlist() before get_user_local_groups().
	Remove call to get_supplementary_group_sidlist(). Never call
	get_user_primary_group() as the passwd group is always included.
	Add well_known_authenticated_users_sid in only one statement.
@
text
@d255 1
a255 1
  WCHAR * buf;
d274 1
a274 1
	for (WCHAR * ptr1 = buf; (*wserver++ = *ptr1++); ) {}
d283 1
a283 1
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user, char * domain)
d455 1
a455 1
get_unix_group_sidlist (struct passwd * pw, cygsidlist &grp_list)
d478 1
a478 1
		   cygsid &usersid, cygsid &pgrpsid, struct passwd * pw,
d480 1
a480 1
		   BOOL * special_pgrp)
d660 1
a660 1
verify_token (HANDLE token, cygsid &usersid, cygsid &pgrpsid, BOOL * pintern)
d716 1
a716 1
create_token (cygsid &usersid, cygsid &pgrpsid, struct passwd * pw)
@


1.113
log
@	* security.cc (get_group_sidlist): Fix formatting.
@
text
@d391 6
a396 6
	     if (GetLastError () != ERROR_NONE_MAPPED)
		 debug_printf ("LookupAccountName(%s): %E", bgroup);
	     strcpy (lgroup + llen, bgroup + blen);
	     if (!LookupAccountName (NULL, lgroup, gsid, &glen,
				     domain, &dlen, &use))
		 debug_printf ("LookupAccountName(%s): %E", lgroup);
d398 3
a400 1
	if (legal_sid_type (use))
a401 1
	else debug_printf ("Rejecting local %s. use: %d", bgroup + blen, use);
a402 1

d418 1
d452 1
d454 2
a455 2
static int
get_supplementary_group_sidlist (const char *username, cygsidlist &grp_list)
d458 1
a458 1
  int cnt = 0;
d462 3
a464 1
      if (gr->gr_mem)
d466 7
a472 10
	  if (strcasematch (username, gr->gr_mem[gi]))
	    {
	      if (gr->gr_passwd && *gr->gr_passwd)
		{
		  cygsid sid (gr->gr_passwd);
		  if ((PSID)sid && grp_list.add (sid))
		    ++cnt;
		}
	      break;
	    }
a473 1
  return cnt;
d478 1
a478 1
		  cygsid &usersid, cygsid &pgrpsid, struct passwd * pw,
d491 1
a493 1
      grp_list += well_known_authenticated_users_sid;
d495 1
a498 3
      extract_nt_dom_user (pw, domain, user);
      if (!get_logon_server (domain, server, wserver))
	return FALSE;
a512 1
	  grp_list += well_known_authenticated_users_sid;
a517 1
	  grp_list += well_known_authenticated_users_sid;
d527 7
a533 2
      if (!get_user_groups (wserver, grp_list, user, domain) ||
	  !get_user_local_groups (grp_list, usersid))
d537 2
a538 8
  if (!pgrpsid)
    {
      *special_pgrp = FALSE;
      get_user_primary_group (wserver, user, usersid, pgrpsid);
    }
  else
    *special_pgrp = TRUE;
  if (pw->pw_name && get_supplementary_group_sidlist (pw->pw_name, sup_list))
d540 2
a541 3
      for (int i = 0; i < sup_list.count; ++i)
	if (!grp_list.contains (sup_list.sids[i]))
	  grp_list += sup_list.sids[i];
a542 4
  if (!grp_list.contains (pgrpsid))
    grp_list += pgrpsid;
  else
    *special_pgrp = FALSE;
d849 1
a849 1
	      special_pgrp?pgrpsid:well_known_null_sid, FALSE))
@


1.112
log
@	* security.cc (get_logon_server): Interpret a zero length
	domain as the local domain.
	(get_group_sidlist): Add authenticated users SID to SYSTEM's group
	list instead of SYSTEM itself.
	(verify_token): Accept the primary group sid if it equals
	the token user sid.
@
text
@d538 1
a538 1
      * special_pgrp = FALSE;
d541 2
a542 1
  else * special_pgrp = TRUE;
d551 2
a552 1
  else * special_pgrp = FALSE;
@


1.111
log
@	* security.h (DONT_INHERIT): Eliminate definition.
	(INHERIT_ALL): Ditto.
	(INHERIT_ONLY): Ditto.
	* sec_acl.cc: Use appropriate defines from accctrl.h instead of the
	above throughout.
	* security.cc: Ditto.
@
text
@d258 1
d260 1
a260 1
      strcasematch (domain, server + 2))
d493 1
a493 1
      grp_list += well_known_system_sid;
d703 1
a703 1
  /* See if the pgrpsid is in the token groups */
d707 2
@


1.110
log
@* autoload.cc (GetSecurityInfo): Define new autoload function.
(RegQueryInfoKeyA): Ditto.
* fhandler.h (fhandler_virtual::fill_filebuf): Change return type to bool.
(fhandler_proc::fill_filebuf): Ditto.
(fhandler_registry::fill_filebuf): Ditto.
(fhandler_process::fill_filebuf): Ditto.
(fhandler_registry::value_name): Add new member.
(fhandler_registry::close): Add new method.
(fhandler_process::p): Remove member.
* fhandler_proc.cc (fhandler_proc::open): Add set_nohandle after calling
superclass method.  Check return value of fill_filebuf.
(fhandler_proc::fill_filebuf): Change return type to bool.  Add return
statement.
* fhandler_process.cc (fhandler_process::open): Add set_nohandle after calling
superclass method.  Remove references to p.  Check return value of
fill_filebuf.
(fhandler_process::fill_filebuf): Change return type to bool.  Don't use
dereference operator on p.  Add return statement.
(fhandler_process::format_process_stat): Fix typo.
* fhandler_registry.cc: Add static open_key declaration.
(fhandler_registry::exists): Assume path is already normalised.  Try opening
the path as a key in its own right first, before reverting to enumerating
subkeys and values of the parent key.
(fhandler_registry::fstat): Add additional code to return more relevant
information about the registry key/value.
(fhandler_registry::readdir): Explicitly set desired access when opening
registry key.  Remove output of buf from debug_printf format string.
(fhandler_registry::open): Use set_io_handle to store registry key handle.  Set
value_name member.  Move code to read a value from the registry to
fill_filebuf.  Add call to fill_filebuf.
(fhandler_registry::close): New method.
(fhandler_registry::fill_filebuf): Change return type to bool.  Add code to
read a value from registry.
(fhandler_registry::open_key): Make function static.  Use KEY_READ as desired
access unless this is the last path component.  Check the return value of
RegOpenKeyEx for an error instead of hKey.
* fhandler_virtual.cc (fhandler_virtual::lseek): Check the return value of
fill_filebuf.
(fhandler_virtual::open): Remove call to set_nohandle.
(fhandler_virtual::fill_filebuf): Change return type to bool.  Add return
statement.
* security.cc (get_nt_object_attribute): New function.
(get_object_attribute): New function.
* security.h (get_object_attribute): New function declaration.
@
text
@d1190 1
a1190 1
      if (ace->Header.AceFlags & INHERIT_ONLY_ACE)
d1366 1
a1366 1
      if (ace->Header.AceFlags & INHERIT_ONLY_ACE)
d1667 2
a1668 1
  DWORD inherit = (attribute & S_IFDIR) ? INHERIT_ALL : DONT_INHERIT;
d1696 1
a1696 1
				  well_known_null_sid, acl_len, DONT_INHERIT))
@


1.109
log
@white space
@
text
@d31 1
d1303 168
@


1.108
log
@	* security.cc (extract_nt_dom_user): Check for all buffer overflows.
	Call LookupAccountSid after trying to get domain & user from passwd.
	(get_group_sidlist): Obtain the domain and user by calling
	extract_nt_dom_user instead of LookupAccountSid.
@
text
@d78 1
a78 1
        c = u + UNLEN + 1;
@


1.107
log
@* security.cc (get_group_sidlist): Add pw argument and use pw->pw_name in call
to get_supplementary_group_sidlist.
(create_token): Add pw argument and use it in call to get_group_sidlist.
* security.h: Add pw argument in declaration of create_token.
* syscalls.cc (seteuid32): Add pw argument in call to create_token.
@
text
@d63 1
a63 6
  cygsid psid;
  DWORD ulen = UNLEN + 1;
  DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  SID_NAME_USE use;
  char buf[INTERNET_MAX_HOST_NAME_LENGTH + UNLEN + 2];
  char *c;
d65 2
a66 2
  strcpy (domain, "");
  strcpy (buf, pw->pw_name);
d69 14
a82 2
  if (psid.getfrompw (pw) &&
      LookupAccountSid (NULL, psid, user, &ulen, domain, &dlen, &use))
d85 6
a90 22
  if (pw->pw_gecos)
    {
      if ((c = strstr (pw->pw_gecos, "U-")) != NULL &&
	  (c == pw->pw_gecos || c[-1] == ','))
	{
	  buf[0] = '\0';
	  strncat (buf, c + 2, INTERNET_MAX_HOST_NAME_LENGTH + UNLEN + 1);
	  if ((c = strchr (buf, ',')) != NULL)
	    *c = '\0';
	}
    }
  if ((c = strchr (buf, '\\')) != NULL)
    {
      *c++ = '\0';
      strcpy (domain, buf);
      strcpy (user, c);
    }
  else
    {
      strcpy (domain, "");
      strcpy (user, buf);
    }
a483 3
  DWORD ulen = sizeof (user);
  DWORD dlen = sizeof (domain);
  SID_NAME_USE use;
a486 6
  if (!LookupAccountSid (NULL, usersid, user, &ulen, domain, &dlen, &use))
    {
      debug_printf ("LookupAccountSid () %E");
      __seterrno ();
      return FALSE;
    }
d496 1
@


1.106
log
@	* security.cc (alloc_sd): Carefully check owner_sid again after trying
	SIDs from cygheap.
@
text
@d485 1
a485 1
		   cygsid &usersid, cygsid &pgrpsid,
d557 1
a557 1
  if (get_supplementary_group_sidlist (user, sup_list))
d737 1
a737 1
create_token (cygsid &usersid, cygsid &pgrpsid)
d821 1
a821 1
  if (!get_group_sidlist (grpsids, usersid, pgrpsid,
d1382 1
a1382 1
        {
d1388 1
a1388 1
        {
@


1.105
log
@	* security.cc (alloc_sd): Remove unnecessary retrieval of owner name.
	Check uid for current user first and use SIDs from cygheap if so.
	Set errno to EINVAL if user SID isn't retrievable.  Just print user SID
	as debug output.
	Don't bail out if group SID isn't retrievable.  Change debug output
	appropriately.
@
text
@d1371 1
a1371 1
  cygsid owner_sid;
d1377 1
a1377 1
  else
@


1.104
log
@* uinfo.cc (cygheap_user::ontherange): Use env_name for NetUserGetInfo.
(cygheap_user::env_logsrv): Verify env_domain is valid.
* environ.cc: Include child_info.h and keep spenvs[] sorted.
(environ_init): Check child_proc_info instead of myself->ppid_handle.
@
text
@d1370 1
a1370 2
  /* Get SID and name of new owner. */
  char owner[UNLEN + 1];
d1372 23
a1394 7
  struct passwd *pw = getpwuid32 (uid);
  strcpy (owner, pw ? pw->pw_name : getlogin ());
  if (!pw || !owner_sid.getfrompw (pw))
    return NULL;
  debug_printf ("owner: %s [%d]", owner,
		*GetSidSubAuthority (owner_sid,
		*GetSidSubAuthorityCount (owner_sid) - 1));
d1396 1
a1396 1
  /* Get SID and name of new group. */
d1399 4
a1402 7
  if (grp)
    {
      if (!grp || !group_sid.getfromgr (grp))
	return NULL;
    }
  else
    debug_printf ("no group");
@


1.103
log
@Use hMainProc where appropriate, throughout.
* environ.cc (spenv::retrieve): Add debugging statements.
* pinfo.cc (set_myself): Don't call strace.hello if already stracing.
* strace.cc (strace): Move NO_COPY keyword so that it will actually take
effect.
@
text
@d271 1
a271 1
        sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d515 1
a515 1
        return FALSE;
d547 2
a548 2
          !get_user_local_groups (grp_list, usersid))
        return FALSE;
@


1.102
log
@* security.cc (get_logon_server): Use strcasematch rather than strcasecmp.
@
text
@d151 1
a151 1
  memcpy(buf, srcstr, tgt.MaximumLength);
d158 1
a158 1
  tgt.MaximumLength = tgt.Length + sizeof(WCHAR);
d191 1
a191 1
  NTSTATUS ret = LsaOpenPolicy(NULL, &oa, POLICY_EXECUTE, &lsa);
d220 1
a220 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d228 1
a228 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d237 1
a237 1
      (ret = NetGetDCName(NULL, primary, (LPBYTE *) &buf)) == STATUS_SUCCESS)
d309 2
a310 2
  len = strlen(domain);
  strcpy(dgroup, domain);
d326 1
a326 1
      else debug_printf("Global group %s invalid. Domain: %s Use: %d",
d381 1
a381 1
       __seterrno();
d400 1
a400 1
	     strcpy(lgroup + llen, bgroup + blen);
d407 1
a407 1
	else debug_printf("Rejecting local %s. use: %d", bgroup + blen, use);
d647 1
a647 1
	  lsa2str (buf, privstrs[i], sizeof(buf) - 1);
d709 1
a709 1
       if (!GetKernelObjectSecurity(token, GROUP_SECURITY_INFORMATION,
d713 1
a713 1
       else if (!GetSecurityDescriptorGroup((PSECURITY_DESCRIPTOR) sd_buf,
d723 2
a724 2
	  GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(token, TokenGroups): %E\n");
d726 1
a726 1
	debug_printf ("malloc (my_grps) failed.");
d728 5
a732 3
	debug_printf ("GetTokenInformation(my_token, TokenGroups): %E\n");
  else 	ret = sid_in_token_groups (my_grps, pgrpsid);
  if (my_grps) free (my_grps);
d764 1
a764 1
  memcpy(source.SourceName, "Cygwin.1", 8);
d789 1
a789 1
  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &my_token))
d847 1
a847 1
  if (!sec_acl((PACL) acl_buf, FALSE,
d929 1
a929 1
  if ((old_tcb_state = set_process_privilege(SE_TCB_NAME)) < 0)
d935 1
a935 1
  ret = LsaRegisterLogonProcess(&name, &lsa_hdl, &sec_mode);
d939 1
a939 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d949 1
a949 1
  ret = LsaLookupAuthenticationPackage(lsa_hdl, &name, &package_id);
d953 2
a954 2
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
      LsaDeregisterLogonProcess(lsa_hdl);
d960 1
a960 1
  memcpy(ts.SourceName, "Cygwin.1", 8);
d967 6
a972 6
  str2buf2uni(subbuf.auth.LogonDomainName, subbuf.dombuf, nt_domain);
  str2buf2uni(subbuf.auth.UserName, subbuf.usrbuf, nt_user);
  str2buf2uni(subbuf.auth.Workstation, subbuf.wkstbuf, "");
  memcpy(subbuf.auth.ChallengeToClient, "12345678", MSV1_0_CHALLENGE_LENGTH);
  str2buf2lsa(subbuf.auth.CaseSensitiveChallengeResponse, subbuf.authinf1, "");
  str2buf2lsa(subbuf.auth.CaseInsensitiveChallengeResponse, subbuf.authinf2,"");
d975 1
a975 1
  ret = LsaLogonUser(lsa_hdl, (PLSA_STRING) &origin, Network,
d982 2
a983 2
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
      LsaDeregisterLogonProcess(lsa_hdl);
d986 1
a986 1
  LsaFreeReturnBuffer(profile);
d994 1
a994 1
  set_process_privilege(SE_TCB_NAME, old_tcb_state);
d1017 1
a1017 1
read_sd(const char *file, PSECURITY_DESCRIPTOR sd_buf, LPDWORD sd_size)
d1026 1
a1026 1
  debug_printf("file = %s", file);
d1035 1
a1035 1
      OemToCharBuff(file, fbuf, fname_len);
d1048 1
a1048 1
  debug_printf("file = %s: len=%d", file, len);
d1058 1
a1058 1
write_sd(const char *file, PSECURITY_DESCRIPTOR sd_buf, DWORD sd_size)
d1174 2
a1175 2
  __uid32_t uid = cygsid(owner_sid).get_uid ();
  __gid32_t gid = cygsid(group_sid).get_gid ();
d1331 1
a1331 1
  if (GetAce(acl, offset, (PVOID *) &ace))
d1348 1
a1348 1
  if (GetAce(acl, offset, (PVOID *) &ace))
d1378 2
a1379 2
		*GetSidSubAuthority(owner_sid,
		*GetSidSubAuthorityCount(owner_sid) - 1));
d1411 1
a1411 1
  if (!SetSecurityDescriptorOwner(&sd, owner_sid, FALSE))
d1418 1
a1418 1
  if (group_sid && !SetSecurityDescriptorGroup(&sd, group_sid, FALSE))
d1564 1
a1564 1
	  if (!AddAce(acl, ACL_REVISION,
@


1.101
log
@* Makefile.in: Ensure that -MD gets added to CFLAGS regardless of CFLAGS
command-line setting.
* cygwin.din: Export sexec* functions as function which returns ENOSYS
(i.e., sexec* is deprecated).
* dtable.cc (dtable::vfork_child_dup): Ensure that impersonation is restored
even on failure.
* exec.cc: Throughout, remove references to sexec* and _spawnve.
* pinfo.h: Remove _spawnve declaration.
* spawn.cc: Rename _spawnve to spawnve and use throughout.
(spawn_guts): Eliminate hToken argument and processing of same.  Just perform
special actions if impersonating.
(spawnve): Rename from _spawnve.
@
text
@d259 1
a259 1
get_logon_server (const char * domain, char * server, WCHAR *wserver)
d266 2
a267 2
  if ((GetComputerNameA(server + 2, &size)) &&
      !strcasecmp(domain, server + 2))
d277 1
a277 1
  if ((ret = NetGetDCName(NULL, wdomain, (LPBYTE *) &buf)) == STATUS_SUCCESS)
d514 1
a514 1
      if (!get_logon_server( domain, server, wserver))
@


1.100
log
@	* sec_helper.cc (lookup_name): Suppress.
	* security.cc (alloc_sd): Remove logsrv argument.
	Remove two calls to lookup_name.
	(set_security_attribute): Remove logsrv argument.
	Remove logsrv argument in call to alloc_sd.
	(set_nt_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_security_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_nt_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_file_attribute.
	* syscalls.cc (chown_worker): Remove logserver argument in
	call to set_file_attribute.
	(chmod): Ditto.
	* shm.cc (shmget): Remove logsrv argument in call to alloc_sd.
	* uinfo.cc (internal_getlogin): Replace calls to
	lookup_name by call to LookupAccountName.
	* security.h: Remove logsrv in declarations of set_file_attribute
	and alloc_sd. Remove declaration of lookup_name.
@
text
@d49 1
a49 2
extern "C"
void
d102 1
a102 2
extern "C"
HANDLE
@


1.99
log
@	* security.cc (lsa2wchar): Suppressed.
	(get_lsa_srv_inf): Suppressed.
	(get_logon_server_and_user_domain): Suppressed.
	(get_logon_server): Essentially new.
	(get_user_groups): Add "domain" argument. Only lookup the
	designated server and use "domain" in LookupAccountName.
	(is_group_member): Simplify the arguments.
	(get_user_local_groups): Simplify the arguments. Do only a
	local lookup. Use "BUILTIN" and local domain in LookupAccountName.
	(get_user_primary_group). Only lookup the designated server.
	(get_group_sidlist): Remove logonserver argument. Do not lookup
	any server for the SYSTEM account.
	(create_token): Delete logonserver and call to get_logon_server.
	Adjust arguments of get_group_sidlist, see above.
	* security.h: Delete declaration of get_logon_server_and_user_domain
	and add declaration of get_logon_server.
	* uinfo.cc (internal_get_login): Call get_logon_server instead of
	get_logon_server_and_user_domain.
@
text
@d1356 1
a1356 1
alloc_sd (__uid32_t uid, __gid32_t gid, const char *logsrv, int attribute,
d1375 1
a1375 2
  if ((!pw || !owner_sid.getfrompw (pw))
      && !lookup_name (owner, logsrv, owner_sid))
d1386 1
a1386 2
      if ((!grp || !group_sid.getfromgr (grp))
	  && !lookup_name (grp->gr_name, logsrv, group_sid))
a1616 1
					cygheap->user.logsrv (),
d1623 1
a1623 1
		  const char *logsrv, int attribute)
d1640 1
a1640 1
  if (!(psd = alloc_sd (uid, gid, logsrv, attribute, psd, &sd_size)))
d1649 1
a1649 1
		    int attribute, const char *logsrv)
d1654 1
a1654 1
    ret = set_nt_attribute (file, uid, gid, logsrv, attribute);
d1671 1
a1671 1
			     attribute, cygheap->user.logsrv ());
@


1.98
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d165 1
d176 1
d207 1
d258 1
d260 2
a261 2
static BOOL
get_logon_server (LSA_HANDLE lsa, char *logonserver)
d263 4
a266 2
  return get_lsa_srv_inf (lsa, logonserver, NULL);
}
d268 2
a269 6
BOOL
get_logon_server_and_user_domain (char *logonserver, char *userdomain)
{
  BOOL ret = FALSE;
  LSA_HANDLE lsa = open_local_policy ();
  if (lsa != INVALID_HANDLE_VALUE)
d271 15
a285 2
      ret = get_lsa_srv_inf (lsa, logonserver, userdomain);
      close_local_policy (lsa);
d287 2
a288 1
  return ret;
d292 1
a292 1
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user)
d294 1
d298 1
a298 1
  DWORD cnt, tot;
d301 1
a303 3
  if (ret == ERROR_BAD_NETPATH || ret == RPC_S_SERVER_UNAVAILABLE)
    ret = NetUserGetGroups (NULL, wuser, 0, (LPBYTE *) &buf,
			    MAX_PREFERRED_LENGTH, &cnt, &tot);
d311 4
d318 1
a318 1
      char group[UNLEN + 1];
d320 1
a320 2
      DWORD glen = UNLEN + 1;
      DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
d323 7
a329 15
      sys_wcstombs (group, buf[i].grui0_name, UNLEN + 1);
      if (!LookupAccountName (NULL, group, gsid, &glen, domain, &dlen, &use))
	debug_printf ("LookupAccountName(%s): %lu\n", group, GetLastError ());
      if (!legal_sid_type (use))
	{
	  strcat (strcpy (group, domain), "\\");
	  sys_wcstombs (group + strlen (group), buf[i].grui0_name,
			UNLEN + 1 - strlen (group));
	  glen = UNLEN + 1;
	  dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
	  if (!LookupAccountName(NULL, group, gsid, &glen, domain, &dlen, &use))
	    debug_printf ("LookupAccountName(%s): %lu\n", group,GetLastError());
	}
      if (legal_sid_type (use))
	grp_list += gsid;
d337 1
a337 2
is_group_member (WCHAR *wlogonserver, WCHAR *wgroup,
		 cygsid &usersid, cygsidlist &grp_list)
d344 1
d351 1
a351 1
    if (EqualSid (usersid, buf[bidx].lgrmi0_sid))
d363 1
a363 2
get_user_local_groups (WCHAR *wlogonserver, const char *logonserver,
		       cygsidlist &grp_list, cygsid &usersid)
d377 11
d389 1
a389 1
    if (is_group_member (wlogonserver, buf[i].lgrpi0_name, usersid, grp_list))
d392 1
a392 1
	char group[UNLEN + 1];
d394 1
a394 2
	DWORD glen = UNLEN + 1;
	DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
d397 2
a398 2
	sys_wcstombs (group, buf[i].lgrpi0_name, UNLEN + 1);
	if (!LookupAccountName (NULL, group, gsid, &glen, domain, &dlen, &use))
d400 6
a405 18
	    glen = UNLEN + 1;
	    dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
	    if (!LookupAccountName (logonserver + 2, group,
				    gsid, &glen, domain, &dlen, &use))
	      debug_printf ("LookupAccountName(%s): %lu\n", group,
							    GetLastError ());
	  }
	else if (!legal_sid_type (use))
	  {
	    strcat (strcpy (group, domain), "\\");
	    sys_wcstombs (group + strlen (group), buf[i].lgrpi0_name,
			  UNLEN + 1 - strlen (group));
	    glen = UNLEN + 1;
	    dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
	    if (!LookupAccountName (NULL, group, gsid, &glen,
				    domain, &dlen, &use))
	      debug_printf ("LookupAccountName(%s): %lu\n", group,
							    GetLastError ());
d409 1
d429 1
a429 1
			cygsid &usersid, cygsid &pgrpsid)
d437 1
a437 1
  if (usersid == well_known_system_sid)
a444 2
  if (ret == ERROR_BAD_NETPATH || ret == RPC_S_SERVER_UNAVAILABLE)
    ret = NetUserGetInfo (NULL, wuser, 3, (LPBYTE *) &buf);
d451 1
a451 1
  pgrpsid = usersid;
d486 1
a486 1
get_group_sidlist (const char *logonserver, cygsidlist &grp_list,
d491 1
a491 2
  WCHAR wserver[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  char user[INTERNET_MAX_HOST_NAME_LENGTH + 1];
d493 4
a496 2
  DWORD ulen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
a500 1
  sys_mbstowcs (wserver, logonserver, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d507 1
d516 2
d548 3
a558 3
  if (!get_user_groups (wserver, grp_list, user) ||
      !get_user_local_groups (wserver, logonserver, grp_list, usersid))
    return FALSE;
a740 1
  char logonserver[INTERNET_MAX_HOST_NAME_LENGTH + 1];
a782 4
  /* Get logon server. */
  if (!get_logon_server (lsa, logonserver))
    goto out;

d821 1
a821 1
  if (!get_group_sidlist (logonserver, grpsids, usersid, pgrpsid,
@


1.97
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@a35 1
#include "sigproc.h"
@


1.96
log
@	* security.cc (set_security_attribute): Call getegid32() instead of
	getegid().
	* include/cygwin/grp.h: Declare getegid32().
@
text
@d1133 1
a1133 1
		  __uid16_t *uidret, __gid32_t *gidret)
d1171 1
a1171 1
  __uid16_t uid = cygsid(owner_sid).get_uid ();
d1282 1
a1282 1
		    int *attribute, __uid16_t *uidret, __gid32_t *gidret)
d1295 1
a1295 1
    *uidret = getuid ();
d1353 1
a1353 1
alloc_sd (__uid16_t uid, __gid32_t gid, const char *logsrv, int attribute,
d1370 1
a1370 1
  struct passwd *pw = getpwuid (uid);
d1615 1
a1615 1
  psa->lpSecurityDescriptor = alloc_sd (geteuid (), getegid32 (),
d1622 1
a1622 1
set_nt_attribute (const char *file, __uid16_t uid, __gid32_t gid,
d1648 1
a1648 1
		    __uid16_t uid, __gid32_t gid,
@


1.95
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@d1615 1
a1615 1
  psa->lpSecurityDescriptor = alloc_sd (geteuid (), getegid (),
@


1.94
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d459 1
a459 1
  struct __group16 *gr;
d1133 1
a1133 1
		  __uid16_t *uidret, __gid16_t *gidret)
d1172 1
a1172 1
  __gid16_t gid = cygsid(group_sid).get_gid ();
d1282 1
a1282 1
		    int *attribute, __uid16_t *uidret, __gid16_t *gidret)
d1297 1
a1297 1
    *gidret = getgid ();
d1353 1
a1353 1
alloc_sd (__uid16_t uid, __gid16_t gid, const char *logsrv, int attribute,
d1381 1
a1381 1
  struct __group16 *grp = getgrgid (gid);
d1622 1
a1622 1
set_nt_attribute (const char *file, __uid16_t uid, __gid16_t gid,
d1648 1
a1648 1
		    __uid16_t uid, __gid16_t gid,
@


1.93
log
@	* security.cc (lsa2str): New function.
	(get_priv_list): Call lsa2str instead of sys_wcstombs.
@
text
@d864 1
a864 1
      if (psa->lpSecurityDescriptor && 
d868 1
a868 1
          debug_printf ("SetSecurityDescriptorGroup %E");
d871 5
a875 5
                             SecurityImpersonation, TokenPrimary, &primary_token))
        {
          __seterrno ();
          debug_printf ("DuplicateTokenEx %E");
        }
@


1.92
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d177 9
d641 1
a641 2
	  sys_wcstombs (buf, privstrs[i].Buffer,
			INTERNET_MAX_HOST_NAME_LENGTH + 1);
@


1.91
log
@	* security.cc (create_token): Call __sec_user() instead of
	sec_user() to remove dependence on allow_ntsec. Verify that
	the returned sd is non-null.
@
text
@a31 1
#include "perprocess.h"
a35 1
#include "sync.h"
@


1.90
log
@        * security.cc (open_local_policy): Initialize lsa to
	INVALID_HANDLE_VALUE instead of NULL.
	(get_logon_server_and_user_domain): Test for INVALID_HANDLE_VALUE
	instead of NULL.
	(create_token): Both of the above.
@
text
@d857 5
a861 4
      psa = sec_user (sa_buf, usersid);
      if (!SetSecurityDescriptorGroup (
                   (PSECURITY_DESCRIPTOR) psa->lpSecurityDescriptor,
                   special_pgrp?pgrpsid:well_known_null_sid, FALSE))
@


1.89
log
@	* fhandler_raw.cc (fhandler_dev_raw::open): Replace set_errno()
	by __seterrno_from_win_error().
	* security.cc (open_local_policy): Ditto.
	(get_lsa_srv_inf): Ditto.
	(get_user_groups): Ditto.
	(get_user_primary_group): Ditto.
	(create_token): Ditto.
	(subauth): Ditto.
@
text
@d183 1
a183 1
  LSA_HANDLE lsa = NULL;
d261 1
a261 1
  if (lsa)
d726 1
a726 1
  LSA_HANDLE lsa = NULL;
d767 1
a767 1
  if (!(lsa = open_local_policy ()))
@


1.88
log
@	* syscalls.cc (seteuid): Set default dacl in process token.
	Replace in-line code by call to verify_token().
	(setegid): Reverse change from 2002-01-21. Add call to
	RevertToSelf and set primary group in impersonation token.
	* security.cc (create_token): Store pgrpsid in token security
	descriptor, except if it already appears in my_grps.
	Use sec_acl() in place of get_dacl().
	(verify_token): Create from code in seteuid(), with tighter checks.
	(get_dacl) Deleted.
	(get_group_sidlist): Add argument to indicate if pgrpsid is already
	in the groups.
	* security.h: Define verify_token().
	* autoload.cc: Load GetKernelObjectSecurity().
@
text
@d187 1
a187 1
    set_errno (LsaNtStatusToWinError (ret));
d213 1
a213 1
      set_errno (LsaNtStatusToWinError(ret));
d221 1
a221 1
      set_errno (LsaNtStatusToWinError(ret));
d285 1
a285 2
      debug_printf ("%d = NetUserGetGroups ()", ret);
      set_errno (ret);
d358 1
a358 2
      debug_printf ("%d = NetLocalGroupEnum ()", ret);
      set_errno (ret);
d435 1
a435 2
      debug_printf ("%d = NetUserGetInfo ()", ret);
      set_errno (ret);
d848 1
a848 1
    set_errno (RtlNtStatusToDosError (ret));
d929 1
a929 1
      set_errno (LsaNtStatusToWinError(ret));
d943 1
a943 1
      set_errno (LsaNtStatusToWinError(ret));
d972 1
a972 1
      set_errno (LsaNtStatusToWinError(ret));
@


1.87
log
@	* security.cc (get_lsa_srv_inf): Prevent extraneous backslashes for
	the NT Domain case.
@
text
@d479 2
a480 1
		   PTOKEN_GROUPS my_grps, LUID auth_luid, int &auth_pos)
d537 1
d539 5
a543 1
    get_user_primary_group (wserver, user, usersid, pgrpsid);
a546 2
  if (!grp_list.contains (pgrpsid))
    grp_list += pgrpsid;
d553 3
d673 5
a677 2
#define token_acl_size (sizeof (ACL) + \
			2 * (sizeof (ACCESS_ALLOWED_ACE) + MAX_SID_LEN))
d679 1
a679 4
static BOOL
get_dacl (PACL acl, cygsid usersid, cygsidlist &grp_list)
{
  if (!InitializeAcl(acl, token_acl_size, ACL_REVISION))
d681 27
a707 2
      __seterrno ();
      return FALSE;
d709 14
a722 21
  if (grp_list.contains (well_known_admins_sid))
    {
      if (!AddAccessAllowedAce(acl, ACL_REVISION, GENERIC_ALL,
			       well_known_admins_sid))
	{
	  __seterrno ();
	  return FALSE;
	}
    }
  else if (!AddAccessAllowedAce(acl, ACL_REVISION, GENERIC_ALL, usersid))
    {
      __seterrno ();
      return FALSE;
    }
  if (!AddAccessAllowedAce(acl, ACL_REVISION, GENERIC_ALL,
			   well_known_system_sid))
    {
      __seterrno ();
      return FALSE;
    }
  return TRUE;
d739 2
d750 1
a750 1
  char acl_buf[token_acl_size];
d816 1
a816 1
			  my_grps, auth_luid, auth_pos))
d841 2
a842 1
  if (!get_dacl ((PACL) acl_buf, usersid, grpsids))
d857 16
a872 5

  /* Convert to primary token. */
  if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, sec_user (sa_buf, usersid),
			 SecurityImpersonation, TokenPrimary, &primary_token))
    __seterrno ();
@


1.86
log
@	* autoload.cc (NetGetDCName): Add symbol.
	(NetServerEnum): Remove symbol.
	* security.cc (get_lsa_srv_inf): Call NetGetDCName() instead of
	NetServerEnum() since it's faster.  Don't call it at all if machine
	is not a domain member.
@
text
@d233 1
d240 2
a246 2
  strcpy (logonserver, "\\\\");
  strcat (logonserver, name);
@


1.85
log
@* fork.cc (fork_parent): Use sec_user_nih to control process/thread
inheritance/permission.
* spawn.cc (spawn_guts): Ditto.
* security.cc (create_token): Initialize token so that it is not tested for
bogus value later.  Use sec_user to control process/thread creation.
* security.h (__sec_user): Rename declaration from sec_user.
(sec_user_nih): Declare here as inline function wrapper for __sec_user.
(sec_user): Ditto.
* sigproc.cc (czombies): Allocate a character array for zombies to avoid
constructor overhead
(extremely hackish, I know).
(cpchildren): Ditto.
(pchildren): New define.
(zombies): Ditto.
(getsem): Use sec_user_nih to control semaphore inheritance/permission.
@
text
@d203 1
a203 2
  LPSERVER_INFO_101 buf;
  DWORD cnt, tot;
d226 5
a230 3
  if ((ret = NetServerEnum (NULL, 101, (LPBYTE *) &buf, MAX_PREFERRED_LENGTH,
			    &cnt, &tot, SV_TYPE_DOMAIN_CTRL, primary, NULL))
      == STATUS_SUCCESS && cnt > 0)
d232 1
a232 1
      sys_wcstombs (name, buf[0].sv101_name, INTERNET_MAX_HOST_NAME_LENGTH + 1);
@


1.84
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d729 1
a729 1
  HANDLE token;
@


1.83
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.82
log
@	* security.cc (create_token): Use sec_user() to create
	SECURITY_ATTRIBUTES structure for primary token.
@
text
@a44 1

d453 1
a453 1
  struct group *gr;
d1088 1
a1088 1
		  uid_t *uidret, gid_t *gidret)
d1126 2
a1127 2
  uid_t uid = cygsid(owner_sid).get_uid ();
  gid_t gid = cygsid(group_sid).get_gid ();
d1237 1
a1237 1
		    int *attribute, uid_t *uidret, gid_t *gidret)
d1308 1
a1308 1
alloc_sd (uid_t uid, gid_t gid, const char *logsrv, int attribute,
d1336 1
a1336 1
  struct group *grp = getgrgid (gid);
d1577 1
a1577 1
set_nt_attribute (const char *file, uid_t uid, gid_t gid,
d1603 1
a1603 1
		    uid_t uid, gid_t gid,
@


1.81
log
@	* security.cc (create_token): Close processes token handle as soon
	as it's not used anymore.
@
text
@d713 1
a713 1
  SECURITY_ATTRIBUTES sa = { sizeof sa, NULL, TRUE };
d830 2
a831 3
  if (!DuplicateTokenEx (token, TOKEN_ALL_ACCESS, &sa,
			 SecurityImpersonation, TokenPrimary,
			 &primary_token))
@


1.80
log
@	* security.cc (open_local_policy): Use POLICY_EXECUTE instead of
	enumerating user rights.
@
text
@d782 1
@


1.79
log
@	* security.cc (open_local_policy): Initialize lsa handle to NULL.
	Request only needed access rights in call to LsaOpenPolicy().
	(create_token): Check for NULL lsa pointer.
@
text
@d186 1
a186 2
  NTSTATUS ret = LsaOpenPolicy(NULL, &oa, POLICY_VIEW_LOCAL_INFORMATION
  					  | POLICY_LOOKUP_NAMES, &lsa);
@


1.78
log
@Eliminate excess whitespace.
@
text
@d184 1
a184 1
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;
d186 2
a187 1
  NTSTATUS ret = LsaOpenPolicy(NULL, &oa, POLICY_ALL_ACCESS, &lsa);
d743 1
a743 1
  if ((lsa = open_local_policy ()) == INVALID_HANDLE_VALUE)
@


1.77
log
@	* security.cc (get_supplementary_group_sidlist): New function.
	(get_group_sidlist): Call get_supplementary_group_sidlist() to
	retrieve list of supplementary groups SIDs from /etc/group and
	add them to the user's group list.
@
text
@d545 1
a545 1
        if (!grp_list.contains (sup_list.sids[i]))
@


1.76
log
@	* security.cc (is_group_member): Call NetLocalGroupGetMembers() for
	local machine only.
	(get_user_local_groups): Ditto for NetLocalGroupEnum().
@
text
@d451 24
d486 1
d542 6
@


1.75
log
@	* autoload.cc: Add load statement for `NtOpenFile'.
	* fhandler.h (fhandler_dev_raw::get_unit): New method.
	(fhandler_dev_tape::norewind): Eliminate.
	(fhandler_dev_tape::is_rewind_device): New method.
	* fhandler_raw.cc (fhandler_dev_raw::open): Open new
	fixed device name devices using NT internal method.
	Keep calling fhandler_base::open() for old mount table
	device mapping compatibility devices.
	(fhandler_dev_raw::fstat): Eliminate.  Settings are done
	by fhandler_base::fstat() already.
	* fhandler_tape.cc: Remove `norewind' usage throughout.
	* ntdll.h: Define FILE_SYNCHRONOUS_IO_NONALERT.
	Define struct _IO_STATUS_BLOCK.
	Declare NtOpenFile().
	* path.cc (get_raw_device_number): Add new approach for
	using fixed device names.
	(win32_device_name): Ditto.
	(get_device_number): Ditto.  Require POSIX path to begin
	with "/dev/".
	(mount_info::conv_to_win32_path): Call win32_device_name()
	instead of get_device_number() after evaluating mount points
	to allow changing the win32 destination path again.
	* security.cc (str2buf2uni): Remove `static' to be able to
	call function from fhandler_dev_raw::open().
	* wincap.cc: Set flag has_raw_devices appropriately.
	* wincap.h: Add flag has_raw_devices.
@
text
@d329 1
a329 1
  ret = NetLocalGroupGetMembers (wlogonserver, wgroup, 0, (LPBYTE *) &buf,
a330 3
  if (ret == ERROR_BAD_NETPATH || ret == RPC_S_SERVER_UNAVAILABLE)
    ret = NetLocalGroupGetMembers (NULL, wgroup, 0, (LPBYTE *) &buf,
				   MAX_PREFERRED_LENGTH, &cnt, &tot, NULL);
d354 1
a354 1
  ret = NetLocalGroupEnum (wlogonserver, 0, (LPBYTE *) &buf,
a355 3
  if (ret == ERROR_BAD_NETPATH || ret == RPC_S_SERVER_UNAVAILABLE)
    ret = NetLocalGroupEnum (NULL, 0, (LPBYTE *) &buf,
			     MAX_PREFERRED_LENGTH, &cnt, &tot, NULL);
@


1.74
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d160 1
a160 1
static void
@


1.74.2.1
log
@Merged changes from HEAD
@
text
@d160 1
a160 1
void
d184 1
a184 1
  LSA_HANDLE lsa = NULL;
d186 1
a186 1
  NTSTATUS ret = LsaOpenPolicy(NULL, &oa, POLICY_EXECUTE, &lsa);
d329 1
a329 1
  ret = NetLocalGroupGetMembers (NULL, wgroup, 0, (LPBYTE *) &buf,
d331 3
d357 1
a357 1
  ret = NetLocalGroupEnum (NULL, 0, (LPBYTE *) &buf,
d359 3
a456 24
static int
get_supplementary_group_sidlist (const char *username, cygsidlist &grp_list)
{
  struct group *gr;
  int cnt = 0;

  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
    {
      if (gr->gr_mem)
	for (int gi = 0; gr->gr_mem[gi]; ++gi)
	  if (strcasematch (username, gr->gr_mem[gi]))
	    {
	      if (gr->gr_passwd && *gr->gr_passwd)
		{
		  cygsid sid (gr->gr_passwd);
		  if ((PSID)sid && grp_list.add (sid))
		    ++cnt;
		}
	      break;
	    }
    }
  return cnt;
}

a467 1
  cygsidlist sup_list;
a522 6
  if (get_supplementary_group_sidlist (user, sup_list))
    {
      for (int i = 0; i < sup_list.count; ++i)
	if (!grp_list.contains (sup_list.sids[i]))
	  grp_list += sup_list.sids[i];
    }
d717 1
a717 1
  if (!(lsa = open_local_policy ()))
@


1.74.2.2
log
@Merged changes from HEAD
@
text
@a781 1
      CloseHandle (my_token);
@


1.74.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d45 1
d454 1
a454 1
  struct __group16 *gr;
d713 1
a713 1
  char sa_buf[1024];
d730 1
a730 1
  HANDLE token = INVALID_HANDLE_VALUE;
d830 3
a832 2
  if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, sec_user (sa_buf, usersid),
			 SecurityImpersonation, TokenPrimary, &primary_token))
d1090 1
a1090 1
		  __uid16_t *uidret, __gid16_t *gidret)
d1128 2
a1129 2
  __uid16_t uid = cygsid(owner_sid).get_uid ();
  __gid16_t gid = cygsid(group_sid).get_gid ();
d1239 1
a1239 1
		    int *attribute, __uid16_t *uidret, __gid16_t *gidret)
d1310 1
a1310 1
alloc_sd (__uid16_t uid, __gid16_t gid, const char *logsrv, int attribute,
d1338 1
a1338 1
  struct __group16 *grp = getgrgid (gid);
d1579 1
a1579 1
set_nt_attribute (const char *file, __uid16_t uid, __gid16_t gid,
d1605 1
a1605 1
		    __uid16_t uid, __gid16_t gid,
@


1.74.2.4
log
@Merged changes from HEAD
@
text
@d32 1
d37 2
d52 2
a53 1
extern "C" void
d106 2
a107 1
extern "C" HANDLE
a167 1
#if 0 //unused
a177 10
#endif

static void
lsa2str (char *tgt, LSA_UNICODE_STRING &src, int size)
{
  if (src.Length / 2 < size)
    size = src.Length / 2;
  sys_wcstombs (tgt, src.Buffer, size);
  tgt[size] = 0;
}
d183 1
a183 1
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;
d187 1
a187 1
    __seterrno_from_win_error (LsaNtStatusToWinError (ret));
a198 1
#if 0 // unused
d203 2
a204 1
  WCHAR *buf;
d214 1
a214 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d222 1
a222 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d227 3
a229 5
  /* If the SID given in the primary domain info is NULL, the machine is
     not member of a domain.  The name in the primary domain info is the
     name of the workgroup then. */
  if (pdi->Sid &&
      (ret = NetGetDCName(NULL, primary, (LPBYTE *) &buf)) == STATUS_SUCCESS)
d231 1
a231 2
      sys_wcstombs (name, buf, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      strcpy (logonserver, name);
a237 2
      strcpy (logonserver, "\\\\");
      strcat (logonserver, name);
d243 2
d247 6
a252 1
#endif
d255 1
a255 1
get_logon_server (const char *domain, char *server, WCHAR *wserver)
d257 3
a259 7
  WCHAR wdomain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  NET_API_STATUS ret;
  WCHAR * buf;
  DWORD size = INTERNET_MAX_HOST_NAME_LENGTH + 1;

  if ((GetComputerName (server + 2, &size)) &&
      strcasematch (domain, server + 2))
d261 2
a262 4
      server[0] = server[1] = '\\';
      if (wserver)
        sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      return TRUE;
d264 1
a264 13

  /* Try to get the primary domain controller for the domain */
  sys_mbstowcs (wdomain, domain, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  if ((ret = NetGetDCName (NULL, wdomain, (LPBYTE *) &buf)) == STATUS_SUCCESS)
    {
      sys_wcstombs (server, buf, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      if (wserver)
	for (WCHAR * ptr1 = buf; (*wserver++ = *ptr1++); ) {}
      NetApiBufferFree (buf);
      return TRUE;
    }
  __seterrno_from_win_error (ret);
  return FALSE;
d268 1
a268 1
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user, char * domain)
a269 1
  char dgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
d273 1
a273 1
  DWORD cnt, tot, len;
a275 1
  /* Look only on logonserver */
d278 3
d283 2
a284 1
      __seterrno_from_win_error (ret);
a288 4
  len = strlen(domain);
  strcpy(dgroup, domain);
  dgroup[len++] = '\\';

d292 1
a292 1
      DWORD glen = sizeof (gsid);
d294 2
a295 1
      DWORD dlen = sizeof (domain);
d298 15
a312 7
      sys_wcstombs (dgroup + len, buf[i].grui0_name, GNLEN + 1);
      if (!LookupAccountName (NULL, dgroup, gsid, &glen, domain, &dlen, &use))
	  debug_printf ("LookupAccountName(%s): %E", dgroup);
      else if (legal_sid_type (use))
	  grp_list += gsid;
      else debug_printf("Global group %s invalid. Domain: %s Use: %d",
			dgroup, domain, use);
d320 2
a321 1
is_group_member (WCHAR *wgroup, PSID pusersid, cygsidlist &grp_list)
a327 1
  /* Members can be users or global groups */
d334 1
a334 1
    if (EqualSid (pusersid, buf[bidx].lgrmi0_sid))
d346 2
a347 1
get_user_local_groups (cygsidlist &grp_list, PSID pusersid)
d357 2
a358 1
      __seterrno_from_win_error (ret);
a361 11
  char bgroup[sizeof ("BUILTIN\\") + GNLEN] = "BUILTIN\\";
  char lgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
  const DWORD blen = sizeof ("BUILTIN\\") - 1;
  DWORD llen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  if (!GetComputerNameA(lgroup, & llen))
    {
       __seterrno();
       return FALSE;
    }
  lgroup[llen++] = '\\';

d363 1
a363 1
    if (is_group_member (buf[i].lgrpi0_name, pusersid, grp_list))
d366 1
a366 1
	DWORD glen = sizeof (gsid);
d368 2
a369 1
	DWORD dlen = sizeof (domain);
d372 11
a382 2
	sys_wcstombs (bgroup + blen, buf[i].lgrpi0_name, GNLEN + 1);
	if (!LookupAccountName (NULL, bgroup, gsid, &glen, domain, &dlen, &use))
d384 9
a392 6
	     if (GetLastError () != ERROR_NONE_MAPPED)
		 debug_printf ("LookupAccountName(%s): %E", bgroup);
	     strcpy(lgroup + llen, bgroup + blen);
	     if (!LookupAccountName (NULL, lgroup, gsid, &glen,
				     domain, &dlen, &use))
		 debug_printf ("LookupAccountName(%s): %E", lgroup);
a395 1
	else debug_printf("Rejecting local %s. use: %d", bgroup + blen, use);
d415 1
a415 1
			PSID pusersid, cygsid &pgrpsid)
d423 1
a423 1
  if (pusersid == well_known_system_sid)
d431 2
d435 2
a436 1
      __seterrno_from_win_error (ret);
d440 1
a440 1
  pgrpsid = pusersid;
d453 1
a453 1
  struct __group32 *gr;
d475 1
a475 1
get_group_sidlist (cygsidlist &grp_list,
d477 1
a477 2
		   PTOKEN_GROUPS my_grps, LUID auth_luid, int &auth_pos,
		   BOOL * special_pgrp)
d479 2
a480 1
  char user[UNLEN + 1];
d482 2
a483 4
  WCHAR wserver[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  char server[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  DWORD ulen = sizeof (user);
  DWORD dlen = sizeof (domain);
d488 1
a494 1

a502 2
      if (!get_logon_server (domain, server, wserver))
        return FALSE;
a532 3
      if (!get_user_groups (wserver, grp_list, user, domain) ||
          !get_user_local_groups (grp_list, usersid))
        return FALSE;
a533 1
  /* special_pgrp true if pgrpsid is not null and not in normal groups */
d535 6
a540 5
    {
      * special_pgrp = FALSE;
      get_user_primary_group (wserver, user, usersid, pgrpsid);
    }
  else * special_pgrp = TRUE;
a546 3
  if (!grp_list.contains (pgrpsid))
    grp_list += pgrpsid;
  else * special_pgrp = FALSE;
d628 2
a629 1
	  lsa2str (buf, privstrs[i], sizeof(buf) - 1);
d664 5
a668 2
BOOL
verify_token (HANDLE token, cygsid &usersid, cygsid &pgrpsid, BOOL * pintern)
d670 21
a690 4
  DWORD size;
  BOOL intern = FALSE;

  if (pintern)
d692 2
a693 27
      TOKEN_SOURCE ts;
      if (!GetTokenInformation (cygheap->user.token, TokenSource,
				&ts, sizeof ts, &size))
	debug_printf ("GetTokenInformation(): %E");
      else *pintern = intern = !memcmp (ts.SourceName, "Cygwin.1", 8);
    }
  /* Verify usersid */
  cygsid tok_usersid = NO_SID;
  if (!GetTokenInformation (token, TokenUser,
			    &tok_usersid, sizeof tok_usersid, &size))
      debug_printf ("GetTokenInformation(): %E");
  if (usersid != tok_usersid) return FALSE;

  /* In an internal token, if the sd group is not well_known_null_sid,
     it must match pgrpsid */
  if (intern)
    {
       char sd_buf[MAX_SID_LEN + sizeof (SECURITY_DESCRIPTOR)];
       PSID gsid = NO_SID;
       if (!GetKernelObjectSecurity(token, GROUP_SECURITY_INFORMATION,
				    (PSECURITY_DESCRIPTOR) sd_buf,
				    sizeof sd_buf, &size))
	   debug_printf ("GetKernelObjectSecurity(): %E");
       else if (!GetSecurityDescriptorGroup((PSECURITY_DESCRIPTOR) sd_buf,
					    &gsid, (BOOL *) &size))
	   debug_printf ("GetSecurityDescriptorGroup(): %E");
       if (well_known_null_sid != gsid) return pgrpsid == gsid;
d695 1
a695 14
  /* See if the pgrpsid is in the token groups */
  PTOKEN_GROUPS my_grps = NULL;
  BOOL ret = FALSE;

  if (!GetTokenInformation (token, TokenGroups, NULL, 0, &size) &&
	  GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(token, TokenGroups): %E\n");
  else if (!(my_grps = (PTOKEN_GROUPS) malloc (size)))
	debug_printf ("malloc (my_grps) failed.");
  else if (!GetTokenInformation (token, TokenGroups, my_grps, size, &size))
	debug_printf ("GetTokenInformation(my_token, TokenGroups): %E\n");
  else 	ret = sid_in_token_groups (my_grps, pgrpsid);
  if (my_grps) free (my_grps);
  return ret;
d702 2
a703 1
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;
a711 2
  PSECURITY_ATTRIBUTES psa;
  BOOL special_pgrp;
d721 1
a721 1
  char acl_buf[MAX_DACL_LEN(5)];
d741 5
a745 1
  if ((lsa = open_local_policy ()) == INVALID_HANDLE_VALUE)
d786 2
a787 2
  if (!get_group_sidlist (grpsids, usersid, pgrpsid,
			  my_grps, auth_luid, auth_pos, &special_pgrp))
d812 1
a812 2
  if (!sec_acl((PACL) acl_buf, FALSE,
		grpsids.contains (well_known_admins_sid)?well_known_admins_sid:usersid))
d821 1
a821 1
    __seterrno_from_win_error (RtlNtStatusToDosError (ret));
d827 5
a831 17
  else
    {
      /* Set security descriptor and primary group */
      psa = __sec_user (sa_buf, usersid, TRUE);
      if (psa->lpSecurityDescriptor &&
	  !SetSecurityDescriptorGroup (
	      (PSECURITY_DESCRIPTOR) psa->lpSecurityDescriptor,
	      special_pgrp?pgrpsid:well_known_null_sid, FALSE))
	  debug_printf ("SetSecurityDescriptorGroup %E");
      /* Convert to primary token. */
      if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, psa,
			     SecurityImpersonation, TokenPrimary, &primary_token))
	{
	  __seterrno ();
	  debug_printf ("DuplicateTokenEx %E");
	}
    }
d891 1
a891 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d905 1
a905 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d934 1
a934 1
      __seterrno_from_win_error (LsaNtStatusToWinError(ret));
d1088 1
a1088 1
		  __uid32_t *uidret, __gid32_t *gidret)
d1126 2
a1127 2
  __uid32_t uid = cygsid(owner_sid).get_uid ();
  __gid32_t gid = cygsid(group_sid).get_gid ();
d1237 1
a1237 1
		    int *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1250 1
a1250 1
    *uidret = getuid32 ();
d1252 1
a1252 1
    *gidret = getgid32 ();
d1308 1
a1308 1
alloc_sd (__uid32_t uid, __gid32_t gid, int attribute,
d1325 1
a1325 1
  struct passwd *pw = getpwuid32 (uid);
d1327 2
a1328 1
  if (!pw || !owner_sid.getfrompw (pw))
d1336 1
a1336 1
  struct __group32 *grp = getgrgid32 (gid);
d1339 2
a1340 1
      if (!grp || !group_sid.getfromgr (grp))
d1570 2
a1571 1
  psa->lpSecurityDescriptor = alloc_sd (geteuid32 (), getegid32 (),
d1577 2
a1578 2
set_nt_attribute (const char *file, __uid32_t uid, __gid32_t gid,
		  int attribute)
d1595 1
a1595 1
  if (!(psd = alloc_sd (uid, gid, attribute, psd, &sd_size)))
d1603 2
a1604 2
		    __uid32_t uid, __gid32_t gid,
		    int attribute)
d1609 1
a1609 1
    ret = set_nt_attribute (file, uid, gid, attribute);
d1626 1
a1626 1
			     attribute);
@


1.74.2.5
log
@Merged changes from HEAD
@
text
@d151 1
a151 1
  memcpy (buf, srcstr, tgt.MaximumLength);
d158 1
a158 1
  tgt.MaximumLength = tgt.Length + sizeof (WCHAR);
d191 1
a191 1
  NTSTATUS ret = LsaOpenPolicy (NULL, &oa, POLICY_EXECUTE, &lsa);
d220 1
a220 1
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
d228 1
a228 1
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
d237 1
a237 1
      (ret = NetGetDCName (NULL, primary, (LPBYTE *) &buf)) == STATUS_SUCCESS)
d309 2
a310 2
  len = strlen (domain);
  strcpy (dgroup, domain);
d326 1
a326 1
      else debug_printf ("Global group %s invalid. Domain: %s Use: %d",
d381 1
a381 1
       __seterrno ();
d400 1
a400 1
	     strcpy (lgroup + llen, bgroup + blen);
d407 1
a407 1
	else debug_printf ("Rejecting local %s. use: %d", bgroup + blen, use);
d647 1
a647 1
	  lsa2str (buf, privstrs[i], sizeof (buf) - 1);
d709 1
a709 1
       if (!GetKernelObjectSecurity (token, GROUP_SECURITY_INFORMATION,
d713 1
a713 1
       else if (!GetSecurityDescriptorGroup ((PSECURITY_DESCRIPTOR) sd_buf,
d723 2
a724 2
      GetLastError () != ERROR_INSUFFICIENT_BUFFER)
    debug_printf ("GetTokenInformation(token, TokenGroups): %E\n");
d726 1
a726 1
    debug_printf ("malloc (my_grps) failed.");
d728 3
a730 5
    debug_printf ("GetTokenInformation(my_token, TokenGroups): %E\n");
  else
    ret = sid_in_token_groups (my_grps, pgrpsid);
  if (my_grps)
    free (my_grps);
d762 1
a762 1
  memcpy (source.SourceName, "Cygwin.1", 8);
d787 1
a787 1
  if (!OpenProcessToken (hMainProc, TOKEN_QUERY, &my_token))
d845 1
a845 1
  if (!sec_acl ((PACL) acl_buf, FALSE,
d927 1
a927 1
  if ((old_tcb_state = set_process_privilege (SE_TCB_NAME)) < 0)
d933 1
a933 1
  ret = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);
d937 1
a937 1
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
d947 1
a947 1
  ret = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);
d951 2
a952 2
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      LsaDeregisterLogonProcess (lsa_hdl);
d958 1
a958 1
  memcpy (ts.SourceName, "Cygwin.1", 8);
d965 6
a970 6
  str2buf2uni (subbuf.auth.LogonDomainName, subbuf.dombuf, nt_domain);
  str2buf2uni (subbuf.auth.UserName, subbuf.usrbuf, nt_user);
  str2buf2uni (subbuf.auth.Workstation, subbuf.wkstbuf, "");
  memcpy (subbuf.auth.ChallengeToClient, "12345678", MSV1_0_CHALLENGE_LENGTH);
  str2buf2lsa (subbuf.auth.CaseSensitiveChallengeResponse, subbuf.authinf1, "");
  str2buf2lsa (subbuf.auth.CaseInsensitiveChallengeResponse, subbuf.authinf2,"");
d973 1
a973 1
  ret = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Network,
d980 2
a981 2
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
      LsaDeregisterLogonProcess (lsa_hdl);
d984 1
a984 1
  LsaFreeReturnBuffer (profile);
d992 1
a992 1
  set_process_privilege (SE_TCB_NAME, old_tcb_state);
d1015 1
a1015 1
read_sd (const char *file, PSECURITY_DESCRIPTOR sd_buf, LPDWORD sd_size)
d1024 1
a1024 1
  debug_printf ("file = %s", file);
d1033 1
a1033 1
      OemToCharBuff (file, fbuf, fname_len);
d1046 1
a1046 1
  debug_printf ("file = %s: len=%d", file, len);
d1056 1
a1056 1
write_sd (const char *file, PSECURITY_DESCRIPTOR sd_buf, DWORD sd_size)
d1172 2
a1173 2
  __uid32_t uid = cygsid (owner_sid).get_uid ();
  __gid32_t gid = cygsid (group_sid).get_gid ();
d1329 1
a1329 1
  if (GetAce (acl, offset, (PVOID *) &ace))
d1346 1
a1346 1
  if (GetAce (acl, offset, (PVOID *) &ace))
d1376 2
a1377 2
		*GetSidSubAuthority (owner_sid,
		*GetSidSubAuthorityCount (owner_sid) - 1));
d1409 1
a1409 1
  if (!SetSecurityDescriptorOwner (&sd, owner_sid, FALSE))
d1416 1
a1416 1
  if (group_sid && !SetSecurityDescriptorGroup (&sd, group_sid, FALSE))
d1562 1
a1562 1
	  if (!AddAce (acl, ACL_REVISION,
@


1.74.2.6
log
@Merged changes from HEAD
@
text
@d271 1
a271 1
	sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d515 1
a515 1
	return FALSE;
d547 2
a548 2
	  !get_user_local_groups (grp_list, usersid))
	return FALSE;
@


1.74.2.7
log
@Merged changes from HEAD
@
text
@d1370 10
a1379 25
  /* Get SID of owner. */
  cygsid owner_sid (NO_SID);
  /* Check for current user first */
  if (uid == myself->uid)
    owner_sid = cygheap->user.sid ();
  else if (uid == cygheap->user.orig_uid)
    owner_sid = cygheap->user.orig_sid ();
  if (!owner_sid)
    {
      /* Otherwise retrieve user data from /etc/passwd */
      struct passwd *pw = getpwuid32 (uid);
      if (!pw)
        {
	  debug_printf ("no /etc/passwd entry for %d", uid);
	  set_errno (EINVAL);
	  return NULL;
	}
      else if (!owner_sid.getfrompw (pw))
        {
	  debug_printf ("no SID for user %d", uid);
	  set_errno (EINVAL);
	  return NULL;
	}
    }
  owner_sid.debug_print ("alloc_sd: owner SID =");
d1381 1
a1381 1
  /* Get SID of new group. */
d1384 7
a1390 4
  if (!grp)
    debug_printf ("no /etc/group entry for %d", gid);
  else if (!group_sid.getfromgr (grp))
    debug_printf ("no SID for group %d", gid);
@


1.74.2.8
log
@Merged changes from HEAD
@
text
@d485 1
a485 1
		  cygsid &usersid, cygsid &pgrpsid, struct passwd * pw,
d557 1
a557 1
  if (pw->pw_name && get_supplementary_group_sidlist (pw->pw_name, sup_list))
d737 1
a737 1
create_token (cygsid &usersid, cygsid &pgrpsid, struct passwd * pw)
d821 1
a821 1
  if (!get_group_sidlist (grpsids, usersid, pgrpsid, pw,
d1382 1
a1382 1
	{
d1388 1
a1388 1
	{
@


1.74.2.9
log
@Merged changes from HEAD
@
text
@d63 6
a68 1
  char *d, *u, *c;
d70 2
a71 2
  domain[0] = 0;
  strlcpy (user, pw->pw_name, UNLEN+1);
d74 5
a78 2
  if ((d = strstr (pw->pw_gecos, "U-")) != NULL &&
      (d == pw->pw_gecos || d[-1] == ','))
d80 19
a98 9
      c = strchr (d + 2, ',');
      if ((u = strchr (d + 2, '\\')) == NULL || (c != NULL && u > c))
	u = d + 1;
      else if (u - d <= INTERNET_MAX_HOST_NAME_LENGTH + 2)
	strlcpy(domain, d + 2, u - d - 1);
      if (c == NULL)
        c = u + UNLEN + 1;
      if (c - u <= UNLEN + 1)
	strlcpy(user, u + 1, c - u);
a99 9
  if (domain[0])
    return;

  cygsid psid;
  DWORD ulen = UNLEN + 1;
  DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  SID_NAME_USE use;
  if (psid.getfrompw (pw))
    LookupAccountSid (NULL, psid, user, &ulen, domain, &dlen, &use);
d493 3
d499 6
a513 1
      extract_nt_dom_user (pw, domain, user);
@


1.74.2.10
log
@Merged changes from HEAD
@
text
@d78 1
a78 1
	c = u + UNLEN + 1;
@


1.74.2.11
log
@Merged changes from HEAD
@
text
@a30 1
#include <aclapi.h>
a256 1
  /* Empty domain is interpreted as local system */
d258 1
a258 1
      (strcasematch (domain, server + 2) || !domain[0]))
d491 1
a491 1
      grp_list += well_known_authenticated_users_sid;
d701 1
a701 1
  /* See if the pgrpsid is the tok_usersid in the token groups */
a704 2
  if ( pgrpsid == tok_usersid)
    return TRUE;
d1189 1
a1189 1
      if (ace->Header.AceFlags & INHERIT_ONLY)
a1303 168
static int
get_nt_object_attribute (HANDLE handle, SE_OBJECT_TYPE object_type, int *attribute,
		  __uid32_t *uidret, __gid32_t *gidret)
{
  if (!wincap.has_security ())
    return 0;

  PSECURITY_DESCRIPTOR psd = NULL;
  PSID owner_sid;
  PSID group_sid;
  PACL acl;

  if (ERROR_SUCCESS != GetSecurityInfo (handle, object_type,
                                        DACL_SECURITY_INFORMATION |
                                        GROUP_SECURITY_INFORMATION |
                                        OWNER_SECURITY_INFORMATION,
                                        &owner_sid,
                                        &group_sid,
                                        &acl,
                                        NULL,
                                        &psd))
	{
	  __seterrno ();
	  debug_printf ("GetSecurityInfo %E");
	  return -1;
    }

  __uid32_t uid = cygsid (owner_sid).get_uid ();
  __gid32_t gid = cygsid (group_sid).get_gid ();
  if (uidret)
    *uidret = uid;
  if (gidret)
    *gidret = gid;

  if (!attribute)
    {
      syscall_printf ("uid %d, gid %d", uid, gid);
      LocalFree (psd);
      return 0;
    }

  BOOL grp_member = is_grp_member (uid, gid);

  if (!acl)
    {
      *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
      syscall_printf ("No ACL = %x, uid %d, gid %d",
		      *attribute, uid, gid);
      LocalFree (psd);
      return 0;
    }

  ACCESS_ALLOWED_ACE *ace;
  int allow = 0;
  int deny = 0;
  int *flags, *anti;

  for (DWORD i = 0; i < acl->AceCount; ++i)
    {
      if (!GetAce (acl, i, (PVOID *) &ace))
	continue;
      if (ace->Header.AceFlags & INHERIT_ONLY)
	continue;
      switch (ace->Header.AceType)
	{
	case ACCESS_ALLOWED_ACE_TYPE:
	  flags = &allow;
	  anti = &deny;
	  break;
	case ACCESS_DENIED_ACE_TYPE:
	  flags = &deny;
	  anti = &allow;
	  break;
	default:
	  continue;
	}

      cygsid ace_sid ((PSID) &ace->SidStart);
      if (owner_sid && ace_sid == owner_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRUSR;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWUSR;
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXUSR;
	}
      else if (group_sid && ace_sid == group_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRGRP
		      | ((grp_member && !(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWGRP
		      | ((grp_member && !(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXGRP
		      | ((grp_member && !(*anti & S_IXUSR)) ? S_IXUSR : 0);
	}
      else if (ace_sid == well_known_world_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IROTH
		      | ((!(*anti & S_IRGRP)) ? S_IRGRP : 0)
		      | ((!(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWOTH
		      | ((!(*anti & S_IWGRP)) ? S_IWGRP : 0)
		      | ((!(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    {
	      *flags |= S_IXOTH
			| ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
			| ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
	    }
	  if ((*attribute & S_IFDIR) &&
	      (ace->Mask & (FILE_WRITE_DATA | FILE_EXECUTE | FILE_DELETE_CHILD))
	      == (FILE_WRITE_DATA | FILE_EXECUTE))
	    *flags |= S_ISVTX;
	}
      else if (ace_sid == well_known_null_sid)
	{
	  /* Read SUID, SGID and VTX bits from NULL ACE. */
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_ISVTX;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_ISGID;
	  if (ace->Mask & FILE_APPEND_DATA)
	    *flags |= S_ISUID;
	}
    }
  *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX | S_ISGID | S_ISUID);
  *attribute |= allow;
  *attribute &= ~deny;

  LocalFree (psd);

  syscall_printf ("%x, uid %d, gid %d", *attribute, uid, gid);
  return 0;
}

int
get_object_attribute (HANDLE handle, SE_OBJECT_TYPE object_type,
		    int *attribute, __uid32_t *uidret, __gid32_t *gidret)
{
  if (allow_ntsec)
    {
      int res = get_nt_object_attribute (handle, object_type, attribute, uidret, gidret);
      if (attribute && (*attribute & S_IFLNK) == S_IFLNK)
	*attribute |= S_IRWXU | S_IRWXG | S_IRWXO;
      return res;
    }

  if (uidret)
    *uidret = getuid32 ();
  if (gidret)
    *gidret = getgid32 ();

  if (!attribute)
    return 0;

  /* symlinks are everything for everyone!*/
  if ((*attribute & S_IFLNK) == S_IFLNK)
    *attribute |= S_IRWXU | S_IRWXG | S_IRWXO;

  return 0;
}

d1498 1
a1498 2
  DWORD inherit = (attribute & S_IFDIR) ? SUB_CONTAINERS_AND_OBJECTS_INHERIT
  					: NO_INHERITANCE;
d1526 1
a1526 1
				  well_known_null_sid, acl_len, NO_INHERITANCE))
@


1.74.2.12
log
@Merged changes from HEAD
@
text
@d255 1
a255 1
  WCHAR *buf;
d274 1
a274 1
	for (WCHAR *ptr1 = buf; (*wserver++ = *ptr1++); ) {}
d283 1
a283 1
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user, char *domain)
d391 6
a396 6
	    if (GetLastError () != ERROR_NONE_MAPPED)
              debug_printf ("LookupAccountName(%s): %E", bgroup);
	    strcpy (lgroup + llen, bgroup + blen);
	    if (!LookupAccountName (NULL, lgroup, gsid, &glen,
				    domain, &dlen, &use))
              debug_printf ("LookupAccountName(%s): %E", lgroup);
d398 1
a398 3
	if (!legal_sid_type (use))
	  debug_printf ("Rejecting local %s. use: %d", bgroup + blen, use);
	else if (!grp_list.contains (gsid))
d400 1
d402 1
a417 1
#if 0 /* Unused */
a450 1
#endif
d452 2
a453 2
static void
get_unix_group_sidlist (struct passwd *pw, cygsidlist &grp_list)
d456 1
a456 1
  cygsid gsid;
d460 1
a460 3
      if (gr->gr_gid == (__gid32_t) pw->pw_gid)
	goto found;
      else if (gr->gr_mem)
d462 10
a471 7
	  if (strcasematch (pw->pw_name, gr->gr_mem[gi]))
	    goto found;
      continue;
    found:
      if (gsid.getfromgr (gr) && !grp_list.contains (gsid))
	grp_list += gsid;

d473 1
d478 1
a478 1
		   cygsid &usersid, cygsid &pgrpsid, struct passwd *pw,
d480 1
a480 1
		   BOOL *special_pgrp)
a490 1
  grp_list += well_known_authenticated_users_sid;
d493 1
a494 1
      get_unix_group_sidlist (pw, grp_list);
d498 3
d515 1
d521 1
d531 2
a532 7
      extract_nt_dom_user (pw, domain, user);
      /* Fail silently if DC is not reachable */
      if (get_logon_server (domain, server, wserver) &&
	  !get_user_groups (wserver, grp_list, user, domain))
	return FALSE;
      get_unix_group_sidlist (pw, grp_list);
      if (!get_user_local_groups (grp_list, usersid))
d536 7
a542 2
  *special_pgrp = FALSE;
  if (pgrpsid && !grp_list.contains (pgrpsid))
d544 3
a546 2
       *special_pgrp = TRUE;
       grp_list += pgrpsid;
d548 3
d668 1
a668 1
verify_token (HANDLE token, cygsid &usersid, cygsid &pgrpsid, BOOL *pintern)
d724 1
a724 1
create_token (cygsid &usersid, cygsid &pgrpsid, struct passwd *pw)
d857 1
a857 1
	      special_pgrp ? pgrpsid : well_known_null_sid, FALSE))
@


1.74.2.13
log
@Merged changes from HEAD
@
text
@d44 1
a44 1
BOOL allow_ntsec = true;
d48 1
a48 1
BOOL allow_smbntsec;
d528 4
a531 2
      if (get_logon_server (domain, server, wserver))
	get_user_groups (wserver, grp_list, user, domain);
@


1.74.2.14
log
@Merged changes from HEAD
@
text
@a49 16
cygsid *
cygsidlist::alloc_sids (int n)
{
  if (n > 0)
    return (cygsid *) cmalloc (HEAP_STR, n * sizeof (cygsid));
  else
    return NULL;
}

void
cygsidlist::free_sids ()
{
  if (sids)
    cfree (sids);
}

d67 1
a67 1
  strlcpy (user, pw->pw_name, UNLEN + 1);
d77 1
a77 1
	strlcpy (domain, d + 2, u - d - 1);
d81 1
a81 1
	strlcpy (user, u + 1, c - u);
d115 3
a117 3
		   LOGON32_LOGON_INTERACTIVE,
		   LOGON32_PROVIDER_DEFAULT,
		   &hToken)
d155 1
a155 1
#if 0				/* unused */
d197 1
a197 1
#if 0 /* unused */
d229 1
a229 2
      (ret =
       NetGetDCName (NULL, primary, (LPBYTE *) &buf)) == STATUS_SUCCESS)
d274 1
a274 2
	for (WCHAR *ptr1 = buf; (*wserver++ = *ptr1++);)
	  ;
d283 1
a283 2
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user,
		 char *domain)
d316 1
a316 1
	debug_printf ("LookupAccountName(%s): %E", dgroup);
d318 3
a320 4
	grp_list += gsid;
      else
	debug_printf ("Global group %s invalid. Domain: %s Use: %d",
		      dgroup, domain, use);
d372 1
a372 1
  if (!GetComputerNameA (lgroup, &llen))
d374 2
a375 2
      __seterrno ();
      return FALSE;
d392 1
a392 1
	      debug_printf ("LookupAccountName(%s): %E", bgroup);
d396 1
a396 1
	      debug_printf ("LookupAccountName(%s): %E", lgroup);
d418 1
a418 1
#if 0				/* Unused */
d444 1
a444 2
  if (IsValidSid (pgrpsid)
      && (count = *GetSidSubAuthorityCount (pgrpsid)) > 1)
d476 12
a487 4
static void
get_token_group_sidlist (cygsidlist &grp_list, PTOKEN_GROUPS my_grps,
			 LUID auth_luid, int &auth_pos)
{
a488 29
  if (my_grps)
    {
      if (sid_in_token_groups (my_grps, well_known_local_sid))
	grp_list += well_known_local_sid;
      if (sid_in_token_groups (my_grps, well_known_dialup_sid))
	grp_list += well_known_dialup_sid;
      if (sid_in_token_groups (my_grps, well_known_network_sid))
	grp_list += well_known_network_sid;
      if (sid_in_token_groups (my_grps, well_known_batch_sid))
	grp_list += well_known_batch_sid;
      if (sid_in_token_groups (my_grps, well_known_interactive_sid))
	grp_list += well_known_interactive_sid;
      if (sid_in_token_groups (my_grps, well_known_service_sid))
	grp_list += well_known_service_sid;
    }
  else
    {
      grp_list += well_known_local_sid;
      grp_list += well_known_interactive_sid;
    }
  if (auth_luid.QuadPart != 999) /* != SYSTEM_LUID */
    {
      char buf[64];
      __small_sprintf (buf, "S-1-5-5-%u-%u", auth_luid.HighPart,
		       auth_luid.LowPart);
      grp_list += buf;
      auth_pos = grp_list.count - 1;
    }
}
a489 6
static BOOL
get_initgroups_sidlist (cygsidlist &grp_list,
			PSID usersid, PSID pgrpsid, struct passwd *pw,
			PTOKEN_GROUPS my_grps, LUID auth_luid, int &auth_pos,
			BOOL &special_pgrp)
{
a493 1
      auth_pos = -1;
d499 28
a526 6
      char user[UNLEN + 1];
      char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      WCHAR wserver[INTERNET_MAX_HOST_NAME_LENGTH + 3];
      char server[INTERNET_MAX_HOST_NAME_LENGTH + 3];

      get_token_group_sidlist (grp_list, my_grps, auth_luid, auth_pos);
d534 7
a540 3
  /* special_pgrp true if pgrpsid is not in normal groups */
  if ((special_pgrp = !grp_list.contains (pgrpsid)))
    grp_list += pgrpsid;
a543 14
static void
get_setgroups_sidlist (cygsidlist &tmp_list, PTOKEN_GROUPS my_grps,
		       user_groups &groups, LUID auth_luid, int &auth_pos)
{
  PSID pgpsid = groups.pgsid;
  tmp_list += well_known_world_sid;
  tmp_list += well_known_authenticated_users_sid;
  get_token_group_sidlist (tmp_list, my_grps, auth_luid, auth_pos);
  for (int gidx = 0; gidx < groups.sgsids.count; gidx++)
    tmp_list += groups.sgsids.sids[gidx];
  if (!groups.sgsids.contains (pgpsid))
    tmp_list += pgpsid;
}

d572 2
a573 2
  PTOKEN_PRIVILEGES privs = (PTOKEN_PRIVILEGES)
    malloc (sizeof (ULONG) + 20 * sizeof (LUID_AND_ATTRIBUTES));
d586 1
a586 1
	  SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
d608 2
a609 2
	  if ((ret = LsaEnumerateAccountRights (lsa, usersid, &privstrs,
						&cnt)) != STATUS_SUCCESS)
d632 2
a633 2
	    realloc (privs, sizeof (ULONG) +
		     (tmp_count + 1) * sizeof (LUID_AND_ATTRIBUTES));
d646 1
a646 1
	    SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
a656 13
/* Accept a token if
   - the requested usersid matches the TokenUser and
   - if setgroups has been called:
        the token groups that are listed in /etc/group match the union of
	the requested primary and supplementary groups in gsids.
   - else the (unknown) implicitly requested supplementary groups and those
        in the token are the groups associated with the usersid. We assume
	they match and verify only the primary groups.
	The requested primary group must appear in the token.
	The primary group in the token is a group associated with the usersid,
	except if the token is internal and the group is in the token SD
	(see create_token). In that latter case that group must match the
	requested primary group.  */
d658 1
a658 1
verify_token (HANDLE token, cygsid &usersid, user_groups &groups, BOOL *pintern)
d669 1
a669 2
      else
	*pintern = intern = !memcmp (ts.SourceName, "Cygwin.1", 8);
d675 2
a676 3
    debug_printf ("GetTokenInformation(): %E");
  if (usersid != tok_usersid)
    return FALSE;
d678 7
a684 7
  /* For an internal token, if setgroups was not called and if the sd group
     is not well_known_null_sid, it must match pgrpsid */
  if (intern && !groups.issetgroups ())
    {
      char sd_buf[MAX_SID_LEN + sizeof (SECURITY_DESCRIPTOR)];
      PSID gsid = NO_SID;
      if (!GetKernelObjectSecurity (token, GROUP_SECURITY_INFORMATION,
d687 2
a688 2
	debug_printf ("GetKernelObjectSecurity(): %E");
      else if (!GetSecurityDescriptorGroup ((PSECURITY_DESCRIPTOR) sd_buf,
d690 2
a691 3
	debug_printf ("GetSecurityDescriptorGroup(): %E");
      if (well_known_null_sid != gsid)
	return gsid == groups.pgsid;
d693 1
a693 1

a695 2
  char saw_buf[NGROUPS_MAX] = {};
  char *saw = saw_buf, sawpg = FALSE;
d697 2
d706 2
a707 33
  else if (!groups.issetgroups ()) /* setgroups was never called */
    {
      ret = sid_in_token_groups (my_grps, groups.pgsid);
      if (ret == FALSE)
	ret = (groups.pgsid == tok_usersid);
    }
  else /* setgroups was called */
    {
      struct __group32 *gr;
      cygsid gsid;
      if (groups.sgsids.count > (int) sizeof (saw_buf) &&
	  !(saw = (char *) calloc (groups.sgsids.count, sizeof (char))))
	goto done;

      /* token groups found in /etc/group match the user.gsids ? */
      for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	if (gsid.getfromgr (gr) && sid_in_token_groups (my_grps, gsid))
	  {
	    int pos = groups.sgsids.position (gsid);
	    if (pos >= 0)
	      saw[pos] = TRUE;
	    else if (groups.pgsid == gsid)
	      sawpg = TRUE;
	    else
	      goto done;
	  }
      for (int gidx = 0; gidx < groups.sgsids.count; gidx++)
	if (!saw[gidx])
	  goto done;
      if (sawpg || groups.sgsids.contains (groups.pgsid))
	ret = TRUE;
    }
done:
a709 2
  if (saw != saw_buf)
    free (saw);
d714 1
a714 1
create_token (cygsid &usersid, user_groups &new_groups, struct passwd *pw)
d720 1
a720 1
  cygsidlist tmp_gsids (cygsidlist_auto, 12);
d724 2
a725 1
  OBJECT_ATTRIBUTES oa = { sizeof oa, 0, 0, 0, 0, &sqos };
d727 1
a727 1
  BOOL special_pgrp = FALSE;
d730 1
a730 1
  LARGE_INTEGER exp = { QuadPart:0x7fffffffffffffffLL };
d733 1
a733 1
  PTOKEN_GROUPS new_tok_gsids = NULL;
d737 1
a737 1
  char acl_buf[MAX_DACL_LEN (5)];
d749 1
a749 1
  PTOKEN_GROUPS my_tok_gsids = NULL;
d771 1
a771 1
         id of the user account running current process. */
d775 1
a775 2
	  debug_printf
	    ("GetTokenInformation(my_token, TokenStatistics): %E\n");
d780 1
a780 1
         some important well known group sids. */
d784 3
a786 3
      else if (!(my_tok_gsids = (PTOKEN_GROUPS) malloc (size)))
	debug_printf ("malloc (my_tok_gsids) failed.");
      else if (!GetTokenInformation (my_token, TokenGroups, my_tok_gsids,
d790 2
a791 2
	  free (my_tok_gsids);
	  my_tok_gsids = NULL;
d798 2
a799 6
  if (new_groups.issetgroups ())
    get_setgroups_sidlist (tmp_gsids, my_tok_gsids, new_groups, auth_luid,
			   auth_pos);
  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid, pw,
				    my_tok_gsids, auth_luid, auth_pos,
				    special_pgrp))
d803 1
a803 1
  pgrp.PrimaryGroup = new_groups.pgsid;
d806 11
a816 8
  char grps_buf[sizeof (ULONG) + tmp_gsids.count * sizeof (SID_AND_ATTRIBUTES)];
  new_tok_gsids = (PTOKEN_GROUPS) grps_buf;
  new_tok_gsids->GroupCount = tmp_gsids.count;
  for (DWORD i = 0; i < new_tok_gsids->GroupCount; ++i)
    {
      new_tok_gsids->Groups[i].Sid = tmp_gsids.sids[i];
      new_tok_gsids->Groups[i].Attributes = SE_GROUP_MANDATORY |
	SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
a817 2
  if (auth_pos >= 0)
    new_tok_gsids->Groups[auth_pos].Attributes |= SE_GROUP_LOGON_ID;
d820 1
a820 1
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids)))
d825 1
a825 2
		tmp_gsids.contains (well_known_admins_sid) ?
		well_known_admins_sid : usersid))
d831 2
a832 2
		       &auth_luid, &exp, &user, new_tok_gsids, privs, &owner,
		       &pgrp, &dacl, &source);
d845 4
a848 6
	  !SetSecurityDescriptorGroup ((PSECURITY_DESCRIPTOR)
				       psa->lpSecurityDescriptor,
				       special_pgrp ? new_groups.pgsid
						    : well_known_null_sid,
				       FALSE))
	debug_printf ("SetSecurityDescriptorGroup %E");
d850 2
a851 2
      if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, psa, SecurityImpersonation,
			     TokenPrimary, &primary_token))
d865 2
a866 2
  if (my_tok_gsids)
    free (my_tok_gsids);
d949 1
a949 1
  str2buf2lsa (subbuf.auth.CaseInsensitiveChallengeResponse,subbuf.authinf2,"");
d953 3
a955 3
		      package_id, &subbuf, sizeof subbuf,
		      NULL, &ts, (PVOID *) &profile, &size,
		      &luid, &user_token, &quota, &ret2);
d966 2
a967 1
			 SecurityImpersonation, TokenPrimary, &primary_token))
d1007 1
a1007 1
  char fbuf[PATH_MAX];
d1018 3
a1020 3
			| GROUP_SECURITY_INFORMATION
			| DACL_SECURITY_INFORMATION,
			sd_buf, *sd_size, &len))
d1093 2
a1094 2
         FAT returns ERROR_INVALID_SECURITY_DESCR.
         This shouldn't return as error, but better be ignored. */
d1120 1
a1120 1
  /* Yeah, sounds too much, but I've seen SDs of 2100 bytes! */
d1285 1
a1285 1
      res = NTReadEA (file, ".UNIXATTR", (char *)attribute, sizeof(*attribute));
d1291 1
a1291 1
  /* symlinks are everything for everyone! */
d1299 2
a1300 2
get_nt_object_attribute (HANDLE handle, SE_OBJECT_TYPE object_type,
			 int *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1311 12
a1322 9
					DACL_SECURITY_INFORMATION |
					GROUP_SECURITY_INFORMATION |
					OWNER_SECURITY_INFORMATION,
					&owner_sid, &group_sid,
					&acl, NULL, &psd))
    {
      __seterrno ();
      debug_printf ("GetSecurityInfo %E");
      return -1;
d1344 2
a1345 1
      syscall_printf ("No ACL = %x, uid %d, gid %d", *attribute, uid, gid);
d1357 1
a1357 1
      if (!GetAce (acl, i, (PVOID *) & ace))
d1375 1
a1375 1
      cygsid ace_sid ((PSID) & ace->SidStart);
d1441 1
a1441 1
		      int *attribute, __uid32_t *uidret, __gid32_t *gidret)
d1445 1
a1445 2
      int res = get_nt_object_attribute (handle, object_type, attribute,
      					 uidret, gidret);
d1459 1
a1459 1
  /* symlinks are everything for everyone! */
d1478 2
a1479 1
  len_add += sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD) + GetLengthSid (sid);
d1495 2
a1496 1
  len_add += sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD) + GetLengthSid (sid);
d1617 2
a1618 1
      == (S_IFDIR | S_IWGRP | S_IXGRP) && !(attribute & S_ISVTX))
d1661 1
a1661 1
					: NO_INHERITANCE;
d1666 1
a1666 1
				 owner_sid, acl_len, inherit))
d1670 1
a1670 1
			       owner_sid, acl_len, inherit))
d1675 1
a1675 1
				 group_sid, acl_len, inherit))
d1679 1
a1679 1
			       group_sid, acl_len, inherit))
d1684 1
a1684 1
			       well_known_world_sid, acl_len, inherit))
d1767 1
a1767 1
  /* symlinks are anything for everyone! */
d1772 1
a1772 1
  InitializeSecurityDescriptor ((PSECURITY_DESCRIPTOR) sd_buf,
d1774 2
a1775 2
  psa->lpSecurityDescriptor = alloc_sd (geteuid32 (), getegid32 (), attribute,
					(PSECURITY_DESCRIPTOR) sd_buf,
d1806 2
a1807 1
		    __uid32_t uid, __gid32_t gid, int attribute)
d1828 2
a1829 1
			     myself->uid, myself->gid, attribute);
@


1.74.2.15
log
@Merged changes from HEAD
@
text
@d782 1
a782 2
           else if (gsid != well_known_world_sid &&
		    gsid != usersid)
d788 1
a788 3
      if (sawpg || 
	  groups.sgsids.contains (groups.pgsid) ||
	  groups.pgsid == usersid)
@


1.74.2.16
log
@Merged changes from HEAD
@
text
@a1204 89
static void
get_attribute_from_acl(int * attribute, PACL acl, PSID owner_sid,
		       PSID group_sid, BOOL grp_member)
{
  ACCESS_ALLOWED_ACE *ace;
  int allow = 0;
  int deny = 0;
  int *flags, *anti;

  for (DWORD i = 0; i < acl->AceCount; ++i)
    {
      if (!GetAce (acl, i, (PVOID *) &ace))
	continue;
      if (ace->Header.AceFlags & INHERIT_ONLY)
	continue;
      switch (ace->Header.AceType)
	{
	case ACCESS_ALLOWED_ACE_TYPE:
	  flags = &allow;
	  anti = &deny;
	  break;
	case ACCESS_DENIED_ACE_TYPE:
	  flags = &deny;
	  anti = &allow;
	  break;
	default:
	  continue;
	}

      cygsid ace_sid ((PSID) &ace->SidStart);
      if (ace_sid == well_known_world_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IROTH
		      | ((!(*anti & S_IRGRP)) ? S_IRGRP : 0)
		      | ((!(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWOTH
		      | ((!(*anti & S_IWGRP)) ? S_IWGRP : 0)
		      | ((!(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    {
	      *flags |= S_IXOTH
			| ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
			| ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
	    }
	  if ((*attribute & S_IFDIR) &&
	      (ace->Mask & (FILE_WRITE_DATA | FILE_EXECUTE | FILE_DELETE_CHILD))
	      == (FILE_WRITE_DATA | FILE_EXECUTE))
	    *flags |= S_ISVTX;
	}
      else if (ace_sid == well_known_null_sid)
	{
	  /* Read SUID, SGID and VTX bits from NULL ACE. */
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_ISVTX;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_ISGID;
	  if (ace->Mask & FILE_APPEND_DATA)
	    *flags |= S_ISUID;
	}
      else if (owner_sid && ace_sid == owner_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRUSR;
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWUSR;
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXUSR;
	}
      else if (group_sid && ace_sid == group_sid)
	{
	  if (ace->Mask & FILE_READ_DATA)
	    *flags |= S_IRGRP
		      | ((grp_member && !(*anti & S_IRUSR)) ? S_IRUSR : 0);
	  if (ace->Mask & FILE_WRITE_DATA)
	    *flags |= S_IWGRP
		      | ((grp_member && !(*anti & S_IWUSR)) ? S_IWUSR : 0);
	  if (ace->Mask & FILE_EXECUTE)
	    *flags |= S_IXGRP
		      | ((grp_member && !(*anti & S_IXUSR)) ? S_IXUSR : 0);
	}
    }
  *attribute &= ~(S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX | S_ISGID | S_ISUID);
  *attribute |= allow;
  *attribute &= ~deny;
  return;
}

a1266 1
  get_attribute_from_acl (attribute, acl, owner_sid, group_sid, grp_member);
d1268 82
d1440 82
a1521 1
  get_attribute_from_acl (attribute, acl, owner_sid, group_sid, grp_member);
@


1.74.2.17
log
@Merged changes from HEAD
@
text
@a63 3
  sids = NULL;
  count = maxcount = 0;
  type = cygsidlist_empty;
@


1.74.2.18
log
@Merged changes from HEAD
@
text
@d700 1
a700 1
	the token groups that are listed in /etc/group match the union of
d703 1
a703 1
	in the token are the groups associated with the usersid. We assume
d785 1
a785 1
	   else if (gsid != well_known_world_sid &&
d792 1
a792 1
      if (sawpg ||
d862 1
a862 1
	 id of the user account running current process. */
d872 1
a872 1
	 some important well known group sids. */
d1190 2
a1191 2
	 FAT returns ERROR_INVALID_SECURITY_DESCR.
	 This shouldn't return as error, but better be ignored. */
d1466 1
a1466 1
					 uidret, gidret);
@


1.74.2.19
log
@Merged changes from HEAD
@
text
@d1209 2
a1210 2
get_attribute_from_acl (int * attribute, PACL acl, PSID owner_sid,
			PSID group_sid, BOOL grp_member)
d1390 1
a1390 1
      res = NTReadEA (file, ".UNIXATTR", (char *)attribute, sizeof (*attribute));
@


1.73
log
@Update copyrights.
@
text
@d111 1
a111 1
  if (!iswinnt)
d1066 1
a1066 1
  if (!iswinnt)
d1289 1
a1289 1
  if (!iswinnt)
d1337 1
a1337 7
  static int win2KorHigher = -1;
  if (win2KorHigher == -1)
    {
      DWORD version = GetVersion ();
      win2KorHigher = (version & 0x80000000) || (version & 0xff) < 5 ? 0 : 1;
    }
  if (win2KorHigher > 0)
d1556 1
a1556 1
  if (!iswinnt)
@


1.72
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001 Cygnus Solutions.
@


1.71
log
@* cygheap.h (init_cygheap): Move bucket array here from cygheap.cc.
* cygheap.cc: Throughout use bucket array from cygheap.
* sigproc.cc (proc_subproc): Dynamically allocate zombie buffer to save DLL
space.
(sigproc_fixup_after_fork): Free zombie array after a fork.
* sigproc.h (sigproc_fixup_after_fork): Declare.
* dir.cc (mkdir): Expand buffer for security descriptor to 4K to avoid stack
corruption.
* fhandler.cc (fhandler_base::open): Ditto.
* path.cc (symlink): Ditto.
@
text
@d86 1
a86 1
          (c == pw->pw_gecos || c[-1] == ','))
d213 1
a213 1
                                        (PVOID *) &adi)) != STATUS_SUCCESS)
d221 1
a221 1
                                        (PVOID *) &pdi)) != STATUS_SUCCESS)
d229 1
a229 1
                            &cnt, &tot, SV_TYPE_DOMAIN_CTRL, primary, NULL))
d234 1
a234 1
        sys_wcstombs (domain, primary, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d240 1
a240 1
        sys_wcstombs (domain, account, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d301 1
a301 1
        debug_printf ("LookupAccountName(%s): %lu\n", group, GetLastError ());
d303 9
a311 9
        {
          strcat (strcpy (group, domain), "\\");
          sys_wcstombs (group + strlen (group), buf[i].grui0_name,
                        UNLEN + 1 - strlen (group));
          glen = UNLEN + 1;
          dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
          if (!LookupAccountName(NULL, group, gsid, &glen, domain, &dlen, &use))
            debug_printf ("LookupAccountName(%s): %lu\n", group,GetLastError());
        }
d313 1
a313 1
        grp_list += gsid;
d322 1
a322 1
                 cygsid &usersid, cygsidlist &grp_list)
d393 1
a393 1
		          UNLEN + 1 - strlen (group));
d568 1
a568 1
                      SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
d589 5
a593 5
        {
          if ((ret = LsaEnumerateAccountRights (lsa, usersid, &privstrs, &cnt))
              != STATUS_SUCCESS)
            continue;
        }
d595 2
a596 2
                                                 &privstrs, &cnt))
               != STATUS_SUCCESS)
d599 20
a618 20
        {
          LUID priv;
          PTOKEN_PRIVILEGES tmp;
          DWORD tmp_count;

          sys_wcstombs (buf, privstrs[i].Buffer,
	  		INTERNET_MAX_HOST_NAME_LENGTH + 1);
          if (!LookupPrivilegeValue (NULL, buf, &priv))
            continue;

          for (DWORD p = 0; privs && p < privs->PrivilegeCount; ++p)
            if (!memcmp (&priv, &privs->Privileges[p].Luid, sizeof (LUID)))
              goto next_account_right;

          tmp_count = privs ? privs->PrivilegeCount : 0;
          tmp = (PTOKEN_PRIVILEGES)
                realloc (privs, sizeof (ULONG) +
                                (tmp_count + 1) * sizeof (LUID_AND_ATTRIBUTES));
          if (!tmp)
            {
d621 1
a621 1
              LsaFreeMemory (privstrs);
d623 12
a634 12
              return NULL;
            }
          tmp->PrivilegeCount = tmp_count;
          privs = tmp;
          privs->Privileges[privs->PrivilegeCount].Luid = priv;
          privs->Privileges[privs->PrivilegeCount].Attributes =
                      SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
          ++privs->PrivilegeCount;

        next_account_right:
          ;
        }
d655 1
a655 1
        {
d657 2
a658 2
          return FALSE;
        }
d715 1
a715 1
 
d1194 1
a1194 1
        {
d1419 1
a1419 1
        null_allow |= FILE_APPEND_DATA;
d1421 1
a1421 1
        null_allow |= FILE_WRITE_DATA;
d1423 1
a1423 1
        null_allow |= FILE_READ_DATA;
d1551 1
a1551 1
  				SECURITY_DESCRIPTOR_REVISION);
@


1.70
log
@       * security.cc (create_token): Change initialization of `exp' to comply
        with new LARGE_INTEGER definition in winnt.h.
@
text
@d47 1
a47 1
BOOL allow_ntsec = FALSE;
@


1.69
log
@        * security.cc (set_nt_attribute): Return always -1 in case of
        a failure.
        * times.cc (utimes): On NTFS with ntsec ON, change the file's
        security descriptor temporarily to acquire write access if
        opening the file failed.
@
text
@d690 1
a690 1
  LARGE_INTEGER exp = { 0x7fffffffffffffffLL } ;
@


1.68
log
@        * security.cc (alloc_sd): Revert to setting inheritance attribute for
        permissions given to directories. Never set inheritance on NULL ACE.
@
text
@d1573 1
a1573 1
      return ret;
@


1.67
log
@        * security.cc (alloc_sd): Don't set FILE_DELETE_CHILD for group
        if S_ISVTX attribute is given.
        * dir.cc (mkdir): Allow immediate setting of S_ISUID, S_ISGID and
        S_ISVTX attribute.
        * syscalls.cc (_open): Ditto.
@
text
@a1438 13
  /* TODO */
#if 0
  /* Inheriting of attributes result in some strange behaviour if
     a user creates files in directories which are owned by another
     user. Even if the creator has all permissions, the default
     permissions of created files are set according to the dirs
     permission bits which may result in the inability to chmod
     the own file.
     Even if not inheriting permissions seems to be the correct
     behaviour from the POSIX point of view, I'll keep that
     stuff in the sources if it turns out that native Windows
     processes are failing due to this change.
  */
a1439 3
#else
  DWORD inherit = DONT_INHERIT;
#endif
d1467 1
a1467 1
				  well_known_null_sid, acl_len, inherit))
@


1.66
log
@        * dir.cc (mkdir): Set security attributes correctly for
        CreateDirectoryA () call if ntsec is on. Don't call
        set_file_attributes () then.
        * fhandler.cc (fhandler_base::open): Ditto for CreateFileA () call.
        * path.cc (symlink): Ditto.
        * security.cc (set_security_attribute): New function.
        * security.h: Add declaration for `allow_ntea' and
        `set_security_attribute'.
@
text
@d1396 2
a1397 1
      == (S_IFDIR | S_IWGRP | S_IXGRP))
@


1.65
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d1556 17
a1602 4
  /* symlinks are anything for everyone!*/
  if ((attribute & S_IFLNK) == S_IFLNK)
    attribute |= S_IRWXU | S_IRWXG | S_IRWXO;

@


1.64
log
@        * security.cc (set_file_attribute): Clean up. Don't call
        `set_nt_attribute' when ntsec isn't set.
@
text
@d111 1
a111 1
  if (os_being_run != winNT)
d1066 1
a1066 1
  if (os_being_run != winNT)
d1289 1
a1289 1
  if (os_being_run != winNT)
d1560 1
a1560 1
  if (os_being_run != winNT)
@


1.63
log
@        * security.cc (get_user_primary_group): Fix compiler warning.
        (alloc_sd): Add DELETE permission for user when S_IWUSR is given.
@
text
@d1590 6
a1595 1
  if (allow_ntea && (!use_ntsec || !allow_ntsec))
d1597 2
a1598 7
      if (!NTWriteEA (file, ".UNIXATTR", (char *) &attribute,
		      sizeof (attribute)))
	{
	  __seterrno ();
	  return -1;
	}
      return 0;
a1599 2

  int ret = set_nt_attribute (file, uid, gid, logsrv, attribute);
@


1.62
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d428 1
a428 1
  UCHAR count;
d1379 1
a1379 1
    owner_allow |= FILE_GENERIC_WRITE;
@


1.61
log
@        * security.cc (get_user_groups): Call Net function with NULL server
        name under specific error conditions.
        (is_group_member): Ditto.
        (get_user_local_groups): Ditto.
        (get_user_primary_group): Ditto.
@
text
@d33 1
a40 1
#include "security.h"
@


1.60
log
@        Change well_known_admin_sid to well_known_admins_sid throughout.
        * sec_acl.cc (setacl): Never set DELETE permission. Set
        FILE_DELETE_CHILD only on readable and executable directories.
        * sec_helper.cc: Add constructor for `well_known_null_sid'.
        * security.cc (get_nt_attribute): Set S_ISVTX for directories if
        FILE_WRITE_DATA and FILE_EXECUTE but not FILE_DELETE_CHILD is set.
        Add evaluation of S_ISVTX, S_ISGID and S_ISUID from NULL ACE.
        (alloc_sd): Never set DELETE permission. Set FILE_DELETE_CHILD
        only on readable and executable directories.
        Add creation of NULL ACE for S_ISVTX, S_ISGID and S_ISUID permissions.
        * security.h: Add extern declaration for `well_known_null_sid'.
@
text
@d277 6
a282 2
  if ((ret = NetUserGetGroups (wlogonserver, wuser, 0, (LPBYTE *) &buf,
			       MAX_PREFERRED_LENGTH, &cnt, &tot)))
d326 2
a327 1
  BOOL ret = FALSE;
d329 6
a334 2
  if (NetLocalGroupGetMembers (wlogonserver, wgroup, 0, (LPBYTE *) &buf,
                               MAX_PREFERRED_LENGTH, &cnt, &tot, NULL))
d337 1
a337 1
  for (DWORD bidx = 0; !ret && bidx < cnt; ++bidx)
d339 1
a339 1
      ret = TRUE;
d341 1
a341 1
      for (int glidx = 0; !ret && glidx < grp_list.count; ++glidx)
d343 1
a343 1
	  ret = TRUE;
d346 1
a346 1
  return ret;
d357 6
a362 2
  if ((ret = NetLocalGroupEnum (wlogonserver, 0, (LPBYTE *) &buf,
			        MAX_PREFERRED_LENGTH, &cnt, &tot, NULL)))
d426 2
a427 1
  BOOL ret = FALSE;
d437 10
a446 2
  if (NetUserGetInfo (wlogonserver, wuser, 3, (LPBYTE *) &buf))
    return FALSE;
d451 1
a451 1
      ret = TRUE;
d454 1
a454 1
  return ret;
@


1.59
log
@        * security.cc (alloc_sd): Don't set inheritance attribute for
        permissions given to directories.
@
text
@d459 1
a459 1
      grp_list += well_known_admin_sid;
d629 1
a629 1
  if (grp_list.contains (well_known_admin_sid))
d632 1
a632 1
			       well_known_admin_sid))
a1164 5
	      /* Sticky bit for directories according to linux rules. */
	      if (!(ace->Mask & FILE_DELETE_CHILD)
		  && S_ISDIR(*attribute)
		  && !(*anti & S_ISVTX))
		*flags |= S_ISVTX;
d1166 14
d1182 1
a1182 1
  *attribute &= ~(S_IRWXU|S_IRWXG|S_IRWXO|S_ISVTX);
a1346 10
  /*
   * VTX bit may only be set if executable for `other' is set.
   * For correct handling under WinNT, FILE_DELETE_CHILD has to
   * be (un)set in each ACE.
   */
  if (!(attribute & S_IXOTH))
    attribute &= ~S_ISVTX;
  if (!(attribute & S_IFDIR))
    attribute |= S_ISVTX;

d1357 1
a1357 1
    owner_allow |= FILE_GENERIC_WRITE | DELETE;
d1360 2
a1361 1
  if (!(attribute & S_ISVTX))
d1370 1
a1370 1
    group_allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE | DELETE;
d1373 2
a1374 1
  if (!(attribute & S_ISVTX))
d1383 1
a1383 1
    other_allow |= STANDARD_RIGHTS_WRITE | FILE_GENERIC_WRITE | DELETE;
d1386 3
a1388 1
  if (!(attribute & S_ISVTX))
d1391 12
d1438 1
a1438 1
      return NULL;
d1447 1
a1447 1
      return NULL;
d1457 5
d1486 2
a1487 1
	      || (ace_sid == well_known_world_sid))
@


1.58
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d1401 13
d1415 3
@


1.57
log
@forced commit
@
text
@d271 1
a271 1
  WCHAR wuser[UNLEN + 1]; 
d273 1
a273 1
  LPGROUP_USERS_INFO_0 buf; 
d446 1
a446 1
  
d628 1
a628 1
    } 
d693 1
a693 1
   
d713 1
a713 1
         id of the user account running current process. */
d722 1
a722 1
         some important well known group sids. */
d724 1
a724 1
          GetLastError () != ERROR_INSUFFICIENT_BUFFER)
d754 2
a755 2
                                   SE_GROUP_ENABLED_BY_DEFAULT |
                                   SE_GROUP_ENABLED;
d757 1
a757 1
        grps->Groups[i].Attributes |= SE_GROUP_LOGON_ID;
d783 1
a783 1
  			 SecurityImpersonation, TokenPrimary,
d882 1
a882 1
  		     package_id, &subbuf, sizeof subbuf,
d895 1
a895 1
  			 SecurityImpersonation, TokenPrimary,
d946 1
a946 1
	 		OWNER_SECURITY_INFORMATION
@


1.56
log
@* security.h (NTWriteEA): Change prototype.
* ntea.cc (NTReadEA): Don't check for global ntea setting, now
it's caller responsibility.
(NTWriteEA): Ditto.
* security.cc (get_file_attribute): Read attribute from EA only
if 'ntea' is enabled.
(set_file_attribute): Ditto.
* path.h: (class path_conv): Add members to store file system
information.
(path_conv::get_drive_type): New function.
* syscalls.cc (stat_worker): Use it.
* path.cc (path_conv::update_fs_info): New functions.
(path_conv::check): Get file system information from device where
file resides. On NTFS, try to read symlink contents from EA.
(get_symlink_ea): New function.
(set_symlink_ea): Ditto.
(symlink): Store symlink in extended attribute, if possible.
@
text
@@


1.55
log
@Maintain 80 col line length.
@
text
@d1202 8
a1209 3
  int oatt = *attribute;
  res = NTReadEA (file, ".UNIXATTR", (char *) attribute, sizeof (*attribute));
  *attribute |= oatt;
d1531 1
a1531 1
  if (!use_ntsec || !allow_ntsec)
@


1.54
log
@* path.cc (chdir): Always send unsigned chars to isspace since newlib's isspace
doesn't deal well with "negative" chars.
* fhandler.cc (fhandler_disk_file::open): Propagate remote status of file
garnered from path_conv.  Move #! checking to fstat.
(fhandler_disk_file::fstat): Reorganize st_mode setting to eliminate
duplication.  Move check for #! here from fhandler::open.
* fhandler.h (fhandler_base::isremote): New method.
(fhandler_base::set_isremote): Ditto.
(fhandler_base::set_execable_p): Also record "don't care if executable state".
(fhandler_base::dont_care_if_execable): New method.
* path.cc (path_conv::check): Clear new flags.  Appropriately set vol_flags,
drive_type, and is_remote_drive.
* path.h: Add new flags and methods for manipulating them.
* syscalls.cc (_unlink): Use isremote() to determine if a path is remote rather
than calling GetDriveType.
(stat_worker): Ditto.
* security.cc (get_file_attribute): Or attribute with result of NTReadEA to be
consistent with get_nt_attribute.
@
text
@d1528 2
a1529 1
      if (!NTWriteEA (file, ".UNIXATTR", (char *) &attribute, sizeof (attribute)))
@


1.53
log
@        * sec_helper.cc (cygsid::getfrompw): Change parameter to `const'.
        (cygsid::getfromgr): Ditto.
        * security.cc: Use `sys_mbstowcs' and `sys_wcstombs' throughout.
        (extract_nt_dom_user): Try to get user and domain from SID in
        pw->pw_gecos first.
        * security.h (class cygsid): Change parameter of getfrompw() and
        getfromgr() to `const'.
        * uinfo.cc (internal_getlogin): Change order for evaluating user
        information in winNT case. Drop usage of NetWkstaUserGetInfo().
@
text
@d1202 1
d1204 1
d1528 1
a1528 2
      if (!NTWriteEA (file, ".UNIXATTR",
		       (char *) &attribute, sizeof (attribute)))
@


1.52
log
@        * security.cc (get_file_attribute): Don't set errno.
@
text
@d25 1
d68 4
d78 5
d166 1
a166 1
  mbstowcs (buf, srcstr, tgt.MaximumLength);
d232 1
a232 1
      wcstombs (name, buf[0].sv101_name, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d234 1
a234 1
        wcstombs (domain, primary, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d238 1
a238 1
      wcstombs (name, account, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d240 1
a240 1
        wcstombs (domain, account, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d272 1
a272 1
  mbstowcs (wuser, user, UNLEN + 1);
d295 1
a295 1
      wcstombs (group, buf[i].grui0_name, UNLEN + 1);
d301 2
a302 2
          wcstombs (group + strlen (group), buf[i].grui0_name,
                    UNLEN + 1 - strlen (group));
d366 1
a366 1
	wcstombs (group, buf[i].lgrpi0_name, UNLEN + 1);
d379 2
a380 2
	    wcstombs (group + strlen (group), buf[i].lgrpi0_name,
		      UNLEN + 1 - strlen (group));
d422 1
a422 1
  mbstowcs (wuser, user, UNLEN + 1);
d448 1
a448 1
  mbstowcs (wserver, logonserver, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d582 2
a583 1
          wcstombs (buf, privstrs[i].Buffer, INTERNET_MAX_HOST_NAME_LENGTH + 1);
@


1.51
log
@        * autoload.cc: Add load statements for `LookupAccountNameW',
        `LsaClose', `LsaEnumerateAccountRights', `LsaFreeMemory',
        `LsaOpenPolicy', `LsaQueryInformationPolicy', `NetLocalGroupEnum',
        `NetLocalGroupGetMembers', `NetServerEnum', `NetUserGetGroups' and
        `NtCreateToken'.
        * ntdll.h: Add declaration for `NtCreateToken'.
        * sec_helper.cc: Add `well_known_local_sid', `well_known_dialup_sid',
        `well_known_network_sid', `well_known_batch_sid',
        `well_known_interactive_sid', `well_known_service_sid' and
        `well_known_authenticated_users_sid'.
        (cygsid::string): Define as const method.
        (cygsid::get_sid): Set psid to NO_SID on error.
        (cygsid::getfromstr): Ditto.
        (cygsid::getfrompw): Simplify.
        (cygsid::getfromgr): Check for gr == NULL.
        (legal_sid_type): Move to security.h.
        (set_process_privilege): Return -1 on error, otherwise 0 or 1 related
        to previous privilege setting.
        * security.cc (extract_nt_dom_user): Remove `static'.
        (lsa2wchar): New function.
        (open_local_policy): Ditto.
        (close_local_policy): Ditto.
        (get_lsa_srv_inf): Ditto.
        (get_logon_server): Ditto.
        (get_logon_server_and_user_domain): Ditto.
        (get_user_groups): Ditto.
        (is_group_member): Ditto.
        (get_user_local_groups): Ditto.
        (sid_in_token_groups): Ditto.
        (get_user_primary_group): Ditto.
        (get_group_sidlist): Ditto.
        (get_system_priv_list): Ditto.
        (get_priv_list): Ditto.
        (get_dacl): Ditto.
        (create_token): Ditto.
        (subauth): Return immediately if SE_TCB_NAME can't be assigned.
        Change all return statements in case of error to jumps to `out'
        label. Add `out' label to support cleanup.
        * security.h: Add extern declarations for `well_known_local_sid',
        `well_known_dialup_sid', `well_known_network_sid',
        `well_known_batch_sid', `well_known_interactive_sid',
        `well_known_service_sid' and `well_known_authenticated_users_sid'.
        Add extern declarations for functions `create_token',
        `extract_nt_dom_user' and `get_logon_server_and_user_domain'.
        (class cygsid): Add method `assign'. Change operator= to call new
        `assign' method. Add `debug_print' method.
        (class cygsidlist): New class.
        (legal_sid_type): Moved from sec_helper.cc to here.
        * spawn.cc (spawn_guts) Revert reversion of previous patch.
        Call `RevertToSelf' and `ImpersonateLoggedOnUser' instead of `seteuid'
        again.
        * syscalls.cc (seteuid): Rearranged. Call `create_token' now when
        needed. Call `subauth' if `create_token' fails. Try setting token
        owner and primary group only if token was not explicitely created
        by `create_token'.
        * uinfo.cc (internal_getlogin): Try harder to generate correct user
        information. Especially don't trust return value of `GetUserName'.
@
text
@a1196 2
  if (res <= 0)
    set_errno (ENOSYS);
@


1.50
log
@        * security.cc (cygwin_set_impersonation_token): Never destroy
        previous token object.
        (subauth): Create token source with well defined identifier.
@
text
@d40 4
d64 1
a64 1
static void
d136 1
a136 1
  tgt.Length = strlen(srcstr);
d144 1
a144 1
  tgt.Length = strlen(srcstr);
d153 1
a153 1
  tgt.Length = strlen(srcstr) * sizeof (WCHAR);
d159 632
a815 1
  HANDLE user_token;
d819 4
d824 2
a825 1
  set_process_privilege(SE_TCB_NAME);
d835 1
a835 1
      return INVALID_HANDLE_VALUE;
d840 1
a840 1
      return INVALID_HANDLE_VALUE;
d850 1
a850 1
      return INVALID_HANDLE_VALUE;
d879 1
a879 1
      return INVALID_HANDLE_VALUE;
a882 2
  SECURITY_ATTRIBUTES sa = { sizeof sa, NULL, TRUE };
  HANDLE primary_token;
d886 6
a891 5
    {
      CloseHandle (user_token);
      return INVALID_HANDLE_VALUE;
    }
  CloseHandle (user_token);
@


1.49
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@a54 2
      if (cygheap->user.token != INVALID_HANDLE_VALUE)
	CloseHandle (cygheap->user.token);
d216 2
a217 1
  AllocateLocallyUniqueId(&ts.SourceIdentifier);
@


1.48
log
@        * autoload.cc: Add autoload statements for ws2_32 functions
        `WSACloseEvent', `WSACreateEvent', `WSAGetOverlappedResult',
        `WSARecv', `WSARecvFrom', `WSASend', `WSASendTo' and `WSASetEvent',
        `WSAWaitForMultipleEvents'.
        * net.cc: Define wsock_evt.
        (wsock_event): New class.
        (cygwin_sendto): Use overlapped socket io if available.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * security.cc (subauth): Set Win32 error to 0 to safely ask for the
        error code of dynamically loaded function `LsaRegisterLogonProcess'.
@
text
@d431 2
a432 2
  uid_t uid = get_uid_from_sid (owner_sid);
  gid_t gid = get_gid_from_sid (group_sid);
d501 1
a501 1
      else if (ace_sid == get_world_sid ())
d618 1
a618 1
  if ((!pw || !get_pw_sid (owner_sid, pw))
d626 1
a626 1
  cygsid group_sid (NULL);
d630 1
a630 1
      if ((!grp || !get_gr_sid (group_sid.set (), grp))
d770 1
a770 1
				get_world_sid (), acl_len, inherit))
d796 1
a796 1
	      || (ace_sid == get_world_sid ()))
@


1.47
log
@        * security.cc (subauth): Check if Secur32.dll could be loaded.
@
text
@d191 1
@


1.46
log
@        * autoload.cc: Add LoadDLLinitfunc for secur32.dll.
        Add LoadDLLfuncEx statements for AllocateLocallyUniqueId@@4,
        DuplicateTokenEx@@24, LsaNtStatusToWinError@@4,
        LsaDeregisterLogonProcess@@4, LsaFreeReturnBuffer@@4,
        LsaLogonUser@@56, LsaLookupAuthenticationPackage@@12,
        LsaRegisterLogonProcess@@12,
        * environ.cc: Add extern declaration for `subauth_id'.
        (subauth_id_init): New function for setting `subauth_id'.
        (struct parse_thing): Add entry for `subauth_id'.
        * fork.cc (fork_parent): Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * security.cc: Define global variable `subauth_id'.
        (extract_nt_dom_user): New function.
        (cygwin_logon_user): Call `extract_nt_dom_user' now.
        (str2lsa): New static function.
        (str2buf2lsa): Ditto.
        (str2buf2uni): Ditto.
        (subauth): Ditto.
        * security.h: Add prototype for `subauth'.
        * spawn.cc (spawn_guts): Use cygheap->user.token only if impersonated.
        Use `cygsid' type. Remove impersonation before allowing access to
        workstation/desktop to everyone. Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * syscalls.cc (seteuid): Rearranged to allow using subauthentication
        to retrieve user tokens when needed.
@
text
@d198 5
@


1.45
log
@        * grp.cc: Eliminate MAX_DOMAIN_NAME define.
        (read_etc_group): Substitute MAX_DOMAIN_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * passwd.cc (parse_pwd): Don't force pw_name to be lower case.
        * sec_helper.cc: Substitute MAX_USER_NAME by UNLEN,
        MAX_COMPUTERNAME_LENGTH by INTERNET_MAX_HOST_NAME_LENGTH throughout.
        (lookup_name): Slight cleanup.
        * security.cc (alloc_sd): Substitute MAX_USER_NAME by UNLEN.
        * security.h: Define DEFAULT_UID as DOMAIN_USER_RID_ADMIN and
        DEFAULT_GID as DOMAIN_ALIAS_RID_ADMINS.
        * shared.cc (memory_init): Substitute MAX_USER_NAME by UNLEN.
        * thread.h: Ditto.
        * uinfo.cc (internal_getlogin): Substitute MAX_USER_NAME by UNLEN.
        Substitute MAX_COMPUTERNAME_LENGTH and MAX_HOST_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * winsup.h: Include lmcons.h. Eliminate MAX_USER_NAME and
        MAX_HOST_NAME. Move DEFAULT_UID and DEFAULT_GID to security.h.
@
text
@d27 3
d62 33
d110 2
a111 2
  char *c, *nt_user, *nt_domain = NULL;
  char usernamebuf[256];
d114 1
a114 20
  strcpy (usernamebuf, pw->pw_name);
  debug_printf ("pw_gecos = %x (%s)", pw->pw_gecos, pw->pw_gecos);
  if (pw->pw_gecos)
    {
      if ((c = strstr (pw->pw_gecos, "U-")) != NULL &&
	  (c == pw->pw_gecos || c[-1] == ','))
	{
	  usernamebuf[0] = '\0';
	  strncat (usernamebuf, c + 2, 255);
	  if ((c = strchr (usernamebuf, ',')) != NULL)
	    *c = '\0';
	}
    }
  nt_user = usernamebuf;
  if ((c = strchr (nt_user, '\\')) != NULL)
    {
      nt_domain = nt_user;
      *c = '\0';
      nt_user = c + 1;
    }
d116 1
a116 1
  if (!LogonUserA (nt_user, nt_domain, (char *) password,
d129 120
@


1.44
log
@        * security.cc (alloc_sd): Add unrelated ACCESS_ALLOWED_ACE behind
        the `everyone' ACE.
@
text
@d471 1
a471 1
  char owner[MAX_USER_NAME];
@


1.43
log
@        * autoload.cc: Add LoadDLLfunc statements for SetTokenInformation@@16.
        * cygheap.cc: Include security.h.
        * grp.cc (internal_getgrent): New function.
        (getgroups): Rearranged using `internal_getgrent' and the new
        `cygsid' class.
        * passwd.cc (internal_getpwent): New function.
        * sec_acl.cc: Use new `cygsid' class throughout.
        (acl_access): Use `internal_getgrent' instead of `getgrent'.
        * sec_helper.cc: Use new `cygsid' class throughout.
        (get_id_from_sid): Use `internal_getgrent' instead of `getgrent'.
        Use `internal_getpwent' instead of `getpwent'.
        * security.cc: Use new `cygsid' class throughout.
        * security.h: Move `MAX_SID_LEN' from winsup.h to here.
        Add extern declarations for `internal_getgrent' and `internal_getpwent'.
        (class cygsid): New class.
        * shared.cc (sec_user): Use new `cygsid' class.
        * syscalls.cc (seteuid): Try to set owner to user and primary group to
        current group in impersonation token before performing impersonation.
        (setegid): Try to set primary group in process token to the new group
        if ntsec is on.
        * uinfo.cc (internal_getlogin): Use new `cygsid' class.
        Try to set owner to user and primary group to current group in process
        token if the process has been started from a non cygwin process.
        (uinfo_init): Set primary group only if the process has been started
        from a non cygwin process.
        * winsup.h: Move define for `MAX_SID_LEN' to security.h.
@
text
@d625 5
d657 1
a657 2
	   * behind the owner_deny, ACCESS_ALLOWED_ACE to the end
	   * but in front of the `everyone' ACE.
a667 1
	  ++ace_off;
a668 5

  /* Set allow ACE for everyone. */
  if (!add_access_allowed_ace (acl, ace_off++, other_allow,
				get_world_sid (), acl_len, inherit))
    return NULL;
@


1.42
log
@        * security.cc (alloc_sd): Reformat comment.
        * shared.cc: Drop function declarations already in security.h.
@
text
@d336 2
a337 2
      PSID ace_sid = (PSID) &ace->SidStart;
      if (owner_sid && EqualSid (ace_sid, owner_sid))
d346 1
a346 1
      else if (group_sid && EqualSid (ace_sid, group_sid))
d358 1
a358 1
      else if (EqualSid (ace_sid, get_world_sid ()))
d472 1
a472 2
  char *owner_sid_buf[MAX_SID_LEN];
  PSID owner_sid = NULL;
a474 1
  owner_sid = (PSID) owner_sid_buf;
d479 2
a480 2
		*GetSidSubAuthority((PSID) owner_sid,
		*GetSidSubAuthorityCount((PSID) owner_sid) - 1));
d483 1
a483 2
  char *group_sid_buf[MAX_SID_LEN];
  PSID group_sid = NULL;
d487 1
a487 2
      group_sid = (PSID) group_sid_buf;
      if ((!grp || !get_gr_sid (group_sid, grp))
d642 1
a642 1
	  PSID ace_sid = (PSID) &ace->SidStart;
d644 5
a648 5
	  if ((cur_owner_sid && EqualSid (ace_sid, cur_owner_sid))
	      || (owner_sid && EqualSid (ace_sid, owner_sid))
	      || (cur_group_sid && EqualSid (ace_sid, cur_group_sid))
	      || (group_sid && EqualSid (ace_sid, group_sid))
	      || (EqualSid (ace_sid, get_world_sid ())))
@


1.41
log
@        * security.cc (set_process_privileges): Swap out.
        * sec_helper.cc (set_process_privilege): Rename from
        `set_process_privileges'. Takes the privilege to enable or disable
        as parameter now.
        * security.h: Add prototype for `set_process_privileges'.
@
text
@d508 4
a511 4
   * We set the SE_DACL_PROTECTED flag here to prevent the DACL from being modified
   * by inheritable ACEs.
   * This flag as well as the SetSecurityDescriptorControl call are available only
   * since Win2K.
@


1.40
log
@        * Makefile.in: Add object files `sec_helper.cc' and `sec_acl.cc'.
        * security.cc: Swap out several functions.
        * sec_acl.cc: New file. Move Sun compatibel ACL functions from
        `security.cc' to here.
        * sec_helper.cc: New file. Move security helper functions from
        `security.cc' to here.
        * security.h: Changed to accomodate the above changes.

        * grp.cc: Replace `group_in_memory_p' by `group_state'.
        Eliminate group_sem throughout.
        (enum grp_state): New enumeration type.
        (read_etc_group): Make race safe.
        * security.cc: Eliminate group_sem throughout.
@
text
@d185 1
a185 1
      set_process_privileges ();
a245 40
}

int
set_process_privileges ()
{
  HANDLE hToken = NULL;
  LUID restore_priv;
  TOKEN_PRIVILEGES new_priv;
  int ret = -1;

  if (!OpenProcessToken (hMainProc, TOKEN_ADJUST_PRIVILEGES, &hToken))
    {
      __seterrno ();
      goto out;
    }

  if (!LookupPrivilegeValue (NULL, SE_RESTORE_NAME, &restore_priv))
    {
      __seterrno ();
      goto out;
    }

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid = restore_priv;
  new_priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!AdjustTokenPrivileges (hToken, FALSE, &new_priv, 0, NULL, NULL))
    {
      __seterrno ();
      goto out;
    }

  ret = 0;

out:
  if (hToken)
    CloseHandle (hToken);

  syscall_printf ("%d = set_process_privileges ()", ret);
  return ret;
@


1.39
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@a44 378
SID_IDENTIFIER_AUTHORITY sid_auth[] = {
	{SECURITY_NULL_SID_AUTHORITY},
	{SECURITY_WORLD_SID_AUTHORITY},
	{SECURITY_LOCAL_SID_AUTHORITY},
	{SECURITY_CREATOR_SID_AUTHORITY},
	{SECURITY_NON_UNIQUE_AUTHORITY},
	{SECURITY_NT_AUTHORITY}
};

#define DONT_INHERIT (0)
#define INHERIT_ALL  (CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE)
#define INHERIT_ONLY (INHERIT_ONLY_ACE|CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE)

char *
convert_sid_to_string_sid (PSID psid, char *sid_str)
{
  char t[32];
  DWORD i;

  if (!psid || !sid_str)
    return NULL;
  strcpy (sid_str, "S-1-");
  __small_sprintf(t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
  strcat (sid_str, t);
  for (i = 0; i < *GetSidSubAuthorityCount (psid); ++i)
    {
      __small_sprintf(t, "-%lu", *GetSidSubAuthority (psid, i));
      strcat (sid_str, t);
    }
  return sid_str;
}

PSID
get_sid (PSID psid, DWORD s, DWORD cnt, DWORD *r)
{
  DWORD i;

  if (!psid || s > 5 || cnt < 1 || cnt > 8)
    return NULL;

  InitializeSid(psid, &sid_auth[s], cnt);
  for (i = 0; i < cnt; ++i)
    memcpy ((char *) psid + 8 + sizeof (DWORD) * i, &r[i], sizeof (DWORD));
  return psid;
}

PSID
convert_string_sid_to_sid (PSID psid, const char *sid_str)
{
  char sid_buf[256];
  char *t, *lasts;
  DWORD cnt = 0;
  DWORD s = 0;
  DWORD i, r[8];

  if (!sid_str || strncmp (sid_str, "S-1-", 4))
    return NULL;

  strcpy (sid_buf, sid_str);

  for (t = sid_buf + 4, i = 0;
       cnt < 8 && (t = strtok_r (t, "-", &lasts));
       t = NULL, ++i)
    if (i == 0)
      s = strtoul (t, NULL, 10);
    else
      r[cnt++] = strtoul (t, NULL, 10);

  return get_sid (psid, s, cnt, r);
}

BOOL
get_pw_sid (PSID sid, struct passwd *pw)
{
  char *sp = pw->pw_gecos ? strrchr (pw->pw_gecos, ',') : NULL;

  if (!sp)
    return FALSE;
  return convert_string_sid_to_sid (sid, ++sp) != NULL;
}

BOOL
get_gr_sid (PSID sid, struct group *gr)
{
  return convert_string_sid_to_sid (sid, gr->gr_passwd) != NULL;
}

PSID
get_admin_sid ()
{
  static NO_COPY char admin_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID admin_sid = NULL;

  if (!admin_sid)
    {
      admin_sid = (PSID) admin_sid_buf;
      convert_string_sid_to_sid (admin_sid, "S-1-5-32-544");
    }
  return admin_sid;
}

PSID
get_system_sid ()
{
  static NO_COPY char system_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID system_sid = NULL;

  if (!system_sid)
    {
      system_sid = (PSID) system_sid_buf;
      convert_string_sid_to_sid (system_sid, "S-1-5-18");
    }
  return system_sid;
}

PSID
get_creator_owner_sid ()
{
  static NO_COPY char owner_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID owner_sid = NULL;

  if (!owner_sid)
    {
      owner_sid = (PSID) owner_sid_buf;
      convert_string_sid_to_sid (owner_sid, "S-1-3-0");
    }
  return owner_sid;
}

PSID
get_world_sid ()
{
  static NO_COPY char world_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID world_sid = NULL;

  if (!world_sid)
    {
      world_sid = (PSID) world_sid_buf;
      convert_string_sid_to_sid (world_sid, "S-1-1-0");
    }
  return world_sid;
}

int group_sem = 0;

static int
get_id_from_sid (PSID psid, BOOL search_grp, int *type)
{
  if (!IsValidSid (psid))
    {
      __seterrno ();
      small_printf ("IsValidSid failed with %E");
      return -1;
    }

  /* First try to get SID from passwd or group entry */
  if (allow_ntsec)
    {
      char sidbuf[MAX_SID_LEN];
      PSID sid = (PSID) sidbuf;
      int id = -1;

      if (!search_grp)
	{
	  struct passwd *pw;
	  while ((pw = getpwent ()) != NULL)
	    {
	      if (get_pw_sid (sid, pw) && EqualSid (psid, sid))
		{
		  id = pw->pw_uid;
		  break;
		}
	    }
	  endpwent ();
	  if (id >= 0)
	    {
	      if (type)
		*type = USER;
	      return id;
	    }
	}
      if (search_grp || type)
	{
	  if (group_sem > 0)
	    return 0;
	  ++group_sem;

	  struct group *gr;
	  while ((gr = getgrent ()) != NULL)
	    {
	      if (get_gr_sid (sid, gr) && EqualSid (psid, sid))
		{
		  id = gr->gr_gid;
		  break;
		}
	    }
	  endgrent ();
	  --group_sem;
	  if (id >= 0)
	    {
	      if (type)
		*type = GROUP;
	      return id;
	    }
	}
    }

  /* We use the RID as default UID/GID */
  int id = *GetSidSubAuthority(psid, *GetSidSubAuthorityCount(psid) - 1);

  /*
   * The RID maybe -1 if accountname == computername.
   * In this case we search for the accountname in the passwd and group files.
   * If type is needed, we search in each case.
   */
  if (id == -1 || type)
    {
      char account[MAX_USER_NAME];
      char domain[MAX_COMPUTERNAME_LENGTH+1];
      DWORD acc_len = MAX_USER_NAME;
      DWORD dom_len = MAX_COMPUTERNAME_LENGTH+1;
      SID_NAME_USE acc_type;

      if (!LookupAccountSid (NULL, psid, account, &acc_len,
			     domain, &dom_len, &acc_type))
	{
	  __seterrno ();
	  return -1;
	}

      switch (acc_type)
	{
	  case SidTypeGroup:
	  case SidTypeAlias:
	  case SidTypeWellKnownGroup:
	    if (type)
	      *type = GROUP;
	    if (id == -1)
	      {
		struct group *gr = getgrnam (account);
		if (gr)
		  id = gr->gr_gid;
	      }
	    break;
	  case SidTypeUser:
	    if (type)
	      *type = USER;
	    if (id == -1)
	      {
		struct passwd *pw = getpwnam (account);
		if (pw)
		  id = pw->pw_uid;
	      }
	    break;
	  default:
	    break;
	}
    }
  if (id == -1)
    id = getuid ();
  return id;
}

int
get_id_from_sid (PSID psid, BOOL search_grp)
{
  return get_id_from_sid (psid, search_grp, NULL);
}

static BOOL
legal_sid_type (SID_NAME_USE type)
{
  return type == SidTypeUser || type == SidTypeGroup
		 || SidTypeAlias || SidTypeWellKnownGroup;
}

BOOL
is_grp_member (uid_t uid, gid_t gid)
{
  extern int getgroups (int, gid_t *, gid_t, const char *);
  BOOL grp_member = TRUE;

  if (!group_sem)
    {
      struct passwd *pw = getpwuid (uid);
      gid_t grps[NGROUPS_MAX];
      int cnt = getgroups (NGROUPS_MAX, grps,
			   pw ? pw->pw_gid : myself->gid,
			   pw ? pw->pw_name : cygheap->user.name ());
      int i;
      for (i = 0; i < cnt; ++i)
	if (grps[i] == gid)
	  break;
      grp_member = (i < cnt);
    }
  return grp_member;
}

BOOL
lookup_name (const char *name, const char *logsrv, PSID ret_sid)
{
  char sidbuf[MAX_SID_LEN];
  PSID sid = (PSID) sidbuf;
  DWORD sidlen;
  char domuser[MAX_COMPUTERNAME_LENGTH+MAX_USER_NAME+1];
  char dom[MAX_COMPUTERNAME_LENGTH+1];
  DWORD domlen;
  SID_NAME_USE acc_type;

  debug_printf ("name  : %s", name ? name : "NULL");

  if (!name)
    return FALSE;

  if (cygheap->user.domain ())
    {
      strcat (strcat (strcpy (domuser, cygheap->user.domain ()), "\\"), name);
      if (LookupAccountName (NULL, domuser,
			     sid, (sidlen = MAX_SID_LEN, &sidlen),
			     dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
			     &acc_type)
	  && legal_sid_type (acc_type))
	goto got_it;
      if (logsrv && *logsrv
	  && LookupAccountName (logsrv, domuser,
				sid, (sidlen = MAX_SID_LEN, &sidlen),
				dom, (domlen = MAX_COMPUTERNAME_LENGTH,&domlen),
				&acc_type)
	  && legal_sid_type (acc_type))
	goto got_it;
    }
  if (logsrv && *logsrv)
    {
      if (LookupAccountName (logsrv, name,
			     sid, (sidlen = MAX_SID_LEN, &sidlen),
			     dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
			     &acc_type)
	  && legal_sid_type (acc_type))
	goto got_it;
      if (acc_type == SidTypeDomain)
	{
	  strcat (strcat (strcpy (domuser, dom), "\\"), name);
	  if (LookupAccountName (logsrv, domuser,
				 sid,(sidlen = MAX_SID_LEN, &sidlen),
				 dom,(domlen = MAX_COMPUTERNAME_LENGTH,&domlen),
				 &acc_type))
	    goto got_it;
	}
    }
  if (LookupAccountName (NULL, name,
			 sid, (sidlen = MAX_SID_LEN, &sidlen),
			 dom, (domlen = 100, &domlen),
			 &acc_type)
      && legal_sid_type (acc_type))
    goto got_it;
  if (acc_type == SidTypeDomain)
    {
      strcat (strcat (strcpy (domuser, dom), "\\"), name);
      if (LookupAccountName (NULL, domuser,
			     sid, (sidlen = MAX_SID_LEN, &sidlen),
			     dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
			     &acc_type))
	goto got_it;
    }
  debug_printf ("LookupAccountName(%s) %E", name);
  __seterrno ();
  return FALSE;

got_it:
  debug_printf ("sid : [%d]", *GetSidSubAuthority((PSID) sid,
			      *GetSidSubAuthorityCount((PSID) sid) - 1));

  if (ret_sid)
    memcpy (ret_sid, sid, sidlen);

  return TRUE;
}

d461 3
a463 2
BOOL add_access_allowed_ace (PACL acl, int offset, DWORD attributes,
			     PSID sid, size_t &len_add, DWORD inherit)
d478 3
a480 2
BOOL add_access_denied_ace (PACL acl, int offset, DWORD attributes,
			    PSID sid, size_t &len_add, DWORD inherit)
a803 1029

static int
searchace (aclent_t *aclp, int nentries, int type, int id = -1)
{
  int i;

  for (i = 0; i < nentries; ++i)
    if ((aclp[i].a_type == type && (id < 0 || aclp[i].a_id == id))
	|| !aclp[i].a_type)
      return i;
  return -1;
}

static int
setacl (const char *file, int nentries, aclent_t *aclbufp)
{
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;

  if (read_sd (file, psd, &sd_size) <= 0)
    {
      debug_printf ("read_sd %E");
      return -1;
    }

  BOOL dummy;

  /* Get owner SID. */
  PSID owner_sid = NULL;
  if (!GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
    {
      __seterrno ();
      return -1;
    }
  char owner_buf[MAX_SID_LEN];
  if (!CopySid (MAX_SID_LEN, (PSID) owner_buf, owner_sid))
    {
      __seterrno ();
      return -1;
    }
  owner_sid = (PSID) owner_buf;

  /* Get group SID. */
  PSID group_sid = NULL;
  if (!GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
    {
      __seterrno ();
      return -1;
    }
  char group_buf[MAX_SID_LEN];
  if (!CopySid (MAX_SID_LEN, (PSID) group_buf, group_sid))
    {
      __seterrno ();
      return -1;
    }
  group_sid = (PSID) group_buf;

  /* Initialize local security descriptor. */
  SECURITY_DESCRIPTOR sd;
  if (!InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION))
    {
      __seterrno ();
      return -1;
    }
  if (!SetSecurityDescriptorOwner(&sd, owner_sid, FALSE))
    {
      __seterrno ();
      return -1;
    }
  if (group_sid
      && !SetSecurityDescriptorGroup(&sd, group_sid, FALSE))
    {
      __seterrno ();
      return -1;
    }

  /* Fill access control list. */
  char acl_buf[3072];
  PACL acl = (PACL) acl_buf;
  size_t acl_len = sizeof (ACL);
  int ace_off = 0;

  char sidbuf[MAX_SID_LEN];
  PSID sid = (PSID) sidbuf;
  struct passwd *pw;
  struct group *gr;
  int pos;

  if (!InitializeAcl (acl, 3072, ACL_REVISION))
    {
      __seterrno ();
      return -1;
    }
  for (int i = 0; i < nentries; ++i)
    {
      DWORD allow = STANDARD_RIGHTS_READ
		    | FILE_READ_ATTRIBUTES | FILE_READ_EA;
      if (aclbufp[i].a_perm & S_IROTH)
	allow |= FILE_GENERIC_READ;
      if (aclbufp[i].a_perm & S_IWOTH)
	allow |= STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE
		 | DELETE | FILE_DELETE_CHILD;
      if (aclbufp[i].a_perm & S_IXOTH)
	allow |= FILE_GENERIC_EXECUTE;
      /* Set inherit property. */
      DWORD inheritance = (aclbufp[i].a_type & ACL_DEFAULT)
			  ? INHERIT_ONLY : DONT_INHERIT;
      /*
       * If a specific acl contains a corresponding default entry with
       * identical permissions, only one Windows ACE with proper
       * inheritance bits is created.
       */
      if (!(aclbufp[i].a_type & ACL_DEFAULT)
	  && (pos = searchace (aclbufp, nentries,
			       aclbufp[i].a_type | ACL_DEFAULT,
			       (aclbufp[i].a_type & (USER|GROUP))
			       ? aclbufp[i].a_id : -1)) >= 0
	  && pos < nentries
	  && aclbufp[i].a_perm == aclbufp[pos].a_perm)
	{
	  inheritance = INHERIT_ALL;
	  /* This eliminates the corresponding default entry. */
	  aclbufp[pos].a_type = 0;
	}
      switch (aclbufp[i].a_type)
	{
	case USER_OBJ:
	case DEF_USER_OBJ:
	  allow |= STANDARD_RIGHTS_ALL & ~DELETE;
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
					owner_sid, acl_len, inheritance))
	    return -1;
	  break;
	case USER:
	case DEF_USER:
	  if (!(pw = getpwuid (aclbufp[i].a_id))
	      || !get_pw_sid (sid, pw)
	      || !add_access_allowed_ace (acl, ace_off++, allow,
					   sid, acl_len, inheritance))
	    return -1;
	  break;
	case GROUP_OBJ:
	case DEF_GROUP_OBJ:
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
					group_sid, acl_len, inheritance))
	    return -1;
	  break;
	case GROUP:
	case DEF_GROUP:
	  if (!(gr = getgrgid (aclbufp[i].a_id))
	      || !get_gr_sid (sid, gr)
	      || !add_access_allowed_ace (acl, ace_off++, allow,
					   sid, acl_len, inheritance))
	    return -1;
	  break;
	case OTHER_OBJ:
	case DEF_OTHER_OBJ:
	  if (!add_access_allowed_ace (acl, ace_off++, allow,
					get_world_sid(), acl_len, inheritance))
	    return -1;
	  break;
	}
    }
  /* Set AclSize to computed value. */
  acl->AclSize = acl_len;
  debug_printf ("ACL-Size: %d", acl_len);
  /* Create DACL for local security descriptor. */
  if (!SetSecurityDescriptorDacl (&sd, TRUE, acl, FALSE))
    {
      __seterrno ();
      return -1;
    }
  /* Make self relative security descriptor in psd. */
  sd_size = 0;
  MakeSelfRelativeSD (&sd, psd, &sd_size);
  if (sd_size <= 0)
    {
      __seterrno ();
      return -1;
    }
  if (!MakeSelfRelativeSD (&sd, psd, &sd_size))
    {
      __seterrno ();
      return -1;
    }
  debug_printf ("Created SD-Size: %d", sd_size);
  return write_sd (file, psd, sd_size);
}

static void
getace (aclent_t &acl, int type, int id, DWORD win_ace_mask, DWORD win_ace_type)
{
  acl.a_type = type;
  acl.a_id = id;

  if (win_ace_mask & FILE_READ_DATA)
    if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
      acl.a_perm |= (acl.a_perm & S_IRGRP) ? 0 : S_IRUSR;
    else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
      acl.a_perm &= ~S_IRGRP;

  if (win_ace_mask & FILE_WRITE_DATA)
    if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
      acl.a_perm |= (acl.a_perm & S_IWGRP) ? 0 : S_IWUSR;
    else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
      acl.a_perm &= ~S_IWGRP;

  if (win_ace_mask & FILE_EXECUTE)
    if (win_ace_type == ACCESS_ALLOWED_ACE_TYPE)
      acl.a_perm |= (acl.a_perm & S_IXGRP) ? 0 : S_IXUSR;
    else if (win_ace_type == ACCESS_DENIED_ACE_TYPE)
      acl.a_perm &= ~S_IXGRP;
}

static int
getacl (const char *file, DWORD attr, int nentries, aclent_t *aclbufp)
{
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;

  int ret;
  if ((ret = read_sd (file, psd, &sd_size)) <= 0)
    {
      debug_printf ("read_sd %E");
      return ret;
    }

  PSID owner_sid;
  PSID group_sid;
  BOOL dummy;
  uid_t uid;
  gid_t gid;

  if (!GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
    {
      debug_printf ("GetSecurityDescriptorOwner %E");
      __seterrno ();
      return -1;
    }
  uid = get_uid_from_sid (owner_sid);

  if (!GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
    {
      debug_printf ("GetSecurityDescriptorGroup %E");
      __seterrno ();
      return -1;
    }
  gid = get_gid_from_sid (group_sid);

  aclent_t lacl[MAX_ACL_ENTRIES];
  memset (&lacl, 0, MAX_ACL_ENTRIES * sizeof (aclent_t));
  lacl[0].a_type = USER_OBJ;
  lacl[0].a_id = uid;
  lacl[1].a_type = GROUP_OBJ;
  lacl[1].a_id = gid;
  lacl[2].a_type = OTHER_OBJ;

  PACL acl;
  BOOL acl_exists;

  if (!GetSecurityDescriptorDacl (psd, &acl_exists, &acl, &dummy))
    {
      __seterrno ();
      debug_printf ("GetSecurityDescriptorDacl %E");
      return -1;
    }

  int pos, i;

  if (!acl_exists || !acl)
    {
      for (pos = 0; pos < MIN_ACL_ENTRIES; ++pos)
	lacl[pos].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
      pos = nentries < MIN_ACL_ENTRIES ? nentries : MIN_ACL_ENTRIES;
      memcpy (aclbufp, lacl, pos * sizeof (aclent_t));
      return pos;
    }

  for (i = 0; i < acl->AceCount && (!nentries || i < nentries); ++i)
    {
      ACCESS_ALLOWED_ACE *ace;

      if (!GetAce (acl, i, (PVOID *) &ace))
	continue;

      PSID ace_sid = (PSID) &ace->SidStart;
      int id;
      int type = 0;

      if (EqualSid (ace_sid, owner_sid))
	{
	  type = USER_OBJ;
	  id = uid;
	}
      else if (EqualSid (ace_sid, group_sid))
	{
	  type = GROUP_OBJ;
	  id = gid;
	}
      else if (EqualSid (ace_sid, get_world_sid ()))
	{
	  type = OTHER_OBJ;
	  id = 0;
	}
      else
	{
	  id = get_id_from_sid (ace_sid, FALSE, &type);
	  if (type != GROUP)
	    {
	      int type2 = 0;
	      int id2 = get_id_from_sid (ace_sid, TRUE, &type2);
	      if (type2 == GROUP)
		{
		  id = id2;
		  type = GROUP;
		}
	    }
	}
      if (!type)
	continue;
      if (!(ace->Header.AceFlags & INHERIT_ONLY_ACE))
	{
	  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
	    getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
	}
      if ((ace->Header.AceFlags & INHERIT_ALL)
	  && (attr & FILE_ATTRIBUTE_DIRECTORY))
	{
	  type |= ACL_DEFAULT;
	  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
	    getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
	}
    }
  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) < 0)
    pos = MAX_ACL_ENTRIES;
  for (i = 0; i < pos; ++i)
    {
      lacl[i].a_perm = (lacl[i].a_perm & S_IRWXU)
		       & ~((lacl[i].a_perm & S_IRWXG) << 3);
      lacl[i].a_perm |= (lacl[i].a_perm & S_IRWXU) >> 3
			| (lacl[i].a_perm & S_IRWXU) >> 6;
    }
  if ((searchace (lacl, MAX_ACL_ENTRIES, USER) >= 0
       || searchace (lacl, MAX_ACL_ENTRIES, GROUP) >= 0)
      && (pos = searchace (lacl, MAX_ACL_ENTRIES, CLASS_OBJ)) >= 0)
    {
      lacl[pos].a_type = CLASS_OBJ;
      lacl[pos].a_perm =
	  lacl[searchace (lacl, MAX_ACL_ENTRIES, GROUP_OBJ)].a_perm;
    }
  int dgpos;
  if ((searchace (lacl, MAX_ACL_ENTRIES, DEF_USER) >= 0
       || searchace (lacl, MAX_ACL_ENTRIES, DEF_GROUP) >= 0)
      && (dgpos = searchace (lacl, MAX_ACL_ENTRIES, DEF_GROUP_OBJ)) >= 0
      && (pos = searchace (lacl, MAX_ACL_ENTRIES, DEF_CLASS_OBJ)) >= 0
      && (attr & FILE_ATTRIBUTE_DIRECTORY))
    {
      lacl[pos].a_type = DEF_CLASS_OBJ;
      lacl[pos].a_perm = lacl[dgpos].a_perm;
    }
  if ((pos = searchace (lacl, MAX_ACL_ENTRIES, 0)) < 0)
    pos = MAX_ACL_ENTRIES;
  if (pos > nentries)
    pos = nentries;
  if (aclbufp)
    memcpy (aclbufp, lacl, pos * sizeof (aclent_t));
  aclsort (pos, 0, aclbufp);
  syscall_printf ("%d = getacl (%s)", pos, file);
  return pos;
}

int
acl_access (const char *path, int flags)
{
  aclent_t acls[MAX_ACL_ENTRIES];
  int cnt;

  if ((cnt = acl (path, GETACL, MAX_ACL_ENTRIES, acls)) < 1)
    return -1;

  /* Only check existance. */
  if (!(flags & (R_OK|W_OK|X_OK)))
    return 0;

  for (int i = 0; i < cnt; ++i)
    {
      switch (acls[i].a_type)
	{
	case USER_OBJ:
	case USER:
	  if (acls[i].a_id != myself->uid)
	    {
	      /*
	       * Check if user is a NT group:
	       * Take SID from passwd, search SID in group, check is_grp_member.
	       */
	      char owner_sidbuf[MAX_SID_LEN];
	      PSID owner_sid = (PSID) owner_sidbuf;
	      char group_sidbuf[MAX_SID_LEN];
	      PSID group_sid = (PSID) group_sidbuf;
	      struct passwd *pw;
	      struct group *gr = NULL;

	      if (group_sem > 0)
		continue;
	      ++group_sem;
	      if ((pw = getpwuid (acls[i].a_id)) != NULL
		  && get_pw_sid (owner_sid, pw))
		{
		  while ((gr = getgrent ()))
		    if (get_gr_sid (group_sid, gr)
			&& EqualSid (owner_sid, group_sid)
			&& is_grp_member (myself->uid, gr->gr_gid))
		      break;
		  endgrent ();
		}
	      --group_sem;
	      if (!gr)
		continue;
	    }
	  break;
	case GROUP_OBJ:
	case GROUP:
	  if (acls[i].a_id != myself->gid &&
	      !is_grp_member (myself->uid, acls[i].a_id))
	    continue;
	  break;
	case OTHER_OBJ:
	  break;
	default:
	  continue;
	}
      if ((!(flags & R_OK) || (acls[i].a_perm & S_IREAD))
	  && (!(flags & W_OK) || (acls[i].a_perm & S_IWRITE))
	  && (!(flags & X_OK) || (acls[i].a_perm & S_IEXEC)))
	return 0;
    }
  set_errno (EACCES);
  return -1;
}

static
int
acl_worker (const char *path, int cmd, int nentries, aclent_t *aclbufp,
	    int nofollow)
{
  extern suffix_info stat_suffixes[];
  path_conv real_path (path, (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW) | PC_FULL, stat_suffixes);
  if (real_path.error)
    {
      set_errno (real_path.error);
      syscall_printf ("-1 = acl (%s)", path);
      return -1;
    }
  if (!real_path.has_acls ())
    {
      struct stat st;
      int ret = -1;

      switch (cmd)
	{
	case SETACL:
	  set_errno (ENOSYS);
	  break;
	case GETACL:
	  if (nentries < 1)
	    set_errno (EINVAL);
	  else if ((nofollow && !lstat (path, &st))
		   || (!nofollow && !stat (path, &st)))
	    {
	      aclent_t lacl[4];
	      if (nentries > 0)
		{
		  lacl[0].a_type = USER_OBJ;
		  lacl[0].a_id = st.st_uid;
		  lacl[0].a_perm = (st.st_mode & S_IRWXU)
				   | (st.st_mode & S_IRWXU) >> 3
				   | (st.st_mode & S_IRWXU) >> 6;
		}
	      if (nentries > 1)
		{
		  lacl[1].a_type = GROUP_OBJ;
		  lacl[1].a_id = st.st_gid;
		  lacl[1].a_perm = (st.st_mode & S_IRWXG)
				   | (st.st_mode & S_IRWXG) << 3
				   | (st.st_mode & S_IRWXG) >> 3;
		}
	      if (nentries > 2)
		{
		  lacl[2].a_type = OTHER_OBJ;
		  lacl[2].a_id = 0;
		  lacl[2].a_perm = (st.st_mode & S_IRWXO)
				   | (st.st_mode & S_IRWXO) << 6
				   | (st.st_mode & S_IRWXO) << 3;
		}
	      if (nentries > 3)
		{
		  lacl[3].a_type = CLASS_OBJ;
		  lacl[3].a_id = 0;
		  lacl[3].a_perm = (st.st_mode & S_IRWXG)
				   | (st.st_mode & S_IRWXG) << 3
				   | (st.st_mode & S_IRWXG) >> 3;
		}
	      if (nentries > 4)
		nentries = 4;
	      if (aclbufp)
		memcpy (aclbufp, lacl, nentries * sizeof (aclent_t));
	      ret = nentries;
	    }
	  break;
	case GETACLCNT:
	  ret = 4;
	  break;
	}
      syscall_printf ("%d = acl (%s)", ret, path);
      return ret;
    }
  switch (cmd)
    {
      case SETACL:
	if (!aclsort(nentries, 0, aclbufp))
	  return setacl (real_path.get_win32 (),
			 nentries, aclbufp);
	break;
      case GETACL:
	if (nentries < 1)
	  break;
	return getacl (real_path.get_win32 (),
		       real_path.file_attributes (),
		       nentries, aclbufp);
      case GETACLCNT:
	return getacl (real_path.get_win32 (),
		       real_path.file_attributes (),
		       0, NULL);
      default:
	break;
    }
  set_errno (EINVAL);
  syscall_printf ("-1 = acl (%s)", path);
  return -1;
}

extern "C"
int
acl (const char *path, int cmd, int nentries, aclent_t *aclbufp)
{
  return acl_worker (path, cmd, nentries, aclbufp, 0);
}

extern "C"
int
lacl (const char *path, int cmd, int nentries, aclent_t *aclbufp)
{
  return acl_worker (path, cmd, nentries, aclbufp, 1);
}

extern "C"
int
facl (int fd, int cmd, int nentries, aclent_t *aclbufp)
{
  if (cygheap->fdtab.not_open (fd))
    {
      syscall_printf ("-1 = facl (%d)", fd);
      set_errno (EBADF);
      return -1;
    }
  const char *path = cygheap->fdtab[fd]->get_name ();
  if (path == NULL)
    {
      syscall_printf ("-1 = facl (%d) (no name)", fd);
      set_errno (ENOSYS);
      return -1;
    }
  syscall_printf ("facl (%d): calling acl (%s)", fd, path);
  return acl_worker (path, cmd, nentries, aclbufp, 0);
}

extern "C"
int
aclcheck (aclent_t *aclbufp, int nentries, int *which)
{
  BOOL has_user_obj = FALSE;
  BOOL has_group_obj = FALSE;
  BOOL has_other_obj = FALSE;
  BOOL has_class_obj = FALSE;
  BOOL has_ug_objs = FALSE;
  BOOL has_def_user_obj = FALSE;
  BOOL has_def_group_obj = FALSE;
  BOOL has_def_other_obj = FALSE;
  BOOL has_def_class_obj = FALSE;
  BOOL has_def_ug_objs = FALSE;
  int pos2;

  for (int pos = 0; pos < nentries; ++pos)
    switch (aclbufp[pos].a_type)
      {
      case USER_OBJ:
	if (has_user_obj)
	  {
	    if (which)
	      *which = pos;
	    return USER_ERROR;
	  }
	has_user_obj = TRUE;
	break;
      case GROUP_OBJ:
	if (has_group_obj)
	  {
	    if (which)
	      *which = pos;
	    return GRP_ERROR;
	  }
	has_group_obj = TRUE;
	break;
      case OTHER_OBJ:
	if (has_other_obj)
	  {
	    if (which)
	      *which = pos;
	    return OTHER_ERROR;
	  }
	has_other_obj = TRUE;
	break;
      case CLASS_OBJ:
	if (has_class_obj)
	  {
	    if (which)
	      *which = pos;
	    return CLASS_ERROR;
	  }
	has_class_obj = TRUE;
	break;
      case USER:
      case GROUP:
	if ((pos2 = searchace (aclbufp + pos + 1, nentries - pos - 1,
			       aclbufp[pos].a_type, aclbufp[pos].a_id)) >= 0)
	  {
	    if (which)
	      *which = pos2;
	    return DUPLICATE_ERROR;
	  }
	has_ug_objs = TRUE;
	break;
      case DEF_USER_OBJ:
	if (has_def_user_obj)
	  {
	    if (which)
	      *which = pos;
	    return USER_ERROR;
	  }
	has_def_user_obj = TRUE;
	break;
      case DEF_GROUP_OBJ:
	if (has_def_group_obj)
	  {
	    if (which)
	      *which = pos;
	    return GRP_ERROR;
	  }
	has_def_group_obj = TRUE;
	break;
      case DEF_OTHER_OBJ:
	if (has_def_other_obj)
	  {
	    if (which)
	      *which = pos;
	    return OTHER_ERROR;
	  }
	has_def_other_obj = TRUE;
	break;
      case DEF_CLASS_OBJ:
	if (has_def_class_obj)
	  {
	    if (which)
	      *which = pos;
	    return CLASS_ERROR;
	  }
	has_def_class_obj = TRUE;
	break;
      case DEF_USER:
      case DEF_GROUP:
	if ((pos2 = searchace (aclbufp + pos + 1, nentries - pos - 1,
			       aclbufp[pos].a_type, aclbufp[pos].a_id)) >= 0)
	  {
	    if (which)
	      *which = pos2;
	    return DUPLICATE_ERROR;
	  }
	has_def_ug_objs = TRUE;
	break;
      default:
	return ENTRY_ERROR;
      }
  if (!has_user_obj
      || !has_group_obj
      || !has_other_obj
#if 0
      /* These checks are not ok yet since CLASS_OBJ isn't fully implemented. */
      || (has_ug_objs && !has_class_obj)
      || (has_def_ug_objs && !has_def_class_obj)
#endif
     )
    {
      if (which)
	*which = -1;
      return MISS_ERROR;
    }
  return 0;
}

extern "C"
int acecmp (const void *a1, const void *a2)
{
#define ace(i) ((const aclent_t *) a##i)
  int ret = ace(1)->a_type - ace(2)->a_type;
  if (!ret)
    ret = ace(1)->a_id - ace(2)->a_id;
  return ret;
#undef ace
}

extern "C"
int
aclsort (int nentries, int, aclent_t *aclbufp)
{
  if (aclcheck (aclbufp, nentries, NULL))
    return -1;
  if (!aclbufp || nentries < 1)
    {
      set_errno (EINVAL);
      return -1;
    }
  qsort((void *) aclbufp, nentries, sizeof (aclent_t), acecmp);
  return 0;
}

extern "C"
int
acltomode (aclent_t *aclbufp, int nentries, mode_t *modep)
{
  int pos;

  if (!aclbufp || nentries < 1 || !modep)
    {
      set_errno (EINVAL);
      return -1;
    }
  *modep = 0;
  if ((pos = searchace (aclbufp, nentries, USER_OBJ)) < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  *modep |= aclbufp[pos].a_perm & S_IRWXU;
  if ((pos = searchace (aclbufp, nentries, GROUP_OBJ)) < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (searchace (aclbufp, nentries, CLASS_OBJ) < 0)
    pos = searchace (aclbufp, nentries, CLASS_OBJ);
  *modep |= (aclbufp[pos].a_perm & S_IRWXU) >> 3;
  if ((pos = searchace (aclbufp, nentries, OTHER_OBJ)) < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  *modep |= (aclbufp[pos].a_perm & S_IRWXU) >> 6;
  return 0;
}

extern "C"
int
aclfrommode(aclent_t *aclbufp, int nentries, mode_t *modep)
{
  int pos;

  if (!aclbufp || nentries < 1 || !modep)
    {
      set_errno (EINVAL);
      return -1;
    }
  if ((pos = searchace (aclbufp, nentries, USER_OBJ)) < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  aclbufp[pos].a_perm = (*modep & S_IRWXU)
			| (*modep & S_IRWXU) >> 3
			| (*modep & S_IRWXU) >> 6;
  if ((pos = searchace (aclbufp, nentries, GROUP_OBJ)) < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (searchace (aclbufp, nentries, CLASS_OBJ) < 0)
    pos = searchace (aclbufp, nentries, CLASS_OBJ);
  aclbufp[pos].a_perm = (*modep & S_IRWXG)
			| (*modep & S_IRWXG) << 3
			| (*modep & S_IRWXG) >> 3;
  if ((pos = searchace (aclbufp, nentries, OTHER_OBJ)) < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  aclbufp[pos].a_perm = (*modep & S_IRWXO)
			| (*modep & S_IRWXO) << 6
			| (*modep & S_IRWXO) << 3;
  return 0;
}

extern "C"
int
acltopbits (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return acltomode (aclbufp, nentries, pbitsp);
}

extern "C"
int
aclfrompbits (aclent_t *aclbufp, int nentries, mode_t *pbitsp)
{
  return aclfrommode (aclbufp, nentries, pbitsp);
}

static char *
permtostr (mode_t perm)
{
  static char pbuf[4];

  pbuf[0] = (perm & S_IREAD) ? 'r' : '-';
  pbuf[1] = (perm & S_IWRITE) ? 'w' : '-';
  pbuf[2] = (perm & S_IEXEC) ? 'x' : '-';
  pbuf[3] = '\0';
  return pbuf;
}

extern "C"
char *
acltotext (aclent_t *aclbufp, int aclcnt)
{
  if (!aclbufp || aclcnt < 1 || aclcnt > MAX_ACL_ENTRIES
      || aclcheck (aclbufp, aclcnt, NULL))
    {
      set_errno (EINVAL);
      return NULL;
    }
  char buf[32000];
  buf[0] = '\0';
  BOOL first = TRUE;

  for (int pos = 0; pos < aclcnt; ++pos)
    {
      if (!first)
	strcat (buf, ",");
      first = FALSE;
      if (aclbufp[pos].a_type & ACL_DEFAULT)
	strcat (buf, "default");
      switch (aclbufp[pos].a_type)
	{
	case USER_OBJ:
	  __small_sprintf (buf + strlen (buf), "user::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	case USER:
	  __small_sprintf (buf + strlen (buf), "user:%d:%s",
		   aclbufp[pos].a_id, permtostr (aclbufp[pos].a_perm));
	  break;
	case GROUP_OBJ:
	  __small_sprintf (buf + strlen (buf), "group::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	case GROUP:
	  __small_sprintf (buf + strlen (buf), "group:%d:%s",
		   aclbufp[pos].a_id, permtostr (aclbufp[pos].a_perm));
	  break;
	case CLASS_OBJ:
	  __small_sprintf (buf + strlen (buf), "mask::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	case OTHER_OBJ:
	  __small_sprintf (buf + strlen (buf), "other::%s",
		   permtostr (aclbufp[pos].a_perm));
	  break;
	default:
	  set_errno (EINVAL);
	  return NULL;
	}
    }
  return strdup (buf);
}

static mode_t
permfromstr (char *perm)
{
  mode_t mode = 0;

  if (strlen (perm) != 3)
    return 01000;
  if (perm[0] == 'r')
    mode |= S_IRUSR | S_IRGRP | S_IROTH;
  else if (perm[0] != '-')
    return 01000;
  if (perm[1] == 'w')
    mode |= S_IWUSR | S_IWGRP | S_IWOTH;
  else if (perm[1] != '-')
    return 01000;
  if (perm[2] == 'x')
    mode |= S_IXUSR | S_IXGRP | S_IXOTH;
  else if (perm[2] != '-')
    return 01000;
  return mode;
}

extern "C"
aclent_t *
aclfromtext (char *acltextp, int *)
{
  if (!acltextp)
    {
      set_errno (EINVAL);
      return NULL;
    }
  char buf[strlen (acltextp) + 1];
  aclent_t lacl[MAX_ACL_ENTRIES];
  memset (lacl, 0, sizeof lacl);
  int pos = 0;
  strcpy (buf, acltextp);
  char *lasts;
  for (char *c = strtok_r (buf, ",", &lasts);
       c;
       c = strtok_r (NULL, ",", &lasts))
    {
      if (!strncmp (c, "default", 7))
	{
	  lacl[pos].a_type |= ACL_DEFAULT;
	  c += 7;
	}
      if (!strncmp (c, "user:", 5))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= USER_OBJ;
	  else
	    {
	      lacl[pos].a_type |= USER;
	      c += 5;
	      if (isalpha (*c))
		{
		  struct passwd *pw = getpwnam (c);
		  if (!pw)
		    {
		      set_errno (EINVAL);
		      return NULL;
		    }
		  lacl[pos].a_id = pw->pw_uid;
		  c = strchr (c, ':');
		}
	      else if (isdigit (*c))
		lacl[pos].a_id = strtol (c, &c, 10);
	      if (!c || *c != ':')
		{
		  set_errno (EINVAL);
		  return NULL;
		}
	    }
	}
      else if (!strncmp (c, "group:", 6))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= GROUP_OBJ;
	  else
	    {
	      lacl[pos].a_type |= GROUP;
	      c += 5;
	      if (isalpha (*c))
		{
		  struct group *gr = getgrnam (c);
		  if (!gr)
		    {
		      set_errno (EINVAL);
		      return NULL;
		    }
		  lacl[pos].a_id = gr->gr_gid;
		  c = strchr (c, ':');
		}
	      else if (isdigit (*c))
		lacl[pos].a_id = strtol (c, &c, 10);
	      if (!c || *c != ':')
		{
		  set_errno (EINVAL);
		  return NULL;
		}
	    }
	}
      else if (!strncmp (c, "mask:", 5))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= CLASS_OBJ;
	  else
	    {
	      set_errno (EINVAL);
	      return NULL;
	    }
	}
      else if (!strncmp (c, "other:", 6))
	{
	  if (c[5] == ':')
	    lacl[pos].a_type |= OTHER_OBJ;
	  else
	    {
	      set_errno (EINVAL);
	      return NULL;
	    }
	}
      if ((lacl[pos].a_perm = permfromstr (c)) == 01000)
	{
	  set_errno (EINVAL);
	  return NULL;
	}
      ++pos;
    }
  aclent_t *aclp = (aclent_t *) malloc (pos * sizeof (aclent_t));
  if (aclp)
    memcpy (aclp, lacl, pos * sizeof (aclent_t));
  return aclp;
}

@


1.38
log
@        * environ.cc (parse_options): Use strtok_r instead of strtok.
        * security.cc (convert_string_sid_to_sid): Ditto.
        (aclfromtext): Ditto. Fix buffer usage.
@
text
@a187 1
int passwd_sem = 0;
a208 4
	  if (passwd_sem > 0)
	    return 0;
	  ++passwd_sem;

a218 1
	  --passwd_sem;
d327 1
a327 1
  if (!group_sem && !passwd_sem)
d1742 1
a1742 1
  if (fdtab.not_open (fd))
d1748 1
a1748 1
  const char *path = fdtab[fd]->get_name ();
@


1.37
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d95 1
a95 1
  char *t;
d105 3
a107 1
  for (t = sid_buf + 4, i = 0; cnt < 8 && (t = strtok (t, "-")); t = NULL, ++i)
d2115 5
a2119 1
  for (char *c = strtok (buf, ","); c; c = strtok (NULL, ","))
@


1.36
log
@        * dir.cc (readdir): Fix shortcut==symlink condition.
        * environ.cc: Add extern decl for `allow_winsymlinks'.
        (struct parse_thing): Add entry for `[no]winsymlinks'.
        * path.cc (symlink): Change to be able to create both,
        symlink==shortcut and symlink==systemfile, dependent of
        the setting of `allow_winsymlinks'.
        * security.cc (cygwin_logon_user): Add debug output.
        * shortcut.c: Add defines from path.h.
        (has_exec_chars): Copy from path.h.
        (check_shortcut): Check for executable file condition if not a
        shortcut.
@
text
@d28 1
@


1.35
log
@Add copyright year 2001
@
text
@d460 1
d479 1
@


1.34
log
@        * Makefile.in: Add `-lshell32 -luuid' to link pass for new-cygwin1.dll.
        * autoload.cc: Add LoadDLLinitfunc for ole32.dll.
        Add LoadDLLfuncEx statements for CoInitialize@@4, CoUninitialize@@0
        and CoCreateInstance@@20.
        * dir.cc (dir_suffixes): New datastructure.
        (readdir): Check for R/O *.lnk files to hide the suffix.
        (opendir): Use `dir_suffixes' in path conversion.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::fstat): Add S_IFLNK flag
        before calling `get_file_attribute'. Take FILE_ATTRIBUTE_READONLY
        into account only if the file is no symlink.
        * path.cc (inner_suffixes): New datastructure.
        (SYMLINKATTR): Eliminated.
        (path_conv::check): Use `inner_suffixes' on inner path components.
        (shortcut_header): New global static variable.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): New function.
        (cmp_shortcut_header): Ditto.
        (symlink): Create symlinks by creating windows shortcuts. Preserve
        the old code.
        (symlink_info::check_shortcut): New method.
        (symlink_info::check_sysfile): Ditto.
        (symlink_info::check): Check for shortcuts. Move code reading
        old system attribute symlinks into symlink_info::check_sysfile().
        (chdir): Use `dir_suffixes' in path conversion.
        * security.cc (get_file_attribute): Check for S_IFLNK flag.
        Force 0777 permissions then.
        * spawn.cc (std_suffixes): Add ".lnk" suffix.
        * syscalls.cc (_unlink): Use `inner_suffixes' in path conversion.
        Check for shortcut symlinks to eliminate R/O attribute before
        calling DeleteFile().
        (stat_suffixes): Add ".lnk" suffix.
        (stat_worker): Force 0777 permissions if file is a symlink.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000 Cygnus Solutions.
d6 1
a6 1
   Extensions by Corinna Vinschen <corinna.vinschen@@cityweb.de>
@


1.33
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d811 2
d814 6
a819 1
    return get_nt_attribute (file, attribute, uidret, gidret);
d829 1
a829 2
  int res = NTReadEA (file, ".UNIXATTR",
		      (char *) attribute, sizeof (*attribute));
@


1.32
log
@        * autoload.cc: Add load statemant for SetSecurityDescriptorControl.
        * security.cc (alloc_sd): Always set SE_DACL_PROTECTED flag on
        Win2K and higher.
@
text
@d81 1
a81 1
  if (! psid || s > 5 || cnt < 1 || cnt > 8)
d99 1
a99 1
  if (! sid_str || strncmp (sid_str, "S-1-", 4))
d205 1
a205 1
      if (! search_grp)
d359 1
a359 1
  if (! name)
d478 1
a478 1
  if (! LogonUserA (nt_user, nt_domain, (char *) password,
d513 1
a513 1
  if (! sd_size)
d532 1
a532 1
  if (! GetFileSecurity (pfile,
d554 1
a554 1
  if (! sd_buf || ! sd_size)
d635 1
a635 1
  if (! OpenProcessToken (hMainProc, TOKEN_ADJUST_PRIVILEGES, &hToken))
d641 1
a641 1
  if (! LookupPrivilegeValue (NULL, SE_RESTORE_NAME, &restore_priv))
d651 1
a651 1
  if (! AdjustTokenPrivileges (hToken, FALSE, &new_priv, 0, NULL, NULL))
d676 1
a676 1
  /* Yeah, sounds too much, but I've seen SDs of 2100 bytes! */
d692 1
a692 1
  if (! GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
d694 1
a694 1
  if (! GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
d700 1
a700 1
  if (! GetSecurityDescriptorDacl (psd, &acl_exists, &acl, &dummy))
d714 1
a714 1
  if (! attribute)
d722 1
a722 1
  if (! acl_exists || ! acl)
d793 1
a793 1
	      if (! (ace->Mask & FILE_DELETE_CHILD)
d819 1
a819 1
  if (! attribute)
d825 1
a825 1
  /* symlinks are everything for everyone! */
d837 1
a837 1
  if (! AddAccessAllowedAce (acl, ACL_REVISION, attributes, sid))
d853 1
a853 1
  if (! AddAccessDeniedAce (acl, ACL_REVISION, attributes, sid))
d875 1
a875 1
  if (! sd_ret || ! sd_size_ret)
d888 2
a889 2
  if ((! pw || ! get_pw_sid (owner_sid, pw))
      && ! lookup_name (owner, logsrv, owner_sid))
d902 2
a903 2
      if ((! grp || ! get_gr_sid (group_sid, grp))
	  && ! lookup_name (grp->gr_name, logsrv, group_sid))
d912 1
a912 1
  if (! InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION))
d934 1
a934 1
  if (! SetSecurityDescriptorOwner(&sd, owner_sid, FALSE))
d941 1
a941 1
  if (group_sid && ! SetSecurityDescriptorGroup(&sd, group_sid, FALSE))
d950 1
a950 1
  if (! InitializeAcl (acl, 3072, ACL_REVISION))
d961 1
a961 1
  if (! (attribute & S_IXOTH))
d963 1
a963 1
  if (! (attribute & S_IFDIR))
d979 1
a979 1
  if (! (attribute & S_ISVTX))
d991 1
a991 1
  if (! (attribute & S_ISVTX))
d1003 1
a1003 1
  if (! (attribute & S_ISVTX))
d1023 1
a1023 1
      && ! add_access_denied_ace (acl, ace_off++, owner_deny,
d1027 1
a1027 1
  if (! add_access_allowed_ace (acl, ace_off++, owner_allow,
d1032 1
a1032 1
      && ! add_access_denied_ace (acl, ace_off++, group_deny,
d1036 1
a1036 1
  if (! add_access_allowed_ace (acl, ace_off++, group_allow,
d1043 1
a1043 1
  if (! GetSecurityDescriptorOwner (sd_ret, &cur_owner_sid, &dummy))
d1045 1
a1045 1
  if (! GetSecurityDescriptorGroup (sd_ret, &cur_group_sid, &dummy))
d1070 1
a1070 1
	  if (! AddAce(acl, ACL_REVISION,
d1083 1
a1083 1
  if (! add_access_allowed_ace (acl, ace_off++, other_allow,
d1092 1
a1092 1
  if (! SetSecurityDescriptorDacl (&sd, TRUE, acl, FALSE))
d1106 1
a1106 1
  if (! MakeSelfRelativeSD (&sd, sd_ret, sd_size_ret))
d1136 1
a1136 1
  if (! (psd = alloc_sd (uid, gid, logsrv, attribute, psd, &sd_size)))
d1147 1
a1147 1
  /* symlinks are anything for everyone! */
d1153 1
a1153 1
      if (! NTWriteEA (file, ".UNIXATTR",
d1205 1
a1205 1
  if (! GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
d1220 1
a1220 1
  if (! GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
d1235 1
a1235 1
  if (! InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION))
d1240 1
a1240 1
  if (! SetSecurityDescriptorOwner(&sd, owner_sid, FALSE))
d1246 1
a1246 1
      && ! SetSecurityDescriptorGroup(&sd, group_sid, FALSE))
d1264 1
a1264 1
  if (! InitializeAcl (acl, 3072, ACL_REVISION))
d1305 1
a1305 1
	  if (! add_access_allowed_ace (acl, ace_off++, allow,
d1312 2
a1313 2
	      || ! get_pw_sid (sid, pw)
	      || ! add_access_allowed_ace (acl, ace_off++, allow,
d1319 1
a1319 1
	  if (! add_access_allowed_ace (acl, ace_off++, allow,
d1326 2
a1327 2
	      || ! get_gr_sid (sid, gr)
	      || ! add_access_allowed_ace (acl, ace_off++, allow,
d1333 1
a1333 1
	  if (! add_access_allowed_ace (acl, ace_off++, allow,
d1343 1
a1343 1
  if (! SetSecurityDescriptorDacl (&sd, TRUE, acl, FALSE))
d1356 1
a1356 1
  if (! MakeSelfRelativeSD (&sd, psd, &sd_size))
d1410 1
a1410 1
  if (! GetSecurityDescriptorOwner (psd, &owner_sid, &dummy))
d1418 1
a1418 1
  if (! GetSecurityDescriptorGroup (psd, &group_sid, &dummy))
d1437 1
a1437 1
  if (! GetSecurityDescriptorDacl (psd, &acl_exists, &acl, &dummy))
d1446 1
a1446 1
  if (! acl_exists || ! acl)
d1594 1
a1594 1
	      if (! gr)
d1644 2
a1645 2
	  else if ((nofollow && ! lstat (path, &st))
		   || (!nofollow && ! stat (path, &st)))
d1919 1
a1919 1
  if (!aclbufp || nentries < 1 || ! modep)
d1954 1
a1954 1
  if (!aclbufp || nentries < 1 || ! modep)
@


1.31
log
@        * environ.cc (struct parse_thing): Add entry for new CYGWIN option
        `smbntsec'.
        * path.cc (path_conv::check): Check path for being a remote path.
        If so and `allow_smbntsec' is set to FALSE, set has_acls to FALSE.
        * security.cc: Add global definition for `allow_smbntsec'.
        * security.h: Add extern declaration for `allow_smbntsec'.
        * fhandler.cc (fhandler_disk_file::open): Eliminate extern declaration
        of `allow_ntsec'.
        * syscalls.cc: Ditto.
@
text
@d918 15
@


1.30
log
@* autoload.cc: Autoload CharToOemA.
* dcrt0.cc (dll_crt0_1): Translate command line to OEM if current codepage is
OEM.
* environ.cc: Add new option 'codepage' to CYGWIN environment variable.
* fhandler_clipboard.cc (fhandler_clipboard::read): Read clipboard in OEM mode
if current codepage is OEM.
* fhandler_console.cc (fhandler_console::read): Only translate console input if
current codepage is ANSI.
* fhandler_console.cc (fhandler_console::write_normal): Translate output data
if current codepage is ANSI.
* pinfo.cc (codepage_init): New function.  Setup current codepage from CYGWIN
environment variable and set codepage for file APIs.
* security.cc (read_sd): Translate file name to it if current codepage is OEM.
* winsup.h: (sys_wcstombs,sys_mbstowcs): Use current codepage for translations
between multibyte and widechar string and vice versa.
@
text
@d39 4
@


1.29
log
@        * cygheap.h: Move `token' and `impersonated' from class _pinfo
        to class cygheap_user.
        * pinfo.h: Ditto.
        * fork.cc (fork_child): Change usage of `token' and `impersonated'
        accordingly.
        (fork_parent): Ditto.
        * security.cc (cygwin_set_impersonation_token): Ditto.
        * sigproc.cc (proc_subproc): Ditto.
        * spawn.cc (spawn_guts): Ditto.
        * syscalls.cc (seteuid): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
@
text
@d25 2
d518 12
a529 2
  if (! GetFileSecurity (file,
			 OWNER_SECURITY_INFORMATION
@


1.28
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d425 1
a425 1
  if (myself->token != hToken)
d427 4
a430 4
      if (myself->token != INVALID_HANDLE_VALUE)
	CloseHandle (myself->token);
      myself->token = hToken;
      myself->impersonated = FALSE;
@


1.27
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d32 1
d330 1
a330 1
			   pw ? pw->pw_name : myself->username);
d356 1
a356 1
  if (*myself->domain)
d358 1
a358 1
      strcat (strcat (strcpy (domuser, myself->domain), "\\"), name);
d1142 1
a1142 1
			     attribute, myself->logsrv);
@


1.26
log
@* security.cc: Eliminate C++ comments throughout.
@
text
@d973 1
a973 1
  
@


1.25
log
@        * pinfo.cc (pinfo_init): Eliminate call to `set_process_privileges'.
        * security.cc (write_sd): Call `set_process_privileges' on the first
        call to `write_sd'.
        (set_process_privileges): Eliminate adjusting SE_BACKUP_NAME privilege.
@
text
@d775 1
a775 2
	      // Sticky bit for directories according to linux rules.
	      // No sense for files.
d808 1
a808 1
  // symlinks are anything for everyone!
d864 1
a864 1
  // Get SID and name of new owner
d878 1
a878 1
  // Get SID and name of new group
d892 1
a892 1
  // Initialize local security descriptor
d901 1
d907 3
a909 2
  if (group_sid
      && ! SetSecurityDescriptorGroup(&sd, group_sid, FALSE))
d915 1
a915 1
  // Initialize local access control list
d924 5
a928 3
  // VTX bit may only be set if executable for `other' is set.
  // For correct handling under WinNT, FILE_DELETE_CHILD has to
  // be (un)set in each ACE.
d934 1
a934 1
  // From here fill ACL
d938 1
a938 1
  // Construct allow attribute for owner
d950 1
a950 1
  // Construct allow attribute for group
d962 1
a962 1
  // Construct allow attribute for everyone
d974 1
a974 1
  // Construct deny attributes for owner and group
d986 1
a986 1
  // Construct appropriate inherit attribute
d989 1
a989 1
  // Set deny ACE for owner
d994 1
a994 1
  // Set allow ACE for owner
d998 1
a998 1
  // Set deny ACE for group
d1003 1
a1003 1
  // Set allow ACE for group
d1008 1
a1008 1
  // Get owner and group from current security descriptor
d1016 1
a1016 1
  // Fill ACL with unrelated ACEs from current security descriptor
d1026 1
a1026 1
	  // Check for related ACEs
d1033 5
a1037 3
	  // Add unrelated ACCESS_DENIED_ACE to the beginning but
	  // behind the owner_deny, ACCESS_ALLOWED_ACE to the end
	  // but in front of the `everyone' ACE.
d1050 1
a1050 1
  // Set allow ACE for everyone
d1055 1
a1055 1
  // Set AclSize to computed value
d1059 1
a1059 1
  // Create DACL for local security descriptor
d1066 1
a1066 1
  // Make self relative security descriptor
d1115 1
a1115 1
  // symlinks are anything for everyone!
d1171 1
a1171 1
  // Get owner SID
d1186 1
a1186 1
  // Get group SID
d1201 1
a1201 1
  // Initialize local security descriptor
d1220 1
a1220 1
  // Fill access control list
d1248 1
a1248 1
      // Set inherit property
d1251 5
a1255 3
      // If a specific acl contains a corresponding default entry with
      // identical permissions, only one Windows ACE with proper
      // inheritance bits is created.
d1265 1
a1265 1
	  // This eliminates the corresponding default entry.
d1307 1
a1307 1
  // Set AclSize to computed value
d1310 1
a1310 1
  // Create DACL for local security descriptor
d1316 1
a1316 1
  // Make self relative security descriptor in psd
d1525 1
a1525 1
  // Only check existance.
d1537 4
a1540 2
	      // Check if user is a NT group:
	      // Take SID from passwd, search SID in group, check is_grp_member
d1842 1
a1842 1
      // These checks are not ok yet since CLASS_OBJ isn't fully implemented.
@


1.24
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@d543 8
d615 1
a615 3
  LUID backup_priv;
  char buf[sizeof (TOKEN_PRIVILEGES) + 2 * sizeof (LUID_AND_ATTRIBUTES)];
  TOKEN_PRIVILEGES *new_priv = (TOKEN_PRIVILEGES *) buf;
d618 1
a618 3
  if (! OpenProcessToken (hMainProc,
			  TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			  &hToken))
a628 5
  if (! LookupPrivilegeValue (NULL, SE_BACKUP_NAME, &backup_priv))
    {
      __seterrno ();
      goto out;
    }
d630 3
a632 5
  new_priv->PrivilegeCount = 2;
  new_priv->Privileges[0].Luid = restore_priv;
  new_priv->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  new_priv->Privileges[1].Luid = backup_priv;
  new_priv->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;
d634 1
a634 1
  if (! AdjustTokenPrivileges (hToken, FALSE, new_priv, 0, NULL, NULL))
a640 3

  if (ret == -1)
    __seterrno ();
@


1.23
log
@* child_info: Bump child_info "version".
(child_info): Move some fields from child_info_spawn to here.
* cygheap.cc: Make cygheap pointers NOCOPY.
* dcrt0.cc (dll_crt0_1): Copy cygwin heap here regardless of whether we've been
forked or execed.
* dtable.cc (dtable::fixup_after_fork): Just release close-on-exec fds.
* exceptions.cc (stackdump): Respond to C warning.
* fork.cc: Reorganize to minimize stack copying.
(fork_child): New function.
(fork_parent): Ditto.
(sync_with_child): Don't suspend the forkee.
(sync_with_parent): Ditto.  Make into a function.
* heap.cc (heap_init): Add some debugging output.
* path.cc (path_conv::check): Add an assertion.
(has_suffix): Ditto.
* security.cc (get_pw_sid): Defend against NULL.
* sigproc.cc (proc_subproc): Fix debugging output.
(wait_sig): Ditto.
* strace.cc: Make statics NO_COPY throughout.
(strace::vsprntf): Defend against NULL.
@
text
@a604 1
  HANDLE hProcess = NULL;
d612 1
a612 8
  hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId ());
  if (! hProcess)
    {
      __seterrno ();
      goto out;
    }

  if (! OpenProcessToken (hProcess,
a650 2
  if (hProcess)
    CloseHandle (hProcess);
@


1.22
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d109 1
a109 1
  char *sp = strrchr (pw->pw_gecos, ',');
@


1.21
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d32 1
@


1.20
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d37 6
a42 6
        {SECURITY_NULL_SID_AUTHORITY},
        {SECURITY_WORLD_SID_AUTHORITY},
        {SECURITY_LOCAL_SID_AUTHORITY},
        {SECURITY_CREATOR_SID_AUTHORITY},
        {SECURITY_NON_UNIQUE_AUTHORITY},
        {SECURITY_NT_AUTHORITY}
d198 23
a220 23
        {
          if (passwd_sem > 0)
            return 0;
          ++passwd_sem;

          struct passwd *pw;
          while ((pw = getpwent ()) != NULL)
            {
              if (get_pw_sid (sid, pw) && EqualSid (psid, sid))
                {
                  id = pw->pw_uid;
                  break;
                }
            }
          endpwent ();
          --passwd_sem;
          if (id >= 0)
            {
              if (type)
                *type = USER;
              return id;
            }
        }
d222 23
a244 23
        {
          if (group_sem > 0)
            return 0;
          ++group_sem;

          struct group *gr;
          while ((gr = getgrent ()) != NULL)
            {
              if (get_gr_sid (sid, gr) && EqualSid (psid, sid))
                {
                  id = gr->gr_gid;
                  break;
                }
            }
          endgrent ();
          --group_sem;
          if (id >= 0)
            {
              if (type)
                *type = GROUP;
              return id;
            }
        }
d264 1
a264 1
                             domain, &dom_len, &acc_type))
d275 9
a283 9
            if (type)
              *type = GROUP;
            if (id == -1)
              {
                struct group *gr = getgrnam (account);
                if (gr)
                  id = gr->gr_gid;
              }
            break;
d285 7
a291 7
            if (type)
              *type = USER;
            if (id == -1)
              {
	        struct passwd *pw = getpwnam (account);
                if (pw)
                  id = pw->pw_uid;
d293 1
a293 1
            break;
d295 1
a295 1
            break;
d313 1
a313 1
                 || SidTypeAlias || SidTypeWellKnownGroup;
d327 2
a328 2
                           pw ? pw->pw_gid : myself->gid,
                           pw ? pw->pw_name : myself->username);
d331 2
a332 2
        if (grps[i] == gid)
          break;
d358 5
a362 5
                             sid, (sidlen = MAX_SID_LEN, &sidlen),
                             dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
                             &acc_type)
          && legal_sid_type (acc_type))
        goto got_it;
d364 6
a369 6
          && LookupAccountName (logsrv, domuser,
                                sid, (sidlen = MAX_SID_LEN, &sidlen),
                                dom, (domlen = MAX_COMPUTERNAME_LENGTH,&domlen),
                                &acc_type)
          && legal_sid_type (acc_type))
        goto got_it;
d374 5
a378 5
                             sid, (sidlen = MAX_SID_LEN, &sidlen),
                             dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
                             &acc_type)
          && legal_sid_type (acc_type))
        goto got_it;
d380 8
a387 8
        {
          strcat (strcat (strcpy (domuser, dom), "\\"), name);
          if (LookupAccountName (logsrv, domuser,
                                 sid,(sidlen = MAX_SID_LEN, &sidlen),
                                 dom,(domlen = MAX_COMPUTERNAME_LENGTH,&domlen),
                                 &acc_type))
            goto got_it;
        }
d390 3
a392 3
                         sid, (sidlen = MAX_SID_LEN, &sidlen),
                         dom, (domlen = 100, &domlen),
                         &acc_type)
d399 4
a402 4
                             sid, (sidlen = MAX_SID_LEN, &sidlen),
                             dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
                             &acc_type))
        goto got_it;
d410 1
a410 1
                              *GetSidSubAuthorityCount((PSID) sid) - 1));
d426 1
a426 1
        CloseHandle (myself->token);
d455 7
a461 7
          (c == pw->pw_gecos || c[-1] == ','))
        {
          usernamebuf[0] = '\0';
          strncat (usernamebuf, c + 2, 255);
          if ((c = strchr (usernamebuf, ',')) != NULL)
            *c = '\0';
        }
d471 3
a473 3
                    LOGON32_LOGON_INTERACTIVE,
                    LOGON32_PROVIDER_DEFAULT,
                    &hToken)
d475 2
a476 2
                                HANDLE_FLAG_INHERIT,
                                HANDLE_FLAG_INHERIT))
d515 4
a518 4
                         OWNER_SECURITY_INFORMATION
                         | GROUP_SECURITY_INFORMATION
                         | DACL_SECURITY_INFORMATION,
                         sd_buf, *sd_size, &len))
d544 6
a549 6
                   WRITE_OWNER | WRITE_DAC,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   &sec_none_nih,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                   NULL);
d583 2
a584 2
         FAT returns ERROR_INVALID_SECURITY_DESCR.
         This shouldn't return as error, but better be ignored. */
d667 1
a667 1
                  uid_t *uidret, gid_t *gidret)
d724 1
a724 1
                      file, *attribute, uid, gid);
d736 1
a736 1
        continue;
d738 1
a738 1
        continue;
d740 12
a751 12
        {
        case ACCESS_ALLOWED_ACE_TYPE:
          flags = &allow;
          anti = &deny;
          break;
        case ACCESS_DENIED_ACE_TYPE:
          flags = &deny;
          anti = &allow;
          break;
        default:
          continue;
        }
d755 8
a762 8
        {
          if (ace->Mask & FILE_READ_DATA)
            *flags |= S_IRUSR;
          if (ace->Mask & FILE_WRITE_DATA)
            *flags |= S_IWUSR;
          if (ace->Mask & FILE_EXECUTE)
            *flags |= S_IXUSR;
        }
d764 11
a774 11
        {
          if (ace->Mask & FILE_READ_DATA)
            *flags |= S_IRGRP
                      | ((grp_member && !(*anti & S_IRUSR)) ? S_IRUSR : 0);
          if (ace->Mask & FILE_WRITE_DATA)
            *flags |= S_IWGRP
                      | ((grp_member && !(*anti & S_IWUSR)) ? S_IWUSR : 0);
          if (ace->Mask & FILE_EXECUTE)
            *flags |= S_IXGRP
                      | ((grp_member && !(*anti & S_IXUSR)) ? S_IXUSR : 0);
        }
d776 22
a797 22
        {
          if (ace->Mask & FILE_READ_DATA)
            *flags |= S_IROTH
                      | ((!(*anti & S_IRGRP)) ? S_IRGRP : 0)
                      | ((!(*anti & S_IRUSR)) ? S_IRUSR : 0);
          if (ace->Mask & FILE_WRITE_DATA)
            *flags |= S_IWOTH
                      | ((!(*anti & S_IWGRP)) ? S_IWGRP : 0)
                      | ((!(*anti & S_IWUSR)) ? S_IWUSR : 0);
          if (ace->Mask & FILE_EXECUTE)
            {
              *flags |= S_IXOTH
                        | ((!(*anti & S_IXGRP)) ? S_IXGRP : 0)
                        | ((!(*anti & S_IXUSR)) ? S_IXUSR : 0);
              // Sticky bit for directories according to linux rules.
              // No sense for files.
              if (! (ace->Mask & FILE_DELETE_CHILD)
                  && S_ISDIR(*attribute)
                  && !(*anti & S_ISVTX))
                *flags |= S_ISVTX;
            }
        }
d808 1
a808 1
                    int *attribute, uid_t *uidret, gid_t *gidret)
d822 1
a822 1
                      (char *) attribute, sizeof (*attribute));
d834 1
a834 1
                             PSID sid, size_t &len_add, DWORD inherit)
d845 1
a845 1
             + GetLengthSid (sid);
d850 1
a850 1
                            PSID sid, size_t &len_add, DWORD inherit)
d861 1
a861 1
             + GetLengthSid (sid);
d891 1
a891 1
                *GetSidSubAuthority((PSID) owner_sid,
d902 2
a903 2
          && ! lookup_name (grp->gr_name, logsrv, group_sid))
        return NULL;
d952 1
a952 1
                      | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA;
d964 1
a964 1
                      | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d976 1
a976 1
                      | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d993 2
a994 2
                  | FILE_READ_ATTRIBUTES | FILE_READ_EA
                  | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA);
d1004 1
a1004 1
                                  owner_sid, acl_len, inherit))
d1008 1
a1008 1
                                owner_sid, acl_len, inherit))
d1013 1
a1013 1
                                  group_sid, acl_len, inherit))
d1017 1
a1017 1
                                group_sid, acl_len, inherit))
d1036 23
a1058 23
        {
          PSID ace_sid = (PSID) &ace->SidStart;
          // Check for related ACEs
          if ((cur_owner_sid && EqualSid (ace_sid, cur_owner_sid))
              || (owner_sid && EqualSid (ace_sid, owner_sid))
              || (cur_group_sid && EqualSid (ace_sid, cur_group_sid))
              || (group_sid && EqualSid (ace_sid, group_sid))
              || (EqualSid (ace_sid, get_world_sid ())))
            continue;
          // Add unrelated ACCESS_DENIED_ACE to the beginning but
          // behind the owner_deny, ACCESS_ALLOWED_ACE to the end
          // but in front of the `everyone' ACE.
          if (! AddAce(acl, ACL_REVISION,
                       ace->Header.AceType == ACCESS_DENIED_ACE_TYPE ?
                       (owner_deny ? 1 : 0) : MAXDWORD,
                       (LPVOID) ace, ace->Header.AceSize))
            {
              __seterrno ();
              return NULL;
            }
          acl_len += ace->Header.AceSize;
          ++ace_off;
        }
d1062 1
a1062 1
                                get_world_sid (), acl_len, inherit))
d1097 1
a1097 1
                  const char *logsrv, int attribute)
d1122 2
a1123 2
                    uid_t uid, gid_t gid,
                    int attribute, const char *logsrv)
d1132 1
a1132 1
                       (char *) &attribute, sizeof (attribute)))
d1150 2
a1151 2
                             myself->uid, myself->gid,
                             attribute, myself->logsrv);
d1161 1
a1161 1
        || !aclp[i].a_type)
d1250 1
a1250 1
                    | FILE_READ_ATTRIBUTES | FILE_READ_EA;
d1252 1
a1252 1
        allow |= FILE_GENERIC_READ;
d1254 2
a1255 2
        allow |= STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE
                 | DELETE | FILE_DELETE_CHILD;
d1257 1
a1257 1
        allow |= FILE_GENERIC_EXECUTE;
d1260 1
a1260 1
                          ? INHERIT_ONLY : DONT_INHERIT;
d1265 11
a1275 11
          && (pos = searchace (aclbufp, nentries,
                               aclbufp[i].a_type | ACL_DEFAULT,
                               (aclbufp[i].a_type & (USER|GROUP))
                               ? aclbufp[i].a_id : -1)) >= 0
          && pos < nentries
          && aclbufp[i].a_perm == aclbufp[pos].a_perm)
        {
          inheritance = INHERIT_ALL;
          // This eliminates the corresponding default entry.
          aclbufp[pos].a_type = 0;
        }
d1277 37
a1313 37
        {
        case USER_OBJ:
        case DEF_USER_OBJ:
          allow |= STANDARD_RIGHTS_ALL & ~DELETE;
          if (! add_access_allowed_ace (acl, ace_off++, allow,
                                        owner_sid, acl_len, inheritance))
            return -1;
          break;
        case USER:
        case DEF_USER:
          if (!(pw = getpwuid (aclbufp[i].a_id))
              || ! get_pw_sid (sid, pw)
              || ! add_access_allowed_ace (acl, ace_off++, allow,
                                           sid, acl_len, inheritance))
            return -1;
          break;
        case GROUP_OBJ:
        case DEF_GROUP_OBJ:
          if (! add_access_allowed_ace (acl, ace_off++, allow,
                                        group_sid, acl_len, inheritance))
            return -1;
          break;
        case GROUP:
        case DEF_GROUP:
          if (!(gr = getgrgid (aclbufp[i].a_id))
              || ! get_gr_sid (sid, gr)
              || ! add_access_allowed_ace (acl, ace_off++, allow,
                                           sid, acl_len, inheritance))
            return -1;
          break;
        case OTHER_OBJ:
        case DEF_OTHER_OBJ:
          if (! add_access_allowed_ace (acl, ace_off++, allow,
                                        get_world_sid(), acl_len, inheritance))
            return -1;
          break;
        }
d1425 1
a1425 1
        lacl[pos].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
d1436 1
a1436 1
        continue;
d1443 4
a1446 4
        {
          type = USER_OBJ;
          id = uid;
        }
d1448 4
a1451 4
        {
          type = GROUP_OBJ;
          id = gid;
        }
d1453 4
a1456 4
        {
          type = OTHER_OBJ;
          id = 0;
        }
d1458 13
a1470 13
        {
          id = get_id_from_sid (ace_sid, FALSE, &type);
          if (type != GROUP)
            {
              int type2 = 0;
              int id2 = get_id_from_sid (ace_sid, TRUE, &type2);
              if (type2 == GROUP)
                {
                  id = id2;
                  type = GROUP;
                }
            }
        }
d1472 1
a1472 1
        continue;
d1474 4
a1477 4
        {
          if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
            getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
        }
d1479 6
a1484 6
          && (attr & FILE_ATTRIBUTE_DIRECTORY))
        {
          type |= ACL_DEFAULT;
          if ((pos = searchace (lacl, MAX_ACL_ENTRIES, type, id)) >= 0)
            getace (lacl[pos], type, id, ace->Mask, ace->Header.AceType);
        }
d1491 1
a1491 1
                       & ~((lacl[i].a_perm & S_IRWXG) << 3);
d1493 1
a1493 1
                        | (lacl[i].a_perm & S_IRWXU) >> 6;
d1501 1
a1501 1
          lacl[searchace (lacl, MAX_ACL_ENTRIES, GROUP_OBJ)].a_perm;
d1540 43
a1582 43
        {
        case USER_OBJ:
        case USER:
          if (acls[i].a_id != myself->uid)
            {
              // Check if user is a NT group:
              // Take SID from passwd, search SID in group, check is_grp_member
              char owner_sidbuf[MAX_SID_LEN];
              PSID owner_sid = (PSID) owner_sidbuf;
              char group_sidbuf[MAX_SID_LEN];
              PSID group_sid = (PSID) group_sidbuf;
              struct passwd *pw;
              struct group *gr = NULL;

              if (group_sem > 0)
                continue;
              ++group_sem;
              if ((pw = getpwuid (acls[i].a_id)) != NULL
                  && get_pw_sid (owner_sid, pw))
                {
                  while ((gr = getgrent ()))
                    if (get_gr_sid (group_sid, gr)
                        && EqualSid (owner_sid, group_sid)
                        && is_grp_member (myself->uid, gr->gr_gid))
                      break;
                  endgrent ();
                }
              --group_sem;
              if (! gr)
                continue;
            }
          break;
        case GROUP_OBJ:
        case GROUP:
          if (acls[i].a_id != myself->gid &&
              !is_grp_member (myself->uid, acls[i].a_id))
            continue;
          break;
        case OTHER_OBJ:
          break;
        default:
          continue;
        }
d1584 3
a1586 3
          && (!(flags & W_OK) || (acls[i].a_perm & S_IWRITE))
          && (!(flags & X_OK) || (acls[i].a_perm & S_IEXEC)))
        return 0;
d1595 1
a1595 1
            int nofollow)
d1611 54
a1664 54
        {
        case SETACL:
          set_errno (ENOSYS);
          break;
        case GETACL:
          if (nentries < 1)
            set_errno (EINVAL);
          else if ((nofollow && ! lstat (path, &st))
                   || (!nofollow && ! stat (path, &st)))
            {
              aclent_t lacl[4];
              if (nentries > 0)
                {
                  lacl[0].a_type = USER_OBJ;
                  lacl[0].a_id = st.st_uid;
                  lacl[0].a_perm = (st.st_mode & S_IRWXU)
                                   | (st.st_mode & S_IRWXU) >> 3
                                   | (st.st_mode & S_IRWXU) >> 6;
                }
              if (nentries > 1)
                {
                  lacl[1].a_type = GROUP_OBJ;
                  lacl[1].a_id = st.st_gid;
                  lacl[1].a_perm = (st.st_mode & S_IRWXG)
                                   | (st.st_mode & S_IRWXG) << 3
                                   | (st.st_mode & S_IRWXG) >> 3;
                }
              if (nentries > 2)
                {
                  lacl[2].a_type = OTHER_OBJ;
                  lacl[2].a_id = 0;
                  lacl[2].a_perm = (st.st_mode & S_IRWXO)
                                   | (st.st_mode & S_IRWXO) << 6
                                   | (st.st_mode & S_IRWXO) << 3;
                }
              if (nentries > 3)
                {
                  lacl[3].a_type = CLASS_OBJ;
                  lacl[3].a_id = 0;
                  lacl[3].a_perm = (st.st_mode & S_IRWXG)
                                   | (st.st_mode & S_IRWXG) << 3
                                   | (st.st_mode & S_IRWXG) >> 3;
                }
              if (nentries > 4)
                nentries = 4;
              if (aclbufp)
                memcpy (aclbufp, lacl, nentries * sizeof (aclent_t));
              ret = nentries;
            }
          break;
        case GETACLCNT:
          ret = 4;
          break;
        }
d1671 4
a1674 4
        if (!aclsort(nentries, 0, aclbufp))
          return setacl (real_path.get_win32 (),
                         nentries, aclbufp);
        break;
d1676 5
a1680 5
        if (nentries < 1)
          break;
        return getacl (real_path.get_win32 (),
                       real_path.file_attributes (),
                       nentries, aclbufp);
d1682 3
a1684 3
        return getacl (real_path.get_win32 (),
                       real_path.file_attributes (),
                       0, NULL);
d1686 1
a1686 1
        break;
d1748 8
a1755 8
        if (has_user_obj)
          {
            if (which)
              *which = pos;
            return USER_ERROR;
          }
        has_user_obj = TRUE;
        break;
d1757 8
a1764 8
        if (has_group_obj)
          {
            if (which)
              *which = pos;
            return GRP_ERROR;
          }
        has_group_obj = TRUE;
        break;
d1766 8
a1773 8
        if (has_other_obj)
          {
            if (which)
              *which = pos;
            return OTHER_ERROR;
          }
        has_other_obj = TRUE;
        break;
d1775 8
a1782 8
        if (has_class_obj)
          {
            if (which)
              *which = pos;
            return CLASS_ERROR;
          }
        has_class_obj = TRUE;
        break;
d1785 9
a1793 9
        if ((pos2 = searchace (aclbufp + pos + 1, nentries - pos - 1,
                               aclbufp[pos].a_type, aclbufp[pos].a_id)) >= 0)
          {
            if (which)
              *which = pos2;
            return DUPLICATE_ERROR;
          }
        has_ug_objs = TRUE;
        break;
d1795 8
a1802 8
        if (has_def_user_obj)
          {
            if (which)
              *which = pos;
            return USER_ERROR;
          }
        has_def_user_obj = TRUE;
        break;
d1804 8
a1811 8
        if (has_def_group_obj)
          {
            if (which)
              *which = pos;
            return GRP_ERROR;
          }
        has_def_group_obj = TRUE;
        break;
d1813 8
a1820 8
        if (has_def_other_obj)
          {
            if (which)
              *which = pos;
            return OTHER_ERROR;
          }
        has_def_other_obj = TRUE;
        break;
d1822 8
a1829 8
        if (has_def_class_obj)
          {
            if (which)
              *which = pos;
            return CLASS_ERROR;
          }
        has_def_class_obj = TRUE;
        break;
d1832 9
a1840 9
        if ((pos2 = searchace (aclbufp + pos + 1, nentries - pos - 1,
                               aclbufp[pos].a_type, aclbufp[pos].a_id)) >= 0)
          {
            if (which)
              *which = pos2;
            return DUPLICATE_ERROR;
          }
        has_def_ug_objs = TRUE;
        break;
d1842 1
a1842 1
        return ENTRY_ERROR;
d1855 1
a1855 1
        *which = -1;
d1939 2
a1940 2
                        | (*modep & S_IRWXU) >> 3
                        | (*modep & S_IRWXU) >> 6;
d1949 2
a1950 2
                        | (*modep & S_IRWXG) << 3
                        | (*modep & S_IRWXG) >> 3;
d1957 2
a1958 2
                        | (*modep & S_IRWXO) << 6
                        | (*modep & S_IRWXO) << 3;
d2005 1
a2005 1
        strcat (buf, ",");
d2008 1
a2008 1
        strcat (buf, "default");
d2010 29
a2038 29
        {
        case USER_OBJ:
          __small_sprintf (buf + strlen (buf), "user::%s",
                   permtostr (aclbufp[pos].a_perm));
          break;
        case USER:
          __small_sprintf (buf + strlen (buf), "user:%d:%s",
                   aclbufp[pos].a_id, permtostr (aclbufp[pos].a_perm));
          break;
        case GROUP_OBJ:
          __small_sprintf (buf + strlen (buf), "group::%s",
                   permtostr (aclbufp[pos].a_perm));
          break;
        case GROUP:
          __small_sprintf (buf + strlen (buf), "group:%d:%s",
                   aclbufp[pos].a_id, permtostr (aclbufp[pos].a_perm));
          break;
        case CLASS_OBJ:
          __small_sprintf (buf + strlen (buf), "mask::%s",
                   permtostr (aclbufp[pos].a_perm));
          break;
        case OTHER_OBJ:
          __small_sprintf (buf + strlen (buf), "other::%s",
                   permtostr (aclbufp[pos].a_perm));
          break;
        default:
          set_errno (EINVAL);
          return NULL;
        }
d2081 4
a2084 4
        {
          lacl[pos].a_type |= ACL_DEFAULT;
          c += 7;
        }
d2086 27
a2112 27
        {
          if (c[5] == ':')
            lacl[pos].a_type |= USER_OBJ;
          else
            {
              lacl[pos].a_type |= USER;
              c += 5;
              if (isalpha (*c))
                {
                  struct passwd *pw = getpwnam (c);
                  if (!pw)
                    {
                      set_errno (EINVAL);
                      return NULL;
                    }
                  lacl[pos].a_id = pw->pw_uid;
                  c = strchr (c, ':');
                }
              else if (isdigit (*c))
                lacl[pos].a_id = strtol (c, &c, 10);
              if (!c || *c != ':')
                {
                  set_errno (EINVAL);
                  return NULL;
                }
            }
        }
d2114 27
a2140 27
        {
          if (c[5] == ':')
            lacl[pos].a_type |= GROUP_OBJ;
          else
            {
              lacl[pos].a_type |= GROUP;
              c += 5;
              if (isalpha (*c))
                {
                  struct group *gr = getgrnam (c);
                  if (!gr)
                    {
                      set_errno (EINVAL);
                      return NULL;
                    }
                  lacl[pos].a_id = gr->gr_gid;
                  c = strchr (c, ':');
                }
              else if (isdigit (*c))
                lacl[pos].a_id = strtol (c, &c, 10);
              if (!c || *c != ':')
                {
                  set_errno (EINVAL);
                  return NULL;
                }
            }
        }
d2142 9
a2150 9
        {
          if (c[5] == ':')
            lacl[pos].a_type |= CLASS_OBJ;
          else
            {
              set_errno (EINVAL);
              return NULL;
            }
        }
d2152 9
a2160 9
        {
          if (c[5] == ':')
            lacl[pos].a_type |= OTHER_OBJ;
          else
            {
              set_errno (EINVAL);
              return NULL;
            }
        }
d2162 4
a2165 4
        {
          set_errno (EINVAL);
          return NULL;
        }
@


1.19
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d25 3
d29 2
a31 1
#include "cygerrno.h"
d58 1
a58 1
  sprintf(t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
d62 1
a62 1
      sprintf(t, "-%lu", *GetSidSubAuthority (psid, i));
d2012 1
a2012 1
          sprintf (buf + strlen (buf), "user::%s",
d2016 1
a2016 1
          sprintf (buf + strlen (buf), "user:%d:%s",
d2020 1
a2020 1
          sprintf (buf + strlen (buf), "group::%s",
d2024 1
a2024 1
          sprintf (buf + strlen (buf), "group:%d:%s",
d2028 1
a2028 1
          sprintf (buf + strlen (buf), "mask::%s",
d2032 1
a2032 1
          sprintf (buf + strlen (buf), "other::%s",
@


1.18
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d27 1
@


1.17
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d25 2
@


1.16
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d1704 1
a1704 1
  if (dtable.not_open (fd))
d1710 1
a1710 1
  const char *path = dtable[fd]->get_name ();
@


1.15
log
@        * security.cc (lookup_name): Search on local machine first if
        myself->domain is not empty.
@
text
@d14 1
a23 1
#include "winsup.h"
@


1.14
log
@        * security.cc (acl_worker): Use stat_suffixes in call to path_conv
        just as in `stat_worker'.
@
text
@d347 17
@


1.13
log
@Throughout, eliminate third argument to path_conv and use new PC_* constants
for second argument.
* path.h: Generalize SYMLINK_* constants to PC_*.
(path_conv): Create a new method.  Fold third argument into second.
* dll_init.cc (dll_list::alloc): Try harder to find space to allocate dll
struct.
(dll_dllcrt0): Don't check sanity if we've already called dll_crt0.
* path.cc (path_conv::check): Don't check for a null or empty path unless
specifically told with a flag setting.
(check_null_empty_path): New function, adapted from macro.
* syscalls.cc (_rename): Use already-determined file attributes rather than
checking again.
* lib/cygwin/cygwin_attach.dll.c (cygwin_attach_dll): Use a static per_process
structure since this is apparently supposed to be zeroed.
* lib/cygwin_crt0.c (cygwin_crt0): Zero per_process structure sent to older
DLLs.
@
text
@d1573 2
a1574 1
  path_conv real_path (path, (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW) | PC_FULL);
@


1.12
log
@        * security.cc (read_sd): Eliminate OemToChar.
@
text
@d1573 1
a1573 1
  path_conv real_path (path, nofollow ? SYMLINK_NOFOLLOW : SYMLINK_FOLLOW, 1);
@


1.11
log
@        * winsup.h: Define MAX_SID_LEN and new MAX_HOST_NAME.
        * fork.cc (fork): Use above defines instead of numerical constants.
        * shared.cc (sec_user): Ditto.
        * shared.h (class pinfo): Ditto.
        * syscall.cc (seteuid): Ditto.
        * spawn.cc (_spawnve): Ditto. Eliminate conditional.
        (spawn_guts): Set child->uid = USHRT_MAX when user context will be
        changed in child process.
        * uinfo.cc (uinfo_init): Check for myself->uid instead of myself->psid
        to avoid reloading of /etc/passwd on process startup if ntsec is off.
        Use above defines instead of numerical constants.
        * security.cc: Move define for MAX_SID_LEN to winsup.h.
@
text
@d490 1
a490 3
  char fbuf[PATH_MAX];
  OemToChar(file, fbuf);
  if (! GetFileSecurity (fbuf,
@


1.10
log
@        * dcrt0.cc: Add load statements for `GetSidIdentifierAuthority'
        and `RegLoadKeyA'.
        * registry.cc (get_registry_hive_path): New function.
        (load_registry_hive): Ditto.
        * security.cc (convert_sid_to_string_sid): New function.
        (get_ssid): Renamed to `convert_string_sid_to_sid'.
        (get_pw_sid): Call `convert_string_sid_to_sid' instead of `get_ssid'.
        (get_gr_sid): Ditto.
        (get_admin_sid): Ditto.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * shared.h: New prototypes for `get_registry_hive_path' and
        `load_registry_hive'.
        * spawn.cc (spawn_guts): Set child->psid to NULL to force calling
        `internal_getlogin' from child process in case of changing user context.
        Call `load_registry_hive' in case of changing user context.
        (_spawnve): Copy user infos only if user context remains the same.
        * uinfo.cc: Add load statement for `NetUserGetInfo'.
        Remove load statement for `NetGetDCName'.
        (internal_getlogin): Rewrite to speed up process startup
        and to correct user environment in case user context changes.
        (uinfo_init): Call internal_getlogin only if myself->psid is NULL,
        that is user context changes.
        * winsup.h: Add prototypes for `convert_sid_to_string_sid',
        `convert_string_sid_to_sid' and `get_pw_sid'.
@
text
@a25 2
#define MAX_SID_LEN     40

@


1.9
log
@        * cygwin.din: Define symbols for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        * dcrt0.cc (dll_crt0_1): Eliminate superfluous conditional
        statements.
        Add load statements for `ImpersonateLoggedOnUser', `LogonUserA'
        and `RevertToSelf'.
        * fork.cc (fork): Care for correct impersonation of parent
        and child process.
        * security.cc (cygwin_set_impersonation_token): New function.
        (cygwin_logon_user): Ditto.
        shared.h (class pinfo): New members `orig_uid', `orig_gid',
        `real_uid' nad `real_gid'.
        spawn.cc (spawn_guts): Care for impersonation when starting
        child process in a different user context.
        * syscalls.cc (setgid): Call `setegid' now. Set real_gid.
        (setuid): Call `seteuid' now. Set real_uid.
        (seteuid): Functionality moved from setuid to here. Care for
        correct impersonation.
        (setegid): Functionality moved from setgid to here.
        * uinfo.cc (uinfo_init): Initialization of additional pinfo
        members.
        (getuid): Return real uid.
        (getgid): Return real gid.
        (geteuid): Return effective uid.
        (getegid): Return effective gid.
        include/sys/cygwin.h: Add prototypes for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        include/cygwin/version.h: Bumb API minor version to 22.
@
text
@d44 19
d78 1
a78 1
get_ssid (PSID psid, const char *sid_str)
d107 1
a107 1
  return get_ssid (sid, ++sp) != NULL;
d113 1
a113 1
  return get_ssid (sid, gr->gr_passwd) != NULL;
d125 1
a125 1
      get_ssid (admin_sid, "S-1-5-32-544");
d139 1
a139 1
      get_ssid (system_sid, "S-1-5-18");
d153 1
a153 1
      get_ssid (owner_sid, "S-1-3-0");
d167 1
a167 1
      get_ssid (world_sid, "S-1-1-0");
@


1.8
log
@        * dir.cc (writable_directory): Comment out previous code,
        return always 1 for now.
        (mkdir): Call set_file_attribute explicitely with S_IFDIR mode bit.
        * syscalls.cc (chown_worker): Ditto.
        (chmod): Ditto.
        * security.cc (get_nt_attribute): Fix error in debug output.
        Never set FILE_DELETE_CHILD for files.
        Construct appropriate inherit attribute according to file type.
@
text
@d377 67
@


1.7
log
@        * security.cc (read_sd): Return 1 on success because we
        can't rely on the returned SD size from GetFileSecurity.
@
text
@d608 1
a608 1
      syscall_printf ("file: %s uid %d, gid %d", uid, gid);
d837 2
d892 3
d898 1
a898 1
                                  owner_sid, acl_len, INHERIT_ALL))
d902 1
a902 1
                                owner_sid, acl_len, INHERIT_ALL))
d907 1
a907 1
                                  group_sid, acl_len, INHERIT_ALL))
d911 1
a911 1
                                group_sid, acl_len, INHERIT_ALL))
d956 1
a956 1
                                get_world_sid (), acl_len, INHERIT_ALL))
@


1.6
log
@        * dcrt0.cc: Add dynamic load code for `OemToCharA' from user32.dll.
        * security.cc (read_sd): Call `OemToCharA' to make
        `GetFileSecurity' happy on filenames with umlauts.
@
text
@d379 12
a390 7
   If the file doesn't have a SD, 0 is returned.
   Otherwise, the size of the SD is returned and
   the SD is copied to the buffer, pointed to by sd_buf.
   sd_size contains the size of the buffer. If
   it's too small, to contain the complete SD, 0 is
   returned and sd_size is set to the needed size
   of the buffer.
d423 1
a423 1
  return len;
@


1.5
log
@        * fhandler.cc (fhandler_disk_file::open): Check for allow_ntsec
        when determining exec flag.
        * path.cc (symlink_info::check): Remove call to get_file_attribute().
        * security.cc (read_sd): Rename, ditto for variables to conform
        to common naming convention. Use GetFileSecurity() instead of
        BackupRead() to avoid permission problems when reading ACLs.
        (write_sd): Same renaming as for read_sd().
        (alloc_sd): Change default permissions according to Linux permissions
        for group and world when write permission is set.
        * syscalls.cc (stat_worker): Avoid different permission problems
        when requesting file informations.
@
text
@d401 3
a403 1
  if (! GetFileSecurity (file,
d412 1
@


1.4
log
@	* cygwin.din: Add symbol for `lacl'.
	* security.cc (ReadSD): Add debug output.
	(acl_worker):  New static function.
	(acl): Call acl_worker now.
	(lacl): New function.
	(facl): Call acl_worker now.
	* include/cygwin/acl.h: Add prototype for `lacl'.
@
text
@d377 1
a377 1
/* ReadSD reads a security descriptor from a file.
d381 2
a382 2
   the SD is copied to the buffer, pointed to by sdBuf.
   sdBufSize contains the size of the buffer. If
d384 1
a384 1
   returned and sdBufSize is set to the needed size
d389 1
a389 1
ReadSD(const char *file, PSECURITY_DESCRIPTOR sdBuf, LPDWORD sdBufSize)
d392 1
a392 1
  if (! sdBufSize)
a397 1
  /* Open file for read */
a398 5
  HANDLE hFile = CreateFile (file, GENERIC_READ,
			     FILE_SHARE_READ | FILE_SHARE_WRITE,
			     &sec_none_nih, OPEN_EXISTING,
			     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
			     NULL);
d400 6
a405 1
  if (hFile == INVALID_HANDLE_VALUE)
d410 4
a413 51

  /* step through the backup streams and search for the security data */
  WIN32_STREAM_ID header;
  DWORD bytes_read = 0;
  LPVOID context = NULL;
  PSECURITY_DESCRIPTOR psd = NULL;
  DWORD datasize;
  LONG ret = 0;

  while (BackupRead (hFile, (LPBYTE) &header,
		     3 * sizeof (DWORD) + sizeof (LARGE_INTEGER),
		     &bytes_read, FALSE, TRUE, &context))
    {
      if (header.dwStreamId != BACKUP_SECURITY_DATA)
	continue;

      /* security data found */
      datasize = header.Size.LowPart + header.dwStreamNameSize;
      char b[datasize];

      if (! BackupRead (hFile, (LPBYTE) b, datasize, &bytes_read,
			FALSE, TRUE, &context))
	{
	  __seterrno ();
	  ret = -1;
	  break;
	}

      /* Check validity of the SD */
      psd = (PSECURITY_DESCRIPTOR) &b[header.dwStreamNameSize];
      if (! IsValidSecurityDescriptor (psd))
	continue;

      /* It's a valid SD */
      datasize -= header.dwStreamNameSize;
      debug_printf ("SD-Size: %d", datasize);

      /* buffer to small? */
      if (*sdBufSize < datasize)
	{
	  *sdBufSize = datasize;
	  ret = 0;
	  break;
	}

      if (sdBuf)
	memcpy (sdBuf, psd, datasize);

      ret = *sdBufSize = datasize;
      break;

d415 1
a415 3
  BackupRead (hFile, NULL, 0, &bytes_read, TRUE, TRUE, &context);
  CloseHandle (hFile);
  return ret;
d419 1
a419 1
WriteSD(const char *file, PSECURITY_DESCRIPTOR sdBuf, DWORD sdBufSize)
d422 1
a422 1
  if (! sdBuf || ! sdBufSize)
d428 8
a435 7
  HANDLE hFile = CreateFile (file,
			     WRITE_OWNER | WRITE_DAC,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &sec_none_nih,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);
d437 1
a437 1
  if (hFile == INVALID_HANDLE_VALUE)
d452 1
a452 1
  header.Size.LowPart = sdBufSize;
d454 1
a454 1
  if (!BackupWrite (hFile, (LPBYTE) &header,
d459 1
a459 1
      CloseHandle (hFile);
d464 1
a464 1
  if (!BackupWrite (hFile, (LPBYTE) sdBuf,
d475 2
a476 2
	  BackupWrite (hFile, NULL, 0, &bytes_written, TRUE, TRUE, &context);
	  CloseHandle (hFile);
d482 2
a483 2
  BackupWrite (hFile, NULL, 0, &bytes_written, TRUE, TRUE, &context);
  CloseHandle (hFile);
d566 1
a566 1
  if ((ret = ReadSD (file, psd, &sd_size)) <= 0)
d568 1
a568 1
      debug_printf ("ReadSD %E");
d693 2
a694 2
get_file_attribute (int use_ntsec, const char *file, int *attribute,
                    uid_t *uidret, gid_t *gidret)
d852 1
a852 1
    group_allow |= STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | DELETE;
d864 1
a864 1
    other_allow |= STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | DELETE;
d988 1
a988 1
  if ((ret = ReadSD (file, psd, &sd_size)) <= 0)
d990 1
a990 1
      debug_printf ("ReadSD %E");
d998 1
a998 1
  return WriteSD (file, psd, sd_size);
d1054 1
a1054 1
  if (ReadSD (file, psd, &sd_size) <= 0)
d1056 1
a1056 1
      debug_printf ("ReadSD %E");
d1219 1
a1219 1
  return WriteSD (file, psd, sd_size);
d1255 1
a1255 1
  if ((ret = ReadSD (file, psd, &sd_size)) <= 0)
d1257 1
a1257 1
      debug_printf ("ReadSD %E");
@


1.3
log
@        * security.cc (set_process_privileges): Removed `static'.
        (get_nt_attribute): Returns uid and gid additionally. Removed call
        to set_process_privileges().
        (get_file_attribute): Returns uid and gid additionally. Don't
        call ntea if ntsec is ON.
        (set_nt_attribute): Removed call to set_process_privileges().
        Don't call ntea if ntsec is ON.
        (acl): Removed call to set_process_privileges().
        * dcrt0.cc (dll_crt0_1): Calls set_process_privileges() now.
        * winsup.h: New prototype for set_process_privileges(),
        changed prototype for get_file_attribute().
        * fhandler.cc (get_file_owner): Discarded.
        (get_file_group): Ditto.
        (fhandler_disk_file::fstat): Discard calls to get_file_owner() and
        get_file_group().
        * path.cc (path_conv::path_conv): Added debugging output for result
        of GetVolumeInformation().
        (mount_info::conv_to_win32_path): Call backslashify() with pathbuf
        instead of src_path.
        * syscalls.cc (chown): Reformatted.
        (chmod): Replace get_file_owner() and get_file_group() calls
        by a call to get_file_attribute(). Discard local variable has_acls.
        Slightly reformatted.
        (stat_worker): Replaced idiot's (it's me) root dir check by call
        to rootdir(). Don't call num_entries() on remote drives.
        Discard local variable has_acls.
@
text
@d399 1
d1522 1
a1522 1
extern "C"
d1524 2
a1525 1
acl (const char *path, int cmd, int nentries, aclent_t *aclbufp)
d1527 1
a1527 1
  path_conv real_path (path);
d1547 2
a1548 1
          else if (! stat (path, &st))
d1624 14
d1654 1
a1654 1
  return acl (path, cmd, nentries, aclbufp);
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d535 1
a535 1
static int
d600 2
a601 1
get_nt_attribute (const char *file, int *attribute)
a607 3
  if (set_process_privileges () < 0)
    return -1;

d639 15
d657 2
a658 1
      syscall_printf ("file: %s No ACL = %x", file, *attribute);
a661 3
  BOOL grp_member = is_grp_member (get_uid_from_sid (owner_sid),
                                   get_gid_from_sid (group_sid));

d736 1
a736 1
  syscall_printf ("file: %s %x", file, *attribute);
d741 2
a742 1
get_file_attribute (int use_ntsec, const char *file, int *attribute)
d744 2
a745 5
  if (!attribute)
    {
      set_errno (EINVAL);
      return -1;
    }
d747 4
a750 1
  int res;
d752 2
a753 6
  if (use_ntsec && allow_ntsec)
    {
      res = get_nt_attribute (file, attribute);
      if (!res)
        return 0;
    }
d755 2
a756 1
  res = NTReadEA (file, ".UNIXATTR", (char *) attribute, sizeof (*attribute));
d762 3
a764 4
  if (res > 0)
    return 0;
  set_errno (ENOSYS);
  return -1;
a1030 3
  if (set_process_privileges () < 0)
    return -1;

a1057 2
  BOOL ret = NTWriteEA (file, ".UNIXATTR",
			(char *) &attribute, sizeof (attribute));
d1060 2
a1061 1
      if (! ret)
d1069 1
a1069 1
  int ret2 = set_nt_attribute (file, uid, gid, logsrv, attribute);
d1071 2
a1072 2
		  ret2, file, uid, gid, attribute);
  return ret2;
a1524 3
  if (set_process_privileges () < 0)
    return -1;

@


1.1
log
@Initial revision
@
text
@d1785 1
a1785 1
aclsort (int nentries, int calclass, aclent_t *aclbufp)
d1978 1
a1978 1
aclfromtext (char *acltextp, int *aclcnt)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
