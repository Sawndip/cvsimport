head	1.37;
access;
symbols
	cygwin-1_7_35-release:1.37
	cygwin-1_7_34-release:1.35
	cygwin-1_7_33-release:1.34.2.1
	cygwin-1_7_32-release:1.34
	cygwin-1_7_31-release:1.34
	cygwin-1_7_30-release:1.34
	cygwin-1_7_29-release:1.34
	cygwin-1_7_29-release-branchpoint:1.34.0.2
	cygwin-pre-user-db:1.34
	cygwin-1_7_28-release:1.34
	cygwin-1_7_27-release:1.34
	cygwin-1_7_26-release:1.34
	cygwin-1_7_25-release:1.34
	cygwin-1_7_24-release:1.34
	cygwin-1_7_23-release:1.34
	cygwin-1_7_22-release:1.34
	cygwin-1_7_21-release:1.34
	cygwin-1_7_20-release:1.33
	cygwin-1_7_19-release:1.33
	cygwin-64bit-postmerge:1.33
	cygwin-64bit-premerge-branch:1.32.0.2
	cygwin-64bit-premerge:1.32
	cygwin-1_7_18-release:1.32
	post-ptmalloc3:1.30.2.4
	pre-ptmalloc3:1.30.2.4
	cygwin-1_7_17-release:1.31
	cygwin-64bit-branch:1.30.0.2
	cygwin-1_7_16-release:1.28
	cygwin-1_7_15-release:1.26
	cygwin-1_7_14_2-release:1.26
	cygwin-1_7_14-release:1.26
	cygwin-1_7_12-release:1.26
	cygwin-1_7_11-release:1.26
	cygwin-1_7_10-release:1.26
	signal-rewrite:1.26.0.2
	pre-notty:1.26
	cygwin-1_7_9-release:1.18
	cv-post-1_7_9:1.18.0.2
	cygwin-1_7_8-release:1.17
	cygwin-1_7_7-release:1.16
	cygwin-1_7_5-release:1.16
	cygwin-1_7_4-release:1.16
	cygwin-1_7_3-release:1.16
	cygwin-1_7_2-release:1.16
	fifo_doover3:1.15.0.2
	cygwin-1_7_1-release:1.15
	prefifo:1.14
	cv-branch-2:1.12.0.2
	pre-ripout-set_console_state_for_spawn:1.10
	EOL_registry_mounts:1.8
	preoverlapped:1.6
	drop_9x_support_start:1.4;
locks; strict;
comment	@// @;


1.37
date	2015.02.26.17.19.27;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2015.02.26.17.00.11;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.14.09.09.41;	author corinna;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2012.08.15.19.07.42;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2012.07.23.04.36.48;	author cgf;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2011.05.01.17.42.41;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.30.16.34.48;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.29.07.22.07;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.28.14.44.24;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.28.12.36.27;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.28.12.13.41;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.28.08.15.56;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.03.15.48.36;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.06.20.20.01;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.24.09.25.35;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.12.09.52.06;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.12.09.50.05;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.11.05.43.11;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.19.09.46.31;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.21.12.46.57;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.01.10.22.33;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.27.17.04.19;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.07.16.43.03;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.29.16.37.36;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.20.15.48.04;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.15.17.49.25;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.15.11.28.46;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.14.10.06.45;	author corinna;	state Exp;
branches;
next	;

1.34.2.1
date	2014.11.13.12.53.04;	author corinna;	state Exp;
branches;
next	;

1.30.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2012.12.10.19.00.13;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.37
log
@	* posix_ipc.cc (ipc_mutex_lock): Revert unneeded call to signal handler.
@
text
@/* posix_ipc.cc: POSIX IPC API for Cygwin.

   Copyright 2007, 2008, 2009, 2010, 2011, 2012, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "shared_info.h"
#include "thread.h"
#include "path.h"
#include "cygtls.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "sigproc.h"
#include "ntdll.h"
#include <sys/mman.h>
#include <sys/param.h>
#include <stdlib.h>
#include <unistd.h>
#include <mqueue.h>
#include <semaphore.h>

/* The prefix_len is the length of the path prefix ncluding trailing "/"
   (or "/sem." for semaphores) as well as the trailing NUL. */
static struct
{
  const char *prefix;
  const size_t prefix_len;
  const char *description;
} ipc_names[] = {
  { "/dev/shm", 10, "POSIX shared memory object" },
  { "/dev/mqueue", 13, "POSIX message queue" },
  { "/dev/shm", 14, "POSIX semaphore" }
};

enum ipc_type_t
{
  shmem,
  mqueue,
  semaphore
};

static bool
check_path (char *res_name, ipc_type_t type, const char *name, size_t len)
{
  /* Note that we require the existance of the appropriate /dev subdirectories
     for POSIX IPC object support, similar to Linux (which supports the
     directories, but doesn't require to mount them).  We don't create
     these directory here, that's the task of the installer.  But we check
     for existance and give ample warning. */
  path_conv path (ipc_names[type].prefix, PC_SYM_NOFOLLOW);
  if (path.error || !path.exists () || !path.isdir ())
    {
      small_printf (
	"Warning: '%s' does not exists or is not a directory.\n\n"
	"%ss require the existance of this directory.\n"
	"Create the directory '%s' and set the permissions to 01777.\n"
	"For instance on the command line: mkdir -m 01777 %s\n",
	ipc_names[type].prefix, ipc_names[type].description,
	ipc_names[type].prefix, ipc_names[type].prefix);
      set_errno (EINVAL);
      return false;
    }
  /* Name must not be empty, or just be a single slash, or start with more
     than one slash.  Same for backslash.
     Apart from handling backslash like slash, the naming rules are identical
     to Linux, including the names and requirements for subdirectories, if
     the name contains further slashes. */
  if (!name || (strchr ("/\\", name[0])
		&& (!name[1] || strchr ("/\\", name[1]))))
    {
      debug_printf ("Invalid %s name '%s'", ipc_names[type].description, name);
      set_errno (EINVAL);
      return false;
    }
  /* Skip leading (back-)slash. */
  if (strchr ("/\\", name[0]))
    ++name;
  if (len > PATH_MAX - ipc_names[type].prefix_len)
    {
      debug_printf ("%s name '%s' too long", ipc_names[type].description, name);
      set_errno (ENAMETOOLONG);
      return false;
    }
  __small_sprintf (res_name, "%s/%s%s", ipc_names[type].prefix,
					type == semaphore ? "sem." : "",
					name);
  return true;
}

static int
ipc_mutex_init (HANDLE *pmtx, const char *name)
{
  WCHAR buf[MAX_PATH];
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  __small_swprintf (buf, L"mqueue/mtx_%s", name);
  RtlInitUnicodeString (&uname, buf);
  InitializeObjectAttributes (&attr, &uname,
			      OBJ_INHERIT | OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
			      get_shared_parent_dir (),
			      everyone_sd (CYG_MUTANT_ACCESS));
  status = NtCreateMutant (pmtx, CYG_MUTANT_ACCESS, &attr, FALSE);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtCreateMutant: %y", status);
      return geterrno_from_win_error (RtlNtStatusToDosError (status));
    }
  return 0;
}

static int
ipc_mutex_lock (HANDLE mtx, bool eintr)
{
  switch (cygwait (mtx, cw_infinite, cw_cancel | cw_cancel_self
				     | (eintr ? cw_sig_eintr : cw_sig_restart)))
    {
    case WAIT_OBJECT_0:
    case WAIT_ABANDONED_0:
      return 0;
    case WAIT_SIGNALED:
      set_errno (EINTR);
      return 1;
    default:
      break;
    }
  return geterrno_from_win_error ();
}

static inline int
ipc_mutex_unlock (HANDLE mtx)
{
  return ReleaseMutex (mtx) ? 0 : geterrno_from_win_error ();
}

static inline int
ipc_mutex_close (HANDLE mtx)
{
  return CloseHandle (mtx) ? 0 : geterrno_from_win_error ();
}

static int
ipc_cond_init (HANDLE *pevt, const char *name, char sr)
{
  WCHAR buf[MAX_PATH];
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  __small_swprintf (buf, L"mqueue/evt_%s%c", name, sr);
  RtlInitUnicodeString (&uname, buf);
  InitializeObjectAttributes (&attr, &uname,
			      OBJ_INHERIT | OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
			      get_shared_parent_dir (),
			      everyone_sd (CYG_EVENT_ACCESS));
  status = NtCreateEvent (pevt, CYG_EVENT_ACCESS, &attr,
			  NotificationEvent, FALSE);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtCreateEvent: %y", status);
      return geterrno_from_win_error (RtlNtStatusToDosError (status));
    }
  return 0;
}

static int
ipc_cond_timedwait (HANDLE evt, HANDLE mtx, const struct timespec *abstime)
{
  HANDLE w4[4] = { evt, };
  DWORD cnt = 2;
  DWORD timer_idx = 0;
  int ret = 0;

  set_signal_arrived here (w4[1]);
  if ((w4[cnt] = pthread::get_cancel_event ()) != NULL)
    ++cnt;
  if (abstime)
    {
      if (abstime->tv_sec < 0
	       || abstime->tv_nsec < 0
	       || abstime->tv_nsec > 999999999)
	return EINVAL;

      /* If a timeout is set, we create a waitable timer to wait for.
	 This is the easiest way to handle the absolute timeout value, given
	 that NtSetTimer also takes absolute times and given the double
	 dependency on evt *and* mtx, which requires to call WFMO twice. */
      NTSTATUS status;
      LARGE_INTEGER duetime;

      timer_idx = cnt++;
      status = NtCreateTimer (&w4[timer_idx], TIMER_ALL_ACCESS, NULL,
			      NotificationTimer);
      if (!NT_SUCCESS (status))
	return geterrno_from_nt_status (status);
      timespec_to_filetime (abstime, &duetime);
      status = NtSetTimer (w4[timer_idx], &duetime, NULL, NULL, FALSE, 0, NULL);
      if (!NT_SUCCESS (status))
	{
	  NtClose (w4[timer_idx]);
	  return geterrno_from_nt_status (status);
	}
    }
  ResetEvent (evt);
  if ((ret = ipc_mutex_unlock (mtx)) != 0)
    return ret;
  /* Everything's set up, so now wait for the event to be signalled. */
restart1:
  switch (WaitForMultipleObjects (cnt, w4, FALSE, INFINITE))
    {
    case WAIT_OBJECT_0:
      break;
    case WAIT_OBJECT_0 + 1:
      if (_my_tls.call_signal_handler ())
	goto restart1;
      ret = EINTR;
      break;
    case WAIT_OBJECT_0 + 2:
      if (timer_idx != 2)
	pthread::static_cancel_self ();
      /*FALLTHRU*/
    case WAIT_OBJECT_0 + 3:
      ret = ETIMEDOUT;
      break;
    default:
      ret = geterrno_from_win_error ();
      break;
    }
  if (ret == 0)
    {
      /* At this point we need to lock the mutex.  The wait is practically
	 the same as before, just that we now wait on the mutex instead of the
	 event. */
    restart2:
      w4[0] = mtx;
      switch (WaitForMultipleObjects (cnt, w4, FALSE, INFINITE))
	{
	case WAIT_OBJECT_0:
	case WAIT_ABANDONED_0:
	  break;
	case WAIT_OBJECT_0 + 1:
	  if (_my_tls.call_signal_handler ())
	    goto restart2;
	  ret = EINTR;
	  break;
	case WAIT_OBJECT_0 + 2:
	  if (timer_idx != 2)
	    pthread_testcancel ();
	  /*FALLTHRU*/
	case WAIT_OBJECT_0 + 3:
	  ret = ETIMEDOUT;
	  break;
	default:
	  ret = geterrno_from_win_error ();
	  break;
	}
    }
  if (timer_idx)
    {
      if (ret != ETIMEDOUT)
	NtCancelTimer (w4[timer_idx], NULL);
      NtClose (w4[timer_idx]);
    }
  return ret;
}

static inline void
ipc_cond_signal (HANDLE evt)
{
  SetEvent (evt);
}

static inline void
ipc_cond_close (HANDLE evt)
{
  CloseHandle (evt);
}

class ipc_flock
{
  struct flock fl;

public:
  ipc_flock () { memset (&fl, 0, sizeof fl); }

  int lock (int fd, size_t size)
  {
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = 0;
    fl.l_len = size;
    return fcntl64 (fd, F_SETLKW, &fl);
  }
  int unlock (int fd)
  {
    if (!fl.l_len)
      return 0;
    fl.l_type = F_UNLCK;
    return fcntl64 (fd, F_SETLKW, &fl);
  }
};

/* POSIX shared memory object implementation. */

extern "C" int
shm_open (const char *name, int oflag, mode_t mode)
{
  size_t len = strlen (name);
  char shmname[ipc_names[shmem].prefix_len + len];

  if (!check_path (shmname, shmem, name, len))
    return -1;

  /* Check for valid flags. */
  if (((oflag & O_ACCMODE) != O_RDONLY && (oflag & O_ACCMODE) != O_RDWR)
      || (oflag & ~(O_ACCMODE | O_CREAT | O_EXCL | O_TRUNC)))
    {
      debug_printf ("Invalid oflag 0%o", oflag);
      set_errno (EINVAL);
      return -1;
    }

  return open (shmname, oflag | O_CLOEXEC, mode & 0777);
}

extern "C" int
shm_unlink (const char *name)
{
  size_t len = strlen (name);
  char shmname[ipc_names[shmem].prefix_len + len];

  if (!check_path (shmname, shmem, name, len))
    return -1;

  return unlink (shmname);
}

/* The POSIX message queue implementation is based on W. Richard STEVENS
   implementation, just tweaked for Cygwin.  The main change is
   the usage of Windows mutexes and events instead of using the pthread
   synchronization objects.  The pathname is massaged so that the
   files are created under /dev/mqueue.  mq_timedsend and mq_timedreceive
   are implemented additionally. */

/* The mq_attr structure is defined using long datatypes per POSIX.
   For interoperability reasons between 32 and 64 bit processes, we have
   to make sure to use a unified structure layout in the message queue file.
   That's what the mq_fattr is, the in-file representation of the mq_attr
   struct. */
#pragma pack (push, 4)
struct mq_fattr
{
  uint32_t mq_flags;
  uint32_t mq_maxmsg;
  uint32_t mq_msgsize;
  uint32_t mq_curmsgs;
};

struct mq_hdr
{
  struct mq_fattr mqh_attr;	 /* the queue's attributes */
  int32_t         mqh_head;	 /* index of first message */
  int32_t         mqh_free;	 /* index of first free message */
  int32_t         mqh_nwait;	 /* #threads blocked in mq_receive() */
  pid_t           mqh_pid;	 /* nonzero PID if mqh_event set */
  char            mqh_uname[36]; /* unique name used to identify synchronization
				    objects connected to this queue */
  union {
    struct sigevent mqh_event;	 /* for mq_notify() */
    /* Make sure sigevent takes the same space on 32 and 64 bit systems.
       Other than that, it doesn't need to be compatible since only
       one process can be notified at a time. */
    uint64_t        mqh_placeholder[8];
  };
  uint32_t        mqh_magic;	/* Expect MQI_MAGIC here, otherwise it's
				   an old-style message queue. */
};

struct msg_hdr
{
  int32_t         msg_next;	 /* index of next on linked list */
  int32_t         msg_len;	 /* actual length */
  unsigned int    msg_prio;	 /* priority */
};
#pragma pack (pop)

struct mq_info
{
  struct mq_hdr  *mqi_hdr;	 /* start of mmap'ed region */
  uint32_t        mqi_magic;	 /* magic number if open */
  int             mqi_flags;	 /* flags for this process */
  HANDLE          mqi_lock;	 /* mutex lock */
  HANDLE          mqi_waitsend;	 /* and condition variable for full queue */
  HANDLE          mqi_waitrecv;	 /* and condition variable for empty queue */
};

#define MQI_MAGIC	0x98765432UL

#define MSGSIZE(i)	roundup((i), sizeof(long))

#define	 MAX_TRIES	10	/* for waiting for initialization */

struct mq_attr defattr = { 0, 10, 8192, 0 };	/* Linux defaults. */

extern "C" off_t lseek64 (int, off_t, int);
extern "C" void *mmap64 (void *, size_t, int, int, int, off_t);

extern "C" mqd_t
mq_open (const char *name, int oflag, ...)
{
  int i, fd = -1, nonblock, created = 0;
  long msgsize, index;
  off_t filesize = 0;
  va_list ap;
  mode_t mode;
  int8_t *mptr = (int8_t *) MAP_FAILED;
  struct stat statbuff;
  struct mq_hdr *mqhdr;
  struct msg_hdr *msghdr;
  struct mq_attr *attr;
  struct mq_info *mqinfo = NULL;
  LUID luid;

  size_t len = strlen (name);
  char mqname[ipc_names[mqueue].prefix_len + len];

  if (!check_path (mqname, mqueue, name, len))
    return (mqd_t) -1;

  __try
    {
      oflag &= (O_CREAT | O_EXCL | O_NONBLOCK);
      nonblock = oflag & O_NONBLOCK;
      oflag &= ~O_NONBLOCK;

    again:
      if (oflag & O_CREAT)
	{
	  va_start (ap, oflag);		/* init ap to final named argument */
	  mode = va_arg (ap, mode_t) & ~S_IXUSR;
	  attr = va_arg (ap, struct mq_attr *);
	  va_end (ap);

	  /* Open and specify O_EXCL and user-execute */
	  fd = open (mqname, oflag | O_EXCL | O_RDWR | O_CLOEXEC,
		     mode | S_IXUSR);
	  if (fd < 0)
	    {
	      if (errno == EEXIST && (oflag & O_EXCL) == 0)
		goto exists;		/* already exists, OK */
	      return (mqd_t) -1;
	    }
	  created = 1;
	  /* First one to create the file initializes it */
	  if (attr == NULL)
	    attr = &defattr;
	  /* Check minimum and maximum values.  The max values are pretty much
	     arbitrary, taken from the linux mq_overview man page.  However,
	     these max values make sure that the internal mq_fattr structure
	     can use 32 bit types. */
	  else if (attr->mq_maxmsg <= 0 || attr->mq_maxmsg > 32768
		   || attr->mq_msgsize <= 0 || attr->mq_msgsize > 1048576)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }
	  /* Calculate and set the file size */
	  msgsize = MSGSIZE (attr->mq_msgsize);
	  filesize = sizeof (struct mq_hdr)
		     + (attr->mq_maxmsg * (sizeof (struct msg_hdr) + msgsize));
	  if (lseek64 (fd, filesize - 1, SEEK_SET) == -1)
	    __leave;
	  if (write (fd, "", 1) == -1)
	    __leave;

	  /* Memory map the file */
	  mptr = (int8_t *) mmap64 (NULL, (size_t) filesize,
				    PROT_READ | PROT_WRITE,
				    MAP_SHARED, fd, 0);
	  if (mptr == (int8_t *) MAP_FAILED)
	    __leave;

	  /* Allocate one mq_info{} for the queue */
	  if (!(mqinfo = (struct mq_info *)
			 calloc (1, sizeof (struct mq_info))))
	    __leave;
	  mqinfo->mqi_hdr = mqhdr = (struct mq_hdr *) mptr;
	  mqinfo->mqi_magic = MQI_MAGIC;
	  mqinfo->mqi_flags = nonblock;

	  /* Initialize header at beginning of file */
	  /* Create free list with all messages on it */
	  mqhdr->mqh_attr.mq_flags = 0;
	  mqhdr->mqh_attr.mq_maxmsg = attr->mq_maxmsg;
	  mqhdr->mqh_attr.mq_msgsize = attr->mq_msgsize;
	  mqhdr->mqh_attr.mq_curmsgs = 0;
	  mqhdr->mqh_nwait = 0;
	  mqhdr->mqh_pid = 0;
	  NtAllocateLocallyUniqueId (&luid);
	  __small_sprintf (mqhdr->mqh_uname, "%016X%08x%08x",
			   hash_path_name (0,mqname),
			   luid.HighPart, luid.LowPart);
	  mqhdr->mqh_head = 0;
	  mqhdr->mqh_magic = MQI_MAGIC;
	  index = sizeof (struct mq_hdr);
	  mqhdr->mqh_free = index;
	  for (i = 0; i < attr->mq_maxmsg - 1; i++)
	    {
	      msghdr = (struct msg_hdr *) &mptr[index];
	      index += sizeof (struct msg_hdr) + msgsize;
	      msghdr->msg_next = index;
	    }
	  msghdr = (struct msg_hdr *) &mptr[index];
	  msghdr->msg_next = 0;		/* end of free list */

	  /* Initialize mutex & condition variables */
	  i = ipc_mutex_init (&mqinfo->mqi_lock, mqhdr->mqh_uname);
	  if (i != 0)
	    {
	      set_errno (i);
	      __leave;
	    }
	  i = ipc_cond_init (&mqinfo->mqi_waitsend, mqhdr->mqh_uname, 'S');
	  if (i != 0)
	    {
	      set_errno (i);
	      __leave;
	    }
	  i = ipc_cond_init (&mqinfo->mqi_waitrecv, mqhdr->mqh_uname, 'R');
	  if (i != 0)
	    {
	      set_errno (i);
	      __leave;
	    }
	  /* Initialization complete, turn off user-execute bit */
	  if (fchmod (fd, mode) == -1)
	    __leave;
	  close (fd);
	  return ((mqd_t) mqinfo);
	}

    exists:
      /* Open the file then memory map */
      if ((fd = open (mqname, O_RDWR | O_CLOEXEC)) < 0)
	{
	  if (errno == ENOENT && (oflag & O_CREAT))
	    goto again;
	  __leave;
	}
      /* Make certain initialization is complete */
      for (i = 0; i < MAX_TRIES; i++)
	{
	  if (stat64 (mqname, &statbuff) == -1)
	    {
	      if (errno == ENOENT && (oflag & O_CREAT))
		{
		  close (fd);
		  fd = -1;
		  goto again;
		}
	      __leave;
	    }
	  if ((statbuff.st_mode & S_IXUSR) == 0)
	    break;
	  sleep (1);
	}
      if (i == MAX_TRIES)
	{
	  set_errno (ETIMEDOUT);
	  __leave;
	}

      filesize = statbuff.st_size;
      mptr = (int8_t *) mmap64 (NULL, (size_t) filesize, PROT_READ | PROT_WRITE,
				MAP_SHARED, fd, 0);
      if (mptr == (int8_t *) MAP_FAILED)
	__leave;
      close (fd);
      fd = -1;

      /* Allocate one mq_info{} for each open */
      if (!(mqinfo = (struct mq_info *) calloc (1, sizeof (struct mq_info))))
	__leave;
      mqinfo->mqi_hdr = mqhdr = (struct mq_hdr *) mptr;
      if (mqhdr->mqh_magic != MQI_MAGIC)
	{
	  system_printf (
    "Old message queue \"%s\" detected!\n"
    "This file is not usable as message queue anymore due to changes in the "
    "internal file layout.  Please remove the file and try again.", mqname);
	  set_errno (EACCES);
	  __leave;
	}
      mqinfo->mqi_magic = MQI_MAGIC;
      mqinfo->mqi_flags = nonblock;

      /* Initialize mutex & condition variable */
      i = ipc_mutex_init (&mqinfo->mqi_lock, mqhdr->mqh_uname);
      if (i != 0)
	{
	  set_errno (i);
	  __leave;
	}
      i = ipc_cond_init (&mqinfo->mqi_waitsend, mqhdr->mqh_uname, 'S');
      if (i != 0)
	{
	  set_errno (i);
	  __leave;
	}
      i = ipc_cond_init (&mqinfo->mqi_waitrecv, mqhdr->mqh_uname, 'R');
      if (i != 0)
	{
	  set_errno (i);
	  __leave;
	}
      return (mqd_t) mqinfo;
    }
  __except (EFAULT) {}
  __endtry
  /* Don't let following function calls change errno */
  save_errno save;
  if (created)
    unlink (mqname);
  if (mptr != (int8_t *) MAP_FAILED)
    munmap((void *) mptr, (size_t) filesize);
  if (mqinfo)
    {
      if (mqinfo->mqi_lock)
	ipc_mutex_close (mqinfo->mqi_lock);
      if (mqinfo->mqi_waitsend)
	ipc_cond_close (mqinfo->mqi_waitsend);
      if (mqinfo->mqi_waitrecv)
	ipc_cond_close (mqinfo->mqi_waitrecv);
      free (mqinfo);
    }
  if (fd >= 0)
    close (fd);
  return (mqd_t) -1;
}

extern "C" int
mq_getattr (mqd_t mqd, struct mq_attr *mqstat)
{
  int n;
  struct mq_hdr *mqhdr;
  struct mq_fattr *attr;
  struct mq_info *mqinfo;

  __try
    {
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock, false)) != 0)
	{
	  errno = n;
	  __leave;
	}
      mqstat->mq_flags = mqinfo->mqi_flags;   /* per-open */
      mqstat->mq_maxmsg = attr->mq_maxmsg;    /* remaining three per-queue */
      mqstat->mq_msgsize = attr->mq_msgsize;
      mqstat->mq_curmsgs = attr->mq_curmsgs;

      ipc_mutex_unlock (mqinfo->mqi_lock);
      return 0;
    }
  __except (EBADF) {}
  __endtry
  return -1;
}

extern "C" int
mq_setattr (mqd_t mqd, const struct mq_attr *mqstat, struct mq_attr *omqstat)
{
  int n;
  struct mq_hdr *mqhdr;
  struct mq_fattr *attr;
  struct mq_info *mqinfo;

  __try
    {
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock, false)) != 0)
	{
	  errno = n;
	  __leave;
	}

      if (omqstat != NULL)
	{
	  omqstat->mq_flags = mqinfo->mqi_flags;  /* previous attributes */
	  omqstat->mq_maxmsg = attr->mq_maxmsg;
	  omqstat->mq_msgsize = attr->mq_msgsize;
	  omqstat->mq_curmsgs = attr->mq_curmsgs; /* and current status */
	}

      if (mqstat->mq_flags & O_NONBLOCK)
	mqinfo->mqi_flags |= O_NONBLOCK;
      else
	mqinfo->mqi_flags &= ~O_NONBLOCK;

      ipc_mutex_unlock (mqinfo->mqi_lock);
      return 0;
    }
  __except (EBADF) {}
  __endtry
  return -1;
}

extern "C" int
mq_notify (mqd_t mqd, const struct sigevent *notification)
{
  int n;
  pid_t pid;
  struct mq_hdr *mqhdr;
  struct mq_info *mqinfo;

  __try
    {
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock, false)) != 0)
	{
	  errno = n;
	  __leave;
	}

      pid = getpid ();
      if (!notification)
	{
	  if (mqhdr->mqh_pid == pid)
	      mqhdr->mqh_pid = 0;     /* unregister calling process */
	}
      else
	{
	  if (mqhdr->mqh_pid != 0)
	    {
	      if (kill (mqhdr->mqh_pid, 0) != -1 || errno != ESRCH)
		{
		  set_errno (EBUSY);
		  ipc_mutex_unlock (mqinfo->mqi_lock);
		  __leave;
		}
	    }
	  mqhdr->mqh_pid = pid;
	  mqhdr->mqh_event = *notification;
	}
      ipc_mutex_unlock (mqinfo->mqi_lock);
      return 0;
    }
  __except (EBADF) {}
  __endtry
  return -1;
}

static int
_mq_send (mqd_t mqd, const char *ptr, size_t len, unsigned int prio,
	  const struct timespec *abstime)
{
  int n;
  long index, freeindex;
  int8_t *mptr;
  struct sigevent *sigev;
  struct mq_hdr *mqhdr;
  struct mq_fattr *attr;
  struct msg_hdr *msghdr, *nmsghdr, *pmsghdr;
  struct mq_info *mqinfo = NULL;
  bool ipc_mutex_locked = false;
  int ret = -1;

  pthread_testcancel ();

  __try
    {
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      if (prio > MQ_PRIO_MAX)
	{
	  set_errno (EINVAL);
	  __leave;
	}

      mqhdr = mqinfo->mqi_hdr;        /* struct pointer */
      mptr = (int8_t *) mqhdr;        /* byte pointer */
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock, true)) != 0)
	{
	  errno = n;
	  __leave;
	}
      ipc_mutex_locked = true;
      if (len > (size_t) attr->mq_msgsize)
	{
	  set_errno (EMSGSIZE);
	  __leave;
	}
      if (attr->mq_curmsgs == 0)
	{
	  if (mqhdr->mqh_pid != 0 && mqhdr->mqh_nwait == 0)
	    {
	      sigev = &mqhdr->mqh_event;
	      if (sigev->sigev_notify == SIGEV_SIGNAL)
		sigqueue (mqhdr->mqh_pid, sigev->sigev_signo,
			  sigev->sigev_value);
	      mqhdr->mqh_pid = 0;             /* unregister */
	    }
	}
      else if (attr->mq_curmsgs >= attr->mq_maxmsg)
	{
	  /* Queue is full */
	  if (mqinfo->mqi_flags & O_NONBLOCK)
	    {
	      set_errno (EAGAIN);
	      __leave;
	    }
	  /* Wait for room for one message on the queue */
	  while (attr->mq_curmsgs >= attr->mq_maxmsg)
	    {
	      int ret = ipc_cond_timedwait (mqinfo->mqi_waitsend,
					    mqinfo->mqi_lock, abstime);
	      if (ret != 0)
		{
		  set_errno (ret);
		  __leave;
		}
	    }
	}

      /* nmsghdr will point to new message */
      if ((freeindex = mqhdr->mqh_free) == 0)
	api_fatal ("mq_send: curmsgs = %ld; free = 0", attr->mq_curmsgs);

      nmsghdr = (struct msg_hdr *) &mptr[freeindex];
      nmsghdr->msg_prio = prio;
      nmsghdr->msg_len = len;
      memcpy (nmsghdr + 1, ptr, len);         /* copy message from caller */
      mqhdr->mqh_free = nmsghdr->msg_next;    /* new freelist head */

      /* Find right place for message in linked list */
      index = mqhdr->mqh_head;
      pmsghdr = (struct msg_hdr *) &(mqhdr->mqh_head);
      while (index)
	{
	  msghdr = (struct msg_hdr *) &mptr[index];
	  if (prio > msghdr->msg_prio)
	    {
	      nmsghdr->msg_next = index;
	      pmsghdr->msg_next = freeindex;
	      break;
	    }
	  index = msghdr->msg_next;
	  pmsghdr = msghdr;
	}
      if (index == 0)
	{
	  /* Queue was empty or new goes at end of list */
	  pmsghdr->msg_next = freeindex;
	  nmsghdr->msg_next = 0;
	}
      /* Wake up anyone blocked in mq_receive waiting for a message */
      if (attr->mq_curmsgs == 0)
	ipc_cond_signal (mqinfo->mqi_waitrecv);
      attr->mq_curmsgs++;

      ipc_mutex_unlock (mqinfo->mqi_lock);
      ret = 0;
    }
  __except (EBADF) {}
  __endtry
  if (ipc_mutex_locked)
    ipc_mutex_unlock (mqinfo->mqi_lock);
  return ret;
}

extern "C" int
mq_send (mqd_t mqd, const char *ptr, size_t len, unsigned int prio)
{
  return _mq_send (mqd, ptr, len, prio, NULL);
}

extern "C" int
mq_timedsend (mqd_t mqd, const char *ptr, size_t len, unsigned int prio,
	      const struct timespec *abstime)
{
  return _mq_send (mqd, ptr, len, prio, abstime);
}

static ssize_t
_mq_receive (mqd_t mqd, char *ptr, size_t maxlen, unsigned int *priop,
	     const struct timespec *abstime)
{
  int n;
  long index;
  int8_t *mptr;
  ssize_t len = -1;
  struct mq_hdr *mqhdr;
  struct mq_fattr *attr;
  struct msg_hdr *msghdr;
  struct mq_info *mqinfo = (struct mq_info *) mqd;
  bool ipc_mutex_locked = false;

  pthread_testcancel ();

  __try
    {
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;        /* struct pointer */
      mptr = (int8_t *) mqhdr;        /* byte pointer */
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock, true)) != 0)
	{
	  errno = n;
	  __leave;
	}
      ipc_mutex_locked = true;
      if (maxlen < (size_t) attr->mq_msgsize)
	{
	  set_errno (EMSGSIZE);
	  __leave;
	}
      if (attr->mq_curmsgs == 0)	/* queue is empty */
	{
	  if (mqinfo->mqi_flags & O_NONBLOCK)
	    {
	      set_errno (EAGAIN);
	      __leave;
	    }
	  /* Wait for a message to be placed onto queue */
	  mqhdr->mqh_nwait++;
	  while (attr->mq_curmsgs == 0)
	    {
	      int ret = ipc_cond_timedwait (mqinfo->mqi_waitrecv,
					    mqinfo->mqi_lock, abstime);
	      if (ret != 0)
		{
		  set_errno (ret);
		  __leave;
		}
	    }
	  mqhdr->mqh_nwait--;
	}

      if ((index = mqhdr->mqh_head) == 0)
	api_fatal ("mq_receive: curmsgs = %ld; head = 0", attr->mq_curmsgs);

      msghdr = (struct msg_hdr *) &mptr[index];
      mqhdr->mqh_head = msghdr->msg_next;     /* new head of list */
      len = msghdr->msg_len;
      memcpy(ptr, msghdr + 1, len);           /* copy the message itself */
      if (priop != NULL)
	*priop = msghdr->msg_prio;

      /* Just-read message goes to front of free list */
      msghdr->msg_next = mqhdr->mqh_free;
      mqhdr->mqh_free = index;

      /* Wake up anyone blocked in mq_send waiting for room */
      if (attr->mq_curmsgs == attr->mq_maxmsg)
	ipc_cond_signal (mqinfo->mqi_waitsend);
      attr->mq_curmsgs--;

      ipc_mutex_unlock (mqinfo->mqi_lock);
    }
  __except (EBADF) {}
  __endtry
  if (ipc_mutex_locked)
    ipc_mutex_unlock (mqinfo->mqi_lock);
  return len;
}

extern "C" ssize_t
mq_receive (mqd_t mqd, char *ptr, size_t maxlen, unsigned int *priop)
{
  return _mq_receive (mqd, ptr, maxlen, priop, NULL);
}

extern "C" ssize_t
mq_timedreceive (mqd_t mqd, char *ptr, size_t maxlen, unsigned int *priop,
		 const struct timespec *abstime)
{
  return _mq_receive (mqd, ptr, maxlen, priop, abstime);
}

extern "C" int
mq_close (mqd_t mqd)
{
  long msgsize, filesize;
  struct mq_hdr *mqhdr;
  struct mq_fattr *attr;
  struct mq_info *mqinfo;

  __try
    {
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      attr = &mqhdr->mqh_attr;

      if (mq_notify (mqd, NULL))	/* unregister calling process */
	__leave;

      msgsize = MSGSIZE (attr->mq_msgsize);
      filesize = sizeof (struct mq_hdr)
		 + (attr->mq_maxmsg * (sizeof (struct msg_hdr) + msgsize));
      if (munmap (mqinfo->mqi_hdr, filesize) == -1)
	__leave;

      mqinfo->mqi_magic = 0;          /* just in case */
      ipc_cond_close (mqinfo->mqi_waitsend);
      ipc_cond_close (mqinfo->mqi_waitrecv);
      ipc_mutex_close (mqinfo->mqi_lock);
      free (mqinfo);
      return 0;
    }
  __except (EBADF) {}
  __endtry
  return -1;
}

extern "C" int
mq_unlink (const char *name)
{
  size_t len = strlen (name);
  char mqname[ipc_names[mqueue].prefix_len + len];

  if (!check_path (mqname, mqueue, name, len))
    return -1;
  if (unlink (mqname) == -1)
    return -1;
  return 0;
}

/* POSIX named semaphore implementation.  Loosely based on Richard W. STEPHENS
   implementation as far as sem_open is concerned, but under the hood using
   the already existing semaphore class in thread.cc.  Using a file backed
   solution allows to implement kernel persistent named semaphores.  */

struct sem_finfo
{
  unsigned int       value;
  unsigned long long hash;
  LUID               luid;
};

extern "C" sem_t *
sem_open (const char *name, int oflag, ...)
{
  int i, fd = -1, created = 0;
  va_list ap;
  mode_t mode = 0;
  unsigned int value = 0;
  struct stat statbuff;
  sem_t *sem = SEM_FAILED;
  sem_finfo sf;
  bool wasopen = false;
  ipc_flock file;

  size_t len = strlen (name);
  char semname[ipc_names[semaphore].prefix_len + len];

  if (!check_path (semname, semaphore, name, len))
    return SEM_FAILED;

  __try
    {
      oflag &= (O_CREAT | O_EXCL);

    again:
      if (oflag & O_CREAT)
	{
	  va_start (ap, oflag);		/* init ap to final named argument */
	  mode = va_arg (ap, mode_t) & ~S_IXUSR;
	  value = va_arg (ap, unsigned int);
	  va_end (ap);

	  /* Open and specify O_EXCL and user-execute */
	  fd = open (semname, oflag | O_EXCL | O_RDWR | O_CLOEXEC,
		     mode | S_IXUSR);
	  if (fd < 0)
	    {
	      if (errno == EEXIST && (oflag & O_EXCL) == 0)
		goto exists;		/* already exists, OK */
	      return SEM_FAILED;
	    }
	  created = 1;
	  /* First one to create the file initializes it. */
	  NtAllocateLocallyUniqueId (&sf.luid);
	  sf.value = value;
	  sf.hash = hash_path_name (0, semname);
	  if (write (fd, &sf, sizeof sf) != sizeof sf)
	    __leave;
	  sem = semaphore::open (sf.hash, sf.luid, fd, oflag, mode, value,
				 wasopen);
	  if (sem == SEM_FAILED)
	    __leave;
	  /* Initialization complete, turn off user-execute bit */
	  if (fchmod (fd, mode) == -1)
	    __leave;
	  /* Don't close (fd); */
	  return sem;
	}

    exists:
      /* Open the file and fetch the semaphore name. */
      if ((fd = open (semname, O_RDWR | O_CLOEXEC)) < 0)
	{
	  if (errno == ENOENT && (oflag & O_CREAT))
	    goto again;
	  __leave;
	}
      /* Make certain initialization is complete */
      for (i = 0; i < MAX_TRIES; i++)
	{
	  if (stat64 (semname, &statbuff) == -1)
	    {
	      if (errno == ENOENT && (oflag & O_CREAT))
		{
		  close (fd);
		  fd = -1;
		  goto again;
		}
	      __leave;
	    }
	  if ((statbuff.st_mode & S_IXUSR) == 0)
	    break;
	  sleep (1);
	}
      if (i == MAX_TRIES)
	{
	  set_errno (ETIMEDOUT);
	  __leave;
	}
      if (file.lock (fd, sizeof sf))
	__leave;
      if (read (fd, &sf, sizeof sf) != sizeof sf)
	__leave;
      sem = semaphore::open (sf.hash, sf.luid, fd, oflag, mode, sf.value,
			     wasopen);
      file.unlock (fd);
      if (sem == SEM_FAILED)
	__leave;
      /* If wasopen is set, the semaphore was already opened and we already have
	 an open file descriptor pointing to the file.  This means, we have to
	 close the file descriptor created in this call.  It won't be stored
	 anywhere anyway. */
      if (wasopen)
	close (fd);
      return sem;
    }
  __except (EFAULT) {}
  __endtry
  /* Don't let following function calls change errno */
  save_errno save;

  if (fd >= 0)
    file.unlock (fd);
  if (created)
    unlink (semname);
  if (sem != SEM_FAILED)
    semaphore::close (sem);
  if (fd >= 0)
    close (fd);
  return SEM_FAILED;
}

int
_sem_close (sem_t *sem, bool do_close)
{
  sem_finfo sf;
  int fd, ret = -1;
  ipc_flock file;

  if (semaphore::getinternal (sem, &fd, &sf.hash, &sf.luid, &sf.value) == -1)
    return -1;
  if (!file.lock (fd, sizeof sf)
      && lseek64 (fd, 0LL, SEEK_SET) != (off_t) -1
      && write (fd, &sf, sizeof sf) == sizeof sf)
    ret = do_close ? semaphore::close (sem) : 0;

  /* Don't let following function calls change errno */
  save_errno save;
  file.unlock (fd);
  close (fd);

  return ret;
}

extern "C" int
sem_close (sem_t *sem)
{
  return _sem_close (sem, true);
}

extern "C" int
sem_unlink (const char *name)
{
  size_t len = strlen (name);
  char semname[ipc_names[semaphore].prefix_len + len];

  if (!check_path (semname, semaphore, name, len))
    return -1;
  if (unlink (semname) == -1)
    return -1;
  return 0;
}
@


1.36
log
@	* posix_ipc.cc (ipc_mutex_lock): Add bool parameter to influence if
	cygwait should be in EINTR or in restart mode.  Call signal handler
	if in EINTR mode.
	(mq_getattr): Call ipc_mutex_lock in restart mode.
	(mq_setattr): Ditto.
	(mq_notify): Ditto.
	(_mq_send): Call ipc_mutex_lock in EINTR mode.
	(_mq_receive): Ditto.
@
text
@a128 1
      _my_tls.call_signal_handler ();
@


1.35
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d3 1
a3 1
   Copyright 2007, 2008, 2009, 2010, 2011, 2012, 2014 Red Hat, Inc.
d120 1
a120 1
ipc_mutex_lock (HANDLE mtx)
d122 2
a123 1
  switch (cygwait (mtx, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
d129 1
d667 1
a667 1
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
d703 1
a703 1
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
d747 1
a747 1
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
d815 1
a815 1
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
d943 1
a943 1
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
@


1.34
log
@	Streamline time/times functionality.  Remove last remains of former
	Windows 9x compatibility.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Drop now unneeded
	casts in calls to_timestruc_t.
	(fhandler_base::utimens_fs): Ditto for timespec_to_filetime.
	* fhandler_proc.cc (format_proc_stat): Ditto for to_time_t.
	* hires.h (class hires_ms): Remove unused member initime_ns.
	Remove declarations for timeGetTime_ns and prime.
	(hires_ms::uptime): Remove.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto for timespec_to_filetime.
	* fhandler_registry.cc (fhandler_registry::fstat): Add cast.
	* resource.cc (fill_rusage): Call NtQueryInformationProcess rather than
	GetProcessTimes to deal with LARGE_INTEGER rather than FILETIME.
	* times.cc: Simplify time handling.  Throughout, use LARGE_INTEGER
	rather than FILETIME to simplify computations.  Throughout use
	{u}int64_t rather than {unsigned} long long.  Drop unneeded casts since
	NSPERSEC is 64 bit anyway.
	(systime_ns): Remove.
	(times): Call NtQuerySystemInformation to fetch boot time.  Call
	NtQueryInformationProcess rather than GetProcessTimes to deal with
	LARGE_INTEGER rather than FILETIME.  Call GetSystemTimeAsFileTime.
	(totimeval): Use constant 1000000 as in other functions.
	(time_t_to_filetime): Remove.
	(to_time_t): Change return type to time_t.
	(time_as_timestruc_t): Rename filetime to systime.
	(time): Ditto. Add cast.
	(hires_ns::nsecs): Fix return type cast.
	(hires_ms::timeGetTime_ns): Remove.
	(hires_ns::prime): Remove.
	(hires_ms::nsecs): Drop call to prime.  Call GetSystemTimeAsFileTime
	directly.  Subtract FACTOR here since it's the only function needing
	to do so.
	(minperiod): Cosmetically change to ULONG.
	(hires_ns::resolution): Fix return type cast.
	(hires_ms::resolution): Simplify, rely on NtQueryTimerResolution.
	* winsup.h: Align time related prototypes to above changes.
@
text
@d3 1
a3 1
   Copyright 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d417 1
a417 1
  int i, fd = -1, nonblock, created;
d422 1
a422 1
  int8_t *mptr;
d427 1
a427 1
  struct mq_info *mqinfo;
d436 85
a520 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return (mqd_t) -1;
d522 25
a546 6
  oflag &= (O_CREAT | O_EXCL | O_NONBLOCK);
  created = 0;
  nonblock = oflag & O_NONBLOCK;
  oflag &= ~O_NONBLOCK;
  mptr = (int8_t *) MAP_FAILED;
  mqinfo = NULL;
d548 26
a573 26
again:
  if (oflag & O_CREAT)
    {
      va_start (ap, oflag);		/* init ap to final named argument */
      mode = va_arg (ap, mode_t) & ~S_IXUSR;
      attr = va_arg (ap, struct mq_attr *);
      va_end (ap);

      /* Open and specify O_EXCL and user-execute */
      fd = open (mqname, oflag | O_EXCL | O_RDWR | O_CLOEXEC, mode | S_IXUSR);
      if (fd < 0)
	{
	  if (errno == EEXIST && (oflag & O_EXCL) == 0)
	    goto exists;		/* already exists, OK */
	  return (mqd_t) -1;
	}
      created = 1;
      /* First one to create the file initializes it */
      if (attr == NULL)
	attr = &defattr;
      /* Check minimum and maximum values.  The max values are pretty much
         arbitrary, taken from the linux mq_overview man page.  However,
	 these max values make sure that the internal mq_fattr structure
	 can use 32 bit types. */
      else if (attr->mq_maxmsg <= 0 || attr->mq_maxmsg > 32768
	       || attr->mq_msgsize <= 0 || attr->mq_msgsize > 1048576)
d575 2
a576 2
	  set_errno (EINVAL);
	  goto err;
a577 8
      /* Calculate and set the file size */
      msgsize = MSGSIZE (attr->mq_msgsize);
      filesize = sizeof (struct mq_hdr)
		 + (attr->mq_maxmsg * (sizeof (struct msg_hdr) + msgsize));
      if (lseek64 (fd, filesize - 1, SEEK_SET) == -1)
	goto err;
      if (write (fd, "", 1) == -1)
	goto err;
d579 1
a579 1
      /* Memory map the file */
d583 3
a585 1
	goto err;
d587 1
a587 1
      /* Allocate one mq_info{} for the queue */
d589 1
a589 1
	goto err;
d591 9
d603 3
a605 17
      /* Initialize header at beginning of file */
      /* Create free list with all messages on it */
      mqhdr->mqh_attr.mq_flags = 0;
      mqhdr->mqh_attr.mq_maxmsg = attr->mq_maxmsg;
      mqhdr->mqh_attr.mq_msgsize = attr->mq_msgsize;
      mqhdr->mqh_attr.mq_curmsgs = 0;
      mqhdr->mqh_nwait = 0;
      mqhdr->mqh_pid = 0;
      NtAllocateLocallyUniqueId (&luid);
      __small_sprintf (mqhdr->mqh_uname, "%016X%08x%08x",
		       hash_path_name (0,mqname),
		       luid.HighPart, luid.LowPart);
      mqhdr->mqh_head = 0;
      mqhdr->mqh_magic = MQI_MAGIC;
      index = sizeof (struct mq_hdr);
      mqhdr->mqh_free = index;
      for (i = 0; i < attr->mq_maxmsg - 1; i++)
d607 2
a608 3
	  msghdr = (struct msg_hdr *) &mptr[index];
	  index += sizeof (struct msg_hdr) + msgsize;
	  msghdr->msg_next = index;
a609 8
      msghdr = (struct msg_hdr *) &mptr[index];
      msghdr->msg_next = 0;		/* end of free list */

      /* Initialize mutex & condition variables */
      i = ipc_mutex_init (&mqinfo->mqi_lock, mqhdr->mqh_uname);
      if (i != 0)
	goto pthreaderr;

d612 4
a615 2
	goto pthreaderr;

a617 21
	goto pthreaderr;

      /* Initialization complete, turn off user-execute bit */
      if (fchmod (fd, mode) == -1)
	goto err;
      close (fd);
      return ((mqd_t) mqinfo);
    }

exists:
  /* Open the file then memory map */
  if ((fd = open (mqname, O_RDWR | O_CLOEXEC)) < 0)
    {
      if (errno == ENOENT && (oflag & O_CREAT))
	goto again;
      goto err;
    }
  /* Make certain initialization is complete */
  for (i = 0; i < MAX_TRIES; i++)
    {
      if (stat64 (mqname, &statbuff) == -1)
d619 2
a620 7
	  if (errno == ENOENT && (oflag & O_CREAT))
	    {
	      close (fd);
	      fd = -1;
	      goto again;
	    }
	  goto err;
d622 1
a622 8
      if ((statbuff.st_mode & S_IXUSR) == 0)
	break;
      sleep (1);
    }
  if (i == MAX_TRIES)
    {
      set_errno (ETIMEDOUT);
      goto err;
d624 2
a625 43

  filesize = statbuff.st_size;
  mptr = (int8_t *) mmap64 (NULL, (size_t) filesize, PROT_READ | PROT_WRITE,
			    MAP_SHARED, fd, 0);
  if (mptr == (int8_t *) MAP_FAILED)
    goto err;
  close (fd);
  fd = -1;

  /* Allocate one mq_info{} for each open */
  if (!(mqinfo = (struct mq_info *) calloc (1, sizeof (struct mq_info))))
    goto err;
  mqinfo->mqi_hdr = mqhdr = (struct mq_hdr *) mptr;
  if (mqhdr->mqh_magic != MQI_MAGIC)
    {
      system_printf (
"Old message queue \"%s\" detected!\n"
"This file is not usable as message queue anymore due to changes in the "
"internal file layout.  Please remove the file and try again.", mqname);
      set_errno (EACCES);
      goto err;
    }
  mqinfo->mqi_magic = MQI_MAGIC;
  mqinfo->mqi_flags = nonblock;

  /* Initialize mutex & condition variable */
  i = ipc_mutex_init (&mqinfo->mqi_lock, mqhdr->mqh_uname);
  if (i != 0)
    goto pthreaderr;

  i = ipc_cond_init (&mqinfo->mqi_waitsend, mqhdr->mqh_uname, 'S');
  if (i != 0)
    goto pthreaderr;

  i = ipc_cond_init (&mqinfo->mqi_waitrecv, mqhdr->mqh_uname, 'R');
  if (i != 0)
    goto pthreaderr;

  return (mqd_t) mqinfo;

pthreaderr:
  errno = i;
err:
a627 1

d655 19
a673 3
  myfault efault;
  if (efault.faulted (EBADF))
      return -1;
d675 2
a676 5
  mqinfo = (struct mq_info *) mqd;
  if (mqinfo->mqi_magic != MQI_MAGIC)
    {
      set_errno (EBADF);
      return -1;
d678 3
a680 14
  mqhdr = mqinfo->mqi_hdr;
  attr = &mqhdr->mqh_attr;
  if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
    {
      errno = n;
      return -1;
    }
  mqstat->mq_flags = mqinfo->mqi_flags;   /* per-open */
  mqstat->mq_maxmsg = attr->mq_maxmsg;    /* remaining three per-queue */
  mqstat->mq_msgsize = attr->mq_msgsize;
  mqstat->mq_curmsgs = attr->mq_curmsgs;

  ipc_mutex_unlock (mqinfo->mqi_lock);
  return 0;
d691 1
a691 6
  myfault efault;
  if (efault.faulted (EBADF))
      return -1;

  mqinfo = (struct mq_info *) mqd;
  if (mqinfo->mqi_magic != MQI_MAGIC)
d693 13
a705 10
      set_errno (EBADF);
      return -1;
    }
  mqhdr = mqinfo->mqi_hdr;
  attr = &mqhdr->mqh_attr;
  if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
    {
      errno = n;
      return -1;
    }
d707 7
a713 7
  if (omqstat != NULL)
    {
      omqstat->mq_flags = mqinfo->mqi_flags;  /* previous attributes */
      omqstat->mq_maxmsg = attr->mq_maxmsg;
      omqstat->mq_msgsize = attr->mq_msgsize;
      omqstat->mq_curmsgs = attr->mq_curmsgs; /* and current status */
    }
d715 4
a718 4
  if (mqstat->mq_flags & O_NONBLOCK)
    mqinfo->mqi_flags |= O_NONBLOCK;
  else
    mqinfo->mqi_flags &= ~O_NONBLOCK;
d720 6
a725 2
  ipc_mutex_unlock (mqinfo->mqi_lock);
  return 0;
d736 1
a736 6
  myfault efault;
  if (efault.faulted (EBADF))
      return -1;

  mqinfo = (struct mq_info *) mqd;
  if (mqinfo->mqi_magic != MQI_MAGIC)
d738 12
a749 9
      set_errno (EBADF);
      return -1;
    }
  mqhdr = mqinfo->mqi_hdr;
  if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
    {
      errno = n;
      return -1;
    }
d751 7
a757 9
  pid = getpid ();
  if (!notification)
    {
      if (mqhdr->mqh_pid == pid)
	  mqhdr->mqh_pid = 0;     /* unregister calling process */
    }
  else
    {
      if (mqhdr->mqh_pid != 0)
d759 1
a759 1
	  if (kill (mqhdr->mqh_pid, 0) != -1 || errno != ESRCH)
d761 6
a766 3
	      set_errno (EBUSY);
	      ipc_mutex_unlock (mqinfo->mqi_lock);
	      return -1;
d768 2
d771 2
a772 2
      mqhdr->mqh_pid = pid;
      mqhdr->mqh_event = *notification;
d774 3
a776 2
  ipc_mutex_unlock (mqinfo->mqi_lock);
  return 0;
d790 3
a792 1
  struct mq_info *mqinfo;
d796 1
a796 6
  myfault efault;
  if (efault.faulted (EBADF))
      return -1;

  mqinfo = (struct mq_info *) mqd;
  if (mqinfo->mqi_magic != MQI_MAGIC)
d798 11
a808 8
      set_errno (EBADF);
      return -1;
    }
  if (prio > MQ_PRIO_MAX)
    {
      set_errno (EINVAL);
      return -1;
    }
d810 10
a819 17
  mqhdr = mqinfo->mqi_hdr;        /* struct pointer */
  mptr = (int8_t *) mqhdr;        /* byte pointer */
  attr = &mqhdr->mqh_attr;
  if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
    {
      errno = n;
      return -1;
    }

  if (len > (size_t) attr->mq_msgsize)
    {
      set_errno (EMSGSIZE);
      goto err;
    }
  if (attr->mq_curmsgs == 0)
    {
      if (mqhdr->mqh_pid != 0 && mqhdr->mqh_nwait == 0)
d821 2
a822 4
	  sigev = &mqhdr->mqh_event;
	  if (sigev->sigev_notify == SIGEV_SIGNAL)
	    sigqueue (mqhdr->mqh_pid, sigev->sigev_signo, sigev->sigev_value);
	  mqhdr->mqh_pid = 0;             /* unregister */
d824 1
a824 5
    }
  else if (attr->mq_curmsgs >= attr->mq_maxmsg)
    {
      /* Queue is full */
      if (mqinfo->mqi_flags & O_NONBLOCK)
d826 8
a833 2
	  set_errno (EAGAIN);
	  goto err;
d835 1
a835 2
      /* Wait for room for one message on the queue */
      while (attr->mq_curmsgs >= attr->mq_maxmsg)
d837 2
a838 3
	  int ret = ipc_cond_timedwait (mqinfo->mqi_waitsend, mqinfo->mqi_lock,
					abstime);
	  if (ret != 0)
d840 13
a852 2
	      set_errno (ret);
	      return -1;
a854 1
    }
d856 26
a881 17
  /* nmsghdr will point to new message */
  if ((freeindex = mqhdr->mqh_free) == 0)
    api_fatal ("mq_send: curmsgs = %ld; free = 0", attr->mq_curmsgs);

  nmsghdr = (struct msg_hdr *) &mptr[freeindex];
  nmsghdr->msg_prio = prio;
  nmsghdr->msg_len = len;
  memcpy (nmsghdr + 1, ptr, len);          /* copy message from caller */
  mqhdr->mqh_free = nmsghdr->msg_next;    /* new freelist head */

  /* Find right place for message in linked list */
  index = mqhdr->mqh_head;
  pmsghdr = (struct msg_hdr *) &(mqhdr->mqh_head);
  while (index)
    {
      msghdr = (struct msg_hdr *) &mptr[index];
      if (prio > msghdr->msg_prio)
d883 1
a883 1
	  nmsghdr->msg_next = index;
d885 1
a885 1
	  break;
d887 13
a899 20
      index = msghdr->msg_next;
      pmsghdr = msghdr;
    }
  if (index == 0)
    {
      /* Queue was empty or new goes at end of list */
      pmsghdr->msg_next = freeindex;
      nmsghdr->msg_next = 0;
    }
  /* Wake up anyone blocked in mq_receive waiting for a message */
  if (attr->mq_curmsgs == 0)
    ipc_cond_signal (mqinfo->mqi_waitrecv);
  attr->mq_curmsgs++;

  ipc_mutex_unlock (mqinfo->mqi_lock);
  return 0;

err:
  ipc_mutex_unlock (mqinfo->mqi_lock);
  return -1;
d922 1
a922 1
  ssize_t len;
d926 2
a927 1
  struct mq_info *mqinfo;
d931 1
a931 6
  myfault efault;
  if (efault.faulted (EBADF))
      return -1;

  mqinfo = (struct mq_info *) mqd;
  if (mqinfo->mqi_magic != MQI_MAGIC)
d933 15
a947 20
      set_errno (EBADF);
      return -1;
    }
  mqhdr = mqinfo->mqi_hdr;        /* struct pointer */
  mptr = (int8_t *) mqhdr;        /* byte pointer */
  attr = &mqhdr->mqh_attr;
  if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
    {
      errno = n;
      return -1;
    }

  if (maxlen < (size_t) attr->mq_msgsize)
    {
      set_errno (EMSGSIZE);
      goto err;
    }
  if (attr->mq_curmsgs == 0)	/* queue is empty */
    {
      if (mqinfo->mqi_flags & O_NONBLOCK)
d949 2
a950 2
	  set_errno (EAGAIN);
	  goto err;
d952 3
a954 7
      /* Wait for a message to be placed onto queue */
      mqhdr->mqh_nwait++;
      while (attr->mq_curmsgs == 0)
	{
	  int ret = ipc_cond_timedwait (mqinfo->mqi_waitrecv, mqinfo->mqi_lock,
					abstime);
	  if (ret != 0)
d956 2
a957 2
	      set_errno (ret);
	      return -1;
d959 13
a972 2
      mqhdr->mqh_nwait--;
    }
d974 2
a975 2
  if ((index = mqhdr->mqh_head) == 0)
    api_fatal ("mq_receive: curmsgs = %ld; head = 0", attr->mq_curmsgs);
d977 6
a982 15
  msghdr = (struct msg_hdr *) &mptr[index];
  mqhdr->mqh_head = msghdr->msg_next;     /* new head of list */
  len = msghdr->msg_len;
  memcpy(ptr, msghdr + 1, len);           /* copy the message itself */
  if (priop != NULL)
    *priop = msghdr->msg_prio;

  /* Just-read message goes to front of free list */
  msghdr->msg_next = mqhdr->mqh_free;
  mqhdr->mqh_free = index;

  /* Wake up anyone blocked in mq_send waiting for room */
  if (attr->mq_curmsgs == attr->mq_maxmsg)
    ipc_cond_signal (mqinfo->mqi_waitsend);
  attr->mq_curmsgs--;
d984 15
a998 1
  ipc_mutex_unlock (mqinfo->mqi_lock);
a999 4

err:
  ipc_mutex_unlock (mqinfo->mqi_lock);
  return -1;
d1023 1
a1023 6
  myfault efault;
  if (efault.faulted (EBADF))
      return -1;

  mqinfo = (struct mq_info *) mqd;
  if (mqinfo->mqi_magic != MQI_MAGIC)
d1025 8
a1032 5
      set_errno (EBADF);
      return -1;
    }
  mqhdr = mqinfo->mqi_hdr;
  attr = &mqhdr->mqh_attr;
d1034 2
a1035 2
  if (mq_notify (mqd, NULL))	/* unregister calling process */
    return -1;
d1037 5
a1041 5
  msgsize = MSGSIZE (attr->mq_msgsize);
  filesize = sizeof (struct mq_hdr)
	     + (attr->mq_maxmsg * (sizeof (struct msg_hdr) + msgsize));
  if (munmap (mqinfo->mqi_hdr, filesize) == -1)
    return -1;
d1043 10
a1052 6
  mqinfo->mqi_magic = 0;          /* just in case */
  ipc_cond_close (mqinfo->mqi_waitsend);
  ipc_cond_close (mqinfo->mqi_waitrecv);
  ipc_mutex_close (mqinfo->mqi_lock);
  free (mqinfo);
  return 0;
d1083 1
a1083 1
  int i, fd = -1, created;
d1099 3
a1101 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return SEM_FAILED;
d1103 34
a1136 2
  created = 0;
  oflag &= (O_CREAT | O_EXCL);
d1138 3
a1140 45
again:
  if (oflag & O_CREAT)
    {
      va_start (ap, oflag);		/* init ap to final named argument */
      mode = va_arg (ap, mode_t) & ~S_IXUSR;
      value = va_arg (ap, unsigned int);
      va_end (ap);

      /* Open and specify O_EXCL and user-execute */
      fd = open (semname, oflag | O_EXCL | O_RDWR | O_CLOEXEC, mode | S_IXUSR);
      if (fd < 0)
	{
	  if (errno == EEXIST && (oflag & O_EXCL) == 0)
	    goto exists;		/* already exists, OK */
	  return SEM_FAILED;
	}
      created = 1;
      /* First one to create the file initializes it. */
      NtAllocateLocallyUniqueId (&sf.luid);
      sf.value = value;
      sf.hash = hash_path_name (0, semname);
      if (write (fd, &sf, sizeof sf) != sizeof sf)
	goto err;
      sem = semaphore::open (sf.hash, sf.luid, fd, oflag, mode, value, wasopen);
      if (sem == SEM_FAILED)
	goto err;
      /* Initialization complete, turn off user-execute bit */
      if (fchmod (fd, mode) == -1)
	goto err;
      /* Don't close (fd); */
      return sem;
    }

exists:
  /* Open the file and fetch the semaphore name. */
  if ((fd = open (semname, O_RDWR | O_CLOEXEC)) < 0)
    {
      if (errno == ENOENT && (oflag & O_CREAT))
	goto again;
      goto err;
    }
  /* Make certain initialization is complete */
  for (i = 0; i < MAX_TRIES; i++)
    {
      if (stat64 (semname, &statbuff) == -1)
d1143 7
d1151 7
a1157 3
	      close (fd);
	      fd = -1;
	      goto again;
d1159 3
a1161 1
	  goto err;
d1163 21
a1183 3
      if ((statbuff.st_mode & S_IXUSR) == 0)
	break;
      sleep (1);
d1185 2
a1186 22
  if (i == MAX_TRIES)
    {
      set_errno (ETIMEDOUT);
      goto err;
    }
  if (file.lock (fd, sizeof sf))
    goto err;
  if (read (fd, &sf, sizeof sf) != sizeof sf)
    goto err;
  sem = semaphore::open (sf.hash, sf.luid, fd, oflag, mode, sf.value, wasopen);
  file.unlock (fd);
  if (sem == SEM_FAILED)
    goto err;
  /* If wasopen is set, the semaphore was already opened and we already have
     an open file descriptor pointing to the file.  This means, we have to
     close the file descriptor created in this call.  It won't be stored
     anywhere anyway. */
  if (wasopen)
    close (fd);
  return sem;

err:
d1190 2
a1191 1
  file.unlock (fd);
@


1.34.2.1
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d3 1
a3 1
   Copyright 2007, 2008, 2009, 2010, 2011, 2012, 2014 Red Hat, Inc.
d417 1
a417 1
  int i, fd = -1, nonblock, created = 0;
d422 1
a422 1
  int8_t *mptr = (int8_t *) MAP_FAILED;
d427 1
a427 1
  struct mq_info *mqinfo = NULL;
d436 3
a438 5
  __try
    {
      oflag &= (O_CREAT | O_EXCL | O_NONBLOCK);
      nonblock = oflag & O_NONBLOCK;
      oflag &= ~O_NONBLOCK;
d440 6
a445 79
    again:
      if (oflag & O_CREAT)
	{
	  va_start (ap, oflag);		/* init ap to final named argument */
	  mode = va_arg (ap, mode_t) & ~S_IXUSR;
	  attr = va_arg (ap, struct mq_attr *);
	  va_end (ap);

	  /* Open and specify O_EXCL and user-execute */
	  fd = open (mqname, oflag | O_EXCL | O_RDWR | O_CLOEXEC,
		     mode | S_IXUSR);
	  if (fd < 0)
	    {
	      if (errno == EEXIST && (oflag & O_EXCL) == 0)
		goto exists;		/* already exists, OK */
	      return (mqd_t) -1;
	    }
	  created = 1;
	  /* First one to create the file initializes it */
	  if (attr == NULL)
	    attr = &defattr;
	  /* Check minimum and maximum values.  The max values are pretty much
	     arbitrary, taken from the linux mq_overview man page.  However,
	     these max values make sure that the internal mq_fattr structure
	     can use 32 bit types. */
	  else if (attr->mq_maxmsg <= 0 || attr->mq_maxmsg > 32768
		   || attr->mq_msgsize <= 0 || attr->mq_msgsize > 1048576)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }
	  /* Calculate and set the file size */
	  msgsize = MSGSIZE (attr->mq_msgsize);
	  filesize = sizeof (struct mq_hdr)
		     + (attr->mq_maxmsg * (sizeof (struct msg_hdr) + msgsize));
	  if (lseek64 (fd, filesize - 1, SEEK_SET) == -1)
	    __leave;
	  if (write (fd, "", 1) == -1)
	    __leave;

	  /* Memory map the file */
	  mptr = (int8_t *) mmap64 (NULL, (size_t) filesize,
				    PROT_READ | PROT_WRITE,
				    MAP_SHARED, fd, 0);
	  if (mptr == (int8_t *) MAP_FAILED)
	    __leave;

	  /* Allocate one mq_info{} for the queue */
	  if (!(mqinfo = (struct mq_info *)
			 calloc (1, sizeof (struct mq_info))))
	    __leave;
	  mqinfo->mqi_hdr = mqhdr = (struct mq_hdr *) mptr;
	  mqinfo->mqi_magic = MQI_MAGIC;
	  mqinfo->mqi_flags = nonblock;

	  /* Initialize header at beginning of file */
	  /* Create free list with all messages on it */
	  mqhdr->mqh_attr.mq_flags = 0;
	  mqhdr->mqh_attr.mq_maxmsg = attr->mq_maxmsg;
	  mqhdr->mqh_attr.mq_msgsize = attr->mq_msgsize;
	  mqhdr->mqh_attr.mq_curmsgs = 0;
	  mqhdr->mqh_nwait = 0;
	  mqhdr->mqh_pid = 0;
	  NtAllocateLocallyUniqueId (&luid);
	  __small_sprintf (mqhdr->mqh_uname, "%016X%08x%08x",
			   hash_path_name (0,mqname),
			   luid.HighPart, luid.LowPart);
	  mqhdr->mqh_head = 0;
	  mqhdr->mqh_magic = MQI_MAGIC;
	  index = sizeof (struct mq_hdr);
	  mqhdr->mqh_free = index;
	  for (i = 0; i < attr->mq_maxmsg - 1; i++)
	    {
	      msghdr = (struct msg_hdr *) &mptr[index];
	      index += sizeof (struct msg_hdr) + msgsize;
	      msghdr->msg_next = index;
	    }
	  msghdr = (struct msg_hdr *) &mptr[index];
	  msghdr->msg_next = 0;		/* end of free list */
d447 26
a472 29
	  /* Initialize mutex & condition variables */
	  i = ipc_mutex_init (&mqinfo->mqi_lock, mqhdr->mqh_uname);
	  if (i != 0)
	    {
	      set_errno (i);
	      __leave;
	    }
	  i = ipc_cond_init (&mqinfo->mqi_waitsend, mqhdr->mqh_uname, 'S');
	  if (i != 0)
	    {
	      set_errno (i);
	      __leave;
	    }
	  i = ipc_cond_init (&mqinfo->mqi_waitrecv, mqhdr->mqh_uname, 'R');
	  if (i != 0)
	    {
	      set_errno (i);
	      __leave;
	    }
	  /* Initialization complete, turn off user-execute bit */
	  if (fchmod (fd, mode) == -1)
	    __leave;
	  close (fd);
	  return ((mqd_t) mqinfo);
	}

    exists:
      /* Open the file then memory map */
      if ((fd = open (mqname, O_RDWR | O_CLOEXEC)) < 0)
d474 2
a475 25
	  if (errno == ENOENT && (oflag & O_CREAT))
	    goto again;
	  __leave;
	}
      /* Make certain initialization is complete */
      for (i = 0; i < MAX_TRIES; i++)
	{
	  if (stat64 (mqname, &statbuff) == -1)
	    {
	      if (errno == ENOENT && (oflag & O_CREAT))
		{
		  close (fd);
		  fd = -1;
		  goto again;
		}
	      __leave;
	    }
	  if ((statbuff.st_mode & S_IXUSR) == 0)
	    break;
	  sleep (1);
	}
      if (i == MAX_TRIES)
	{
	  set_errno (ETIMEDOUT);
	  __leave;
d477 8
d486 1
a486 1
      filesize = statbuff.st_size;
d490 1
a490 3
	__leave;
      close (fd);
      fd = -1;
d492 1
a492 1
      /* Allocate one mq_info{} for each open */
d494 1
a494 1
	__leave;
d496 20
a515 1
      if (mqhdr->mqh_magic != MQI_MAGIC)
d517 3
a519 6
	  system_printf (
    "Old message queue \"%s\" detected!\n"
    "This file is not usable as message queue anymore due to changes in the "
    "internal file layout.  Please remove the file and try again.", mqname);
	  set_errno (EACCES);
	  __leave;
d521 2
a522 2
      mqinfo->mqi_magic = MQI_MAGIC;
      mqinfo->mqi_flags = nonblock;
d524 1
a524 1
      /* Initialize mutex & condition variable */
d527 2
a528 4
	{
	  set_errno (i);
	  __leave;
	}
d531 2
a532 4
	{
	  set_errno (i);
	  __leave;
	}
d535 21
d557 7
a563 2
	  set_errno (i);
	  __leave;
d565 8
a572 1
      return (mqd_t) mqinfo;
d574 43
a616 2
  __except (EFAULT) {}
  __endtry
d619 1
d647 13
a659 1
  __try
d661 7
a667 17
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
	{
	  errno = n;
	  __leave;
	}
      mqstat->mq_flags = mqinfo->mqi_flags;   /* per-open */
      mqstat->mq_maxmsg = attr->mq_maxmsg;    /* remaining three per-queue */
      mqstat->mq_msgsize = attr->mq_msgsize;
      mqstat->mq_curmsgs = attr->mq_curmsgs;
d669 2
a670 6
      ipc_mutex_unlock (mqinfo->mqi_lock);
      return 0;
    }
  __except (EBADF) {}
  __endtry
  return -1;
d681 6
a686 1
  __try
d688 10
a697 13
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
	{
	  errno = n;
	  __leave;
	}
d699 7
a705 7
      if (omqstat != NULL)
	{
	  omqstat->mq_flags = mqinfo->mqi_flags;  /* previous attributes */
	  omqstat->mq_maxmsg = attr->mq_maxmsg;
	  omqstat->mq_msgsize = attr->mq_msgsize;
	  omqstat->mq_curmsgs = attr->mq_curmsgs; /* and current status */
	}
d707 4
a710 4
      if (mqstat->mq_flags & O_NONBLOCK)
	mqinfo->mqi_flags |= O_NONBLOCK;
      else
	mqinfo->mqi_flags &= ~O_NONBLOCK;
d712 2
a713 6
      ipc_mutex_unlock (mqinfo->mqi_lock);
      return 0;
    }
  __except (EBADF) {}
  __endtry
  return -1;
d724 6
a729 1
  __try
d731 9
a739 12
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
	{
	  errno = n;
	  __leave;
	}
d741 9
a749 2
      pid = getpid ();
      if (!notification)
d751 1
a751 6
	  if (mqhdr->mqh_pid == pid)
	      mqhdr->mqh_pid = 0;     /* unregister calling process */
	}
      else
	{
	  if (mqhdr->mqh_pid != 0)
d753 3
a755 6
	      if (kill (mqhdr->mqh_pid, 0) != -1 || errno != ESRCH)
		{
		  set_errno (EBUSY);
		  ipc_mutex_unlock (mqinfo->mqi_lock);
		  __leave;
		}
a756 2
	  mqhdr->mqh_pid = pid;
	  mqhdr->mqh_event = *notification;
d758 2
a759 2
      ipc_mutex_unlock (mqinfo->mqi_lock);
      return 0;
d761 2
a762 3
  __except (EBADF) {}
  __endtry
  return -1;
d776 1
a776 3
  struct mq_info *mqinfo = NULL;
  bool ipc_mutex_locked = false;
  int ret = -1;
d780 11
a790 1
  __try
d792 12
a803 11
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      if (prio > MQ_PRIO_MAX)
	{
	  set_errno (EINVAL);
	  __leave;
	}
d805 8
a812 4
      mqhdr = mqinfo->mqi_hdr;        /* struct pointer */
      mptr = (int8_t *) mqhdr;        /* byte pointer */
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
d814 4
a817 2
	  errno = n;
	  __leave;
d819 5
a823 2
      ipc_mutex_locked = true;
      if (len > (size_t) attr->mq_msgsize)
d825 2
a826 2
	  set_errno (EMSGSIZE);
	  __leave;
d828 2
a829 1
      if (attr->mq_curmsgs == 0)
d831 3
a833 1
	  if (mqhdr->mqh_pid != 0 && mqhdr->mqh_nwait == 0)
d835 2
a836 25
	      sigev = &mqhdr->mqh_event;
	      if (sigev->sigev_notify == SIGEV_SIGNAL)
		sigqueue (mqhdr->mqh_pid, sigev->sigev_signo,
			  sigev->sigev_value);
	      mqhdr->mqh_pid = 0;             /* unregister */
	    }
	}
      else if (attr->mq_curmsgs >= attr->mq_maxmsg)
	{
	  /* Queue is full */
	  if (mqinfo->mqi_flags & O_NONBLOCK)
	    {
	      set_errno (EAGAIN);
	      __leave;
	    }
	  /* Wait for room for one message on the queue */
	  while (attr->mq_curmsgs >= attr->mq_maxmsg)
	    {
	      int ret = ipc_cond_timedwait (mqinfo->mqi_waitsend,
					    mqinfo->mqi_lock, abstime);
	      if (ret != 0)
		{
		  set_errno (ret);
		  __leave;
		}
d839 1
d841 17
a857 14
      /* nmsghdr will point to new message */
      if ((freeindex = mqhdr->mqh_free) == 0)
	api_fatal ("mq_send: curmsgs = %ld; free = 0", attr->mq_curmsgs);

      nmsghdr = (struct msg_hdr *) &mptr[freeindex];
      nmsghdr->msg_prio = prio;
      nmsghdr->msg_len = len;
      memcpy (nmsghdr + 1, ptr, len);         /* copy message from caller */
      mqhdr->mqh_free = nmsghdr->msg_next;    /* new freelist head */

      /* Find right place for message in linked list */
      index = mqhdr->mqh_head;
      pmsghdr = (struct msg_hdr *) &(mqhdr->mqh_head);
      while (index)
d859 1
a859 13
	  msghdr = (struct msg_hdr *) &mptr[index];
	  if (prio > msghdr->msg_prio)
	    {
	      nmsghdr->msg_next = index;
	      pmsghdr->msg_next = freeindex;
	      break;
	    }
	  index = msghdr->msg_next;
	  pmsghdr = msghdr;
	}
      if (index == 0)
	{
	  /* Queue was empty or new goes at end of list */
d861 1
a861 1
	  nmsghdr->msg_next = 0;
d863 20
a882 13
      /* Wake up anyone blocked in mq_receive waiting for a message */
      if (attr->mq_curmsgs == 0)
	ipc_cond_signal (mqinfo->mqi_waitrecv);
      attr->mq_curmsgs++;

      ipc_mutex_unlock (mqinfo->mqi_lock);
      ret = 0;
    }
  __except (EBADF) {}
  __endtry
  if (ipc_mutex_locked)
    ipc_mutex_unlock (mqinfo->mqi_lock);
  return ret;
d905 1
a905 1
  ssize_t len = -1;
d909 1
a909 2
  struct mq_info *mqinfo = (struct mq_info *) mqd;
  bool ipc_mutex_locked = false;
d913 20
a932 1
  __try
d934 6
a939 9
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;        /* struct pointer */
      mptr = (int8_t *) mqhdr;        /* byte pointer */
      attr = &mqhdr->mqh_attr;
      if ((n = ipc_mutex_lock (mqinfo->mqi_lock)) != 0)
d941 2
a942 2
	  errno = n;
	  __leave;
d944 7
a950 9
      ipc_mutex_locked = true;
      if (maxlen < (size_t) attr->mq_msgsize)
	{
	  set_errno (EMSGSIZE);
	  __leave;
	}
      if (attr->mq_curmsgs == 0)	/* queue is empty */
	{
	  if (mqinfo->mqi_flags & O_NONBLOCK)
d952 2
a953 2
	      set_errno (EAGAIN);
	      __leave;
a954 13
	  /* Wait for a message to be placed onto queue */
	  mqhdr->mqh_nwait++;
	  while (attr->mq_curmsgs == 0)
	    {
	      int ret = ipc_cond_timedwait (mqinfo->mqi_waitrecv,
					    mqinfo->mqi_lock, abstime);
	      if (ret != 0)
		{
		  set_errno (ret);
		  __leave;
		}
	    }
	  mqhdr->mqh_nwait--;
d956 2
d959 2
a960 2
      if ((index = mqhdr->mqh_head) == 0)
	api_fatal ("mq_receive: curmsgs = %ld; head = 0", attr->mq_curmsgs);
d962 15
a976 6
      msghdr = (struct msg_hdr *) &mptr[index];
      mqhdr->mqh_head = msghdr->msg_next;     /* new head of list */
      len = msghdr->msg_len;
      memcpy(ptr, msghdr + 1, len);           /* copy the message itself */
      if (priop != NULL)
	*priop = msghdr->msg_prio;
d978 2
a979 3
      /* Just-read message goes to front of free list */
      msghdr->msg_next = mqhdr->mqh_free;
      mqhdr->mqh_free = index;
d981 3
a983 12
      /* Wake up anyone blocked in mq_send waiting for room */
      if (attr->mq_curmsgs == attr->mq_maxmsg)
	ipc_cond_signal (mqinfo->mqi_waitsend);
      attr->mq_curmsgs--;

      ipc_mutex_unlock (mqinfo->mqi_lock);
    }
  __except (EBADF) {}
  __endtry
  if (ipc_mutex_locked)
    ipc_mutex_unlock (mqinfo->mqi_lock);
  return len;
d1007 6
a1012 1
  __try
d1014 5
a1018 8
      mqinfo = (struct mq_info *) mqd;
      if (mqinfo->mqi_magic != MQI_MAGIC)
	{
	  set_errno (EBADF);
	  __leave;
	}
      mqhdr = mqinfo->mqi_hdr;
      attr = &mqhdr->mqh_attr;
d1020 2
a1021 2
      if (mq_notify (mqd, NULL))	/* unregister calling process */
	__leave;
d1023 5
a1027 5
      msgsize = MSGSIZE (attr->mq_msgsize);
      filesize = sizeof (struct mq_hdr)
		 + (attr->mq_maxmsg * (sizeof (struct msg_hdr) + msgsize));
      if (munmap (mqinfo->mqi_hdr, filesize) == -1)
	__leave;
d1029 6
a1034 10
      mqinfo->mqi_magic = 0;          /* just in case */
      ipc_cond_close (mqinfo->mqi_waitsend);
      ipc_cond_close (mqinfo->mqi_waitrecv);
      ipc_mutex_close (mqinfo->mqi_lock);
      free (mqinfo);
      return 0;
    }
  __except (EBADF) {}
  __endtry
  return -1;
d1065 1
a1065 1
  int i, fd = -1, created = 0;
d1081 9
a1089 1
  __try
d1091 29
a1119 1
      oflag &= (O_CREAT | O_EXCL);
d1121 12
a1132 38
    again:
      if (oflag & O_CREAT)
	{
	  va_start (ap, oflag);		/* init ap to final named argument */
	  mode = va_arg (ap, mode_t) & ~S_IXUSR;
	  value = va_arg (ap, unsigned int);
	  va_end (ap);

	  /* Open and specify O_EXCL and user-execute */
	  fd = open (semname, oflag | O_EXCL | O_RDWR | O_CLOEXEC,
		     mode | S_IXUSR);
	  if (fd < 0)
	    {
	      if (errno == EEXIST && (oflag & O_EXCL) == 0)
		goto exists;		/* already exists, OK */
	      return SEM_FAILED;
	    }
	  created = 1;
	  /* First one to create the file initializes it. */
	  NtAllocateLocallyUniqueId (&sf.luid);
	  sf.value = value;
	  sf.hash = hash_path_name (0, semname);
	  if (write (fd, &sf, sizeof sf) != sizeof sf)
	    __leave;
	  sem = semaphore::open (sf.hash, sf.luid, fd, oflag, mode, value,
				 wasopen);
	  if (sem == SEM_FAILED)
	    __leave;
	  /* Initialization complete, turn off user-execute bit */
	  if (fchmod (fd, mode) == -1)
	    __leave;
	  /* Don't close (fd); */
	  return sem;
	}

    exists:
      /* Open the file and fetch the semaphore name. */
      if ((fd = open (semname, O_RDWR | O_CLOEXEC)) < 0)
a1134 7
	    goto again;
	  __leave;
	}
      /* Make certain initialization is complete */
      for (i = 0; i < MAX_TRIES; i++)
	{
	  if (stat64 (semname, &statbuff) == -1)
d1136 3
a1138 7
	      if (errno == ENOENT && (oflag & O_CREAT))
		{
		  close (fd);
		  fd = -1;
		  goto again;
		}
	      __leave;
d1140 1
a1140 3
	  if ((statbuff.st_mode & S_IXUSR) == 0)
	    break;
	  sleep (1);
d1142 8
a1149 21
      if (i == MAX_TRIES)
	{
	  set_errno (ETIMEDOUT);
	  __leave;
	}
      if (file.lock (fd, sizeof sf))
	__leave;
      if (read (fd, &sf, sizeof sf) != sizeof sf)
	__leave;
      sem = semaphore::open (sf.hash, sf.luid, fd, oflag, mode, sf.value,
			     wasopen);
      file.unlock (fd);
      if (sem == SEM_FAILED)
	__leave;
      /* If wasopen is set, the semaphore was already opened and we already have
	 an open file descriptor pointing to the file.  This means, we have to
	 close the file descriptor created in this call.  It won't be stored
	 anywhere anyway. */
      if (wasopen)
	close (fd);
      return sem;
d1151 17
a1167 2
  __except (EFAULT) {}
  __endtry
d1171 1
a1171 2
  if (fd >= 0)
    file.unlock (fd);
@


1.33
log
@	* Merge in cygwin-64bit-branch.
@
text
@d202 1
a202 1
      timespec_to_filetime (abstime, (FILETIME *) &duetime);
@


1.32
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d113 1
a113 1
      debug_printf ("NtCreateMutant: %p", status);
d166 1
a166 1
      debug_printf ("NtCreateEvent: %p", status);
d287 1
a287 1
  struct __flock64 fl;
d351 14
d367 4
a370 4
  struct mq_attr  mqh_attr;	 /* the queue's attributes */
  long            mqh_head;	 /* index of first message */
  long            mqh_free;	 /* index of first free message */
  long            mqh_nwait;	 /* #threads blocked in mq_receive() */
d374 9
a382 1
  struct sigevent mqh_event;	 /* for mq_notify() */
d387 2
a388 2
  long            msg_next;	 /* index of next on linked list */
  ssize_t         msg_len;	 /* actual length */
d391 1
d396 1
a396 1
  unsigned long   mqi_magic;	 /* magic number if open */
d411 2
a412 2
extern "C" _off64_t lseek64 (int, _off64_t, int);
extern "C" void *mmap64 (void *, size_t, int, int, int, _off64_t);
d419 1
a419 1
  _off64_t filesize = 0;
d423 1
a423 1
  struct __stat64 statbuff;
d467 6
a472 1
      else if (attr->mq_maxmsg <= 0 || attr->mq_msgsize <= 0)
d512 1
d587 9
d644 1
a644 1
  struct mq_attr *attr;
d678 1
a678 1
  struct mq_attr *attr;
d774 1
a774 1
  struct mq_attr *attr;
d907 1
a907 1
  struct mq_attr *attr;
d1004 1
a1004 1
  struct mq_attr *attr;
d1069 1
a1069 1
  struct __stat64 statbuff;
d1191 1
a1191 1
      && lseek64 (fd, 0LL, SEEK_SET) != (_off64_t) -1
@


1.31
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d3 1
a3 1
   Copyright 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.30
log
@Change "set_thread_waiting" to "set_signal_arrived" throughout.
@
text
@d122 1
a122 1
  switch (cancelable_wait (mtx, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
@


1.30.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d287 1
a287 1
  struct flock fl;
d388 2
a389 2
extern "C" off_t lseek64 (int, off_t, int);
extern "C" void *mmap64 (void *, size_t, int, int, int, off_t);
d396 1
a396 1
  off_t filesize = 0;
d400 1
a400 1
  struct stat statbuff;
d1031 1
a1031 1
  struct stat statbuff;
d1153 1
a1153 1
      && lseek64 (fd, 0LL, SEEK_SET) != (off_t) -1
@


1.30.2.2
log
@Pull in changes from HEAD
@
text
@d122 1
a122 1
  switch (cygwait (mtx, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
@


1.30.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d3 1
a3 1
   Copyright 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d113 1
a113 1
      debug_printf ("NtCreateMutant: %y", status);
d166 1
a166 1
      debug_printf ("NtCreateEvent: %y", status);
@


1.30.2.4
log
@	* posix_ipc.cc: Enforce 4 byte alignment on all structs used in the
	message queue file.
	(struct mq_fattr): Fixed size mq_attr structure as stored in file.
	(struct mq_hdr): Change to have same size on 32 and 64 bit.  Add
	mqh_magic to allow check for old message queue file.
	(struct msg_hdr): Change to have same size on 32 and 64 bit.  Change
	type of mqh_attr to struct mq_fattr.
	(struct mq_info): Change to have same size on 32 and 64 bit.
	(mq_open): Add check for maximum mq_maxmsg and mq_msgsize values which
	still fit into 32 bit values.  Set mqh_magic in file to MQI_MAGIC.
	Check mqh_magic value on existing file to detect old message queue file.
	(mq_getattr): Change type of local attr variable to struct mq_fattr.
	(mq_setattr): Ditto.
	(_mq_send): Ditto.
	(_mq_receive): Ditto.
	(mq_close): Ditto.
@
text
@a350 14
/* The mq_attr structure is defined using long datatypes per POSIX.
   For interoperability reasons between 32 and 64 bit processes, we have
   to make sure to use a unified structure layout in the message queue file.
   That's what the mq_fattr is, the in-file representation of the mq_attr
   struct. */
#pragma pack (push, 4)
struct mq_fattr
{
  uint32_t mq_flags;
  uint32_t mq_maxmsg;
  uint32_t mq_msgsize;
  uint32_t mq_curmsgs;
};

d353 4
a356 4
  struct mq_fattr mqh_attr;	 /* the queue's attributes */
  int32_t         mqh_head;	 /* index of first message */
  int32_t         mqh_free;	 /* index of first free message */
  int32_t         mqh_nwait;	 /* #threads blocked in mq_receive() */
d360 1
a360 9
  union {
    struct sigevent mqh_event;	 /* for mq_notify() */
    /* Make sure sigevent takes the same space on 32 and 64 bit systems.
       Other than that, it doesn't need to be compatible since only
       one process can be notified at a time. */
    uint64_t        mqh_placeholder[8];
  };
  uint32_t        mqh_magic;	/* Expect MQI_MAGIC here, otherwise it's
				   an old-style message queue. */
d365 2
a366 2
  int32_t         msg_next;	 /* index of next on linked list */
  int32_t         msg_len;	 /* actual length */
a368 1
#pragma pack (pop)
d373 1
a373 1
  uint32_t        mqi_magic;	 /* magic number if open */
d444 1
a444 6
      /* Check minimum and maximum values.  The max values are pretty much
         arbitrary, taken from the linux mq_overview man page.  However,
	 these max values make sure that the internal mq_fattr structure
	 can use 32 bit types. */
      else if (attr->mq_maxmsg <= 0 || attr->mq_maxmsg > 32768
	       || attr->mq_msgsize <= 0 || attr->mq_msgsize > 1048576)
a483 1
      mqhdr->mqh_magic = MQI_MAGIC;
a557 9
  if (mqhdr->mqh_magic != MQI_MAGIC)
    {
      system_printf (
"Old message queue \"%s\" detected!\n"
"This file is not usable as message queue anymore due to changes in the "
"internal file layout.  Please remove the file and try again.", mqname);
      set_errno (EACCES);
      goto err;
    }
d606 1
a606 1
  struct mq_fattr *attr;
d640 1
a640 1
  struct mq_fattr *attr;
d736 1
a736 1
  struct mq_fattr *attr;
d869 1
a869 1
  struct mq_fattr *attr;
d966 1
a966 1
  struct mq_fattr *attr;
@


1.29
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d180 1
a180 1
  set_thread_waiting here (w4[1]);
@


1.28
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d122 1
a122 3
  HANDLE h[2] = { mtx, signal_arrived };

  switch (WaitForMultipleObjects (2, h, FALSE, INFINITE))
d127 1
a127 1
    case WAIT_OBJECT_0 + 1:
d175 1
a175 1
  HANDLE w4[4] = { evt, signal_arrived, NULL, NULL };
d180 1
@


1.27
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d122 3
a124 1
  switch (cancelable_wait (mtx, NULL, cw_sig_eintr | cw_cancel | cw_cancel_self))
d129 1
a129 1
    case WAIT_SIGNALED:
d177 1
a177 1
  HANDLE w4[4] = { evt, };
a181 1
  set_thread_waiting (w4[1]);
@


1.26
log
@whitespace elimination
@
text
@d122 1
a122 3
  HANDLE h[2] = { mtx, signal_arrived };

  switch (WaitForMultipleObjects (2, h, FALSE, INFINITE))
d127 1
a127 1
    case WAIT_OBJECT_0 + 1:
d175 1
a175 1
  HANDLE w4[4] = { evt, signal_arrived, NULL, NULL };
d180 1
@


1.25
log
@	* fhandler_windows.cc (fhandler_windows::read): Use
	pthread::get_cancel_event to fetch thread's cancel event.
	* flock.cc (lf_setlock): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto.
	* thread.cc (pthread::get_cancel_event): New static method.
	* thread.h (pthread::get_cancel_event): Declare.
@
text
@d227 1
a227 1
      	pthread::static_cancel_self ();
d590 1
a590 1
      	ipc_mutex_close (mqinfo->mqi_lock);
@


1.24
log
@	* fcntl.cc (fcntl64): Call pthread_testcancel.
	* fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* flock.cc (lf_setlock): Allow to cancel thread running blocking
	file lock.  Try to make code more readable.
	(lockf): Call pthread_testcancel.
	* mmap.cc (msync): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Call pthread::static_cancel_self
	rather than pthread_testcancel.
	* select.cc (cygwin_select): Call pthread_testcancel.
	* syscalls.cc (pread): Ditto.
	(pwrite): Ditto.
	(readv): Ditto.
	(writev): Ditto.
	(open): Ditto.
	(close): Ditto.
	(fsync): Ditto.
	* termios.cc (tcdrain): Ditto.
	* thread.cc: Align list of cancellation points with above changes.
	Mark not-implemented functions, too.
	(cancelable_wait): Don't set unused object indices to WAIT_FAILED
	since that could result in wrong behaviour.  Set them to the invalid
	value WAIT_TIMEOUT + 1 instead.
@
text
@a176 1
  pthread_t thread;
d182 2
a183 4
  thread = pthread::self ();
  if (thread && thread->cancel_event
      && thread->cancelstate != PTHREAD_CANCEL_DISABLE)
    w4[cnt++] = thread->cancel_event;
@


1.23
log
@	* posix_ipc.cc (ipc_cond_timedwait): Only wait for pthread's
	cancel_event if thread's cancelability isn't disabled.
@
text
@d230 1
a230 1
      	pthread_testcancel ();
@


1.22
log
@	* posix_ipc.cc (ipc_cond_timedwait): Also wait for pthread's
	cancel_event, if any.  Call pthread_testcancel if cancel_event has been
	signalled.
@
text
@d184 2
a185 1
  if (thread && thread->cancel_event)
@


1.21
log
@	* posix_ipc.cc (ipc_cond_timedwait): Remove pthread_testcancel calls.
	(_mq_send): Add pthread_testcancel call at start of function.
	(_mq_receive): Ditto.
@
text
@d177 2
a178 1
  HANDLE w4[3] = { evt, signal_arrived, NULL };
d180 1
d183 3
d200 2
a201 1
      status = NtCreateTimer (&w4[2], TIMER_ALL_ACCESS, NULL,
d206 1
a206 1
      status = NtSetTimer (w4[2], &duetime, NULL, NULL, FALSE, 0, NULL);
d209 1
a209 1
	  NtClose (w4[2]);
a211 1
      cnt = 3;
d228 4
d256 4
d267 1
a267 1
  if (w4[2])
d270 2
a271 2
	NtCancelTimer (w4[2], NULL);
      NtClose (w4[2]);
@


1.20
log
@	* cygerrno.h (geterrno_from_nt_status): Declare.
	* errno.cc (geterrno_from_nt_status): Define.
	* flock.cc: Fix copyright dates.
	* ntdll.h (enum _TIMER_TYPE): Define.
	(PTIMER_APC_ROUTINE): Define.
	(NtCancelTimer): Declare.
	(NtCreateTimer): Declare.
	(NtSetTimer): Declare.
	* posix_ipc.cc (ipc_cond_timedwait): Rewrite to make interruptible and
	restartable.  Call pthread_testcancel in case of timeout to enable
	pthread_cancel on waiting thread.  Replace WFMO timeout with waiting
	for a waitable timer.  Explain why.  Replace single call to WFMO with
	two calls, one for the event, one for the mutex.  Don't lock mutex in
	case of error.
	(ipc_cond_signal): Make void function.
	(ipc_cond_close): Ditto.
	(_mq_send): Immediately return -1 in case of error from
	ipc_cond_timedwait.
	(_mq_receive): Ditto.
@
text
@a222 1
      pthread_testcancel ();
a246 1
	  pthread_testcancel ();
d730 2
d863 2
@


1.19
log
@	* advapi32.cc (AllocateLocallyUniqueId): Remove.
	* fhandler_disk_file.cc (fhandler_base::open_fs): Replace call to
	AllocateLocallyUniqueId with call to NtAllocateLocallyUniqueId;
	* posix_ipc.cc (mq_open): Ditto.  Drop error handling for that call.
	(sem_open): Ditto.
@
text
@d177 30
a206 21
  struct timeval tv;
  DWORD timeout;
  HANDLE h[2] = { mtx, evt };
  int err;

  if (!abstime)
    timeout = INFINITE;
  else if (abstime->tv_sec < 0
	   || abstime->tv_nsec < 0
	   || abstime->tv_nsec > 999999999)
    return EINVAL;
  else
    {
      gettimeofday (&tv, NULL);
      /* Check for immediate timeout. */
      if (tv.tv_sec > abstime->tv_sec
	  || (tv.tv_sec == abstime->tv_sec
	      && tv.tv_usec > abstime->tv_nsec / 1000))
	return ETIMEDOUT;
      timeout = (abstime->tv_sec - tv.tv_sec) * 1000;
      timeout += (abstime->tv_nsec / 1000 - tv.tv_usec) / 1000;
d209 5
a213 3
  if ((err = ipc_mutex_unlock (mtx)) != 0)
    return err;
  switch (WaitForMultipleObjects (2, h, TRUE, timeout))
d216 10
a225 5
    case WAIT_ABANDONED_0:
      return 0;
    case WAIT_TIMEOUT:
      ipc_mutex_lock (mtx);
      return ETIMEDOUT;
d227 1
d230 33
a262 1
  return geterrno_from_win_error ();
d265 1
a265 1
static inline int
d268 1
a268 1
  return SetEvent (evt) ? 0 : geterrno_from_win_error ();
d271 1
a271 1
static inline int
d274 1
a274 1
  return CloseHandle (evt) ? 0 : geterrno_from_win_error ();
d788 1
a788 1
	      goto err;
d903 1
a903 1
	      goto err;
@


1.18
log
@	* posix_ipc.cc (ipc_cond_timedwait): If ipc_mutex_unlock fails, return
	actual error number.
	(_mq_send): Break loop if ipc_cond_timedwait returns with error.
	(_mq_receive): Ditto.
@
text
@d422 1
a422 5
      if (!AllocateLocallyUniqueId (&luid))
	{
	  __seterrno ();
	  goto err;
	}
d1007 1
a1007 5
      if (!AllocateLocallyUniqueId (&sf.luid))
	{
	  __seterrno ();
	  goto err;
	}
@


1.17
log
@	* posix_ipc.cc (ipc_mutex_init): Call NtCreateMutant to make sure the
	access mask is correct.
	(ipc_cond_init): Take additional parameter to differ between send and
	receive event.  Call NtCreateEvent to make sure the access mask is
	correct.
	(ipc_cond_timedwait): Reset Event prior to calling WFMO.
	(struct mq_info): Split mqi_wait into two events, mqi_waitsend and
	mqi_waitrecv.
	(mq_open): Calloc mqinfo.  Create mqi_waitsend and mqi_waitrecv events.
	Make sure all synchronization objects are closed in case of an error.
	(_mq_send): Wait for mqi_waitsend event.  Signal mqi_waitrecv event.
	(_mq_receive): Wait for mqi_waitrecv event.  Signal mqi_waitsend event.
	(mq_close): Close mqi_waitsend and mqi_waitrecv events.
@
text
@d3 1
a3 1
   Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
d180 1
d200 2
a201 2
  if (ipc_mutex_unlock (mtx))
    return -1;
d737 9
a745 1
	ipc_cond_timedwait (mqinfo->mqi_waitsend, mqinfo->mqi_lock, abstime);
d852 9
a860 1
	ipc_cond_timedwait (mqinfo->mqi_waitrecv, mqinfo->mqi_lock, abstime);
@


1.16
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d12 1
d99 18
a116 9
  char buf[MAX_PATH];
  SECURITY_ATTRIBUTES sa = sec_none;

  __small_sprintf (buf, "mqueue/mtx_%s", name);
  sa.lpSecurityDescriptor = everyone_sd (CYG_MUTANT_ACCESS);
  *pmtx = CreateMutex (&sa, FALSE, buf);
  if (!*pmtx)
    debug_printf ("CreateMutex: %E");
  return *pmtx ? 0 : geterrno_from_win_error ();
d151 1
a151 1
ipc_cond_init (HANDLE *pevt, const char *name)
d153 19
a171 9
  char buf[MAX_PATH];
  SECURITY_ATTRIBUTES sa = sec_none;

  __small_sprintf (buf, "mqueue/evt_%s", name);
  sa.lpSecurityDescriptor = everyone_sd (CYG_EVENT_ACCESS);
  *pevt = CreateEvent (&sa, TRUE, FALSE, buf);
  if (!*pevt)
    debug_printf ("CreateEvent: %E");
  return *pevt ? 0 : geterrno_from_win_error ();
d198 1
a204 1
      ResetEvent (evt);
d318 2
a319 1
  HANDLE          mqi_wait;	 /* and condition variable */
d407 1
a407 1
      if (!(mqinfo = (struct mq_info *) malloc (sizeof (struct mq_info))))
d441 1
a441 1
      /* Initialize mutex & condition variable */
d446 5
a450 1
      i = ipc_cond_init (&mqinfo->mqi_wait, mqhdr->mqh_uname);
d501 1
a501 1
  if (!(mqinfo = (struct mq_info *) malloc (sizeof (struct mq_info))))
d512 5
a516 1
  i = ipc_cond_init (&mqinfo->mqi_wait, mqhdr->mqh_uname);
d533 9
a541 1
    free (mqinfo);
d736 1
a736 1
	ipc_cond_timedwait (mqinfo->mqi_wait, mqinfo->mqi_lock, abstime);
d772 1
a772 1
    ipc_cond_signal (mqinfo->mqi_wait);
d843 1
a843 1
	ipc_cond_timedwait (mqinfo->mqi_wait, mqinfo->mqi_lock, abstime);
d863 1
a863 1
    ipc_cond_signal (mqinfo->mqi_wait);
d918 2
a919 1
  ipc_cond_close (mqinfo->mqi_wait);
@


1.15
log
@	* posix_ipc.cc (mq_open): Avoid closing the same descriptor twice in
	case of errors.
	(sem_open): Ditto.
@
text
@d3 1
a3 1
   Copyright 2007, 2008, 2009 Red Hat, Inc.
d251 1
a251 1
  return open (shmname, oflag, mode & 0777);
d354 1
a354 1
      fd = open (mqname, oflag | O_EXCL | O_RDWR, mode | S_IXUSR);
d438 1
a438 1
  if ((fd = open (mqname, O_RDWR)) < 0)
d947 1
a947 1
      fd = open (semname, oflag | O_EXCL | O_RDWR, mode | S_IXUSR);
d977 1
a977 1
  if ((fd = open (semname, O_RDWR)) < 0)
@


1.14
log
@Improve ChangeLog entry.  Fix posix_ipc.cc copyright
@
text
@d315 1
a315 1
  int i, fd, nonblock, created;
d452 1
d473 1
d505 2
a506 1
  close (fd);
d915 1
a915 1
  int i, fd, created;
d991 1
d1030 2
a1031 1
  close (fd);
@


1.13
log
@	* posix_ipc.cc (check_path): Fix typo in comment.  Align naming
	convention rules to Linux.  Add comment.
@
text
@d3 1
a3 1
   Copyright 2007 Red Hat, Inc.
@


1.12
log
@* localtime.cc (increment_overflow): Mark as non-inline to prevent compiler
from complaining about the very thing we're trying to test.
* ntea.cc (read_ea): Reorganize to avoid a new compiler warning/error.
* sched.cc (sched_rr_get_interval): Ditto.
* select.cc (peek_serial): Ditto.
* libc/rexec.cc (ruserpass): Ditto.
* posix_ipc.cc (ipc_names): Make static to avoid a compiler warning
(and it's the right thing to do anyway).
@
text
@d50 1
a50 1
  /* Note that we require the existance of the apprpriate /dev subdirectories
d68 7
a74 2
  /* Name must start with a single slash. */
  if (!name || name[0] != '/' || name[1] == '/' || !name[1])
d80 3
d91 1
a91 1
					name + 1);
@


1.11
log
@	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Drop fattr variable
	and use FILE_ATTRIBUTE_DIRECTORY directly in call to NtCreateFile.
	* posix_ipc.cc (ipc_mutex_init): Fix format string when creating IPC
	object name.
	(ipc_cond_init): Ditto.
	* security.cc (alloc_sd): Add parentheses to fix setting initial
	owner_allow value.
@
text
@d29 1
a29 1
struct
@


1.10
log
@	* Makefile.in (DLL_OFILES): Add kernel32.o.
	* autoload.cc (WSACloseEvent): Remove.
	(WSACreateEvent): Remove.
	* cygheap.cc (cygheap_init): Drop initializing shared_prefix.
	* cygheap.h (struct init_cygheap): Drop shared_prefix and
	shared_prefix_buf members.
	* fhandler_socket.cc (sock_shared_name): New static function.
	(search_wsa_event_slot): Convert name buffers to WCHAR.  Call
	NtCreateMutant/NtOpenMutant to create mutexes in session local
	namespace.
	(fhandler_socket::init_events): Ditto.  Fix debug output.
	(fhandler_socket::release_events): Close mutexes using NtClose.
	(fhandler_socket::dup): Ditto.
	* kernel32.cc: New file, implementing Win32 calls in a Cygwin-specific
	way.
	* mmap.cc (MapView): Make static.
	* ntdll.h: Fix status code sorting.
	(STATUS_OBJECT_NAME_EXISTS): Define.
	(SEMAPHORE_QUERY_STATE): Define.
	(CYG_SHARED_DIR_ACCESS): Define.
	(CYG_MUTANT_ACCESS): Define.
	(CYG_EVENT_ACCESS): Define.
	(CYG_SEMAPHORE_ACCESS): Define.
	(enum _PROCESSINFOCLASS): Define ProcessSessionInformation.
	(struct _PROCESS_SESSION_INFORMATION): Define.
	(NtCreateSemaphore): Declare.
	(NtOpenSemaphore): Declare.
	* flock.cc: Use CYG_xxx_ACCESS access masks where appropriate.
	* posix_ipc.cc (ipc_mutex_init): Use native functions to create mutex.
	Create in cygwin-shared subdir.
	(ipc_cond_init): Ditto for event.
	(ipc_mutex_close): Use NtClose.
	(ipc_cond_close): Ditto.
	(mq_open): Drop "cyg" prefix from mqh_uname.
	* shared.cc (CYG_SHARED_DIR_ACCESS): Drop definition here.
	(_cygwin_testing): Declare extern on file level.
	(get_shared_parent_dir): Change name of shared directory.  Add name
	to api_fatal output.
	(get_session_parent_dir): New function.
	(shared_name): Simplify.
	(shared_info::initialize): Call get_session_parent_dir.
	* shared_info.h (get_session_parent_dir): Declare.
	* smallprint.cc (__small_vswprintf): Fix bug in multibyte string
	conversion.
	* thread.cc (semaphore::semaphore): Align semaphore name to object
	names in posix IPC functions.
	* include/cygwin/version.h (CYGWIN_VERSION_SHARED_DATA): Bump.
@
text
@d93 1
a93 1
  __small_sprintf (buf, "mqueue/mtx_%W", name);
d138 1
a138 1
  __small_sprintf (buf, "mqueue/evt_%W", name);
@


1.9
log
@Remove unneeded header files from source files throughout.
@
text
@d19 1
d91 5
a95 2
  __small_sprintf (buf, "%scyg_pmtx/%s", cygheap->shared_prefix, name);
  *pmtx = CreateMutex (&sec_all, FALSE, buf);
d97 1
a97 1
    debug_printf ("failed: %E\n");
d136 5
a140 2
  __small_sprintf (buf, "%scyg_pevt/%s", cygheap->shared_prefix, name);
  *pevt = CreateEvent (&sec_all, TRUE, FALSE, buf);
d142 1
a142 1
    debug_printf ("failed: %E\n");
d397 1
a397 1
      __small_sprintf (mqhdr->mqh_uname, "cyg%016X%08x%08x",
@


1.8
log
@	Throughout, call fcntl64 instead of fcntl or fcntl_worker.
	* fcntl.cc (fcntl_worker): Remove.
	(fcntl64): Add fault handler.  Move fcntl_worker stuff here.  Add case
	for locking and call fhandler's lock method directly.  Make sure that
	F_FLOCK flag isn't set in lock call.
	(_fcntl): Add fault handler.
	* fhandler.cc (fhandler_base::fcntl): Drop lock cases.
	* flock.cc (flock): Add fault handler.  Simplify code.  Call fhandlers
	lock method directly instead of fcntl_worker.  Add debug output.
	(lockf): Add fault handler.  Call fhandlers lock method directly
	instead of fcntl_worker.  Add debug output.
	* winsup.h (fcntl_worker): Drop declaration.
	(fcntl64): Declare.
@
text
@a13 1
#include "cygerrno.h"
a17 1
#include "security.h"
a18 1
#include <sys/stat.h>
a20 2
#include <fcntl.h>
#include <pwd.h>
a21 1
#include <limits.h>
a22 1
#include <stdarg.h>
@


1.7
log
@	* posix_ipc.cc (ipc_names): Rename max_len to prefix_len.  Store
	the prefix len in it.
	(check_path): Take length parameter.  Use this length insetad of
	calling strlen.  Allow PATH_MAX length paths.
	(ipc_mutex_init): Use MAX_PATH instead of CYG_MAX_PATH.
	(ipc_cond_init): Ditto.
	(shm_open): Allocate local name buffer not bigger than necessary.  Call
	check_path with additional length argument.
	(shm_unlink): Ditto.
	(mq_open): Ditto.
	(mq_unlink): Ditto.
	(sem_open): Ditto.
	(sem_unlink): Ditto.
@
text
@d212 1
a212 1
    return fcntl (fd, F_SETLKW, &fl);
d219 1
a219 1
    return fcntl (fd, F_SETLKW, &fl);
@


1.6
log
@* fork.cc: White space.
* net.cc: Ditto.
* posix_ipc.cc: Ditto.
@
text
@d33 2
d38 1
a38 1
  const size_t max_len;
d41 3
a43 3
  { "/dev/shm", CYG_MAX_PATH - 10, "POSIX shared memory object" },
  { "/dev/mqueue", CYG_MAX_PATH - 13, "POSIX message queue" },
  { "/dev/shm", CYG_MAX_PATH - 14, "POSIX semaphore" }
d54 1
a54 1
check_path (char *res_name, ipc_type_t type, const char *name)
d81 1
a81 1
  if (strlen (name) > ipc_names[type].max_len)
d96 1
a96 1
  char buf[CYG_MAX_PATH];
d138 1
a138 1
  char buf[CYG_MAX_PATH];
d228 2
a229 1
  char shmname[CYG_MAX_PATH];
d231 1
a231 1
  if (!check_path (shmname, shmem, name))
d249 2
a250 1
  char shmname[CYG_MAX_PATH];
d252 1
a252 1
  if (!check_path (shmname, shmem, name))
a318 1
  char mqname[CYG_MAX_PATH];
d320 4
a323 1
  if (!check_path (mqname, mqueue, name))
d879 2
a880 1
  char mqname[CYG_MAX_PATH];
d882 1
a882 1
  if (!check_path (mqname, mqueue, name))
a910 1
  char semname[CYG_MAX_PATH];
d914 4
a917 1
  if (!check_path (semname, semaphore, name))
d1053 2
a1054 1
  char semname[CYG_MAX_PATH];
d1056 1
a1056 1
  if (!check_path (semname, semaphore, name))
@


1.5
log
@	* cygheap.cc (cygheap_init): Fix formatting.  Remove comment.  Set
	shared_prefix depending only on terminal service capability.
	* dcrt0.cc (dll_crt0_1): Don't call set_cygwin_privileges here.
	* fhandler_fifo.cc (fhandler_fifo::open): Create the mutex as global
	object.
	* posix_ipc.cc (ipc_mutex_init): Use cygheap->shared_prefix.
	(ipc_cond_init): Ditto.
	* sec_helper.cc (privilege_name): Make static.  Use LookupPrivilegeName
	directly to be independent of the state of cygheap.
	(set_privilege): Take a LUID as parameter instead of an index value.
	Only print debug output in case of failure.
	(set_cygwin_privileges): Add comment.  Use LookupPrivilegeValue to
	get privilege LUIDs.
	(init_global_security): Call set_cygwin_privileges here.
	* security.h (privilege_name): Drop declaration.
	(set_privilege): Declare according to above change.
	(set_process_privilege): Call privilege_luid to get LUID.
	(_push_thread_privilege): Ditto.
	* shared.cc (open_shared): Add comment.  On systems supporting the
	SeCreateGlobalPrivilege, try to create/open global shared memory first.
	Fall back to local shared memory if that fails.
	* thread.cc (semaphore::semaphore): Use cygheap->shared_prefix.
	* wincap.h (wincapc::has_create_global_privilege): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d108 1
a108 1
    {     
d117 1
a117 1
    }     
d171 1
a171 1
    {     
d181 1
a181 1
    }     
d269 1
a269 1
  				    objects connected to this queue */
d342 1
a342 1
        {
d359 1
a359 1
      		 + (attr->mq_maxmsg * (sizeof (struct msg_hdr) + msgsize));
d387 1
a387 1
        {
d500 1
a500 1
  
d517 1
a517 1
    }       
d525 1
a525 1
}               
d531 1
a531 1
  struct mq_hdr *mqhdr; 
d577 1
a577 1
  
d585 1
a585 1
      set_errno (EBADF);  
d588 1
a588 1
  mqhdr = mqinfo->mqi_hdr; 
d594 1
a594 1
  
d614 1
a614 1
    }                                        
d617 1
a617 1
}                       
d750 1
a750 1
  struct mq_hdr *mqhdr; 
d929 1
a929 1
        {
d937 1
a937 1
        {
d944 1
a944 1
        goto err;
d947 1
a947 1
        goto err;
@


1.4
log
@	* cygwin.din (sem_unlink): Export.
	* posix_ipc.cc: Include thread.h and semaphore.h.  Remove TODO
	comment.
	(ipc_names): Add max_len member.  Set to maximum length of the path
	before tacking on the prefix path.  Set prefix path for named semaphors
	to /dev/shm, as on Linux.
	(enum ipc_type_t): Change sem to semaphore to avoid name conflicts.
	(check_path): Detect empty paths.  Use ipc_names's max_len member.
	Use __small_sprintf to create full object path name.  Special case
	semaphores.
	(ipc_cond_init): Drop superfluous strcpy.
	(class ipc_flock): New class to simplify file locking in subsequent
	code.
	(struct mq_hdr): Raise size of mqh_uname to allow adding a unique
	LUID to the name.
	(mq_open): Fix formatting.  Create unique synchronization object names
	using AllocateLocallyUniqueId.
	(struct sem_finfo): New structure defining named semaphore file content.
	(sem_open): Move here.  Rework implementation to allow kernel
	persistent implementation of POSIX named semaphores.
	(_sem_close): Implement sem_close.
	(sem_close): Move here.  Just call _sem_close with do_close parameter
	set to true.
	(sem_unlink): New function.
	* pthread.cc (mangle_sem_name): Remove.
	(sem_open): Move to posix_ipc.cc.
	(sem_close): Ditto.
	* syscalls.cc (close_all_files): Call semaphore::terminate here.
	* thread.cc: Fix formatting.  Rearrange semaphore functions so that
	they are close together.
	(semaphore::semaphore): Rework to play nicely with new named semaphore
	implementation.
	(semaphore::_terminate): Call _sem_close if semaphore is a named
	semaphore.
	(semaphore::destroy): Don't destroy named semaphores.  Return EINVAL
	instead.
	(semaphore::close): Only destroy named semaphores.  Return EINVAL
	otherwise.
	(semaphore::open): Rework to play nicely with new named semaphore
	implementation.  Loop through existing semaphores to be able to
	return same sem_t pointer as a former call on the same named semaphore.
	(semaphore::getinternal): New function called from _sem_close.
	* thread.h (class List): Make mx and head public.
	(class semaphore): Fix formatting.  Align method declarations with
	implementation in thread.cc.  Add members used for named semaphores.
	(semaphore::terminate): New static method.
	* include/semaphore.h: Redefine SEM_FAILED.  Fix formatting.
	(sem_unlink): Add declaration.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d16 3
d95 1
a95 2
  __small_sprintf (buf, "%scyg_pmtx/%s",
		   wincap.has_terminal_services () ? "Global\\" : "", name);
d137 1
a137 2
  __small_sprintf (buf, "%scyg_pevt/%s",
		   wincap.has_terminal_services () ? "Global\\" : "", name);
@


1.3
log
@	* posix_ipc.cc (mq_open): Avoid compiler warning.  Initialize mqhdr
	before using it in file exists case.
	* include/mqueue.h (mqd_t): Make non-pointer type.
@
text
@a10 5
/* TODO: POSIX semaphores are implemented in thread.cc right now.  The
	 implementation in thread.cc disallows implementing kernel
	 persistent semaphores, so in the long run we should move the
	 implementation here, using file based shared memory instead. */

d12 1
d28 1
d33 1
d36 3
a38 3
  { "/dev/shm", "POSIX shared memory object" },
  { "/dev/mqueue", "POSIX message queue" },
  { "/dev/sem", "POSIX semaphore" }
d45 1
a45 1
  sem
d70 1
a70 1
  if (!name || name[0] != '/' || name[1] == '/')
d76 1
a76 1
  if (strlen (name) > CYG_MAX_PATH - sizeof (ipc_names[type].prefix))
d82 3
a84 2
  strcpy (res_name, ipc_names[type].prefix);
  strcat (res_name, name);
a134 1
  strcpy (buf, wincap.has_terminal_services () ? "Global\\" : "");
d196 24
d267 1
a267 1
  char            mqh_uname[20]; /* unique name used to identify synchronization
d313 1
d321 1
a321 1
      return (mqd_t) -1;
d323 1
d385 8
a392 1
      __small_sprintf (mqhdr->mqh_uname, "cyg%016X", hash_path_name (0,mqname));
d436 1
a436 1
	      close(fd);
d881 170
@


1.2
log
@	* posix_ipc.cc (ipc_mutex_init): Create global object name.
	(ipc_cond_init): Ditto.
	(struct mq_hdr): Add mqh_uname member to store synchronization object
	name.
	(mq_open): Create unique synchronization object name and store in
	mq_hdr->mqh_uname.  Use this name in calls to ipc_mutex_init and
	ipc_cond_init.
@
text
@d282 1
a282 1
  _off64_t filesize;
d430 1
a430 1
  mqinfo->mqi_hdr = (struct mq_hdr *) mptr;
@


1.1
log
@	* Makefile.in (DLL_OFILES): Add posix_ipc.o.
	* cygwin.din (mq_close): Export.
	(mq_getattr): Export.
	(mq_notify): Export.
	(mq_open): Export.
	(mq_receive): Export.
	(mq_send): Export.
	(mq_setattr): Export.
	(mq_timedreceive): Export.
	(mq_timedsend): Export.
	(mq_unlink): Export.
	* posix_ipc.cc: New file implementing the above functions.  Move
	shm_open and shm_unlink from syscalls.cc here.
	* sysconf.cc (sca): Set value of _SC_MQ_OPEN_MAX to MQ_OPEN_MAX,
	_SC_MQ_PRIO_MAX to MQ_PRIO_MAX, _SC_MESSAGE_PASSING to
	_POSIX_MESSAGE_PASSING.
	* include/limits.h (MQ_OPEN_MAX): Define.
	(MQ_PRIO_MAX): Define.
	* include/mqueue.h: New file.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d93 2
a94 4
  strcpy (buf, "cyg_pmtx");
  strcat (buf, name);
  for (char *c = buf; c = strchr (c + 1, '\\'); ++c)
    *c = '/';
d136 3
a138 4
  strcpy (buf, "cyg_pevt");
  strcat (buf, name);
  for (char *c = buf; c = strchr (c + 1, '\\'); ++c)
    *c = '/';
d240 8
a247 6
  struct mq_attr  mqh_attr;	/* the queue's attributes */
  long            mqh_head;	/* index of first message */
  long            mqh_free;	/* index of first free message */
  long            mqh_nwait;	/* #threads blocked in mq_receive() */
  pid_t           mqh_pid;	/* nonzero PID if mqh_event set */
  struct sigevent mqh_event;	/* for mq_notify() */
d252 3
a254 3
  long            msg_next;	/* index of next on linked list */
  ssize_t         msg_len;	/* actual length */
  unsigned int    msg_prio;	/* priority */
d259 5
a263 5
  struct mq_hdr  *mqi_hdr;	/* start of mmap'ed region */
  unsigned long   mqi_magic;	/* magic number if open */
  int             mqi_flags;	/* flags for this process */
  HANDLE          mqi_lock;	/* mutex lock */
  HANDLE          mqi_wait;	/* and condition variable */
d361 1
d375 1
a375 1
      i = ipc_mutex_init (&mqinfo->mqi_lock, mqname);
d379 1
a379 1
      i = ipc_cond_init (&mqinfo->mqi_wait, mqname);
d435 1
a435 1
  i = ipc_mutex_init (&mqinfo->mqi_lock, mqname);
d439 1
a439 1
  i = ipc_cond_init (&mqinfo->mqi_wait, mqname);
@

