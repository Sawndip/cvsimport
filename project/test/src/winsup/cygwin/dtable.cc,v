head	1.280;
access;
symbols
	cygwin-1_7_35-release:1.280
	cygwin-1_7_34-release:1.279
	cygwin-1_7_33-release:1.277.2.2
	cygwin-1_7_32-release:1.277.2.1
	cygwin-1_7_31-release:1.277.2.1
	cygwin-1_7_30-release:1.277
	cygwin-1_7_29-release:1.277
	cygwin-1_7_29-release-branchpoint:1.277.0.2
	cygwin-pre-user-db:1.277
	cygwin-1_7_28-release:1.277
	cygwin-1_7_27-release:1.277
	cygwin-1_7_26-release:1.270
	cygwin-1_7_25-release:1.268
	cygwin-1_7_24-release:1.268
	cygwin-1_7_23-release:1.268
	cygwin-1_7_22-release:1.268
	cygwin-1_7_21-release:1.267
	cygwin-1_7_20-release:1.267
	cygwin-1_7_19-release:1.267
	cygwin-64bit-postmerge:1.267
	cygwin-64bit-premerge-branch:1.266.0.2
	cygwin-64bit-premerge:1.266
	cygwin-1_7_18-release:1.266
	post-ptmalloc3:1.264.2.9
	pre-ptmalloc3:1.264.2.9
	cygwin-1_7_17-release:1.264
	cygwin-64bit-branch:1.264.0.2
	cygwin-1_7_16-release:1.264
	cygwin-1_7_15-release:1.260
	cygwin-1_7_14_2-release:1.260
	cygwin-1_7_14-release:1.260
	cygwin-1_7_12-release:1.256
	cygwin-1_7_11-release:1.250
	cygwin-1_7_10-release:1.246
	signal-rewrite:1.233.0.2
	pre-notty:1.224
	cygwin-1_7_9-release:1.217
	cv-post-1_7_9:1.217.0.2
	cygwin-1_7_8-release:1.217
	cygwin-1_7_7-release:1.216
	cygwin-1_7_5-release:1.213
	cygwin-1_7_4-release:1.213
	cygwin-1_7_3-release:1.213
	cygwin-1_7_2-release:1.212
	fifo_doover3:1.210.0.2
	cygwin-1_7_1-release:1.209
	prefifo:1.200
	cv-branch-2:1.196.0.2
	pre-ripout-set_console_state_for_spawn:1.191
	EOL_registry_mounts:1.188
	preoverlapped:1.174
	drop_9x_support_start:1.173
	cr-0x5f1:1.169.0.4
	cv-branch:1.169.0.2
	pre-ptymaster-archetype:1.168
	cr-0x3b58:1.163.0.4
	cr-0x5ef:1.163.0.2
	after-mmap-privanon-noreserve:1.162
	after-mmap-revamp:1.162
	before-mmap-revamp:1.162
	cgf-more-exit-sync:1.160
	post_wait_sig_exit:1.158
	pre_wait_sig_exit:1.157
	reparent-point:1.142
	noreparent:1.142.0.2
	cr-0x5e6:1.140.0.2
	cr-0x9e:1.134.0.4
	cr-0x9d:1.134.0.2
	cgf-deleteme:1.131.0.2
	pre-sigrewrite:1.124
	corinna-01:1.119
	cr-0x9c:1.114.0.6
	cr-0x9b:1.114.0.4
	cr-0x99:1.114
	Z-emcb-cygwin_daemon:1.114.0.2
	w32api-2_2:1.109
	mingw-runtime-2_4:1.109
	pre-cgf-merge:1.114
	cgf-dev-branch:1.109.0.2
	predaemon:1.78
	cygwin_daemon_merge_HEAD:1.78
	pregp02r1:1.77.0.2
	cygnus_cvs_20020108_pre:1.74
	Z-cygwin_daemon_merge-new_HEAD:1.100
	Z-cygwin_daemon_merge_HEAD:1.100
	cygwin_daemon:1.54.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.280
date	2015.02.15.08.59.54;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2014.08.18.11.09.55;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2014.05.19.11.17.59;	author corinna;	state Exp;
branches;
next	1.277;

1.277
date	2013.12.05.19.43.34;	author cgf;	state Exp;
branches
	1.277.2.1;
next	1.276;

1.276
date	2013.12.04.17.55.17;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2013.12.01.19.17.56;	author cgf;	state Exp;
branches;
next	1.274;

1.274
date	2013.12.01.17.52.48;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2013.12.01.10.27.16;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2013.12.01.02.52.53;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2013.12.01.02.09.21;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2013.11.24.13.01.25;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2013.11.23.13.51.53;	author ericb;	state Exp;
branches;
next	1.268;

1.268
date	2013.07.15.13.54.27;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.265;

1.265
date	2012.12.31.18.31.49;	author cgf;	state Exp;
branches;
next	1.264;

1.264
date	2012.07.06.13.52.17;	author corinna;	state Exp;
branches
	1.264.2.1;
next	1.263;

1.263
date	2012.06.04.01.26.05;	author cgf;	state Exp;
branches;
next	1.262;

1.262
date	2012.06.03.18.02.45;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2012.05.22.17.37.39;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2012.04.21.19.52.11;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2012.04.19.17.21.31;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2012.04.18.05.57.37;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2012.04.07.17.32.44;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2012.04.02.15.56.43;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2012.04.02.11.45.56;	author corinna;	state Exp;
branches;
next	1.254;

1.254
date	2012.04.01.22.28.39;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2012.03.29.18.02.54;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2012.03.20.23.13.40;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2012.03.10.17.51.33;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2012.02.15.16.11.36;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2012.02.14.19.08.20;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2012.02.14.11.27.42;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2012.02.09.01.20.55;	author cgf;	state Exp;
branches;
next	1.246;

1.246
date	2012.02.01.17.20.02;	author cgf;	state Exp;
branches;
next	1.245;

1.245
date	2012.01.22.07.27.57;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2012.01.11.19.07.09;	author cgf;	state Exp;
branches;
next	1.243;

1.243
date	2012.01.08.06.24.17;	author cgf;	state Exp;
branches;
next	1.242;

1.242
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2011.12.17.00.03.30;	author cgf;	state Exp;
branches;
next	1.240;

1.240
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2011.11.08.06.26.15;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2011.10.22.16.26.26;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.236;

1.236
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2011.10.11.23.20.38;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2011.10.11.12.39.31;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2011.08.19.18.19.22;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2011.08.18.09.16.50;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2011.07.04.09.47.10;	author corinna;	state Exp;
branches;
next	1.230;

1.230
date	2011.07.01.22.04.20;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2011.06.30.14.04.51;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2011.06.30.09.37.36;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2011.06.17.08.27.32;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2011.06.14.21.48.43;	author cgf;	state Exp;
branches;
next	1.225;

1.225
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2011.05.31.00.26.37;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2011.04.17.19.56.25;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2011.04.04.11.24.20;	author corinna;	state Exp;
branches;
next	1.218;

1.218
date	2011.04.01.19.48.19;	author yselkowitz;	state Exp;
branches;
next	1.217;

1.217
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2010.06.15.12.05.14;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2010.04.21.18.44.38;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2010.04.19.16.25.11;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2010.04.02.15.41.27;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.211;

1.211
date	2010.01.12.10.14.59;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2009.12.18.20.32.03;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2009.11.26.10.58.06;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2009.11.17.10.43.00;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2009.10.31.13.24.05;	author corinna;	state Exp;
branches;
next	1.206;

1.206
date	2009.09.22.04.09.02;	author ericb;	state Exp;
branches;
next	1.205;

1.205
date	2009.08.20.08.34.21;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2009.08.18.15.21.47;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2009.08.10.15.38.37;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2009.08.08.20.24.54;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2009.08.05.04.44.27;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2009.07.21.13.29.00;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2009.07.06.15.11.30;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2009.07.03.18.05.50;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2009.06.30.21.18.43;	author cgf;	state Exp;
branches;
next	1.196;

1.196
date	2009.05.09.15.56.37;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2009.02.27.00.34.40;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2009.01.20.17.22.11;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2008.10.17.16.24.20;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2008.09.11.04.34.22;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2008.05.13.13.44.04;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2008.04.30.09.51.38;	author corinna;	state Exp;
branches;
next	1.189;

1.189
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.187;

1.187
date	2008.03.22.21.27.05;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2008.03.22.21.04.16;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2008.03.12.12.41.49;	author corinna;	state Exp;
branches;
next	1.184;

1.184
date	2008.03.11.13.17.52;	author corinna;	state Exp;
branches;
next	1.183;

1.183
date	2008.03.08.03.28.34;	author briand;	state Exp;
branches;
next	1.182;

1.182
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2008.02.07.18.59.40;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2007.12.16.21.21.23;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2007.12.14.11.32.40;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2007.11.08.14.37.59;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2007.11.08.14.36.49;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2007.07.07.17.00.33;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2007.05.29.17.25.36;	author corinna;	state Exp;
branches;
next	1.173;

1.173
date	2007.01.17.19.26.57;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2006.11.23.09.55.55;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2006.11.06.13.46.24;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2006.06.03.06.35.10;	author cgf;	state Exp;
branches
	1.169.4.1;
next	1.168;

1.168
date	2006.05.21.05.25.49;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2006.04.21.18.53.05;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2006.03.23.16.52.34;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2006.03.13.11.22.51;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2006.02.07.15.49.08;	author corinna;	state Exp;
branches;
next	1.163;

1.163
date	2005.12.19.04.34.13;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2005.10.23.23.47.45;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2005.09.28.19.22.20;	author corinna;	state Exp;
branches;
next	1.159;

1.159
date	2005.09.28.19.02.48;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2005.09.13.17.08.52;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2005.08.08.13.53.05;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2005.08.08.04.06.07;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2005.06.20.15.33.50;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2005.06.02.02.36.50;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2005.06.01.03.46.56;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2005.05.13.15.46.05;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2005.05.10.20.56.06;	author corinna;	state Exp;
branches;
next	1.150;

1.150
date	2005.05.09.02.39.34;	author phumblet;	state Exp;
branches;
next	1.149;

1.149
date	2005.04.05.04.30.58;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2005.02.23.12.30.31;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2005.02.20.04.25.31;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2005.02.01.16.49.11;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2004.12.23.21.37.43;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2004.11.26.04.15.07;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2004.07.23.09.04.59;	author corinna;	state Exp;
branches
	1.142.2.1;
next	1.141;

1.141
date	2004.06.07.04.26.32;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2004.04.11.04.00.01;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2004.03.21.17.41.40;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2004.01.17.05.49.42;	author cgf;	state Exp;
branches
	1.134.4.1;
next	1.133;

1.133
date	2004.01.16.21.51.30;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2004.01.03.18.15.03;	author cgf;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2003.12.30.01.57.16;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2003.12.27.17.41.17;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2003.12.12.20.46.03;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2003.12.11.06.12.41;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2003.11.25.02.03.17;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2003.11.23.17.55.37;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.19.11.19.27;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.120;

1.120
date	2003.11.14.01.37.23;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2003.10.01.12.36.39;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2003.09.30.21.03.57;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2003.09.28.09.44.13;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2003.09.26.03.26.44;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2003.07.09.01.33.06;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2003.03.02.18.37.17;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2003.02.21.14.29.17;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.109.2.1;
next	1.108;

1.108
date	2003.01.03.06.20.23;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2002.10.21.01.00.56;	author cgf;	state Exp;
branches
	1.107.12.1;
next	1.106;

1.106
date	2002.10.18.01.28.48;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2002.10.17.17.45.09;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2002.10.14.20.25.52;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2002.10.08.02.44.35;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2002.10.07.20.06.16;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2002.09.19.03.30.19;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2002.07.03.18.02.53;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2002.07.03.03.20.50;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2002.06.24.21.14.04;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2002.06.24.20.05.52;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2002.06.16.23.34.42;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2002.06.11.02.08.00;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2002.06.06.23.53.45;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2002.06.05.15.43.49;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2002.06.05.02.42.15;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2002.06.05.01.42.27;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2002.06.02.17.48.05;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2002.05.31.22.53.25;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2002.05.29.05.15.43;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2002.05.28.01.55.39;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2002.05.27.02.25.28;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2002.05.24.05.44.10;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2002.05.03.02.43.45;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2002.05.02.04.13.44;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2002.02.22.19.33.41;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2002.02.09.10.40.48;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2002.02.08.11.54.10;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2002.01.13.20.03.03;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2002.01.06.17.29.41;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2002.01.06.09.28.13;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2002.01.05.18.42.52;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2001.12.17.19.55.58;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.11.22.05.59.07;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.10.19.46.15;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.05.06.09.06;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.05.02.45.42;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2001.10.31.12.03.45;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2001.10.30.07.43.46;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2001.10.22.18.39.21;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.10.14.15.49.13;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.10.14.04.14.23;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.08.05.50.33;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.03.03.49.26;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.02.01.58.06;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.24.21.50.44;	author cgf;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2001.09.23.14.39.16;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2001.09.22.21.44.07;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.11.15.25.08;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.10.02.11.59;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.04.20.48.45;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.23.02.27.01;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.22.17.50.22;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.04.18.53.53;	author duda;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.26.00.10.52;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.21.03.20.01;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.24.22.26.50;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.16.05.07.51;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.08.15.16.48;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.04.28.23.48.27;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.20.15.50.03;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.18.21.10.11;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.16.03.27.16;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.28.03.42.58;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.20.19.50.27;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.15.06.27.48;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.26.10.13.41;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.25.14.17.27;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.17.01.46.26;	author dj;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.13.03.13.59;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.12.22.15.46;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.09.02.53.44;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.01.01.02.40;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.10.16.43.47;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.18.18.14.08;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.04.04.04.46;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.29.16.01.23;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.27.17.30.48;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.15.02.48.11;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.01.17.30.35;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.26.21.36.52;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.26.15.27.12;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.03.15.39.10;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.05.33.09;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.03.00.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.277.2.1
date	2014.07.16.09.54.55;	author corinna;	state Exp;
branches;
next	1.277.2.2;

1.277.2.2
date	2014.11.13.12.52.55;	author corinna;	state Exp;
branches;
next	;

1.264.2.1
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	1.264.2.2;

1.264.2.2
date	2012.10.23.14.29.33;	author corinna;	state Exp;
branches;
next	1.264.2.3;

1.264.2.3
date	2012.10.30.10.36.35;	author corinna;	state Exp;
branches;
next	1.264.2.4;

1.264.2.4
date	2012.10.30.17.31.02;	author corinna;	state Exp;
branches;
next	1.264.2.5;

1.264.2.5
date	2012.10.31.17.00.05;	author corinna;	state Exp;
branches;
next	1.264.2.6;

1.264.2.6
date	2012.12.10.11.45.46;	author corinna;	state Exp;
branches;
next	1.264.2.7;

1.264.2.7
date	2013.01.09.16.27.20;	author corinna;	state Exp;
branches;
next	1.264.2.8;

1.264.2.8
date	2013.01.21.13.52.04;	author corinna;	state Exp;
branches;
next	1.264.2.9;

1.264.2.9
date	2013.02.09.20.37.59;	author corinna;	state Exp;
branches;
next	;

1.169.4.1
date	2006.11.08.10.00.06;	author corinna;	state Exp;
branches;
next	1.169.4.2;

1.169.4.2
date	2007.01.15.11.56.06;	author corinna;	state Exp;
branches;
next	1.169.4.3;

1.169.4.3
date	2007.11.12.15.30.18;	author corinna;	state Exp;
branches;
next	1.169.4.4;

1.169.4.4
date	2007.12.14.11.32.50;	author corinna;	state Exp;
branches;
next	1.169.4.5;

1.169.4.5
date	2008.02.21.17.37.32;	author cgf;	state Exp;
branches;
next	1.169.4.6;

1.169.4.6
date	2008.03.04.22.30.27;	author corinna;	state Exp;
branches;
next	1.169.4.7;

1.169.4.7
date	2008.04.17.09.29.51;	author corinna;	state Exp;
branches;
next	;

1.142.2.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	;

1.134.4.1
date	2004.01.24.01.53.52;	author cgf;	state Exp;
branches;
next	;

1.131.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	1.131.2.2;

1.131.2.2
date	2004.01.13.05.13.23;	author cgf;	state Exp;
branches;
next	1.131.2.3;

1.131.2.3
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	1.131.2.4;

1.131.2.4
date	2004.01.17.05.51.36;	author cgf;	state Exp;
branches;
next	;

1.109.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.109.2.2;

1.109.2.2
date	2003.01.25.18.59.43;	author cgf;	state Exp;
branches;
next	1.109.2.3;

1.109.2.3
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.109.2.4;

1.109.2.4
date	2003.02.14.05.21.51;	author cgf;	state Exp;
branches;
next	1.109.2.5;

1.109.2.5
date	2003.03.02.18.57.51;	author cgf;	state Exp;
branches;
next	1.109.2.6;

1.109.2.6
date	2003.03.02.23.39.10;	author cgf;	state Exp;
branches;
next	1.109.2.7;

1.109.2.7
date	2003.03.19.16.23.03;	author cgf;	state Exp;
branches;
next	1.109.2.8;

1.109.2.8
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.109.2.9;

1.109.2.9
date	2003.07.10.01.06.23;	author cgf;	state Exp;
branches;
next	;

1.107.12.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.107.12.2;

1.107.12.2
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.107.12.3;

1.107.12.3
date	2002.12.29.06.14.14;	author cgf;	state Exp;
branches;
next	1.107.12.4;

1.107.12.4
date	2003.01.01.18.16.37;	author cgf;	state Exp;
branches;
next	1.107.12.5;

1.107.12.5
date	2003.01.03.06.17.23;	author cgf;	state Exp;
branches;
next	1.107.12.6;

1.107.12.6
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	1.107.12.7;

1.107.12.7
date	2003.01.05.06.48.55;	author cgf;	state Exp;
branches;
next	;

1.54.2.1
date	2001.10.02.12.09.53;	author rbcollins;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2002.01.04.03.56.06;	author rbcollins;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2002.01.15.12.52.50;	author rbcollins;	state Exp;
branches;
next	1.54.2.4;

1.54.2.4
date	2002.02.28.12.53.23;	author rbcollins;	state Exp;
branches;
next	1.54.2.5;

1.54.2.5
date	2002.06.13.14.34.02;	author rbcollins;	state Exp;
branches;
next	1.54.2.6;

1.54.2.6
date	2002.06.18.00.17.06;	author scottc;	state Exp;
branches;
next	1.54.2.7;

1.54.2.7
date	2002.06.25.10.50.38;	author scottc;	state Exp;
branches;
next	1.54.2.8;

1.54.2.8
date	2002.07.03.16.01.46;	author scottc;	state Exp;
branches;
next	1.54.2.9;

1.54.2.9
date	2002.07.04.20.09.46;	author scottc;	state Exp;
branches;
next	1.54.2.10;

1.54.2.10
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.280
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@/* dtable.cc: file descriptor support.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#define  __INSIDE_CYGWIN_NET__

#include "winsup.h"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <wchar.h>

#define USE_SYS_TYPES_FD_SET
#include <winsock.h>
#include "pinfo.h"
#include "cygerrno.h"
#include "perprocess.h"
#include "path.h"
#include "fhandler.h"
#include "select.h"
#include "dtable.h"
#include "cygheap.h"
#include "tls_pbuf.h"
#include "ntdll.h"
#include "shared_info.h"

static const DWORD std_consts[] = {STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,
				   STD_ERROR_HANDLE};

static bool handle_to_fn (HANDLE, char *);

#define WCLEN(x) ((sizeof (x) / sizeof (WCHAR)) - 1)
static const char unknown_file[] = "some disk file";
static const WCHAR DEV_NULL[] = L"\\Device\\Null";
static const WCHAR DEV_SOCKET[] = L"\\Device\\Afd";

static const WCHAR DEVICE_PREFIX[] = L"\\device\\";
static const size_t DEVICE_PREFIX_LEN WCLEN (DEVICE_PREFIX);

static const WCHAR DEV_NAMED_PIPE[] = L"\\Device\\NamedPipe\\";
static const size_t DEV_NAMED_PIPE_LEN = WCLEN (DEV_NAMED_PIPE);

static const WCHAR DEV_REMOTE[] = L"\\Device\\LanmanRedirector\\";
static const size_t DEV_REMOTE_LEN = WCLEN (DEV_REMOTE);

static const WCHAR DEV_REMOTE1[] = L"\\Device\\WinDfs\\Root\\";
static const size_t DEV_REMOTE1_LEN = WCLEN (DEV_REMOTE1);

/* Set aside space for the table of fds */
void
dtable_init ()
{
  if (!cygheap->fdtab.size)
    cygheap->fdtab.extend (NOFILE_INCR, 0);
}

void __stdcall
set_std_handle (int fd)
{
  fhandler_base *fh = cygheap->fdtab[fd];
  if (fd == 0)
    SetStdHandle (std_consts[fd], fh ? fh->get_handle () : NULL);
  else if (fd <= 2)
    SetStdHandle (std_consts[fd], fh ? fh->get_output_handle () : NULL);
}

int
dtable::extend (size_t howmuch, size_t min)
{
  size_t new_size = size + howmuch;
  fhandler_base **newfds;

  if (new_size <= OPEN_MAX_MAX)
    /* ok */;
  else if (size < OPEN_MAX_MAX && min < OPEN_MAX_MAX)
    new_size = OPEN_MAX_MAX;
  else
    {
      set_errno (EMFILE);
      return 0;
    }

  /* Try to allocate more space for fd table. We can't call realloc ()
     here to preserve old table if memory allocation fails */

  if (!(newfds = (fhandler_base **) ccalloc (HEAP_ARGV, new_size, sizeof newfds[0])))
    {
      debug_printf ("calloc failed");
      set_errno (ENOMEM);
      return 0;
    }
  if (fds)
    {
      memcpy (newfds, fds, size * sizeof (fds[0]));
      cfree (fds);
    }

  size = new_size;
  fds = newfds;
  debug_printf ("size %ld, fds %p", size, fds);
  return 1;
}

void
dtable::get_debugger_info ()
{
  extern bool jit_debug;
  if (!jit_debug && being_debugged ())
    {
      char std[3][sizeof ("/dev/ptyNNNN")];
      std[0][0] = std[1][0] = std [2][0] = '\0';
      char buf[sizeof ("cYgstd %x") + 64];
      sprintf (buf, "cYgstd %p %zx %x", &std, sizeof (std[0]), 3);
      OutputDebugString (buf);
      for (int i = 0; i < 3; i++)
	if (std[i][0])
	  {
	    HANDLE h = GetStdHandle (std_consts[i]);
	    fhandler_base *fh = build_fh_name (std[i]);
	    if (!fh)
	      continue;
	    fds[i] = fh;
	    if (!fh->open ((i ? (i == 2 ? O_RDWR : O_WRONLY) : O_RDONLY)
			   | O_BINARY, 0777))
	      release (i);
	    else
	      {
		CloseHandle (h);
		/* Copy to Windows' idea of a standard handle, otherwise
		   we have invalid standard handles when calling Windows
		   functions (small_printf and strace might suffer, too). */
		SetStdHandle (std_consts[i], i ? fh->get_output_handle ()
					       : fh->get_handle ());
	      }
	  }
    }
}

/* Initialize the file descriptor/handle mapping table.
   This function should only be called when a cygwin function is invoked
   by a non-cygwin function, i.e., it should only happen very rarely. */

void
dtable::stdio_init ()
{
  if (myself->cygstarted || ISSTATE (myself, PID_CYGPARENT))
    {
      tty_min *t = cygwin_shared->tty.get_cttyp ();
      if (t && t->is_console)
	init_console_handler (true);
      return;
    }

  HANDLE in = GetStdHandle (STD_INPUT_HANDLE);
  HANDLE out = GetStdHandle (STD_OUTPUT_HANDLE);
  HANDLE err = GetStdHandle (STD_ERROR_HANDLE);

  init_std_file_from_handle (0, in);

  /* STD_ERROR_HANDLE has been observed to be the same as
     STD_OUTPUT_HANDLE.  We need separate handles (e.g. using pipes
     to pass data from child to parent).  */
  /* CV 2008-10-17: Under debugger control, std fd's have been potentially
     initialized in dtable::get_debugger_info ().  In this case
     init_std_file_from_handle is a no-op, so, even if out == err we don't
     want to duplicate the handle since it will be unused. */
  if (out == err && (!being_debugged () || not_open (2)))
    {
      /* Since this code is not invoked for forked tasks, we don't have
	 to worry about the close-on-exec flag here.  */
      if (!DuplicateHandle (GetCurrentProcess (), out,
			    GetCurrentProcess (), &err,
			    0, TRUE, DUPLICATE_SAME_ACCESS))
	{
	  /* If that fails, do this as a fall back.  */
	  err = out;
	  system_printf ("couldn't make stderr distinct from stdout, %E");
	}
    }

  init_std_file_from_handle (1, out);
  init_std_file_from_handle (2, err);
}

const int dtable::initial_archetype_size;

fhandler_base *
dtable::find_archetype (device& dev)
{
  for (unsigned i = 0; i < farchetype; i++)
    if (archetypes[i]->get_device () == (dev_t) dev)
      return archetypes[i];
  return NULL;
}

fhandler_base **
dtable::add_archetype ()
{
  if (farchetype++ >= narchetypes)
    archetypes = (fhandler_base **) crealloc_abort (archetypes, (narchetypes += initial_archetype_size) * sizeof archetypes[0]);
  return archetypes + farchetype - 1;
}

void
dtable::delete_archetype (fhandler_base *fh)
{
  for (unsigned i = 0; i < farchetype; i++)
    if (fh == archetypes[i])
      {
	debug_printf ("deleting element %d for %s(%d/%d)", i, fh->get_name (),
		      fh->dev ().get_major (), fh->dev ().get_minor ());
	if (i < --farchetype)
	  archetypes[i] = archetypes[farchetype];
	break;
      }

  delete fh;
}

int
dtable::find_unused_handle (size_t start)
{
  /* When extending, try to allocate a NOFILE_INCR chunk
     following the empty fd.  */
  size_t extendby = NOFILE_INCR + ((start >= size) ? 1 + start - size : 0);

  /* This do loop should only ever execute twice. */
  int res = -1;
  do
    {
      for (size_t i = start; i < size; i++)
	if (fds[i] == NULL)
	  {
	    res = (int) i;
	    goto out;
	  }
    }
  while (extend (extendby, start));
out:
  return res;
}

void
dtable::release (int fd)
{
  if (fds[fd]->need_fixup_before ())
    dec_need_fixup_before ();
  fds[fd]->dec_refcnt ();
  fds[fd] = NULL;
  if (fd <= 2)
    set_std_handle (fd);
}

extern "C" int
cygwin_attach_handle_to_fd (char *name, int fd, HANDLE handle, mode_t bin,
			    DWORD myaccess)
{
  cygheap->fdtab.lock ();
  if (fd == -1)
    fd = cygheap->fdtab.find_unused_handle ();
  fhandler_base *fh = build_fh_name (name);
  if (!fh)
    fd = -1;
  else
    {
      cygheap->fdtab[fd] = fh;
      cygheap->fdtab[fd]->inc_refcnt ();
      fh->init (handle, myaccess, bin ?: fh->pc_binmode ());
    }
  cygheap->fdtab.unlock ();
  return fd;
}

void
dtable::init_std_file_from_handle (int fd, HANDLE handle)
{
  tmp_pathbuf tp;
  CONSOLE_SCREEN_BUFFER_INFO buf;
  DCB dcb;
  unsigned bin = O_BINARY;
  device dev = {};

  first_fd_for_open = 0;

  if (!not_open (fd))
    return;

  SetLastError (0);
  DWORD access = 0;
  DWORD ft = GetFileType (handle);
  char *name = tp.c_get ();
  name[0] = '\0';
  if (ft == FILE_TYPE_UNKNOWN && GetLastError () == ERROR_INVALID_HANDLE)
    /* can't figure out what this is */;
  else if (ft == FILE_TYPE_PIPE)
    {
      int rcv = 0, len = sizeof (int);

      if (handle_to_fn (handle, name))
	dev.parse (name);
      else if (strcmp (name, ":sock:") == 0
	       /* NtQueryObject returns an error when called on an LSP socket
		  handle.  While fdsock now tries to fetch the underlying
		  base socket, this only works on Vista and later. */
	       || (strcmp (name, unknown_file) == 0
		   && !::getsockopt ((SOCKET) handle, SOL_SOCKET, SO_RCVBUF,
				     (char *) &rcv, &len)))
	{
	  /* socket */
	  dev = *tcp_dev;
	  name[0] = '\0';
	}
      else if (fd == 0)
	dev = *piper_dev;
      else
	dev = *pipew_dev;
    }
  else if (GetConsoleScreenBufferInfo (handle, &buf)
	   || GetNumberOfConsoleInputEvents (handle, (DWORD *) &buf))
    {
      /* Console I/O */
      if (myself->ctty > 0)
	dev.parse (myself->ctty);
      else
	{
	  dev.parse (FH_CONSOLE);
	  CloseHandle (handle);
	  handle = INVALID_HANDLE_VALUE;
	}
    }
  else if (GetCommState (handle, &dcb))
    /* FIXME: Not right - assumes ttyS0 */
    dev.parse (DEV_SERIAL_MAJOR, 0);
  else
    /* Try to figure it out from context - probably a disk file */
    handle_to_fn (handle, name);

  if (!name[0] && !dev)
    fds[fd] = NULL;
  else
    {
      fhandler_base *fh;

      if (dev)
	fh = build_fh_dev (dev);
      else
	fh = build_fh_name (name);

      if (!fh)
	return;

      if (name[0])
	{
	  bin = fh->pc_binmode ();
	  if (!bin)
	    {
	      bin = fh->get_default_fmode (O_RDWR);
	      if (!bin && dev)
		bin = O_BINARY;
	    }
	}

      IO_STATUS_BLOCK io;
      FILE_ACCESS_INFORMATION fai;
      int openflags = O_BINARY;

      /* Console windows are no kernel objects up to Windows 7/2008R2, so the
      	 access mask returned by NtQueryInformationFile is meaningless.  CMD
	 always hands down stdin handles as R/O handles, but our tty slave
	 sides are R/W. */
      if (fh->is_tty ())
	{
	  openflags |= O_RDWR;
	  access |= GENERIC_READ | GENERIC_WRITE;
	}
      else if (!iscons_dev (dev)
	       && NT_SUCCESS (NtQueryInformationFile (handle, &io, &fai,
						      sizeof fai,
						      FileAccessInformation)))
	{
	  if (fai.AccessFlags & FILE_WRITE_DATA)
	    {
	      openflags |= O_WRONLY;
	      access |= GENERIC_WRITE;
	    }
	  if (fai.AccessFlags & FILE_READ_DATA)
	    {
	      openflags |= openflags & O_WRONLY ? O_RDWR : O_RDONLY;
	      access |= GENERIC_READ;
	    }
	}
      else if (fd == 0)
	{
	  openflags |= O_RDONLY;
	  access |= GENERIC_READ;
	}
      else
	{
	  openflags |= O_WRONLY;
	  access |= GENERIC_WRITE;  /* Should be rdwr for stderr but not sure that's
				       possible for some versions of handles */
	}
      if (!fh->init (handle, access, bin))
	api_fatal ("couldn't initialize fd %d for %s", fd, fh->get_name ());

      fh->open_setup (openflags);
      fh->usecount = 0;
      cygheap->fdtab[fd] = fh;
      cygheap->fdtab[fd]->inc_refcnt ();
      set_std_handle (fd);
      paranoid_printf ("fd %d, handle %p", fd, handle);
    }
}

#define cnew(name, ...) \
  ({ \
    void* ptr = (void*) ccalloc (HEAP_FHANDLER, 1, sizeof (name)); \
    ptr ? new (ptr) name (__VA_ARGS__) : NULL; \
  })

#define cnew_no_ctor(name, ...) \
  ({ \
    void* ptr = (void*) ccalloc (HEAP_FHANDLER, 1, sizeof (name)); \
    ptr ? new (ptr) name (ptr) : NULL; \
  })

fhandler_base *
build_fh_name (const char *name, unsigned opt, suffix_info *si)
{
  path_conv pc (name, opt | PC_NULLEMPTY | PC_POSIX, si);
  if (pc.error)
    {
      fhandler_base *fh = cnew (fhandler_nodevice);
      if (fh)
	fh->set_error (pc.error);
      set_errno (fh ? pc.error : EMFILE);
      return fh;
    }

  return build_fh_pc (pc);
}

fhandler_base *
build_fh_dev (const device& dev, const char *unix_name)
{
  path_conv pc (dev);
  if (unix_name)
    pc.set_posix (unix_name);
  else
    pc.set_posix (dev.name);
  return build_fh_pc (pc);
}

#define fh_unset ((fhandler_base *) 1)
static device last_tty_dev;
#define fh_last_tty_dev ((fhandler_termios *) cygheap->fdtab.find_archetype (last_tty_dev))

static fhandler_base *
fh_alloc (path_conv& pc)
{
  fhandler_base *fh = fh_unset;
  fhandler_base *fhraw = NULL;

  switch (pc.dev.get_major ())
    {
    case DEV_PTYS_MAJOR:
      fh = cnew (fhandler_pty_slave, pc.dev.get_minor ());
      break;
    case DEV_PTYM_MAJOR:
      fh = cnew (fhandler_pty_master, pc.dev.get_minor ());
      break;
    case DEV_FLOPPY_MAJOR:
    case DEV_CDROM_MAJOR:
    case DEV_SD_MAJOR:
    case DEV_SD1_MAJOR:
    case DEV_SD2_MAJOR:
    case DEV_SD3_MAJOR:
    case DEV_SD4_MAJOR:
    case DEV_SD5_MAJOR:
    case DEV_SD6_MAJOR:
    case DEV_SD7_MAJOR:
      fh = cnew (fhandler_dev_floppy);
      break;
    case DEV_TAPE_MAJOR:
      fh = cnew (fhandler_dev_tape);
      break;
    case DEV_SERIAL_MAJOR:
      fh = cnew (fhandler_serial);
      break;
    case DEV_CONS_MAJOR:
      fh = cnew (fhandler_console, pc.dev);
      break;
    default:
      switch ((dev_t) pc.dev)
	{
	case FH_CONSOLE:
	case FH_CONIN:
	case FH_CONOUT:
	  fh = cnew (fhandler_console, pc.dev);
	  break;
	case FH_PTMX:
	  if (pc.isopen ())
	    fh = cnew (fhandler_pty_master, -1);
	  else
	    fhraw = cnew_no_ctor (fhandler_pty_master, -1);
	  break;
	case FH_WINDOWS:
	  fh = cnew (fhandler_windows);
	  break;
	case FH_FIFO:
	  fh = cnew (fhandler_fifo);
	  break;
	case FH_PIPE:
	case FH_PIPER:
	case FH_PIPEW:
	  fh = cnew (fhandler_pipe);
	  break;
	case FH_TCP:
	case FH_UDP:
	case FH_ICMP:
	case FH_UNIX:
	case FH_STREAM:
	case FH_DGRAM:
	  fh = cnew (fhandler_socket);
	  break;
	case FH_FS:
	  fh = cnew (fhandler_disk_file);
	  break;
	case FH_NULL:
	  fh = cnew (fhandler_dev_null);
	  break;
	case FH_ZERO:
	case FH_FULL:
	  fh = cnew (fhandler_dev_zero);
	  break;
	case FH_RANDOM:
	case FH_URANDOM:
	  fh = cnew (fhandler_dev_random);
	  break;
	case FH_CLIPBOARD:
	  fh = cnew (fhandler_dev_clipboard);
	  break;
	case FH_OSS_DSP:
	  fh = cnew (fhandler_dev_dsp);
	  break;
	case FH_PROC:
	  fh = cnew (fhandler_proc);
	  break;
	case FH_REGISTRY:
	  fh = cnew (fhandler_registry);
	  break;
	case FH_PROCESS:
	case FH_PROCESSFD:
	  fh = cnew (fhandler_process);
	  break;
	case FH_PROCNET:
	  fh = cnew (fhandler_procnet);
	  break;
	case FH_PROCSYS:
	  fh = cnew (fhandler_procsys);
	  break;
	case FH_PROCSYSVIPC:
	  fh = cnew (fhandler_procsysvipc);
	  break;
	case FH_NETDRIVE:
	  fh = cnew (fhandler_netdrive);
	  break;
	case FH_DEV:
	  fh = cnew (fhandler_dev);
	  break;
	case FH_CYGDRIVE:
	  fh = cnew (fhandler_cygdrive);
	  break;
	case FH_TTY:
	  if (!pc.isopen ())
	    {
	      fhraw = cnew_no_ctor (fhandler_console, -1);
	      debug_printf ("not called from open for /dev/tty");
	    }
	  else if (myself->ctty <= 0 && last_tty_dev
		   && !myself->set_ctty (fh_last_tty_dev, 0))
	    debug_printf ("no /dev/tty assigned");
	  else if (myself->ctty > 0)
	    {
	      debug_printf ("determining /dev/tty assignment for ctty %p", myself->ctty);
	      if (iscons_dev (myself->ctty))
		fh = cnew (fhandler_console, pc.dev);
	      else
		fh = cnew (fhandler_pty_slave, myself->ctty);
	      if (fh->dev () != FH_NADA)
		fh->set_name ("/dev/tty");
	    }
	  break;
	case FH_KMSG:
	  fh = cnew (fhandler_mailslot);
	  break;
      }
    }

  /* If `fhraw' is set that means that this fhandler is just a dummy
     set up for stat().  Mock it up for use by stat without actually
     trying to do any real initialization.  */
  if (fhraw)
    {
      fh = fhraw;
      fh->set_name (pc);
      if (fh->use_archetype ())
	fh->archetype = fh;
    }
  if (fh == fh_unset)
    fh = cnew (fhandler_nodevice);
  else if (fh->dev () == FH_ERROR)
    {
      if (!pc.isopen () && pc.dev.isfs ())
	fh->dev () = pc.dev;	/* Special case: This file actually exists on
				   disk and we're not trying to open it so just
				   return the info from pc.  */
      else
	{
	  delete fh;
	  fh = NULL;
	}
    }
  return fh;
}

fhandler_base *
build_fh_pc (path_conv& pc)
{
  fhandler_base *fh = fh_alloc (pc);

  if (!fh)
    {
      set_errno (ENXIO);
      goto out;
    }

  if (!fh->use_archetype ())
    fh->set_name (pc);
  else if ((fh->archetype = cygheap->fdtab.find_archetype (fh->dev ())))
    {
      debug_printf ("found an archetype for %s(%d/%d) io_handle %p", fh->get_name (), fh->dev ().get_major (), fh->dev ().get_minor (),
		    fh->archetype->get_io_handle ());
      if (!fh->get_name ())
	fh->set_name (fh->archetype->dev ().name);
    }
  else if (cygwin_finished_initializing && !pc.isopen ())
    fh->set_name (pc);
  else
    {
      if (!fh->get_name ())
	fh->set_name (fh->dev ().native);
      fh->archetype = fh->clone ();
      debug_printf ("created an archetype (%p) for %s(%d/%d)", fh->archetype, fh->get_name (), fh->dev ().get_major (), fh->dev ().get_minor ());
      fh->archetype->archetype = NULL;
      *cygheap->fdtab.add_archetype () = fh->archetype;
    }


  /* Keep track of the last tty-like thing opened.  We could potentially want
     to open it if /dev/tty is referenced. */
  if (myself->ctty > 0 || !fh->is_tty () || !pc.isctty_capable ())
    last_tty_dev = FH_NADA;
  else
    last_tty_dev = fh->dev ();

out:
  debug_printf ("fh %p, dev %08x", fh, fh ? (dev_t) fh->dev () : 0);
  return fh;
}

fhandler_base *
dtable::dup_worker (fhandler_base *oldfh, int flags)
{
  /* Don't call set_name in build_fh_pc.  It will be called in
     fhandler_base::operator= below.  Calling it twice will result
     in double allocation. */
  fhandler_base *newfh = oldfh->clone ();
  if (!newfh)
    debug_printf ("build_fh_pc failed");
  else
    {
      if (!oldfh->archetype)
	newfh->set_io_handle (NULL);

      newfh->pc.reset_conv_handle ();
      if (oldfh->dup (newfh, flags))
	{
	  delete newfh;
	  newfh = NULL;
	  debug_printf ("oldfh->dup failed");
	}
      else
	{
	  /* Don't increment refcnt here since we don't know if this is a
	     allocated fd.  So we leave this chore to the caller. */

	  newfh->usecount = 0;
	  newfh->archetype_usecount (1);

	  /* The O_CLOEXEC flag enforces close-on-exec behaviour. */
	  newfh->set_close_on_exec (!!(flags & O_CLOEXEC));
	  debug_printf ("duped '%s' old %p, new %p", oldfh->get_name (),
			oldfh->get_io_handle (), newfh->get_io_handle ());
	}
    }
  return newfh;
}

int
dtable::dup3 (int oldfd, int newfd, int flags)
{
  int res = -1;
  fhandler_base *newfh = NULL;	// = NULL to avoid an incorrect warning

  MALLOC_CHECK;
  debug_printf ("dup3 (%d, %d, %y)", oldfd, newfd, flags);
  lock ();
  bool do_unlock = true;
  bool unlock_on_return;
  if (!(flags & O_EXCL))
    unlock_on_return = true;	/* Relinquish lock on return */
  else
    {
      flags &= ~O_EXCL;
      unlock_on_return = false;	/* Return with lock set on success */
    }

  if (not_open (oldfd))
    {
      syscall_printf ("fd %d not open", oldfd);
      set_errno (EBADF);
      goto done;
    }
  if (newfd >= OPEN_MAX_MAX || newfd < 0)
    {
      syscall_printf ("new fd out of bounds: %d", newfd);
      set_errno (EBADF);
      goto done;
    }
  if ((flags & ~O_CLOEXEC) != 0)
    {
      syscall_printf ("invalid flags value %y", flags);
      set_errno (EINVAL);
      return -1;
    }

  /* This is a temporary kludge until all utilities can catch up with
     a change in behavior that implements linux functionality:  opening
     a tty should not automatically cause it to become the controlling
     tty for the process.  */
  if (newfd > 2)
    flags |= O_NOCTTY;

  if ((newfh = dup_worker (fds[oldfd], flags)) == NULL)
    {
      res = -1;
      goto done;
    }

  debug_printf ("newfh->io_handle %p, oldfh->io_handle %p, new win32_name %p, old win32_name %p",
		newfh->get_io_handle (), fds[oldfd]->get_io_handle (), newfh->get_win32_name (), fds[oldfd]->get_win32_name ());

  if (!not_open (newfd))
    close (newfd);
  else if ((size_t) newfd >= size
	   && find_unused_handle (newfd) < 0)
    /* couldn't extend fdtab */
    {
      newfh->close ();
      res = -1;
      goto done;
    }

  fds[newfd] = newfh;

  if ((res = newfd) <= 2)
    set_std_handle (res);
  do_unlock = unlock_on_return;

done:
  MALLOC_CHECK;
  if (do_unlock)
    unlock ();
  syscall_printf ("%R = dup3(%d, %d, %y)", res, oldfd, newfd, flags);

  return res;
}

bool
dtable::select_read (int fd, select_stuff *ss)
{
  if (not_open (fd))
    {
      set_errno (EBADF);
      return false;
    }
  fhandler_base *fh = fds[fd];
  select_record *s = fh->select_read (ss);
  s->fd = fd;
  if (!s->fh)
    s->fh = fh;
  s->thread_errno = 0;
  debug_printf ("%s fd %d", fh->get_name (), fd);
  return true;
}

bool
dtable::select_write (int fd, select_stuff *ss)
{
  if (not_open (fd))
    {
      set_errno (EBADF);
      return NULL;
    }
  fhandler_base *fh = fds[fd];
  select_record *s = fh->select_write (ss);
  s->fd = fd;
  s->fh = fh;
  s->thread_errno = 0;
  debug_printf ("%s fd %d", fh->get_name (), fd);
  return true;
}

bool
dtable::select_except (int fd, select_stuff *ss)
{
  if (not_open (fd))
    {
      set_errno (EBADF);
      return NULL;
    }
  fhandler_base *fh = fds[fd];
  select_record *s = fh->select_except (ss);
  s->fd = fd;
  s->fh = fh;
  s->thread_errno = 0;
  debug_printf ("%s fd %d", fh->get_name (), fd);
  return true;
}

void
dtable::move_fd (int from, int to)
{
  // close (to); /* It is assumed that this is close-on-exec */
  fds[to] = fds[from];
  fds[from] = NULL;
}

void
dtable::set_file_pointers_for_exec ()
{
/* This is not POSIX-compliant so the function is only called for
   non-Cygwin processes. */
  LONG off_high = 0;
  lock ();
  fhandler_base *fh;
  for (size_t i = 0; i < size; i++)
    if ((fh = fds[i]) != NULL && fh->get_flags () & O_APPEND)
      SetFilePointer (fh->get_handle (), 0, &off_high, FILE_END);
  unlock ();
}

void
dtable::fixup_close (size_t i, fhandler_base *fh)
{
  if (fh->archetype)
    {
      debug_printf ("closing fd %d since it is an archetype", i);
      fh->close_with_arch ();
    }
  release (i);
}

void
dtable::fixup_after_exec ()
{
  first_fd_for_open = 0;
  fhandler_base *fh;
  for (size_t i = 0; i < size; i++)
    if ((fh = fds[i]) != NULL)
      {
	fh->clear_readahead ();
	fh->fixup_after_exec ();
	/* Close the handle if it's close-on-exec or if an error was detected
	   (typically with opening a console in a gui app) by fixup_after_exec.
	 */
	if (fh->close_on_exec () || (!fh->nohandle () && !fh->get_io_handle ()))
	  fixup_close (i, fh);
	else if (fh->get_popen_pid ())
	  close (i);
	else if (i == 0)
	  SetStdHandle (std_consts[i], fh->get_io_handle ());
	else if (i <= 2)
	  SetStdHandle (std_consts[i], fh->get_output_handle ());
      }
}

void
dtable::fixup_after_fork (HANDLE parent)
{
  fhandler_base *fh;
  for (size_t i = 0; i < size; i++)
    if ((fh = fds[i]) != NULL)
      {
	if (fh->close_on_exec () || fh->need_fork_fixup ())
	  {
	    debug_printf ("fd %d (%s)", i, fh->get_name ());
	    fh->fixup_after_fork (parent);
	    if (!fh->nohandle () && !fh->get_io_handle ())
	      {
		/* This should actually never happen but it's here to make sure
		   we don't crash due to access of an unopened file handle.  */
		fixup_close (i, fh);
		continue;
	      }
	  }
	if (i == 0)
	  SetStdHandle (std_consts[i], fh->get_io_handle ());
	else if (i <= 2)
	  SetStdHandle (std_consts[i], fh->get_output_handle ());
      }
}

static void
decode_tty (char *buf, WCHAR *w32)
{
  int ttyn = wcstol (w32, NULL, 10);
  __ptsname (buf, ttyn);
}

/* Try to derive posix filename from given handle.  Return true if
   the handle is associated with a cygwin tty. */
static bool
handle_to_fn (HANDLE h, char *posix_fn)
{
  tmp_pathbuf tp;
  ULONG len = 0;
  WCHAR *maxmatchdos = NULL;
  PWCHAR device = tp.w_get ();
  int maxmatchlen = 0;
  OBJECT_NAME_INFORMATION *ntfn = (OBJECT_NAME_INFORMATION *) tp.w_get ();

  NTSTATUS status = NtQueryObject (h, ObjectNameInformation, ntfn, 65536, &len);
  if (!NT_SUCCESS (status))
    debug_printf ("NtQueryObject failed, %y", status);
  // NT seems to do this on an unopened file
  else if (!ntfn->Name.Buffer)
    debug_printf ("nt->Name.Buffer == NULL");
  else
    {
      WCHAR *w32 = ntfn->Name.Buffer;
      size_t w32len = ntfn->Name.Length / sizeof (WCHAR);
      w32[w32len] = L'\0';

      if (wcscasecmp (w32, DEV_NULL) == 0)
	{
	  strcpy (posix_fn, "/dev/null");
	  return false;
	}

      if (wcscasecmp (w32, DEV_SOCKET) == 0)
	{
	  strcpy (posix_fn, ":sock:");
	  return false;
	}

      if (wcsncasecmp (w32, DEV_NAMED_PIPE, DEV_NAMED_PIPE_LEN) == 0)
	{
	  w32 += DEV_NAMED_PIPE_LEN;
	  if (wcsncmp (w32, L"cygwin-", WCLEN (L"cygwin-")) != 0)
	    return false;
	  w32 += WCLEN (L"cygwin-");
	  /* Check for installation key and trailing dash. */
	  w32len = cygheap->installation_key.Length / sizeof (WCHAR);
	  if (w32len
	      && wcsncmp (w32, cygheap->installation_key.Buffer, w32len) != 0)
	    return false;
	  w32 += w32len;
	  if (*w32 != L'-')
	    return false;
	  ++w32;
	  bool istty = wcsncmp (w32, L"pty", WCLEN (L"pty")) == 0;
	  if (istty)
	    decode_tty (posix_fn, w32 + WCLEN (L"pty"));
	  else if (wcsncmp (w32, L"pipe", WCLEN (L"pipe")) == 0)
	    strcpy (posix_fn, "/dev/pipe");
	  return istty;
	}

      WCHAR fnbuf[64 * 1024];
      if (wcsncasecmp (w32, DEVICE_PREFIX, DEVICE_PREFIX_LEN) != 0
	  || !QueryDosDeviceW (NULL, fnbuf, sizeof (fnbuf) / sizeof (WCHAR)))
	{
	  sys_wcstombs (posix_fn, NT_MAX_PATH, w32, w32len);
	  return false;
	}

      for (WCHAR *s = fnbuf; *s; s = wcschr (s, '\0') + 1)
	{
	  if (!QueryDosDeviceW (s, device, NT_MAX_PATH))
	    continue;
	  if (wcschr (s, ':') == NULL)
	    continue;
	  WCHAR *q = wcsrchr (device, ';');
	  if (q)
	    {
	      WCHAR *r = wcschr (q, '\\');
	      if (r)
		wcscpy (q, r + 1);
	    }
	  int devlen = wcslen (device);
	  if (device[devlen - 1] == L'\\')
	    device[--devlen] = L'\0';
	  if (devlen < maxmatchlen)
	    continue;
	  if (wcsncmp (device, w32, devlen) != 0||
	      (w32[devlen] != L'\0' && w32[devlen] != L'\\'))
	    continue;
	  maxmatchlen = devlen;
	  maxmatchdos = s;
	  debug_printf ("current match '%W' = '%W'\n", s, device);
	}

      if (maxmatchlen)
	{
	  WCHAR *p = wcschr (w32 + DEVICE_PREFIX_LEN, L'\\');
	  size_t n = wcslen (maxmatchdos);
	  WCHAR ch;
	  if (!p)
	    ch = L'\0';
	  else
	    {
	      if (maxmatchdos[n - 1] == L'\\')
		n--;
	      w32 += maxmatchlen - n;
	      ch = L'\\';
	    }
	  memcpy (w32, maxmatchdos, n * sizeof (WCHAR));
	  w32[n] = ch;
	}
      else if (wcsncmp (w32, DEV_REMOTE, DEV_REMOTE_LEN) == 0)
	{
	  w32 += DEV_REMOTE_LEN - 2;
	  *w32 = L'\\';
	  debug_printf ("remote drive");
	}
      else if (wcsncmp (w32, DEV_REMOTE1, DEV_REMOTE1_LEN) == 0)
	{
	  w32 += DEV_REMOTE1_LEN - 2;
	  *w32 = L'\\';
	  debug_printf ("remote drive");
	}

      cygwin_conv_path (CCP_WIN_W_TO_POSIX | CCP_ABSOLUTE, w32, posix_fn,
			NT_MAX_PATH);

      debug_printf ("derived path '%W', posix '%s'", w32, posix_fn);
      return false;
    }

  strcpy (posix_fn,  unknown_file);
  return false;
}

void
dtable::fixup_before_fork (DWORD target_proc_id)
{
  lock ();
  fhandler_base *fh;
  for (size_t i = 0; i < size; i++)
    if ((fh = fds[i]) != NULL)
      {
	debug_printf ("fd %d (%s)", i, fh->get_name ());
	fh->fixup_before_fork_exec (target_proc_id);
      }
  unlock ();
}

void
dtable::fixup_before_exec (DWORD target_proc_id)
{
  lock ();
  fhandler_base *fh;
  for (size_t i = 0; i < size; i++)
    if ((fh = fds[i]) != NULL && !fh->close_on_exec ())
      {
	debug_printf ("fd %d (%s)", i, fh->get_name ());
	fh->fixup_before_fork_exec (target_proc_id);
      }
  unlock ();
}
@


1.279
log
@	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::recv_internal): Explicitely check if the socket is
	connected if it's a stream socket.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d455 1
a455 1
    pc.set_normalized_path (unix_name);
d457 1
a457 1
    pc.set_normalized_path (dev.name);
@


1.278
log
@	* dtable.cc (handle_to_fn): Fix length parameter in call to
	QueryDosDeviceW (CID 59936).
@
text
@d374 4
a377 3
      /* Console windows are not kernel objects, so the access mask returned
	 by NtQueryInformationFile is meaningless.  CMD always hands down
	 stdin handles as R/O handles, but our tty slave sides are R/W. */
@


1.277
log
@* cygheap.h (cygheap_fdnew): Avoid setting errno directly since it will have
been set by a previous function.
* dtable.h (dtable::extend): Accept second size_t argument.
* dtable.cc (dtable::extend): Accept second "min" argument which allows
checking for OPEN_MAX_MAX boundary conditions.
(dtable_init): Accommodate second argument to dtable::extend.
(dtable::find_unused_handle): Ditto.
* syscalls.cc (setdtablesize): Ditto.
(dup): Return any error passed by cygheap_fdnew() directly.
(getdtablesize): Just return dtable size directly.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d999 1
a999 1
	  || !QueryDosDeviceW (NULL, fnbuf, sizeof (fnbuf)))
@


1.277.2.1
log
@Add more missing patches
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d999 1
a999 1
	  || !QueryDosDeviceW (NULL, fnbuf, sizeof (fnbuf) / sizeof (WCHAR)))
@


1.277.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d374 3
a376 4
      /* Console windows are no kernel objects up to Windows 7/2008R2, so the
      	 access mask returned by NtQueryInformationFile is meaningless.  CMD
	 always hands down stdin handles as R/O handles, but our tty slave
	 sides are R/W. */
@


1.276
log
@* dtable.cc (dtable::find_unused_handle): When extending, always make sure that
there is a NOFILE_INCR chunk following the free fd.
@
text
@d61 1
a61 1
    cygheap->fdtab.extend (NOFILE_INCR);
d75 1
a75 1
dtable::extend (size_t howmuch)
d80 5
a84 1
  if (new_size > OPEN_MAX_MAX)
d230 1
a230 1
  /* When extending, always make sure that there is a NOFILE_INCR chunk
d245 1
a245 1
  while (extend (extendby));
@


1.275
log
@* dtable.cc (dtable::find_unused_handle): Break out of the right loop.
@
text
@d226 3
a228 1
  size_t extendby = (start >= size) ? 1 + start - size : NOFILE_INCR;
@


1.274
log
@* dtable.cc (dtable::find_unused_handle): Fix off-by-one error.  Always exit
through the bottom.
(cygwin_attach_handle_to_fd): Make sure that fd tab is locked for the duration
of this function.
* dtable.h (dtable::lock): Make public.
(dtable::unlock): Ditto.
(dtable): Remove friends.
@
text
@a232 1
	/* See if open -- no need for overhead of not_open */
d236 1
a236 1
	    break;
d240 1
@


1.273
log
@	* dtable.cc (dtable::extend): Change local variable new_size to size_t
	as well.

	* thread.cc: Fix comment.
@
text
@d226 2
a227 1
  size_t extendby = (start > size) ? start - size : NOFILE_INCR;
d229 1
d235 4
a238 1
	  return i;
d241 1
a241 1
  return -1;
d259 1
d264 8
a271 4
    return -1;
  cygheap->fdtab[fd] = fh;
  cygheap->fdtab[fd]->inc_refcnt ();
  fh->init (handle, myaccess, bin ?: fh->pc_binmode ());
@


1.272
log
@* dtable.h (dtable::first_fd_for_open): Change declaration to size_t.
(dtable::extend): Change parameter to size_t.
(dtable::find_unused_handle): Ditto.
* dtable.cc: Remove now-unused header.
(dtable::extend): Remove pointless test.  Change parameter to size_t.
(dtable::find_unused_handle): Rework to avoid MAX calculation in extend() call.
Change parameter to size_t.
@
text
@d77 1
a77 1
  int new_size = size + howmuch;
@


1.271
log
@* dtable.cc (build_fh_pc): When creating an archetype, use native name rather
than unix name if name doesn't exist.
@
text
@a18 1
#include <sys/param.h>
d75 1
a75 1
dtable::extend (int howmuch)
a79 3
  if (howmuch <= 0)
    return 0;

d224 1
a224 1
dtable::find_unused_handle (int start)
d226 2
d235 1
a235 1
  while (extend (MAX (NOFILE_INCR, start - size)));
@


1.270
log
@	* dtable.cc: Include sys/param.h for MAX definition.
@
text
@d644 1
a644 1
	fh->set_name (fh->dev ().name);
@


1.269
log
@dup2: fix off-by-one crash

* dtable.cc (dup3): Fix off-by-one.
(find_unused_handle): Reduce time spent expanding during dup.
* syscalls.cc (setdtablesize): Report error on invalid value.
@
text
@d19 1
@


1.268
log
@	Remove /dev/mem, /dev/kmem, /dev/port support.
	* Makefile.in (DLL_OFILES): Drop fhandler_mem.o.
	(fhandler_mem_CFLAGS): Remove rule.
	* devices.in (enum fh_devices): Remove FH_MEM, FH_KMEM and FH_PORT.
	* devices.cc: Regenerate.
	* dtable.cc (fh_alloc): Drop handling for FH_MEM, FH_KMEM and FH_PORT.
	* fhandler.h (class fhandler_dev_mem): Remove.
	* fhandler_mem.cc: Remove file.
	* globals.cc (ro_u_pmem): Remove.
	* mmap.cc (fhandler_dev_mem::mmap): Remove.
	(fhandler_dev_mem::munmap): Remove.
	(fhandler_dev_mem::fixup_mmap_after_fork): Remove.
@
text
@d236 1
a236 1
  while (extend (NOFILE_INCR));
d757 1
a757 1
  else if ((size_t) newfd > size
@


1.267
log
@	* Merge in cygwin-64bit-branch.
@
text
@a530 5
	case FH_MEM:
	case FH_KMEM:
	case FH_PORT:
	  fh = cnew (fhandler_dev_mem);
	  break;
@


1.266
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d34 2
a35 2
static const NO_COPY DWORD std_consts[] = {STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,
					   STD_ERROR_HANDLE};
d106 1
a106 1
  debug_printf ("size %d, fds %p", size, fds);
d118 2
a119 2
      char buf[sizeof ("cYgstd %x") + 32];
      sprintf (buf, "cYgstd %x %x %x", (unsigned) &std, sizeof (std[0]), 3);
d197 1
a197 1
    if (archetypes[i]->get_device () == (DWORD) dev)
d485 1
a485 1
      switch ((DWORD) pc.dev)
d664 1
a664 1
  debug_printf ("fh %p, dev %p", fh, fh ? (DWORD) fh->dev () : 0);
d713 1
a713 1
  debug_printf ("dup3 (%d, %d, %p)", oldfd, newfd, flags);
d739 1
a739 1
      syscall_printf ("invalid flags value %x", flags);
d781 1
a781 1
  syscall_printf ("%R = dup3(%d, %d, %p)", res, oldfd, newfd, flags);
d942 1
a942 1
    debug_printf ("NtQueryObject failed, %p", status);
@


1.265
log
@* dtable.cc (dtable::dup3): Fix bounds checking for valid newfd.
* syscalls.cc (dup2): Ditto.
* winsup.h (events_terminate): Delete obsolete function declaration.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.264
log
@	In terms of network related functionality, rely on Winsock definitions
	as much as possible:
	* dtable.cc: Drop including sys/socket.h.
	* fhandler_procnet.cc: Change includes accordingly.
	* fhandler_socket.cc: Ditto.
	(fhandler_socket::listen): Avoid gcc error message initializing sin6.
	(LPFN_WSARECVMSG): Only define when building against w32api headers.
	* net.cc: Change includes accordingly.  Define USE_SYS_TYPES_FD_SET
	and __WSA_ERR_MACROS_DEFINED.  Define _INC_NETIOAPI temporarily and
	explain why.
	(struct _IP_ADAPTER_UNICAST_ADDRESS_LH): Only define when building
	against w32api headers.
	(struct _IP_ADAPTER_ADDRESSES_LH): Ditto.
	(SIO_GET_INTERFACE_LIST): Ditto.
	(ws_freeaddrinfo): Rename from freeaddrinfo so as not to collide with
	Winsock declaration.  Change througout.
	(ws_getaddrinfo): Ditto.
	(ws_getnameinfo): Ditto.
	* select.cc: Include netdb.h after defining USE_SYS_TYPES_FD_SET.
	* syslog.cc: Drop including netinet/in.h.  Define USE_SYS_TYPES_FD_SET
	and include ws2tcpip.h.
	* include/netdb.h (struct addrinfo): Don't define when building Cygwin.
	* include/cygwin/if.h: Don't declare if_xxx functions when building
	Cygwin.
	* include/cygwin/in.h: Disable most definitions when building Cygwin.
	* include/cygwin/socket.h: Disable sockaddr and sockaddr_storage
	definitions when building Cygwin.  Same for MCAST_INCLUDE/MCAST_EXCLUDE.
	* libc/inet_addr.c: Don't define __INSIDE_CYGWIN__ nor
	__INSIDE_CYGWIN_NET__.
	* libc/inet_network.c: Ditto.
	* libc/minires.h: Drop redundant inclusion of netdb.h.  Define
	__INSIDE_CYGWIN_NET__ only before including netdb.h and resolver
	headers.
@
text
@d731 1
a731 1
  if (newfd < 0)
@


1.264.2.1
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d197 1
a197 1
    if (archetypes[i]->get_device () == (dev_t) dev)
d485 1
a485 1
      switch ((dev_t) pc.dev)
d664 1
a664 1
  debug_printf ("fh %p, dev %p", fh, fh ? (dev_t) fh->dev () : 0);
@


1.264.2.2
log
@	* dtable.cc (dtable::get_debugger_info): Raise size of buf to allow
	64 bit values.  Call sprintf in a type-safe manner.
@
text
@d118 2
a119 2
      char buf[sizeof ("cYgstd %x") + 64];
      sprintf (buf, "cYgstd %p %zx %x", &std, sizeof (std[0]), 3);
@


1.264.2.3
log
@	* dll_init.cc: Fix debug printf to be type-safe.
	* dtable.cc: Ditto.
@
text
@d664 1
a664 1
  debug_printf ("fh %p, dev %08x", fh, fh ? (dev_t) fh->dev () : 0);
d713 1
a713 1
  debug_printf ("dup3 (%d, %d, 0x%x)", oldfd, newfd, flags);
d739 1
a739 1
      syscall_printf ("invalid flags value 0x%x", flags);
d781 1
a781 1
  syscall_printf ("%R = dup3(%d, %d, 0x%x)", res, oldfd, newfd, flags);
d942 1
a942 1
    debug_printf ("NtQueryObject failed, 0x%08x", status);
@


1.264.2.4
log
@	* dtable.cc: Use %y rather than 0x%x.
	* exceptions.cc: Ditto.
@
text
@d713 1
a713 1
  debug_printf ("dup3 (%d, %d, %y)", oldfd, newfd, flags);
d739 1
a739 1
      syscall_printf ("invalid flags value %y", flags);
d781 1
a781 1
  syscall_printf ("%R = dup3(%d, %d, %y)", res, oldfd, newfd, flags);
@


1.264.2.5
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d106 1
a106 1
  debug_printf ("size %ld, fds %p", size, fds);
@


1.264.2.6
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d942 1
a942 1
    debug_printf ("NtQueryObject failed, %y", status);
@


1.264.2.7
log
@Pull in changes from HEAD
@
text
@d731 1
a731 1
  if (newfd >= OPEN_MAX_MAX || newfd < 0)
@


1.264.2.8
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.264.2.9
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d34 2
a35 2
static const DWORD std_consts[] = {STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,
				   STD_ERROR_HANDLE};
@


1.263
log
@* dtable.cc (dtable::dup3): Only return with lock set when O_EXCL flag is
passed in.
* syscalls.cc (dup_finish): Pass O_EXCL in flags to dtable::dup3.
@
text
@a14 1
#include <sys/socket.h>
@


1.262
log
@* DevNotes: Add entry cgf-000011.
* fhandler.h (fhandler_base::refcnt): Delete.
(fhandler_base::inc_refcnt): New function.
(fhandler_base::dec_refcnt): New function.
* cygheap.h (cygheap_fdnew::~cygheap_fdnew): Accommodate split of refcnt to
inc_refcnt/dec_refcnt.
(cygheap_fdget::cygheap_fdget): Ditto.
(cygheap_fdget::~cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable::release): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::init_std_file_from_handle): Ditto.
(dtable::dup3): On success, return with fdtab locked.
* dtable.h (dtable): Add dup_finish as a friend.
* syscalls.cc (dup_finish): Define new function.  Increment refcnt while fdtab
is locked.
(dup2): Use common dup_finish() to perform dup operation.
(dup3): Ditto.
@
text
@d717 8
a771 1
  do_unlock = false;
d776 1
@


1.261
log
@	* devices.in: Fix native name of /dev/kmem.
	* devices.cc: Regenerate.
	* dtable.cc (fh_alloc): Don't forget FH_KMEM.
	* fhandler_mem.cc (fhandler_dev_mem::open): Set errno to EACCES rather
	than ENOENT on systems not granting access to physical memory from
	user space.
@
text
@d246 1
a246 1
  fds[fd]->refcnt (-1);
d262 1
a262 1
  cygheap->fdtab[fd]->refcnt (1);
d401 1
a401 1
      cygheap->fdtab[fd]->refcnt (1);
d716 1
d764 1
d772 2
a773 1
  unlock ();
@


1.260
log
@* dtable.cc (fh_alloc): Only disallow opening of nonexistent on-disk device.
* path.cc (path_conv::check): Remove PATH_KEPT_HANDLE setting.
* path.h (path_types): Remove PATH_KEPT_HANDLE.
(path_conv::kept_handle): Delete now-unneeded function.
@
text
@d533 1
@


1.259
log
@* dtable.cc (fh_alloc): Keep fh which was flagged as error if it is for an
on-disk device and we were stating it.
* path.cc (path_conv::check): Set PATH_KEPT_HANDLE.
* path.h (path_types): Add PATH_KEPT_HANDLE.
(path_conv::kept_handle): Implement.
@
text
@d610 1
a610 1
      if (pc.kept_handle () && pc.dev.isfs ())
d612 2
a613 2
				   disk and this is a stat() so just return the
				   info from pc.  */
@


1.258
log
@* fhandler.h (fhandler_base::nohandle): Revert to standard implementation.
* dtable.cc (dtable::fixup_after_exec): Specifically reject releasing
nohandle() type fhandlers rather than relying on contents of io_handle.
(dtable::fixup_after_fork): Ditto.
* fhandler_termios.cc: Add includes necessary for definitions of have_execed
and have_execed_cygwin.
(fhandler_termios::sigflush): Don't flush console input when we've started a
non-Cygwin process.
@
text
@d610 9
a618 2
      delete fh;
      fh = NULL;
@


1.257
log
@* dtable.cc (cygwin_attach_handle_to_fd): Defend against NULL return from
build_fh_*.
(dtable::init_std_file_from_handle): Ditto.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* path.cc (path_conv::check): Ditto.
@
text
@d866 1
a866 1
	if (fh->close_on_exec () || !fh->get_io_handle ())
d888 1
a888 1
	    if (!fh->get_io_handle ())
@


1.256
log
@	* devices.h (FH_CYGDRIVE): Define as DEV_VIRTFS_MAJOR class device.
	(DEV_CYGDRIVE_MAJOR): Remove.
	(iscygdrive_dev): Define.
	* dtable.cc (fh_alloc): Accommodate above change.
	* path.cc (path_conv::check): Use iscygdrive_dev to check for cygdrive.
	* syscalls.cc (fhandler_base::set_ino_and_dev): Drop check for
	DEV_CYGDRIVE_MAJOR from conditional.
@
text
@d259 2
d342 3
@


1.255
log
@	* devices.h (FH_DEV): Define as DEV_VIRTFS_MAJOR class device.
	(DEV_DEV_MAJOR): Remove.
	* dtable.cc (fh_alloc): Accommodate above change.
	* syscalls.cc (set_ino_and_dev): Drop check for DEV_DEV_MAJOR from
	conditional.
@
text
@a458 3
    case DEV_CYGDRIVE_MAJOR:
      fh = cnew (fhandler_cygdrive);
      break;
d562 3
@


1.254
log
@* dtable.cc (dtable::fixup_close): Define new function.
(dtable::fixup_after_exec): Use fixup_close() and detect when it was not
possible to open an inherited file handle.
(dtable::fixup_after_fork): Defensively close any file handles which were not,
for some reason, inheritable.
* dtable.h: Make #pragma once.
(dtable::fixup_close): Declare new function.
* fhandler_console.cc (fhandler_console::set_unit): Set I/O handles to NULL
when this function fails.
@
text
@a461 3
    case DEV_DEV_MAJOR:
      fh = cnew (fhandler_dev);
      break;
d562 3
@


1.253
log
@	* Makefile.in (DLL_OFILES): Add fhandler_dev.o.
	* devices.h (DEV_DEV_MAJOR): Define.
	(FH_DEV): Redefine in terms of DEV_DEV_MAJOR.
	(ext_dev_storage): Declare.
	(dev_storage_size): Declare.
	(dev_dev_storage): Declare.
	(dev_dev): Define.
	(isdev_dev): Define.
	* devices.in (dev_dev_storage): Activate.
	(ext_dev_storage): Define as externally available pointer to
	dev_storage.
	(dev_storage_size): Define to contain number of dev_storage elements.
	* dir.cc (rmdir): Handle /dev as always not empty.
	* dtable.cc (fh_alloc): Handle DEV_DEV_MAJOR.
	* fhandler.h (fhandler_dev): New class, derived from fhandler_disk_file.
	(fhandler_union): Add fhandler_dev member.
	* fhandler_disk_file.cc (class __DIR_mounts): Handle /dev directory
	to make sure it always exists.
	* fhandler_dev.cc: New file implementing /dev.
	* globals.cc (ro_u_dev): New R/O unicode string.
	* path.cc (path_conv::check): Handle FH_DEV device.
@
text
@d838 11
d858 5
a862 9
	if (fh->close_on_exec ())
	  {
	    if (fh->archetype)
	      {
		debug_printf ("closing fd %d since it is an archetype", i);
		fh->close_with_arch ();
	      }
	    release (i);
	  }
d883 7
@


1.252
log
@* dtable.cc (set_std_handle): Call SetStdHandle with NULL if fd is closed.
(dtable::release): "Close" standard handle if appropriate.
* dcrt0.cc (dll_crt0_0): Fix minor switch formatting problem.
* fork.cc (frok::parent): Make minor comment indentation change.
@
text
@d462 3
@


1.251
log
@* dtable.cc (fh_alloc): Treat pc.dev as unsigned.
* fhandler_console.cc (fhandler_console::set_unit): Use lock always to avoid
races between competing cygwin processes running on the console.
@
text
@d68 1
d70 1
a70 1
    SetStdHandle (std_consts[fd], cygheap->fdtab[fd]->get_handle ());
d72 1
a72 1
    SetStdHandle (std_consts[fd], cygheap->fdtab[fd]->get_output_handle ());
d248 2
@


1.250
log
@	* dtable.cc (dtable::init_std_file_from_handle): Use tmp_pathbuf for
	name.
	(handle_to_fn): Ditto for device.  Fix size in QueryDosDeviceW call.
@
text
@d481 1
a481 1
      switch ((int) pc.dev)
@


1.249
log
@* pinfo.cc (_pinfo::set_ctty): Revert 2012-02-07 change to skip function if tty
in question == our ctty.
* syscalls.cc (setsid): Avoid two function calls.
* dtable.cc (dtable::dup_worker): Remove debugging.
* init.cc (search_for): Calculate for every new process rather than using
shared value.
(threadfunc_ix): Fill in for ever new process rather than sing shared value.
@
text
@d265 1
d279 1
a279 1
  char name[NT_MAX_PATH];
d893 1
d954 1
a954 2
	  WCHAR device[NT_MAX_PATH];
	  if (!QueryDosDeviceW (s, device, sizeof (device)))
@


1.248
log
@	* cygheap.cc (init_cygheap::init_installation_root): Convert function
	init_installation_root into a cygheap method.
	* cygheap.h (struct init_cygheap): Move installation_root,
	installation_key, and installation_key_buf from shared
	.cygwin_dll_common DLL section to cygheap.  Declare new method
	init_installation_root.
	* dtable.cc (handle_to_fn): Accommodate the move of installation strings
	to the cygheap.
	* external.cc (cygwin_internal): Ditto.
	* fhandler_console.cc (fhandler_console::open_shared_console): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Ditto.
	* fhandler_tty.cc: Ditto, throughout.
	* mount.cc (mount_info::init): Ditto.
	* pipe.cc (fhandler_pipe::create): Ditto.
	* shared.cc: Ditto, throughout.
	(installation_root): Remove.
	(installation_key): Move to cygheap.
	(installation_key_buf): Ditto.
	(installation_root_inited): Remove.
	(SPIN_WAIT): Remove.
	(init_installation_root): Move to cygheap.
	(memory_init): Call cygheap->init_installation_root right after
	cygheap->user.init.  Drop call of init_installation_root function.
	* shared_info.h (init_installation_root): Drop declaration.
	(installation_root): Ditto.
	(installation_key): Ditto.
	* uinfo.cc (pwdgrp::load): Accommodate the move of installation strings
	to the cygheap.
@
text
@d680 2
a681 10
	  debug_printf ("duped '%s' old %p, new %p", oldfh->get_name (), oldfh->get_io_handle (), newfh->get_io_handle ());
#ifdef DEBUGGING
	  debug_printf ("duped output_handles old %p, new %p",
			oldfh->get_output_handle (),
			newfh->get_output_handle ());
	  if (oldfh->archetype)
	    debug_printf ("duped output_handles archetype old %p, archetype new %p",
			  oldfh->archetype->get_output_handle (),
			  newfh->archetype->get_output_handle ());
#endif /*DEBUGGING*/
@


1.247
log
@* dtable.cc (dtable::init_std_file_from_handle): Reinstate opening tty handles
with O_RDWR permissions.
@
text
@d934 3
a936 2
	  w32len = installation_key.Length / sizeof (WCHAR);
	  if (w32len && wcsncmp (w32, installation_key.Buffer, w32len) != 0)
@


1.246
log
@* dtable.cc (dtable::dup_worker): Add comment explaining why refcnt isn't
incremented here.
(dtable::dup3): Simplify slightly.  Add comment.
* syscalls.cc (dup3): Increment refcnt here, similarly to dup2.
@
text
@d354 1
a354 1
      if (!iscons_dev (dev) && fh->is_tty ())
@


1.245
log
@* cygheap.h (cygheap_fdmanip::release): Simplify.
* dtable.cc (dtable::release): Make void again.  Skip not_open check since it
is guaranteed to be open.  Don't bother deleting here since actual deletion
will be handled in cygheap_fdget::~cygheap_fdget.
* dtable.h (dtable::release): Make void again.
* syscalls.cc (dup2): Bump fhandler use count on successful dup.
@
text
@d672 3
d677 1
d742 3
a744 3
  else if ((size_t) newfd < size)
    /* nothing to do */;
  else if (find_unused_handle (newfd) < 0)
@


1.244
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@d240 1
a240 1
bool
d243 4
a246 17
  bool deleted;
  if (not_open (fd))
    deleted = false;
  else
    {
      if (fds[fd]->need_fixup_before ())
	dec_need_fixup_before ();
      if (fds[fd]->refcnt (-1) > 0)
	deleted = false;
      else
	{
	  deleted = true;
	  delete fds[fd];
	}
      fds[fd] = NULL;
    }
  return deleted;
@


1.243
log
@* dtable.cc (dtable::stdio_init): Always initialize console when we have one.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use a better method to
print tty name for debugging.
(fhandler_termios::bg_check): Ditto.
* pinfo.cc (_pinfo::set_ctty): Remove leftover debugging stuff.  Simplify
behavior when setting tty's sid and pgid to avoid overwriting previously set
values.
* spawn.cc (ch_spawn): Cosmetic change.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.242
log
@Clean up whitespace.
@
text
@a151 4
  /* Set these before trying to output anything from strace.
     Also, always set them even if we're to pick up our parent's fds
     in case they're missed.  */

d155 1
a155 1
      if (t && t->getpgid () == myself->pid && t->is_console)
@


1.241
log
@Implement fhandler reference counting.
* cygheap.h
(cygheap_fdmanip::release): Make virtual.
(cygheap_fdnew::~cygheap_fdnew): New destructor increments reference count when
fd has been allocated.
(cygheap_fdget::fh): New (old?) field.
(cygheap_fdget::cygheap_fdget): Increment reference count when we've found an
active fd.  Set fh appropriately.
(cygheap_fdget::~cygheap_fdget): Decrement reference count when appropriate.
Delete fh if reference count goes to zero.
(cygheap_fdget::release): New function.  Do more bookkeping on release.
* dtable.cc (dtable::release): Change from void to boolean return.  Only delete
the fhandler when its reference count is <= 0 (this should be a fairly unusual
case).  Return true if fhandler has been deleted.
(cygwin_attach_handle_to_fd): Increment reference count when fh is assigned.
(dtable::init_std_file_from_handle): Ditto.
* dtable.h (dtable::release): Change return to boolean.
* fhandler.cc (fhandler_base::fhandler_base): Set new isclosed flag to false.
Set _refcnt to zero.
(fhandler_base::close): Simplify paranoid debugging output.  Set new isclosed()
flag.
(fhandler_base_overlapped::wait_overlapped): Use isclosed() flag to avoid
querying the exception handle.
* fhandler.h (fhandler_base::_refcnt): New field.
(fhandler_base::refcnt): New function.
(fhandler_base::isclosed): Implement.
(fhandler_base::fhandler_base): Set isclosed to false.
* syscalls.cc: Remove space after function before parentheses for several
strace printfs.
(dup): Add standard strace "leaver" code.
(dup2): Ditto.
(dup3): Ditto.
(remove): Ditto.
(getpid): Ditto.
(getppid): Ditto.
(lseek64): Fix strace debugging to correctly use %R.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Avoid sending signals to
other processes if we're debugging since it can cause a deadlock with the
calling debugger.
* exceptions.cc (_cygtls::call_signal_handler): Add debugging-only strace
output.
@
text
@d508 1
a508 1
	    fhraw = cnew_no_ctor (fhandler_pty_master, -1); 
d578 1
a578 1
	      fhraw = cnew_no_ctor (fhandler_console, -1); 
@


1.240
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d244 1
a244 1
void
d247 4
a250 1
  if (!not_open (fd))
d254 7
a260 1
      delete fds[fd];
d263 1
d274 1
d409 1
@


1.239
log
@* fhandler.h (__ptsname): New macro.
* dtable.cc (decode_tty): Use __ptsname to generate the slave pty name.
* fhandler_tty.cc (fhandler_pty_master::ptsname_r): Ditto.
* bsdlib.cc: Add needed includes for openpty() changes.
(openpty): Use __ptsname to generate the slave pty name.  Close slave fd when
aslave == NULL.
@
text
@d760 1
a760 1
  syscall_printf ("%d = dup3 (%d, %d, %p)", res, oldfd, newfd, flags);
@


1.238
log
@* dtable.cc (dtable::delete_archetype): Improve debugging output.
(dtable::init_std_file_from_handle): Close console handle early, before
initialization.  Build up openflags for passing to open_setup, just to be safe.
(last_tty_dev): New variable.
(fh_last_tty_dev): New macro.
(fh_alloc): Try again to keep track of previously opened tty, this time by just
saving the device and using that to potentially open an archetype.  Avoid
setting the "/dev/tty" name if the creation of the fhandler failed.
(build_fh_pc): Remove unused second argument.  Reorganize how and where the
name is set.  Set last_tty_dev as appropriate.  Avoid a NULL dereference in a
debug printf.
* dtable.h (build_fh_pc): Reflect removal of second parameter.
* fhandler.cc (fhandler_base::reset): Use new '<<' operator to copy pc since it
preserves any potentially previously set name.
(fhandler_base::set_name): Ditto.
* fhandler.h (fhandler_*::clone): Throughout use ccalloc to allocate new
fhandler, primarily to make sure that pc field is properly zeroed.
(fhandler_termios::last): Eliminate.
(fhandler_termios): Remove setting of last.
(fhandler_base::~fhandler_termios): Ditto.
* fhandler_console.cc (fhandler_console::open): Don't make decisions about
opening close-on-exec handles here since it makes no sense for archetypes.
(fhandler_console::init): Assume that input handle has already been opened.
* fhandler_termios.cc (fhandler_termios::last): Delete.
* path.h (path_conv::eq_worker): New function.  Move bulk of operator = here.
(operator <<): New function.
(operator =): Use eq_worker to perform old functionality.
@
text
@d890 1
a890 1
  __small_sprintf (buf, "/dev/pty%d", ttyn);
@


1.237
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@d220 2
a221 1
	debug_printf ("deleting element %d for %s", i, fh->get_name ());
d318 5
a322 1
	dev.parse (FH_CONSOLE);
d355 1
d360 9
a368 5
      if (dev == FH_TTY || iscons_dev (dev) || dev.get_major () == DEV_PTYS_MAJOR)
	access |= GENERIC_READ | GENERIC_WRITE;
      else if (NT_SUCCESS (NtQueryInformationFile (handle, &io, &fai,
						   sizeof fai,
						   FileAccessInformation)))
d370 5
d376 4
a379 3
	    access |= GENERIC_READ;
	  if (fai.AccessFlags & FILE_WRITE_DATA)
	    access |= GENERIC_WRITE;
d382 4
a385 1
	access |= GENERIC_READ;
d387 6
a392 22
	access |= GENERIC_WRITE;  /* Should be rdwr for stderr but not sure that's
				    possible for some versions of handles */
      /* FIXME: Workaround Windows 7 issue.  If the parent process of
	 the process tree closes the original handles to the console window,
	 strange problems occur when starting child processes later on if
	 stdio redirection is used.

	 CV 2009-08-08:  It looks like this problem has been fixed only
	 half-heartedly in RTM.  Unfortunately the new implementation
	 has still a problem which now also occurs on the 32 bit release
	 of Windows 7.  It's still not quite clear what happens but it's
	 easily reproducible.  Just start X via the start menu entry.
	 This opens an xterm window with a shell.  Exit from the shell,
	 and you get a Windows error box reporting a crash in the
	 Console Window Host application (conhost.exe) due to an access
	 violation.

	 This needs further investigation but the workaround not to close
	 the handles will have a marginal hit of three extra handles per
	 process at most. */
      if (!fh->init (iscons_dev (dev) && wincap.has_console_handle_problem ()
		     ? INVALID_HANDLE_VALUE : handle, access, bin))
d395 2
d443 2
a564 5
	    fhraw = cnew_no_ctor (fhandler_console, -1); 
	  else if (myself->ctty <= 0
		   && !myself->set_ctty (fhandler_termios::last, 0))
	    /* no tty assigned */;
	  else
d566 9
d579 2
a580 1
	      fh->set_name ("/dev/tty");
d610 1
a610 1
build_fh_pc (path_conv& pc, bool set_name)
a618 6
  else if (fh->get_name ())
    /* already got one */;
  else if (fh->dev () != FH_NADA)
    fh->set_name (fh->dev ().name);
  else if (set_name)
    fh->set_name (pc);
d621 1
a621 1
    /* doesn't use archetypes */;
d623 8
a630 2
    debug_printf ("found an archetype for %s(%d/%d) io_handle %p", fh->get_name (), fh->dev ().get_major (), fh->dev ().get_minor (),
		  fh->archetype->get_io_handle ());
d633 2
d641 3
a643 4
  /* The fhandler_termios constructor keeps track of the last tty-like thing
     opened but we're only interested in this if we don't have a controlling
     terminal since we could potentially want to open it if /dev/tty is
     referenced. */
d645 3
a647 1
    fhandler_termios::last = NULL;
d650 1
a650 1
  debug_printf ("fh %p, dev %p", fh, (DWORD) fh->dev ());
d686 4
a689 3
	  debug_printf ("duped output_handles archetype old %p, archetype new %p",
			oldfh->archetype->get_output_handle (),
			newfh->archetype->get_output_handle ());
@


1.236
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d354 1
a354 1
      if (dev == FH_TTY || iscons_dev (dev) || dev.get_major () == DEV_TTYS_MAJOR)
d447 1
a447 1
    case DEV_TTYS_MAJOR:
d450 1
a450 1
    case DEV_TTYM_MAJOR:
a561 2
	  else if (iscons_dev (myself->ctty))
	    fh = cnew (fhandler_console, pc.dev);
d563 7
a569 1
	    fh = cnew (fhandler_pty_slave, myself->ctty);
d607 2
@


1.235
log
@* cygwin.din: Remove some _tc* exports.  Add tcgetsid().
* dtable.cc (fh_alloc): Revert ill-advised setting of major/minor.  Use new
is_dev_tty to remember that this device was opened as /dev/tty.
* fhandler.cc (fhandler_base::fstat): Remove leftover debugging statement.
(fhandler_base::tcgetsid): New function.
* fhandler.h ((fhandler_base::tcgetsid): Declare new function.
(fhandler_base::is_dev_tty): Ditto.
(fhandler_termios::opened_as_dev_tty): Declare new field.
(fhandler_termios::is_dev_tty): Declare new function.
(fhandler_termios::tcgetsid): Ditto.
(fhandler_pty_common::use_archetype): Move here from subclass.
(fhandler_pty_slave::use_archetype): Move up.
(fhandler_pty_master::use_archetype): Ditto.
* fhandler_console.cc (fhandler_console::ioctl): Rename second argument from
`buf' to `arg' for consistency.  Call ioctl_termios for common fhandler_termios
ioctl handling.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call ioctl_termios for common
fhandler_termios ioctl handling.
(fhandler_pty_master::ioctl): Ditto.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Implement new function.
(fhandler_termios::ioctl_termios): Ditto.  Implements TIOCSCTTY handling.
* syscalls.cc (stat_worker): Set /dev/tty device info when appropriate.
* termios.cc (tcgetpgrp): Avoid extraneous "isatty" check.
(tcgetsid): Implement new function.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 253.
* include/sys/termios.h (TIOCSCTTY): Define.
@
text
@d116 1
a116 1
      char std[3][sizeof ("/dev/ttyNNNN")];
d404 6
d438 1
d440 1
a440 1
fh_alloc (device dev)
d443 1
d445 1
a445 1
  switch (dev.get_major ())
d448 4
a451 1
      fh = cnew (fhandler_pty_slave, dev.get_minor ());
d475 1
a475 1
      fh = cnew (fhandler_console, dev);
d478 1
a478 1
      switch ((int) dev)
d483 1
a483 1
	  fh = cnew (fhandler_console, dev);
d485 5
a489 2
	case FH_PTYM:
	  fh = cnew (fhandler_pty_master);
d557 10
a566 11
	  {
	    if (myself->ctty > 0)
	      {
		if (iscons_dev (myself->ctty))
		  fh = cnew (fhandler_console, dev);
		else
		  fh = cnew (fhandler_pty_slave, myself->ctty);
	      }
	      ((fhandler_termios *) fh)->is_dev_tty (true);
	    break;
	  }
d573 10
d585 5
d596 1
a596 1
  fhandler_base *fh = fh_alloc (pc.dev);
d600 1
a600 1
      set_errno (EMFILE);
a602 2
  else if (fh->dev () == FH_ERROR)
    goto out;
d611 2
a612 1
    debug_printf ("found an archetype for %s(%d/%d)", fh->get_name (), fh->dev ().get_major (), fh->dev ().get_minor ());
d615 2
a616 3
      debug_printf ("creating an archetype for %s(%d/%d)", fh->get_name (), fh->dev ().get_major (), fh->dev ().get_minor ());
      fh->archetype = fh_alloc (fh->pc.dev);
      *fh->archetype = *fh;
d621 7
d629 1
a629 1
  debug_printf ("fh %p", fh);
d639 1
a639 1
  fhandler_base *newfh = build_fh_pc (oldfh->pc, false);
a643 1
      *newfh = *oldfh;
d646 1
d648 1
a648 1
      if (oldfh->dup (newfh))
d661 8
d703 7
d868 1
a868 1
  __small_sprintf (buf, "/dev/tty%d", ttyn);
@


1.234
log
@* dtable.cc (fh_alloc): Don't parse /dev/tty if ctty is < 0.  Reset major/minor
from the specific tty to those for /dev/tty.
@
text
@a549 1
		fh->dev () = FH_TTY;
d551 1
@


1.233
log
@* dtable.cc: Mark some const variables as static.
* environ.cc (conv_start_chars): Move to shared cygwin region and initialize at
compile time.
(match_first_char): New generic function for querying conv_start_chars.
(posify_maybe): Rename from posify.
(environ_init): Remove conv_envvars initialization.  Don't check
conv_start_chars, just allow posify_maybe to make the decision.
* fhandler_console.cc (__vt100_conv): Fix formatting.  Mark as const.
@
text
@d544 8
a551 4
	    if (iscons_dev (myself->ctty))
	      fh = cnew (fhandler_console, dev);
	    else
	      fh = cnew (fhandler_pty_slave, myself->ctty);
@


1.232
log
@	* dtable.cc (dtable::get_debugger_info): Add missing braces.
	(dtable::stdio_init): Fix incorrect negation of not_open(2) condition.
@
text
@d41 2
a42 2
char unknown_file[] = "some disk file";
const WCHAR DEV_NULL[] = L"\\Device\\Null";
d45 2
a46 2
const WCHAR DEVICE_PREFIX[] = L"\\device\\";
const size_t DEVICE_PREFIX_LEN WCLEN (DEVICE_PREFIX);
@


1.231
log
@	* dtable.cc (dtable::init_std_file_from_handle): Change test for console
	device in call to fh->init to avoid conhost crash on W7.
@
text
@d133 8
a140 6
	      CloseHandle (h);
	      /* Copy to Windows' idea of a standard handle, otherwise
		 we have invalid standard handles when calling Windows
		 functions (small_printf and strace might suffer, too). */
	      SetStdHandle (std_consts[i], i ? fh->get_output_handle ()
					     : fh->get_handle ());
d177 1
a177 1
  if (out == err && (!being_debugged () || !not_open (2)))
@


1.230
log
@* dtable.cc (cnew): Fix whitespace.
@
text
@d386 1
a386 1
      if (!fh->init (dev == FH_CONSOLE && wincap.has_console_handle_problem ()
@


1.229
log
@	* dtable.cc (fh_oom): Remove.
	(fh_calloc): Remove.
	(cnew): Redefine to handle NULL returns from cmalloc.
	(build_fh_name): Accommodate new definition of cnew.  Remove unneeded
	test for fh_oom.
	(fh_alloc): Ditto.
@
text
@d399 1
a399 1
    ptr? new(ptr) name(__VA_ARGS__) : NULL; \
@


1.228
log
@	* dtable.cc (fh_oom): New static fhandler storage.
	(fh_calloc): New static function.  Add a comment to explain why this
	is needed.
	(cnew): Call fh_calloc as placement argument.
	(build_fh_name): Check return code from cnew against address of
	fh_oom to test for out of memory condition.
	(fh_alloc): Ditto.
	(build_fh_pc): Avoid a crash due to useing a NULL fhandler.
	* pipe.cc (fhandler_pipe::create): Check if build_fh_dev returned a
	valid pointer before using it.
@
text
@d396 5
a400 11
/* This is a workaround for the fact that the placement new operator
   always calls the constructor, even if the placement pointer is NULL. */
static fhandler_union fh_oom;
static void *
fh_calloc (size_t size)
{
  void *ret = ccalloc (HEAP_FHANDLER, 1, size);
  return ret ?: (void *) &fh_oom;
}

#define cnew(name) new (fh_calloc (sizeof (name))) name
d408 2
a409 2
      fhandler_base *fh = cnew (fhandler_nodevice) ();
      if (fh != (fhandler_base *) &fh_oom)
d438 1
a438 1
      fh = cnew (fhandler_pty_slave) (dev.get_minor ());
d441 1
a441 1
      fh = cnew (fhandler_cygdrive) ();
d453 1
a453 1
      fh = cnew (fhandler_dev_floppy) ();
d456 1
a456 1
      fh = cnew (fhandler_dev_tape) ();
d459 1
a459 1
      fh = cnew (fhandler_serial) ();
d462 1
a462 1
      fh = cnew (fhandler_console) (dev);
d470 1
a470 1
	  fh = cnew (fhandler_console) (dev);
d473 1
a473 1
	  fh = cnew (fhandler_pty_master) ();
d476 1
a476 1
	  fh = cnew (fhandler_windows) ();
d479 1
a479 1
	  fh = cnew (fhandler_fifo) ();
d484 1
a484 1
	  fh = cnew (fhandler_pipe) ();
d492 1
a492 1
	  fh = cnew (fhandler_socket) ();
d495 1
a495 1
	  fh = cnew (fhandler_disk_file) ();
d498 1
a498 1
	  fh = cnew (fhandler_dev_null) ();
d502 1
a502 1
	  fh = cnew (fhandler_dev_zero) ();
d506 1
a506 1
	  fh = cnew (fhandler_dev_random) ();
d510 1
a510 1
	  fh = cnew (fhandler_dev_mem) ();
d513 1
a513 1
	  fh = cnew (fhandler_dev_clipboard) ();
d516 1
a516 1
	  fh = cnew (fhandler_dev_dsp) ();
d519 1
a519 1
	  fh = cnew (fhandler_proc) ();
d522 1
a522 1
	  fh = cnew (fhandler_registry) ();
d526 1
a526 1
	  fh = cnew (fhandler_process) ();
d529 1
a529 1
	  fh = cnew (fhandler_procnet) ();
d532 1
a532 1
	  fh = cnew (fhandler_procsys) ();
d535 1
a535 1
	  fh = cnew (fhandler_procsysvipc) ();
d538 1
a538 1
	  fh = cnew (fhandler_netdrive) ();
d543 1
a543 1
	      fh = cnew (fhandler_console) (dev);
d545 1
a545 1
	      fh = cnew (fhandler_pty_slave) (myself->ctty);
d549 1
a549 1
	  fh = cnew (fhandler_mailslot) ();
d555 1
a555 3
    fh = cnew (fhandler_nodevice) ();
  if (fh == (fhandler_base *) &fh_oom)
    fh = NULL;
@


1.227
log
@	* dtable.cc (handle_to_fn): Accommodate name change of pty named pipes,
	otherwise ptys are not recognized.
@
text
@d396 11
a406 1
#define cnew(name) new ((void *) ccalloc (HEAP_FHANDLER, 1, sizeof (name))) name
d415 1
a415 1
      if (fh)
d562 2
d573 4
a576 1
    set_errno (EMFILE);
@


1.226
log
@* cygheap.h (init_cygheap::ctty_on_hold): Remove conditionalized variable.
* dcrt0.cc (do_exit): Remove code which handled CYGWIN=tty style ttys.
* devices.in: Remove "/dev/ttym".
* dtable.cc: Rename tty to pty where appropriate throughout.
(dtable::stdio_init): Use new t->is_console rather than using now-deleted hwnd
element in tty structure.
(dtable::init_std_file_from_handle): Remove code which handled CYGWIN=tty style
ttys.
(fh_alloc): Ditto.
* fhandler.h: Rename tty to pty where appropriate.
(fhandler_pty_common): Delete output_done_event, ioctl_request_event,
ioctl_done_event.
(fhandler_pty_master::setup): Delete argument.
(fhandler_tty_master): Delete.
(fhandler_union): Delete __tty_master.
* fhandler_console.cc (use_tty): Delete.
(fhandler_console::get_tty_stuff): Set is_console to true rather than calling
sethwnd.
(fhandler_console::send_winch_maybe): Remove CYGWIN=tty considerations.
(fhandler_console::input_tcsetattr): Ditto.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use new t->is_console
rather than using now-deleted hwnd element in tty structure.
* fhandler_tty.cc: Rename tty to pty where appropriate throughout.
(tty_master): Delete.
(process_input): Ditto.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::*): Ditto.
(fhandler_pty_master::process_slave_output): Remove CYGWIN=tty considerations.
(fhandler_pty_slave::open): Ditto for *_done_event.
(fhandler_pty_slave::write): Ditto.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_slave::fch_open_handles): Ditto.
(fhandler_pty_slave::fch_set_sd): Ditto.
(fhandler_pty_slave::fch_close_handles): Ditto.
(fhandler_pty_common::close): Ditto.
(fhandler_pty_master::setup): Ditto.  Remove now-unneeded ispty parameter.
(fhandler_pty_master::open): Reflect argument removal for tty::allocate.
* select.cc: Rename tty to pty where appropriate throughout.
* sigproc.cc (proc_subproc): Remove CYGWIN=tty considerations.
* tty.cc (ttyslot): Accommodate CYGWIN=tty removal.
(tty_list::init_session): Ditto.
(tty_list::attach): Ditto.
(tty::create_master): Delete.
(tty_list::terminate): Ditto.
(tty_list::allocate): Delete "with_console" parameter.  Remove CYGWIN=tty
considerations.
(tty::init): Set is_console = false.  Use 'false' for was_opened since it is a
boolean.
* tty.h (*_{DONE,REQUEST}_EVENT): Delete.
(tty_min::is_console): Declare new field which replaces hwnd.
(tty_min::gethwnd): Delete.
(tty_min::sethwnd): Ditto.
(tty_list::allocate): Delete parameter.
(tty_list::terminate): Delete declaration.
* include/sys/cygwin.h (PID_USETTY): Redefine to PID_UNUSED1 and change comment
to reflect its availability.
@
text
@d859 1
a859 1
	  bool istty = wcsncmp (w32, L"tty", WCLEN (L"tty")) == 0;
d861 1
a861 1
	    decode_tty (posix_fn, w32 + WCLEN (L"tty"));
@


1.225
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@d157 1
a157 1
      if (t && t->getpgid () == myself->pid && t->gethwnd ())
d312 1
a312 3
      if (!ISSTATE (myself, PID_USETTY))
	dev.parse (FH_CONSOLE);
      else if (myself->ctty > 0)
d315 1
a315 1
	dev.parse (FH_TTY);
d434 1
a434 4
      fh = cnew (fhandler_tty_slave) (dev.get_minor ());
      break;
    case DEV_TTYM_MAJOR:
      fh = cnew (fhandler_tty_master) ();
d541 1
a541 1
	      fh = cnew (fhandler_tty_slave) (myself->ctty);
@


1.224
log
@whitespace elimination
@
text
@d354 1
a354 1
      if (dev == FH_TTY || dev == FH_CONSOLE || dev.get_major () == DEV_TTYS_MAJOR)
d463 1
a463 1
      fh = cnew (fhandler_console) ();
d471 1
a471 1
	  fh = cnew (fhandler_console) ();
d544 1
a544 1
	      fh = cnew (fhandler_console) ();
d567 3
a569 1
  else if (fh->dev () != FH_BAD)
d587 1
@


1.223
log
@* dtable.cc (dtable::select_write): Add missing argument to debug_printf.
* fhandler.cc (fhandler_base_overlapped::setup_overlapped): Explicitly set
io_pending to false.
(fhandler_base_overlapped::has_ongoing_io): Call GetOverlappedResult to force
completion of I/O.
(fhandler_base_overlapped::wait_overlapped): Rewrite to correctly deal with
nonblocking reads and to make more race proof.
(fhandler_base_overlapped::raw_write): Deal with new enum values.
(fhandler_base_overlapped::raw_read): Ditto.  Don't deal with ongoing I/O here
since it makes no sense in the read context.
* fhandler.h (enum wait_return): Add overlapped_unknown,
overlapped_nonblocking_no_data.
* pipe.cc (pipe): Add debugging output.
@
text
@d309 1
a309 1
  	   || GetNumberOfConsoleInputEvents (handle, (DWORD *) &buf))
d355 1
a355 1
      	access |= GENERIC_READ | GENERIC_WRITE;
d953 2
a954 2
        debug_printf ("fd %d (%s)", i, fh->get_name ());
        fh->fixup_before_fork_exec (target_proc_id);
d957 2
a958 1
} 
d967 2
a968 2
        debug_printf ("fd %d (%s)", i, fh->get_name ());
        fh->fixup_before_fork_exec (target_proc_id);
d971 1
a971 2
} 

@


1.222
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d715 1
a715 1
  debug_printf ("%s fd %d", fh->get_name ());
@


1.221
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d156 1
a156 1
      tty_min *t = cygwin_shared->tty.get_tty (myself->ctty);
d199 1
a199 1
    if (archetypes[i]->get_device () == (unsigned) dev)
d271 1
a271 1
  device dev;
a272 1
  dev.devn = 0;		/* FIXME: device */
d313 3
a315 3
	dev = *console_dev;
      else if (myself->ctty >= 0)
	dev.parse (DEV_TTYS_MAJOR, myself->ctty);
d354 1
a354 1
      if (dev == FH_TTY || dev == FH_CONSOLE || dev.major == DEV_TTYS_MAJOR)
d433 1
a433 1
  switch (dev.major)
d436 1
a436 1
      fh = cnew (fhandler_tty_slave) (dev.minor);
d462 3
d466 1
a466 1
      switch (dev)
d543 1
a543 1
	    if (myself->ctty == TTY_CONSOLE)
d575 1
a575 1
    debug_printf ("found an archetype for %s(%d/%d)", fh->get_name (), fh->dev ().major, fh->dev ().minor);
d578 1
a578 1
      debug_printf ("creating an archetype for %s(%d/%d)", fh->get_name (), fh->dev ().major, fh->dev ().minor);
@


1.220
log
@* cygheap.h (init_cygheap::ctty): Use base class so that console can join in
the fun.
* dtable.cc (dtable::stdio_init): Remove special-case call to set_console_ctty
().
* exceptions.cc (sigpacket::process): Conditionally flush terminal input on
certain signals.
* fhandler.h (fhandler_console::get_tty_stuff): Make non-static.
(fhandler_termios::get_ttyp): Move here.
(fhandler_termios::sigflush): Declare.
(fhandler_tty_common::get_ttyp): Delete.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass this as "arch"
argument.
(set_console_ctty): Delete.
(tty_list::get_tty): Just return pointer to shared console region, delaying
get_tty_stuff until open().
(fhandler_console::init): Treat NULL handle as signifying that console should
be opened with O_NOCTTY flag.  Rename handle argument to the more common 'h'.
* fhandler_termios.cc (fhandler_termios::sigflush): Define.
* fhandler_tty.cc (handler_tty_master::init_console): Pass NULL as first
argument to fhandler_console::init.
* pinfo.cc (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
Add extra debugging.
* pinfo.h (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
* sigproc.cc (handle_sigsuspend): Don't special-case non-main threads.
@
text
@a247 1
      fhandler_base *arch = fds[fd]->archetype;
a248 2
      if (arch && !arch->usecount)
	cygheap->fdtab.delete_archetype (arch);
d309 2
a310 1
  else if (GetConsoleScreenBufferInfo (handle, &buf))
d312 5
a316 3
      /* Console output */
      if (ISSTATE (myself, PID_USETTY))
	dev.parse (FH_TTY);
a317 6
	dev = *console_dev;
    }
  else if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &buf))
    {
      /* Console input */
      if (ISSTATE (myself, PID_USETTY))
a318 2
      else
	dev = *console_dev;
d321 2
a322 2
    /* serial */
    dev.parse (DEV_TTYS_MAJOR, 0);
d429 2
a430 2
fhandler_base *
build_fh_pc (path_conv& pc, bool set_name)
d434 1
a434 1
  switch (pc.dev.major)
d437 1
a437 1
      fh = cnew (fhandler_tty_slave) ();
d464 1
a464 1
      switch (pc.dev)
d543 2
a544 2
	    else if (myself->ctty >= 0)
	      fh = cnew (fhandler_tty_slave) ();
d555 7
d565 2
d570 13
d599 2
a600 1
      newfh->set_io_handle (NULL);
d610 2
d613 1
a613 4
	  if (flags & O_CLOEXEC)
	    newfh->set_close_on_exec (true);
	  else
	    newfh->close_on_exec (false);
d771 1
a771 1
		fh->close ();
a802 96
#ifdef NEWVFORK
int
dtable::vfork_child_dup ()
{
  fhandler_base **newtable;
  lock ();
  newtable = (fhandler_base **) ccalloc (HEAP_ARGV, size, sizeof (fds[0]));
  int res = 1;

  /* Remove impersonation */
  cygheap->user.deimpersonate ();
  if (cygheap->ctty)
    {
      cygheap->ctty->usecount++;
      cygheap->console_count++;
      report_tty_counts (cygheap->ctty, "vfork dup", "incremented ", "");
    }

  for (size_t i = 0; i < size; i++)
    if (not_open (i))
      continue;
    else if ((newtable[i] = dup_worker (fds[i])) != NULL)
      newtable[i]->set_close_on_exec (fds[i]->close_on_exec ());
    else
      {
	res = 0;
	goto out;
      }

  fds_on_hold = fds;
  fds = newtable;

out:
  /* Restore impersonation */
  cygheap->user.reimpersonate ();

  unlock ();
  return 1;
}

void
dtable::vfork_parent_restore ()
{
  lock ();

  fhandler_tty_slave *ctty_on_hold = cygheap->ctty_on_hold;
  close_all_files ();
  fhandler_base **deleteme = fds;
  fds = fds_on_hold;
  fds_on_hold = NULL;
  cfree (deleteme);
  unlock ();

  if (cygheap->ctty != ctty_on_hold)
    {
      cygheap->ctty = ctty_on_hold;		// revert
      cygheap->ctty->close ();			// Undo previous bump of this archetype
    }
  cygheap->ctty_on_hold = NULL;
}

void
dtable::vfork_child_fixup ()
{
  if (!fds_on_hold)
    return;
  debug_printf ("here");
  fhandler_base **saveme = fds;
  fds = fds_on_hold;

  fhandler_base *fh;
  for (int i = 0; i < (int) size; i++)
    if ((fh = fds[i]) != NULL)
      {
	fh->clear_readahead ();
	if (!fh->archetype && fh->close_on_exec ())
	  release (i);
	else
	  {
	    fh->close ();
	    release (i);
	  }
      }

  fds = saveme;
  cfree (fds_on_hold);
  fds_on_hold = NULL;

  if (cygheap->ctty_on_hold)
    {
      cygheap->ctty_on_hold->close ();
      cygheap->ctty_on_hold = NULL;
    }
}
#endif /*NEWVFORK*/

@


1.219
log
@	* dtable.cc (dtable::init_std_file_from_handle): Fix a comment to
	reflect the current state.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
a149 1
  extern void set_console_ctty ();
a190 5

  /* Assign the console as the controlling tty for this process if we actually
     have a console and no other controlling tty has been assigned. */
  if (!fhandler_console::need_invisible () && myself->ctty < 0)
    set_console_ctty ();
@


1.218
log
@Implement /proc/sysvipc/*
* devices.in (dev_procsysvipc_storage): Add.
* devices.cc: Regenerate.
* devices.h (fh_devices): Add FH_PROCSYSVIPC.
* dtable.cc (build_fh_pc): Add case FH_PROCSYSVIPC.
* fhandler.h (class fhandler_procsysvipc): Declare.
(fhandler_union): Add __procsysvipc.
* fhandler_proc.cc (proc_tab): Add sysvipc virt_directory.
* fhandler_procsysvipc.cc: New file.
* Makefile.in (DLL_OFILES): Add fhandler_procsysvipc.o.
* path.h (isproc_dev): Add FH_PROCSYSVIPC to conditional.
@
text
@d302 3
a304 2
	       /* On NT4, NtQueryObject returns STATUS_NOT_IMPLEMENTED when
	          called for a socket handle. */
@


1.217
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d546 3
@


1.216
log
@	* dtable.cc (dtable::dup_worker): Reset path_conv handle in duplicated
	fhandler.
	* fhandler.cc (fhandler_base::fstatvfs): Keep handle in created
	path_conv.
	* fhandler.h (fhandler_base::get_stat_access): New method.
	(fhandler_base::get_stat_handle): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use handle
	returned by get_stat_handle.  Only request inode from system if it
	isn't already set in the fhandler, and only for filesystems supporting
	them.
	(fhandler_base::fstat_fs): Use handle returned by get_stat_handle.
	Change the way open_fs is called.  Explain why.
	(fhandler_base::fstat_helper): Use handle returned by get_stat_handle.
	Never use 0 inode number.  Simplify executable recognition by re-using
	get_stat_handle if file could be opened with sufficient rights.
	(fhandler_disk_file::fstatvfs): Use handle returned by get_stat_handle.
	(fhandler_disk_file::facl): Use handle returned by get_stat_handle in
	GETACL and GETACLCNT cases.
	(fhandler_disk_file::link): Use handle returned by get_stat_handle
	instead of opening file here again.  Add comment.
	(readdir_get_ino): Keep handle in created path_conv and drop
	opening file.
	* ntdll.h (wait_pending): New helper function.
	* path.cc (symlink_info::check): Drop unused 'opt' parameter from
	declaration.  Add path_conv_handle argument.
	(path_conv::check): Make sure conv_handle is closed.  Keep
	PC_KEEP_HANDLE flag in pflags_or.  Accommodate call to sym.check to
	new args.
	(path_conv::~path_conv): Close conv_handle.
	(symlink_info::check_shortcut): Don't re-open file here, just use
	incoming handle.  Drop goto's and label out.
	(symlink_info::check_sysfile): Don't re-open file here, just use
	incoming handle.  Keep track of file position to accommodate the fact
	that file has been opened asynchronously in calling function.
	(symlink_info::check_nfs_symlink): Don't re-open file here, just use
	incoming handle.
	(symlink_info::check): Drop unused 'opt' parameter.  Add
	path_conv_handle argument.  Always try to open file with GENERIC_READ
	rights first to allow reading file content w/o having to re-open the
	file.  Drop back to READ_CONTROL | FILE_READ_ATTRIBUTES otherwise.
	Call symlink test functions (except for check_reparse_point) only if
	file could be opened with GENERIC_READ.  Keep file handle open if
	PC_KEEP_HANDLE is set in pflags.
	* path.h (enum pathconv_arg): Add PC_KEEP_HANDLE flag.
	(class path_conv_handle): New class.
	(class path_conv): Add conv_handle member.
	(path_conv::operator =): Duplicate conv_handle.
	(path_conv::handle): New method.
	(path_conv::access): New method.
	(path_conv::reset_conv_handle): New method.
	(path_conv::close_conv_handle): New method.
@
text
@d543 3
@


1.215
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set access mask for
	the slave side of ttys explicitely.  Explain why.
@
text
@d585 1
@


1.214
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set dev to
	valid content for ptys.  Remove setting FILE_CREATE_PIPE_INSTANCE
	in access flags since it's not needed.  Set the access mask for
	kernel objects according to what's returned by NtQueryInformationFile,
	info class FileAccessInformation.
@
text
@d366 3
a368 2
	 by NtQueryInformationFile is meaningless. */
      if (dev == FH_TTY || dev == FH_CONSOLE)
@


1.213
log
@* dtable.cc (dtable::init_std_file_from_handle): Avoid adding fh to fdtab until
we know that it is good.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Handle error
conditions more consistently.  Avoid handle leakage on error.
@
text
@d300 1
a300 1
	/* ok */;
a315 2
      if (name[0])
	access = FILE_CREATE_PIPE_INSTANCE;
d362 5
d369 9
@


1.212
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@a352 3
      if (fh)
	cygheap->fdtab[fd] = fh;

d389 1
a389 1
      if (fh->init (dev == FH_CONSOLE && wincap.has_console_handle_problem ()
a390 2
	set_std_handle (fd);
      else
d392 3
@


1.211
log
@	* dtable.cc (build_fh_name_worker): Remove.  Move all functionality
	back into build_fh_name.
	(build_fh_name): Drop unused HANDLE parameter.  Drop call to pc.fillin.
	Remove disabled build_fh_name with UNICODE_STRING name parameter.
	* dtable.h (build_fh_name): Drop HANDLE parameter from declaration.
	Remove declaration for build_fh_name with UNICODE_STRING name parameter.
	* path.cc (path_conv::fillin): Remove.
	(symlink_info::check): Fix comment.
	* path.h (path_conv::fillin): Remove declaration.
	* dir.cc: Accommodate change in build_fh_name parameters throughout.
	* sec_acl.cc: Ditto.
	* syscalls.cc: Ditto.

	* ntea.cc (getxattr_worker): Fix debug output.
	(setxattr_worker): Ditto.
	* times.cc (utimens_worker): Ditto.
@
text
@d562 1
a562 1
dtable::dup_worker (fhandler_base *oldfh)
d582 5
a586 1
	  newfh->close_on_exec (false);
d594 1
a594 1
dtable::dup2 (int oldfd, int newfd)
d600 1
a600 1
  debug_printf ("dup2 (%d, %d)", oldfd, newfd);
a608 1

d615 1
a615 2

  if (newfd == oldfd)
d617 3
a619 2
      res = newfd;
      goto done;
d622 1
a622 1
  if ((newfh = dup_worker (fds[oldfd])) == NULL)
d650 1
a650 1
  syscall_printf ("%d = dup2 (%d, %d)", res, oldfd, newfd);
@


1.210
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d403 2
a404 2
static fhandler_base *
build_fh_name_worker (path_conv& pc, HANDLE h, unsigned opt, suffix_info *si)
d406 1
a415 3
  if (!pc.exists () && h)
    pc.fillin (h);

a417 16
fhandler_base *
build_fh_name (const char *name, HANDLE h, unsigned opt, suffix_info *si)
{
  path_conv pc (name, opt | PC_NULLEMPTY | PC_POSIX, si);
  return build_fh_name_worker (pc, h, opt, si);
}

#if 0 /* Not needed yet */
#define cnew(name) new ((void *) ccalloc (HEAP_FHANDLER, 1, sizeof (name))) name
fhandler_base *
build_fh_name (const UNICODE_STRING *name, HANDLE h, unsigned opt, suffix_info *si)
{
  path_conv pc (name, opt | PC_NULLEMPTY | PC_POSIX, si);
  return build_fh_name_worker (pc, h, opt, si);
}
#endif
@


1.209
log
@	* dtable.cc (dtable::stdio_init): Use GetCurrentProcess() rather than
	hMainProc as process handle when duplicating the stdout handle.
	Explain why.  Add Win32 error code to debug output.
@
text
@a179 3
      /* CV 2009-11-26: Using hMainProc results in ERROR_INVALID_PARAMETER
	 when trying to duplicate a console handle.  It only works using
	 the GetCurrentProcess () pseudo handle for some unknown reason. */
@


1.208
log
@	Reintegrate socket duplication via WSADuplicateSocket/WSASocket.
	* autoload.cc (WSADuplicateSocketW): Define.
	(WSASocketW): Define.
	* dtable.cc (dtable::release): Call dec_need_fixup_before if necessary.
	(dtable::fixup_before_fork): New function.
	(dtable::fixup_before_exec): New function.
	* dtable.h (class dtable): Add member cnt_need_fixup_before.  Add
	declarations for above new functions.
	(dtable::dec_need_fixup_before): New inline method.
	(dtable::inc_need_fixup_before): New inline method.
	(dtable::need_fixup_before): New inline method.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): New virtual
	method.
	(fhandler_base::need_fixup_before): New virtual method.
	(class fhandler_socket): Add member prot_info_ptr.
	(fhandler_socket::init_fixup_before): Declare.
	(fhandler_socket::need_fixup_before): New inline method.
	(fhandler_socket::fixup_before_fork_exec): Declare.
	(fhandler_socket::fixup_after_exec): Declare.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	prot_info_ptr to NULL.
	(fhandler_socket::~fhandler_socket): Free prot_info_ptr conditionally.
	(fhandler_socket::init_fixup_before): New method.
	(fhandler_socket::fixup_before_fork_exec): Ditto.
	(fhandler_socket::fixup_after_fork): Use WSASocketW to duplicate
	socket if necessary.
	(fhandler_socket::fixup_after_exec): New method.
	(fhandler_socket::dup): Use fixup_before_fork_exec/fixup_after_fork
	to duplicate socket if necessary.
	* fork.cc (frok::parent): Start child suspended if some fhandler
	needs fixup before fork.  If so, call dtable::fixup_before_fork after
	CreateProcess and resume child.
	* net.cc (fdsock): Try to find out if socket needs fixup before and
	initialize socket accordingly.  Add HUGE comment to explain what happens
	and why.
	* spawn.cc (spawn_guts): Start child suspended if some fhandler needs
	fixup before exec.  If so, call dtable::fixup_before_exec after
	CreateProcess.
@
text
@d180 6
a185 2
      if (!DuplicateHandle (hMainProc, out, hMainProc, &err, 0, true,
			    DUPLICATE_SAME_ACCESS))
d189 1
a189 1
	  system_printf ("couldn't make stderr distinct from stdout");
@


1.207
log
@	* cygprops.h: New file.
	* dtable.cc (handle_to_fn): Add check for correct installation_key
	string in object name for pipes and ttys.
	* external.cc (cygwin_internal): Add CW_GET_INSTKEY to allow fetching
	the installation_key from cygserver.
	* fhandler_fifo.cc (fhandler_fifo::fifo_name): Add installation_key
	to fifo name.
	* globals.cc: Include cygprops.h.
	(_RDATA): Move slightly and add comment.
	(cygwin_props): Define.
	* mount.cc (mount_info::init): Accommodate the fact that
	installation_root is now a global variable in DLL common shared memory,
	rather than a member of cygwin_shared.
	* pipe.cc (fhandler_pipe::create_selectable): Add installation_key to
	pipe name.
	* shared.cc (installation_root): Define here for storage in DLL
	common shared memory.
	(installation_key): Ditto.
	(installation_key_buf): Ditto.
	(init_installation_root): Convert from shared_info method to ordinary
	function.  Add initializing installation_key.  Invalidate
	installation_key depending of value of disable_key property.  Add
	comment to explain.
	(get_shared_parent_dir): Add installation_key to directory name.
	(get_session_parent_dir): Ditto.
	(shared_info::initialize): Move call to init_installation_root from
	here...
	(memory_init): ...to here.  Add debug output to print installation root
	and installation key.  Add comment to explain why.
	* shared_info.h (SHARED_INFO_CB): Recalculate.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Remove definition of installation_root and
	declaration of init_installation_root.
	(init_installation_root): Declare.
	(installation_root): Declare.
	(installation_key): Declare.
	* uinfo.cc (pwdgrp::load): Accommodate the fact that installation_root
	is now a global variable in DLL common shared memory.
	* include/cygwin/version.h: Bump API minor number.
	(CYGWIN_INFO_INSTALLATIONS_NAME): Add.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_INSTKEY.
@
text
@d251 2
d1025 28
@


1.206
log
@Match dup2 and fcntl error values to POSIX.

* dtable.h (OPEN_MAX_MAX): New macro.
* resource.cc (getrlimit) [RLIMIT_NOFILE]: Use it.
* dtable.cc (dtable::extend): Likewise.
* fcntl.cc (fcntl64): Obey POSIX rule with too-large F_DUPFD.
* syscalls.cc (dup2): Likewise.
@
text
@d932 8
@


1.205
log
@	* dtable.cc (build_fh_dev): Take additional bool parameter indicating
	whether set_name should be called or not.
	(dtable::dup_worker): Call build_fh_pc with new second parameter set
	to false.  Explain why.  If fhandler's dup failed, delete rather than
	cfree newfh and set newfh to NULL to indicate failure correctly.
	* dtable.h (build_fh_pc): Change declaration according to above change.
	Default set_name parameter to true.
	* mmap.cc (mmap_record::free_fh): Delete rather than cfree fh.
@
text
@d83 1
a83 1
  if (new_size > (100 * NOFILE_INCR))
@


1.204
log
@* dtable.cc (dtable::fixup_after_exec): Close any popen'ed file handles here.
* fhandler.h (fhandler_*::ispipe): New function.
(fhandler_base::get_popen_pid): Define virtual function.
(fhandler_*::isdevice): Make const.
(fhandler_*::isfifo): Ditto.
@
text
@d447 1
a447 1
build_fh_pc (path_conv& pc)
d567 3
a569 1
  if (fh)
a570 2
  else
    set_errno (EMFILE);
d579 4
a582 1
  fhandler_base *newfh = build_fh_pc (oldfh->pc);
d591 2
a592 1
	  cfree (newfh);
@


1.203
log
@	* dtable.cc (DEV_SOCKET): New static WCHAR string.  Name of
	the native NT socket device.
	(dtable::init_std_file_from_handle): Remove unused tmp_pathbuf
	variable.  Move check for sockets into FILE_TYPE_PIPE clause.
	Rely on handle_to_fn having recognized socket, or check if
	getsockopt works to accommodate NT4 shortcoming.
	(handle_to_fn): Use tmp_pathbuf for OBJECT_NAME_INFORMATION
	buffer and simplify code due to that.  Check name returned by
	NtQueryObject for socket device.
@
text
@d756 2
@


1.202
log
@	* dtable.cc (dtable::init_std_file_from_handle): Fix comment to
	document change in the Windows 7 workaround.
	* wincap.cc (wincapc::init): Don't set has_console_handle_problem
	to false on 32 bit systems.
@
text
@d43 1
a274 2
  struct sockaddr sa;
  int sal = sizeof (sa);
a277 1
  tmp_pathbuf tp;
d294 2
d298 11
a331 3
  else if (wsock_started && getpeername ((SOCKET) handle, &sa, &sal) == 0)
    /* socket */
    dev = *tcp_dev;
a891 1
  OBJECT_NAME_INFORMATION dummy_oni;
d894 1
d896 6
a901 4
  NTSTATUS status = NtQueryObject (h, ObjectNameInformation, &dummy_oni,
				   sizeof (dummy_oni), &len);
  if (!NT_SUCCESS (status) || !len)
    debug_printf ("NtQueryObject failed 1");
d904 3
a906 2
      OBJECT_NAME_INFORMATION *ntfn = (OBJECT_NAME_INFORMATION *) alloca (len + sizeof (WCHAR));
      NTSTATUS res = NtQueryObject (h, ObjectNameInformation, ntfn, len, NULL);
d908 1
a908 6
      if (!NT_SUCCESS (res))
	  debug_printf ("NtQueryObject failed 2");
      // NT seems to do this on an unopened file
      else if (!ntfn->Name.Buffer)
	debug_printf ("nt->Name.Buffer == NULL");
      else
d910 3
a912 3
	  WCHAR *w32 = ntfn->Name.Buffer;
	  size_t w32len = ntfn->Name.Length / sizeof (WCHAR);
	  w32[w32len] = L'\0';
d914 5
a918 5
	  if (wcscasecmp (w32, DEV_NULL) == 0)
	    {
	      strcpy (posix_fn, "/dev/null");
	      return false;
	    }
d920 13
a932 13
	  if (wcsncasecmp (w32, DEV_NAMED_PIPE, DEV_NAMED_PIPE_LEN) == 0)
	    {
	      w32 += DEV_NAMED_PIPE_LEN;
	      if (wcsncmp (w32, L"cygwin-", WCLEN (L"cygwin-")) != 0)
		return false;
	      w32 += WCLEN (L"cygwin-");
	      bool istty = wcsncmp (w32, L"tty", WCLEN (L"tty")) == 0;
	      if (istty)
		decode_tty (posix_fn, w32 + WCLEN (L"tty"));
	      else if (wcsncmp (w32, L"pipe", WCLEN (L"pipe")) == 0)
		strcpy (posix_fn, "/dev/pipe");
	      return istty;
	    }
d934 7
d942 9
a950 3
	  WCHAR fnbuf[64 * 1024];
	  if (wcsncasecmp (w32, DEVICE_PREFIX, DEVICE_PREFIX_LEN) != 0
	      || !QueryDosDeviceW (NULL, fnbuf, sizeof (fnbuf)))
d952 3
a954 2
	      sys_wcstombs (posix_fn, NT_MAX_PATH, w32, w32len);
	      return false;
d956 12
d969 8
a976 1
	  for (WCHAR *s = fnbuf; *s; s = wcschr (s, '\0') + 1)
d978 4
a981 53
	      WCHAR device[NT_MAX_PATH];
	      if (!QueryDosDeviceW (s, device, sizeof (device)))
		continue;
	      if (wcschr (s, ':') == NULL)
		continue;
	      WCHAR *q = wcsrchr (device, ';');
	      if (q)
		{
		  WCHAR *r = wcschr (q, '\\');
		  if (r)
		    wcscpy (q, r + 1);
		}
	      int devlen = wcslen (device);
	      if (device[devlen - 1] == L'\\')
		device[--devlen] = L'\0';
	      if (devlen < maxmatchlen)
		continue;
	      if (wcsncmp (device, w32, devlen) != 0||
		  (w32[devlen] != L'\0' && w32[devlen] != L'\\'))
		continue;
	      maxmatchlen = devlen;
	      maxmatchdos = s;
	      debug_printf ("current match '%W' = '%W'\n", s, device);
	    }

	  if (maxmatchlen)
	    {
	      WCHAR *p = wcschr (w32 + DEVICE_PREFIX_LEN, L'\\');
	      size_t n = wcslen (maxmatchdos);
	      WCHAR ch;
	      if (!p)
		ch = L'\0';
	      else
		{
		  if (maxmatchdos[n - 1] == L'\\')
		    n--;
		  w32 += maxmatchlen - n;
		  ch = L'\\';
		}
	      memcpy (w32, maxmatchdos, n * sizeof (WCHAR));
	      w32[n] = ch;
	    }
	  else if (wcsncmp (w32, DEV_REMOTE, DEV_REMOTE_LEN) == 0)
	    {
	      w32 += DEV_REMOTE_LEN - 2;
	      *w32 = L'\\';
	      debug_printf ("remote drive");
	    }
	  else if (wcsncmp (w32, DEV_REMOTE1, DEV_REMOTE1_LEN) == 0)
	    {
	      w32 += DEV_REMOTE1_LEN - 2;
	      *w32 = L'\\';
	      debug_printf ("remote drive");
d983 15
d999 2
a1000 2
	  cygwin_conv_path (CCP_WIN_W_TO_POSIX | CCP_ABSOLUTE, w32, posix_fn,
			    NT_MAX_PATH);
d1002 2
a1003 3
	  debug_printf ("derived path '%W', posix '%s'", w32, posix_fn);
	  return false;
	}
@


1.201
log
@* cygheap.h (cygheap_debug::endh): Delete.
* debug.cc (lock_debug::acquired): Delete.
(lock_debug::lock_debug): Simplify.
(lock_debug::unlock): Ditto.
(find_handle): Don't set endh here.
(add_handle): Add new handle to beginning of the list rather than trying to
maintain an end list pointer.
(delete_handle): Minor optimization.
(mark_closed): Make logic clearer.
(verify_handle): Lock handle list before scanning.
(setclexec): Ditto.
(modify_handle): Ditto.
(newh): Don't lock handle list here.  Assume caller did this.
(mark_closed): Ditto.
(close_handle): Remove unneeded #if.
* dtable.cc (dtable::dup2): Tweak debug output.
@
text
@d363 1
a363 1
      /* FIXME: Workaround Windows 7 64 bit issue.  If the parent process of
d366 1
a366 1
	 stdio redirection is used.  How to reproduce:
d368 9
a376 15
	   shell script foo:

	     exec 2>foo.log
	     FOO=$( uname -n | cat )
	     echo $FOO

	 start from cmd with `bash foo'.  The result is that the cat process
	 will be started but dies before Cygwin strace output can be generated
	 and $FOO stays empty.  The strace output shows that bash tries
	 multiple times to start cat, but none of the invocations of cat will
	 ever show up in the strace output.

	 Remove the `exec 2>' or remove the cat call and the script will work.
	 Start bash interactively, then start the script manually, and the
	 script will work.
@


1.200
log
@	* dtable.cc (dup2): Correct return value for no-op.
@
text
@d634 2
a635 2
  debug_printf ("newfh->io_handle %p, oldfh->io_handle %p",
		newfh->get_io_handle (), fds[oldfd]->get_io_handle ());
@


1.199
log
@* dtable.cc (handle_to_fn): Detect failing NtQueryObject.
@
text
@d624 1
a624 1
      res = 0;
@


1.198
log
@* dcrt0.cc (jit_debug): New global.
(initial_env): Set jit_debug when we are automatically starting a gdb process.
* dtable.cc (dtable::get_debugger_info): Don't tty tricks when we are being
debugged by our own captive gdb, as determined by jit_debug == true.
(dtable::init_std_file_from_handle): Detect errors when initializing a tty
early rather than at random points later.
* fhandler.h (fhandler_*::init): Return int to indicate success/failure.
* fhandler.cc (fhandler_base::init): Reflect change in return value.
* pipe.cc (fhandler_pipe::init): Ditto.
(fhandler_pipe::create_selectable): Don't say we're retrying when we aren't.
* fhandler_console.cc (fhandler_console::init): Ditto.  Return success/failure.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
(fhandler_tty_slave::open): Make debugging output more detailed.
* tty.cc (tty_list::terminate): Don't close I/O handles before all slaves have
checked in.
(tty::slave_alive): Make a non-inlined function.  Check if tty pipe handles can
be created as an additional exists check.
* tty.h (tty::slave_alive): Just define here.
@
text
@d894 3
a896 2
  NtQueryObject (h, ObjectNameInformation, &dummy_oni, sizeof (dummy_oni), &len);
  if (!len)
@


1.197
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d112 2
a113 1
  if (being_debugged ())
d387 5
a391 3
      fh->init (dev == FH_CONSOLE && wincap.has_console_handle_problem ()
      		? INVALID_HANDLE_VALUE : handle, access, bin);
      set_std_handle (fd);
@


1.196
log
@	* dtable.cc (dtable::init_std_file_from_handle): Add workaround for
	Windows 7 64 bit issue.  Add lengthy comment to explain what happens.
	* wincap.h (wincaps::has_console_handle_problem): New element.
	* wincap.cc: Implement above element throughout.
	(wincap_7): New wincaps structure for NT 6.1 kernels.
	(wincapc::init): Set has_console_handle_problem to false for 32 bit
	systems.

	Fix broken older ChangeLog entry.
@
text
@d28 1
d363 1
a363 1
	 the process tree closes the original handles to the console window, 
d382 1
a382 1
	 
d658 2
a659 2
select_record *
dtable::select_read (int fd, select_record *s)
d664 1
a664 1
      return NULL;
d667 1
a667 1
  s = fh->select_read (s);
d673 1
a673 1
  return s;
d676 2
a677 2
select_record *
dtable::select_write (int fd, select_record *s)
d685 1
a685 1
  s = fh->select_write (s);
d689 2
a690 2
  debug_printf ("%s fd %d", fh->get_name (), fd);
  return s;
d693 2
a694 2
select_record *
dtable::select_except (int fd, select_record *s)
d702 1
a702 1
  s = fh->select_except (s);
d707 1
a707 1
  return s;
@


1.195
log
@* dtable.cc (dtable::select_read): Add ability to override fh.
* fhandler.h (fhandler_fifo::select_read): Declare new function.
(fhandler_fifo::select_write): Ditto.
(fhandler_fifo::select_except): Ditto.
* select.cc (peek_pipe): Treat certain classes of pipe errors as "no data".
(fhandler_fifo::select_read): Define new function.
(fhandler_fifo::select_write): Ditto.
(fhandler_fifo::select_except): Ditto.
* shared_info.h (CURR_SHARED_MAGIC): Update.
@
text
@d361 26
a386 1
      fh->init (handle, access, bin);
@


1.194
log
@	* devices.h (FH_PROCESSFD): New device type.
	* dtable.cc (build_fh_pc): Add case for FH_PROCESSFD.
	* fhandler.h (class fhandler_virtual): Drop bufalloc member.
	* fhandler_virtual.h: New header.
	* fhandler_proc.cc: Remove types proc_type_t and proc_tab_t in favor
	of types virt_type_t and virt_tab_t from fhandler_virtual.h.
	Change prototypes of format_XXX functions accordingly.
	(proc_tab): Drop size member info.
	(fhandler_proc::fill_filebuf): Don't allocate filebuf here.  Allocate
	it in the format_XXX functions.
	* fhandler_process.cc: Reorganize global process content data into a
	new struct virt_tab_t.  Accommodate throughout.
	(format_process_winexename): New function.
	(format_process_winpid): New function.
	(format_process_exename): New function.
	(format_process_root): New function.
	(format_process_cwd): New function.
	(format_process_cmdline): New function.
	(format_process_ppid): New function.
	(format_process_uid): New function.
	(format_process_pgid): New function.
	(format_process_sid): New function.
	(format_process_gid): New function.
	(format_process_ctty): New function.
	(format_process_fd): New function.
	* fhandler_procnet.cc (fhandler_procnet::fill_filebuf): Don't use
	bufalloc.
	* fhandler_registry.cc (fhandler_registry::fill_filebuf): Define
	bufalloc locally.
	* fhandler_virtual.cc (fhandler_virtual::fhandler_virtual): Drop
	initialization of bufalloc.
	(fhandler_virtual::dup): Drop copying bufalloc.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
d643 2
a644 1
  s->fh = fh;
@


1.193
log
@	* dtable.cc (dtable::get_debugger_info): Call SetStdHandle
	for the newly opened handle.  Explain why.
	(dtable::stdio_init): Don't duplicate standard error handle
	when stderr has already been created under debugger control.
@
text
@d510 1
@


1.192
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d131 5
d169 5
a173 1
  if (out == err)
@


1.191
log
@	* path.cc (path_conv::set_normalized_path): Drop strip_tail argument.
	Never strip trailing dots and spaces.
	* (path_conv::check): Accomodate above change.
	* path.h (path_conv::operator=): Ditto
	* dtable.cc (build_fh_dev): Ditto.
	* fhandler.h (fhandler_base::set_name): Ditto.

	* path.cc (transform_chars): Disable converting trailing dots and
	spaces.

	* path.cc (path_conv::check): Remove two disabled code snippets.
@
text
@d856 2
d859 2
a860 43
      debug_printf ("NtQueryObject failed 1");
      goto unknown;
    }

  OBJECT_NAME_INFORMATION *ntfn = (OBJECT_NAME_INFORMATION *) alloca (len + sizeof (WCHAR));
  NTSTATUS res = NtQueryObject (h, ObjectNameInformation, ntfn, len, NULL);

  if (!NT_SUCCESS (res))
    {
      debug_printf ("NtQueryObject failed 2");
      goto unknown;
    }

  // NT seems to do this on an unopened file
  if (!ntfn->Name.Buffer)
    {
      debug_printf ("nt->Name.Buffer == NULL");
      goto unknown;
    }

  WCHAR *w32 = ntfn->Name.Buffer;
  size_t w32len = ntfn->Name.Length / sizeof (WCHAR);
  w32[w32len] = L'\0';

  if (wcscasecmp (w32, DEV_NULL) == 0)
    {
      strcpy (posix_fn, "/dev/null");
      return false;
    }

  if (wcsncasecmp (w32, DEV_NAMED_PIPE, DEV_NAMED_PIPE_LEN) == 0)
    {
      w32 += DEV_NAMED_PIPE_LEN;
      if (wcsncmp (w32, L"cygwin-", WCLEN (L"cygwin-")) != 0)
	return false;
      w32 += WCLEN (L"cygwin-");
      bool istty = wcsncmp (w32, L"tty", WCLEN (L"tty")) == 0;
      if (istty)
	decode_tty (posix_fn, w32 + WCLEN (L"tty"));
      else if (wcsncmp (w32, L"pipe", WCLEN (L"pipe")) == 0)
	strcpy (posix_fn, "/dev/pipe");
      return istty;
    }
d862 96
d959 2
a960 7
  WCHAR fnbuf[64 * 1024];
  if (wcsncasecmp (w32, DEVICE_PREFIX, DEVICE_PREFIX_LEN) != 0
      || !QueryDosDeviceW (NULL, fnbuf, sizeof (fnbuf)))
    {
      sys_wcstombs (posix_fn, NT_MAX_PATH, w32, w32len);
      return false;
    }
d962 2
a963 13
  for (WCHAR *s = fnbuf; *s; s = wcschr (s, '\0') + 1)
    {
      WCHAR device[NT_MAX_PATH];
      if (!QueryDosDeviceW (s, device, sizeof (device)))
	continue;
      if (wcschr (s, ':') == NULL)
	continue;
      WCHAR *q = wcsrchr (device, ';');
      if (q)
	{
	  WCHAR *r = wcschr (q, '\\');
	  if (r)
	    wcscpy (q, r + 1);
a964 11
      int devlen = wcslen (device);
      if (device[devlen - 1] == L'\\')
	device[--devlen] = L'\0';
      if (devlen < maxmatchlen)
	continue;
      if (wcsncmp (device, w32, devlen) != 0||
	  (w32[devlen] != L'\0' && w32[devlen] != L'\\'))
	continue;
      maxmatchlen = devlen;
      maxmatchdos = s;
      debug_printf ("current match '%W' = '%W'\n", s, device);
a966 37
  if (maxmatchlen)
    {
      WCHAR *p = wcschr (w32 + DEVICE_PREFIX_LEN, L'\\');
      size_t n = wcslen (maxmatchdos);
      WCHAR ch;
      if (!p)
	ch = L'\0';
      else
	{
	  if (maxmatchdos[n - 1] == L'\\')
	    n--;
	  w32 += maxmatchlen - n;
	  ch = L'\\';
	}
      memcpy (w32, maxmatchdos, n * sizeof (WCHAR));
      w32[n] = ch;
    }
  else if (wcsncmp (w32, DEV_REMOTE, DEV_REMOTE_LEN) == 0)
    {
      w32 += DEV_REMOTE_LEN - 2;
      *w32 = L'\\';
      debug_printf ("remote drive");
    }
  else if (wcsncmp (w32, DEV_REMOTE1, DEV_REMOTE1_LEN) == 0)
    {
      w32 += DEV_REMOTE1_LEN - 2;
      *w32 = L'\\';
      debug_printf ("remote drive");
    }

  cygwin_conv_path (CCP_WIN_W_TO_POSIX | CCP_ABSOLUTE, w32, posix_fn,
		    NT_MAX_PATH);

  debug_printf ("derived path '%W', posix '%s'", w32, posix_fn);
  return false;

unknown:
@


1.190
log
@	* dtable.cc (dtable::release): Drop fixup_before handling.
	(dtable::fixup_before_fork): Remove.
	(dtable::fixup_before_exec): Remove.
	* dtable.h (class dtable): Remove cnt_need_fixup_before member.
	(dtable::dtable): Accommodate above change.
	(dtable::dec_need_fixup_before): Remove.
	(dtable::inc_need_fixup_before): Remove.
	(dtable::need_fixup_before): Remove.
	(dtable::fixup_before_exec): Remove declaration.
	(dtable::fixup_before_fork): Ditto.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): Remove.
	(fhandler_base::need_fixup_before): Remove.
	* fork.cc (frok::parent): Drop fixup_before handling.
	* spawn.cc (spawn_guts): Ditto.
@
text
@d399 1
a399 1
    pc.set_normalized_path (unix_name, false);
d401 1
a401 1
    pc.set_normalized_path (dev.name, false);
@


1.189
log
@Remove unneeded header files from source files throughout.
@
text
@a238 2
      if (fds[fd]->need_fixup_before ())
	dec_need_fixup_before ();
a672 16
/* Function to walk the fd table after an exec and perform
   per-fhandler type fixups. */
void
dtable::fixup_before_fork (DWORD target_proc_id)
{
  lock ();
  fhandler_base *fh;
  for (size_t i = 0; i < size; i++)
    if ((fh = fds[i]) != NULL)
      {
	debug_printf ("fd %d (%s)", i, fh->get_name ());
	fh->fixup_before_fork_exec (target_proc_id);
      }
  unlock ();
}

a681 14
dtable::fixup_before_exec (DWORD target_proc_id)
{
  lock ();
  fhandler_base *fh;
  for (size_t i = 0; i < size; i++)
    if ((fh = fds[i]) != NULL && !fh->close_on_exec ())
      {
	debug_printf ("fd %d (%s)", i, fh->get_name ());
	fh->fixup_before_fork_exec (target_proc_id);
      }
  unlock ();
}

void
@


1.188
log
@	* Fix copyright dates.
@
text
@a18 3
#include <sys/cygwin.h>
#include <assert.h>
#include <winnls.h>
a25 1
#include "security.h"
@


1.187
log
@* dtable.cc (handle_to_fn): Modify to return true if handle represents a cygwin
tty.
(dtable::init_std_file_from_handle): Detect when we've seen a cygwin pipe and
use it in overlapped mode by default.
(decode_tty): Make static.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.186
log
@* dtable.cc: Define various device-related string constants as wide character
constants.
(dtable::init_std_file_from_handle): Reorganize pipe handling to try to catch
special tty case.
(build_fh_name_worker): Declare for common use.
(build_fh_name): Define char version.
(build_fh_name): Define (currently unused) UNICODE_STRING version.
(decode_tty): Detect if pipe is actually a cygwin tty, returning the tty name
in the buffer.
(handle_to_fn): Reorganize to use wide characters.
* dtable.h (build_fh_name): Declare (currently unused) UNICODE_STRING version.
* fhandler_tty.cc (fhandler_pty_master::setup): Use
fhandler_pipe::create_selectable to create a pipe with a given name.
* pipe.cc (pipe_handler): Make returned handle inheritable.
(fhandler_pipe::create_selectable): Take an optional name.  Use a standard
cygwin introducer for the name.
* path.cc (path_conv::check): Make first argument const.
* path.h (path_conv::check): Ditto for declaration.
(path_conv::path_conv): Ditto for UNICODE_STRING version.
@
text
@d41 1
a41 1
static void handle_to_fn (HANDLE, char *);
d287 3
a289 1
  if (ft == FILE_TYPE_PIPE)
d291 1
a291 2
      handle_to_fn (handle, name);
      if (name[0])
d297 2
a299 2
  else if (ft == FILE_TYPE_UNKNOWN && GetLastError () == ERROR_INVALID_HANDLE)
    /* can't figure out what this is */;
d352 1
a352 1
      	access = GENERIC_READ | GENERIC_WRITE;
d354 1
a354 1
	access = GENERIC_READ;
d356 1
a356 1
	access = GENERIC_WRITE;  /* Should be rdwr for stderr but not sure that's
d390 1
d398 1
d872 2
a873 1
void decode_tty (WCHAR *w32, char *buf)
d879 3
a881 1
static void
d920 1
a920 1
      return;
d926 9
a934 3
      if (wcsncmp (w32, L"cygwin-tty", WCLEN (L"cygwin-tty")) == 0)
	decode_tty (w32 + WCLEN (L"cygwin-tty"), posix_fn);
      return;
d943 1
a943 1
      return;
d1007 1
a1007 1
  return;
d1011 1
@


1.185
log
@	* winsup.h (NT_MAX_PATH): Revert ill-advised change to 32767.
	Accommodate change throughout.

	* cygwin.din (cygwin_conv_path): Export.
	(cygwin_conv_path_list): Export.
	(cygwin_create_path): Export.
	* dcrt0.cc (dll_crt0_1): Use cygwin_conv_path.
	* dtable.cc (handle_to_fn): Ditto.  Don't expect UNICODE_STRING being
	0-terminated.
	* environ.cc (env_plist_to_posix): New helper function.
	(env_plist_to_win32): Ditto.
	(env_path_to_posix): Ditto.
	(env_path_to_win32): Ditto.
	(return_MAX_PATH): Remove.
	(conv_envvars): Use new helper functions.  Drop removed members.
	(win_env::operator =): Accommodate removal of path length functions.
	(win_env::add_cache): Accommodate new env helper function API.
	(posify): Ditto.
	* environ.h (struct win_env): Ditto. Remove path length function
	pointers since they are unused.
	* path.cc (warn_msdos): Use cygwin_conv_path.
	(getfileattr): Use new tmp_pathbuf::u_get method.
	(fillout_mntent): Ditto.
	(symlink_info::check): Ditto.
	(path_conv::check): Use sizeof (WCHAR) instead of constant 2.
	(symlink_info::check_reparse_point): Ditto.
	(conv_path_list): Get max size of target string as argument.  Call
	cygwin_conv_path as helper function.
	(cygwin_conv_path): New function.
	(cygwin_create_path): New function.
	(cygwin_conv_to_win32_path): Just call cygwin_conv_path with size set
	to MAX_PATH.
	(cygwin_conv_to_full_win32_path): Ditto.
	(cygwin_conv_to_posix_path): Ditto.
	(cygwin_conv_to_full_posix_path): Ditto.
	(conv_path_list_buf_size): Add FIXME comment.
	(env_PATH_to_posix): Rename from env_win32_to_posix_path_list.
	Add size argument as required for env helper functions.
	(cygwin_win32_to_posix_path_list): Call conv_path_list with size set to
	MAX_PATH.
	(cygwin_posix_to_win32_path_list): Ditto.
	(cygwin_conv_path_list): New function.
	(cwdstuff::get): Fix length argument in call to sys_wcstombs.
	* spawn.cc (find_exec): Use cygwin_conv_path_list.
	* tls_pbuf.h (tmp_pathbuf::u_get: New method.
	* uinfo.cc (cygheap_user::ontherange): Allocate temporary path buffers
	using tmp_pathbuf.  Use cygwin_conv_path.
	* winf.cc (av::unshift): Use cygwin_conv_path.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h: Comment out old cygwin32_XXX API.
	Mark old path handling API as deprecated.
	(cygwin_conv_path_t): Typedef.  Define values.
	(cygwin_conv_path): Declare.
	(cygwin_create_path): Declare.
	(cygwin_conv_path_list): Declare.
@
text
@a20 1
#include <ntdef.h>
d22 1
a37 2
static const char NO_COPY unknown_file[] = "some disk file";

d41 11
a51 1
static const char *handle_to_fn (HANDLE, char *);
d53 5
a57 10
#define DEVICE_PREFIX "\\device\\"
#define DEVICE_PREFIX_LEN sizeof (DEVICE_PREFIX) - 1
#define REMOTE "\\Device\\LanmanRedirector\\"
#define REMOTE_LEN sizeof (REMOTE) - 1
#define REMOTE1 "\\Device\\WinDfs\\Root\\"
#define REMOTE1_LEN sizeof (REMOTE1) - 1
#define NAMED_PIPE "\\Device\\NamedPipe\\"
#define NAMED_PIPE_LEN sizeof (NAMED_PIPE) - 1
#define POSIX_NAMED_PIPE "/Device/NamedPipe/"
#define POSIX_NAMED_PIPE_LEN sizeof (POSIX_NAMED_PIPE) - 1
a267 1
  const char *name = NULL;
d283 1
d285 23
a307 1
  if (ft != FILE_TYPE_UNKNOWN || GetLastError () != ERROR_INVALID_HANDLE)
d309 3
a311 19
      /* See if we can consoleify it */
      if (GetConsoleScreenBufferInfo (handle, &buf))
	{
	  if (ISSTATE (myself, PID_USETTY))
	    dev.parse (FH_TTY);
	  else
	    dev = *console_dev;
	}
      else if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &buf))
	{
	  if (ISSTATE (myself, PID_USETTY))
	    dev.parse (FH_TTY);
	  else
	    dev = *console_dev;
	}
      else if (wsock_started && getpeername ((SOCKET) handle, &sa, &sal) == 0)
	dev = *tcp_dev;
      else if (GetCommState (handle, &dcb))
	dev.parse (DEV_TTYS_MAJOR, 0);
d313 1
a313 9
	{
	  name = handle_to_fn (handle, tp.c_get ());
	  if (!strncasematch (name, POSIX_NAMED_PIPE, POSIX_NAMED_PIPE_LEN))
	    /* nothing */;
	  else if (fd == 0)
	    dev = *piper_dev;
	  else
	    dev = *pipew_dev;
	}
d315 9
d325 1
a325 1
  if (!name && !dev)
d332 1
a332 1
	fh = build_fh_dev (dev, name);
d339 1
a339 1
      if (name)
a349 1
      DWORD access;
d364 3
a366 2
fhandler_base *
build_fh_name (const char *name, HANDLE h, unsigned opt, suffix_info *si)
a367 1
  path_conv pc (name, opt | PC_NULLEMPTY | PC_POSIX, si);
d382 14
d869 7
a875 1
static const char *
d879 11
a889 9
  OBJECT_NAME_INFORMATION *ntfn;
  const size_t len = sizeof (OBJECT_NAME_INFORMATION)
		     + NT_MAX_PATH * sizeof (WCHAR);
  char *fnbuf = (char *) alloca (len);

  memset (fnbuf, 0, len);
  ntfn = (OBJECT_NAME_INFORMATION *) fnbuf;
  ntfn->Name.MaximumLength = (NT_MAX_PATH - 1) * sizeof (WCHAR);
  ntfn->Name.Buffer = (WCHAR *) (ntfn + 1);
d891 1
d896 2
a897 3
      strcpy (posix_fn, unknown_file);
      debug_printf ("NtQueryObject failed");
      return unknown_file;
d904 11
a914 1
      return NULL;
d917 7
a923 1
  ntfn->Name.Buffer[ntfn->Name.Length / sizeof (WCHAR)] = 0;
a924 7
  char *win32_fn = tp.c_get ();
  sys_wcstombs (win32_fn, NT_MAX_PATH, ntfn->Name.Buffer,
  		ntfn->Name.Length / sizeof (WCHAR));
  debug_printf ("nt name '%s'", win32_fn);
  if (!strncasematch (win32_fn, DEVICE_PREFIX, DEVICE_PREFIX_LEN)
      || !QueryDosDevice (NULL, fnbuf, len))
    return strcpy (posix_fn, win32_fn);
d926 7
a932 1
  char *p = strechr (win32_fn + DEVICE_PREFIX_LEN, '\\');
d934 1
a934 5
  int n = p - win32_fn;
  int maxmatchlen = 0;
  char *maxmatchdos = NULL;
  char *device = tp.c_get ();
  for (char *s = fnbuf; *s; s = strchr (s, '\0') + 1)
d936 2
a937 2
      device[NT_MAX_PATH - 1] = '\0';
      if (strchr (s, ':') == NULL)
d939 1
a939 1
      if (!QueryDosDevice (s, device, NT_MAX_PATH - 1))
d941 1
a941 1
      char *q = strrchr (device, ';');
d944 1
a944 1
	  char *r = strchr (q, '\\');
d946 1
a946 1
	    strcpy (q, r + 1);
d948 3
a950 3
      int devlen = strlen (device);
      if (device[devlen - 1] == '\\')
	device[--devlen] = '\0';
d953 2
a954 2
      if (!strncasematch (device, win32_fn, devlen) ||
	  (win32_fn[devlen] != '\0' && win32_fn[devlen] != '\\'))
d958 1
a958 1
      debug_printf ("current match '%s'", device);
a960 2
  char *w32 = win32_fn;
  bool justslash = false;
d963 14
a976 11
      n = strlen (maxmatchdos);
      if (maxmatchdos[n - 1] == '\\')
	n--;
      w32 += maxmatchlen - n;
      memcpy (w32, maxmatchdos, n);
      w32[n] = '\\';
    }
  else if (strncasematch (w32, NAMED_PIPE, NAMED_PIPE_LEN))
    {
      debug_printf ("pipe");
      justslash = true;
d978 1
a978 1
  else if (strncasematch (w32, REMOTE, REMOTE_LEN))
d980 2
a981 2
      w32 += REMOTE_LEN - 2;
      *w32 = '\\';
a982 1
      justslash = true;
d984 1
a984 1
  else if (strncasematch (w32, REMOTE1, REMOTE1_LEN))
d986 2
a987 2
      w32 += REMOTE1_LEN - 2;
      *w32 = '\\';
a988 1
      justslash = true;
d991 5
a995 13
  if (!justslash)
    cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE, w32, posix_fn,
		      NT_MAX_PATH);
  else
    {
      char *s, *d;
      for (s = w32, d = posix_fn; *s; s++, d++)
	if (*s == '\\')
	  *d = '/';
	else
	  *d = *s;
      *d = 0;
    }
d997 2
a998 2
  debug_printf ("derived path '%s', posix '%s'", w32, posix_fn);
  return posix_fn;
@


1.184
log
@	* dtable.cc (dtable::init_std_file_from_handle): Use tmp_pathbuf to
	allocate path buffer.
	(handle_to_fn): Ditto.  Allocate fnbuf big enough to get long path
	names.
@
text
@d857 1
a857 1
  ntfn->Name.MaximumLength = NT_MAX_PATH * sizeof (WCHAR);
d879 2
a880 1
  sys_wcstombs (win32_fn, NT_MAX_PATH, ntfn->Name.Buffer);
d951 2
a952 1
    cygwin_conv_to_full_posix_path (w32, posix_fn);
@


1.183
log
@	* dtable.cc (handle_to_fn): Null-terminate posix_fn in the case
	of justslash = true.
@
text
@d34 1
d272 1
d305 1
a305 1
	  name = handle_to_fn (handle, (char *) alloca (CYG_MAX_PATH + 100));
d849 1
d851 3
a853 1
  char fnbuf[32768];
d855 1
a855 1
  memset (fnbuf, 0, sizeof (fnbuf));
d857 1
a857 1
  ntfn->Name.MaximumLength = sizeof (fnbuf) - sizeof (*ntfn);
d860 1
a860 2
  NTSTATUS res = NtQueryObject (h, ObjectNameInformation, ntfn, sizeof (fnbuf),
  				NULL);
d878 2
a879 2
  char win32_fn[CYG_MAX_PATH + 100];
  sys_wcstombs (win32_fn, CYG_MAX_PATH + 100, ntfn->Name.Buffer);
d882 1
a882 1
      || !QueryDosDevice (NULL, fnbuf, sizeof (fnbuf)))
d890 1
d893 1
a893 2
      char device[CYG_MAX_PATH + 10];
      device[CYG_MAX_PATH + 9] = '\0';
d896 1
a896 1
      if (!QueryDosDevice (s, device, sizeof (device) - 1))
@


1.182
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d955 1
@


1.181
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set access to
	read/write of handle is connected to a tty or console.
	* fhandler_dsp.cc (fhandler_dev_dsp::dup): Set open flags correctly
	after duplicating from archetype.
	* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
	(fhandler_pty_master::dup): Ditto.
@
text
@d343 1
a343 1
      else 
@


1.180
log
@* dtable.cc (POSIX_NAMED_PIPE): New define.
(POSIX_NAMED_PIPE_LEN): Ditto.
(dtable::add_archetype): Use crealloc_abort.
(dtable::init_std_file_from_handle): Specifically detect pipe stdin/stdout.
Pass name to build_fh_dev so that proper name is recorded.  Use binmode of fh
if it is set before using get_default_mode.  Set proper read/write access when
calling init().
(handle_to_fn): Handle pipes.
* fhandler.cc (fhandler_base::wait_overlapped): Add some debugging.
* fhandler.h (fhandler_base::set_name): Default to just setting the path_conv
name.
(fhandler_pipe::init): Declare.
* pipe.cc (struct pipesync): New struct.
(getov_result): New function.  Blocks and retrieves the result of an overlay
I/O operation.
(pipe_handler): New function.
(pipesync::pipesync): New function.  Initializer for pipesync struct.
(handler_pipe::init): Define.  Detects attempts to set up a "native" pipe
fhandler and creates a thread which accepts input from or output to the
non-cygwin pipe, creating a cygwin pipe wrapper around the non-cygwin pipe.
(fhandler_pipe::create): Add pipe-specific flags to call to init().
* exceptions.cc (ctrl_c_handler): Lock process while we determine what to do.
@
text
@d339 3
a341 1
      if (fd == 0)
@


1.179
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Reenable.  Fix
	comment.
	* spawn.cc (spawn_guts): Call cygheap->fdtab.set_file_pointers_for_exec
	only for non-Cygwin processes.
@
text
@d44 11
d201 1
a201 1
    archetypes = (fhandler_base **) crealloc (archetypes, (narchetypes += initial_archetype_size) * sizeof archetypes[0]);
a296 7
      else if (ft == FILE_TYPE_PIPE)
	{
	  if (fd == 0)
	    dev = *piper_dev;
	  else
	    dev = *pipew_dev;
	}
d304 6
a309 1
	  bin = 0;
d320 1
a320 1
	fh = build_fh_dev (dev);
d327 1
a327 1
      if (!bin)
d329 7
a335 7
	  bin = fh->get_default_fmode (O_RDWR);
	  if (bin)
	    /* nothing */;
	  else if (dev)
	    bin = O_BINARY;
	  else if (name != unknown_file)
	    bin = fh->pc_binmode ();
d338 7
a344 1
      fh->init (handle, GENERIC_READ | GENERIC_WRITE, bin);
a841 5
#define DEVICE_PREFIX "\\device\\"
#define DEVICE_PREFIX_LEN sizeof (DEVICE_PREFIX) - 1
#define REMOTE "\\Device\\LanmanRedirector\\"
#define REMOTE_LEN sizeof (REMOTE) - 1

d913 1
d923 5
d933 8
d943 11
d955 1
a955 2
  debug_printf ("derived path '%s'", w32);
  cygwin_conv_to_full_posix_path (w32, posix_fn);
@


1.178
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d675 2
a676 2
/* This is not POSIX-compliant. */
#if 0
a683 1
#endif
@


1.177
log
@revert premature checkin
@
text
@d847 1
a847 1
  if (NT_SUCCESS (res))
@


1.176
log
@* dllfixdbg: Eliminate extra objcopy step.
@
text
@a43 11
#define DEVICE_PREFIX "\\device\\"
#define DEVICE_PREFIX_LEN sizeof (DEVICE_PREFIX) - 1
#define REMOTE "\\Device\\LanmanRedirector\\"
#define REMOTE_LEN sizeof (REMOTE) - 1
#define REMOTE1 "\\Device\\WinDfs\\Root\\"
#define REMOTE1_LEN sizeof (REMOTE1) - 1
#define NAMED_PIPE "\\Device\\NamedPipe\\"
#define NAMED_PIPE_LEN sizeof (NAMED_PIPE) - 1
#define POSIX_NAMED_PIPE "/Device/NamedPipe/"
#define POSIX_NAMED_PIPE_LEN sizeof (POSIX_NAMED_PIPE) - 1

d286 1
a286 1
      else if (0 && ft == FILE_TYPE_PIPE)
d300 1
a300 6
	  if (!strncasematch (name, POSIX_NAMED_PIPE, POSIX_NAMED_PIPE_LEN))
	    /* nothing */;
	  else if (fd == 0)
	    dev = *piper_dev;
	  else
	    dev = *pipew_dev;
d311 1
a311 1
	fh = build_fh_dev (dev, name);
d318 1
a318 1
      if (name)
d320 7
a326 7
	  bin = fh->pc_binmode ();
	  if (!bin)
	    {
	      bin = fh->get_default_fmode (O_RDWR);
	      if (!bin && dev)
		bin = O_BINARY;
	    }
d329 1
a329 7
      DWORD access;
      if (fd == 0)
	access = GENERIC_READ;
      else 
	access = GENERIC_WRITE;  /* Should be rdwr for stderr but not sure that's
				    possible for some versions of handles */
      fh->init (handle, access, bin);
d828 5
d847 1
a847 1
  if (!NT_SUCCESS (res))
a903 1
  bool justslash = false;
a912 5
  else if (strncasematch (w32, NAMED_PIPE, NAMED_PIPE_LEN))
    {
      debug_printf ("pipe");
      justslash = true;
    }
a917 8
      justslash = true;
    }
  else if (strncasematch (w32, REMOTE1, REMOTE1_LEN))
    {
      w32 += REMOTE1_LEN - 2;
      *w32 = '\\';
      debug_printf ("remote drive");
      justslash = true;
a919 11
  if (!justslash)
    cygwin_conv_to_full_posix_path (w32, posix_fn);
  else
    {
      char *s, *d;
      for (s = w32, d = posix_fn; *s; s++, d++)
	if (*s == '\\')
	  *d = '/';
	else
	  *d = *s;
    }
d921 2
a922 1
  debug_printf ("derived path '%s', posix '%s'", w32, posix_fn);
@


1.175
log
@Preliminary change to make fifos/pipes interruptible and fifos reliable.
* dtable.cc (dtable::find_fifo): Eliminate definition.
* dtable.h (dtable::find_fifo): Ditto for declaration.
* fhandler.cc (fhandler_base::raw_read): Remove pipe-specific stuff.
(fhandler_base::fhandler_base): Ditto.
(fhandler_base::close): Handle overlapped I/O structure if appropriate.
(fhandler_base::dup): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::setup_overlapped): Define new function.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::get_overlapped): Declare new function.
(fhandler_base::setup_overlapped): Ditto.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_guard): Eliminate.
(fhandler_pipe::*): Rework to eliminate most Win9x related cruft, removing many
variables and defining a new overlapped capability.
(fhandler_fifo::*): Ditto.
(fifo_state): Declare new enum.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove old Win9x stuff.
Initialize overlapped handle to NULL.
(fhandler_fifo::set_use): Eliminate.
(fhandler_fifo::open_nonserver): Define.
(fhandler_fifo::open): Rework to use named pipes and overlapped I/O.
(fhandler_fifo::wait): Define new function to wait for named pipe connection.
(fhandler_fifo::read): Rework to use wait() and new overlapped I/O
functionality.
(fhandler_fifo::write): Ditto.
(fhandler_fifo::dup): Eliminate.
* pinfo.cc (commune_process): Remove fifo handling.
(_pinfo::commune_request): Ditto.
* pinfo.h (picom): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Remove Win9x stuff.  Initialize
overlapped handle to NULL.
(fhandler_pipe::open): Eliminate Win9x stuff.
(fhandler_pipe::set_close_on_exec): Eliminate.
(read_pipe): Eliminate.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::fixup_after_exec): Ditto.
(fhandler_pipe::fixup_in_child): Ditto.
(fhandler_pipe::read): Rework to use overlapped I/O.
(fhandler_pipe::write): New function using overlapped I/O.
(fhandler_pipe::dup): Rework to eliminate Win9x stuff.
(fhandler_pipe::create_selectable): Rework to eliminate Win9x and use
overlapped I/O.
* select.cc (peek_pipe): Rework to eliminate Win9x stuff and use overlapped
I/O.
(fhandler_base::ready_for_read): Ditto.
@
text
@d44 11
d297 1
a297 1
      else if (ft == FILE_TYPE_PIPE)
d311 6
a316 1
	  bin = 0;
d327 1
a327 1
	fh = build_fh_dev (dev);
d334 1
a334 1
      if (!bin)
d336 7
a342 7
	  bin = fh->get_default_fmode (O_RDWR);
	  if (bin)
	    /* nothing */;
	  else if (dev)
	    bin = O_BINARY;
	  else if (name != unknown_file)
	    bin = fh->pc_binmode ();
d345 7
a351 1
      fh->init (handle, GENERIC_READ | GENERIC_WRITE, bin);
a849 5
#define DEVICE_PREFIX "\\device\\"
#define DEVICE_PREFIX_LEN sizeof (DEVICE_PREFIX) - 1
#define REMOTE "\\Device\\LanmanRedirector\\"
#define REMOTE_LEN sizeof (REMOTE) - 1

d864 1
a864 1
  if (NT_SUCCESS (res))
d921 1
d931 5
d941 8
d951 11
d963 1
a963 2
  debug_printf ("derived path '%s'", w32);
  cygwin_conv_to_full_posix_path (w32, posix_fn);
@


1.174
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.
@
text
@a582 18
fhandler_fifo *
dtable::find_fifo (const char *path)
{
  lock ();
  fhandler_fifo *fh_res = NULL;
  for (unsigned i = 0; i < size; i++)
    {
      fhandler_base *fh = fds[i];
      if (fh && fh->isfifo () && strcmp (path, fh->get_win32_name ()) == 0)
	{
	  fh_res = (fhandler_fifo *) fh;
	  break;
	}
    }
  unlock ();
  return fh_res;
}

@


1.173
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procnet.o.
	* autoload.cc (GetAdaptersAddresses): Define.
	* devices.h (FH_PROCNET): Define new device.
	* devices.in (dev_procnet_storage): Add "/proc/net" entry.
	* devices.cc: Regenerate.
	* dir.cc (readdir_worker): Use isproc_dev macro.
	* dtable.cc (build_fh_pc): Add FH_PROCNET.
	* fhandler.h (class fhandler_procnet): New class.
	* fhandler_proc.cc: Add "net" subdirectory handling.
	* fhandler_procnet.cc: New file handling "/proc/net" directory.
	* path.cc (isvirtual_dev): Move to path.h.
	* path.h (isproc_dev): New macro to identify /proc files by device.
	(isvirtual_dev): Moved here.  Define using isproc_dev.
	* syscalls.cc (unlink): Use isproc_dev macro.
	* wincap.h (wincapc::has_gaa_prefixes): New element.
	(wincapc::has_gaa_on_link_prefix): New element.
	* wincap.cc: Implement above elements throughout.
	(wincapc::init): Check XP for service pack and set has_gaa_prefixes
	appropriately.
	* include/cygwin/in6.h: Include asm/byteorder.h.
@
text
@d693 3
d700 1
a700 1
      SetFilePointer (fh->get_handle (), 0, 0, FILE_END);
d702 1
@


1.172
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d464 3
@


1.171
log
@	* devices.h: Add additional SCSI disk block device numbers per
	http://www.kernel.org/pub/linux/docs/device-list/devices.txt
	up to 128 devices.
	* devices.in: Ditto.
	(device::parsedisk): Add additonal else-if cases for decoding base
	and drive indices.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add additional DEV_SD{2..7}_MAJOR cases.
@
text
@d666 8
@


1.170
log
@	* dtable.cc (build_fh_pc): Add missing DEV_SD1_MAJOR case (Thanks to
	Joe Loh for noticing).
@
text
@d387 6
@


1.169
log
@* cygheap.cc (init_cygheap::close_ctty): Remove obsolete code.
* dcrt0.cc (child_info_spawn::handle_spawn): Signal ready after we've run
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Add debugging output.
* fhandler_tty.cc (fhandler_pty_master::doecho): Use class version of
to_master.
(fhandler_tty_common::close): Remove obsolete code.
(fhandler_tty_slave::fixup_after_exec): Don't close, since this is done in
dtable's fixup_after_exec.  (revisit later?)
(fhandler_pty_master::fixup_after_exec): Ditto.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
d386 1
@


1.169.4.1
log
@	* dtable.cc (build_fh_pc): Add missing DEV_SD1_MAJOR case (Thanks to
	Joe Loh for noticing).

	* cygheap.h (struct user_heap_info): Add slop member.
	* heap.cc (heap_init): Add slop factor to heap allocation.  Add
	comment.
	* mmap.cc (MapViewNT): Allocate memory maps top down.
	(fhandler_dev_zero::mmap): Ditto.
	* shared.cc (shared_info::heap_slop_size): New method.
	(shared_info::heap_chunk_size): Don't use debug_printf at early stage.
	* shared_info.h (SHARED_INFO_CB): Accomodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop member.  Declare heap_slop_size.
	* wincap.h: Define heapslop throughout.
	* wincap.cc: Ditto.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
a385 1
    case DEV_SD1_MAJOR:
@


1.169.4.2
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@a659 8
dtable::move_fd (int from, int to)
{
  // close (to); /* It is assumed that this is close-on-exec */
  fds[to] = fds[from];
  fds[from] = NULL;
}

void
@


1.169.4.3
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@a683 3
/* This is not POSIX-compliant. */
#if 0
  LONG off_high = 0;
d688 1
a688 1
      SetFilePointer (fh->get_handle (), 0, &off_high, FILE_END);
a689 1
#endif
@


1.169.4.4
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Reenable.  Fix
	comment.
	* spawn.cc (spawn_guts): Call cygheap->fdtab.set_file_pointers_for_exec
	only for non-Cygwin processes.
@
text
@d684 2
a685 2
/* This is not POSIX-compliant so the function is only called for
   non-Cygwin processes. */
d693 1
@


1.169.4.5
log
@* dtable.cc (dtable::init_std_file_from_handle): Try harder to make a pipe into
a full-cygwin device.
(handle_to_fn): Change \ to / when necessary.
* fhandler.cc (fhandler_base::init): Change bin to mode.
* fhandler.h (fhandler_pipe::init): Declare.
* pipe.cc (fhandler_pipe::init): Define.
(handler_pipe::open): Move initialization code into init.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
a43 11
#define DEVICE_PREFIX "\\device\\"
#define DEVICE_PREFIX_LEN sizeof (DEVICE_PREFIX) - 1
#define REMOTE "\\Device\\LanmanRedirector\\"
#define REMOTE_LEN sizeof (REMOTE) - 1
#define REMOTE1 "\\Device\\WinDfs\\Root\\"
#define REMOTE1_LEN sizeof (REMOTE1) - 1
#define NAMED_PIPE "\\Device\\NamedPipe\\"
#define NAMED_PIPE_LEN sizeof (NAMED_PIPE) - 1
#define POSIX_NAMED_PIPE "/Device/NamedPipe/"
#define POSIX_NAMED_PIPE_LEN sizeof (POSIX_NAMED_PIPE) - 1

d286 7
d300 1
a300 6
	  if (!strncasematch (name, POSIX_NAMED_PIPE, POSIX_NAMED_PIPE_LEN))
	    /* nothing */;
	  else if (fd == 0)
	    dev = *piper_dev;
	  else
	    dev = *pipew_dev;
d311 1
a311 1
	fh = build_fh_dev (dev, name);
d318 1
a318 1
      if (name)
d320 7
a326 7
	  bin = fh->pc_binmode ();
	  if (!bin)
	    {
	      bin = fh->get_default_fmode (O_RDWR);
	      if (!bin && dev)
		bin = O_BINARY;
	    }
d329 1
a329 7
      DWORD access;
      if (fd == 0)
	access = GENERIC_READ;
      else 
	access = GENERIC_WRITE;  /* Should be rdwr for stderr but not sure that's
				    possible for some versions of handles */
      fh->init (handle, access, bin);
d836 5
d855 1
a855 1
  if (!NT_SUCCESS (res))
a911 1
  bool justslash = false;
a920 5
  else if (strncasematch (w32, NAMED_PIPE, NAMED_PIPE_LEN))
    {
      debug_printf ("pipe");
      justslash = true;
    }
a925 8
      justslash = true;
    }
  else if (strncasematch (w32, REMOTE1, REMOTE1_LEN))
    {
      w32 += REMOTE1_LEN - 2;
      *w32 = '\\';
      debug_printf ("remote drive");
      justslash = true;
a927 11
  if (!justslash)
    cygwin_conv_to_full_posix_path (w32, posix_fn);
  else
    {
      char *s, *d;
      for (s = w32, d = posix_fn; *s; s++, d++)
	if (*s == '\\')
	  *d = '/';
	else
	  *d = *s;
    }
d929 2
a930 1
  debug_printf ("derived path '%s', posix '%s'", w32, posix_fn);
@


1.169.4.6
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set access to
	read/write if handle is connected to a tty or console.
	* fhandler_dsp.cc (fhandler_dev_dsp::dup): Set open flags correctly
	after duplicating from archetype.
	* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
	(fhandler_pty_master::dup): Ditto.
@
text
@d339 1
a339 3
      if (dev == FH_TTY || dev == FH_CONSOLE) 
	access = GENERIC_READ | GENERIC_WRITE;
      else if (fd == 0)
@


1.169.4.7
log
@	* dtable.cc (dtable::init_std_file_from_handle): Fix pipe related test.
@
text
@d304 1
a304 1
	  if (ft != FILE_TYPE_PIPE)
@


1.168
log
@* debug.cc (add_handle): Print handle value when collision detected.
* dtable.cc (dtable::stdio_init): Cosmetic change.
* fhandler.h (fhandler_base::create_read_state): Protect handle.
(fhandler_pipe::create_guard): Ditto.  Always mark the handle as inheritable.
(fhandler_pipe::is_slow): Return boolean value rather than numeric 1.
* pipe.cc (fhandler_pipe::fhandler_pipe): Always flag that we need fork fixup.
(fhandler_pipe::open): Don't pass security attributes to create_guard.
(fhandler_pipe::set_close_on_exec): Don't handle guard here.
(fhandler_pipe::close): Accommodate now-protected guard handle.
(fhandler_pipe::fixup_in_child): Don't proected read_state here.
(fhandler_pipe::fixup_after_exec): Close guard handle if close_on_exec.
(fhandler_pipe::fixup_after_fork): Don't bother with guard here.
(fhandler_pipe::dup): Don't set res to non-error prematurely.  Use boolean
values where appropriate.  Protect guard and read_state.
(fhandler_pipe::create): Don't call need_fork_fixup since it is now the
default.  Don't protect read_state or guard.
* pipe.cc (fhandler_base::ready_for_read): Use bool values for "avail".
* spawn.cc (spawn_guts): Set cygheap->pid_handle as inheritable when
protecting.
* select.cc (fhandler_pipe::ready_for_read): Actually get the guard mutex for
blocking reads.
@
text
@d696 4
a699 1
	      fh->close ();
@


1.167
log
@* tty.h (tty::hwnd): Move to tty_min.
(tty::gethwnd): Ditto.
(tty::sethwnd): Ditto.
(tty_min::hwnd): Receive variable from tty class.
(tty_min::gethwnd): Receive function from tty classs.
(tty_min::sethwnd): Ditto.
* dtable.cc (dtable::stdio_init): Only call init_console_handler when we
actually own the console.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Set tty's hwnd to
non-zero value.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Semi-reinstate handling of
console when pgrp is set.
@
text
@d157 2
a158 2
      if (!DuplicateHandle (hMainProc, out, hMainProc, &err, 0,
			     1, DUPLICATE_SAME_ACCESS))
@


1.166
log
@* dcrt0.cc (child_info_spawn::handle_spawn): Don't initialize the console
handler here.
* dtable.cc (dtable::stdio_init): Initialize console handler here.
@
text
@d35 1
a35 1
#include "tty.h"
d138 3
a140 1
      init_console_handler (myself->ctty >= 0);
@


1.165
log
@	* autoload.cc (LoadDLLfuncNt): New define to wrap NT native functions.
	Use for NT native functions throughout.
	* dtable.cc (handle_to_fn): Treate return value of NtQueryObject as
	NTSTATUS value.
@
text
@d137 4
a140 1
    return;
@


1.164
log
@	* dtable.cc (handle_to_fn): Accomodate new argument order in call to
	sys_wcstombs.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Call sys_wcstombs
	instead of just wcstombs to accomodate OEM codepages.
	* miscfuncs.cc (sys_wcstombs): Split len argument in source and target
	length.  Always 0-terminate result in target string.
	* security.cc (lsa2wchar): Remove unused function.
	(lsa2str): Ditto.
	(get_lsa_srv_inf): Ditto.
	(get_logon_server): Accomodate new argument order in call to
	sys_wcstombs.
	(get_user_groups): Ditto.
	(get_user_local_groups): Ditto.
	(get_priv_list): Call sys_wcstombs directly instead of lsa2str.
	* uinfo.cc (cygheap_user::ontherange): Accomodate new argument order
	in call to sys_wcstombs.
	* winsup.h (sys_wcstombs): Change prototype to match new argument order.
@
text
@d832 2
a833 1
  DWORD res = NtQueryObject (h, ObjectNameInformation, ntfn, sizeof (fnbuf), NULL);
d835 1
a835 1
  if (res)
@


1.163
log
@* fhandler.h (fhandler_pipe::fixup_in_child): Declare new function.
(fhandler_console::invisible_console): Declare new variable.
(fhandler_console::need_invisible): Ditto.
(fhandler_console::has_a): Ditto.
* fhandler_console.cc (set_console_state_for_spawn): Eliminate return value.
Set up an invisible console if necessary prior to spawning.
(fhandler_console::invisible_console): Define.
* fhandler_tty.cc (fhandler_tty_slave::open): Use
fhandler_console::invisible_console to setup an invisible console.
* pipe.cc (fhandler_pipe::fixup_in_child): Define new function from
fixup_after_exec.
(fhandler_pipe::fixup_after_exec): Use fixup_in_child when appropriate.
(fhandler_pipe::fixup_after_fork): Ditto.
* spawn.cc (handle): Reorganize and modernize a little.
(spawn_guts): Rely on set_console_state_for_spawn to set the console into the
right state but don't create the process with "detached" flag if we have no
controlling tty since that confuses 'cmd'.
* dtable.cc (dtable::stdio_init): Don't set console as controlling terminal if
we have an invisible console.
* sigproc.cc (child_info::sync): Use correct name in ForceCloseHandle1.
@
text
@d851 1
a851 1
  sys_wcstombs (win32_fn, ntfn->Name.Buffer, ntfn->Name.Length);
@


1.162
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d163 1
d166 1
a166 1
  if (myself->ctty < 0 && GetConsoleCP () > 0)
@


1.161
log
@* cygheap.h (cygheap_fdenum::cygheap_fdenum): Record locked state or suffer
deadlocks.
(class locked_process): Move to another header.
* sync.h (lock_process): Define here.
* cygtls.cc (_cygtls::fixup_after_fork): Reset spinning state as well as
stacklock state.
* dcrt0.cc (lock_process::locker): Define.
(dtable::lock_cs): Delete.
* dtable.cc (dtable_init): Eliminate call to init_lock().
(dtable::fixup_after_fork): Ditto.
(dtable::init_lock): Delete definition.
* dtable.h (dtable::init_lock): Delete declaration.
(dtable::lock): Use process lock rather than dtable-specific lock.
(dtable::unlock): Ditto.
* sigproc.cc (sigproc_init): Minor change to debugging output.
* times.cc (utime_worker): Use build_fh_pc rather than reinterpreting the posix
path name again.  Return any error from path_conv immediately.
@
text
@d686 1
d693 4
a696 8
	else
	  {
	    fh->fixup_after_exec ();
	    if (i == 0)
	      SetStdHandle (std_consts[i], fh->get_io_handle ());
	    else if (i <= 2)
	      SetStdHandle (std_consts[i], fh->get_output_handle ());
	  }
d733 1
a733 1
      cygheap->open_fhs++;
@


1.160
log
@	Revert erroneous checkin.
@
text
@a49 2
  cygheap->fdtab.init_lock ();

a60 6
void
dtable::init_lock ()
{
  lock_cs.init ("lock_cs");
}

a681 1
  cygheap->fdtab.init_lock ();
a706 1
  cygheap->fdtab.init_lock ();
@


1.159
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d337 1
a337 1
#define cnew(name) new ((void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_union))) name
d498 1
a498 1
      if (oldfh->dup (newfh, hMainProc))
@


1.158
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@d337 1
a337 1
#define cnew(name) new ((void *) ccalloc (HEAP_FHANDLER, 1, sizeof (name))) name
d498 1
a498 1
      if (oldfh->dup (newfh))
@


1.157
log
@* cygwin.sc: Use simpler method to align .cygheap.
* dllfixdbg: Just copy .stab and .stabstr sections when making cygwin1.dbg,
rather than relying on objcopy to keep only the debug sections since objcopy
seems to get it wrong.
* dtable.cc (build_fh_pc): Check setting fh to fhandler_nodevice for NULL, too.
@
text
@a790 2

  return;
a824 2

  return;
@


1.156
log
@* Makefile.in (dtable_CFLAGS): Use -fomit-frame-pointer and -fcheck-new.
* cygheap.cc (cmalloc): Only emit system_printf warnings on failure if
DEBUGGING.
(crealloc): Ditto.
(ccalloc): Ditto.
* dtable.cc (build_fh_name): Treat NULL return from cnew as indicative of
EMFILE condition.
(build_fh_dev): Ditto.
(dtable::dup_worker): Handle NULL return from build_fh_pc.
(dtable::vfork_child_dup): Trust dup_worker to set errno.
* fhandler.h (fhandler_base::new): Mark as nothrow.
@
text
@d476 6
a481 1
  if (!fh)
a482 6
  else
    {
      if (fh == fh_unset)
	fh = cnew (fhandler_nodevice) ();
      fh->set_name (pc);
    }
@


1.155
log
@fix indentation
@
text
@d345 3
a347 2
      fh->set_error (pc.error);
      set_errno (pc.error);
d368 1
d372 1
a372 1
  fhandler_base *fh = NULL;
d477 7
a483 3
    fh = cnew (fhandler_nodevice) ();

  fh->set_name (pc);
d493 3
a495 3
  *newfh = *oldfh;
  newfh->set_io_handle (NULL);
  if (oldfh->dup (newfh))
d497 12
a508 3
      cfree (newfh);
      newfh = NULL;
      return NULL;
a509 4

  newfh->close_on_exec (false);
  MALLOC_CHECK;
  debug_printf ("duped '%s' old %p, new %p", oldfh->get_name (), oldfh->get_io_handle (), newfh->get_io_handle ());
a758 1
	set_errno (EBADF);
@


1.154
log
@Revert 2005-05-30 close_all_files changes.
* spawn.cc (spawn_guts): When execing, close all files after the child has
synced with us.
@
text
@d372 89
a460 24
    switch (pc.dev.major)
      {
      case DEV_TTYS_MAJOR:
	fh = cnew (fhandler_tty_slave) ();
	break;
      case DEV_TTYM_MAJOR:
	fh = cnew (fhandler_tty_master) ();
	break;
      case DEV_CYGDRIVE_MAJOR:
	fh = cnew (fhandler_cygdrive) ();
	break;
      case DEV_FLOPPY_MAJOR:
      case DEV_CDROM_MAJOR:
      case DEV_SD_MAJOR:
	fh = cnew (fhandler_dev_floppy) ();
	break;
      case DEV_TAPE_MAJOR:
	fh = cnew (fhandler_dev_tape) ();
	break;
      case DEV_SERIAL_MAJOR:
	fh = cnew (fhandler_serial) ();
	break;
      default:
	switch (pc.dev)
d462 4
a465 4
	  case FH_CONSOLE:
	  case FH_CONIN:
	  case FH_CONOUT:
	    fh = cnew (fhandler_console) ();
d467 4
a470 70
	  case FH_PTYM:
	    fh = cnew (fhandler_pty_master) ();
	    break;
	  case FH_WINDOWS:
	    fh = cnew (fhandler_windows) ();
	    break;
	  case FH_FIFO:
	    fh = cnew (fhandler_fifo) ();
	    break;
	  case FH_PIPE:
	  case FH_PIPER:
	  case FH_PIPEW:
	    fh = cnew (fhandler_pipe) ();
	    break;
	  case FH_TCP:
	  case FH_UDP:
	  case FH_ICMP:
	  case FH_UNIX:
	  case FH_STREAM:
	  case FH_DGRAM:
	    fh = cnew (fhandler_socket) ();
	    break;
	  case FH_FS:
	    fh = cnew (fhandler_disk_file) ();
	    break;
	  case FH_NULL:
	    fh = cnew (fhandler_dev_null) ();
	    break;
	  case FH_ZERO:
	  case FH_FULL:
	    fh = cnew (fhandler_dev_zero) ();
	    break;
	  case FH_RANDOM:
	  case FH_URANDOM:
	    fh = cnew (fhandler_dev_random) ();
	    break;
	  case FH_MEM:
	  case FH_PORT:
	    fh = cnew (fhandler_dev_mem) ();
	    break;
	  case FH_CLIPBOARD:
	    fh = cnew (fhandler_dev_clipboard) ();
	    break;
	  case FH_OSS_DSP:
	    fh = cnew (fhandler_dev_dsp) ();
	    break;
	  case FH_PROC:
	    fh = cnew (fhandler_proc) ();
	    break;
	  case FH_REGISTRY:
	    fh = cnew (fhandler_registry) ();
	    break;
	  case FH_PROCESS:
	    fh = cnew (fhandler_process) ();
	    break;
	  case FH_NETDRIVE:
	    fh = cnew (fhandler_netdrive) ();
	    break;
	  case FH_TTY:
	    {
	      if (myself->ctty == TTY_CONSOLE)
		fh = cnew (fhandler_console) ();
	      else if (myself->ctty >= 0)
		fh = cnew (fhandler_tty_slave) ();
	      break;
	    }
	  case FH_KMSG:
	    fh = cnew (fhandler_mailslot) ();
	    break;
	}
d472 1
@


1.153
log
@* child_info.h (child_info::cygheap_h): Delete.
(child_info::dwProcessId): New field.
* cygheap.cc (init_cheap): Delete.
(dup_now): Ditto.
(cygheap_setup_for_child): Ditto.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_fixup_in_child): Simplify.  Use new "child_copy" function to copy heap
from parent.
(_csbrk): Don't attempt allocation if within cygheap section.  Fix so that more
than one allocation will succeed.
(cygheap_init): Reset possibly-nonzero region to zero.
* cygheap.h (cygheap_setup_for_child): Delete declaration.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_start): Define as an array.
* cygwin.sc: Modernize.  Remove unneeded sections.  Define cygheap here.
* dcrt0.cc (do_exit): Reflect argument change to close_all_files.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* fork.cc (fork_copy): Call ReadProcessMemory if there is no thread
(indicating that we're execing).
(fork_child): Don't mess with hParent.
(fork_parent): Remove hParent stuff.  It happens earlier now.  Remove call to
cygheap_setup_for_child* stuff.
(fork): Put child_info_stuff in grouped structure.  Issue error if parent
handle is not set.
(child_copy): New function.
* sigproc.cc (child_info::child_info): Put cygheap settings here.  Set parent
handle.
(child_info::~child_info): Close parent handle if it exists.
* spawn.cc (spawn_guts): Reorganize so that ciresrv is allocated at only the
last minute so that cygheap changes are reflected.  Delete cygheap_setup*
calls.
* syscalls.cc (close_all_files): Add an argument to flag when the fd entry
should be released.
* winsup.h (close_all_files): Add an argument to close_all_files declaration.
Declare child_copy.
@
text
@d769 1
a769 1
  close_all_files (false);
@


1.152
log
@Remove PC_FULL from path_conv usage throughout.
* path.h (enum pathconv_arg): Change PC_FULL to PC_NOUILL.
* path.cc (path_conv::check): Test for PC_NOFULL rather than !PC_FULL.
(cygwin_conv_to_win32_path): Use PC_NOFULL to force non-absolute path.
@
text
@d769 1
a769 1
  close_all_files ();
@


1.151
log
@	* Makefile.in (DLL_OFILES): Add fhandler_mailslot.o.
	* devices.h (FH_KMSG): Define new device.
	* devices.in: Add "/dev/kmsg" entry.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Handle case FH_KMSG.
	* fhandler.h (class fhandler_mailslot): New class.
	(class select_stuff): Add device_specific_mailslot pointer.
	* fhandler_mailslot.cc: New file.
	* select.cc (peek_mailslot): New function.
	(verify_mailslot): Ditto.
	(struct mailslotinf): New stuct to handle select on mailslots.
	(thread_mailslot): New function.
	(start_thread_mailslot): Ditto.
	(mailslot_cleanup): Ditto.
	(fhandler_mailslot::select_read): New method.
	* syslog.cc (klog_guard): New muto.
	(dev_kmsg): Local mailslot for kernel message device.
	(vklog): New function.
	(klog): Ditto.
	* winsup.h (vklog): Declare.
	(klog): Ditto.
	* include/sys/syslog.h: Define _PATH_KLOG.
@
text
@d341 1
a341 1
  path_conv pc (name, opt | PC_NULLEMPTY | PC_FULL | PC_POSIX, si);
@


1.150
log
@2005-05-09  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.h (class fhandler_netdrive): New class.
        * fhandler_netdrive.cc (fhandler_netdrive::fhandler_netdrive): New constructor.
        (fhandler_netdrive::exists): New method.
        (fhandler_netdrive::fstat): Ditto.
        (fhandler_netdrive::readdir): Ditto.
        (fhandler_netdrive::open): Ditto.
        * dtable.cc (build_fh_pc): Handle case FH_NETDRIVE.
        * path.cc (isvirtual_dev): Add FH_NETDRIVE.
        (mount_info::conv_to_win32_path): Detect netdrive device and bypass mount
        search for network paths.
@
text
@d468 3
@


1.149
log
@* sync.h (muto::operator int): New operator.
(locker): Remove unused class.
(new_muto): Delete.
(new_muto1): Ditto.
(new_muto_name): Ditto.
* cygheap.cc (cygheap_setup_for_child): Reflect use of static storage for muto
rather than pointer.
(_csbrk): Ditto.
(_cmalloc): Ditto.
(_cmalloc): Ditto.
(_cfree): Ditto.
* cygheap.h (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_drive): Ditto.
* cygmalloc.h (__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* cygtls.cc (sentry::lock): Ditto.
(sentry::sentry): Ditto.
(~sentry): Ditto.
(_cygtls::init): Ditto.
* dcrt0.cc: Ditto.
(cygwin_atexit): Ditto.
(cygwin_exit): Ditto.
* debug.cc (lock_debug::locker): Ditto.
(lock_debug::lock_debug): Ditto.
(lock_debug::unlock): Ditto.
(debug_init): Ditto.
* dtable.cc (dtable::init_lock): Ditto.
* dtable.h (dtable::lock_cs): Ditto.
(dtable::lock): Ditto.
(dtable::unlock): Ditto.
* exceptions.cc (mask_sync): Ditto.
(sighold): Ditto.
(set_process_mask_delta): Ditto.
(set_signal_mask): Ditto.
(events_init): Ditto.
* grp.cc (pwdgrp::pwdgrp): Ditto.
* malloc_wrapper.cc (mallock): Ditto.
(malloc_init): Ditto.
* path.cc (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::init): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* pwdgrp.h (pwdgrp::pglock): Ditto.
(pwdgrp::refresh): Ditto.
* sigproc.cc (sync_proc_subproc): Ditto.
(get_proc_lock): Ditto.
(proc_subproc): Ditto.
(_cygtls::remove_wq): Ditto.
(proc_terminate): Ditto.
(sigproc_init): Ditto.
* timer.cc (lock_timer_tracker::protect): Ditto.
(lock_timer_tracker::lock_timer_tracker): Ditto.
(lock_timer_tracker::~lock_timer_tracker): Ditto.
* wininfo.cc (wininfo::_lock;): Ditto.
(wininfo::winthread): Ditto.
(operator HWND): Ditto.
(wininfo::lock): Ditto.
(wininfo::release): Ditto.
* wininfo.h (wininfo::_lock;): Ditto.
@
text
@d457 3
@


1.148
log
@	* devices.h: Switch FH_ZERO and FH_PORT as on Linux.  Add FH_FULL.
	* devices.in: Add /dev/full.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add FH_FULL.
	* fhandler.cc (fhandler_base::fstat): Set FH_FULL permission bits
	correctly.
	* fhandler_zero.cc (fhandler_dev_zero::write): Set errno to ENOSPC
	and return -1 if device is FH_FULL.
@
text
@d66 1
a66 1
  new_muto (lock_cs);
@


1.147
log
@copyright
@
text
@d431 1
@


1.146
log
@* cygthread.cc (cygthread::terminate_thread): Wait briefly for notification
event in the event that the thread was actually in the process of exiting.
* pipe.cc (fhandler_pipe::dup): read_state is not supposed to be inheritable.
Fix that.
* path.cc (path_conv::check): Set symlen = 0 to avoid a compiler warning.
* devices.h (devices::parsedisk): Declare new function.
* devices.in (devices::parsedisk): Define new function.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
name.
* fhandler_proc.cc (format_proc_partitions): Use parsedisk to generate disk
names from numeric codes.  (This was broken on two of my systems previously and
is still broken now)
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.145
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d276 1
a276 1
	    dev.parse ("/dev/tty");
d283 1
a283 1
	    dev.parse ("/dev/tty");
d297 1
a297 1
	dev.parse ("/dev/ttyS0");
@


1.144
log
@* path.h (path_conv::set_normalized_path): Add second argument and fill it in
throughout.
* path.cc (path_conv::check): Declare, set and use "strip_tail".
(path_conv::set_normalized_path): Add and use second argument, replacing all
tail stripping tests.
@
text
@d587 1
a587 1
  s->saw_error = 0;
d604 1
a604 1
  s->saw_error = 0;
d621 1
a621 1
  s->saw_error = 0;
@


1.143
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d360 1
a360 1
    pc.set_normalized_path (unix_name);
d362 1
a362 1
    pc.set_normalized_path (dev.name);
@


1.142
log
@	* dtable.cc (dtable::get_debugger_info): Make stderr r/w according
	to SUSv3.
@
text
@d143 1
a143 1
  if (myself->ppid_handle || ISSTATE (myself, PID_CYGPARENT))
@


1.142.2.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@d143 1
a143 1
  if (myself->cygstarted || ISSTATE (myself, PID_CYGPARENT))
@


1.141
log
@* dtable.cc (dtable::find_fifo): Release lock after fifo found (still racy).
* fhandler.h (fhandler_fifo::get_io_handle): New fifo-specific method.
* fhandler_fifo.cc (fhandler_fifo::close): Close output_handle only if it is
open.
(fhandler_fifo::open_not_mine): Reorganize slightly.  Don't call _pinfo methods
when the fifo is owned by me or suffer dtable lock_cs deadlock.
(fhandler_fifo::open): Call open_not_mine first, otherwise open myself
(racy).
* pinfo.cc (_pinfo::commune_recv): Duplicate fifo handles here in requesting
processes arena to avoid one potential race (of many).
(_pinfo::commune_send): Move all PICOM_FIFO code under one case statement.
* thread.cc (pthread::init_mainthread) Use existing hMainProc handle rather
than calling GetCurrentProcess.
@
text
@d122 2
a123 1
	    if (!fh->open ((i ? O_WRONLY : O_RDONLY) | O_BINARY, 0777))
@


1.140
log
@* dtable.cc (dtable::extend): Change order of memcpy and cfree.
@
text
@d560 1
d565 4
a568 1
	return (fhandler_fifo *) fh;
d570 2
a571 1
  return NULL;
@


1.139
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d94 1
a95 1
      memcpy (newfds, fds, size * sizeof (fds[0]));
@


1.138
log
@* cygheap.cc (init_cheap): Add ability to specify minimal cygwin heap size when
debugging.
(_csbrk): Report error in allocation to stderr.
(ccalloc): Ditto.
* dtable.cc (dtable::find_fifo): Remove use of atoms.
* dtable.h (dtable::find_fifo): Ditto.
* fhandler.h (fhandler_fifo): Ditto.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Ditto.
(fhandler_fifo::set_use): Ditto.
(fhandler_fifo::open_not_mine): Ditto.
(fhandler_fifo::open): Ditto.
* pinfo.cc (_pinfo::commune_recv): Ditto.
(_pinfo::commune_send): Ditto.
@
text
@d487 1
a487 1
  newfh->set_close_on_exec_flag (0);
d642 1
a642 1
    if ((fh = fds[i]) != NULL && !fh->get_close_on_exec ())
d671 1
a671 1
	if (fh->get_close_on_exec ())
d696 1
a696 1
	if (fh->get_close_on_exec () || fh->get_need_fork_fixup ())
d730 1
a730 1
      newtable[i]->set_close_on_exec (fds[i]->get_close_on_exec ());
d786 1
a786 1
	if (!fh->archetype && fh->get_close_on_exec ())
@


1.137
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d557 1
a557 1
dtable::find_fifo (ATOM hill)
d563 1
a563 1
      if (fh && fh->isfifo () && ((fhandler_fifo *) fh)->get_atom () == hill)
@


1.136
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.135
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d662 1
a662 1
dtable::fixup_after_exec (HANDLE parent)
d679 1
a679 1
	    fh->fixup_after_exec (parent);
@


1.134
log
@* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
@
text
@d708 1
d807 1
@


1.134.4.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a707 1
#ifdef NEWVFORK
a805 1
#endif /*NEWVFORK*/
@


1.133
log
@* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@d761 5
a765 3
  cygheap->ctty = ctty_on_hold;			// revert
  if (cygheap->ctty)
    cygheap->ctty->close ();			// Undo previous bump of this archetype
@


1.132
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d753 1
d761 1
a761 1
  cygheap->ctty = cygheap->ctty_on_hold;	// revert
@


1.131
log
@* cygheap.h (init_cygheap): Play more vfork shell games and move ctty_on_hold
and open_fhs_on_hold (back) here.
* dcrt0.cc (_dll_crt0): Just set impure_ptr_ptr here and let later
initialization deal with tls.
* dtable.cc (dtable::vfork_child_fixup): Move ctty considerations here.
(dtable:vfork_parent_restore): And here.
* fork.cc (vfork): Reflect change to ctty handling.
* perthread.h (vfork_save::fhctty): Eliminate.
* cygwin.din: Make more exports NOSIGFE that will never be interrupted by a
signal.
* init.cc (dll_entry): Set stackptr to NULL to catch problems earlier.
@
text
@d36 2
a42 2
static const char NO_COPY unknown_file[] = "some disk file";

d45 1
a45 1
dtable_init (void)
d49 2
d62 6
d501 1
a501 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d550 1
a550 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d559 1
a559 1
  SetResourceLock (LOCK_FD_LIST, READ_LOCK, "dup");
d625 1
a625 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fixup_before_fork");
d633 1
a633 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fixup_before_fork");
d639 1
a639 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fixup_before_exec");
d647 1
a647 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fixup_before_exec");
d653 1
a653 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "set_file_pointers_for_exec");
d658 1
a658 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fixup_before_exec");
d666 1
d692 1
d712 1
a712 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d744 1
a744 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d751 1
a751 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "restore");
d758 1
a758 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "restore");
@


1.131.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d45 1
a45 1
dtable_init ()
a48 2
  cygheap->fdtab.init_lock ();

d493 1
a493 1
  lock ();
d542 1
a542 1
  unlock ();
d551 1
a551 1
  lock ();
d617 1
a617 1
  lock ();
d625 1
a625 1
  unlock ();
d631 1
a631 1
  lock ();
d639 1
a639 1
  unlock ();
d645 1
a645 1
  lock ();
d650 1
a650 1
  unlock ();
a657 1
  cygheap->fdtab.init_lock ();
a682 1
  cygheap->fdtab.init_lock ();
d702 1
a702 1
  lock ();
d734 1
a734 1
  unlock ();
d741 1
a741 1
  lock ();
d748 1
a748 1
  unlock ();
@


1.131.2.2
log
@* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
@
text
@a35 2
static const char NO_COPY unknown_file[] = "some disk file";

d41 2
a59 7
}

void
dtable::init_lock ()
{
  new_muto (lock_cs);
  // InitializeCriticalSection (&lock_cs);
@


1.131.2.3
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@d66 1
a753 1
  fhandler_tty_slave *ctty_on_hold = cygheap->ctty_on_hold;
d761 1
a761 1
  cygheap->ctty = ctty_on_hold;			// revert
@


1.131.2.4
log
@* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
@
text
@d761 3
a763 5
  if (cygheap->ctty != ctty_on_hold)
    {
      cygheap->ctty = ctty_on_hold;		// revert
      cygheap->ctty->close ();			// Undo previous bump of this archetype
    }
@


1.130
log
@Move open_fhs from fhandler.h to cygheap.h for easier tracking.  Accommodate
this change throughout.
* dtable.cc (dtable::add_archetype): Use correct count when iterating through
*active* archetypes.
* dtable.cc (dtable::fixup_after_exec): Close handle if close_on_exec and
archetype exists since archetype currently does not set windows close-on-exec
flag (FIXME).
* fhandler_tty.cc (fhandler_tty_slave::open): Change debugging output slightly.
(fhandler_tty_slave::close): Ditto.
(fhandler_tty_slave::fixup_after_fork): Just report on inherited use counts
since since archetype currently does not set windows close-on-exec flag
(FIXME).
* pinfo.cc (_pinfo::set_ctty): Change debugging output slightly.
* cygheap.cc (cygheap_init): Remove open_fhs accommodation and use count
reporting.
* perthread.h (vfork_save::fhctty): New element.
* perthread.h (vfork_save::open_fhs): New element.
* fork.cc (vfork): Muck around with ctty and open_fhs stuff, both of which are
now saved in the vfork_save structure.
@
text
@d748 6
a754 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "restore");
d784 6
@


1.129
log
@* fhandler.h (fhandler_tty_slave::archetype): Make public.
(report_tty_counts): New macro.  Use throughout for reporting tty use counts.
* dtable.cc (dtable::vfork_child_dup): Add debugging output for usecount
increment.  Increment open_fhs if appropriate.
(dtable::vfork_parent_restore): "Close" artificially bumped ctty.
(dtable::vfork_child_fixup): Close ctty since it was bumped prior to vfork.
Save open_fhs around close since the closing of these handles has no effect on
the console.
* fhandler_tty.cc (fhandler_tty_slave::open): Reorganize calls to allow for
easier tracking of usecount modification.
(fhandler_tty_slave::open): Ditto.
@
text
@d189 1
a189 1
  for (unsigned i = 0; i < narchetypes; i++)
d192 1
a192 1
	debug_printf ("deleting archive element %d for %s", i, fh->get_name ());
d663 5
a667 1
	  release (i);
d711 1
a711 1
      fhandler_console::open_fhs++;
a748 3
  if (cygheap->ctty)
    cygheap->ctty->close ();

a761 1
  int old_open_fhs = fhandler_console::open_fhs;
a774 4

  fhandler_console::open_fhs = old_open_fhs;
  if (cygheap->ctty)
    cygheap->ctty->close ();
@


1.128
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d34 1
d705 5
a709 1
    cygheap->ctty->usecount++;
d745 3
d761 1
d775 4
@


1.127
log
@* dtable.cc (dtable::delete_archetype): Add debugging.
(dtable::release): Move archetype deletion here.
(dtable::vfork_child_dup): Increment ctty usecount to catch later
close_all_files case in parent/child.
(dtable::vfork_child_fixup): Avoid using cygheap->foo where this should really
be using local references.  Call close on archetyped handles since the handles
haven't had the noninherit flag set.
* fhandler_tty.cc (fhandler_tty_slave::close): Remove archetype deletion code.
Add defensive error message when DEBUGGING.
(fhandler_tty_common::set_close_on_exec): Use more robust method for checking
whether to set handles into noninherit if there is an archetype associated with
the fhandler.
@
text
@a202 1
  AssertResourceOwner (LOCK_FD_LIST, READ_LOCK);
@


1.126
log
@* cygheap.h (cygheap_types): Add HEAP_ARCHETYPES.
(init_cheap::ctty): Change to pointer.
* dtable.h (dtable::find_archetype): Declare new function.
(dtable::add_archetype): Declare new function.
(dtable::delete_archetype): Declare new function.
(dtable::narchetypes): Declare.
(dtable::farchetypes): Declare.
(dtable::initial_archetype_size): Declare.
(dtable::dtable): Initialize new fields.
(dtable::initial_archetype_size): Declare.
* dtable.cc (dtable::find_archetype): Define new function.
(dtable::add_archetype): Define new function.
(dtable::delete_archetype): Define new function.
(dtable::initial_archetype_size): Define.
* fhandler.h (fhandler_base::archetype): Declare.
(fhandler_base::usecount): Declare.
* fhandler.cc (fhandler_base::fhandler_base): Initialize new fields.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass NULL to third
argument of set_ctty.
* fhandler_tty.cc (fhandler_tty_slave::open): Accommodate new archetype method
to create only one instance of a tty.
(fhandler_tty_slave::close): Don't close handles unless archetype usecount is
zero.  When that happens, close archetype too.
(fhandler_tty_slave::dup): Just copy archetype.  Set use count appropriately.
Set ctty, if appropriate.
(fhandler_tty_common::dup): Remove slave considerations.
(fhandler_tty_common::set_close_on_exec): Remove cygheap->ctty considerations.
* pinfo.cc (_pinfo::set_ctty): Accommodate new archetype methods.
* pinfo.h (_pinfo::set_ctty): Make third argument explicit.
* syscalls.cc (close_all_files): Decrement controlling tty use count before
closing all handles to allow controlling tty to be closed.  Remove previous
controlling tty considerations.
@
text
@d191 1
d222 1
d224 2
d704 2
d755 2
a756 2
  for (int i = 0; i < (int) cygheap->fdtab.size; i++)
    if ((fh = cygheap->fdtab[i]) != NULL)
d759 1
a759 1
	if (fh->get_close_on_exec ())
d764 1
a764 1
	    cygheap->fdtab.release (i);
@


1.125
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d166 33
@


1.124
log
@* dtable.cc (build_fh_name): Set error in dummy fhandler when one is noted
during path_conv.
* fhandler.h (fhandler_base::set_error): New method.
@
text
@d411 5
a415 11
	      device newdev = pc.dev;
	      newdev.tty_to_real_device ();
	      switch (newdev)
		{
		case FH_CONSOLE:
		  fh = cnew (fhandler_console) ();
		  break;
		case FH_TTYS:
		  fh = cnew (fhandler_tty_slave) ();
		  break;
		}
@


1.123
log
@white space
@
text
@d297 2
d300 1
a300 1
      return cnew (fhandler_nodevice) ();
@


1.122
log
@	* dtable.cc (build_fh_pc): Resurrect accidentally removed
	DEV_CYGDRIVE_MAJOR case.
@
text
@d332 1
a332 1
        fh = cnew (fhandler_cygdrive) ();
@


1.121
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d331 3
@


1.120
log
@* dtable.cc (build_fh_pc): Use DEV_SERIAL_MAJOR to catch all serial ports.
Remove redundant FH_CYGDRIVE case since it is handled by DEV_CYGDRIVE_MAJOR.
@
text
@d254 1
a254 1
	  name = handle_to_fn (handle, (char *) alloca (MAX_PATH + 100));
d771 1
a771 1
  char win32_fn[MAX_PATH + 100];
d785 2
a786 2
      char device[MAX_PATH + 10];
      device[MAX_PATH + 9] = '\0';
@


1.119
log
@* Makefile.in: Add YA method for generating devices.cc.
* child_info.h: YA update of another magic number.
* gendevices: New file.
* devices.in: New file.
* devices.cc: Regenerate.
* devices.shilka: Remove.
* devices.h: Correctly define device pointers.
(device): Remove now obsolete fields.
(device::native): Renamed from device::fmt.
* dtable.cc (build_fh_dev): Simplify in light of new unit parsing scheme.
(build_fh_pc): Ditto.
* path.cc (win32_device_name): Ditto.
* fhandler.h (fhandler_base::get_native_name): Reflect renaming of fmt to
native.
* fhandler_tty.cc (fhandler_tty_mster::init): Initialize slave device prior to
reporting unit.
@
text
@a330 3
      case DEV_CYGDRIVE_MAJOR:
	fh = cnew (fhandler_cygdrive) ();
	break;
d339 3
a349 3
	  case FH_CYGDRIVE:
	    fh = cnew (fhandler_cygdrive) ();
	    break;
a354 3
	    break;
	  case FH_SERIAL:
	    fh = cnew (fhandler_serial) ();
@


1.118
log
@	* devices.h (enum fh_devices): Remove DEV_RAWDRIVE_MAJOR and
	FH_RAWDRIVE.
	* devices.shilka (dev_rawdrive_storage): Remove.
	(unit_devices): Remove pointer to dev_rawdrive_storage.
	(uniq_devices): Remove rawdrive entry.
	* dtable.cc (build_fh_pc): Remove DEV_RAWDRIVE_MAJOR case.
	* path.cc (win32_device_name): ditto.
@
text
@a310 3
  char *w32buf = const_cast<char *> (pc.get_win32 ());

  __small_sprintf (w32buf, dev.fmt, dev.minor);
d313 1
a313 1
  else if (!dev.upper)
a314 8
  else
    {
      pc.set_normalized_path (w32buf);
      for (char *p = strchr (pc.normalized_path, '\\');
	   p;
	   p = strchr (p + 1, '\\'))
	*p = '/';
    }
a322 1
  if (pc.dev.upper)
d342 69
a410 74
      }
  else
    switch (pc.dev)
      {
      case FH_CONSOLE:
      case FH_CONIN:
      case FH_CONOUT:
	fh = cnew (fhandler_console) ();
	break;
      case FH_CYGDRIVE:
	fh = cnew (fhandler_cygdrive) ();
	break;
      case FH_PTYM:
	fh = cnew (fhandler_pty_master) ();
	break;
      case FH_WINDOWS:
	fh = cnew (fhandler_windows) ();
	break;
      case FH_SERIAL:
	fh = cnew (fhandler_serial) ();
	break;
      case FH_FIFO:
	fh = cnew (fhandler_fifo) ();
	break;
      case FH_PIPE:
      case FH_PIPER:
      case FH_PIPEW:
	fh = cnew (fhandler_pipe) ();
	break;
      case FH_TCP:
      case FH_UDP:
      case FH_ICMP:
      case FH_UNIX:
      case FH_STREAM:
      case FH_DGRAM:
	fh = cnew (fhandler_socket) ();
	break;
      case FH_FS:
	fh = cnew (fhandler_disk_file) ();
	break;
      case FH_NULL:
	fh = cnew (fhandler_dev_null) ();
	break;
      case FH_ZERO:
	fh = cnew (fhandler_dev_zero) ();
	break;
      case FH_RANDOM:
      case FH_URANDOM:
	fh = cnew (fhandler_dev_random) ();
	break;
      case FH_MEM:
      case FH_PORT:
	fh = cnew (fhandler_dev_mem) ();
	break;
      case FH_CLIPBOARD:
	fh = cnew (fhandler_dev_clipboard) ();
	break;
      case FH_OSS_DSP:
	fh = cnew (fhandler_dev_dsp) ();
	break;
      case FH_PROC:
	fh = cnew (fhandler_proc) ();
	break;
      case FH_REGISTRY:
	fh = cnew (fhandler_registry) ();
	break;
      case FH_PROCESS:
	fh = cnew (fhandler_process) ();
	break;
      case FH_TTY:
	{
	  device newdev = pc.dev;
	  newdev.tty_to_real_device ();
	  switch (newdev)
d412 11
a422 6
	    case FH_CONSOLE:
	      fh = cnew (fhandler_console) ();
	      break;
	    case FH_TTYS:
	      fh = cnew (fhandler_tty_slave) ();
	      break;
d425 1
a425 1
    }
@


1.117
log
@	* devices.h: Move a few device major numbers.  Fix typo of FH_UDP.
	* device.shilka: Remove /dev/hd device entries, rename all device_hd*
	to device_sd*.
	(device::parse): Disallow units outside lower and upper bounds.
	* dtable.cc (build_fh_pc): Fix typo of FH_UDP.
	* path.cc (win32_device_name): Fix win32 name creation to match new
	device handling.
@
text
@a348 1
      case DEV_RAWDRIVE_MAJOR:
@


1.116
log
@* dtable.cc (build_fh_name): Return pointer to a 'nodevice' rather than a NULL
pointer or suffer SEGVs with invalid paths.
@
text
@d385 1
a385 1
      case FH_UCP:
@


1.115
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d290 1
d298 1
a298 1
      return NULL;
a328 1
#define cnew(name) new ((void *) ccalloc (HEAP_FHANDLER, 1, sizeof (name))) name
@


1.114
log
@* cygheap.cc (creturn): Set appropriate errno when out of memory.
(ccalloc): Only issue system_printf when debugging.
* dtable.cc (dtable::extend): Only allocate 100 * the incremental growth size
max.  Set errno appropriately.
(dtable::build_fhandler): Check for error from set_name.
* fhandler.cc (fhandler_base::set_name): Set errno and return error on OOM.
* fhandler.h (fhandler_base::set_name): Change to bool.
* fhandler_process.cc (format_process_stat): Fix formatting.
* resource.cc (getrlimit): Return greater of OPEN_MAX or fd table size.
* sysconf.cc (sysconf): Ditto.
@
text
@d29 1
a30 1
#include "path.h"
a107 1
	    path_conv pc;
d109 1
a109 1
	    fhandler_base *fh = build_fhandler_from_name (i, std[i], NULL, pc);
d112 2
a113 1
	    if (!fh->open (&pc, (i ? O_WRONLY : O_RDONLY) | O_BINARY, 0777))
d186 2
a187 6
      switch (fds[fd]->get_device ())
	{
	case FH_SOCKET:
	  dec_need_fixup_before ();
	  break;
	}
d199 3
a201 4
  path_conv pc;
  fhandler_base *res = cygheap->fdtab.build_fhandler_from_name (fd, name, handle,
								pc);
  res->init (handle, myaccess, bin ?: pc.binmode ());
d208 1
a208 1
  const char *name;
d214 1
d216 1
d224 1
a224 3
  if (ft == FILE_TYPE_UNKNOWN && GetLastError () == ERROR_INVALID_HANDLE)
    name = NULL;
  else
d230 1
a230 1
	    name = "/dev/tty";
d232 1
a232 1
	    name = "/dev/conout";
d237 1
a237 1
	    name = "/dev/tty";
d239 1
a239 1
	    name = "/dev/conin";
d244 1
a244 1
	    name = "/dev/piper";
d246 1
a246 1
	    name = "/dev/pipew";
d249 1
a249 1
	name = "/dev/socket";
d251 1
a251 1
	name = "/dev/ttyS0"; // FIXME - determine correct device
d259 1
a259 1
  if (!name)
d263 10
a272 2
      path_conv pc;
      fhandler_base *fh = build_fhandler_from_name (fd, name, handle, pc);
d276 6
a281 2
	  if (!bin && name != unknown_file)
	    bin = pc.binmode ();
d291 1
a291 2
dtable::build_fhandler_from_name (int fd, const char *name, HANDLE handle,
				  path_conv& pc, unsigned opt, suffix_info *si)
d293 1
a293 1
  pc.check (name, opt | PC_NULLEMPTY | PC_FULL | PC_POSIX, si);
d300 2
a301 2
  if (!pc.exists () && handle)
    pc.fillin (handle);
d303 1
a303 10
  char *posix_path = pc.return_and_clear_normalized_path ();
  fhandler_base *fh = build_fhandler (fd, pc.get_devn (), posix_path,
				      pc, pc.get_unitn ());
  if (pc.issocket ()) /* Only true for files pretending an AF_LOCAL socket. */
    {
      fhandler_socket * fhs = (fhandler_socket *) fh;
      fhs->set_addr_family (AF_LOCAL);
      fhs->set_sun_path (posix_path);
    }
  return fh;
d307 1
a307 2
dtable::build_fhandler (int fd, DWORD dev, const char *unix_name,
			const char *win32_name, int unit)
d309 17
a325 1
  return build_fhandler (fd, dev, cstrdup (unix_name), win32_name, unit);
d330 1
a330 2
dtable::build_fhandler (int fd, DWORD dev, char *unix_name,
			const char *win32_name, int unit)
d332 1
a332 1
  fhandler_base *fh;
d334 20
a353 5
  dev &= FH_DEVMASK;
  switch (dev)
    {
      case FH_TTYM:
	fh = cnew (fhandler_tty_master) (unit);
d355 4
d364 3
a369 6
      case FH_TTYS:
	if (unit < 0)
	  fh = cnew (fhandler_tty_slave) ();
	else
	  fh = cnew (fhandler_tty_slave) (unit);
	break;
d374 4
a377 1
	fh = cnew (fhandler_serial) (unit);
d382 1
a382 1
	fh = cnew (fhandler_pipe) (dev);
d384 7
a390 3
      case FH_SOCKET:
	if ((fh = cnew (fhandler_socket) (unit)))
	  inc_need_fixup_before ();
d392 1
a392 1
      case FH_DISK:
a394 9
      case FH_CYGDRIVE:
	fh = cnew (fhandler_cygdrive) (unit);
	break;
      case FH_FLOPPY:
	fh = cnew (fhandler_dev_floppy) (unit);
	break;
      case FH_TAPE:
	fh = cnew (fhandler_dev_tape) (unit);
	break;
d402 2
a403 1
	fh = cnew (fhandler_dev_random) (unit);
d406 2
a407 1
	fh = cnew (fhandler_dev_mem) (unit);
d424 1
a424 9
      default:
	system_printf ("internal error -- unknown device - %p", dev);
	fh = NULL;
    }

  if (unix_name)
    {
      char new_win32_name[strlen (unix_name) + 1];
      if (!win32_name)
d426 11
a436 6
	  char *p;
	  /* FIXME: ? Should we call win32_device_name here?
	     It seems like overkill, but... */
	  win32_name = strcpy (new_win32_name, unix_name);
	  for (p = (char *) win32_name; (p = strchr (p, '/')); p++)
	    *p = '\\';
a437 2
      if (!fh->set_name (unix_name, win32_name, fh->get_unit ()))
	return NULL;
d439 8
a446 2
  debug_printf ("fd %d, fh %p", fd, fh);
  return fd >= 0 ? (fds[fd] = fh) : fh;
d452 1
a452 1
  fhandler_base *newfh = build_fhandler (-1, oldfh->get_device ());
d531 13
d797 1
a797 3
  char *p = strchr (win32_fn + DEVICE_PREFIX_LEN, '\\');
  if (!p)
    p = strchr (win32_fn + DEVICE_PREFIX_LEN, '\0');
@


1.113
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@d68 6
d80 1
d85 1
a86 1
      cfree (fds);
d414 2
a415 1
      fh->set_name (unix_name, win32_name, fh->get_unit ());
@


1.112
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d637 1
a637 2
  if (cygheap->user.issetuid ())
    RevertToSelf ();
d656 1
a656 2
  if (cygheap->user.issetuid ())
    ImpersonateLoggedOnUser (cygheap->user.token);
@


1.111
log
@* dll_init.cc (dll_list::load_after_fork): Don't revert to LoadLibrary if
LoadLibraryEx fails.
* dtable.cc (dtable::dec_console_fds): Eliminate.
(dtable::release): Don't treat console specially.
(dtable::build_fhandler): Ditto.
* dtable.h (console_fds): Eliminate.
(dtable::dec_console_fds): Eliminate.
(dtable::inc_console_fds): Eliminate.
* fhandler.h (fhandler_console::open_fhs): New static element.
* fhandler_console.cc (fhandler_console::open): Increment open_fs.
(fhandler_console::close): Call FreeConsole if no more open consoles and ctty
is not associated with the console.
* syscalls.cc (setsid): Simplify check for when to call FreeConsole.
(check_pty_fds): Eliminate definition.
* winsup.h (check_pty_fds): Eliminate declaration.
@
text
@a13 1
#include <errno.h>
@


1.110
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@a59 8
void
dtable::dec_console_fds ()
{
  if (console_fds > 0 && !--console_fds &&
      myself->ctty != TTY_CONSOLE && !check_pty_fds())
    FreeConsole ();
}

a184 3
	case FH_CONSOLE:
	  dec_console_fds ();
	  break;
d326 1
a326 2
	if ((fh = cnew (fhandler_console) ()))
	  inc_console_fds ();
@


1.109
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d302 2
a303 2
  fhandler_base *fh = build_fhandler (fd, pc.get_devn (),
				      pc.return_and_clear_normalized_path (),
d305 6
d361 1
a361 1
	if ((fh = cnew (fhandler_socket) ()))
@


1.109.2.1
log
@merge from trunk
@
text
@d218 1
a218 1
  const char *name = NULL;
a223 1
  device dev;
a224 1
  dev.devn = 0;		/* FIXME: device */
d232 3
a234 1
  if (ft != FILE_TYPE_UNKNOWN || GetLastError () != ERROR_INVALID_HANDLE)
d240 1
a240 1
	    dev.parse ("/dev/tty");
d242 1
a242 1
	    dev = *console_dev;
d247 1
a247 1
	    dev.parse ("/dev/tty");
d249 1
a249 1
	    dev = *console_dev;
d254 1
a254 1
	    dev = *piper_dev;
d256 1
a256 1
	    dev = *pipew_dev;
d259 1
a259 1
	dev = *socket_dev;
d261 1
a261 1
	dev.parse ("/dev/ttyS0");
d269 1
a269 1
  if (!name && !dev)
d274 1
a274 7
      fhandler_base *fh;

      if (dev)
	fh = build_fhandler (fd, dev);
      else
	fh = build_fhandler_from_name (fd, name, handle, pc);

d278 1
a278 5
	  if (bin)
	    /* nothing */;
	  else if (dev)
	    bin = O_BINARY;
	  else if (name != unknown_file)
d302 1
a302 1
  fhandler_base *fh = build_fhandler (fd, pc.dev,
d304 1
a304 1
				      pc);
d309 2
a310 2
dtable::build_fhandler (int fd, const device& dev, const char *unix_name,
			const char *win32_name)
d312 1
a312 1
  return build_fhandler (fd, dev, cstrdup (unix_name), win32_name);
d317 2
a318 2
dtable::build_fhandler (int fd, const device& dev, char *unix_name,
			const char *win32_name)
d320 1
a320 1
  fhandler_base *fh = NULL;
d322 5
a326 20
  if (dev.upper)
    switch (dev.major)
      {
      case DEV_TTYS_MAJOR:
	fh = cnew (fhandler_tty_slave) ();
	break;
      case DEV_TTYM_MAJOR:
	fh = cnew (fhandler_tty_master) ();
	break;
      case DEV_CYGDRIVE_MAJOR:
	fh = cnew (fhandler_cygdrive) ();
	break;
      case DEV_FLOPPY_MAJOR:
      case DEV_CDROM_MAJOR:
      case DEV_SD_MAJOR:
      case DEV_RAWDRIVE_MAJOR:
	fh = cnew (fhandler_dev_floppy) ();
	break;
      case DEV_TAPE_MAJOR:
	fh = cnew (fhandler_dev_tape) ();
a327 4
      }
  else
    switch (dev)
      {
d337 6
d347 1
a347 4
	fh = cnew (fhandler_serial) ();
	break;
      case FH_FIFO:
	fh = cnew (fhandler_fifo) ();
d352 1
a352 1
	fh = cnew (fhandler_pipe) ();
d358 1
a358 1
      case FH_FS:
d361 9
d377 1
a377 2
      case FH_URANDOM:
	fh = cnew (fhandler_dev_random) ();
d380 1
a380 2
      case FH_PORT:
	fh = cnew (fhandler_dev_mem) ();
d397 3
a399 15
      case FH_TTY:
	{
	  device newdev = dev;
	  newdev.tty_to_real_device ();
	  switch (newdev)
	    {
	    case FH_CONSOLE:
	      if ((fh = cnew (fhandler_console) ()))
		inc_console_fds ();
	      break;
	    case FH_TTYS:
	      fh = cnew (fhandler_tty_slave) ();
	      break;
	    }
	}
a401 27
  if (!fh)
    {
      set_errno (ENODEV);
#ifdef DEBUGGING
      system_printf ("unknown device - %p, '%s', upper %d",
	       (int) dev, dev.name, dev.upper);
      return NULL;
#endif
    }

  char w32buf[MAX_PATH + 1];
  if (!unix_name || !*unix_name)
    {
      if (!win32_name && dev.fmt && *dev.fmt)
	{
	  sprintf (w32buf, dev.fmt, dev.minor);
	  win32_name = w32buf;
	}
      if (win32_name)
	{
	  unix_name = cstrdup (w32buf);
	  for (char *p = strchr (unix_name, '\\'); p; p = strchr (p + 1, '\\'))
	    *p = '/';
	}
    }

  fh->dev = dev;
d404 1
d407 1
d410 2
a411 2
	  win32_name = strcpy (w32buf, unix_name);
	  for (char *p = w32buf; (p = strchr (p, '/')); p++)
d414 1
a414 1
      fh->set_name (unix_name, win32_name);
a415 1

d423 1
a423 1
  fhandler_base *newfh = build_fhandler (-1, oldfh->dev);
a499 13
}

fhandler_fifo *
dtable::find_fifo (ATOM hill)
{
  SetResourceLock (LOCK_FD_LIST, READ_LOCK, "dup");
  for (unsigned i = 0; i < size; i++)
    {
      fhandler_base *fh = fds[i];
      if (fh && fh->isfifo () && ((fhandler_fifo *) fh)->get_atom () == hill)
	return (fhandler_fifo *) fh;
    }
  return NULL;
@


1.109.2.2
log
@* Makefile.in (DLL_OFILES): Add fhandler_nodevice.o.
* devices.gperf (device::parse): Just set devn to input if device not found --
nonexistent device will be caught later.
* dtable.cc (dtable::build_fhandler): Build fhandler_nodevice type when unknown
device.
* fhandler.h (fhandler_nodevice): New class.
(fhandler_union): Add fhandler_nodevice.
* path.cc (path_conv::check): Always set device stuff if major/minor are
specified.
@
text
@d434 8
a441 1
    fh = cnew (fhandler_nodevice) ();
@


1.109.2.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d30 1
a31 1
#include "fhandler.h"
d110 1
d112 1
a112 1
	    fhandler_base *fh = build_fh_name (std[i]);
d115 1
a115 2
	    fds[i] = fh;
	    if (!fh->open ((i ? O_WRONLY : O_RDONLY) | O_BINARY, 0777))
d209 3
a211 3
  fhandler_base *fh = build_fh_name (name);
  cygheap->fdtab[fd] = fh;
  fh->init (handle, myaccess, bin ?: fh->pc_binmode ());
d273 1
d277 1
a277 1
	fh = build_fh_dev (dev);
d279 1
a279 4
	fh = build_fh_name (name);

      if (fh)
	cygheap->fdtab[fd] = fh;
d289 1
a289 1
	    bin = fh->pc_binmode ();
d299 2
a300 1
build_fh_name (const char *name, HANDLE h, unsigned opt, suffix_info *si)
d302 1
a302 1
  path_conv pc (name, opt | PC_NULLEMPTY | PC_FULL | PC_POSIX, si);
d309 2
a310 2
  if (!pc.exists () && h)
    pc.fillin (h);
d312 4
a315 1
  return build_fh_pc (pc);
d319 2
a320 1
build_fh_dev (const device& dev, const char *unix_name)
d322 1
a322 17
  path_conv pc (dev);
  char *w32buf = const_cast<char *> (pc.get_win32 ());

  __small_sprintf (w32buf, dev.fmt, dev.minor);
  if (unix_name)
    pc.normalized_path = cstrdup (unix_name);
  else if (!dev.upper)
    pc.normalized_path = cstrdup (dev.name);
  else
    {
      pc.normalized_path = cstrdup (w32buf);
      for (char *p = strchr (pc.normalized_path, '\\');
	   p;
	   p = strchr (p + 1, '\\'))
	*p = '/';
    }
  return build_fh_pc (pc);
d327 2
a328 1
build_fh_pc (path_conv& pc)
d332 2
a333 2
  if (pc.dev.upper)
    switch (pc.dev.major)
d355 1
a355 1
    switch (pc.dev)
d361 1
a361 4
	  cygheap->fdtab.inc_console_fds ();
	break;
      case FH_CYGDRIVE:
	fh = cnew (fhandler_cygdrive) ();
d382 1
a382 1
	  cygheap->fdtab.inc_need_fixup_before ();
d418 1
a418 1
	  device newdev = pc.dev;
d424 1
a424 1
		cygheap->fdtab.inc_console_fds ();
d436 32
a467 3
  fh->set_name (pc);
  debug_printf ("fh %p", fh);
  return fh;
d473 1
a473 1
  fhandler_base *newfh = build_fh_pc (oldfh->pc);
d820 3
a822 1
  char *p = strechr (win32_fn + DEVICE_PREFIX_LEN, '\\');
@


1.109.2.4
log
@* path.h (path_conv::set_normalized_path): Declare.
(path_conv::normalized_path_size): Declare.
(path_conv::return_and_clear_normalized_path): Delete declaration.
* path.cc (path_conv::set_normalized_path): Define.  Puts normalized path in
path buf if there is room.
(path_conv::check): Call set_normalized_path.
(path_conv::return_and_clear_normalized_path): Delete definition.
* dtable.cc (build_fh_dev): Ditto.
* fhandler.cc (fhandler_base::operator =): Ditto.
(fhandler_base::~fhandler_base): Only free normalized_path when appropriate.
@
text
@d324 1
a324 1
    pc.set_normalized_path (unix_name);
d326 1
a326 1
    pc.set_normalized_path (dev.name);
d329 1
a329 1
      pc.set_normalized_path (w32buf);
@


1.109.2.5
log
@merge from trunk
@
text
@d60 8
d193 3
d372 2
a373 1
	fh = cnew (fhandler_console) ();
d438 2
a439 1
	      fh = cnew (fhandler_console) ();
@


1.109.2.6
log
@Merge from trunk.
* Makefile.in (devicess.cc): Make generation dependent on cygwin-gperf.
* cygheap.h (cygheap_fdmanip): Add fhandler_socket cast.
* cygwin-gperf: Autogenerate references to network devices.
* devices.h: Create separate device types for all network types.  Export
references to global network device storage.
* dtable.cc (dtable::release): Use generic determination to control when
need_fixup_before needs to be decremented.
(dtable::init_std_file_from_handle): Replace use of 'socket_dev' with
'tcp_dev'.
(build_fh_pc): Adapt to new socket types.  Don't increment fixup_before here.
* fhandler.h (fhandler_base::need_fixup_before): Declare/define.
(fhandler_socket::need_fixup_before): Ditto.
* fhandler_socket.cc (fhandler_socket::accept): Accommodate new fdsock
definition.
* net.cc: Throughout, change use of fdsock to return true/false for
success/failure and take cygheap_fdmanip type and device
* select.cc (set_bits): Use 'is_socket ()' test rather than specificially
testing device type.
@
text
@d180 6
a185 2
      if (fds[fd]->need_fixup_before ())
	dec_need_fixup_before ();
d248 1
a248 1
	dev = *tcp_dev;
d383 3
a385 7
      case FH_TCP:
      case FH_UCP:
      case FH_ICMP:
      case FH_UNIX:
      case FH_STREAM:
      case FH_DGRAM:
	fh = cnew (fhandler_socket) ();
@


1.109.2.7
log
@* dtable.cc (cygwin_attach_handle_to_fd): Eliminate unused variable.
@
text
@d193 1
@


1.109.2.8
log
@merge from trunk
@
text
@d14 1
d679 2
a680 1
  cygheap->user.deimpersonate ();
d699 2
a700 1
  cygheap->user.reimpersonate ();
@


1.109.2.9
log
@merge from trunk
@
text
@a67 6
  if (new_size > (100 * NOFILE_INCR))
    {
      set_errno (EMFILE);
      return 0;
    }

a73 1
      set_errno (ENOMEM);
d78 1
a79 1
      memcpy (newfds, fds, size * sizeof (fds[0]));
a436 1

@


1.108
log
@* dtable.h (dtable::in_vfork_cleanup): New function.  True if vfork cleanup
needed.
* dtable.cc (dtable::vfork_parent_restore): Remove assertion.
* pipe.cc (fhandler_pipe::close): Don't close read_state during fork_fixup
since it wasn't inherited.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.107
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@a677 1
  assert (fds_on_hold != NULL);
@


1.107.12.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d218 1
a218 1
  const char *name = NULL;
a223 1
  device dev;
a224 1
  dev.devn = 0;		/* FIXME: device */
d232 3
a234 1
  if (ft != FILE_TYPE_UNKNOWN || GetLastError () != ERROR_INVALID_HANDLE)
d240 1
a240 1
	    dev.parse ("/dev/tty");
d242 1
a242 1
	    dev = *console_dev;
d247 1
a247 1
	    dev.parse ("/dev/tty");
d249 1
a249 1
	    dev = *console_dev;
d254 1
a254 1
	    dev = *piper_dev;
d256 1
a256 1
	    dev = *pipew_dev;
d259 1
a259 1
	dev = *socket_dev;
d261 1
a261 1
	dev.parse ("/dev/ttyS0");
d269 1
a269 1
  if (!name && !dev)
d274 1
a274 7
      fhandler_base *fh;

      if (dev)
	fh = build_fhandler (fd, dev);
      else
	fh = build_fhandler_from_name (fd, name, handle, pc);

d278 1
a278 5
	  if (bin)
	    /* nothing */;
	  else if (dev)
	    bin = O_BINARY;
	  else if (name != unknown_file)
d302 1
a302 1
  fhandler_base *fh = build_fhandler (fd, pc.dev,
d304 1
a304 1
				      pc);
d309 2
a310 2
dtable::build_fhandler (int fd, const device& dev, const char *unix_name,
			const char *win32_name)
d312 1
a312 1
  return build_fhandler (fd, dev, cstrdup (unix_name), win32_name);
d317 2
a318 2
dtable::build_fhandler (int fd, const device& dev, char *unix_name,
			const char *win32_name)
d320 1
a320 1
  fhandler_base *fh = NULL;
d322 5
a326 17
  if (dev.upper)
    switch (dev.major)
      {
      case DEV_TTYS_MAJOR:
	fh = cnew (fhandler_tty_slave) (dev.minor);
	break;
      case DEV_TTYM_MAJOR:
	fh = cnew (fhandler_tty_master) (dev.minor);
	break;
      case DEV_CYGDRIVE_MAJOR:
	fh = cnew (fhandler_cygdrive) (dev.minor);
	break;
      case DEV_FLOPPY_MAJOR:
      case DEV_CDROM_MAJOR:
      case DEV_SD_MAJOR:
      case DEV_RAWDRIVE_MAJOR:
	fh = cnew (fhandler_dev_floppy) (dev.minor);
a327 7
      case DEV_TAPE_MAJOR:
	fh = cnew (fhandler_dev_tape) (dev.minor);
	break;
      }
  else
    switch (dev)
      {
d337 6
d347 1
a347 1
	fh = cnew (fhandler_serial) (dev.minor);
d358 1
a358 1
      case FH_FS:
d361 9
d377 1
a377 2
      case FH_URANDOM:
	fh = cnew (fhandler_dev_random) (dev.minor);
d380 1
a380 2
      case FH_PORT:
	fh = cnew (fhandler_dev_mem) (dev.minor);
d397 3
a401 20
  if (!fh)
    api_fatal ("internal error -- unknown device - %p, '%s'", (int) dev, dev.name);

  char w32buf[MAX_PATH + 1];
  if (!unix_name)
    {
      if (!win32_name && dev.fmt && *dev.fmt)
	{
	  sprintf (w32buf, dev.fmt, dev.minor);
	  win32_name = w32buf;
	}
      if (win32_name)
	{
	  unix_name = cstrdup (w32buf);
	  for (char *p = strchr (unix_name, '\\'); p; p = strchr (p + 1, '\\'))
	    *p = '/';
	}
    }

  fh->dev = dev;
d404 1
d407 1
d410 2
a411 2
	  win32_name = strcpy (w32buf, unix_name);
	  for (char *p = w32buf; (p = strchr (p, '/')); p++)
d414 1
a414 1
      fh->set_name (unix_name, win32_name);
d423 1
a423 1
  fhandler_base *newfh = build_fhandler (-1, oldfh->dev);
@


1.107.12.2
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d336 1
a336 1
	fh = cnew (fhandler_tty_slave) ();
d339 1
a339 1
	fh = cnew (fhandler_tty_master) ();
d342 1
a342 1
	fh = cnew (fhandler_cygdrive) ();
d348 1
a348 1
	fh = cnew (fhandler_dev_floppy) ();
d351 1
a351 1
	fh = cnew (fhandler_dev_tape) ();
d370 1
a370 1
	fh = cnew (fhandler_serial) ();
d375 1
a375 1
	fh = cnew (fhandler_pipe) ();
d392 1
a392 1
	fh = cnew (fhandler_dev_random) ();
d396 1
a396 1
	fh = cnew (fhandler_dev_mem) ();
@


1.107.12.3
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@a412 15
      case FH_TTY:
	{
	  device newdev = dev;
	  newdev.tty_to_real_device ();
	  switch (newdev)
	    {
	    case FH_CONSOLE:
	      if ((fh = cnew (fhandler_console) ()))
		inc_console_fds ();
	      break;
	    case FH_TTYS:
	      fh = cnew (fhandler_tty_slave) ();
	      break;
	    }
	}
d419 1
a419 1
  if (!unix_name || !*unix_name)
@


1.107.12.4
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
* exceptions.cc (events_init): Display name of mutex on failure.
* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@d431 1
a431 2
    api_fatal ("internal error -- unknown device - %p, '%s', upper %d",
	       (int) dev, dev.name, dev.upper);
@


1.107.12.5
log
@* dtable.h (dtable::in_vfork_cleanup): New function.  True if vfork cleanup
needed.
* dtable.cc (dtable::vfork_parent_restore): Remove assertion.
* pipe.cc (fhandler_pipe::close): Don't close read_state during fork_fixup
since it wasn't inherited.
@
text
@d725 1
@


1.107.12.6
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@a371 3
      case FH_FIFO:
	fh = cnew (fhandler_fifo) ();
	break;
d431 1
a431 4
    {
      set_errno (ENODEV);
#ifdef DEBUGGING
      system_printf ("unknown device - %p, '%s', upper %d",
a432 3
      return NULL;
#endif
    }
a462 1

a546 13
}

fhandler_fifo *
dtable::find_fifo (ATOM hill)
{
  SetResourceLock (LOCK_FD_LIST, READ_LOCK, "dup");
  for (unsigned i = 0; i < size; i++)
    {
      fhandler_base *fh = fds[0];
      if (fh && fh->isfifo () && ((fhandler_fifo *) fh)->get_atom () == hill)
	return (fhandler_fifo *) fh;
    }
  return NULL;
@


1.107.12.7
log
@* pinfo.cc (_pinfo::commune_send): Use myself->lock rather than just lock when
leaving.
@
text
@d565 1
a565 1
      fhandler_base *fh = fds[i];
@


1.106
log
@* dtable.cc (dtable::init_std_file_from_handle): Force "devices" to always be
in binary mode.  Temporary fix until ssh is rebuilt?
@
text
@d479 1
a479 1
    _close (newfd);
@


1.105
log
@* dtable.cc (dtable::set_file_pointers_for_exec): New function.
* dtable.h (dtable::set_file_pointers_for_exec): Declare new function.
* spawn.cc (spawn_guts): Call dtable::set_file_pointers_for_exec to set
pointers to EOF when execing non-cygwin applications.
@
text
@d223 1
d263 4
a266 1
	name = handle_to_fn (handle, (char *) alloca (MAX_PATH + 100));
a273 1
      unsigned bin;
d275 6
a280 3
      bin = fh->get_default_fmode (O_RDWR);
      if (!bin && name != unknown_file)
	bin = pc.binmode ();
@


1.104
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::heaptop): Remove obsolete element.
(child_info_fork::heabbase): Ditto.
(child_info_fork::heapptr): Ditto.
(child_info_fork::mount_table): New element.
(child_info_fork::myself_addr): Ditto.
* dcrt0.cc (dll_crt0_1): Set mount_table and myself_addr when forking.
(initial_env): Add newline to "sleeping" message.
* dll_init.cc (reserve_upto): Accommodate cygwin heap when freeing memory.
Make debugging output a little more descriptive.
* fork.cc (fork_parent): Save mount_table and myself_addr.
* pinfo.cc (myself_addr): New variable.
(set_myself): Pass PID_MYSELF flag to init.
(pinfo::Init): Honor PID_MYSELF.  Save address where myself shared memory
resides in myself_addr, for fork.
* pinfo.h (myself_addr): Declare.
* shared.cc (memory_init): On fork, use previously saved address for location
of mount table.
* include/sys/cygwin.h (PID_MYSELF): New value.
* dtable.cc (dtable::stdio_init): Don't pass access type to
init_std_file_from_handle.  It's always the same.
(dtable::init_std_file_from_handle): Remove access type argument.  Assume
read/write.
* dtable.h (dtable::init_std_file_from_handle): Ditto for declaration.
* exceptions.cc (try_to_debug): Don't try to debug if already being debugged.
* fhandler_console.cc (shared_console_info_save): New variable.
(fhandler_console::get_tty_stuff): Save address of shared console stuff for
fork.
@
text
@d578 11
@


1.103
log
@* dtable.cc (dtable::init_std_file_from_handle): Try to mimic standard open
behavior with files redirected from stdin/stdout/stderr, i.e., fmode settings
take precedence over mount settings.
@
text
@d142 1
a142 1
  init_std_file_from_handle (0, in, GENERIC_READ);
d160 2
a161 2
  init_std_file_from_handle (1, out, GENERIC_WRITE);
  init_std_file_from_handle (2, err, GENERIC_WRITE);
d216 1
a216 1
dtable::init_std_file_from_handle (int fd, HANDLE handle, DWORD myaccess)
d272 1
a272 1
      bin = fh->get_default_fmode (myaccess == GENERIC_READ ? O_RDONLY : O_WRONLY);
d276 1
a276 1
      fh->init (handle, myaccess, bin);
@


1.102
log
@* dtable.cc (unknown_file): New variable.
(dtable::init_std_file_from_handle): Don't set binmode if we couldn't determine
the actual file name on stdin/stdout/stderr.
(handle_to_fn): Return unknown_file when can't determine filename.
@
text
@d270 7
a276 2
      build_fhandler_from_name (fd, name, handle, pc)
	->init (handle, myaccess, (name == unknown_file) ? 0 : pc.binmode ());
@


1.101
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d39 3
a41 1
static char *handle_to_fn (HANDLE, char *);
d270 2
a271 2
      build_fhandler_from_name (fd, name, handle, pc)->init (handle, myaccess,
							     pc.binmode ());
d700 1
a700 1
static char *
d715 1
a715 1
      strcpy (posix_fn, "some disk file");
d717 1
a717 1
      return posix_fn;
@


1.100
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d694 1
a694 1
#define DEVICE_PREFIX_LEN sizeof(DEVICE_PREFIX) - 1
@


1.99
log
@* dtable.cc (cygwin_attach_handle_to_fd): Default to implicit bin mode if none
specified.
* fhandler.cc (fhandler_base::init): Make bin argument a guarantee rather than
a suggestion.
* path.cc (path_conv::check): Load flag returned from cygwin_conv_to_win32_path
into path_flags.
@
text
@d733 1
a733 1
  
@


1.98
log
@* cygheap.cc (init_cheap): Rearrange error message.
(cygheap_fixup_in_child): Ditto.
* dtable.cc: Remove if 0'ed code.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode.
* sec_helper.cc (cygsid::get_id): Use system_printf for error message.
* tty.cc (tty::common_init): Ditto.
@
text
@d209 1
a209 1
  res->init (handle, myaccess, bin);
@


1.97
log
@* dtable.cc (dtable::find_unused_handle): Avoid coercion.
@
text
@d200 1
a200 2
extern "C"
int
a692 25
#if 0
static char *
handle_to_fn (HANDLE h, char *posix_fn)
{
  IO_STATUS_BLOCK io;
  FILE_NAME_INFORMATION ntfn;

  io.Status = 0;
  io.Information = 0;

  SetLastError (0);
  DWORD res = NtQueryInformationFile (h, &io, &ntfn, sizeof (ntfn), 9);
  if (res || GetLastError () == ERROR_PROC_NOT_FOUND)
    {
      strcpy (posix_fn, "some disk file");
      return posix_fn;
    }
  ntfn.FileName[ntfn.FileNameLength / sizeof (WCHAR)] = 0;

  char win32_fn[MAX_PATH + 100];
  sys_wcstombs (win32_fn, ntfn.FileName, ntfn.FileNameLength);
  cygwin_conv_to_full_posix_path (win32_fn, posix_fn);
  return posix_fn;
}
#else
a790 1
#endif
@


1.96
log
@* dtable.cc (fhandler_base::dup2): Cleanup.  Ensure that lock is turned off in
error condition.
@
text
@a169 1

d172 1
a172 1
      for (int i = start; i < (int) size; i++)
@


1.95
log
@* cygheap.h (cygheap_user::issetuid): New method.
* dtable.cc (dtable::vfork_child_dup): Use new method to determine if we are in
"setuid mode."
* fork.cc (fork_parent): Ditto.
* spawn.cc (spawn_guts): Ditto.
* syscalls.cc (seteuid32): Ditto.
(setegid32): Ditto.
* environ.cc (spenv::retrieve): (Suggested by Pierre Humblet) Do potential
recalculation of cygheap_user stuff when in setuid mode.  Return special value
when environment variable exists but should not be added.
(build_env): Don't add retrieved value to dstp if it is 'dont_add'.
@
text
@d436 1
d445 7
d464 2
a465 2
  debug_printf ("newfh->io_handle %p, oldfh->io_handle %p", newfh->get_io_handle (), fds[oldfd]->get_io_handle ());
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d467 5
a471 1
  if (newfd < 0)
d473 2
a474 2
      syscall_printf ("new fd out of bounds: %d", newfd);
      set_errno (EBADF);
a477 9
  if ((size_t) newfd >= size)
   {
     int inc_size = NOFILE_INCR * ((newfd + NOFILE_INCR - 1) / NOFILE_INCR) -
		    size;
     extend (inc_size);
   }

  if (!not_open (newfd))
    _close (newfd);
a479 3
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
  MALLOC_CHECK;

d483 1
d485 1
a485 1
done:
@


1.94
log
@* Makefile.in: Ensure that -MD gets added to CFLAGS regardless of CFLAGS
command-line setting.
* cygwin.din: Export sexec* functions as function which returns ENOSYS
(i.e., sexec* is deprecated).
* dtable.cc (dtable::vfork_child_dup): Ensure that impersonation is restored
even on failure.
* exec.cc: Throughout, remove references to sexec* and _spawnve.
* pinfo.h: Remove _spawnve declaration.
* spawn.cc: Rename _spawnve to spawnve and use throughout.
(spawn_guts): Eliminate hToken argument and processing of same.  Just perform
special actions if impersonating.
(spawnve): Rename from _spawnve.
@
text
@d621 1
a621 1
  if (cygheap->user.impersonated && cygheap->user.token != INVALID_HANDLE_VALUE)
d641 1
a641 1
  if (cygheap->user.impersonated && cygheap->user.token != INVALID_HANDLE_VALUE)
@


1.93
log
@* autoload.cc (noload): Correctly save argument count register.
@
text
@d636 4
a643 4
  fds_on_hold = fds;
  fds = newtable;

out:
@


1.92
log
@* dtable.cc (handle_to_fn): Check error return value from NtQueryObject first
before seeing if name buffer is NULL.
* grp.cc (read_etc_group): Fix gcc warning regarding snprintf format.
* passwd.cc (read_etc_passwd): Ditto.
@
text
@d740 1
@


1.91
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@a736 4
  // NT seems to do this on an unopened file
  if (!ntfn->Name.Buffer)
    return NULL;

d742 8
@


1.90
log
@* dtable.cc (handle_to_fn): Correct placement and length of name buffer.
(Suggested by Pavel Tsekov)
@
text
@d721 3
d800 7
@


1.89
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d729 2
a730 2
  ntfn->Name.MaximumLength = sizeof (fnbuf);
  ntfn->Name.Buffer = (WCHAR *) ntfn + 1;
@


1.88
log
@* dtable.cc (handle_to_fn): Use largest match for device.  Correctly
(?) deal with remote drive weirdness.
@
text
@a18 1
#include <fcntl.h>
a217 1
  int bin = -1;
d235 1
a235 7
      if (__fmode)
	bin = __fmode;
      else
	bin = (int) binmode ?: -1;

      /* See if we can consoleify it  - if it is a console,
       don't open it in binary.  That will screw up our crlfs*/
a241 1
	  bin = 0;
a248 1
	  bin = 0;
a255 2
	  if (bin == 0)
	    bin = O_BINARY;
d271 1
a271 1
							     bin < 0 ? pc.isbinary () : bin);
@


1.87
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d759 1
d769 2
a770 1
  char *w32 = win32_fn;
d779 14
a792 2
      if (!strncasematch (device, win32_fn, n) ||
	  (device[n] != '\0' && (device[n] != '\\' || device[n + 1] != ';')))
d794 14
a807 5
      n = strlen (s);
      w32 = p - (n + 1);
      memcpy (w32, s, n);
      p[-1] = '\\';
      break;
d810 1
@


1.86
log
@* fhandler_console.cc (fhandler_console::open): Reinstate setting of flags.
@
text
@a26 1
#include "sigproc.h"
@


1.85
log
@* dtable.cc (dtable::init_std_file_from_handle): Attempt stronger detection of
invalid handle.
(handle_to_fn): Detect pathological condition where NT resets the buffer
pointer to NULL on an invalid handle.
@
text
@d220 1
a220 1
  int bin = 0;
d241 1
a241 1
	bin = binmode ?: 0;
d283 2
a284 1
      build_fhandler_from_name (fd, name, handle, pc)->init (handle, myaccess, bin);
@


1.84
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d220 1
a220 1
  int bin;
d232 5
a236 1
  if (!handle || handle == INVALID_HANDLE_VALUE)
d238 38
a275 2
      fds[fd] = NULL;
      return;
d278 2
a279 2
  if (__fmode)
    bin = __fmode;
a280 13
    bin = binmode ?: 0;

  /* See if we can consoleify it  - if it is a console,
   don't open it in binary.  That will screw up our crlfs*/
  if (GetConsoleScreenBufferInfo (handle, &buf))
    {
      if (ISSTATE (myself, PID_USETTY))
	name = "/dev/tty";
      else
	name = "/dev/conout";
      bin = 0;
    }
  else if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &buf))
d282 4
a285 5
      if (ISSTATE (myself, PID_USETTY))
	name = "/dev/tty";
      else
	name = "/dev/conin";
      bin = 0;
a286 20
  else if (GetFileType (handle) == FILE_TYPE_PIPE)
    {
      if (fd == 0)
	name = "/dev/piper";
      else
	name = "/dev/pipew";
      if (bin == 0)
	bin = O_BINARY;
    }
  else if (wsock_started && getpeername ((SOCKET) handle, &sa, &sal) == 0)
    name = "/dev/socket";
  else if (GetCommState (handle, &dcb))
    name = "/dev/ttyS0"; // FIXME - determine correct device
  else
    name = handle_to_fn (handle, (char *) alloca (MAX_PATH + 100));

  path_conv pc;
  build_fhandler_from_name (fd, name, handle, pc)->init (handle, myaccess, bin);
  set_std_handle (fd);
  paranoid_printf ("fd %d, handle %p", fd, handle);
d745 5
@


1.83
log
@* debug.h (being_debugged): New macro.
* dtable.cc (dtable::extend): Use new macro.
* exceptions.cc (try_to_debug): Ditto.
* strace.cc (strace::hello): Only output debugging info when we think we're
being debugged.
@
text
@d22 2
d36 1
d41 2
d275 1
a275 1
    name = "unknown disk file";
d294 3
d384 2
a385 2
        fh = cnew (fhandler_proc) ();
        break;
d387 2
a388 2
        fh = cnew (fhandler_registry) ();
        break;
d390 2
a391 2
        fh = cnew (fhandler_process) ();
        break;
d699 81
@


1.82
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d95 1
a95 1
  if (IsDebuggerPresent ())
@


1.81
log
@* dtable.cc (dtable::build_fhandler_from_name): Just pass posix path along to
set_name via return_and_clear_normalized_path.
(dtable::build_fhandler): New method with const char * argument.
(dtable::reset_unix_path_name): Eliminate.
(dtable::dup_worker): Use correct build_fhandler method.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* dtable.h (dtable::build_fhandler): New method.
(dtable::reset_unix_path_name): Eliminate.
* fhandler.cc (fhandler_base::set_name): Assume that unix_name has already been
cmalloced.
(fhandler_base::reset_unix_path_name): Eliminate.
(fhandler_base::~fhandler_base): Coercion for cfree.
* fhandler.h (fhandler_base::unix_path_name): Make const char *.
(fhandler_base::win32_path_name): Ditto.
(fhandler_base::reset_unix_path_name): Eliminate.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Accommodate const char
*ness of win32_path_name.
* fhandler_socket.cc (fhandler_socket::fstat): Accommodate new set_name
requirements.
* path.cc (path_conv::return_and_clear_normalized_path): New method.
(path_conv::clear_normalized_path): Eliminate.
(path_conv::~path_conv): Ditto.
(path_conv::check): Accommodate new build_fhandler method.
* path.h (path_conv::~path_conv): Eliminate.
(path_conv::clear_normalized_path): Ditto.
(path_conv::return_and_clear_normalized_path): Declare new method.
@
text
@a24 1
#include "sync.h"
@


1.80
log
@* fhandler_proc.cc (fhandler_proc::fstat): Use fhandler name rather than
path_conv name.
(fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::fstat): Use fhandler name rather than
path_conv name.
(fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::fstat): Use fhandler name rather
than path_conv name.
(fhandler_registry::open): Ditto.
* path.cc (path_conv::check): Don't copy posix path when virtual.
(mount_info::conv_to_win32_path): Don't zero string when isproc.  Just derive
normal windows path.
* path.h (path_conv::clear_normalized_path): Declare new method.
* path.cc (path_conv::clear_normalized_path): Define new method.
* dtable.cc (build_fhandler_from_name): Clear normalized path when finished to
conserve space.
@
text
@d290 3
a292 2
  fhandler_base *fh = build_fhandler (fd, pc.get_devn (), pc.normalized_path, pc, pc.get_unitn ());
  pc.clear_normalized_path ();
d296 7
d305 1
a305 1
dtable::build_fhandler (int fd, DWORD dev, const char *unix_name,
d411 1
a411 1
  fhandler_base *newfh = build_fhandler (-1, oldfh->get_device (), NULL);
a486 8
}

void
dtable::reset_unix_path_name (int fd, const char *name)
{
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "reset_unix_name");
  fds[fd]->reset_unix_path_name (name);
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "reset_unix_name");
@


1.79
log
@* path.h (pathconv_arg): Add PC_POSIX.
(path_conv): Add normalized_path field.
* path.cc (path_conv::~path_conv): New destructor.
(path_conv::check): Set normalized_path, where appropriate.
* dtable.cc (build_fhandler_from_name): Use normalized path from path_conv.
* syscalls.cc (chroot): Ditto.
* cygheap.h: Remove path_prefix_p declaration.  Christopher Faylor
<cgf@@redhat.com> (minor fixups)
* Makefile.in: Add fhandler_proc.o, fhandler_registry.o, fhandler_process.o and
fhandler_virtual.o.
* dtable.cc (dtable::build_fhandler): Add entries for FH_PROC, FH_REGISTRY and
FH_PROCESS.  Set unix_name to the normalized posix path.
* fhandler.h: Add constants for FH_PROC, FH_REGISTRY and FH_PROCESS.  Add class
declarations for fhandler_virtual, fhandler_proc, fhandler_registry and
fhandler_virtual.  Update fhandler_union accordingly.
* fhandler_proc.cc: New file.  Add implementation for fhandler_proc.
* fhandler_virtual.cc: New file.  Add implementation for fhandler_virtual.
* fhandler_process.cc: New file.  Add implementation for fhandler_process.
* fhandler_registry.cc: New file.  Add implementation for fhandler_registry.
* path.cc: Add isproc and isvirtual_dev macros.
* path.cc (path_conv::check): Add check for virtual devices.
* path.cc (mount_info::conv_to_win32_path): Convert paths in /proc to empty
Win32 paths.
* path.cc (chdir): Replace check for FH_CYGDRIVE with more generic
isvirtual_dev macro.  Force setting of posix path for virtual fhandlers.
* path.h: Add externally visible path_prefix_p and normalized_posix_path
prototypes.
@
text
@d290 3
a292 1
  return build_fhandler (fd, pc.get_devn (), pc.normalized_path, pc, pc.get_unitn ());
@


1.78
log
@* sync.h (new_muto): Just accept an argument which denotes the name of the
muto.  Use this argument to construct static storage.
* cygheap.cc (cygheap_init): Reflect above change.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* cygheap.h (cwdstuff): Change name of lock element to make it less generic.
* path.cc (cwdstuff::get_hash): Ditto.
(cwdstuff::get_initial): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* sigproc.cc (proc_subproc): Ditto.
* debug.cc (lock_debug): Change to method.  Use method rather than macro
throughout.
* tty.h (tty_min::kill_pgrp): Declare new method.
* fhandler_termios.cc (tty_min::kill_pgrp): New method.
(fhandler_termios::line_edit): Use new method for killing process.
* dcrt0.cc (do_exit): Ditto.
* dtable.cc (dtable::get_debugger_info): New method for inheriting dtable info
from a debugger.
* tty.cc (tty_init): Attempt to grab file handle info from parent debugger, if
appropriate.  # dtable.cc (dtable::stdio_init): Make this a method.
(dtable::init_std_file_from_handle): Don't set fd unless it's not open.
(dtable::build_fhandler_from_name): Move name setting to
dtable::build_fhandler.
(dtable::build_fhandler): Add win32 name parameter.
* dcrt0.cc (dll_crt0_1): Change to use dtable stdio_init.
* dtable.h (dtable): Reflect build_fhandler parameter change.
* mmap.cc (mmap_record::alloc_fh): Don't set name parameter in build_fhandler.
* net.cc (fdsock): Remove set_name call since it is now handled by
build_fhandler.
* sigproc.cc (proc_subproc): Release muto as early as possible.
@
text
@d283 1
a283 1
  pc.check (name, opt | PC_NULLEMPTY | PC_FULL, si);
d290 1
a290 1
  return build_fhandler (fd, pc.get_devn (), name, pc, pc.get_unitn ());
d366 9
@


1.77
log
@	* dtable.cc (dtable::dup2): Revert previous patch.
	* fhandler.h: Ditto.
	(fhandler_socket::recv): Define new method.
	(fhandler_socket::send): Ditto.
	* fhandler_socket.cc (fhandler_socket::recv): New method.
	(fhandler_socket::send): Ditto.
	(fhandler_socket::read): Call fhandler_socket::recv() now.
	(fhandler_socket::write): Call fhandler_socket::send() now.
	* net.cc (class wsock_event): Move definition to wsock_event.h.
	(fdsock): Revert previous patch.
	(cygwin_recv): Move implementation to fhandler_socket::recv().
	(cygwin_send): Move implementation to fhandler_socket::send().
	* wsock_event.h: New file.
@
text
@d37 1
a37 1
			     STD_ERROR_HANDLE};
d93 26
d124 1
a124 1
stdio_init (void)
d131 18
a148 12
  if (!myself->ppid_handle && NOTSTATE (myself, PID_CYGPARENT))
    {
      HANDLE in = GetStdHandle (STD_INPUT_HANDLE);
      HANDLE out = GetStdHandle (STD_OUTPUT_HANDLE);
      HANDLE err = GetStdHandle (STD_ERROR_HANDLE);

      cygheap->fdtab.init_std_file_from_handle (0, in, GENERIC_READ);

      /* STD_ERROR_HANDLE has been observed to be the same as
	 STD_OUTPUT_HANDLE.  We need separate handles (e.g. using pipes
	 to pass data from child to parent).  */
      if (out == err)
d150 3
a152 9
	  /* Since this code is not invoked for forked tasks, we don't have
	     to worry about the close-on-exec flag here.  */
	  if (!DuplicateHandle (hMainProc, out, hMainProc, &err, 0,
				 1, DUPLICATE_SAME_ACCESS))
	    {
	      /* If that fails, do this as a fall back.  */
	      err = out;
	      system_printf ("couldn't make stderr distinct from stdout");
	    }
d154 1
d156 6
a161 7
      cygheap->fdtab.init_std_file_from_handle (1, out, GENERIC_WRITE);
      cygheap->fdtab.init_std_file_from_handle (2, err, GENERIC_WRITE);
      /* Assign the console as the controlling tty for this process if we actually
	 have a console and no other controlling tty has been assigned. */
      if (myself->ctty < 0 && GetConsoleCP () > 0)
	set_console_ctty ();
    }
d225 3
d290 1
a290 3
  fhandler_base *fh = build_fhandler (fd, pc.get_devn (), name, pc.get_unitn ());
  fh->set_name (name, pc, pc.get_unitn ());
  return fh;
d295 2
a296 1
dtable::build_fhandler (int fd, DWORD dev, const char *name, int unit)
d371 14
@


1.76
log
@	* dtable.cc (dtable::dup2): Store fd for fhandler_socket.
	* fhandler.h (fhandler_base::set_fd): New virtual method.
	(fhandler_base::get_fd): Ditto.
	(fhandler_socket::set_fd): Ditto.
	(fhandler_socket::get_fd): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): Call cygwin_recv instead
	of native Winsock recv.
	(fhandler_socket::write): Call cygwin_send instead of native Winsock
	send.
	* net.cc (fdsock): Store fd in fhandler_socket.
@
text
@a413 1
  newfh->set_fd (newfd);
@


1.75
log
@Add copyright stuff
@
text
@d414 1
@


1.74
log
@* dtable.cc (dtable::init_std_file_from_handle): Add some defensive code to
invalid handle case.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.73
log
@	* ioctl.cc (ioctl): Make third argument optional.
	* include/sys/ioctl.h: Ditto in declaration.
	* dtable.cc (dtable::init_std_file_from_handle): Revert previous
	bogus patch.
	* window.cc (WndProc): Raise SIGURG instead of SIGIO in case of FD_OOB
	message.
@
text
@d94 2
a95 2
   We only initialize the parent table here.  The child table is
   initialized at each fork () call.  */
d200 4
a203 1
    return;
@


1.72
log
@	* dtable.cc (dtable::init_std_file_from_handle): Don't treat NULL
	handle as errorneous.
@
text
@d199 1
a199 1
  if (handle == INVALID_HANDLE_VALUE)
@


1.71
log
@* dtable.cc (dtable::init_std_file_from_handle): Avoid initializing using an
invalid handle.
@
text
@d199 1
a199 1
  if (!handle || handle == INVALID_HANDLE_VALUE)
@


1.70
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d199 3
@


1.69
log
@* path.cc (conv_path_list): Fix wild indexing into path due to conflicting
methods for setting src pointer.
* dir.cc (opendir): Only pass path_conv argument to opendir, since name is
already part of the fhandler.
* dtable.cc (dtable::build_fhandler): Accomodate new FH_CYGDRIVE type.
* fhandler.cc (fhandler_base::opendir): Nuke name argument.
* fhandler.h: Add FH_CYGDRIVE to "device" enum.
(fhandler_base::opendir): Nuke name argument.
(fhandler_disk_file::opendir): Ditto.
(fhandler_disk_file::fhandler_disk_file): Declare new method which passes
devtype through.
(fhandler_cygdrive): Add elements for tracking drives.
(fhandler_cygdrive::set_drives): Declare new method.
(fhandler_cygdrive::iscygdrive_root): Declare new method.
(fhandler_cygdrive::opendir): Declare new method.
(fhandler_cygdrive::readdir): Declare new method.
(fhandler_cygdrive::telldir): Declare new method.
(fhandler_cygdrive::seekdir): Declare new method.
(fhandler_cygdrive::rewinddir): Declare new method.
(fhandler_cygdrive::closedir): Declare new method.
(fhandler_cygdrive::fstat): Declare new method.
* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file): Define new
method which passes devtype through.
(fhandler_disk_file::open): Tweak debug output.
(fhandler_disk_file::opendir): Nuke first argument.  Use info from path_conv
and class rather than calling fstat.
(fhandler_cygdrive::set_drives): New method.
(fhandler_cygdrive::iscygdrive_root): New method.
(fhandler_cygdrive::opendir): New method.
(fhandler_cygdrive::readdir): New method.
(fhandler_cygdrive::telldir): New method.
(fhandler_cygdrive::seekdir): New method.
(fhandler_cygdrive::rewinddir): New method.
(fhandler_cygdrive::closedir): New method.
(fhandler_cygdrive::fstat): New method.
* path.cc (iscygdrive_device): Assume cygdriveness is already verified.
(path_conv::check): Treat FH_CYGDRIVE "method" as a special case, setting file
attributes as needed.
(mount_info::conv_to_win32_path): Allow stand-alone /cygdrive, meaning "the
directory which contains all of the drives on the system".
(fillout_mntent): Use cyg_tolower for conversions.
(mount_info::cygdrive_win32_path): Replace unused argument with unit number.
* shared_info.h (mount_info::cygdrive_win32_path): Reflect argument change.
@
text
@d21 1
d296 1
a296 1
	fh = cnew (fhandler_pipe) ();
d595 1
@


1.68
log
@* dtable.cc (dtable::build_fhandler): Don't increment console fd count if new
operation fails.  Increment fork_fixup field here.
(dtable::dup2): Don't increment fork_fixup field here.
(fdsock): Ditto.
@
text
@d304 3
@


1.67
log
@Eliminate excess whitespace.
@
text
@d274 2
a275 2
	fh = cnew (fhandler_console) ();
	inc_console_fds ();
d298 2
a299 1
	fh = cnew (fhandler_socket) ();
a403 4

  /* Count sockets. */
  if ((fds[newfd]->get_device () & FH_DEVMASK) == FH_SOCKET)
    inc_need_fixup_before ();
@


1.66
log
@* dtable.cc (dtable::build_fhandler): Fix debug_printf to avoid SEGV due to
incorrect parameter placement.
@
text
@d181 1
a181 1
      								pc);
d245 1
a245 1
    				  path_conv& pc, unsigned opt, suffix_info *si)
@


1.65
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d332 1
a332 1
  debug_printf ("%s - fd %d, fh %p", fd, fh);
@


1.64
log
@	* dtable.cc (dtable::vfork_child_dup): Revert impersonation
	before duplicating fhandler.
@
text
@d328 2
a329 5
	{
	  /* FIXME - this could recurse forever */
	  path_conv pc;
	  return build_fhandler_from_name (fd, name, NULL, pc);
	}
d332 1
a332 1
  debug_printf ("%s - fd %d, fh %p", fh->get_name () ?: "", fd, fh);
@


1.63
log
@* dtable.cc (dtable::dup2): Add some debugging.  Use methods from passed in
class rather than cygheap->fdtab.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Add more
debugging output.
(fhandler_socket::dup): Allocate new space for prot_info_ptr for duplicated
entry.
* syscalls.cc (stat_worker): Always delete fh if it has been created.
@
text
@d562 4
d577 4
@


1.62
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d386 1
d396 1
a396 1
  if ((size_t) newfd >= cygheap->fdtab.size)
d399 2
a400 2
		    cygheap->fdtab.size;
     cygheap->fdtab.extend (inc_size);
@


1.61
log
@* dtable.cc (dtable::build_fhandler_from_name): Use PC_FULL to determine path
name.
* fork.cc (fork_parent): Correct the "unable to allocate forker_finished event"
error message.  It named the wrong event before.
@
text
@d335 1
a335 2
  debug_printf ("%s - cb %d, fd %d, fh %p", fh->get_name () ?: "", fh->cb,
		fd, fh);
@


1.60
log
@* autoload.cc (load_wsock32): Declare dummy function to force loading of
winsock.
* fhandler.cc (fhandler_base::set_inheritance): Make debugging output more
verbose.
* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Force loading of
winsock32 if winsock2 not available.
* net.cc (set_socket_inheritance): Use DuplicateHandle in all cases to set
inheritance correctly.
(fdsock): Use winsock2_active macro to determine when to set socket
inheritance.  Remove fdtab resource locking since this function should already
be protected.
(cygwin_accept): Simplify logic.  Ensure that fdtab unlock is not called
inappropriately.
(cygwin_rcmd): Use fdtab locking.
(cygwin_rresvport): Ditto.
(cygwin_rexec): Ditto.
* select.cc (peek_socket): Set errno appropriately if winsock select fails.
* winsup.h: Declare check_pty_fds.
* syscalls.cc (check_pty_fds): Rename from check_ttys_fds.  Also check pty
master.
(setsid): Use check_pty_fds.
* dtable.cc (dtable::dec_console_fds): Add check on pty fds.
@
text
@d247 1
a247 1
  pc.check (name, opt | PC_NULLEMPTY, si);
@


1.59
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d58 2
a59 1
  if (console_fds > 0 && !--console_fds && myself->ctty != TTY_CONSOLE)
@


1.58
log
@* dtable.cc (dtable::build_fhandler): Allocate correct amount for given
fhandler class.
* fhandler.h (fhandler_union): Properly define rather than relying on
fhandler_console being "big enough".
@
text
@d268 1
a268 1
	fh = cnew (fhandler_tty_master) (name, unit);
d273 1
a273 1
	fh = cnew (fhandler_console) (name);
d277 1
a277 1
	fh = cnew (fhandler_pty_master) (name);
d281 1
a281 1
	  fh = cnew (fhandler_tty_slave) (name);
d283 1
a283 1
	  fh = cnew (fhandler_tty_slave) (unit, name);
d286 1
a286 1
	fh = cnew (fhandler_windows) (name);
d289 1
a289 1
	fh = cnew (fhandler_serial) (name, dev, unit);
d294 1
a294 1
	fh = cnew (fhandler_pipe) (name, dev);
d297 1
a297 1
	fh = cnew (fhandler_socket) (name);
d300 1
a300 1
	fh = cnew (fhandler_disk_file) (NULL);
d303 1
a303 1
	fh = cnew (fhandler_dev_floppy) (name, unit);
d306 1
a306 1
	fh = cnew (fhandler_dev_tape) (name, unit);
d309 1
a309 1
	fh = cnew (fhandler_dev_null) (name);
d312 1
a312 1
	fh = cnew (fhandler_dev_zero) (name);
d315 1
a315 1
	fh = cnew (fhandler_dev_random) (name, unit);
d318 1
a318 1
	fh = cnew (fhandler_dev_mem) (name, unit);
d321 1
a321 1
	fh = cnew (fhandler_dev_clipboard) (name);
d324 1
a324 1
	fh = cnew (fhandler_dev_dsp) (name);
@


1.57
log
@* cygheap.cc (cfree): Remove malloc debugging probe.
* dlmalloc.c (errprint): Remove abort() call which causes interesting error
message printing to abort prematurely.
* environ.cc: Sprinkle MALLOC_CHECKs liberally throughout.
(_addenv): Allocate two empty elements at end of environ to
(apparently) work around problems with some buggy applications.
(winenv): Avoid calling alloca if no forced environment variable is present.

* exceptions.cc (open_stackdumpfile): Don't print "Dumping stack trace to..."
when running in a cygwin environment (i.e., the parent is a cygwin process).

* dtable.cc (dtable::init_std_file_from_handle): Move device type detection
code from build_fhandler here since it is only used by this function.
(dtable::build_fhandler_from_name): New method.  Renamed from
dtable::build_fhandler.
(dtable::build_fhandler): Use build_fhandler_from_name.
(cygwin_attach_handle_to_fd): Ditto.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
* dtable.h (dtable::build_fhandler_from_name): Rename declaration from
dtable::build_fhandler.
@
text
@d258 1
a262 1
  void *buf = ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_union) + 100);
d268 1
a268 1
	fh = new (buf) fhandler_tty_master (name, unit);
d273 1
a273 1
	fh = new (buf) fhandler_console (name);
d277 1
a277 1
	fh = new (buf) fhandler_pty_master (name);
d281 1
a281 1
	  fh = new (buf) fhandler_tty_slave (name);
d283 1
a283 1
	  fh = new (buf) fhandler_tty_slave (unit, name);
d286 1
a286 1
	fh = new (buf) fhandler_windows (name);
d289 1
a289 1
	fh = new (buf) fhandler_serial (name, dev, unit);
d294 1
a294 1
	fh = new (buf) fhandler_pipe (name, dev);
d297 1
a297 1
	fh = new (buf) fhandler_socket (name);
d300 1
a300 1
	fh = new (buf) fhandler_disk_file (NULL);
d303 1
a303 1
	fh = new (buf) fhandler_dev_floppy (name, unit);
d306 1
a306 1
	fh = new (buf) fhandler_dev_tape (name, unit);
d309 1
a309 1
	fh = new (buf) fhandler_dev_null (name);
d312 1
a312 1
	fh = new (buf) fhandler_dev_zero (name);
d315 1
a315 1
	fh = new (buf) fhandler_dev_random (name, unit);
d318 1
a318 1
	fh = new (buf) fhandler_dev_mem (name, unit);
d321 1
a321 1
	fh = new (buf) fhandler_dev_clipboard (name);
d324 1
a324 1
	fh = new (buf) fhandler_dev_dsp (name);
@


1.56
log
@* dtable.h (dtable::build_fhandler): Make path_conv parameter non-optional.
(dtable::init_std_file_from_handle): Eliminate name parameter.
* dtable.cc (stdio_init): Don't pass bogus name to init_std_file_from_handle.
The function will figure out the name itself.
(dtable::init_std_file_from_handle): Eliminate name parameter.  Assume that
we're always called with an appropriate fd.  Pass name as NULL if we can't
simply figure it out from context.
(cygwin_attach_handle_to_fd): Pass path_conv argument to build_fhandler.
(dtable::build_fhandler): Make path_conv argument mandatory.  Eliminate
specific call to get_device_number.  With unknown device names, set name from
handle context for parsing by path_conv.
(dtable::build_fhandler): Pass path_conv argument to build_fhandler.
* path.h (path_conv::set_isdisk): Set disk device type.
(path_conv::is_device): Don't consider FH_DISK a "device".
* syscalls.cc (_open): Pass path_conv argument by reference.
(stat_worker): Ditto.
(_rename): Use path_conv operators.  Add bounds to DeleteFile/MoveFile for
loop.
@
text
@d171 14
d186 1
a186 2
dtable::init_std_file_from_handle (int fd, HANDLE handle,
				  DWORD myaccess)
d189 7
a195 1
  const char *name = NULL;
a201 1
  first_fd_for_open = 0;
a203 1
  CONSOLE_SCREEN_BUFFER_INFO buf;
d212 1
a212 1
  else if (FlushConsoleInputBuffer (handle))
d224 1
a224 1
      else if (fd == 1 || fd == 2)
d229 6
d237 1
a237 1
  build_fhandler (fd, name, handle, pc)->init (handle, myaccess, bin);
a241 13
extern "C"
int
cygwin_attach_handle_to_fd (char *name, int fd, HANDLE handle, mode_t bin,
			    DWORD myaccess)
{
  if (fd == -1)
    fd = cygheap->fdtab.find_unused_handle ();
  path_conv pc;
  fhandler_base *res = cygheap->fdtab.build_fhandler (fd, name, handle, pc);
  res->init (handle, myaccess, bin);
  return fd;
}

d243 2
a244 2
dtable::build_fhandler (int fd, const char *name, HANDLE handle, path_conv& pc,
    			unsigned opt, suffix_info *si)
a245 21
  if (!name && handle)
    {
      struct sockaddr sa;
      int sal = sizeof (sa);
      CONSOLE_SCREEN_BUFFER_INFO cinfo;
      DCB dcb;

      if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &cinfo))
	name = "/dev/conin";
      else if (GetConsoleScreenBufferInfo (handle, &cinfo))
	name = "/dev/conout";
      else if (wsock_started && getpeername ((SOCKET) handle, &sa, &sal) == 0)
	name = "/dev/socket";
      else if (GetFileType (handle) == FILE_TYPE_PIPE)
	name = "/dev/pipe";
      else if (GetCommState (handle, &dcb))
	name = "/dev/ttyS0"; // FIXME - determine correct device
      else
	name = "some disk file";
    }

d330 1
a330 1
	  return build_fhandler (fd, name, NULL, pc);
@


1.55
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d109 1
a109 1
      cygheap->fdtab.init_std_file_from_handle (0, in, GENERIC_READ, "{stdin}");
d127 2
a128 2
      cygheap->fdtab.init_std_file_from_handle (1, out, GENERIC_WRITE, "{stdout}");
      cygheap->fdtab.init_std_file_from_handle (2, err, GENERIC_WRITE, "{stderr}");
d173 1
a173 1
				  DWORD myaccess, const char *name)
d176 1
d183 28
a210 29
  /* Check to see if we're being redirected - if not then
     we open then as consoles */
  if (fd == 0 || fd == 1 || fd == 2)
    {
      first_fd_for_open = 0;
      /* See if we can consoleify it  - if it is a console,
       don't open it in binary.  That will screw up our crlfs*/
      CONSOLE_SCREEN_BUFFER_INFO buf;
      if (GetConsoleScreenBufferInfo (handle, &buf))
	{
	  bin = 0;
	  if (ISSTATE (myself, PID_USETTY))
	    name = "/dev/tty";
	  else
	    name = "/dev/conout";
	}
      else if (FlushConsoleInputBuffer (handle))
	{
	  bin = 0;
	  if (ISSTATE (myself, PID_USETTY))
	    name = "/dev/tty";
	  else
	    name = "/dev/conin";
	}
      else if (GetFileType (handle) == FILE_TYPE_PIPE)
	{
	  if (bin == 0)
	    bin = O_BINARY;
	}
d214 1
a214 1
  build_fhandler (fd, name, handle, &pc)->init (handle, myaccess, bin);
d222 1
a222 1
			      DWORD myaccess)
d226 2
a227 1
  fhandler_base *res = cygheap->fdtab.build_fhandler (fd, name, handle);
d233 1
a233 1
dtable::build_fhandler (int fd, const char *name, HANDLE handle, path_conv *pc,
d236 1
a236 19
  int unit;
  DWORD devn;
  fhandler_base *fh;

  if (!pc)
    devn = get_device_number (name, unit);
  else
    {
      pc->check (name, opt | PC_NULLEMPTY, si);
      if (pc->error)
	{
	  set_errno (pc->error);
	  return NULL;
	}
      devn = pc->get_devn ();
      unit = pc->get_unitn ();
    }

  if (devn == FH_BAD)
d243 2
a244 4
      if (handle == NULL)
	devn = FH_DISK;
      else if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &cinfo))
	devn = FH_CONIN;
d246 1
a246 1
	devn= FH_CONOUT;
d248 1
a248 1
	devn = FH_SOCKET;
d250 1
a250 1
	devn = FH_PIPE;
d252 1
a252 1
	devn = FH_SERIAL;
d254 1
a254 1
	devn = FH_DISK;
d257 9
a265 3
  fh = build_fhandler (fd, devn, name, unit);
  if (pc)
    fh->set_name (name, *pc, unit);
d338 5
a342 2
	/* FIXME - this could recurse forever */
	return build_fhandler (fd, name, NULL);
@


1.54
log
@* fhandler.h (fhandler_pipe::hit_eof): New method.
(writepipe_exists): New class element.
(orig_pid): Ditto.
(id): Ditto.
(is_slow): Eliminate.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance on
writepipe_exists, if it exists.
(fhandler_pipe::hit_eof): New method, modelled after tty.
(fhandler_pipe::dup): Duplicate writepipe_exists, if it exists.
(make_pipe): Set up a dummy event for pipes on windows 9x.  The nonexistence
of this event means that the write side of the pipe has closed.
(_dup): Move to syscalls.cc
(_dup2): Ditto.

* dtable.cc (dtable::build_fhandler): Fill out set_names here, if appropriate.
* syscalls.cc (_open): Call set_names in build_fhandler.
@
text
@d213 2
a214 1
  build_fhandler (fd, name, handle)->init (handle, myaccess, bin);
d232 2
a233 1
dtable::build_fhandler (int fd, const char *name, HANDLE handle, path_conv *pc)
d243 6
a248 1
      pc->check (name);
d278 1
a278 1
    fh->set_name (name, *pc);
d442 8
@


1.54.2.1
log
@Merged changes from HEAD
@
text
@d109 1
a109 1
      cygheap->fdtab.init_std_file_from_handle (0, in, GENERIC_READ);
d127 2
a128 2
      cygheap->fdtab.init_std_file_from_handle (1, out, GENERIC_WRITE);
      cygheap->fdtab.init_std_file_from_handle (2, err, GENERIC_WRITE);
d173 1
a173 1
				  DWORD myaccess)
a175 1
  const char *name = NULL;
d182 29
a210 28
  first_fd_for_open = 0;
  /* See if we can consoleify it  - if it is a console,
   don't open it in binary.  That will screw up our crlfs*/
  CONSOLE_SCREEN_BUFFER_INFO buf;
  if (GetConsoleScreenBufferInfo (handle, &buf))
    {
      if (ISSTATE (myself, PID_USETTY))
	name = "/dev/tty";
      else
	name = "/dev/conout";
      bin = 0;
    }
  else if (FlushConsoleInputBuffer (handle))
    {
      if (ISSTATE (myself, PID_USETTY))
	name = "/dev/tty";
      else
	name = "/dev/conin";
      bin = 0;
    }
  else if (GetFileType (handle) == FILE_TYPE_PIPE)
    {
      if (fd == 0)
	name = "/dev/piper";
      else if (fd == 1 || fd == 2)
	name = "/dev/pipew";
      if (bin == 0)
	bin = O_BINARY;
d213 1
a213 2
  path_conv pc;
  build_fhandler (fd, name, handle, pc)->init (handle, myaccess, bin);
d221 1
a221 1
			    DWORD myaccess)
d225 1
a225 2
  path_conv pc;
  fhandler_base *res = cygheap->fdtab.build_fhandler (fd, name, handle, pc);
d231 1
a231 2
dtable::build_fhandler (int fd, const char *name, HANDLE handle, path_conv& pc,
    			unsigned opt, suffix_info *si)
d233 14
a246 1
  if (!name && handle)
d253 4
a256 2
      if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &cinfo))
	name = "/dev/conin";
d258 1
a258 1
	name = "/dev/conout";
d260 1
a260 1
	name = "/dev/socket";
d262 1
a262 1
	name = "/dev/pipe";
d264 1
a264 1
	name = "/dev/ttyS0"; // FIXME - determine correct device
d266 1
a266 1
	name = "some disk file";
d269 3
a271 9
  pc.check (name, opt | PC_NULLEMPTY, si);
  if (pc.error)
    {
      set_errno (pc.error);
      return NULL;
    }

  fhandler_base *fh = build_fhandler (fd, pc.get_devn (), name, pc.get_unitn ());
  fh->set_name (name, pc, pc.get_unitn ());
d344 2
a345 5
	{
	  /* FIXME - this could recurse forever */
	  path_conv pc;
	  return build_fhandler (fd, name, NULL, pc);
	}
a434 8
}

void
dtable::reset_unix_path_name (int fd, const char *name)
{
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "reset_unix_name");
  fds[fd]->reset_unix_path_name (name);
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "reset_unix_name");
@


1.54.2.2
log
@Merged changes from HEAD
@
text
@a20 1
#include <assert.h>
d58 1
a58 2
  if (console_fds > 0 && !--console_fds &&
      myself->ctty != TTY_CONSOLE && !check_pty_fds())
a170 14
extern "C"
int
cygwin_attach_handle_to_fd (char *name, int fd, HANDLE handle, mode_t bin,
			    DWORD myaccess)
{
  if (fd == -1)
    fd = cygheap->fdtab.find_unused_handle ();
  path_conv pc;
  fhandler_base *res = cygheap->fdtab.build_fhandler_from_name (fd, name, handle,
								pc);
  res->init (handle, myaccess, bin);
  return fd;
}

d172 2
a173 1
dtable::init_std_file_from_handle (int fd, HANDLE handle, DWORD myaccess)
d176 1
a176 10
  const char *name;
  CONSOLE_SCREEN_BUFFER_INFO buf;
  struct sockaddr sa;
  int sal = sizeof (sa);
  DCB dcb;

  first_fd_for_open = 0;

  if (!handle || handle == INVALID_HANDLE_VALUE)
    return;
d183 1
d186 1
d195 1
a195 1
  else if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &buf))
d207 1
a207 1
      else
a211 6
  else if (wsock_started && getpeername ((SOCKET) handle, &sa, &sal) == 0)
    name = "/dev/socket";
  else if (GetCommState (handle, &dcb))
    name = "/dev/ttyS0"; // FIXME - determine correct device
  else
    name = "unknown disk file";
d214 1
a214 1
  build_fhandler_from_name (fd, name, handle, pc)->init (handle, myaccess, bin);
d219 13
d233 2
a234 2
dtable::build_fhandler_from_name (int fd, const char *name, HANDLE handle,
				  path_conv& pc, unsigned opt, suffix_info *si)
d236 22
a257 1
  pc.check (name, opt | PC_NULLEMPTY | PC_FULL, si);
a268 1
#define cnew(name) new ((void *) ccalloc (HEAP_FHANDLER, 1, sizeof (name))) name
d273 1
d279 1
a279 1
	fh = cnew (fhandler_tty_master) (unit);
d284 2
a285 2
	if ((fh = cnew (fhandler_console) ()))
	  inc_console_fds ();
d288 1
a288 1
	fh = cnew (fhandler_pty_master) ();
d292 1
a292 1
	  fh = cnew (fhandler_tty_slave) ();
d294 1
a294 1
	  fh = cnew (fhandler_tty_slave) (unit);
d297 1
a297 1
	fh = cnew (fhandler_windows) ();
d300 1
a300 1
	fh = cnew (fhandler_serial) (unit);
d305 1
a305 1
	fh = cnew (fhandler_pipe) (dev);
d308 1
a308 2
	if ((fh = cnew (fhandler_socket) ()))
	  inc_need_fixup_before ();
d311 1
a311 4
	fh = cnew (fhandler_disk_file) ();
	break;
      case FH_CYGDRIVE:
	fh = cnew (fhandler_cygdrive) (unit);
d314 1
a314 1
	fh = cnew (fhandler_dev_floppy) (unit);
d317 1
a317 1
	fh = cnew (fhandler_dev_tape) (unit);
d320 1
a320 1
	fh = cnew (fhandler_dev_null) ();
d323 1
a323 1
	fh = cnew (fhandler_dev_zero) ();
d326 1
a326 1
	fh = cnew (fhandler_dev_random) (unit);
d329 1
a329 1
	fh = cnew (fhandler_dev_mem) (unit);
d332 1
a332 1
	fh = cnew (fhandler_dev_clipboard) ();
d335 1
a335 1
	fh = cnew (fhandler_dev_dsp) ();
d338 5
a342 2
	system_printf ("internal error -- unknown device - %p", dev);
	fh = NULL;
d345 2
a346 1
  debug_printf ("fd %d, fh %p", fd, fh);
a396 1
  debug_printf ("newfh->io_handle %p, oldfh->io_handle %p", newfh->get_io_handle (), fds[oldfd]->get_io_handle ());
d406 1
a406 1
  if ((size_t) newfd >= size)
d409 2
a410 2
		    size;
     extend (inc_size);
d417 4
a571 4
  /* Remove impersonation */
  if (cygheap->user.impersonated && cygheap->user.token != INVALID_HANDLE_VALUE)
    RevertToSelf ();

a583 4
  /* Restore impersonation */
  if (cygheap->user.impersonated && cygheap->user.token != INVALID_HANDLE_VALUE)
    ImpersonateLoggedOnUser (cygheap->user.token);

a598 1
  assert (fds_on_hold != NULL);
@


1.54.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d94 2
a95 2
   This function should only be called when a cygwin function is invoked
   by a non-cygwin function, i.e., it should only happen very rarely. */
d200 1
a200 4
    {
      fds[fd] = NULL;
      return;
    }
@


1.54.2.4
log
@Merged changes from HEAD
@
text
@d37 1
a37 1
					   STD_ERROR_HANDLE};
a92 26
void
dtable::get_debugger_info ()
{
  if (IsDebuggerPresent ())
    {
      char std[3][sizeof ("/dev/ttyNNNN")];
      std[0][0] = std[1][0] = std [2][0] = '\0';
      char buf[sizeof ("cYgstd %x") + 32];
      sprintf (buf, "cYgstd %x %x %x", (unsigned) &std, sizeof (std[0]), 3);
      OutputDebugString (buf);
      for (int i = 0; i < 3; i++)
	if (std[i][0])
	  {
	    path_conv pc;
	    HANDLE h = GetStdHandle (std_consts[i]);
	    fhandler_base *fh = build_fhandler_from_name (i, std[i], NULL, pc);
	    if (!fh)
	      continue;
	    if (!fh->open (&pc, (i ? O_WRONLY : O_RDONLY) | O_BINARY, 0777))
	      release (i);
	    else
	      CloseHandle (h);
	  }
    }
}

d98 1
a98 1
dtable::stdio_init ()
d105 12
a116 18
  if (myself->ppid_handle || ISSTATE (myself, PID_CYGPARENT))
    return;

  HANDLE in = GetStdHandle (STD_INPUT_HANDLE);
  HANDLE out = GetStdHandle (STD_OUTPUT_HANDLE);
  HANDLE err = GetStdHandle (STD_ERROR_HANDLE);

  init_std_file_from_handle (0, in, GENERIC_READ);

  /* STD_ERROR_HANDLE has been observed to be the same as
     STD_OUTPUT_HANDLE.  We need separate handles (e.g. using pipes
     to pass data from child to parent).  */
  if (out == err)
    {
      /* Since this code is not invoked for forked tasks, we don't have
	 to worry about the close-on-exec flag here.  */
      if (!DuplicateHandle (hMainProc, out, hMainProc, &err, 0,
			     1, DUPLICATE_SAME_ACCESS))
d118 9
a126 3
	  /* If that fails, do this as a fall back.  */
	  err = out;
	  system_printf ("couldn't make stderr distinct from stdout");
d128 7
a135 7

  init_std_file_from_handle (1, out, GENERIC_WRITE);
  init_std_file_from_handle (2, err, GENERIC_WRITE);
  /* Assign the console as the controlling tty for this process if we actually
     have a console and no other controlling tty has been assigned. */
  if (myself->ctty < 0 && GetConsoleCP () > 0)
    set_console_ctty ();
a198 3
  if (!not_open (fd))
    return;

d261 3
a263 1
  return build_fhandler (fd, pc.get_devn (), name, pc, pc.get_unitn ());
d268 1
a268 2
dtable::build_fhandler (int fd, DWORD dev, const char *unix_name,
			const char *win32_name, int unit)
a342 14
  if (unix_name)
    {
      char new_win32_name[strlen (unix_name) + 1];
      if (!win32_name)
	{
	  char *p;
	  /* FIXME: ? Should we call win32_device_name here?
	     It seems like overkill, but... */
	  win32_name = strcpy (new_win32_name, unix_name);
	  for (p = (char *) win32_name; (p = strchr (p, '/')); p++)
	    *p = '\\';
	}
      fh->set_name (unix_name, win32_name, fh->get_unit ());
    }
@


1.54.2.5
log
@Merged changes from HEAD
@
text
@d19 1
a21 2
#include <ntdef.h>
#include <winnls.h>
d25 2
a34 1
#include "ntdll.h"
a38 2
static char *handle_to_fn (HANDLE, char *);

d96 1
a96 1
  if (being_debugged ())
d216 1
d228 8
a235 4
  SetLastError (0);
  DWORD ft = GetFileType (handle);
  if (ft == FILE_TYPE_UNKNOWN && GetLastError () == ERROR_INVALID_HANDLE)
    name = NULL;
d237 5
d243 2
a244 26
      /* See if we can consoleify it */
      if (GetConsoleScreenBufferInfo (handle, &buf))
	{
	  if (ISSTATE (myself, PID_USETTY))
	    name = "/dev/tty";
	  else
	    name = "/dev/conout";
	}
      else if (GetNumberOfConsoleInputEvents (handle, (DWORD *) &buf))
	{
	  if (ISSTATE (myself, PID_USETTY))
	    name = "/dev/tty";
	  else
	    name = "/dev/conin";
	}
      else if (ft == FILE_TYPE_PIPE)
	{
	  if (fd == 0)
	    name = "/dev/piper";
	  else
	    name = "/dev/pipew";
	}
      else if (wsock_started && getpeername ((SOCKET) handle, &sa, &sal) == 0)
	name = "/dev/socket";
      else if (GetCommState (handle, &dcb))
	name = "/dev/ttyS0"; // FIXME - determine correct device
d246 2
a247 1
	name = handle_to_fn (handle, (char *) alloca (MAX_PATH + 100));
d249 1
a249 4

  if (!name)
    fds[fd] = NULL;
  else
d251 5
a255 5
      path_conv pc;
      build_fhandler_from_name (fd, name, handle, pc)->init (handle, myaccess,
							     pc.binmode ());
      set_std_handle (fd);
      paranoid_printf ("fd %d, handle %p", fd, handle);
d257 20
d283 1
a283 1
  pc.check (name, opt | PC_NULLEMPTY | PC_FULL | PC_POSIX, si);
d290 1
a290 7
  if (!pc.exists () && handle)
    pc.fillin (handle);

  fhandler_base *fh = build_fhandler (fd, pc.get_devn (),
				      pc.return_and_clear_normalized_path (),
				      pc, pc.get_unitn ());
  return fh;
d293 1
a297 8
  return build_fhandler (fd, dev, cstrdup (unix_name), win32_name, unit);
}

#define cnew(name) new ((void *) ccalloc (HEAP_FHANDLER, 1, sizeof (name))) name
fhandler_base *
dtable::build_fhandler (int fd, DWORD dev, char *unix_name,
			const char *win32_name, int unit)
{
a365 9
      case FH_PROC:
	fh = cnew (fhandler_proc) ();
	break;
      case FH_REGISTRY:
	fh = cnew (fhandler_registry) ();
	break;
      case FH_PROCESS:
	fh = cnew (fhandler_process) ();
	break;
d392 1
a392 1
  fhandler_base *newfh = build_fhandler (-1, oldfh->get_device ());
d470 8
d624 4
a631 4
  /* Restore impersonation */
  if (cygheap->user.impersonated && cygheap->user.token != INVALID_HANDLE_VALUE)
    ImpersonateLoggedOnUser (cygheap->user.token);

a680 125

#if 0
static char *
handle_to_fn (HANDLE h, char *posix_fn)
{
  IO_STATUS_BLOCK io;
  FILE_NAME_INFORMATION ntfn;

  io.Status = 0;
  io.Information = 0;

  SetLastError (0);
  DWORD res = NtQueryInformationFile (h, &io, &ntfn, sizeof (ntfn), 9);
  if (res || GetLastError () == ERROR_PROC_NOT_FOUND)
    {
      strcpy (posix_fn, "some disk file");
      return posix_fn;
    }
  ntfn.FileName[ntfn.FileNameLength / sizeof (WCHAR)] = 0;

  char win32_fn[MAX_PATH + 100];
  sys_wcstombs (win32_fn, ntfn.FileName, ntfn.FileNameLength);
  cygwin_conv_to_full_posix_path (win32_fn, posix_fn);
  return posix_fn;
}
#else
#define DEVICE_PREFIX "\\device\\"
#define DEVICE_PREFIX_LEN sizeof(DEVICE_PREFIX) - 1
#define REMOTE "\\Device\\LanmanRedirector\\"
#define REMOTE_LEN sizeof (REMOTE) - 1

static char *
handle_to_fn (HANDLE h, char *posix_fn)
{
  OBJECT_NAME_INFORMATION *ntfn;
  char fnbuf[32768];

  memset (fnbuf, 0, sizeof (fnbuf));
  ntfn = (OBJECT_NAME_INFORMATION *) fnbuf;
  ntfn->Name.MaximumLength = sizeof (fnbuf) - sizeof (*ntfn);
  ntfn->Name.Buffer = (WCHAR *) (ntfn + 1);

  DWORD res = NtQueryObject (h, ObjectNameInformation, ntfn, sizeof (fnbuf), NULL);

  if (res)
    {
      strcpy (posix_fn, "some disk file");
      debug_printf ("NtQueryObject failed");
      return posix_fn;
    }

  // NT seems to do this on an unopened file
  if (!ntfn->Name.Buffer)
    {
      debug_printf ("nt->Name.Buffer == NULL");
      return NULL;
    }

  ntfn->Name.Buffer[ntfn->Name.Length / sizeof (WCHAR)] = 0;

  char win32_fn[MAX_PATH + 100];
  sys_wcstombs (win32_fn, ntfn->Name.Buffer, ntfn->Name.Length);
  debug_printf ("nt name '%s'", win32_fn);
  if (!strncasematch (win32_fn, DEVICE_PREFIX, DEVICE_PREFIX_LEN)
      || !QueryDosDevice (NULL, fnbuf, sizeof (fnbuf)))
    return strcpy (posix_fn, win32_fn);
  
  char *p = strchr (win32_fn + DEVICE_PREFIX_LEN, '\\');
  if (!p)
    p = strchr (win32_fn + DEVICE_PREFIX_LEN, '\0');

  int n = p - win32_fn;
  int maxmatchlen = 0;
  char *maxmatchdos = NULL;
  for (char *s = fnbuf; *s; s = strchr (s, '\0') + 1)
    {
      char device[MAX_PATH + 10];
      device[MAX_PATH + 9] = '\0';
      if (strchr (s, ':') == NULL)
	continue;
      if (!QueryDosDevice (s, device, sizeof (device) - 1))
	continue;
      char *q = strrchr (device, ';');
      if (q)
	{
	  char *r = strchr (q, '\\');
	  if (r)
	    strcpy (q, r + 1);
	}
      int devlen = strlen (device);
      if (device[devlen - 1] == '\\')
	device[--devlen] = '\0';
      if (devlen < maxmatchlen)
	continue;
      if (!strncasematch (device, win32_fn, devlen) ||
	  (win32_fn[devlen] != '\0' && win32_fn[devlen] != '\\'))
	continue;
      maxmatchlen = devlen;
      maxmatchdos = s;
      debug_printf ("current match '%s'", device);
    }

  char *w32 = win32_fn;
  if (maxmatchlen)
    {
      n = strlen (maxmatchdos);
      if (maxmatchdos[n - 1] == '\\')
	n--;
      w32 += maxmatchlen - n;
      memcpy (w32, maxmatchdos, n);
      w32[n] = '\\';
    }
  else if (strncasematch (w32, REMOTE, REMOTE_LEN))
    {
      w32 += REMOTE_LEN - 2;
      *w32 = '\\';
      debug_printf ("remote drive");
    }


  debug_printf ("derived path '%s'", w32);
  cygwin_conv_to_full_posix_path (w32, posix_fn);
  return posix_fn;
}
#endif
@


1.54.2.6
log
@Merged changes from HEAD
@
text
@d621 1
a621 1
  if (cygheap->user.issetuid ())
d641 1
a641 1
  if (cygheap->user.issetuid ())
@


1.54.2.7
log
@Merged changes from HEAD
@
text
@d170 1
d173 1
a173 1
      for (size_t i = start; i < size; i++)
a435 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
a443 7
  if (newfd < 0)
    {
      syscall_printf ("new fd out of bounds: %d", newfd);
      set_errno (EBADF);
      goto done;
    }

d456 2
a457 2
  debug_printf ("newfh->io_handle %p, oldfh->io_handle %p",
		newfh->get_io_handle (), fds[oldfd]->get_io_handle ());
d459 1
a459 5
  if (!not_open (newfd))
    _close (newfd);
  else if ((size_t) newfd < size)
    /* nothing to do */;
  else if (find_unused_handle (newfd) < 0)
d461 2
a462 2
      newfh->close ();
      res = -1;
d466 9
d477 3
d483 1
a484 2
  MALLOC_CHECK;
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
@


1.54.2.8
log
@Merged changes from HEAD
@
text
@d200 2
a201 1
extern "C" int
d694 25
d817 1
@


1.54.2.9
log
@Merged changes from HEAD
@
text
@d209 1
a209 1
  res->init (handle, myaccess, bin ?: pc.binmode ());
@


1.54.2.10
log
@Merged changes from HEAD
@
text
@d733 1
a733 1

@


1.53
log
@        * dtable.cc (dtable::build_fhandler): Initialize unit when using
        optional path_conv argument.
@
text
@d235 1
d269 4
a272 1
  return build_fhandler (fd, devn, name, unit);
@


1.52
log
@* dtable.cc (dtable::build_fhandler): Accept an optional path_conv argument.
If available, use this to calculate path name and device number.
* dtable.h (dtable): Reflect above change.
* fhandler.h (fhandler_base): Declare virtual method which accepts path_conv
rather than path string as first argument.
* fhandler.cc (fhandler_base::open): Define above new method.
* syscalls.cc (_open): Set aside a path_conv variable for use in build_fhandler
and subsequent call to open.
@
text
@d242 1
@


1.51
log
@Update copyrights.
@
text
@d231 1
a231 1
dtable::build_fhandler (int fd, const char *name, HANDLE handle)
d236 9
a244 1
  if ((devn = get_device_number (name, unit)) == FH_BAD)
@


1.50
log
@* cygwin.din: Remove cygwin_getshared.
* shared.cc: Ditto.
* include/cygwin/version.h: Bump API minor number.
* dtable.cc (dtable::build_fhandler): Fix incorrect test for socket.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Cygnus Solutions.
@


1.49
log
@* dtable.cc (dtable::fixup_after_fork): Use SetStdHandle appropriately on
inherited fds.
@
text
@d249 1
a249 1
      else if (wsock_started && getpeername ((SOCKET) handle, &sa, &sal))
@


1.48
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d539 4
@


1.47
log
@* thread.cc (InterlockedExchangePointer): Don't define if it already exists.
@
text
@d35 1
a35 1
static DWORD std_consts[] = {STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,
@


1.46
log
@* dtable.cc (dtable::dup2): Allow extension of fd table by dup2.
* syscalls.cc: Minor code cleanup.
(fpathconf): Check for bad fd before doing anything else.
* termios.cc (tcsetattr): Don't convert to new termios if bad fd.
(tcgetattr): Minor debugging tweak.
@
text
@d36 1
a36 1
			   STD_ERROR_HANDLE};
d43 1
a43 1
    cygheap->fdtab.extend(NOFILE_INCR);
d71 1
a71 1
  /* Try to allocate more space for fd table. We can't call realloc()
d103 1
a103 1
  if (!myself->ppid_handle && NOTSTATE(myself, PID_CYGPARENT))
d139 1
a139 1
  AssertResourceOwner(LOCK_FD_LIST, READ_LOCK);
d224 1
a224 1
    fd = cygheap->fdtab.find_unused_handle();
d387 1
a387 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d411 1
a411 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d480 1
a480 1
  SetResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fixup_before_fork");
d485 1
a485 1
	debug_printf ("fd %d(%s)", i, fh->get_name ());
d488 1
a488 1
  ReleaseResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fixup_before_fork");
d499 1
a499 1
	debug_printf ("fd %d(%s)", i, fh->get_name ());
d536 1
a536 1
	    debug_printf ("fd %d(%s)", i, fh->get_name ());
d546 2
a547 1
  newtable = (fhandler_base **) ccalloc (HEAP_ARGV, size, sizeof(fds[0]));
a549 1
  SetResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d564 1
d566 1
a566 1
  ReleaseResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d573 1
a573 1
  SetResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "restore");
d581 1
a581 1
  ReleaseResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "restore");
@


1.45
log
@* smallprint.c (console_printf): New function.
* dcrt0.cc (dll_crt0_1): Use console_printf for debugging output.
* debug.cc (debug_mark_closed): New function.
(close_handle): Use debug_mark_closed.
* debug.h: Declare new functions.
* dtable.cc (dtable::build_fhandler): Remove unneeded extern.
* spawn.cc: Cosmetic changes.
* winsup.h: Define NO_COPY for C files, too.  Declare a global.
@
text
@d389 1
a389 1
  if ((size_t) newfd >= cygheap->fdtab.size || newfd < 0)
@


1.44
log
@* dtable.cc (dtable::release): Avoid messing with console when
closing socket.
@
text
@a234 1
  extern bool wsock_started;
@


1.43
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d161 1
d164 1
@


1.42
log
@* syscalls.cc (setsid): Detach process from its console if the current
controlling tty is the console and already closed.
* dtable.h (class dtable): Add members to count descriptors referring to the
console.
* dtable.cc (dtable::dec_console_fds): New function to detach process from its
console.
(dtable::release): Decrement the counter of console descriptors.
(dtable::build_fhandler): Increment it.
* exception.cc (ctrl_c_handler): Send SIGTERM to myself when catch
CTRL_SHUTDOWN_EVENT.
@
text
@d29 1
@


1.41
log
@* cygheap.cc (cygheap_fixup_in_child): Attempt Win95 workaround.
* dtable.cc (dtable::dup_worker): Add debugging output.
(dtable::vfork_child_dup): Correctly set close_on_exec.
* fhandler.cc (fhandler_base::fork_fixup): Don't mess with handle if there is
no need to get it from the parent.
* fhandler_tty.cc (fhandler_tty_common::close): Add debugging output.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
d54 7
d156 7
a162 2
      if ((fds[fd]->get_device () & FH_DEVMASK) == FH_SOCKET)
        dec_need_fixup_before ();
d276 1
@


1.40
log
@forced commit
@
text
@d340 1
d538 3
a540 1
    else if ((newtable[i] = dup_worker (fds[i])) == NULL)
d574 1
@


1.39
log
@* autoload.h: Eliminate.
* autoload.cc: Pull in autoload.h.  Eliminate many macros.  Rewrite to avoid
necessity of initialization routines.  Just use a standard one.
(wsock_init): New function.  Moved from net.cc.
* net.cc (wsock_init): Move to autoload.cc.
(wsadata): Make global.
* dtable.cc (dtable::build_fhandler): Use more reliable method for checking if
net stuff has been loaded.
@
text
@@


1.38
log
@* cygheap.cc (_cfree): Add regparm attribute.
(_crealloc): Ditto.
* dcrt0.cc (dll_crt0_1): Default to always checking for executable for now.
* dtable.cc (dtable::not_open): Move method.
* dtable.h (dtable): Here.
* exceptions.cc (ctrl_c_handler): Don't expect process group leader to handle a
signal if it doesn't exist.
* fhandler.h (fhandler_base): Make openflags protected.
* localtime.c (tzsetwall): Check for __CYGWIN__ as well as __WIN32__.
* path.cc (path_conv::check): Add some comments.  Change strcat to assignment.
* lib/_cygwin_S_IEXEC.cc (_cygwin_bob__): Eliminate.
* fhandler_tty.cc (fhandler_console::dup): Set controlling terminal if
necessary.
* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
@
text
@d220 1
d235 1
a235 1
      else if (wsock32_handle && getpeername ((SOCKET) handle, &sa, &sal))
@


1.37
log
@Throughout, change 'tty_attached' to 'real_tty_attached', for clarity.
Throughout, change 'OutputStopped' to 'output_stopped', for consistency.
* dtable.cc (stdio_init): Set controlling tty if not set by stdio opens.
* exceptions.cc (ctrl_c_handler): Avoid special pgid checking if no tty is
associated with the process.
(Suggested by Tim Baker <dbaker@@direct.ca>)
* external.cc (fillout_pinfo): Return actual tty number for ctty.
* fhandler_console.cc (get_tty_stuff): Set ctty when shared memory is
allocated.  Accept flags input from open().
(set_console_ctty): New function.
(fhandler_console::open): Pass flags to get_tty_stuff and rely on this function
to set the ctty, if appropriate.
* fhandler_termios.cc (fhandler_termios::set_ctty): Move to tty_min class.
* fhandler_tty.cc (fhandler_tty_slave::open): Use tc field to access
set_ctty().
* tty.h (TTY_CONSOLE): Move to include/sys/cygwin.h.
(tty_min): Add set_ctty class here.
* include/sys/cygwin.h (TTY_CONSOLE): New home here.
* path.cc (symlink_info): Make contents an actual buffer.  Pass more flags to
case_check.
(path_conv::check): Reorganize to do parsing based on posix path rather than
native path.
(symlink_info::check): Expect posix path as input.  Translate to native path
here.  Accept path_conv flags.  Stop parsing if not a symlink regardless of
whether previous path was a symlink.
@
text
@a128 11
dtable::not_open (int fd)
{
  SetResourceLock(LOCK_FD_LIST, READ_LOCK, "not_open");

  int res = fd < 0 || fd >= (int)size || fds[fd] == NULL;

  ReleaseResourceLock(LOCK_FD_LIST, READ_LOCK, "not open");
  return res;
}

int
@


1.36
log
@* include/sys/file.h: Move X_OK protection earlier.
* dtable.cc (dtable::vfork_child_fixup): Avoid closing already closed handles.
@
text
@d90 1
d121 4
@


1.35
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@a582 1
        fh->close ();
d584 7
a590 1
        cygheap->fdtab.release (i);
@


1.34
log
@* autoload.cc: Add winmm functions needed by fhandler_dsp.cc.
* fhandler_dsp.cc: New file.  Implements OSS like /dev/dsp.
* include/sys/soundcard.h: New file.  User land includes for OSS /dev/dsp.
* fhandler.h: Add new class fhandler_dev_dsp and a FH_OSS_DSP definition.
* dtable.cc (dtable::build_fhandler): Allow creation of the /dev/dsp device.
* path.cc (windows_device_names): Add /dev/dsp into list of device names.
* Makefile.in (DLL_OFILES): Add fhandler_dsp.o.
@
text
@a26 1
#include "cygheap.h"
d32 1
a32 2

dtable fdtab;
d41 2
a42 2
  if (!fdtab.size)
    fdtab.extend(NOFILE_INCR);
d49 1
a49 1
    SetStdHandle (std_consts[fd], fdtab[fd]->get_handle ());
d51 1
a51 1
    SetStdHandle (std_consts[fd], fdtab[fd]->get_output_handle ());
d100 1
a100 1
      fdtab.init_std_file_from_handle (0, in, GENERIC_READ, "{stdin}");
d118 2
a119 2
      fdtab.init_std_file_from_handle (1, out, GENERIC_WRITE, "{stdout}");
      fdtab.init_std_file_from_handle (2, err, GENERIC_WRITE, "{stderr}");
d126 1
a126 1
  SetResourceLock(LOCK_FD_LIST,READ_LOCK," not_open");
d130 1
a130 1
  ReleaseResourceLock(LOCK_FD_LIST,READ_LOCK," not open");
d215 2
a216 2
    fd = fdtab.find_unused_handle();
  fhandler_base *res = fdtab.build_fhandler (fd, name, handle);
d378 1
a378 1
  if ((size_t) newfd >= fdtab.size || newfd < 0)
d385 1
a385 1
  if ((size_t) newfd >= fdtab.size)
d388 2
a389 2
		    fdtab.size;
     fdtab.extend (inc_size);
d469 1
a469 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d477 1
a477 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d483 1
a483 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d486 1
a486 1
    if ((fh = fds[i]) != NULL && (!fh->get_close_on_exec ()))
d491 1
a491 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d495 1
a495 1
dtable::fixup_after_exec (HANDLE parent, size_t sz, fhandler_base **f)
a496 2
  size = sz;
  fds = f;
a518 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
a528 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d538 1
a538 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d552 1
a552 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d559 1
a559 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
d567 25
a591 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK,"dup");
@


1.33
log
@* lib/_cygwin_S_IEXEC.c: Remove "const" from globals or they never seem to be
defined.  Wrap definitions in extern "C".  Include winsup.h to assure proper
definitions.
* dcrt0.cc (dll_crt0_1): Call stdio_init after premain run so that binmode.o,
etc., will control default stdio settings.
* dtable.cc (dtable::init_std_file_from_handle): Allow __fmode to force
binmode/textmode settings.  Default pipes to binmode.
@
text
@d319 3
@


1.32
log
@* dtable.cc: Guard against new winsock.h/winsock2.h warnings when mixing
winsock*.h and sys/types.h.
* fhandler_socket.cc: Ditto.
* net.cc: Ditto.
* select.cc: Ditto.
* exceptions.cc: Remove unneeded define.
@
text
@d168 7
a174 1
  int bin = binmode ? O_BINARY : 0;
d198 5
@


1.31
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@a12 1
#define Win32_Winsock
d22 1
@


1.30
log
@Throughout use myself->ppid_handle rather than parent_alive.
* child_info.h (child_info): Eliminate parent_alive.
* dcrt0.cc (dll_crt0_1): Call fork_init for debugging pid creation.
* fork.cc (fork_child): Reflect change to fixup_mmaps_after_fork arguments.
(slow_pid_reuse): New function to grab last 'n' pids to prevent pid reuse.
(fork_parent): Move last_fork_proc into slow_pid_reuse.  Handle fork_pids
debugging.  Eliminate unnecessary call to set_child_mmap_ptr.
(fork_init): New debugging function.
* mmap.cc (fixup_mmaps_after_fork): Renamed from recreate_mmaps_after_fork.
Rely on copied data after a fork.
(set_child_mmap_ptr): Eliminate.
* pinfo.h (_pinfo): Eliminate parent_alive, mmap_ptr and reflect above changes.
* spawn.cc (spawn_guts): Eliminate vestiges of "old way" of sending new hProc
to parent process.
@
text
@d29 1
@


1.29
log
@        * dtable.cc (dtable::release): Check for socket. Change
        cnt_need_fixup_before accordingly.
        (dtable::dup2): Ditto.
        (dtable::fixup_before_fork): New method.
        (dtable::fixup_before_exec): Ditto.
        * dtable.h (class dtable): Add member `cnt_need_fixup_before'. Add
        definition for methods `dec_need_fixup_before', `inc_need_fixup_before',
        `need_fixup_before', `fixup_before_exec' and `fixup_before_fork'.
        * fhandler.h (class fhandler_base): Slight rearrangements. Add
        definitions for methods `fixup_before_fork_exec'.
        (class fhandler_socket): Eliminate superfluous constructor.
        Add member `prot_info_ptr'. Add destructor. Add definitions for
        methods `dup', `fixup_before_fork_exec', `fixup_after_fork' and
        `fixup_after_exec'.
        * fork.cc (fork_parent): Care for file types which need a fixup
        before fork. Start child in suspended state then.
        * net.cc: New global variable `ws2_32_handle' and `wsadata'.
        (fdsock): Check for Winsock version. Call `set_socket_inheritance'
        only if Winsock version < 2.0. Care for `need_fixup' count in fdtab.
        (cygwin_socket): Eliminate call to `set_socket_inheritance'.
        (cygwin_accept): Ditto.
        (cygwin_rcmd): Ditto.
        (cygwin_rresvport): Ditto.
        (cygwin_rexec): Ditto.
        (socketpair): Ditto.
        (fhandler_socket::fhandler_socket): Set `need_fork_fixup'. Allocate
        space for the WSAPROTOCOL_INFOA struct used in fixup.
        (fhandler_socket::~fhandler_socket): New destructor.
        (fhandler_socket::fixup_before_fork_exec): New method.
        (fhandler_socket::fixup_after_fork): Ditto.
        (fhandler_socket::dup): Ditto.
        (wsock_init): New static function.
        (LoadDLLinitfunc (wsock32)): Rearranged.
        (LoadDLLinitfunc (ws2_32)): New function.
        (dummy_autoload): Add autoload statemants for `WSADuplicateSocketA'
        and `WSASocketA'.
        * spawn.cc (spawn_guts): Care for file types which need a fixup
        before exec. Start child in suspended state then.
@
text
@d95 1
a95 1
  if (!parent_alive && NOTSTATE(myself, PID_CYGPARENT))
@


1.28
log
@* dtable.cc (dtable::fixup_after_exec): Use variable rather than constantly
indexing into fds array.
(dtable::fixup_after_fork): Ditto.
@
text
@d156 2
d382 5
d453 28
@


1.27
log
@* fhandler_clipboard.cc: new file
* Makefile.in: include fhandler_clipboard.o in DLL_OFILES list.
* fhandler.h: add FH_CLIPBOARD to the devices enum.
(fhandler_dev_clipboard): new
* path.cc (windows_device_names): add "\\dev\\clipboard"
(get_device_number): check for "clipboard"
* dcrt0.cc: declare a few more functions from winuser.h
* dtable.cc (dtable::build_fhandler): check for FH_CLIPBOARD in
switch().
@
text
@d452 1
d454 1
a454 1
    if (fds[i])
d456 2
a457 2
	fds[i]->clear_readahead ();
	if (fds[i]->get_close_on_exec ())
d461 1
a461 1
	    fds[i]->fixup_after_exec (parent);
d463 1
a463 1
	      SetStdHandle (std_consts[i], fds[i]->get_io_handle ());
d465 1
a465 1
	      SetStdHandle (std_consts[i], fds[i]->get_output_handle ());
d478 1
a478 1
	if (fds[i]->get_close_on_exec () || fh->get_need_fork_fixup ())
@


1.26
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d302 3
@


1.25
log
@* dtable.cc (dtable::fixup_after_fork): Revert thinko below.
* pinfo.cc (set_myself): Show pid in initial strace line.
@
text
@a31 1
#include "thread.h"
d156 1
a156 1
      delete fds[fd];	/* CGF FIXME */
@


1.24
log
@* child_info: Bump child_info "version".
(child_info): Move some fields from child_info_spawn to here.
* cygheap.cc: Make cygheap pointers NOCOPY.
* dcrt0.cc (dll_crt0_1): Copy cygwin heap here regardless of whether we've been
forked or execed.
* dtable.cc (dtable::fixup_after_fork): Just release close-on-exec fds.
* exceptions.cc (stackdump): Respond to C warning.
* fork.cc: Reorganize to minimize stack copying.
(fork_child): New function.
(fork_parent): Ditto.
(sync_with_child): Don't suspend the forkee.
(sync_with_parent): Ditto.  Make into a function.
* heap.cc (heap_init): Add some debugging output.
* path.cc (path_conv::check): Add an assertion.
(has_suffix): Ditto.
* security.cc (get_pw_sid): Defend against NULL.
* sigproc.cc (proc_subproc): Fix debugging output.
(wait_sig): Ditto.
* strace.cc: Make statics NO_COPY throughout.
(strace::vsprntf): Defend against NULL.
@
text
@d475 1
a475 3
	if (fds[i]->get_close_on_exec ())
	  release (i);
	else if (fh->get_need_fork_fixup ())
@


1.23
log
@* dtable.cc (set_std_handle): Use std_consts array to control SetStdHandle
settings.
(dtable::fixup_after_fork): Ditto.
* exceptions.cc (set_sig_errno): Remove some debugging output.
* path.cc (path_conv::check): Don't OR need_directory with flags sent to
symlink_info::check.
(symlink_info::check): Use PATH_ALL_EXEC to determine when a file is
executable.
* path.h (path_types): Add PATH_ALL_EXEC.
(isexec): Use PATH_ALL_EXEC so that cygexec types will be considered
executable.
* pinfo.h (_pinfo): Add a process handle that is kept open throughout the life
of a cygwin pid.
* sigproc.cc (proc_exists): Remove hopefully obsolete stuff.
(proc_subproc): Set up process handle that is kept open throughout the life of
a cygwin pid.  Reorganize PROC_WAIT stuff to use common code.
(proc_terminate): Close pid lifetime process handle.
(checkstate): Cleanup.
(stopped_or_terminated): Move zombie cleanup.
(remove_zombie): To here.
* spawn.cc (spawn_guts): Reorganize reparenting code for 1247th time.
@
text
@d475 3
a477 1
	if (fh->get_close_on_exec () || fh->get_need_fork_fixup ())
@


1.22
log
@        * Makefile.in: Add fhandler_mem.o to the dependencies.
        * dtable.cc (dtable::build_fhandler): Add case for FH_MEM.
        * fhandler.h: Add FH_MEM device type.  Add class fhandler_dev_mem.
        * fhandler_mem.cc: New file. Implementation of class fhandler_dev_mem.
        * path.cc: Add /dev/mem to windows_device_names.
        (get_device_number): Add FH_MEM type.
@
text
@d36 3
d51 3
a53 5
    SetStdHandle (STD_INPUT_HANDLE, fdtab[fd]->get_handle ());
  else if (fd == 1)
    SetStdHandle (STD_OUTPUT_HANDLE, fdtab[fd]->get_output_handle ());
  else if (fd == 2)
    SetStdHandle (STD_ERROR_HANDLE, fdtab[fd]->get_output_handle ());
d457 7
a463 1
	  fds[i]->fixup_after_exec (parent);
@


1.21
log
@* dcrt0.cc (dll_crt0_1): Initialize thread and debug stuff before handling
exec/fork.
* dtable.cc (dtable::fixup_after_exec): Always clear out the read ahead buffer
whether closing or adjusting.
* path.cc (chdir): Avoid a compiler warning.
@
text
@d299 3
@


1.20
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d448 5
a452 5
      if (fds[i]->get_close_on_exec ())
	release (i);
      else
	{
	  fds[i]->clear_readahead ();
d454 1
a454 1
	}
@


1.19
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d21 1
@


1.18
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d26 1
d66 1
a66 1
  if (!(newfds = (fhandler_base **) calloc (new_size, sizeof newfds[0])))
d74 1
a74 1
      free (fds);
d155 1
a155 1
      delete (fds[fd]);
d244 1
a244 1
  void *buf = calloc (1, sizeof (fhandler_union) + 100);
d316 1
a316 1
      free (newfh);
d355 1
a355 6
  if ((size_t) newfd >= fdtab.size)
    {
      int inc_size = NOFILE_INCR * ((newfd + NOFILE_INCR - 1) / NOFILE_INCR) -
                     fdtab.size;
      fdtab.extend (inc_size);
    }
d362 8
d389 1
a389 1
  if (fdtab.not_open (fd))
d394 1
a394 1
  fhandler_base *fh = fdtab[fd];
d406 1
a406 1
  if (fdtab.not_open (fd))
d411 1
a411 1
  fhandler_base *fh = fdtab[fd];
d423 1
a423 1
  if (fdtab.not_open (fd))
d428 1
a428 1
  fhandler_base *fh = fdtab[fd];
d437 4
a440 10
/*
 * Function to take an existant dtable array
 * and linearize it into a memory buffer.
 * If memory buffer is NULL, it returns the size
 * of memory buffer needed to do the linearization.
 * On error returns -1.
 */

int
dtable::linearize_fd_array (unsigned char *in_buf, int buflen)
d442 7
a448 46
  /* If buf == NULL, just precalculate length */
  if (in_buf == NULL)
    {
      buflen = sizeof (size_t);
      for (int i = 0, max_used_fd = -1; i < (int)size; i++)
	if (!not_open (i) && !fds[i]->get_close_on_exec ())
	  {
	    buflen += i - (max_used_fd + 1);
	    buflen += fds[i]->cb + strlen (fds[i]->get_name ()) + 1
				 + strlen (fds[i]->get_win32_name ()) + 1;
	    max_used_fd = i;
	  }
      debug_printf ("needed buflen %d", buflen);
      return buflen;
    }

  debug_printf ("in_buf = %x, buflen = %d", in_buf, buflen);

  /*
   * Now linearize each open fd (write a 0xff byte for a closed fd).
   * Write the name of the open fd first (null terminated). This
   * allows the de_linearizeing code to determine what kind of fhandler_xxx
   * to create.
   */

  size_t i;
  int len, total_size;

  total_size = sizeof (size_t);
  if (total_size > buflen)
    {
      system_printf ("FATAL: linearize_fd_array exceeded buffer size");
      return -1;
    }

  unsigned char *buf = in_buf;
  buf += sizeof (size_t);	/* skip over length which is added later */

  for (i = 0, total_size = sizeof (size_t); total_size < buflen; i++)
    {
      if (not_open (i) || fds[i]->get_close_on_exec ())
	{
	  debug_printf ("linearizing closed fd %d",i);
	  *buf = 0xff;		/* place holder */
	  len = 1;
	}
d451 2
a452 54
	  len = fds[i]->linearize (buf);
	  debug_printf ("fd %d, len %d, name %s, device %p", i, len, buf,
			fds[i]->get_device ());
	}

      total_size += len;
      buf += len;
    }

  i--;
  memcpy (in_buf, &i, sizeof (size_t));
  if (total_size != buflen)
    system_printf ("out of sync %d != %d", total_size, buflen);
  return total_size;
}

/*
 * Function to take a linearized dtable array in a memory buffer and
 * re-create the original dtable array.
 */

LPBYTE
dtable::de_linearize_fd_array (LPBYTE buf)
{
  int len, max_used_fd;
  size_t inc_size;

  debug_printf ("buf %x", buf);

  /* First get the number of fd's - use this to set the fdtabsize.
     NB. This is the only place in the code this should be done !!
  */

  memcpy ((char *) &max_used_fd, buf, sizeof (int));
  buf += sizeof (size_t);

  inc_size = NOFILE_INCR * ((max_used_fd + NOFILE_INCR - 1) / NOFILE_INCR) -
	     size;
  debug_printf ("max_used_fd %d, inc size %d", max_used_fd, inc_size);
  if (inc_size > 0 && !extend (inc_size))
    {
      system_printf ("out of memory");
      return NULL;
    }

  for (int i = 0; i <= max_used_fd; i++)
    {
      /* 0xFF means closed */
      if (*buf == 0xff)
	{
	  fds[i] = NULL;
	  buf++;
	  debug_printf ("closed fd %d", i);
	  continue;
a453 21
      /* fd was open - de_linearize it */
      /* Get the null-terminated name.  It is followed by an image of
	 the actual fhandler_* structure.  Use the status field from
	 this to build a new fhandler type. */

      DWORD status;
      LPBYTE obuf = buf;
      char *win32;
      win32 = strchr ((char *)obuf, '\0') + 1;
      buf = (LPBYTE)strchr ((char *)win32, '\0') + 1;
      memcpy ((char *)&status, buf + FHSTATOFF, sizeof(DWORD));
      debug_printf ("fd %d, name %s, win32 name %s, status %p",
		    i, obuf, win32, status);
      len = build_fhandler (i, status, (const char *) NULL)->
	    de_linearize ((char *) buf, (char *) obuf, win32);
      set_std_handle (i);
      buf += len;
      debug_printf ("len %d", buf - obuf);
    }
  first_fd_for_open = 0;
  return buf;
d460 1
d462 1
a462 1
    if (!not_open (i))
a463 1
	fhandler_base *fh = fds[i];
d477 1
a477 1
  newtable = (fhandler_base **) calloc (size, sizeof(fds[0]));
d490 1
d507 1
a507 1
  free (deleteme);
@


1.17
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d23 2
a24 1
#include "dtable.h"
d27 4
@


1.16
log
@* dtable.cc (dtable::dup2): Extend fdtab if newfd is out of current
allocated bounds.
@
text
@d25 1
@


1.15
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d348 6
@


1.14
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d23 2
d30 1
a30 1
fdtab_init (void)
@


1.13
log
@* hinfo.cc (hinfo::find_unused_handle): Just check for table entry == NULL
since we are already bounds checked by default.
* thread.cc (ResourceLocks::Lock): Streamline this function since it is called
a lot.
(ReleaseResourceLock): Ditto.
@
text
@d1 1
a1 1
/* hinfo.cc: file descriptor support.
d24 1
a24 1
hinfo dtable;
d28 1
a28 1
dtable_init (void)
d30 2
a31 2
  if (!dtable.size)
    dtable.extend(NOFILE_INCR);
d38 1
a38 1
    SetStdHandle (STD_INPUT_HANDLE, dtable[fd]->get_handle ());
d40 1
a40 1
    SetStdHandle (STD_OUTPUT_HANDLE, dtable[fd]->get_output_handle ());
d42 1
a42 1
    SetStdHandle (STD_ERROR_HANDLE, dtable[fd]->get_output_handle ());
d46 1
a46 1
hinfo::extend (int howmuch)
d79 1
a79 1
hinfo_init (void)
d91 1
a91 1
      dtable.init_std_file_from_handle (0, in, GENERIC_READ, "{stdin}");
d109 2
a110 2
      dtable.init_std_file_from_handle (1, out, GENERIC_WRITE, "{stdout}");
      dtable.init_std_file_from_handle (2, err, GENERIC_WRITE, "{stderr}");
d115 1
a115 1
hinfo::not_open (int fd)
d126 1
a126 1
hinfo::find_unused_handle (int start)
d142 1
a142 1
hinfo::release (int fd)
d152 1
a152 1
hinfo::init_std_file_from_handle (int fd, HANDLE handle,
d193 2
a194 2
    fd = dtable.find_unused_handle();
  fhandler_base *res = dtable.build_fhandler (fd, name, handle);
d200 1
a200 1
hinfo::build_fhandler (int fd, const char *name, HANDLE handle)
d232 1
a232 1
hinfo::build_fhandler (int fd, DWORD dev, const char *name, int unit)
d300 1
a300 1
hinfo::dup_worker (fhandler_base *oldfh)
d318 1
a318 1
hinfo::dup2 (int oldfd, int newfd)
d346 1
a346 1
  if ((size_t) newfd >= dtable.size || newfd < 0)
d369 1
a369 1
hinfo::select_read (int fd, select_record *s)
d371 1
a371 1
  if (dtable.not_open (fd))
d376 1
a376 1
  fhandler_base *fh = dtable[fd];
d386 1
a386 1
hinfo::select_write (int fd, select_record *s)
d388 1
a388 1
  if (dtable.not_open (fd))
d393 1
a393 1
  fhandler_base *fh = dtable[fd];
d403 1
a403 1
hinfo::select_except (int fd, select_record *s)
d405 1
a405 1
  if (dtable.not_open (fd))
d410 1
a410 1
  fhandler_base *fh = dtable[fd];
d420 1
a420 1
 * Function to take an existant hinfo array
d428 1
a428 1
hinfo::linearize_fd_array (unsigned char *in_buf, int buflen)
d495 2
a496 2
 * Function to take a linearized hinfo array in a memory buffer and
 * re-create the original hinfo array.
d500 1
a500 1
hinfo::de_linearize_fd_array (LPBYTE buf)
d507 1
a507 1
  /* First get the number of fd's - use this to set the dtablesize.
d557 1
a557 1
hinfo::fixup_after_fork (HANDLE parent)
d574 1
a574 1
hinfo::vfork_child_dup ()
d598 1
a598 1
hinfo::vfork_parent_restore ()
@


1.12
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d128 1
a128 1
  AssertResourceOwner(LOCK_FD_LIST,READ_LOCK);
d133 2
a134 1
	if (not_open (i))
@


1.11
log
@* environ.cc (parse_thing): Make binmode a DWORD.
* hinfo.cc (hinfo::init_std_file_from_handle): Use 'binmode' to determine
default open mode.
* winsup.h: Declare binmode.
@
text
@d13 2
a21 2
#define Win32_Winsock
#include "winsup.h"
@


1.10
log
@* testsuite/winsup.api/winsup.exp: ignore stdout by default
* testsuite/winsup.api/crlf.c: non-verbose by default

* winsup.h: prune out windows headers we don't normally need
* assert.cc: add wingdi.h and winuser.h
* fhandler_console.cc: ditto
* fhandler_windows.cc: ditto
* select.cc: ditto
* spawn.cc: ditto
* strace.cc: ditto
* tty.cc: ditto
* window.cc: ditto
* hinfo.cc: add winsock.h
* syscalls.cc: add winnls.h
* uinfo.cc: ditto

* include/windows.h: optimize non-inclusion of repeat headers
@
text
@d154 1
a154 1
  int bin = __fmode;
@


1.9
log
@* hinfo.cc (hinfo::linearize_fd_array): Make max_used_fd an int so that we can
detect when there are no fds to pass.
* dcrt0.cc (host_dependent_constants::init): Revert Sat Mar 18 01:32:04 2000
change.
(dll_crt0_1): Set "cygwin_finished_initializing" flag.
(dll_crt0): Don't perform memcpy if uptr is already set to internal structure.
(_dll_crt0): Remember location of programs envptr.
* dll_init.h (per_module, dll, dll_list): Revamp.
* dll_init.cc: Revamp.  Use new classes.
* fork.cc (fork): Use new revamped dll, dll_list, and per_module stuff.
* environ.cc: Use __cygwin_environ throughout rather than the
user_data->envptr.
* exec.cc: Ditto.
* spawn.cc: Ditto.
* winsup.h: Declare update_envptrs, cygwin_finished_initializing.
* lib/_cygwin_crt0_common.cc (_cygwin_crt0_common): Revert previous change.
* lib/cygwin_attach_dll.cc (cygwin_attach_dll): Always pass in own per_process
structure or we end up overwriting information from the main program.
@
text
@d22 1
@


1.8
log
@Changes by  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>
        * assert.cc (__assert): Reduce dependency on newlib.
        * exec.cc: Eliminate unnecessary inclusion of ctype.h.
        * glob.c: Ditto.
        * hinfo.cc: Ditto.
        * init.cc: Ditto.
        * strace.cc: Ditto.
        * tty.cc: Ditto.
        * grp.cc (parse_grp): Eliminate atoi.
        * passwd.cc (grab_int): Ditto.
        * grp.cc (getgroups): Eliminate str{n,}casecmp.
        * path.cc (get_raw_device_number): Ditto.
        * path.cc (sort_by_native_name): Ditto.
        * spawn.cc (iscmd): Ditto.
        * uinfo.cc (internal_getlogin): Ditto.
@
text
@d500 2
a501 2
  int len;
  size_t max_used_fd, inc_size;
d521 1
a521 1
  for (size_t i = 0; i <= max_used_fd; i++)
@


1.7
log
@* hinfo.cc (hinfo::dup2): Eliminate compiler warning.
@
text
@a16 1
#include <ctype.h>
@


1.6
log
@* hinfo.cc (hinfo::dup2): Guard against out of bounds newfd.
@
text
@d345 1
a345 1
  if (newfd >= dtable.size || newfd < 0)
@


1.5
log
@        * Makefile.in: Add dependencies for fhandler_random.o
        * fhandler.h: Add device type FH_RANDOM. Add class
        fhandler_dev_random.
        * fhandler_random.cc: New file. Implementation of
        fhandler_dev_random.
        * hinfo.cc (build_fhandler): Add case for FH_RANDOM.
        * path.cc: Add device names for random devices to
        windows_device_names.
        (get_device_number): Add if branch for random devices.
        (win32_device_name): Add device name generation for
        random devices.
        winsup.h: Include <wincrypt.h>.
@
text
@d327 1
a327 1
      syscall_printf("dup2: fd %d not open", oldfd);
d345 6
@


1.4
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@d285 3
@


1.3
log
@Throughout use strace class in place of individual functions and variables.
* cygwin.din: Eliminate _strace_wm.
* sigproc.cc (wait_sig): Temporarily add more debugging output.
* include/cygwin/version.h: Bump minor api to reflect export change.
@
text
@d236 2
a237 1
  switch (dev & FH_DEVMASK)
d260 1
a260 1
	fh = new (buf) fhandler_serial (name, FH_SERIAL, unit);
d265 1
a265 1
	fh = new (buf) fhandler_pipe (name);
@


1.2
log
@* hinfo.cc (hinfo::extend): Clean up debugging output.
@
text
@a144 1
MALLOC_CHECK;
a145 1
MALLOC_CHECK;
@


1.1
log
@Initial revision
@
text
@a56 2
debug_printf ("here size %d", size);

d70 1
a70 1
  debug_printf ("size %d, fds %d", size, fds);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
