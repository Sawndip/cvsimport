head	1.47;
access;
symbols
	cygwin-1_7_35-release:1.47
	cygwin-1_7_34-release:1.47
	cygwin-1_7_33-release:1.47
	cygwin-1_7_32-release:1.47
	cygwin-1_7_31-release:1.47
	cygwin-1_7_30-release:1.47
	cygwin-1_7_29-release:1.47
	cygwin-1_7_29-release-branchpoint:1.47.0.2
	cygwin-pre-user-db:1.47
	cygwin-1_7_28-release:1.47
	cygwin-1_7_27-release:1.47
	cygwin-1_7_26-release:1.47
	cygwin-1_7_25-release:1.41
	cygwin-1_7_24-release:1.41
	cygwin-1_7_23-release:1.41
	cygwin-1_7_22-release:1.41
	cygwin-1_7_21-release:1.40
	cygwin-1_7_20-release:1.40
	cygwin-1_7_19-release:1.40
	cygwin-64bit-postmerge:1.40
	cygwin-64bit-premerge-branch:1.39.0.4
	cygwin-64bit-premerge:1.39
	cygwin-1_7_18-release:1.39
	post-ptmalloc3:1.39.2.2
	pre-ptmalloc3:1.39.2.2
	cygwin-1_7_17-release:1.39
	cygwin-64bit-branch:1.39.0.2
	cygwin-1_7_16-release:1.39
	cygwin-1_7_15-release:1.38
	cygwin-1_7_14_2-release:1.38
	cygwin-1_7_14-release:1.38
	cygwin-1_7_12-release:1.36
	cygwin-1_7_11-release:1.31
	cygwin-1_7_10-release:1.31
	signal-rewrite:1.29.0.2
	pre-notty:1.27
	cygwin-1_7_9-release:1.24
	cv-post-1_7_9:1.24.0.2
	cygwin-1_7_8-release:1.24
	cygwin-1_7_7-release:1.22
	cygwin-1_7_5-release:1.22
	cygwin-1_7_4-release:1.22
	cygwin-1_7_3-release:1.22
	cygwin-1_7_2-release:1.22
	fifo_doover3:1.22.0.4
	cygwin-1_7_1-release:1.22
	prefifo:1.22
	cv-branch-2:1.22.0.2
	pre-ripout-set_console_state_for_spawn:1.21
	EOL_registry_mounts:1.19
	preoverlapped:1.17
	drop_9x_support_start:1.16
	cr-0x5f1:1.13.0.8
	cv-branch:1.13.0.6
	pre-ptymaster-archetype:1.13
	cr-0x3b58:1.13.0.4
	cr-0x5ef:1.13.0.2
	after-mmap-privanon-noreserve:1.13
	after-mmap-revamp:1.13
	before-mmap-revamp:1.13
	cgf-more-exit-sync:1.13
	post_wait_sig_exit:1.13
	pre_wait_sig_exit:1.12
	reparent-point:1.4
	noreparent:1.4.0.4
	cr-0x5e6:1.4.0.2
	cr-0x9e:1.3.0.6
	cr-0x9d:1.3.0.4
	cgf-deleteme:1.3.0.2
	pre-sigrewrite:1.1
	corinna-01:1.1;
locks; strict;
comment	@# @;


1.47
date	2013.10.31.14.26.42;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.30.09.44.47;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.26.13.23.54;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2013.10.25.16.16.50;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2013.10.25.12.21.58;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2013.10.24.09.41.16;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2013.07.15.13.54.27;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.23.09.44.31;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2012.05.22.17.37.40;	author corinna;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2012.04.15.17.51.22;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2012.04.13.02.30.51;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.02.20.41.46;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.01.07.19.52;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2012.03.31.20.14.13;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.31.17.38.00;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.29.18.02.54;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.14.21.48.43;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.01.19.48.19;	author yselkowitz;	state Exp;
branches;
next	1.24;

1.24
date	2011.02.15.15.25.59;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.03.05.12.20;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.09.14.01.40;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.29.17.08.45;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.13.15.08.25;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.23.14.20.28;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.17.19.26.57;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.23.09.55.55;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.09.08.27.23;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.13.17.08.52;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.24.04.38.39;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.10.20.56.06;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.06.04.06.17;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.19.21.45.14;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.23.17.59.04;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.23.12.30.31;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.01.16.49.11;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.01.15.00.40;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.21.19.14.19;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.01.12.36.39;	author cgf;	state Exp;
branches;
next	;

1.39.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	;

1.3.6.1
date	2004.01.21.19.17.55;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.47
log
@	* devices.in (dev_cygdrive_storage): Revert mapping to \Device\Null.
	(dev_storage): Ditto for /dev.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_null): New method to open a fake
	\Device\Null handler.
	(fhandler_base::open): Fix formatting.  Change O_ACCMODE test to a
	switch statement.  Simplify a test which still tested for a now unused
	create_disposition.
	* fhandler.h (fhandler_base::open_null): Declare.
	(fhandler_netdrive::close): Declare.
	* fhandler_dev.cc (fhandler_dev::open): Open fake \Device\Null handle
	by just calling new open_null method.
	* fhandler_disk_file.cc (fhandler_cygdrive::open): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::open): Call open_null
	rather than setting nohandle.
	(fhandler_netdrive::close): New method.
	* fhandler_registry.cc (fetch_hkey): Fix token in RegOpenUserClassesRoot
	call.  Create valid key for HKEY_CURRENT_CONFIG by mapping to real key
	HKEY_LOCAL_MACHINE\System\CurrentControlSet\Hardware Profiles\Current.
	(fhandler_registry::open): Set nohandle only when using pseudo registry
	handle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Call open rather
	than just setting nohandle here.
	* fhandler_virtual::fstatvfs): Set ST_RDONLY fs flag.
	* globals.cc (ro_u_null): New readonly UNICODE_STRING for \Device\Null.
	* path.h (path_conv::set_path): Revert previous change caring for
	wide_path.
@
text
@%import {
#include "winsup.h"
#include "devices.h"
#include "sys/cygwin.h"
#include "tty.h"
#include "pinfo.h"
#include "shared_info.h"
#include "path.h"
#include "fhandler.h"
#include "ntdll.h"

typedef const device *KR_device_t;
}
%type KR_device_t
%local {

static int
exists_internal (const device&)
{
  return false;
}

static int
exists (const device&)
{
  return true;
}

/* Check existence of POSIX devices backed by real NT devices. */
static int
exists_ntdev (const device& dev)
{
  WCHAR wpath[MAX_PATH];
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  HANDLE h;
  NTSTATUS status;

  sys_mbstowcs (wpath, MAX_PATH, dev.native);
  RtlInitUnicodeString (&upath, wpath);
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  /* Except for the serial IO devices, the native paths are
     direct device paths, not symlinks, so every status code
     except for "NOT_FOUND" means the device exists. */
  status = NtOpenSymbolicLinkObject (&h, SYMBOLIC_LINK_QUERY, &attr);
  switch (status)
    {
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_OBJECT_PATH_NOT_FOUND:
      return false;
    case STATUS_SUCCESS:
      NtClose (h);
    default:
      break;
    }
  return true;
}

/* Don't list via readdir but allow as a direct reference. */
static int
exists_ntdev_silent (const device& dev)
{
  return exists_ntdev (dev) ? -1 : false;
}

static int
exists_console (const device& dev)
{
  fh_devices devn = *const_cast<device *> (&dev);
  switch (devn)
    {
    case FH_CONSOLE:
    case FH_CONIN:
    case FH_CONOUT:
      return fhandler_console::exists ();
    default:
      /* Only show my own console device (for now?) */
      return iscons_dev (myself->ctty) && myself->ctty == devn;
    }
}

static int
exists_pty (const device& dev)
{
  /* Only existing slave ptys. */
  return cygwin_shared->tty.connect (dev.get_minor ()) != -1;
}

const device dev_cygdrive_storage =
  {"/cygdrive", {FH_CYGDRIVE}, "", exists};

const device dev_fs_storage =
  {"", {FH_FS}, "", exists};

const device dev_proc_storage =
  {"", {FH_PROC}, "", exists};

const device dev_procnet_storage =
  {"", {FH_PROCNET}, "", exists};

const device dev_procsys_storage =
  {"", {FH_PROCSYS}, "", exists};

const device dev_procsysvipc_storage =
  {"", {FH_PROCSYSVIPC}, "", exists};

const device dev_netdrive_storage =
  {"", {FH_NETDRIVE}, "", exists};

const device dev_registry_storage =
  {"", {FH_REGISTRY}, "", exists_internal};

const device dev_piper_storage =
  {"", {FH_PIPER}, "", exists_internal};

const device dev_pipew_storage =
  {"", {FH_PIPEW}, "", exists_internal};

const device dev_tcp_storage =
  {"", {FH_TCP}, "", exists_internal};

const device dev_udp_storage =
  {"", {FH_UDP}, "", exists_internal};

const device dev_stream_storage =
  {"", {FH_STREAM}, "", exists_internal};

const device dev_dgram_storage =
  {"", {FH_DGRAM}, "", exists_internal};

const device dev_bad_storage =
  {"", {FH_NADA}, "", exists_internal};

const device dev_error_storage =
  {"", {FH_ERROR}, "", exists_internal};

#define BRACK(x) {devn_int: x}
%storage_here
}
/* Internal devices below are prefixed with a ":".  This moves them out of
   the POSIX namespace.  */
%%
"/dev", BRACK(FH_DEV), "", exists, S_IFDIR
"/dev/tty", BRACK(FH_TTY), "/dev/tty", exists, S_IFCHR
"/dev/pty%(0-63)d", BRACK(FHDEV(DEV_PTYS_MAJOR, {$1})), "/dev/pty{$1}", exists_pty, S_IFCHR, =ptys_dev
":ptym%(0-63)d", BRACK(FHDEV(DEV_PTYM_MAJOR, {$1})), "/dev/ptym{$1}", exists_internal, S_IFCHR, =ptym_dev
"/dev/cons%(0-63)d", BRACK(FHDEV(DEV_CONS_MAJOR, {$1})), "/dev/cons{$1}", exists_console, S_IFCHR, =cons_dev
"/dev/console", BRACK(FH_CONSOLE), "/dev/console", exists_console, S_IFCHR, =console_dev
"/dev/ptmx", BRACK(FH_PTMX), "/dev/ptmx", exists, S_IFCHR
"/dev/windows", BRACK(FH_WINDOWS), "\\Device\\Null", exists_ntdev, S_IFCHR
"/dev/dsp", BRACK(FH_OSS_DSP), "\\Device\\Null", exists_ntdev, S_IFCHR
"/dev/conin", BRACK(FH_CONIN), "/dev/conin", exists_console, S_IFCHR
"/dev/conout", BRACK(FH_CONOUT), "/dev/conout", exists_console, S_IFCHR
"/dev/null", BRACK(FH_NULL), "\\Device\\Null", exists_ntdev, S_IFCHR
"/dev/zero", BRACK(FH_ZERO), "\\Device\\Null", exists_ntdev, S_IFCHR
"/dev/full", BRACK(FH_FULL), "\\Device\\Null", exists_ntdev, S_IFCHR
"/dev/random", BRACK(FH_RANDOM), "\\Device\\Null", exists_ntdev, S_IFCHR
"/dev/urandom", BRACK(FH_URANDOM), "\\Device\\Null", exists_ntdev, S_IFCHR, =urandom_dev
"/dev/clipboard", BRACK(FH_CLIPBOARD), "\\Device\\Null", exists_ntdev, S_IFCHR
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 - 1})), "\\??\\COM{$1}", exists_ntdev_silent, S_IFCHR
"/dev/ttyS%(0-63)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1})), "\\??\\COM{$1 + 1}", exists_ntdev, S_IFCHR
":pipe", BRACK(FH_PIPE), "/dev/pipe", exists_internal, S_IFCHR
":fifo", BRACK(FH_FIFO), "/dev/fifo", exists_internal, S_IFCHR
"/dev/st%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1})), "\\Device\\Tape{$1}", exists_ntdev, S_IFBLK
"/dev/nst%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1 + 128})), "\\Device\\Tape{$1}", exists_ntdev, S_IFBLK
"/dev/fd%(0-15)d", BRACK(FHDEV(DEV_FLOPPY_MAJOR, {$1})), "\\Device\\Floppy{$1}", exists_ntdev, S_IFBLK
"/dev/scd%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}", exists_ntdev, S_IFBLK
"/dev/sr%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}", exists_ntdev, S_IFBLK
"/dev/sd%{a-z}s", BRACK(FH_SD{uc $1}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition0", exists_ntdev, S_IFBLK
"/dev/sda%{a-z}s", BRACK(FH_SDA{uc $1}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition0", exists_ntdev, S_IFBLK
"/dev/sdb%{a-z}s", BRACK(FH_SDB{uc $1}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition0", exists_ntdev, S_IFBLK
"/dev/sdc%{a-z}s", BRACK(FH_SDC{uc $1}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition0", exists_ntdev, S_IFBLK
"/dev/sdd%{a-x}s", BRACK(FH_SDD{uc $1}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition0", exists_ntdev, S_IFBLK
"/dev/sd%{a-z}s%(1-15)d", BRACK(FH_SD{uc $1} | {$2}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition{$2 % 16}", exists_ntdev, S_IFBLK
"/dev/sda%{a-z}s%(1-15)d", BRACK(FH_SDA{uc $1} | {$2}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition{$2 % 16}", exists_ntdev, S_IFBLK
"/dev/sdb%{a-z}s%(1-15)d", BRACK(FH_SDB{uc $1} | {$2}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition{$2 % 16}", exists_ntdev, S_IFBLK
"/dev/sdc%{a-z}s%(1-15)d", BRACK(FH_SDC{uc $1} | {$2}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition{$2 % 16}", exists_ntdev, S_IFBLK
"/dev/sdd%{a-x}s%(1-15)d", BRACK(FH_SDD{uc $1} | {$2}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition{$2 % 16}", exists_ntdev, S_IFBLK
"/dev/kmsg", BRACK(FH_KMSG), "\\Device\\MailSlot\\cygwin\\dev\\kmsg", exists_ntdev, S_IFCHR
%other	{return	NULL;}
%%
#undef BRACK

const device *dev_storage_end = dev_storage + (sizeof dev_storage / sizeof dev_storage[0]);

void
device::parse (const char *s)
{
  size_t len = strlen (s);
  const device *dev = KR_find_keyword (s, len);

  if (!dev)
    *this = *fs_dev;
  else
    *this = *dev;
}

void
device::init ()
{
  /* nothing to do... yet */
}

void
device::parse (_major_t major, _minor_t minor)
{
  dev_t devn = FHDEV (major, minor);

  d.devn = 0;

  for (const device *devidx = dev_storage; devidx < dev_storage_end; devidx++)
    if (devidx->d.devn == devn)
      {
	*this = *devidx;
	break;
      }

  if (!*this)
    d.devn = FHDEV (major, minor);
}

void
device::parse (dev_t dev)
{
  parse (_major (dev), _minor (dev));
}

void
device::parsedisk (int drive, int part)
{
  int base;
  if (drive < ('q' - 'a'))      /* /dev/sda -to- /dev/sdp */
    base = DEV_SD_MAJOR;
  else if (drive < 32)		/* /dev/sdq -to- /dev/sdaf */
    {
      base = DEV_SD1_MAJOR;
      drive -= 'q' - 'a';
    }
  else if (drive < 48)		/* /dev/sdag -to- /dev/sdav */
    {
      base = DEV_SD2_MAJOR;
      drive -= 32;
    }
  else if (drive < 64)		/* /dev/sdaw -to- /dev/sdbl */
    {
      base = DEV_SD3_MAJOR;
      drive -= 48;
    }
  else if (drive < 80)		/* /dev/sdbm -to- /dev/sdcb */
    {
      base = DEV_SD4_MAJOR;
      drive -= 64;
    }
  else if (drive < 96)		/* /dev/sdcc -to- /dev/sdcr */
    {
      base = DEV_SD5_MAJOR;
      drive -= 80;
    }
  else if (drive < 112)		/* /dev/sdcs -to- /dev/sddh */
    {
      base = DEV_SD6_MAJOR;
      drive -= 96;
    }
  /* NOTE: This will cause multiple /dev/sddx entries in
	   /proc/partitions if there are more than 128 devices */
  else				/* /dev/sddi -to- /dev/sddx */
    {
      base = DEV_SD7_MAJOR;
      drive -= 112;
    }
  parse (base, part + (drive * 16));
}
@


1.46
log
@	* devices.in (dev_cygdrive_storage): Map to \Device\Null.
	(dev_storage): Map /dev and /dev/windows to \Device\Null.
	* devices.cc: Regenerate.
	* dir.cc (opendir): Create unique id.  Explain why.
	* fhandler.h (fhandler_dev::get_dev): Implement inline.
	(fhandler_cygdrive::close): Drop declaration.
	(fhandler_cygdrive::get_dev): Implement inline.
	(fhandler_windows::get_hwnd): Ditto.
	(fhandler_windows::set_close_on_exec): Drop declaration.
	(fhandler_windows::fixup_after_fork): Ditto.
	* fhandler_dev.cc (fhandler_dev::open): Call fhandler_disk_file::open
	without O_CREAT flag.  Explain why.  Create \Device\Null handle if
	/dev/ doesn't actually exist.
	(fhandler_dev::close): Drop nohandle case.
	(fhandler_dev::fstatvfs): Drop nohandle check.  Test for fs_got_fs
	instead.  Set ST_RDONLY fs flag for simulated /dev.
	(fhandler_dev::opendir): If /dev doesn't exist, call open() to create
	fake \Device\Null handle.  Don't set nohandle.  Set dir_exists
	correctly.
	(fhandler_dev::rewinddir): Call fhandler_disk_file::rewinddir only if
	/dev is a real directory.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If called for
	the cygdrive dir, call open() to create fake \Device\Null handle.
	Only attach __DIR_mounts buffer to dir if not called for cygdrive dir.
	Don't set nohandle.
	(fhandler_cygdrive::open): Create \Device\Null handle.
	(fhandler_cygdrive::close): Remove.
	(fhandler_cygdrive::fstatvfs): Set ST_RDONLY fs flag.
	* fhandler_windows.cc (fhandler_windows::open): Create \Device\Null
	handle.
	(fhandler_windows::read): Don't add io_handle to WFMO handle array.
	Change subsequent test for return value accordingly.  Fix test for
	"message arrived".
	(fhandler_windows::set_close_on_exec): Remove.
	(fhandler_windows::fixup_after_fork): Remove.
	* path.h (path_conv::set_path): Make sure wide_path is NULL when
	setting a new path.
	* select.cc (peek_windows): Use correct hWnd value, not io_handle.
	(fhandler_windows::select_read): Don't use io_handle as wait object.
	(fhandler_windows::select_write): Ditto.
	(fhandler_windows::select_except): Ditto.
@
text
@d90 1
a90 1
  {"/cygdrive", {FH_CYGDRIVE}, "\\Device\\Null", exists};
d143 1
a143 1
"/dev", BRACK(FH_DEV), "\\Device\\Null", exists, S_IFDIR
@


1.45
log
@	* devices.in (dev_storage): Map /dev/dsp to \Device\Null.
	* devices.cc: Regenerate.
	* fhandler_dsp.cc (fhandler_dev_dsp::open): Call fhandler_base::open.
	(fhandler_dev_dsp::close): Call fhandler_base::close.
	(fhandler_dev_dsp::fixup_after_fork): Call
	fhandler_base::fixup_after_fork.

	* fhandler_raw.cc (fhandler_dev_raw::fixup_after_fork): Call
	fhandler_base::fixup_after_fork.
@
text
@d90 1
a90 1
  {"/cygdrive", {FH_CYGDRIVE}, "/cygdrive", exists};
d143 1
a143 1
"/dev", BRACK(FH_DEV), "/dev", exists, S_IFDIR
d150 1
a150 1
"/dev/windows", BRACK(FH_WINDOWS), "/dev/windows", exists, S_IFCHR
@


1.44
log
@	* devices.in (dev_storage): Map /dev/clipboard to \Device\Null.
	* devices.cc: Regenerate.
	* fhandler.h (fhandler_dev_clipboard::open): Drop declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Drop call to
	open.  Set private members to 0 and call fhandler_base::dup.
	(fhandler_dev_clipboard::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	(set_clipboard): Drop gratuitios call to RegisterClipboardFormatW.
	(fhandler_dev_clipboard::close): Call fhandler_base::close from here.
@
text
@d151 1
a151 1
"/dev/dsp", BRACK(FH_OSS_DSP), "/dev/dsp", exists, S_IFCHR
@


1.43
log
@	* devices.in (dev_storage): Map /dev/random and /dev/urandom to
	\Device\Null.
	* devices.cc: Regenerate.
	* fhandler.h (fhandler_dev_random::open): Drop declaration.
	(fhandler_dev_random::close): Ditto.
	(fhandler_dev_random::crypt_gen_random): Convert to static method.
	* fhandler_random.cc (fhandler_dev_random::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	(fhandler_dev_random::close): Ditto.
	* fhandler_socket.cc (entropy_source): Delete.
	(fhandler_socket::af_local_set_secret): Remove entropy_source code and
	call fhandler_dev_random::crypt_gen_random directly instead.
@
text
@d159 1
a159 1
"/dev/clipboard", BRACK(FH_CLIPBOARD), "/dev/clipboard", exists, S_IFCHR
@


1.42
log
@	* devices.in (dev_storage): Map /dev/zero and /dev/full to \Device\Null.
	* devices.cc: Regenerate.
	* dtable.h (struct dtable): Make fhandler_base friend, rather
	than fhandler_disk_file.
	* fhandler.cc (fhandler_base::open_with_arch): Create unique id.
	(fhandler_base::cleanup): Call del_my_locks.
	(fhandler_base::fcntl): Handle F_GETLK, F_SETLK and F_SETLKW.
	* fhandler.h (fhandler_base::get_dev): Return real device number.
	(fhandler_base::set_unique_id): New inline method.
	(fhandler_disk_file::lock): Drop declaration.
	(fhandler_disk_file::get_dev): New method, return pc.fs_serial_number.
	(fhandler_dev_zero::open): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Move
	del_my_locks call to fhandler_base::open_with_arch.
	(fhandler_disk_file::fcntl): Move handling of locking commands to
	fhandler_base::fcntl.
	(fhandler_base::open_fs): Drop call to NtAllocateLocallyUniqueId.
	* fhandler_zero.cc (fhandler_dev_zero::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	* flock.cc (fixup_lockf_after_exec): Finding a single fhandler is
	enough here.
	(fhandler_base::lock): Replace fhandler_disk_file::lock.  Refuse to lock
	nohandle devices.  Handle read/write test using POSIX flags.  Explain
	why.  Never fail on SEEK_CUR or SEEK_END, rather assume position 0,
	just as Linux.
	* net.cc (fdsock): Create unique id.
@
text
@d157 2
a158 2
"/dev/random", BRACK(FH_RANDOM), "/dev/random", exists, S_IFCHR
"/dev/urandom", BRACK(FH_URANDOM), "/dev/urandom", exists, S_IFCHR, =urandom_dev
@


1.41
log
@	Remove /dev/mem, /dev/kmem, /dev/port support.
	* Makefile.in (DLL_OFILES): Drop fhandler_mem.o.
	(fhandler_mem_CFLAGS): Remove rule.
	* devices.in (enum fh_devices): Remove FH_MEM, FH_KMEM and FH_PORT.
	* devices.cc: Regenerate.
	* dtable.cc (fh_alloc): Drop handling for FH_MEM, FH_KMEM and FH_PORT.
	* fhandler.h (class fhandler_dev_mem): Remove.
	* fhandler_mem.cc: Remove file.
	* globals.cc (ro_u_pmem): Remove.
	* mmap.cc (fhandler_dev_mem::mmap): Remove.
	(fhandler_dev_mem::munmap): Remove.
	(fhandler_dev_mem::fixup_mmap_after_fork): Remove.
@
text
@d155 2
a156 2
"/dev/zero", BRACK(FH_ZERO), "/dev/zero", exists, S_IFCHR
"/dev/full", BRACK(FH_FULL), "/dev/full", exists, S_IFCHR
@


1.40
log
@	* Merge in cygwin-64bit-branch.
@
text
@a158 2
"/dev/mem", BRACK(FH_MEM), "/dev/mem", exists, S_IFCHR
"/dev/kmem", BRACK(FH_KMEM), "/dev/kmem", exists, S_IFCHR
a159 1
"/dev/port", BRACK(FH_PORT), "/dev/port", exists, S_IFCHR
@


1.39
log
@	* devices.in: Fix native name of /dev/kmem.
	* devices.cc: Regenerate.
	* dtable.cc (fh_alloc): Don't forget FH_KMEM.
	* fhandler_mem.cc (fhandler_dev_mem::open): Set errno to EACCES rather
	than ENOENT on systems not granting access to physical memory from
	user space.
@
text
@d69 1
a69 1
  int devn = *const_cast<device *> (&dev);
d210 1
a210 1
  _dev_t devn = FHDEV (major, minor);
d226 1
a226 1
device::parse (_dev_t dev)
@


1.39.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d210 1
a210 1
  dev_t devn = FHDEV (major, minor);
d226 1
a226 1
device::parse (dev_t dev)
@


1.39.2.2
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d69 1
a69 1
  fh_devices devn = *const_cast<device *> (&dev);
@


1.38
log
@wincap.h: Rename assitant to assistant throughout.  wincap.cc: Ditto.
* devices.in (exists_console): Use fhandler_console::exists () rather than raw
test.
* devices.cc: Regenerate.
* fhandler.h (fhandler_console::exists): Define new function.
* fhandler_console.cc (fhandler_console::need_invisible): Use
fhandler_console::exists () rather than raw test.
* spawn.cc: Rename assitant to assistant throughout.
(child_info_spawn::worker): Simplify test for when to start a non-Cygwin
process in its own process group.  Just do it whenever we start a non-Cygwin
process.
@
text
@d160 1
a160 1
"/dev/kmem", BRACK(FH_KMEM), "/dev/mem", exists, S_IFCHR
@


1.37
log
@* devices.in (exists_console): Allow /dev/con{sole,in,out} to be referenced
they exist.
* devices.cc: Regenerate.
* fhandler_console.cc (fhandler_console::set_unit): Ditto.
@
text
@d8 2
d11 1
d75 1
a75 1
      return !!GetConsoleCP ();
@


1.36
log
@* devices.h (lives_in_dev): New field.
(dev_on_fs): Set bit size.
(is_dev_resident): Define new method.
* devices.in: Use different method for labelling requested name for dev
storage: prefix it with a ='.  Use an actual ':' to denote an internal device.
(exists_console): Avoid repeated test.
(exists_ntdev_silent): Rename from the less-descriptive exists_ntdevs.
(dev_dev_storage): Delete unneeded define.
* gendevices: Add a flag to each line denoting whether the device lives in /dev
space.
(generate): Handle special ":" case here for internal devices.  Parse
=something_dev as requiring a storage location.  Tack the rest of the line back
onto the reformulated "$rest".
* devices.cc: Regenerate.
@
text
@a65 2
  if (!iscons_dev (myself->ctty))
    return false;
d72 1
a72 1
      return true;
d75 1
a75 1
      return myself->ctty == devn;
@


1.35
log
@* devices.h (device::exists_func): Redefine field.
(device::dev_on_fs): Remove unneeded bit field.  Just make a normal boolean.
(device::exists): Redefine function.
* devices.in: Move previous functions earlier since they are now only defined
static.  Rename some functions due to an as-yet unresolved bug in gendevices.
Rename posix part of internal-only devices with a double-slash.  gendevices
will eventuall translate that to a ":".
(device::parse): Rework to use dev pointer and dev_storage_end.
* devices.cc: Regenerate.
* gendevices: Translate "// to ": after shilka processing.
@
text
@d58 1
a58 1
exists_ntdevs (const device& dev)
d74 1
a74 1
      return iscons_dev (myself->ctty);
d76 1
a108 3
const device dev_dev_storage =
  {"/dev", {FH_DEV}, "/dev", exists};

d139 2
a140 4
/* Internal devices below are marked with a //.  gendevices will
   eventually translate that to a : .  This is done because shilka
   does not support a colon here since it is designed to only handle
   C keywords with special handling for "/".  */
d144 4
a147 4
"/dev/pty%(0-63)d", BRACK(FHDEV(DEV_PTYS_MAJOR, {$1})), "/dev/pty{$1}", exists_pty, S_IFCHR, ptys_dev
"//ptym%(0-63)d", BRACK(FHDEV(DEV_PTYM_MAJOR, {$1})), "/dev/ptym{$1}", exists_internal, S_IFCHR, ptym_dev
"/dev/cons%(0-63)d", BRACK(FHDEV(DEV_CONS_MAJOR, {$1})), "/dev/cons{$1}", exists_console, S_IFCHR, cons_dev
"/dev/console", BRACK(FH_CONSOLE), "/dev/console", exists_console, S_IFCHR, console_dev
d157 1
a157 1
"/dev/urandom", BRACK(FH_URANDOM), "/dev/urandom", exists, S_IFCHR, urandom_dev
d162 1
a162 1
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 - 1})), "\\??\\COM{$1}", exists_ntdevs, S_IFCHR
d164 2
a165 2
"//pipe", BRACK(FH_PIPE), "/dev/pipe", exists_internal, S_IFCHR
"//fifo", BRACK(FH_FIFO), "/dev/fifo", exists_internal, S_IFCHR
@


1.34
log
@	* devices.cc: Regenerate.
	* devices.h (device::exists_func): New member function pointer,
	replacing noexpose.
	(device::expose): Remove.
	(device::exists_never): Declare.
	(device::exists_ptys): Declare.
	(device::exists_cons): Declare.
	(device::exists_console): Declare.
	(device::exists_nt_dev): Declare.
	(device::exists): Declare.
	* devices.in (dev_storage): Replace former noexpose values with
	pointers to matching exists_XXX method.
	(device::exists_never): New method.
	(device::exists_ptys): New method.
	(device::exists_cons): New method.
	(device::exists_console): New method.
	(device::exists_nt_dev): New method.
	(device::exists): New method.
	* fhandler_dev.cc (fhandler_dev::readdir): Replace call to
	device::expose with call to device::exists and drop all further
	existence filtering since it's done in device::exists now.
	* path.cc (path_conv::check): Replace call to device::expose with call
	to device::exists.
@
text
@d13 74
d88 1
a88 1
  {"/cygdrive", {FH_CYGDRIVE}, "/cygdrive"};
d91 1
a91 1
  {"", {FH_FS}, ""};
d94 1
a94 1
  {"", {FH_PROC}, ""};
d97 1
a97 1
  {"", {FH_PROCNET}, ""};
d100 1
a100 1
  {"", {FH_PROCSYS}, ""};
d103 1
a103 1
  {"", {FH_PROCSYSVIPC}, ""};
d106 1
a106 1
  {"", {FH_NETDRIVE}, ""};
d109 1
a109 1
  {"/dev", {FH_DEV}, "/dev"};
d112 1
a112 1
  {"", {FH_REGISTRY}, ""};
d115 1
a115 1
  {"", {FH_PIPER}, ""};
d118 1
a118 1
  {"", {FH_PIPEW}, ""};
d121 1
a121 1
  {"", {FH_TCP}, ""};
d124 1
a124 1
  {"", {FH_UDP}, ""};
d127 1
a127 1
  {"", {FH_STREAM}, ""};
d130 1
a130 1
  {"", {FH_DGRAM}, ""};
d133 1
a133 1
  {"", {FH_NADA}, ""};
d136 2
a137 1
  {"", {FH_ERROR}, ""};
a138 1

d141 4
d146 40
a185 40
"/dev/tty", BRACK(FH_TTY), "/dev/tty"
"/dev/pty%(0-63)d", BRACK(FHDEV(DEV_PTYS_MAJOR, {$1})), "/dev/pty{$1}", &device::exists_ptys, ptys_dev
"/dev/ptym%(0-63)d", BRACK(FHDEV(DEV_PTYM_MAJOR, {$1})), "/dev/ptym{$1}", &device::exists_never, ptym_dev
"/dev/cons%(0-63)d", BRACK(FHDEV(DEV_CONS_MAJOR, {$1})), "/dev/cons{$1}", &device::exists_cons, cons_dev
"/dev/console", BRACK(FH_CONSOLE), "/dev/console", &device::exists_console, console_dev
"/dev/ptmx", BRACK(FH_PTMX), "/dev/ptmx"
"/dev/windows", BRACK(FH_WINDOWS), "/dev/windows"
"/dev/dsp", BRACK(FH_OSS_DSP), "/dev/dsp"
"/dev/conin", BRACK(FH_CONIN), "/dev/conin", &device::exists_console
"/dev/conout", BRACK(FH_CONOUT), "/dev/conout", &device::exists_console
"/dev/null", BRACK(FH_NULL), "\\Device\\Null"
"/dev/zero", BRACK(FH_ZERO), "/dev/zero"
"/dev/full", BRACK(FH_FULL), "/dev/full"
"/dev/random", BRACK(FH_RANDOM), "/dev/random"
"/dev/urandom", BRACK(FH_URANDOM), "/dev/urandom", urandom_dev
"/dev/mem", BRACK(FH_MEM), "/dev/mem"
"/dev/kmem", BRACK(FH_KMEM), "/dev/mem"
"/dev/clipboard", BRACK(FH_CLIPBOARD), "/dev/clipboard"
"/dev/port", BRACK(FH_PORT), "/dev/port"
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 - 1})), "\\??\\COM{$1}", &device::exists_never
"/dev/ttyS%(0-63)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1})), "\\??\\COM{$1 + 1}", &device::exists_nt_dev
"/dev/pipe", BRACK(FH_PIPE), "/dev/pipe", &device::exists_never
"/dev/fifo", BRACK(FH_FIFO), "/dev/fifo", &device::exists_never
"/dev/st%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1})), "\\Device\\Tape{$1}", &device::exists_nt_dev
"/dev/nst%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1 + 128})), "\\Device\\Tape{$1}", &device::exists_nt_dev
"/dev/fd%(0-15)d", BRACK(FHDEV(DEV_FLOPPY_MAJOR, {$1})), "\\Device\\Floppy{$1}", &device::exists_nt_dev
"/dev/scd%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}", &device::exists_nt_dev
"/dev/sr%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}", &device::exists_nt_dev
"/dev/sd%{a-z}s", BRACK(FH_SD{uc $1}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sda%{a-z}s", BRACK(FH_SDA{uc $1}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sdb%{a-z}s", BRACK(FH_SDB{uc $1}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sdc%{a-z}s", BRACK(FH_SDC{uc $1}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sdd%{a-x}s", BRACK(FH_SDD{uc $1}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sd%{a-z}s%(1-15)d", BRACK(FH_SD{uc $1} | {$2}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sda%{a-z}s%(1-15)d", BRACK(FH_SDA{uc $1} | {$2}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sdb%{a-z}s%(1-15)d", BRACK(FH_SDB{uc $1} | {$2}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sdc%{a-z}s%(1-15)d", BRACK(FH_SDC{uc $1} | {$2}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sdd%{a-x}s%(1-15)d", BRACK(FH_SDD{uc $1} | {$2}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/kmsg", BRACK(FH_KMSG), "\\Device\\MailSlot\\cygwin\\dev\\kmsg"
"/dev", BRACK(FH_DEV), "/dev"
d213 1
a213 1
  _dev_t dev = FHDEV (major, minor);
d217 2
a218 2
  for (unsigned i = 0; i < (sizeof (dev_storage) / sizeof (dev_storage[0])); i++)
    if (dev_storage[i].d.devn == dev)
d220 1
a220 1
	*this = dev_storage[i];
a278 68

bool
device::exists_never () const
{
  return false;
}

bool
device::exists_ptys () const
{
  /* Only in-use ptys exist. */
  return cygwin_shared->tty.connect (get_minor ()) != -1;
}

bool
device::exists_cons () const
{
  /* /dev/consX only exists, if it's the current controlling tty. */
  return iscons_dev (myself->ctty) && myself->ctty == d.devn_int;
}

bool
device::exists_console () const
{
  /* console, conin, conout only exist if a console is our controlling tty. */
  return iscons_dev (myself->ctty);
}

bool
device::exists_nt_dev () const
{
  /* POSIX devices backed by real NT devices only exist if their NT device
     exists. */
  WCHAR wpath[MAX_PATH];
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  HANDLE h;
  NTSTATUS status;

  sys_mbstowcs (wpath, MAX_PATH, native);
  RtlInitUnicodeString (&upath, wpath);
  InitializeObjectAttributes (&attr, &upath,
			      OBJ_CASE_INSENSITIVE, NULL, NULL);
  /* Except for the serial IO devices, the native paths are direct device
     paths, not symlinks, so every status code except for "NOT_FOUND" means
     the device exists. */
  status = NtOpenSymbolicLinkObject (&h, SYMBOLIC_LINK_QUERY, &attr);
  switch (status)
    {
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_OBJECT_PATH_NOT_FOUND:
      return false;
    case STATUS_SUCCESS:
      NtClose (h);
      break;
    default:
      break;
    }
  return true;
}

bool  
device::exists () const
{
  if (!exists_func)
    return true;
  return (this->*exists_func)();
}
@


1.33
log
@(Interim checkin while we work on this)
* devices.cc: Regenerate.
* devices.h (device::noexpose): New field.
(device::dev_on_fs): Make a bit field.
(get_major): Use proper type for declaration.
(expose): New field.
(ext_dev_storage): Delete declaration.
(dev_storage_size): Ditto.
(dev_storage): New declaration.
(dev_storage_end): Ditto.
* devices.in: Mark /dev/ptym*, /dev/com*, /dev/pipe, /dev/fifo, and "/dev" as
"no expose".
* fhandler.h (fhandler_dev::lastrealpos): Delete declaration.
(fhandler_dev::devidx): Declare new field.
* fhandler_disk_file.cc: Move fhandler_dev functions into fhandler_dev.cc.
* fhandler_dev.cc: Add includes needed for functions moved from
fhandler_disk_file.cc.
(dev_storage_scan_start): Define place to start listing devices.
(dev_storage_size): Define size of array to scan.
(fhandler_dev::fhandler_dev): Move here from fhandler_disk_file.cc.
(fhandler_dev::opendir): Ditto.
(fhandler_dev::readdir): Just check devidx for non-NULL to determine when to go
to disk for /dev content.  Use dev_storage rather than ext_dev_storage.
Iterate over dev_storage using devidx pointer.  Use accessor functions rather
than raw references to the device struct.  Only increment dir->__d_position
when we are actually going to be returning something.  Add debug_printf for
exit.
(fhandler_dev::rewinddir): Set devidx as appropriate depending on whether
there's a /dev on disk or not.
* gendevices: Don't mark dev_storage static but do put it in the _RDATA
section.
* path.cc (path_conv::check): Use new "device::expose()" function to decide to
forbid programs from referencing internal device types.
@
text
@d7 2
d69 4
a72 4
"/dev/pty%(0-63)d", BRACK(FHDEV(DEV_PTYS_MAJOR, {$1})), "/dev/pty{$1}", ptys_dev
"/dev/ptym%(0-63)d", BRACK(FHDEV(DEV_PTYM_MAJOR, {$1})), "/dev/ptym{$1}", true, ptym_dev
"/dev/cons%(0-63)d", BRACK(FHDEV(DEV_CONS_MAJOR, {$1})), "/dev/cons{$1}", cons_dev
"/dev/console", BRACK(FH_CONSOLE), "/dev/console", console_dev
d76 2
a77 2
"/dev/conin", BRACK(FH_CONIN), "/dev/conin"
"/dev/conout", BRACK(FH_CONOUT), "/dev/conout"
d87 19
a105 19
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 - 1})), "\\??\\COM{$1}", true
"/dev/ttyS%(0-63)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1})), "\\??\\COM{$1 + 1}"
"/dev/pipe", BRACK(FH_PIPE), "/dev/pipe", true
"/dev/fifo", BRACK(FH_FIFO), "/dev/fifo", true
"/dev/st%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1})), "\\Device\\Tape{$1}"
"/dev/nst%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1 + 128})), "\\Device\\Tape{$1}"
"/dev/fd%(0-15)d", BRACK(FHDEV(DEV_FLOPPY_MAJOR, {$1})), "\\Device\\Floppy{$1}"
"/dev/scd%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}"
"/dev/sr%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}"
"/dev/sd%{a-z}s", BRACK(FH_SD{uc $1}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition0"
"/dev/sda%{a-z}s", BRACK(FH_SDA{uc $1}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition0"
"/dev/sdb%{a-z}s", BRACK(FH_SDB{uc $1}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition0"
"/dev/sdc%{a-z}s", BRACK(FH_SDC{uc $1}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition0"
"/dev/sdd%{a-x}s", BRACK(FH_SDD{uc $1}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition0"
"/dev/sd%{a-z}s%(1-15)d", BRACK(FH_SD{uc $1} | {$2}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition{$2 % 16}"
"/dev/sda%{a-z}s%(1-15)d", BRACK(FH_SDA{uc $1} | {$2}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition{$2 % 16}"
"/dev/sdb%{a-z}s%(1-15)d", BRACK(FH_SDB{uc $1} | {$2}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition{$2 % 16}"
"/dev/sdc%{a-z}s%(1-15)d", BRACK(FH_SDC{uc $1} | {$2}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition{$2 % 16}"
"/dev/sdd%{a-x}s%(1-15)d", BRACK(FH_SDD{uc $1} | {$2}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition{$2 % 16}"
d201 68
@


1.32
log
@	* Makefile.in (DLL_OFILES): Add fhandler_dev.o.
	* devices.h (DEV_DEV_MAJOR): Define.
	(FH_DEV): Redefine in terms of DEV_DEV_MAJOR.
	(ext_dev_storage): Declare.
	(dev_storage_size): Declare.
	(dev_dev_storage): Declare.
	(dev_dev): Define.
	(isdev_dev): Define.
	* devices.in (dev_dev_storage): Activate.
	(ext_dev_storage): Define as externally available pointer to
	dev_storage.
	(dev_storage_size): Define to contain number of dev_storage elements.
	* dir.cc (rmdir): Handle /dev as always not empty.
	* dtable.cc (fh_alloc): Handle DEV_DEV_MAJOR.
	* fhandler.h (fhandler_dev): New class, derived from fhandler_disk_file.
	(fhandler_union): Add fhandler_dev member.
	* fhandler_disk_file.cc (class __DIR_mounts): Handle /dev directory
	to make sure it always exists.
	* fhandler_dev.cc: New file implementing /dev.
	* globals.cc (ro_u_dev): New R/O unicode string.
	* path.cc (path_conv::check): Handle FH_DEV device.
@
text
@d68 1
a68 1
"/dev/ptym%(0-63)d", BRACK(FHDEV(DEV_PTYM_MAJOR, {$1})), "/dev/ptym{$1}", ptym_dev
d85 1
a85 1
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 - 1})), "\\??\\COM{$1}"
d87 2
a88 2
"/dev/pipe", BRACK(FH_PIPE), "/dev/pipe"
"/dev/fifo", BRACK(FH_FIFO), "/dev/fifo"
d110 1
a110 2
const device *ext_dev_storage = dev_storage;
const size_t dev_storage_size = sizeof dev_storage / sizeof dev_storage[0];
@


1.31
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@a31 1
#if 0
a33 1
#endif
d109 4
@


1.30
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d69 2
a70 2
"/dev/pty%(0-63)d", BRACK(FHDEV(DEV_TTYS_MAJOR, {$1})), "/dev/pty{$1}", ttys_dev
"/dev/ptym%(0-63)d", BRACK(FHDEV(DEV_TTYM_MAJOR, {$1})), "/dev/ptym{$1}", ttym_dev
@


1.29
log
@* cygheap.h (init_cygheap::ctty_on_hold): Remove conditionalized variable.
* dcrt0.cc (do_exit): Remove code which handled CYGWIN=tty style ttys.
* devices.in: Remove "/dev/ttym".
* dtable.cc: Rename tty to pty where appropriate throughout.
(dtable::stdio_init): Use new t->is_console rather than using now-deleted hwnd
element in tty structure.
(dtable::init_std_file_from_handle): Remove code which handled CYGWIN=tty style
ttys.
(fh_alloc): Ditto.
* fhandler.h: Rename tty to pty where appropriate.
(fhandler_pty_common): Delete output_done_event, ioctl_request_event,
ioctl_done_event.
(fhandler_pty_master::setup): Delete argument.
(fhandler_tty_master): Delete.
(fhandler_union): Delete __tty_master.
* fhandler_console.cc (use_tty): Delete.
(fhandler_console::get_tty_stuff): Set is_console to true rather than calling
sethwnd.
(fhandler_console::send_winch_maybe): Remove CYGWIN=tty considerations.
(fhandler_console::input_tcsetattr): Ditto.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use new t->is_console
rather than using now-deleted hwnd element in tty structure.
* fhandler_tty.cc: Rename tty to pty where appropriate throughout.
(tty_master): Delete.
(process_input): Ditto.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::*): Ditto.
(fhandler_pty_master::process_slave_output): Remove CYGWIN=tty considerations.
(fhandler_pty_slave::open): Ditto for *_done_event.
(fhandler_pty_slave::write): Ditto.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_slave::fch_open_handles): Ditto.
(fhandler_pty_slave::fch_set_sd): Ditto.
(fhandler_pty_slave::fch_close_handles): Ditto.
(fhandler_pty_common::close): Ditto.
(fhandler_pty_master::setup): Ditto.  Remove now-unneeded ispty parameter.
(fhandler_pty_master::open): Reflect argument removal for tty::allocate.
* select.cc: Rename tty to pty where appropriate throughout.
* sigproc.cc (proc_subproc): Remove CYGWIN=tty considerations.
* tty.cc (ttyslot): Accommodate CYGWIN=tty removal.
(tty_list::init_session): Ditto.
(tty_list::attach): Ditto.
(tty::create_master): Delete.
(tty_list::terminate): Ditto.
(tty_list::allocate): Delete "with_console" parameter.  Remove CYGWIN=tty
considerations.
(tty::init): Set is_console = false.  Use 'false' for was_opened since it is a
boolean.
* tty.h (*_{DONE,REQUEST}_EVENT): Delete.
(tty_min::is_console): Declare new field which replaces hwnd.
(tty_min::gethwnd): Delete.
(tty_min::sethwnd): Ditto.
(tty_list::allocate): Delete parameter.
(tty_list::terminate): Delete declaration.
* include/sys/cygwin.h (PID_USETTY): Redefine to PID_UNUSED1 and change comment
to reflect its availability.
@
text
@d69 2
a70 1
"/dev/tty%(0-63)d", BRACK(FHDEV(DEV_TTYS_MAJOR, {$1})), "/dev/tty{$1}", ttys_dev
d73 1
a73 1
"/dev/ptmx", BRACK(FH_PTYM), "/dev/ptmx"
@


1.28
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@a71 1
"/dev/ttym", BRACK(FH_TTYM), "/dev/ttym", ttym_dev
@


1.27
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d59 4
a62 1
  {"", {FH_BAD}, ""};
@


1.26
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d60 1
a60 1
#define BRACK(x) {x}
d67 1
d131 1
a131 1
  devn = 0;
d134 1
a134 1
    if (dev_storage[i].devn == dev)
d141 1
a141 1
    devn = FHDEV (major, minor);
@


1.25
log
@Implement /proc/sysvipc/*
* devices.in (dev_procsysvipc_storage): Add.
* devices.cc: Regenerate.
* devices.h (fh_devices): Add FH_PROCSYSVIPC.
* dtable.cc (build_fh_pc): Add case FH_PROCSYSVIPC.
* fhandler.h (class fhandler_procsysvipc): Declare.
(fhandler_union): Add __procsysvipc.
* fhandler_proc.cc (proc_tab): Add sysvipc virt_directory.
* fhandler_procsysvipc.cc: New file.
* Makefile.in (DLL_OFILES): Add fhandler_procsysvipc.o.
* path.h (isproc_dev): Add FH_PROCSYSVIPC to conditional.
@
text
@a149 9
device::tty_to_real_device ()
{
  if (!real_tty_attached (myself))
    *this = myself->ctty < 0 ? dev_bad_storage : *console_dev;
  else
    parse (DEV_TTYS_MAJOR, myself->ctty);
}

void
@


1.24
log
@	* devices.in: Throughout use slashes instead of backslashes in the
	native path of devices not backed by native NT devices.
	* devices.cc: Regenerate.
	* globals.cc (ro_u_pmem): Use correct case.
	(ro_u_globalroot): New R/O unicode string.
	* path.cc (path_conv::check): Fix incorrect handling of /proc/sys
	block devices if they are just visited due to a component check.
	(symlink_info::posixify): Fix typo in comment.
	(cygwin_conv_path): Use ro_u_globalroot instead of string constant.
	(fast_cwd_version): New shared variable to store FAST_CWD version
	used on the system.
	(find_fast_cwd_pointer): Rename from find_fast_cwd_pointers.  Don't
	set global fast_cwd_ptr pointer here.  Return pointer value instead.
	(find_fast_cwd): New function to set fast_cwd_ptr and fast_cwd_version.
	(cwdstuff::override_win32_cwd): Call find_fast_cwd from here.
	Check for fast_cwd_version to differ between old and new FAST_CWD
	structure.  Check old_cwd for NULL to avoid SEGV.  Don't set CWD if
	we have neitehr a valid fast_cwd_ptr, nor a valid CWD handle in the
	process parameter block.
	(cwdstuff::set): Create Win32 path taking /proc/sys paths into account.
	* spawn.cc (spawn_guts): Recode creating runpath.  Also take /proc/sys
	paths into account.  Drop special CWD handling when starting non-Cygwin
	processes.
@
text
@d26 3
@


1.23
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d62 9
a70 9
"/dev/tty", BRACK(FH_TTY), "\\dev\\tty"
"/dev/tty%(0-63)d", BRACK(FHDEV(DEV_TTYS_MAJOR, {$1})), "\\dev\\tty{$1}", ttys_dev
"/dev/console", BRACK(FH_CONSOLE), "\\dev\\console", console_dev
"/dev/ttym", BRACK(FH_TTYM), "\\dev\\ttym", ttym_dev
"/dev/ptmx", BRACK(FH_PTYM), "\\dev\\ptmx"
"/dev/windows", BRACK(FH_WINDOWS), "\\dev\\windows"
"/dev/dsp", BRACK(FH_OSS_DSP), "\\dev\\dsp"
"/dev/conin", BRACK(FH_CONIN), "conin"
"/dev/conout", BRACK(FH_CONOUT), "conout"
d72 8
a79 8
"/dev/zero", BRACK(FH_ZERO), "\\dev\\zero"
"/dev/full", BRACK(FH_FULL), "\\dev\\full"
"/dev/random", BRACK(FH_RANDOM), "\\dev\\random"
"/dev/urandom", BRACK(FH_URANDOM), "\\dev\\urandom", urandom_dev
"/dev/mem", BRACK(FH_MEM), "\\dev\\mem"
"/dev/kmem", BRACK(FH_KMEM), "\\dev\\mem"
"/dev/clipboard", BRACK(FH_CLIPBOARD), "\\dev\\clipboard"
"/dev/port", BRACK(FH_PORT), "\\dev\\port"
d82 2
a83 2
"/dev/pipe", BRACK(FH_PIPE), "\\dev\\pipe"
"/dev/fifo", BRACK(FH_FIFO), "\\dev\\fifo"
@


1.22
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d23 3
@


1.21
log
@* devices.in: Remove "Global" from tty device.
@
text
@a2 4
#include <sys/types.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
@


1.20
log
@* devices.in: Change mapping for /dev/ttyS* and /dev/com*.
@
text
@d82 1
a82 1
"/dev/ttyS%(0-63)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1})), "\\Global??\\COM{$1 + 1}"
@


1.19
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d81 2
a82 2
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 - 1})), "\\Device\\Serial{$1 - 1}"
"/dev/ttyS%(0-63)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1})), "\\Device\\Serial{$1}"
@


1.18
log
@	* devices.in (dev_storage): Use native NT device name for kmsg mailslot.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::operator =): Use path_conv assignment
	operator.
	(fhandler_base::set_name): Ditto.
	(fhandler_base::open): Use NT native path in debug output.
	* fhandler_mailslot.cc: Convert to NT native function calls.
	* ntdll.h (struct _FILE_MAILSLOT_SET_INFORMATION): Define.
	(NtCreateMailslotFile): Declare.
	* path.cc (path_conv::set_normalized_path): Don't set wide_path to NULL.
	(path_conv::set_name): Remove unused function.
	* path.h (path_conv::set_name): Drop declaration.
	(path_conv::operator =): Define.
@
text
@d162 1
a162 1
  else if (drive < 32)          /* /dev/sdq -to- /dev/sdaf */
d167 1
a167 1
  else if (drive < 48)          /* /dev/sdag -to- /dev/sdav */
d172 1
a172 1
  else if (drive < 64)          /* /dev/sdaw -to- /dev/sdbl */
d177 1
a177 1
  else if (drive < 80)          /* /dev/sdbm -to- /dev/sdcb */
d182 1
a182 1
  else if (drive < 96)          /* /dev/sdcc -to- /dev/sdcr */
d187 1
a187 1
  else if (drive < 112)          /* /dev/sdcs -to- /dev/sddh */
d193 2
a194 2
           /proc/partitions if there are more than 128 devices */
  else                           /* /dev/sddi -to- /dev/sddx */
@


1.17
log
@	* devices.in: Change native device name to native NT device name for
	/dev/null, /dev/comX and /dev/ttySx.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_9x): Remove.
	(fhandler_base::open): Don't test for DOS device name, don't call
	open_9x.
	(fhandler_dev_null::open): Remove.
	* fhandler.h (class fhandler_base): Drop open_9x declaration.
	(class fhandler_dev_null): Drop open declaration.
@
text
@d100 1
a100 1
"/dev/kmsg", BRACK(FH_KMSG), "\\\\.\\mailslot\\cygwin\\dev\\kmsg"
@


1.16
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procnet.o.
	* autoload.cc (GetAdaptersAddresses): Define.
	* devices.h (FH_PROCNET): Define new device.
	* devices.in (dev_procnet_storage): Add "/proc/net" entry.
	* devices.cc: Regenerate.
	* dir.cc (readdir_worker): Use isproc_dev macro.
	* dtable.cc (build_fh_pc): Add FH_PROCNET.
	* fhandler.h (class fhandler_procnet): New class.
	* fhandler_proc.cc: Add "net" subdirectory handling.
	* fhandler_procnet.cc: New file handling "/proc/net" directory.
	* path.cc (isvirtual_dev): Move to path.h.
	* path.h (isproc_dev): New macro to identify /proc files by device.
	(isvirtual_dev): Moved here.  Define using isproc_dev.
	* syscalls.cc (unlink): Use isproc_dev macro.
	* wincap.h (wincapc::has_gaa_prefixes): New element.
	(wincapc::has_gaa_on_link_prefix): New element.
	* wincap.cc: Implement above elements throughout.
	(wincapc::init): Check XP for service pack and set has_gaa_prefixes
	appropriately.
	* include/cygwin/in6.h: Include asm/byteorder.h.
@
text
@d72 1
a72 1
"/dev/null", BRACK(FH_NULL), "nul"
d81 2
a82 2
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1})), "\\\\.\\com{$1}"
"/dev/ttyS%(0-63)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 + 1})), "\\\\.\\com{$1 + 1}"
@


1.15
log
@	* devices.h: Add additional SCSI disk block device numbers per
	http://www.kernel.org/pub/linux/docs/device-list/devices.txt
	up to 128 devices.
	* devices.in: Ditto.
	(device::parsedisk): Add additonal else-if cases for decoding base
	and drive indices.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add additional DEV_SD{2..7}_MAJOR cases.
@
text
@d24 3
@


1.14
log
@	* devices.in: Raise number of handled serial ports to 64.
	* devices.cc: Regenerate.
@
text
@d88 4
d93 4
d157 1
a157 1
  if (drive < ('q' - 'a'))
d159 1
a159 1
  else
d164 32
@


1.13
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@d79 1
a79 1
"/dev/ttyS%(0-15)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 + 1})), "\\\\.\\com{$1 + 1}"
@


1.12
log
@* cygheap.h (cygheap_types): Add HEAP_COMMUNE.
* fhandler_proc.cc: Use cygheap rather than user heap for allocation of filebuf
throughout.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_process.cc: Ditto.
(get_mem_values): Use malloc/realloc/free rather than new.
* pinfo.cc (_pinfo::commune_send): Allocate on cygwin heap rather than user
heap.  Avoid calling ReadFile when correct number of characters have been read
or suffer buffer corruption.
(_pinfo::fd): Allocate on cygwin heap rather than user heap.
(_pinfo::fds): Ditto.
(_pinfo::root): Ditto.
(_pinfo::cwd): Ditto.
(_pinfo::cmdline): Ditto.
* devices.h (FH_DEV): New define.
* devices.in: Detect lone /dev.
* devices.cc: Regenerate.
* path.cc (path_conv::check): Treat FH_DEV as a special case.
@
text
@a127 1
  return;
@


1.11
log
@	* Makefile.in (DLL_OFILES): Add fhandler_mailslot.o.
	* devices.h (FH_KMSG): Define new device.
	* devices.in: Add "/dev/kmsg" entry.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Handle case FH_KMSG.
	* fhandler.h (class fhandler_mailslot): New class.
	(class select_stuff): Add device_specific_mailslot pointer.
	* fhandler_mailslot.cc: New file.
	* select.cc (peek_mailslot): New function.
	(verify_mailslot): Ditto.
	(struct mailslotinf): New stuct to handle select on mailslots.
	(thread_mailslot): New function.
	(start_thread_mailslot): Ditto.
	(mailslot_cleanup): Ditto.
	(fhandler_mailslot::select_read): New method.
	* syslog.cc (klog_guard): New muto.
	(dev_kmsg): Local mailslot for kernel message device.
	(vklog): New function.
	(klog): Ditto.
	* winsup.h (vklog): Declare.
	(klog): Ditto.
	* include/sys/syslog.h: Define _PATH_KLOG.
@
text
@d27 5
d90 1
@


1.10
log
@* Makefile.in (DLL_O_FILES): Add fhandler_netdrive.o.
* fhandler_netdrive.cc: Placeholder file for future development.
* devices.h (FH_NETDRIVE): Define new virtual device type.
(netdrive_dev): Define.
* devices.in (dev_netdrive_storage): Define.
* devices.cc: Regenerate.
@
text
@d84 1
@


1.9
log
@* child_info.h (fork_info): Use different method to alias variable.
(spawn_info): Ditto.
* cxx.cc (__cxa_guard_acquire): New function (needed for gcc 4.x).
(__cxa_guard_release): Ditto.
* devices.in: Make sure stuff is correctly bracketed (for gcc 4.x).
* devices.cc: Regenerate.
* fhandler.h (fhandler_disk_file::fchmod): Avoid left coercion (for gcc 4.x).
* smallprint.c (__rn): Declare as __fastcall since gcc 4.x complains about use
of regparm, for some reason.
* sync.h (sync::init_lock): Remove.
* sync.cc (sync::init_lock): Ditto.
@
text
@d24 3
@


1.8
log
@	* devices.in (parsedisk): Fix typo.
@
text
@d16 1
a16 1
  {"/cygdrive", FH_CYGDRIVE, "/cygdrive"};
d19 1
a19 1
  {"", FH_FS, ""};
d22 1
a22 1
  {"", FH_PROC, ""};
d25 1
a25 1
  {"", FH_REGISTRY, ""};
d28 1
a28 1
  {"", FH_PIPER, ""};
d31 1
a31 1
  {"", FH_PIPEW, ""};
d34 1
a34 1
  {"", FH_TCP, ""};
d37 1
a37 1
  {"", FH_UDP, ""};
d40 1
a40 1
  {"", FH_STREAM, ""};
d43 1
a43 1
  {"", FH_DGRAM, ""};
d46 2
a47 1
  {"", FH_BAD, ""};
d52 29
a80 29
"/dev/tty", FH_TTY, "\\dev\\tty"
"/dev/tty%(0-63)d", FHDEV(DEV_TTYS_MAJOR, {$1}), "\\dev\\tty{$1}", ttys_dev
"/dev/console", FH_CONSOLE, "\\dev\\console", console_dev
"/dev/ttym", FH_TTYM, "\\dev\\ttym", ttym_dev
"/dev/ptmx", FH_PTYM, "\\dev\\ptmx"
"/dev/windows", FH_WINDOWS, "\\dev\\windows"
"/dev/dsp", FH_OSS_DSP, "\\dev\\dsp"
"/dev/conin", FH_CONIN, "conin"
"/dev/conout", FH_CONOUT, "conout"
"/dev/null", FH_NULL, "nul"
"/dev/zero", FH_ZERO, "\\dev\\zero"
"/dev/full", FH_FULL, "\\dev\\full"
"/dev/random", FH_RANDOM, "\\dev\\random"
"/dev/urandom", FH_URANDOM, "\\dev\\urandom", urandom_dev
"/dev/mem", FH_MEM, "\\dev\\mem"
"/dev/kmem", FH_KMEM, "\\dev\\mem"
"/dev/clipboard", FH_CLIPBOARD, "\\dev\\clipboard"
"/dev/port", FH_PORT, "\\dev\\port"
"/dev/com%(1-16)d", FHDEV(DEV_SERIAL_MAJOR, {$1}), "\\\\.\\com{$1}"
"/dev/ttyS%(0-15)d", FHDEV(DEV_SERIAL_MAJOR, {$1 + 1}), "\\\\.\\com{$1 + 1}"
"/dev/pipe", FH_PIPE, "\\dev\\pipe"
"/dev/fifo", FH_FIFO, "\\dev\\fifo"
"/dev/st%(0-127)d", FHDEV(DEV_TAPE_MAJOR, {$1}), "\\Device\\Tape{$1}"
"/dev/nst%(0-127)d", FHDEV(DEV_TAPE_MAJOR, {$1 + 128}), "\\Device\\Tape{$1}"
"/dev/fd%(0-15)d", FHDEV(DEV_FLOPPY_MAJOR, {$1}), "\\Device\\Floppy{$1}"
"/dev/scd%(0-15)d", FHDEV(DEV_CDROM_MAJOR, {$1}), "\\Device\\CdRom{$1}"
"/dev/sr%(0-15)d", FHDEV(DEV_CDROM_MAJOR, {$1}), "\\Device\\CdRom{$1}"
"/dev/sd%{a-z}s", FH_SD{uc $1}, "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition0"
"/dev/sd%{a-z}s%(1-15)d", FH_SD{uc $1} | {$2}, "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition{$2 % 16}"
d83 1
@


1.7
log
@	* devices.h: Switch FH_ZERO and FH_PORT as on Linux.  Add FH_FULL.
	* devices.in: Add /dev/full.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add FH_FULL.
	* fhandler.cc (fhandler_base::fstat): Set FH_FULL permission bits
	correctly.
	* fhandler_zero.cc (fhandler_dev_zero::write): Set errno to ENOSPC
	and return -1 if device is FH_FULL.
@
text
@d143 1
a143 1
      drive -= 'q' - 'q';
@


1.6
log
@* cygthread.cc (cygthread::terminate_thread): Wait briefly for notification
event in the event that the thread was actually in the process of exiting.
* pipe.cc (fhandler_pipe::dup): read_state is not supposed to be inheritable.
Fix that.
* path.cc (path_conv::check): Set symlen = 0 to avoid a compiler warning.
* devices.h (devices::parsedisk): Declare new function.
* devices.in (devices::parsedisk): Define new function.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
name.
* fhandler_proc.cc (format_proc_partitions): Use parsedisk to generate disk
names from numeric codes.  (This was broken on two of my systems previously and
is still broken now)
@
text
@d62 1
@


1.5
log
@* syscalls.cc (truncate64): Don't second-guess errno if open fails.
@
text
@d133 13
@


1.4
log
@* devices.in: Change raw com device to more correct form.
@
text
@d68 1
a68 1
"/dev/com%(0-16)d", FHDEV(DEV_SERIAL_MAJOR, {$1}), "\\\\.\\com{$1}"
@


1.3
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d68 2
a69 2
"/dev/com%(0-16)d", FHDEV(DEV_SERIAL_MAJOR, {$1}), "\\.\\com{$1}"
"/dev/ttyS%(0-15)d", FHDEV(DEV_SERIAL_MAJOR, {$1 + 1}), "\\.\\com{$1 + 1}"
@


1.3.6.1
log
@* devices.in: Change raw com device to more correct form.
* fhandler.cc (fhandler_base::open): Use major numbers rather than device
numbers to control special behavior for devices which take units.
* fhandler_raw.cc (fhandler_dev_raw::writebuf): Ditto.
(fhandler_dev_raw::fstat): Ditto.
(fhandler_dev_raw::open): Ditto.
(fhandler_dev_raw::ioctl): Ditto.
@
text
@d68 2
a69 2
"/dev/com%(0-16)d", FHDEV(DEV_SERIAL_MAJOR, {$1}), "\\\\.\\com{$1}"
"/dev/ttyS%(0-15)d", FHDEV(DEV_SERIAL_MAJOR, {$1 + 1}), "\\\\.\\com{$1 + 1}"
@


1.2
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@a88 2
  else if (dev->devn == FH_TTY)
    tty_to_real_device ();
@


1.1
log
@* Makefile.in: Add YA method for generating devices.cc.
* child_info.h: YA update of another magic number.
* gendevices: New file.
* devices.in: New file.
* devices.cc: Regenerate.
* devices.shilka: Remove.
* devices.h: Correctly define device pointers.
(device): Remove now obsolete fields.
(device::native): Renamed from device::fmt.
* dtable.cc (build_fh_dev): Simplify in light of new unit parsing scheme.
(build_fh_pc): Ditto.
* path.cc (win32_device_name): Ditto.
* fhandler.h (fhandler_base::get_native_name): Reflect renaming of fmt to
native.
* fhandler_tty.cc (fhandler_tty_mster::init): Initialize slave device prior to
reporting unit.
@
text
@d33 12
d46 1
a46 1
  {":bad:", FH_BAD, ""};
a50 6
"/dev/inet/tcp", FH_TCP, "", tcp_dev
"/dev/inet/udp", FH_UDP, "", udp_dev
"/dev/inet/icmp", FH_ICMP, "", icmp_dev
"/dev/inet/unix", FH_UNIX, "", unix_dev
"/dev/inet/stream", FH_STREAM, "", stream_dev
"/dev/inet/dgram", FH_DGRAM, "", dgram_dev
@

