head	1.17;
access;
symbols
	cygwin-1_7_35-release:1.17
	cygwin-1_7_34-release:1.17
	cygwin-1_7_33-release:1.15
	cygwin-1_7_32-release:1.15
	cygwin-1_7_31-release:1.15
	cygwin-1_7_30-release:1.15
	cygwin-1_7_29-release:1.15
	cygwin-1_7_29-release-branchpoint:1.15.0.2
	cygwin-pre-user-db:1.15
	cygwin-1_7_28-release:1.15
	cygwin-1_7_27-release:1.15
	cygwin-1_7_26-release:1.15
	cygwin-1_7_25-release:1.15
	cygwin-1_7_24-release:1.15
	cygwin-1_7_23-release:1.15
	cygwin-1_7_22-release:1.15
	cygwin-1_7_21-release:1.15
	cygwin-1_7_20-release:1.15
	cygwin-1_7_19-release:1.15
	cygwin-64bit-postmerge:1.13
	cygwin-64bit-premerge-branch:1.12.0.2
	cygwin-64bit-premerge:1.12
	cygwin-1_7_18-release:1.12
	post-ptmalloc3:1.11.2.4
	pre-ptmalloc3:1.11.2.4
	cygwin-1_7_17-release:1.11
	cygwin-64bit-branch:1.11.0.2
	cygwin-1_7_16-release:1.11
	cygwin-1_7_15-release:1.11
	cygwin-1_7_14_2-release:1.11
	cygwin-1_7_14-release:1.11
	cygwin-1_7_12-release:1.11
	cygwin-1_7_11-release:1.11
	cygwin-1_7_10-release:1.11
	signal-rewrite:1.10.0.2
	pre-notty:1.10
	cygwin-1_7_9-release:1.7
	cv-post-1_7_9:1.7.0.2
	cygwin-1_7_8-release:1.5;
locks; strict;
comment	@// @;


1.17
date	2014.10.09.17.45.27;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2014.10.09.13.24.37;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.28.15.07.00;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.06.06.05.02.10;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.06.10.56.37;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2011.03.04.17.51.42;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.02.13.22.44;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2011.02.15.14.44.11;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.02.08.44.08;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.10.08.06.02;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.08.09.10.21;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	;

1.11.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2012.12.10.11.45.47;	author corinna;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.17
log
@	* fhandler_procsys.cc (fhandler_procsys::readdir): Just test
	ObjectTypeName for object types rather than calling lstat to avoid
	performance hit.
	* globals.cc (ro_u_natdir): Define.
	(ro_u_natsyml): Define.
	(ro_u_natdev): Define.
@
text
@/* fhandler_procsys.cc: fhandler for native NT namespace.

   Copyright 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include <winioctl.h>
#include "ntdll.h"
#include "tls_pbuf.h"

#include <dirent.h>

/* Path of the /proc/sys filesystem */
const char procsys[] = "/proc/sys";
const size_t procsys_len = sizeof (procsys) - 1;

#define mk_unicode_path(p) \
	WCHAR namebuf[strlen (get_name ()) + 1]; \
	{ \
	  const char *from; \
	  PWCHAR to; \
	  for (to = namebuf, from = get_name () + procsys_len; *from; \
	       to++, from++) \
	    /* The NT device namespace is ASCII only. */ \
	    *to = (*from == '/') ? L'\\' : (WCHAR) *from; \
	  if (to == namebuf) \
	    *to++ = L'\\'; \
	  *to = L'\0'; \
	  RtlInitUnicodeString ((p), namebuf); \
	}

/* Returns 0 if path doesn't exist, >0 if path is a directory,
   -1 if path is a file, -2 if it's a symlink.  */
virtual_ftype_t
fhandler_procsys::exists (struct stat *buf)
{
  UNICODE_STRING path;
  UNICODE_STRING dir;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  HANDLE h;
  FILE_BASIC_INFORMATION fbi;
  bool internal = false;
  bool desperate_parent_check = false;
  /* Default device type is character device. */
  virtual_ftype_t file_type = virt_chr;

  if (strlen (get_name ()) == procsys_len)
    return virt_rootdir;
  mk_unicode_path (&path);

  /* Try to open parent dir.  If it works, the object is definitely
     an object within the internal namespace.  We don't need to test
     it for being a file or dir on the filesystem anymore.  If the
     error is STATUS_OBJECT_TYPE_MISMATCH, we know that the file
     itself is external.  Otherwise we don't know. */
  RtlSplitUnicodePath (&path, &dir, NULL);
  /* RtlSplitUnicodePath preserves the trailing backslash in dir.  Don't
     preserve it to open the dir, unless it's the object root. */
  if (dir.Length > sizeof (WCHAR))
    dir.Length -= sizeof (WCHAR);
  InitializeObjectAttributes (&attr, &dir, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenDirectoryObject (&h, DIRECTORY_QUERY, &attr);
  debug_printf ("NtOpenDirectoryObject: %y", status);
  if (NT_SUCCESS (status))
    {
      internal = true;
      NtClose (h);
    }

  /* First check if the object is a symlink. */
  InitializeObjectAttributes (&attr, &path, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenSymbolicLinkObject (&h, READ_CONTROL | SYMBOLIC_LINK_QUERY,
				     &attr);
  debug_printf ("NtOpenSymbolicLinkObject: %y", status);
  if (NT_SUCCESS (status))
    {
      /* If requested, check permissions. */
      if (buf)
	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);
      NtClose (h);
      return virt_symlink;
    }
  else if (status == STATUS_ACCESS_DENIED)
    return virt_symlink;
  /* Then check if it's an object directory. */
  status = NtOpenDirectoryObject (&h, READ_CONTROL | DIRECTORY_QUERY, &attr);
  debug_printf ("NtOpenDirectoryObject: %y", status);
  if (NT_SUCCESS (status))
    {
      /* If requested, check permissions. */
      if (buf)
	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);
      NtClose (h);
      return virt_directory;
    }
  else if (status == STATUS_ACCESS_DENIED)
    return virt_directory;
  /* Next try to open as file/device. */
  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_ATTRIBUTES, &attr, &io,
		       FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
  debug_printf ("NtOpenFile: %y", status);
  /* Name is invalid, that's nothing. */
  if (status == STATUS_OBJECT_NAME_INVALID)
    return virt_none;
  /* If no media is found, or we get this dreaded sharing violation, let
     the caller immediately try again as normal file. */
  if (status == STATUS_NO_MEDIA_IN_DEVICE
      || status == STATUS_SHARING_VIOLATION)
    return virt_fsfile;	/* Just try again as normal file. */
  /* If file or path can't be found, let caller try again as normal file. */
  if (status == STATUS_OBJECT_PATH_NOT_FOUND
      || status == STATUS_OBJECT_NAME_NOT_FOUND)
    return virt_fsfile;
  /* Check for pipe errors, which make a good hint... */
  if (status >= STATUS_PIPE_NOT_AVAILABLE && status <= STATUS_PIPE_BUSY)
    return virt_pipe;
  if (status == STATUS_ACCESS_DENIED && !internal)
    {
      /* Check if this is just some file or dir on a real FS to circumvent
	 most permission problems.  Don't try that on internal objects,
	 since NtQueryAttributesFile might crash the machine if the underlying
	 driver is badly written. */
      status = NtQueryAttributesFile (&attr, &fbi);
      debug_printf ("NtQueryAttributesFile: %y", status);
      if (NT_SUCCESS (status))
	return (fbi.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	       ? virt_fsdir : virt_fsfile;
      /* Ok, so we're desperate and the file still maybe on some filesystem.
	 To check this, we now split the path until we can finally access any
	 of the parent's.  Then we fall through to check the parent type.  In
	 contrast to the first parent check, we now check explicitely with
	 trailing backslash.  This will fail for directories in the internal
	 namespace, so we won't accidentally test those. */
      dir = path;
      InitializeObjectAttributes (&attr, &dir, OBJ_CASE_INSENSITIVE,
				  NULL, NULL);
      do
	{
	  RtlSplitUnicodePath (&dir, &dir, NULL);
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_ATTRIBUTES,
			       &attr, &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  debug_printf ("NtOpenDirectoryObject: %y", status);
	  if (dir.Length > sizeof (WCHAR))
	    dir.Length -= sizeof (WCHAR);
	}
      while (dir.Length > sizeof (WCHAR) && !NT_SUCCESS (status));
      desperate_parent_check = true;
    }
  if (NT_SUCCESS (status))
    {
      FILE_FS_DEVICE_INFORMATION ffdi;

      /* If requested, check permissions.  If this is a parent handle from
	 the above desperate parent check, skip. */
      if (buf && !desperate_parent_check)
	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);

      /* Check for the device type. */
      status = NtQueryVolumeInformationFile (h, &io, &ffdi, sizeof ffdi,
					     FileFsDeviceInformation);
      debug_printf ("NtQueryVolumeInformationFile: %y", status);
      /* Don't call NtQueryInformationFile unless we know it's a safe type.
	 The call is known to crash machines, if the underlying driver is
	 badly written. */
      if (NT_SUCCESS (status))
	{
	  if (ffdi.DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM)
	    file_type = virt_blk;
	  else if (ffdi.DeviceType == FILE_DEVICE_NAMED_PIPE)
	    file_type = internal ? virt_blk : virt_pipe;
	  else if (ffdi.DeviceType == FILE_DEVICE_DISK
		   || ffdi.DeviceType == FILE_DEVICE_CD_ROM
		   || ffdi.DeviceType == FILE_DEVICE_DFS
		   || ffdi.DeviceType == FILE_DEVICE_VIRTUAL_DISK)
	    {
	      /* Check for file attributes.  If we get them, we peeked
		 into a real FS through /proc/sys. */
	      status = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
					       FileBasicInformation);
	      debug_printf ("NtQueryInformationFile: %y", status);
	      if (!NT_SUCCESS (status))
		file_type = virt_blk;
	      else
		file_type = (fbi.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			    ? virt_fsdir : virt_fsfile;
	    }
	}
      NtClose (h);
    }
  /* That's it.  Return type we found above. */
  return file_type;
}

virtual_ftype_t
fhandler_procsys::exists ()
{
  return exists (NULL);
}

fhandler_procsys::fhandler_procsys ():
  fhandler_virtual ()
{
}

#define UNREADABLE_SYMLINK_CONTENT "<access denied>"

bool
fhandler_procsys::fill_filebuf ()
{
  char *fnamep;
  UNICODE_STRING path, target;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;
  HANDLE h;
  tmp_pathbuf tp;
  size_t len;

  mk_unicode_path (&path);
  if (path.Buffer[path.Length / sizeof (WCHAR) - 1] == L'\\')
    path.Length -= sizeof (WCHAR);
  InitializeObjectAttributes (&attr, &path, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenSymbolicLinkObject (&h, SYMBOLIC_LINK_QUERY, &attr);
  if (!NT_SUCCESS (status))
    goto unreadable;
  RtlInitEmptyUnicodeString (&target, tp.w_get (),
			     (NT_MAX_PATH - 1) * sizeof (WCHAR));
  status = NtQuerySymbolicLinkObject (h, &target, NULL);
  NtClose (h);
  if (!NT_SUCCESS (status))
    goto unreadable;
  len = sys_wcstombs (NULL, 0, target.Buffer, target.Length / sizeof (WCHAR));
  filebuf = (char *) crealloc_abort (filebuf, procsys_len + len + 1);
  sys_wcstombs (fnamep = stpcpy (filebuf, procsys), len + 1, target.Buffer,
		target.Length / sizeof (WCHAR));
  while ((fnamep = strchr (fnamep, '\\')))
    *fnamep = '/';
  return true;

unreadable:
  filebuf = (char *) crealloc_abort (filebuf,
				     sizeof (UNREADABLE_SYMLINK_CONTENT));
  strcpy (filebuf, UNREADABLE_SYMLINK_CONTENT);
  return false;
}

int __reg2
fhandler_procsys::fstat (struct stat *buf)
{
  const char *path = get_name ();
  debug_printf ("fstat (%s)", path);

  fhandler_base::fstat (buf);
  /* Best bet. */
  buf->st_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
  buf->st_uid = 544;
  buf->st_gid = 18;
  buf->st_dev = buf->st_rdev = dev ();
  buf->st_ino = get_ino ();
  switch (exists (buf))
    {
    case virt_directory:
    case virt_rootdir:
    case virt_fsdir:
      buf->st_mode |= S_IFDIR;
      if (buf->st_mode & S_IRUSR)
	buf->st_mode |= S_IXUSR;
      if (buf->st_mode & S_IRGRP)
	buf->st_mode |= S_IXGRP;
      if (buf->st_mode & S_IROTH)
	buf->st_mode |= S_IXOTH;
      break;
    case virt_file:
    case virt_fsfile:
      buf->st_mode |= S_IFREG;
      break;
    case virt_symlink:
      buf->st_mode |= S_IFLNK;
      break;
    case virt_pipe:
      buf->st_mode |= S_IFIFO;
      break;
    case virt_socket:
      buf->st_mode |= S_IFSOCK;
      break;
    case virt_chr:
      buf->st_mode |= S_IFCHR;
      break;
    case virt_blk:
      buf->st_mode |= S_IFBLK;
      break;
    default:
      set_errno (ENOENT);
      return -1;
    }
  return 0;
}

DIR *
fhandler_procsys::opendir (int fd)
{
  UNICODE_STRING path;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;
  HANDLE h;
  DIR *dir;

  mk_unicode_path (&path);
  InitializeObjectAttributes (&attr, &path, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenDirectoryObject (&h, DIRECTORY_QUERY, &attr);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return NULL;
    }
  if (!(dir = fhandler_virtual::opendir (fd)))
    NtClose (h);
  else
    dir->__handle = h;
  return dir;
}

int
fhandler_procsys::readdir (DIR *dir, dirent *de)
{
  NTSTATUS status;
  struct fdbi
  {
    DIRECTORY_BASIC_INFORMATION dbi;
    WCHAR buf[2][NAME_MAX + 1];
  } f;
  int res = EBADF;

  if (dir->__handle != INVALID_HANDLE_VALUE)
    {
      BOOLEAN restart = dir->__d_position ? FALSE : TRUE;
      status = NtQueryDirectoryObject (dir->__handle, &f, sizeof f, TRUE,
				       restart, (PULONG) &dir->__d_position,
				       NULL);
      if (!NT_SUCCESS (status))
	res = ENMFILE;
      else
	{
	  sys_wcstombs (de->d_name, NAME_MAX + 1, f.dbi.ObjectName.Buffer,
			f.dbi.ObjectName.Length / sizeof (WCHAR));
	  de->d_ino = hash_path_name (get_ino (), de->d_name);
	  if (RtlEqualUnicodeString (&f.dbi.ObjectTypeName, &ro_u_natdir,
				     FALSE))
	    de->d_type = DT_DIR;
	  else if (RtlEqualUnicodeString (&f.dbi.ObjectTypeName, &ro_u_natsyml,
					  FALSE))
	    de->d_type = DT_LNK;
	  else if (!RtlEqualUnicodeString (&f.dbi.ObjectTypeName, &ro_u_natdev,
					   FALSE))
	    de->d_type = DT_CHR;
	  else /* Can't nail down "Device" objects without further testing. */
	    de->d_type = DT_UNKNOWN;
	  res = 0;
	}
    }
  syscall_printf ("%d = readdir(%p, %p)", res, dir, de);
  return res;
}

long
fhandler_procsys::telldir (DIR *dir)
{
  return dir->__d_position;
}

void
fhandler_procsys::seekdir (DIR *dir, long pos)
{
  dir->__d_position = pos;
}

int
fhandler_procsys::closedir (DIR *dir)
{
  if (dir->__handle != INVALID_HANDLE_VALUE)
    {
      NtClose (dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
    }
  return fhandler_virtual::closedir (dir);
}

void __reg3
fhandler_procsys::read (void *ptr, size_t& len)
{
  fhandler_base::raw_read (ptr, len);
}

ssize_t __stdcall
fhandler_procsys::write (const void *ptr, size_t len)
{
  return fhandler_base::raw_write (ptr, len);
}

int
fhandler_procsys::open (int flags, mode_t mode)
{
  int res = 0;

  if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
    set_errno (EINVAL);
  else
    {
      switch (exists (NULL))
	{
	case virt_directory:
	case virt_rootdir:
	  if ((flags & O_ACCMODE) != O_RDONLY)
	    set_errno (EISDIR);
	  else
	    {
	      nohandle (true);
	      res = 1;
	    }
	  break;
	case virt_none:
	  set_errno (ENOENT);
	  break;
	default:
	  res = fhandler_base::open (flags, mode);
	  break;
	}
    }
  syscall_printf ("%d = fhandler_procsys::open(%p, 0%o)", res, flags, mode);
  return res;
}

int
fhandler_procsys::close ()
{
  if (!nohandle ())
    NtClose (get_handle ());
  return fhandler_virtual::close ();
}
#if 0
int
fhandler_procsys::ioctl (unsigned int cmd, void *)
{
}
#endif
@


1.16
log
@	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent d_type.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::readdir): Ditto.
	* fhandler_procsys.cc (fhandler_procsys::readdir): Ditto.
	* fhandler_procsysvipc.cc (fhandler_procsysvipc::readdir): Ditto.
	*  fhandler_virtual.h (virt_ftype_to_dtype): Define new inline function
	to generate dirent d_type from virtual_ftype_t.
@
text
@d180 1
a180 13
      if (!NT_SUCCESS (status))
	{
	  NtClose (h);
	  return file_type;
	}
      if (ffdi.DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM)
	file_type = virt_blk;
      else if (ffdi.DeviceType == FILE_DEVICE_NAMED_PIPE)
	file_type = internal ? virt_blk : virt_pipe;
      else if (ffdi.DeviceType == FILE_DEVICE_DISK
	       || ffdi.DeviceType == FILE_DEVICE_CD_ROM
	       || ffdi.DeviceType == FILE_DEVICE_DFS
	       || ffdi.DeviceType == FILE_DEVICE_VIRTUAL_DISK)
d182 1
a182 6
	  /* Check for file attributes.  If we get them, we peeked
	     into a real FS through /proc/sys. */
	  status = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
					   FileBasicInformation);
	  debug_printf ("NtQueryInformationFile: %y", status);
	  if (!NT_SUCCESS (status))
d184 18
a201 3
	  else
	    file_type = (fbi.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			? virt_fsdir : virt_fsfile;
a346 1
  tmp_pathbuf tp;
a357 3
	  struct stat st;
	  char *file = tp.c_get ();

d361 10
a370 4
	  stpcpy (stpcpy (stpcpy (file, get_name ()), "/"), de->d_name);
	  if (!lstat64 (file, &st))
	    de->d_type = IFTODT (st.st_mode);
	  else
@


1.15
log
@	* fhandler_procsys.cc (fhandler_procsys::read): Just call
	fhandler_base::raw_read from here.  Drop comment.
	(fhandler_procsys::write): Drop comment.
@
text
@d3 1
a3 1
   Copyright 2010, 2011, 2012, 2013 Red Hat, Inc.
d349 1
d361 3
d367 5
a371 1
	  de->d_type = 0;
@


1.14
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d397 1
a397 14
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  LARGE_INTEGER off = { QuadPart:0LL };

  /* FIXME: Implement nonblocking I/O, interruptibility and cancelability. */
  status = NtReadFile (get_handle (), NULL, NULL, NULL, &io, ptr, len,
		       &off, NULL);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      len = -1;
    }
  else
    len = io.Information;
a402 1
  /* FIXME: Implement nonblocking I/O, interruptibility and cancelability. */
@


1.13
log
@	* Merge in cygwin-64bit-branch.
@
text
@d394 1
a394 1
void __stdcall
@


1.12
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d3 1
a3 1
   Copyright 2010, 2011, 2013 Red Hat, Inc.
d47 1
a47 1
fhandler_procsys::exists (struct __stat64 *buf)
d77 1
a77 1
  debug_printf ("NtOpenDirectoryObject: %p", status);
d88 1
a88 1
  debug_printf ("NtOpenSymbolicLinkObject: %p", status);
d101 1
a101 1
  debug_printf ("NtOpenDirectoryObject: %p", status);
d115 1
a115 1
  debug_printf ("NtOpenFile: %p", status);
d138 1
a138 1
      debug_printf ("NtQueryAttributesFile: %p", status);
d157 1
a157 1
	  debug_printf ("NtOpenDirectoryObject: %p", status);
d176 1
a176 1
      debug_printf ("NtQueryVolumeInformationFile: %p", status);
d198 1
a198 1
	  debug_printf ("NtQueryInformationFile: %p", status);
d264 1
a264 1
fhandler_procsys::fstat (struct __stat64 *buf)
d274 1
a274 1
  buf->st_dev = buf->st_rdev = (int) dev ();
d449 1
a449 1
  syscall_printf ("%d = fhandler_procsys::open(%p, %d)", res, flags, mode);
@


1.11
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d3 1
a3 1
   Copyright 2010, 2011 Red Hat, Inc.
d263 1
a263 1
int
@


1.11.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d47 1
a47 1
fhandler_procsys::exists (struct stat *buf)
d264 1
a264 1
fhandler_procsys::fstat (struct stat *buf)
@


1.11.2.2
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d274 1
a274 1
  buf->st_dev = buf->st_rdev = dev ();
@


1.11.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d3 1
a3 1
   Copyright 2010, 2011, 2012 Red Hat, Inc.
d77 1
a77 1
  debug_printf ("NtOpenDirectoryObject: %y", status);
d88 1
a88 1
  debug_printf ("NtOpenSymbolicLinkObject: %y", status);
d101 1
a101 1
  debug_printf ("NtOpenDirectoryObject: %y", status);
d115 1
a115 1
  debug_printf ("NtOpenFile: %y", status);
d138 1
a138 1
      debug_printf ("NtQueryAttributesFile: %y", status);
d157 1
a157 1
	  debug_printf ("NtOpenDirectoryObject: %y", status);
d176 1
a176 1
      debug_printf ("NtQueryVolumeInformationFile: %y", status);
d198 1
a198 1
	  debug_printf ("NtQueryInformationFile: %y", status);
d449 1
a449 1
  syscall_printf ("%d = fhandler_procsys::open(%p, 0%o)", res, flags, mode);
@


1.11.2.4
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2010, 2011, 2012, 2013 Red Hat, Inc.
d263 1
a263 1
int __reg2
@


1.10
log
@whitespace elimination
@
text
@d367 1
a367 1
  syscall_printf ("%d = readdir (%p, %p)", res, dir, de);
d449 1
a449 1
  syscall_printf ("%d = fhandler_procsys::open (%p, %d)", res, flags, mode);
@


1.9
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d93 1
a93 1
      	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);
d106 1
a106 1
      	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);
d171 1
a171 1
      	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);
@


1.8
log
@	* fhandler.h (fhandler_socket::read): Declare.
	(fhandler_socket::write): Declare.
	* fhandler_procsys.cc (fhandler_procsys::read): Add FIXME comment.
	(fhandler_procsys::write): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): New method.
	(fhandler_socket::write): New method.
	* syscalls.cc: Rearrange order of read/write functions.
	(read): Call fhandler read method directly instead of just readv.
	(readv): Remove EINTR loop.  This is done in all affected fhandler's
	now.
	(write): Call fhandler write method directly instead of just writev.
	Fix debug output.
@
text
@d274 1
a274 1
  buf->st_dev = buf->st_rdev = dev ().devn;
@


1.7
log
@	* fhandler_procsys.cc (fhandler_procsys::exists): Rewrite.
	(fhandler_procsys::fill_filebuf): Fill buffer with valid string even if
	reading the symlink fails.
@
text
@d401 1
d416 1
@


1.6
log
@	* fhandler_procsys.cc (fhandler_procsys::open): Call worker exists
	method, rather than wrapper.
@
text
@d49 2
a50 1
  UNICODE_STRING path; \
d56 2
d64 21
a84 1
  /* First try to open as file/device to get more info. */
d86 27
d115 2
d127 1
a127 1
    file_type = virt_fsfile;
d129 3
a131 3
  else if (status >= STATUS_PIPE_NOT_AVAILABLE && status <= STATUS_PIPE_BUSY)
    file_type = virt_pipe;
  else if (status == STATUS_ACCESS_DENIED)
d134 3
a136 1
         most permission problems. */
d138 1
d142 21
d164 1
a164 1
  else if (NT_SUCCESS (status))
a165 1
      NTSTATUS dev_stat;
d168 3
a170 2
      /* If requested, check permissions. */
      if (buf)
d172 1
d174 19
a192 8
      dev_stat = NtQueryVolumeInformationFile (h, &io, &ffdi, sizeof ffdi,
					       FileFsDeviceInformation);
      /* And check for file attributes.  If we get them, we peeked into
	 a real FS through /proc/sys. */
      status = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
				       FileBasicInformation);
      NtClose (h);
      if (NT_SUCCESS (dev_stat))
d194 8
a201 3
	  if (ffdi.DeviceType == FILE_DEVICE_NAMED_PIPE)
	    file_type = NT_SUCCESS (status) ? virt_pipe : virt_blk;
	  else if (NT_SUCCESS (status))
a203 5
	  else if (ffdi.DeviceType == FILE_DEVICE_DISK
		   || ffdi.DeviceType == FILE_DEVICE_CD_ROM
		   || ffdi.DeviceType == FILE_DEVICE_DFS
		   || ffdi.DeviceType == FILE_DEVICE_VIRTUAL_DISK)
	    file_type = virt_blk;
a204 19
    }
  /* Then check if it's a symlink. */
  status = NtOpenSymbolicLinkObject (&h, READ_CONTROL | SYMBOLIC_LINK_QUERY,
				     &attr);
  if (NT_SUCCESS (status))
    {
      /* If requested, check permissions. */
      if (buf)
      	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);
      NtClose (h);
      return virt_symlink;
    }
  /* Eventually, test if it's an object directory. */
  status = NtOpenDirectoryObject (&h, READ_CONTROL | DIRECTORY_QUERY, &attr);
  if (NT_SUCCESS (status))
    {
      /* If requested, check permissions. */
      if (buf)
      	get_object_attribute (h, &buf->st_uid, &buf->st_gid, &buf->st_mode);
a205 1
      return virt_directory;
a206 2
  else if (status == STATUS_ACCESS_DENIED)
    return virt_directory;
d222 2
d233 1
d241 1
a241 1
    return false;
d247 2
a248 3
    return false;
  size_t len = sys_wcstombs (NULL, 0, target.Buffer,
			     target.Length / sizeof (WCHAR));
d255 6
@


1.5
log
@	* fhandler_procsys.cc (fhandler_procsys::opendir): Avoid SEGV if
	opening object directory fails.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Don't leak memory.
@
text
@d353 1
a353 1
      switch (exists ())
@


1.4
log
@	* fhandler_procsys.cc (fhandler_procsys::exists): Return virt_none
	if path is invalid.
@
text
@d3 1
a3 1
   Copyright 2010 Red Hat, Inc.
d248 1
a248 1
  DIR *dir = fhandler_virtual::opendir (fd);
a254 1
      free (dir);
d258 4
a261 1
  dir->__handle = h;
@


1.3
log
@	* fhandler_procsys.cc (fhandler_procsys::exists): Rearrange to handle
	dangling symlinks correctly.  Fix comments.
	(fhandler_procsys::fill_filebuf): Remove useless comment.
@
text
@d65 2
@


1.2
log
@	* fhandler_procsys.cc (fhandler_procsys::open): Simplify by just
	calling fhandler_base::open.
@
text
@d55 1
d65 3
a67 6
  if (status == STATUS_OBJECT_PATH_NOT_FOUND)
    return virt_none;
  /* If the name isn't found, or we get this dreaded sharing violation, let
     the caller try again as normal file. */
  if (status == STATUS_OBJECT_NAME_NOT_FOUND
      || status == STATUS_NO_MEDIA_IN_DEVICE
d70 4
d75 1
a75 1
  if (status >= STATUS_PIPE_NOT_AVAILABLE && status <= STATUS_PIPE_BUSY)
d139 1
a139 1
  /* Give up.  Just treat as character device. */
a156 1
  /* The NT device namespace is ASCII only. */
@


1.1
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d342 1
a342 7
  UNICODE_STRING path;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  HANDLE h;
  ULONG access;
  ULONG options = FILE_OPEN_FOR_BACKUP_INTENT;
d344 3
a346 15

  int res = fhandler_virtual::open (flags, mode);
  if (!res)
    goto out;

  if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL) || (flags & O_TRUNC))
    {
      set_errno (EINVAL);
      res = 0;
      goto out;
    }
  mk_unicode_path (&path);
  InitializeObjectAttributes (&attr, &path, OBJ_INHERIT | OBJ_CASE_INSENSITIVE,
			      NULL, NULL);
  switch (exists ())
d348 1
a348 3
    case virt_directory:
    case virt_rootdir:
      if ((flags & O_ACCMODE) != O_RDONLY)
d350 16
a365 3
	  set_errno (EISDIR);
	  res = 0;
	  goto out;
a366 27
      nohandle (true);
      res = 1;
      goto out;
    default:
      break;
    }
  if ((flags & O_ACCMODE) == O_RDONLY)
    access = GENERIC_READ;
  else if ((flags & O_ACCMODE) == O_WRONLY)
    access = GENERIC_WRITE | READ_CONTROL | FILE_READ_ATTRIBUTES;
  else
    access = GENERIC_READ | GENERIC_WRITE;
  if (flags & O_SYNC)
    options |= FILE_WRITE_THROUGH;
  if (flags & O_DIRECT)
    options |= FILE_NO_INTERMEDIATE_BUFFERING;
  if (!(flags & O_NONBLOCK))
    {
      access |= SYNCHRONIZE;
      options |= FILE_SYNCHRONOUS_IO_NONALERT;
    }
  status = NtOpenFile (&h, access, &attr, &io, FILE_SHARE_VALID_FLAGS, options);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      res = 0;
      goto out;
a367 4
  set_io_handle (h);
  set_open_status ();
  res = 1;
out:
@

