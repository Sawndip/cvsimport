head	1.671;
access;
symbols
	cygwin-1_7_35-release:1.671
	cygwin-1_7_34-release:1.669
	cygwin-1_7_33-release:1.659.2.5
	cygwin-1_7_32-release:1.659.2.4
	cygwin-1_7_31-release:1.659.2.3
	cygwin-1_7_30-release:1.659.2.2
	cygwin-1_7_29-release:1.659
	cygwin-1_7_29-release-branchpoint:1.659.0.2
	cygwin-pre-user-db:1.659
	cygwin-1_7_28-release:1.659
	cygwin-1_7_27-release:1.656
	cygwin-1_7_26-release:1.654
	cygwin-1_7_25-release:1.648
	cygwin-1_7_24-release:1.648
	cygwin-1_7_23-release:1.648
	cygwin-1_7_22-release:1.648
	cygwin-1_7_21-release:1.648
	cygwin-1_7_20-release:1.648
	cygwin-1_7_19-release:1.648
	cygwin-64bit-postmerge:1.645
	cygwin-64bit-premerge-branch:1.644.0.2
	cygwin-64bit-premerge:1.644
	cygwin-1_7_18-release:1.644
	post-ptmalloc3:1.638.2.11
	pre-ptmalloc3:1.638.2.11
	cygwin-1_7_17-release:1.639
	cygwin-64bit-branch:1.638.0.2
	cygwin-1_7_16-release:1.636
	cygwin-1_7_15-release:1.631
	cygwin-1_7_14_2-release:1.631
	cygwin-1_7_14-release:1.631
	cygwin-1_7_12-release:1.630
	cygwin-1_7_11-release:1.623
	cygwin-1_7_10-release:1.617
	signal-rewrite:1.591.0.2
	pre-notty:1.589
	cygwin-1_7_9-release:1.575
	cv-post-1_7_9:1.575.0.2
	cygwin-1_7_8-release:1.575
	cygwin-1_7_7-release:1.565
	cygwin-1_7_5-release:1.559
	cygwin-1_7_4-release:1.559
	cygwin-1_7_3-release:1.559
	cygwin-1_7_2-release:1.557
	fifo_doover3:1.549.0.2
	cygwin-1_7_1-release:1.547
	prefifo:1.525
	cv-branch-2:1.519.0.2
	pre-ripout-set_console_state_for_spawn:1.497
	EOL_registry_mounts:1.483
	preoverlapped:1.443
	drop_9x_support_start:1.434
	cr-0x5f1:1.403.0.4
	cv-branch:1.403.0.2
	pre-ptymaster-archetype:1.403
	cr-0x3b58:1.394.0.4
	cr-0x5ef:1.394.0.2
	after-mmap-privanon-noreserve:1.393
	after-mmap-revamp:1.393
	before-mmap-revamp:1.392
	cgf-more-exit-sync:1.390
	post_wait_sig_exit:1.389
	pre_wait_sig_exit:1.389
	reparent-point:1.349
	noreparent:1.349.0.2
	cr-0x5e6:1.338.0.2
	cr-0x9e:1.314.0.4
	cr-0x9d:1.314.0.2
	cgf-deleteme:1.313.0.2
	pre-sigrewrite:1.300
	corinna-01:1.299
	cr-0x9c:1.287.2.2.0.2
	cr-0x9b:1.287.0.2
	cr-0x99:1.282
	Z-emcb-cygwin_daemon:1.282.0.2
	w32api-2_2:1.244
	mingw-runtime-2_4:1.244
	pre-cgf-merge:1.291
	cgf-dev-branch:1.240.0.2
	predaemon:1.183
	cygwin_daemon_merge_HEAD:1.183
	pregp02r1:1.182.0.2
	cygnus_cvs_20020108_pre:1.176
	Z-cygwin_daemon_merge-new_HEAD:1.228
	Z-cygwin_daemon_merge_HEAD:1.228
	cygwin_daemon:1.149.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.671
date	2015.02.15.08.59.55;	author corinna;	state Exp;
branches;
next	1.670;

1.670
date	2015.02.10.20.41.16;	author corinna;	state Exp;
branches;
next	1.669;

1.669
date	2014.12.02.10.49.47;	author corinna;	state Exp;
branches;
next	1.668;

1.668
date	2014.10.08.21.03.40;	author corinna;	state Exp;
branches;
next	1.667;

1.667
date	2014.10.08.16.34.31;	author corinna;	state Exp;
branches;
next	1.666;

1.666
date	2014.08.26.20.47.46;	author corinna;	state Exp;
branches;
next	1.665;

1.665
date	2014.08.22.09.21.32;	author corinna;	state Exp;
branches;
next	1.664;

1.664
date	2014.08.11.12.03.18;	author corinna;	state Exp;
branches;
next	1.663;

1.663
date	2014.06.23.19.05.14;	author corinna;	state Exp;
branches;
next	1.662;

1.662
date	2014.05.19.08.29.47;	author corinna;	state Exp;
branches;
next	1.661;

1.661
date	2014.04.25.14.43.13;	author corinna;	state Exp;
branches;
next	1.660;

1.660
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.659;

1.659
date	2014.01.18.11.37.55;	author corinna;	state Exp;
branches
	1.659.2.1;
next	1.658;

1.658
date	2014.01.17.11.07.37;	author corinna;	state Exp;
branches;
next	1.657;

1.657
date	2013.12.11.12.12.11;	author corinna;	state Exp;
branches;
next	1.656;

1.656
date	2013.12.06.15.38.21;	author cgf;	state Exp;
branches;
next	1.655;

1.655
date	2013.12.05.19.43.34;	author cgf;	state Exp;
branches;
next	1.654;

1.654
date	2013.11.27.14.48.27;	author corinna;	state Exp;
branches;
next	1.653;

1.653
date	2013.11.27.14.30.36;	author corinna;	state Exp;
branches;
next	1.652;

1.652
date	2013.11.27.14.27.33;	author corinna;	state Exp;
branches;
next	1.651;

1.651
date	2013.11.25.11.38.08;	author corinna;	state Exp;
branches;
next	1.650;

1.650
date	2013.11.24.12.13.36;	author corinna;	state Exp;
branches;
next	1.649;

1.649
date	2013.11.23.13.51.53;	author ericb;	state Exp;
branches;
next	1.648;

1.648
date	2013.05.21.10.04.45;	author corinna;	state Exp;
branches;
next	1.647;

1.647
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.646;

1.646
date	2013.04.24.10.16.12;	author corinna;	state Exp;
branches;
next	1.645;

1.645
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.644;

1.644
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.643;

1.643
date	2013.01.19.14.54.18;	author corinna;	state Exp;
branches;
next	1.642;

1.642
date	2013.01.11.12.34.41;	author corinna;	state Exp;
branches;
next	1.641;

1.641
date	2013.01.10.15.08.22;	author corinna;	state Exp;
branches;
next	1.640;

1.640
date	2012.12.31.18.31.49;	author cgf;	state Exp;
branches;
next	1.639;

1.639
date	2012.08.16.23.34.45;	author cgf;	state Exp;
branches;
next	1.638;

1.638
date	2012.07.25.12.32.37;	author corinna;	state Exp;
branches
	1.638.2.1;
next	1.637;

1.637
date	2012.07.21.22.58.20;	author cgf;	state Exp;
branches;
next	1.636;

1.636
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.635;

1.635
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.634;

1.634
date	2012.06.04.01.26.05;	author cgf;	state Exp;
branches;
next	1.633;

1.633
date	2012.06.03.18.02.45;	author cgf;	state Exp;
branches;
next	1.632;

1.632
date	2012.06.03.16.46.53;	author corinna;	state Exp;
branches;
next	1.631;

1.631
date	2012.04.11.08.49.52;	author corinna;	state Exp;
branches;
next	1.630;

1.630
date	2012.04.03.07.28.48;	author corinna;	state Exp;
branches;
next	1.629;

1.629
date	2012.04.02.19.25.58;	author corinna;	state Exp;
branches;
next	1.628;

1.628
date	2012.04.02.16.19.29;	author corinna;	state Exp;
branches;
next	1.627;

1.627
date	2012.04.02.15.56.43;	author corinna;	state Exp;
branches;
next	1.626;

1.626
date	2012.04.02.11.45.56;	author corinna;	state Exp;
branches;
next	1.625;

1.625
date	2012.04.02.11.18.45;	author corinna;	state Exp;
branches;
next	1.624;

1.624
date	2012.03.20.20.39.32;	author corinna;	state Exp;
branches;
next	1.623;

1.623
date	2012.02.22.01.58.24;	author yselkowitz;	state Exp;
branches;
next	1.622;

1.622
date	2012.02.14.19.08.19;	author cgf;	state Exp;
branches;
next	1.621;

1.621
date	2012.02.10.16.43.36;	author cgf;	state Exp;
branches;
next	1.620;

1.620
date	2012.02.10.16.33.53;	author cgf;	state Exp;
branches;
next	1.619;

1.619
date	2012.02.07.17.15.06;	author corinna;	state Exp;
branches;
next	1.618;

1.618
date	2012.02.07.16.54.14;	author cgf;	state Exp;
branches;
next	1.617;

1.617
date	2012.02.02.16.58.13;	author cgf;	state Exp;
branches;
next	1.616;

1.616
date	2012.02.01.17.20.02;	author cgf;	state Exp;
branches;
next	1.615;

1.615
date	2012.01.31.23.52.51;	author cgf;	state Exp;
branches;
next	1.614;

1.614
date	2012.01.23.12.59.44;	author corinna;	state Exp;
branches;
next	1.613;

1.613
date	2012.01.22.07.27.57;	author cgf;	state Exp;
branches;
next	1.612;

1.612
date	2012.01.09.17.03.38;	author corinna;	state Exp;
branches;
next	1.611;

1.611
date	2011.12.25.04.05.31;	author cgf;	state Exp;
branches;
next	1.610;

1.610
date	2011.12.22.11.02.36;	author corinna;	state Exp;
branches;
next	1.609;

1.609
date	2011.12.19.17.01.37;	author corinna;	state Exp;
branches;
next	1.608;

1.608
date	2011.12.18.04.07.47;	author cgf;	state Exp;
branches;
next	1.607;

1.607
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.606;

1.606
date	2011.12.17.07.01.20;	author cgf;	state Exp;
branches;
next	1.605;

1.605
date	2011.12.17.00.03.31;	author cgf;	state Exp;
branches;
next	1.604;

1.604
date	2011.12.03.23.55.21;	author cgf;	state Exp;
branches;
next	1.603;

1.603
date	2011.12.03.21.43.27;	author cgf;	state Exp;
branches;
next	1.602;

1.602
date	2011.11.29.15.34.48;	author cgf;	state Exp;
branches;
next	1.601;

1.601
date	2011.11.14.01.29.49;	author cgf;	state Exp;
branches;
next	1.600;

1.600
date	2011.11.07.20.05.48;	author cgf;	state Exp;
branches;
next	1.599;

1.599
date	2011.11.07.10.03.30;	author corinna;	state Exp;
branches;
next	1.598;

1.598
date	2011.10.24.14.02.32;	author corinna;	state Exp;
branches;
next	1.597;

1.597
date	2011.10.21.17.43.00;	author corinna;	state Exp;
branches;
next	1.596;

1.596
date	2011.10.21.08.29.19;	author corinna;	state Exp;
branches;
next	1.595;

1.595
date	2011.10.20.10.59.01;	author corinna;	state Exp;
branches;
next	1.594;

1.594
date	2011.10.15.22.37.30;	author cgf;	state Exp;
branches;
next	1.593;

1.593
date	2011.10.11.23.20.38;	author cgf;	state Exp;
branches;
next	1.592;

1.592
date	2011.10.10.22.01.05;	author cgf;	state Exp;
branches;
next	1.591;

1.591
date	2011.08.01.17.01.38;	author corinna;	state Exp;
branches;
next	1.590;

1.590
date	2011.07.26.13.30.41;	author corinna;	state Exp;
branches;
next	1.589;

1.589
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.588;

1.588
date	2011.05.28.18.17.09;	author cgf;	state Exp;
branches;
next	1.587;

1.587
date	2011.05.10.15.39.02;	author corinna;	state Exp;
branches;
next	1.586;

1.586
date	2011.05.06.10.56.37;	author corinna;	state Exp;
branches;
next	1.585;

1.585
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.584;

1.584
date	2011.05.05.19.43.04;	author corinna;	state Exp;
branches;
next	1.583;

1.583
date	2011.05.05.18.46.38;	author corinna;	state Exp;
branches;
next	1.582;

1.582
date	2011.05.04.13.06.10;	author corinna;	state Exp;
branches;
next	1.581;

1.581
date	2011.04.30.16.34.48;	author corinna;	state Exp;
branches;
next	1.580;

1.580
date	2011.04.29.07.34.04;	author corinna;	state Exp;
branches;
next	1.579;

1.579
date	2011.04.19.10.02.06;	author corinna;	state Exp;
branches;
next	1.578;

1.578
date	2011.04.04.12.23.36;	author corinna;	state Exp;
branches;
next	1.577;

1.577
date	2011.04.02.11.43.43;	author corinna;	state Exp;
branches;
next	1.576;

1.576
date	2011.03.29.10.42.11;	author corinna;	state Exp;
branches;
next	1.575;

1.575
date	2011.02.22.09.17.57;	author corinna;	state Exp;
branches
	1.575.2.1;
next	1.574;

1.574
date	2011.02.15.15.56.01;	author corinna;	state Exp;
branches;
next	1.573;

1.573
date	2011.01.31.13.58.59;	author corinna;	state Exp;
branches;
next	1.572;

1.572
date	2011.01.21.13.13.00;	author corinna;	state Exp;
branches;
next	1.571;

1.571
date	2010.12.12.15.32.45;	author corinna;	state Exp;
branches;
next	1.570;

1.570
date	2010.09.28.07.54.52;	author corinna;	state Exp;
branches;
next	1.569;

1.569
date	2010.09.21.16.32.22;	author corinna;	state Exp;
branches;
next	1.568;

1.568
date	2010.09.12.11.41.56;	author corinna;	state Exp;
branches;
next	1.567;

1.567
date	2010.09.10.19.55.26;	author corinna;	state Exp;
branches;
next	1.566;

1.566
date	2010.09.10.18.51.44;	author corinna;	state Exp;
branches;
next	1.565;

1.565
date	2010.08.25.08.51.41;	author corinna;	state Exp;
branches;
next	1.564;

1.564
date	2010.08.20.08.52.25;	author corinna;	state Exp;
branches;
next	1.563;

1.563
date	2010.08.18.15.21.35;	author corinna;	state Exp;
branches;
next	1.562;

1.562
date	2010.07.07.07.53.22;	author corinna;	state Exp;
branches;
next	1.561;

1.561
date	2010.06.15.12.05.15;	author corinna;	state Exp;
branches;
next	1.560;

1.560
date	2010.04.19.08.09.51;	author corinna;	state Exp;
branches;
next	1.559;

1.559
date	2010.04.02.22.36.44;	author cgf;	state Exp;
branches;
next	1.558;

1.558
date	2010.03.30.14.36.42;	author corinna;	state Exp;
branches;
next	1.557;

1.557
date	2010.03.15.21.29.15;	author cgf;	state Exp;
branches;
next	1.556;

1.556
date	2010.03.04.16.20.37;	author corinna;	state Exp;
branches;
next	1.555;

1.555
date	2010.01.24.12.29.49;	author corinna;	state Exp;
branches;
next	1.554;

1.554
date	2010.01.17.09.41.01;	author corinna;	state Exp;
branches;
next	1.553;

1.553
date	2010.01.14.18.56.24;	author corinna;	state Exp;
branches;
next	1.552;

1.552
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.551;

1.551
date	2010.01.13.09.45.18;	author corinna;	state Exp;
branches;
next	1.550;

1.550
date	2010.01.12.10.14.59;	author corinna;	state Exp;
branches;
next	1.549;

1.549
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.548;

1.548
date	2009.12.17.18.33.05;	author corinna;	state Exp;
branches;
next	1.547;

1.547
date	2009.11.21.12.44.13;	author corinna;	state Exp;
branches;
next	1.546;

1.546
date	2009.11.09.19.46.36;	author corinna;	state Exp;
branches;
next	1.545;

1.545
date	2009.11.06.20.51.03;	author corinna;	state Exp;
branches;
next	1.544;

1.544
date	2009.11.05.14.44.12;	author corinna;	state Exp;
branches;
next	1.543;

1.543
date	2009.10.19.19.47.15;	author corinna;	state Exp;
branches;
next	1.542;

1.542
date	2009.10.13.10.23.31;	author corinna;	state Exp;
branches;
next	1.541;

1.541
date	2009.10.07.08.20.49;	author corinna;	state Exp;
branches;
next	1.540;

1.540
date	2009.10.04.11.32.07;	author corinna;	state Exp;
branches;
next	1.539;

1.539
date	2009.10.02.14.58.10;	author corinna;	state Exp;
branches;
next	1.538;

1.538
date	2009.09.30.02.11.05;	author ericb;	state Exp;
branches;
next	1.537;

1.537
date	2009.09.28.10.43.49;	author corinna;	state Exp;
branches;
next	1.536;

1.536
date	2009.09.26.15.51.53;	author ericb;	state Exp;
branches;
next	1.535;

1.535
date	2009.09.25.23.55.00;	author ericb;	state Exp;
branches;
next	1.534;

1.534
date	2009.09.25.13.44.45;	author ericb;	state Exp;
branches;
next	1.533;

1.533
date	2009.09.22.12.13.53;	author ericb;	state Exp;
branches;
next	1.532;

1.532
date	2009.09.22.04.09.03;	author ericb;	state Exp;
branches;
next	1.531;

1.531
date	2009.09.21.19.29.15;	author corinna;	state Exp;
branches;
next	1.530;

1.530
date	2009.09.18.21.27.02;	author cgf;	state Exp;
branches;
next	1.529;

1.529
date	2009.08.18.01.51.35;	author cgf;	state Exp;
branches;
next	1.528;

1.528
date	2009.08.18.01.40.46;	author cgf;	state Exp;
branches;
next	1.527;

1.527
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.526;

1.526
date	2009.07.24.18.24.57;	author corinna;	state Exp;
branches;
next	1.525;

1.525
date	2009.07.24.14.13.44;	author corinna;	state Exp;
branches;
next	1.524;

1.524
date	2009.07.20.15.44.54;	author corinna;	state Exp;
branches;
next	1.523;

1.523
date	2009.07.17.16.45.22;	author corinna;	state Exp;
branches;
next	1.522;

1.522
date	2009.07.16.16.55.25;	author corinna;	state Exp;
branches;
next	1.521;

1.521
date	2009.07.14.17.37.42;	author corinna;	state Exp;
branches;
next	1.520;

1.520
date	2009.06.30.21.18.44;	author cgf;	state Exp;
branches;
next	1.519;

1.519
date	2009.05.14.19.49.37;	author corinna;	state Exp;
branches;
next	1.518;

1.518
date	2009.05.13.15.00.06;	author corinna;	state Exp;
branches;
next	1.517;

1.517
date	2009.04.16.12.16.35;	author corinna;	state Exp;
branches;
next	1.516;

1.516
date	2009.04.09.17.55.01;	author corinna;	state Exp;
branches;
next	1.515;

1.515
date	2009.04.09.17.00.35;	author corinna;	state Exp;
branches;
next	1.514;

1.514
date	2009.03.27.11.29.56;	author corinna;	state Exp;
branches;
next	1.513;

1.513
date	2009.02.11.16.06.38;	author corinna;	state Exp;
branches;
next	1.512;

1.512
date	2009.01.12.15.51.23;	author corinna;	state Exp;
branches;
next	1.511;

1.511
date	2009.01.07.18.18.23;	author corinna;	state Exp;
branches;
next	1.510;

1.510
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.509;

1.509
date	2008.12.15.20.53.18;	author corinna;	state Exp;
branches;
next	1.508;

1.508
date	2008.11.26.17.21.04;	author cgf;	state Exp;
branches;
next	1.507;

1.507
date	2008.11.26.10.18.10;	author corinna;	state Exp;
branches;
next	1.506;

1.506
date	2008.10.20.19.30.06;	author corinna;	state Exp;
branches;
next	1.505;

1.505
date	2008.10.09.09.43.02;	author corinna;	state Exp;
branches;
next	1.504;

1.504
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.503;

1.503
date	2008.08.11.15.05.25;	author corinna;	state Exp;
branches;
next	1.502;

1.502
date	2008.07.30.04.58.23;	author cgf;	state Exp;
branches;
next	1.501;

1.501
date	2008.07.29.10.40.36;	author corinna;	state Exp;
branches;
next	1.500;

1.500
date	2008.07.27.22.31.48;	author cgf;	state Exp;
branches;
next	1.499;

1.499
date	2008.07.25.15.23.56;	author corinna;	state Exp;
branches;
next	1.498;

1.498
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.497;

1.497
date	2008.05.22.11.18.46;	author corinna;	state Exp;
branches;
next	1.496;

1.496
date	2008.05.22.01.25.37;	author cgf;	state Exp;
branches;
next	1.495;

1.495
date	2008.05.21.08.05.53;	author corinna;	state Exp;
branches;
next	1.494;

1.494
date	2008.05.20.10.24.25;	author corinna;	state Exp;
branches;
next	1.493;

1.493
date	2008.05.19.20.22.29;	author corinna;	state Exp;
branches;
next	1.492;

1.492
date	2008.05.15.17.23.29;	author corinna;	state Exp;
branches;
next	1.491;

1.491
date	2008.05.15.16.34.01;	author corinna;	state Exp;
branches;
next	1.490;

1.490
date	2008.04.29.09.24.54;	author corinna;	state Exp;
branches;
next	1.489;

1.489
date	2008.04.24.09.59.54;	author corinna;	state Exp;
branches;
next	1.488;

1.488
date	2008.04.23.11.13.52;	author corinna;	state Exp;
branches;
next	1.487;

1.487
date	2008.04.13.16.47.21;	author corinna;	state Exp;
branches;
next	1.486;

1.486
date	2008.04.10.09.27.58;	author corinna;	state Exp;
branches;
next	1.485;

1.485
date	2008.04.07.18.45.59;	author cgf;	state Exp;
branches;
next	1.484;

1.484
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.483;

1.483
date	2008.04.03.15.28.03;	author corinna;	state Exp;
branches;
next	1.482;

1.482
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.481;

1.481
date	2008.04.01.10.22.33;	author corinna;	state Exp;
branches;
next	1.480;

1.480
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.479;

1.479
date	2008.03.27.13.02.07;	author corinna;	state Exp;
branches;
next	1.478;

1.478
date	2008.03.27.01.50.40;	author cgf;	state Exp;
branches;
next	1.477;

1.477
date	2008.03.12.18.54.24;	author corinna;	state Exp;
branches;
next	1.476;

1.476
date	2008.03.12.18.46.10;	author corinna;	state Exp;
branches;
next	1.475;

1.475
date	2008.03.11.11.12.09;	author corinna;	state Exp;
branches;
next	1.474;

1.474
date	2008.03.08.01.33.22;	author briand;	state Exp;
branches;
next	1.473;

1.473
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.472;

1.472
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.471;

1.471
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.470;

1.470
date	2008.02.13.17.21.05;	author cgf;	state Exp;
branches;
next	1.469;

1.469
date	2008.02.01.12.37.51;	author corinna;	state Exp;
branches;
next	1.468;

1.468
date	2007.11.28.16.45.34;	author corinna;	state Exp;
branches;
next	1.467;

1.467
date	2007.11.08.14.36.49;	author cgf;	state Exp;
branches;
next	1.466;

1.466
date	2007.08.24.14.55.56;	author corinna;	state Exp;
branches;
next	1.465;

1.465
date	2007.08.21.12.39.53;	author corinna;	state Exp;
branches;
next	1.464;

1.464
date	2007.08.16.15.07.41;	author corinna;	state Exp;
branches;
next	1.463;

1.463
date	2007.08.16.14.46.23;	author corinna;	state Exp;
branches;
next	1.462;

1.462
date	2007.08.15.16.27.09;	author corinna;	state Exp;
branches;
next	1.461;

1.461
date	2007.08.13.17.16.05;	author corinna;	state Exp;
branches;
next	1.460;

1.460
date	2007.08.12.15.20.16;	author corinna;	state Exp;
branches;
next	1.459;

1.459
date	2007.08.12.12.48.02;	author corinna;	state Exp;
branches;
next	1.458;

1.458
date	2007.08.10.11.16.27;	author corinna;	state Exp;
branches;
next	1.457;

1.457
date	2007.08.09.10.32.25;	author corinna;	state Exp;
branches;
next	1.456;

1.456
date	2007.08.02.15.13.56;	author corinna;	state Exp;
branches;
next	1.455;

1.455
date	2007.08.02.11.11.34;	author corinna;	state Exp;
branches;
next	1.454;

1.454
date	2007.08.02.10.33.28;	author corinna;	state Exp;
branches;
next	1.453;

1.453
date	2007.08.01.21.02.24;	author corinna;	state Exp;
branches;
next	1.452;

1.452
date	2007.08.01.14.46.09;	author corinna;	state Exp;
branches;
next	1.451;

1.451
date	2007.08.01.07.52.35;	author corinna;	state Exp;
branches;
next	1.450;

1.450
date	2007.07.31.15.20.00;	author corinna;	state Exp;
branches;
next	1.449;

1.449
date	2007.07.30.10.05.27;	author corinna;	state Exp;
branches;
next	1.448;

1.448
date	2007.07.29.15.57.41;	author corinna;	state Exp;
branches;
next	1.447;

1.447
date	2007.07.29.12.27.22;	author corinna;	state Exp;
branches;
next	1.446;

1.446
date	2007.07.26.17.30.54;	author corinna;	state Exp;
branches;
next	1.445;

1.445
date	2007.07.19.11.41.17;	author corinna;	state Exp;
branches;
next	1.444;

1.444
date	2007.07.16.20.01.15;	author corinna;	state Exp;
branches;
next	1.443;

1.443
date	2007.03.02.20.04.26;	author corinna;	state Exp;
branches;
next	1.442;

1.442
date	2007.02.27.18.38.22;	author corinna;	state Exp;
branches;
next	1.441;

1.441
date	2007.02.27.12.58.56;	author corinna;	state Exp;
branches;
next	1.440;

1.440
date	2007.02.26.12.22.41;	author corinna;	state Exp;
branches;
next	1.439;

1.439
date	2007.02.23.15.15.50;	author corinna;	state Exp;
branches;
next	1.438;

1.438
date	2007.02.23.12.01.52;	author corinna;	state Exp;
branches;
next	1.437;

1.437
date	2007.02.22.16.04.19;	author corinna;	state Exp;
branches;
next	1.436;

1.436
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.435;

1.435
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.434;

1.434
date	2007.02.20.15.48.04;	author corinna;	state Exp;
branches;
next	1.433;

1.433
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.432;

1.432
date	2007.02.14.10.06.45;	author corinna;	state Exp;
branches;
next	1.431;

1.431
date	2007.02.08.14.40.13;	author corinna;	state Exp;
branches;
next	1.430;

1.430
date	2007.02.08.13.36.53;	author corinna;	state Exp;
branches;
next	1.429;

1.429
date	2007.02.02.15.16.54;	author corinna;	state Exp;
branches;
next	1.428;

1.428
date	2007.01.31.10.55.59;	author corinna;	state Exp;
branches;
next	1.427;

1.427
date	2007.01.26.12.25.23;	author corinna;	state Exp;
branches;
next	1.426;

1.426
date	2007.01.17.19.26.58;	author corinna;	state Exp;
branches;
next	1.425;

1.425
date	2007.01.13.20.56.01;	author corinna;	state Exp;
branches;
next	1.424;

1.424
date	2007.01.12.14.16.42;	author corinna;	state Exp;
branches;
next	1.423;

1.423
date	2007.01.10.09.06.20;	author corinna;	state Exp;
branches;
next	1.422;

1.422
date	2007.01.09.15.46.41;	author corinna;	state Exp;
branches;
next	1.421;

1.421
date	2006.12.12.19.18.56;	author corinna;	state Exp;
branches;
next	1.420;

1.420
date	2006.12.12.18.47.25;	author corinna;	state Exp;
branches;
next	1.419;

1.419
date	2006.12.12.16.27.32;	author corinna;	state Exp;
branches;
next	1.418;

1.418
date	2006.12.12.15.58.08;	author cgf;	state Exp;
branches;
next	1.417;

1.417
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.416;

1.416
date	2006.12.11.09.07.22;	author corinna;	state Exp;
branches;
next	1.415;

1.415
date	2006.12.10.16.43.30;	author corinna;	state Exp;
branches;
next	1.414;

1.414
date	2006.12.09.09.29.47;	author corinna;	state Exp;
branches;
next	1.413;

1.413
date	2006.12.07.17.53.05;	author corinna;	state Exp;
branches;
next	1.412;

1.412
date	2006.12.07.17.40.24;	author corinna;	state Exp;
branches;
next	1.411;

1.411
date	2006.12.07.11.53.46;	author corinna;	state Exp;
branches;
next	1.410;

1.410
date	2006.11.28.23.15.01;	author corinna;	state Exp;
branches;
next	1.409;

1.409
date	2006.11.27.12.59.58;	author corinna;	state Exp;
branches;
next	1.408;

1.408
date	2006.11.07.17.59.54;	author corinna;	state Exp;
branches;
next	1.407;

1.407
date	2006.10.31.11.40.47;	author corinna;	state Exp;
branches;
next	1.406;

1.406
date	2006.08.31.15.57.56;	author corinna;	state Exp;
branches;
next	1.405;

1.405
date	2006.08.07.19.29.14;	author corinna;	state Exp;
branches;
next	1.404;

1.404
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.403;

1.403
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches
	1.403.2.1
	1.403.4.1;
next	1.402;

1.402
date	2006.03.18.19.17.21;	author cgf;	state Exp;
branches;
next	1.401;

1.401
date	2006.03.09.15.31.08;	author corinna;	state Exp;
branches;
next	1.400;

1.400
date	2006.03.08.23.55.14;	author cgf;	state Exp;
branches;
next	1.399;

1.399
date	2006.03.08.16.10.55;	author corinna;	state Exp;
branches;
next	1.398;

1.398
date	2006.03.08.16.07.28;	author corinna;	state Exp;
branches;
next	1.397;

1.397
date	2006.03.02.18.08.09;	author corinna;	state Exp;
branches;
next	1.396;

1.396
date	2006.02.05.18.18.02;	author corinna;	state Exp;
branches;
next	1.395;

1.395
date	2006.02.02.22.46.36;	author corinna;	state Exp;
branches;
next	1.394;

1.394
date	2005.12.22.16.45.15;	author corinna;	state Exp;
branches;
next	1.393;

1.393
date	2005.11.28.22.32.29;	author corinna;	state Exp;
branches;
next	1.392;

1.392
date	2005.11.14.05.36.16;	author cgf;	state Exp;
branches;
next	1.391;

1.391
date	2005.11.14.04.28.45;	author cgf;	state Exp;
branches;
next	1.390;

1.390
date	2005.10.02.00.13.41;	author cgf;	state Exp;
branches;
next	1.389;

1.389
date	2005.08.24.15.50.11;	author corinna;	state Exp;
branches;
next	1.388;

1.388
date	2005.08.12.02.39.12;	author cgf;	state Exp;
branches;
next	1.387;

1.387
date	2005.07.29.17.04.46;	author cgf;	state Exp;
branches;
next	1.386;

1.386
date	2005.07.06.20.05.03;	author cgf;	state Exp;
branches;
next	1.385;

1.385
date	2005.07.05.02.05.07;	author cgf;	state Exp;
branches;
next	1.384;

1.384
date	2005.07.03.02.40.29;	author cgf;	state Exp;
branches;
next	1.383;

1.383
date	2005.06.24.09.12.15;	author corinna;	state Exp;
branches;
next	1.382;

1.382
date	2005.06.16.15.46.40;	author corinna;	state Exp;
branches;
next	1.381;

1.381
date	2005.06.09.22.33.56;	author cgf;	state Exp;
branches;
next	1.380;

1.380
date	2005.06.07.19.31.41;	author corinna;	state Exp;
branches;
next	1.379;

1.379
date	2005.06.02.02.36.50;	author cgf;	state Exp;
branches;
next	1.378;

1.378
date	2005.06.01.03.46.56;	author cgf;	state Exp;
branches;
next	1.377;

1.377
date	2005.05.13.15.46.07;	author cgf;	state Exp;
branches;
next	1.376;

1.376
date	2005.05.02.03.50.08;	author cgf;	state Exp;
branches;
next	1.375;

1.375
date	2005.04.28.03.41.09;	author cgf;	state Exp;
branches;
next	1.374;

1.374
date	2005.04.15.08.19.07;	author corinna;	state Exp;
branches;
next	1.373;

1.373
date	2005.04.14.17.34.03;	author cgf;	state Exp;
branches;
next	1.372;

1.372
date	2005.04.11.21.54.54;	author corinna;	state Exp;
branches;
next	1.371;

1.371
date	2005.04.11.20.44.44;	author corinna;	state Exp;
branches;
next	1.370;

1.370
date	2005.04.03.13.06.43;	author corinna;	state Exp;
branches;
next	1.369;

1.369
date	2005.03.29.17.42.50;	author corinna;	state Exp;
branches;
next	1.368;

1.368
date	2005.03.10.17.02.52;	author corinna;	state Exp;
branches;
next	1.367;

1.367
date	2005.03.03.22.08.11;	author corinna;	state Exp;
branches;
next	1.366;

1.366
date	2005.03.01.11.51.29;	author corinna;	state Exp;
branches;
next	1.365;

1.365
date	2005.02.23.13.12.42;	author corinna;	state Exp;
branches;
next	1.364;

1.364
date	2005.02.22.15.30.07;	author corinna;	state Exp;
branches;
next	1.363;

1.363
date	2005.02.20.13.28.23;	author corinna;	state Exp;
branches;
next	1.362;

1.362
date	2005.02.19.21.53.36;	author corinna;	state Exp;
branches;
next	1.361;

1.361
date	2005.02.13.18.17.29;	author cgf;	state Exp;
branches;
next	1.360;

1.360
date	2005.02.02.22.42.06;	author corinna;	state Exp;
branches;
next	1.359;

1.359
date	2005.01.26.13.07.48;	author corinna;	state Exp;
branches;
next	1.358;

1.358
date	2005.01.25.22.45.09;	author corinna;	state Exp;
branches;
next	1.357;

1.357
date	2005.01.12.18.05.07;	author cgf;	state Exp;
branches;
next	1.356;

1.356
date	2005.01.08.18.33.07;	author phumblet;	state Exp;
branches;
next	1.355;

1.355
date	2005.01.06.22.10.08;	author corinna;	state Exp;
branches;
next	1.354;

1.354
date	2005.01.03.10.59.09;	author corinna;	state Exp;
branches;
next	1.353;

1.353
date	2004.12.15.17.28.55;	author corinna;	state Exp;
branches;
next	1.352;

1.352
date	2004.12.01.15.00.40;	author cgf;	state Exp;
branches;
next	1.351;

1.351
date	2004.11.26.04.15.08;	author cgf;	state Exp;
branches;
next	1.350;

1.350
date	2004.11.20.19.09.19;	author phumblet;	state Exp;
branches;
next	1.349;

1.349
date	2004.10.28.01.46.01;	author phumblet;	state Exp;
branches
	1.349.2.1;
next	1.348;

1.348
date	2004.09.17.09.10.53;	author corinna;	state Exp;
branches;
next	1.347;

1.347
date	2004.09.12.03.47.57;	author cgf;	state Exp;
branches;
next	1.346;

1.346
date	2004.09.10.08.30.50;	author corinna;	state Exp;
branches;
next	1.345;

1.345
date	2004.09.03.01.53.12;	author cgf;	state Exp;
branches;
next	1.344;

1.344
date	2004.08.28.01.37.27;	author phumblet;	state Exp;
branches;
next	1.343;

1.343
date	2004.08.24.22.49.16;	author corinna;	state Exp;
branches;
next	1.342;

1.342
date	2004.08.03.14.37.26;	author corinna;	state Exp;
branches;
next	1.341;

1.341
date	2004.07.20.16.01.39;	author cgf;	state Exp;
branches;
next	1.340;

1.340
date	2004.07.20.15.52.33;	author cgf;	state Exp;
branches;
next	1.339;

1.339
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.338;

1.338
date	2004.05.17.16.06.00;	author corinna;	state Exp;
branches;
next	1.337;

1.337
date	2004.05.08.02.55.38;	author cgf;	state Exp;
branches;
next	1.336;

1.336
date	2004.05.03.11.53.07;	author corinna;	state Exp;
branches;
next	1.335;

1.335
date	2004.04.21.08.16.13;	author corinna;	state Exp;
branches;
next	1.334;

1.334
date	2004.04.20.15.51.24;	author corinna;	state Exp;
branches;
next	1.333;

1.333
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.332;

1.332
date	2004.04.14.21.11.45;	author corinna;	state Exp;
branches;
next	1.331;

1.331
date	2004.04.14.16.51.28;	author corinna;	state Exp;
branches;
next	1.330;

1.330
date	2004.04.14.16.36.26;	author corinna;	state Exp;
branches;
next	1.329;

1.329
date	2004.04.14.10.20.25;	author corinna;	state Exp;
branches;
next	1.328;

1.328
date	2004.04.14.09.12.03;	author corinna;	state Exp;
branches;
next	1.327;

1.327
date	2004.04.13.20.36.58;	author corinna;	state Exp;
branches;
next	1.326;

1.326
date	2004.04.10.20.40.41;	author corinna;	state Exp;
branches;
next	1.325;

1.325
date	2004.04.10.19.24.55;	author corinna;	state Exp;
branches;
next	1.324;

1.324
date	2004.04.10.13.45.10;	author corinna;	state Exp;
branches;
next	1.323;

1.323
date	2004.04.08.07.57.28;	author corinna;	state Exp;
branches;
next	1.322;

1.322
date	2004.02.17.20.03.01;	author cgf;	state Exp;
branches;
next	1.321;

1.321
date	2004.02.16.11.45.04;	author corinna;	state Exp;
branches;
next	1.320;

1.320
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.319;

1.319
date	2004.02.09.04.04.24;	author cgf;	state Exp;
branches;
next	1.318;

1.318
date	2004.01.26.18.52.02;	author cgf;	state Exp;
branches;
next	1.317;

1.317
date	2004.01.24.03.40.33;	author cgf;	state Exp;
branches;
next	1.316;

1.316
date	2004.01.23.23.05.33;	author cgf;	state Exp;
branches;
next	1.315;

1.315
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.314;

1.314
date	2004.01.14.15.45.37;	author cgf;	state Exp;
branches
	1.314.4.1;
next	1.313;

1.313
date	2003.12.30.01.57.16;	author cgf;	state Exp;
branches
	1.313.2.1;
next	1.312;

1.312
date	2003.12.27.02.41.07;	author cgf;	state Exp;
branches;
next	1.311;

1.311
date	2003.12.27.01.59.29;	author cgf;	state Exp;
branches;
next	1.310;

1.310
date	2003.12.27.00.25.02;	author cgf;	state Exp;
branches;
next	1.309;

1.309
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.308;

1.308
date	2003.12.16.23.28.03;	author cgf;	state Exp;
branches;
next	1.307;

1.307
date	2003.12.15.04.16.42;	author cgf;	state Exp;
branches;
next	1.306;

1.306
date	2003.12.11.06.12.41;	author cgf;	state Exp;
branches;
next	1.305;

1.305
date	2003.12.10.03.19.19;	author cgf;	state Exp;
branches;
next	1.304;

1.304
date	2003.12.08.06.27.05;	author cgf;	state Exp;
branches;
next	1.303;

1.303
date	2003.12.07.22.37.12;	author cgf;	state Exp;
branches;
next	1.302;

1.302
date	2003.12.07.12.56.59;	author corinna;	state Exp;
branches;
next	1.301;

1.301
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.300;

1.300
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.299;

1.299
date	2003.11.08.16.38.34;	author corinna;	state Exp;
branches;
next	1.298;

1.298
date	2003.11.06.14.33.15;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2003.10.16.23.20.41;	author phumblet;	state Exp;
branches;
next	1.296;

1.296
date	2003.10.08.09.17.08;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2003.09.27.05.44.58;	author cgf;	state Exp;
branches;
next	1.294;

1.294
date	2003.09.27.05.35.02;	author cgf;	state Exp;
branches;
next	1.293;

1.293
date	2003.09.25.02.29.05;	author phumblet;	state Exp;
branches;
next	1.292;

1.292
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.291;

1.291
date	2003.09.20.00.31.13;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2003.09.17.21.47.12;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2003.09.16.00.45.50;	author phumblet;	state Exp;
branches;
next	1.288;

1.288
date	2003.09.13.17.14.15;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2003.09.10.19.13.04;	author corinna;	state Exp;
branches
	1.287.2.1;
next	1.286;

1.286
date	2003.09.10.16.22.49;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2003.09.10.15.51.58;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2003.09.10.02.12.26;	author phumblet;	state Exp;
branches;
next	1.283;

1.283
date	2003.09.08.20.08.52;	author corinna;	state Exp;
branches;
next	1.282;

1.282
date	2003.08.23.18.03.16;	author cgf;	state Exp;
branches;
next	1.281;

1.281
date	2003.08.19.04.10.42;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2003.08.13.11.28.42;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2003.08.05.04.49.44;	author cgf;	state Exp;
branches;
next	1.278;

1.278
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2003.07.14.17.04.21;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2003.07.06.20.13.48;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2003.07.06.20.08.42;	author cgf;	state Exp;
branches;
next	1.274;

1.274
date	2003.07.02.03.16.00;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2003.05.26.16.52.58;	author corinna;	state Exp;
branches;
next	1.270;

1.270
date	2003.05.25.09.18.43;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2003.05.21.08.01.57;	author corinna;	state Exp;
branches;
next	1.268;

1.268
date	2003.05.12.11.06.26;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2003.05.11.00.10.10;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2003.05.03.16.03.19;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2003.04.18.00.25.41;	author cgf;	state Exp;
branches;
next	1.264;

1.264
date	2003.04.16.03.03.44;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2003.03.29.13.15.55;	author corinna;	state Exp;
branches;
next	1.261;

1.261
date	2003.03.29.12.44.01;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2003.03.22.17.48.40;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2003.03.20.01.34.53;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2003.03.19.21.34.38;	author corinna;	state Exp;
branches;
next	1.257;

1.257
date	2003.03.17.19.08.10;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2003.03.13.23.11.38;	author cgf;	state Exp;
branches;
next	1.255;

1.255
date	2003.03.13.08.18.15;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2003.03.09.21.51.00;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches
	1.253.2.1;
next	1.252;

1.252
date	2003.03.09.18.10.42;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2003.03.09.00.10.29;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2003.03.08.03.36.39;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2003.03.07.16.35.56;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2003.03.02.18.37.17;	author cgf;	state Exp;
branches;
next	1.247;

1.247
date	2003.02.28.23.52.48;	author phumblet;	state Exp;
branches;
next	1.246;

1.246
date	2003.02.21.14.29.18;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2003.02.10.22.43.29;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2003.02.04.19.49.39;	author tpfaff;	state Exp;
branches;
next	1.243;

1.243
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.242;

1.242
date	2003.01.25.10.36.46;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2003.01.24.15.23.15;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2003.01.15.10.21.23;	author corinna;	state Exp;
branches
	1.240.2.1;
next	1.239;

1.239
date	2003.01.14.20.19.27;	author tpfaff;	state Exp;
branches;
next	1.238;

1.238
date	2002.12.10.12.43.49;	author corinna;	state Exp;
branches
	1.238.4.1;
next	1.237;

1.237
date	2002.11.29.07.05.26;	author cgf;	state Exp;
branches;
next	1.236;

1.236
date	2002.11.22.20.51.13;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2002.11.20.09.23.21;	author corinna;	state Exp;
branches;
next	1.234;

1.234
date	2002.11.12.15.51.11;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2002.11.07.02.50.50;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2002.11.07.02.19.51;	author cgf;	state Exp;
branches;
next	1.231;

1.231
date	2002.10.21.01.00.57;	author cgf;	state Exp;
branches
	1.231.4.1;
next	1.230;

1.230
date	2002.10.20.04.15.50;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2002.09.30.04.35.18;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2002.09.19.15.12.48;	author cgf;	state Exp;
branches;
next	1.226;

1.226
date	2002.09.13.09.00.28;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2002.08.30.15.47.09;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2002.08.18.05.49.25;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2002.08.02.11.00.18;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2002.08.02.02.10.24;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2002.08.01.23.53.07;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2002.08.01.21.29.31;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2002.07.31.00.57.40;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2002.07.29.12.51.52;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2002.07.29.03.18.41;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2002.07.26.19.58.00;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2002.07.13.20.00.26;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2002.07.02.03.06.32;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2002.07.02.01.53.58;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2002.07.02.01.42.41;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2002.07.01.23.42.05;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2002.06.27.20.44.27;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2002.06.26.04.21.01;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2002.06.25.08.06.29;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2002.06.24.13.01.50;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2002.06.21.15.01.19;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2002.06.19.15.27.26;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2002.06.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2002.06.14.18.01.20;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2002.06.11.16.06.15;	author cgf;	state Exp;
branches;
next	1.201;

1.201
date	2002.06.06.15.35.06;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2002.06.06.11.17.50;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2002.06.05.16.01.55;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2002.06.03.17.44.08;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2002.06.03.17.11.14;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2002.06.02.03.13.22;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2002.05.29.15.04.27;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2002.05.28.14.10.52;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2002.05.27.11.48.15;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2002.05.22.22.09.58;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2002.05.16.09.30.48;	author corinna;	state Exp;
branches;
next	1.187;

1.187
date	2002.05.12.04.43.29;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2002.05.09.22.55.08;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2002.05.02.04.13.47;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2002.03.04.16.47.41;	author corinna;	state Exp;
branches;
next	1.183;

1.183
date	2002.02.25.17.47.47;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.181;

1.181
date	2002.01.21.20.51.30;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2002.01.21.03.15.24;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2002.01.14.20.39.59;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2002.01.13.20.03.03;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2002.01.10.13.24.28;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2001.12.28.15.53.26;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2001.11.15.03.25.52;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2001.11.14.04.12.11;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2001.11.13.21.49.06;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2001.11.08.17.49.52;	author corinna;	state Exp;
branches
	1.172.4.1;
next	1.171;

1.171
date	2001.11.08.15.01.44;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2001.11.05.06.09.08;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2001.11.04.02.31.58;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2001.11.03.03.32.27;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2001.11.01.23.48.34;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2001.10.31.00.55.32;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2001.10.30.07.43.46;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2001.10.22.18.31.00;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2001.10.20.05.08.21;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2001.10.19.02.27.19;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2001.10.16.03.31.50;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2001.10.15.23.39.33;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2001.10.14.04.14.24;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2001.10.07.21.16.36;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2001.10.05.04.21.41;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2001.10.05.00.17.57;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2001.10.04.02.34.20;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2001.10.03.03.49.26;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2001.10.02.01.58.06;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2001.10.01.04.10.07;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2001.09.24.21.50.44;	author cgf;	state Exp;
branches
	1.149.2.1;
next	1.148;

1.148
date	2001.09.23.15.35.02;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2001.09.22.21.44.07;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2001.09.16.14.26.11;	author duda;	state Exp;
branches;
next	1.144;

1.144
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2001.09.12.05.09.24;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2001.09.07.08.31.16;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2001.09.03.02.13.05;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2001.08.25.17.27.31;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2001.08.23.02.27.01;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2001.08.16.14.29.21;	author corinna;	state Exp;
branches;
next	1.136;

1.136
date	2001.08.16.14.20.09;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2001.08.15.07.49.15;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2001.08.14.07.41.45;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2001.08.07.16.14.59;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2001.07.26.00.10.52;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2001.07.18.11.00.05;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2001.07.14.00.09.33;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2001.07.13.17.22.15;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2001.06.28.02.19.57;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2001.06.26.21.03.08;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2001.06.24.22.26.53;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2001.06.18.21.18.59;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2001.06.14.18.21.17;	author duda;	state Exp;
branches;
next	1.121;

1.121
date	2001.06.09.21.25.55;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2001.06.05.10.45.52;	author duda;	state Exp;
branches;
next	1.119;

1.119
date	2001.06.03.02.31.16;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2001.06.01.11.53.20;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2001.05.31.05.25.46;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2001.05.23.15.49.22;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2001.05.23.08.12.49;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2001.05.20.08.10.47;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2001.04.30.21.19.42;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2001.04.28.23.48.28;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2001.04.25.12.54.21;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2001.04.25.09.43.25;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2001.04.24.02.07.58;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2001.04.23.17.29.33;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2001.04.23.16.46.30;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2001.04.18.21.10.13;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2001.04.17.11.47.37;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2001.04.12.21.21.37;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2001.04.12.16.50.13;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2001.04.05.20.43.23;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2001.04.03.02.53.24;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2001.04.02.00.18.29;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2001.04.01.03.06.02;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2001.04.01.00.06.17;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2001.03.19.11.02.40;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2001.03.18.21.11.25;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2001.03.17.19.53.52;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2001.03.17.05.11.20;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2001.03.17.05.06.14;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2001.03.14.11.13.46;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2001.03.12.14.49.29;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2001.03.10.20.25.19;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2001.03.07.20.52.33;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2001.03.05.06.28.24;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2001.03.03.03.56.34;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2001.02.22.14.51.16;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2001.02.21.21.49.37;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2001.02.16.18.49.20;	author duda;	state Exp;
branches;
next	1.82;

1.82
date	2001.02.09.17.17.34;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2001.02.06.14.07.02;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2001.01.29.00.46.25;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2001.01.22.20.29.20;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2001.01.18.04.26.04;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2001.01.17.14.57.09;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2001.01.15.12.53.30;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2001.01.15.12.25.00;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2001.01.14.19.08.30;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.01.12.05.38.25;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2000.12.19.20.43.41;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2000.12.19.19.52.57;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2000.11.15.21.14.27;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2000.11.15.21.04.02;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2000.11.15.00.13.09;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.14.05.53.32;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2000.11.03.04.27.01;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2000.10.25.03.54.50;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2000.10.24.18.15.25;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2000.10.18.04.53.37;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2000.10.17.18.55.58;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2000.10.12.04.38.29;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2000.10.07.03.25.38;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2000.09.30.01.56.40;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2000.09.25.16.36.12;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2000.09.07.16.23.51;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2000.08.09.02.33.47;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2000.08.04.04.04.46;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.43;

1.43
date	2000.07.29.16.24.40;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.27.17.30.48;	author dj;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.26.17.48.49;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.26.01.56.48;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.26.01.44.16;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2000.07.24.19.14.38;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2000.07.22.16.43.54;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2000.07.19.20.14.24;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.17.19.18.21;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2000.07.09.21.02.44;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2000.07.09.05.29.51;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.04.02.26.20;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.02.10.17.44;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.28.17.42.28;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.16.19.36.07;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.24.20.09.43;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.23.23.52.49;	author dj;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.22.17.15.47;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.19.17.15.02;	author dj;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.17.05.49.51;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.06.17.00.53;	author khan;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.04.19.46.32;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.03.16.11.11;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.26.15.28.06;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.25.19.39.05;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.25.16.31.14;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.20.13.52.41;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.19.22.33.20;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.19.03.21.13;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.16.22.57.05;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.13.22.43.48;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.02.20.42.42;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.28.21.49.16;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.26.01.54.21;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.19.11.05.14;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.18.06.26.14;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.16.19.35.18;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.09.21.04.05;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.24.20.57.40;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.24.20.57.03;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.04.07.13;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.38;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.659.2.1
date	2014.05.19.11.47.54;	author corinna;	state Exp;
branches;
next	1.659.2.2;

1.659.2.2
date	2014.05.19.11.49.16;	author corinna;	state Exp;
branches;
next	1.659.2.3;

1.659.2.3
date	2014.07.15.14.34.38;	author corinna;	state Exp;
branches;
next	1.659.2.4;

1.659.2.4
date	2014.08.13.17.39.10;	author corinna;	state Exp;
branches;
next	1.659.2.5;

1.659.2.5
date	2014.11.13.12.53.07;	author corinna;	state Exp;
branches;
next	;

1.638.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.638.2.2;

1.638.2.2
date	2012.10.16.15.18.39;	author corinna;	state Exp;
branches;
next	1.638.2.3;

1.638.2.3
date	2012.10.18.17.16.01;	author corinna;	state Exp;
branches;
next	1.638.2.4;

1.638.2.4
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.638.2.5;

1.638.2.5
date	2013.01.09.16.27.22;	author corinna;	state Exp;
branches;
next	1.638.2.6;

1.638.2.6
date	2013.01.10.15.08.59;	author corinna;	state Exp;
branches;
next	1.638.2.7;

1.638.2.7
date	2013.01.11.12.36.55;	author corinna;	state Exp;
branches;
next	1.638.2.8;

1.638.2.8
date	2013.01.19.15.41.56;	author corinna;	state Exp;
branches;
next	1.638.2.9;

1.638.2.9
date	2013.01.21.13.52.11;	author corinna;	state Exp;
branches;
next	1.638.2.10;

1.638.2.10
date	2013.02.09.20.38.03;	author corinna;	state Exp;
branches;
next	1.638.2.11;

1.638.2.11
date	2013.02.22.10.02.14;	author corinna;	state Exp;
branches;
next	1.638.2.12;

1.638.2.12
date	2013.03.14.12.09.52;	author corinna;	state Exp;
branches;
next	1.638.2.13;

1.638.2.13
date	2013.04.08.10.03.11;	author corinna;	state Exp;
branches;
next	1.638.2.14;

1.638.2.14
date	2013.04.08.10.33.55;	author corinna;	state Exp;
branches;
next	;

1.575.2.1
date	2011.03.13.12.05.58;	author corinna;	state Exp;
branches;
next	1.575.2.2;

1.575.2.2
date	2011.03.13.13.20.46;	author corinna;	state Exp;
branches;
next	;

1.403.2.1
date	2006.07.14.13.03.11;	author corinna;	state Exp;
branches;
next	;

1.403.4.1
date	2007.01.12.19.44.19;	author corinna;	state Exp;
branches;
next	1.403.4.2;

1.403.4.2
date	2007.01.15.11.56.07;	author corinna;	state Exp;
branches;
next	1.403.4.3;

1.403.4.3
date	2007.11.12.15.30.20;	author corinna;	state Exp;
branches;
next	;

1.349.2.1
date	2004.11.18.00.48.41;	author cgf;	state Exp;
branches;
next	;

1.314.4.1
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	1.314.4.2;

1.314.4.2
date	2004.01.24.03.41.29;	author cgf;	state Exp;
branches;
next	1.314.4.3;

1.314.4.3
date	2004.01.26.18.52.52;	author cgf;	state Exp;
branches;
next	;

1.313.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	1.313.2.2;

1.313.2.2
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	;

1.287.2.1
date	2003.09.19.03.55.54;	author cgf;	state Exp;
branches;
next	1.287.2.2;

1.287.2.2
date	2003.09.20.02.48.13;	author cgf;	state Exp;
branches;
next	;

1.253.2.1
date	2003.03.16.23.38.19;	author cgf;	state Exp;
branches;
next	1.253.2.2;

1.253.2.2
date	2003.03.17.19.11.23;	author cgf;	state Exp;
branches;
next	;

1.240.2.1
date	2003.01.16.01.27.31;	author cgf;	state Exp;
branches;
next	1.240.2.2;

1.240.2.2
date	2003.01.25.01.18.28;	author cgf;	state Exp;
branches;
next	1.240.2.3;

1.240.2.3
date	2003.01.25.16.37.00;	author cgf;	state Exp;
branches;
next	1.240.2.4;

1.240.2.4
date	2003.01.26.06.43.33;	author cgf;	state Exp;
branches;
next	1.240.2.5;

1.240.2.5
date	2003.02.05.14.25.11;	author cgf;	state Exp;
branches;
next	1.240.2.6;

1.240.2.6
date	2003.02.11.03.13.09;	author cgf;	state Exp;
branches;
next	1.240.2.7;

1.240.2.7
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.240.2.8;

1.240.2.8
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.240.2.9;

1.240.2.9
date	2003.02.23.07.03.23;	author cgf;	state Exp;
branches;
next	1.240.2.10;

1.240.2.10
date	2003.03.02.18.57.51;	author cgf;	state Exp;
branches;
next	1.240.2.11;

1.240.2.11
date	2003.03.03.03.59.39;	author cgf;	state Exp;
branches;
next	1.240.2.12;

1.240.2.12
date	2003.03.09.16.22.58;	author cgf;	state Exp;
branches;
next	1.240.2.13;

1.240.2.13
date	2003.03.09.18.15.57;	author cgf;	state Exp;
branches;
next	1.240.2.14;

1.240.2.14
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.240.2.15;

1.240.2.15
date	2003.03.10.00.07.01;	author cgf;	state Exp;
branches;
next	1.240.2.16;

1.240.2.16
date	2003.03.19.19.59.56;	author cgf;	state Exp;
branches;
next	1.240.2.17;

1.240.2.17
date	2003.03.21.15.15.18;	author cgf;	state Exp;
branches;
next	1.240.2.18;

1.240.2.18
date	2003.03.22.17.50.48;	author cgf;	state Exp;
branches;
next	1.240.2.19;

1.240.2.19
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.240.2.20;

1.240.2.20
date	2003.05.10.17.20.54;	author cgf;	state Exp;
branches;
next	1.240.2.21;

1.240.2.21
date	2003.05.26.19.39.07;	author cgf;	state Exp;
branches;
next	1.240.2.22;

1.240.2.22
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.240.2.23;

1.240.2.23
date	2003.07.10.01.06.23;	author cgf;	state Exp;
branches;
next	1.240.2.24;

1.240.2.24
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.240.2.25;

1.240.2.25
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.240.2.26;

1.240.2.26
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.240.2.27;

1.240.2.27
date	2003.09.11.04.47.23;	author cgf;	state Exp;
branches;
next	1.240.2.28;

1.240.2.28
date	2003.09.14.01.35.38;	author cgf;	state Exp;
branches;
next	;

1.238.4.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.238.4.2;

1.238.4.2
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.238.4.3;

1.238.4.3
date	2002.12.29.06.14.14;	author cgf;	state Exp;
branches;
next	1.238.4.4;

1.238.4.4
date	2003.01.02.06.16.17;	author cgf;	state Exp;
branches;
next	1.238.4.5;

1.238.4.5
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	;

1.231.4.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.172.4.1
date	2001.11.14.04.13.09;	author cgf;	state Exp;
branches;
next	;

1.149.2.1
date	2001.10.02.12.09.56;	author rbcollins;	state Exp;
branches;
next	1.149.2.2;

1.149.2.2
date	2002.01.04.03.56.11;	author rbcollins;	state Exp;
branches;
next	1.149.2.3;

1.149.2.3
date	2002.01.04.04.29.45;	author rbcollins;	state Exp;
branches;
next	1.149.2.4;

1.149.2.4
date	2002.01.15.12.52.52;	author rbcollins;	state Exp;
branches;
next	1.149.2.5;

1.149.2.5
date	2002.01.22.04.52.40;	author rbcollins;	state Exp;
branches;
next	1.149.2.6;

1.149.2.6
date	2002.02.28.12.53.28;	author rbcollins;	state Exp;
branches;
next	1.149.2.7;

1.149.2.7
date	2002.06.13.14.34.12;	author rbcollins;	state Exp;
branches;
next	1.149.2.8;

1.149.2.8
date	2002.06.15.10.26.32;	author rbcollins;	state Exp;
branches;
next	1.149.2.9;

1.149.2.9
date	2002.06.18.00.17.07;	author scottc;	state Exp;
branches;
next	1.149.2.10;

1.149.2.10
date	2002.06.19.20.58.58;	author scottc;	state Exp;
branches;
next	1.149.2.11;

1.149.2.11
date	2002.06.22.09.51.23;	author scottc;	state Exp;
branches;
next	1.149.2.12;

1.149.2.12
date	2002.06.25.10.50.38;	author scottc;	state Exp;
branches;
next	1.149.2.13;

1.149.2.13
date	2002.06.27.11.30.17;	author scottc;	state Exp;
branches;
next	1.149.2.14;

1.149.2.14
date	2002.06.28.18.15.48;	author scottc;	state Exp;
branches;
next	1.149.2.15;

1.149.2.15
date	2002.07.02.10.58.20;	author scottc;	state Exp;
branches;
next	1.149.2.16;

1.149.2.16
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.149.2.17;

1.149.2.17
date	2002.07.29.10.54.14;	author scottc;	state Exp;
branches;
next	1.149.2.18;

1.149.2.18
date	2002.07.30.13.31.46;	author scottc;	state Exp;
branches;
next	1.149.2.19;

1.149.2.19
date	2002.07.31.16.49.37;	author scottc;	state Exp;
branches;
next	1.149.2.20;

1.149.2.20
date	2002.08.02.02.23.44;	author scottc;	state Exp;
branches;
next	1.149.2.21;

1.149.2.21
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	1.149.2.22;

1.149.2.22
date	2002.08.18.12.09.27;	author scottc;	state Exp;
branches;
next	1.149.2.23;

1.149.2.23
date	2002.08.30.22.08.50;	author scottc;	state Exp;
branches;
next	1.149.2.24;

1.149.2.24
date	2002.09.16.17.24.16;	author scottc;	state Exp;
branches;
next	1.149.2.25;

1.149.2.25
date	2002.09.19.21.51.22;	author scottc;	state Exp;
branches;
next	1.149.2.26;

1.149.2.26
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.671
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@/* syscalls.cc: syscalls

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#define fstat __FOOfstat__
#define lstat __FOOlstat__
//#define stat __FOOstat__
#define _close __FOO_close__
#define _lseek __FOO_lseek__
#define _open __FOO_open__
#define _read __FOO_read__
#define _write __FOO_write__
#define _open64 __FOO_open64__
#define _lseek64 __FOO_lseek64__
#define _fstat64 __FOO_fstat64__
#define pread __FOO_pread
#define pwrite __FOO_pwrite

#include "winsup.h"
#include "miscfuncs.h"
#include <sys/stat.h>
#include <sys/vfs.h> /* needed for statfs */
#include <sys/statvfs.h> /* needed for statvfs */
#include <stdlib.h>
#include <stdio.h>
#include <process.h>
#include <utmp.h>
#include <utmpx.h>
#include <sys/uio.h>
#include <ctype.h>
#include <wctype.h>
#include <unistd.h>
#include <sys/wait.h>
#include <dirent.h>
#include "ntdll.h"

#undef fstat
#undef lstat
//#undef stat
#undef pread
#undef pwrite

#include <cygwin/version.h>
#include "cygerrno.h"
#include "perprocess.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "sigproc.h"
#include "pinfo.h"
#include "shared_info.h"
#include "cygheap.h"
#include "registry.h"
#include "environ.h"
#include "tls_pbuf.h"
#include "sync.h"
#include "child_info.h"

#undef _close
#undef _lseek
#undef _open
#undef _read
#undef _write
#undef _open64
#undef _lseek64
#undef _fstat64

static int __stdcall mknod_worker (const char *, mode_t, mode_t, _major_t,
				   _minor_t);

/* Close all files and process any queued deletions.
   Lots of unix style applications will open a tmp file, unlink it,
   but never call close.  This function is called by _exit to
   ensure we don't leave any such files lying around.  */

void __stdcall
close_all_files (bool norelease)
{
  cygheap->fdtab.lock ();

  semaphore::terminate ();

  HANDLE h = NULL;

  for (int i = 0; i < (int) cygheap->fdtab.size; i++)
    {
      cygheap_fdget cfd (i, false, false);
      if (cfd >= 0)
	{
	  debug_only_printf ("closing fd %d", i);
	  if (i == 2)
	    DuplicateHandle (GetCurrentProcess (), cfd->get_output_handle (),
			     GetCurrentProcess (), &h,
			     0, false, DUPLICATE_SAME_ACCESS);
	  cfd->close_with_arch ();
	  if (!norelease)
	    cfd.release ();
	}
    }

  if (!have_execed && cygheap->ctty)
    cygheap->close_ctty ();

  fhandler_base_overlapped::flush_all_async_io ();
  if (h)
    SetStdHandle (STD_ERROR_HANDLE, h);
  cygheap->fdtab.unlock ();
}

extern "C" int
dup (int fd)
{
  int res;
  cygheap_fdnew newfd;
  if (newfd < 0)
    res = -1;
  else
    res = cygheap->fdtab.dup3 (fd, newfd, 0);
  syscall_printf ("%R = dup(%d)", res, fd);
  return res;
}

inline int
dup_finish (int oldfd, int newfd, int flags)
{
  int res;
  if ((res = cygheap->fdtab.dup3 (oldfd, newfd, flags | O_EXCL)) == newfd)
    {
      cygheap_fdget (newfd)->inc_refcnt ();
      cygheap->fdtab.unlock ();	/* dup3 exits with lock set on success */
    }
  return res;
}

extern "C" int
dup2 (int oldfd, int newfd)
{
  int res;
  if (newfd >= OPEN_MAX_MAX || newfd < 0)
    {
      set_errno (EBADF);
      res = -1;
    }
  else if (newfd == oldfd)
    {
      cygheap_fdget cfd (oldfd);
      res = (cfd >= 0) ? oldfd : -1;
    }
  else
    res = dup_finish (oldfd, newfd, 0);

  syscall_printf ("%R = dup2(%d, %d)", res, oldfd, newfd);
  return res;
}

extern "C" int
dup3 (int oldfd, int newfd, int flags)
{
  int res;
  if (newfd >= OPEN_MAX_MAX)
    {
      set_errno (EBADF);
      res = -1;
    }
  else if (newfd == oldfd)
    {
      cygheap_fdget cfd (oldfd, false, false);
      set_errno (cfd < 0 ? EBADF : EINVAL);
      res = -1;
    }
  else
    res = dup_finish (oldfd, newfd, flags);

  syscall_printf ("%R = dup3(%d, %d, %y)", res, oldfd, newfd, flags);
  return res;
}

/* Define macro to simplify checking for a transactional error code. */
#define NT_TRANSACTIONAL_ERROR(s)	\
		(((ULONG)(s) >= (ULONG)STATUS_TRANSACTIONAL_CONFLICT) \
		 && ((ULONG)(s) <= (ULONG)STATUS_TRANSACTION_NOT_ENLISTED))

static inline void
start_transaction (HANDLE &old_trans, HANDLE &trans)
{
  NTSTATUS status = NtCreateTransaction (&trans,
				SYNCHRONIZE | TRANSACTION_ALL_ACCESS,
				NULL, NULL, NULL, 0, 0, 0, NULL, NULL);
  if (NT_SUCCESS (status))
    {
      old_trans = RtlGetCurrentTransaction ();
      RtlSetCurrentTransaction (trans);
    }
  else
    {
      debug_printf ("NtCreateTransaction failed, %y", status);
      old_trans = trans = NULL;
    }
}

static inline NTSTATUS
stop_transaction (NTSTATUS status, HANDLE old_trans, HANDLE &trans)
{
  RtlSetCurrentTransaction (old_trans);
  if (NT_SUCCESS (status))
    status = NtCommitTransaction (trans, TRUE);
  else
    status = NtRollbackTransaction (trans, TRUE);
  NtClose (trans);
  trans = NULL;
  return status;
}

static char desktop_ini[] =
  "[.ShellClassInfo]\r\n"
  "CLSID={645FF040-5081-101B-9F08-00AA002F954E}\r\n";

static char desktop_ini_ext[] =
  "LocalizedResourceName=@@%SystemRoot%\\system32\\shell32.dll,-8964\r\n";

static BYTE info2[] =
{
  0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

enum bin_status
{
  dont_move,
  move_to_bin,
  has_been_moved,
  dir_not_empty
};

static bin_status
try_to_bin (path_conv &pc, HANDLE &fh, ACCESS_MASK access, ULONG flags)
{
  bin_status bin_stat = move_to_bin;
  NTSTATUS status;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  HANDLE rootdir = NULL, recyclerdir = NULL, tmp_fh = NULL;
  USHORT recycler_base_len = 0, recycler_user_len = 0;
  UNICODE_STRING root, recycler, fname;
  WCHAR recyclerbuf[NAME_MAX + 1]; /* Enough for recycler + SID + filename */
  PFILE_NAME_INFORMATION pfni;
  PFILE_INTERNAL_INFORMATION pfii;
  PFILE_RENAME_INFORMATION pfri;
  ULONG frisiz;
  FILE_DISPOSITION_INFORMATION disp = { TRUE };
  bool fs_has_per_user_recycler = pc.fs_is_ntfs () || pc.fs_is_refs ();

  tmp_pathbuf tp;
  PBYTE infobuf = (PBYTE) tp.w_get ();

  pfni = (PFILE_NAME_INFORMATION) infobuf;
  status = NtQueryInformationFile (fh, &io, pfni, 65536, FileNameInformation);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQueryInformationFile (%S, FileNameInformation) "
		    "failed, status = %y", pc.get_nt_native_path (), status);
      goto out;
    }
  /* The filename could change, the parent dir not.  So we split both paths
     and take the prefix.  However, there are two special cases:
     - The handle refers to the root dir of the volume.
     - The handle refers to the recycler or a subdir.
     Both cases are handled by just returning and not even trying to move
     them into the recycler. */
  if (pfni->FileNameLength == 2) /* root dir. */
    goto out;
  /* The recycler name on Vista and later is $Recycler.Bin by default.  If the
     recycler dir disappeared for some reason, the shell32.dll recreates the
     directory in all upper case.  So, we never know beforehand if the dir
     is written in mixed case or in all upper case.  That's a problem when
     using casesensitivity.  If the file handle given to FileRenameInformation
     has been opened casesensitive, the call also handles the path to the
     target dir casesensitive.  Rather then trying to find the right name
     of the recycler, we just reopen the file to move with OBJ_CASE_INSENSITIVE,
     so the subsequent FileRenameInformation works caseinsensitive in terms of
     the recycler directory name, too. */
  if (!pc.objcaseinsensitive ())
    {
      InitializeObjectAttributes (&attr, &ro_u_empty, OBJ_CASE_INSENSITIVE,
				  fh, NULL);
      status = NtOpenFile (&tmp_fh, access, &attr, &io, FILE_SHARE_VALID_FLAGS,
			   flags);
      if (!NT_SUCCESS (status))
	debug_printf ("NtOpenFile (%S) for reopening caseinsensitive failed, "
		      "status = %y", pc.get_nt_native_path (), status);
      else
	{
	  NtClose (fh);
	  fh = tmp_fh;
	}
    }
  /* Initialize recycler path. */
  RtlInitEmptyUnicodeString (&recycler, recyclerbuf, sizeof recyclerbuf);
  if (!pc.isremote ())
    {
      if (wincap.has_recycle_dot_bin ()) /* NTFS and FAT since Vista, ReFS */
	RtlAppendUnicodeToString (&recycler, L"\\$Recycle.Bin\\");
      else if (pc.fs_is_ntfs ())	/* NTFS up to 2K3 */
	RtlAppendUnicodeToString (&recycler, L"\\RECYCLER\\");
      else if (pc.fs_is_fat ())	/* FAT up to 2K3 */
	RtlAppendUnicodeToString (&recycler, L"\\Recycled\\");
      else
	goto out;
      /* Is the file a subdir of the recycler? */
      RtlInitCountedUnicodeString(&fname, pfni->FileName, pfni->FileNameLength);
      if (RtlEqualUnicodePathPrefix (&fname, &recycler, TRUE))
	goto out;
      /* Is fname the recycler?  Temporarily hide trailing backslash. */
      recycler.Length -= sizeof (WCHAR);
      if (RtlEqualUnicodeString (&fname, &recycler, TRUE))
	goto out;

      /* Create root dir path from file name information. */
      RtlSplitUnicodePath (&fname, &fname, NULL);
      RtlSplitUnicodePath (pc.get_nt_native_path (), &root, NULL);
      root.Length -= fname.Length - sizeof (WCHAR);

      /* Open root directory.  All recycler bin ops are caseinsensitive. */
      InitializeObjectAttributes (&attr, &root, OBJ_CASE_INSENSITIVE,
				  NULL, NULL);
      status = NtOpenFile (&rootdir, FILE_TRAVERSE, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtOpenFile (%S) failed, status = %y", &root, status);
	  goto out;
	}

      /* Strip leading backslash */
      ++recycler.Buffer;
      recycler.Length -= sizeof (WCHAR);
      /* Store length of recycler base dir, if it's necessary to create it. */
      recycler_base_len = recycler.Length;
      /* On NTFS or ReFS the recycler dir contains user specific subdirs, which
	 are the actual recycle bins per user.  The name if this dir is the
	 string representation of the user SID. */
      if (fs_has_per_user_recycler)
	{
	  UNICODE_STRING sid;
	  WCHAR sidbuf[128];
	  /* Unhide trailing backslash. */
	  recycler.Length += sizeof (WCHAR);
	  RtlInitEmptyUnicodeString (&sid, sidbuf, sizeof sidbuf);
	  RtlConvertSidToUnicodeString (&sid, cygheap->user.sid (), FALSE);
	  RtlAppendUnicodeStringToString (&recycler, &sid);
	  recycler_user_len = recycler.Length;
	}
      RtlAppendUnicodeToString (&recycler, L"\\");
    }
  /* Create hopefully unique filename.
     Since we have to stick to the current directory on remote shares, make
     the new filename at least very unlikely to match by accident.  It starts
     with ".cyg", with "cyg" transposed into the Unicode low surrogate area
     starting at U+dc00.  Use plain ASCII chars on filesystems not supporting
     Unicode.  The rest of the filename is the inode number in hex encoding
     and a hash of the full NT path in hex.  The combination allows to remove
     multiple hardlinks to the same file. */
  RtlAppendUnicodeToString (&recycler,
			    pc.fs_flags () & FILE_UNICODE_ON_DISK
			    ? L".\xdc63\xdc79\xdc67" : L".cyg");
  pfii = (PFILE_INTERNAL_INFORMATION) infobuf;
  /* Note: Modern Samba versions apparently don't like buffer sizes of more
     than 65535 in some NtQueryInformationFile/NtSetInformationFile calls.
     Therefore we better use exact buffer sizes from now on. */
  status = NtQueryInformationFile (fh, &io, pfii, sizeof *pfii,
				   FileInternalInformation);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQueryInformationFile (%S, FileInternalInformation) "
		    "failed, status = %y", pc.get_nt_native_path (), status);
      goto out;
    }
  RtlInt64ToHexUnicodeString (pfii->FileId.QuadPart, &recycler, TRUE);
  RtlInt64ToHexUnicodeString (hash_path_name (0, pc.get_nt_native_path ()),
			      &recycler, TRUE);
  /* Shoot. */
  pfri = (PFILE_RENAME_INFORMATION) infobuf;
  pfri->ReplaceIfExists = TRUE;
  pfri->RootDirectory = pc.isremote () ? NULL : rootdir;
  pfri->FileNameLength = recycler.Length;
  memcpy (pfri->FileName, recycler.Buffer, recycler.Length);
  frisiz = sizeof *pfri + pfri->FileNameLength - sizeof (WCHAR);

  status = NtSetInformationFile (fh, &io, pfri, frisiz, FileRenameInformation);
  if (status == STATUS_OBJECT_PATH_NOT_FOUND && !pc.isremote ())
    {
      /* Ok, so the recycler and/or the recycler/SID directory don't exist.
	 First reopen root dir with permission to create subdirs. */
      NtClose (rootdir);
      InitializeObjectAttributes (&attr, &root, OBJ_CASE_INSENSITIVE,
				  NULL, NULL);
      status = NtOpenFile (&rootdir, FILE_ADD_SUBDIRECTORY, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtOpenFile (%S) failed, status = %y",
	  		&recycler, status);
	  goto out;
	}
      /* Then check if recycler exists by opening and potentially creating it.
	 Yes, we can really do that.  Typically the recycle bin is created
	 by the first user actually using the bin.  Pre-Vista, the permissions
	 are the default permissions propagated from the root directory.
	 Since Vista the top-level recycle dir has explicit permissions. */
      InitializeObjectAttributes (&attr, &recycler, OBJ_CASE_INSENSITIVE,
				  rootdir,
				  wincap.has_recycle_dot_bin ()
				  ? recycler_sd (true, true) : NULL);
      recycler.Length = recycler_base_len;
      status = NtCreateFile (&recyclerdir,
			     READ_CONTROL
			     | (fs_has_per_user_recycler ? 0 : FILE_ADD_FILE),
			     &attr, &io, NULL,
			     FILE_ATTRIBUTE_DIRECTORY
			     | FILE_ATTRIBUTE_SYSTEM
			     | FILE_ATTRIBUTE_HIDDEN,
			     FILE_SHARE_VALID_FLAGS, FILE_OPEN_IF,
			     FILE_DIRECTORY_FILE, NULL, 0);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtCreateFile (%S) failed, status = %y",
	  		&recycler, status);
	  goto out;
	}
      /* Next, if necessary, check if the recycler/SID dir exists and
	 create it if not. */
      if (fs_has_per_user_recycler)
	{
	  NtClose (recyclerdir);
	  recycler.Length = recycler_user_len;
	  InitializeObjectAttributes (&attr, &recycler, OBJ_CASE_INSENSITIVE,
				      rootdir, recycler_sd (false, true));
	  status = NtCreateFile (&recyclerdir, READ_CONTROL | FILE_ADD_FILE,
				 &attr, &io, NULL, FILE_ATTRIBUTE_DIRECTORY
						   | FILE_ATTRIBUTE_SYSTEM
						   | FILE_ATTRIBUTE_HIDDEN,
				 FILE_SHARE_VALID_FLAGS, FILE_OPEN_IF,
				 FILE_DIRECTORY_FILE, NULL, 0);
	  if (!NT_SUCCESS (status))
	    {
	      debug_printf ("NtCreateFile (%S) failed, status = %y",
			    &recycler, status);
	      goto out;
	    }
	}
      /* The desktop.ini and INFO2 (pre-Vista) files are expected by
	 Windows Explorer.  Otherwise, the created bin is treated as
	 corrupted */
      if (io.Information == FILE_CREATED)
	{
	  RtlInitUnicodeString (&fname, L"desktop.ini");
	  InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE,
				      recyclerdir, recycler_sd (false, false));
	  status = NtCreateFile (&tmp_fh, FILE_GENERIC_WRITE, &attr, &io, NULL,
				 FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN,
				 FILE_SHARE_VALID_FLAGS, FILE_CREATE,
				 FILE_SYNCHRONOUS_IO_NONALERT
				 | FILE_NON_DIRECTORY_FILE, NULL, 0);
	  if (!NT_SUCCESS (status))
	    debug_printf ("NtCreateFile (%S) failed, status = %y",
			  &recycler, status);
	  else
	    {
	      status = NtWriteFile (tmp_fh, NULL, NULL, NULL, &io, desktop_ini,
				    sizeof desktop_ini - 1, NULL, NULL);
	      if (!NT_SUCCESS (status))
		debug_printf ("NtWriteFile (%S) failed, status = %y",
			      &fname, status);
	      else if (wincap.has_recycle_dot_bin ())
	      	{
		  status = NtWriteFile (tmp_fh, NULL, NULL, NULL, &io,
		  			desktop_ini_ext,
					sizeof desktop_ini_ext - 1, NULL, NULL);
		  if (!NT_SUCCESS (status))
		    debug_printf ("NtWriteFile (%S) failed, status = %y",
				  &fname, status);
		}
	      NtClose (tmp_fh);
	    }
	  if (!wincap.has_recycle_dot_bin ()) /* No INFO2 file since Vista */
	    {
	      RtlInitUnicodeString (&fname, L"INFO2");
	      status = NtCreateFile (&tmp_fh, FILE_GENERIC_WRITE, &attr, &io,
				     NULL, FILE_ATTRIBUTE_ARCHIVE
					   | FILE_ATTRIBUTE_HIDDEN,
				     FILE_SHARE_VALID_FLAGS, FILE_CREATE,
				     FILE_SYNCHRONOUS_IO_NONALERT
				     | FILE_NON_DIRECTORY_FILE, NULL, 0);
		if (!NT_SUCCESS (status))
		  debug_printf ("NtCreateFile (%S) failed, status = %y",
				&recycler, status);
		else
		{
		  status = NtWriteFile (tmp_fh, NULL, NULL, NULL, &io, info2,
					sizeof info2, NULL, NULL);
		  if (!NT_SUCCESS (status))
		    debug_printf ("NtWriteFile (%S) failed, status = %y",
				  &fname, status);
		  NtClose (tmp_fh);
		}
	    }
	}
      NtClose (recyclerdir);
      /* Shoot again. */
      status = NtSetInformationFile (fh, &io, pfri, frisiz,
				     FileRenameInformation);
    }
  if (!NT_SUCCESS (status))
    {
      debug_printf ("Move %S to %S failed, status = %y",
		    pc.get_nt_native_path (), &recycler, status);
      goto out;
    }
  /* Moving to the bin worked. */
  bin_stat = has_been_moved;
  /* Now we try to set the delete disposition.  If that worked, we're done.
     We try this here first, as long as we still have the open handle.
     Otherwise the below code closes the handle to allow replacing the file. */
  status = NtSetInformationFile (fh, &io, &disp, sizeof disp,
				 FileDispositionInformation);
  if (status == STATUS_DIRECTORY_NOT_EMPTY)
    {
      /* Uh oh!  This was supposed to be avoided by the check_dir_not_empty
	 test in unlink_nt, but given that the test isn't atomic, this *can*
	 happen.  Try to move the dir back ASAP. */
      pfri->RootDirectory = NULL;
      pfri->FileNameLength = pc.get_nt_native_path ()->Length;
      memcpy (pfri->FileName, pc.get_nt_native_path ()->Buffer,
			      pc.get_nt_native_path ()->Length);
      frisiz = sizeof *pfri + pfri->FileNameLength - sizeof (WCHAR);
      if (NT_SUCCESS (NtSetInformationFile (fh, &io, pfri, frisiz,
					    FileRenameInformation)))
	{
	  /* Give notice to unlink_nt and leave immediately.  This avoids
	     closing the handle, which might still be used if called from
	     the rm -r workaround code. */
	  bin_stat = dir_not_empty;
	  goto out;
	}
    }
  /* In case of success, restore R/O attribute to accommodate hardlinks.
     That leaves potentially hardlinks around with the R/O bit suddenly
     off if setting the delete disposition failed, but please, keep in
     mind this is really a border case only. */
  if ((access & FILE_WRITE_ATTRIBUTES) && NT_SUCCESS (status) && !pc.isdir ())
    NtSetAttributesFile (fh, pc.file_attributes ());
  NtClose (fh);
  fh = NULL; /* So unlink_nt doesn't close the handle twice. */
  /* On success or when trying to unlink a directory we just return here.
     The below code only works for files. */
  if (NT_SUCCESS (status) || pc.isdir ())
    goto out;
  /* The final trick.  We create a temporary file with delete-on-close
     semantic and rename that file to the file just moved to the bin.
     This typically overwrites the original file and we get rid of it,
     even if neither setting the delete dispostion, nor setting
     delete-on-close on the original file succeeds.  There are still
     cases in which this fails, for instance, when trying to delete a
     hardlink to a DLL used by the unlinking application itself. */
  RtlAppendUnicodeToString (&recycler, L"X");
  InitializeObjectAttributes (&attr, &recycler, 0, rootdir, NULL);
  status = NtCreateFile (&tmp_fh, DELETE, &attr, &io, NULL,
			 FILE_ATTRIBUTE_NORMAL, 0, FILE_SUPERSEDE,
			 FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE,
			 NULL, 0);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("Creating file for overwriting failed, status = %y",
		    status);
      goto out;
    }
  status = NtSetInformationFile (tmp_fh, &io, pfri, frisiz,
				 FileRenameInformation);
  NtClose (tmp_fh);
  if (!NT_SUCCESS (status))
    debug_printf ("Overwriting with another file failed, status = %y", status);

out:
  if (rootdir)
    NtClose (rootdir);
  debug_printf ("%S, return bin_status %d", pc.get_nt_native_path (), bin_stat);
  return bin_stat;
}

static NTSTATUS
check_dir_not_empty (HANDLE dir, path_conv &pc)
{
  IO_STATUS_BLOCK io;
  const ULONG bufsiz = 3 * sizeof (FILE_NAMES_INFORMATION)
		       + 3 * NAME_MAX * sizeof (WCHAR);
  PFILE_NAMES_INFORMATION pfni = (PFILE_NAMES_INFORMATION)
				 alloca (bufsiz);
  NTSTATUS status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io, pfni,
					  bufsiz, FileNamesInformation,
					  FALSE, NULL, TRUE);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("Checking if directory %S is empty failed, status = %y",
		    pc.get_nt_native_path (), status);
      return status;
    }
  int cnt = 1;
  do
    {
      while (pfni->NextEntryOffset)
	{
	  if (++cnt > 2)
	    {
	      UNICODE_STRING fname;
	      OBJECT_ATTRIBUTES attr;
	      FILE_BASIC_INFORMATION fbi;

	      pfni = (PFILE_NAMES_INFORMATION)
		     ((caddr_t) pfni + pfni->NextEntryOffset);
	      RtlInitCountedUnicodeString(&fname, pfni->FileName,
					  pfni->FileNameLength);
	      InitializeObjectAttributes (&attr, &fname, 0, dir, NULL);
	      status = NtQueryAttributesFile (&attr, &fbi);
	      /* Intensive testing shows that sometimes directories, for which
		 the delete disposition has already been set, and the deleting
		 handle is already closed, can linger in the parent dir for a
		 couple of ms for no apparent reason (Windows Defender or other
		 real-time scanners are suspect).

		 A fast rm -r is capable to exploit this problem.  Setting the
		 delete disposition of the parent dir then fails with
		 STATUS_DIRECTORY_NOT_EMPTY.  Examining the content of the
		 affected dir can then show either that the dir is empty, or it
		 can contain a lingering subdir.  Calling NtQueryAttributesFile
		 on that subdir returns with STATUS_DELETE_PENDING, or it
		 disappeared before that call.

		 That's what we do here.  If NtQueryAttributesFile succeeded,
		 or if the error code does not indicate an already deleted
		 entry, STATUS_DIRECTORY_NOT_EMPTY is returned.

		 Otherwise STATUS_SUCCESS is returned.  Read on in unlink_nt. */
	      if (status != STATUS_DELETE_PENDING
		  && status != STATUS_OBJECT_NAME_NOT_FOUND
		  && status != STATUS_OBJECT_PATH_NOT_FOUND)
		{
		  debug_printf ("Directory %S not empty, found file <%S>, "
				 "query status = %y",
				pc.get_nt_native_path (), &fname, status);
		  return STATUS_DIRECTORY_NOT_EMPTY;
		}
	    }
	  pfni = (PFILE_NAMES_INFORMATION) ((caddr_t) pfni + pfni->NextEntryOffset);
	}
    }
  while (NT_SUCCESS (NtQueryDirectoryFile (dir, NULL, NULL, 0, &io, pfni,
					   bufsiz, FileNamesInformation,
					   FALSE, NULL, FALSE)));
  return STATUS_SUCCESS;
}

NTSTATUS
unlink_nt (path_conv &pc)
{
  NTSTATUS status;
  HANDLE fh, fh_ro = NULL;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  HANDLE old_trans = NULL, trans = NULL;
  ULONG num_links = 1;
  FILE_DISPOSITION_INFORMATION disp = { TRUE };
  int reopened = 0;

  bin_status bin_stat = dont_move;

  syscall_printf ("Trying to delete %S, isdir = %d",
		  pc.get_nt_native_path (), pc.isdir ());
  ACCESS_MASK access = DELETE;
  ULONG flags = FILE_OPEN_FOR_BACKUP_INTENT;
  /* Add the reparse point flag to native symlinks, otherwise we remove the
     target, not the symlink. */
  if (pc.is_rep_symlink ())
    flags |= FILE_OPEN_REPARSE_POINT;

  pc.get_object_attr (attr, sec_none_nih);
  /* If the R/O attribute is set, we have to open the file with
     FILE_WRITE_ATTRIBUTES to be able to remove this flags before trying
     to delete it.  We do this separately because there are filesystems
     out there (MVFS), which refuse a request to open a file for DELETE
     if the DOS R/O attribute is set for the file.  After removing the R/O
     attribute, just re-open the file for DELETE and go ahead. */
  if (pc.file_attributes () & FILE_ATTRIBUTE_READONLY)
    {
      FILE_STANDARD_INFORMATION fsi;

      /* If possible, hide the non-atomicity of the "remove R/O flag, remove
	 link to file" operation behind a transaction. */
      if (wincap.has_transactions ()
	  && (pc.fs_flags () & FILE_SUPPORTS_TRANSACTIONS))
	start_transaction (old_trans, trans);
retry_open:
      status = NtOpenFile (&fh_ro, FILE_WRITE_ATTRIBUTES, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, flags);
      if (NT_SUCCESS (status))
	{
	  debug_printf ("Opening %S for removing R/O succeeded",
			pc.get_nt_native_path ());
	  NTSTATUS status2 = NtSetAttributesFile (fh_ro,
						  pc.file_attributes ()
						  & ~FILE_ATTRIBUTE_READONLY);
	  if (!NT_SUCCESS (status2))
	    debug_printf ("Removing R/O on %S failed, status = %y",
			  pc.get_nt_native_path (), status2);
	  pc.init_reopen_attr (attr, fh_ro);
	}
      else
	{
	  debug_printf ("Opening %S for removing R/O failed, status = %y",
			pc.get_nt_native_path (), status);
	  if (NT_TRANSACTIONAL_ERROR (status) && trans)
	    {
	      /* If NtOpenFile fails due to transactional problems, stop
		 transaction and go ahead without. */
	      stop_transaction (status, old_trans, trans);
	      debug_printf ("Transaction failure.  Retry open.");
	      goto retry_open;
	    }
	}
      if (pc.is_lnk_symlink ())
	{
	  status = NtQueryInformationFile (fh_ro, &io, &fsi, sizeof fsi,
					   FileStandardInformation);
	  if (NT_SUCCESS (status))
	    num_links = fsi.NumberOfLinks;
	}
      access |= FILE_WRITE_ATTRIBUTES;
    }
  /* First try to open the file with only allowing sharing for delete.  If
     the file has an open handle on it, other than just for deletion, this
     will fail.  That indicates that the file has to be moved to the recycle
     bin so that it actually disappears from its directory even though its
     in use.  Otherwise, if opening doesn't fail, the file is not in use and
     we can go straight to setting the delete disposition flag.

     NOTE: The missing sharing modes FILE_SHARE_READ and FILE_SHARE_WRITE do
	   NOT result in a STATUS_SHARING_VIOLATION, if another handle is
	   opened for reading/writing metadata only.  In other words, if
	   another handle is open, but does not have the file open with
	   FILE_READ_DATA or FILE_WRITE_DATA, the following NtOpenFile call
	   will succeed.  So, apparently there is no reliable way to find out
	   if a file is already open elsewhere for other purposes than
	   reading and writing data.  */
  status = NtOpenFile (&fh, access, &attr, &io, FILE_SHARE_DELETE, flags);
  /* STATUS_SHARING_VIOLATION is what we expect. STATUS_LOCK_NOT_GRANTED can
     be generated under not quite clear circumstances when trying to open a
     file on NFS with FILE_SHARE_DELETE only.  This has been observed with
     SFU 3.5 if the NFS share has been mounted under a drive letter.  It's
     not generated for all files, but only for some.  If it's generated once
     for a file, it will be generated all the time.  It looks as if wrong file
     state information is stored within the NFS client which never times out.
     Opening the file with FILE_SHARE_VALID_FLAGS will work, though, and it
     is then possible to delete the file quite normally. */
  if (status == STATUS_SHARING_VIOLATION || status == STATUS_LOCK_NOT_GRANTED)
    {
      debug_printf ("Sharing violation when opening %S",
		    pc.get_nt_native_path ());
      /* We never call try_to_bin on NFS and NetApp for the follwing reasons:

	 NFS implements its own mechanism to remove in-use files, which looks
	 quite similar to what we do in try_to_bin for remote files.

	 Netapp filesystems don't understand the "move and delete" method
	 at all and have all kinds of weird effects.  Just setting the delete
	 dispositon usually works fine, though. */
      if (!pc.fs_is_nfs () && !pc.fs_is_netapp ())
	bin_stat = move_to_bin;
      /* If the file is not a directory, of if we didn't set the move_to_bin
	 flag, just proceed with the FILE_SHARE_VALID_FLAGS set. */
      if (!pc.isdir () || bin_stat == dont_move)
	status = NtOpenFile (&fh, access, &attr, &io,
			     FILE_SHARE_VALID_FLAGS, flags);
      else
	{
	  /* Otherwise it's getting tricky.  The directory is opened in some
	     process, so we're supposed to move it to the recycler and mark it
	     for deletion.  But what if the directory is not empty?  The move
	     will work, but the subsequent delete will fail.  So we would
	     have to move it back.  While we do that in try_to_bin, it's bad,
	     because the move results in a temporary inconsistent state.
	     So, we test first if the directory is empty.  If not, we bail
	     out with STATUS_DIRECTORY_NOT_EMPTY.  This avoids most of the
	     problems. */
	  status = NtOpenFile (&fh, access | FILE_LIST_DIRECTORY | SYNCHRONIZE,
			       &attr, &io, FILE_SHARE_VALID_FLAGS,
			       flags | FILE_SYNCHRONOUS_IO_NONALERT);
	  if (NT_SUCCESS (status))
	    {
	      status = check_dir_not_empty (fh, pc);
	      if (!NT_SUCCESS (status))
		{
		  NtClose (fh);
		  if (fh_ro)
		    NtClose (fh_ro);
		  goto out;
		}
	    }
	}
    }
  if (fh_ro)
    NtClose (fh_ro);
  if (!NT_SUCCESS (status))
    {
      if (status == STATUS_DELETE_PENDING)
	{
	  debug_printf ("Delete %S already pending", pc.get_nt_native_path ());
	  status = STATUS_SUCCESS;
	  goto out;
	}
      debug_printf ("Opening %S for delete failed, status = %y",
		    pc.get_nt_native_path (), status);
      goto out;
    }
  /* Try to move to bin if a sharing violation occured.  If that worked,
     we're done. */
  if (bin_stat == move_to_bin
      && (bin_stat = try_to_bin (pc, fh, access, flags)) >= has_been_moved)
    {
      if (bin_stat == has_been_moved)
	status = STATUS_SUCCESS;
      else
	{
	  status = STATUS_DIRECTORY_NOT_EMPTY;
	  NtClose (fh);
	}
      goto out;
    }

try_again:
  /* Try to set delete disposition. */
  status = NtSetInformationFile (fh, &io, &disp, sizeof disp,
				 FileDispositionInformation);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("Setting delete disposition on %S failed, status = %y",
		    pc.get_nt_native_path (), status);
      if (status == STATUS_DIRECTORY_NOT_EMPTY)
	{
	  NTSTATUS status2 = STATUS_SUCCESS;

	  if (!reopened)
	    {
	      /* Have to close and reopen the file from scratch, otherwise
		 we collide with the delete-only sharing mode. */
	      pc.get_object_attr (attr, sec_none_nih);
	      NtClose (fh);
	      status2 = NtOpenFile (&fh, access | FILE_LIST_DIRECTORY
					 | SYNCHRONIZE,
				    &attr, &io, FILE_SHARE_VALID_FLAGS,
				    flags | FILE_SYNCHRONOUS_IO_NONALERT);
	    }
	  if (NT_SUCCESS (status2) && reopened < 20)
	    {
	      /* Workaround rm -r problem:

		 Sometimes a deleted directory lingers in its parent dir
		 after the deleting handle has already been closed.  This
		 can break deleting the parent dir.  See the comment in
		 check_dir_not_empty for more information.

		 What we do here is this:  If check_dir_not_empty returns
		 STATUS_SUCCESS, the dir is either empty, or only inhabited
		 by already deleted entries.  If so, we try to move the dir
		 into the bin.  This usually works.

		 However, if we're on a filesystem which doesn't support
		 the try_to_bin method, or if moving to the bin doesn't work
		 for some reason, just try to delete the directory again,
		 with a very short grace period to free the CPU for a while.
		 This gives the OS time to clean up.  5ms is enough in my
		 testing to make sure that we don't have to try more than
		 once in practically all cases.
		 While this is an extrem bordercase, we don't want to hang
		 infinitely in case a file in the directory is in the "delete
		 pending" state but an application holds an open handle to it
		 for a longer time.  So we don't try this more than 20 times,
		 which means a process time of 100-120ms. */
	      if (check_dir_not_empty (fh, pc) == STATUS_SUCCESS)
		{
		  if (bin_stat == dont_move)
		    {
		      bin_stat = move_to_bin;
		      if (!pc.fs_is_nfs () && !pc.fs_is_netapp ())
			{
			  debug_printf ("Try-to-bin %S",
					pc.get_nt_native_path ());
			  bin_stat = try_to_bin (pc, fh, access, flags);
			}
		    }
		  /* Do NOT handle bin_stat == dir_not_empty here! */
		  if (bin_stat == has_been_moved)
		    status = STATUS_SUCCESS;
		  else
		    {
		      debug_printf ("Try %S again", pc.get_nt_native_path ());
		      ++reopened;
		      Sleep (5L);
		      goto try_again;
		    }
		}
	    }
	  else if (status2 != STATUS_OBJECT_PATH_NOT_FOUND
		   && status2 !=  STATUS_OBJECT_NAME_NOT_FOUND)
	    {
	      fh = NULL;
	      debug_printf ("Opening dir %S for check_dir_not_empty failed, "
			    "status = %y", pc.get_nt_native_path (), status2);
	    }
	  else /* Directory disappeared between NtClose and NtOpenFile. */
	    status = STATUS_SUCCESS;
	}
      /* Trying to delete a hardlink to a file in use by the system in some
	 way (for instance, font files) by setting the delete disposition fails
	 with STATUS_CANNOT_DELETE.  Strange enough, deleting these hardlinks
	 using delete-on-close semantic works... most of the time.

	 Don't use delete-on-close on remote shares.  If two processes
	 have open handles on a file and one of them calls unlink, the
	 file is removed from the remote share even though the other
	 process still has an open handle.  That process than gets Win32
	 error 59, ERROR_UNEXP_NET_ERR when trying to access the file.
	 Microsoft KB 837665 describes this problem as a bug in 2K3, but
	 I have reproduced it on other systems. */
      else if (status == STATUS_CANNOT_DELETE
	       && (!pc.isremote () || pc.fs_is_ncfsd ()))
	{
	  HANDLE fh2;

	  debug_printf ("Cannot delete %S, try delete-on-close",
			pc.get_nt_native_path ());
	  /* Re-open from handle so we open the correct file no matter if it
	     has been moved to the bin or not. */
	  status = NtOpenFile (&fh2, DELETE,
			       pc.init_reopen_attr (attr, fh), &io,
			       bin_stat == move_to_bin ? FILE_SHARE_VALID_FLAGS
						       : FILE_SHARE_DELETE,
			       flags | FILE_DELETE_ON_CLOSE);
	  if (!NT_SUCCESS (status))
	    {
	      debug_printf ("Setting delete-on-close on %S failed, status = %y",
			    pc.get_nt_native_path (), status);
	      /* This is really the last chance.  If it hasn't been moved
		 to the bin already, try it now.  If moving to the bin
		 succeeds, we got rid of the file in some way, even if
		 unlinking didn't work. */
	      if (bin_stat == dont_move)
		bin_stat = try_to_bin (pc, fh, access, flags);
	      if (bin_stat >= has_been_moved)
		status = bin_stat == has_been_moved
				     ? STATUS_SUCCESS
				     : STATUS_DIRECTORY_NOT_EMPTY;
	    }
	  else
	    NtClose (fh2);
	}
    }
  if (fh)
    {
      if (access & FILE_WRITE_ATTRIBUTES)
	{
	  /* Restore R/O attribute if setting the delete disposition failed. */
	  if (!NT_SUCCESS (status))
	    NtSetAttributesFile (fh, pc.file_attributes ());
	  /* If we succeeded, restore R/O attribute to accommodate hardlinks.
	     Only ever try to do this for our own winsymlinks, because there's
	     a problem with setting the delete disposition:
	     http://msdn.microsoft.com/en-us/library/ff545765%28VS.85%29.aspx
	     "Subsequently, the only legal operation by such a caller is
	     to close the open file handle."

	     FIXME? On Vista and later, we could use FILE_HARD_LINK_INFORMATION
	     to find all hardlinks and use one of them to restore the R/O bit,
	     after the NtClose, but before we stop the transaction.  This
	     avoids the aforementioned problem entirely . */
	  else if (pc.is_lnk_symlink () && num_links > 1)
	    NtSetAttributesFile (fh, pc.file_attributes ());
	}

      NtClose (fh);

    }
out:
  /* Stop transaction if we started one. */
  if (trans)
    stop_transaction (status, old_trans, trans);
  syscall_printf ("%S, return status = %y", pc.get_nt_native_path (), status);
  return status;
}

extern "C" int
unlink (const char *ourname)
{
  int res = -1;
  dev_t devn;
  NTSTATUS status;

  path_conv win32_name (ourname, PC_SYM_NOFOLLOW, stat_suffixes);

  if (win32_name.error)
    {
      set_errno (win32_name.error);
      goto done;
    }

  devn = win32_name.get_device ();
  if (isproc_dev (devn))
    {
      set_errno (EROFS);
      goto done;
    }

  if (!win32_name.exists ())
    {
      debug_printf ("unlinking a nonexistent file");
      set_errno (ENOENT);
      goto done;
    }
  else if (win32_name.isdir ())
    {
      debug_printf ("unlinking a directory");
      set_errno (EPERM);
      goto done;
    }

  status = unlink_nt (win32_name);
  if (NT_SUCCESS (status))
    res = 0;
  else
    __seterrno_from_nt_status (status);

 done:
  syscall_printf ("%R = unlink(%s)", res, ourname);
  return res;
}

extern "C" int
_remove_r (struct _reent *, const char *ourname)
{
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW);

  if (win32_name.error)
    {
      set_errno (win32_name.error);
      syscall_printf ("%R = remove(%s)",-1, ourname);
      return -1;
    }

  return win32_name.isdir () ? rmdir (ourname) : unlink (ourname);
}

extern "C" int
remove (const char *ourname)
{
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW);

  if (win32_name.error)
    {
      set_errno (win32_name.error);
      syscall_printf ("-1 = remove (%s)", ourname);
      return -1;
    }

  int res = win32_name.isdir () ? rmdir (ourname) : unlink (ourname);
  syscall_printf ("%R = remove(%s)", res, ourname);
  return res;
}

extern "C" pid_t
getpid ()
{
  syscall_printf ("%d = getpid()", myself->pid);
  return myself->pid;
}

extern "C" pid_t
_getpid_r (struct _reent *)
{
  return getpid ();
}

/* getppid: POSIX 4.1.1.1 */
extern "C" pid_t
getppid ()
{
  syscall_printf ("%d = getppid()", myself->ppid);
  return myself->ppid;
}

/* setsid: POSIX 4.3.2.1 */
extern "C" pid_t
setsid (void)
{
#ifdef NEWVFORK
  vfork_save *vf = vfork_storage.val ();
  /* This is a horrible, horrible kludge */
  if (vf && vf->pid < 0)
    {
      pid_t pid = fork ();
      if (pid > 0)
	{
	  syscall_printf ("longjmping due to vfork");
	  vf->restore_pid (pid);
	}
      /* assuming that fork was successful */
    }
#endif

  if (myself->pgid == myself->pid)
    syscall_printf ("hmm.  pgid %d pid %d", myself->pgid, myself->pid);
  else
    {
      myself->ctty = -2;
      myself->sid = myself->pid;
      myself->pgid = myself->pid;
      if (cygheap->ctty)
	cygheap->close_ctty ();
      syscall_printf ("sid %d, pgid %d, %s", myself->sid, myself->pgid, myctty ());
      return myself->sid;
    }

  set_errno (EPERM);
  return -1;
}

extern "C" pid_t
getsid (pid_t pid)
{
  pid_t res;
  if (!pid)
    res = myself->sid;
  else
    {
      pinfo p (pid);
      if (p)
	res = p->sid;
      else
	{
	  set_errno (ESRCH);
	  res = -1;
	}
    }
  syscall_printf ("%R = getsid(%d)", pid);
  return res;
}

extern "C" ssize_t
read (int fd, void *ptr, size_t len)
{
  size_t res = (size_t) -1;

  pthread_testcancel ();

  __try
    {
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;

      if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}

      /* Could block, so let user know we at least got here.  */
      syscall_printf ("read(%d, %p, %d) %sblocking",
		      fd, ptr, len, cfd->is_nonblocking () ? "non" : "");

      cfd->read (ptr, len);
      res = len;
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%lR = read(%d, %p, %d)", res, fd, ptr, len);
  MALLOC_CHECK;
  return (ssize_t) res;
}

EXPORT_ALIAS (read, _read)

extern "C" ssize_t
readv (int fd, const struct iovec *const iov, const int iovcnt)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      const ssize_t tot = check_iovec_for_read (iov, iovcnt);

      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;

      if (tot <= 0)
	{
	  res = tot;
	  __leave;
	}

      if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}

      /* Could block, so let user know we at least got here.  */
      syscall_printf ("readv(%d, %p, %d) %sblocking",
		      fd, iov, iovcnt, cfd->is_nonblocking () ? "non" : "");

      res = cfd->readv (iov, iovcnt, tot);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%lR = readv(%d, %p, %d)", res, fd, iov, iovcnt);
  MALLOC_CHECK;
  return res;
}

extern "C" ssize_t
pread (int fd, void *ptr, size_t len, off_t off)
{
  ssize_t res;

  pthread_testcancel ();

  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
  else
    res = cfd->pread (ptr, len, off);

  syscall_printf ("%lR = pread(%d, %p, %d, %d)", res, fd, ptr, len, off);
  return res;
}

extern "C" ssize_t
write (int fd, const void *ptr, size_t len)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;

      if ((cfd->get_flags () & O_ACCMODE) == O_RDONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}

      /* Could block, so let user know we at least got here.  */
      if (fd == 1 || fd == 2)
	paranoid_printf ("write(%d, %p, %d)", fd, ptr, len);
      else
	syscall_printf  ("write(%d, %p, %d)", fd, ptr, len);

      res = cfd->write (ptr, len);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%lR = write(%d, %p, %d)", res, fd, ptr, len);
  MALLOC_CHECK;
  return res;
}

EXPORT_ALIAS (write, _write)

extern "C" ssize_t
writev (const int fd, const struct iovec *const iov, const int iovcnt)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      const ssize_t tot = check_iovec_for_write (iov, iovcnt);

      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;

      if (tot <= 0)
	{
	  res = tot;
	  __leave;
	}

      if ((cfd->get_flags () & O_ACCMODE) == O_RDONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}

      /* Could block, so let user know we at least got here.  */
      if (fd == 1 || fd == 2)
	paranoid_printf ("writev(%d, %p, %d)", fd, iov, iovcnt);
      else
	syscall_printf  ("writev(%d, %p, %d)", fd, iov, iovcnt);

      res = cfd->writev (iov, iovcnt, tot);
    }
  __except (EFAULT) {}
  __endtry
  if (fd == 1 || fd == 2)
    paranoid_printf ("%lR = writev(%d, %p, %d)", res, fd, iov, iovcnt);
  else
    syscall_printf ("%lR = writev(%d, %p, %d)", res, fd, iov, iovcnt);
  MALLOC_CHECK;
  return res;
}

extern "C" ssize_t
pwrite (int fd, void *ptr, size_t len, off_t off)
{
  pthread_testcancel ();

  ssize_t res;
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
  else
    res = cfd->pwrite (ptr, len, off);

  syscall_printf ("%lR = pwrite(%d, %p, %d, %d)", res, fd, ptr, len, off);
  return res;
}

/* _open */
/* newlib's fcntl.h defines _open as taking variable args so we must
   correspond.  The third arg if it exists is: mode_t mode. */
extern "C" int
open (const char *unix_path, int flags, ...)
{
  int res = -1;
  va_list ap;
  mode_t mode = 0;

  pthread_testcancel ();

  __try
    {
      syscall_printf ("open(%s, %y)", unix_path, flags);
      if (!*unix_path)
	set_errno (ENOENT);
      else
	{
	  /* check for optional mode argument */
	  va_start (ap, flags);
	  mode = va_arg (ap, mode_t);
	  va_end (ap);

	  fhandler_base *fh;
	  cygheap_fdnew fd;

	  if (fd >= 0)
	    {
	      /* This is a temporary kludge until all utilities can catch up
		 with a change in behavior that implements linux functionality: 
		 opening a tty should not automatically cause it to become the
		 controlling tty for the process.  */
	      int opt = PC_OPEN | ((flags & (O_NOFOLLOW | O_EXCL))
				   ?  PC_SYM_NOFOLLOW : PC_SYM_FOLLOW);
	      if (!(flags & O_NOCTTY) && fd > 2 && myself->ctty != -2)
		{
		  flags |= O_NOCTTY;
		  /* flag that, if opened, this fhandler could later be capable
		     of being a controlling terminal if /dev/tty is opened. */
		  opt |= PC_CTTY;
		}
	      if (!(fh = build_fh_name (unix_path, opt, stat_suffixes)))
		;		// errno already set
	      else if ((flags & O_NOFOLLOW) && fh->issymlink ())
		{
		  delete fh;
		  set_errno (ELOOP);
		}
	      else if ((flags & O_DIRECTORY) && fh->exists ()
		       && !fh->pc.isdir ())
		{
		  delete fh;
		  set_errno (ENOTDIR);
		}
	      else if (((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
		       && fh->exists ())
		{
		  delete fh;
		  set_errno (EEXIST);
		}
	      else if ((fh->is_fs_special ()
	      		&& fh->device_access_denied (flags))
		       || !fh->open_with_arch (flags, (mode & 07777)
						      & ~cygheap->umask))
		delete fh;
	      else
		{
		  fd = fh;
		  if (fd <= 2)
		    set_std_handle (fd);
		  res = fd;
		}
	    }
	}

      syscall_printf ("%R = open(%s, %y)", res, unix_path, flags);
    }
  __except (EFAULT) {}
  __endtry
  return res;
}

EXPORT_ALIAS (open, _open )
EXPORT_ALIAS (open, _open64 )

extern "C" off_t
lseek64 (int fd, off_t pos, int dir)
{
  off_t res;

  if (dir != SEEK_SET && dir != SEEK_CUR && dir != SEEK_END)
    {
      set_errno (EINVAL);
      res = -1;
    }
  else
    {
      cygheap_fdget cfd (fd);
      if (cfd >= 0)
	res = cfd->lseek (pos, dir);
      else
	res = -1;
    }
  /* Can't use %R/%lR here since res is always 8 bytes */
  syscall_printf (res == -1 ? "%D = lseek(%d, %D, %d), errno %d"
			    : "%D = lseek(%d, %D, %d)",
		  res, fd, pos, dir, get_errno ());

  return res;
}

EXPORT_ALIAS (lseek64, _lseek64)

#ifdef __x86_64__
EXPORT_ALIAS (lseek64, lseek)
EXPORT_ALIAS (lseek64, _lseek)
#else
extern "C" _off_t
lseek (int fd, _off_t pos, int dir)
{
  return lseek64 (fd, (off_t) pos, dir);
}
EXPORT_ALIAS (lseek, _lseek)
#endif


extern "C" int
close (int fd)
{
  int res;

  syscall_printf ("close(%d)", fd);

  pthread_testcancel ();

  MALLOC_CHECK;
  cygheap_fdget cfd (fd, true);
  if (cfd < 0)
    res = -1;
  else
    {
      cfd->isclosed (true);
      res = cfd->close_with_arch ();
      cfd.release ();
    }

  syscall_printf ("%R = close(%d)", res, fd);
  MALLOC_CHECK;
  return res;
}

EXPORT_ALIAS (close, _close)

extern "C" int
isatty (int fd)
{
  int res;

  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = 0;
  else
    res = cfd->is_tty ();
  syscall_printf ("%R = isatty(%d)", res, fd);
  return res;
}
EXPORT_ALIAS (isatty, _isatty)

extern "C" int
link (const char *oldpath, const char *newpath)
{
  int res = -1;
  fhandler_base *fh;

  if (!(fh = build_fh_name (oldpath, PC_SYM_NOFOLLOW | PC_KEEP_HANDLE,
			    stat_suffixes)))
    goto error;

  if (fh->error ())
    {
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
    }
  else if (fh->pc.isdir ())
    set_errno (EPERM); /* We do not permit linking directories.  */
  else if (!fh->pc.exists ())
    set_errno (ENOENT);
  else
    res = fh->link (newpath);

  delete fh;
 error:
  syscall_printf ("%R = link(%s, %s)", res, oldpath, newpath);
  return res;
}

/* chown: POSIX 5.6.5.1 */
/*
 * chown () is only implemented for Windows NT.  Under other operating
 * systems, it is only a stub that always returns zero.
 */
static int
chown_worker (const char *name, unsigned fmode, uid_t uid, gid_t gid)
{
  int res = -1;
  fhandler_base *fh;

  if (!(fh = build_fh_name (name, fmode, stat_suffixes)))
    goto error;

  if (fh->error ())
    {
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
    }
  else
    res = fh->fchown (uid, gid);

  delete fh;
 error:
  syscall_printf ("%R = %schown(%s,...)",
		  res, (fmode & PC_SYM_NOFOLLOW) ? "l" : "", name);
  return res;
}

extern "C" int
chown32 (const char * name, uid_t uid, gid_t gid)
{
  return chown_worker (name, PC_SYM_FOLLOW, uid, gid);
}

#ifdef __x86_64__
EXPORT_ALIAS (chown32, chown)
#else
extern "C" int
chown (const char * name, __uid16_t uid, __gid16_t gid)
{
  return chown_worker (name, PC_SYM_FOLLOW,
		       uid16touid32 (uid), gid16togid32 (gid));
}
#endif

extern "C" int
lchown32 (const char * name, uid_t uid, gid_t gid)
{
  return chown_worker (name, PC_SYM_NOFOLLOW, uid, gid);
}

#ifdef __x86_64__
EXPORT_ALIAS (lchown32, lchown)
#else
extern "C" int
lchown (const char * name, __uid16_t uid, __gid16_t gid)
{
  return chown_worker (name, PC_SYM_NOFOLLOW,
		       uid16touid32 (uid), gid16togid32 (gid));
}
#endif

extern "C" int
fchown32 (int fd, uid_t uid, gid_t gid)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    {
      syscall_printf ("-1 = fchown (%d,...)", fd);
      return -1;
    }

  int res = cfd->fchown (uid, gid);

  syscall_printf ("%R = fchown(%s,...)", res, cfd->get_name ());
  return res;
}

#ifdef __x86_64__
EXPORT_ALIAS (fchown32, fchown)
#else
extern "C" int
fchown (int fd, __uid16_t uid, __gid16_t gid)
{
  return fchown32 (fd, uid16touid32 (uid), gid16togid32 (gid));
}
#endif

/* umask: POSIX 5.3.3.1 */
extern "C" mode_t
umask (mode_t mask)
{
  mode_t oldmask;

  oldmask = cygheap->umask;
  cygheap->umask = mask & 0777;
  return oldmask;
}

int
chmod_device (path_conv& pc, mode_t mode)
{
  return mknod_worker (pc.get_win32 (), pc.dev.mode & S_IFMT, mode, pc.dev.get_major (), pc.dev.get_minor ());
}

#define FILTERED_MODE(m)	((m) & (S_ISUID | S_ISGID | S_ISVTX \
					| S_IRWXU | S_IRWXG | S_IRWXO))

/* chmod: POSIX 5.6.4.1 */
extern "C" int
chmod (const char *path, mode_t mode)
{
  int res = -1;
  fhandler_base *fh;
  if (!(fh = build_fh_name (path, PC_SYM_FOLLOW, stat_suffixes)))
    goto error;

  if (fh->error ())
    {
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
    }
  else
    res = fh->fchmod (FILTERED_MODE (mode));

  delete fh;
 error:
  syscall_printf ("%R = chmod(%s, 0%o)", res, path, mode);
  return res;
}

/* fchmod: P96 5.6.4.1 */

extern "C" int
fchmod (int fd, mode_t mode)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    {
      syscall_printf ("-1 = fchmod (%d, 0%o)", fd, mode);
      return -1;
    }

  return cfd->fchmod (FILTERED_MODE (mode));
}

#ifndef __x86_64__
static void
stat64_to_stat32 (struct stat *src, struct __stat32 *dst)
{
  dst->st_dev = ((src->st_dev >> 8) & 0xff00) | (src->st_dev & 0xff);
  dst->st_ino = ((unsigned) (src->st_ino >> 32)) | (unsigned) src->st_ino;
  dst->st_mode = src->st_mode;
  dst->st_nlink = src->st_nlink;
  dst->st_uid = src->st_uid;
  dst->st_gid = src->st_gid;
  dst->st_rdev = ((src->st_rdev >> 8) & 0xff00) | (src->st_rdev & 0xff);
  dst->st_size = src->st_size;
  dst->st_atim = src->st_atim;
  dst->st_mtim = src->st_mtim;
  dst->st_ctim = src->st_ctim;
  dst->st_blksize = src->st_blksize;
  dst->st_blocks = src->st_blocks;
}
#endif

static struct stat dev_st;
static bool dev_st_inited;

void
fhandler_base::stat_fixup (struct stat *buf)
{
  /* For devices, set inode number to device number.  This gives us a valid,
     unique inode number without having to call hash_path_name.  /dev/tty needs
     a bit of persuasion to get the same st_ino value in stat and fstat. */
  if (!buf->st_ino)
    {
      if (get_major () == DEV_VIRTFS_MAJOR)
	buf->st_ino = get_ino ();
      else if (dev () == FH_TTY ||
	       ((get_major () == DEV_PTYS_MAJOR
		 || get_major () == DEV_CONS_MAJOR)
		&& !strcmp (get_name (), "/dev/tty")))
	buf->st_ino = FH_TTY;
      else
	buf->st_ino = get_device ();
      	
    }
  /* For /dev-based devices, st_dev must be set to the device number of /dev,
     not it's own device major/minor numbers.  What we do here to speed up
     the process is to fetch the device number of /dev only once, liberally
     assuming that /dev doesn't change over the lifetime of a process. */
  if (!buf->st_dev)
    {
      if (dev ().is_dev_resident ())
	{
	  if (!dev_st_inited)
	    {
	      stat64 ("/dev", &dev_st);
	      dev_st_inited = true;
	    }
	  buf->st_dev = dev_st.st_dev;
	}
      else
	buf->st_dev = get_device ();
    }
  /* Only set st_rdev if it's a device. */
  if (!buf->st_rdev && get_major () != DEV_VIRTFS_MAJOR)
    {
      buf->st_rdev = get_device ();
      /* consX, console, conin, and conout point to the same device.
	 Make sure the link count is correct. */
      if (buf->st_rdev == (dev_t) myself->ctty && iscons_dev (myself->ctty))
	buf->st_nlink = 4;
      /* CD-ROM drives have two links, /dev/srX and /dev/scdX. */
      else if (gnu_dev_major (buf->st_rdev) == DEV_CDROM_MAJOR)
	buf->st_nlink = 2;
    }
}

extern "C" int
fstat64 (int fd, struct stat *buf)
{
  int res;

  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
  else
    {
      memset (buf, 0, sizeof (struct stat));
      res = cfd->fstat (buf);
      if (!res)
	cfd->stat_fixup (buf);
    }

  syscall_printf ("%R = fstat(%d, %p)", res, fd, buf);
  return res;
}

extern "C" int
_fstat64_r (struct _reent *ptr, int fd, struct stat *buf)
{
  int ret;

  if ((ret = fstat64 (fd, buf)) == -1)
    ptr->_errno = get_errno ();
  return ret;
}

#ifdef __x86_64__
EXPORT_ALIAS (fstat64, fstat)
EXPORT_ALIAS (_fstat64_r, _fstat_r)
#else
extern "C" int
fstat (int fd, struct stat *buf)
{
  struct stat buf64;
  int ret = fstat64 (fd, &buf64);
  if (!ret)
    stat64_to_stat32 (&buf64, (struct __stat32 *) buf);
  return ret;
}

extern "C" int
_fstat_r (struct _reent *ptr, int fd, struct stat *buf)
{
  int ret;

  if ((ret = fstat (fd, buf)) == -1)
    ptr->_errno = get_errno ();
  return ret;
}
#endif

/* fsync: P96 6.6.1.1 */
extern "C" int
fsync (int fd)
{
  pthread_testcancel ();
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    {
      syscall_printf ("-1 = fsync (%d)", fd);
      return -1;
    }
  return cfd->fsync ();
}

EXPORT_ALIAS (fsync, fdatasync)

static void
sync_worker (HANDLE dir, USHORT len, LPCWSTR vol)
{
  NTSTATUS status;
  HANDLE fh;
  IO_STATUS_BLOCK io;
  OBJECT_ATTRIBUTES attr;
  UNICODE_STRING uvol = { len, len, (WCHAR *) vol };

  InitializeObjectAttributes (&attr, &uvol, OBJ_CASE_INSENSITIVE, dir, NULL);
  status = NtOpenFile (&fh, GENERIC_WRITE, &attr, &io,
		       FILE_SHARE_VALID_FLAGS, 0);
  if (!NT_SUCCESS (status))
    debug_printf ("NtOpenFile (%S), status %y", &uvol, status);
  else
    {
      status = NtFlushBuffersFile (fh, &io);
      if (!NT_SUCCESS (status))
	debug_printf ("NtFlushBuffersFile (%S), status %y", &uvol, status);
      NtClose (fh);
    }
}

/* sync: SUSv3 */
extern "C" void
sync ()
{
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;
  HANDLE devhdl;
  UNICODE_STRING device;

  /* Open \Device object directory. */
  RtlInitUnicodeString (&device, L"\\Device");
  InitializeObjectAttributes (&attr, &device, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenDirectoryObject (&devhdl, DIRECTORY_QUERY, &attr);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtOpenDirectoryObject, status %y", status);
      return;
    }
  /* Traverse \Device directory ... */
  PDIRECTORY_BASIC_INFORMATION dbi = (PDIRECTORY_BASIC_INFORMATION)
				     alloca (640);
  BOOLEAN restart = TRUE;
  ULONG context = 0;
  while (NT_SUCCESS (NtQueryDirectoryObject (devhdl, dbi, 640, TRUE, restart,
					     &context, NULL)))
    {
      restart = FALSE;
      /* ... and call sync_worker for each HarddiskVolumeX entry. */
      if (dbi->ObjectName.Length >= 15 * sizeof (WCHAR)
	  && !wcsncasecmp (dbi->ObjectName.Buffer, L"HarddiskVolume", 14)
	  && iswdigit (dbi->ObjectName.Buffer[14]))
	sync_worker (devhdl, dbi->ObjectName.Length, dbi->ObjectName.Buffer);
    }
  NtClose (devhdl);
}

/* Cygwin internal */
int __reg2
stat_worker (path_conv &pc, struct stat *buf)
{
  int res = -1;

  __try
    {
      if (pc.error)
	{
	  debug_printf ("got %d error from path_conv", pc.error);
	  set_errno (pc.error);
	}
      else if (pc.exists ())
	{
	  fhandler_base *fh;

	  if (!(fh = build_fh_pc (pc)))
	    __leave;

	  debug_printf ("(%S, %p, %p), file_attributes %d",
			pc.get_nt_native_path (), buf, fh, (DWORD) *fh);
	  memset (buf, 0, sizeof (*buf));
	  res = fh->fstat (buf);
	  if (!res)
	    fh->stat_fixup (buf);
	  delete fh;
	}
      else
	set_errno (ENOENT);
    }
  __except (EFAULT) {}
  __endtry
  MALLOC_CHECK;
  syscall_printf ("%d = (%S,%p)", res, pc.get_nt_native_path (), buf);
  return res;
}

extern "C" int
stat64 (const char *__restrict name, struct stat *__restrict buf)
{
  syscall_printf ("entering");
  path_conv pc (name, PC_SYM_FOLLOW | PC_POSIX | PC_KEEP_HANDLE,
		stat_suffixes);
  return stat_worker (pc, buf);
}

extern "C" int
_stat64_r (struct _reent *__restrict ptr, const char *__restrict name,
	   struct stat *buf)
{
  int ret;

  if ((ret = stat64 (name, buf)) == -1)
    ptr->_errno = get_errno ();
  return ret;
}

#ifdef __x86_64__
EXPORT_ALIAS (stat64, stat)
EXPORT_ALIAS (_stat64_r, _stat_r)
#else
extern "C" int
stat (const char *__restrict name, struct stat *__restrict buf)
{
  struct stat buf64;
  int ret = stat64 (name, &buf64);
  if (!ret)
    stat64_to_stat32 (&buf64, (struct __stat32 *) buf);
  return ret;
}

extern "C" int
_stat_r (struct _reent *__restrict ptr, const char *__restrict name,
	 struct stat *__restrict buf)
{
  int ret;

  if ((ret = stat (name, buf)) == -1)
    ptr->_errno = get_errno ();
  return ret;
}
#endif

/* lstat: Provided by SVR4 and 4.3+BSD, POSIX? */
extern "C" int
lstat64 (const char *__restrict name, struct stat *__restrict buf)
{
  syscall_printf ("entering");
  path_conv pc (name, PC_SYM_NOFOLLOW | PC_POSIX | PC_KEEP_HANDLE,
		stat_suffixes);
  return stat_worker (pc, buf);
}

#ifdef __x86_64__
EXPORT_ALIAS (lstat64, lstat)
#else
/* lstat: Provided by SVR4 and 4.3+BSD, POSIX? */
extern "C" int
lstat (const char *__restrict name, struct stat *__restrict buf)
{
  struct stat buf64;
  int ret = lstat64 (name, &buf64);
  if (!ret)
    stat64_to_stat32 (&buf64, (struct __stat32 *) buf);
  return ret;
}
#endif

extern "C" int
access (const char *fn, int flags)
{
  // flags were incorrectly specified
  int res = -1;
  if (flags & ~(F_OK|R_OK|W_OK|X_OK))
    set_errno (EINVAL);
  else
    {
      fhandler_base *fh = build_fh_name (fn, PC_SYM_FOLLOW | PC_KEEP_HANDLE,
					 stat_suffixes);
      if (fh)
	{
	  res =  fh->fhaccess (flags, false);
	  delete fh;
	}
    }
  debug_printf ("returning %d", res);
  return res;
}

/* Linux provides this extension; it is basically a wrapper around the
   POSIX:2008 faccessat (AT_FDCWD, fn, flags, AT_EACCESS).  We also
   provide eaccess as an alias for this, in cygwin.din.  */
extern "C" int
euidaccess (const char *fn, int flags)
{
  // flags were incorrectly specified
  int res = -1;
  if (flags & ~(F_OK|R_OK|W_OK|X_OK))
    set_errno (EINVAL);
  else
    {
      fhandler_base *fh = build_fh_name (fn, PC_SYM_FOLLOW | PC_KEEP_HANDLE,
					 stat_suffixes);
      if (fh)
	{
	  res =  fh->fhaccess (flags, true);
	  delete fh;
	}
    }
  debug_printf ("returning %d", res);
  return res;
}

static void
rename_append_suffix (path_conv &pc, const char *path, size_t len,
		      const char *suffix)
{
  char buf[len + 5];

  if (ascii_strcasematch (path + len - 4, ".lnk")
      || ascii_strcasematch (path + len - 4, ".exe"))
    len -= 4;
  stpcpy (stpncpy (buf, path, len), suffix);
  pc.check (buf, PC_SYM_NOFOLLOW);
}

/* This function tests if a filename has one of the "approved" executable
   suffix.  This list is probably not complete... */
static inline bool
nt_path_has_executable_suffix (PUNICODE_STRING upath)
{
  static const PUNICODE_STRING blessed_executable_suffixes[] =
  {
    &ro_u_com,
    &ro_u_dll,	/* Messy, messy.  Per MSDN, the GetBinaryType function is
		   supposed to return with ERROR_BAD_EXE_FORMAT. if the file
		   is a DLL.  On 64-bit Windows, this works as expected for
		   32-bit and 64-bit DLLs.  On 32-bit Windows this only works
		   for 32-bit DLLs.  For 64-bit DLLs, 32-bit Windows returns
		   true with the type set to SCS_64BIT_BINARY. */
    &ro_u_exe,
    &ro_u_scr,
    &ro_u_sys,
    NULL
  };

  USHORT pos = upath->Length / sizeof (WCHAR);
  PWCHAR path;
  UNICODE_STRING usuf;
  const PUNICODE_STRING *suf;

  /* Too short for a native path? */
  if (pos < 8)
    return false;
  /* Assumption: All executable suffixes have a length of three. */
  path = upath->Buffer + pos - 4;
  if (*path != L'.')
    return false;
  RtlInitCountedUnicodeString (&usuf, path, 4 * sizeof (WCHAR));
  for (suf = blessed_executable_suffixes; *suf; ++suf)
    if (RtlEqualUnicodeString (&usuf, *suf, TRUE))
      return true;
  return false;
}

extern "C" int
rename (const char *oldpath, const char *newpath)
{
  tmp_pathbuf tp;
  int res = -1;
  path_conv oldpc, newpc, new2pc, *dstpc, *removepc = NULL;
  bool old_dir_requested = false, new_dir_requested = false;
  bool old_explicit_suffix = false, new_explicit_suffix = false;
  size_t olen, nlen;
  bool equal_path;
  NTSTATUS status = STATUS_SUCCESS;
  HANDLE fh = NULL, nfh;
  HANDLE old_trans = NULL, trans = NULL;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  FILE_STANDARD_INFORMATION ofsi;
  PFILE_RENAME_INFORMATION pfri;

  __try
    {
      if (!*oldpath || !*newpath)
	{
	  /* Reject rename("","x"), rename("x","").  */
	  set_errno (ENOENT);
	  __leave;
	}
      if (has_dot_last_component (oldpath, true))
	{
	  /* Reject rename("dir/.","x").  */
	  oldpc.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	  set_errno (oldpc.isdir () ? EINVAL : ENOTDIR);
	  __leave;
	}
      if (has_dot_last_component (newpath, true))
	{
	  /* Reject rename("dir","x/.").  */
	  newpc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
	  set_errno (!newpc.exists () ? ENOENT
				      : newpc.isdir () ? EINVAL : ENOTDIR);
	  __leave;
	}

      /* A trailing slash requires that the pathname points to an existing
	 directory.  If it's not, it's a ENOTDIR condition.  The same goes
	 for newpath a bit further down this function. */
      olen = strlen (oldpath);
      if (isdirsep (oldpath[olen - 1]))
	{
	  char *buf;
	  char *p = stpcpy (buf = tp.c_get (), oldpath) - 1;
	  oldpath = buf;
	  while (p >= oldpath && isdirsep (*p))
	    *p-- = '\0';
	  olen = p + 1 - oldpath;
	  if (!olen)
	    {
	      /* The root directory cannot be renamed.  This also rejects
		 the corner case of rename("/","/"), even though it is the
		 same file.  */
	      set_errno (EINVAL);
	      __leave;
	    }
	  old_dir_requested = true;
	}
      oldpc.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
      if (oldpc.error)
	{
	  set_errno (oldpc.error);
	  __leave;
	}
      if (!oldpc.exists ())
	{
	  set_errno (ENOENT);
	  __leave;
	}
      if (oldpc.isspecial () && !oldpc.issocket () && !oldpc.is_fs_special ())
	{
	  /* No renames from virtual FS */
	  set_errno (EROFS);
	  __leave;
	}
      if (oldpc.has_attribute (FILE_ATTRIBUTE_REPARSE_POINT)
	  && !oldpc.issymlink ())
	{
	  /* Volume mount point.  If we try to rename a volume mount point, NT
	     returns STATUS_NOT_SAME_DEVICE ==> Win32 ERROR_NOT_SAME_DEVICE ==>
	     errno EXDEV.  That's bad since mv(1) will now perform a
	     cross-device move.  So what we do here is to treat the volume
	     mount point just like Linux treats a mount point. */
	  set_errno (EBUSY);
	  __leave;
	}
      if (old_dir_requested && !oldpc.isdir ())
	{
	  /* Reject rename("file/","x").  */
	  set_errno (ENOTDIR);
	  __leave;
	}
      if (oldpc.known_suffix ()
	   && (ascii_strcasematch (oldpath + olen - 4, ".lnk")
	       || ascii_strcasematch (oldpath + olen - 4, ".exe")))
	old_explicit_suffix = true;

      nlen = strlen (newpath);
      if (isdirsep (newpath[nlen - 1]))
	{
	  char *buf;
	  char *p = stpcpy (buf = tp.c_get (), newpath) - 1;
	  newpath = buf;
	  while (p >= newpath && isdirsep (*p))
	    *p-- = '\0';
	  nlen = p + 1 - newpath;
	  if (!nlen) /* The root directory is never empty.  */
	    {
	      set_errno (ENOTEMPTY);
	      __leave;
	    }
	  new_dir_requested = true;
	}
      newpc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
      if (newpc.error)
	{
	  set_errno (newpc.error);
	  __leave;
	}
      if (newpc.isspecial () && !newpc.issocket ())
	{
	  /* No renames to virtual FSes */
	  set_errno (EROFS);
	  __leave;
	}
      if (new_dir_requested && !(newpc.exists ()
				 ? newpc.isdir () : oldpc.isdir ()))
	{
	  /* Reject rename("file1","file2/"), but allow rename("dir","d/").  */
	  set_errno (newpc.exists () ? ENOTDIR : ENOENT);
	  __leave;
	}
      if (newpc.exists ()
	  && (oldpc.isdir () ? !newpc.isdir () : newpc.isdir ()))
	{
	  /* Reject rename("file","dir") and rename("dir","file").  */
	  set_errno (newpc.isdir () ? EISDIR : ENOTDIR);
	  __leave;
	}
      if (newpc.known_suffix ()
	  && (ascii_strcasematch (newpath + nlen - 4, ".lnk")
	      || ascii_strcasematch (newpath + nlen - 4, ".exe")))
	new_explicit_suffix = true;

      /* This test is necessary in almost every case, so do it once here. */
      equal_path = RtlEqualUnicodeString (oldpc.get_nt_native_path (),
					  newpc.get_nt_native_path (),
					  oldpc.objcaseinsensitive ());

      /* First check if oldpath and newpath only differ by case.  If so, it's
	 just a request to change the case of the filename.  By simply setting
	 the file attributes to INVALID_FILE_ATTRIBUTES (which translates to
	 "file doesn't exist"), all later tests are skipped. */
      if (oldpc.objcaseinsensitive () && newpc.exists () && equal_path
	  && old_explicit_suffix == new_explicit_suffix)
	{
	  if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
				     newpc.get_nt_native_path (),
				     FALSE))
	    {
	      res = 0;
	      __leave;
	    }
	  newpc.file_attributes (INVALID_FILE_ATTRIBUTES);
	}
      else if (oldpc.isdir ())
	{
	  /* Check for newpath being identical or a subdir of oldpath. */
	  if (RtlPrefixUnicodeString (oldpc.get_nt_native_path (),
				      newpc.get_nt_native_path (),
				      TRUE))
	    {
	      if (newpc.get_nt_native_path ()->Length
		  == oldpc.get_nt_native_path ()->Length)
		{
		  res = 0;
		  __leave;
		}
	      if (*(PWCHAR) ((PBYTE) newpc.get_nt_native_path ()->Buffer
			     + oldpc.get_nt_native_path ()->Length) == L'\\')
		{
		  set_errno (EINVAL);
		  __leave;
		}
	    }
	}
      else if (!newpc.exists ())
	{
	  if (equal_path && old_explicit_suffix != new_explicit_suffix)
	    {
	      newpc.check (newpath, PC_SYM_NOFOLLOW);
	      if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
					 newpc.get_nt_native_path (),
					 oldpc.objcaseinsensitive ()))
		{
		  res = 0;
		  __leave;
		}
	    }
	  else if (oldpc.is_lnk_special ()
		   && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
						  &ro_u_lnk, TRUE))
	    rename_append_suffix (newpc, newpath, nlen, ".lnk");
	  else if (oldpc.is_binary () && !old_explicit_suffix
		   && oldpc.known_suffix ()
		   && !nt_path_has_executable_suffix
		   				(newpc.get_nt_native_path ()))
	    /* Never append .exe suffix if oldpath had .exe suffix given
	       explicitely, or if oldpath wasn't already a .exe file, or
	       if the destination filename has one of the blessed executable
	       suffixes.
	       Note: To rename an executable foo.exe to bar-without-suffix,
	       the .exe suffix must be given explicitly in oldpath. */
	    rename_append_suffix (newpc, newpath, nlen, ".exe");
	}
      else
	{
	  if (equal_path && old_explicit_suffix != new_explicit_suffix)
	    {
	      newpc.check (newpath, PC_SYM_NOFOLLOW);
	      if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
					 newpc.get_nt_native_path (),
					 oldpc.objcaseinsensitive ()))
		{
		  res = 0;
		  __leave;
		}
	    }
	  else if (oldpc.is_lnk_special ())
	    {
	      if (!newpc.is_lnk_special ()
		  && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
						 &ro_u_lnk, TRUE))
		{
		  rename_append_suffix (new2pc, newpath, nlen, ".lnk");
		  removepc = &newpc;
		}
	    }
	  else if (oldpc.is_binary ())
	    {
	      /* Never append .exe suffix if oldpath had .exe suffix given
		 explicitely, or if newfile is a binary (in which case the given
		 name probably makes sense as it is), or if the destination
		 filename has one of the blessed executable suffixes. */
	      if (!old_explicit_suffix && oldpc.known_suffix ()
		  && !newpc.is_binary ()
		  && !nt_path_has_executable_suffix
		  				(newpc.get_nt_native_path ()))
		{
		  rename_append_suffix (new2pc, newpath, nlen, ".exe");
		  removepc = &newpc;
		}
	    }
	  else
	    {
	      /* If the new path is an existing .lnk symlink or a .exe file,
		 but the new path has not been specified with explicit suffix,
		 rename to the new name without suffix, as expected, but also
		 remove the clashing symlink or executable.  Did I ever mention
		 how I hate the file suffix idea? */
	      if ((newpc.is_lnk_special ()
		   || RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
						 &ro_u_exe, TRUE))
		  && !new_explicit_suffix)
		{
		  new2pc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
		  newpc.get_nt_native_path ()->Length -= 4 * sizeof (WCHAR);
		  if (new2pc.is_binary () || new2pc.is_lnk_special ())
		    removepc = &new2pc;
		}
	    }
	}
      dstpc = (removepc == &newpc) ? &new2pc : &newpc;

      /* Check cross-device before touching anything.  Otherwise we might end
	 up with an unlinked target dir even if the actual rename didn't work.*/
      if (oldpc.fs_type () != dstpc->fs_type ()
	  || oldpc.fs_serial_number () != dstpc->fs_serial_number ())
	{
	  set_errno (EXDEV);
	  __leave;
	}

      /* Opening the file must be part of the transaction.  It's not sufficient
	 to call only NtSetInformationFile under the transaction.  Therefore we
	 have to start the transaction here, if necessary. */
      if (wincap.has_transactions ()
	  && (dstpc->fs_flags () & FILE_SUPPORTS_TRANSACTIONS)
	  && (dstpc->isdir ()
	      || (!removepc && dstpc->has_attribute (FILE_ATTRIBUTE_READONLY))))
	start_transaction (old_trans, trans);

      int retry_count;
      retry_count = 0;
    retry:
      /* Talking about inconsistent behaviour...
	 - DELETE is required to rename a file.  So far, so good.
	 - At least one cifs FS (Tru64) needs FILE_READ_ATTRIBUTE, otherwise the
	   FileRenameInformation call fails with STATUS_ACCESS_DENIED.  However,
	   on NFS we get a STATUS_ACCESS_DENIED if FILE_READ_ATTRIBUTE is used
	   and the file we try to rename is a symlink.  Urgh.
	 - Samba (only some versions?) doesn't like the FILE_SHARE_DELETE
	   mode if the file has the R/O attribute set and returns
	   STATUS_ACCESS_DENIED in that case. */
      {
	ULONG access = DELETE
		       | (oldpc.fs_is_cifs () ? FILE_READ_ATTRIBUTES : 0);
	ULONG sharing = FILE_SHARE_READ | FILE_SHARE_WRITE
			| (oldpc.fs_is_samba () ? 0 : FILE_SHARE_DELETE);
	ULONG flags = FILE_OPEN_FOR_BACKUP_INTENT
		      | (oldpc.is_rep_symlink () ? FILE_OPEN_REPARSE_POINT : 0);
	status = NtOpenFile (&fh, access,
			     oldpc.get_object_attr (attr, sec_none_nih),
			     &io, sharing, flags);
      }
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("status %y", status);
	  if (status == STATUS_SHARING_VIOLATION
	      && cygwait (10L) != WAIT_SIGNALED)
	    {
	      /* Typical BLODA problem.  Some virus scanners check newly
		 generated files and while doing that disallow DELETE access.
		 That's really bad because it breaks applications which copy
		 files by creating a temporary filename and then rename the
		 temp filename to the target filename.  This renaming fails due
		 to the jealous virus scanner and the application fails to
		 create the target file.

		 This kludge tries to work around that by yielding until the
		 sharing violation goes away, or a signal arrived, or after
		 about a second, give or take. */
	      if (++retry_count < 40)
		{
		  yield ();
		  goto retry;
		}
	    }
	  else if (NT_TRANSACTIONAL_ERROR (status) && trans)
	    {
	      /* If NtOpenFile fails due to transactional problems, stop
		 transaction and go ahead without. */
	      stop_transaction (status, old_trans, trans);
	      debug_printf ("Transaction failure.  Retry open.");
	      goto retry;
	    }
	  __seterrno_from_nt_status (status);
	  __leave;
	}

      /* Renaming a dir to another, existing dir fails always, even if
	 ReplaceIfExists is set to TRUE and the existing dir is empty.  So
	 we have to remove the destination dir first.  This also covers the
	 case that the destination directory is not empty.  In that case,
	 unlink_nt returns with STATUS_DIRECTORY_NOT_EMPTY. */
      if (dstpc->isdir ())
	{
	  status = unlink_nt (*dstpc);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	}
      /* You can't copy a file if the destination exists and has the R/O
	 attribute set.  Remove the R/O attribute first.  But first check
	 if a removepc exists.  If so, dstpc points to a non-existing file
	 due to a mangled suffix. */
      else if (!removepc && dstpc->has_attribute (FILE_ATTRIBUTE_READONLY))
	{
	  status = NtOpenFile (&nfh, FILE_WRITE_ATTRIBUTES,
			       dstpc->get_object_attr (attr, sec_none_nih),
			       &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT
			       | (dstpc->is_rep_symlink ()
				  ? FILE_OPEN_REPARSE_POINT : 0));
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	  status = NtSetAttributesFile (nfh, dstpc->file_attributes ()
					     & ~FILE_ATTRIBUTE_READONLY);
	  NtClose (nfh);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	}

      /* SUSv3: If the old argument and the new argument resolve to the same
	 existing file, rename() shall return successfully and perform no
	 other action.
	 The test tries to be as quick as possible.  Due to the above cross
	 device check we already know both files are on the same device.  So
	 it just tests if oldpath has more than 1 hardlink, then it opens
	 newpath and tests for identical file ids.  If so, oldpath and newpath
	 refer to the same file. */
      if ((removepc || dstpc->exists ())
	  && !oldpc.isdir ()
	  && NT_SUCCESS (NtQueryInformationFile (fh, &io, &ofsi, sizeof ofsi,
						 FileStandardInformation))
	  && ofsi.NumberOfLinks > 1
	  && NT_SUCCESS (NtOpenFile (&nfh, READ_CONTROL,
		     (removepc ?: dstpc)->get_object_attr (attr, sec_none_nih),
		     &io, FILE_SHARE_VALID_FLAGS,
		     FILE_OPEN_FOR_BACKUP_INTENT
		     | ((removepc ?: dstpc)->is_rep_symlink ()
			? FILE_OPEN_REPARSE_POINT : 0))))
	{
	  FILE_INTERNAL_INFORMATION ofii, nfii;

	  if (NT_SUCCESS (NtQueryInformationFile (fh, &io, &ofii, sizeof ofii,
						  FileInternalInformation))
	      && NT_SUCCESS (NtQueryInformationFile (nfh, &io, &nfii,
						     sizeof nfii,
						     FileInternalInformation))
	      && ofii.FileId.QuadPart == nfii.FileId.QuadPart)
	    {
	      debug_printf ("%s and %s are the same file", oldpath, newpath);
	      NtClose (nfh);
	      res = 0;
	      __leave;
	    }
	  NtClose (nfh);
	}
      /* Create FILE_RENAME_INFORMATION struct.  Using a tmp_pathbuf area
	 allows for paths of up to 32757 chars.  This test is just for
	 paranoia's sake. */
      if (dstpc->get_nt_native_path ()->Length
	  > NT_MAX_PATH * sizeof (WCHAR) - sizeof (FILE_RENAME_INFORMATION))
	{
	  debug_printf ("target filename too long");
	  set_errno (EINVAL);
	  __leave;
	}
      pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
      pfri->ReplaceIfExists = TRUE;
      pfri->RootDirectory = NULL;
      pfri->FileNameLength = dstpc->get_nt_native_path ()->Length;
      memcpy (&pfri->FileName,  dstpc->get_nt_native_path ()->Buffer,
	      pfri->FileNameLength);
      status = NtSetInformationFile (fh, &io, pfri,
				     sizeof *pfri + pfri->FileNameLength,
				     FileRenameInformation);
      /* This happens if the access rights don't allow deleting the destination.
	 Even if the handle to the original file is opened with BACKUP
	 and/or RECOVERY, these flags don't apply to the destination of the
	 rename operation.  So, a privileged user can't rename a file to an
	 existing file, if the permissions of the existing file aren't right.
	 Like directories, we have to handle this separately by removing the
	 destination before renaming. */
      if (status == STATUS_ACCESS_DENIED && dstpc->exists ()
	  && !dstpc->isdir ())
	{
	  if (wincap.has_transactions ()
	      && (dstpc->fs_flags () & FILE_SUPPORTS_TRANSACTIONS)
	      && !trans)
	    {
	      start_transaction (old_trans, trans);
	      /* As mentioned earlier, opening the file must be part of the
		 transaction.  Therefore we have to reopen the file here if the
		 transaction hasn't been started already.  Unfortunately we
		 can't use the NT "reopen file from existing handle" feature.
		 In that case NtOpenFile returns STATUS_TRANSACTIONAL_CONFLICT.
		 We *have* to close the handle to the file first, *then* we can
		 re-open it.  Fortunately nothing has happened yet, so the
		 atomicity of the rename functionality is not spoiled. */
	      NtClose (fh);
    retry_reopen:
	      status = NtOpenFile (&fh, DELETE,
				   oldpc.get_object_attr (attr, sec_none_nih),
				   &io, FILE_SHARE_VALID_FLAGS,
				   FILE_OPEN_FOR_BACKUP_INTENT
				   | (oldpc.is_rep_symlink ()
				      ? FILE_OPEN_REPARSE_POINT : 0));
	      if (!NT_SUCCESS (status))
		{
		  if (NT_TRANSACTIONAL_ERROR (status) && trans)
		    {
		      /* If NtOpenFile fails due to transactional problems,
			 stop transaction and go ahead without. */
		      stop_transaction (status, old_trans, trans);
		      debug_printf ("Transaction failure.  Retry open.");
		      goto retry_reopen;
		    }
		  __seterrno_from_nt_status (status);
		  __leave;
		}
	    }
	  if (NT_SUCCESS (status = unlink_nt (*dstpc)))
	    status = NtSetInformationFile (fh, &io, pfri,
					   sizeof *pfri + pfri->FileNameLength,
					   FileRenameInformation);
	}
      if (NT_SUCCESS (status))
	{
	  if (removepc)
	    unlink_nt (*removepc);
	  res = 0;
	}
      else
	__seterrno_from_nt_status (status);
    }
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
  if (fh)
    NtClose (fh);
  /* Stop transaction if we started one. */
  if (trans)
    stop_transaction (status, old_trans, trans);
  if (get_errno () != EFAULT)
    syscall_printf ("%R = rename(%s, %s)", res, oldpath, newpath);
  return res;
}

extern "C" int
system (const char *cmdstring)
{
  pthread_testcancel ();

  if (cmdstring == NULL)
    return 1;

  int res = -1;
  const char* command[4];

  __try
    {
      command[0] = "sh";
      command[1] = "-c";
      command[2] = cmdstring;
      command[3] = (const char *) NULL;

      if ((res = spawnvp (_P_SYSTEM, "/bin/sh", command)) == -1)
	{
	  // when exec fails, return value should be as if shell
	  // executed exit (127)
	  res = 127;
	}
    }
  __except (EFAULT) {}
  __endtry
  return res;
}

extern "C" int
setdtablesize (int size)
{
  if (size < 0)
    {
      set_errno (EINVAL);
      return -1;
    }

  if (size <= (int) cygheap->fdtab.size
      || cygheap->fdtab.extend (size - cygheap->fdtab.size, OPEN_MAX_MAX))
    return 0;

  return -1;
}

extern "C" int
getdtablesize ()
{
  return cygheap->fdtab.size;
}

extern "C" int
getpagesize ()
{
  return (size_t) wincap.allocation_granularity ();
}

/* FIXME: not all values are correct... */
extern "C" long int
fpathconf (int fd, int v)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
  return cfd->fpathconf (v);
}

extern "C" long int
pathconf (const char *file, int v)
{
  fhandler_base *fh = NULL;
  long ret = -1;

  __try
    {
      if (!*file)
	{
	  set_errno (ENOENT);
	  return -1;
	}
      if (!(fh = build_fh_name (file, PC_SYM_FOLLOW, stat_suffixes)))
	return -1;
      if (!fh->exists ())
	set_errno (ENOENT);
      else
	ret = fh->fpathconf (v);
    }
  __except (EFAULT) {}
  __endtry
  delete fh;
  return ret;
}

extern "C" int
ttyname_r (int fd, char *buf, size_t buflen)
{
  int ret = 0;

  __try
    {
      cygheap_fdget cfd (fd, true);
      if (cfd < 0)
	ret = EBADF;
      else if (!cfd->is_tty ())
	ret = ENOTTY;
      else if (buflen < strlen (cfd->ttyname ()) + 1)
	ret = ERANGE;
      else
	strcpy (buf, cfd->ttyname ());
      debug_printf ("returning %d tty: %s", ret, ret ? "NULL" : buf);
    }
  __except (NO_ERROR)
    {
      ret = EFAULT;
    }
  __endtry
  return ret;
}

extern "C" char *
ttyname (int fd)
{
  static char name[TTY_NAME_MAX];
  int ret = ttyname_r (fd, name, TTY_NAME_MAX);
  if (ret)
    {
      set_errno (ret);
      return NULL;
    }
  return name;
}

extern "C" char *
ctermid (char *str)
{
  if (str == NULL)
    str = _my_tls.locals.ttybuf;
  if (myself->ctty < 0)
    strcpy (str, "no tty");
  else
    {
      device d;
      d.parse (myself->ctty);
      strcpy (str, d.name);
    }
  return str;
}

/* Tells stdio if it should do the cr/lf conversion for this file */
extern "C" int
_cygwin_istext_for_stdio (int fd)
{
  if (CYGWIN_VERSION_OLD_STDIO_CRLF_HANDLING)
    {
      syscall_printf ("fd %d: old API", fd);
      return 0; /* we do it for old apps, due to getc/putc macros */
    }

  cygheap_fdget cfd (fd, false, false);
  if (cfd < 0)
    {
      syscall_printf ("fd %d: not open", fd);
      return 0;
    }

#if 0
  if (cfd->get_device () != FH_FS)
    {
      syscall_printf ("fd not disk file.  Defaulting to binary.");
      return 0;
    }
#endif

  if (cfd->wbinary () || cfd->rbinary ())
    {
      syscall_printf ("fd %d: opened as binary", fd);
      return 0;
    }

  syscall_printf ("fd %d: defaulting to text", fd);
  return 1;
}

/* internal newlib function */
extern "C" int _fwalk (struct _reent *ptr, int (*function) (FILE *));

static int
setmode_helper (FILE *f)
{
  if (fileno (f) != _my_tls.locals.setmode_file)
    {
      syscall_printf ("improbable, but %d != %d", fileno (f), _my_tls.locals.setmode_file);
      return 0;
    }
  syscall_printf ("file was %s now %s", f->_flags & __SCLE ? "text" : "binary",
		  _my_tls.locals.setmode_mode & O_TEXT ? "text" : "binary");
  if (_my_tls.locals.setmode_mode & O_TEXT)
    f->_flags |= __SCLE;
  else
    f->_flags &= ~__SCLE;
  return 0;
}

extern "C" int
getmode (int fd)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;

  return cfd->get_flags () & (O_BINARY | O_TEXT);
}

/* Set a file descriptor into text or binary mode, returning the
   previous mode.  */

extern "C" int
_setmode (int fd, int mode)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
  if (mode != O_BINARY  && mode != O_TEXT && mode != 0)
    {
      set_errno (EINVAL);
      return -1;
    }

  /* Note that we have no way to indicate the case that writes are
     binary but not reads, or vice-versa.  These cases can arise when
     using the tty or console interface.  People using those
     interfaces should not use setmode.  */

  int res;
  if (cfd->wbinary () && cfd->rbinary ())
    res = O_BINARY;
  else if (cfd->wbinset () && cfd->rbinset ())
    res = O_TEXT;	/* Specifically set O_TEXT */
  else
    res = 0;

  if (!mode)
    cfd->reset_to_open_binmode ();
  else
    cfd->set_flags ((cfd->get_flags () & ~(O_TEXT | O_BINARY)) | mode);

  syscall_printf ("(%d<%S>, %p) returning %s", fd,
		  cfd->pc.get_nt_native_path (), mode,
		  res & O_TEXT ? "text" : "binary");
  return res;
}

extern "C" int
cygwin_setmode (int fd, int mode)
{
  int res = _setmode (fd, mode);
  if (res != -1)
    {
      _my_tls.locals.setmode_file = fd;
      if (_cygwin_istext_for_stdio (fd))
	_my_tls.locals.setmode_mode = O_TEXT;
      else
	_my_tls.locals.setmode_mode = O_BINARY;
      _fwalk (_GLOBAL_REENT, setmode_helper);
    }
  return res;
}

extern "C" int
posix_fadvise (int fd, off_t offset, off_t len, int advice)
{
  int res = -1;
  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = cfd->fadvise (offset, len, advice);
  else
    set_errno (EBADF);
  syscall_printf ("%R = posix_fadvice(%d, %D, %D, %d)",
		  res, fd, offset, len, advice);
  return res;
}

extern "C" int
posix_fallocate (int fd, off_t offset, off_t len)
{
  int res = -1;
  if (offset < 0 || len == 0)
    set_errno (EINVAL);
  else
    {
      cygheap_fdget cfd (fd);
      if (cfd >= 0)
	res = cfd->ftruncate (offset + len, false);
      else
	set_errno (EBADF);
    }
  syscall_printf ("%R = posix_fallocate(%d, %D, %D)", res, fd, offset, len);
  return res;
}

extern "C" int
ftruncate64 (int fd, off_t length)
{
  int res = -1;
  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = cfd->ftruncate (length, true);
  else
    set_errno (EBADF);
  syscall_printf ("%R = ftruncate(%d, %D)", res, fd, length);
  return res;
}

#ifdef __x86_64__
EXPORT_ALIAS (ftruncate64, ftruncate)
#else
/* ftruncate: P96 5.6.7.1 */
extern "C" int
ftruncate (int fd, _off_t length)
{
  return ftruncate64 (fd, (off_t)length);
}
#endif

/* truncate: Provided by SVR4 and 4.3+BSD.  Not part of POSIX.1 or XPG3 */
extern "C" int
truncate64 (const char *pathname, off_t length)
{
  int fd;
  int res = -1;

  fd = open (pathname, O_RDWR);

  if (fd != -1)
    {
      res = ftruncate64 (fd, length);
      close (fd);
    }
  syscall_printf ("%R = truncate(%s, %D)", res, pathname, length);

  return res;
}

#ifdef __x86_64__
EXPORT_ALIAS (truncate64, truncate)
#else
/* truncate: Provided by SVR4 and 4.3+BSD.  Not part of POSIX.1 or XPG3 */
extern "C" int
truncate (const char *pathname, _off_t length)
{
  return truncate64 (pathname, (off_t)length);
}
#endif

extern "C" long
_get_osfhandle (int fd)
{
  long res;

  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = (long) cfd->get_handle ();
  else
    res = -1;

  syscall_printf ("%R = get_osfhandle(%d)", res, fd);
  return res;
}

extern "C" int
fstatvfs (int fd, struct statvfs *sfs)
{
  __try
    {
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;
      return cfd->fstatvfs (sfs);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
statvfs (const char *name, struct statvfs *sfs)
{
  int res = -1;
  fhandler_base *fh = NULL;

  __try
    {
      if (!(fh = build_fh_name (name, PC_SYM_FOLLOW, stat_suffixes)))
	__leave;

      if (fh->error ())
	{
	  debug_printf ("got %d error from build_fh_name", fh->error ());
	  set_errno (fh->error ());
	}
      else if (fh->exists ())
	{
	  debug_printf ("(%s, %p), file_attributes %d", name, sfs, (DWORD) *fh);
	  res = fh->fstatvfs (sfs);
	}
      else
	set_errno (ENOENT);

    }
  __except (EFAULT) {}
  __endtry
  delete fh;
  MALLOC_CHECK;
  if (get_errno () != EFAULT)
    syscall_printf ("%R = statvfs(%s,%p)", res, name, sfs);
  return res;
}

extern "C" int
fstatfs (int fd, struct statfs *sfs)
{
  struct statvfs vfs;
  int ret = fstatvfs (fd, &vfs);
  if (!ret)
    {
      sfs->f_type = vfs.f_flag;
      sfs->f_bsize = vfs.f_bsize;
      sfs->f_blocks = vfs.f_blocks;
      sfs->f_bavail = vfs.f_bavail;
      sfs->f_bfree = vfs.f_bfree;
      sfs->f_files = -1;
      sfs->f_ffree = -1;
      sfs->f_fsid = vfs.f_fsid;
      sfs->f_namelen = vfs.f_namemax;
    }
  return ret;
}

extern "C" int
statfs (const char *fname, struct statfs *sfs)
{
  struct statvfs vfs;
  int ret = statvfs (fname, &vfs);
  if (!ret)
    {
      sfs->f_type = vfs.f_flag;
      sfs->f_bsize = vfs.f_bsize;
      sfs->f_blocks = vfs.f_blocks;
      sfs->f_bavail = vfs.f_bavail;
      sfs->f_bfree = vfs.f_bfree;
      sfs->f_files = -1;
      sfs->f_ffree = -1;
      sfs->f_fsid = vfs.f_fsid;
      sfs->f_namelen = vfs.f_namemax;
    }
  return ret;
}

/* setpgid: POSIX 4.3.3.1 */
extern "C" int
setpgid (pid_t pid, pid_t pgid)
{
  int res = -1;
  if (pid == 0)
    pid = getpid ();
  if (pgid == 0)
    pgid = pid;

  if (pgid < 0)
    set_errno (EINVAL);
  else
    {
      pinfo p (pid, PID_MAP_RW);
      if (!p)
	set_errno (ESRCH);
      else if (p->pgid == pgid)
	res = 0;
      /* A process may only change the process group of itself and its children */
      else if (p != myself && p->ppid != myself->pid)
	set_errno (EPERM);
      else
	{
	  p->pgid = pgid;
	  if (p->pid != p->pgid)
	    p->set_has_pgid_children (0);
	  res = 0;
	}
    }

  syscall_printf ("pid %d, pgid %d, res %d", pid, pgid, res);
  return res;
}

extern "C" pid_t
getpgid (pid_t pid)
{
  if (pid == 0)
    pid = getpid ();

  pinfo p (pid);
  if (!p)
    {
      set_errno (ESRCH);
      return -1;
    }
  return p->pgid;
}

extern "C" int
setpgrp (void)
{
  return setpgid (0, 0);
}

extern "C" pid_t
getpgrp (void)
{
  return getpgid (0);
}

extern "C" char *
ptsname (int fd)
{
  static char buf[TTY_NAME_MAX];
  return ptsname_r (fd, buf, sizeof (buf)) == 0 ? buf : NULL;
}

extern "C" int
ptsname_r (int fd, char *buf, size_t buflen)
{
  if (!buf)
    {
      set_errno (EINVAL);
      return EINVAL;
    }

  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return 0;
  return cfd->ptsname_r (buf, buflen);
}

static int __stdcall
mknod_worker (const char *path, mode_t type, mode_t mode, _major_t major,
	      _minor_t minor)
{
  char buf[sizeof (":\\00000000:00000000:00000000") + PATH_MAX];
  sprintf (buf, ":\\%x:%x:%x", major, minor,
	   type | (mode & (S_IRWXU | S_IRWXG | S_IRWXO)));
  return symlink_worker (buf, path, true);
}

extern "C" int
mknod32 (const char *path, mode_t mode, dev_t dev)
{
  __try
    {
      if (!*path)
	{
	  set_errno (ENOENT);
	  __leave;
	}

      if (strlen (path) >= PATH_MAX)
	__leave;

      path_conv w32path (path, PC_SYM_NOFOLLOW);
      if (w32path.exists ())
	{
	  set_errno (EEXIST);
	  __leave;
	}

      mode_t type = mode & S_IFMT;
      _major_t major = _major (dev);
      _minor_t minor = _minor (dev);
      switch (type)
	{
	case S_IFCHR:
	case S_IFBLK:
	  break;

	case S_IFIFO:
	  major = _major (FH_FIFO);
	  minor = _minor (FH_FIFO);
	  break;

	case 0:
	case S_IFREG:
	  {
	    int fd = open (path, O_CREAT, mode);
	    if (fd < 0)
	      __leave;
	    close (fd);
	    return 0;
	  }

	default:
	  set_errno (EINVAL);
	  __leave;
	}

      return mknod_worker (w32path.get_win32 (), type, mode, major, minor);
    }
  __except (EFAULT)
  __endtry
  return -1;
}

extern "C" int
mknod (const char *_path, mode_t mode, __dev16_t dev)
{
  return mknod32 (_path, mode, (dev_t) dev);
}

extern "C" int
mkfifo (const char *path, mode_t mode)
{
  return mknod32 (path, (mode & ~S_IFMT) | S_IFIFO, 0);
}

/* seteuid: standards? */
extern "C" int
seteuid32 (uid_t uid)
{
  debug_printf ("uid: %u myself->uid: %u myself->gid: %u",
		uid, myself->uid, myself->gid);

  /* Same uid as we're just running under is usually a no-op.

     Except we have an external token which is a restricted token.  Or,
     the external token is NULL, but the current impersonation token is
     a restricted token.  This allows to restrict user rights temporarily
     like this:

       cygwin_internal(CW_SET_EXTERNAL_TOKEN, restricted_token,
		       CW_TOKEN_RESTRICTED);
       setuid (getuid ());
       [...do stuff with restricted rights...]
       cygwin_internal(CW_SET_EXTERNAL_TOKEN, INVALID_HANDLE_VALUE,
		       CW_TOKEN_RESTRICTED);
       setuid (getuid ());

    Note that using the current uid is a requirement!  Starting with Windows
    Vista, we have restricted tokens galore (UAC), so this is really just
    a special case to restict your own processes to lesser rights. */
  bool request_restricted_uid_switch = (uid == myself->uid
      && cygheap->user.ext_token_is_restricted);
  if (uid == myself->uid && !cygheap->user.groups.ischanged
      && !request_restricted_uid_switch)
    {
      debug_printf ("Nothing happens");
      return 0;
    }

  cygsid usersid;
  user_groups &groups = cygheap->user.groups;
  HANDLE new_token = INVALID_HANDLE_VALUE;
  struct passwd * pw_new;
  bool token_is_internal, issamesid = false;

  pw_new = internal_getpwuid (uid);
  if (!usersid.getfrompw (pw_new))
    {
      set_errno (EINVAL);
      return -1;
    }

  cygheap->user.deimpersonate ();

  /* Verify if the process token is suitable. */
  /* First of all, skip all checks if a switch to a restricted token has been
     requested, or if trying to switch back from it. */
  if (request_restricted_uid_switch)
    {
      if (cygheap->user.external_token != NO_IMPERSONATION)
	{
	  debug_printf ("Switch to restricted token");
	  new_token = cygheap->user.external_token;
	}
      else
	{
	  debug_printf ("Switch back from restricted token");
	  new_token = hProcToken;
	  cygheap->user.ext_token_is_restricted = false;
	}
    }
  /* TODO, CV 2008-11-25: The check against saved_sid is a kludge and a
     shortcut.  We must check if it's really feasible in the long run.
     The reason to add this shortcut is this:  sshd switches back to the
     privileged user running sshd at least twice in the process of
     authentication.  It calls seteuid first, then setegid.  Due to this
     order, the setgroups group list is still active when calling seteuid
     and verify_token treats the original token of the privileged user as
     insufficient.  This in turn results in creating a new user token for
     the privileged user instead of using the orignal token.  This can have
     unfortunate side effects.  The created token has different group
     memberships, different user rights, and misses possible network
     credentials.
     Therefore we try this shortcut now.  When switching back to the
     privileged user, we probably always want a correct (aka original)
     user token for this privileged user, not only in sshd. */
  else if ((uid == cygheap->user.saved_uid
	   && usersid == cygheap->user.saved_sid ())
	   || verify_token (hProcToken, usersid, groups))
    new_token = hProcToken;
  /* Verify if the external token is suitable */
  else if (cygheap->user.external_token != NO_IMPERSONATION
	   && verify_token (cygheap->user.external_token, usersid, groups))
    new_token = cygheap->user.external_token;
  /* Verify if the current token (internal or former external) is suitable */
  else if (cygheap->user.curr_primary_token != NO_IMPERSONATION
	   && cygheap->user.curr_primary_token != cygheap->user.external_token
	   && verify_token (cygheap->user.curr_primary_token, usersid, groups,
			    &token_is_internal))
    new_token = cygheap->user.curr_primary_token;
  /* Verify if the internal token is suitable */
  else if (cygheap->user.internal_token != NO_IMPERSONATION
	   && cygheap->user.internal_token != cygheap->user.curr_primary_token
	   && verify_token (cygheap->user.internal_token, usersid, groups,
			    &token_is_internal))
    new_token = cygheap->user.internal_token;

  debug_printf ("Found token %p", new_token);

  /* If no impersonation token is available, try to authenticate using
     LSA private data stored password, LSA authentication using our own
     LSA module, or, as last chance, NtCreateToken. */
  if (new_token == INVALID_HANDLE_VALUE)
    {
      new_token = lsaprivkeyauth (pw_new);
      if (new_token)
	{
	  /* We have to verify this token since settings in /etc/group
	     might render it unusable im terms of group membership. */
	  if (!verify_token (new_token, usersid, groups))
	    {
	      CloseHandle (new_token);
	      new_token = NULL;
	    }
	}
      if (!new_token)
	{
	  debug_printf ("lsaprivkeyauth failed, try lsaauth.");
	  if (!(new_token = lsaauth (usersid, groups, pw_new)))
	    {
	      debug_printf ("lsaauth failed, try create_token.");
	      new_token = create_token (usersid, groups, pw_new);
	      if (new_token == INVALID_HANDLE_VALUE)
		{
		  debug_printf ("create_token failed, bail out of here");
		  cygheap->user.reimpersonate ();
		  return -1;
		}
	    }
	}

      /* Keep at most one internal token */
      if (cygheap->user.internal_token != NO_IMPERSONATION)
	CloseHandle (cygheap->user.internal_token);
      cygheap->user.internal_token = new_token;
    }

  if (new_token != hProcToken)
    {
      NTSTATUS status;

      if (!request_restricted_uid_switch)
	load_user_profile (new_token, pw_new, usersid);

      /* Try setting owner to same value as user. */
      status = NtSetInformationToken (new_token, TokenOwner,
				      &usersid, sizeof usersid);
      if (!NT_SUCCESS (status))
	debug_printf ("NtSetInformationToken (user.token, TokenOwner), %y",
		      status);
      /* Try setting primary group in token to current group */
      status = NtSetInformationToken (new_token, TokenPrimaryGroup,
				      &groups.pgsid, sizeof (cygsid));
      if (!NT_SUCCESS (status))
	debug_printf ("NtSetInformationToken (user.token, TokenPrimaryGroup),"
		      "%y", status);
      /* Try setting default DACL */
      PACL dacl_buf = (PACL) alloca (MAX_DACL_LEN (5));
      if (sec_acl (dacl_buf, true, true, usersid))
	{
	  TOKEN_DEFAULT_DACL tdacl = { dacl_buf };
	  status = NtSetInformationToken (new_token, TokenDefaultDacl,
					  &tdacl, sizeof (tdacl));
	  if (!NT_SUCCESS (status))
	    debug_printf ("NtSetInformationToken (TokenDefaultDacl), %y",
			  status);
	}
    }

  issamesid = (usersid == cygheap->user.sid ());
  cygheap->user.set_sid (usersid);
  cygheap->user.curr_primary_token = new_token == hProcToken ? NO_IMPERSONATION
							: new_token;
  cygheap->user.curr_token_is_restricted = false;
  cygheap->user.setuid_to_restricted = false;
  if (cygheap->user.curr_imp_token != NO_IMPERSONATION)
    {
      CloseHandle (cygheap->user.curr_imp_token);
      cygheap->user.curr_imp_token = NO_IMPERSONATION;
    }
  if (cygheap->user.curr_primary_token != NO_IMPERSONATION)
    {
      /* HANDLE_FLAG_INHERIT may be missing in external token.  */
      if (!SetHandleInformation (cygheap->user.curr_primary_token,
				 HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT)
	  || !DuplicateTokenEx (cygheap->user.curr_primary_token,
				MAXIMUM_ALLOWED, &sec_none,
				SecurityImpersonation, TokenImpersonation,
				&cygheap->user.curr_imp_token))
	{
	  __seterrno ();
	  cygheap->user.curr_primary_token = NO_IMPERSONATION;
	  return -1;
	}
      cygheap->user.curr_token_is_restricted = request_restricted_uid_switch;
      set_cygwin_privileges (cygheap->user.curr_primary_token);
      set_cygwin_privileges (cygheap->user.curr_imp_token);
    }
  if (!cygheap->user.reimpersonate ())
    {
      __seterrno ();
      return -1;
    }

  cygheap->user.set_name (pw_new->pw_name);
  myself->uid = uid;
  groups.ischanged = FALSE;
  if (!issamesid)
    /* Recreate and fill out the user shared region for a new user. */
    user_info::create (true);
  return 0;
}

#ifdef __x86_64__
EXPORT_ALIAS (seteuid32, seteuid)
#else
extern "C" int
seteuid (__uid16_t uid)
{
  return seteuid32 (uid16touid32 (uid));
}
#endif

/* setuid: POSIX 4.2.2.1 */
extern "C" int
setuid32 (uid_t uid)
{
  int ret = seteuid32 (uid);
  if (!ret)
    {
      cygheap->user.real_uid = myself->uid;
      /* If restricted token, forget original privileges on exec ().  */
      cygheap->user.setuid_to_restricted = cygheap->user.curr_token_is_restricted;
    }
  debug_printf ("real: %d, effective: %d", cygheap->user.real_uid, myself->uid);
  return ret;
}

#ifdef __x86_64__
EXPORT_ALIAS (setuid32, setuid)
#else
extern "C" int
setuid (__uid16_t uid)
{
  return setuid32 (uid16touid32 (uid));
}
#endif

extern "C" int
setreuid32 (uid_t ruid, uid_t euid)
{
  int ret = 0;
  bool tried = false;
  uid_t old_euid = myself->uid;

  if (ruid != ILLEGAL_UID && cygheap->user.real_uid != ruid && euid != ruid)
    tried = !(ret = seteuid32 (ruid));
  if (!ret && euid != ILLEGAL_UID)
    ret = seteuid32 (euid);
  if (tried && (ret || euid == ILLEGAL_UID) && seteuid32 (old_euid))
    system_printf ("Cannot restore original euid %u", old_euid);
  if (!ret && ruid != ILLEGAL_UID)
    cygheap->user.real_uid = ruid;
  debug_printf ("real: %u, effective: %u", cygheap->user.real_uid, myself->uid);
  return ret;
}

#ifdef __x86_64__
EXPORT_ALIAS (setreuid32, setreuid)
#else
extern "C" int
setreuid (__uid16_t ruid, __uid16_t euid)
{
  return setreuid32 (uid16touid32 (ruid), uid16touid32 (euid));
}
#endif

/* setegid: from System V.  */
extern "C" int
setegid32 (gid_t gid)
{
  debug_printf ("new egid: %u current: %u", gid, myself->gid);

  if (gid == myself->gid)
    {
      myself->gid = gid;
      return 0;
    }

  NTSTATUS status;
  user_groups * groups = &cygheap->user.groups;
  cygsid gsid;
  struct group * gr = internal_getgrgid (gid);

  if (!gsid.getfromgr (gr))
    {
      set_errno (EINVAL);
      return -1;
    }
  myself->gid = gid;

  groups->update_pgrp (gsid);
  if (cygheap->user.issetuid ())
    {
      /* If impersonated, update impersonation token... */
      status = NtSetInformationToken (cygheap->user.primary_token (),
				      TokenPrimaryGroup, &gsid, sizeof gsid);
      if (!NT_SUCCESS (status))
	debug_printf ("NtSetInformationToken (primary_token, "
		      "TokenPrimaryGroup), %y", status);
      status = NtSetInformationToken (cygheap->user.imp_token (),
				      TokenPrimaryGroup, &gsid, sizeof gsid);
      if (!NT_SUCCESS (status))
	debug_printf ("NtSetInformationToken (token, TokenPrimaryGroup), %y",
		      status);
    }
  cygheap->user.deimpersonate ();
  status = NtSetInformationToken (hProcToken, TokenPrimaryGroup,
				  &gsid, sizeof gsid);
  if (!NT_SUCCESS (status))
    debug_printf ("NtSetInformationToken (hProcToken, TokenPrimaryGroup), %y",
		  status);
  clear_procimptoken ();
  cygheap->user.reimpersonate ();
  return 0;
}

#ifdef __x86_64__
EXPORT_ALIAS (setegid32, setegid)
#else
extern "C" int
setegid (__gid16_t gid)
{
  return setegid32 (gid16togid32 (gid));
}
#endif

/* setgid: POSIX 4.2.2.1 */
extern "C" int
setgid32 (gid_t gid)
{
  int ret = setegid32 (gid);
  if (!ret)
    cygheap->user.real_gid = myself->gid;
  return ret;
}

#ifdef __x86_64__
EXPORT_ALIAS (setgid32, setgid)
#else
extern "C" int
setgid (__gid16_t gid)
{
  int ret = setegid32 (gid16togid32 (gid));
  if (!ret)
    cygheap->user.real_gid = myself->gid;
  return ret;
}
#endif

extern "C" int
setregid32 (gid_t rgid, gid_t egid)
{
  int ret = 0;
  bool tried = false;
  gid_t old_egid = myself->gid;

  if (rgid != ILLEGAL_GID && cygheap->user.real_gid != rgid && egid != rgid)
    tried = !(ret = setegid32 (rgid));
  if (!ret && egid != ILLEGAL_GID)
    ret = setegid32 (egid);
  if (tried && (ret || egid == ILLEGAL_GID) && setegid32 (old_egid))
    system_printf ("Cannot restore original egid %u", old_egid);
  if (!ret && rgid != ILLEGAL_GID)
    cygheap->user.real_gid = rgid;
  debug_printf ("real: %u, effective: %u", cygheap->user.real_gid, myself->gid);
  return ret;
}

#ifdef __x86_64__
EXPORT_ALIAS (setregid32, setregid)
#else
extern "C" int
setregid (__gid16_t rgid, __gid16_t egid)
{
  return setregid32 (gid16togid32 (rgid), gid16togid32 (egid));
}
#endif

/* chroot: privileged Unix system call.  */
/* FIXME: Not privileged here. How should this be done? */
extern "C" int
chroot (const char *newroot)
{
  path_conv path (newroot, PC_SYM_FOLLOW | PC_POSIX);

  int ret = -1;
  if (path.error)
    set_errno (path.error);
  else if (!path.exists ())
    set_errno (ENOENT);
  else if (!path.isdir ())
    set_errno (ENOTDIR);
  else if (path.isspecial ())
    set_errno (EPERM);
  else
    {
      getwinenv("PATH="); /* Save the native PATH */
      cygheap->root.set (path.get_posix (), path.get_win32 (),
			 !!path.objcaseinsensitive ());
      ret = 0;
    }

  syscall_printf ("%R = chroot(%s)", ret, newroot ?: "NULL");
  return ret;
}

extern "C" int
creat (const char *path, mode_t mode)
{
  return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
}

extern "C" void
__assertfail ()
{
  exit (99);
}

extern "C" int
vhangup ()
{
  set_errno (ENOSYS);
  return -1;
}

extern "C" int
setpriority (int which, id_t who, int value)
{
  DWORD prio = nice_to_winprio (value);
  int error = 0;

  switch (which)
    {
    case PRIO_PROCESS:
      if (!who)
	who = myself->pid;
      if ((pid_t) who == myself->pid)
	{
	  if (!SetPriorityClass (GetCurrentProcess (), prio))
	    {
	      set_errno (EACCES);
	      return -1;
	    }
	  myself->nice = value;
	  debug_printf ("Set nice to %d", myself->nice);
	  return 0;
	}
      break;
    case PRIO_PGRP:
      if (!who)
	who = myself->pgid;
      break;
    case PRIO_USER:
      if (!who)
	who = myself->uid;
      break;
    default:
      set_errno (EINVAL);
      return -1;
    }
  winpids pids ((DWORD) PID_MAP_RW);
  for (DWORD i = 0; i < pids.npids; ++i)
    {
      _pinfo *p = pids[i];
      if (p)
	{
	  switch (which)
	    {
	    case PRIO_PROCESS:
	      if ((pid_t) who != p->pid)
		continue;
	      break;
	    case PRIO_PGRP:
	      if ((pid_t) who != p->pgid)
		continue;
	      break;
	    case PRIO_USER:
		if ((uid_t) who != p->uid)
		continue;
	      break;
	    }
	  HANDLE proc_h = OpenProcess (PROCESS_SET_INFORMATION, FALSE,
				       p->dwProcessId);
	  if (!proc_h)
	    error = EPERM;
	  else
	    {
	      if (!SetPriorityClass (proc_h, prio))
		error = EACCES;
	      else
		p->nice = value;
	      CloseHandle (proc_h);
	    }
	}
    }
  pids.reset ();
  if (error)
    {
      set_errno (error);
      return -1;
    }
  return 0;
}

extern "C" int
getpriority (int which, id_t who)
{
  int nice = NZERO * 2; /* Illegal value */

  switch (which)
    {
    case PRIO_PROCESS:
      if (!who)
	who = myself->pid;
      if ((pid_t) who == myself->pid)
	return myself->nice;
      break;
    case PRIO_PGRP:
      if (!who)
	who = myself->pgid;
      break;
    case PRIO_USER:
      if (!who)
	who = myself->uid;
      break;
    default:
      set_errno (EINVAL);
      return -1;
    }
  winpids pids ((DWORD) 0);
  for (DWORD i = 0; i < pids.npids; ++i)
    {
      _pinfo *p = pids[i];
      if (p)
	switch (which)
	  {
	  case PRIO_PROCESS:
	    if ((pid_t) who == p->pid)
	      {
		nice = p->nice;
		goto out;
	      }
	    break;
	  case PRIO_PGRP:
	    if ((pid_t) who == p->pgid && p->nice < nice)
	      nice = p->nice;
	    break;
	  case PRIO_USER:
	    if ((uid_t) who == p->uid && p->nice < nice)
	      nice = p->nice;
	      break;
	  }
    }
out:
  pids.reset ();
  if (nice == NZERO * 2)
    {
      set_errno (ESRCH);
      return -1;
    }
  return nice;
}

extern "C" int
nice (int incr)
{
  return setpriority (PRIO_PROCESS, myself->pid, myself->nice + incr);
}

/*
 * Find the first bit set in I.
 */

extern "C" int
ffs (int i)
{
  return __builtin_ffs (i);
}

extern "C" int
ffsl (long i)
{
  return __builtin_ffsl (i);
}

extern "C" int
ffsll (long long i)
{
  return __builtin_ffsll (i);
}

static void
locked_append (int fd, const void * buf, size_t size)
{
  struct flock lock_buffer = {F_WRLCK, SEEK_SET, 0, 0, 0};
  int count = 0;

  do
    if ((lock_buffer.l_start = lseek64 (fd, 0, SEEK_END)) != (off_t) -1
	&& fcntl64 (fd, F_SETLKW, &lock_buffer) != -1)
      {
	if (lseek64 (fd, 0, SEEK_END) != (off_t) -1)
	  write (fd, buf, size);
	lock_buffer.l_type = F_UNLCK;
	fcntl64 (fd, F_SETLK, &lock_buffer);
	break;
      }
  while (count++ < 1000
	 && (errno == EACCES || errno == EAGAIN)
	 && !usleep (1000));
}

extern "C" void
updwtmp (const char *wtmp_file, const struct utmp *ut)
{
  int fd;

  if ((fd = open (wtmp_file, O_WRONLY | O_BINARY, 0)) >= 0)
    {
      locked_append (fd, ut, sizeof *ut);
      close (fd);
    }
}

static int utmp_fd = -1;
static bool utmp_readonly = false;
static char *utmp_file = (char *) _PATH_UTMP;

static void
internal_setutent (bool force_readwrite)
{
  if (force_readwrite && utmp_readonly)
    endutent ();
  if (utmp_fd < 0)
    {
      utmp_fd = open (utmp_file, O_RDWR | O_BINARY);
      /* If open fails, we assume an unprivileged process (who?).  In this
	 case we try again for reading only unless the process calls
	 pututline() (==force_readwrite) in which case opening just fails. */
      if (utmp_fd < 0 && !force_readwrite)
	{
	  utmp_fd = open (utmp_file, O_RDONLY | O_BINARY);
	  if (utmp_fd >= 0)
	    utmp_readonly = true;
	}
    }
  else
    lseek (utmp_fd, 0, SEEK_SET);
}

extern "C" void
setutent ()
{
  internal_setutent (false);
}

extern "C" void
endutent ()
{
  if (utmp_fd >= 0)
    {
      close (utmp_fd);
      utmp_fd = -1;
      utmp_readonly = false;
    }
}

extern "C" void
utmpname (const char *file)
{
  __try
    {
      if (*file)
	{
	  endutent ();
	  utmp_file = strdup (file);
	  debug_printf ("New UTMP file: %s", utmp_file);
	  return;
	}
    }
  __except (NO_ERROR) {}
  __endtry
  debug_printf ("Invalid file");
}

EXPORT_ALIAS (utmpname, utmpxname)

/* Note: do not make NO_COPY */
static struct utmp utmp_data_buf[16];
static unsigned utix = 0;
#define nutdbuf (sizeof (utmp_data_buf) / sizeof (utmp_data_buf[0]))
#define utmp_data ({ \
  if (utix >= nutdbuf) \
    utix = 0; \
  utmp_data_buf + utix++; \
})

static struct utmpx *
copy_ut_to_utx (struct utmp *ut, struct utmpx *utx)
{
  if (!ut)
    return NULL;
  memcpy (utx, ut, sizeof *ut);
  utx->ut_tv.tv_sec = ut->ut_time;
  utx->ut_tv.tv_usec = 0;
  return utx;
}

extern "C" struct utmp *
getutent ()
{
  if (utmp_fd < 0)
    {
      internal_setutent (false);
      if (utmp_fd < 0)
	return NULL;
    }

  utmp *ut = utmp_data;
  if (read (utmp_fd, ut, sizeof *ut) != sizeof *ut)
    return NULL;
  return ut;
}

extern "C" struct utmp *
getutid (const struct utmp *id)
{
  __try
    {
      if (utmp_fd < 0)
	{
	  internal_setutent (false);
	  if (utmp_fd < 0)
	    __leave;
	}
      utmp *ut = utmp_data;
      while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
	{
	  switch (id->ut_type)
	    {
	    case RUN_LVL:
	    case BOOT_TIME:
	    case OLD_TIME:
	    case NEW_TIME:
	      if (id->ut_type == ut->ut_type)
		return ut;
	      break;
	    case INIT_PROCESS:
	    case LOGIN_PROCESS:
	    case USER_PROCESS:
	    case DEAD_PROCESS:
	       if (strncmp (id->ut_id, ut->ut_id, UT_IDLEN) == 0)
		return ut;
	      break;
	    default:
	      break;
	    }
	}
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

extern "C" struct utmp *
getutline (const struct utmp *line)
{
  __try
    {
      if (utmp_fd < 0)
	{
	  internal_setutent (false);
	  if (utmp_fd < 0)
	    __leave;
	}

      utmp *ut = utmp_data;
      while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
	if ((ut->ut_type == LOGIN_PROCESS ||
	     ut->ut_type == USER_PROCESS) &&
	    !strncmp (ut->ut_line, line->ut_line, sizeof (ut->ut_line)))
	  return ut;
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

extern "C" struct utmp *
pututline (const struct utmp *ut)
{
  __try
    {
      internal_setutent (true);
      if (utmp_fd < 0)
	{
	  debug_printf ("error: utmp_fd %d", utmp_fd);
	  __leave;
	}
      debug_printf ("ut->ut_type %d, ut->ut_pid %d, ut->ut_line '%s', ut->ut_id '%s'\n",
		    ut->ut_type, ut->ut_pid, ut->ut_line, ut->ut_id);
      debug_printf ("ut->ut_user '%s', ut->ut_host '%s'\n",
		    ut->ut_user, ut->ut_host);

      struct utmp *u;
      if ((u = getutid (ut)))
	{
	  lseek (utmp_fd, -sizeof *ut, SEEK_CUR);
	  write (utmp_fd, ut, sizeof *ut);
	}
      else
	locked_append (utmp_fd, ut, sizeof *ut);
      /* The documentation says to return a pointer to this which implies that
	 this has to be cast from a const.  That doesn't seem right but the
	 documentation seems pretty clear on this.  */
      return (struct utmp *) ut;
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

extern "C" void
setutxent ()
{
  internal_setutent (false);
}

extern "C" void
endutxent ()
{
  endutent ();
}

extern "C" struct utmpx *
getutxent ()
{
  /* POSIX: Not required to be thread safe. */
  static struct utmpx utx;
  return copy_ut_to_utx (getutent (), &utx);
}

extern "C" struct utmpx *
getutxid (const struct utmpx *id)
{
  /* POSIX: Not required to be thread safe. */
  static struct utmpx utx;

  __try
    {
      ((struct utmpx *)id)->ut_time = id->ut_tv.tv_sec;
      return copy_ut_to_utx (getutid ((struct utmp *) id), &utx);
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

extern "C" struct utmpx *
getutxline (const struct utmpx *line)
{
  /* POSIX: Not required to be thread safe. */
  static struct utmpx utx;

  __try
    {
      ((struct utmpx *)line)->ut_time = line->ut_tv.tv_sec;
      return copy_ut_to_utx (getutline ((struct utmp *) line), &utx);
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

extern "C" struct utmpx *
pututxline (const struct utmpx *utmpx)
{
  /* POSIX: Not required to be thread safe. */
  static struct utmpx utx;

  __try
    {
      ((struct utmpx *)utmpx)->ut_time = utmpx->ut_tv.tv_sec;
      return copy_ut_to_utx (pututline ((struct utmp *) utmpx), &utx);
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

extern "C" void
updwtmpx (const char *wtmpx_file, const struct utmpx *utmpx)
{
  ((struct utmpx *)utmpx)->ut_time = utmpx->ut_tv.tv_sec;
  updwtmp (wtmpx_file, (const struct utmp *) utmpx);
}

extern "C" long
gethostid (void)
{
  /* Fetch the globally unique MachineGuid value from
     HKLM/Software/Microsoft/Cryptography and hash it. */

  /* Caution: sizeof long might become > 4 when we go 64 bit, but gethostid
     is supposed to return a 32 bit value, despite the return type long.
     That's why hostid is *not* long here. */
  int32_t hostid = 0x40291372; /* Choose a nice start value */
  WCHAR wguid[38];

  reg_key key (HKEY_LOCAL_MACHINE,
	       KEY_READ | (wincap.is_wow64() ? KEY_WOW64_64KEY : 0),
	       L"SOFTWARE", L"Microsoft", L"Cryptography", NULL);
  key.get_string (L"MachineGuid", wguid, 38,
		  L"00000000-0000-0000-0000-000000000000");
  /* SDBM hash */
  for (PWCHAR wp = wguid; *wp; ++wp)
    hostid = *wp + (hostid << 6) + (hostid << 16) - hostid;
  debug_printf ("hostid %08y from MachineGuid %W", hostid, wguid);
  return (int32_t) hostid; /* Avoid sign extension. */
}

#define ETC_SHELLS "/etc/shells"
static int shell_index;
static struct __sFILE64 *shell_fp;

extern "C" char *
getusershell ()
{
  /* List of default shells if no /etc/shells exists, defined as on Linux.
     FIXME: SunOS has a far longer list, containing all shells which
     might be shipped with the OS.  Should we do the same for the Cygwin
     distro, adding bash, tcsh, ksh, pdksh and zsh?  */
  static const char *def_shells[] = {
    "/bin/sh",
    "/bin/csh",
    "/usr/bin/sh",
    "/usr/bin/csh",
    NULL
  };
  static char buf[PATH_MAX];
  int ch, buf_idx;

  if (!shell_fp && !(shell_fp = fopen64 (ETC_SHELLS, "rt")))
    {
      if (def_shells[shell_index])
	return strcpy (buf, def_shells[shell_index++]);
      return NULL;
    }
  /* Skip white space characters. */
  while ((ch = getc (shell_fp)) != EOF && isspace (ch))
    ;
  /* Get each non-whitespace character as part of the shell path as long as
     it fits in buf. */
  for (buf_idx = 0;
       ch != EOF && !isspace (ch) && buf_idx < (PATH_MAX - 1);
       buf_idx++, ch = getc (shell_fp))
    buf[buf_idx] = ch;
  /* Skip any trailing non-whitespace character not fitting in buf.  If the
     path is longer than PATH_MAX, it's invalid anyway. */
  while (ch != EOF && !isspace (ch))
    ch = getc (shell_fp);
  if (buf_idx)
    {
      buf[buf_idx] = '\0';
      return buf;
    }
  return NULL;
}

extern "C" void
setusershell ()
{
  if (shell_fp)
    fseek (shell_fp, 0L, SEEK_SET);
  shell_index = 0;
}

extern "C" void
endusershell ()
{
  if (shell_fp)
    {
      fclose (shell_fp);
      shell_fp = NULL;
    }
  shell_index = 0;
}

extern "C" void
flockfile (FILE *file)
{
  _flockfile (file);
}

extern "C" int
ftrylockfile (FILE *file)
{
  return _ftrylockfile (file);
}

extern "C" void
funlockfile (FILE *file)
{
  _funlockfile (file);
}

extern "C" FILE *
popen (const char *command, const char *in_type)
{
  const char *type = in_type;
  char fdopen_flags[3] = "\0\0";
  int pipe_flags = 0;

#define rw	fdopen_flags[0]
#define bintext	fdopen_flags[1]

  /* Sanity check.  GLibc allows any order and any number of repetition,
     as long as the string doesn't contradict itself.  We do the same here. */
  while (*type)
    {
      if (*type == 'r' || *type == 'w')
	{
	  if (rw && rw != *type)
	    break;
	  rw = *type++;
	}
      else if (*type == 'b' || *type == 't')
	{
	  if (bintext && bintext != *type)
	    break;
	  bintext = *type++;
	}
      else if (*type == 'e')
	{
	  pipe_flags = O_CLOEXEC;
	  ++type;
	}
      else
	break;
    }
  if ((rw != 'r' && rw != 'w') || (*type != '\0'))
    {
      set_errno (EINVAL);
      return NULL;
    }

  int fds[2];
  if (pipe2 (fds, pipe_flags) < 0)
    return NULL;

  int myix = rw == 'r' ? 0 : 1;

  lock_process now;
  FILE *fp = fdopen (fds[myix], fdopen_flags);
  if (fp)
    {
      /* If fds are in the range of stdin/stdout/stderr, move them
	 out of the way (possibly temporarily).  Otherwise, spawn_guts
	 will be confused.  We do this here rather than adding logic to
	 spawn_guts because spawn_guts is likely to be a more frequently
	 used routine and having stdin/stdout/stderr closed and reassigned
	 to pipe handles is an unlikely event. */
      int orig_fds[2] = {fds[0], fds[1]};
      for (int i = 0; i < 2; i++)
	if (fds[i] <= 2)
	  {
	    cygheap_fdnew newfd(3);
	    cygheap->fdtab.move_fd (fds[i], newfd);
	    fds[i] = newfd;
	  }

      int myfd = fds[myix];	/* myfd - convenience variable for manipulation
				   of the "parent" end of the pipe. */
      int stdchild = myix ^ 1;	/* stdchild denotes the index into fd for the
				   handle which will be redirected to
				   stdin/stdout */
      int __std[2];
      __std[myix] = -1;		/* -1 means don't pass this fd to the child
				   process */
      __std[stdchild] = fds[stdchild]; /* Do pass this as the std handle */

      const char *argv[4] =
	{
	  "/bin/sh",
	  "-c",
	  command,
	  NULL
	};

      /* With 'e' flag given, we have to revert the close-on-exec on the child
         end of the pipe.  Otherwise don't pass our end of the pipe to the
	 child process. */
      if (pipe_flags & O_CLOEXEC)
	fcntl64 (__std[stdchild], F_SETFD, 0);
      else
	fcntl64 (myfd, F_SETFD, FD_CLOEXEC);

      /* Also don't pass the file handle currently associated with stdin/stdout
	 to the child.  This function may actually fail if the stdchild fd
	 is closed.  But that's ok. */
      int stdchild_state = fcntl64 (stdchild, F_GETFD, 0);
      fcntl64 (stdchild, F_SETFD, stdchild_state | FD_CLOEXEC);

      /* Start a shell process to run the given command without forking. */
      pid_t pid = ch_spawn.worker ("/bin/sh", argv, cur_environ (), _P_NOWAIT,
				   __std[0], __std[1]);

      /* Reinstate the close-on-exec state */
      fcntl64 (stdchild, F_SETFD, stdchild_state);

      /* If pid >= 0 then spawn_guts succeeded.  */
      if (pid >= 0)
	{
	  close (fds[stdchild]);	/* Close the child end of the pipe. */
	  /* Move the fd back to its original slot if it has been moved since
	     we're always supposed to open the lowest numbered available fd
	     and, if fds[mix] != orig_fds[myix] then orig_fds[myix] is
	     presumably lower. */
	  if (fds[myix] != orig_fds[myix])
	    cygheap->fdtab.move_fd (fds[myix], myfd = orig_fds[myix]);
	  fhandler_pipe *fh = (fhandler_pipe *) cygheap->fdtab[myfd];
	  /* Flag that this handle is associated with popen. */
	  fh->set_popen_pid (pid);
	  return fp;
	}
    }

  /* If we reach here we've seen an error but the pipe handles are open.
     Close them and return NULL. */
  int save_errno = get_errno ();
  if (fp)
    {
      /* Must fclose fp to avoid memory leak. */
      fclose (fp);
      close (fds[myix ^ 1]);
    }
  else
    {
      close (fds[0]);
      close (fds[1]);
    }
  set_errno (save_errno);

#undef rw
#undef bintext

  return NULL;
}

int
pclose (FILE *fp)
{
  fhandler_pipe *fh = (fhandler_pipe *) cygheap->fdtab[fileno(fp)];

  if (fh->get_device () != FH_PIPEW && fh->get_device () != FH_PIPER)
    {
      set_errno (EBADF);
      return -1;
    }

  int pid = fh->get_popen_pid ();
  if (!pid)
    {
      set_errno (ECHILD);
      return -1;
    }

  if (fclose (fp))
    return -1;

  int status;
  while (1)
    if (waitpid (pid, &status, 0) == pid)
      break;
    else if (get_errno () == EINTR)
      continue;
    else
      return -1;

  return status;
}

/* Preliminary(?) implementation of the openat family of functions. */

static int
gen_full_path_at (char *path_ret, int dirfd, const char *pathname,
		  bool null_pathname_allowed = false)
{
  /* Set null_pathname_allowed to true to allow GLIBC compatible behaviour
     for NULL pathname.  Only used by futimesat. */
  if (!pathname && !null_pathname_allowed)
    {
      set_errno (EFAULT);
      return -1;
    }
  if (pathname)
    {
      if (!*pathname)
	{
	  set_errno (ENOENT);
	  return -1;
	}
      if (strlen (pathname) >= PATH_MAX)
	{
	  set_errno (ENAMETOOLONG);
	  return -1;
	}
    }
  if (pathname && isabspath (pathname))
    stpcpy (path_ret, pathname);
  else
    {
      char *p;

      if (dirfd == AT_FDCWD)
	{
	  cwdstuff::cwd_lock.acquire ();
	  p = stpcpy (path_ret, cygheap->cwd.get_posix ());
	  cwdstuff::cwd_lock.release ();
	}
      else
	{
	  cygheap_fdget cfd (dirfd);
	  if (cfd < 0)
	    return -1;
	  if (!cfd->pc.isdir ())
	    {
	      set_errno (ENOTDIR);
	      return -1;
	    }
	  p = stpcpy (path_ret, cfd->get_name ());
	}
      if (!p)
	{
	  set_errno (ENOTDIR);
	  return -1;
	}
      if (pathname)
	{
	  if (p[-1] != '/')
	    *p++ = '/';
	  stpcpy (p, pathname);
	}
    }
  return 0;
}

extern "C" int
openat (int dirfd, const char *pathname, int flags, ...)
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;

      va_list ap;
      mode_t mode;

      va_start (ap, flags);
      mode = va_arg (ap, mode_t);
      va_end (ap);
      return open (path, flags, mode);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
faccessat (int dirfd, const char *pathname, int mode, int flags)
{
  tmp_pathbuf tp;
  int res = -1;

  __try
    {
      char *path = tp.c_get ();
      if (!gen_full_path_at (path, dirfd, pathname))
	{
	  if ((mode & ~(F_OK|R_OK|W_OK|X_OK))
	      || (flags & ~(AT_SYMLINK_NOFOLLOW|AT_EACCESS)))
	    set_errno (EINVAL);
	  else
	    {
	      fhandler_base *fh = build_fh_name (path,
						 (flags & AT_SYMLINK_NOFOLLOW
						  ? PC_SYM_NOFOLLOW
						  : PC_SYM_FOLLOW)
						 | PC_KEEP_HANDLE,
						 stat_suffixes);
	      if (fh)
		{
		  res = fh->fhaccess (mode, !!(flags & AT_EACCESS));
		  delete fh;
		}
	    }
	}
    }
  __except (EFAULT) {}
  __endtry
  debug_printf ("returning %d", res);
  return res;
}

extern "C" int
fchmodat (int dirfd, const char *pathname, mode_t mode, int flags)
{
  tmp_pathbuf tp;
  __try
    {
      if (flags)
	{
	  /* BSD has lchmod, but Linux does not.  POSIX says
	     AT_SYMLINK_NOFOLLOW is allowed to fail on symlinks; but Linux
	     blindly fails even for non-symlinks.  */
	  set_errno ((flags & ~AT_SYMLINK_NOFOLLOW) ? EINVAL : EOPNOTSUPP);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return chmod (path, mode);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
fchownat (int dirfd, const char *pathname, uid_t uid, gid_t gid, int flags)
{
  tmp_pathbuf tp;
  __try
    {
      if (flags & ~AT_SYMLINK_NOFOLLOW)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return chown_worker (path, (flags & AT_SYMLINK_NOFOLLOW)
				 ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW, uid, gid);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
fstatat (int dirfd, const char *__restrict pathname, struct stat *__restrict st,
	 int flags)
{
  tmp_pathbuf tp;
  __try
    {
      if (flags & ~AT_SYMLINK_NOFOLLOW)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      path_conv pc (path, ((flags & AT_SYMLINK_NOFOLLOW)
			   ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)
			  | PC_POSIX | PC_KEEP_HANDLE, stat_suffixes);
      return stat_worker (pc, st);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern int utimens_worker (path_conv &, const struct timespec *);

extern "C" int
utimensat (int dirfd, const char *pathname, const struct timespec *times,
	   int flags)
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (flags & ~AT_SYMLINK_NOFOLLOW)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      path_conv win32 (path, PC_POSIX | ((flags & AT_SYMLINK_NOFOLLOW)
					 ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW),
		       stat_suffixes);
      return utimens_worker (win32, times);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
futimesat (int dirfd, const char *pathname, const struct timeval *times)
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname, true))
	__leave;
      return utimes (path, times);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
linkat (int olddirfd, const char *oldpathname,
	int newdirfd, const char *newpathname,
	int flags)
{
  tmp_pathbuf tp;
  __try
    {
      if (flags & ~AT_SYMLINK_FOLLOW)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      char *oldpath = tp.c_get ();
      if (gen_full_path_at (oldpath, olddirfd, oldpathname))
	__leave;
      char *newpath = tp.c_get ();
      if (gen_full_path_at (newpath, newdirfd, newpathname))
	__leave;
      if (flags & AT_SYMLINK_FOLLOW)
	{
	  path_conv old_name (oldpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
	  if (old_name.error)
	    {
	      set_errno (old_name.error);
	      __leave;
	    }
	  strcpy (oldpath, old_name.get_posix ());
	}
      return link (oldpath, newpath);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
mkdirat (int dirfd, const char *pathname, mode_t mode)
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return mkdir (path, mode);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
mkfifoat (int dirfd, const char *pathname, mode_t mode)
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return mkfifo (path, mode);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
mknodat (int dirfd, const char *pathname, mode_t mode, dev_t dev)
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return mknod32 (path, mode, dev);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" ssize_t
readlinkat (int dirfd, const char *__restrict pathname, char *__restrict buf,
	    size_t bufsize)
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return readlink (path, buf, bufsize);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
renameat (int olddirfd, const char *oldpathname,
	  int newdirfd, const char *newpathname)
{
  tmp_pathbuf tp;
  __try
    {
      char *oldpath = tp.c_get ();
      if (gen_full_path_at (oldpath, olddirfd, oldpathname))
	__leave;
      char *newpath = tp.c_get ();
      if (gen_full_path_at (newpath, newdirfd, newpathname))
	__leave;
      return rename (oldpath, newpath);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
scandirat (int dirfd, const char *pathname, struct dirent ***namelist,
	   int (*select) (const struct dirent *),
	   int (*compar) (const struct dirent **, const struct dirent **))
{
  tmp_pathbuf tp;
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return scandir (pathname, namelist, select, compar);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
symlinkat (const char *oldpath, int newdirfd, const char *newpathname)
{
  tmp_pathbuf tp;
  __try
    {
      char *newpath = tp.c_get ();
      if (gen_full_path_at (newpath, newdirfd, newpathname))
	__leave;
      return symlink (oldpath, newpath);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
unlinkat (int dirfd, const char *pathname, int flags)
{
  tmp_pathbuf tp;
  __try
    {
      if (flags & ~AT_REMOVEDIR)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return (flags & AT_REMOVEDIR) ? rmdir (path) : unlink (path);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}
@


1.670
log
@	* syscalls.cc (fhandler_base::stat_fixup): Generate unique inode number
	for /dev/tty under all circumstances.  Add to comment.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d2204 1
a2204 1
      if (oldpc.known_suffix
d2251 1
a2251 1
      if (newpc.known_suffix
d2316 1
a2316 1
		   && oldpc.known_suffix
d2356 1
a2356 1
	      if (!old_explicit_suffix && oldpc.known_suffix
d3667 1
a3667 1
      cygheap->root.set (path.normalized_path, path.get_win32 (),
d4717 1
a4717 1
	  strcpy (oldpath, old_name.normalized_path);
@


1.669
log
@	* autoload.cc (CreateProfile): Import.
	(LoadUserProfileW): Import.
	* registry.cc (get_registry_hive_path): Move to sec_auth.cc.
	(load_registry_hive): Remove.
	* registry.h (get_registry_hive_path): Drop declaration.
	(load_registry_hive): Ditto.
	* sec_auth.cc (get_user_profile_directory): Moved from registry.cc and
	renamed.  Take third parameter with buffer length.
	(load_user_profile): New function taking over for load_registry_hive.
	Use official functions to load profile.  If profile is missing, create
	it on Vista and later.
	* security.h (get_user_profile_directory): Declare.
	(load_user_profile): Declare.
	* syscalls.cc (seteuid32): Replace call to load_registry_hive with call
	to load_user_profile.
	* uinfo.cc (cygheap_user::env_userprofile): Replace call to
	get_registry_hive_path with call to get_user_profile_directory.
@
text
@d1723 2
a1724 1
     unique inode number without having to call hash_path_name. */
d1726 12
a1737 2
    buf->st_ino = (get_major () == DEV_VIRTFS_MAJOR) ? get_ino ()
						     : get_device ();
@


1.668
log
@	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d3390 1
a3390 5
	{
	  /* Avoid having HKCU use default user */
	  WCHAR name[128];
	  load_registry_hive (usersid.string (name));
	}
@


1.667
log
@	* syscall.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.
@
text
@d3839 2
a3840 12
  static const unsigned char table[] =
    {
      0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
      6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
      7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
      7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
    };
  unsigned x = i & -i;
d3842 5
a3846 1
  int a = x <= 0xffff ? (x <= 0xff ? 0 : 8) : (x <= 0xffffff ?  16 : 24);
d3848 4
a3851 1
  return table[x >> a] + a;
@


1.666
log
@	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.
@
text
@d3850 1
a3850 2
  unsigned long int a;
  unsigned long int x = i & -i;
d3852 1
a3852 1
  a = x <= 0xffff ? (x <= 0xff ? 0 : 8) : (x <= 0xffffff ?  16 : 24);
@


1.665
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d722 1
a722 1
	  pc.init_reopen_attr (&attr, fh_ro);
d950 2
a951 2
	  pc.init_reopen_attr (&attr, fh);
	  status = NtOpenFile (&fh2, DELETE, &attr, &io,
@


1.664
log
@	* cpuid.h: Add missing copyright header.  Fix formatting.  Use uint32_t
	instead of unsigned throughout.  Change functions to static inline and
	always inline.
	(cpuid): Add parameter to set ecx, allowing to request extended CPUID
	info.
	* fhandler_proc.cc (format_proc_cpuinfo): Use uint32_t instead of
	unsigned throughout.  Add fake decimal places to MHz info.  Handle more
	feature flags.
	* fhandler_random.cc (fhandler_dev_random::write): Allow up to 4K
	input to add entropy.
	* syscalls.cc: Drop including cpuid.h.
@
text
@a1165 6
  pthread_testcancel ();

  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

d1168 1
a1168 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    goto done;
d1170 1
a1170 1
  if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
d1172 3
a1174 3
      set_errno (EBADF);
      goto done;
    }
d1176 5
a1180 3
  /* Could block, so let user know we at least got here.  */
  syscall_printf ("read(%d, %p, %d) %sblocking",
		  fd, ptr, len, cfd->is_nonblocking () ? "non" : "");
d1182 3
a1184 1
  cfd->read (ptr, res = len);
d1186 5
a1190 1
done:
a1200 6
  pthread_testcancel ();

  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

a1201 1
  const ssize_t tot = check_iovec_for_read (iov, iovcnt);
d1203 1
a1203 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    goto done;
d1205 1
a1205 1
  if (tot <= 0)
d1207 5
a1211 3
      res = tot;
      goto done;
    }
d1213 5
a1217 5
  if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
    {
      set_errno (EBADF);
      goto done;
    }
d1219 5
a1223 3
  /* Could block, so let user know we at least got here.  */
  syscall_printf ("readv(%d, %p, %d) %sblocking",
		  fd, iov, iovcnt, cfd->is_nonblocking () ? "non" : "");
d1225 3
a1227 1
  res = cfd->readv (iov, iovcnt, tot);
d1229 4
a1232 1
done:
d1241 2
a1244 1
  ssize_t res;
a1257 6
  pthread_testcancel ();

  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

d1260 1
a1260 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    goto done;
d1262 1
a1262 1
  if ((cfd->get_flags () & O_ACCMODE) == O_RDONLY)
d1264 3
a1266 3
      set_errno (EBADF);
      goto done;
    }
d1268 5
a1272 5
  /* Could block, so let user know we at least got here.  */
  if (fd == 1 || fd == 2)
    paranoid_printf ("write(%d, %p, %d)", fd, ptr, len);
  else
    syscall_printf  ("write(%d, %p, %d)", fd, ptr, len);
d1274 5
a1278 1
  res = cfd->write (ptr, len);
d1280 4
a1283 1
done:
a1284 1

a1293 6
  pthread_testcancel ();

  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

a1294 1
  const ssize_t tot = check_iovec_for_write (iov, iovcnt);
d1296 1
a1296 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    goto done;
d1298 1
a1298 1
  if (tot <= 0)
d1300 5
a1304 3
      res = tot;
      goto done;
    }
d1306 5
a1310 5
  if ((cfd->get_flags () & O_ACCMODE) == O_RDONLY)
    {
      set_errno (EBADF);
      goto done;
    }
d1312 5
a1316 5
  /* Could block, so let user know we at least got here.  */
  if (fd == 1 || fd == 2)
    paranoid_printf ("writev(%d, %p, %d)", fd, iov, iovcnt);
  else
    syscall_printf  ("writev(%d, %p, %d)", fd, iov, iovcnt);
d1318 5
a1322 1
  res = cfd->writev (iov, iovcnt, tot);
d1324 4
a1327 1
done:
a1331 1

a1361 1
  syscall_printf ("open(%s, %y)", unix_path, flags);
d1363 2
a1364 6
  myfault efault;
  if (efault.faulted (EFAULT))
    /* errno already set */;
  else if (!*unix_path)
    set_errno (ENOENT);
  else
d1366 4
a1369 9
      /* check for optional mode argument */
      va_start (ap, flags);
      mode = va_arg (ap, mode_t);
      va_end (ap);

      fhandler_base *fh;
      cygheap_fdnew fd;

      if (fd >= 0)
d1371 54
a1424 45
	  /* This is a temporary kludge until all utilities can catch up with
	     a change in behavior that implements linux functionality:  opening
	     a tty should not automatically cause it to become the controlling
	     tty for the process.  */
	  int opt = PC_OPEN | ((flags & (O_NOFOLLOW | O_EXCL))
			       ?  PC_SYM_NOFOLLOW : PC_SYM_FOLLOW);
	  if (!(flags & O_NOCTTY) && fd > 2 && myself->ctty != -2)
	    {
	      flags |= O_NOCTTY;
	      opt |= PC_CTTY;	/* flag that, if opened, this fhandler could
				   later be capable of being a controlling
				   terminal if /dev/tty is opened. */
	    }
	  if (!(fh = build_fh_name (unix_path, opt, stat_suffixes)))
	    res = -1;		// errno already set
	  else if ((flags & O_NOFOLLOW) && fh->issymlink ())
	    {
	      delete fh;
	      res = -1;
	      set_errno (ELOOP);
	    }
	  else if ((flags & O_DIRECTORY) && fh->exists () && !fh->pc.isdir ())
	    {
	      delete fh;
	      res = -1;
	      set_errno (ENOTDIR);
	    }
	  else if (((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) && fh->exists ())
	    {
	      delete fh;
	      res = -1;
	      set_errno (EEXIST);
	    }
	  else if ((fh->is_fs_special () && fh->device_access_denied (flags))
		   || !fh->open_with_arch (flags, (mode & 07777) & ~cygheap->umask))
	    {
	      delete fh;
	      res = -1;
	    }
	  else
	    {
	      fd = fh;
	      if (fd <= 2)
		set_std_handle (fd);
	      res = fd;
d1427 2
d1430 2
a1431 2

  syscall_printf ("%R = open(%s, %y)", res, unix_path, flags);
d1895 1
a1895 5
  myfault efault;
  if (efault.faulted (EFAULT))
    goto error;

  if (pc.error)
d1897 8
a1904 6
      debug_printf ("got %d error from path_conv", pc.error);
      set_errno (pc.error);
    }
  else if (pc.exists ())
    {
      fhandler_base *fh;
d1906 2
a1907 2
      if (!(fh = build_fh_pc (pc)))
	goto error;
d1909 10
a1918 7
      debug_printf ("(%S, %p, %p), file_attributes %d",
		    pc.get_nt_native_path (), buf, fh, (DWORD) *fh);
      memset (buf, 0, sizeof (*buf));
      res = fh->fstat (buf);
      if (!res)
	fh->stat_fixup (buf);
      delete fh;
d1920 2
a1921 4
  else
    set_errno (ENOENT);

 error:
d2113 1
a2113 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  if (!*oldpath || !*newpath)
d2115 44
a2158 7
      /* Reject rename("","x"), rename("x","").  */
      set_errno (ENOENT);
      goto out;
    }
  if (has_dot_last_component (oldpath, true))
    {
      /* Reject rename("dir/.","x").  */
d2160 9
a2168 30
      set_errno (oldpc.isdir () ? EINVAL : ENOTDIR);
      goto out;
    }
  if (has_dot_last_component (newpath, true))
    {
      /* Reject rename("dir","x/.").  */
      newpc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
      set_errno (!newpc.exists () ? ENOENT : newpc.isdir () ? EINVAL : ENOTDIR);
      goto out;
    }

  /* A trailing slash requires that the pathname points to an existing
     directory.  If it's not, it's a ENOTDIR condition.  The same goes
     for newpath a bit further down this function. */
  olen = strlen (oldpath);
  if (isdirsep (oldpath[olen - 1]))
    {
      char *buf;
      char *p = stpcpy (buf = tp.c_get (), oldpath) - 1;
      oldpath = buf;
      while (p >= oldpath && isdirsep (*p))
	*p-- = '\0';
      olen = p + 1 - oldpath;
      if (!olen)
	{
	  /* The root directory cannot be renamed.  This also rejects
	     the corner case of rename("/","/"), even though it is the
	     same file.  */
	  set_errno (EINVAL);
	  goto out;
d2170 1
a2170 50
      old_dir_requested = true;
    }
  oldpc.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
  if (oldpc.error)
    {
      set_errno (oldpc.error);
      goto out;
    }
  if (!oldpc.exists ())
    {
      set_errno (ENOENT);
      goto out;
    }
  if (oldpc.isspecial () && !oldpc.issocket () && !oldpc.is_fs_special ())
    {
      /* No renames from virtual FS */
      set_errno (EROFS);
      goto out;
    }
  if (oldpc.has_attribute (FILE_ATTRIBUTE_REPARSE_POINT) && !oldpc.issymlink ())
    {
      /* Volume mount point.  If we try to rename a volume mount point, NT
	 returns STATUS_NOT_SAME_DEVICE ==> Win32 ERROR_NOT_SAME_DEVICE ==>
	 errno EXDEV.  That's bad since mv(1) will now perform a cross-device
	 move.  So what we do here is to treat the volume mount point just
	 like Linux treats a mount point. */
      set_errno (EBUSY);
      goto out;
    }
  if (old_dir_requested && !oldpc.isdir ())
    {
      /* Reject rename("file/","x").  */
      set_errno (ENOTDIR);
      goto out;
    }
  if (oldpc.known_suffix
       && (ascii_strcasematch (oldpath + olen - 4, ".lnk")
	   || ascii_strcasematch (oldpath + olen - 4, ".exe")))
    old_explicit_suffix = true;

  nlen = strlen (newpath);
  if (isdirsep (newpath[nlen - 1]))
    {
      char *buf;
      char *p = stpcpy (buf = tp.c_get (), newpath) - 1;
      newpath = buf;
      while (p >= newpath && isdirsep (*p))
	*p-- = '\0';
      nlen = p + 1 - newpath;
      if (!nlen) /* The root directory is never empty.  */
d2172 3
a2174 2
	  set_errno (ENOTEMPTY);
	  goto out;
d2176 2
a2177 46
      new_dir_requested = true;
    }
  newpc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
  if (newpc.error)
    {
      set_errno (newpc.error);
      goto out;
    }
  if (newpc.isspecial () && !newpc.issocket ()) /* No renames to virtual FSes */
    {
      set_errno (EROFS);
      goto out;
    }
  if (new_dir_requested && !(newpc.exists ()
			     ? newpc.isdir () : oldpc.isdir ()))
    {
      /* Reject rename("file1","file2/"), but allow rename("dir","d/").  */
      set_errno (newpc.exists () ? ENOTDIR : ENOENT);
      goto out;
    }
  if (newpc.exists () && (oldpc.isdir () ? !newpc.isdir () : newpc.isdir ()))
    {
      /* Reject rename("file","dir") and rename("dir","file").  */
      set_errno (newpc.isdir () ? EISDIR : ENOTDIR);
      goto out;
    }
  if (newpc.known_suffix
      && (ascii_strcasematch (newpath + nlen - 4, ".lnk")
	  || ascii_strcasematch (newpath + nlen - 4, ".exe")))
    new_explicit_suffix = true;

  /* This test is necessary in almost every case, so just do it once here. */
  equal_path = RtlEqualUnicodeString (oldpc.get_nt_native_path (),
				      newpc.get_nt_native_path (),
				      oldpc.objcaseinsensitive ());

  /* First check if oldpath and newpath only differ by case.  If so, it's
     just a request to change the case of the filename.  By simply setting
     the file attributes to INVALID_FILE_ATTRIBUTES (which translates to
     "file doesn't exist"), all later tests are skipped. */
  if (oldpc.objcaseinsensitive () && newpc.exists () && equal_path
      && old_explicit_suffix == new_explicit_suffix)
    {
      if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
				 newpc.get_nt_native_path (),
				 FALSE))
d2179 7
a2185 2
	  res = 0;
	  goto out;
d2187 1
a2187 8
      newpc.file_attributes (INVALID_FILE_ATTRIBUTES);
    }
  else if (oldpc.isdir ())
    {
      /* Check for newpath being identical or a subdir of oldpath. */
      if (RtlPrefixUnicodeString (oldpc.get_nt_native_path (),
				  newpc.get_nt_native_path (),
				  TRUE))
d2189 19
a2207 2
	  if (newpc.get_nt_native_path ()->Length
	      == oldpc.get_nt_native_path ()->Length)
d2209 2
a2210 8
	      res = 0;
	      goto out;
	    }
	  if (*(PWCHAR) ((PBYTE) newpc.get_nt_native_path ()->Buffer
			 + oldpc.get_nt_native_path ()->Length) == L'\\')
	    {
	      set_errno (EINVAL);
	      goto out;
d2212 1
d2214 2
a2215 4
    }
  else if (!newpc.exists ())
    {
      if (equal_path && old_explicit_suffix != new_explicit_suffix)
d2217 2
a2218 8
	  newpc.check (newpath, PC_SYM_NOFOLLOW);
	  if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
				     newpc.get_nt_native_path (),
				     oldpc.objcaseinsensitive ()))
	    {
	      res = 0;
	      goto out;
	    }
d2220 36
a2255 18
      else if (oldpc.is_lnk_special ()
	       && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
					      &ro_u_lnk, TRUE))
	rename_append_suffix (newpc, newpath, nlen, ".lnk");
      else if (oldpc.is_binary () && !old_explicit_suffix
	       && oldpc.known_suffix
	       && !nt_path_has_executable_suffix (newpc.get_nt_native_path ()))
	/* Never append .exe suffix if oldpath had .exe suffix given
	   explicitely, or if oldpath wasn't already a .exe file, or
	   if the destination filename has one of the blessed executable
	   suffixes.
	   Note: To rename an executable foo.exe to bar-without-suffix,
	   the .exe suffix must be given explicitly in oldpath. */
	rename_append_suffix (newpc, newpath, nlen, ".exe");
    }
  else
    {
      if (equal_path && old_explicit_suffix != new_explicit_suffix)
a2256 1
	  newpc.check (newpath, PC_SYM_NOFOLLOW);
d2259 1
a2259 1
				     oldpc.objcaseinsensitive ()))
d2262 1
a2262 1
	      goto out;
d2264 1
d2266 1
a2266 1
      else if (oldpc.is_lnk_special ())
d2268 4
a2271 3
	  if (!newpc.is_lnk_special ()
	      && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
					     &ro_u_lnk, TRUE))
d2273 12
a2284 2
	      rename_append_suffix (new2pc, newpath, nlen, ".lnk");
	      removepc = &newpc;
d2287 1
a2287 1
      else if (oldpc.is_binary ())
d2289 1
a2289 7
	  /* Never append .exe suffix if oldpath had .exe suffix given
	     explicitely, or if newfile is a binary (in which case the given
	     name probably makes sense as it is), or if the destination
	     filename has one of the blessed executable suffixes. */
	  if (!old_explicit_suffix && oldpc.known_suffix
	      && !newpc.is_binary ()
	      && !nt_path_has_executable_suffix (newpc.get_nt_native_path ()))
d2291 8
a2298 2
	      rename_append_suffix (new2pc, newpath, nlen, ".exe");
	      removepc = &newpc;
d2300 15
d2318 10
a2327 14
	  /* If the new path is an existing .lnk symlink or a .exe file,
	     but the new path has not been specified with explicit suffix,
	     rename to the new name without suffix, as expected, but also
	     remove the clashing symlink or executable.  Did I ever mention
	     how I hate the file suffix idea? */
	  if ((newpc.is_lnk_special ()
	       || RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
					     &ro_u_exe, TRUE))
	      && !new_explicit_suffix)
	    {
	      new2pc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
	      newpc.get_nt_native_path ()->Length -= 4 * sizeof (WCHAR);
	      if (new2pc.is_binary () || new2pc.is_lnk_special ())
		removepc = &new2pc;
d2329 26
a2354 61
	}
    }
  dstpc = (removepc == &newpc) ? &new2pc : &newpc;

  /* Check cross-device before touching anything.  Otherwise we might end
     up with an unlinked target dir even if the actual rename didn't work. */
  if (oldpc.fs_type () != dstpc->fs_type ()
      || oldpc.fs_serial_number () != dstpc->fs_serial_number ())
    {
      set_errno (EXDEV);
      goto out;
    }

  /* Opening the file must be part of the transaction.  It's not sufficient
     to call only NtSetInformationFile under the transaction.  Therefore we
     have to start the transaction here, if necessary. */
  if (wincap.has_transactions ()
      && (dstpc->fs_flags () & FILE_SUPPORTS_TRANSACTIONS)
      && (dstpc->isdir ()
	  || (!removepc && dstpc->has_attribute (FILE_ATTRIBUTE_READONLY))))
    start_transaction (old_trans, trans);

  int retry_count;
  retry_count = 0;
retry:
  /* Talking about inconsistent behaviour...
     - DELETE is required to rename a file.  So far, so good.
     - At least one cifs FS (Tru64) needs FILE_READ_ATTRIBUTE, otherwise the
       FileRenameInformation call fails with STATUS_ACCESS_DENIED.  However,
       on NFS we get a STATUS_ACCESS_DENIED if FILE_READ_ATTRIBUTE is used
       and the file we try to rename is a symlink.  Urgh.
     - Samba (only some versions?) doesn't like the FILE_SHARE_DELETE mode if
       the file has the R/O attribute set and returns STATUS_ACCESS_DENIED in
       that case. */
  {
    ULONG access = DELETE | (oldpc.fs_is_cifs () ? FILE_READ_ATTRIBUTES : 0);
    ULONG sharing = FILE_SHARE_READ | FILE_SHARE_WRITE
		    | (oldpc.fs_is_samba () ? 0 : FILE_SHARE_DELETE);
    ULONG flags = FILE_OPEN_FOR_BACKUP_INTENT
		  | (oldpc.is_rep_symlink () ? FILE_OPEN_REPARSE_POINT : 0);
    status = NtOpenFile (&fh, access,
			 oldpc.get_object_attr (attr, sec_none_nih),
			 &io, sharing, flags);
  }
  if (!NT_SUCCESS (status))
    {
      debug_printf ("status %y", status);
      if (status == STATUS_SHARING_VIOLATION
	  && cygwait (10L) != WAIT_SIGNALED)
	{
	  /* Typical BLODA problem.  Some virus scanners check newly generated
	     files and while doing that disallow DELETE access.  That's really
	     bad because it breaks applications which copy files by creating
	     a temporary filename and then rename the temp filename to the
	     target filename.  This renaming fails due to the jealous virus
	     scanner and the application fails to create the target file.

	     This kludge tries to work around that by yielding until the
	     sharing violation goes away, or a signal arrived, or after
	     about a second, give or take. */
	  if (++retry_count < 40)
d2356 15
a2370 2
	      yield ();
	      goto retry;
d2373 6
a2378 1
      else if (NT_TRANSACTIONAL_ERROR (status) && trans)
d2380 36
a2415 18
	  /* If NtOpenFile fails due to transactional problems, stop
	     transaction and go ahead without. */
	  stop_transaction (status, old_trans, trans);
	  debug_printf ("Transaction failure.  Retry open.");
	  goto retry;
	}
      __seterrno_from_nt_status (status);
      goto out;
    }

  /* Renaming a dir to another, existing dir fails always, even if
     ReplaceIfExists is set to TRUE and the existing dir is empty.  So
     we have to remove the destination dir first.  This also covers the
     case that the destination directory is not empty.  In that case,
     unlink_nt returns with STATUS_DIRECTORY_NOT_EMPTY. */
  if (dstpc->isdir ())
    {
      status = unlink_nt (*dstpc);
d2418 29
d2448 1
a2448 1
	  goto out;
d2450 7
a2456 14
    }
  /* You can't copy a file if the destination exists and has the R/O
     attribute set.  Remove the R/O attribute first.  But first check
     if a removepc exists.  If so, dstpc points to a non-existing file
     due to a mangled suffix. */
  else if (!removepc && dstpc->has_attribute (FILE_ATTRIBUTE_READONLY))
    {
      status = NtOpenFile (&nfh, FILE_WRITE_ATTRIBUTES,
			   dstpc->get_object_attr (attr, sec_none_nih),
			   &io, FILE_SHARE_VALID_FLAGS,
			   FILE_OPEN_FOR_BACKUP_INTENT
			   | (dstpc->is_rep_symlink ()
			      ? FILE_OPEN_REPARSE_POINT : 0));
      if (!NT_SUCCESS (status))
d2458 6
a2463 2
	  __seterrno_from_nt_status (status);
	  goto out;
d2465 5
a2469 4
      status = NtSetAttributesFile (nfh, dstpc->file_attributes ()
					 & ~FILE_ATTRIBUTE_READONLY);
      NtClose (nfh);
      if (!NT_SUCCESS (status))
d2471 19
a2489 2
	  __seterrno_from_nt_status (status);
	  goto out;
a2490 1
    }
d2492 14
a2505 14
  /* SUSv3: If the old argument and the new argument resolve to the same
     existing file, rename() shall return successfully and perform no
     other action.
     The test tries to be as quick as possible.  Due to the above cross device
     check we already know both files are on the same device.  So it just
     tests if oldpath has more than 1 hardlink, then it opens newpath
     and tests for identical file ids.  If so, oldpath and newpath refer to
     the same file. */
  if ((removepc || dstpc->exists ())
      && !oldpc.isdir ()
      && NT_SUCCESS (NtQueryInformationFile (fh, &io, &ofsi, sizeof ofsi,
					     FileStandardInformation))
      && ofsi.NumberOfLinks > 1
      && NT_SUCCESS (NtOpenFile (&nfh, READ_CONTROL,
d2511 2
a2512 2
    {
      FILE_INTERNAL_INFORMATION ofii, nfii;
d2514 12
a2525 7
      if (NT_SUCCESS (NtQueryInformationFile (fh, &io, &ofii, sizeof ofii,
					      FileInternalInformation))
	  && NT_SUCCESS (NtQueryInformationFile (nfh, &io, &nfii, sizeof nfii,
						 FileInternalInformation))
	  && ofii.FileId.QuadPart == nfii.FileId.QuadPart)
	{
	  debug_printf ("%s and %s are the same file", oldpath, newpath);
a2526 2
	  res = 0;
	  goto out;
d2528 5
a2532 32
      NtClose (nfh);
    }
  /* Create FILE_RENAME_INFORMATION struct.  Using a tmp_pathbuf area allows
     for paths of up to 32757 chars.  This test is just for paranoia's sake. */
  if (dstpc->get_nt_native_path ()->Length > NT_MAX_PATH * sizeof (WCHAR)
					     - sizeof (FILE_RENAME_INFORMATION))
    {
      debug_printf ("target filename too long");
      set_errno (EINVAL);
      goto out;
    }
  pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
  pfri->ReplaceIfExists = TRUE;
  pfri->RootDirectory = NULL;
  pfri->FileNameLength = dstpc->get_nt_native_path ()->Length;
  memcpy (&pfri->FileName,  dstpc->get_nt_native_path ()->Buffer,
	  pfri->FileNameLength);
  status = NtSetInformationFile (fh, &io, pfri,
  				 sizeof *pfri + pfri->FileNameLength,
				 FileRenameInformation);
  /* This happens if the access rights don't allow deleting the destination.
     Even if the handle to the original file is opened with BACKUP
     and/or RECOVERY, these flags don't apply to the destination of the
     rename operation.  So, a privileged user can't rename a file to an
     existing file, if the permissions of the existing file aren't right.
     Like directories, we have to handle this separately by removing the
     destination before renaming. */
  if (status == STATUS_ACCESS_DENIED && dstpc->exists () && !dstpc->isdir ())
    {
      if (wincap.has_transactions ()
	  && (dstpc->fs_flags () & FILE_SUPPORTS_TRANSACTIONS)
	  && !trans)
d2534 45
a2578 20
	  start_transaction (old_trans, trans);
	  /* As mentioned earlier, opening the file must be part of the
	     transaction.  Therefore we have to reopen the file here if the
	     transaction hasn't been started already.  Unfortunately we can't
	     use the NT "reopen file from existing handle" feature.  In that
	     case NtOpenFile returns STATUS_TRANSACTIONAL_CONFLICT.  We *have*
	     to close the handle to the file first, *then* we can re-open it.
	     Fortunately nothing has happened yet, so the atomicity of the
	     rename functionality is not spoiled. */
	  NtClose (fh);
retry_reopen:
	  status = NtOpenFile (&fh, DELETE,
			       oldpc.get_object_attr (attr, sec_none_nih),
			       &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT
			       | (oldpc.is_rep_symlink ()
				  ? FILE_OPEN_REPARSE_POINT : 0));
	  if (!NT_SUCCESS (status))
	    {
	      if (NT_TRANSACTIONAL_ERROR (status) && trans)
d2580 10
a2589 5
		  /* If NtOpenFile fails due to transactional problems, stop
		     transaction and go ahead without. */
		  stop_transaction (status, old_trans, trans);
		  debug_printf ("Transaction failure.  Retry open.");
		  goto retry_reopen;
d2591 11
a2601 3
	      __seterrno_from_nt_status (status);
	      goto out;
	    }
d2603 2
a2604 4
      if (NT_SUCCESS (status = unlink_nt (*dstpc)))
	status = NtSetInformationFile (fh, &io, pfri,
				       sizeof *pfri + pfri->FileNameLength,
				       FileRenameInformation);
d2606 1
a2606 1
  if (NT_SUCCESS (status))
d2608 1
a2608 3
      if (removepc)
	unlink_nt (*removepc);
      res = 0;
d2610 1
a2610 4
  else
    __seterrno_from_nt_status (status);

out:
d2616 2
a2617 1
  syscall_printf ("%R = rename(%s, %s)", res, oldpath, newpath);
d2626 2
a2627 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d2629 1
a2629 1
  int res;
d2632 6
a2637 2
  if (cmdstring == NULL)
    return 1;
d2639 6
a2644 10
  command[0] = "sh";
  command[1] = "-c";
  command[2] = cmdstring;
  command[3] = (const char *) NULL;

  if ((res = spawnvp (_P_SYSTEM, "/bin/sh", command)) == -1)
    {
      // when exec fails, return value should be as if shell
      // executed exit (127)
      res = 127;
d2646 2
a2647 1

d2692 1
a2692 1
  fhandler_base *fh;
d2695 1
a2695 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  if (!*file)
d2697 11
a2707 2
      set_errno (ENOENT);
      return -1;
d2709 2
a2710 6
  if (!(fh = build_fh_name (file, PC_SYM_FOLLOW, stat_suffixes)))
    return -1;
  if (!fh->exists ())
    set_errno (ENOENT);
  else
    ret = fh->fpathconf (v);
d2719 2
a2720 4
  myfault efault;
  if (efault.faulted ())
    ret = EFAULT;
  else
d2731 5
d2737 1
a2737 1
  debug_printf ("returning %d tty: %s", ret, ret ? "NULL" : buf);
d2994 10
a3003 8
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
  return cfd->fstatvfs (sfs);
d3012 4
a3015 3
  myfault efault;
  if (efault.faulted (EFAULT))
    goto error;
d3017 12
a3028 2
  if (!(fh = build_fh_name (name, PC_SYM_FOLLOW, stat_suffixes)))
    goto error;
a3029 9
  if (fh->error ())
    {
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
    }
  else if (fh->exists ())
    {
      debug_printf ("(%s, %p), file_attributes %d", name, sfs, (DWORD) *fh);
      res = fh->fstatvfs (sfs);
d3031 2
a3032 3
  else
    set_errno (ENOENT);

a3033 1
 error:
d3035 2
a3036 1
  syscall_printf ("%R = statvfs(%s,%p)", res, name, sfs);
d3177 1
a3177 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (!*path)
d3179 8
a3186 3
      set_errno (ENOENT);
      return -1;
    }
d3188 6
a3193 2
  if (strlen (path) >= PATH_MAX)
    return -1;
d3195 8
a3202 6
  path_conv w32path (path, PC_SYM_NOFOLLOW);
  if (w32path.exists ())
    {
      set_errno (EEXIST);
      return -1;
    }
d3204 4
a3207 8
  mode_t type = mode & S_IFMT;
  _major_t major = _major (dev);
  _minor_t minor = _minor (dev);
  switch (type)
    {
    case S_IFCHR:
    case S_IFBLK:
      break;
d3209 9
a3217 4
    case S_IFIFO:
      major = _major (FH_FIFO);
      minor = _minor (FH_FIFO);
      break;
d3219 4
a3222 9
    case 0:
    case S_IFREG:
      {
	int fd = open (path, O_CREAT, mode);
	if (fd < 0)
	  return -1;
	close (fd);
	return 0;
      }
d3224 1
a3224 3
    default:
      set_errno (EINVAL);
      return -1;
d3226 3
a3228 2

  return mknod_worker (w32path.get_win32 (), type, mode, major, minor);
d3937 1
a3937 2
  myfault efault;
  if (efault.faulted () || !*file)
d3939 7
a3945 2
      debug_printf ("Invalid file");
      return;
d3947 3
a3949 3
  endutent ();
  utmp_file = strdup (file);
  debug_printf ("New UTMP file: %s", utmp_file);
d3994 1
a3994 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
  if (utmp_fd < 0)
a3995 1
      internal_setutent (false);
a3996 7
	return NULL;
    }

  utmp *ut = utmp_data;
  while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
    {
      switch (id->ut_type)
d3998 26
a4023 16
	case RUN_LVL:
	case BOOT_TIME:
	case OLD_TIME:
	case NEW_TIME:
	  if (id->ut_type == ut->ut_type)
	    return ut;
	  break;
	case INIT_PROCESS:
	case LOGIN_PROCESS:
	case USER_PROCESS:
	case DEAD_PROCESS:
	   if (strncmp (id->ut_id, ut->ut_id, UT_IDLEN) == 0)
	    return ut;
	  break;
	default:
	  return NULL;
d4026 2
d4034 1
a4034 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
  if (utmp_fd < 0)
a4035 1
      internal_setutent (false);
d4037 12
a4048 1
	return NULL;
d4050 2
a4051 8

  utmp *ut = utmp_data;
  while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
    if ((ut->ut_type == LOGIN_PROCESS ||
	 ut->ut_type == USER_PROCESS) &&
	!strncmp (ut->ut_line, line->ut_line, sizeof (ut->ut_line)))
      return ut;

d4058 1
a4058 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
  internal_setutent (true);
  if (utmp_fd < 0)
d4060 23
a4082 2
      debug_printf ("error: utmp_fd %d", utmp_fd);
      return NULL;
d4084 3
a4086 17
  debug_printf ("ut->ut_type %d, ut->ut_pid %d, ut->ut_line '%s', ut->ut_id '%s'\n",
		ut->ut_type, ut->ut_pid, ut->ut_line, ut->ut_id);
  debug_printf ("ut->ut_user '%s', ut->ut_host '%s'\n",
		ut->ut_user, ut->ut_host);

  struct utmp *u;
  if ((u = getutid (ut)))
    {
      lseek (utmp_fd, -sizeof *ut, SEEK_CUR);
      write (utmp_fd, ut, sizeof *ut);
    }
  else
    locked_append (utmp_fd, ut, sizeof *ut);
  /* The documentation says to return a pointer to this which implies that
     this has to be cast from a const.  That doesn't seem right but the
     documentation seems pretty clear on this.  */
  return (struct utmp *) ut;
d4104 1
a4104 1
  /* UGH.  Not thread safe. */
d4112 1
a4112 1
  /* UGH.  Not thread safe. */
d4115 8
a4122 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
  ((struct utmpx *)id)->ut_time = id->ut_tv.tv_sec;
  return copy_ut_to_utx (getutid ((struct utmp *) id), &utx);
d4128 1
a4128 1
  /* UGH.  Not thread safe. */
d4131 8
a4138 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
  ((struct utmpx *)line)->ut_time = line->ut_tv.tv_sec;
  return copy_ut_to_utx (getutline ((struct utmp *) line), &utx);
d4144 1
a4144 1
  /* UGH.  Not thread safe. */
d4147 8
a4154 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
  ((struct utmpx *)utmpx)->ut_time = utmpx->ut_tv.tv_sec;
  return copy_ut_to_utx (pututline ((struct utmp *) utmpx), &utx);
d4518 5
a4522 6
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
d4524 2
a4525 2
  va_list ap;
  mode_t mode;
d4527 8
a4534 4
  va_start (ap, flags);
  mode = va_arg (ap, mode_t);
  va_end (ap);
  return open (path, flags, mode);
d4541 1
a4541 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d4543 1
a4543 3
  int res = -1;
  char *path = tp.c_get ();
  if (!gen_full_path_at (path, dirfd, pathname))
d4545 2
a4546 4
      if ((mode & ~(F_OK|R_OK|W_OK|X_OK))
	  || (flags & ~(AT_SYMLINK_NOFOLLOW|AT_EACCESS)))
	set_errno (EINVAL);
      else
d4548 4
a4551 6
	  fhandler_base *fh = build_fh_name (path, (flags & AT_SYMLINK_NOFOLLOW
						    ? PC_SYM_NOFOLLOW
						    : PC_SYM_FOLLOW)
						   | PC_KEEP_HANDLE,
					     stat_suffixes);
	  if (fh)
d4553 11
a4563 2
	      res =  fh->fhaccess (mode, !!(flags & AT_EACCESS));
	      delete fh;
d4567 2
d4577 1
a4577 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (flags)
d4579 12
a4590 5
      /* BSD has lchmod, but Linux does not.  POSIX says
	 AT_SYMLINK_NOFOLLOW is allowed to fail on symlinks; but Linux
	 blindly fails even for non-symlinks.  */
      set_errno ((flags & ~AT_SYMLINK_NOFOLLOW) ? EINVAL : EOPNOTSUPP);
      return -1;
d4592 3
a4594 4
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return chmod (path, mode);
d4601 1
a4601 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (flags & ~AT_SYMLINK_NOFOLLOW)
d4603 10
a4612 2
      set_errno (EINVAL);
      return -1;
d4614 3
a4616 5
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return chown_worker (path, (flags & AT_SYMLINK_NOFOLLOW)
			     ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW, uid, gid);
d4624 1
a4624 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (flags & ~AT_SYMLINK_NOFOLLOW)
d4626 12
a4637 2
      set_errno (EINVAL);
      return -1;
d4639 3
a4641 7
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  path_conv pc (path, ((flags & AT_SYMLINK_NOFOLLOW)
		       ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)
		      | PC_POSIX | PC_KEEP_HANDLE, stat_suffixes);
  return stat_worker (pc, st);
d4651 1
a4651 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (flags & ~AT_SYMLINK_NOFOLLOW)
d4653 12
a4664 2
      set_errno (EINVAL);
      return -1;
d4666 3
a4668 6
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  path_conv win32 (path, PC_POSIX | ((flags & AT_SYMLINK_NOFOLLOW)
				     ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW),
		   stat_suffixes);
  return utimens_worker (win32, times);
d4675 10
a4684 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname, true))
    return -1;
  return utimes (path, times);
d4693 1
a4693 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (flags & ~AT_SYMLINK_FOLLOW)
d4695 12
a4706 13
      set_errno (EINVAL);
      return -1;
    }
  char *oldpath = tp.c_get ();
  if (gen_full_path_at (oldpath, olddirfd, oldpathname))
    return -1;
  char *newpath = tp.c_get ();
  if (gen_full_path_at (newpath, newdirfd, newpathname))
    return -1;
  if (flags & AT_SYMLINK_FOLLOW)
    {
      path_conv old_name (oldpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
      if (old_name.error)
d4708 7
a4714 2
	  set_errno (old_name.error);
	  return -1;
d4716 1
a4716 1
      strcpy (oldpath, old_name.normalized_path);
d4718 3
a4720 1
  return link (oldpath, newpath);
d4727 10
a4736 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return mkdir (path, mode);
d4743 10
a4752 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return mkfifo (path, mode);
d4759 10
a4768 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return mknod32 (path, mode, dev);
d4776 10
a4785 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return readlink (path, buf, bufsize);
d4793 13
a4805 10
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *oldpath = tp.c_get ();
  if (gen_full_path_at (oldpath, olddirfd, oldpathname))
    return -1;
  char *newpath = tp.c_get ();
  if (gen_full_path_at (newpath, newdirfd, newpathname))
    return -1;
  return rename (oldpath, newpath);
d4814 10
a4823 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return scandir (pathname, namelist, select, compar);
d4830 10
a4839 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  char *newpath = tp.c_get ();
  if (gen_full_path_at (newpath, newdirfd, newpathname))
    return -1;
  return symlink (oldpath, newpath);
d4846 1
a4846 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (flags & ~AT_REMOVEDIR)
d4848 9
a4856 2
      set_errno (EINVAL);
      return -1;
d4858 3
a4860 4
  char *path = tp.c_get ();
  if (gen_full_path_at (path, dirfd, pathname))
    return -1;
  return (flags & AT_REMOVEDIR) ? rmdir (path) : unlink (path);
@


1.663
log
@	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).
@
text
@a60 1
#include "cpuid.h"
@


1.662
log
@	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).
@
text
@d4358 11
a4368 2
  close (fds[0]);
  close (fds[1]);
@


1.661
log
@	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.
@
text
@d4182 1
a4182 1
       ch != EOF && !isspace (ch) && buf_idx < PATH_MAX;
@


1.660
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d190 1
a190 1
		 && ((ULONG)(s) <= (ULONG)STATUS_LOG_GROWTH_FAILED))
@


1.659
log
@	* include/netinet/ip6.h: New file, copied from FreeBSD vebatim.
@
text
@a60 1
#include "pwdgrp.h"
@


1.659.2.1
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@d61 1
d191 1
a191 1
		 && ((ULONG)(s) <= (ULONG)STATUS_TRANSACTION_NOT_ENLISTED))
d4183 1
a4183 1
       ch != EOF && !isspace (ch) && buf_idx < (PATH_MAX - 1);
@


1.659.2.2
log
@	revert accidental checkin of removing "#include <pwdgrp.h>"
@
text
@a60 1
#include "pwdgrp.h"
@


1.659.2.3
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d4359 2
a4360 11
  if (fp)
    {
      /* Must fclose fp to avoid memory leak. */
      fclose (fp);
      close (fds[myix ^ 1]);
    }
  else
    {
      close (fds[0]);
      close (fds[1]);
    }
@


1.659.2.4
log
@2014-08-11  Corinna Vinschen  <corinna@@vinschen.de>

	* cpuid.h: Add missing copyright header.  Fix formatting.  Use uint32_t
	instead of unsigned throughout.  Change functions to static inline and
	always inline.
	(cpuid): Add parameter to set ecx, allowing to request extended CPUID
	info.
	* fhandler_proc.cc (format_proc_cpuinfo): Use uint32_t instead of
	unsigned throughout.  Add fake decimal places to MHz info.  Handle more
	feature flags.
	* fhandler_random.cc (fhandler_dev_random::write): Allow up to 4K
	input to add entropy.
	* syscalls.cc: Drop including cpuid.h.

2014-08-07  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (__cxa_finalize): Export.
	* dcrt0.cc (cygwin_atexit): Use d->handle with __cxa_atexit.
	* dll_init.cc (dll_list::detach): Use d->handle with __cxa_finalize.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Use 274 for
	__cxa_finalize as well.

2014-08-04  Anthony Heading  <anthony@@ajrh.net>

	* include/sys/file.h: Add extern "C".

2014-08-04  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Export.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump to 274.

2014-07-31  Eric Blake  <eblake@@redhat.com>

	* include/pthread.h: Decorate attribute names with __, for
	namespace safety.
	* include/cygwin/core_dump.h: Likewise.
	* include/cygwin/cygwin_dll.h: Likewise.
	* include/sys/cygwin.h: Likewise.
	* include/sys/strace.h: Likewise.
@
text
@d62 1
@


1.659.2.5
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d723 1
a723 1
	  pc.init_reopen_attr (attr, fh_ro);
d951 2
a952 2
	  status = NtOpenFile (&fh2, DELETE,
			       pc.init_reopen_attr (attr, fh), &io,
d1167 6
d1175 3
a1177 1
  pthread_testcancel ();
d1179 1
a1179 1
  __try
d1181 3
a1183 3
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;
d1185 3
a1187 5
      if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}
d1189 1
a1189 3
      /* Could block, so let user know we at least got here.  */
      syscall_printf ("read(%d, %p, %d) %sblocking",
		      fd, ptr, len, cfd->is_nonblocking () ? "non" : "");
d1191 1
a1191 5
      cfd->read (ptr, len);
      res = len;
    }
  __except (EFAULT) {}
  __endtry
d1202 6
d1209 1
d1211 3
a1213 1
  pthread_testcancel ();
d1215 1
a1215 1
  __try
d1217 3
a1219 1
      const ssize_t tot = check_iovec_for_read (iov, iovcnt);
d1221 5
a1225 3
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;
d1227 3
a1229 5
      if (tot <= 0)
	{
	  res = tot;
	  __leave;
	}
d1231 1
a1231 9
      if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}

      /* Could block, so let user know we at least got here.  */
      syscall_printf ("readv(%d, %p, %d) %sblocking",
		      fd, iov, iovcnt, cfd->is_nonblocking () ? "non" : "");
d1233 1
a1233 4
      res = cfd->readv (iov, iovcnt, tot);
    }
  __except (EFAULT) {}
  __endtry
a1241 2
  ssize_t res;

d1244 1
d1258 6
d1266 3
a1268 1
  pthread_testcancel ();
d1270 1
a1270 1
  __try
d1272 3
a1274 3
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;
d1276 5
a1280 5
      if ((cfd->get_flags () & O_ACCMODE) == O_RDONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}
d1282 1
a1282 5
      /* Could block, so let user know we at least got here.  */
      if (fd == 1 || fd == 2)
	paranoid_printf ("write(%d, %p, %d)", fd, ptr, len);
      else
	syscall_printf  ("write(%d, %p, %d)", fd, ptr, len);
d1284 1
a1284 4
      res = cfd->write (ptr, len);
    }
  __except (EFAULT) {}
  __endtry
d1286 1
d1296 6
d1303 1
d1305 3
a1307 1
  pthread_testcancel ();
d1309 1
a1309 1
  __try
d1311 3
a1313 1
      const ssize_t tot = check_iovec_for_write (iov, iovcnt);
d1315 5
a1319 3
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;
d1321 5
a1325 11
      if (tot <= 0)
	{
	  res = tot;
	  __leave;
	}

      if ((cfd->get_flags () & O_ACCMODE) == O_RDONLY)
	{
	  set_errno (EBADF);
	  __leave;
	}
d1327 1
a1327 5
      /* Could block, so let user know we at least got here.  */
      if (fd == 1 || fd == 2)
	paranoid_printf ("writev(%d, %p, %d)", fd, iov, iovcnt);
      else
	syscall_printf  ("writev(%d, %p, %d)", fd, iov, iovcnt);
d1329 1
a1329 4
      res = cfd->writev (iov, iovcnt, tot);
    }
  __except (EFAULT) {}
  __endtry
d1334 1
d1365 1
d1367 6
a1372 2

  __try
d1374 4
a1377 9
      syscall_printf ("open(%s, %y)", unix_path, flags);
      if (!*unix_path)
	set_errno (ENOENT);
      else
	{
	  /* check for optional mode argument */
	  va_start (ap, flags);
	  mode = va_arg (ap, mode_t);
	  va_end (ap);
d1379 2
a1380 2
	  fhandler_base *fh;
	  cygheap_fdnew fd;
d1382 24
a1405 1
	  if (fd >= 0)
d1407 22
a1428 44
	      /* This is a temporary kludge until all utilities can catch up
		 with a change in behavior that implements linux functionality: 
		 opening a tty should not automatically cause it to become the
		 controlling tty for the process.  */
	      int opt = PC_OPEN | ((flags & (O_NOFOLLOW | O_EXCL))
				   ?  PC_SYM_NOFOLLOW : PC_SYM_FOLLOW);
	      if (!(flags & O_NOCTTY) && fd > 2 && myself->ctty != -2)
		{
		  flags |= O_NOCTTY;
		  /* flag that, if opened, this fhandler could later be capable
		     of being a controlling terminal if /dev/tty is opened. */
		  opt |= PC_CTTY;
		}
	      if (!(fh = build_fh_name (unix_path, opt, stat_suffixes)))
		;		// errno already set
	      else if ((flags & O_NOFOLLOW) && fh->issymlink ())
		{
		  delete fh;
		  set_errno (ELOOP);
		}
	      else if ((flags & O_DIRECTORY) && fh->exists ()
		       && !fh->pc.isdir ())
		{
		  delete fh;
		  set_errno (ENOTDIR);
		}
	      else if (((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
		       && fh->exists ())
		{
		  delete fh;
		  set_errno (EEXIST);
		}
	      else if ((fh->is_fs_special ()
	      		&& fh->device_access_denied (flags))
		       || !fh->open_with_arch (flags, (mode & 07777)
						      & ~cygheap->umask))
		delete fh;
	      else
		{
		  fd = fh;
		  if (fd <= 2)
		    set_std_handle (fd);
		  res = fd;
		}
d1431 1
d1433 1
a1433 4
      syscall_printf ("%R = open(%s, %y)", res, unix_path, flags);
    }
  __except (EFAULT) {}
  __endtry
d1897 5
a1901 1
  __try
d1903 6
a1908 8
      if (pc.error)
	{
	  debug_printf ("got %d error from path_conv", pc.error);
	  set_errno (pc.error);
	}
      else if (pc.exists ())
	{
	  fhandler_base *fh;
d1910 2
a1911 2
	  if (!(fh = build_fh_pc (pc)))
	    __leave;
d1913 7
a1919 10
	  debug_printf ("(%S, %p, %p), file_attributes %d",
			pc.get_nt_native_path (), buf, fh, (DWORD) *fh);
	  memset (buf, 0, sizeof (*buf));
	  res = fh->fstat (buf);
	  if (!res)
	    fh->stat_fixup (buf);
	  delete fh;
	}
      else
	set_errno (ENOENT);
d1921 4
a1924 2
  __except (EFAULT) {}
  __endtry
d2116 5
a2120 1
  __try
d2122 7
a2128 44
      if (!*oldpath || !*newpath)
	{
	  /* Reject rename("","x"), rename("x","").  */
	  set_errno (ENOENT);
	  __leave;
	}
      if (has_dot_last_component (oldpath, true))
	{
	  /* Reject rename("dir/.","x").  */
	  oldpc.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	  set_errno (oldpc.isdir () ? EINVAL : ENOTDIR);
	  __leave;
	}
      if (has_dot_last_component (newpath, true))
	{
	  /* Reject rename("dir","x/.").  */
	  newpc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
	  set_errno (!newpc.exists () ? ENOENT
				      : newpc.isdir () ? EINVAL : ENOTDIR);
	  __leave;
	}

      /* A trailing slash requires that the pathname points to an existing
	 directory.  If it's not, it's a ENOTDIR condition.  The same goes
	 for newpath a bit further down this function. */
      olen = strlen (oldpath);
      if (isdirsep (oldpath[olen - 1]))
	{
	  char *buf;
	  char *p = stpcpy (buf = tp.c_get (), oldpath) - 1;
	  oldpath = buf;
	  while (p >= oldpath && isdirsep (*p))
	    *p-- = '\0';
	  olen = p + 1 - oldpath;
	  if (!olen)
	    {
	      /* The root directory cannot be renamed.  This also rejects
		 the corner case of rename("/","/"), even though it is the
		 same file.  */
	      set_errno (EINVAL);
	      __leave;
	    }
	  old_dir_requested = true;
	}
d2130 30
a2159 4
      if (oldpc.error)
	{
	  set_errno (oldpc.error);
	  __leave;
d2161 50
a2210 1
      if (!oldpc.exists ())
d2212 2
a2213 2
	  set_errno (ENOENT);
	  __leave;
d2215 46
a2260 1
      if (oldpc.isspecial () && !oldpc.issocket () && !oldpc.is_fs_special ())
d2262 2
a2263 3
	  /* No renames from virtual FS */
	  set_errno (EROFS);
	  __leave;
d2265 8
a2272 2
      if (oldpc.has_attribute (FILE_ATTRIBUTE_REPARSE_POINT)
	  && !oldpc.issymlink ())
d2274 12
a2285 7
	  /* Volume mount point.  If we try to rename a volume mount point, NT
	     returns STATUS_NOT_SAME_DEVICE ==> Win32 ERROR_NOT_SAME_DEVICE ==>
	     errno EXDEV.  That's bad since mv(1) will now perform a
	     cross-device move.  So what we do here is to treat the volume
	     mount point just like Linux treats a mount point. */
	  set_errno (EBUSY);
	  __leave;
d2287 4
a2290 1
      if (old_dir_requested && !oldpc.isdir ())
d2292 4
a2295 19
	  /* Reject rename("file/","x").  */
	  set_errno (ENOTDIR);
	  __leave;
	}
      if (oldpc.known_suffix
	   && (ascii_strcasematch (oldpath + olen - 4, ".lnk")
	       || ascii_strcasematch (oldpath + olen - 4, ".exe")))
	old_explicit_suffix = true;

      nlen = strlen (newpath);
      if (isdirsep (newpath[nlen - 1]))
	{
	  char *buf;
	  char *p = stpcpy (buf = tp.c_get (), newpath) - 1;
	  newpath = buf;
	  while (p >= newpath && isdirsep (*p))
	    *p-- = '\0';
	  nlen = p + 1 - newpath;
	  if (!nlen) /* The root directory is never empty.  */
d2297 2
a2298 2
	      set_errno (ENOTEMPTY);
	      __leave;
a2299 1
	  new_dir_requested = true;
d2301 18
a2318 42
      newpc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
      if (newpc.error)
	{
	  set_errno (newpc.error);
	  __leave;
	}
      if (newpc.isspecial () && !newpc.issocket ())
	{
	  /* No renames to virtual FSes */
	  set_errno (EROFS);
	  __leave;
	}
      if (new_dir_requested && !(newpc.exists ()
				 ? newpc.isdir () : oldpc.isdir ()))
	{
	  /* Reject rename("file1","file2/"), but allow rename("dir","d/").  */
	  set_errno (newpc.exists () ? ENOTDIR : ENOENT);
	  __leave;
	}
      if (newpc.exists ()
	  && (oldpc.isdir () ? !newpc.isdir () : newpc.isdir ()))
	{
	  /* Reject rename("file","dir") and rename("dir","file").  */
	  set_errno (newpc.isdir () ? EISDIR : ENOTDIR);
	  __leave;
	}
      if (newpc.known_suffix
	  && (ascii_strcasematch (newpath + nlen - 4, ".lnk")
	      || ascii_strcasematch (newpath + nlen - 4, ".exe")))
	new_explicit_suffix = true;

      /* This test is necessary in almost every case, so do it once here. */
      equal_path = RtlEqualUnicodeString (oldpc.get_nt_native_path (),
					  newpc.get_nt_native_path (),
					  oldpc.objcaseinsensitive ());

      /* First check if oldpath and newpath only differ by case.  If so, it's
	 just a request to change the case of the filename.  By simply setting
	 the file attributes to INVALID_FILE_ATTRIBUTES (which translates to
	 "file doesn't exist"), all later tests are skipped. */
      if (oldpc.objcaseinsensitive () && newpc.exists () && equal_path
	  && old_explicit_suffix == new_explicit_suffix)
d2320 1
d2323 1
a2323 1
				     FALSE))
d2326 1
a2326 1
	      __leave;
a2327 1
	  newpc.file_attributes (INVALID_FILE_ATTRIBUTES);
d2329 1
a2329 1
      else if (oldpc.isdir ())
d2331 3
a2333 4
	  /* Check for newpath being identical or a subdir of oldpath. */
	  if (RtlPrefixUnicodeString (oldpc.get_nt_native_path (),
				      newpc.get_nt_native_path (),
				      TRUE))
d2335 2
a2336 12
	      if (newpc.get_nt_native_path ()->Length
		  == oldpc.get_nt_native_path ()->Length)
		{
		  res = 0;
		  __leave;
		}
	      if (*(PWCHAR) ((PBYTE) newpc.get_nt_native_path ()->Buffer
			     + oldpc.get_nt_native_path ()->Length) == L'\\')
		{
		  set_errno (EINVAL);
		  __leave;
		}
d2339 1
a2339 1
      else if (!newpc.exists ())
d2341 7
a2347 1
	  if (equal_path && old_explicit_suffix != new_explicit_suffix)
d2349 2
a2350 8
	      newpc.check (newpath, PC_SYM_NOFOLLOW);
	      if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
					 newpc.get_nt_native_path (),
					 oldpc.objcaseinsensitive ()))
		{
		  res = 0;
		  __leave;
		}
a2351 15
	  else if (oldpc.is_lnk_special ()
		   && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
						  &ro_u_lnk, TRUE))
	    rename_append_suffix (newpc, newpath, nlen, ".lnk");
	  else if (oldpc.is_binary () && !old_explicit_suffix
		   && oldpc.known_suffix
		   && !nt_path_has_executable_suffix
		   				(newpc.get_nt_native_path ()))
	    /* Never append .exe suffix if oldpath had .exe suffix given
	       explicitely, or if oldpath wasn't already a .exe file, or
	       if the destination filename has one of the blessed executable
	       suffixes.
	       Note: To rename an executable foo.exe to bar-without-suffix,
	       the .exe suffix must be given explicitly in oldpath. */
	    rename_append_suffix (newpc, newpath, nlen, ".exe");
d2355 9
a2363 1
	  if (equal_path && old_explicit_suffix != new_explicit_suffix)
d2365 4
a2368 8
	      newpc.check (newpath, PC_SYM_NOFOLLOW);
	      if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
					 newpc.get_nt_native_path (),
					 oldpc.objcaseinsensitive ()))
		{
		  res = 0;
		  __leave;
		}
d2370 61
a2430 1
	  else if (oldpc.is_lnk_special ())
d2432 2
a2433 40
	      if (!newpc.is_lnk_special ()
		  && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
						 &ro_u_lnk, TRUE))
		{
		  rename_append_suffix (new2pc, newpath, nlen, ".lnk");
		  removepc = &newpc;
		}
	    }
	  else if (oldpc.is_binary ())
	    {
	      /* Never append .exe suffix if oldpath had .exe suffix given
		 explicitely, or if newfile is a binary (in which case the given
		 name probably makes sense as it is), or if the destination
		 filename has one of the blessed executable suffixes. */
	      if (!old_explicit_suffix && oldpc.known_suffix
		  && !newpc.is_binary ()
		  && !nt_path_has_executable_suffix
		  				(newpc.get_nt_native_path ()))
		{
		  rename_append_suffix (new2pc, newpath, nlen, ".exe");
		  removepc = &newpc;
		}
	    }
	  else
	    {
	      /* If the new path is an existing .lnk symlink or a .exe file,
		 but the new path has not been specified with explicit suffix,
		 rename to the new name without suffix, as expected, but also
		 remove the clashing symlink or executable.  Did I ever mention
		 how I hate the file suffix idea? */
	      if ((newpc.is_lnk_special ()
		   || RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
						 &ro_u_exe, TRUE))
		  && !new_explicit_suffix)
		{
		  new2pc.check (newpath, PC_SYM_NOFOLLOW, stat_suffixes);
		  newpc.get_nt_native_path ()->Length -= 4 * sizeof (WCHAR);
		  if (new2pc.is_binary () || new2pc.is_lnk_special ())
		    removepc = &new2pc;
		}
d2436 1
a2436 6
      dstpc = (removepc == &newpc) ? &new2pc : &newpc;

      /* Check cross-device before touching anything.  Otherwise we might end
	 up with an unlinked target dir even if the actual rename didn't work.*/
      if (oldpc.fs_type () != dstpc->fs_type ()
	  || oldpc.fs_serial_number () != dstpc->fs_serial_number ())
d2438 5
a2442 2
	  set_errno (EXDEV);
	  __leave;
d2444 3
d2448 8
a2455 32
      /* Opening the file must be part of the transaction.  It's not sufficient
	 to call only NtSetInformationFile under the transaction.  Therefore we
	 have to start the transaction here, if necessary. */
      if (wincap.has_transactions ()
	  && (dstpc->fs_flags () & FILE_SUPPORTS_TRANSACTIONS)
	  && (dstpc->isdir ()
	      || (!removepc && dstpc->has_attribute (FILE_ATTRIBUTE_READONLY))))
	start_transaction (old_trans, trans);

      int retry_count;
      retry_count = 0;
    retry:
      /* Talking about inconsistent behaviour...
	 - DELETE is required to rename a file.  So far, so good.
	 - At least one cifs FS (Tru64) needs FILE_READ_ATTRIBUTE, otherwise the
	   FileRenameInformation call fails with STATUS_ACCESS_DENIED.  However,
	   on NFS we get a STATUS_ACCESS_DENIED if FILE_READ_ATTRIBUTE is used
	   and the file we try to rename is a symlink.  Urgh.
	 - Samba (only some versions?) doesn't like the FILE_SHARE_DELETE
	   mode if the file has the R/O attribute set and returns
	   STATUS_ACCESS_DENIED in that case. */
      {
	ULONG access = DELETE
		       | (oldpc.fs_is_cifs () ? FILE_READ_ATTRIBUTES : 0);
	ULONG sharing = FILE_SHARE_READ | FILE_SHARE_WRITE
			| (oldpc.fs_is_samba () ? 0 : FILE_SHARE_DELETE);
	ULONG flags = FILE_OPEN_FOR_BACKUP_INTENT
		      | (oldpc.is_rep_symlink () ? FILE_OPEN_REPARSE_POINT : 0);
	status = NtOpenFile (&fh, access,
			     oldpc.get_object_attr (attr, sec_none_nih),
			     &io, sharing, flags);
      }
a2457 29
	  debug_printf ("status %y", status);
	  if (status == STATUS_SHARING_VIOLATION
	      && cygwait (10L) != WAIT_SIGNALED)
	    {
	      /* Typical BLODA problem.  Some virus scanners check newly
		 generated files and while doing that disallow DELETE access.
		 That's really bad because it breaks applications which copy
		 files by creating a temporary filename and then rename the
		 temp filename to the target filename.  This renaming fails due
		 to the jealous virus scanner and the application fails to
		 create the target file.

		 This kludge tries to work around that by yielding until the
		 sharing violation goes away, or a signal arrived, or after
		 about a second, give or take. */
	      if (++retry_count < 40)
		{
		  yield ();
		  goto retry;
		}
	    }
	  else if (NT_TRANSACTIONAL_ERROR (status) && trans)
	    {
	      /* If NtOpenFile fails due to transactional problems, stop
		 transaction and go ahead without. */
	      stop_transaction (status, old_trans, trans);
	      debug_printf ("Transaction failure.  Retry open.");
	      goto retry;
	    }
d2459 1
a2459 1
	  __leave;
d2461 14
a2474 7

      /* Renaming a dir to another, existing dir fails always, even if
	 ReplaceIfExists is set to TRUE and the existing dir is empty.  So
	 we have to remove the destination dir first.  This also covers the
	 case that the destination directory is not empty.  In that case,
	 unlink_nt returns with STATUS_DIRECTORY_NOT_EMPTY. */
      if (dstpc->isdir ())
d2476 2
a2477 6
	  status = unlink_nt (*dstpc);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
d2479 4
a2482 5
      /* You can't copy a file if the destination exists and has the R/O
	 attribute set.  Remove the R/O attribute first.  But first check
	 if a removepc exists.  If so, dstpc points to a non-existing file
	 due to a mangled suffix. */
      else if (!removepc && dstpc->has_attribute (FILE_ATTRIBUTE_READONLY))
d2484 2
a2485 19
	  status = NtOpenFile (&nfh, FILE_WRITE_ATTRIBUTES,
			       dstpc->get_object_attr (attr, sec_none_nih),
			       &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT
			       | (dstpc->is_rep_symlink ()
				  ? FILE_OPEN_REPARSE_POINT : 0));
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	  status = NtSetAttributesFile (nfh, dstpc->file_attributes ()
					     & ~FILE_ATTRIBUTE_READONLY);
	  NtClose (nfh);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
d2487 1
d2489 14
a2502 14
      /* SUSv3: If the old argument and the new argument resolve to the same
	 existing file, rename() shall return successfully and perform no
	 other action.
	 The test tries to be as quick as possible.  Due to the above cross
	 device check we already know both files are on the same device.  So
	 it just tests if oldpath has more than 1 hardlink, then it opens
	 newpath and tests for identical file ids.  If so, oldpath and newpath
	 refer to the same file. */
      if ((removepc || dstpc->exists ())
	  && !oldpc.isdir ()
	  && NT_SUCCESS (NtQueryInformationFile (fh, &io, &ofsi, sizeof ofsi,
						 FileStandardInformation))
	  && ofsi.NumberOfLinks > 1
	  && NT_SUCCESS (NtOpenFile (&nfh, READ_CONTROL,
d2508 8
d2517 1
a2517 14
	  FILE_INTERNAL_INFORMATION ofii, nfii;

	  if (NT_SUCCESS (NtQueryInformationFile (fh, &io, &ofii, sizeof ofii,
						  FileInternalInformation))
	      && NT_SUCCESS (NtQueryInformationFile (nfh, &io, &nfii,
						     sizeof nfii,
						     FileInternalInformation))
	      && ofii.FileId.QuadPart == nfii.FileId.QuadPart)
	    {
	      debug_printf ("%s and %s are the same file", oldpath, newpath);
	      NtClose (nfh);
	      res = 0;
	      __leave;
	    }
d2519 2
d2522 32
a2553 5
      /* Create FILE_RENAME_INFORMATION struct.  Using a tmp_pathbuf area
	 allows for paths of up to 32757 chars.  This test is just for
	 paranoia's sake. */
      if (dstpc->get_nt_native_path ()->Length
	  > NT_MAX_PATH * sizeof (WCHAR) - sizeof (FILE_RENAME_INFORMATION))
d2555 18
a2572 26
	  debug_printf ("target filename too long");
	  set_errno (EINVAL);
	  __leave;
	}
      pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
      pfri->ReplaceIfExists = TRUE;
      pfri->RootDirectory = NULL;
      pfri->FileNameLength = dstpc->get_nt_native_path ()->Length;
      memcpy (&pfri->FileName,  dstpc->get_nt_native_path ()->Buffer,
	      pfri->FileNameLength);
      status = NtSetInformationFile (fh, &io, pfri,
				     sizeof *pfri + pfri->FileNameLength,
				     FileRenameInformation);
      /* This happens if the access rights don't allow deleting the destination.
	 Even if the handle to the original file is opened with BACKUP
	 and/or RECOVERY, these flags don't apply to the destination of the
	 rename operation.  So, a privileged user can't rename a file to an
	 existing file, if the permissions of the existing file aren't right.
	 Like directories, we have to handle this separately by removing the
	 destination before renaming. */
      if (status == STATUS_ACCESS_DENIED && dstpc->exists ()
	  && !dstpc->isdir ())
	{
	  if (wincap.has_transactions ()
	      && (dstpc->fs_flags () & FILE_SUPPORTS_TRANSACTIONS)
	      && !trans)
d2574 1
a2574 18
	      start_transaction (old_trans, trans);
	      /* As mentioned earlier, opening the file must be part of the
		 transaction.  Therefore we have to reopen the file here if the
		 transaction hasn't been started already.  Unfortunately we
		 can't use the NT "reopen file from existing handle" feature.
		 In that case NtOpenFile returns STATUS_TRANSACTIONAL_CONFLICT.
		 We *have* to close the handle to the file first, *then* we can
		 re-open it.  Fortunately nothing has happened yet, so the
		 atomicity of the rename functionality is not spoiled. */
	      NtClose (fh);
    retry_reopen:
	      status = NtOpenFile (&fh, DELETE,
				   oldpc.get_object_attr (attr, sec_none_nih),
				   &io, FILE_SHARE_VALID_FLAGS,
				   FILE_OPEN_FOR_BACKUP_INTENT
				   | (oldpc.is_rep_symlink ()
				      ? FILE_OPEN_REPARSE_POINT : 0));
	      if (!NT_SUCCESS (status))
d2576 5
a2580 10
		  if (NT_TRANSACTIONAL_ERROR (status) && trans)
		    {
		      /* If NtOpenFile fails due to transactional problems,
			 stop transaction and go ahead without. */
		      stop_transaction (status, old_trans, trans);
		      debug_printf ("Transaction failure.  Retry open.");
		      goto retry_reopen;
		    }
		  __seterrno_from_nt_status (status);
		  __leave;
d2582 2
a2584 4
	  if (NT_SUCCESS (status = unlink_nt (*dstpc)))
	    status = NtSetInformationFile (fh, &io, pfri,
					   sizeof *pfri + pfri->FileNameLength,
					   FileRenameInformation);
d2586 4
a2589 8
      if (NT_SUCCESS (status))
	{
	  if (removepc)
	    unlink_nt (*removepc);
	  res = 0;
	}
      else
	__seterrno_from_nt_status (status);
d2591 1
a2591 1
  __except (EFAULT)
d2593 3
a2595 1
      res = -1;
d2597 4
a2600 1
  __endtry
d2606 1
a2606 2
  if (get_errno () != EFAULT)
    syscall_printf ("%R = rename(%s, %s)", res, oldpath, newpath);
d2615 3
a2617 2
  if (cmdstring == NULL)
    return 1;
d2619 1
a2619 1
  int res = -1;
d2622 2
a2623 6
  __try
    {
      command[0] = "sh";
      command[1] = "-c";
      command[2] = cmdstring;
      command[3] = (const char *) NULL;
d2625 10
a2634 6
      if ((res = spawnvp (_P_SYSTEM, "/bin/sh", command)) == -1)
	{
	  // when exec fails, return value should be as if shell
	  // executed exit (127)
	  res = 127;
	}
d2636 1
a2636 2
  __except (EFAULT) {}
  __endtry
d2681 1
a2681 1
  fhandler_base *fh = NULL;
d2684 5
a2688 1
  __try
d2690 2
a2691 11
      if (!*file)
	{
	  set_errno (ENOENT);
	  return -1;
	}
      if (!(fh = build_fh_name (file, PC_SYM_FOLLOW, stat_suffixes)))
	return -1;
      if (!fh->exists ())
	set_errno (ENOENT);
      else
	ret = fh->fpathconf (v);
d2693 6
a2698 2
  __except (EFAULT) {}
  __endtry
d2707 4
a2710 2

  __try
a2720 5
      debug_printf ("returning %d tty: %s", ret, ret ? "NULL" : buf);
    }
  __except (NO_ERROR)
    {
      ret = EFAULT;
d2722 1
a2722 1
  __endtry
d2979 8
a2986 10
  __try
    {
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	__leave;
      return cfd->fstatvfs (sfs);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d2995 3
a2997 4
  __try
    {
      if (!(fh = build_fh_name (name, PC_SYM_FOLLOW, stat_suffixes)))
	__leave;
d2999 2
a3000 12
      if (fh->error ())
	{
	  debug_printf ("got %d error from build_fh_name", fh->error ());
	  set_errno (fh->error ());
	}
      else if (fh->exists ())
	{
	  debug_printf ("(%s, %p), file_attributes %d", name, sfs, (DWORD) *fh);
	  res = fh->fstatvfs (sfs);
	}
      else
	set_errno (ENOENT);
d3002 9
d3012 3
a3014 2
  __except (EFAULT) {}
  __endtry
d3016 1
d3018 1
a3018 2
  if (get_errno () != EFAULT)
    syscall_printf ("%R = statvfs(%s,%p)", res, name, sfs);
d3159 4
a3162 1
  __try
d3164 3
a3166 5
      if (!*path)
	{
	  set_errno (ENOENT);
	  __leave;
	}
d3168 2
a3169 2
      if (strlen (path) >= PATH_MAX)
	__leave;
d3171 6
a3176 6
      path_conv w32path (path, PC_SYM_NOFOLLOW);
      if (w32path.exists ())
	{
	  set_errno (EEXIST);
	  __leave;
	}
d3178 8
a3185 8
      mode_t type = mode & S_IFMT;
      _major_t major = _major (dev);
      _minor_t minor = _minor (dev);
      switch (type)
	{
	case S_IFCHR:
	case S_IFBLK:
	  break;
d3187 4
a3190 4
	case S_IFIFO:
	  major = _major (FH_FIFO);
	  minor = _minor (FH_FIFO);
	  break;
d3192 9
a3200 9
	case 0:
	case S_IFREG:
	  {
	    int fd = open (path, O_CREAT, mode);
	    if (fd < 0)
	      __leave;
	    close (fd);
	    return 0;
	  }
d3202 4
a3205 4
	default:
	  set_errno (EINVAL);
	  __leave;
	}
d3207 1
a3207 5
      return mknod_worker (w32path.get_win32 (), type, mode, major, minor);
    }
  __except (EFAULT)
  __endtry
  return -1;
d3818 13
a3830 2
  return __builtin_ffs (i);
}
d3832 1
a3832 5
extern "C" int
ffsl (long i)
{
  return __builtin_ffsl (i);
}
d3834 1
a3834 4
extern "C" int
ffsll (long long i)
{
  return __builtin_ffsll (i);
d3916 2
a3917 1
  __try
d3919 2
a3920 7
      if (*file)
	{
	  endutent ();
	  utmp_file = strdup (file);
	  debug_printf ("New UTMP file: %s", utmp_file);
	  return;
	}
d3922 3
a3924 3
  __except (NO_ERROR) {}
  __endtry
  debug_printf ("Invalid file");
d3969 4
a3972 1
  __try
d3974 1
d3976 7
d3984 16
a3999 26
	  internal_setutent (false);
	  if (utmp_fd < 0)
	    __leave;
	}
      utmp *ut = utmp_data;
      while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
	{
	  switch (id->ut_type)
	    {
	    case RUN_LVL:
	    case BOOT_TIME:
	    case OLD_TIME:
	    case NEW_TIME:
	      if (id->ut_type == ut->ut_type)
		return ut;
	      break;
	    case INIT_PROCESS:
	    case LOGIN_PROCESS:
	    case USER_PROCESS:
	    case DEAD_PROCESS:
	       if (strncmp (id->ut_id, ut->ut_id, UT_IDLEN) == 0)
		return ut;
	      break;
	    default:
	      break;
	    }
a4001 2
  __except (EFAULT) {}
  __endtry
d4008 4
a4011 1
  __try
d4013 1
d4015 9
a4023 5
	{
	  internal_setutent (false);
	  if (utmp_fd < 0)
	    __leave;
	}
a4024 9
      utmp *ut = utmp_data;
      while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
	if ((ut->ut_type == LOGIN_PROCESS ||
	     ut->ut_type == USER_PROCESS) &&
	    !strncmp (ut->ut_line, line->ut_line, sizeof (ut->ut_line)))
	  return ut;
    }
  __except (EFAULT) {}
  __endtry
d4031 5
a4035 1
  __try
d4037 2
a4038 23
      internal_setutent (true);
      if (utmp_fd < 0)
	{
	  debug_printf ("error: utmp_fd %d", utmp_fd);
	  __leave;
	}
      debug_printf ("ut->ut_type %d, ut->ut_pid %d, ut->ut_line '%s', ut->ut_id '%s'\n",
		    ut->ut_type, ut->ut_pid, ut->ut_line, ut->ut_id);
      debug_printf ("ut->ut_user '%s', ut->ut_host '%s'\n",
		    ut->ut_user, ut->ut_host);

      struct utmp *u;
      if ((u = getutid (ut)))
	{
	  lseek (utmp_fd, -sizeof *ut, SEEK_CUR);
	  write (utmp_fd, ut, sizeof *ut);
	}
      else
	locked_append (utmp_fd, ut, sizeof *ut);
      /* The documentation says to return a pointer to this which implies that
	 this has to be cast from a const.  That doesn't seem right but the
	 documentation seems pretty clear on this.  */
      return (struct utmp *) ut;
d4040 17
a4056 3
  __except (EFAULT) {}
  __endtry
  return NULL;
d4074 1
a4074 1
  /* POSIX: Not required to be thread safe. */
d4082 1
a4082 1
  /* POSIX: Not required to be thread safe. */
d4085 5
a4089 8
  __try
    {
      ((struct utmpx *)id)->ut_time = id->ut_tv.tv_sec;
      return copy_ut_to_utx (getutid ((struct utmp *) id), &utx);
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
d4095 1
a4095 1
  /* POSIX: Not required to be thread safe. */
d4098 5
a4102 8
  __try
    {
      ((struct utmpx *)line)->ut_time = line->ut_tv.tv_sec;
      return copy_ut_to_utx (getutline ((struct utmp *) line), &utx);
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
d4108 1
a4108 1
  /* POSIX: Not required to be thread safe. */
d4111 5
a4115 8
  __try
    {
      ((struct utmpx *)utmpx)->ut_time = utmpx->ut_tv.tv_sec;
      return copy_ut_to_utx (pututline ((struct utmp *) utmpx), &utx);
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
d4479 6
a4484 5
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
d4486 2
a4487 2
      va_list ap;
      mode_t mode;
d4489 4
a4492 8
      va_start (ap, flags);
      mode = va_arg (ap, mode_t);
      va_end (ap);
      return open (path, flags, mode);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4499 4
d4504 2
a4505 2

  __try
d4507 11
a4517 7
      char *path = tp.c_get ();
      if (!gen_full_path_at (path, dirfd, pathname))
	{
	  if ((mode & ~(F_OK|R_OK|W_OK|X_OK))
	      || (flags & ~(AT_SYMLINK_NOFOLLOW|AT_EACCESS)))
	    set_errno (EINVAL);
	  else
d4519 2
a4520 11
	      fhandler_base *fh = build_fh_name (path,
						 (flags & AT_SYMLINK_NOFOLLOW
						  ? PC_SYM_NOFOLLOW
						  : PC_SYM_FOLLOW)
						 | PC_KEEP_HANDLE,
						 stat_suffixes);
	      if (fh)
		{
		  res = fh->fhaccess (mode, !!(flags & AT_EACCESS));
		  delete fh;
		}
a4523 2
  __except (EFAULT) {}
  __endtry
d4532 4
a4535 1
  __try
d4537 5
a4541 12
      if (flags)
	{
	  /* BSD has lchmod, but Linux does not.  POSIX says
	     AT_SYMLINK_NOFOLLOW is allowed to fail on symlinks; but Linux
	     blindly fails even for non-symlinks.  */
	  set_errno ((flags & ~AT_SYMLINK_NOFOLLOW) ? EINVAL : EOPNOTSUPP);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return chmod (path, mode);
d4543 4
a4546 3
  __except (EFAULT) {}
  __endtry
  return -1;
d4553 4
a4556 1
  __try
d4558 2
a4559 10
      if (flags & ~AT_SYMLINK_NOFOLLOW)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return chown_worker (path, (flags & AT_SYMLINK_NOFOLLOW)
				 ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW, uid, gid);
d4561 5
a4565 3
  __except (EFAULT) {}
  __endtry
  return -1;
d4573 4
a4576 1
  __try
d4578 2
a4579 12
      if (flags & ~AT_SYMLINK_NOFOLLOW)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      path_conv pc (path, ((flags & AT_SYMLINK_NOFOLLOW)
			   ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)
			  | PC_POSIX | PC_KEEP_HANDLE, stat_suffixes);
      return stat_worker (pc, st);
d4581 7
a4587 3
  __except (EFAULT) {}
  __endtry
  return -1;
d4597 5
a4601 1
  __try
d4603 2
a4604 12
      char *path = tp.c_get ();
      if (flags & ~AT_SYMLINK_NOFOLLOW)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      path_conv win32 (path, PC_POSIX | ((flags & AT_SYMLINK_NOFOLLOW)
					 ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW),
		       stat_suffixes);
      return utimens_worker (win32, times);
d4606 6
a4611 3
  __except (EFAULT) {}
  __endtry
  return -1;
d4618 7
a4624 10
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname, true))
	__leave;
      return utimes (path, times);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4633 15
a4647 1
  __try
d4649 2
a4650 1
      if (flags & ~AT_SYMLINK_FOLLOW)
d4652 2
a4653 18
	  set_errno (EINVAL);
	  __leave;
	}
      char *oldpath = tp.c_get ();
      if (gen_full_path_at (oldpath, olddirfd, oldpathname))
	__leave;
      char *newpath = tp.c_get ();
      if (gen_full_path_at (newpath, newdirfd, newpathname))
	__leave;
      if (flags & AT_SYMLINK_FOLLOW)
	{
	  path_conv old_name (oldpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
	  if (old_name.error)
	    {
	      set_errno (old_name.error);
	      __leave;
	    }
	  strcpy (oldpath, old_name.normalized_path);
d4655 1
a4655 1
      return link (oldpath, newpath);
d4657 1
a4657 3
  __except (EFAULT) {}
  __endtry
  return -1;
d4664 7
a4670 10
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return mkdir (path, mode);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4677 7
a4683 10
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return mkfifo (path, mode);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4690 7
a4696 10
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return mknod32 (path, mode, dev);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4704 7
a4710 10
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return readlink (path, buf, bufsize);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4718 10
a4727 13
  __try
    {
      char *oldpath = tp.c_get ();
      if (gen_full_path_at (oldpath, olddirfd, oldpathname))
	__leave;
      char *newpath = tp.c_get ();
      if (gen_full_path_at (newpath, newdirfd, newpathname))
	__leave;
      return rename (oldpath, newpath);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4736 7
a4742 10
  __try
    {
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return scandir (pathname, namelist, select, compar);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4749 7
a4755 10
  __try
    {
      char *newpath = tp.c_get ();
      if (gen_full_path_at (newpath, newdirfd, newpathname))
	__leave;
      return symlink (oldpath, newpath);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d4762 4
a4765 1
  __try
d4767 2
a4768 9
      if (flags & ~AT_REMOVEDIR)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      char *path = tp.c_get ();
      if (gen_full_path_at (path, dirfd, pathname))
	__leave;
      return (flags & AT_REMOVEDIR) ? rmdir (path) : unlink (path);
d4770 4
a4773 3
  __except (EFAULT) {}
  __endtry
  return -1;
@


1.658
log
@	* syscalls.cc (popen): Introduce Glibc 'e' flag to allow thread-safe
	opening of the pipe with O_CLOEXEC flag.  Simplify FD_CLOEXEC handling.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.657
log
@	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Define.
	(stop_transaction): Take "trans" HANDLE by reference and set it to
	NULL after closing it.
	(unlink_nt): If NtOpenFile fails due to a transactional error, stop
	transaction and retry NtOpenFile.  Simplify check for having to call
	stop_transaction.
	(rename): If NtOpenFile fails due to a transactional error, stop
	transaction and retry NtOpenFile in both affected cases.  Simplify check
	for having to call stop_transaction and add comment from unlink_nt.
@
text
@d4239 2
a4240 1
  char rw = *type++;
d4242 27
a4268 3
  /* Sanity check in_type */
  if (*type == 'b' || *type == 't')
    type++;
d4276 1
a4276 1
  if (pipe (fds) < 0)
d4282 1
a4282 1
  FILE *fp = fdopen (fds[myix], in_type);
d4318 7
a4324 3
      /* Don't pass our end of the pipe to the child process */
      int fd_state = fcntl64 (myfd, F_GETFD, 0);
      fcntl64 (myfd, F_SETFD, fd_state | FD_CLOEXEC);
d4350 1
a4350 2
	  /* Flag that this handle is associated with popen and then reset
	     the handle's original close-on-exec state. */
a4351 1
	  fcntl64 (myfd, F_SETFD, fd_state);
d4362 4
@


1.656
log
@* syscalls.cc (dup): Use cygheap_fdnew properly.
@
text
@d188 5
d212 1
a212 1
stop_transaction (NTSTATUS status, HANDLE old_trans, HANDLE trans)
d220 1
d711 1
a711 1

d727 12
a738 2
	debug_printf ("Opening %S for removing R/O failed, status = %y",
		      pc.get_nt_native_path (), status);
d1003 1
a1003 3
  if ((access & FILE_WRITE_ATTRIBUTES)
      && wincap.has_transactions ()
      && (pc.fs_flags () & FILE_SUPPORTS_TRANSACTIONS))
a1004 1

d2437 8
d2566 1
d2575 8
d2604 2
a2605 1
  if (wincap.has_transactions () && trans)
@


1.655
log
@* cygheap.h (cygheap_fdnew): Avoid setting errno directly since it will have
been set by a previous function.
* dtable.h (dtable::extend): Accept second size_t argument.
* dtable.cc (dtable::extend): Accept second "min" argument which allows
checking for OPEN_MAX_MAX boundary conditions.
(dtable_init): Accommodate second argument to dtable::extend.
(dtable::find_unused_handle): Ditto.
* syscalls.cc (setdtablesize): Ditto.
(dup): Return any error passed by cygheap_fdnew() directly.
(getdtablesize): Just return dtable size directly.
@
text
@d124 1
a124 1
  int newfd = cygheap_fdnew ();
@


1.654
log
@	* syscalls.cc (try_to_bin): Enhance debug output in case reopen fails.
@
text
@d123 6
a128 1
  int res = cygheap->fdtab.dup3 (fd, cygheap_fdnew (), 0);
d2619 2
a2620 1
  if (size <= (int)cygheap->fdtab.size || cygheap->fdtab.extend (size - cygheap->fdtab.size))
d2629 1
a2629 1
  return cygheap->fdtab.size > OPEN_MAX ? cygheap->fdtab.size : OPEN_MAX;
@


1.653
log
@	* syscalls.cc (try_to_bin): Drop fh_dup, reuse tmp_fh instead.
@
text
@d288 2
a289 1
	debug_printf ("NtOpenFile (reopen) failed, status = %y", status);
@


1.652
log
@	* syscalls.cc (try_to_bin): Take additional parameter to get file open
	flags.  If the file to move to the bin has been opened casesensitive,
	reopen it caseinsensitive.  Explain why.  Revert the default name of
	the Vista-and-later recycler to mixed case for readability.
	(unlink_nt): Call try_to_bin with file open flags as evaluated.
@
text
@a282 1
      HANDLE fh_dup;
d285 1
a285 1
      status = NtOpenFile (&fh_dup, access, &attr, &io, FILE_SHARE_VALID_FLAGS,
d292 1
a292 1
	  fh = fh_dup;
@


1.651
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@d235 1
a235 1
try_to_bin (path_conv &pc, HANDLE &fh, ACCESS_MASK access)
d271 25
d301 1
a301 1
	RtlAppendUnicodeToString (&recycler, L"\\$RECYCLE.BIN\\");
d387 1
d815 1
a815 1
      && (bin_stat = try_to_bin (pc, fh, access)) >= has_been_moved)
d885 1
a885 1
			  bin_stat = try_to_bin (pc, fh, access);
d945 1
a945 1
		bin_stat = try_to_bin (pc, fh, access);
@


1.650
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d1888 1
a1888 1
stat64 (const char *name, struct stat *buf)
d1897 2
a1898 1
_stat64_r (struct _reent *ptr, const char *name, struct stat *buf)
d1912 1
a1912 1
stat (const char *name, struct stat *buf)
d1922 2
a1923 1
_stat_r (struct _reent *ptr, const char *name, struct stat *buf)
d1935 1
a1935 1
lstat64 (const char *name, struct stat *buf)
d1948 1
a1948 1
lstat (const char *name, struct stat *buf)
d4467 2
a4468 1
fstatat (int dirfd, const char *pathname, struct stat *st, int flags)
d4598 2
a4599 1
readlinkat (int dirfd, const char *pathname, char *buf, size_t bufsize)
@


1.649
log
@dup2: fix off-by-one crash

* dtable.cc (dup3): Fix off-by-one.
(find_unused_handle): Reduce time spent expanding during dup.
* syscalls.cc (setdtablesize): Report error on invalid value.
@
text
@a26 1
#include <winnls.h>
@


1.648
log
@	* syscalls.cc (open): Only return ENOTDIR if file exists.
@
text
@d2581 6
@


1.647
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d1363 1
a1363 1
	  else if ((flags & O_DIRECTORY) && !fh->pc.isdir ())
@


1.646
log
@	* autoload.cc (CreateSymbolicLink): Define.
	* environ.cc (set_winsymlinks): Set allow_winsymlinks.
	(parse_thing): Change "winsymlinks" to set by function.
	* globals.cc (enum winsym_t): Define.
	(allow_winsymlinks): Define as winsym_t.
	(ro_u_afs): New R/O Unicode string.
	* mount.cc (fs_info::update): Fix comment.  Handle AFS.
	(fs_names): Add "afs".
	* mount.h (enum fs_info_type): Add afs.
	(class fs_info): Implement afs.
	* path.cc (symlink): Drop third parameter in call to symlink_worker.
	(symlink_nfs): New function.
	(symlink_native): New function.
	(symlink_worker): Drop third argument.  Handle native symlink type by
	calling symlink_native.  Move code to handle NFS to symlink_nfs.  Fix
	formatting.  Slightly restructure code.
	* path.h (class path_conv): Add fs_is_afs method.
	(symlink_worker): Declare here.
	* security.h: Define privilege constants as unsigned int instead of as
	unsigned long.
	* syscalls.cc (mknod_worker): Set third parameter in symlink_worker
	call to WSYM_lnk.
	* winsup.h (symlink_worker): Drop declaration here.
@
text
@d1850 1
a1850 1
int __stdcall
@


1.645
log
@	* Merge in cygwin-64bit-branch.
@
text
@d3084 1
a3084 1
  return symlink_worker (buf, path, true, true);
@


1.644
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d14 1
a14 1
#define stat __FOOstat__
d47 1
a47 1
#undef stat
d180 1
a180 1
  syscall_printf ("%R = dup3(%d, %d, %p)", res, oldfd, newfd, flags);
d197 1
a197 1
      debug_printf ("NtCreateTransaction failed, %p", status);
d261 1
a261 1
		    "failed, status = %p", pc.get_nt_native_path (), status);
d305 1
a305 1
	  debug_printf ("NtOpenFile (%S) failed, status = %p", &root, status);
a323 2
	  /* In contrast to what MSDN claims, this function is already available
	     since NT4. */
d350 1
a350 1
		    "failed, status = %p", pc.get_nt_native_path (), status);
d375 1
a375 1
	  debug_printf ("NtOpenFile (%S) failed, status = %p",
d400 1
a400 1
	  debug_printf ("NtCreateFile (%S) failed, status = %p",
d420 1
a420 1
	      debug_printf ("NtCreateFile (%S) failed, status = %p",
d439 1
a439 1
	    debug_printf ("NtCreateFile (%S) failed, status = %p",
d446 1
a446 1
		debug_printf ("NtWriteFile (%S) failed, status = %p",
d454 1
a454 1
		    debug_printf ("NtWriteFile (%S) failed, status = %p",
d469 1
a469 1
		  debug_printf ("NtCreateFile (%S) failed, status = %p",
d476 1
a476 1
		    debug_printf ("NtWriteFile (%S) failed, status = %p",
d489 1
a489 1
      debug_printf ("Move %S to %S failed, status = %p",
d547 1
a547 1
      debug_printf ("Creating file for overwriting failed, status = %p",
d555 1
a555 1
    debug_printf ("Overwriting with another file failed, status = %p", status);
d560 1
a560 1
  debug_printf ("%S, return status %d", pc.get_nt_native_path (), bin_stat);
d577 1
a577 1
      debug_printf ("Checking if directory %S is empty failed, status = %p",
d622 1
a622 1
				 "query status = %p",
d686 1
a686 1
	    debug_printf ("Removing R/O on %S failed, status = %p",
d691 1
a691 1
	debug_printf ("Opening %S for removing R/O failed, status = %p",
d783 1
a783 1
      debug_printf ("Opening %S for delete failed, status = %p",
d808 1
a808 1
      debug_printf ("Setting delete disposition on %S failed, status = %p",
d880 1
a880 1
			    "status = %p", pc.get_nt_native_path (), status2);
d913 1
a913 1
	      debug_printf ("Setting delete-on-close on %S failed, status = %p",
d962 1
a962 1
  syscall_printf ("%S, return status = %p", pc.get_nt_native_path (), status);
d970 1
a970 1
  DWORD devn;
d981 1
a981 1
  devn = win32_name.get_devn ();
d1150 1
a1150 1
  syscall_printf ("%R = read(%d, %p, %d)", res, fd, ptr, len);
d1192 1
a1192 1
  syscall_printf ("%R = readv(%d, %p, %d)", res, fd, iov, iovcnt);
d1198 1
a1198 1
pread (int fd, void *ptr, size_t len, _off64_t off)
d1209 1
a1209 1
  syscall_printf ("%R = pread(%d, %p, %d, %d)", res, fd, ptr, len, off);
d1222 1
a1222 1
  int res = -1;
d1243 1
a1243 1
  syscall_printf ("%R = write(%d, %p, %d)", res, fd, ptr, len);
d1260 1
a1260 1
  int res = -1;
d1289 1
a1289 1
    paranoid_printf ("%R = writev(%d, %p, %d)", res, fd, iov, iovcnt);
d1291 1
a1291 1
    syscall_printf ("%R = writev(%d, %p, %d)", res, fd, iov, iovcnt);
d1298 1
a1298 1
pwrite (int fd, void *ptr, size_t len, _off64_t off)
d1309 1
a1309 1
  syscall_printf ("%R = pwrite(%d, %p, %d, %d)", res, fd, ptr, len, off);
d1323 1
a1323 1
  syscall_printf ("open(%s, %p)", unix_path, flags);
d1391 1
a1391 1
  syscall_printf ("%R = open(%s, %p)", res, unix_path, flags);
d1398 2
a1399 2
extern "C" _off64_t
lseek64 (int fd, _off64_t pos, int dir)
d1401 1
a1401 1
  _off64_t res;
d1416 1
a1416 1
  /* Can't use %R here since res is 8 bytes */
d1426 4
d1433 1
a1433 1
  return lseek64 (fd, (_off64_t) pos, dir);
d1435 2
a1437 1
EXPORT_ALIAS (lseek, _lseek)
d1515 1
a1515 1
chown_worker (const char *name, unsigned fmode, __uid32_t uid, __gid32_t gid)
d1539 1
a1539 1
chown32 (const char * name, __uid32_t uid, __gid32_t gid)
d1544 3
d1553 1
d1556 1
a1556 1
lchown32 (const char * name, __uid32_t uid, __gid32_t gid)
d1561 3
d1570 1
d1573 1
a1573 1
fchown32 (int fd, __uid32_t uid, __gid32_t gid)
d1588 3
d1596 1
d1637 1
a1637 1
  syscall_printf ("%R = chmod(%s, %p)", res, path, mode);
d1656 1
d1658 1
a1658 1
stat64_to_stat32 (struct __stat64 *src, struct __stat32 *dst)
d1674 1
d1676 1
a1676 1
static struct __stat64 dev_st;
d1680 1
a1680 1
fhandler_base::stat_fixup (struct __stat64 *buf)
d1720 1
a1720 1
fstat64 (int fd, struct __stat64 *buf)
d1729 1
a1729 1
      memset (buf, 0, sizeof (struct __stat64));
d1740 1
a1740 1
_fstat64_r (struct _reent *ptr, int fd, struct __stat64 *buf)
d1749 4
d1754 1
a1754 1
fstat (int fd, struct __stat32 *buf)
d1756 1
a1756 1
  struct __stat64 buf64;
d1759 1
a1759 1
    stat64_to_stat32 (&buf64, buf);
d1764 1
a1764 1
_fstat_r (struct _reent *ptr, int fd, struct __stat32 *buf)
d1772 1
d1803 1
a1803 1
    debug_printf ("NtOpenFile (%S), status %p", &uvol, status);
d1808 1
a1808 1
	debug_printf ("NtFlushBuffersFile (%S), status %p", &uvol, status);
d1828 1
a1828 1
      debug_printf ("NtOpenDirectoryObject, status %p", status);
d1851 1
a1851 1
stat_worker (path_conv &pc, struct __stat64 *buf)
d1889 1
a1889 1
stat64 (const char *name, struct __stat64 *buf)
d1898 1
a1898 1
_stat64_r (struct _reent *ptr, const char *name, struct __stat64 *buf)
d1907 4
d1912 1
a1912 1
stat (const char *name, struct __stat32 *buf)
d1914 1
a1914 1
  struct __stat64 buf64;
d1917 1
a1917 1
    stat64_to_stat32 (&buf64, buf);
d1922 1
a1922 1
_stat_r (struct _reent *ptr, const char *name, struct __stat32 *buf)
d1930 1
d1934 1
a1934 1
lstat64 (const char *name, struct __stat64 *buf)
d1942 3
d1947 1
a1947 1
lstat (const char *name, struct __stat32 *buf)
d1949 1
a1949 1
  struct __stat64 buf64;
d1952 1
a1952 1
    stat64_to_stat32 (&buf64, buf);
d1955 1
d2372 1
a2372 1
      debug_printf ("status %p", status);
d2755 1
a2755 1
setmode (int fd, int mode)
d2793 1
a2793 1
  int res = setmode (fd, mode);
d2807 1
a2807 1
posix_fadvise (int fd, _off64_t offset, _off64_t len, int advice)
d2821 1
a2821 1
posix_fallocate (int fd, _off64_t offset, _off64_t len)
d2839 1
a2839 1
ftruncate64 (int fd, _off64_t length)
d2851 3
d2858 1
a2858 1
  return ftruncate64 (fd, (_off64_t)length);
d2860 1
d2864 1
a2864 1
truncate64 (const char *pathname, _off64_t length)
d2881 3
d2888 1
a2888 1
  return truncate64 (pathname, (_off64_t)length);
d2890 1
d2893 1
a2893 1
get_osfhandle (int fd)
d3035 1
a3035 1
  if (p == 0)
d3088 1
a3088 1
mknod32 (const char *path, mode_t mode, __dev32_t dev)
d3144 1
a3144 1
  return mknod32 (_path, mode, (__dev32_t) dev);
d3155 1
a3155 1
seteuid32 (__uid32_t uid)
d3255 1
a3255 1
  debug_printf ("Found token %d", new_token);
d3310 1
a3310 1
	debug_printf ("NtSetInformationToken (user.token, TokenOwner), %p",
d3317 1
a3317 1
		      "%p", status);
d3326 1
a3326 1
	    debug_printf ("NtSetInformationToken (TokenDefaultDacl), %p",
d3375 3
d3383 1
d3387 1
a3387 1
setuid32 (__uid32_t uid)
d3400 3
d3408 1
d3411 1
a3411 1
setreuid32 (__uid32_t ruid, __uid32_t euid)
d3415 1
a3415 1
  __uid32_t old_euid = myself->uid;
d3429 3
d3437 1
d3441 1
a3441 1
setegid32 (__gid32_t gid)
d3454 1
a3454 1
  struct __group32 * gr = internal_getgrgid (gid);
d3471 1
a3471 1
		      "TokenPrimaryGroup), %p", status);
d3475 1
a3475 1
	debug_printf ("NtSetInformationToken (token, TokenPrimaryGroup), %p",
d3482 1
a3482 1
    debug_printf ("NtSetInformationToken (hProcToken, TokenPrimaryGroup), %p",
d3489 3
d3497 1
d3501 1
a3501 1
setgid32 (__gid32_t gid)
d3509 3
d3520 1
d3523 1
a3523 1
setregid32 (__gid32_t rgid, __gid32_t egid)
d3527 1
a3527 1
  __gid32_t old_egid = myself->gid;
d3541 3
d3549 1
d3650 1
a3650 1
		if ((__uid32_t) who != p->uid)
d3721 1
a3721 1
	    if ((__uid32_t) who == p->uid && p->nice < nice)
d3771 1
a3771 1
  struct __flock64 lock_buffer = {F_WRLCK, SEEK_SET, 0, 0, 0};
d3775 1
a3775 1
    if ((lock_buffer.l_start = lseek64 (fd, 0, SEEK_END)) != (_off64_t) -1
d3778 1
a3778 1
	if (lseek64 (fd, 0, SEEK_END) != (_off64_t) -1)
d4076 1
a4076 1
  debug_printf ("hostid 0x%08x from MachineGuid %W", hostid, wguid);
d4091 1
a4091 1
  static NO_COPY const char *def_shells[] = {
d4441 1
a4441 2
fchownat (int dirfd, const char *pathname, __uid32_t uid, __gid32_t gid,
	 int flags)
d4460 1
a4460 1
fstatat (int dirfd, const char *pathname, struct __stat64 *st, int flags)
d4577 1
a4577 1
mknodat (int dirfd, const char *pathname, mode_t mode, __dev32_t dev)
@


1.643
log
@	* syscalls.cc (rename): Remove ill-conceived NFS workaround from
	2013-01-10 for self-inflicted NFS server problem.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.642
log
@	* syscalls.cc (rename): Drop handling paths > 32757 chars, emit EINVAL
	instead, thus simplifying code allocating and filling pfri.  Drop size
	and use constant expression in NtSetInformationFile call.  Add comments.
	Drop redundant test for fs_serial_number and change comment accordingly.
@
text
@d2453 3
a2455 46
  if (oldpc.fs_is_nfs ())
    {
      /* Workaround depressing NFS bug.  FILE_RENAME_INFORMATION.FileName
	 *must* be relative to the parent directory of the original file,
	 otherwise NtSetInformationFile returns with STATUS_NOT_SAME_DEVICE.
	 Neither absolute paths, nor directory handle relative paths work
	 as expected! */
      PWCHAR oldp, dstp;

      /* Skip equivalent path prefix.  We already know that both paths are
	 on the same drive anyway. */
      for (oldp = oldpc.get_nt_native_path ()->Buffer,
	   dstp = dstpc->get_nt_native_path ()->Buffer;
	   *oldp == *dstp; ++oldp, ++dstp)
	;
      while (oldp[-1] != L'\\')
      	--oldp, --dstp;
      /* Now oldp points to the first path component in oldpc different from
         dstpc, vice versa for dstp and oldpc.  To create a dstpc path relative
	 to oldpc, we now have to prepend as many ".." components to dstp, as
	 are still available in oldp.  Example:

	   oldpc = \??\UNC\server\a\b\c\d\e
	   dstpc = \??\UNC\server\a\b\f\g

           prefix: \??\UNC\server\a\b\
	   oldp: c\d\e
	   dstp: f\g
	   dstp expressed relative to e's parent dir:  ..\..\f\g

	 So what we do here is to count the number of backslashes in oldp and
	 prepend one "..\" to dstp for each of them. */
      PWCHAR newdst = tp.w_get ();
      PWCHAR newp = newdst;
      while ((oldp = wcschr (++oldp, L'\\')) != NULL)
      	newp = wcpcpy (newp, L"..\\");
      newp = wcpcpy (newp, dstp);
      pfri->FileNameLength = (newp - newdst) * sizeof (WCHAR);
      memcpy (&pfri->FileName,  newdst, pfri->FileNameLength);
    }
  else
    {
      pfri->FileNameLength = dstpc->get_nt_native_path ()->Length;
      memcpy (&pfri->FileName,  dstpc->get_nt_native_path ()->Buffer,
	      pfri->FileNameLength);
    }
@


1.641
log
@	* path.h (path_conv::fs_type): New method.
	* syscalls.cc (rename): Check for cross-device situation before
	touching anything.  Explain why.  Workaround NFS bug in call to
	NtSetInformationFile(FileRenameInformation).
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
a2037 1
  ULONG size;
d2409 3
a2411 3
     The test tries to be as quick as possible.  First it tests for identical
     volume serial numbers because that information is available anyway.
     Then it tests if oldpath has more than 1 hardlink, then it opens newpath
a2415 1
      && dstpc->fs_serial_number () == oldpc.fs_serial_number ()
d2441 12
a2489 6
      size = sizeof (FILE_RENAME_INFORMATION)
	     + (newp - newdst) * sizeof (WCHAR);
      if (size > NT_MAX_PATH * sizeof (WCHAR)) /* Hopefully very seldom. */
	pfri = (PFILE_RENAME_INFORMATION) alloca (size);
      else
	pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
a2494 6
      size = sizeof (FILE_RENAME_INFORMATION)
	     + dstpc->get_nt_native_path ()->Length;
      if (size > NT_MAX_PATH * sizeof (WCHAR)) /* Hopefully very seldom. */
	pfri = (PFILE_RENAME_INFORMATION) alloca (size);
      else
	pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
d2499 3
a2501 3
  pfri->ReplaceIfExists = TRUE;
  pfri->RootDirectory = NULL;
  status = NtSetInformationFile (fh, &io, pfri, size, FileRenameInformation);
d2538 2
a2539 1
	status = NtSetInformationFile (fh, &io, pfri, size,
@


1.640
log
@* dtable.cc (dtable::dup3): Fix bounds checking for valid newfd.
* syscalls.cc (dup2): Ditto.
* winsup.h (events_terminate): Delete obsolete function declaration.
@
text
@d2300 9
d2443 46
a2488 4
  size = sizeof (FILE_RENAME_INFORMATION)
	 + dstpc->get_nt_native_path ()->Length;
  if (size > NT_MAX_PATH * sizeof (WCHAR)) /* Hopefully very seldom. */
    pfri = (PFILE_RENAME_INFORMATION) alloca (size);
d2490 11
a2500 1
    pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
a2502 3
  pfri->FileNameLength = dstpc->get_nt_native_path ()->Length;
  memcpy (&pfri->FileName,  dstpc->get_nt_native_path ()->Buffer,
	  pfri->FileNameLength);
@


1.639
log
@whitespace cleanup
@
text
@d145 1
a145 1
  if (newfd >= OPEN_MAX_MAX)
@


1.638
log
@	* syscalls.cc (enum bin_status): Add dir_not_empty.
	(try_to_bin): Call NtQueryInformationFile(FileInternalInformation)
	with exact buffer size.  Explain why.
	Ditto for NtSetInformationFile(FileRenameInformation).
	Handle race-condition which might lead to renaming a non-empty
	directory.
	(unlink_nt): Rearrange and partially rephrase comments related to the
	STATUS_SHARING_VIOLATION case.  Fix condition under which a dir is
	tested for being non-empty.  Handle dir_not_empty return code from
	try_to_bin.  Gracefully handle disappearing directory in rm -r
	workaround.  Fix typo in comment.
@
text
@d734 2
a735 2
      
         NFS implements its own mechanism to remove in-use files, which looks
@


1.638.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d14 1
a14 1
//#define stat __FOOstat__
d47 1
a47 1
//#undef stat
d1200 1
a1200 1
pread (int fd, void *ptr, size_t len, off_t off)
d1300 1
a1300 1
pwrite (int fd, void *ptr, size_t len, off_t off)
d1400 2
a1401 2
extern "C" off_t
lseek64 (int fd, off_t pos, int dir)
d1403 1
a1403 1
  off_t res;
a1427 4
#ifdef __x86_64__
EXPORT_ALIAS (lseek64, lseek)
EXPORT_ALIAS (lseek64, _lseek)
#else
d1431 1
a1431 1
  return lseek64 (fd, (off_t) pos, dir);
d1433 1
a1434 2
#endif

d1512 1
a1512 1
chown_worker (const char *name, unsigned fmode, uid_t uid, gid_t gid)
d1536 1
a1536 1
chown32 (const char * name, uid_t uid, gid_t gid)
a1540 3
#ifdef __x86_64__
EXPORT_ALIAS (chown32, chown)
#else
a1546 1
#endif
d1549 1
a1549 1
lchown32 (const char * name, uid_t uid, gid_t gid)
a1553 3
#ifdef __x86_64__
EXPORT_ALIAS (lchown32, lchown)
#else
a1559 1
#endif
d1562 1
a1562 1
fchown32 (int fd, uid_t uid, gid_t gid)
a1576 3
#ifdef __x86_64__
EXPORT_ALIAS (fchown32, fchown)
#else
a1581 1
#endif
a1640 1
#ifndef __x86_64__
d1642 1
a1642 1
stat64_to_stat32 (struct stat *src, struct __stat32 *dst)
a1657 1
#endif
d1659 1
a1659 1
static struct stat dev_st;
d1663 1
a1663 1
fhandler_base::stat_fixup (struct stat *buf)
d1703 1
a1703 1
fstat64 (int fd, struct stat *buf)
d1712 1
a1712 1
      memset (buf, 0, sizeof (struct stat));
d1723 1
a1723 1
_fstat64_r (struct _reent *ptr, int fd, struct stat *buf)
a1731 4
#ifdef __x86_64__
EXPORT_ALIAS (fstat64, fstat)
EXPORT_ALIAS (_fstat64_r, _fstat_r)
#else
d1733 1
a1733 1
fstat (int fd, struct stat *buf)
d1735 1
a1735 1
  struct stat buf64;
d1738 1
a1738 1
    stat64_to_stat32 (&buf64, (struct __stat32 *) buf);
d1743 1
a1743 1
_fstat_r (struct _reent *ptr, int fd, struct stat *buf)
a1750 1
#endif
d1829 1
a1829 1
stat_worker (path_conv &pc, struct stat *buf)
d1867 1
a1867 1
stat64 (const char *name, struct stat *buf)
d1876 1
a1876 1
_stat64_r (struct _reent *ptr, const char *name, struct stat *buf)
a1884 4
#ifdef __x86_64__
EXPORT_ALIAS (stat64, stat)
EXPORT_ALIAS (_stat64_r, _stat_r)
#else
d1886 1
a1886 1
stat (const char *name, struct stat *buf)
d1888 1
a1888 1
  struct stat buf64;
d1891 1
a1891 1
    stat64_to_stat32 (&buf64, (struct __stat32 *) buf);
d1896 1
a1896 1
_stat_r (struct _reent *ptr, const char *name, struct stat *buf)
a1903 1
#endif
d1907 1
a1907 1
lstat64 (const char *name, struct stat *buf)
a1914 3
#ifdef __x86_64__
EXPORT_ALIAS (lstat64, lstat)
#else
d1917 1
a1917 1
lstat (const char *name, struct stat *buf)
d1919 1
a1919 1
  struct stat buf64;
d1922 1
a1922 1
    stat64_to_stat32 (&buf64, (struct __stat32 *) buf);
a1924 1
#endif
d2762 1
a2762 1
posix_fadvise (int fd, off_t offset, off_t len, int advice)
d2776 1
a2776 1
posix_fallocate (int fd, off_t offset, off_t len)
d2794 1
a2794 1
ftruncate64 (int fd, off_t length)
a2805 3
#ifdef __x86_64__
EXPORT_ALIAS (ftruncate64, ftruncate)
#else
d2810 1
a2810 1
  return ftruncate64 (fd, (off_t)length);
a2811 1
#endif
d2815 1
a2815 1
truncate64 (const char *pathname, off_t length)
a2831 3
#ifdef __x86_64__
EXPORT_ALIAS (truncate64, truncate)
#else
d2836 1
a2836 1
  return truncate64 (pathname, (off_t)length);
a2837 1
#endif
d3035 1
a3035 1
mknod32 (const char *path, mode_t mode, dev_t dev)
d3091 1
a3091 1
  return mknod32 (_path, mode, (dev_t) dev);
d3102 1
a3102 1
seteuid32 (uid_t uid)
a3321 3
#ifdef __x86_64__
EXPORT_ALIAS (seteuid32, seteuid)
#else
a3326 1
#endif
d3330 1
a3330 1
setuid32 (uid_t uid)
a3342 3
#ifdef __x86_64__
EXPORT_ALIAS (setuid32, setuid)
#else
a3347 1
#endif
d3350 1
a3350 1
setreuid32 (uid_t ruid, uid_t euid)
d3354 1
a3354 1
  uid_t old_euid = myself->uid;
a3367 3
#ifdef __x86_64__
EXPORT_ALIAS (setreuid32, setreuid)
#else
a3372 1
#endif
d3376 1
a3376 1
setegid32 (gid_t gid)
d3389 1
a3389 1
  struct group * gr = internal_getgrgid (gid);
a3423 3
#ifdef __x86_64__
EXPORT_ALIAS (setegid32, setegid)
#else
a3428 1
#endif
d3432 1
a3432 1
setgid32 (gid_t gid)
a3439 3
#ifdef __x86_64__
EXPORT_ALIAS (setgid32, setgid)
#else
a3447 1
#endif
d3450 1
a3450 1
setregid32 (gid_t rgid, gid_t egid)
d3454 1
a3454 1
  gid_t old_egid = myself->gid;
a3467 3
#ifdef __x86_64__
EXPORT_ALIAS (setregid32, setregid)
#else
a3472 1
#endif
d3573 1
a3573 1
		if ((uid_t) who != p->uid)
d3644 1
a3644 1
	    if ((uid_t) who == p->uid && p->nice < nice)
d3694 1
a3694 1
  struct flock lock_buffer = {F_WRLCK, SEEK_SET, 0, 0, 0};
d3698 1
a3698 1
    if ((lock_buffer.l_start = lseek64 (fd, 0, SEEK_END)) != (off_t) -1
d3701 1
a3701 1
	if (lseek64 (fd, 0, SEEK_END) != (off_t) -1)
d4364 2
a4365 1
fchownat (int dirfd, const char *pathname, uid_t uid, gid_t gid, int flags)
d4384 1
a4384 1
fstatat (int dirfd, const char *pathname, struct stat *st, int flags)
d4501 1
a4501 1
mknodat (int dirfd, const char *pathname, mode_t mode, dev_t dev)
@


1.638.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d734 2
a735 2

	 NFS implements its own mechanism to remove in-use files, which looks
@


1.638.2.3
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d972 1
a972 1
  dev_t devn;
d983 1
a983 1
  devn = win32_name.get_device ();
d3023 1
a3023 1
  if (!p)
@


1.638.2.4
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d180 1
a180 1
  syscall_printf ("%R = dup3(%d, %d, %y)", res, oldfd, newfd, flags);
d197 1
a197 1
      debug_printf ("NtCreateTransaction failed, %y", status);
d261 1
a261 1
		    "failed, status = %y", pc.get_nt_native_path (), status);
d305 1
a305 1
	  debug_printf ("NtOpenFile (%S) failed, status = %y", &root, status);
d352 1
a352 1
		    "failed, status = %y", pc.get_nt_native_path (), status);
d377 1
a377 1
	  debug_printf ("NtOpenFile (%S) failed, status = %y",
d402 1
a402 1
	  debug_printf ("NtCreateFile (%S) failed, status = %y",
d422 1
a422 1
	      debug_printf ("NtCreateFile (%S) failed, status = %y",
d441 1
a441 1
	    debug_printf ("NtCreateFile (%S) failed, status = %y",
d448 1
a448 1
		debug_printf ("NtWriteFile (%S) failed, status = %y",
d456 1
a456 1
		    debug_printf ("NtWriteFile (%S) failed, status = %y",
d471 1
a471 1
		  debug_printf ("NtCreateFile (%S) failed, status = %y",
d478 1
a478 1
		    debug_printf ("NtWriteFile (%S) failed, status = %y",
d491 1
a491 1
      debug_printf ("Move %S to %S failed, status = %y",
d549 1
a549 1
      debug_printf ("Creating file for overwriting failed, status = %y",
d557 1
a557 1
    debug_printf ("Overwriting with another file failed, status = %y", status);
d562 1
a562 1
  debug_printf ("%S, return bin_status %d", pc.get_nt_native_path (), bin_stat);
d579 1
a579 1
      debug_printf ("Checking if directory %S is empty failed, status = %y",
d624 1
a624 1
				 "query status = %y",
d688 1
a688 1
	    debug_printf ("Removing R/O on %S failed, status = %y",
d693 1
a693 1
	debug_printf ("Opening %S for removing R/O failed, status = %y",
d785 1
a785 1
      debug_printf ("Opening %S for delete failed, status = %y",
d810 1
a810 1
      debug_printf ("Setting delete disposition on %S failed, status = %y",
d882 1
a882 1
			    "status = %y", pc.get_nt_native_path (), status2);
d915 1
a915 1
	      debug_printf ("Setting delete-on-close on %S failed, status = %y",
d964 1
a964 1
  syscall_printf ("%S, return status = %y", pc.get_nt_native_path (), status);
d1325 1
a1325 1
  syscall_printf ("open(%s, %y)", unix_path, flags);
d1393 1
a1393 1
  syscall_printf ("%R = open(%s, %y)", res, unix_path, flags);
d1639 1
a1639 1
  syscall_printf ("%R = chmod(%s, 0%o)", res, path, mode);
d1805 1
a1805 1
    debug_printf ("NtOpenFile (%S), status %y", &uvol, status);
d1810 1
a1810 1
	debug_printf ("NtFlushBuffersFile (%S), status %y", &uvol, status);
d1830 1
a1830 1
      debug_printf ("NtOpenDirectoryObject, status %y", status);
d2366 1
a2366 1
      debug_printf ("status %y", status);
d3243 1
a3243 1
  debug_printf ("Found token %p", new_token);
d3298 1
a3298 1
	debug_printf ("NtSetInformationToken (user.token, TokenOwner), %y",
d3305 1
a3305 1
		      "%y", status);
d3314 1
a3314 1
	    debug_printf ("NtSetInformationToken (TokenDefaultDacl), %y",
d3459 1
a3459 1
		      "TokenPrimaryGroup), %y", status);
d3463 1
a3463 1
	debug_printf ("NtSetInformationToken (token, TokenPrimaryGroup), %y",
d3470 1
a3470 1
    debug_printf ("NtSetInformationToken (hProcToken, TokenPrimaryGroup), %y",
d4064 1
a4064 1
  debug_printf ("hostid %08y from MachineGuid %W", hostid, wguid);
@


1.638.2.5
log
@Pull in changes from HEAD
@
text
@d145 1
a145 1
  if (newfd >= OPEN_MAX_MAX || newfd < 0)
@


1.638.2.6
log
@Pull in changes from HEAD
@
text
@a2332 9
  /* Check cross-device before touching anything.  Otherwise we might end
     up with an unlinked target dir even if the actual rename didn't work. */
  if (oldpc.fs_type () != dstpc->fs_type ()
      || oldpc.fs_serial_number () != dstpc->fs_serial_number ())
    {
      set_errno (EXDEV);
      goto out;
    }

d2467 4
a2470 46
  if (oldpc.fs_is_nfs ())
    {
      /* Workaround depressing NFS bug.  FILE_RENAME_INFORMATION.FileName
	 *must* be relative to the parent directory of the original file,
	 otherwise NtSetInformationFile returns with STATUS_NOT_SAME_DEVICE.
	 Neither absolute paths, nor directory handle relative paths work
	 as expected! */
      PWCHAR oldp, dstp;

      /* Skip equivalent path prefix.  We already know that both paths are
	 on the same drive anyway. */
      for (oldp = oldpc.get_nt_native_path ()->Buffer,
	   dstp = dstpc->get_nt_native_path ()->Buffer;
	   *oldp == *dstp; ++oldp, ++dstp)
	;
      while (oldp[-1] != L'\\')
      	--oldp, --dstp;
      /* Now oldp points to the first path component in oldpc different from
         dstpc, vice versa for dstp and oldpc.  To create a dstpc path relative
	 to oldpc, we now have to prepend as many ".." components to dstp, as
	 are still available in oldp.  Example:

	   oldpc = \??\UNC\server\a\b\c\d\e
	   dstpc = \??\UNC\server\a\b\f\g

           prefix: \??\UNC\server\a\b\
	   oldp: c\d\e
	   dstp: f\g
	   dstp expressed relative to e's parent dir:  ..\..\f\g

	 So what we do here is to count the number of backslashes in oldp and
	 prepend one "..\" to dstp for each of them. */
      PWCHAR newdst = tp.w_get ();
      PWCHAR newp = newdst;
      while ((oldp = wcschr (++oldp, L'\\')) != NULL)
      	newp = wcpcpy (newp, L"..\\");
      newp = wcpcpy (newp, dstp);
      size = sizeof (FILE_RENAME_INFORMATION)
	     + (newp - newdst) * sizeof (WCHAR);
      if (size > NT_MAX_PATH * sizeof (WCHAR)) /* Hopefully very seldom. */
	pfri = (PFILE_RENAME_INFORMATION) alloca (size);
      else
	pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
      pfri->FileNameLength = (newp - newdst) * sizeof (WCHAR);
      memcpy (&pfri->FileName,  newdst, pfri->FileNameLength);
    }
d2472 1
a2472 11
    {
      size = sizeof (FILE_RENAME_INFORMATION)
	     + dstpc->get_nt_native_path ()->Length;
      if (size > NT_MAX_PATH * sizeof (WCHAR)) /* Hopefully very seldom. */
	pfri = (PFILE_RENAME_INFORMATION) alloca (size);
      else
	pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
      pfri->FileNameLength = dstpc->get_nt_native_path ()->Length;
      memcpy (&pfri->FileName,  dstpc->get_nt_native_path ()->Buffer,
	      pfri->FileNameLength);
    }
d2475 3
@


1.638.2.7
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d2071 1
d2443 3
a2445 3
     The test tries to be as quick as possible.  Due to the above cross device
     check we already know both files are on the same device.  So it just
     tests if oldpath has more than 1 hardlink, then it opens newpath
d2450 1
a2475 12
  /* Create FILE_RENAME_INFORMATION struct.  Using a tmp_pathbuf area allows
     for paths of up to 32757 chars.  This test is just for paranoia's sake. */
  if (dstpc->get_nt_native_path ()->Length > NT_MAX_PATH * sizeof (WCHAR)
					     - sizeof (FILE_RENAME_INFORMATION))
    {
      debug_printf ("target filename too long");
      set_errno (EINVAL);
      goto out;
    }
  pfri = (PFILE_RENAME_INFORMATION) tp.w_get ();
  pfri->ReplaceIfExists = TRUE;
  pfri->RootDirectory = NULL;
d2513 6
d2524 6
d2534 3
a2536 3
  status = NtSetInformationFile (fh, &io, pfri,
  				 sizeof *pfri + pfri->FileNameLength,
				 FileRenameInformation);
d2573 1
a2573 2
	status = NtSetInformationFile (fh, &io, pfri,
				       sizeof *pfri + pfri->FileNameLength,
@


1.638.2.8
log
@Pull in changes from HEAD
@
text
@d2486 46
a2531 3
  pfri->FileNameLength = dstpc->get_nt_native_path ()->Length;
  memcpy (&pfri->FileName,  dstpc->get_nt_native_path ()->Buffer,
	  pfri->FileNameLength);
@


1.638.2.9
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.638.2.10
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d4093 1
a4093 1
  static const char *def_shells[] = {
@


1.638.2.11
log
@	* cygwin.din (_get_osfhandle): Make main export.  Define get_osfhandle
	from here.
	* cygwin64.din (_get_osfhandle): Rename from get_osfhandle.
	(_setmode): Rename from setmode.
	* include/io.h: Ditto. Define unprefixed names with preprocessor
	macros for backwards source compatibility.
	(access): Remove.
	* syscalls.cc (_setmode): Rename from setmode.
	(cygwin_setmode): Call _setmode.
	(_get_osfhandle): Rename from get_osfhandle.
@
text
@d2757 1
a2757 1
_setmode (int fd, int mode)
d2795 1
a2795 1
  int res = _setmode (fd, mode);
d2895 1
a2895 1
_get_osfhandle (int fd)
@


1.638.2.12
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d324 2
@


1.638.2.13
log
@	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Use %lu as
	format specifier to match HANDLE size.
	* net.cc (cygwin_sendto): Fix return type to be ssize_t.  Change
	syscall_printf return type format specifier to %lR.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* smallprint.cc (__small_vsprintf): Handle `l' for %R, too.
	(__small_vswprintf): Ditto.
	* syscalls.cc (read): Change syscall_printf return type format specifier
	to %lR.
	(readv): Ditto.
	(pread): Ditto.
	(write): Ditto.
	(writev): Ditto.
	(pwrite): Ditto.
	(lseek64): Enhance comment.
@
text
@d1150 1
a1150 1
  syscall_printf ("%lR = read(%d, %p, %d)", res, fd, ptr, len);
d1192 1
a1192 1
  syscall_printf ("%lR = readv(%d, %p, %d)", res, fd, iov, iovcnt);
d1209 1
a1209 1
  syscall_printf ("%lR = pread(%d, %p, %d, %d)", res, fd, ptr, len, off);
d1243 1
a1243 1
  syscall_printf ("%lR = write(%d, %p, %d)", res, fd, ptr, len);
d1289 1
a1289 1
    paranoid_printf ("%lR = writev(%d, %p, %d)", res, fd, iov, iovcnt);
d1291 1
a1291 1
    syscall_printf ("%lR = writev(%d, %p, %d)", res, fd, iov, iovcnt);
d1309 1
a1309 1
  syscall_printf ("%lR = pwrite(%d, %p, %d, %d)", res, fd, ptr, len, off);
d1416 1
a1416 1
  /* Can't use %R/%lR here since res is always 8 bytes */
@


1.638.2.14
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Change type of
	local variable res to ssize_t.
	* net.cc (cygwin_sendto): Fix local variable res, containing return
	value, to be ssize_t as well.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* syscalls.cc (write): Ditto.
	(writev): Ditto.
	* pipe.cc (fhandler_pipe::open): Fix type when reading handle value to
	accommodate 32 bit compiler.
@
text
@d1222 1
a1222 1
  ssize_t res = -1;
d1260 1
a1260 1
  ssize_t res = -1;
@


1.637
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d231 2
a232 1
  has_been_moved
d249 1
d344 4
a347 1
  status = NtQueryInformationFile (fh, &io, pfii, 65536,
d364 2
a365 1
  status = NtSetInformationFile (fh, &io, pfri, 65536, FileRenameInformation);
d486 1
a486 1
      status = NtSetInformationFile (fh, &io, pfri, 65536,
d502 20
d553 1
a553 1
  status = NtSetInformationFile (tmp_fh, &io, pfri, 65536,
d720 9
d731 6
a736 13
      /* STATUS_LOCK_NOT_GRANTED can be generated under not quite clear
	 circumstances when trying to open a file on NFS with FILE_SHARE_DELETE
	 only.  This has been observed with SFU 3.5 if the NFS share has been
	 mounted under a drive letter.  It's not generated for all files, but
	 only for some.  If it's generated once for a file, it will be
	 generated all the time.  It looks like wrong file state information
	 is stored within the NFS client, for no apparent reason, which never
	 times out.  Opening the file with FILE_SHARE_VALID_FLAGS will work,
	 though, and it is then possible to delete the file quite normally.

	 NFS implements its own mechanism to remove in-use files which
	 looks quite similar to what we do in try_to_bin for remote files.
	 That's why we don't call try_to_bin on NFS.
a740 2
      debug_printf ("Sharing violation when opening %S",
		    pc.get_nt_native_path ());
d743 3
a745 1
      if (!pc.isdir () || pc.isremote ())
d750 3
a752 3
	  /* It's getting tricky.  The directory is opened in some process,
	     so we're supposed to move it to the recycler and mark it for
	     deletion.  But what if the directory is not empty?  The move
d754 5
a758 8
	     have to move it back.  That's bad, because the directory would
	     be moved around which results in a temporary inconsistent state.
	     So, what we do here is to test if the directory is empty.  If
	     not, we bail out with STATUS_DIRECTORY_NOT_EMPTY.  The below code
	     tests for at least three entries in the directory, ".", "..",
	     and another one.  Three entries means, not empty.  This doesn't
	     work for the root directory of a drive, but the root dir can
	     neither be deleted, nor moved anyway. */
d792 1
a792 1
      && (bin_stat = try_to_bin (pc, fh, access)) == has_been_moved)
d794 7
a800 1
      status = STATUS_SUCCESS;
d865 1
d877 2
a878 1
	  else
d884 2
d923 4
a926 2
	      if (bin_stat == has_been_moved)
		status = STATUS_SUCCESS;
d936 1
a936 1
	  /* Restore R/O attribute if setting the delete dispostion failed. */
@


1.636
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d2298 1
a2298 1
	  && WaitForSingleObject (signal_arrived, 10L) != WAIT_OBJECT_0)
@


1.635
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d2298 1
a2298 1
	  && cygwait (10L) != WAIT_SIGNALED)
@


1.634
log
@* dtable.cc (dtable::dup3): Only return with lock set when O_EXCL flag is
passed in.
* syscalls.cc (dup_finish): Pass O_EXCL in flags to dtable::dup3.
@
text
@d2298 1
a2298 1
	  && WaitForSingleObject (signal_arrived, 10L) != WAIT_OBJECT_0)
@


1.633
log
@* DevNotes: Add entry cgf-000011.
* fhandler.h (fhandler_base::refcnt): Delete.
(fhandler_base::inc_refcnt): New function.
(fhandler_base::dec_refcnt): New function.
* cygheap.h (cygheap_fdnew::~cygheap_fdnew): Accommodate split of refcnt to
inc_refcnt/dec_refcnt.
(cygheap_fdget::cygheap_fdget): Ditto.
(cygheap_fdget::~cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable::release): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::init_std_file_from_handle): Ditto.
(dtable::dup3): On success, return with fdtab locked.
* dtable.h (dtable): Add dup_finish as a friend.
* syscalls.cc (dup_finish): Define new function.  Increment refcnt while fdtab
is locked.
(dup2): Use common dup_finish() to perform dup operation.
(dup3): Ditto.
@
text
@d133 1
a133 1
  if ((res = cygheap->fdtab.dup3 (oldfd, newfd, flags)) == newfd)
@


1.632
log
@	* globals.cc (ro_u_refs): New R/O unicode string.
	* mount.cc (fs_info::update): Recognize ReFS.
	* mount.h (enum fs_info_type): Add refs.
	(class fs_info): Add refs flag and accessor methods.
	* ntdll.h (RtlAddAccessAllowedAceEx): Declare.
	(RtlAddAccessDeniedAceEx): Declare.
	* path.h (path_conv::fs_is_refs): Define.
	* sec_helper.cc (_recycler_sd): New function to create security
	descriptors suitable for the recycler bin starting with Vista.
	* security.cc (add_access_allowed_ace): Use RtlAddAccessAllowedAceEx
	and drop code to set AceFlags explicitely.
	(add_access_denied_ace): Use RtlAddAccessDeniedAceEx and drop code to
	set AceFlags explicitely.
	* security.h (_recycler_sd): Declare.
	(recycler_sd): Define.
	* syscalls.cc (desktop_ini): Change formatting.
	(desktop_ini_ext): Define third line of recycler desktop.ini file
	since Vista,
	(try_to_bin): Handle ReFS just like NTFS.  Write Vista and later
	Recycler in all uppercase, just like shell32 does when recreating it.
	Fix comments to include ReFS.  Don't implicitely reuse object
	attributes from earlier NtOpenFile call, rather recreate it for safety.
	Use recycler_sd call when creating security descriptor for Recycler
	dirs and files on Vista and later.  Write third line of desktop.ini
	when on Vista and later.
@
text
@d129 12
d155 2
a156 2
  else if ((res = cygheap->fdtab.dup3 (oldfd, newfd, 0)) == newfd)
    cygheap->fdtab[newfd]->refcnt (1);
d177 2
a178 2
  else if ((res = cygheap->fdtab.dup3 (oldfd, newfd, flags)) == newfd)
    cygheap->fdtab[newfd]->refcnt (1);
@


1.631
log
@	* syscalls.cc (fhandler_base::stat_fixup): Fix inode numbers of
	non-device files in virtual fileysystems.
@
text
@d203 6
a208 1
  "[.ShellClassInfo]\r\nCLSID={645FF040-5081-101B-9F08-00AA002F954E}\r\n";
d237 1
d262 2
a263 2
      if (wincap.has_recycle_dot_bin ())	/* NTFS and FAT since Vista */
	RtlAppendUnicodeToString (&recycler, L"\\$Recycle.Bin\\");
d300 4
a303 4
      /* On NTFS the recycler dir contains user specific subdirs, which are the
	 actual recycle bins per user.  The name if this dir is the string
	 representation of the user SID. */
      if (pc.fs_is_ntfs ())
d353 2
d365 3
a367 2
	 by the first user actually using the bin.  The permissions are the
	 default permissions propagated from the root directory. */
d369 3
a371 1
				  rootdir, NULL);
d375 1
a375 1
			     | (pc.fs_is_ntfs () ? 0 : FILE_ADD_FILE),
d390 1
a390 1
      if (pc.fs_is_ntfs ())
d394 2
d416 1
a416 1
				      recyclerdir, NULL);
d432 9
@


1.630
log
@	* syscalls.cc (fhandler_base::stat_fixup): Replace string comparison
	with new device::is_dev_resident() call.
@
text
@d1594 2
a1595 2
  /* Set inode number to device number.  This gives us a valid, unique
     inode number and we especially don't have to call hash_path_name. */
d1597 2
a1598 1
    buf->st_ino = get_device ();
@


1.629
log
@	* devices.h (device::get_device): New method.
	* fhandler_dev.cc (fhandler_dev::readdir): Set st_ino to device number.
	* syscalls.cc (fhandler_base::stat_fixup): Ditto.  Fix link count for
	CD-ROM devices.  Fix typo in comment.
@
text
@d1604 1
a1604 1
      if (!strncmp (dev ().name, "/dev/", 5))
@


1.628
log
@	* fhandler.h (fhandler_base::stat_fixup): Rename from
	fhandler_base::set_ino_and_dev.
	* syscalls.cc (fhandler_base::stat_fixup): Ditto. Accommodate name
	change throughout.  Fixup link count of console devices.
@
text
@d1594 2
d1597 1
a1597 1
    buf->st_ino = get_ino ();
d1621 1
a1621 1
	 make sure the link count is correct. */
d1624 3
@


1.627
log
@	* devices.h (FH_CYGDRIVE): Define as DEV_VIRTFS_MAJOR class device.
	(DEV_CYGDRIVE_MAJOR): Remove.
	(iscygdrive_dev): Define.
	* dtable.cc (fh_alloc): Accommodate above change.
	* path.cc (path_conv::check): Use iscygdrive_dev to check for cygdrive.
	* syscalls.cc (fhandler_base::set_ino_and_dev): Drop check for
	DEV_CYGDRIVE_MAJOR from conditional.
@
text
@d1592 1
a1592 1
fhandler_base::set_ino_and_dev (struct __stat64 *buf)
d1616 7
a1622 1
    buf->st_rdev = get_device ();
d1638 1
a1638 1
	cfd->set_ino_and_dev (buf);
d1777 1
a1777 1
	fh->set_ino_and_dev (buf);
@


1.626
log
@	* devices.h (FH_DEV): Define as DEV_VIRTFS_MAJOR class device.
	(DEV_DEV_MAJOR): Remove.
	* dtable.cc (fh_alloc): Accommodate above change.
	* syscalls.cc (set_ino_and_dev): Drop check for DEV_DEV_MAJOR from
	conditional.
@
text
@d1615 1
a1615 2
  if (!buf->st_rdev && get_major () != DEV_VIRTFS_MAJOR
      && get_major () != DEV_CYGDRIVE_MAJOR)
@


1.625
log
@	* fhandler.h (fhandler_base::set_ino_and_dev): Declare.
	* syscalls.cc (fhandler_base::set_ino_and_dev): New method to set
	st_ino, st_dev, and st_rdev for devices in a single spot.
	(fstat64): Call fhandler_base::set_ino_and_dev instead of setting
	st_ino, st_dev, and st_rdev here.
	(stat_worker): Ditto.
@
text
@d1616 1
a1616 1
      && get_major () != DEV_CYGDRIVE_MAJOR && get_major () != DEV_DEV_MAJOR)
@


1.624
log
@	* syscalls.cc (lseek): Fix debug output.
@
text
@d1588 32
d1633 1
a1633 8
	{
	  if (!buf->st_ino)
	    buf->st_ino = cfd->get_ino ();
	  if (!buf->st_dev)
	    buf->st_dev = cfd->get_device ();
	  if (!buf->st_rdev)
	    buf->st_rdev = buf->st_dev;
	}
d1772 1
a1772 8
	{
	  if (!buf->st_ino)
	    buf->st_ino = fh->get_ino ();
	  if (!buf->st_dev)
	    buf->st_dev = fh->get_device ();
	  if (!buf->st_rdev)
	    buf->st_rdev = buf->st_dev;
	}
@


1.623
log
@	* cygwin.din (scandirat): Export.
	* posix.sgml (std-gnu): Add scandirat.
	* syscalls.cc (scandirat): New function.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/dirent.h (scandirat): Declare.
@
text
@d1347 4
a1350 1
  syscall_printf ("%R = lseek(%d, %D, %d)", res, fd, pos, dir);
@


1.622
log
@* pinfo.cc (_pinfo::set_ctty): Revert 2012-02-07 change to skip function if tty
in question == our ctty.
* syscalls.cc (setsid): Avoid two function calls.
* dtable.cc (dtable::dup_worker): Remove debugging.
* init.cc (search_for): Calculate for every new process rather than using
shared value.
(threadfunc_ix): Fill in for ever new process rather than sing shared value.
@
text
@d42 1
d4441 15
@


1.621
log
@* syscalls.cc (setsid): On second thought, in the spirit of keeping things
kludgy, set ctty to -2 here as a special flag, and...
(open): ...only eschew setting O_NOCTTY when that case is detected.
@
text
@d1019 2
a1020 2
      myself->sid = getpid ();
      myself->pgid = getpid ();
@


1.620
log
@* syscalls.cc (open): Semi-revert (?) to allowing open of a tty to become
controlling tty if there is no controlling tty.
@
text
@d1018 1
a1018 1
      myself->ctty = -1;
d1278 1
a1278 1
	  if (!(flags & O_NOCTTY) && fd > 2 && myself->ctty > 0)
@


1.619
log
@	* include/process.h: Move here from include/cygwin subdir.
	* exec.cc: Change include of process.h to reflect the fact that it's
	now back in include.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
@
text
@d1278 1
a1278 1
	  if (!(flags & O_NOCTTY) && fd > 2)
@


1.618
log
@* cygheap.cc (init_cygheap::manage_console_count): Delete.
* cygheap.h (init_cygheap::manage_console_count): Ditto.
(init_cygheap::console_count): Ditto.
* fhandler.h (fhandler_console::has_a): Ditto.
(fhandler_console::free_console): Declare new function.
* fhandler_console.cc (fhandler_console::free_console): Define new function.
(fhandler_console::open_setup): Delete call to manage_console_count.
(fhandler_console::close): Ditto.  Replace with call to free_console().
* fhandler_tty.cc (fhandler_pty_slave::open): Delete call to
manage_console_count.
(fhandler_pty_slave::cleanup): Ditto.
(fhandler_pty_slave::close): Call fhandler_console::free_console() if this is
our controlling tty.
* pinfo.cc (_pinfo::set_ctty): Skip function if tty in question == our ctty.
Delete call to manage_console_count.
* syscalls.cc (close_all_files): Avoid locking and avoid setting errno when
iterating over fds.
@
text
@d34 1
a34 1
#include <cygwin/process.h>
@


1.617
log
@* syscalls.cc (close_all_files): Use cygheap_fdget to manipulate fhandler.  Use
debug_only_printf.
@
text
@d97 1
a97 1
      cygheap_fdget cfd (i);
a1018 1
      cygheap->manage_console_count ("setsid", 0);
@


1.616
log
@* dtable.cc (dtable::dup_worker): Add comment explaining why refcnt isn't
incremented here.
(dtable::dup3): Simplify slightly.  Add comment.
* syscalls.cc (dup3): Increment refcnt here, similarly to dup2.
@
text
@a92 1
  fhandler_base *fh;
d96 14
a109 13
    if ((fh = cygheap->fdtab[i]) != NULL)
      {
#ifdef DEBUGGING
	debug_printf ("closing fd %d", i);
#endif
	if (i == 2)
	  DuplicateHandle (GetCurrentProcess (), fh->get_output_handle (),
			   GetCurrentProcess (), &h,
			   0, false, DUPLICATE_SAME_ACCESS);
	fh->close_with_arch ();
	if (!norelease)
	  cygheap->fdtab.release (i);
      }
@


1.615
log
@* syscalls.cc (dup3): Fix debug typo.
* fhandler.cc (flush_async_io): Assume only called for writer.  Call
GetOverlappedResult directly rather than kluding call to has_ongoing_io.
(fhandler_base_overlapped::close): Only start flush thread when closing write
handle.  Only cancel I/O when reading.
@
text
@d164 3
a166 2
  else
    res = cygheap->fdtab.dup3 (oldfd, newfd, flags);
@


1.614
log
@	* syscalls.cc (gethostid): Simplify.  Just fetch MachineGuid and
	create hash from there.
@
text
@d166 1
a166 1
  syscall_printf ("%R = dup2(%d, %d, %p)", res, oldfd, newfd, flags);
@


1.613
log
@* cygheap.h (cygheap_fdmanip::release): Simplify.
* dtable.cc (dtable::release): Make void again.  Skip not_open check since it
is guaranteed to be open.  Don't bother deleting here since actual deletion
will be handled in cygheap_fdget::~cygheap_fdget.
* dtable.h (dtable::release): Make void again.
* syscalls.cc (dup2): Bump fhandler use count on successful dup.
@
text
@d3878 2
a3879 19
  unsigned data[13] = {0x92895012,
		       0x10293412,
		       0x29602018,
		       0x81928167,
		       0x34601329,
		       0x75630198,
		       0x89860395,
		       0x62897564,
		       0x00194362,
		       0x20548593,
		       0x96839102,
		       0x12219854,
		       0x00290012};

  bool has_cpuid = false;

  DWORD opmask = SetThreadAffinityMask (GetCurrentThread (), 1);
  if (!opmask)
    debug_printf ("SetThreadAffinityMask to 1 failed, %E");
d3881 16
a3896 94
  if (!can_set_flag (0x00040000))
    debug_printf ("386 processor - no cpuid");
  else
    {
      debug_printf ("486 processor");
      if (can_set_flag (0x00200000))
	{
	  debug_printf ("processor supports CPUID instruction");
	  has_cpuid = true;
	}
      else
	debug_printf ("processor does not support CPUID instruction");
    }
  if (has_cpuid)
    {
      unsigned maxf, unused[3];
      cpuid (&maxf, &unused[0], &unused[1], &unused[2], 0);
      maxf &= 0xffff;
      if (maxf >= 1)
	{
	  unsigned features;
	  cpuid (&data[0], &unused[0], &unused[1], &features, 1);
	  if (features & (1 << 18))
	    {
	      debug_printf ("processor has psn");
	      if (maxf >= 3)
		{
		  cpuid (&unused[0], &unused[1], &data[1], &data[2], 3);
		  debug_printf ("Processor PSN: %04x-%04x-%04x-%04x-%04x-%04x",
				data[0] >> 16, data[0] & 0xffff, data[2] >> 16, data[2] & 0xffff, data[1] >> 16, data[1] & 0xffff);
		}
	    }
	  else
	    debug_printf ("processor does not have psn");
	}
    }

  LARGE_INTEGER u1;
  ULONG u2, u3;
  union {
    UCHAR mac[6];
    struct {
      ULONG m1;
      USHORT m2;
    };
  } u4;
  NTSTATUS status = NtAllocateUuids (&u1, &u2, &u3, u4.mac);
  if (NT_SUCCESS (status))
    {
      data[4] = u4.m1;
      data[5] = u4.m2;
      // Unfortunately Windows will sometimes pick a virtual Ethernet card
      // e.g. VMWare Virtual Ethernet Adaptor
      debug_printf ("MAC address of first Ethernet card: "
		    "%02x:%02x:%02x:%02x:%02x:%02x",
		    u4.mac[0], u4.mac[1], u4.mac[2],
		    u4.mac[3], u4.mac[4], u4.mac[5]);
    }
  else
    debug_printf ("no Ethernet card installed");

  WCHAR wdata[24];
  reg_key key (HKEY_LOCAL_MACHINE, KEY_READ, L"SOFTWARE", L"Microsoft",
	       L"Windows NT", L"CurrentVersion", NULL);
  key.get_string (L"ProductId", wdata, 24, L"00000-000-0000000-00000");
  sys_wcstombs ((char *)&data[6], 24, wdata, 24);
  debug_printf ("Windows Product ID: %s", (char *)&data[6]);

  GetDiskFreeSpaceEx ("C:\\", NULL, (PULARGE_INTEGER) &data[11], NULL);

  debug_printf ("hostid entropy: %08x %08x %08x %08x "
				"%08x %08x %08x %08x "
				"%08x %08x %08x %08x "
				"%08x",
				data[0], data[1],
				data[2], data[3],
				data[4], data[5],
				data[6], data[7],
				data[8], data[9],
				data[10], data[11],
				data[12]);

  long hostid = 0x40291372;
  // a random hashing algorithm
  // dependancy on md5 is probably too costly
  for (int i=0;i<13;i++)
    hostid ^= ((data[i] << (i << 2)) | (data[i] >> (32 - (i << 2))));

  if (opmask && !SetThreadAffinityMask (GetCurrentThread (), opmask))
    debug_printf ("SetThreadAffinityMask to %p failed, %E", opmask);

  debug_printf ("hostid: %08x", hostid);

  return hostid;
@


1.612
log
@	* include/cygwin/process.h: Move here from newlib.
	* exec.cc: Change include of process.h to reflect the fact that it's
	now in the include/cygwin subfolder.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
@
text
@d142 2
a143 2
  else
    res = cygheap->fdtab.dup3 (oldfd, newfd, 0);
@


1.611
log
@* fhandler_dsp.cc (fhandler_dev_dsp::fhandler_dev_dsp): Set up device.
* syscalls.cc (open): Very minor formatting tweak.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d34 1
a34 1
#include <process.h>
@


1.610
log
@	Throughout use wincap.allocation_granularity instead of getpagesize.
	Throughout use wincap.page_size instead of getsystempagesize.
	Throughout use "status" as variable name to hold NTSTATUS values.
	* fhandler_mem.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	Fix debug_printf output.  Rectify long statements.  Fix comment
	formatting.
	* fhandler_proc.cc: Ditto.
	(format_proc_swaps): Drop useless test for ERROR_PROC_NOT_FOUND.
	* fhandler_process.cc: Ditto as in fhandler_mem.cc.
	(get_process_state): Rearrange allocation loop.  Use malloc/realloc.
	(get_mem_values): Fix potential NULL pointer usage.  Drop unused
	variable.
	* pinfo.cc (winpids::enum_processes): Handle low memory gracefully.
	* sec_auth.cc (get_priv_list): Drop local variable ret.
	* shared.cc (memory_init): Drop outdated call to getpagesize.
	* syscalls.cc (getsystempagesize): Remove.
	* sysconf.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	(sysinfo): Constify sizeof_stodi.  Drop useless test for
	ERROR_PROC_NOT_FOUND.
	* thread.cc (pthread_getattr_np): Cast pointers to uintptr_t rather
	than to int for pointer arithmetic.
	* winsup.h (getsystempagesize): Drop declaration.
@
text
@d1278 1
a1278 1
	  if (!(flags & O_NOCTTY)&& fd > 2)
@


1.609
log
@	* syscalls.cc (rename): Fix typo in comment.  Fix condition to handle
	the case oldpath is no .lnk symlink and newpath points to an existing
	.lnk symlink or .exe file and no explicit .lnk suffix has been given
	in oldpath.  Add a comment to explain.
@
text
@a2449 6
size_t
getsystempagesize ()
{
  return (size_t) wincap.page_size ();
}

@


1.608
log
@* fhandler.cc (fhandler_base::close): Move setting isclosed() from here to
closed().
(fhandler_base_overlapped::close): Correct comment.
(fhandler_base_overlapped::destroy_overlapped): Signal overlapped event before
closing it to potentially wake up a waiting thread.
(fhandler_base_overlapped::wait_overlapped): Expand setting of err when closed
to encompass non-signal event.  Test for a cancel event before making
nonblocking decisions.
* syscalls.cc (close): Set closed flag here so that any concurrently executing
functions will be notified ASAP.
@
text
@d2165 1
a2165 1
	     name probably makes sesne as it is), or if the destination
d2177 6
a2182 2
	  if ((RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
					  &ro_u_lnk, TRUE)
@


1.607
log
@Clean up whitespace.
@
text
@d1376 1
@


1.606
log
@* exceptions.cc (set_signal_mask): Remove useless debugging output.
* fhandler.cc (fhandler_base::write): Ditto.
(fhandler_base_overlapped::close): Cancel any ongoing I/O before closing.
* syscalls.cc (write): Default to always reporting all writes in strace output
via syscall_printf.
* wait.cc (wait4): Fix debugging output.  Use standard syscall leaver output.
@
text
@d143 1
a143 1
    res = cygheap->fdtab.dup3 (oldfd, newfd, 0); 
d648 1
a648 1
     
d763 1
a763 1
	      
d773 1
a773 1
		 
@


1.605
log
@Implement fhandler reference counting.
* cygheap.h
(cygheap_fdmanip::release): Make virtual.
(cygheap_fdnew::~cygheap_fdnew): New destructor increments reference count when
fd has been allocated.
(cygheap_fdget::fh): New (old?) field.
(cygheap_fdget::cygheap_fdget): Increment reference count when we've found an
active fd.  Set fh appropriately.
(cygheap_fdget::~cygheap_fdget): Decrement reference count when appropriate.
Delete fh if reference count goes to zero.
(cygheap_fdget::release): New function.  Do more bookkeping on release.
* dtable.cc (dtable::release): Change from void to boolean return.  Only delete
the fhandler when its reference count is <= 0 (this should be a fairly unusual
case).  Return true if fhandler has been deleted.
(cygwin_attach_handle_to_fd): Increment reference count when fh is assigned.
(dtable::init_std_file_from_handle): Ditto.
* dtable.h (dtable::release): Change return to boolean.
* fhandler.cc (fhandler_base::fhandler_base): Set new isclosed flag to false.
Set _refcnt to zero.
(fhandler_base::close): Simplify paranoid debugging output.  Set new isclosed()
flag.
(fhandler_base_overlapped::wait_overlapped): Use isclosed() flag to avoid
querying the exception handle.
* fhandler.h (fhandler_base::_refcnt): New field.
(fhandler_base::refcnt): New function.
(fhandler_base::isclosed): Implement.
(fhandler_base::fhandler_base): Set isclosed to false.
* syscalls.cc: Remove space after function before parentheses for several
strace printfs.
(dup): Add standard strace "leaver" code.
(dup2): Ditto.
(dup3): Ditto.
(remove): Ditto.
(getpid): Ditto.
(getppid): Ditto.
(lseek64): Fix strace debugging to correctly use %R.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Avoid sending signals to
other processes if we're debugging since it can cause a deadlock with the
calling debugger.
* exceptions.cc (_cygtls::call_signal_handler): Add debugging-only strace
output.
@
text
@d1173 1
a1173 4
  if (fd == 1 || fd == 2)
    paranoid_printf ("%R = write(%d, %p, %d)", res, fd, ptr, len);
  else
    syscall_printf ("%R = write(%d, %p, %d)", res, fd, ptr, len);
@


1.604
log
@* mmap.cc (mlock): Add standard syscall return value debugging output.
(munlock): Ditto.
(posix_madvise): Ditto.
* signal.cc: Remove obsolete sigcatchers stuff throughout.
(sigaction_worker): Add function name parameter and use it to show standard
syscall return value debugging output.  Also add fault protection.
(sigaction): Accommodate extra argument to sigaction_worker.
(siginterrupt): Ditto.
* syscalls.cc (read): Remove obsolete sigcatchers stuff.
(readv): Ditto.
@
text
@d123 3
a125 1
  return cygheap->fdtab.dup3 (fd, cygheap_fdnew (), 0);
d131 1
a133 1
      syscall_printf ("-1 = dup2 (%d, %d) (%d too large)", oldfd, newfd, newfd);
d135 1
a135 1
      return -1;
d137 1
a137 1
  if (newfd == oldfd)
d140 1
a140 7
      if (cfd < 0)
	{
	  syscall_printf ("%R = dup2(%d,%d) (oldfd not open)", -1, oldfd, newfd);
	  return -1;
	}
      syscall_printf ("%R = dup2(%d, %d) (newfd==oldfd)", oldfd, oldfd, newfd);
      return oldfd;
d142 5
a146 1
  return cygheap->fdtab.dup3 (oldfd, newfd, 0);
d152 1
a154 2
      syscall_printf ("-1 = dup3 (%d, %d, %p) (%d too large)",
		      oldfd, newfd, flags, newfd);
d156 1
a156 1
      return -1;
d158 1
a158 1
  if (newfd == oldfd)
d162 1
a162 3
      syscall_printf ("-1 = dup3 (%d, %d, %p) (newfd==oldfd)",
		      oldfd, newfd, flags);
      return -1;
d164 4
a167 1
  return cygheap->fdtab.dup3 (oldfd, newfd, flags);
d968 3
a970 1
  return win32_name.isdir () ? rmdir (ourname) : unlink (ourname);
d976 1
d990 1
d1048 1
d1074 1
a1074 1
  syscall_printf ("read (%d, %p, %d) %sblocking",
d1116 1
a1116 1
  syscall_printf ("readv (%d, %p, %d) %sblocking",
d1166 1
a1166 1
    paranoid_printf ("write (%d, %p, %d)", fd, ptr, len);
d1168 1
a1168 1
    syscall_printf  ("write (%d, %p, %d)", fd, ptr, len);
d1214 1
a1214 1
    paranoid_printf ("writev (%d, %p, %d)", fd, iov, iovcnt);
d1216 1
a1216 1
    syscall_printf  ("writev (%d, %p, %d)", fd, iov, iovcnt);
d1256 1
a1256 1
  syscall_printf ("open (%s, %p)", unix_path, flags);
d1349 1
a1349 1
  syscall_printf ("%D = lseek (%d, %D, %d)", res, fd, pos, dir);
d1369 1
a1369 1
  syscall_printf ("close (%d)", fd);
@


1.603
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d1069 2
a1070 4
  extern int sigcatchers;
  syscall_printf ("read (%d, %p, %d) %sblocking, sigcatchers %d",
		  fd, ptr, len, cfd->is_nonblocking () ? "non" : "",
		  sigcatchers);
d1111 2
a1112 4
  extern int sigcatchers;
  syscall_printf ("readv (%d, %p, %d) %sblocking, sigcatchers %d",
		  fd, iov, iovcnt, cfd->is_nonblocking () ? "non" : "",
		  sigcatchers);
@


1.602
log
@* sigproc.cc (remove_proc): Don't terminate the currently executing thread.
@
text
@d140 1
a140 1
	  syscall_printf ("-1 = dup2 (%d, %d) (oldfd not open)", oldfd, newfd);
d143 1
a143 1
      syscall_printf ("%d = dup2 (%d, %d) (newfd==oldfd)", oldfd, oldfd, newfd);
d937 1
a937 1
  syscall_printf ("%d = unlink (%s)", res, ourname);
d949 1
a949 1
      syscall_printf ("-1 = remove (%s)", ourname);
d1077 1
a1077 2
  syscall_printf ("%d = read (%d, %p, %d), errno %d", res, fd, ptr, len,
		  get_errno ());
d1121 1
a1121 2
  syscall_printf ("%d = readv (%d, %p, %d), errno %d", res, fd, iov, iovcnt,
		  get_errno ());
d1138 1
a1138 2
  syscall_printf ("%d = pread (%d, %p, %d, %d), errno %d",
		  res, fd, ptr, len, off, get_errno ());
d1173 1
a1173 2
    paranoid_printf ("%d = write (%d, %p, %d), errno %d",
		     res, fd, ptr, len, get_errno ());
d1175 1
a1175 2
    syscall_printf ("%d = write (%d, %p, %d), errno %d",
		    res, fd, ptr, len, get_errno ());
d1221 1
a1221 2
    paranoid_printf ("%d = writev (%d, %p, %d), errno %d",
		     res, fd, iov, iovcnt, get_errno ());
d1223 1
a1223 2
    syscall_printf ("%d = writev (%d, %p, %d), errno %d",
		    res, fd, iov, iovcnt, get_errno ());
d1241 1
a1241 2
  syscall_printf ("%d = pwrite (%d, %p, %d, %d), errno %d",
		  res, fd, ptr, len, off, get_errno ());
d1323 1
a1323 1
  syscall_printf ("%d = open (%s, %p)", res, unix_path, flags);
d1382 1
a1382 1
  syscall_printf ("%d = close (%d)", res, fd);
d1399 1
a1399 1
  syscall_printf ("%d = isatty (%d)", res, fd);
d1428 1
a1428 1
  syscall_printf ("%d = link (%s, %s)", res, oldpath, newpath);
d1456 1
a1456 1
  syscall_printf ("%d = %schown (%s,...)",
d1499 1
a1499 1
  syscall_printf ("%d = fchown (%s,...)", res, cfd->get_name ());
d1548 1
a1548 1
  syscall_printf ("%d = chmod (%s, %p)", res, path, mode);
d1608 1
a1608 1
  syscall_printf ("%d = fstat (%d, %p)", res, fd, buf);
d1759 1
a1759 1
  syscall_printf ("%d = (%S, %p)", res, pc.get_nt_native_path (), buf);
d2392 1
a2392 1
  syscall_printf ("%d = rename (%s, %s)", res, oldpath, newpath);
d2669 1
a2669 1
  syscall_printf ("%d = posix_fadvice (%d, %D, %D, %d)",
d2688 1
a2688 1
  syscall_printf ("%d = posix_fallocate (%d, %D, %D)", res, fd, offset, len);
d2701 1
a2701 1
  syscall_printf ("%d = ftruncate (%d, %D)", res, fd, length);
d2726 1
a2726 1
  syscall_printf ("%d = truncate (%s, %D)", res, pathname, length);
d2749 1
a2749 1
  syscall_printf ("%d = get_osfhandle (%d)", res, fd);
d2795 1
a2795 1
  syscall_printf ("%d = (%s, %p)", res, name, sfs);
d3397 1
a3397 2
  syscall_printf ("%d = chroot (%s)", ret ? get_errno () : 0,
				      newroot ? newroot : "NULL");
@


1.601
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d114 1
@


1.600
log
@* cygwin.din (ptsname_r): Export.
* fhandler.cc (fhandler_base::ptsname_r): Define.
* fhandler.h (fhandler_base::ptsname): Delete.
(fhandler_base::ptsname_r): Declare.
(fhandler_pty_master::ptsname_r): Declare.
* fhandler_tty.cc (fhandler_pty_master::ptsname): Delete.
(fhandler_pty_master::ptsname_r): New reentrant function derived from previous
ptsname.
* syscalls.cc (ptsname_r): Implement new function with functionality similar to
Linux.
(ptsname): Use ptsname_r () to fill out buf.
* include/cygwin/stdlib.h (ptsname_r): Declare.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 255 to reflect
export of ptsname_r.
* pinfo.cc (pinfo::wait): Return bool rather than int.
* pinfo.h (info::wait): Ditto.
(pinfo::reattach): Define !defined(_SIGPROC_H) case for consistency.
* sigproc.cc (child_info_spawn::reattach_children): Use correct dwProcessId
rather than pid when duplicating handle.
@
text
@d66 2
d111 1
a111 1
  if (!hExeced && cygheap->ctty)
d4159 2
a4160 2
      pid_t pid = spawn_guts ("/bin/sh", argv, cur_environ (), _P_NOWAIT,
			       __std[0], __std[1]);
@


1.599
log
@	* syscalls.cc (check_dir_not_empty): Check surplus directory entries
	by calling NtQueryAttributesFile.  Make STATUS_DIRECTORY_NOT_EMPTY
	return value dependent on its status code.  Add long comment to explain.
	(unlink_nt): Add comment to explain flaw in checking the sharing mode.
	Set status to STATUS_SUCCESS instead of 0.  Add a retry loop to setting
	the delete disposition and trying to move a directory to bin to
	workaround rare cases of lingering, already deleted subdirectory
	entries.  Add long comment to explain.
	(rename): Set status to STATUS_SUCCESS instead of 0.
@
text
@d2909 13
d2925 1
a2925 1
  return (char *) (cfd->ptsname ());
@


1.598
log
@	* syscalls.cc (unlink_nt): Fix a bug which overwrites the NT status
	value in case setting the delete disposition returns with
	STATUS_DIRECTORY_NOT_EMPTY.
@
text
@d519 1
a519 1
  while (pfni->NextEntryOffset)
d521 1
a521 1
      if (++cnt > 2)
d523 1
a523 1
	  if (strace.active ())
d526 2
d533 30
a562 2
	      debug_printf ("Directory %S not empty, found file <%S>",
			    pc.get_nt_native_path (), &fname);
d564 1
a564 1
	  return STATUS_DIRECTORY_NOT_EMPTY;
a565 1
      pfni = (PFILE_NAMES_INFORMATION) ((caddr_t) pfni + pfni->NextEntryOffset);
d567 3
d583 1
d644 10
a653 1
     we can go straight to setting the delete disposition flag. */
d718 1
a718 1
	  status = 0;
d730 1
a730 1
      status = 0;
d733 2
d742 1
a742 1
      if (strace.active () && status == STATUS_DIRECTORY_NOT_EMPTY)
d744 1
a744 1
	  NTSTATUS status2;
d746 60
a805 7
	  pc.get_object_attr (attr, sec_none_nih);
	  NtClose (fh);
	  status2 = NtOpenFile (&fh, access | FILE_LIST_DIRECTORY | SYNCHRONIZE,
				&attr, &io, FILE_SHARE_VALID_FLAGS,
				flags | FILE_SYNCHRONOUS_IO_NONALERT);
	  if (NT_SUCCESS (status2))
	    check_dir_not_empty (fh, pc);
d825 2
a826 2
      if (status == STATUS_CANNOT_DELETE
	  && (!pc.isremote () || pc.fs_is_ncfsd ()))
d1935 1
a1935 1
  NTSTATUS status = 0;
@


1.597
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Check invalid
	success only on Samba shares.
	* mount.cc (fs_info::update): Drop has_buggy_basic_info flag for
	NcFsd.
	* syscalls.cc (unlink_nt): Fix typo in comment.
@
text
@d698 1
a698 1
      if (status == STATUS_DIRECTORY_NOT_EMPTY)
d700 2
d704 4
a707 4
	  status = NtOpenFile (&fh, access | FILE_LIST_DIRECTORY | SYNCHRONIZE,
			       &attr, &io, FILE_SHARE_VALID_FLAGS,
			       flags | FILE_SYNCHRONOUS_IO_NONALERT);
	  if (NT_SUCCESS (status))
d713 1
a713 1
			    "status = %p", pc.get_nt_native_path (), status);
@


1.596
log
@	* globals.cc (ro_u_ncfsd): New R/O unicode string.
	* mount.cc (fs_info::update): Check for "NcFsd" FS.  Set flags and
	change comments accordingly.
	(fs_names): Add entry for NcFsd FS.
	* mount.h (enum fs_info_type): Add ncfsd.
	(class fs_info): Add ncfsd flag and accessor methods.
	* path.h (class path_conv): Add fs_is_ncfsd method.
	* syscalls.cc (unlink_nt): Experimentally try delete-on-close on NcFsd
	in STATUS_CANNOT_DELETE case.
@
text
@d648 1
a648 1
	     not, we bail out with ERROR_DIR_NOT_EMTPY.  The below code
@


1.595
log
@	* syscalls.cc (try_to_bin): Improve debug output.
	(check_dir_not_empty): Take additional path_conv argument.  Improve
	debug output.  Change syscall_printf to debug_printf.
	(unlink_nt): Improve debug output.  Change syscall_printf to
	debug_printf.
	(unlink): Change syscall_printf to debug_printf.

	* cygthread.h: Fix copyright dates.
@
text
@d726 2
a727 1
      if (status == STATUS_CANNOT_DELETE && !pc.isremote ())
@


1.594
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d235 2
a236 2
      debug_printf ("NtQueryInformationFile (FileNameInformation) failed, %08x",
		    status);
d280 1
a280 1
	  debug_printf ("NtOpenFile (%S) failed, %08x", &root, status);
d323 2
a324 2
      debug_printf ("NtQueryInformationFile (FileInternalInformation) failed, "
		    "%08x", status);
d346 2
a347 1
	  debug_printf ("NtOpenFile (%S) failed, %08x", &recycler, status);
d368 2
a369 1
	  debug_printf ("NtCreateFile (%S) failed, %08x", &recycler, status);
d386 1
a386 1
	      debug_printf ("NtCreateFile (%S) failed, %08x",
d405 2
a406 1
	    debug_printf ("NtCreateFile (%S) failed, %08x", &recycler, status);
d412 2
a413 1
		debug_printf ("NtWriteFile (%S) failed, %08x", &fname, status);
d426 1
a426 1
		  debug_printf ("NtCreateFile (%S) failed, %08x",
d433 1
a433 1
		    debug_printf ("NtWriteFile (%S) failed, %08x",
d492 1
a492 2
    debug_printf ("Overwriting with another file failed, status = %p",
		  status);
d497 1
d502 1
a502 1
check_dir_not_empty (HANDLE dir)
d514 2
a515 2
      syscall_printf ("Checking if directory is empty failed, "
		      "status = %p", status);
d523 11
a533 1
	  syscall_printf ("Directory not empty");
d536 1
a536 2
      pfni = (PFILE_NAMES_INFORMATION)
	     ((caddr_t) pfni + pfni->NextEntryOffset);
d554 2
d584 8
a591 2
	  NtSetAttributesFile (fh_ro, pc.file_attributes ()
				      & ~FILE_ATTRIBUTE_READONLY);
d594 3
d632 2
d658 1
a658 1
	      status = check_dir_not_empty (fh);
d675 1
a675 1
	  syscall_printf ("Delete already pending");
d679 2
a680 1
      syscall_printf ("Opening file for delete failed, status = %p", status);
d696 18
a713 2
      syscall_printf ("Setting delete disposition failed, status = %p",
		      status);
d730 2
d741 2
a742 2
	      syscall_printf ("Setting delete-on-close failed, status = %p",
			      status);
d788 1
d816 1
a816 1
      syscall_printf ("unlinking a nonexistent file");
d822 1
a822 1
      syscall_printf ("unlinking a directory");
@


1.593
log
@* cygwin.din: Remove some _tc* exports.  Add tcgetsid().
* dtable.cc (fh_alloc): Revert ill-advised setting of major/minor.  Use new
is_dev_tty to remember that this device was opened as /dev/tty.
* fhandler.cc (fhandler_base::fstat): Remove leftover debugging statement.
(fhandler_base::tcgetsid): New function.
* fhandler.h ((fhandler_base::tcgetsid): Declare new function.
(fhandler_base::is_dev_tty): Ditto.
(fhandler_termios::opened_as_dev_tty): Declare new field.
(fhandler_termios::is_dev_tty): Declare new function.
(fhandler_termios::tcgetsid): Ditto.
(fhandler_pty_common::use_archetype): Move here from subclass.
(fhandler_pty_slave::use_archetype): Move up.
(fhandler_pty_master::use_archetype): Ditto.
* fhandler_console.cc (fhandler_console::ioctl): Rename second argument from
`buf' to `arg' for consistency.  Call ioctl_termios for common fhandler_termios
ioctl handling.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call ioctl_termios for common
fhandler_termios ioctl handling.
(fhandler_pty_master::ioctl): Ditto.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Implement new function.
(fhandler_termios::ioctl_termios): Ditto.  Implements TIOCSCTTY handling.
* syscalls.cc (stat_worker): Set /dev/tty device info when appropriate.
* termios.cc (tcgetpgrp): Avoid extraneous "isatty" check.
(tcgetsid): Implement new function.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 253.
* include/sys/termios.h (TIOCSCTTY): Define.
@
text
@d1137 10
a1146 6
	  if (0 && fd > 2)
	    flags |= O_NOCTTY;
	  if (!(fh = build_fh_name (unix_path,
				    (flags & (O_NOFOLLOW | O_EXCL))
				    ?  PC_SYM_NOFOLLOW : PC_SYM_FOLLOW,
				    stat_suffixes)))
d1607 1
a1607 1
	    buf->st_dev = fh->is_dev_tty () ? FH_TTY : fh->get_device ();
a1609 1
debug_printf ("is_dev_tty %d, st_dev %p\n", fh->is_dev_tty (), buf->st_dev);
d1626 2
a1627 1
  path_conv pc (name, PC_SYM_FOLLOW | PC_POSIX | PC_KEEP_HANDLE, stat_suffixes);
@


1.592
log
@* syscalls.cc (open): Add temporary kludge to avoid assigning the controlling
tty on open unless the open is for stdin/stdout/stderr.
* tty.cc (tty_list::connect): Set ENXIO when can't find a tty.
@
text
@d1137 1
a1137 1
	  if (fd > 2)
d1603 1
a1603 1
	    buf->st_dev = fh->get_device ();
d1606 1
@


1.591
log
@	* syscalls.cc (faccessat): Fix parens in flag expression when calling
	build_fh_name.

	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Fix typo in
	comment.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
@
text
@d1133 6
@


1.590
log
@	* fhandler_disk_file.cc (__DIR_mounts::eval_ino): Create path_conv
	with PC_KEEP_HANDLE flag.
	* path.h (path_conv::operator =): Duplicate UNICODE path as well.
	* security.cc (check_file_access): Use path_conv handle if available.
	* syscalls.cc (access): Create fhandler with PC_KEEP_HANDLE flag set.
	(euidaccess): Ditto.
	(faccessat): Ditto.
@
text
@d4156 4
a4159 4
	  fhandler_base *fh = build_fh_name (path,
					     PC_KEEP_HANDLE |
					     (flags & AT_SYMLINK_NOFOLLOW)
					     ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW,
d4163 1
a4163 1
	      res =  fh->fhaccess (mode, flags & AT_EACCESS);
@


1.589
log
@whitespace elimination
@
text
@d1680 2
a1681 1
      fhandler_base *fh = build_fh_name (fn, PC_SYM_FOLLOW, stat_suffixes);
d1704 2
a1705 1
      fhandler_base *fh = build_fh_name (fn, PC_SYM_FOLLOW, stat_suffixes);
d4157 1
@


1.588
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d560 1
a560 1
         link to file" operation behind a transaction. */
d572 1
a572 1
      	}
d601 1
a601 1
         NFS implements its own mechanism to remove in-use files which
d714 1
a714 1
      	{
d1550 1
a1550 1
                                     alloca (640);
d1554 1
a1554 1
                                             &context, NULL)))
d1820 1
a1820 1
        *p-- = '\0';
d1823 7
a1829 7
        {
          /* The root directory cannot be renamed.  This also rejects
             the corner case of rename("/","/"), even though it is the
             same file.  */
          set_errno (EINVAL);
          goto out;
        }
d1877 1
a1877 1
        *p-- = '\0';
d1880 4
a1883 4
        {
          set_errno (ENOTEMPTY);
          goto out;
        }
d1898 1
a1898 1
                             ? newpc.isdir () : oldpc.isdir ()))
d2847 1
a2847 1
                       CW_TOKEN_RESTRICTED);
d2851 1
a2851 1
                       CW_TOKEN_RESTRICTED);
@


1.587
log
@	* fhandler_proc.cc (format_proc_uptime): Don't call GetSystemInfo.
	Fetch CPU count from wincap.
	(format_proc_stat): Ditto.
	* globals.cc (system_info): Move to wincap.
	* heap.cc (heap_init): Fetch page size from wincap.
	* syscalls.cc (getpagesize): Fetch allocation granularity from wincap.
	(getsystempagesize): Fetch page size from wincap.
	* wincap.cc (wincap_2003): Default is_server to false.
	(wincapc::init): Call GetSystemInfo here.  Always set is_server value.
	* wincap.h (class wincapc): Add system_info as private member.
	(wincapc::cpu_count): New public method.
	(wincapc::page_size): Ditto.
	(wincapc::allocation_granularity): Ditto.
@
text
@d1372 1
a1372 1
  return mknod_worker (pc.get_win32 (), pc.dev.mode & S_IFMT, mode, pc.dev.major, pc.dev.minor);
a2372 1
  static NO_COPY char buf[16];
d2374 3
a2376 3
    str = buf;
  if (!real_tty_attached (myself))
    strcpy (str, "/dev/conin");
d2378 5
a2382 1
    __small_sprintf (str, "/dev/tty%d", myself->ctty);
@


1.586
log
@	* fhandler.h (fhandler_socket::read): Declare.
	(fhandler_socket::write): Declare.
	* fhandler_procsys.cc (fhandler_procsys::read): Add FIXME comment.
	(fhandler_procsys::write): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): New method.
	(fhandler_socket::write): New method.
	* syscalls.cc: Rearrange order of read/write functions.
	(read): Call fhandler read method directly instead of just readv.
	(readv): Remove EINTR loop.  This is done in all affected fhandler's
	now.
	(write): Call fhandler write method directly instead of just writev.
	Fix debug output.
@
text
@d2290 1
a2290 3
  if (!system_info.dwAllocationGranularity)
    GetSystemInfo (&system_info);
  return (size_t) system_info.dwAllocationGranularity;
d2296 1
a2296 3
  if (!system_info.dwPageSize)
    GetSystemInfo (&system_info);
  return (size_t) system_info.dwPageSize;
@


1.585
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d901 13
a913 1
  const iovec iov =
d915 11
a925 3
      iov_base: ptr,
      iov_len: len
    };
d927 5
a931 1
  return readv (fd, &iov, 1);
d937 1
a937 1
pread (int fd, void *ptr, size_t len, _off64_t off)
d941 7
a947 1
  ssize_t res;
d950 21
a970 3
    res = -1;
  else
    res = cfd->pread (ptr, len, off);
d972 4
a975 2
  syscall_printf ("%d = pread (%d, %p, %d, %d), errno %d",
		  res, fd, ptr, len, off, get_errno ());
d980 1
a980 1
pwrite (int fd, void *ptr, size_t len, _off64_t off)
d989 1
a989 1
    res = cfd->pwrite (ptr, len, off);
d991 1
a991 1
  syscall_printf ("%d = pwrite (%d, %p, %d, %d), errno %d",
a998 14
  const struct iovec iov =
    {
      iov_base: (void *) ptr,	// const_cast
      iov_len: len
    };

  return writev (fd, &iov, 1);
}

EXPORT_ALIAS (write, _write)

extern "C" ssize_t
readv (int fd, const struct iovec *const iov, const int iovcnt)
{
d1005 1
a1005 3
  ssize_t res = -1;
  const int e = get_errno ();
  const ssize_t tot = check_iovec_for_read (iov, iovcnt);
d1011 1
a1011 7
  if (tot <= 0)
    {
      res = tot;
      goto done;
    }

  if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
d1018 4
a1021 4
  extern int sigcatchers;
  syscall_printf ("readv (%d, %p, %d) %sblocking, sigcatchers %d",
		  fd, iov, iovcnt, cfd->is_nonblocking () ? "non" : "",
		  sigcatchers);
d1023 1
a1023 7
  while (1)
    {
      res = cfd->readv (iov, iovcnt, tot);
      if (res >= 0 || get_errno () != EINTR || !_my_tls.call_signal_handler ())
	break;
      set_errno (e);
    }
d1026 7
a1032 2
  syscall_printf ("%d = readv (%d, %p, %d), errno %d", res, fd, iov, iovcnt,
		  get_errno ());
d1037 2
d1077 1
a1077 1
    paranoid_printf ("%d = write (%d, %p, %d), errno %d",
d1080 1
a1080 1
    syscall_printf ("%d = write (%d, %p, %d), errno %d",
d1087 17
@


1.584
log
@	* pinfo.h (class push_process_state): New class to push a process state
	flag temporarily into myself->process_state.
	* fhandler_console.cc (fhandler_console::read): Add push_process_state
	handler.
	(fhandler_console::write): Call bg_check from here.  Add
	push_process_state handler.
	* fhandler_tty.cc (fhandler_tty_slave::write): Ditto.
	(fhandler_tty_slave::read): Ditto.
	(fhandler_pty_master::write): Ditto.
	(fhandler_pty_master::read): Ditto.
	* syscalls.cc (readv): Remove bg_check call and setting process state.
	(writev): Ditto.
@
text
@d104 1
a104 1
	fh->close ();
d604 1
a604 1
	 
d724 1
a724 1
	     
d1110 2
a1111 1
	  else if (fh->is_fs_special () && fh->device_access_denied (flags))
d1118 4
a1121 12
	      fh->close_on_exec (flags & O_CLOEXEC);
	      if (!fh->open (flags, (mode & 07777) & ~cygheap->umask))
		{
		  delete fh;
		  res = -1;
		}
	      else
		{
		  cygheap->fdtab[fd] = fh;
		  if ((res = fd) <= 2)
		    set_std_handle (res);
		}
d1181 1
a1181 1
      res = cfd->close ();
d1970 1
a1970 1
	      && !nt_path_has_executable_suffix (newpc.get_nt_native_path ()))	
d2036 1
a2036 1
	     
@


1.583
log
@	* syscalls.cc (readv): Add myfault handler.  Don't check repeatedly
	open state of file handler.  Streamline loop.
	(writev): Add myfault handler.
@
text
@d997 1
a997 11
      /* Check to see if this is a background read from a "tty",
	 sending a SIGTTIN, if appropriate */
      res = cfd->bg_check (SIGTTIN);

      if (res > bg_eof)
	{
	  myself->process_state |= PID_TTYIN;
	  res = cfd->readv (iov, iovcnt, tot);
	  myself->process_state &= ~PID_TTYIN;
	}

d1044 1
a1044 8
  res = cfd->bg_check (SIGTTOU);

  if (res > (int) bg_eof)
    {
      myself->process_state |= PID_TTYOU;
      res = cfd->writev (iov, iovcnt, tot);
      myself->process_state &= ~PID_TTYOU;
    }
@


1.582
log
@	* fhandler.h (class fhandler_base): Remove uninterruptible_io status
	flag.
	(fhandler_base::ready_for_read): Remove declaration.
	(fhandler_socket::ready_for_read): Ditto.
	(fhandler_pipe::ready_for_read): Ditto.
	(fhandler_tty_master::is_slow): Remove.
	* fhandler_console.cc (fhandler_console::open): Drop setting
	uninterruptible_io.
	* fhandler_serial.cc (fhandler_serial::open): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Ditto.
	(fhandler_tty_master::init_console): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
	(fhandler_pipe::open): Ditto.
	(_pipe): Ditto.
	* select.cc (fhandler_pipe::ready_for_read): Remove.
	(fhandler_base::ready_for_read): Remove.
	* syscalls.cc (readv): Drop unneeded wait variable.  Remove entire test
	which might lead to calling ready_for_read.  Remove now unused label
	out.
@
text
@d965 3
a967 2
  extern int sigcatchers;
  const int e = get_errno ();
d970 2
d973 3
a975 1
  const ssize_t tot = check_iovec_for_read (iov, iovcnt);
d983 1
a983 1
  while (1)
d985 3
a987 3
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	break;
d989 5
a993 16
      if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
	{
	  set_errno (EBADF);
	  break;
	}

      /* Could block, so let user know we at least got here.  */
      syscall_printf ("readv (%d, %p, %d) %sblocking, sigcatchers %d",
		      fd, iov, iovcnt, cfd->is_nonblocking () ? "non" : "",
		      sigcatchers);

      /* FIXME: This is not thread safe.  We need some method to
	 ensure that an fd, closed in another thread, aborts I/O
	 operations. */
      if (!cfd.isopen ())
	break;
d995 2
a1000 6
      if (!cfd.isopen ())
	{
	  res = -1;
	  break;
	}

a1003 5
	  if (!cfd.isopen ())
	    {
	      res = -1;
	      break;
	    }
d1025 4
@


1.581
log
@	* fcntl.cc (fcntl64): Call pthread_testcancel.
	* fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* flock.cc (lf_setlock): Allow to cancel thread running blocking
	file lock.  Try to make code more readable.
	(lockf): Call pthread_testcancel.
	* mmap.cc (msync): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Call pthread::static_cancel_self
	rather than pthread_testcancel.
	* select.cc (cygwin_select): Call pthread_testcancel.
	* syscalls.cc (pread): Ditto.
	(pwrite): Ditto.
	(readv): Ditto.
	(writev): Ditto.
	(open): Ditto.
	(close): Ditto.
	(fsync): Ditto.
	* termios.cc (tcdrain): Ditto.
	* thread.cc: Align list of cancellation points with above changes.
	Mark not-implemented functions, too.
	(cancelable_wait): Don't set unused object indices to WAIT_FAILED
	since that could result in wrong behaviour.  Set them to the invalid
	value WAIT_TIMEOUT + 1 instead.
@
text
@a989 2
      DWORD wait = cfd->is_nonblocking () ? 0 : INFINITE;

d992 2
a993 9
		      fd, iov, iovcnt, wait ? "" : "non", sigcatchers);

      if (wait && (!cfd->is_slow () || cfd->uninterruptible_io ()))
	/* no need to call ready_for_read */;
      else if (!cfd->ready_for_read (fd, wait))
	{
	  res = -1;
	  goto out;
	}
a1022 1
    out:
@


1.580
log
@	* advapi32.cc (GetTokenInformation): Remove.
	(SetTokenInformation): Remove.
	* grp.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_auth.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d915 2
d932 2
d963 2
d1048 2
d1107 1
d1218 2
d1494 1
@


1.579
log
@	* Makefile.in (DLL_IMPORTS): Drop advapi32.dll.
	* autoload.cc: Enable autoloading advapi32 functions.
	* environ.cc (regopt): Use wide char arguments in reg_key functions.
	* fhandler_console.cc (beep): Ditto.  Use WCHAR throughout.
	* registry.cc (reg_key): Rewrite reg_key class to use native NT registry
	functions.  Use WCHAR string parameters throughout.  Use PCWSTR rather
	than const WCHAR.  Drop multibyte char functionality.  Drop unused
	methods.
	(get_registry_hive_path): Use RtlQueryRegistryValues to fetch path from
	registry.
	(load_registry_hive): Drop useless check for user hive being available.
	Load hive using NtLoadKey.
	* registry.h: Accommodate above changes.
	* sched.cc (sched_rr_get_interval): Use wide char arguments in reg_key
	functions.
	* shared.cc (init_installation_root): Ditto.
	(shared_info::init_obcaseinsensitive): Use RtlQueryRegistryValues to
	fetch obcaseinsensitive value.
	(shared_info::heap_slop_size): Use wide char arguments in reg_key
	functions.
	(shared_info::heap_chunk_size): Ditto.
	* syscalls.cc (gethostid): Ditto.
	* winsup.h (__WIDE): Define.
	(_WIDE): Define.
	* libc/minires-os-if.c (get_registry_dns_items): Don't fetch values
	from registry.  Just extract them from given UNICODE_STRING parameter.
	(get_registry_dns): Fetch all registry values at once using
	RtlQueryRegistryValues.
@
text
@d2964 2
d2974 5
a2978 3
      if (!SetTokenInformation (new_token, TokenOwner,
				&usersid, sizeof usersid))
	debug_printf ("SetTokenInformation(user.token, TokenOwner), %E");
d2980 5
a2984 3
      if (!SetTokenInformation (new_token, TokenPrimaryGroup,
				&groups.pgsid, sizeof (cygsid)))
	debug_printf ("SetTokenInformation(user.token, TokenPrimaryGroup), %E");
d2990 5
a2994 3
	  if (!SetTokenInformation (new_token, TokenDefaultDacl,
				    &tdacl, sizeof (tdacl)))
	    debug_printf ("SetTokenInformation (TokenDefaultDacl), %E");
d3106 1
d3122 10
a3131 7
      if (!SetTokenInformation (cygheap->user.primary_token (),
				TokenPrimaryGroup, &gsid, sizeof gsid))
	debug_printf ("SetTokenInformation(primary_token, "
		      "TokenPrimaryGroup), %E");
      if (!SetTokenInformation (cygheap->user.imp_token (), TokenPrimaryGroup,
				&gsid, sizeof gsid))
	debug_printf ("SetTokenInformation(token, TokenPrimaryGroup), %E");
d3134 5
a3138 2
  if (!SetTokenInformation (hProcToken, TokenPrimaryGroup, &gsid, sizeof gsid))
    debug_printf ("SetTokenInformation(hProcToken, TokenPrimaryGroup), %E");
@


1.578
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d3685 2
a3686 2
extern "C"
long gethostid (void)
d3769 5
a3773 3
  reg_key key (HKEY_LOCAL_MACHINE, KEY_READ, "SOFTWARE", "Microsoft",
	       "Windows NT", "CurrentVersion", NULL);
  key.get_string ("ProductId", (char *)&data[6], 24, "00000-000-0000000-00000");
@


1.577
log
@	* autoload.cc (FindFirstVolumeA): Remove.
	(FindNextVolumeA): Remove.
	(FindVolumeClose): Remove.
	(GetVolumeNameForVolumeMountPointA): Remove.
	* ntdll.h (NtFlushBuffersFile): Declare.
	* syscalls.cc (sync_worker): Rewrite using native NT functions.
	(sync): Ditto.
@
text
@d3774 1
a3774 4
  /* Contrary to MSDN, NT4 requires the second argument
     or a STATUS_ACCESS_VIOLATION is generated */
  ULARGE_INTEGER availb;
  GetDiskFreeSpaceEx ("C:\\", &availb, (PULARGE_INTEGER) &data[11], NULL);
@


1.576
log
@	* autoload.cc (UuidCreate): Remove.
	(UuidCreateSequential): Remove.
	* passwd.cc (internal_getpwsid): Avoid a strict-aliasing compiler
	error with gcc 4.5.1.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Ditto.
	* ntdll.h (NtAllocateUuids): Declare.
	* syscalls.cc (gethostid): Use NtAllocateUuids function rather than
	UuidCreateSequential/UuidCreate to get rid of rpcrt4 dependency.
@
text
@d39 1
a41 1
#include <rpc.h>
d1495 1
a1495 1
sync_worker (const char *vol)
d1497 12
a1508 3
  HANDLE fh = CreateFileA (vol, GENERIC_WRITE, FILE_SHARE_VALID_FLAGS,
			   &sec_none_nih, OPEN_EXISTING, 0, NULL);
  if (fh != INVALID_HANDLE_VALUE)
d1510 4
a1513 2
      FlushFileBuffers (fh);
      CloseHandle (fh);
a1514 2
  else
    debug_printf ("Open failed with %E");
d1521 4
a1524 2
  /* Per MSDN, 50 bytes should be enough here. */
  char vol[MAX_PATH];
d1526 5
a1530 1
  if (wincap.has_guid_volumes ()) /* Win2k and newer */
d1532 2
a1533 29
      char a_drive[MAX_PATH] = {0};
      char b_drive[MAX_PATH] = {0};

      if (is_floppy ("A:"))
	GetVolumeNameForVolumeMountPointA ("A:\\", a_drive, MAX_PATH);
      if (is_floppy ("B:"))
	GetVolumeNameForVolumeMountPointA ("B:\\", b_drive, MAX_PATH);

      HANDLE sh = FindFirstVolumeA (vol, MAX_PATH);
      if (sh != INVALID_HANDLE_VALUE)
	{
	  do
	    {
	      debug_printf ("Try volume %s", vol);

	      /* Check vol for being a floppy on A: or B:.  Skip them. */
	      if (strcasematch (vol, a_drive) || strcasematch (vol, b_drive))
		{
		  debug_printf ("Is floppy, don't sync");
		  continue;
		}

	      /* Eliminate trailing backslash. */
	      vol[strlen (vol) - 1] = '\0';
	      sync_worker (vol);
	    }
	  while (FindNextVolumeA (sh, vol, MAX_PATH));
	  FindVolumeClose (sh);
	}
d1535 14
a1548 21
  else
    {
      DWORD drives = GetLogicalDrives ();
      DWORD mask = 1;
      /* Skip floppies on A: and B: as in setmntent. */
      if ((drives & 1) && is_floppy ("A:"))
	drives &= ~1;
      if ((drives & 2) && is_floppy ("B:"))
	drives &= ~2;
      strcpy (vol, "\\\\.\\A:");
      do
	{
	  /* Geeh.  Try to sync only non-floppy drives. */
	  if (drives & mask)
	    {
	      debug_printf ("Try volume %s", vol);
	      sync_worker (vol);
	    }
	  vol[4]++;
	}
      while ((mask <<= 1) <= 1 << 25);
d1550 1
@


1.575
log
@	* dcrt0.cc: Fix copyright dates.
	* winsup.h: Ditto.
	* syscalls.cc (_read): Move EXPORT_ALIAS to its rightful place.
@
text
@d3763 11
a3773 5
  UUID Uuid;
  RPC_STATUS status = UuidCreateSequential (&Uuid);
  if (GetLastError () == ERROR_PROC_NOT_FOUND)
    status = UuidCreate (&Uuid);
  if (status == RPC_S_OK)
d3775 2
a3776 2
      data[4] = *(unsigned *)&Uuid.Data4[2];
      data[5] = *(unsigned short *)&Uuid.Data4[6];
d3779 4
a3782 3
      debug_printf ("MAC address of first Ethernet card: %02x:%02x:%02x:%02x:%02x:%02x",
		    Uuid.Data4[2], Uuid.Data4[3], Uuid.Data4[4],
		    Uuid.Data4[5], Uuid.Data4[6], Uuid.Data4[7]);
d3785 1
a3785 3
    {
      debug_printf ("no Ethernet card installed");
    }
@


1.575.2.1
log
@	* passwd.cc (internal_getpwsid): Avoid a strict-aliasing compiler
	error with gcc 4.5.1.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Ditto.
	* syscalls.cc (gethostid): Ditto.
@
text
@d3769 2
a3770 6
      unsigned *ud;

      ud = (unsigned *) &Uuid.Data4[2];
      data[4] = *ud;
      ud = (unsigned *) &Uuid.Data4[6];
      data[5] = *ud;
@


1.575.2.2
log
@	* autoload.cc (UuidCreate): Remove.
	(UuidCreateSequential): Remove.
	* ntdll.h (NtAllocateUuids): Declare.
	* syscalls.cc (gethostid): Use NtAllocateUuids function rather than
	UuidCreateSequential/UuidCreate to get rid of rpcrt4 dependency.
@
text
@d3763 12
a3774 14
  LARGE_INTEGER u1;
  ULONG u2, u3;
  union {
    UCHAR mac[6];
    struct {
      ULONG m1;
      USHORT m2;
    };
  } u4;
  NTSTATUS status = NtAllocateUuids (&u1, &u2, &u3, u4.mac);
  if (NT_SUCCESS (status))
    {
      data[4] = u4.m1;
      data[5] = u4.m2;
d3777 3
a3779 4
      debug_printf ("MAC address of first Ethernet card: "
		    "%02x:%02x:%02x:%02x:%02x:%02x",
		    u4.mac[0], u4.mac[1], u4.mac[2],
		    u4.mac[3], u4.mac[4], u4.mac[5]);
d3782 3
a3784 1
    debug_printf ("no Ethernet card installed");
@


1.574
log
@	* Throughout fix copyright dates.
@
text
@d910 2
a941 2
EXPORT_ALIAS (read, _read)

d3504 1
@


1.573
log
@	* syscalls.cc (utmp_data): Fix potential buffer overflow.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
@


1.572
log
@	* syscalls.cc (rename): Fix permission problem with symlinks on NFS.
	Rework how NtOpenFile gets called to make it more readable.  Change
	comment.
@
text
@d3511 1
a3511 1
  if (utix > nutdbuf) \
@


1.571
log
@	* syscalls.cc (check_dir_not_empty): Never count more than 3 directory
	entries.
@
text
@d2056 19
a2074 12
  /* DELETE is required to rename a file.  At least one cifs FS (Tru64) needs
     FILE_READ_ATTRIBUTE, otherwise the FileRenameInformation call fails with
     STATUS_ACCESS_DENIED.  Samba (only some versions?) doesn't like the
     FILE_SHARE_DELETE mode if the file has the R/O attribute set and returns
     STATUS_ACCESS_DENIED in that case. */
  status = NtOpenFile (&fh, DELETE | FILE_READ_ATTRIBUTES,
		     oldpc.get_object_attr (attr, sec_none_nih),
		     &io,
		     oldpc.fs_is_samba () ? FILE_SHARE_READ | FILE_SHARE_WRITE
					  : FILE_SHARE_VALID_FLAGS,
		     FILE_OPEN_FOR_BACKUP_INTENT
		     | (oldpc.is_rep_symlink () ? FILE_OPEN_REPARSE_POINT : 0));
@


1.570
log
@	* syscalls.cc (gethostid): Use correct path to ProductId registry value.
@
text
@d517 5
a523 6
      ++cnt;
    }
  if (cnt > 2)
    {
      syscall_printf ("Directory not empty");
      return STATUS_DIRECTORY_NOT_EMPTY;
@


1.569
log
@	* mount.h (class fs_info): Add has_buggy_reopen flag and accessor
	methods.
	* mount.cc (fs_info::update): Set has_buggy_reopen flag for NWFS.
	Add comment.
	* path.h (path_conv::get_object_attr) Make inline method.
	(path_conv::init_reopen_attr): New inline method.
	* path.cc (path_conv::get_object_attr): Remove.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use
	path_conv::init_reopen_attr method to initialize OBJECT_ATTRIBUTE for
	reopening file.
	(fhandler_disk_file::fchmod): Ditto.
	(fhandler_base::utimens_fs): Ditto.
	(fhandler_disk_file::rewinddir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
@
text
@d3775 2
a3776 1
  reg_key key (HKEY_LOCAL_MACHINE, KEY_READ, "SOFTWARE", "Microsoft", "Windows", "CurrentVersion", NULL);
@


1.568
log
@	* syscalls.cc (start_transaction): Make inline function.  Move up to be
	more generally available.
	(stop_transaction): Ditto.
	(unlink_nt): Potentially start transaction when trying to delete file
	with DOS R/O attribute set.  If file is .lnk symlink, check for number
	of hardlinks.  Add "out" label and only return via "out".  Rearrange
	reversion of DOS R/O attribute and, on success, only revert R/O
	attribute if file is .lnk symlink with more than one hardlink.  Add
	length comment to explain why.
@
text
@d572 1
a572 2
	  InitializeObjectAttributes (&attr, &ro_u_empty,
				      pc.objcaseinsensitive (), fh_ro, NULL);
d690 1
a690 1
	  InitializeObjectAttributes (&attr, &ro_u_empty, 0, fh, NULL);
@


1.567
log
@	* syscalls.cc (rename): Limit retry loop in case of sharing violation
	to about a second.
@
text
@d167 30
d536 3
d558 8
a565 1
      access |= FILE_WRITE_ATTRIBUTES;
d575 8
d640 1
a640 1
		  return status;
d652 2
a653 1
	  return 0;
d656 1
a656 1
      return status;
d662 4
a665 1
    return 0;
a666 1
  FILE_DISPOSITION_INFORMATION disp = { TRUE };
d715 20
a734 6
      /* Restore R/O attribute to accommodate hardlinks.  Don't try this
	 with directories!  For some reason the below NtSetInformationFile
	 changes the delete disposition back to FALSE, at least on XP. */
      if ((access & FILE_WRITE_ATTRIBUTES)
	  && (!NT_SUCCESS (status) || !pc.isdir ()))
	NtSetAttributesFile (fh, pc.file_attributes ());
d736 1
d738 7
a1733 30
static void
start_transaction (HANDLE &old_trans, HANDLE &trans)
{
  NTSTATUS status = NtCreateTransaction (&trans,
				SYNCHRONIZE | TRANSACTION_ALL_ACCESS,
				NULL, NULL, NULL, 0, 0, 0, NULL, NULL);
  if (NT_SUCCESS (status))
    {
      old_trans = RtlGetCurrentTransaction ();
      RtlSetCurrentTransaction (trans);
    }
  else
    {
      debug_printf ("NtCreateTransaction failed, %p", status);
      old_trans = trans = NULL;
    }
}

static NTSTATUS
stop_transaction (NTSTATUS status, HANDLE old_trans, HANDLE trans)
{
  RtlSetCurrentTransaction (old_trans);
  if (NT_SUCCESS (status))
    status = NtCommitTransaction (trans, TRUE);
  else
    status = NtRollbackTransaction (trans, TRUE);
  NtClose (trans);
  return status;
}

@


1.566
log
@	* syscalls.cc (fstatat): Call stat_worker directly from here.
@
text
@d2012 2
d2031 1
a2031 1
	  && WaitForSingleObject (signal_arrived, 0) != WAIT_OBJECT_0)
d2041 7
a2047 3
	     sharing violation goes away, or a signal arrived. */
	  yield ();
	  goto retry;
@


1.565
log
@	* syscalls.cc (rename): Open file with FILE_READ_ATTRIBUTES.
@
text
@d4156 4
a4159 1
  return (flags & AT_SYMLINK_NOFOLLOW) ? lstat64 (path, st) : stat64 (path, st);
@


1.564
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Revert usage
	of get_stat_handle () to get_handle ().  Add comment to explain why.
	* syscalls.cc (statvfs): Drop using PC_KEEP_HANDLE.
@
text
@d2013 7
a2019 4
  /* DELETE is required to rename a file.  Samba (only some versions?) doesn't
     like the FILE_SHARE_DELETE mode if the file has the R/O attribute set
     and returns STATUS_ACCESS_DENIED in that case. */
  status = NtOpenFile (&fh, DELETE, oldpc.get_object_attr (attr, sec_none_nih),
@


1.563
log
@	* syscalls.cc (rename): Fix renaming file-based devices.
@
text
@d2571 1
a2571 2
  if (!(fh = build_fh_name (name, PC_SYM_FOLLOW | PC_KEEP_HANDLE,
			    stat_suffixes)))
@


1.562
log
@	* syscalls.cc (unlink_nt): Disable try_to_bin for netapp drives.
	Explain why.
@
text
@d1807 1
a1807 1
  if (oldpc.isspecial () && !oldpc.issocket ()) /* No renames from virtual FS */
d1809 1
d1934 1
a1934 1
      else if (oldpc.is_lnk_symlink ()
d1962 1
a1962 1
      else if (oldpc.is_lnk_symlink ())
d1964 1
a1964 1
	  if (!newpc.is_lnk_symlink ()
d1996 1
a1996 1
	      if (new2pc.is_binary () || new2pc.is_lnk_symlink ())
@


1.561
log
@	* dtable.cc (dtable::dup_worker): Reset path_conv handle in duplicated
	fhandler.
	* fhandler.cc (fhandler_base::fstatvfs): Keep handle in created
	path_conv.
	* fhandler.h (fhandler_base::get_stat_access): New method.
	(fhandler_base::get_stat_handle): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use handle
	returned by get_stat_handle.  Only request inode from system if it
	isn't already set in the fhandler, and only for filesystems supporting
	them.
	(fhandler_base::fstat_fs): Use handle returned by get_stat_handle.
	Change the way open_fs is called.  Explain why.
	(fhandler_base::fstat_helper): Use handle returned by get_stat_handle.
	Never use 0 inode number.  Simplify executable recognition by re-using
	get_stat_handle if file could be opened with sufficient rights.
	(fhandler_disk_file::fstatvfs): Use handle returned by get_stat_handle.
	(fhandler_disk_file::facl): Use handle returned by get_stat_handle in
	GETACL and GETACLCNT cases.
	(fhandler_disk_file::link): Use handle returned by get_stat_handle
	instead of opening file here again.  Add comment.
	(readdir_get_ino): Keep handle in created path_conv and drop
	opening file.
	* ntdll.h (wait_pending): New helper function.
	* path.cc (symlink_info::check): Drop unused 'opt' parameter from
	declaration.  Add path_conv_handle argument.
	(path_conv::check): Make sure conv_handle is closed.  Keep
	PC_KEEP_HANDLE flag in pflags_or.  Accommodate call to sym.check to
	new args.
	(path_conv::~path_conv): Close conv_handle.
	(symlink_info::check_shortcut): Don't re-open file here, just use
	incoming handle.  Drop goto's and label out.
	(symlink_info::check_sysfile): Don't re-open file here, just use
	incoming handle.  Keep track of file position to accommodate the fact
	that file has been opened asynchronously in calling function.
	(symlink_info::check_nfs_symlink): Don't re-open file here, just use
	incoming handle.
	(symlink_info::check): Drop unused 'opt' parameter.  Add
	path_conv_handle argument.  Always try to open file with GENERIC_READ
	rights first to allow reading file content w/o having to re-open the
	file.  Drop back to READ_CONTROL | FILE_READ_ATTRIBUTES otherwise.
	Call symlink test functions (except for check_reparse_point) only if
	file could be opened with GENERIC_READ.  Keep file handle open if
	PC_KEEP_HANDLE is set in pflags.
	* path.h (enum pathconv_arg): Add PC_KEEP_HANDLE flag.
	(class path_conv_handle): New class.
	(class path_conv): Add conv_handle member.
	(path_conv::operator =): Duplicate conv_handle.
	(path_conv::handle): New method.
	(path_conv::access): New method.
	(path_conv::reset_conv_handle): New method.
	(path_conv::close_conv_handle): New method.
@
text
@d557 6
a562 2
	 That's why we don't call try_to_bin on NFS. */
      if (!pc.fs_is_nfs ())
@


1.560
log
@	* syscalls.cc (rename): On STATUS_ACCESS_VIOLATION, retry to open
	for DELETE until the STATUS_ACCESS_VIOLATION goes away.  Add comment
	to explain why.
@
text
@d1172 2
a1173 1
  if (!(fh = build_fh_name (oldpath, PC_SYM_NOFOLLOW, stat_suffixes)))
d1546 1
a1546 1
  path_conv pc (name, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
d1585 2
a1586 1
  path_conv pc (name, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
d2566 2
a2567 1
  if (!(fh = build_fh_name (name, PC_SYM_FOLLOW, stat_suffixes)))
@


1.559
log
@* fhandler.h (fhandler_base::has_ongoing_io): Declare virtual method.
* select.cc (peek_pipe): Reorganize slightly.  Don't attempt to check a handle
if it has ongoing I/O.
(select_pipe_info::select_pipe_info): Delete definition.
(select_pipe_info::~select_pipe_info): Delete definition.
(thread_pipe): Get rid of WFMO call.  Reorganize loop.
(pipe_cleanup): Remove dependence on destructor.
(thread_serial): Reorganize loop.
* select.h (select_pipe_info): Empty this class since it no longer has any
special requirements (for now).
* syscalls.cc (readv): Remove an unneeded debug printf.
@
text
@d2005 1
d2017 16
@


1.558
log
@	* syscalls.cc (open): Remove call to sig_dispatch_pending.
@
text
@d916 1
a916 1
	debug_printf ("no need to call ready_for_read");
@


1.557
log
@* shared_info.h (user_info): Add dll_crt0_1 as a friend.
(user_info::version): Make LONG to accommodate spinlock use.
(user_info::create): New static function renamed from user_info_create.
(user_info::initialize): New private function renamed from
user_info_initialize.
(SHARED_VERSION): Delete.
(SHARED_VERSION_MAGIC): Ditto.
(USER_VERSION_MAGIC): Ditto.
(SHARED_INFO_CB): Ditto.
(USER_VERSION): Ditto.
(USER_VERSION_MAGIC): Ditto.
(CURR_SHARED_MAGIC): Update.
(CURR_USER_MAGIC): Ditto.
(shared_info::version): Make LONG to accommodate spinlock use.
(shared_info::create): New static function mirroring user_info::create.
(dll_crt0_1): Accommodate change to user_info::initialize.
* spinlock.h (spinlock::setto): New variable member.
(spinlock::done): New function.
(spinlock::spinlock): Generalize to allow arbitrary values and timeouts.  Call
done() when lock is not needed.
* ntdll.h: Make multiple-inclusion safe.
(NtQuerySystemTime): Declare.
* shared.cc (installation_root_inited): Rename from shared_mem_inited.
(init_installation_root): Make inline.  Use a spinlock to ensure that this is
initialized only once per session.
(user_info::initialize): Rename from user_shared_initialize.  Protect with
spinlock on sversion and remove other spinlock-like things.  Remove reference
to user_shared since it is now implicit.  Refer to spinlock version of
multiple_cygwin_problem to ensure that any spinlock is released.
(user_info::create): Rename from user_shared_create.  Accommodate change from
user_shared_initialize to user_info::initialize.
(shared_info::create): New inline function.
(shared_info::initialize): Protect with spinlock on sversion.  Move heap_init
back under specific control of shared_info spinlock.  Remove reference to
SHARED_INFO_CB and just use sizeof(*this).
(memory_init): Move all locking into respective functions where it is needed.
Accommodate name changes.  Remove call to heap_init().
* syscalls.cc (seteuid32): Accommodate name change to user_info::create().
* mount.cc (mount_info::create_root_entry): Report on errors from add_item
since they should be nonexistent.
(mount_info::init): Don't initialize nmounts.  It should already be zero.  Give
more verbose error when root_idx < 0.  Implicitly use this pointer rather than
explicitly referencing mount_table->.
(mount_info::add_item): Minor whitespace fix.
@
text
@a1021 1
  sig_dispatch_pending ();
@


1.556
log
@	* syscalls.cc (nt_path_has_executable_suffix): Change storage class of
	blessed_executable_suffixes to static.
	(rename): Revert meaning of old_explicit_suffix.  Change the rules
	for appending a .exe suffix and (yikes!) document them.
@
text
@d2968 1
a2968 1
    user_shared_create (true);
@


1.555
log
@	* nlsfuncs.cc (check_codepage): Move from syscalls.cc here.
	(internal_setlocale): Ditto.
	(initial_setlocale): Ditto.
	(setlocale): Ditto.
	* strfuncs.cc (__sjis_wctomb): Revert previous patch.
	(__sjis_mbtowc): Ditto.
	* syscalls.cc: Move setlocale-related functions to nlsfuncs.cc.
@
text
@d1691 1
a1691 1
  const PUNICODE_STRING blessed_executable_suffixes[] =
d1823 1
a1823 1
  if ((oldpc.known_suffix
a1825 1
      || nt_path_has_executable_suffix (oldpc.get_nt_native_path ()))
d1933 1
d1935 6
a1940 2
	/* To rename an executable foo.exe to bar-without-suffix, the
	   .exe suffix must be given explicitly in oldpath. */
d1968 7
a1974 2
	  /* Never append .exe suffix if file has any suffix already. */
	  if (!nt_path_has_executable_suffix (newpc.get_nt_native_path ()))
@


1.554
log
@	* syscalls.cc (internal_setlocale): Use UTF-8 internally if external
	charset is ASCII.
@
text
@d27 1
a27 1
#include "winnls.h"
a38 2
#include <locale.h>
#include <wchar.h>
a4292 107

static char *
check_codepage (char *ret)
{
  if (!wincap.has_always_all_codepages ())
    {
      /* Prior to Windows Vista, many codepages are not installed by
	 default, or can be deinstalled.  The following codepages require
	 that the respective conversion tables are installed into the OS.
	 So we check if they are installed and if not, setlocale should
	 fail. */
      CPINFO cpi;
      UINT cp = 0;
      if (__mbtowc == __sjis_mbtowc)
	cp = 932;
      else if (__mbtowc == __eucjp_mbtowc)
	cp = 20932;
      else if (__mbtowc == __gbk_mbtowc)
	cp = 936;
      else if (__mbtowc == __kr_mbtowc)
	cp = 949;
      else if (__mbtowc == __big5_mbtowc)
	cp = 950;
      if (cp && !GetCPInfo (cp, &cpi)
	  && GetLastError () == ERROR_INVALID_PARAMETER)
	return NULL;
    }
  return ret;
}

static void
internal_setlocale ()
{
  /* Each setlocale from the environment potentially changes the
     multibyte representation of the CWD.  Therefore we have to
     reevaluate the CWD's posix path and store in the new charset.
     Same for the PATH environment variable. */
  /* FIXME: Other buffered paths might be affected as well. */
  /* FIXME: It could be necessary to convert the entire environment,
	    not just PATH. */
  tmp_pathbuf tp;
  char *path = getenv ("PATH");
  wchar_t *w_path = NULL, *w_cwd;

  debug_printf ("Cygwin charset changed from %s to %s",
		cygheap->locale.charset, __locale_charset ());
  /* Fetch PATH and CWD and convert to wchar_t in previous charset. */
  if (path && *path)	/* $PATH can be potentially unset. */
    {
      w_path = tp.w_get ();
      sys_mbstowcs (w_path, 32768, path);
    }
  w_cwd = tp.w_get ();
  cwdstuff::cwd_lock.acquire ();
  sys_mbstowcs (w_cwd, 32768, cygheap->cwd.get_posix ());
  /* Set charset for internal conversion functions. */
  if (*__locale_charset () == 'A'/*SCII*/)
    {
      cygheap->locale.mbtowc = __utf8_mbtowc;
      cygheap->locale.wctomb = __utf8_wctomb;
    }
  else
    {
      cygheap->locale.mbtowc = __mbtowc;
      cygheap->locale.wctomb = __wctomb;
    }
  strcpy (cygheap->locale.charset, __locale_charset ());
  /* Restore CWD and PATH in new charset. */
  cygheap->cwd.reset_posix (w_cwd);
  cwdstuff::cwd_lock.release ();
  if (w_path)
    {
      char *c_path = tp.c_get ();
      sys_wcstombs (c_path, 32768, w_path);
      setenv ("PATH", c_path, 1);
    }
}

/* Called from dll_crt0_1, before fetching the command line from Windows.
   Set the internal charset according to the environment locale settings.
   Check if a required codepage is available, and only switch internal
   charset if so.
   Make sure to reset the application locale to "C" per POSIX. */
void
initial_setlocale ()
{
  char *ret = _setlocale_r (_REENT, LC_CTYPE, "");
  if (ret && check_codepage (ret)
      && strcmp (cygheap->locale.charset, __locale_charset ()) != 0)
    internal_setlocale ();
}

/* Like newlib's setlocale, but additionally check if the charset needs
   OS support and the required codepage is actually installed.  If codepage
   is not available, revert to previous locale and return NULL.  For details
   about codepage availability, see the comment in check_codepage() above. */
extern "C" char *
setlocale (int category, const char *locale)
{
  char old[(LC_MESSAGES + 1) * (ENCODING_LEN + 1/*"/"*/ + 1)];
  if (locale && !wincap.has_always_all_codepages ())
    stpcpy (old, _setlocale_r (_REENT, category, NULL));
  char *ret = _setlocale_r (_REENT, category, locale);
  if (ret && locale && !(ret = check_codepage (ret)))
    _setlocale_r (_REENT, category, old);
  return ret;
}
@


1.553
log
@	* dcrt0.cc (dll_crt0_1): Reset locale to "C" at the last moment before
	calling the application's main.
	* syscalls.cc (internal_setlocale): Don't reset locale to "C here.
	Change comment accordingly.
@
text
@d4351 10
a4360 2
  cygheap->locale.mbtowc = __mbtowc;
  cygheap->locale.wctomb = __wctomb;
@


1.552
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d4365 1
a4365 1
/* Called from dll_crt0_1, before calling the application's main().
d4368 2
a4369 1
   charset if so.  Afterwards, reset application locale to "C" per POSIX. */
a4376 1
  _setlocale_r (_REENT, LC_CTYPE, "C");
@


1.551
log
@	* syscalls.cc (rename): Don't exit prematurely with EROFS when trying
	to rename an AF_LOCAL socket or when trying to replace an AF_LOCAL
	socket.
@
text
@d119 1
a119 1
int
d122 1
a122 1
  return cygheap->fdtab.dup2 (fd, cygheap_fdnew ());
d125 1
a125 1
int
d134 33
a166 1
  return cygheap->fdtab.dup2 (oldfd, newfd);
a1071 5
	  else if (!fh->open (flags, (mode & 07777) & ~cygheap->umask))
	    {
	      delete fh;
	      res = -1;
	    }
d1074 12
a1085 3
	      cygheap->fdtab[fd] = fh;
	      if ((res = fd) <= 2)
		set_std_handle (res);
@


1.550
log
@	* dtable.cc (build_fh_name_worker): Remove.  Move all functionality
	back into build_fh_name.
	(build_fh_name): Drop unused HANDLE parameter.  Drop call to pc.fillin.
	Remove disabled build_fh_name with UNICODE_STRING name parameter.
	* dtable.h (build_fh_name): Drop HANDLE parameter from declaration.
	Remove declaration for build_fh_name with UNICODE_STRING name parameter.
	* path.cc (path_conv::fillin): Remove.
	(symlink_info::check): Fix comment.
	* path.h (path_conv::fillin): Remove declaration.
	* dir.cc: Accommodate change in build_fh_name parameters throughout.
	* sec_acl.cc: Ditto.
	* syscalls.cc: Ditto.

	* ntea.cc (getxattr_worker): Fix debug output.
	(setxattr_worker): Ditto.
	* times.cc (utimens_worker): Ditto.
@
text
@d1768 1
a1768 1
  if (oldpc.isspecial ()) /* No renames from virtual FS */
d1817 1
a1817 1
  if (newpc.isspecial ()) /* No renames to virtual FSes */
@


1.549
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d1012 1
a1012 1
	  if (!(fh = build_fh_name (unix_path, NULL,
d1139 1
a1139 1
  if (!(fh = build_fh_name (oldpath, NULL, PC_SYM_NOFOLLOW, stat_suffixes)))
d1171 1
a1171 1
  if (!(fh = build_fh_name (name, NULL, fmode, stat_suffixes)))
d1263 1
a1263 1
  if (!(fh = build_fh_name (path, NULL, PC_SYM_FOLLOW, stat_suffixes)))
d1474 1
a1474 1
      debug_printf ("got %d error from build_fh_name", pc.error);
d1575 1
a1575 1
      fhandler_base *fh = build_fh_name (fn, NULL, PC_SYM_FOLLOW, stat_suffixes);
d1598 1
a1598 1
      fhandler_base *fh = build_fh_name (fn, NULL, PC_SYM_FOLLOW, stat_suffixes);
d2210 1
a2210 1
  if (!(fh = build_fh_name (file, NULL, PC_SYM_FOLLOW, stat_suffixes)))
d2505 1
a2505 1
  if (!(fh = build_fh_name (name, NULL, PC_SYM_FOLLOW, stat_suffixes)))
d4016 1
a4016 1
	  fhandler_base *fh = build_fh_name (path, NULL,
@


1.548
log
@	* syscalls.cc (try_to_bin): Handle remote shares as well.  Just rename
	files in this case, instead of moving them to the recycler.  Create
	even more unique filename.  Add comment to explain filename.
	(unlink_nt): Remove code returning with EBUSY on remote shares.
	Set bin_stat to move_to_bin except on NFS.  Add comment to explain.
@
text
@d103 3
a105 2
	  DuplicateHandle (GetCurrentProcess (), fh->get_output_handle (), GetCurrentProcess (), &h, 0, false,
			   DUPLICATE_SAME_ACCESS);
d3135 1
a3135 1
	  if (!SetPriorityClass (hMainProc, prio))
@


1.547
log
@	* globals.cc (ro_u_dll): New R/O unicode string.
	* syscalls.cc (nt_path_has_executable_suffix): Add ro_u_dll to
	blessed_executable_suffixes array.  Explain why.
@
text
@d188 1
a188 27
  if (wincap.has_recycle_dot_bin ())	/* NTFS and FAT since Vista */
    RtlAppendUnicodeToString (&recycler, L"\\$Recycle.Bin\\");
  else if (pc.fs_is_ntfs ())	/* NTFS up to 2K3 */
    RtlAppendUnicodeToString (&recycler, L"\\RECYCLER\\");
  else if (pc.fs_is_fat ())	/* FAT up to 2K3 */
    RtlAppendUnicodeToString (&recycler, L"\\Recycled\\");
  else
    goto out;
  /* Is the file a subdir of the recycler? */
  RtlInitCountedUnicodeString(&fname, pfni->FileName, pfni->FileNameLength);
  if (RtlEqualUnicodePathPrefix (&fname, &recycler, TRUE))
    goto out;
  /* Is fname the recycler?  Temporarily hide trailing backslash. */
  recycler.Length -= sizeof (WCHAR);
  if (RtlEqualUnicodeString (&fname, &recycler, TRUE))
    goto out;

  /* Create root dir path from file name information. */
  RtlSplitUnicodePath (&fname, &fname, NULL);
  RtlSplitUnicodePath (pc.get_nt_native_path (), &root, NULL);
  root.Length -= fname.Length - sizeof (WCHAR);

  /* Open root directory.  All recycler bin ops are caseinsensitive. */
  InitializeObjectAttributes (&attr, &root, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenFile (&rootdir, FILE_TRAVERSE, &attr, &io,
		       FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
  if (!NT_SUCCESS (status))
d190 32
a221 3
      debug_printf ("NtOpenFile (%S) failed, %08x", &root, status);
      goto out;
    }
d223 34
a256 23
  /* Strip leading backslash */
  ++recycler.Buffer;
  recycler.Length -= sizeof (WCHAR);
  /* Store length of recycler base dir, should it be necessary to create it. */
  recycler_base_len = recycler.Length;
  /* On NTFS the recycler dir contains user specific subdirs, which are the
     actual recycle bins per user.  The name if this dir is the string
     representation of the user SID. */
  if (pc.fs_is_ntfs ())
    {
      UNICODE_STRING sid;
      WCHAR sidbuf[128];
      /* Unhide trailing backslash. */
      recycler.Length += sizeof (WCHAR);
      RtlInitEmptyUnicodeString (&sid, sidbuf, sizeof sidbuf);
      /* In contrast to what MSDN claims, this function is already available
	 since NT4. */
      RtlConvertSidToUnicodeString (&sid, cygheap->user.sid (), FALSE);
      RtlAppendUnicodeStringToString (&recycler, &sid);
      recycler_user_len = recycler.Length;
    }
  /* Create hopefully unique filename. */
  RtlAppendUnicodeToString (&recycler, L"\\cyg");
d267 2
d272 1
a272 1
  pfri->RootDirectory = rootdir;
d276 1
a276 1
  if (status == STATUS_OBJECT_PATH_NOT_FOUND)
d522 1
a522 1
	 though, and it is then possible to delete the file quite normally. */
d524 4
a527 15
      /* The recycle bin is only accessible locally.  For in-use remote
	 files we drop back to just returning EBUSY, except for NFS. */
      if (pc.isremote () && status == STATUS_SHARING_VIOLATION
	  && !pc.fs_is_nfs ())
	{
	  if (fh_ro)
	    {
	      /* Try to reset R/O attribute and close handle. */
	      NtSetAttributesFile (fh_ro, pc.file_attributes ());
	      NtClose (fh_ro);
	    }
	  return status;
	}
      /* Only local FS and NFS should arrive here. */
      if (!pc.isremote ())
@


1.546
log
@	* path.cc (symlink_info::check_reparse_point): Always check
	SubstituteName for volume string to recognize volume mount points.
	Reuse subst when calling sys_wcstombs.
	* syscalls.cc (rename): Set errno to EBUSY when trying to rename
	volume mount points.  Explain why.
@
text
@d1654 6
@


1.545
log
@	* globals.cc (ro_u_scr): New R/O unicode string.
	(ro_u_sys): Ditto.
	* syscalls.cc (nt_path_has_suffix): Replace with ...
	(nt_path_has_executable_suffix): New function checking for explicit
	executable suffixes.
	(rename): Call nt_path_has_executable_suffix instead of
	nt_path_has_suffix.  Check oldpath for nt_path_has_executable_suffix
	as well to set old_explicit_suffix.
@
text
@d1761 10
@


1.544
log
@	* syscalls.cc (nt_path_has_suffix): New function.
	(rename): Don't append .exe suffix if binary target name has any suffix
	at all.
@
text
@d1646 2
a1647 3
/* This function tests if a filename has *any* suffix.  In order to
   make this quick and simple, we define a suffix as being not longer
   than 4 chars, plus the leading dot. */
d1649 1
a1649 1
nt_path_has_suffix (PUNICODE_STRING upath)
d1651 9
d1661 3
a1663 2
  const PWCHAR path = upath->Buffer;
  USHORT upto;
d1668 8
a1675 8
  upto = pos - 5;
  while (--pos >= upto)
    {
      if (path[pos] == L'.')
	return true;
      if (path[pos] == L'\\')
	break;
    }
d1767 4
a1770 3
  if (oldpc.known_suffix
      && (ascii_strcasematch (oldpath + olen - 4, ".lnk")
	  || ascii_strcasematch (oldpath + olen - 4, ".exe")))
d1878 1
a1878 1
	       && !nt_path_has_suffix (newpc.get_nt_native_path ()))
d1909 1
a1909 1
	  if (!nt_path_has_suffix (newpc.get_nt_native_path ()))
@


1.543
log
@	* syscalls.cc (internal_setlocale): Only convert $PATH if there is a
	$PATH.
@
text
@d1646 24
d1868 2
a1869 3
	   && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
					  &ro_u_exe, TRUE))
	/* To rename an executable foo.exe to bar-without-exe-suffix, the
d1898 2
a1899 2
	  if (!RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
					  &ro_u_exe, TRUE))
@


1.542
log
@	* include/sys/cygwin.h: Add new cygwin_getinfo_type
	CW_SET_EXTERNAL_TOKEN.
	Add new enum CW_TOKEN_IMPERSONATION, CW_TOKEN_RESTRICTED.
	* cygheap.h (cyguser): New flags ext_token_is_restricted,
	curr_token_is_restricted and setuid_to_restricted.
	* external.cc (cygwin_internal): Add CW_SET_EXTERNAL_TOKEN.
	* sec_auth.cc (set_imp_token): New function.
	(cygwin_set_impersonation_token): Call set_imp_token ().
	* security.h (set_imp_token): New prototype.
	* spawn.cc (spawn_guts): Use CreateProcessAsUserW if restricted token
	was enabled by setuid().  Do not create new window station in this case.
	* syscalls.cc (seteuid32): Add handling of restricted external tokens.
	Set HANDLE_FLAG_INHERIT for primary token.
	(setuid32): Set setuid_to_restricted flag.
	* uinfo.cc (uinfo_init): Do not reimpersonate if restricted token was
	enabled by setuid ().  Initialize user.*_restricted flags.
@
text
@d4245 2
a4246 1
  wchar_t *w_path, *w_cwd;
d4250 6
a4255 3
  /* Fetch CWD and PATH and convert to wchar_t in previous charset. */
  w_path = tp.w_get ();
  sys_mbstowcs (w_path, 32768, getenv ("PATH"));
d4266 6
a4271 3
  char *c_path = tp.c_get ();
  sys_wcstombs (c_path, 32768, w_path);
  setenv ("PATH", c_path, 1);
@


1.541
log
@	* syscalls.cc (seteuid32): Call set_cygwin_privileges on primary token
	as well.
@
text
@d2667 22
a2688 1
  if (uid == myself->uid && !cygheap->user.groups.ischanged)
d2710 16
d2741 3
a2743 2
  if ((uid == cygheap->user.saved_uid && usersid == cygheap->user.saved_sid ())
      || verify_token (hProcToken, usersid, groups))
d2804 6
a2809 3
      /* Avoid having HKCU use default user */
      WCHAR name[128];
      load_registry_hive (usersid.string (name));
d2834 2
d2843 7
a2849 3
      if (!DuplicateTokenEx (cygheap->user.curr_primary_token, MAXIMUM_ALLOWED,
			     &sec_none, SecurityImpersonation,
			     TokenImpersonation, &cygheap->user.curr_imp_token))
d2855 1
d2886 5
a2890 1
    cygheap->user.real_uid = myself->uid;
@


1.540
log
@	* syscalls.cc (internal_setlocale): Add comment.
@
text
@d2808 1
@


1.539
log
@	* dcrt0.cc (dll_crt0_1): Drop calls to setlocale/_setlocale_r.  Just
	call initial_setlocale from here.
	* syscalls.cc (initial_setlocale): Set internal charset and revert
	application locale to "C".
	(setlocale): Don't set Cygwin's internal charset here.
@
text
@d4189 2
@


1.538
log
@* syscalls.cc (rename): Fix regression in rename("dir","d/").
@
text
@d4212 18
d4237 2
a4238 8
  if (ret && locale)
    {
      if (!(ret = check_codepage (ret)))
	_setlocale_r (_REENT, category, old);
      else if (!*locale && strcmp (cygheap->locale.charset,
				   __locale_charset ()) != 0)
	internal_setlocale ();
    }
@


1.537
log
@	* cygheap.cc (cygheap_init): Default locale.charset to "UTF-8".
	* dcrt0.cc (dll_crt0_1): Call setlocale (LC_CTYPE, "") here, just
	before resetting application locale to "C".
	* environ.cc (environ_init): Drop code setting locale here.
	* syscalls.cc (check_codepage): Break out check for required codepage
	from internal_setlocale.
	(internal_setlocale): Just convert CWD and $PATH from old charset to
	new charset and set internal charset.
	(setlocale): Change accordingly.  Don't require LC_ALL or LC_CTYPE to
	store old locale value.  Always call internal_setlocale if charset
	changed due to locale environment changes.
@
text
@d1671 1
d1677 1
d1684 1
d1730 1
d1766 2
a1767 1
  if (new_dir_requested)
d1769 3
a1771 10
      if (!newpc.exists())
        {
          set_errno (ENOENT);
          goto out;
        }
      if (!newpc.isdir ())
        {
          set_errno (ENOTDIR);
          goto out;
        }
d1775 1
@


1.536
log
@Fix some POSIX-compliance bugs in link, rename, mkdir.

* syscalls.cc (link): Delete obsolete comment.  Reject directories
and missing source up front.
(rename): Use correct errno for trailing '.'.  Detect empty
strings.  Allow trailing slash to newpath iff oldpath is
directory.
* dir.cc (mkdir): Reject dangling symlink with trailing slash.
* fhandler_disk_file.cc (fhandler_disk_file::link): Reject
trailing slash.
* fhandler.cc (fhandler_base::link): Match Linux errno.
@
text
@d4154 1
a4154 1
internal_setlocale (char *ret)
d4156 34
d4191 1
d4193 6
a4198 5
  /* Each setlocale potentially changes the multibyte representation
     of the CWD.  Therefore we have to reevaluate the CWD's posix path and
     store in the new charset. */
  /* FIXME: Other buffered paths might be affected as well. */
  wchar_t *w_cwd = tp.w_get ();
d4201 3
a4203 34

  if (*__locale_charset () == 'A')
    {
      cygheap->locale.mbtowc = __utf8_mbtowc;
      cygheap->locale.wctomb = __utf8_wctomb;
    }
  else
    {
      if (!wincap.has_always_all_codepages ())
	{
	  /* Prior to Windows Vista, many codepages are not installed by
	     default, or can be deinstalled.  The following codepages require
	     that the respective conversion tables are installed into the OS.
	     So we check if they are installed and if not, setlocale should
	     fail. */
	  CPINFO cpi;
	  UINT cp = 0;
	  if (__mbtowc == __sjis_mbtowc)
	    cp = 932;
	  else if (__mbtowc == __eucjp_mbtowc)
	    cp = 20932;
	  else if (__mbtowc == __gbk_mbtowc)
	    cp = 936;
	  else if (__mbtowc == __kr_mbtowc)
	    cp = 949;
	  else if (__mbtowc == __big5_mbtowc)
	    cp = 950;
	  if (cp && !GetCPInfo (cp, &cpi)
	      && GetLastError () == ERROR_INVALID_PARAMETER)
	    return NULL;
	}
      cygheap->locale.mbtowc = __mbtowc;
      cygheap->locale.wctomb = __wctomb;
    }
d4205 1
a4205 2

  /* See above. */
d4208 3
a4210 1
  return ret;
d4217 1
a4217 2
  if (locale && (category == LC_ALL || category == LC_CTYPE)
      && !wincap.has_always_all_codepages ())
d4220 8
a4227 3
  if (ret && locale && (category == LC_ALL || category == LC_CTYPE)
      && !(ret = internal_setlocale (ret)))
    _setlocale_r (_REENT, category, old);
@


1.535
log
@Provide euidaccess, canonicalize_file_name; fix fchmodat.

* syscalls.cc (fchmodat): lchmod is not yet implemented.
(euidaccess): New function.
* path.cc (realpath): Update comment.
(canonicalize_file_name): New function.
* include/cygwin/stdlib.h (canonicalize_file_name): Declare it.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
* cygwin.din: Export canonicalize_file_name, eaccess, euidaccess.
* posix.sgml: Mention them.
@
text
@a1126 7
/* Under NT, try to make a hard link using backup API.  If that
   fails or we are Win 95, just copy the file.
   FIXME: We should actually be checking partition type, not OS.
   Under NTFS, we should support hard links.  On FAT partitions,
   we should just copy the file.
*/

d1141 4
a1650 1
  char *oldbuf, *newbuf;
d1669 5
d1677 1
a1677 1
      set_errno (oldpc.isdir () ? EBUSY : ENOTDIR);
d1683 1
a1683 1
      set_errno (!newpc.exists () ? ENOENT : newpc.isdir () ? EBUSY : ENOTDIR);
d1693 14
a1706 4
      stpcpy (oldbuf = tp.c_get (), oldpath);
      while (olen > 0 && isdirsep (oldbuf[olen - 1]))
	oldbuf[--olen] = '\0';
      oldpath = oldbuf;
d1738 11
a1748 4
      stpcpy (newbuf = tp.c_get (), newpath);
      while (nlen > 0 && isdirsep (newbuf[nlen - 1]))
	newbuf[--nlen] = '\0';
      newpath = newbuf;
d1762 1
a1762 1
  if (new_dir_requested && !newpc.isdir ())
d1764 14
a1777 1
      set_errno (ENOTDIR);
d1808 1
a1808 6
      if (newpc.exists () && !newpc.isdir ())
	{
	  set_errno (ENOTDIR);
	  goto out;
	}
      /* Check for newpath being a subdir of oldpath. */
d1811 1
a1811 5
				  TRUE)
	  && newpc.get_nt_native_path ()->Length >
	     oldpc.get_nt_native_path ()->Length
	  && *(PWCHAR) ((PBYTE) newpc.get_nt_native_path ()->Buffer
			+ oldpc.get_nt_native_path ()->Length) == L'\\')
d1813 12
a1824 2
	  set_errno (EINVAL);
	  goto out;
a1850 5
  else if (newpc.isdir ())
    {
      set_errno (EISDIR);
      goto out;
    }
@


1.534
log
@Fix faccessat(,0) and access() semantics.

* fhandler.h (fhandler_base::fhaccess): Add parameter.
* security.h (check_file_access, check_registry_access): Likewise.
* security.cc (check_file_access, check_registry_access)
(check_access): Implement new parameter.
* fhandler.cc (fhandler_base::fhaccess): Likewise.
(device_access_denied): Update caller.
* syscalls.cc (access, faccessat): Update callers.
* spawn.cc (find_exec, fixup): Likewise.
@
text
@d1583 23
d3904 1
a3904 1
  if (flags & ~AT_SYMLINK_NOFOLLOW)
d3906 4
a3909 1
      set_errno (EINVAL);
@


1.533
log
@Make *at functions more like Linux.

* syscalls.cc (faccessat): Fix typo, reject bad flags.
(fchmodat, fchownat, fstatat, utimensat, linkat, unlinkat): Reject
bad flags.
@
text
@d1575 1
a1575 1
	  res =  fh->fhaccess (flags);
d3865 1
a3865 1
	      res =  fh->fhaccess (mode);
@


1.532
log
@Match dup2 and fcntl error values to POSIX.

* dtable.h (OPEN_MAX_MAX): New macro.
* resource.cc (getrlimit) [RLIMIT_NOFILE]: Use it.
* dtable.cc (dtable::extend): Likewise.
* fcntl.cc (fcntl64): Obey POSIX rule with too-large F_DUPFD.
* syscalls.cc (dup2): Likewise.
@
text
@d3854 2
a3855 1
      if (flags & ~(F_OK|R_OK|W_OK|X_OK))
d3881 5
d3900 5
d3919 5
d3941 5
d3976 5
d4089 5
@


1.531
log
@	* cygheap.h (cwdstuff::get_posix): Convert to const inline method just
	returning pointer to posix path.
	(cwdstuff::reset_posix): Convert to non-inline method taking a wchar_t
	pointer.
	* path.cc (cwdstuff::set): Revert change from 2009-05-13.  Set posix
	to valid incoming path again.
	(cwdstuff::reset_posix): New implementation setting posix path from
	incoming wchar_t path.  Explain usage.
	(cwdstuff::get_posix): Drop implementation.
	(cwdstuff::get): Drop special case to handle empty posix path.
	* syscalls.cc (internal_setlocale): Store old posix cwd as wide char
	path.  Restore posix cwd using new charset.  Explain why.
@
text
@d127 6
@


1.530
log
@* exceptions.cc (sigpacket::process): Give sigwait() processing precedence even
when a handler is present.
* syscalls.cc (getpagesize): Change return to 'int'.
@
text
@d4066 10
d4110 4
a4113 5
  /* Each setlocale potentially changes the multibyte representation
     of the CWD.  Therefore we have to reset the CWD's posix path and
     reevaluate the next time it's used. */
  /* FIXME: Other buffered paths might be affected as well. */
  cygheap->cwd.reset_posix ();
@


1.529
log
@* syscalls.cc (popen): Reorganize slightly for clarity.  Fix a comment.
@
text
@d2059 1
a2059 1
extern "C" size_t
@


1.528
log
@* syscalls.cc (popen): Rewrite to accommodate situations where stdin, stdout,
or stderr are closed.
@
text
@a3633 1
  int orig_fds[2] = {fds[0], fds[1]};
a3634 2
  int __std[2];
  __std[myix] = -1;	/* -1 denotes don't pass this fd to child process */
d3646 1
d3660 4
a3663 1
      __std[stdchild] = fds[stdchild];
@


1.527
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d3621 1
a3629 2
  int fd, other_fd, __stdin, __stdout, stdwhat;

d3634 29
a3662 17
  switch (rw)
    {
    case 'r':
      __stdin = -1;
      stdwhat = 1;
      other_fd = __stdout = fds[1];
      fd = fds[0];
      break;
    case 'w':
      __stdout = -1;
      stdwhat = 0;
      other_fd = __stdin = fds[0];
      fd = fds[1];
      break;
    default:
      return NULL;	/* avoid a compiler warning */
    }
d3664 21
a3684 2
  FILE *fp = fdopen (fd, in_type);
  fcntl64 (fd, F_SETFD, fcntl64 (fd, F_GETFD, 0) | FD_CLOEXEC);
d3686 2
a3687 2
  if (!fp)
    goto err;
d3689 17
a3705 23
  pid_t pid;
  const char *argv[4];

  argv[0] = "/bin/sh";
  argv[1] = "-c";
  argv[2] = command;
  argv[3] = NULL;

  {
    lock_process now;
    int state = fcntl64 (stdwhat, F_GETFD, 0);
    fcntl64 (stdwhat, F_SETFD, state | FD_CLOEXEC);
    pid = spawn_guts ("/bin/sh", argv, cur_environ (), _P_NOWAIT,
		      __stdin, __stdout);
    fcntl64 (stdwhat, F_SETFD, state);
  }

  if (pid >= 0)
    {
      close (other_fd);
      fhandler_pipe *fh = (fhandler_pipe *) cygheap->fdtab[fd];
      fh->set_popen_pid (pid);
      return fp;
d3708 2
a3709 1
err:
@


1.526
log
@	* syscalls.cc (internal_setlocale): Fix typo in GBK codepage.
@
text
@d845 1
a845 1
  int res = -1;
@


1.525
log
@	* syscalls.cc (unlink_nt): Ignore sharing violation on NFS.  Align
	comments.
@
text
@d4061 1
a4061 1
	    cp = 963;
@


1.524
log
@	* wincap.h (wincaps::has_always_all_codepages): New element.
	* wincap.cc: Implement above element throughout.
	* wchar.h (__sjis_mbtowc): Declare.
	(__eucjp_mbtowc): Ditto.
	(__gbk_mbtowc): Ditto.
	(__kr_mbtowc): Ditto.
	(__big5_mbtowc): Ditto.
	* syscalls.cc (internal_setlocale): Convert to char * function.
	Return parameter by default.  Return NULL if request to use a
	charset can't be satisfied due to missing codepage support in the
	underlying OS.  Fix comment.
	(setlocale): Store original locale.  Restore to original locale if
	internal_setlocale returns NULL.
@
text
@d503 3
a505 2
	 files we drop back to just returning EBUSY. */
      if (pc.isremote () && status == STATUS_SHARING_VIOLATION)
d515 1
a515 1
      /* Only local FS and NFS w/ STATUS_LOCK_NOT_GRANTED should arrive here. */
@


1.523
log
@	* syscalls.cc (unlink_nt): Just return when a sharing violation
	occurs on remote filesystems.
@
text
@d27 1
d40 1
d4036 2
a4037 2
static void
internal_setlocale ()
d4039 1
a4039 1
  if (*cygheap->locale.charset == 'A')
d4046 23
d4074 1
a4074 1
     of the CWD.  Therefore we have to rest the CWD's posix path and
d4078 1
d4084 4
d4089 3
a4091 2
  if (ret && locale && (category == LC_ALL || category == LC_CTYPE))
    internal_setlocale ();
@


1.522
log
@	* syscalls.cc (unlink_nt): First remove the R/O DOS attribute with
	FILE_WRITE_ATTRIBUTES access only, then re-open the file for DELETE.
	Explain why.
@
text
@d500 13
a512 1
      /* Bin is only accessible locally. */
@


1.521
log
@	Throughout avoid having to initialize constant UNICODE_STRINGs.
	* globals.cc: Define constant UNICODE_STRINGs and store in .rdata
	section.
	* fhandler_disk_file.cc: Throughout, use readonly UNICODE_STRINGs
	rather then initializing local UNICODE_STRING variable where
	applicable.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* flock.cc (inode_t::inode_t): Ditto.
	* mmap.cc: Ditto.
	* syscalls.cc: Ditto.
	* mount.cc (fs_info::update): Ditto.
	* path.cc: Ditto.

	* ntdll.h (RtlEqualUnicodePathPrefix): Redefine to take prefix as
	UNICODE_STRING.
	(RtlEqualUnicodePathSuffix): Redefine to take suffix as UNICODE_STRING.
	* fhandler_disk_file.cc: Accommodate throughout.
	* mount.cc (fs_info::update): Ditto.
	* path.cc (cwdstuff::set): Ditto.
	* syscalls.cc: Ditto.
@
text
@d448 1
a448 1
  HANDLE fh;
d452 2
a454 6
  /* If the R/O attribute is set, we have to open the file with
     FILE_WRITE_ATTRIBUTES to be able to remove this flags before trying
     to delete it. */
  if (pc.file_attributes () & FILE_ATTRIBUTE_READONLY)
    access |= FILE_WRITE_ATTRIBUTES;

d462 19
a486 1
  bin_status bin_stat = dont_move;
d529 2
d536 2
a547 3
  /* Get rid of read-only attribute. */
  if (access & FILE_WRITE_ATTRIBUTES)
    NtSetAttributesFile (fh, pc.file_attributes () & ~FILE_ATTRIBUTE_READONLY);
@


1.520
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d190 1
a190 1
  if (RtlEqualUnicodePathPrefix (&fname, recycler.Buffer, TRUE))
a560 1
	  UNICODE_STRING fname;
d564 1
a564 2
	  RtlInitUnicodeString (&fname, L"");
	  InitializeObjectAttributes (&attr, &fname, 0, fh, NULL);
d1751 1
a1751 1
					      L".lnk", TRUE))
d1755 1
a1755 1
					  L".exe", TRUE))
d1782 1
a1782 1
					     L".lnk", TRUE))
d1791 1
a1791 1
					  L".exe", TRUE))
d1800 1
a1800 1
					  L".lnk", TRUE)
d1802 1
a1802 1
					     L".exe", TRUE))
@


1.519
log
@	* cygheap.cc (cygheap_init): Set Cygwin default locale values.
	* cygheap.h (struct cygheap_locale): New structure.
	(struct user_heap_info): Add cygheap_locale member locale.
	* dcrt0.cc (dll_crt0_1): Revert to calling _setlocale_r so that only
	the applications locale is reverted to "C".
	* environ.cc (environ_init): Remove unused got_lc variable.
	* fhandler.h (class dev_console): Remove now unsed locale variables.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove
	setting dev_console's locale members.
	(dev_console::con_to_str): Use internal locale settings.  Default to
	__ascii_wctomb if charset is "ASCII".
	(fhandler_console::write_normal): Ditto.
	* strfuncs.cc (__ascii_wctomb): Drop declaration.
	(__db_wctomb): Use fixed value 2 instead of not
	necessarily matching MB_CUR_MAX.
	(__eucjp_wctomb): Use 3 instead of MB_CUR_MAX.
	(sys_cp_wcstombs): Remove special case for "C" locale.
	(sys_wcstombs): Implement here.  Use internal locale data stored on
	cygheap.
	(sys_cp_mbstowcs): Remove special case for "C" locale.
	(sys_mbstowcs): Implement here.  Use internal locale data stored on
	cygheap.
	* syscalls.cc (internal_setlocale): New function to set cygheap locale
	data and to reset CWD posix path.
	(setlocale): Just call internal_setlocale from here if necessary.
	* wchar.h (__ascii_wctomb): Declare.
	(sys_wcstombs): Don't define inline, just declare.
	(sys_mbstowcs): Ditto.
@
text
@d550 1
a550 1
      
d559 1
a559 1
        {
d576 1
a576 1
	         to the bin already, try it now.  If moving to the bin
d580 1
a580 1
	      	bin_stat = try_to_bin (pc, fh, access);
d1566 1
a1566 1
  				SYNCHRONIZE | TRANSACTION_ALL_ACCESS,
@


1.518
log
@	* cygheap.h (cwdstuff): Convert to class.  Make posix and dir private.
	(cwdstuff::get_posix): New method.
	(cwdstuff::reset_posix): New method.
	* dcrt0.cc (dll_crt0_1): Call setlocale rather than _setlocale_r.
	* environ.cc (environ_init): Ditto.  Prefer "C" locale over current
	codepage default locale.
	* path.cc (chdir): Use cwdstuff::get_posix method instead of accessing
	cwdstuff::posix directly.
	(cwdstuff::set): Defer creating posix path to first usage.
	(cwdstuff::get_posix): Create posix path if it's empty, and return it.
	(cwdstuff::get): Create posix path if it's empty.
	* strfuncs.cc (sys_cp_wcstombs): Use UTF-8 conversion in the "C"
	locale.
	(sys_cp_mbstowcs): Ditto.
	* syscalls.cc (gen_full_path_at): Fetch CWD posix path locked.
	(setlocale): Implement here.  Reset CWD posix path.
@
text
@d4009 2
a4010 2
extern "C" char *
setlocale (int category, const char *locale)
d4012 11
d4027 6
d4034 2
a4035 2
  if (ret)
    cygheap->cwd.reset_posix ();
@


1.517
log
@	* ntdll.h (STATUS_LOCK_NOT_GRANTED): Define.
	* syscalls.cc (unlink_nt): Handle STATUS_LOCK_NOT_GRANTED same as
	STATUS_SHARING_VIOLATION.  Add lengthy comment to explain why.
@
text
@d38 1
d3730 5
a3734 1
	p = stpcpy (path_ret, cygheap->cwd.posix);
d4008 13
@


1.516
log
@	* syscalls.cc (try_to_bin): Use tmp_pathbuf buffer to allocate infobuf
	rather than using the stack.
@
text
@d473 1
a473 1
  if (status == STATUS_SHARING_VIOLATION)
d475 10
@


1.515
log
@	* syscalls.cc (try_to_bin): Fix alignment of infobuf.
@
text
@a155 3
  /* Enforce alignment for multi-purpose infobuf buffer */
  BYTE infobuf[sizeof (FILE_NAME_INFORMATION) + 32767 * sizeof (WCHAR)]
	__attribute__ ((aligned));
d158 3
d162 1
a162 2
  status = NtQueryInformationFile (fh, &io, pfni, sizeof infobuf,
				   FileNameInformation);
d235 1
a235 1
  status = NtQueryInformationFile (fh, &io, pfii, sizeof infobuf,
d250 1
a250 2
  status = NtSetInformationFile (fh, &io, pfri, sizeof infobuf,
				 FileRenameInformation);
d351 1
a351 1
      status = NtSetInformationFile (fh, &io, pfri, sizeof infobuf,
d398 1
a398 1
  status = NtSetInformationFile (tmp_fh, &io, pfri, sizeof infobuf,
@


1.514
log
@	* syscalls.cc (pathconf): Fix memory leak.
@
text
@d156 3
a158 1
  BYTE infobuf[sizeof (FILE_NAME_INFORMATION ) + 32767 * sizeof (WCHAR)];
@


1.513
log
@	* syscalls.cc (open): Handle O_DIRECTORY flag.
	* include/fcntl.h: Add SUSv4 flags O_DIRECTORY, O_EXEC and O_SEARCH.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d2050 1
d2055 1
d2064 5
a2068 5
    {
      set_errno (ENOENT);
      return -1;
    }
  return fh->fpathconf (v);
@


1.512
log
@	* syscalls.cc (enum bin_status): New type.
	(try_to_bin): Return bin_status.  Rename win32_path to pc.  Rename h
	to fh.  Rename fh to tmp_fh.  Add code to set delete dispostion and
	more code to replace file moved to bin by another, temporary file.
	Add comments to explain why.
	(unlink_nt): Replace move_to_bin with bin_stat.  Only set bin_stat
	to move_to_bin for non-remote files.  As a last resort, call try_to_bin
	if setting delete-on-close failed.  Only re-set R/O DOS attribute
	and only close handle if it's still valid.
@
text
@d972 6
@


1.511
log
@	* ntdll.h: Reorder NT status flags.  Fix a case difference. Add
	STATUS_CANNOT_DELETE flag.
	* syscalls.cc (unlink_nt): Change initial NtOpenFile to request
	FILE_SHARE_DELETE sharing mode.  Change comment accordingly.
	If setting delete disposition failed with STATUS_CANNOT_DELETE, try
	to delete using delete-on-close.  Explain why.
	Rearrange setting R/O DOS attribute after trying to delete.  Simplify
	comment.
@
text
@d135 9
a143 2
static void
try_to_bin (path_conv &win32_path, HANDLE h)
d145 1
d149 1
a149 1
  HANDLE rootdir = NULL, recyclerdir = NULL;
d157 1
d160 1
a160 1
  status = NtQueryInformationFile (h, &io, pfni, sizeof infobuf,
d180 1
a180 1
  else if (win32_path.fs_is_ntfs ())	/* NTFS up to 2K3 */
d182 1
a182 1
  else if (win32_path.fs_is_fat ())	/* FAT up to 2K3 */
d197 1
a197 1
  RtlSplitUnicodePath (win32_path.get_nt_native_path (), &root, NULL);
d218 1
a218 1
  if (win32_path.fs_is_ntfs ())
d234 1
a234 1
  status = NtQueryInformationFile (h, &io, pfii, sizeof infobuf,
d249 1
a249 1
  status = NtSetInformationFile (h, &io, pfri, sizeof infobuf,
d272 1
a272 1
			     | (win32_path.fs_is_ntfs () ? 0 : FILE_ADD_FILE),
d286 1
a286 1
      if (win32_path.fs_is_ntfs ())
a307 1
	  HANDLE fh;
d311 1
a311 1
	  status = NtCreateFile (&fh, FILE_GENERIC_WRITE, &attr, &io, NULL,
d320 1
a320 1
	      status = NtWriteFile (fh, NULL, NULL, NULL, &io, desktop_ini,
d324 1
a324 1
	      NtClose (fh);
d329 3
a331 3
	      status = NtCreateFile (&fh, FILE_GENERIC_WRITE, &attr, &io, NULL,
				     FILE_ATTRIBUTE_ARCHIVE
				     | FILE_ATTRIBUTE_HIDDEN,
d340 1
a340 1
		  status = NtWriteFile (fh, NULL, NULL, NULL, &io, info2,
d345 1
a345 1
		  NtClose (fh);
d351 1
a351 1
      status = NtSetInformationFile (h, &io, pfri, sizeof infobuf,
d355 50
a404 2
    debug_printf ("Move %S to %S failed, status = %p",
		  win32_path.get_nt_native_path (), &recycler, status);
d408 1
d471 1
a471 1
  bool move_to_bin = false;
d475 3
a477 1
      move_to_bin = true;
a518 4

  if (move_to_bin && !pc.isremote ())
    try_to_bin (pc, fh);

d522 6
a527 1

d538 1
a538 1
	 using delete-on-close semantic works.
d557 2
a558 2
			       move_to_bin ? FILE_SHARE_VALID_FLAGS
					   : FILE_SHARE_DELETE,
d561 12
a572 2
	    syscall_printf ("Setting delete-on-close failed, status = %p",
			    status);
d577 1
a577 2
  if ((access & FILE_WRITE_ATTRIBUTES)
      && (!NT_SUCCESS (status) || !pc.isdir ()))
d582 4
a585 1
      NtSetAttributesFile (fh, pc.file_attributes ());
a586 2

  NtClose (fh);
@


1.510
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d408 6
a413 6
  /* First try to open the file with sharing not allowed.  If the file
     has an open handle on it, this will fail.  That indicates that the
     file has to be moved to the recycle bin so that it actually disappears
     from its directory even though its in use.  Otherwise, if opening
     doesn't fail, the file is not in use and by simply closing the handle
     the file will disappear. */
d415 1
a415 1
  status = NtOpenFile (&fh, access, &attr, &io, 0, flags);
d473 33
a505 4
      syscall_printf ("Setting delete disposition failed, status = %p", status);
      /* Restore R/O attributes. */
      if (access & FILE_WRITE_ATTRIBUTES)
	NtSetAttributesFile (fh, pc.file_attributes ());
d507 2
a508 1
  else if ((access & FILE_WRITE_ATTRIBUTES) && !pc.isdir ())
d512 1
a512 1
	 changes the disposition for delete back to FALSE, at least on XP. */
@


1.509
log
@	* syscalls.cc (gen_full_path_at): Use isabspath instead of isdirsep
	to recognize absolute path.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
a74 9
suffix_info stat_suffixes[] =
{
  suffix_info ("", 1),
  suffix_info (".exe", 1),
  suffix_info (NULL)
};

SYSTEM_INFO system_info;

@


1.508
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d3613 1
a3613 1
  if (pathname && isdirsep (*pathname))
@


1.507
log
@	* Makefile.in (DLL_OFILES): Add setlsapwd.o.
	* cygserver.h (CYGWIN_SERVER_VERSION_API): Bump.
	(request_code_t): Define CYGSERVER_REQUEST_SETPWD request type.
	* cygserver_msg.h (client_request_msg::retval): Use default value of -1
	for retval if msglen is 0.
	* cygserver_sem.h (client_request_sem::retval): Ditto.
	* cygserver_shm.h (client_request_shm::retval): Ditto.
	* cygserver_setpwd.h: New file.
	* external.cc (cygwin_internal): Implement new CW_SET_PRIV_KEY type.
	* sec_auth.cc (open_local_policy): Make externally available.
	Get ACCESS_MASK as argument.
	(create_token): Accommodate change to open_local_policy.
	(lsaauth): Ditto.
	(lsaprivkeyauth): New function fetching token by retrieving
	password stored in Cygwin or Interix LSA private data area and
	calling LogonUser with it.
	* security.h (lsaprivkeyauth): Declare.
	(open_local_policy): Declare.
	* setlsapwd.cc: New file implementing setting LSA private data password
	using LsaStorePrivateData or by calling cygserver if available.
	* syscalls.cc (seteuid32): Add workaround to get the original token
	when switching back to the original privileged user, even if
	setgroups group list is still active.  Add long comment to explain why.
	Call lsaprivkeyauth first, only if that fails call lsaauth or
	create_token.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_SET_PRIV_KEY.
@
text
@d2507 1
a2507 1
     credentials. 
d2540 1
a2540 1
        {
d2550 1
a2550 1
        {
d3622 1
a3622 1
        {
d3634 1
a3634 1
        {
d3658 1
a3658 1
  
d3683 1
a3683 1
	{ 
d3687 1
a3687 1
					     stat_suffixes); 
@


1.506
log
@	* ntdll.h (NtSetAttributesFile): New inline function.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Use
	NtSetAttributesFile.
	* path.cc (symlink_worker): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
	(rename): Omit FILE_SHARE_DELETE when opening files on Samba.  Add
	comment to explain why.
@
text
@d2496 17
a2512 1
  if (verify_token (hProcToken, usersid, groups))
d2533 3
a2535 2
  /* If no impersonation token is available, try to
     authenticate using NtCreateToken () or LSA authentication. */
d2538 15
a2552 5
      if (!(new_token = lsaauth (usersid, groups, pw_new)))
	{
	  debug_printf ("lsaauth failed, try create_token.");
	  new_token = create_token (usersid, groups, pw_new);
	  if (new_token == INVALID_HANDLE_VALUE)
d2554 8
a2561 3
	      debug_printf ("create_token failed, bail out of here");
	      cygheap->user.reimpersonate ();
	      return -1;
@


1.505
log
@	* path.cc (path_conv::is_binary): Always check for GetBinaryType.
	* syscalls.cc (rename): Fix test for just changing case of name on
	case insensitive filesystems.
@
text
@a401 1
  FILE_BASIC_INFORMATION fbi;
d475 1
a475 7
    {
      fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart =
      fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
      fbi.FileAttributes = (pc.file_attributes () & ~FILE_ATTRIBUTE_READONLY)
			   ?: FILE_ATTRIBUTE_NORMAL;
      NtSetInformationFile (fh, &io,  &fbi, sizeof fbi, FileBasicInformation);
    }
d483 1
d485 1
a485 6
	{
	  /* Restore R/O attributes. */
	  fbi.FileAttributes = pc.file_attributes ();
	  NtSetInformationFile (fh, &io,  &fbi, sizeof fbi,
				FileBasicInformation);
	}
d492 1
a492 3
      fbi.FileAttributes = pc.file_attributes ();
      NtSetInformationFile (fh, &io,  &fbi, sizeof fbi,
			    FileBasicInformation);
d1717 3
a1719 1
  /* DELETE is required to rename a file. */
d1721 3
a1723 1
		     &io, FILE_SHARE_VALID_FLAGS,
d1763 2
a1764 8
      FILE_BASIC_INFORMATION fbi;
      fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart =
      fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
      fbi.FileAttributes = (dstpc->file_attributes ()
			    & ~FILE_ATTRIBUTE_READONLY)
			   ?: FILE_ATTRIBUTE_NORMAL;
      status = NtSetInformationFile (nfh, &io,  &fbi, sizeof fbi,
				     FileBasicInformation);
@


1.504
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d1611 2
a1612 1
  if (oldpc.objcaseinsensitive () && newpc.exists () && equal_path)
@


1.503
log
@	* syscalls.cc (rename): If newpath doesn't exist, check if .exe suffix
	in oldpath has been omitted before appending .exe to newpath.
@
text
@d3520 7
a3526 8
  if (pid < 0)
    goto err;
  close (other_fd);

  fhandler_pipe *fh = (fhandler_pipe *) cygheap->fdtab[fd];
  fh->set_popen_pid (pid);

  return fp;
@


1.502
log
@* cygwin.din (_getutline): Remove.
* lib/bsdlib.cc (login): Make argument const as per linux.
(logout): Ditto.
* syscalls.cc (getutid): Ditto.
(getutline): Ditto.
(pututline): Ditto.
(getutxent): Add comment mentioning non-thread-safety.
(getutxid): Ditto.
(getutxline): Ditto.
(pututxline): Ditto.
* sys/utmp.h: Declare arguments to various functions as const as per linux.
Remove bogus _getutline definition.
@
text
@d1659 1
a1659 1
      else if (oldpc.is_binary ()
d1662 2
a1663 1
	/* NOTE: No way to rename an executable foo.exe to foo. */
@


1.501
log
@	* Makefile.in (DLL_OFILES): Remove v8 regexp files.
	(OBSOLETE_FUNCTIONS): Remove v8 regexp functions.
	(NEW_FUNCTIONS): Remove POSIX regex functions.
	* cygwin.din: Export POSIX regex functions with their correct symbol
	name.  Export with posix_ prefix for backward compatibility.
	* syscalls.cc (regfree): Remove ancient fake function.
	* regex/regex.h: Remove renaming regex functions within Cygwin.
	* regexp/*: Remove.
	* include /cygwin/version,.h: Bump API minor number.
@
text
@d3101 1
a3101 1
getutid (struct utmp *id)
d3140 1
a3140 1
getutline (struct utmp *line)
d3163 1
a3163 1
pututline (struct utmp *ut)
d3187 4
a3190 1
  return ut;
d3208 1
d3216 1
d3229 1
d3242 1
@


1.500
log
@* dcrt0.cc (dll_crt0_0): Remove calling malloc_init and
user_shared_initialize_1 from here.
(dll_crt0_1): Remove dynamically_loaded check.  Just call malloc_init and
user_shared_initialize unconditionally.
* shared.cc (user_shared_create): Rename from user_shared_initialize.
(user_shared_initialize): Rename from user_shared_initialize_1.  Move complete
user_shared content initialization code here from user_shared_create.
* syscalls.cc (seteuid32): Remove call to user_shared_initialize_1.  That is
implied by the "true" argument to user_shared_create().
@
text
@a2403 7
/* FIXME: what is this? */
extern "C" int __declspec(dllexport)
regfree ()
{
  return 0;
}

@


1.499
log
@	* dcrt0.cc (dll_crt0_0): Call malloc_init and user_shared_initialize_1
	here in case we're dynamically loaded.  Explain why.
	(dll_crt0_1): Call user_shared_initialize_1 from here.
	* mount.cc (is_native_path): New inline function testing for native
	and long Win32 path prefix.
	(is_unc_share): Remove long WIn32 path prefix test.
	(mount_info::create_root_entry): Use PATH_MAX buffer.
	(mount_info::init): Ditto.
	(mount_info::add_item): Test for is_native_path as well.
	* path.cc (normalize_win32_path): Simplify native path prefix code.
	* shared.cc (user_shared_initialize_1): New function taking user
	shared initialization code relying on malloc and cygtls.
	(user_shared_initialize): Move mountinfo initialization to
	user_shared_initialize_1.
	* shared_info.h (user_shared_initialize_1): Declare.
	* syscalls.cc (seteuid32): Call user_shared_initialize_1 after user
	changed.
@
text
@d2615 2
a2616 4
    {
      user_shared_initialize (true);
      user_shared_initialize_1 ();
    }
@


1.498
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d2615 4
a2618 1
    user_shared_initialize (true);
@


1.497
log
@	* path.cc (cygwin_conv_path): Define tp before setting up faul handler.
	* syscalls.cc: Ditto, throughout.
	(gen_full_path_at): Add bool parameter to allow NULL pathname.
	(futimesat): Allow NULL pathname as GLIBC.
@
text
@d200 1
a200 1
  /* Open root directory. */
d1605 1
a1605 1
				      TRUE);
d1611 1
a1611 1
  if (newpc.exists () && equal_path)
d1649 1
a1649 1
				     TRUE))
d1677 1
a1677 1
				     TRUE))
d2779 2
a2780 1
      cygheap->root.set (path.normalized_path, path.get_win32 ());
@


1.496
log
@* string.h (strchr): Eliminate.
* syscalls.cc (rename): Work around inexplicable C++ warning.
@
text
@d3570 2
a3571 1
gen_full_path_at (char *path_ret, int dirfd, const char *pathname)
d3573 3
a3575 1
  if (!*pathname)
d3577 1
a3577 1
      set_errno (ENOENT);
d3580 1
a3580 1
  if (strlen (pathname) >= PATH_MAX)
d3582 10
a3591 2
      set_errno (ENAMETOOLONG);
      return -1;
d3593 1
a3593 1
  if (isdirsep (*pathname))
d3618 6
a3623 3
      if (p[-1] != '/')
        *p++ = '/';
      stpcpy (p, pathname);
d3631 1
a3634 1
  tmp_pathbuf tp;
d3651 1
a3656 1
  tmp_pathbuf tp;
d3682 1
a3685 1
  tmp_pathbuf tp;
d3696 1
a3699 1
  tmp_pathbuf tp;
d3710 1
a3713 1
  tmp_pathbuf tp;
d3726 1
a3729 1
  tmp_pathbuf tp;
d3742 1
a3745 1
  tmp_pathbuf tp;
d3747 1
a3747 1
  if (gen_full_path_at (path, dirfd, pathname))
d3757 1
a3760 1
  tmp_pathbuf tp;
d3783 1
a3786 1
  tmp_pathbuf tp;
d3796 1
a3799 1
  tmp_pathbuf tp;
d3809 1
a3812 1
  tmp_pathbuf tp;
d3822 1
a3825 1
  tmp_pathbuf tp;
d3836 1
a3839 1
  tmp_pathbuf tp;
d3852 1
a3855 1
  tmp_pathbuf tp;
d3865 1
a3868 1
  tmp_pathbuf tp;
@


1.495
log
@	* syscalls.cc (FILTERED_MODE): Define valid chmod mode mask.
	(chmod): Call fh->fchmod with filtered mode.
	(fchmod): Ditto.
@
text
@d1508 1
a1508 1
  NTSTATUS status;
@


1.494
log
@	* syscalls.cc (rename): Fix condition when to start a transaction.
@
text
@d1122 3
d1140 1
a1140 1
    res = fh->fchmod (mode);
d1160 1
a1160 1
  return cfd->fchmod (mode);
@


1.493
log
@	* syscalls.cc (rename): Allocate temporary path buffers using
	tmp_pathbuf.  Don't try to unset R/O attribute on dstpc if a
	removepc exists.  dstpc is a non-existant file in that case.
@
text
@d1721 2
a1722 1
      && (dstpc->isdir () || dstpc->has_attribute (FILE_ATTRIBUTE_READONLY)))
@


1.492
log
@	* syscalls.cc (rename): ONly start transaction if FS supports them.
@
text
@d1497 1
d1537 1
a1537 1
      stpcpy (oldbuf = (char *) alloca (olen + 1), oldpath);
d1572 1
a1572 1
      stpcpy (newbuf = (char *) alloca (nlen + 1), newpath);
d1750 4
a1753 2
     attribute set.  Remove the R/O attribute first. */
  else if (dstpc->has_attribute (FILE_ATTRIBUTE_READONLY))
d1820 4
a1823 1
  pfri = (PFILE_RENAME_INFORMATION) alloca (size);
@


1.491
log
@	* autoload.cc (LoadDLLfuncNt): Re-invent.
	(NtCreateTransaction): Define.
	(NtCommitTransaction): Define.
	(NtRollbackTransaction): Define.
	(RtlGetCurrentTransaction): Define.
	(RtlSetCurrentTransaction): Define.
	* ntdll.h (TRANSACTION_ALL_ACCESS): Define.
	(NtCreateTransaction): Declare.
	(NtCommitTransaction): Declare.
	(NtRollbackTransaction): Declare.
	(RtlGetCurrentTransaction): Declare.
	(RtlSetCurrentTransaction): Declare.
	* syscalls.cc (start_transaction): New static function to start TxF
	transaction.
	(stop_transaction): New static function to end TxF transaction.
	(rename): Call start_transaction and stop_transaction where appropriate
	on systems supporting transactions.
	* wincap.h (wincaps::has_transactions): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d1719 1
d1833 3
a1835 1
      if (wincap.has_transactions () && !trans)
@


1.490
log
@	* syscalls.cc (rename): Use volume serial numbers stored in path_conv
	rather than fetching them here for the "same file" test.  Change
	comment to reflect this.
@
text
@d1464 30
d1506 1
d1715 7
d1830 30
a1859 3
  if (status == STATUS_ACCESS_DENIED && dstpc->exists () && !dstpc->isdir ()
      && NT_SUCCESS (status = unlink_nt (*dstpc)))
    status = NtSetInformationFile (fh, &io, pfri, size, FileRenameInformation);
d1872 2
@


1.489
log
@	* cygwin.din (futimens): Export.
	(utimensat): Export.
	* fhandler.cc (fhandler_base::utimens): Replace fhandler_base::utimes.
	Call utimens_fs.
	* fhandler.h (class fhandler_base): Declare utimens_fs instead of
	utimes_fs, utimens instead of utimes.
	(class fhandler_disk_file): Declare utimens instead of utimes.
	* fhandler_disk_file.cc (fhandler_disk_file::utimens): Replace
	fhandler_disk_file::utimes.
	(fhandler_base::utimens_fs): Replace fhandler_base::utimes_fs.
	Implement tv_nsec handling according to SUSv4.
	* syscalls.cc (utimensat): New function.
	* times.cc (timespec_to_filetime): New function.
	(timeval_to_timespec): New function.
	(utimens_worker): Replace utimes_worker.
	(utimes): Convert timeval to timespec and call utimens_worker.
	(lutimes): Ditto.
	(futimens): Take over implementation from futimes.
	(futimes): Convert timeval to timespec and call futimens.
	* winsup.h (timespec_to_filetime): Declare.
	* include/cygwin/version.h: Bump API minor number.
	* posix.sgml: Add SUSv4 section.  Add futimens and utimensat to it.
@
text
@d1743 5
a1747 4
     The test tries to be as quick as possible.  First it tests if oldpath
     has more than 1 hardlink, then it opens newpath and tests for identical
     file ids.  If so, it tests for identical volume serial numbers,  If so,
     oldpath and newpath refer to the same file. */
d1750 1
a1760 2
      static const size_t vsiz = sizeof (FILE_FS_VOLUME_INFORMATION)
				 + 32 * sizeof (WCHAR);
a1761 1
      PFILE_FS_VOLUME_INFORMATION opffvi, npffvi;
d1767 1
a1767 8
	  && ofii.FileId.QuadPart == nfii.FileId.QuadPart
	  && (opffvi = (PFILE_FS_VOLUME_INFORMATION) alloca (vsiz))
	  && (npffvi = (PFILE_FS_VOLUME_INFORMATION) alloca (vsiz))
	  && NT_SUCCESS (NtQueryVolumeInformationFile (fh, &io, opffvi, vsiz,
						    FileFsVolumeInformation))
	  && NT_SUCCESS (NtQueryVolumeInformationFile (nfh, &io, npffvi, vsiz,
						    FileFsVolumeInformation))
	  && opffvi->VolumeSerialNumber == npffvi->VolumeSerialNumber)
@


1.488
log
@	* cygwin.din: Sort.
	(faccessat): Export.
	(fchmodat): Export.
	(fchownat): Export.
	(fstatat): Export.
	(futimesat): Export.
	(linkat): Export.
	(mkdirat): Export.
	(mkfifoat): Export.
	(mknodat): Export.
	(openat): Export.
	(readlinkat): Export.
	(renameat): Export.
	(symlinkat): Export.
	(unlinkat): Export.
	* path.cc (readlink): Align definition to POSIX.
	* syscalls.cc (gen_full_path_at): New static function.
	(faccessat): Implement.
	(fchmodat): Implement.
	(fchownat): Implement.
	(fstatat): Implement.
	(futimesat): Implement.
	(linkat): Implement.
	(mkdirat): Implement.
	(mkfifoat): Implement.
	(mknodat): Implement.
	(openat): Implement.
	(readlinkat): Implement.
	(renameat): Implement.
	(symlinkat): Implement.
	(unlinkat): Implement.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d3634 19
@


1.487
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Simplify
	code which checks for symlinks.  Fix problem with UNC paths.

	* environ.cc (struct parse_thing): Remove transparent_exe option.
	* syscalls.cc (transparent_exe): Remove.
	(unlink): Always add stat_suffixes, drop transparent_exe check.
	(open): Ditto.
	(link): Ditto.
	(pathconf): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Ditto.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Always remove
	.exe suffix.
	* path.cc (realpath): Never attach known_suffix.
@
text
@d64 1
d3494 275
@


1.486
log
@	* cygwin.din (wprintf): Remove.
	(_wprintf): Ditto.
	* syscalls.cc (wprintf): Ditto.
	* include/cygwin/version.h: Add FIXME comment.
@
text
@a80 2
bool transparent_exe = false;

d518 1
a518 2
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW,
			transparent_exe ? stat_suffixes : NULL);
d885 1
a885 1
				    transparent_exe ? stat_suffixes : NULL)))
d1010 1
a1010 2
  if (!(fh = build_fh_name (oldpath, NULL, PC_SYM_NOFOLLOW,
			    transparent_exe ? stat_suffixes : NULL)))
d1902 1
a1902 2
  if (!(fh = build_fh_name (file, NULL, PC_SYM_FOLLOW,
			    transparent_exe ? stat_suffixes : NULL)))
@


1.485
log
@Remove unneeded header files from source files throughout.
@
text
@a2731 15
/* FIXME: to do this right, maybe work out the usoft va_list machine
   and use wsvprintfW instead?
*/
extern "C" int
wprintf (const char *fmt, ...)
{
  va_list ap;
  int ret;

  va_start (ap, fmt);
  ret = vprintf (fmt, ap);
  va_end (ap);
  return ret;
}

@


1.484
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a30 2
#include <pwd.h>
#include <grp.h>
a36 1
#include <errno.h>
a37 1
#include <limits.h>
a38 1
#include <setjmp.h>
a39 4
#include <winnls.h>
#include <wininet.h>
#include <winioctl.h>
#include <lmcons.h> /* for UNLEN */
a40 2
#include <shellapi.h>
#include <ntdef.h>
a49 1
#include <sys/cygwin.h>
@


1.483
log
@	Cleanup.
	* exceptions.cc (windows_system_directory): Make static.  Convert to
	WCHAR.
	(_cygtls::inside_kernel): Accommodate above change.  Check module
	path name for leading \\?\ and skip, if so.
	(try_to_debug): Call GetEnvironmentStringsW and convert evaluation to
	WCHAR to avoid truncated environment problem.
	(has_visible_window_station): Call GetUserObjectInformationW.
	(events_init): Accommodate above conversion of windows_system_directory.
	* init.cc (respawn_wow64_process): Use WCHAR functions to start new
	process.
	* net.cc (__dup_ent): Drop Windows 9x consideration.
	(load_ipv6_funcs): Use WCHAR functions to load IPv6 libs.
	* syscalls.cc (syscalls.cc): Remove call to GetDiskFreeSpace.
@
text
@d27 1
@


1.482
log
@	* Fix copyright dates.
@
text
@a3301 2
  if (GetLastError () == ERROR_PROC_NOT_FOUND)
    GetDiskFreeSpace ("C:\\", NULL, NULL, NULL, (DWORD *)&data[11]);
@


1.481
log
@	Throughout, call fcntl64 instead of fcntl or fcntl_worker.
	* fcntl.cc (fcntl_worker): Remove.
	(fcntl64): Add fault handler.  Move fcntl_worker stuff here.  Add case
	for locking and call fhandler's lock method directly.  Make sure that
	F_FLOCK flag isn't set in lock call.
	(_fcntl): Add fault handler.
	* fhandler.cc (fhandler_base::fcntl): Drop lock cases.
	* flock.cc (flock): Add fault handler.  Simplify code.  Call fhandlers
	lock method directly instead of fcntl_worker.  Add debug output.
	(lockf): Add fault handler.  Call fhandlers lock method directly
	instead of fcntl_worker.  Add debug output.
	* winsup.h (fcntl_worker): Drop declaration.
	(fcntl64): Declare.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.480
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@d2943 1
a2943 1
	&& fcntl_worker (fd, F_SETLKW, &lock_buffer) != -1)
d2948 1
a2948 1
	fcntl_worker (fd, F_SETLK, &lock_buffer);
d3455 1
a3455 1
  fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
d3470 2
a3471 2
    int state = fcntl (stdwhat, F_GETFD, 0);
    fcntl (stdwhat, F_SETFD, state | FD_CLOEXEC);
d3474 1
a3474 1
    fcntl (stdwhat, F_SETFD, state);
@


1.479
log
@	* syscalls.cc (rename): Fix setting errno in case of trailing "/."
@
text
@d1207 1
a1207 1
	    buf->st_ino = cfd->get_namehash ();
d1370 1
a1370 1
	    buf->st_ino = fh->get_namehash ();
@


1.478
log
@* hookapi.cc (find_first_notloaded_dll): New function.
* pinfo.cc (status_exit): New function.  Issue message when dll not found.  Use
find_first_notloaded_dll to find a nonexistent dll.
(pinfo::maybe_set_exit_code_from_windows): Call status_exit when exit code >=
0xc0000000UL.
* sigproc.cc (child_info::proc_retry): Return exit code when
STATUS_DLL_NOT_FOUND.
* spawn.cc (spawn_guts): Minor cleanup.
* syscalls.cc (close_all_files): Don't actually close stderr filehandle.  Just
make it noninheritable.
* winsup.h (find_first_notloaded_dll): Declare new function.
* ntdll.h: Add several missing NTSTATUS defines.
@
text
@d1500 1
a1500 2
  if (has_dot_last_component (oldpath, true)
      || has_dot_last_component (newpath, true))
d1502 8
a1509 1
      set_errno (EINVAL);
@


1.477
log
@	* syscalls.cc (rename): Just return with 0 if filenames are identical,
	per POSIX.  Drop comment added in previous patch.
@
text
@d112 2
d120 3
d131 2
@


1.476
log
@	* syscalls.cc (rename): Handle a special case of trying to rename a
	mount point.
@
text
@d1576 1
a1576 4
     "file doesn't exist"), all later tests are skipped.
     If not, it's a request to change the case of the name of a mount
     point.  If we don't catch this here, the underlying directory would
     be deleted, if it happens to be empty. */
d1583 1
a1583 1
	  set_errno (EACCES);
@


1.475
log
@	* syscalls.cc (sync): Use MAX_PATH rather than CYG_MAX_PATH.
@
text
@d1576 7
a1582 4
     "file doesn't exist"), all later tests are skipped. */
  if (newpc.exists ()
      && equal_path
      && !RtlEqualUnicodeString (oldpc.get_nt_native_path (),
d1585 6
a1590 1
    newpc.file_attributes (INVALID_FILE_ATTRIBUTES);
@


1.474
log
@	* fhandler.cc (fhandler_base::open): Use %S for PUNICODE_STRING.
	* syscalls.cc (setmode): Ditto.
@
text
@d1275 2
a1276 1
  char vol[CYG_MAX_PATH];
d1280 2
a1281 2
      char a_drive[CYG_MAX_PATH] = {0};
      char b_drive[CYG_MAX_PATH] = {0};
d1284 1
a1284 1
	GetVolumeNameForVolumeMountPointA ("A:\\", a_drive, CYG_MAX_PATH);
d1286 1
a1286 1
	GetVolumeNameForVolumeMountPointA ("B:\\", b_drive, CYG_MAX_PATH);
d1288 1
a1288 1
      HANDLE sh = FindFirstVolumeA (vol, CYG_MAX_PATH);
d1306 1
a1306 1
	  while (FindNextVolumeA (sh, vol, CYG_MAX_PATH));
@


1.473
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d2056 1
a2056 1
  syscall_printf ("(%d<%s>, %p) returning %s", fd,
@


1.472
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d2339 1
a2339 1
  char buf[sizeof (":\\00000000:00000000:00000000") + CYG_MAX_PATH];
d2357 1
a2357 1
  if (strlen (path) >= CYG_MAX_PATH)
d3330 1
a3330 1
  static char buf[CYG_MAX_PATH];
d3345 1
a3345 1
       ch != EOF && !isspace (ch) && buf_idx < CYG_MAX_PATH;
d3349 1
a3349 1
     path is longer than CYG_MAX_PATH, it's invalid anyway. */
@


1.471
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d186 1
a186 1
    RtlAppendUnicodeToString (&recycler, L"\\RECYCLER\\");	
d188 1
a188 1
    RtlAppendUnicodeToString (&recycler, L"\\Recycled\\");	
d290 1
a290 1
         create it if not. */
d292 1
a292 1
        {
d309 1
a309 1
         Windows Explorer.  Otherwise, the created bin is treated as
d312 1
a312 1
        {
d329 1
a329 1
	        debug_printf ("NtWriteFile (%S) failed, %08x", &fname, status);
d458 1
a458 1
	        {
d1507 1
a1507 1
        oldbuf[--olen] = '\0';
d1542 1
a1542 1
        newbuf[--nlen] = '\0';
d1596 1
a1596 1
	  		+ oldpc.get_nt_native_path ()->Length) == L'\\')
d1618 1
a1618 1
      	rename_append_suffix (newpc, newpath, nlen, ".lnk");
d1623 1
a1623 1
      	rename_append_suffix (newpc, newpath, nlen, ".exe");
d1644 1
a1644 1
        {
d1661 1
a1661 1
      	}
d1663 1
a1663 1
        {
d1715 1
a1715 1
        {
d1729 1
a1729 1
        {
d1752 1
a1752 1
		     	? FILE_OPEN_REPARSE_POINT : 0))))
@


1.470
log
@* syscalls.cc (_isatty): Define as an alias to isatty to override newlib
version.
* thread.cc (pthread_kill): Deal with signal 0 as per POSIX and also avoid
manipulating an invalid thread.
@
text
@d2486 1
a2486 1
      char name[128];
@


1.469
log
@	* string.h: Re-enable inline strcasematch and strncasematch
	implementations and rename to ascii_strcasematch/ascii_strncasematch.
	* dcrt0.cc: Replace str[n]casematch with ascii_str[n]casematch where
	applicable.
	* environ.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
	* winf.cc: Ditto.
@
text
@d1002 1
@


1.468
log
@	* fhandler_tape.cc (mtinfo::initialize): Use MAX_PATH instead of
	CYG_MAX_PATH.
	* fhandler_tty.cc (fhandler_pty_master::ptsname): Set buffer size to
	TTY_NAME_MAX.
	* syscalls.cc (ttyname): Eliminate the `+ 1' from the name buffer size
	since TTY_NAME_MAX already counts the trailing NUL.
	* libc/bsdlib.cc (openpty): Set pts buffer size to TTY_NAME_MAX.
@
text
@d1462 2
a1463 2
  if (strcasematch (path + len - 4, ".lnk")
      || strcasematch (path + len - 4, ".exe"))
d1532 2
a1533 2
      && (strcasematch (oldpath + olen - 4, ".lnk")
	  || strcasematch (oldpath + olen - 4, ".exe")))
d1562 2
a1563 2
      && (strcasematch (newpath + nlen - 4, ".lnk")
	  || strcasematch (newpath + nlen - 4, ".exe")))
@


1.467
log
@* dllfixdbg: Eliminate extra objcopy step.
@
text
@d1934 2
a1935 2
  static char name[TTY_NAME_MAX + 1];
  int ret = ttyname_r (fd, name, TTY_NAME_MAX + 1);
@


1.466
log
@	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.
@
text
@a745 2
      sig_dispatch_pending ();

a814 1
  sig_dispatch_pending ();
@


1.465
log
@	* syscalls.cc (unlink_nt): Drop one local FILE_BASIC_INFORMATION struct.
@
text
@d892 3
a894 2
	  if (!(fh = build_fh_name (unix_path, NULL, (flags & O_NOFOLLOW) ?
				    PC_SYM_NOFOLLOW : PC_SYM_FOLLOW,
@


1.464
log
@	* path.h (path_conv::operator char *): Delete.
	(path_conv::operator const char *): Delete.
	* dlfcn.cc: Throughout, replace path_conv::operator char * and
	path_conv::operator const char * by call to path_conv::get_win32
	for easier transition to UNICODE_PATHs.
	* fhandler_socket.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@a481 1
      FILE_BASIC_INFORMATION fbi;
@


1.463
log
@	* dir.cc (readdir_worker): Convert w32name to PUNICODE_STRING.
	* sec_acl.cc (getacl): Convert debug output to print native NT path.
	* security.cc (set_file_attribute): Ditto.
	* syscalls.cc (try_to_bin): Ditto and fix buggy debug statement.
@
text
@d1128 1
a1128 1
  return mknod_worker (pc, pc.dev.mode & S_IFMT, mode, pc.dev.major, pc.dev.minor);
d2398 1
a2398 1
  return mknod_worker (w32path, type, mode, major, minor);
d2705 1
a2705 1
      cygheap->root.set (path.normalized_path, path);
@


1.462
log
@	* path.cc (get_nt_native_path): Allow to convert special paths which
	have no native NT path representation for simplified debug output.
	* syscalls.cc: Convert debug output to print native NT path.
	(unlink): Drop redundant debug output.
@
text
@d361 2
a362 2
    debug_printf ("Move %s to %s failed, status = %p", win32_path.get_win32 (),
		  recycler, status);
@


1.461
log
@	* Makefile.in (DLL_OFILES): Remove delqueue.o.
	* delqueue.cc: Delete.
	* fhandler.h (fhandler_base::close_fs): Drop declaration.
	(fhandler_disk_file::close): Drop declaration.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Call close instead of
	close_fs.
	(fhandler_base::fstat_helper): Use open FH_UNIX handle in call to
	get_file_attribute.
	(fhandler_base::open_fs): Call close instead of get_file_attribute.
	(fhandler_disk_file::close): Remove.
	(fhandler_base::close_fs): Remove.
	* fhandler_socket.cc (fhandler_socket::close): Just call
	fhandler_base::close for FH_UNIX sockets.
	* shared.cc (user_shared_initialize): Drop call to
	user_shared->delqueue.init.
	* shared_info.h (CURR_USER_MAGIC): Change according to below change.
	(MAX_DELQUEUES_PENDING): Remove.
	(class delqueue_list): Remove.
	(class user_info): Remove delqueue.
	* syscalls.cc (close_all_files): Drop call to
	user_shared->delqueue.process_queue.
	(unlink): Drop delqueue handling.
@
text
@a540 2
  syscall_printf ("_unlink (%s)", win32_name.get_win32 ());

d1357 2
a1358 2
      debug_printf ("(%s, %p, %p), file_attributes %d",
		    pc.normalized_path, buf, fh, (DWORD) *fh);
d1377 1
a1377 1
  syscall_printf ("%d = (%s, %p)", res, pc.normalized_path ?: "", buf);
d2058 3
a2060 2
  syscall_printf ("(%d<%s>, %p) returning %s", fd, cfd->get_name (),
		  mode, res & O_TEXT ? "text" : "binary");
@


1.460
log
@	* syscalls.cc (getw): Remove redundant implementation.
	(putw): Ditto.
	(wcscmp): Ditto.
	(wcslen): Ditto.
	(memccpy): Ditto.
@
text
@a126 1
  user_shared->delqueue.process_queue ();
d560 1
a560 12
    {
      /* FIXME: Can we get rid of the delqueue now? */
      if (status == STATUS_SHARING_VIOLATION)
	{
	  /* Add file to the "to be deleted" queue. */
	  syscall_printf ("Sharing violation, couldn't delete file");
	  user_shared->delqueue.queue_file (win32_name);
	  res = 0;
	}
      else
	__seterrno_from_nt_status (status);
    }
@


1.459
log
@	* ntdll.h: Add descriptive comments to special Rtl functions.
	(STATUS_OBJECT_PATH_NOT_FOUND): Define.
	(STATUS_BUFFER_OVERFLOW): Define.
	(FILE_SUPERSEDED): Define.
	(FILE_OPENED): Define.
	(FILE_CREATED): Define.
	(FILE_OVERWRITTEN): Define.
	(FILE_EXISTS): Define.
	(FILE_DOES_NOT_EXIST): Define.
	(PIO_APC_ROUTINE): Typedef.
	(NtFsControlFile): Fix parameter types to use PIO_APC_ROUTINE.
	(NtWriteFile): Declare.
	(RtlInt64ToHexUnicodeString): Declare.
	* strfuncs.cc: Include ntdll.h.
	(RtlInt64ToHexUnicodeString): New function.
	* syscalls.cc (try_to_bin): Rewrite using native NT functions.
	Only try to create recycle bin after unsuccessfully trying to move
	file.  Also try to create special files in recycle bin so that Windows
	Explorer isn't unnecessarily stampeded.
@
text
@a2738 39
extern "C" int
getw (FILE *fp)
{
  int w, ret;
  ret = fread (&w, sizeof (int), 1, fp);
  return ret != 1 ? EOF : w;
}

extern "C" int
putw (int w, FILE *fp)
{
  int ret;
  ret = fwrite (&w, sizeof (int), 1, fp);
  if (feof (fp) || ferror (fp))
    return -1;
  return 0;
}

extern "C" int
wcscmp (const wchar_t *s1, const wchar_t *s2)
{
  while (*s1  && *s1 == *s2)
    {
      s1++;
      s2++;
    }

  return (* (unsigned short *) s1) - (* (unsigned short *) s2);
}

extern "C" size_t
wcslen (const wchar_t *s1)
{
  int l = 0;
  while (s1[l])
    l++;
  return l;
}

a2760 17
extern "C" _PTR
memccpy (_PTR out, const _PTR in, int c, size_t len)
{
  const char *inc = (char *) in;
  char *outc = (char *) out;

  while (len)
    {
      char x = *inc++;
      *outc++ = x;
      if (x == c)
	return outc;
      len --;
    }
  return 0;
}

@


1.458
log
@	* syscalls.cc (rename): Check oldpath and newpath for trailing dir
	separators, require them to be existing directories if so.  Check
	for a request to change only the case of the filename.  Check paths
	for case insensitve equality only once.  Handle renaming a directory
	to another, existing directory by unlinking the destination directory
	first.  If newpath points to an existing file with R/O attribute set,
	try to unset R/O attribute first.  Augment hardlink test by not
	checking directories.  If renaming fails with STATUS_ACCESS_DENIED,
	try to unlink existing destination filename and try renaming again.
	Drop useless test for non-empty directory.  Always close fh at the
	end of the function.
@
text
@d142 8
d154 1
d156 8
a163 1
  char recycler[CYG_MAX_PATH + 20];
d165 4
a168 3
  rootdir (win32_path, recycler);
  char *c = recycler + strlen (recycler);
  if (wincap.has_recycle_dot_bin ())
d170 3
a172 2
      strcpy (c, "$Recycle.Bin");	/* NTFS and FAT since Vista */
      c += 12;
d174 37
a210 1
  else if (win32_path.fs_is_ntfs ())
d212 2
a213 2
      strcpy (c, "RECYCLER");		/* NTFS up to 2K3 */
      c += 8;
d215 10
a224 1
  else if (win32_path.fs_is_fat ())
d226 10
a235 2
      strcpy (c, "Recycled");		/* FAT up to 2K3 */
      c += 8;
d237 6
a242 7
  else
    return;

  /* Yes, we can really do that.  Typically the recycle bin is created
     by the first user actually using the bin.  The permissions are the
     default permissions propagated from the root directory. */
  if (GetFileAttributes (recycler) == INVALID_FILE_ATTRIBUTES)
d244 21
a264 1
      if (!CreateDirectory (recycler, NULL))
d266 2
a267 2
	  debug_printf ("Can't create folder %s, %E", recycler);
	  return;
d269 65
a333 22
      SetFileAttributes (recycler,
      			 FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
    }

  /* Up to Windows 2003 Server, the default settings for the top level recycle
     bin are so that everybody has the right to create files in it.  Starting
     with Vista, users are by default not allowed to create files in that
     directory, only subdirectories.  Too bad, but that requires to move
     files to the user's own recycler subdir.  Instead of adding yet another
     special case, we just move the stuff to the user's recycler, especially
     since only shared files are moved at all. */
  if (win32_path.fs_is_ntfs ())
    {
      *c++ = '\\';
      cygheap->user.get_windows_id (c);
      while (*c)
       ++c;
      if (GetFileAttributes (recycler) == INVALID_FILE_ATTRIBUTES)
	{
	  if (!CreateDirectory (recycler,
				sec_user ((PSECURITY_ATTRIBUTES) alloca (1024),
					  cygheap->user.sid ())))
d335 19
a353 2
	      debug_printf ("Can't create folder %s, %E", recycler);
	      return;
a354 2
	  SetFileAttributes (recycler,
			     FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
d356 4
a360 18

  /* Create hopefully unique filename. */
  __small_sprintf (c, "\\cyg%016X", hash_path_name (myself->uid,
						    win32_path.get_win32 ()));
  c += 20;

  /* Length of the WCHAR path in bytes. */
  ULONG len = 2 * (c - recycler);
  /* Choose size big enough to fit a local native NT path into it. */
  ULONG size = sizeof (FILE_RENAME_INFORMATION) + len + 10;
  PFILE_RENAME_INFORMATION pfri = (PFILE_RENAME_INFORMATION) alloca (size);

  pfri->ReplaceIfExists = TRUE;
  pfri->RootDirectory = NULL;
  UNICODE_STRING uname = { 0, len + 10, pfri->FileName };
  get_nt_native_path (recycler, uname);
  pfri->FileNameLength = uname.Length;
  status = NtSetInformationFile (h, &io, pfri, size, FileRenameInformation);
d364 3
@


1.457
log
@	* syscalls.cc (rename): Close oldpath file handle immediately after
	trying to rename it.  Use nfh handle when checking for non-empty
	newpath directory.  Only change status if check_dir_not_empty really
	returns STATUS_DIRECTORY_NOT_EMPTY.
@
text
@d1353 1
d1355 1
d1358 1
d1360 1
a1360 1
  HANDLE fh, nfh;
d1378 12
d1406 5
a1410 1
  olen = strlen (oldpath);
d1416 9
d1436 5
a1440 1
  nlen = strlen (newpath);
d1446 16
a1461 1
  if (oldpc.isdir ())
d1483 1
a1483 4
      if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
				 newpc.get_nt_native_path (),
				 TRUE)
	  && old_explicit_suffix != new_explicit_suffix)
d1511 1
a1511 4
      if (RtlEqualUnicodeString (oldpc.get_nt_native_path (),
				 newpc.get_nt_native_path (),
				 TRUE)
	  && old_explicit_suffix != new_explicit_suffix)
d1568 46
d1622 1
a1652 1
	  NtClose (fh);
d1667 10
a1676 1
  NtClose (fh);
d1684 1
a1684 17
    {
      /* Check in case of STATUS_ACCESS_DENIED and pc.isdir(),
         whether we tried to rename to an existing non-empty dir.
	 In this case we have to set errno to EEXIST. */
      if (status == STATUS_ACCESS_DENIED && dstpc->isdir ()
	  && NT_SUCCESS (NtOpenFile (&nfh, FILE_LIST_DIRECTORY | SYNCHRONIZE,
				    dstpc->get_object_attr (attr, sec_none_nih),
				    &io, FILE_SHARE_VALID_FLAGS,
				    FILE_OPEN_FOR_BACKUP_INTENT
				    | FILE_SYNCHRONOUS_IO_NONALERT)))
	{
	  if (check_dir_not_empty (nfh) == STATUS_DIRECTORY_NOT_EMPTY)
	    status = STATUS_DIRECTORY_NOT_EMPTY;
	  NtClose (nfh);
	}
      __seterrno_from_nt_status (status);
    }
d1687 2
@


1.456
log
@	* fhandler_disk_file.cc (readdir_get_ino): Accommodate native symlinks.
	* syscalls.cc (rename): Ditto.
@
text
@d1580 1
d1593 1
a1593 1
	  && NT_SUCCESS (NtOpenFile (&fh, FILE_LIST_DIRECTORY | SYNCHRONIZE,
d1599 3
a1601 2
	  status = check_dir_not_empty (fh);
	  NtClose (fh);
a1604 1
  NtClose (fh);
@


1.455
log
@	* syscalls.cc (rename): Move and add text to comment about testing
	oldpath and newpath referring to the same file.  Test if oldpath
	has more than one hardlink before opening oldpath (idea by Eric Blake).
	Reorder test so that file id is tested before volume serial number.
@
text
@d1519 3
a1521 1
		     &io, FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
d1540 4
a1543 1
		     &io, FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT)))
@


1.454
log
@	* path.h (struct fs_info): Drop root_len and name_hash members.
	(fsinfo::length): Remove.
	(path_conv::rootdir): Remove.
	* syscalls.cc (try_to_bin): Use rootdir function instead of
	path_conv::rootdir method.
@
text
@d1361 1
d1525 7
d1533 3
d1540 2
a1541 5
      size_t size = sizeof (FILE_FS_VOLUME_INFORMATION) + 32 * sizeof (WCHAR);
      PFILE_FS_VOLUME_INFORMATION opffvi = (PFILE_FS_VOLUME_INFORMATION)
					   alloca (size);
      PFILE_FS_VOLUME_INFORMATION npffvi = (PFILE_FS_VOLUME_INFORMATION)
					   alloca (size);
d1543 1
d1545 8
a1552 4
      /* SUSv3: If the old argument and the new argument resolve to the same
	 existing file, rename() shall return successfully and perform no
	 other action. */
      if (NT_SUCCESS (NtQueryVolumeInformationFile (fh, &io, opffvi, size,
d1554 1
a1554 1
	  && NT_SUCCESS (NtQueryVolumeInformationFile (nfh, &io, npffvi, size,
d1556 1
a1556 6
	  && opffvi->VolumeSerialNumber == npffvi->VolumeSerialNumber
	  && NT_SUCCESS (NtQueryInformationFile (fh, &io, &ofii, sizeof ofii,
						    FileInternalInformation))
	  && NT_SUCCESS (NtQueryInformationFile (nfh, &io, &nfii, sizeof nfii,
	  					    FileInternalInformation))
	  && ofii.FileId.QuadPart == nfii.FileId.QuadPart)
@


1.453
log
@	* syscalls.cc (rename): Check if oldpath and newpath refer to the
	same file.  If so, return successfully and perform no other action,
	as per SUSv3.
@
text
@d149 2
a150 1
  char *c = recycler + win32_path.rootdir (recycler);
@


1.452
log
@	* ntdll.h (STATUS_ACCESS_DENIED): Define.
	* syscalls.cc (check_dir_not_empty): New static function.
	(unlink_nt): Move code checking for non-empty dir to check_dir_not_empty
	and call check_dir_not_empty instead.
	(rename): Add fault handler.  Check oldpath and newpath for trailing
	. and .. path components and return EINVAL if so.  Check oldpath
	for being on a vrtual file system.  If renaming a dir fails with
	STATUS_ACCESS_DENIED, check if the target dir is non-empty and return
	ENOTEMPTY if so.
@
text
@d1356 1
a1356 1
  HANDLE fh;
d1523 34
@


1.451
log
@	* syscalls.cc (rename): Use unchanged path_conv in condition.
@
text
@d231 32
d319 1
a319 7
	      const ULONG bufsiz = 3 * sizeof (FILE_NAMES_INFORMATION)
				   + 3 * NAME_MAX * sizeof (WCHAR);
	      PFILE_NAMES_INFORMATION pfni = (PFILE_NAMES_INFORMATION)
					     alloca (bufsiz);
	      status = NtQueryDirectoryFile (fh, NULL, NULL, 0, &io, pfni,
					     bufsiz, FileNamesInformation,
					     FALSE, NULL, TRUE);
a322 2
		  syscall_printf ("Checking if directory is empty failed, "
				  "status = %p", status);
a324 13
	      int cnt = 1;
	      while (pfni->NextEntryOffset)
	        {
		  pfni = (PFILE_NAMES_INFORMATION)
			 ((caddr_t) pfni + pfni->NextEntryOffset);
		  ++cnt;
		}
	      if (cnt > 2)
	        {
		  NtClose (fh);
		  syscall_printf ("Directory not empty");
		  return STATUS_DIRECTORY_NOT_EMPTY;
		}
d1361 12
a1372 1
  
d1384 5
d1401 1
a1401 1
  if (newpc.isspecial ()) /* No renames out of the FS */
d1539 16
a1554 1
    __seterrno_from_nt_status (status);
@


1.450
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Revert to checking
	for binary in case of .exe files.
	* ntdll.h (RtlPrefixUnicodeString): Declare.
	* path.cc (path_conv::is_binary): New method.
	* path.h (path_conv::is_binary): Declare.
	* syscalls.cc (rename_append_suffix): New static helper function for
	rename.
	(rename): Rewrite.  New suffix tests.  Use native NT functions.
@
text
@d1481 1
a1481 1
	      if (newpc.is_binary () || newpc.is_lnk_symlink ())
d1487 1
a1487 1
  
@


1.449
log
@	* syscalls.cc (stat_worker): Don't call build_fh_pc with invalid pc.
@
text
@d1324 13
d1340 13
a1352 8
  int res = 0;
  char *lnk_suffix = NULL;
  bool no_lnk_file_exists = false;

  path_conv real_old (oldpath, PC_SYM_NOFOLLOW,
		      transparent_exe ? stat_suffixes : NULL);

  if (real_old.error)
d1354 2
a1355 3
      syscall_printf ("-1 = rename (%s, %s)", oldpath, newpath);
      set_errno (real_old.error);
      return -1;
d1357 1
a1357 2

  if (!real_old.exists ()) /* file to move doesn't exist */
a1358 1
      syscall_printf ("file to move doesn't exist");
d1360 1
a1360 1
      return -1;
d1362 5
d1368 16
a1383 2
  path_conv real_new (newpath, PC_SYM_NOFOLLOW,
		      transparent_exe ? stat_suffixes : NULL);
d1385 1
a1385 2
  char new_buf[CYG_MAX_PATH + 5];
  if (!real_new.error && !real_new.case_clash)
d1387 1
a1387 4
      DWORD bintype;
      int len;

      if (real_old.is_lnk_special ())
d1389 2
a1390 20
	  if (real_new.exists ())
	    {
	      /* This early directory test is necessary because the below test
		 tests against the name with attached .lnk suffix.  To avoid
		 name collisions, we shouldn't rename a file to "foo.lnk"
		 if a "foo" directory exists. */
	      if (real_new.isdir ())
		{
		  syscall_printf ("newpath is directory, but oldpath is not");
		  set_errno (EISDIR);
		  return -1;
		}
	      /* Shortcut hack, No. 3, part 1 */
	      no_lnk_file_exists = true;
	    }
	  /* Shortcut hack. */
	  strcpy (new_buf, newpath);
	  strcat (new_buf, ".lnk");
	  newpath = new_buf;
	  real_new.check (newpath, PC_SYM_NOFOLLOW);
d1392 8
a1399 5
      else if (transparent_exe
	       && !real_old.isdir ()
	       && GetBinaryType (real_old, &bintype)
	       && (len = strlen (real_new)) > 4
	       && !strcasematch ((const char *) real_new + len - 4, ".exe"))
d1401 2
a1402 5
	  /* Executable hack. */
	  strcpy (new_buf, newpath);
	  strcat (new_buf, ".exe");
	  newpath = new_buf;
	  real_new.check (newpath, PC_SYM_NOFOLLOW);
d1405 1
a1405 2

  if (real_new.error || real_new.case_clash)
d1407 23
a1429 3
      syscall_printf ("-1 = rename (%s, %s)", oldpath, newpath);
      set_errno (real_new.case_clash ? ECASECLASH : real_new.error);
      return -1;
d1431 1
a1431 2

  if (real_new.isdir () && !real_old.isdir ())
a1432 1
      syscall_printf ("newpath is directory, but oldpath is not");
d1434 1
a1434 57
      return -1;
    }

  /* Destination file exists and is read only, change that or else
     the rename won't work. */
  if (real_new.has_attribute (FILE_ATTRIBUTE_READONLY))
    SetFileAttributes (real_new, (DWORD) real_new & ~FILE_ATTRIBUTE_READONLY);

  /* Shortcut hack No. 2, part 1 */
  if (!real_old.issymlink () && !real_new.error && real_new.is_lnk_special ()
      && (lnk_suffix = strrchr (real_new.get_win32 (), '.')))
     *lnk_suffix = '\0';

  if (MoveFile (real_old, real_new))
    goto done;

  res = -1;

  /* Test for an attempt to make a directory a subdirectory of itself first.
     This test has to be made before any attempt to remove the potentially
     existing file or directory real_new.  Otherwise we end up with a
     non-moved directory *and* a deleted read_new path.  Also this case
     has to generate an EINVAL in all circumstances,

     NB: We could test this also before calling MoveFile but the idea is
     that this is a somewhat seldom case and we like to avoid expensive
     string comparison.  So we allow MoveFile to fail and test the error
     code instead.

     The order in the condition is (hopefully) trimmed for doing the least
     expensive stuff first. */
  int len;
  DWORD lasterr;
  lasterr = GetLastError ();
  if (real_old.isdir ()
      && lasterr == ERROR_SHARING_VIOLATION
      && (len = strlen (real_old), strncasematch (real_old, real_new, len))
      && real_new[len] == '\\')
    SetLastError (ERROR_INVALID_PARAMETER);
  else if (MoveFileEx (real_old.get_win32 (), real_new.get_win32 (),
		       MOVEFILE_REPLACE_EXISTING))
    res = 0;
  else if ((lasterr = unlink_nt (real_new)))
    {
      SetLastError (lasterr);
      syscall_printf ("Can't remove target file/dir, %E");
    }
  else if (MoveFile (real_old, real_new))
    res = 0;

done:
  if (res)
    {
      __seterrno ();
      /* Reset R/O attributes if neccessary. */
      if (real_new.has_attribute (FILE_ATTRIBUTE_READONLY))
	SetFileAttributes (real_new, real_new);
d1438 4
a1441 16
      /* make the new file have the permissions of the old one */
      DWORD attr = real_old;
#ifdef HIDDEN_DOT_FILES
      char *c = strrchr (real_old.get_win32 (), '\\');
      if ((c && c[1] == '.') || *real_old.get_win32 () == '.')
	attr &= ~FILE_ATTRIBUTE_HIDDEN;
      c = strrchr (real_new.get_win32 (), '\\');
      if ((c && c[1] == '.') || *real_new.get_win32 () == '.')
	attr |= FILE_ATTRIBUTE_HIDDEN;
#endif
      SetFileAttributes (real_new, attr);

      /* Shortcut hack, No. 2, part 2 */
      /* if the new filename was an existing shortcut, remove it now if the
	 new filename is equal to the shortcut name without .lnk suffix. */
      if (lnk_suffix)
d1443 18
a1460 2
	  *lnk_suffix = '.';
	  unlink_nt (real_new);
d1462 1
a1462 7
      /* Shortcut hack, No. 3, part 2 */
      /* If a file with the given name exists, it must be deleted after the
	 symlink has been renamed.  Otherwise we end up with two files of
	 the same name in the directory, one file "newpath", which already
	 exited before rename has been called, and one file "newpath.lnk",
	 which is the result of the rename operation. */
      else if (no_lnk_file_exists)
d1464 20
a1483 3
	  lnk_suffix = strrchr (real_new.get_win32 (), '.');
	  *lnk_suffix = '\0';
	  unlink_nt (real_new);
d1486 28
d1515 2
a1516 3
  syscall_printf ("%d = rename (%s, %s)", res, (char *) real_old,
		  (char *) real_new);

@


1.448
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't allow
	FileAttributes set to 0 when calling NtSetInformationFile since it has
	a special meaning.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::link): Only set attributes after copying files.
	Use SetFileAttributesW.
	* syscalls.cc (unlink_nt): Only care for actual FILE_ATTRIBUTE_READONLY.
	Don't allow FileAttributes set to 0 when calling NtSetInformationFile.
	After marking for deletion, restore R/O attribute on files to
	accommodate hardlinks.
@
text
@a1204 1
  fhandler_base *fh = NULL;
d1210 1
a1210 4
  if (!(fh = build_fh_pc (pc)))
    goto error;

  if (fh->error ())
d1212 2
a1213 2
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
d1215 1
a1215 1
  else if (fh->exists ())
d1217 5
d1235 1
a1239 1
  delete fh;
d1242 1
a1242 1
  syscall_printf ("%d = (%s, %p)", res, pc.normalized_path, buf);
@


1.447
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Use FILE_ANY_ACCESS.
	(fhandler_base::utimes_fs): Fix white space.
	(fhandler_disk_file::lock): Remove 9x blurb from comment.
	(fhandler_disk_file::mkdir): Use NtCreateFile/NtClose instead of
	CreateDirectoryA.
	(fhandler_disk_file::rmdir): Accommodate changes to unlink_nt.
	Simplify post-delete SMB-related tests.  Use NtQueryAttributesFile
	instead of GetFileAttributes.
	* ntdll.h (STATUS_DIRECTORY_NOT_EMPTY): Define.
	(NtQueryAttributesFile): Declare.
	* syscalls.cc (unlink_nt): Return NTSTATUS.  Drop setattrs parameter.
	Never use FILE_DELETE_ON_CLOSE, always use
	NtSetInformationFile(FileDispositionInformation) instead.
	Check for R/O attributes and open file with FILE_WRITE_ATTRIBUTES
	access if any of them are set.  Remove R/O attributes before
	marking for delete if necessary.  Revert them afterwards if necessary.
	(unlink): Accommodate changes to unlink_nt.
@
text
@d241 2
a242 2
  /* If one of the R/O attributes is set, we have to open the file with
     FILE_WRITE_ATTRIBUTES to be able to remove these flags before trying
d244 1
a244 3
  if (pc.file_attributes () & (FILE_ATTRIBUTE_READONLY
			       | FILE_ATTRIBUTE_SYSTEM
			       | FILE_ATTRIBUTE_HIDDEN))
d331 1
a331 1
  /* Get rid of read-only attributes. */
d337 2
a338 4
      fbi.FileAttributes = pc.file_attributes ()
			   & ~(FILE_ATTRIBUTE_READONLY
			       | FILE_ATTRIBUTE_SYSTEM
			       | FILE_ATTRIBUTE_HIDDEN);
a347 1
      /* Restore R/O attributes. */
d349 2
a350 1
        {
d356 9
@


1.446
log
@	* dir.cc (readdir_worker): Drop dir parameter from call to
	readdir_get_ino.
	* fhandler.h (fhandler_disk_file::readdir_helper): Switch file name
	parameter to PUNICODE_STRING.
	* fhandler_disk_file.cc: Drop including ntdef.h.
	(class __DIR_mounts): Store mount points in UNICODE.  Additionally
	store cygdrive prefix in unicode here.  Change methods accordingly.
	(__DIR_mounts::eval_ino): Call new stat_worker instead of lstat64.
	(__DIR_mounts::~__DIR_mounts): New destructor to free UNICODE buffers.
	(path_conv::ndisk_links): Rewrite using native NT functions.
	(fhandler_base::fstat_by_handle): Use NAME_MAX instead of CYG_MAX_PATH.
	Always set pfvi->VolumeSerialNumber to non-0.  Remove last resort
	code.
	(fhandler_base::fstat_by_name): Rewrite using native NT functions.
	(fhandler_base::fstat_fs): Always call fstat_by_name if fstat_by_handle
	fails.
	(fhandler_base::fstat_helper): Rely on dwVolumeSerialNumber.
	(fhandler_disk_file::facl): Call fstat_by_name if fstat_by_handle fails.
	(DIR_BUF_SIZE): Define using NAME_MAX instead of CYG_MAX_PATH.
	(__DIR_cache): Remove __name.
	(d_dirname): Remove.
	(fhandler_disk_file::opendir): Drop pathname length check.
	Remove outdated comment.  Use get_name method instead of accessing
	pc.normalized_path directly.
	(readdir_get_ino): Drop unused dir parameter.  Accomodate throughout.
	Allocate fname dynamically.  Call new stat_worker instead of lstat64.
	Call NtOpenFile instead of CreateFile.  Call NtClose instead of
	CloseHandle.
	(fhandler_disk_file::readdir_helper): Use native NT functions.
	Check for volume mount points and use correct inode number.
	(fhandler_disk_file::readdir): Simplify slightly.
	Use get_name instead of pc.normalized_path.
	(fhandler_disk_file::rewinddir): Use RtlInitUnicodeString.
	(fhandler_cygdrive::fstat): Ignore floppy drives.  Set st_nlink
	correctly.
	(fhandler_cygdrive::readdir): Ignore floppy drives.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Accommodate
	change to readdir_get_ino.
	* fhandler_proc.cc (PROC_DIR_COUNT): Define.
	(fhandler_proc::fstat): Evaluate correct link count for /proc.
	* ntdll.h (struct _FILE_DIRECTORY_INFORMATION): Define.
	(NtFsControlFile): Declare.
	(RtlAppendUnicodeToString): Declare.
	(RtlAppendUnicodeStringToString): Declare.
	(RtlCompareUnicodeString): Declare.
	(RtlCopyUnicodeString): Declare.
	(RtlCreateUnicodeStringFromAsciiz): Declare.
	(RtlEqualUnicodeString): Declare.
	(RtlFreeUnicodeString): Declare.
	(RtlInitEmptyUnicodeString): Declare.
	(RtlSecondsSince1970ToTime): Declare.
	(RtlInitEmptyUnicodeString): Define as inline function.
	(RtlInitCountedUnicodeString): Define as inline function.
	* path.cc (path_conv::check): New method with PUNICODE_STRING as path,
	preliminary implementation.
	(mount_info::get_mounts_here): Change to create UNICODE_STRINGs.
	Also copy cygpath prefix into UNICODE_STRING.
	(is_floppy): Drop 9x consideration.
	* path.h: Drop including ntdef.h.
	(path_conv::check): Add declaration.
	(path_conv::path_conv): Add constructor for UNICODE_STRING paths.
	* shared_info.h (mount_info::get_mounts_here): Change declaration.
	* syscalls.cc: Drop forward declaration of stat_worker.
	(stat_worke): Take path_conv as parameter.  Drop nofollow flag.
	(stat64): Create matching path_conv and call stat_worker with it.
	(lstat64): Ditto.
	* winsup.h: Include ntdef.h.
	(stat_worker): Declare.
	(readdir_get_ino): Change declaration.
@
text
@d231 2
a232 2
DWORD
unlink_nt (path_conv &win32_name, bool setattrs)
d234 2
d238 10
a247 2
  NTSTATUS status;
  HANDLE h;
a249 22
  /* Don't open directories with "delete on close", because the NT internal
     semantic is apparently different from the file semantic.  If a directory
     is opened "delete on close", the rename operation in try_to_bin fails
     with STATUS_ACCESS_DENIED.  So directories must be deleted using
     NtSetInformationFile, class FileDispositionInformation, which works fine.

     Correction, moving a directory opened with delete-on-close fails ONLY
     on XP.  Note to myself: Never take anything for granted on Windows!

     Don't try "delete on close" if the file is on a remote share.  If two
     processes have open handles on a file and one of them calls unlink, then
     it happens that the file is removed from the remote share even though the
     other process still has an open handle.  This other process than gets
     Win32 error 59, ERROR_UNEXP_NET_ERR when trying to access the file.  That
     does not happen when using NtSetInformationFile, class
     FileDispositionInformation, which nicely succeeds but still, the file is
     available for the other process.  Microsoft KB 837665 describes this
     problem as a bug in 2K3, but I have reproduced it on shares on Samba
     2.2.8, Samba 3.0.2, NT4SP6, XP64SP1 and 2K3 and in all cases, DeleteFile
     works, "delete on close" does not. */
  if (!win32_name.isdir () && !win32_name.isremote ())
    flags |= FILE_DELETE_ON_CLOSE;
d252 1
a252 1
  if (win32_name.is_rep_symlink ())
d255 1
a255 1
  win32_name.get_object_attr (attr, sec_none_nih);
d263 1
a263 1
  status = NtOpenFile (&h, DELETE, &attr, &io, 0, flags);
d267 3
a269 3
      if (!win32_name.isdir () || win32_name.isremote ())
	status = NtOpenFile (&h, DELETE, &attr, &io, FILE_SHARE_VALID_FLAGS,
			     flags);
d284 1
a284 1
	  status = NtOpenFile (&h, DELETE | SYNCHRONIZE | FILE_LIST_DIRECTORY,
d293 1
a293 1
	      status = NtQueryDirectoryFile (h, NULL, NULL, 0, &io, pfni,
d298 1
a298 1
		  NtClose (h);
d301 1
a301 1
		  return RtlNtStatusToDosError (status);
d312 1
a312 1
		  NtClose (h);
d314 1
a314 1
		  return ERROR_DIR_NOT_EMPTY;
d323 1
a323 1
	  syscall_printf ("Delete already pending, status = %p", status);
d327 1
a327 1
      return RtlNtStatusToDosError (status);
d330 2
a331 5
  if (setattrs)
    SetFileAttributes (win32_name, (DWORD) win32_name);

  if (move_to_bin && !win32_name.isremote ())
    try_to_bin (win32_name, h);
d333 2
a334 3
  DWORD lasterr = 0;

  if (win32_name.isdir () || win32_name.isremote ())
d336 8
a343 9
      FILE_DISPOSITION_INFORMATION disp = { TRUE };
      status = NtSetInformationFile (h, &io, &disp, sizeof disp,
				     FileDispositionInformation);
      if (!NT_SUCCESS (status))
	{
	  syscall_printf ("Setting delete disposition failed, status = %p",
			  status);
	  lasterr = RtlNtStatusToDosError (status);
	}
d346 3
a348 1
  status = NtClose (h);
d351 8
a358 5
      /* Maybe that's really paranoid, but not being able to close the file
	 also means that deleting fails. */
      syscall_printf ("%p = NtClose (%p)", status, h);
      if (!lasterr)
	lasterr = RtlNtStatusToDosError (status);
d361 2
a362 2
  syscall_printf ("Deleting succeeded");
  return lasterr;
d370 1
a370 1
  DWORD lasterr;
d403 2
a404 17
  bool setattrs;
  if (!((DWORD) win32_name & (FILE_ATTRIBUTE_READONLY
			      | FILE_ATTRIBUTE_SYSTEM
			      | FILE_ATTRIBUTE_HIDDEN)))
    setattrs = false;
  else
    {
      /* Allow us to delete even if read-only */
      setattrs = SetFileAttributes (win32_name,
				    (DWORD) win32_name
				    & ~(FILE_ATTRIBUTE_READONLY
					| FILE_ATTRIBUTE_SYSTEM
					| FILE_ATTRIBUTE_HIDDEN));
    }

  lasterr = unlink_nt (win32_name, setattrs);
  if (!lasterr)
a407 2
      SetFileAttributes (win32_name, (DWORD) win32_name);

d409 1
a409 1
      if (lasterr == ERROR_SHARING_VIOLATION)
d417 1
a417 1
	__seterrno_from_win_error (lasterr);
d1441 1
a1441 1
  else if ((lasterr = unlink_nt (real_new, false)))
d1477 1
a1477 1
	  unlink_nt (real_new, false);
d1489 1
a1489 1
	  unlink_nt (real_new, false);
@


1.445
log
@	* fhandler.cc (fhandler_base::open): Drop local wpath and upath
	variables.  Call pc.get_object_attr to create object attributes.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
	* path.cc (path_conv::set_normalized_path): Set wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.  Create path in
	wide_path/uni_path members.
	(path_conv::get_object_attr): New method to create object attributes.
	(path_conv::get_wide_win32_path): New method to create Win32 wide path.
	(path_conv::check): Initialize wide_path to NULL.
	(path_conv::~path_conv): cfree wide_path.
	* path.h (class path_conv): New members wide_path and uni_path.
	Add declarations of get_object_attr and get_wide_win32_path.
	(path_conv::path_conv): Initialize wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.
@
text
@a98 3
static int __stdcall stat_worker (const char *name, struct __stat64 *buf,
				  int nofollow) __attribute__ ((regparm (3)));

d1225 2
a1226 2
static int __stdcall
stat_worker (const char *name, struct __stat64 *buf, int nofollow)
d1235 1
a1235 2
  if (!(fh = build_fh_name (name, NULL, nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW,
			    stat_suffixes)))
d1245 2
a1246 2
      debug_printf ("(%s, %p, %d, %p), file_attributes %d", name, buf, nofollow,
		    fh, (DWORD) *fh);
d1265 1
a1265 1
  syscall_printf ("%d = (%s, %p)", res, name, buf);
d1273 2
a1274 1
  return stat_worker (name, buf, 0);
d1312 2
a1313 1
  return stat_worker (name, buf, 1);
@


1.444
log
@	* cygheap.h (cygheap_user::curr_imp_token): Rename from current_token.
	Accommodate changge throughout Cygwin.
	(cygheap_user::imp_token): Rename from token.  Accommodate changge
	throughout Cygwin.
	(rcygheap_user::eimpersonate): Use primary token for impersonation.
	* grp.cc (internal_getgroups): Use primary impersonation token when
	impersonated.
	* security.h (_push_thread_privilege): Use primary impersonation token
	when impersonated.
@
text
@a236 2
  WCHAR wpath[CYG_MAX_PATH + 10];
  UNICODE_STRING upath = {0, sizeof (wpath), wpath};
d270 1
a270 3
  win32_name.get_nt_native_path (upath);
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
			      NULL, sec_none_nih.lpSecurityDescriptor);
@


1.443
log
@	* ntdll.h (struct _OBJECT_NAME_INFORMATION): Define.
	* syscalls.cc (unlink_nt): Check shared directory for being empty
	before trying to move and mark for deletion.
@
text
@d2231 1
a2231 1
  if (cygheap->user.current_token != NO_IMPERSONATION)
d2233 2
a2234 2
      CloseHandle (cygheap->user.current_token);
      cygheap->user.current_token = NO_IMPERSONATION;
d2240 1
a2240 1
			     TokenImpersonation, &cygheap->user.current_token))
d2246 1
a2246 1
      set_cygwin_privileges (cygheap->user.current_token);
d2341 1
a2341 1
      if (!SetTokenInformation (cygheap->user.token (), TokenPrimaryGroup,
@


1.442
log
@	* path.cc (close_user_proc_parms_cwd_handle): Remove.
	(cwdstuff::init): Don't call close_user_proc_parms_cwd_handle.
	Call set to set cwd with all-sharing handle.
	(cwdstuff::set): Fix comment.  Don't close cwd handle.  Set in
	user parameter block instead and close old cwd handle.
	* syscalls.cc (rename): Call unlink_nt instead of RemoveDirectory or
	DeleteFile to allow deleting shared files/directories.
@
text
@d286 51
a336 2
      status = NtOpenFile (&h, DELETE, &attr, &io, FILE_SHARE_VALID_FLAGS,
			   flags);
@


1.441
log
@	* fhandler.cc(fhandler_base::open): Open with READ_CONTROL only in
	case of query_open flag set to query_read_control.  Add case for
	new query_read_attributes flag.
	(fhandler_base::fstatvfs): New method.
	* fhandler.h (enum query_state): Add query_read_attributes flag.
	(class fhandler_base): Declare new virtual fstatvfs method.
	(class fhandler_socket): Ditto.
	(class fhandler_pipe): Ditto.
	(class fhandler_fifo): Ditto.
	(class fhandler_disk_file): Ditto.
	(class fhandler_virtual): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Open with
	query_read_attributes instead of query_read_control.
	(fhandler_disk_file::fstatvfs): New method.
	(fhandler_disk_file::facl): Open with query_read_attributes instead of
	query_read_control.
	* fhandler_fifo.cc (fhandler_fifo::fstatvfs): New method.
	* fhandler_socket.cc (fhandler_socket::fstatvfs): New method.
	(fhandler_socket::fchmod): Return with EBADF in the default case.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::fstatvfs): Ditto.
	* ntdll.h (struct _FILE_FS_ATTRIBUTE_INFORMATION): Define.
	(struct _FILE_FS_FULL_SIZE_INFORMATION): Define.
	* pipe.cc (fhandler_pipe::fstatvfs): New method.
	* syscalls.cc (fstatvfs): Just call the fhandler's fstatvfs.
	(statvfs): Ditto.
	(fstatfs): Call fstatvfs.
	(statfs): Drop EFAULT handling.
@
text
@d1424 4
a1427 1
  else if (real_new.isdir ())
d1429 2
a1430 6
      /* Since neither MoveFileEx(MOVEFILE_REPLACE_EXISTING) nor DeleteFile
	 allow to remove directories, this case is handled separately. */
      if (!RemoveDirectoryA (real_new))
	syscall_printf ("Can't remove target directory");
      else if (MoveFile (real_old, real_new))
	res = 0;
d1432 1
a1432 2
  else if (MoveFileEx (real_old.get_win32 (), real_new.get_win32 (),
		       MOVEFILE_REPLACE_EXISTING))
d1463 1
a1463 1
	  DeleteFile (real_new);
d1475 1
a1475 1
	  DeleteFile (real_new);
@


1.440
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop comment.
	* mmap.cc (gen_access): Remove.
	(mmap_record::gen_access): Remove.
	(mmap64): Don't mention 9x any longer.
	* syscalls.cc (statvfs): Drop status code consideration for 9x.
	* libc/minires-os-if.c (get_registry_dns_items): Don't mention 9x any
	longer.
	(get_registry_dns): Drop getting registry key on 9x.  Drop is9x
	variable.
@
text
@d1844 1
a1844 1
statvfs (const char *fname, struct statvfs *sfs)
a1845 3
  int ret = -1;
  char root[CYG_MAX_PATH];

a1848 5
  if (!*fname)
    {
      set_errno (ENOENT);
      return -1;
    }
d1850 15
a1864 1
  syscall_printf ("statfs %s", fname);
d1866 2
a1867 5
  if (!sfs)
    {
      set_errno (EFAULT);
      return -1;
    }
d1869 1
a1869 2
  path_conv full_path (fname, PC_SYM_FOLLOW);
  if (!full_path.rootdir (root))
d1871 2
a1872 2
      set_errno (ENOTDIR);
      return -1;
d1874 1
a1874 10

  ULARGE_INTEGER availb, freeb, totalb;
  DWORD spc, bps, availc, freec, totalc, vsn, maxlen, flags;
  BOOL status, statusex;

  /* GetDiskFreeSpaceEx must be called before GetDiskFreeSpace on
     WinME, to avoid the MS KB 314417 bug */
  statusex = GetDiskFreeSpaceEx (root, &availb, &totalb, &freeb);
  status = GetDiskFreeSpace (root, &spc, &bps, &freec, &totalc);
  if (status)
d1876 2
a1877 44
      if (statusex)
	{
	  availc = availb.QuadPart / (spc*bps);
	  totalc = totalb.QuadPart / (spc*bps);
	  freec = freeb.QuadPart / (spc*bps);
	  if (freec > availc)
	    {
	      /* Quotas active.  We can't trust totalc. */
	      HANDLE hdl = CreateFile (full_path, READ_CONTROL,
				       FILE_SHARE_VALID_FLAGS, &sec_none_nih,
				       OPEN_EXISTING,
				       FILE_FLAG_BACKUP_SEMANTICS, NULL);
	      if (hdl == INVALID_HANDLE_VALUE)
		debug_printf ("CreateFile (%s) failed, %E", (char *) full_path);
	      else
		{
		  NTFS_VOLUME_DATA_BUFFER nvdb;
		  DWORD bytes;
		  if (!DeviceIoControl (hdl, FSCTL_GET_NTFS_VOLUME_DATA, NULL,
					0, &nvdb, sizeof nvdb, &bytes, NULL))
		    debug_printf ("DeviceIoControl (%s) failed, %E", (char *) full_path);
		  else
		    totalc = nvdb.TotalClusters.QuadPart;
		  CloseHandle (hdl);
		}
	    }
	}
      else
	availc = freec;
      if (GetVolumeInformation (root, NULL, 0, &vsn, &maxlen, &flags, NULL, 0))
	{
	  sfs->f_bsize = spc*bps;
	  sfs->f_frsize = spc*bps;
	  sfs->f_blocks = totalc;
	  sfs->f_bfree = freec;
	  sfs->f_bavail = availc;
	  sfs->f_files = ULONG_MAX;
	  sfs->f_ffree = ULONG_MAX;
	  sfs->f_favail = ULONG_MAX;
	  sfs->f_fsid = vsn;
	  sfs->f_flag = flags;
	  sfs->f_namemax = maxlen;
	  ret = 0;
	}
d1879 2
a1880 2
  if (ret)
    __seterrno ();
d1882 5
a1886 1
  return ret;
d1890 1
a1890 1
fstatvfs (int fd, struct statvfs *sfs)
d1892 15
a1906 4
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
  return statvfs (cfd->get_name (), sfs);
a1911 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
a1928 9
extern "C" int
fstatfs (int fd, struct statfs *sfs)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
  return statfs (cfd->get_name (), sfs);
}

@


1.439
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@a1880 10
  if (!status && statusex)
    {
      /* Grrr, this can happen on 9x when a share isn't attached to
	 a drive letter.  Fake, fake, hoorah. */
      status = TRUE;
      bps = 512;
      spc = 8;
      while ((totalb.QuadPart % (spc*bps)) && spc > 1)
	spc >>= 1;
    }
@


1.438
log
@	* fhandler_console.cc (fhandler_console::need_invisible): Drop
	pty_needs_alloc_console check.
	* spawn.cc (spawn_guts): Ditto.
	(av::fixup): Remove setting iscui.
	* syscalls.cc (rename): Drop has_move_file_ex checks.  Remove 9x
	specific code.
	* wincap.cc: Remove has_move_file_ex and pty_needs_alloc_console
	throughout.
	* wincap.h: Ditto.
@
text
@a891 3
  if (!wincap.has_security ())  // real chown only works on NT
    return 0;			// return zero (and do nothing) under Windows 9x

a941 3
  if (!wincap.has_security ())  // real chown only works on NT
    return 0;			// return zero (and do nothing) under Windows 9x

a2158 5
  if (!wincap.has_security () && pw_new)
    {
      load_registry_hive (pw_new->pw_name);
      goto success_9x;
    }
a2262 1
success_9x:
d2325 1
a2325 1
  if (gid == myself->gid || !wincap.has_security ())
@


1.437
log
@	Throughout remove all usage of wincap.access_denied_on_delete.
	* dir.cc (rmdir): Add existance check to be errno-compatible with Linux.
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop test for
	non-existent dir on 9x share.
	* syscalls.cc (unlink): Add comment.
	* wincap.cc: Remove access_denied_on_delete flag throughout.
	* wincap.h: Ditto.
@
text
@d1421 1
a1421 5
     expensive stuff first.  Nevertheless it would be nice if 9x could
     generate the same error codes as NT.
     NT generates ERROR_SHARING_VIOLATION in all cases, while 9x generates
     ERROR_ACCESS_DENIED if the target path doesn't exist,
     ERROR_ALREADY_EXISTS otherwise */
d1426 1
a1426 5
      && ((lasterr == ERROR_SHARING_VIOLATION && wincap.has_move_file_ex ())
       || (lasterr == ERROR_ACCESS_DENIED && !real_new.exists ()
	   && !wincap.has_move_file_ex ())
       || (lasterr == ERROR_ALREADY_EXISTS && real_new.exists ()
	   && !wincap.has_move_file_ex ()))
d1439 3
a1441 25
  else if (wincap.has_move_file_ex ())
    {
      if (MoveFileEx (real_old.get_win32 (), real_new.get_win32 (),
		      MOVEFILE_REPLACE_EXISTING))
	res = 0;
    }
  else if (lasterr == ERROR_ALREADY_EXISTS || lasterr == ERROR_FILE_EXISTS)
    {
      syscall_printf ("try win95 hack");
      for (int i = 0; i < 2; i++)
	{
	  if (!DeleteFileA (real_new) &&
	      GetLastError () != ERROR_FILE_NOT_FOUND)
	    {
	      syscall_printf ("deleting %s to be paranoid",
			      real_new.get_win32 ());
	      break;
	    }
	  else if (MoveFile (real_old, real_new))
	    {
	      res = 0;
	      break;
	    }
	}
    }
@


1.436
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@d395 2
a396 5
      /* Windows 9x seems to report ERROR_ACCESS_DENIED rather than sharing
	 violation. */
      if ((wincap.access_denied_on_delete () && lasterr == ERROR_ACCESS_DENIED
	   && !win32_name.isremote ())
	  || lasterr == ERROR_SHARING_VIOLATION)
d1443 1
a1443 8
	{
	  syscall_printf ("Can't remove target directory");
	  /* On 9X ERROR_ACCESS_DENIED is returned if you try to remove
	     a non-empty directory. */
	  if (GetLastError () == ERROR_ACCESS_DENIED
	      && wincap.access_denied_on_delete ())
	    SetLastError (ERROR_DIR_NOT_EMPTY);
	}
@


1.435
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d286 2
a287 1
      status = NtOpenFile (&h, DELETE, &attr, &io, wincap.shared (), flags);
d1118 1
a1118 1
  HANDLE fh = CreateFileA (vol, GENERIC_WRITE, wincap.shared (),
d1948 1
a1948 1
				       wincap.shared (), &sec_none_nih,
@


1.434
log
@	* cygwin.din (sem_unlink): Export.
	* posix_ipc.cc: Include thread.h and semaphore.h.  Remove TODO
	comment.
	(ipc_names): Add max_len member.  Set to maximum length of the path
	before tacking on the prefix path.  Set prefix path for named semaphors
	to /dev/shm, as on Linux.
	(enum ipc_type_t): Change sem to semaphore to avoid name conflicts.
	(check_path): Detect empty paths.  Use ipc_names's max_len member.
	Use __small_sprintf to create full object path name.  Special case
	semaphores.
	(ipc_cond_init): Drop superfluous strcpy.
	(class ipc_flock): New class to simplify file locking in subsequent
	code.
	(struct mq_hdr): Raise size of mqh_uname to allow adding a unique
	LUID to the name.
	(mq_open): Fix formatting.  Create unique synchronization object names
	using AllocateLocallyUniqueId.
	(struct sem_finfo): New structure defining named semaphore file content.
	(sem_open): Move here.  Rework implementation to allow kernel
	persistent implementation of POSIX named semaphores.
	(_sem_close): Implement sem_close.
	(sem_close): Move here.  Just call _sem_close with do_close parameter
	set to true.
	(sem_unlink): New function.
	* pthread.cc (mangle_sem_name): Remove.
	(sem_open): Move to posix_ipc.cc.
	(sem_close): Ditto.
	* syscalls.cc (close_all_files): Call semaphore::terminate here.
	* thread.cc: Fix formatting.  Rearrange semaphore functions so that
	they are close together.
	(semaphore::semaphore): Rework to play nicely with new named semaphore
	implementation.
	(semaphore::_terminate): Call _sem_close if semaphore is a named
	semaphore.
	(semaphore::destroy): Don't destroy named semaphores.  Return EINVAL
	instead.
	(semaphore::close): Only destroy named semaphores.  Return EINVAL
	otherwise.
	(semaphore::open): Rework to play nicely with new named semaphore
	implementation.  Loop through existing semaphores to be able to
	return same sem_t pointer as a former call on the same named semaphore.
	(semaphore::getinternal): New function called from _sem_close.
	* thread.h (class List): Make mx and head public.
	(class semaphore): Fix formatting.  Align method declarations with
	implementation in thread.cc.  Add members used for named semaphores.
	(semaphore::terminate): New static method.
	* include/semaphore.h: Redefine SEM_FAILED.  Fix formatting.
	(sem_unlink): Add declaration.
	* include/cygwin/version.h: Bump API minor number.
@
text
@a233 8
static DWORD
unlink_9x (path_conv &win32_name)
{
  BOOL ret = DeleteFile (win32_name);
  syscall_printf ("DeleteFile %s", ret ? "succeeded" : "failed");
  return GetLastError ();
}

d339 1
d387 1
a387 3
  DWORD lasterr;
  lasterr = wincap.is_winnt () ? unlink_nt (win32_name, setattrs)
			       : unlink_9x (win32_name);
d1166 1
a1166 1
  else if (wincap.is_winnt ())	/* 9x has no concept for opening volumes */
@


1.433
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d112 2
@


1.432
log
@	* Makefile.in (DLL_OFILES): Add posix_ipc.o.
	* cygwin.din (mq_close): Export.
	(mq_getattr): Export.
	(mq_notify): Export.
	(mq_open): Export.
	(mq_receive): Export.
	(mq_send): Export.
	(mq_setattr): Export.
	(mq_timedreceive): Export.
	(mq_timedsend): Export.
	(mq_unlink): Export.
	* posix_ipc.cc: New file implementing the above functions.  Move
	shm_open and shm_unlink from syscalls.cc here.
	* sysconf.cc (sca): Set value of _SC_MQ_OPEN_MAX to MQ_OPEN_MAX,
	_SC_MQ_PRIO_MAX to MQ_PRIO_MAX, _SC_MESSAGE_PASSING to
	_POSIX_MESSAGE_PASSING.
	* include/limits.h (MQ_OPEN_MAX): Define.
	(MQ_PRIO_MAX): Define.
	* include/mqueue.h: New file.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d256 1
a256 1
     
d259 1
a259 1
     
@


1.431
log
@	* syscalls.cc (check_shm): New static function to do path checking
	common to shm_open and shm_unlink.  Check for /dev/shm existance.
	(shm_open): Call check_shm.
	(shm_unlink): Ditto.
@
text
@a3348 70

#define SHM_STORAGE "/dev/shm"

static bool
check_shm (const char *name)
{
  /* Note that we require the existance of /dev/shm for shared memory
     object support, same as on Linux.  We don't create this directory
     here, that's the task of the installer.  But we check for existance
     and give ample warning. */
  path_conv dev_shm (SHM_STORAGE, PC_SYM_NOFOLLOW);
  if (dev_shm.error || !dev_shm.exists () || !dev_shm.isdir ())
    {
      small_printf (
	"Warning: '%s' does not exists or is not a directory.\n\n"
	"Shared memory objects require the existance of this directory.\n"
	"Create the directory '%s' and set the permissions to 01777.\n"
	"For instance on the command line: mkdir -m 01777 %s\n",
	SHM_STORAGE, SHM_STORAGE, SHM_STORAGE);
      set_errno (EINVAL);
      return false;
    }
  /* Name must start with a single slash. */
  if (!name || name[0] != '/' || name[1] == '/')
    {
      debug_printf ("Invalid shared memory object name '%s'", name);
      set_errno (EINVAL);
      return false;
    }
  if (strlen (name) > CYG_MAX_PATH - sizeof (SHM_STORAGE))
    {
      debug_printf ("shared memory object name '%s' too long", name);
      set_errno (ENAMETOOLONG);
      return false;
    }
  return true;
}

extern "C" int
shm_open (const char *name, int oflag, mode_t mode)
{
  if (!check_shm (name))
    return -1;

  /* Check for valid flags. */
  if (((oflag & O_ACCMODE) != O_RDONLY && (oflag & O_ACCMODE) != O_RDWR)
      || (oflag & ~(O_ACCMODE | O_CREAT | O_EXCL | O_TRUNC)))
    {
      debug_printf ("Invalid oflag 0%o", oflag);
      set_errno (EINVAL);
      return -1;
    }

  char shmname[CYG_MAX_PATH];
  strcpy (shmname, SHM_STORAGE);
  strcat (shmname, name);
  return open (shmname, oflag, mode & 0777);
}

extern "C" int
shm_unlink (const char *name)
{
  if (!check_shm (name))
    return -1;

  char shmname[CYG_MAX_PATH];
  strcpy (shmname, SHM_STORAGE);
  strcat (shmname, name);
  return unlink (shmname);
}
@


1.430
log
@	* cygwin.din (shm_open): Export.
	(shm_unlink): Export.
	* syscalls.cc (shm_open): New function.
	(shm_unlink): New function.
	* sysconf.cc (sca): Set value of _SC_SHARED_MEMORY_OBJECTS to
	_POSIX_SHARED_MEMORY_OBJECTS.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/mman.h (shm_open): Add prototype.
	(shm_unlink): Ditto.
@
text
@d3352 2
a3353 2
extern "C" int
shm_open (const char *name, int oflag, mode_t mode)
d3355 16
d3372 1
a3372 2
  if (!name || name[0] != '/' || name[1] == '/'
      || strlen (name) > CYG_MAX_PATH - sizeof (SHM_STORAGE))
d3376 7
a3382 1
      return -1;
d3384 9
d3401 1
a3401 2
  /* Note that we require the existance of /dev/shm here.  We don't
     create this directory from here.  That's the task of the installer. */
d3411 3
a3413 8
  /* Name must start with a single slash. */
  if (!name || name[0] != '/' || name[1] == '/'
      || strlen (name) > CYG_MAX_PATH - sizeof (SHM_STORAGE))
    {
      debug_printf ("Invalid shared memory object name '%s'", name);
      set_errno (EINVAL);
      return -1;
    }
@


1.429
log
@	* syscalls.cc (unlink_nt): Add missing assignment in case NtClose fails.
@
text
@d3349 46
@


1.428
log
@	* fhandler_disk_file.cc (fhandler_disk_file::closedir): Add dir name
	to debug output.
	* syscalls.cc (try_to_bin): Enable code to move file to user specific
	recycler dir to eliminate Vista problem.
	(unlink_nt): Add comment that rename after opening for delete on close
	only fails on XP.
@
text
@d333 1
a333 1
	RtlNtStatusToDosError (status);
@


1.427
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Implement rmdir
	on NT by calling unlink_nt.  Check for directory here.
	* syscalls.cc (try_to_bin): Fix buggy debug_printf statement.
	(unlink_nt): Make non-static.  Don't use delete-on-close semantics on
	directoires.  Explain why.
@
text
@d183 7
a189 6
#if 0
  /* The default settings for the top level recycle bin are so that
     everybody has the right to create files in it.  Should that be
     insufficient at one point, we can enable the following code to
     move the file into the user's own bin subdir.  At this point,
     I'm going to opt for speed, though. */
a208 1
#endif
d256 4
a259 1

@


1.426
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procnet.o.
	* autoload.cc (GetAdaptersAddresses): Define.
	* devices.h (FH_PROCNET): Define new device.
	* devices.in (dev_procnet_storage): Add "/proc/net" entry.
	* devices.cc: Regenerate.
	* dir.cc (readdir_worker): Use isproc_dev macro.
	* dtable.cc (build_fh_pc): Add FH_PROCNET.
	* fhandler.h (class fhandler_procnet): New class.
	* fhandler_proc.cc: Add "net" subdirectory handling.
	* fhandler_procnet.cc: New file handling "/proc/net" directory.
	* path.cc (isvirtual_dev): Move to path.h.
	* path.h (isproc_dev): New macro to identify /proc files by device.
	(isvirtual_dev): Moved here.  Define using isproc_dev.
	* syscalls.cc (unlink): Use isproc_dev macro.
	* wincap.h (wincapc::has_gaa_prefixes): New element.
	(wincapc::has_gaa_on_link_prefix): New element.
	* wincap.cc: Implement above elements throughout.
	(wincapc::init): Check XP for service pack and set has_gaa_prefixes
	appropriately.
	* include/cygwin/in6.h: Include asm/byteorder.h.
@
text
@d228 2
a229 1
    debug_printf ("Move %s to %s failed, status = %p", status);
d240 1
a240 1
static DWORD
d251 18
a268 13
  /* Don't try "delete on close" if the file is on a remote share.  If two
     processes have open handles on a file and one of them calls unlink,
     then it happens that the file is remove from the remote share even
     though the other process still has an open handle.  This other process
     than gets Win32 error 59, ERROR_UNEXP_NET_ERR when trying to access the
     file.
     That does not happen when using DeleteFile (NtSetInformationFile, class
     FileDispositionInformation), which nicely succeeds but still, the file
     is available for the other process.
     Microsoft KB 837665 describes this problem as a bug in 2K3, but I have
     reproduced it on shares on Samba 2.2.8, Samba 3.0.2, NT4SP6, XP64SP1 and
     2K3 and in all cases, DeleteFile works, "delete on close" does not. */
  if (!win32_name.isremote ())
d310 1
a310 1
  if (win32_name.isremote ())
@


1.425
log
@	* syscalls.cc (unlink_nt): Don't move files to recycle bin which are
	not in use.
@
text
@d346 2
a347 2
  if ((devn = win32_name.get_devn ()) == FH_PROC || devn == FH_REGISTRY
      || devn == FH_PROCESS)
@


1.424
log
@	* syscalls.cc: Update copyright.
@
text
@d256 3
a258 2
     That does not happen when using DeleteFile, which nicely succeeds but
     still, the file is available for the other process.
d272 13
a284 1
  status = NtOpenFile (&h, DELETE, &attr, &io, wincap.shared (), flags);
d299 1
a299 1
  if (!win32_name.isremote ())
@


1.423
log
@	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
@


1.422
log
@	* syscalls.cc (getpagesize): Change condition for clarity.
	(getsystempagesize): Ditto.
@
text
@d1127 1
a1127 1
	GetVolumeNameForVolumeMountPointA ("B:\\", a_drive, CYG_MAX_PATH);
@


1.421
log
@	* environ.cc (subauth_id_init): Remove.
	(parse_thing): Drop "subauth_id" option.
	* security.cc (get_token_group_sidlist): Drop comments concerning
	subauthentication.
	(create_token): Back out subauthentication related changes.
	(subauth): Remove.
	* security.h (create_token): Remove declaration.
	(subauth): Ditto.
	* syscalls.cc (seteuid32): Drop subauthentication handling entirely.
@
text
@d1565 1
a1565 1
  if (!system_info.dwPageSize)
d1573 1
a1573 1
  if (!system_info.dwAllocationGranularity)
@


1.420
log
@	* environ.cc (set_traverse): Remove.
	(parse_thing): Drop "traverse" option.
	* path.cc (fs_info::update): Don't request SE_CHANGE_NOTIFY_PRIV
	privilege.
	* sec_helper.cc (set_cygwin_privileges): Ditto.
	* security.cc (allow_traverse): Remove.
	(alloc_sd): Drop special allow_traverse code.
	* security.h (allow_traverse): Drop declaration.
	* syscalls.cc (statvfs): Don't request SE_CHANGE_NOTIFY_PRIV privilege.
@
text
@a2229 23
#if 0
	  new_token = subauth (pw_new);
	  debug_printf ("subauth %s, try create_token.",
			new_token == INVALID_HANDLE_VALUE ? "failed" : "succeeded");
	  HANDLE new_token2 = create_token (usersid, groups, pw_new, new_token);
	  if (new_token2 == INVALID_HANDLE_VALUE)
	    {
	      if (new_token == INVALID_HANDLE_VALUE)
		{
		  debug_printf ("create_token failed, bail out of here");
		  cygheap->user.reimpersonate ();
		  return -1;
		}
	      debug_printf ("create_token failed, use original subauth token");
	    }
	  else
	    {
	      debug_printf ("create_token succeeded");
	      if (new_token != INVALID_HANDLE_VALUE)
		CloseHandle (new_token);
	      new_token = new_token2;
	    }
#else
d2231 1
a2231 1
	  new_token = create_token (usersid, groups, pw_new, NULL);
a2237 1
#endif
@


1.419
log
@	Partially revert change from 2005-04-03, always running under an
	impersonation token, which collides with Vista UAC.
	* cygheap.h (deimpersonate): revert to self instead of impersonating
	hProcImpToken.
	(reimpersonate): Only impersonate if setuid.
	* dcrt0.cc (dll_crt0_0): Don't initialize hProcImpToken here.
	(dll_crt0_1): Set privileges on hProcToken.
	* fork.cc (frok::child): Set privileges on hProcToken.  Close handle to
	hProcImpToken.
	* grp.cc (internal_getgroups): Use hProcToken instead of hProcImpToken.
	* security.cc (check_access): Create hProcImpToken on demand here.
	* security.h (set_process_privilege): Set privileges on hProcToken.
	(_push_thread_privilege): Use hProcToken instead of hProcImpToken.
	(pop_thread_privilege): If not setuid'ed, revert to self.
	* syscalls.cc (setegid32): Drop setting primary group on hProcImpToken.
	Close handle to hProcImpToken.
	* uinfo.cc (internal_getlogin): Ditto.
	* winsup.h (clear_procimptoken): New inline function.
@
text
@a1906 2
  push_thread_privilege (SE_CHANGE_NOTIFY_PRIV, true);

a1970 2
  pop_thread_privilege ();

@


1.418
log
@* sigproc.cc (child_info::child_info): Initialize msv_count.
@
text
@d2421 1
a2421 3
  if (!SetTokenInformation (hProcImpToken, TokenPrimaryGroup, &gsid,
			    sizeof gsid))
    debug_printf ("SetTokenInformation(hProcImpToken, TokenPrimaryGroup), %E");
@


1.417
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d196 1
a196 1
        {
d198 1
a198 1
	  			sec_user ((PSECURITY_ATTRIBUTES) alloca (1024),
d311 1
a311 1
        RtlNtStatusToDosError (status);
d384 1
a384 1
        {
d1790 1
a1790 1
  		  res, fd, offset, len, advice);
d2233 1
a2233 1
        {
d3248 1
a3248 1
popen (const char *command, const char *type)
d3250 2
a3251 1
  int fds[2];
d3253 3
a3255 4
  if (pipe (fds) < 0)
    return NULL;
  int fd, other_fd, __stdin, __stdout, stdwhat;
  if (type[1] != '\0')
d3260 8
a3267 1
  if (*type == 'r')
d3269 1
d3274 2
a3275 3
    }
  else if (*type == 'w')
    {
d3280 3
a3282 5
    }
  else
    {
      set_errno (EINVAL);
      return NULL;
d3285 1
a3285 1
  FILE *fp = fdopen (fd, type);
@


1.416
log
@	* fhandler.cc (rootdir): Fix typo in comment.
	* syscalls.cc (try_to_bin): Ditto.
@
text
@d43 1
d3246 106
@


1.415
log
@	* autoload.cc (SHFileOperationA): Drop definition.
	* ntdll.h (struct _FILE_RENAME_INFORMATION): Define.
	* path.cc (fs_info::update): Note length of rootdir prefix in
	root_len.
	(get_nt_native_path): New function, taking over functionality of
	path_conv::get_nt_native_path.
	(path_conv::get_nt_native_path): Just call get_nt_native_path.
	* path.h (get_nt_native_path): Declare.
	(struct fs_info): New member root_len.
	(fs_info::length): New inline method returning root_len.
	(path_conv::rootdir): New inline method returning rootdir prefix.
	* syscalls.cc (try_to_bin): Rewrite using only system calls.
	(unlink_nt): Call try_to_bin with additional handle to open file
	parameter.
	(statvfs): Use path_conv::rootdir method.
	* wincap.h: Define has_recycle_dot_bin throughout.
	* wincap.cc: Ditto.
@
text
@d214 1
a214 1
  /* Length of thr WCHAR path in bytes. */
@


1.414
log
@	* syscalls.cc (try_to_bin): Add comment that this is not possibly
	the final version.
@
text
@a141 7
#ifndef FOF_NORECURSION
#define FOF_NORECURSION 0x1000
#endif
#ifndef FOF_NORECURSEREPARSE
#define FOF_NORECURSEREPARSE 0x8000
#endif

d143 1
a143 1
try_to_bin (const char *win32_path)
d145 63
a207 14
/* TODO: Using SHFileOperation for this functionality is incredibly slow.
	 Given the fact that we have an open handle to the file at this
	 point, there must be some quicker way to move the file to the
	 bin or something bin-like.  I keep this activated to remind me
	 by its slowness, that this can't go into a release version as
	 is.  Back to the drawing board. */

  /* The op.pFrom parameter must be double \0 terminated since it's not
     just a filename, but a list of filenames.  If the double \0 is
     missing, SHFileOperationA returns with error number 1026 (which is
     not a valid system error number). */
  char file[CYG_MAX_PATH + 1] = { 0 };
  SHFILEOPSTRUCT op;
  int ret;
d209 19
a227 16
  op.hwnd = NULL;
  op.wFunc = FO_DELETE;
  op.pFrom = strcpy (file, win32_path);
  op.pTo = NULL;
  op.fFlags = FOF_ALLOWUNDO
              | FOF_NOCONFIRMATION
              | FOF_NOCONFIRMMKDIR
              | FOF_NOERRORUI
              | FOF_NORECURSION
              | FOF_NORECURSEREPARSE
              | FOF_SILENT;
  op.fAnyOperationsAborted = FALSE;
  op.hNameMappings = NULL;
  op.lpszProgressTitle = NULL;
  ret = SHFileOperationA (&op);
  debug_printf ("SHFileOperation (%s) = %d\n", win32_path, ret);
d286 1
a286 1
    try_to_bin (win32_name.get_win32 ());
d1896 1
a1896 1
  if (!rootdir (full_path, root))
@


1.413
log
@	* syscalls.cc (unlink_nt): Open native symlinks with
	FILE_OPEN_REPARSE_POINT flag.
@
text
@d152 7
@


1.412
log
@	* ntdll.h (STATUS_DELETE_PENDING): Define.
	(struct _FILE_DISPOSITION_INFORMATION): Define.
	* syscalls.cc (unlink_9x): new function to delete file on 9x.
	* syscalls.cc (unlink_nt): new function to delete file on NT.
	(unlink): Simplify.  Move OS dependent stuff into aforementioned
	functions.  Also handle FILE_ATTRIBUTE_HIDDEN as R/O-like flag.
@
text
@d210 4
@


1.411
log
@	* autoload.cc (SHFileOperationA): Define.
	* syscalls.cc (try_to_bin): New function trying to move a file to
	the recycle bin.
	(unlink): Fix arguments used in CreateFile for delete on close.
	Before closing the handle, try to move the file to the recycle bin.
@
text
@d49 2
d178 83
d299 3
a301 1
  if (!((DWORD) win32_name & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
d309 2
a310 1
					| FILE_ATTRIBUTE_SYSTEM));
a311 2
  /* Attempt to use "delete on close" semantics to handle removing
     a file which may be open.
d313 8
a320 9
     CV 2004-09-17: Not if the file is on a remote share.  If two processes
     have open handles on a file and one of them calls unlink, then it
     happens that the file is remove from the remote share even though the
     other process still has an open handle.  This other process than gets
     Win32 error 59, ERROR_UNEXP_NET_ERR when trying to access the file.

     For some reason, that does not happen when using DeleteFile, which
     nicely succeeds but still, the file is available for the other process.
     To reproduce, mount /tmp on a remote share and call
d322 10
a331 32
       bash -c "cat << EOF"

     Microsoft KB 837665 describes this problem as a bug in 2K3, but I have
     reproduced it on shares on Samba 2.2.8, Samba 3.0.2, NT4SP6, XP64SP1 and
     2K3 and in all cases, DeleteFile works, "delete on close" does not. */
  if (!win32_name.isremote () && wincap.has_delete_on_close ())
    {
      HANDLE h;
      DWORD flags = FILE_FLAG_DELETE_ON_CLOSE;
      if (win32_name.is_rep_symlink ())
        flags |= FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS;
      h = CreateFile (win32_name, DELETE, wincap.shared (), &sec_none_nih,
		      OPEN_EXISTING, flags, 0);
      if (h != INVALID_HANDLE_VALUE)
	{
	  if (wincap.has_hard_links () && setattrs)
	    SetFileAttributes (win32_name, (DWORD) win32_name);
	  try_to_bin (win32_name.get_win32 ());
	  BOOL res = CloseHandle (h);
	  syscall_printf ("%d = CloseHandle (%p)", res, h);
	  if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	      || !win32_name.isremote ())
	    {
	      syscall_printf ("CreateFile (FILE_FLAG_DELETE_ON_CLOSE) succeeded");
	      goto ok;
	    }
	  else
	    {
	      syscall_printf ("CreateFile (FILE_FLAG_DELETE_ON_CLOSE) failed");
	      if (setattrs)
		SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
	    }
d333 2
a336 45
  /* Try a delete with attributes reset */
  if (win32_name.is_rep_symlink () && RemoveDirectory (win32_name))
    {
      syscall_printf ("RemoveDirectory after CreateFile/CloseHandle succeeded");
      goto ok;
    }
  else if (DeleteFile (win32_name))
    {
      syscall_printf ("DeleteFile after CreateFile/CloseHandle succeeded");
      goto ok;
    }

  DWORD lasterr;
  lasterr = GetLastError ();

  SetFileAttributes (win32_name, (DWORD) win32_name);

  /* Windows 9x seems to report ERROR_ACCESS_DENIED rather than sharing
     violation.  So, set lasterr to ERROR_SHARING_VIOLATION in this case
     to simplify tests. */
  if (wincap.access_denied_on_delete () && lasterr == ERROR_ACCESS_DENIED
      && !win32_name.isremote ())
    lasterr = ERROR_SHARING_VIOLATION;

  /* FILE_FLAGS_DELETE_ON_CLOSE was a bust.  If this is a sharing
     violation, then queue the file for deletion when the process
     exits.  Otherwise, punt. */
  if (lasterr != ERROR_SHARING_VIOLATION)
    goto err;

  syscall_printf ("couldn't delete file, err %d", lasterr);

  /* Add file to the "to be deleted" queue. */
  user_shared->delqueue.queue_file (win32_name);

 /* Success condition. */
 ok:
  res = 0;
  goto done;

 /* Error condition. */
 err:
  __seterrno ();
  res = -1;

@


1.410
log
@	* security.cc (create_token): Revert erroneous change to test
	subauth_token for INVAILD_HANDLE_VALUE.
	* syscalls.cc (seteuid32): Set create_token's subauth_token parameter
	back to NULL.
@
text
@d48 1
d140 36
d248 1
a248 1
      h = CreateFile (win32_name, 0, FILE_SHARE_READ, &sec_none_nih,
d254 1
@


1.409
log
@	* cyglsa.h: New header file.
	* environ.cc: Disable subauth settings.
	* grp.cc: Accomodate cygsidlist's count now being a method.
	* sec_helper.cc (SECURITY_MANDATORY_INTEGRITY_AUTHORITY): Remove.
	(mandatory_medium_integrity_sid): Remove.
	(mandatory_high_integrity_sid): Remove.
	(mandatory_system_integrity_sid): Remove.
	(fake_logon_sid): Add.
	(cygsid::get_sid): Add well_known parameter.  Set well_known_sid
	accordingly.
	(cygsid::getfromstr): Ditto.
	(cygsidlist::alloc_sids): Move here from security.cc.
	(cygsidlist::free_sids): Ditto.
	(cygsidlist::add): Move here from security.h.  Add well_known parameter.
	Set well_known_sid accordingly.  Don't allow duplicate SIDs.
	* security.cc: Include cyglsa.h and cygwin/version.h.  Throughout
	accomodate cygsidlist's count now being a method.  Throughout drop
	redundant "contains" tests.
	(get_user_local_groups): Add local groups as well known SIDs.
	(get_token_group_sidlist): Add well known groups as well known SIDs.
	(get_server_groups): Ditto.  Only call get_unix_group_sidlist after
	get_user_local_groups to maintain "well_known_sid" attribute.
	(get_initgroups_sidlist): Add well known groups as well known SIDs.
	(get_setgroups_sidlist): Add usersid and struct passwd parameter to
	allow calling get_server_groups from here.
	(get_system_priv_list): Make static.  Return size of TOKEN_PRIVILEGES
	structure.
	(get_priv_list): Ditto.
	(create_token): Accomodate above changes.  Drop misguided attempt to
	add MIC SIDs to created user token.  Print returned token as hex value.
	(subauth): Disable.
	(lsaauth): New function implementing client side of LSA authentication.
	* security.h (class cygsid): Add well_known_sid attribute.  Accomodate
	throughout.  Add *= operator to create a well known SID.
	(class cygsidlist): Rename count to cnt.  Make count a method.
	(cygsidlist::add): Move to sec_helper.cc.
	(cygsidlist::operator *=): New method to add well known SID.
	(cygsidlist::non_well_known_count): New method returning number of
	non well known SIDs in list.
	(cygsidlist::next_non_well_known_sid): New method returning next non
	well known SID by index.
	(mandatory_medium_integrity_sid): Drop declaration.
	(mandatory_high_integrity_sid): Drop declaration.
	(mandatory_system_integrity_sid): Drop declaration.
	(fake_logon_sid): Add declaration.
	(subauth): Disable declaration.
	(lsaauth): Add declaration.
	* syscalls.cc (seteuid32): Disable subauthentication.  Add LSA
	authentication.
	* wincap.h: Define needs_logon_sid_in_sid_list throughout.
	* wincap.cc: Ditto.
@
text
@d2143 1
a2143 2
	  new_token = create_token (usersid, groups, pw_new,
				    INVALID_HANDLE_VALUE);
@


1.408
log
@	* fhandler.cc (check_posix_perm): Moved here from syscalls.cc.
	(fhandler_base::fpathconf): New method implementing (f)pathconf.
	* fhandler.h (class fhandler_base): Declare fpathconf method.
	* path.cc (path_conv::check): Replace MAX_LINK_DEPTH with SYMLOOP_MAX.
	* path.h (MAX_LINK_DEPTH): Delete.
	* syscalls.cc (check_posix_perm): Move to fhandler.cc.
	(fpathconf): Call fhandler's fpathconf method.
	(pathconf): Build fhandler and call fhandler's fpathconf method.
	* sysconf.cc (sysconf): Reorder switch according to order of flags
	in sys/unistd.h.  Add handling for some missing flags.
	* include/limits.h: Reorder according to SUSv3 description.  Add some
	missing definitions.  Add comments.
	* include/sys/syslimits.h: New file overriding newlib's syslimits.h
	file.
@
text
@d2114 1
a2114 1
     authenticate using NtCreateToken () or subauthentication. */
d2117 28
a2144 6
      new_token = subauth (pw_new);
      debug_printf ("subauth %s, try create_token.",
		    new_token == INVALID_HANDLE_VALUE ? "failed" : "succeeded");
      HANDLE new_token2 = create_token (usersid, groups, pw_new, new_token);
      if (new_token2 == INVALID_HANDLE_VALUE)
	{
d2151 1
a2151 8
	  debug_printf ("create_token failed, use original subauth token");
	}
      else
        {
	  debug_printf ("create_token succeeded");
	  if (new_token != INVALID_HANDLE_VALUE)
	    CloseHandle (new_token);
	  new_token = new_token2;
d2153 1
@


1.407
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop
	directory attribute for reparse points to avoid mistreating.
	(fhandler_base::fstat_by_name): Ditto.
	* path.cc (symlink_info::check_reparse_point): New method testing
	reparse points for symbolic links.
	(symlink_info::check_shortcut): Move file attribute tesat to calling
	function.
	(symlink_info::check): Add handling for reparse points.
	* path.h (enum path_types): Add PATH_REP to denote reparse point based
	symlinks.
	(path_conv::is_rep_symlink): New method.
	* syscalls.cc (unlink): Handle reparse points.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
a1462 32
static int
check_posix_perm (const char *fname, int v)
{
  /* Windows 95/98/ME don't support file system security at all. */
  if (!wincap.has_security ())
    return 0;

  /* ntea is ok for supporting permission bits but it doesn't support
     full POSIX security settings. */
  if (v == _PC_POSIX_PERMISSIONS && allow_ntea)
    return 1;

  if (!allow_ntsec)
    return 0;

  char *root = rootdir (fname, (char *)alloca (strlen (fname)));

  if (!allow_smbntsec
      && ((root[0] == '\\' && root[1] == '\\')
	  || GetDriveType (root) == DRIVE_REMOTE))
    return 0;

  DWORD vsn, len, flags;
  if (!GetVolumeInformation (root, NULL, 0, &vsn, &len, &flags, NULL, 16))
    {
      __seterrno ();
      return 0;
    }

  return (flags & FS_PERSISTENT_ACLS) ? 1 : 0;
}

d1470 1
a1470 39
  switch (v)
    {
    case _PC_LINK_MAX:
      return _POSIX_LINK_MAX;
    case _PC_MAX_CANON:
    case _PC_MAX_INPUT:
      if (isatty (fd))
	return _POSIX_MAX_CANON;
      else
	{
	  set_errno (EBADF);
	  return -1;
	}
    case _PC_NAME_MAX:
    case _PC_PATH_MAX:
      return PATH_MAX;
    case _PC_PIPE_BUF:
      return PIPE_BUF;
    case _PC_CHOWN_RESTRICTED:
    case _PC_NO_TRUNC:
      return -1;
    case _PC_VDISABLE:
      if (cfd->is_tty ())
	return -1;
      else
	{
	  set_errno (EBADF);
	  return -1;
	}
    case _PC_POSIX_PERMISSIONS:
    case _PC_POSIX_SECURITY:
      if (cfd->get_device () == FH_FS)
	return check_posix_perm (cfd->get_win32_name (), v);
      set_errno (EINVAL);
      return -1;
    default:
      set_errno (EINVAL);
      return -1;
    }
d1476 2
d1486 4
a1489 1
  switch (v)
d1491 1
a1491 35
    case _PC_PATH_MAX:
      return PATH_MAX - strlen (file);
    case _PC_NAME_MAX:
      return PATH_MAX;
    case _PC_LINK_MAX:
      return _POSIX_LINK_MAX;
    case _PC_MAX_CANON:
    case _PC_MAX_INPUT:
      return _POSIX_MAX_CANON;
    case _PC_PIPE_BUF:
      return PIPE_BUF;
    case _PC_CHOWN_RESTRICTED:
    case _PC_NO_TRUNC:
      return -1;
    case _PC_VDISABLE:
      return -1;
    case _PC_POSIX_PERMISSIONS:
    case _PC_POSIX_SECURITY:
      {
	path_conv full_path (file, PC_SYM_FOLLOW,
			     transparent_exe ? stat_suffixes : NULL);
	if (full_path.error)
	  {
	    set_errno (full_path.error);
	    return -1;
	  }
	if (full_path.is_auto_device ())
	  {
	    set_errno (EINVAL);
	    return -1;
	  }
	return check_posix_perm (full_path, v);
      }
    default:
      set_errno (EINVAL);
d1494 1
@


1.406
log
@	* grp.cc (initgroups32): Run get_server_groups under original token.
	* syscalls.cc (seteuid32): Slightly reorganize code creating a token.
@
text
@d208 3
d212 1
a212 1
		      OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
d235 6
a240 1
  if (DeleteFile (win32_name))
@


1.405
log
@	* autoload.cc (NtSetInformationFile): Define.
	* cygwin.din: Export posix_fadvise and posix_fallocate.
	* fhandler.cc (fhandler_base::fadvise): New method.
	(fhandler_base::ftruncate): Add allow_truncate parameter.
	* fhandler.h (class fhandler_base): Add fadvise method.  Accomodate
	new parameter to ftruncate.
	(class fhandler_pipe): Add fadvise and ftruncate methods.
	(class fhandler_disk_file): Add fadvise method.  Accomodate new
	parameter to ftruncate.
	* fhandler_disk_file.cc (fhandler_disk_file::fadvise): New method.
	(fhandler_disk_file::ftruncate): Accomodate new allow_truncate
	parameter.  Set EOF using NtSetInformationFile on NT.
	* ntdll.h (struct _FILE_END_OF_FILE_INFORMATION): Define.
	(NtSetInformationFile): Declare.
	* pipe.cc (fhandler_pipe::fadvise): New method.
	(fhandler_pipe::ftruncate): Ditto.
	* syscalls.cc (posix_fadvise): New function.
	(posix_fallocate): Ditto.
	(ftruncate64): Accomodate second parameter to fhandler's ftruncate
	method.
	* include/fcntl.h: Add POSIX_FADV_* flags.  Add declarations of
	posix_fadvise and posix_fallocate.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d2208 4
a2211 1
      if (new_token == INVALID_HANDLE_VALUE)
a2212 2
	  debug_printf ("subauthentication failed, try create token.");
	  new_token = create_token (usersid, groups, pw_new, NULL);
d2215 1
d2219 1
d2223 4
a2226 9
	  debug_printf ("subauthentication succeeded, try create token.");
	  HANDLE new_token2 = create_token (usersid, groups, pw_new, new_token);
	  if (new_token2 == INVALID_HANDLE_VALUE)
	    debug_printf ("create token failed, use original token");
	  else
	    {
	      CloseHandle (new_token);
	      new_token = new_token2;
	    }
@


1.404
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@d1756 32
d1793 1
a1793 1
    res = cfd->ftruncate (length);
@


1.403
log
@white space
@
text
@d2175 1
a2175 1
      new_token = create_token (usersid, groups, pw_new);
d2178 2
a2179 3
	  /* create_token failed. Try subauthentication. */
	  debug_printf ("create token failed, try subauthentication.");
	  new_token = subauth (pw_new);
d2186 12
@


1.403.4.1
log
@2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d1004 1
a1004 1
	GetVolumeNameForVolumeMountPointA ("B:\\", b_drive, CYG_MAX_PATH);
@


1.403.4.2
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@a42 1
#include <sys/wait.h>
a3164 111

extern "C" FILE *
popen (const char *command, const char *in_type)
{
  const char *type = in_type;
  char rw = *type++;

  if (*type == 'b' || *type == 't')
    type++;
  if ((rw != 'r' && rw != 'w') || (*type != '\0'))
    {
      set_errno (EINVAL);
      return NULL;
    }

  int fd, other_fd, __stdin, __stdout, stdwhat;

  int fds[2];
  if (pipe (fds) < 0)
    return NULL;

  switch (rw)
    {
    case 'r':
      __stdin = -1;
      stdwhat = 1;
      other_fd = __stdout = fds[1];
      fd = fds[0];
      break;
    case 'w':
      __stdout = -1;
      stdwhat = 0;
      other_fd = __stdin = fds[0];
      fd = fds[1];
      break;
    default:
      return NULL;	/* avoid a compiler warning */
    }

  FILE *fp = fdopen (fd, in_type);
  fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);

  if (!fp)
    goto err;

  pid_t pid;
  const char *argv[4];

  argv[0] = "/bin/sh";
  argv[1] = "-c";
  argv[2] = command;
  argv[3] = NULL;

  {
    lock_process now;
    int state = fcntl (stdwhat, F_GETFD, 0);
    fcntl (stdwhat, F_SETFD, state | FD_CLOEXEC);
    pid = spawn_guts ("/bin/sh", argv, cur_environ (), _P_NOWAIT,
		      __stdin, __stdout);
    fcntl (stdwhat, F_SETFD, state);
  }

  if (pid < 0)
    goto err;
  close (other_fd);

  fhandler_pipe *fh = (fhandler_pipe *) cygheap->fdtab[fd];
  fh->set_popen_pid (pid);

  return fp;

err:
  int save_errno = get_errno ();
  close (fds[0]);
  close (fds[1]);
  set_errno (save_errno);
  return NULL;
}

int
pclose (FILE *fp)
{
  fhandler_pipe *fh = (fhandler_pipe *) cygheap->fdtab[fileno(fp)];

  if (fh->get_device () != FH_PIPEW && fh->get_device () != FH_PIPER)
    {
      set_errno (EBADF);
      return -1;
    }

  int pid = fh->get_popen_pid ();
  if (!pid)
    {
      set_errno (ECHILD);
      return -1;
    }

  if (fclose (fp))
    return -1;

  int status;
  while (1)
    if (waitpid (pid, &status, 0) == pid)
      break;
    else if (get_errno () == EINTR)
      continue;
    else
      return -1;

  return status;
}
@


1.403.4.3
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d605 2
a606 3
	  if (!(fh = build_fh_name (unix_path, NULL,
				    (flags & (O_NOFOLLOW | O_EXCL))
				    ?  PC_SYM_NOFOLLOW : PC_SYM_FOLLOW,
@


1.403.2.1
log
@	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.
@
text
@d2175 1
a2175 1
      new_token = subauth (pw_new);
d2178 3
a2180 2
	  debug_printf ("subauthentication failed, try create token.");
	  new_token = create_token (usersid, groups, pw_new, NULL);
a2186 12
      else
        {
	  debug_printf ("subauthentication succeeded, try create token.");
	  HANDLE new_token2 = create_token (usersid, groups, pw_new, new_token);
	  if (new_token2 == INVALID_HANDLE_VALUE)
	    debug_printf ("create token failed, use original token");
	  else
	    {
	      CloseHandle (new_token);
	      new_token = new_token2;
	    }
	}
@


1.402
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Regenerate.
(child_info::retry): Move here from fork subclass.
(child_info::exit_code): New field.
(child_info::retry_count): Max retry count for process start.
(child_info::proc_retry): Declare new function.
(child_info_fork::retry): Move to parent.
(child_info_fork::fork_retry): Ditto.
* dcrt0.cc (child_info::fork_retry): Rename and move.
(child_info_fork::handle_failure): Move.
(dll_crt0_0): Initialize console handler based on whether we have a controlling
tty or not.  Avoid nonsensical check for fork where it can never occur.
* environ.cc (set_proc_retry): Rename from set_fork_retry.  Set retry_count in
child_info.
(parse_thing): Reflect above change.
* exceptions.cc (dummy_ctrl_c_handler): Remove unused variable name.
(ctrl_c_handler): Always return TRUE for the annoying CTRL_LOGOFF_EVENT.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Remove call to
init_console_handler.
* fhandler_tty.cc (fhandler_tty_slave::open): Just call mange_console_count
here and let it decide what to do with initializing console control handling.
* fork.cc (fork_retry): Remove definition.
(frok::parent): Define static errbuf and use in error messages (not thread safe
yet).  Close pi.hThread as soon as possible.  Protect pi.hProcess as soon as
possible.  Don't set retry_count.  That happens automatically in the
constructor now.  Accommodate name change from fork_retry to proc_retry.
* init.cc (dll_entry): Turn off ctrl-c handling early until we know how it is
supposed to be handled.
* pinfo.cc (_pinfo::dup_proc_pipe): Remember original proc pipe value for
failure error message.  Tweak debug message slightly.
* sigproc.cc (child_info::retry_count): Define.
(child_info::child_info): Initialize retry count.
(child_info::sync): Set exit code if process dies before synchronization.
(child_info::proc_retry): Rename from child_info_fork::fork_retry.  Use
previously derived exit code.  Be more defensive about what is classified as an
error exit.
(child_info_fork::handle_failure): Move here from dcrt0.cc.
* spawn.cc (spawn_guts): Maintain error mode when starting new process to avoid
annoying pop ups.  Move deimpersonate call within new loop.  Move envblock
freeing to end.  Loop if process dies prematurely with bad exit code.
* syscalls.cc (init_console_handler): Remove hopefully unneeded call to
init_console_handler.
@
text
@d146 1
a146 1
  			transparent_exe ? stat_suffixes : NULL);
d1235 1
a1235 1
        {
d1376 1
a1376 1
         symlink has been renamed.  Otherwise we end up with two files of
d1381 1
a1381 1
        {
d1881 1
a1881 1
	        debug_printf ("CreateFile (%s) failed, %E", (char *) full_path);
d1883 1
a1883 1
	        {
@


1.401
log
@	* syscalls.cc (rename): Move existance check for oldpath further up
	to the start of the function.  Avoid another case of a name collision
	if oldpath is a shortcut and a file or directory newpath already exists.
@
text
@a1989 1
	  // init_console_handler (FALSE);
@


1.400
log
@* cygtls.h (_cygtls::retaddr): New method.
* dll_init.cc (cygwin_detach_dll): Use new tls function to find return address
since this function is now signal guarded.
(update_envptrs): Remove unneeded braces.
* syscalls.cc (statvfs): Coerce full_path to avoid a gcc warning.
@
text
@d1179 1
d1191 7
d1209 15
a1250 7
  if (!real_old.exists ()) /* file to move doesn't exist */
    {
      syscall_printf ("file to move doesn't exist");
      set_errno (ENOENT);
      return -1;
    }

d1374 12
@


1.399
log
@	* syscalls.cc (statvfs): Simplify path name expression.
@
text
@d1853 1
a1853 1
	        debug_printf ("CreateFile (%s) failed, %E", full_path);
d1860 1
a1860 1
		    debug_printf ("DeviceIoControl (%s) failed, %E", full_path);
@


1.398
log
@	* syscalls.cc: Include winioctl.h.
	(statvfs): Request correct volume size using DeviceIoControl if
	quotas are enforced on the file system.
@
text
@d1848 1
a1848 1
	      HANDLE hdl = CreateFile (full_path.get_win32 (), READ_CONTROL,
d1853 1
a1853 1
	        debug_printf ("CreateFile (%s) failed, %E", full_path.get_win32 ());
d1860 1
a1860 1
		    debug_printf ("DeviceIoControl (%s) failed, %E", full_path.get_win32 ());
@


1.397
log
@	* syscalls.cc (chroot): Disallow chroot into special directories.
	Return EPERM instead.
@
text
@d45 1
d1845 21
@


1.396
log
@	* environ.cc (struct parse_thing): Add transparent_exe option.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Accomodate
	transparent_exe option.  Add .exe suffix for links to executable files,
	if transparent_exe is set.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Remove .exe
	suffix if transparent_exe option is set.
	* path.cc (symlink_worker): Accomodate transparent_exe option.
	(realpath): Don't tack on .exe suffix if transparent_exe is set.
	* syscalls.cc (transparent_exe): New global variable.
	(unlink): Accomodate transparent_exe option.
	(open): Ditto.
	(link): Ditto.
	(rename): Ditto. Maybe add .exe suffix when renaming executable files.
	(pathconf): Accomodate transparent_exe option.
	* winsup.h: Declare transparent_exe.
@
text
@d2362 2
@


1.395
log
@	* cygwin.din (updwtmpx): Export.
	* syscalls.cc (updwtmpx): New function.
	* include/utmpx.h (updwtmpx): Declare.
	* include/cygwin/version.h: Bump API minor number to 153.
@
text
@d87 2
d144 2
a145 1
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW);
d604 2
a605 1
				    PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)))
d729 2
a730 1
  if (!(fh = build_fh_name (oldpath, NULL, PC_SYM_NOFOLLOW)))
d1179 2
a1180 1
  path_conv real_old (oldpath, PC_SYM_NOFOLLOW);
d1189 2
a1190 1
  path_conv real_new (newpath, PC_SYM_NOFOLLOW);
d1192 26
a1217 8
  /* Shortcut hack. */
  char new_lnk_buf[CYG_MAX_PATH + 5];
  if (real_old.is_lnk_special () && !real_new.error && !real_new.case_clash)
    {
      strcpy (new_lnk_buf, newpath);
      strcat (new_lnk_buf, ".lnk");
      newpath = new_lnk_buf;
      real_new.check (newpath, PC_SYM_NOFOLLOW);
d1538 2
a1539 1
	path_conv full_path (file, PC_SYM_FOLLOW);
@


1.394
log
@	* fhandler.h (fhandler_base::issymlink): New method.
	* syscalls.cc (open): Handle O_NOFOLLOW flag.
	* include/fcntl.h (_FNOFOLLOW): New define.
	(O_NOFOLLOW): Ditto.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d2881 7
@


1.393
log
@	* autoload.cc (NtCreateSection): Define.
	* cygheap.cc (_csbrk): Call getpagesize instead of getshmlba.
	* dcrt0.cc (dll_crt0_0): Call mmap_init.
	* external.cc (cygwin_internal): Call getpagesize instead of getshmlba.
	* fhandler.h (fhandler_base::mmap): Change access to prot parameter.
	(fhandler_base::fixup_mmap_after_fork): Ditto.
	(fhandler_disk_file::mmap): Ditto.
	(fhandler_disk_file::fixup_mmap_after_fork): Ditto.
	(fhandler_dev_mem::mmap): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::write): Call getsystempagesize
	instead of getpagesize.
	(fhandler_dev_mem::read): Ditto.
	(fhandler_dev_mem::fstat): Ditto.
	(fhandler_dev_mem::mmap): Move to mmap.cc.
	(fhandler_dev_mem::munmap): Ditto.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_proc.cc (format_proc_meminfo): Call getsystempagesize
	instead of getpagesize.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(get_mem_values): Ditto.
	* mmap.cc: Fix formatting.  Try to make more readable and modular.
	Take advantage of pagesize==granularity.
	(gen_protect): New static function to evaluate Windows
	protection bits from POSIX protection and flags.
	(gen_access): Ditto for Windows access mode.
	(VirtualProt9x): Wrapper function to call VirtualProtect on 9x.
	(VirtualProtNT): Ditto for NT.
	(VirtualProtEx9x): Ditto for VirtualProtectEx on 9x.
	(VirtualProtExNT): Ditto for NT.
	(CreateMapping9x): Wrapper function for creating a mapping handle on 9x.
	(CreateMappingNT): Ditto for NT.
	(MapView9x): Wrapper function to map a view on 9x.
	(MapViewNT): Ditto for NT.
	(mmap_funcs_9x): Structure containing function pointers to wrapper
	functions for 9x.
	(mmap_funcs_nt): Ditto for NT.
	(mmap_func): Pointer to wrapper functions used in subsequent code.
	(mmap_init): Initialize mmap_func depending on OS.
	(class mmap_record): Use sensible member names.  Add POSIX protection
	member. Drop Windows access flags member.  Constify more methods.
	Use accessors instead of direct member access inside of own methods.
	(mmap_record::gen_protect): Class wrapper to evaluate matching
	Windows protection bits.
	(mmap_record::gen_access): Ditto for Windows access flags.
	(mmap_record::compatible_flags): New function to check if flags are
	compatible with flags of existing map.
	(list::add_record): Drop offset and length arguments.
	(class map): Change counters to unsigned.  Match usage throughout.
	(mmapped_areas): Convert from pointer to global struct.
	(mmap_record::alloc_page_map): Simplify.
	(mmap_record::map_pages): Ditto.
	(mmap_record::fixup_page_map): Delete.
	(mmap64): Simplify.  Add workaround for Windows 98 bug.  Fix bug on
	NT that existing anonymous mappings weren't searched for a match.
	(munmap): Add workaround for Windows 98 bug.
	(msync): Simplify.
	(mprotect): Handle existing maps correctly.
	(mlock): Add local pagesize variable and enlightening comment.
	(fhandler_disk_file::mmap): Main functionality now in CreateMapping/
	MapView wrapper functions.
	(fhandler_disk_file::fixup_mmap_after_fork): Call MapView wrapper.
	(fhandler_dev_mem::mmap): Moved from fhandler_mem.cc.  Simplify by
	calling MapViewNT.
	(fhandler_dev_mem::munmap): Moved from fhandler_mem.cc.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.  Call MapViewNT.
	(fixup_mmaps_after_fork): Restructure and hopefully speed up loop for
	setting protection and memory content on MAP_PRIVATE maps.
	* ntdll.h (AT_ROUND_TO_PAGE): Remove define.
	(AT_EXTENDABLE_FILE): Add define.
	(NtCreateSection): Add prototype.
	* syscalls.cc (getpagesize): Return granularity as pagesize now.
	(getsystempagesize): New function to retrieve "real" pagesize.
	(getshmlba): Delete since it's replaced by getpagesize now.
	* wincap.h (wincaps::has_mmap_alignment_bug): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (getshmlba): Drop prototype.
	(getsystempagesize): Add prototype.
	(mmap_init): Ditto.
	* include/sys/mman.h: (Not yet) define MAP_NORESERVE.
@
text
@d600 2
a601 1
	  if (!(fh = build_fh_name (unix_path, NULL, PC_SYM_FOLLOW)))
d603 6
@


1.392
log
@* fhandler.h (fhandler_console::fixup_after_fork_exec): Declare new function.
(fhandler_console::fixup_after_fork): Use fixup_after_fork_exec.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Delete definition.
(fhandler_console::fixup_after_fork_exec): Rename from fixup_after_exec.
* pinfo.cc (_pinfo::set_ctty): Don't play with console count here.
* syscalls.cc (close_all_files): Don't close cygheap ctty if hExeced since the
child will be copying information from us.
(setsid): Use myctty() rather than raw ctty #.
@
text
@d1383 1
a1383 1
  return (int) system_info.dwPageSize;
d1387 1
a1387 1
getshmlba ()
d1391 1
a1391 1
  return system_info.dwAllocationGranularity;
@


1.391
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d117 1
a117 1
  if (cygheap->ctty)
d350 1
a350 2
      syscall_printf ("sid %d, pgid %d, ctty %d", myself->sid, myself->pgid,
		      myself->ctty);
@


1.390
log
@* dcrt0.cc (get_exit_lock): Use myself.lock rather than exit_lock.
* exceptions.cc (exit_lock): Delete.
(events_init): Don't init exit_lock.
* (_pinfo::commune_process): Add per-PICOM debugging.
* sigproc.cc (talktome): Add some temporary debugging statements.
* fhandler_proc.cc (format_proc_cpuinfo): Cosmetic change.
(format_proc_partitions): Ditto.
* syscalls.cc (locked_append): Ditto.
@
text
@a343 5
      if (myself->ctty >= 0 && cygheap->open_fhs <= 0)
	{
	  syscall_printf ("freeing console");
	  FreeConsole ();
	}
d345 1
d350 2
a351 2
      syscall_printf ("sid %d, pgid %d, ctty %d, open_fhs %d", myself->sid,
		      myself->pgid, myself->ctty, cygheap->open_fhs);
@


1.389
log
@	* syscalls.cc (endusershell): Reset shell_fp to NULL to allow
	subsequent getusershell calls.
@
text
@d2613 1
a2613 1
    if ((lock_buffer.l_start = lseek64 (fd, 0, SEEK_END)) != (_off64_t)-1
d2616 1
a2616 1
	if (lseek64 (fd, 0, SEEK_END) != (_off64_t)-1)
@


1.388
log
@white space
@
text
@d3055 4
a3058 1
    fclose (shell_fp);
@


1.387
log
@* fhandler.h (fhandler_base::pread): Declare new function.
(fhandler_base::pwrite): Ditto.
(fhandler_disk_file::pread): Ditto.
(fhandler_disk_file::pwrite): Ditto.
* fhandler.cc (fhandler_base::pread): Define new function.
(fhandler_base::pwrite): Ditto.
* fhandler_disk_file.cc (fhandler_base::pread): Ditto.
(fhandler_base::pwrite): Ditto.
* syscalls.cc (pread): Define new function.
(pwrite): Ditto.
* cygwin.din: Export pread, pwrite.
* include/sys/ioctl.h: Guard some _IO* declarations to avoid conflict with
socket.h.
@
text
@d1802 1
a1802 1
         a drive letter.  Fake, fake, hoorah. */
d1807 1
a1807 1
        spc >>= 1;
@


1.386
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d23 2
d51 2
d395 30
@


1.385
log
@* cygtls.h (_cygtls): Perform minor reformatting.
* winsup.h (close_all_files): Reflect argument change.
* dtable.cc (close_all_files): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* spawn.cc (spawn_guts): Move close_all_files back to its original location in
first P_OVERLAY test but use argument denoting that handles are only supposed
to be closed, not released (more work to be done here).
* syscalls.cc (close_all_files): Take an argument denoting whether to release
closed files or not.
* path.cc (symlink): Change argument names to reflect linux man page.
(symlink_worker): Ditto.  Also appropriately set ENOENT for empty strings.
@
text
@d205 1
a205 1
	    (void) SetFileAttributes (win32_name, (DWORD) win32_name);
d233 1
a233 1
  (void) SetFileAttributes (win32_name, (DWORD) win32_name);
@


1.384
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d97 1
a97 1
close_all_files ()
d109 2
a110 1
	cygheap->fdtab.release (i);
@


1.383
log
@	* fhandler.cc (rootdir): Don't set errno.
	* syscalls.cc (statvfs): Set errno to ENOTDIR if rootdir() failed.
@
text
@d553 6
a558 1
  if (!check_null_empty_str_errno (unix_path))
d1016 2
a1017 1
  if (check_null_invalid_struct_errno (buf))
d1308 2
a1309 1
  if (check_null_empty_str_errno (cmdstring))
d1315 1
a1315 1
  if (cmdstring == (const char *) NULL)
d1447 8
a1457 2
      if (check_null_empty_str_errno (file))
	  return -1;
d1499 3
a1501 2
  if (__check_null_invalid_struct (buf, buflen))
    ret = EINVAL;
d1730 2
a1731 2
  if (check_null_empty_str_errno (fname)
      || check_null_invalid_struct_errno (sfs))
d1733 5
d1820 2
a1821 1
  if (check_null_invalid_struct_errno (sfs))
d1860 1
a1860 4
    {
      set_errno (EINVAL);
      goto out;
    }
d1865 3
a1867 4
	{
	  set_errno (ESRCH);
	  goto out;
	}
d1869 3
a1871 1
      if (p == myself || p->ppid == myself->pid)
d1877 1
a1877 5
	}
      else
	{
	  set_errno (EPERM);
	  goto out;
d1880 1
a1880 1
out:
d1941 2
a1942 1
  if (check_null_empty_str_errno (path))
d1944 5
d2650 2
a2651 1
  if (check_null_empty_str (file))
d2702 2
a2703 1
  if (check_null_invalid_struct_errno (id))
d2741 2
a2742 1
  if (check_null_invalid_struct_errno (line))
d2764 2
a2765 1
  if (check_null_invalid_struct (ut))
d2813 2
a2814 1
  if (__check_invalid_read_ptr (id, sizeof *id))
d2825 2
a2826 1
  if (__check_invalid_read_ptr (line, sizeof *line))
d2837 2
a2838 1
  if (__check_invalid_read_ptr (utmpx, sizeof *utmpx))
@


1.382
log
@	* syscalls.cc (statvfs): Handle the case when GetDiskFreeSpaceEx
	succeeds but GetDiskFreeSpace fails by faking bytes-per-sector and
	sectors-per-cluster values.
@
text
@d1730 4
a1733 1
    return -1;
@


1.381
log
@* cygtls.h (_local_storage::setmode_file): New element.
(_local_storage::setmode_mode): New element.
* tlsoffsets.h: Regenerate.
* cygwin.din (setmode): Define as cygwin_getmode.
* syscalls.cc (setmode_helper): Use setmode_* variables from tls rather than
using unthreadsafe static.
(setmode): Break out fwalk stuff.
(cygwin_setmode): New function.  Put fwalk stdio stuff here.
@
text
@d1734 1
a1734 1
  BOOL status;
d1740 13
a1752 2
  status = GetDiskFreeSpaceEx (root, &availb, &totalb, &freeb);
  if (GetDiskFreeSpace (root, &spc, &bps, &freec, &totalc))
d1754 1
a1754 1
      if (status)
@


1.380
log
@	* pinfo.cc (pinfo::init): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	(pinfo::set_acl): Replace sa_buf by dynamically allocated acl_buf.
	* sec_acl.cc (setacl): Allocate acl dynamically.
	* sec_helper.cc (sec_acl): Add test for alignment of acl when
	DEBUGGING is defined.
	(__sec_user): Same for sa_buf.
	* security.cc (verify_token): Define sd_buf as PSECURITY_DESCRIPTOR
	and allocate dynamically.
	(alloc_sd): Allocate acl dynamically.
	security.h (sec_user_nih): Change first parameter to
	SECURITY_ATTRIBUTES *.
	(sec_user): Ditto.
	* sigproc.cc (wait_sig): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	* syscalls.cc (seteuid32): Define dacl_buf as PACL and allocate
	dynamically.
	* uinfo.cc (cygheap_user::init): Define sa_buf as PSECURITY_ATTRIBUTES
	and allocate dynamically.
	* winbase.h (ilockincr): Mark first argument of inline assembly as
	earlyclobber.
	(ilockdecr): Ditto.
@
text
@a1567 3
static int setmode_mode;
static int setmode_file;

d1571 1
a1571 1
  if (fileno (f) != setmode_file)
d1573 1
a1573 1
      syscall_printf ("improbable, but %d != %d", fileno (f), setmode_file);
d1577 2
a1578 2
		  setmode_mode & O_TEXT ? "text" : "binary");
  if (setmode_mode & O_TEXT)
a1627 7
  if (_cygwin_istext_for_stdio (fd))
    setmode_mode = O_TEXT;
  else
    setmode_mode = O_BINARY;
  setmode_file = fd;
  _fwalk (_GLOBAL_REENT, setmode_helper);

d1634 16
@


1.379
log
@Revert 2005-05-30 close_all_files changes.
* spawn.cc (spawn_guts): When execing, close all files after the child has
synced with us.
@
text
@d2056 2
a2057 2
      char dacl_buf[MAX_DACL_LEN (5)];
      if (sec_acl ((PACL) dacl_buf, true, true, usersid))
d2059 1
a2059 1
	  TOKEN_DEFAULT_DACL tdacl = { (PACL) dacl_buf };
@


1.378
log
@* child_info.h (child_info::cygheap_h): Delete.
(child_info::dwProcessId): New field.
* cygheap.cc (init_cheap): Delete.
(dup_now): Ditto.
(cygheap_setup_for_child): Ditto.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_fixup_in_child): Simplify.  Use new "child_copy" function to copy heap
from parent.
(_csbrk): Don't attempt allocation if within cygheap section.  Fix so that more
than one allocation will succeed.
(cygheap_init): Reset possibly-nonzero region to zero.
* cygheap.h (cygheap_setup_for_child): Delete declaration.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_start): Define as an array.
* cygwin.sc: Modernize.  Remove unneeded sections.  Define cygheap here.
* dcrt0.cc (do_exit): Reflect argument change to close_all_files.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* fork.cc (fork_copy): Call ReadProcessMemory if there is no thread
(indicating that we're execing).
(fork_child): Don't mess with hParent.
(fork_parent): Remove hParent stuff.  It happens earlier now.  Remove call to
cygheap_setup_for_child* stuff.
(fork): Put child_info_stuff in grouped structure.  Issue error if parent
handle is not set.
(child_copy): New function.
* sigproc.cc (child_info::child_info): Put cygheap settings here.  Set parent
handle.
(child_info::~child_info): Close parent handle if it exists.
* spawn.cc (spawn_guts): Reorganize so that ciresrv is allocated at only the
last minute so that cygheap changes are reflected.  Delete cygheap_setup*
calls.
* syscalls.cc (close_all_files): Add an argument to flag when the fd entry
should be released.
* winsup.h (close_all_files): Add an argument to close_all_files declaration.
Declare child_copy.
@
text
@d97 1
a97 1
close_all_files (bool keep_table)
d109 1
a109 2
	if (!keep_table)
	  cygheap->fdtab.release (i);
@


1.377
log
@Remove PC_FULL from path_conv usage throughout.
* path.h (enum pathconv_arg): Change PC_FULL to PC_NOUILL.
* path.cc (path_conv::check): Test for PC_NOFULL rather than !PC_FULL.
(cygwin_conv_to_win32_path): Use PC_NOFULL to force non-absolute path.
@
text
@d97 1
a97 1
close_all_files ()
d109 2
a110 1
	cygheap->fdtab.release (i);
@


1.376
log
@white space and minor comment cleanup.
@
text
@d137 1
a137 1
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW | PC_FULL);
d270 1
a270 1
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW | PC_FULL);
d285 1
a285 1
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW | PC_FULL);
d1131 1
a1131 1
  path_conv real_old (oldpath, PC_FULL | PC_SYM_NOFOLLOW);
d1140 1
a1140 1
  path_conv real_new (newpath, PC_FULL | PC_SYM_NOFOLLOW);
d1149 1
a1149 1
      real_new.check (newpath, PC_FULL | PC_SYM_NOFOLLOW);
d1463 1
a1463 1
	path_conv full_path (file, PC_SYM_FOLLOW | PC_FULL);
d1722 1
a1722 1
  path_conv full_path (fname, PC_SYM_FOLLOW | PC_FULL);
d1913 1
a1913 1
  path_conv w32path (path, PC_SYM_NOFOLLOW | PC_FULL);
d2250 1
a2250 1
  path_conv path (newroot, PC_SYM_FOLLOW | PC_FULL | PC_POSIX);
@


1.375
log
@(check in files that should have been checked in previously)
* fhandler.cc (fhandler_base::open_9x): Remove (broken) check for
O_CREAT|O_EXCL.
* syscalls.cc (open): Do O_CREAT|O_EXCL check here first.
@
text
@d928 1
a928 1
static void 
d947 1
a947 1
  
d954 1
a954 1
        GetVolumeNameForVolumeMountPointA ("A:\\", a_drive, CYG_MAX_PATH);
d956 1
a956 1
        GetVolumeNameForVolumeMountPointA ("B:\\", a_drive, CYG_MAX_PATH);
d967 1
a967 1
	        {
d991 1
a991 1
        {
d1211 1
a1211 1
           && !wincap.has_move_file_ex ())
d1213 1
a1213 1
           && !wincap.has_move_file_ex ()))
d1746 1
a1746 1
        {
d1969 1
a1969 1
  		uid, myself->uid, myself->gid);
d2058 1
a2058 1
        {
d2178 1
a2178 1
      				TokenPrimaryGroup, &gsid, sizeof gsid))
d2470 1
a2470 1
        switch (which)
@


1.374
log
@	* syscalls.cc (setuid32): Correct debugging output.
@
text
@d567 6
@


1.373
log
@* dcrt0.cc (do_global_dtors): Run DLL dtors.
(__main): Don't rely on atexit to run dtors.
(do_exit): Specifically call do_global_dtors here.
(cygwin_exit): Ditto.
* dll_init.cc (dll_global_dtors): Make global.  Only run dtors once.
(dll_list::init): Just set flag that dtors should be run.  Don't rely on
atexit.
* dll_init.h (dll_global_dtors): Declare.
* exceptions.cc (sigrelse): Define.
* path.h (is_fs_device): New method.
(is_lnk_special): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::link): Use "is_lnk_special" rather
than "is_lnk_symlink".
* syscalls.cc (rename): Ditto.
* hookapi.cc (ld_preload): Use colon as a separator rather than space.
@
text
@d1962 2
a1963 1
  debug_printf ("uid: %u myself->gid: %u", uid, myself->gid);
@


1.372
log
@	Revert previous patch.
	* autoload.cc (GetVolumePathNamesForVolumeNameA): Remove.
	* autoload.cc (GetVolumeNameForVolumeMountPointA): Add.
	* syscalls.cc (sync): Rewrite guid case to skip floppies also on
	Windows 2000.
@
text
@d1138 1
a1138 1
  if (real_old.is_lnk_symlink () && !real_new.error && !real_new.case_clash)
d1173 1
a1173 1
  if (!real_old.issymlink () && !real_new.error && real_new.is_lnk_symlink ()
@


1.371
log
@	* syscalls.cc (sync): Use renamed has_get_volume_pathnames wincap.
	* wincap.h (wincaps::has_get_volume_pathnames): Rename from
	has_guid_volumes
	* wincap.cc: Accomodate above rename throughout.  Set to false on
	Windows 2000.
@
text
@d942 1
a942 1
  if (wincap.has_get_volume_pathnames ()) /* Win2k and newer */
d944 8
d957 1
a957 7
	      char pvol[CYG_MAX_PATH];
	      DWORD len;
	      if (GetVolumePathNamesForVolumeNameA (vol, pvol, CYG_MAX_PATH,
						    &len))
		debug_printf ("Try volume %s (GUID: %s)", pvol, vol);
	      else
		debug_printf ("Try volume %s", vol);
d959 2
a960 3
	      /* Check pvol for being a floppy on A: or B:.  Skip them. */
	      if (strncasematch (pvol, "A:", 2)
	          || strncasematch (pvol, "B:", 2))
d962 2
a963 3
		  pvol[2] = '\0';
		  if (is_floppy (pvol))
		    continue;
@


1.370
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d942 1
a942 1
  if (wincap.has_guid_volumes ()) /* Win2k and newer */
@


1.369
log
@	* path.cc (is_floppy): Make externally available.
	* path.h (is_floppy): Declare.
	* syscalls.cc (sync): Check for floppies on A: and B: in guid case.
	Don't call setmntent in non-guid case but evaluate drive bit mask
	locally.
@
text
@d1701 1
a1719 2
  /* GetDiskFreeSpaceEx must be called before GetDiskFreeSpace on
     WinME, to avoid the MS KB 314417 bug */
d1721 2
a1722 1
  BOOL status = GetDiskFreeSpaceEx (root, &availb, &totalb, &freeb);
d1724 1
a1724 1
  DWORD spc, bps, availc, freec, totalc;
d1726 4
a1729 1
  if (!GetDiskFreeSpace (root, &spc, &bps, &freec, &totalc))
d1731 23
a1753 2
      __seterrno ();
      return -1;
d1755 2
d1758 1
a1758 8
  if (status)
    {
      availc = availb.QuadPart / (spc*bps);
      totalc = totalb.QuadPart / (spc*bps);
      freec = freeb.QuadPart / (spc*bps);
    }
  else
    availc = freec;
d1760 1
a1760 19
  DWORD vsn, maxlen, flags;

  if (!GetVolumeInformation (root, NULL, 0, &vsn, &maxlen, &flags, NULL, 0))
    {
      __seterrno ();
      return -1;
    }
  sfs->f_bsize = spc*bps;
  sfs->f_frsize = spc*bps;
  sfs->f_blocks = totalc;
  sfs->f_bfree = freec;
  sfs->f_bavail = availc;
  sfs->f_files = ULONG_MAX;
  sfs->f_ffree = ULONG_MAX;
  sfs->f_favail = ULONG_MAX;
  sfs->f_fsid = vsn;
  sfs->f_flag = flags;
  sfs->f_namemax = maxlen;
  return 0;
d1972 1
a1972 1
  HANDLE ptok, new_token = INVALID_HANDLE_VALUE;
a1974 2
  char dacl_buf[MAX_DACL_LEN (5)];
  TOKEN_DEFAULT_DACL tdacl = {};
d1988 1
a1988 6
  RevertToSelf ();
  if (!OpenProcessToken (hMainProc, TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, &ptok))
    {
      __seterrno ();
      goto failed_ptok;;
    }
d1991 2
a1992 2
  if (verify_token (ptok, usersid, groups))
    new_token = ptok;
d1998 3
a2000 3
  else if (cygheap->user.current_token != NO_IMPERSONATION
	   && cygheap->user.current_token != cygheap->user.external_token
	   && verify_token (cygheap->user.current_token, usersid, groups,
d2002 1
a2002 1
    new_token = cygheap->user.current_token;
d2005 1
a2005 1
	   && cygheap->user.internal_token != cygheap->user.current_token
d2023 4
a2026 1
	    goto failed;
d2034 1
a2034 11
  /* Set process def dacl to allow access to impersonated token */
  if (sec_acl ((PACL) dacl_buf, true, true, usersid))
    {
      tdacl.DefaultDacl = (PACL) dacl_buf;
      if (!SetTokenInformation (ptok, TokenDefaultDacl,
				&tdacl, sizeof dacl_buf))
	debug_printf ("SetTokenInformation"
		      "(TokenDefaultDacl), %E");
    }

  if (new_token != ptok)
d2043 1
a2043 2
	debug_printf ("SetTokenInformation(user.token, "
		      "TokenOwner), %E");
d2047 1
a2047 2
	debug_printf ("SetTokenInformation(user.token, "
		      "TokenPrimaryGroup), %E");
d2049 8
a2056 4
      if (tdacl.DefaultDacl
	  && !SetTokenInformation (new_token, TokenDefaultDacl,
				   &tdacl, sizeof (tdacl)))
	debug_printf ("SetTokenInformation (TokenDefaultDacl), %E");
a2058 1
  CloseHandle (ptok);
d2061 24
a2084 3
  cygheap->user.current_token = new_token == ptok ? NO_IMPERSONATION
						  : new_token;
  cygheap->user.reimpersonate ();
a2092 6

failed:
  CloseHandle (ptok);
failed_ptok:
  cygheap->user.reimpersonate ();
  return -1;
a2156 1
  HANDLE ptok;
a2166 1
  /* If impersonated, update primary group and revert */
d2169 4
a2172 4
      if (!SetTokenInformation (cygheap->user.token (),
				TokenPrimaryGroup,
				&gsid, sizeof gsid))
	debug_printf ("SetTokenInformation(thread, "
d2174 1
a2174 7
      RevertToSelf ();
    }
  if (!OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT, &ptok))
    debug_printf ("OpenProcessToken(), %E");
  else
    {
      if (!SetTokenInformation (ptok, TokenPrimaryGroup,
d2176 1
a2176 3
	debug_printf ("SetTokenInformation(process, "
		      "TokenPrimaryGroup), %E");
      CloseHandle (ptok);
d2178 7
a2184 3
  if (cygheap->user.issetuid ()
      && !ImpersonateLoggedOnUser (cygheap->user.token ()))
    system_printf ("Impersonating in setegid failed, %E");
@


1.368
log
@	* path.cc (is_floppy): New function.
	(setmntent): Drop floppy drives on A: and B: from logical drive DWORD.
	* syscalls.cc (sync): Don't sync floppies on A: and B:.
@
text
@d957 9
d976 1
a976 3
      extern FILE *setmntent (const char *, const char *);
      setmntent ("", "");
      DWORD drives = _my_tls.locals.available_drives;
d978 5
@


1.367
log
@	* cygwin.din (utmpxname): Export.
	* syscalls.cc (utmpxname): Create export alias to utmpname.
	* include/utmpx.h: Define ut_name and ut_xtime if not already defined.
	(utmpxname): Add prototype.
	* include/sys/utmp.h: Only define ut_name if not already defined.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d967 3
a969 1
      DWORD drives = GetLogicalDrives ();
d974 1
@


1.366
log
@	* fhandler_clipboard.cc (fhandler_dev_clipboard::write): Never set
	errno to 0.
	(fhandler_dev_clipboard::read): Ditto.
	* fhandler_windows.cc (fhandler_windows::read): Ditto.
	* scandir.cc (scandir): Ditto.
	* syscalls.cc (_fstat64_r): Ditto.
	(_fstat_r): Ditto.
	(_stat64_r): Ditto.
	(_stat_r): Ditto.

	* mmap.cc (mmap64): Fix /dev/zero mapping.
@
text
@d2600 1
@


1.365
log
@	* cygwin.din (fstatvfs): Export.
	(statvfs): Export.
	* syscalls.cc: Include sys/statvfs.h.
	(statvfs): New function.  Move statfs functionality here.
	(fstatvfs): New function.
	(statfs): Just call statvfs and copy structure.  Check validity of
	incoming struct statfs pointer.
	* include/cygwin/types.h (fsblkcnt_t): Define.
	(fsfilcnt_t): Define.
	* include/cygwin/version.h: Bump API minor version.
	* include/sys/statvfs.h: New file.
@
text
@d882 1
a882 2
  set_errno (0);
  if ((ret = fstat64 (fd, buf)) == -1 && get_errno () != 0)
d902 1
a902 2
  set_errno (0);
  if ((ret = fstat (fd, buf)) == -1 && get_errno () != 0)
d1040 1
a1040 2
  set_errno (0);
  if ((ret = stat64 (name, buf)) == -1 && get_errno () != 0)
d1060 1
a1060 2
  set_errno (0);
  if ((ret = stat (name, buf)) == -1 && get_errno () != 0)
@


1.364
log
@	* cygwin.din (fdatasync): Export.
	* fhandler.cc (fhandler_base::fsync): Return with EINVAL if no
	handle is available.
	* syscalls.cc (fdatasync): Create export alias to fsync.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d27 1
d1688 1
a1688 1
statfs (const char *fname, struct statfs *sfs)
d1692 4
a1736 1
  sfs->f_type = flags;
d1738 1
d1740 1
d1742 3
a1744 3
  sfs->f_bfree = freec;
  sfs->f_files = -1;
  sfs->f_ffree = -1;
d1746 2
a1747 1
  sfs->f_namelen = maxlen;
d1752 31
@


1.363
log
@	* autoload.cc (FindFirstVolumeA): Add.
	(FindNextVolumeA): Add.
	(FindVolumeClose): Add.
	(GetVolumePathNamesForVolumeNameA): Add.
	* fhandler.h (class fhandler_base): Declare new method fsync.
	* fhandler.cc (fhandler_base::fsync): New method.
	* syscalls.cc (fsync): Move functionality into fhandler method fsync.
	Just call this method from here.
	(sync_worker): New static function.
	(sync): Fill with life for NT systems.
	* wincap.h (wincaps::has_guid_volumes): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d921 2
@


1.362
log
@	* fhandler.h (class fhandler_base): Declare new method link.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::open): Add FILE_WRITE_ATTRIBUTES
	to query_write_control access flags.
	(fhandler_base::link): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't try to
	open with O_WRONLY since query_write_control includes
	FILE_WRITE_ATTRIBUTES.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::link): New method.  Touch st_ctime on successful
	link.
	* fhandler_socket.cc (fhandler_socket::link): New method.
	* syscalls.cc (link): Move functionality into fhandler method link.
	Just call this method from here.
@
text
@d918 2
d921 6
a926 1
  if (FlushFileBuffers (cfd->get_handle ()) == 0)
d928 2
a929 2
      __seterrno ();
      return -1;
d931 2
a932 1
  return 0;
d939 41
@


1.361
log
@white space
@
text
@d671 1
a671 1
link (const char *a, const char *b)
d674 1
a674 3
  path_conv real_a (a, PC_SYM_NOFOLLOW | PC_FULL);
  path_conv real_b (b, PC_SYM_NOFOLLOW | PC_FULL);
  extern bool allow_winsymlinks;
d676 2
a677 5
  if (real_a.error)
    {
      set_errno (real_a.error);
      goto done;
    }
d679 1
a679 1
  if (real_b.error)
d681 2
a682 26
      set_errno (real_b.case_clash ? ECASECLASH : real_b.error);
      goto done;
    }

  if (real_b.exists ())
    {
      syscall_printf ("file '%s' exists?", (char *) real_b);
      set_errno (EEXIST);
      goto done;
    }

  if (real_b[strlen (real_b) - 1] == '.')
    {
      syscall_printf ("trailing dot, bailing out");
      set_errno (EINVAL);
      goto done;
    }

  /* Shortcut hack. */
  char new_lnk_buf[CYG_MAX_PATH + 5];
  if (allow_winsymlinks && real_a.is_lnk_symlink () && !real_b.case_clash)
    {
      strcpy (new_lnk_buf, b);
      strcat (new_lnk_buf, ".lnk");
      b = new_lnk_buf;
      real_b.check (b, PC_SYM_NOFOLLOW | PC_FULL);
a683 135
  /* Try to make hard link first on Windows NT */
  if (wincap.has_hard_links ())
    {
      if (CreateHardLinkA (real_b, real_a, NULL))
	goto success;

      /* There are two cases to consider:
	 - The FS doesn't support hard links ==> ERROR_INVALID_FUNCTION
	   We copy the file.
	 - CreateHardLinkA is not supported  ==> ERROR_PROC_NOT_FOUND
	   In that case (<= NT4) we try the old-style method.
	 Any other error should be taken seriously. */
      if (GetLastError () == ERROR_INVALID_FUNCTION)
	{
	  syscall_printf ("FS doesn't support hard links: Copy file");
	  goto docopy;
	}
      if (GetLastError () != ERROR_PROC_NOT_FOUND)
	{
	  syscall_printf ("CreateHardLinkA failed");
	  __seterrno ();
	  goto done;
	}

      HANDLE hFileSource;

      WIN32_STREAM_ID StreamId;
      DWORD dwBytesWritten;
      LPVOID lpContext;
      DWORD cbPathLen;
      DWORD StreamSize;
      WCHAR wbuf[CYG_MAX_PATH];

      BOOL bSuccess;
      DWORD write_err;

      hFileSource = CreateFile (real_a, FILE_WRITE_ATTRIBUTES,
				FILE_SHARE_READ | FILE_SHARE_WRITE /*| FILE_SHARE_DELETE*/,
				&sec_none_nih, // sa
				OPEN_EXISTING, 0, NULL);

      if (hFileSource == INVALID_HANDLE_VALUE)
	{
	  syscall_printf ("cannot open source, %E");
	  goto docopy;
	}

      cbPathLen = sys_mbstowcs (wbuf, real_b, CYG_MAX_PATH) * sizeof (WCHAR);

      StreamId.dwStreamId = BACKUP_LINK;
      StreamId.dwStreamAttributes = 0;
      StreamId.dwStreamNameSize = 0;
      StreamId.Size.HighPart = 0;
      StreamId.Size.LowPart = cbPathLen;

      StreamSize = sizeof (WIN32_STREAM_ID) - sizeof (WCHAR**) +
		   StreamId.dwStreamNameSize;

      lpContext = NULL;
      write_err = 0;
      /* Write the WIN32_STREAM_ID */
      bSuccess = BackupWrite (
	hFileSource,
	 (LPBYTE) &StreamId,	// buffer to write
	StreamSize,		// number of bytes to write
	&dwBytesWritten,
	FALSE,			// don't abort yet
	FALSE,			// don't process security
	&lpContext);

      if (bSuccess)
	{
	  /* write the buffer containing the path */
	  /* FIXME: BackupWrite sometimes traps if linkname is invalid.
	     Need to handle. */
	  bSuccess = BackupWrite (
		hFileSource,
		 (LPBYTE) wbuf,	// buffer to write
		cbPathLen,	// number of bytes to write
		&dwBytesWritten,
		FALSE,		// don't abort yet
		FALSE,		// don't process security
		&lpContext
		);

	  if (!bSuccess)
	    {
	      write_err = GetLastError ();
	      syscall_printf ("cannot write linkname, %E");
	    }

	  /* Free context */
	  BackupWrite (
	    hFileSource,
	    NULL,		// buffer to write
	    0,			// number of bytes to write
	    &dwBytesWritten,
	    TRUE,		// abort
	    FALSE,		// don't process security
	    &lpContext);
	}
      else
	{
	  write_err = GetLastError ();
	  syscall_printf ("cannot write streamId, %E");
	}

      CloseHandle (hFileSource);

      if (!bSuccess)
	{
	  /* Only copy file if FS doesn't support hard links */
	  if (write_err == ERROR_INVALID_FUNCTION)
	    {
	      syscall_printf ("FS doesn't support hard links: Copy file");
	      goto docopy;
	    }

	  __seterrno_from_win_error (write_err);
	  goto done;
	}

    success:
      res = 0;
      if (!allow_winsymlinks && real_a.is_lnk_symlink ())
	SetFileAttributes (real_b, (DWORD) real_a
				   | FILE_ATTRIBUTE_SYSTEM
				   | FILE_ATTRIBUTE_READONLY);

      goto done;
    }
docopy:
  /* do this with a copy */
  if (CopyFileA (real_a, real_b, 1))
    res = 0;
d685 1
a685 1
    __seterrno ();
d687 3
a689 2
done:
  syscall_printf ("%d = link (%s, %s)", res, a, b);
@


1.360
log
@	* fhandler.h (fhandler_base::ftruncate): Define new virtual method.
	(fhandler_disk_file::ftruncate): Ditto.
	* fhandler.cc (fhandler_base::ftruncate): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.
	* syscalls.cc (ftruncate64): Move functionality into fhandlers.
	Call fhandler method from here.
@
text
@d184 1
a184 1
     Win32 error 59, ERROR_UNEXP_NET_ERR when trying to access the file. 
d187 1
a187 1
     nicely succeeds but still, the file is available for the other process. 
d189 1
a189 1
     
d1287 1
a1287 1
     
d1291 2
a1292 2
     code instead. 
     
@


1.359
log
@	* syscalls.cc (setpriority): Implement PRIO_PGRP, PRIO_USER and
	setting priority in other Cygwin processes.
	(getpriority): Implement PRIO_PGRP, PRIO_USER and getting nice value
	from other processes.
@
text
@d1740 4
a1743 4
  int res = -1, res_bug = 0;

  if (length < 0)
    set_errno (EINVAL);
d1745 1
a1745 26
    {
      cygheap_fdget cfd (fd);
      if (cfd >= 0)
	{
	  HANDLE h = cygheap->fdtab[fd]->get_handle ();

	  if (cfd->get_handle ())
	    {
	      /* remember curr file pointer location */
	      _off64_t prev_loc = cfd->lseek (0, SEEK_CUR);

	      cfd->lseek (length, SEEK_SET);
	      /* Fill the space with 0, if needed */
	      if (wincap.has_lseek_bug ())
		res_bug = cfd->write (&res, 0);
	      if (!SetEndOfFile (h))
		__seterrno ();
	      else
		res = res_bug;

	      /* restore original file pointer location */
	      cfd->lseek (prev_loc, SEEK_SET);
	    }
	}
    }

@


1.358
log
@	* cygwin.din: Export getpriority and setpriority.
	* fork.cc (fork_parent): Copy parent's nice value into child.
	* spawn.cc (spawn_guts): Ditto.
	* miscfuncs.cc (winprio_to_nice): New function.
	(nice_to_winprio): Ditto.
	* pinfo.cc (pinfo_init): If parent is not a Cygwin process, set
	default nice value according to current Win32 priority class.
	* pinfo.h (class _pinfo): Add nice member.
	* syscalls.cc (setpriority): New function, only implementing
	PRIO_PROCESS for now.
	(getpriority): Ditto.
	(nice): Just call setpriority.
	* wincap.h (wincaps::has_extended_priority_class): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h: Add prototypes for winprio_to_nice and nice_to_winprio.
	* include/limits.h (NZERO): New define.
	* include/cygwin/types.h (id_t): New datatype.
	* include/cygwin/version.h: Bump API minor version.
	* include/sys/resource.h: Add PRIO_XXX defines and prototypes for
	getpriority and setpriority.
@
text
@d2448 4
a2451 2
  /* TODO: Support PRIO_PGRP and PRIO_USER. */
  if (which != PRIO_PROCESS || (who != 0 && (pid_t) who != myself->pid))
d2453 24
d2480 37
a2516 2
  DWORD prio = nice_to_winprio (value);
  if (SetPriorityClass (hMainProc, prio) == FALSE)
d2518 1
a2518 1
      __seterrno ();
a2520 2
  myself->nice = value;
  debug_printf ("Set nice to %d", myself->nice);
d2527 3
a2529 2
  /* TODO: Support PRIO_PGRP and PRIO_USER. */
  if (which != PRIO_PROCESS || (who != 0 && (pid_t) who != myself->pid))
d2531 15
d2549 32
a2580 1
  return myself->nice;
@


1.357
log
@* pinfo.cc (pinfo::exit): Don't assume that this == myself.
@
text
@d2446 1
a2446 1
nice (int incr)
d2448 2
a2449 1
  DWORD priority[] =
d2451 5
a2455 10
      IDLE_PRIORITY_CLASS,
      IDLE_PRIORITY_CLASS,
      NORMAL_PRIORITY_CLASS,
      HIGH_PRIORITY_CLASS,
      REALTIME_PRIORITY_CLASS,
      REALTIME_PRIORITY_CLASS
    };
  int curr = 2;

  switch (GetPriorityClass (hMainProc))
d2457 2
a2458 12
      case IDLE_PRIORITY_CLASS:
	curr = 1;
	break;
      case NORMAL_PRIORITY_CLASS:
	curr = 2;
	break;
      case HIGH_PRIORITY_CLASS:
	curr = 3;
	break;
      case REALTIME_PRIORITY_CLASS:
	curr = 4;
	break;
d2460 4
a2463 4
  if (incr > 0)
    incr = -1;
  else if (incr < 0)
    incr = 1;
d2465 5
a2469 1
  if (SetPriorityClass (hMainProc, priority[curr + incr]) == FALSE)
d2471 1
a2471 1
      __seterrno ();
d2474 2
d2477 4
a2480 1
  return 0;
d2586 1
a2586 1
utmpname (_CONST char *file)
@


1.356
log
@2005-01-08  Pierre Humblet <pierre.humblet@@ieee.org>

	* syscalls.cc (seteuid32): Only change the default dacl when
	seteuid succeeds. Do not close HKCU.
@
text
@d1410 1
a1410 1
  if ((res = spawnvp (_P_SYSTEM, "sh", command)) == -1)
@


1.355
log
@	* syscalls.cc (rename): Fix behaviour in case of renaming directories
	according to SUSv3.
@
text
@d2069 1
a2069 1
    goto success_9x;
a2105 10
  /* Set process def dacl to allow access to impersonated token */
  if (sec_acl ((PACL) dacl_buf, true, true, usersid))
    {
      tdacl.DefaultDacl = (PACL) dacl_buf;
      if (!SetTokenInformation (ptok, TokenDefaultDacl,
				&tdacl, sizeof dacl_buf))
	debug_printf ("SetTokenInformation"
		      "(TokenDefaultDacl), %E");
    }

d2125 10
d2169 2
a2170 5
  if (!issamesid) /* MS KB 199190 */
    {
      RegCloseKey (HKEY_CURRENT_USER);
      user_shared_initialize (true);
    }
@


1.354
log
@	* syscalls.cc (setmode): Call _fwalk with _GLOBAL_REENT.
@
text
@d1225 1
a1225 1
  path_conv real_old (oldpath, PC_SYM_NOFOLLOW);
d1234 1
a1234 1
  path_conv real_new (newpath, PC_SYM_NOFOLLOW);
d1243 1
a1243 1
      real_new.check (newpath, PC_SYM_NOFOLLOW);
d1255 10
a1264 3
       syscall_printf ("file to move doesn't exist");
       set_errno (ENOENT);
       return (-1);
d1281 47
a1327 1
  if (wincap.has_move_file_ex ())
d1333 1
a1333 2
  else if (GetLastError () == ERROR_ALREADY_EXISTS
	   || GetLastError () == ERROR_FILE_EXISTS)
d1338 1
a1338 1
	  if (!DeleteFileA (real_new.get_win32 ()) &&
d1345 1
a1345 1
	  else if (MoveFile (real_old.get_win32 (), real_new.get_win32 ()))
@


1.353
log
@	* cygwin.din: Add utmpx symbols.
	* syscalls.cc: Include utmpx.h.  Implement utmpx functions as stubs
	to utmp functions.
	(copy_ut_to_utx): New static function.
	(pututline): Change from void to struct utmp * as on Linux.
	(setutxent): New function.
	(endutxent): New function.
	(getutxent): New function.
	(getutxid): New function.
	(getutxline): New function.
	(pututxline): New function.
	* include/utmpx.h: New file.
	* include/cygwin/utmp.h: New file.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/utmp.h: Include cygwin/utmp.h.  Move stuff common with
	utmpx functionality there.
	(pututline): Declare struct utmp *.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d1678 1
a1678 1
  _fwalk (_REENT, setmode_helper);
@


1.352
log
@* syscalls.cc (truncate64): Don't second-guess errno if open fails.
@
text
@d32 1
d2563 11
d2650 1
a2650 1
extern "C" void
d2654 1
a2654 1
    return;
d2659 1
a2659 1
      return;
d2674 53
@


1.351
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d1737 1
a1737 3
  if (fd == -1)
    set_errno (EBADF);
  else
@


1.350
log
@2004-11-20  Pierre Humblet <pierre.humblet@@ieee.org>

	* cygheap.h (cygheap_user::get_windows_id): New method.
	* registry.h (get_registry_hive_path): Change argument type.
	(load_registry_hive): Ditto.
	* registry.cc (get_registry_hive_path): Change argument type and take
	Win9x keys into account.
	(load_registry_hive): Ditto.
	* uinfo.cc (cygheap_user::env_userprofile): Use get_windows_id, even
	for SYSTEM.
	* shared.cc (user_shared_initialize): Use get_windows_id.
	* syscalls.cc (seteuid32): Load the registry hive and reload the user
	shared also on Win9x.
@
text
@a58 2
#define NEED_VFORK
#include "perthread.h"
@


1.349
log
@2004-10-28  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.cc (mount_info::from_registry): Deimpersonate while
        accessing HKLM.
        (mount_info::read_cygdrive_info_from_registry): Ditto.
        * cygheap.h: Define NO_IMPERSONATION.
        (cygheap_user::issetuid): Replace INVALID_HANDLE_VALUE by
        NO_IMPERSONATION.
        (cygheap_user::has_impersonation_tokens): Ditto.
        (cygheap_user::close_impersonation_tokens): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
        * syscalls.cc (seteuid32): Ditto.
        * security.cc (set_impersonation_token): Ditto.
@
text
@d2011 1
a2011 1
  bool token_is_internal, issamesid;
d2017 2
d2020 1
d2088 2
a2089 1
      load_registry_hive (usersid);
a2112 2
  if (!issamesid) /* MS KB 199190 */
    RegCloseKey (HKEY_CURRENT_USER);
a2113 2
  if (!issamesid)
    user_shared_initialize (true);
d2119 5
@


1.349.2.1
log
@checkpoint
@
text
@d59 2
@


1.348
log
@	* syscalls.cc (unlink): Don't use "delete on close" on remote shares.
@
text
@d2035 1
a2035 1
  else if (cygheap->user.external_token != INVALID_HANDLE_VALUE
d2039 1
a2039 1
  else if (cygheap->user.current_token != INVALID_HANDLE_VALUE
d2045 1
a2045 1
  else if (cygheap->user.internal_token != INVALID_HANDLE_VALUE
d2077 1
a2077 1
      if (cygheap->user.internal_token != INVALID_HANDLE_VALUE)
d2081 1
d2107 1
a2107 1
  cygheap->user.current_token = new_token == ptok ? INVALID_HANDLE_VALUE
@


1.347
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d178 18
a195 2
     a file which may be open. */
  if (wincap.has_delete_on_close ())
@


1.346
log
@	* Makefile.in: Create libutil.a from bsdlib.o exports.
	* bsdlib.cc (logwtmp): Move from syscalls.cc to here.
	(login): Ditto.
	(logout): Ditto.

	* winsup.h (EXPORT_ALIAS): New macro.
	* exec.cc: Define alias symbols using EXPORT_ALIAS macro.
	* syscalls.cc: Ditto.
	* times.cc: Ditto.
@
text
@d715 1
a715 1
        {
d807 1
a807 1
        {
@


1.345
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d373 1
a373 2
extern "C" ssize_t _read (int, void *, size_t)
  __attribute__ ((alias ("read")));
d387 1
a387 2
extern "C" ssize_t _write (int fd, const void *ptr, size_t len)
  __attribute__ ((alias ("write")));
d573 2
a574 5
extern "C" int _open (const char *, int flags, ...)
  __attribute__ ((alias ("open")));

extern "C" int _open64 (const char *, int flags, ...)
  __attribute__ ((alias ("open")));
d599 1
a599 2
extern "C" int _lseek64 (int fd, _off64_t pos, int dir)
  __attribute__ ((alias ("lseek64")));
d607 1
a607 2
extern "C" _off_t _lseek (int, _off_t, int)
  __attribute__ ((alias ("lseek")));
d631 1
a631 1
extern "C" int _close (int) __attribute__ ((alias ("close")));
a2477 49
extern "C" void
logwtmp (const char *line, const char *user, const char *host)
{
  struct utmp ut;
  memset (&ut, 0, sizeof ut);
  ut.ut_type = USER_PROCESS;
  ut.ut_pid = getpid ();
  if (line)
    strncpy (ut.ut_line, line, sizeof ut.ut_line);
  time (&ut.ut_time);
  if (user)
    strncpy (ut.ut_user, user, sizeof ut.ut_user);
  if (host)
    strncpy (ut.ut_host, host, sizeof ut.ut_host);
  updwtmp (_PATH_WTMP, &ut);
}

extern "C" void
login (struct utmp *ut)
{
  pututline (ut);
  endutent ();
  updwtmp (_PATH_WTMP, ut);
}

extern "C" int
logout (char *line)
{
  struct utmp ut_buf, *ut;

  memset (&ut_buf, 0, sizeof ut_buf);
  strncpy (ut_buf.ut_line, line, sizeof ut_buf.ut_line);
  setutent ();
  ut = getutline (&ut_buf);

  if (ut)
    {
      ut->ut_type = DEAD_PROCESS;
      memset (ut->ut_user, 0, sizeof ut->ut_user);
      memset (ut->ut_host, 0, sizeof ut->ut_host);
      time (&ut->ut_time);
      debug_printf ("set logout time for %s", line);
      pututline (ut);
      endutent ();
      return 1;
    }
  return 0;
}

@


1.344
log
@2004-08-28  Pierre Humblet <pierre.humblet@@ieee.org>

        * syscalls.cc (ftruncate64): On 9x, call write with a zero length
        to zero fill when the file is extended.
@
text
@d1981 1
a1981 1
mkfifo (const char *_path, mode_t mode)
d1983 1
a1983 2
  set_errno (ENOSYS);  // FIXME
  return -1;
d2051 1
a2051 1
		      "(TokenDefaultDacl): %E");
d2081 1
a2081 1
		      "TokenOwner): %E");
d2086 1
a2086 1
		      "TokenPrimaryGroup): %E");
d2091 1
a2091 1
	debug_printf ("SetTokenInformation (TokenDefaultDacl): %E");
d2198 1
a2198 1
		      "TokenPrimaryGroup): %E");
d2202 1
a2202 1
    debug_printf ("OpenProcessToken(): %E");
d2208 1
a2208 1
		      "TokenPrimaryGroup): %E");
d2213 1
a2213 1
    system_printf ("Impersonating in setegid failed: %E");
@


1.343
log
@	* syscalls.cc (link): Avoid compiler warning.
@
text
@d1679 1
a1679 1
  int res = -1;
d1696 3
d1702 1
a1702 1
		res = 0;
@


1.342
log
@	* errno.cc (errmap): Add ERROR_TOO_MANY_LINKS -> EMLINK mapping.
	* syscalls.cc (link): Only copy files if FS doesn't support hard links.
@
text
@d763 1
@


1.341
log
@revert erroneous checkin
@
text
@d710 18
d738 1
d789 4
a792 1
	    syscall_printf ("cannot write linkname, %E");
d805 4
a808 1
	syscall_printf ("cannot write streamId, %E");
d813 11
a823 1
	goto docopy;
@


1.340
log
@* Makefile.in (clean): Remove cygwin.def since it is autogenerated.
@
text
@d1942 1
a1942 1
mkfifo (const char *path, mode_t mode)
d1944 2
a1945 1
  return mknod32 (path, (mode & ~S_IFMT) | S_IFIFO, 0);
@


1.339
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d1942 1
a1942 1
mkfifo (const char *_path, mode_t mode)
d1944 1
a1944 2
  set_errno (ENOSYS);	// FIXME
  return -1;
@


1.338
log
@	* cygwin.din: Add symbols flockfile, ftrylockfile, funlockfile,
	getgrgid_r, getgrnam_r and getlogin_r.
	* grp.cc (getgrgid_r): New function.
	(getgrnam_r): Ditto.
	* syscalls.cc (flockfile): Ditto.
	(ftrylockfile): Ditto.
	(funlockfile): Ditto.
	* sysconf.cc (sysconf): Return LOGIN_NAME_MAX in case of
	_SC_LOGIN_NAME_MAX.
	* thread.cc (__cygwin_lock_trylock): Define int.  Return value from
	call to pthread_mutex_trylock.
	* uinfo.cc (getlogin_r): New function.
	* include/limits.h: Define LOGIN_NAME_MAX.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/lock.h: Add declarations for __cygwin_lock_xxx functions.
	* include/sys/stdio.h: Add define for _ftrylockfile.
@
text
@d919 1
a919 1
      
d1061 1
a1061 1
  if (!(fh = build_fh_name (name, NULL, nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW, 
d1064 1
a1064 1
  
d1165 1
a1165 1
        {
d1495 1
a1495 1
        strcpy (buf, cfd->ttyname ());
@


1.337
log
@* syscalls.cc: Include environ.h.
(chroot): Set errno in case of path error.  Call getwinenv.
* environ.cc: Remove the NO_COPY attribute of conv_envvars.
@
text
@d2843 18
@


1.336
log
@	* dir.cc (writable_directory): Remove.
	(mkdir): Remove call to writable_directory.
	* syscalls.cc (unlink): Ditto.
	(rename): Ditto.
	* winsup.h (writable_directory): Remove declaration.
@
text
@d64 1
d2236 1
a2236 1
  int ret;
d2238 1
a2238 1
    ret = -1;
d2240 1
a2240 4
    {
      set_errno (ENOENT);
      ret = -1;
    }
d2242 1
a2242 4
    {
      set_errno (ENOTDIR);
      ret = -1;
    }
d2245 1
@


1.335
log
@	* syscalls.cc (lseek64): Fix debug_printf format string.
	(truncate64): Ditto.

	* fhandler.cc (fhandler_base::lseek): Force res to -1 on error.
@
text
@a164 8
  /* Windows won't check the directory mode, so we do that ourselves.  */
  if (!writable_directory (win32_name))
    {
      syscall_printf ("non-writable directory");
      set_errno (EPERM);
      goto done;
    }

a1203 7
      return -1;
    }

  if (!writable_directory (real_old) || !writable_directory (real_new))
    {
      syscall_printf ("-1 = rename (%s, %s)", oldpath, newpath);
      set_errno (EACCES);
@


1.334
log
@	* fhandler_disk_file.cc (fhandler_base::open_fs): Change
	set_file_attribute call to indicate that NT security isn't used.
	(fhandler_disk_file::fchmod): Rearrange to isolate 9x related
	statements.
	Do not set FILE_ATTRIBUTE_SYSTEM.
	(fhandler_disk_file::fchown): Check noop case first.
	* fhandler.cc (fhandler_base::open9x): Remove ntsec related statements.
	(fhandler_base::set_name): Do not set namehash.
	* fhandler.h (fhandler_base::get_namehash): Compute and set namehash if
	needed.
	* syscalls.cc (access): Verify that fh is not NULL. Do not set PC_FULL.
	(chmod): Ditto.
	(chown_worker): Ditto.
	(stat_worker): Ditto. Verify if the path exists.
@
text
@d606 1
a606 1
  syscall_printf ("%d = lseek (%d, %D, %d)", res, fd, pos, dir);
d1712 1
a1712 1
  syscall_printf ("%d = truncate (%s, %d)", res, pathname, length);
@


1.333
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d830 5
a834 2
  fhandler_base *fh = build_fh_name (name, NULL, fmode | PC_FULL,
				     stat_suffixes);
d844 1
d923 4
a926 2
  fhandler_base *fh = build_fh_name (path, NULL, PC_SYM_FOLLOW | PC_FULL,
				     stat_suffixes);
d936 1
d1066 1
a1066 4
    goto done;

  fh = build_fh_name (name, NULL, (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)
		      		  | PC_FULL, stat_suffixes);
d1068 4
d1077 1
a1077 1
  else
d1093 2
d1096 2
a1097 3
 done:
  if (fh)
    delete fh;
d1170 6
a1175 3
      fhandler_base *fh = build_fh_name (fn, NULL, PC_SYM_FOLLOW | PC_FULL, stat_suffixes);
      res =  fh->fhaccess (flags);
      delete fh;
@


1.332
log
@	* ntdll.h: Fix copyright date.
	* sec_acl.cc (acl_worker): delete allocated fhandler.
	* syscalls.cc (chown_worker): Ditto.
	(chmod): Ditto.
	(stat_worker): Use get_namehash instead of hash_path_name.
@
text
@d875 3
@


1.331
log
@	* syscalls.cc (fstat64): Use get_namehash instead of hash_path_name.
@
text
@d840 1
d926 1
d1075 1
a1075 1
	    buf->st_ino = hash_path_name (0, fh->get_win32_name ());
@


1.330
log
@	* fhandler.cc (fhandler_base::open): Simplify access evaluation
	expression.
	(fhandler_base::facl): New method.
	* fhandler.h: Declare facl method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): New method.
	* fhandler_virtual.cc (fhandler_virtual::facl): New method.
	* sec_acl.cc: Remove forward declaration for aclsort32 and acl32.
	(setacl): Remove static.  Add and use handle parameter.
	(getacl): Ditto.
	(acl_worker): Reorganize to call fhandler's facl method eventually.
	(facl32): Ditto.
	* security.cc (get_nt_object_security): Remove static.
	* security.h: Add extern declarations for get_nt_object_security,
	aclsort32, acl32, getacl and setacl.


	Apply missing syscalls.cc patch and ChangeLog of previous check in.
	* syscalls.cc (chown_worker): Reorganize to call fhandler's fchown
	method eventually.
	(fchown): Ditto.
@
text
@d977 1
a977 1
	    buf->st_ino = hash_path_name (0, cfd->get_win32_name ());
@


1.329
log
@	* autoload.cc (NtSetSecurityObject): Add.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Only request
	READ_CONTROL rights when opening the file.
	* ntdll.h (NtSetSecurityObject): Add declaration.
	* security.cc (write_sd): Call NtSetSecurityObject instead of
	BackupWrite.
	(get_nt_object_security): Don't free security descriptor here.

	* syscalls.cc (ttyname): Use buffer of length TTY_NAME_MAX + 1.
	* sysconf.cc (sysconf): Handle _SC_TTY_NAME_MAX request.
	* include/limits.h: Define TTY_NAME_MAX and _POSIX_TTY_NAME_MAX.
@
text
@d826 2
a827 4
  int res;

  if (check_null_empty_str_errno (name))
    return -1;
d829 4
a832 3
  if (!wincap.has_security ())  // real chown only works on NT
    res = 0;			// return zero (and do nothing) under Windows 9x
  else
d834 2
a835 32
      /* we need Win32 path names because of usage of Win32 API functions */
      path_conv win32_path (PC_NONULLEMPTY, name, fmode);

      if (win32_path.error)
	{
	  set_errno (win32_path.error);
	  res = -1;
	  goto done;
	}

      /* FIXME: This makes chown on a device succeed always.  Someday we'll want
	 to actually allow chown to work properly on devices. */
      if (win32_path.is_auto_device () && !win32_path.issocket ())
	{
	  res = 0;
	  goto done;
	}

      mode_t attrib = 0;
      if (win32_path.isdir ())
	attrib |= S_IFDIR;
      res = get_file_attribute (win32_path.has_acls (), NULL,
				win32_path.get_win32 (), &attrib);
      if (!res)
	 res = set_file_attribute (win32_path.has_acls (), NULL, win32_path,
				   uid, gid, attrib);
      if (res != 0 && (!win32_path.has_acls () || !allow_ntsec))
	{
	  /* fake - if not supported, pretend we're like win95
	     where it just works */
	  res = 0;
	}
d837 2
a839 1
done:
d881 1
a881 1
  const char *path = cfd->get_name ();
d883 2
a884 10
  if (path == NULL)
    {
      syscall_printf ("-1 = fchown (%d,...) (no name)", fd);
      set_errno (ENOSYS);
      return -1;
    }

  syscall_printf ("fchown (%d,...): calling chown_worker (%s,FOLLOW,...)",
		  fd, path);
  return chown_worker (path, PC_SYM_FOLLOW, uid, gid);
@


1.328
log
@	* cygwin.din: Export rand_r and ttyname_r.
	* syscalls.cc (ttyname_r): New function.
	(ttyname): Move functionality to ttyname_r.  Call it from here.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1539 2
a1540 2
  static char name[CYG_MAX_PATH];
  int ret = ttyname_r (fd, name, CYG_MAX_PATH);
@


1.327
log
@	* dir.cc (mkdir): Call set_file_attribute with additional handle
	argument.
	* fhandler.cc (fhandler_base::fchmod): New method.
	* fhandler.h: Declare fchmod method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): New method.
	(fhandler_base::open_fs): Call set_file_attribute with additional
	handle argument.
	* fhandler_virtual.cc (fhandler_virtual::fchmod): New method.
	* path.cc (symlink_worker): Call set_file_attribute with additional
	handle argument.
	* security.cc (get_nt_object_security): New function.
	(get_nt_object_attribute): Call get_nt_object_security.
	(set_nt_attribute): Add handle argument.  Call get_nt_object_security
	first, read_sd only if that fails.
	(set_file_attribute): Add handle argument.
	* security.h (set_file_attribute): Declare with additional handle
	argument.
	* syscalls.cc (stat_suffixes): Move to beginning of file.
	(chown_worker): Call set_file_attribute with additional handle argument.
	(chmod): Reorganize to call fhandler's fchmod method eventually.
	(fchmod): Ditto.
@
text
@d1514 22
d1539 7
a1545 6
  char *name;
  cygheap_fdget cfd (fd);
  if (cfd < 0 || !cfd->is_tty ())
    return 0;
  name = (char *) (cfd->ttyname ());
  debug_printf ("returning %s", name);
@


1.326
log
@	* syscalls.cc (sync): Define void according to SUSv3.
@
text
@d74 7
d859 2
a860 2
	 res = set_file_attribute (win32_path.has_acls (), win32_path, uid,
				   gid, attrib);
d953 3
a955 12

  path_conv win32_path (path);

  if (win32_path.error)
    {
      set_errno (win32_path.error);
      goto done;
    }

  /* FIXME: This makes chmod on a device succeed always.  Someday we'll want
     to actually allow chmod to work properly on devices. */
  if (win32_path.is_auto_device ())
d957 2
a958 2
      res = 0;
      goto done;
a959 8
  if (win32_path.is_fs_special ())
    {
      res = chmod_device (win32_path, mode);
      goto done;
    }

  if (!win32_path.exists ())
    __seterrno ();
d961 1
a961 3
    {
      /* temporary erase read only bit, to be able to set file security */
      SetFileAttributes (win32_path, (DWORD) win32_path & ~FILE_ATTRIBUTE_READONLY);
a962 25
      if (win32_path.isdir ())
	mode |= S_IFDIR;
      if (!set_file_attribute (win32_path.has_acls (), win32_path,
			       ILLEGAL_UID, ILLEGAL_GID, mode)
	  && allow_ntsec)
	res = 0;

      /* if the mode we want has any write bits set, we can't
	 be read only. */
      if (mode & (S_IWUSR | S_IWGRP | S_IWOTH))
	(DWORD) win32_path &= ~FILE_ATTRIBUTE_READONLY;
      else
	(DWORD) win32_path |= FILE_ATTRIBUTE_READONLY;

      if (!win32_path.is_lnk_symlink () && S_ISLNK (mode) || S_ISSOCK (mode))
	(DWORD) win32_path |= FILE_ATTRIBUTE_SYSTEM;

      if (!SetFileAttributes (win32_path, win32_path))
	__seterrno ();
      else if (!allow_ntsec)
	/* Correct NTFS security attributes have higher priority */
	res = 0;
    }

done:
d979 1
a979 12
  const char *path = cfd->get_name ();

  if (path == NULL)
    {
      syscall_printf ("-1 = fchmod (%d, 0%o) (no name)", fd, mode);
      set_errno (ENOSYS);
      return -1;
    }

  syscall_printf ("fchmod (%d, 0%o): calling chmod (%s, 0%o)",
		  fd, mode, path, mode);
  return chmod (path, mode);
a1082 7

suffix_info stat_suffixes[] =
{
  suffix_info ("", 1),
  suffix_info (".exe", 1),
  suffix_info (NULL)
};
@


1.325
log
@	* fhandler.cc (rootdir): Add and use second argument.
	* winsup.h (rootdir): Add second argument in declaration.
	* path.cc (fs_info::update): Modify call to rootdir.
	* syscalls.cc (check_posix_perm): Ditto.
	(statfs): Ditto. Move syscall_printf near top.
@
text
@d1126 2
a1127 2
/* sync: standards? */
extern "C" int
a1129 1
  return 0;
@


1.324
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d1460 1
a1460 1
  char *root = rootdir (strcpy ((char *)alloca (strlen (fname)), fname));
d1796 3
a1798 1
  char root_dir[CYG_MAX_PATH];
d1807 2
a1808 4
  strncpy (root_dir, full_path, CYG_MAX_PATH);
  const char *root = rootdir (root_dir);

  syscall_printf ("statfs %s", root);
@


1.323
log
@	* fhandler.cc (fhandler_base::open): Set query access mode according
	to query_open setting.
	(fhandler_base::fhandler_base): Initialize query_open.
	* fhandler.h (FH_QUERYOPEN): Drop.
	(enum query_state): Add.
	(class fhandler_base): Add query_open member.
	(fhandler_base::get_query_open): Redefine to use query_open.
	(fhandler_base::set_query_open): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Remove O_DIROPEN
	from open_flags since it's added in open_fs anyway.  Remove
	query_open_already.  Use new query_open settings.  Rearrange slightly.
	(fhandler_base::fstat_helper): Add get_io_handle as parameter to
	get_file_attribute.
	* security.cc (get_nt_object_attribute): Make returning an int.
	Return -1 on error, 0 otherwise.
	(get_file_attribute): Take an object handle as argument. Move down
	to allow calling get_nt_object_attribute in case a non-NULL handle
	is given.
	* security.h (get_file_attribute): Add handle to argument list.
	* syscalls.cc (chown_worker): Accomodate new definition of
	get_file_attribute.
@
text
@d427 1
a427 1
      if (wait && (!cfd->is_slow () || cfd->get_r_no_interrupt ()))
d1620 1
a1620 1
  if (cfd->get_w_binary () || cfd->get_r_binary ())
d1684 1
a1684 1
  if (cfd->get_w_binary () && cfd->get_r_binary ())
d1686 1
a1686 1
  else if (cfd->get_w_binset () && cfd->get_r_binset ())
d1796 2
d1805 2
a1806 1
  const char *root = full_path.root_dir ();
@


1.322
log
@* Makefile.in (clean): Clean libserver, too.
* fhandler.cc (fhandler_base::~fhandler_base): Remove path_conv cleanup.
* syscalls.cc (chroot): Ditto.
* path.cc (path_conv::~path_conv): Define new destructor.
(conv_path_list_buf_size): Remove explicit path_conv cleanup.
* path.h (path_conv::~path_conv): Declare new destructor.
@
text
@d849 2
a850 3
      res = get_file_attribute (win32_path.has_acls (),
				win32_path.get_win32 (),
				&attrib);
@


1.321
log
@	* syscalls.cc (rename): Do not test the MoveFile error code
	where MoveFileEx exists.
@
text
@a2322 2
  if (!path.normalized_path_size && path.normalized_path)
    cfree (path.normalized_path);
@


1.320
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d1317 1
a1317 5
  if (!MoveFile (real_old, real_new))
    res = -1;

  if (res == 0 || (GetLastError () != ERROR_ALREADY_EXISTS
		   && GetLastError () != ERROR_FILE_EXISTS))
d1320 1
d1327 2
a1328 1
  else
@


1.319
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d464 1
a464 1
      if (res >= 0 || get_errno () != EINTR || !call_signal_handler_now ())
@


1.318
log
@* cygtls.cc (_threadinfo::init_thread): Add more local reent stdio
initialization.
* dcrt0.cc (initial_env): Can it really be true that XP doesn't allow attaching
a debugger during DLL attach?  Add temporary workaround.
(dll_crt0_0): Ensure that _impure_ptr stdio is initialized before any threads.
(dll_crt0_1): Move _impure_ptr initialization to dll_crt0_0.
* exceptions.cc (try_to_debug): Reinstate old method for looping while
debugging.
* syscalls.cc (_cygwin_istext_for_stdio): Regularize debugging output.  Remove
hopefully extraneous check.
(setmode_helper): Add debugging output for improbable case.  Use "binary"
rather "raw" for consistency.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.317
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@a1601 1
  syscall_printf ("_cygwin_istext_for_stdio (%d)", fd);
d1604 1
a1604 1
      syscall_printf (" _cifs: old API");
d1611 1
a1611 1
      syscall_printf (" _cifs: fd not open");
d1615 1
d1618 1
a1618 1
      syscall_printf (" _cifs: fd not disk file");
d1621 1
d1625 1
a1625 1
      syscall_printf (" _cifs: get_*_binary");
d1629 1
a1629 1
  syscall_printf ("_cygwin_istext_for_stdio says yes");
d1643 6
a1648 4
    return 0;
  syscall_printf ("setmode: file was %s now %s",
		 f->_flags & __SCLE ? "text" : "raw",
		 setmode_mode & O_TEXT ? "text" : "raw");
d1706 1
a1706 1
  syscall_printf ("setmode (%d<%s>, %p) returns %s", fd, cfd->get_name (),
@


1.316
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d330 2
a333 2
      if (cygheap->ctty)
	cygheap->close_ctty ();
a1241 85
int
access_worker (path_conv& real_path, int flags, fhandler_base *fh)
{
  if (real_path.error)
    {
      set_errno (real_path.error);
      return -1;
    }

  if (!real_path.exists ())
    {
      set_errno (ENOENT);
      return -1;
    }

  if (!(flags & (R_OK | W_OK | X_OK)))
    return 0;

  if (real_path.is_fs_special ())
    /* short circuit */;
  else if (real_path.has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK))
    {
      set_errno (EACCES);
      return -1;
    }
  else if (real_path.has_acls () && allow_ntsec)
    return check_file_access (real_path, flags);

  struct __stat64 st;
  int r = fh ? fh->fstat (&st) : stat_worker (real_path, &st, 0);
  if (r)
    return -1;
  r = -1;
  if (flags & R_OK)
    {
      if (st.st_uid == myself->uid)
	{
	  if (!(st.st_mode & S_IRUSR))
	    goto done;
	}
      else if (st.st_gid == myself->gid)
	{
	  if (!(st.st_mode & S_IRGRP))
	    goto done;
	}
      else if (!(st.st_mode & S_IROTH))
	goto done;
    }
  if (flags & W_OK)
    {
      if (st.st_uid == myself->uid)
	{
	  if (!(st.st_mode & S_IWUSR))
	    goto done;
	}
      else if (st.st_gid == myself->gid)
	{
	  if (!(st.st_mode & S_IWGRP))
	    goto done;
	}
      else if (!(st.st_mode & S_IWOTH))
	goto done;
    }
  if (flags & X_OK)
    {
      if (st.st_uid == myself->uid)
	{
	  if (!(st.st_mode & S_IXUSR))
	    goto done;
	}
      else if (st.st_gid == myself->gid)
	{
	  if (!(st.st_mode & S_IXGRP))
	    goto done;
	}
      else if (!(st.st_mode & S_IXOTH))
	goto done;
    }
  r = 0;
done:
  if (r)
    set_errno (EACCES);
  return r;
}

d1246 1
d1248 2
d1251 3
a1253 2
      set_errno (EINVAL);
      return -1;
d1255 2
a1256 3

  path_conv pc (fn, PC_SYM_FOLLOW | PC_FULL, stat_suffixes);
  return access_worker (pc, flags);
@


1.315
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d303 1
d316 1
@


1.314
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d88 1
a88 1
close_all_files (void)
@


1.314.4.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a302 1
#ifdef NEWVFORK
a314 1
#endif
@


1.314.4.2
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d330 2
a333 2
      syscall_printf ("sid %d, pgid %d, ctty %d, open_fhs %d", myself->sid,
		      myself->pgid, myself->ctty, cygheap->open_fhs);
d1242 85
a1330 1
  int res = -1;
a1331 2
    set_errno (EINVAL);
  else
d1333 2
a1334 3
      fhandler_base *fh = build_fh_name (fn, NULL, PC_SYM_FOLLOW | PC_FULL, stat_suffixes);
      res =  fh->fhaccess (flags);
      delete fh;
d1336 3
a1338 2
  debug_printf ("returning %d", res);
  return res;
@


1.314.4.3
log
@* cygtls.cc (_threadinfo::init_thread): Add more local reent stdio
initialization.
* dcrt0.cc (initial_env): Can it really be true that XP doesn't allow attaching
a debugger during DLL attach?  Add temporary workaround.
(dll_crt0_0): Ensure that _impure_ptr stdio is initialized before any threads.
(dll_crt0_1): Move _impure_ptr initialization to dll_crt0_0.
* exceptions.cc (try_to_debug): Reinstate old method for looping while
debugging.
* syscalls.cc (_cygwin_istext_for_stdio): Regularize debugging output.  Remove
hopefully extraneous check.
(setmode_helper): Add debugging output for improbable case.  Use "binary"
rather "raw" for consistency.
@
text
@d1602 1
d1605 1
a1605 1
      syscall_printf ("fd %d: old API", fd);
d1612 1
a1612 1
      syscall_printf ("fd %d: not open", fd);
a1615 1
#if 0
d1618 1
a1618 1
      syscall_printf ("fd not disk file.  Defaulting to binary.");
a1620 1
#endif
d1624 1
a1624 1
      syscall_printf ("fd %d: opened as binary", fd);
d1628 1
a1628 1
  syscall_printf ("fd %d: defaulting to text", fd);
d1642 4
a1645 6
    {
      syscall_printf ("improbable, but %d != %d", fileno (f), setmode_file);
      return 0;
    }
  syscall_printf ("file was %s now %s", f->_flags & __SCLE ? "text" : "binary",
		  setmode_mode & O_TEXT ? "text" : "binary");
d1703 1
a1703 1
  syscall_printf ("(%d<%s>, %p) returning %s", fd, cfd->get_name (),
@


1.313
log
@Move open_fhs from fhandler.h to cygheap.h for easier tracking.  Accommodate
this change throughout.
* dtable.cc (dtable::add_archetype): Use correct count when iterating through
*active* archetypes.
* dtable.cc (dtable::fixup_after_exec): Close handle if close_on_exec and
archetype exists since archetype currently does not set windows close-on-exec
flag (FIXME).
* fhandler_tty.cc (fhandler_tty_slave::open): Change debugging output slightly.
(fhandler_tty_slave::close): Ditto.
(fhandler_tty_slave::fixup_after_fork): Just report on inherited use counts
since since archetype currently does not set windows close-on-exec flag
(FIXME).
* pinfo.cc (_pinfo::set_ctty): Change debugging output slightly.
* cygheap.cc (cygheap_init): Remove open_fhs accommodation and use count
reporting.
* perthread.h (vfork_save::fhctty): New element.
* perthread.h (vfork_save::open_fhs): New element.
* fork.cc (vfork): Muck around with ctty and open_fhs stuff, both of which are
now saved in the vfork_save structure.
@
text
@d90 1
a90 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "close_all_files");
d104 1
a104 5
    {
      debug_printf ("closing ctty");
      cygheap->ctty->close ();
      cygheap->ctty = NULL;
    }
d106 1
a106 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "close_all_files");
d331 1
a331 4
	{
	  cygheap->ctty->close ();
	  cygheap->ctty = NULL;
	}
@


1.313.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d90 1
a90 1
  cygheap->fdtab.lock ();
d104 5
a108 1
    cygheap->close_ctty ();
d110 1
a110 1
  cygheap->fdtab.unlock ();
d335 4
a338 1
	cygheap->close_ctty ();
@


1.313.2.2
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@d88 1
a88 1
close_all_files ()
@


1.312
log
@* syscalls.cc (close_all_files): Simplify logic around closing ctty.
@
text
@d107 1
d324 1
a324 1
      if (myself->ctty >= 0 && fhandler_console::open_fhs <= 0)
d333 1
a333 1
		      myself->pgid, myself->ctty, fhandler_console::open_fhs);
@


1.311
log
@* fhandler.h (fhandler_tty_master::fixup_after_fork): Remove declaration.
(fhandler_tty_master::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Fix so that children do not
inherit master tty handles.
(fhandler_tty_master::fixup_after_fork): Remove, since it was never used.
(fhandler_tty_master::fixup_after_exec): Ditto.
* pinfo.cc (_pinfo::set_ctty): Increment open_fhs when ctty is set.
* cygheap.cc (cygheap_init): Ditto.
* syscalls.cc (setsid): *Always* call close on opened ctty since the archetype
is associated with the ctty and it counts as an opened handle.
* tty.cc (tty::common_init): Don't protect input/output mutex since it confuses
subsequent fork/execs when CYGWIN=tty.
@
text
@a91 9
  if (cygheap->ctty)
    {
      if (cygheap->ctty->usecount == 1)
	cygheap->ctty->close ();
      else
	cygheap->ctty->usecount--;
      debug_printf ("ctty usecount %d", cygheap->ctty->archetype->usecount);
    }

d102 6
@


1.310
log
@* exceptions.cc (try_to_debug): Fix off-by-one problem when resetting
environment variable after error_start detected.
* fhandler_tty_slave.cc (fhandler_tty_slave::close): Clarify debug message.
* syscalls.cc (setsid): Don't increment usecount here, since it will be
automatically decremented on close.
@
text
@d338 1
a338 2
	  if (cygheap->ctty->usecount == 1)
	    cygheap->ctty->close ();
@


1.309
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d338 1
a338 1
	  if (!--cygheap->ctty->usecount)
@


1.308
log
@* exceptions.cc (set_signal_mask): Report on input argument rather than
getsigmask.
* fhandler.h (fhandler_base): Make friends with close_all_files.
* pinfo.cc (_pinfo::set_ctty): Add more debugging.
* sigproc.cc (proc_can_be_signalled): Detect state when signal handler thread
is gone in target process as an EPERM situation.  Set errno to ESRCH if process
doesn't exist.
(sigproc_terminate): Set sendsig to illegal value when closed.
(sig_send): Rely on proc_can_be_signalled setting the proper errno.
* syscalls.cc (close_all_files): Detect when all ttys are closed prior to
calling close_all_files.  The ctty needs to be closed explicitly in this case.
@
text
@d322 3
a324 1
  if (myself->pgid != myself->pid)
@


1.307
log
@* winsup.h (access_worker): Declare with added fhandler_base parameter.
* syscalls.cc (access_worker): Accommodate extra fhandler_base argument.  Use
it instead of stat_worker to determine stat information, when appropriate.
* fhandler.cc (fhandler_base::device_access_denied): Pass fhandler pointer to
access_worker so that it can use the proper method for determining stat
information.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
@
text
@d94 5
a98 2
      debug_printf ("decrementing ctty usecount");
      cygheap->ctty->usecount--;
d105 3
@


1.306
log
@* cygheap.h (cygheap_types): Add HEAP_ARCHETYPES.
(init_cheap::ctty): Change to pointer.
* dtable.h (dtable::find_archetype): Declare new function.
(dtable::add_archetype): Declare new function.
(dtable::delete_archetype): Declare new function.
(dtable::narchetypes): Declare.
(dtable::farchetypes): Declare.
(dtable::initial_archetype_size): Declare.
(dtable::dtable): Initialize new fields.
(dtable::initial_archetype_size): Declare.
* dtable.cc (dtable::find_archetype): Define new function.
(dtable::add_archetype): Define new function.
(dtable::delete_archetype): Define new function.
(dtable::initial_archetype_size): Define.
* fhandler.h (fhandler_base::archetype): Declare.
(fhandler_base::usecount): Declare.
* fhandler.cc (fhandler_base::fhandler_base): Initialize new fields.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass NULL to third
argument of set_ctty.
* fhandler_tty.cc (fhandler_tty_slave::open): Accommodate new archetype method
to create only one instance of a tty.
(fhandler_tty_slave::close): Don't close handles unless archetype usecount is
zero.  When that happens, close archetype too.
(fhandler_tty_slave::dup): Just copy archetype.  Set use count appropriately.
Set ctty, if appropriate.
(fhandler_tty_common::dup): Remove slave considerations.
(fhandler_tty_common::set_close_on_exec): Remove cygheap->ctty considerations.
* pinfo.cc (_pinfo::set_ctty): Accommodate new archetype methods.
* pinfo.h (_pinfo::set_ctty): Make third argument explicit.
* syscalls.cc (close_all_files): Decrement controlling tty use count before
closing all handles to allow controlling tty to be closed.  Remove previous
controlling tty considerations.
@
text
@d1243 1
a1243 1
access_worker (path_conv& real_path, int flags)
d1271 1
a1271 1
  int r = stat_worker (real_path, &st, 0);
@


1.305
log
@* fhandler_tty.cc (fhandler_tty_common::dup): Just copy cygheap->ctty to child
if duping the current ctty.
(fhandler_tty_common::close): Move debugging statement earlier in function.
(fhandler_tty_slave::close): Return success when closing ctty.
* syscalls.cc (close_all_files): Avoid calling fhandler_tty_slave close method
so that open_fhs will not be decremented when closing cygheap ctty.
(setsid): Ditto.
* dcrt0.cc (do_exit): Reorganize to avoid leaving a critical section active
after vfork.
* fhandler.h (fhandler_tty_slave::get_unit): Remove regparm parameter since it
can't work in a virtualized function.
@
text
@d92 6
a105 3
  if (cygheap->ctty.get_io_handle ())
    cygheap->ctty.fhandler_tty_common::close ();

a325 2
      if (cygheap->ctty.get_io_handle ())
	cygheap->ctty.fhandler_tty_common::close ();
d328 6
@


1.304
log
@* fhandler.h (fhandler_tty_slave::ttyname): Use name from pc since it is
guaranteed to be accurate.
* fhandler_tty.cc (fhandler_tty_slave::open): Increment open_fhs appropriate
when copying ctty.
(fhandler_tty_slave::close): Remove special case handling for exit_state.  Use
ctty < 0 check instead.
(fhandler_tty_common::close): Set io_handle to NULL after closing.
* syscalls.cc (close_all_files): Specifically close cygheap->ctty, if
appropriate.
@
text
@d101 1
a101 4
    {
      myself->ctty = -1;
      cygheap->ctty.close ();
    }
d324 1
a324 4
	{
	  cygheap->ctty.close ();
	  cygheap->ctty.set_io_handle (NULL);
	}
@


1.303
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d100 6
@


1.302
log
@	* syscalls.cc (locked_append): New.
	(updwtmp): Remove mutex code and call locked_append.
	(pututline): Ditto.
@
text
@d320 5
d660 1
a660 1
  extern BOOL allow_winsymlinks;
d2104 1
a2104 1
  BOOL token_is_internal, issamesid;
@


1.301
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d2556 21
a2579 3
  /* Writing to wtmp must be atomic to prevent mixed up data. */
  char mutex_name[CYG_MAX_PATH];
  HANDLE mutex;
d2582 1
a2582 5
  mutex = CreateMutex (NULL, FALSE, shared_name (mutex_name, "wtmp_mutex", 0));
  if (mutex)
    while (WaitForSingleObject (mutex, INFINITE) == WAIT_ABANDONED)
      ;
  if ((fd = open (wtmp_file, O_WRONLY | O_APPEND | O_BINARY, 0)) >= 0)
d2584 1
a2584 1
      write (fd, ut, sizeof *ut);
a2586 5
  if (mutex)
    {
      ReleaseMutex (mutex);
      CloseHandle (mutex);
    }
d2795 1
a2795 8
  /* Read/write to utmp must be atomic to prevent overriding data
     by concurrent processes. */
  char mutex_name[CYG_MAX_PATH];
  HANDLE mutex = CreateMutex (NULL, FALSE,
			      shared_name (mutex_name, "utmp_mutex", 0));
  if (mutex)
    while (WaitForSingleObject (mutex, INFINITE) == WAIT_ABANDONED)
      ;
a2797 5
    lseek (utmp_fd, -sizeof *ut, SEEK_CUR);
  else
    lseek (utmp_fd, 0, SEEK_END);
  write (utmp_fd, ut, sizeof *ut);
  if (mutex)
d2799 2
a2800 2
      ReleaseMutex (mutex);
      CloseHandle (mutex);
d2802 2
@


1.300
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@a120 1
  sigframe thisframe (mainthread);
a397 1
      sigframe thisframe (mainthread);
d452 1
a452 1
      if (res >= 0 || get_errno () != EINTR || !thisframe.call_signal_handler ())
a470 1
  sigframe thisframe (mainthread);
a523 1
  sigframe thisframe (mainthread);
a572 1
  sigframe thisframe (mainthread);
a607 1
  sigframe thisframe (mainthread);
a631 1
  sigframe thisframe (mainthread);
a652 1
  sigframe thisframe (mainthread);
d782 1
a782 1
			           | FILE_ATTRIBUTE_SYSTEM
a859 1
  sigframe thisframe (mainthread);
a865 1
  sigframe thisframe (mainthread);
a872 1
  sigframe thisframe (mainthread);
a878 1
  sigframe thisframe (mainthread);
a885 1
  sigframe thisframe (mainthread);
a934 1
  sigframe thisframe (mainthread);
a997 1
  sigframe thisframe (mainthread);
a1040 1
  sigframe thisframe (mainthread);
a1099 1
  sigframe thisframe (mainthread);
a1174 1
  sigframe thisframe (mainthread);
a1214 1
  sigframe thisframe (mainthread);
a1317 1
  sigframe thisframe (mainthread);
a1331 1
  sigframe thisframe (mainthread);
a1465 1
  sigframe thisframe (mainthread);
a1780 1
  sigframe thisframe (mainthread);
a1823 1
  sigframe thisframe (mainthread);
a1865 1
  sigframe thisframe (mainthread);
a1920 1
  sigframe thisframe (mainthread);
a1930 1
  sigframe thisframe (mainthread);
a1971 1
  sigframe thisframe (mainthread);
a1986 1
  sigframe thisframe (mainthread);
a1992 1
  sigframe thisframe (mainthread);
a1998 1
  sigframe thisframe (mainthread);
a2094 1
  sigframe thisframe (mainthread);
d2102 1
a2102 1
  
d2173 1
a2173 1
      
d2192 1
a2192 1
  issamesid = (usersid == cygheap->user.sid ()); 
d2195 1
a2195 1
                                                  : new_token;
d2197 1
a2197 1
    RegCloseKey(HKEY_CURRENT_USER); 
a2274 1
  sigframe thisframe (mainthread);
a2368 1
  sigframe thisframe (mainthread);
a2399 1
  sigframe thisframe (mainthread);
a2411 1
  sigframe thisframe (mainthread);
a2419 1
  sigframe thisframe (mainthread);
a2489 1
  sigframe thisframe (mainthread);
a2582 1
  sigframe thisframe (mainthread);
a2599 1
  sigframe thisframe (mainthread);
a2607 1
  sigframe thisframe (mainthread);
a2635 1
  sigframe thisframe (mainthread);
a2663 1
  sigframe thisframe (mainthread);
a2674 1
  sigframe thisframe (mainthread);
a2697 1
  sigframe thisframe (mainthread);
a2713 1
  sigframe thisframe (mainthread);
a2751 1
  sigframe thisframe (mainthread);
a2773 1
  sigframe thisframe (mainthread);
d2808 1
a2808 1
long gethostid(void)
a2824 1
  sigframe thisframe (mainthread);
d2947 1
a2947 1
        return strcpy (buf, def_shells[shell_index++]);
@


1.299
log
@	* syscalls.cc (ftruncate64): Log length as long long.
	(logout): Erase ut_host.  Don't write wtmp entry.  Return 1 only
	if matching utmp entry has been found, 0 otherwise.
@
text
@d692 1
a692 1
  char new_lnk_buf[MAX_PATH + 5];
d713 1
a713 1
      WCHAR wbuf[MAX_PATH];
d728 1
a728 1
      cbPathLen = sys_mbstowcs (wbuf, real_b, MAX_PATH) * sizeof (WCHAR);
d1368 1
a1368 1
  char new_lnk_buf[MAX_PATH + 5];
d2047 1
a2047 1
  char buf[sizeof (":\\00000000:00000000:00000000") + MAX_PATH];
d2059 1
a2059 1
  if (strlen (path) >= MAX_PATH)
d2598 1
a2598 1
  char mutex_name[MAX_PATH];
d2836 1
a2836 1
  char mutex_name[MAX_PATH];
d2990 1
a2990 1
  static char buf[MAX_PATH];
d3005 1
a3005 1
       ch != EOF && !isspace (ch) && buf_idx < MAX_PATH;
d3009 1
a3009 1
     path is longer than MAX_PATH, it's invalid anyway. */
@


1.298
log
@	* syscalls.cc (getshmlba): New function.
	* external.cc (cygwin_internal): Add CW_GET_SHMLBA handling.
	* mmap.cc (mmap64): Call getshmlba to evaluate granularity.
	* winsup.h (getshmlba): Add declaration.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_SHMLBA.
@
text
@d1832 1
a1832 1
  syscall_printf ("%d = ftruncate (%d, %d)", res, fd, length);
d2660 1
a2661 1
      updwtmp (_PATH_WTMP, &ut_buf);
a2662 2
      memset (ut->ut_line, 0, sizeof ut_buf.ut_line);
      ut->ut_time = 0;
d2665 1
d2667 1
a2667 1
  return 1;
@


1.297
log
@2003-10-16  Pierre Humblet  <pierre.humblet@@ieee.org>

	* syscalls.cc (seteuid32): Always construct a default DACL including
	the new sid, Admins and SYSTEM and copy it to the new thread token.
	* security.cc (create_token): Use a NULL default DACL in NtCreateToken.
@
text
@d1532 8
@


1.296
log
@	* syscalls.cc (unlink): Don't even try DELETE_ON_CLOSE technique on
	systems not supporting it.
@
text
@d2124 2
d2166 1
a2166 1
  if (cygheap->user.current_token != new_token)
d2168 5
a2172 10
      char dacl_buf[MAX_DACL_LEN (5)];
      if (sec_acl ((PACL) dacl_buf, true, false, usersid))
	{
	  TOKEN_DEFAULT_DACL tdacl;
	  tdacl.DefaultDacl = (PACL) dacl_buf;
	  if (!SetTokenInformation (ptok, TokenDefaultDacl,
				    &tdacl, sizeof dacl_buf))
	    debug_printf ("SetTokenInformation"
			  "(TokenDefaultDacl): %E");
	}
d2193 1
a2193 1
  else if (new_token != ptok)
d2204 1
a2204 2
      if (!SetTokenInformation (new_token,
				TokenPrimaryGroup,
d2208 5
@


1.295
log
@* path.cc (symlink_info::check): Use new introducer for mknod'ed files.
(parse_device): Ditto.
* syscalls.cc (mknod_worker): Ditto.
@
text
@d174 1
a174 4
  HANDLE h;
  h = CreateFile (win32_name, 0, FILE_SHARE_READ, &sec_none_nih,
		  OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
  if (h != INVALID_HANDLE_VALUE)
d176 4
a179 6
      if (wincap.has_hard_links () && setattrs)
	(void) SetFileAttributes (win32_name, (DWORD) win32_name);
      BOOL res = CloseHandle (h);
      syscall_printf ("%d = CloseHandle (%p)", res, h);
      if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	  || !win32_name.isremote ())
d181 16
a196 8
	  syscall_printf ("CreateFile (FILE_FLAG_DELETE_ON_CLOSE) succeeded");
	  goto ok;
	}
      else
	{
	  syscall_printf ("CreateFile (FILE_FLAG_DELETE_ON_CLOSE) failed");
	  if (setattrs)
	    SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
@


1.294
log
@* cygwin-shilka: Remove '#line directives' or suffer debugging oddities.  Use
-length option so that device prefixes are used.
* devices.cc: Regenerate.
* syscalls.cc (ttyname): Add debugging output.
@
text
@d2036 2
a2037 2
  char buf[sizeof (":00000000:00000000:00000000") + MAX_PATH];
  sprintf (buf, ":%x:%x:%x", major, minor,
@


1.293
log
@2003-09-24  Pierre Humblet <pierre.humblet@@ieee.org>

	* shared_info.h (class user_info): New.
	(cygwin_user_h): New.
	(user_shared): New.
	(enum shared_locations): Replace SH_MOUNT_TABLE by SH_USER_SHARED;
	(mount_table): Change from variable to macro.
	* shared.cc: Use sizeof(user_info) in "offsets".
	(user_shared_initialize): Add "reinit" argument to indicate need
	to reinitialize the mapping. Replace "mount_table" by "user_shared"
	throughout. Call user_shared->mountinfo.init and
	user_shared->delqueue.init.
	(shared_info::initialize): Do not call delqueue.init.
	(memory_init): Add argument to user_shared_initialize.
	* child_info.h (child_info::mount_h): Delete.
	(child_info::user_h): New.
	* sigpproc.cc (init_child_info): Use user_h instead of mount_h.
	* dcrt0.cc (_dll_crt0): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Use
	user_shared->delqueue instead of cygwin_shared->delqueue.
	* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
	* syscalls.cc (close_all_files): Ditto.
	(unlink): Ditto.
	(seteuid32): Add argument to user_shared_initialize.
@
text
@d1657 1
d1661 3
a1663 1
  return (char *) (cfd->ttyname ());
@


1.292
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d101 1
a101 1
  cygwin_shared->delqueue.process_queue ();
d225 1
a225 1
  cygwin_shared->delqueue.queue_file (win32_name);
d2217 1
a2217 1
    user_shared_initialize ();
@


1.291
log
@* syscalls.cc (system): Strip signal considerations from here so that they are
not inherited by a child process.
* spawn.cc (spawn_guts): Handle system() signal stuff here.
* winsup.h (_P_SYSTEM): Define.
@
text
@d52 1
a53 1
#include "path.h"
d76 6
d495 1
a495 1
  if (res > bg_eof)
d539 1
a539 3
	  path_conv pc;
	  if (!(fh = cygheap->fdtab.build_fhandler_from_name (fd, unix_path,
							      NULL, pc)))
d541 1
a541 1
	  else if (!fh->open (&pc, flags, (mode & 07777) & ~cygheap->umask))
d543 1
a543 1
	      fd.release ();
d546 11
a556 2
	  else if ((res = fd) <= 2)
	    set_std_handle (res);
d833 1
a833 1
      if (win32_path.is_device () && !win32_path.issocket ())
d934 6
d957 1
a957 1
  if (win32_path.is_device () && !win32_path.issocket ())
d962 5
a1059 1
      path_conv pc (cfd->get_name (), PC_SYM_NOFOLLOW);
d1061 2
a1062 2
      res = cfd->fstat (buf, &pc);
      if (!res && cfd->get_device () != FH_SOCKET)
d1067 1
a1067 1
	    buf->st_dev = (cfd->get_device () << 16) | cfd->get_unit ();
d1144 2
a1145 3
int __stdcall
stat_worker (const char *name, struct __stat64 *buf, int nofollow,
	     path_conv *pc)
a1147 1
  path_conv real_path;
d1153 2
a1154 7
  if (!pc)
    pc = &real_path;

  fh = cygheap->fdtab.build_fhandler_from_name (-1, name, NULL, *pc,
						(nofollow ? PC_SYM_NOFOLLOW
							  : PC_SYM_FOLLOW)
						| PC_FULL, stat_suffixes);
d1156 1
a1156 1
  if (pc->error)
d1158 2
a1159 2
      debug_printf ("got %d error from build_fhandler_from_name", pc->error);
      set_errno (pc->error);
d1164 1
a1164 1
		    pc, (DWORD) real_path);
d1166 2
a1167 2
      res = fh->fstat (buf, pc);
      if (!res && fh->get_device () != FH_SOCKET)
d1172 1
a1172 1
	    buf->st_dev = (fh->get_device () << 16) | fh->get_unit ();
d1246 2
a1247 2
extern "C" int
access (const char *fn, int flags)
a1248 9
  sigframe thisframe (mainthread);
  // flags were incorrectly specified
  if (flags & ~(F_OK|R_OK|W_OK|X_OK))
    {
      set_errno (EINVAL);
      return -1;
    }

  path_conv real_path (fn, PC_SYM_FOLLOW | PC_FULL, stat_suffixes);
d1264 3
a1266 1
  if (real_path.has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK))
d1271 1
a1271 2

  if (real_path.has_acls () && allow_ntsec)
d1275 1
a1275 1
  int r = stat_worker (fn, &st, 0);
d1332 15
d1599 1
a1599 1
      if (cfd->get_device () == FH_DISK)
d1641 1
a1641 1
	if (full_path.is_device ())
d1659 1
a1659 3
    {
      return 0;
    }
d1694 1
a1694 1
  if (cfd->get_device () != FH_DISK)
d1884 1
a1884 2

  const char *root = full_path.root_dir();
d2029 10
a2038 6
/* mknod was the call to create directories before the introduction
   of mkdir in 4.2BSD and SVR3.  Use of mknod required superuser privs
   so the mkdir command had to be setuid root.
   Although mknod hasn't been implemented yet, some GNU tools (e.g. the
   fileutils) assume its existence so we must provide a stub that always
   fails. */
d2040 1
a2040 1
mknod32 (const char *_path, mode_t mode, __dev32_t dev)
d2042 43
a2084 2
  set_errno (ENOSYS);
  return -1;
d2096 1
a2096 1
  set_errno (ENOSYS);
d2411 1
a2411 1
  if (path.normalized_path)
@


1.290
log
@* syscalls.cc (gethostid): Add lpFreeBytesAvailable argument to
GetDiskFreeSpaceEx call since NT4 requires it.
@
text
@a1452 15
struct system_cleanup_args
{
  _sig_func_ptr oldint, oldquit;
  sigset_t old_mask;
};

static void system_cleanup (void *args)
{
  struct system_cleanup_args *cleanup_args = (struct system_cleanup_args *) args;

  signal (SIGINT, cleanup_args->oldint);
  signal (SIGQUIT, cleanup_args->oldquit);
  (void) sigprocmask (SIG_SETMASK, &cleanup_args->old_mask, 0);
}

a1463 2
  struct system_cleanup_args cleanup_args;
  sigset_t child_block;
d1466 1
a1466 7
	return 1;

  cleanup_args.oldint = signal (SIGINT, SIG_IGN);
  cleanup_args.oldquit = signal (SIGQUIT, SIG_IGN);
  sigemptyset (&child_block);
  sigaddset (&child_block, SIGCHLD);
  (void) sigprocmask (SIG_BLOCK, &child_block, &cleanup_args.old_mask);
d1473 1
a1473 3
  pthread_cleanup_push (system_cleanup, (void *) &cleanup_args);

  if ((res = spawnvp (_P_WAIT, "sh", command)) == -1)
a1478 2

  pthread_cleanup_pop (1);
@


1.289
log
@2003-09-15  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h (__sec_user): Add "access2" argument.
	(sec_acl): Add "original" and "access2" arguments.
	(sec_user): Add "sid2" and "access2" argument. Remove dependence on
	allow_ntsec.
	(sec_user_nih): Ditto.
	* sec_helper.cc (__sec_user): Add "has_security" test.
	Call sec_acl with new arguments, letting it handle original_sid.
	(sec_acl): Add "original" and "access2" arguments. Handle original_sid
	depending on flag but avoiding duplicates. Use "access2" for sid2.
	* pinfo.cc (pinfo::init): Use security attributes created by sec_user
	when creating the mapping.
	* security.cc (create_token): Adjust arguments in call to sec_acl.
	Call sec_user instead of __sec_user.
	* syscall.cc (seteuid32):  Adjust arguments in call to sec_acl. Remove
	now unnecessary test. Remove useless conversions to psid.
	* dcrt0.cc (dll_crt0_1): Call cygsid::init before pinfo_init.
@
text
@d2887 4
a2890 1
  GetDiskFreeSpaceEx ("C:\\", NULL, (PULARGE_INTEGER) &data[11], NULL);
@


1.288
log
@* include/sys/cygwin.h: Rename PID_UNUSED to PID_MAP_RW.
* pinfo.cc (pinfo_init): Initialize myself->gid.
(pinfo::init): Create the "access" variable, set it appropriately and use it to
specify the requested access.
* exceptions.cc (sig_handle_tty_stop): Add PID_MAP_RW in pinfo parent.
* signal.cc (kill_worker): Ditto for pinfo dest.
* syscalls.cc (setpgid): Ditto for pinfo p.
@
text
@a2078 1
  cygpsid origpsid, psid2 (NO_SID);
d2123 1
a2123 3
      if (usersid != (origpsid = cygheap->user.orig_sid ()))
	psid2 = usersid;
      if (sec_acl ((PACL) dacl_buf, FALSE, origpsid, psid2))
d2171 1
a2171 1
  issamesid = (usersid == (psid2 = cygheap->user.sid ())); 
@


1.287
log
@	* Makefile.in (DLL_OFILES): Add getopt.o and iruserok.o.
	* cygwin.din: Export __check_rhosts_file, __rcmd_errstr, optarg,
	opterr, optind, optopt, optreset, getopt, getopt_long, iruserok
	and ruserok.
	* getopt.c: Moved from lib to here.  Define opt* variables as
	dllexport.
	* iruserok.c: Moved from lib to here.  Rearrange function order.
	Prefer using 64/32 bit functions.
	* syscalls.cc (shell_fp): Define as struct __sFILE64.
	(getusershell): Use fopen64 instead of fopen.
	* winsup.h: Add declarations for seteuid32, fopen64,
	cygwin_gethostbyname and cygwin_inet_addr.
	* include/getopt.h: Declare opt* variables dllimport.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1964 1
a1964 1
      pinfo p (pid);
@


1.287.2.1
log
@* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Handle buf ==
NULL as flushing the buffer.
(fhandler_tty_slave::read): Handle ptr == NULL as flushing the buffer.
(fhandler_tty_slave::tcflush): Implement input queue flushing by calling read
with NULL buffer.
(fhandler_pty_master::tcflush): Ditto, calling process_slave_output.
* termios.cc (tcflush): Check for legal `queue' value.  Return EINVAL
otherwise.
* syscalls.cc (gethostid): Add lpFreeBytesAvailable argument to
GetDiskFreeSpaceEx call since NT4 requires it.
@
text
@d2890 1
a2890 4
  /* Contrary to MSDN, NT4 requires the second argument
     or a STATUS_ACCESS_VIOLATION is generated */
  ULARGE_INTEGER availb;
  GetDiskFreeSpaceEx ("C:\\", &availb, (PULARGE_INTEGER) &data[11], NULL);
@


1.287.2.2
log
@* thread.h (__reent_t::init_clib): Declare new function.
* thread.cc (__reent_t::init_clib): Define new function.
(pthread::thread_init_wrapper): Use __reent_t::init_clib to init local clib
storage and set std{in,out,err} appropriately.
* syscalls.cc (system): Strip signal considerations from here so that they are
not inherited by a child process.
* spawn.cc (spawn_guts): Handle system() signal stuff here.
* winsup.h (_P_SYSTEM): Define.
@
text
@d1453 15
d1479 2
d1483 7
a1489 1
    return 1;
d1496 3
a1498 1
  if ((res = spawnvp (_P_SYSTEM, "sh", command)) == -1)
d1504 2
@


1.286
log
@* Makefile.in: Add some more -fomit-frame-pointer files.
* path.cc (conv_path_list_buf_size): Free normalized_path or suffer memory
leak.
* syscalls.cc (chroot): Ditto.
@
text
@d2922 1
a2922 1
static FILE *shell_fp;
d2941 1
a2941 1
  if (!shell_fp && !(shell_fp = fopen (ETC_SHELLS, "rt")))
@


1.285
log
@	* Makefile.in (DLL_OFILES): Add bsdlib.o.
	* autoload.cc (RegisterServiceProcess): Add.
	* bsdlib.cc: New file.
	(daemon): New function.
	(login_tty): Ditto.
	(openpty): Ditto.
	(forkpty): Ditto.
	* cygwin.din: Export daemon, forkpty, login_tty, logwtmp, updwtmp,
	openpty and revoke.
	* syscalls.cc (updwtmp): New function, writing to wtmp exclusively.
	(logwtmp): Ditto.
	(login): Call updwtmp instead of writing to wtmp by itself.
	(logout): Ditto.
	* tty.cc (revoke): New funtion.
	* include/paths.h: Define _PATH_DEVNULL.
	* include/pty.h: New header.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/utmp.h: Declare logwtmp with const arguments.
	Declare updwtmp.
	* lib/iruserok.c: New file.
	(ruserok): New function.
	(iruserok): Ditto.
	(__ivaliduser): Ditto.
	(__icheckhost): Ditto.
@
text
@d2376 2
@


1.284
log
@2003-09-09  Pierre Humblet <pierre.humblet@@ieee.org>

	* shared_info.h: Include security.h.
	(open_shared): Add psa argument.
	(user_shared_initialize): New declaration.
	* security.h: Add _SECURITY_H guard.
	(sec_user): Use sec_none in the no ntsec case.
	* spawn.cc (spawn_guts): Remove call to load_registry_hive.
	* syscalls (seteuid32): If warranted, call load_registry_hive,
	user_shared_initialize and RegCloseKey(HKEY_CURRENT_USER).
	* shared.cc (user_shared_initialize): New.
	(open_shared): Add and use psa argument.
	(memory_init): Move mount table initialization to
	user_shared_initialize. Call it.
@
text
@d2543 1
a2543 1
login (struct utmp *ut)
a2544 5
  sigframe thisframe (mainthread);
  register int fd;

  pututline (ut);
  endutent ();
d2547 4
a2550 2
  HANDLE mutex = CreateMutex (NULL, FALSE,
			      shared_name (mutex_name, "wtmp_mutex", 0));
d2554 1
a2554 1
  if ((fd = open (_PATH_WTMP, O_WRONLY | O_APPEND | O_BINARY, 0)) >= 0)
d2566 27
a2605 2
      int fd;

d2609 2
a2610 18
      /* Writing to wtmp must be atomic to prevent mixed up data. */
      char mutex_name[MAX_PATH];
      HANDLE mutex = CreateMutex (NULL, FALSE,
				  shared_name (mutex_name, "wtmp_mutex", 0));
      if (mutex)
	while (WaitForSingleObject (mutex, INFINITE) == WAIT_ABANDONED)
	  ;
      if ((fd = open (_PATH_WTMP, O_WRONLY | O_APPEND | O_BINARY, 0)) >= 0)
	{
	  write (fd, &ut_buf, sizeof ut_buf);
	  debug_printf ("set logout time for %s", line);
	  close (fd);
	}
      if (mutex)
	{
	  ReleaseMutex (mutex);
	  CloseHandle (mutex);
	}
@


1.283
log
@	* cygwin.din: Export endusershell, getusershell and setusershell.
	* syscalls.cc (getusershell): New function.
	(setusershell): Ditto.
	(endusershell): Ditto.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d2079 3
a2081 3
  PSID origpsid, psid2 = NO_SID;
  BOOL token_is_internal;

d2157 3
d2174 1
d2177 3
a2179 1
						  : new_token;
d2181 3
@


1.282
log
@* syscalls.cc (_remove_r): Define.
@
text
@d33 2
d2901 64
@


1.281
log
@Throughout, eliminate argument to sig_dispatch_pending.
* exceptions.cc (setup_handler): Move non-interruptible condition handling
(back) to wait_sig (as suggested by Pierre Humblet).
(set_process_mask): Don't worry about calling sig_dispatch_pending from
sigthread since it is detected in the function anyway.
(sig_handle): Eliminate thisproc arg.  Don't call sig_dispatch_pending on
SIGCONT since that should happen automatically.
* sigproc.cc (sig_dispatch_pending): Eliminate justwake argument.  Just return
when called from sigthread.
(wait_sig): Change some variables to bool.  Change inner while to an if.  Move
uninterruptible signal handling here.
(sigproc_terminate): Don't call sig_dispatch_pending.  Just increment semaphore
on exit.
* speclib: Use slightly different (but still flawed) method for determining
symbols to extract from libraries.
@
text
@d235 15
@


1.280
log
@	* cygwin.din: Accomodate change from cygwin_lstat to lstat.
	* syscalls.cc: Add defines to avoid declaration issues when
	renaming cygwin_lstat back to lstat.
	(lstat): Reverted name change from cygwin_lstat.
@
text
@d372 1
a372 1
      sig_dispatch_pending (0);
d444 1
a444 1
  sig_dispatch_pending (0);
d500 1
a500 1
  sig_dispatch_pending (0);
@


1.279
log
@* path.cc (cygdrive_getmntent): Do not skip over drives of type
DRIVE_REMOVABLE.
* fhandler.cc (fhandler_base::lseek): Be more paranoid when constructing
offsets from 64 bit value.
* syscalls.cc (logout): Avoid temp buffer memcpy since new scheme does not
require it.
(utmp_data): Rework as a macro which returns a pointer into a buffer.
(getutent): Use new buffer allocation mechanism to grab a utmp buffer.
(getutid): Ditto.
(pututline): Ditto.
@
text
@d12 1
d42 1
d1204 1
a1204 1
cygwin_lstat (const char *name, struct __stat32 *buf)
@


1.278
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d2551 1
d2556 3
a2558 7
      /* We can't use ut further since it's a pointer to the static utmp_data
	 area (see below) and would get overwritten in pututline().  So we
	 copy it back to the local ut_buf. */
      memcpy (&ut_buf, ut, sizeof ut_buf);
      ut_buf.ut_type = DEAD_PROCESS;
      memset (ut_buf.ut_user, 0, sizeof ut_buf.ut_user);
      time (&ut_buf.ut_time);
d2569 1
d2577 3
a2579 3
      memset (ut_buf.ut_line, 0, sizeof ut_buf.ut_line);
      ut_buf.ut_time = 0;
      pututline (&ut_buf);
a2588 2
static struct utmp utmp_data;

d2644 10
d2664 3
a2666 1
  if (read (utmp_fd, &utmp_data, sizeof utmp_data) != sizeof utmp_data)
d2668 1
a2668 1
  return &utmp_data;
d2683 3
a2685 1
  while (read (utmp_fd, &utmp_data, sizeof utmp_data) == sizeof utmp_data)
d2693 2
a2694 2
	  if (id->ut_type == utmp_data.ut_type)
	    return &utmp_data;
d2700 2
a2701 2
	   if (strncmp (id->ut_id, utmp_data.ut_id, UT_IDLEN) == 0)
	    return &utmp_data;
d2722 8
a2729 8
  while (read (utmp_fd, &utmp_data, sizeof utmp_data) == sizeof utmp_data)
    {
      if ((utmp_data.ut_type == LOGIN_PROCESS ||
	   utmp_data.ut_type == USER_PROCESS) &&
	  !strncmp (utmp_data.ut_line, line->ut_line,
		    sizeof utmp_data.ut_line))
	return &utmp_data;
    }
d2741 8
a2748 1
    return;
@


1.277
log
@	* cygheap.h (class cygheap_user): Use INVALID_HANDLE_VALUE as invalid
	value for tokens.
	* syscalls.cc (seteuid32): Ditto.  Set new_token to process token if
	process token is suitable.
	* uinfo.cc (uinfo_init): Initialize tokens in cygheap user info
	to INVALID_HANDLE_VALUE.

	* cygheap.h (enum impersonation): Delete.
	(cygheap_user::impersonation_state): Delete.
	(cygheap_user::current_token): New.
	(cygheap_user::issetuid): Modify to use current_token.
	(cygheap_user::token): Ditto.
	(cygheap_user::deimpersonate): Ditto.
	(cygheap_user::reimpersonate): Ditto.
	(cygheap_user::has_impersonation_tokens): Ditto.
	(cygheap_user::close_impersonation_tokens): Ditto.
	* security.cc (cygwin_set_impersonation_token): Always set the token.
	(verify_token): Change type of gsid to cygpsid.
	(get_file_attribute): Use the effective ids.
	* syscalls.cc (seteuid32): Modify to use cygheap_user::current_token.
	* uinfo.cc (uinfo_init) Do not set cygheap->user.impersonation_state.
@
text
@d287 1
a287 2
	  syscall_printf ("open_fhs %d, freeing console",
			  fhandler_console::open_fhs);
d293 2
a294 1
      syscall_printf ("sid %d, pgid %d, ctty %d", myself->sid, myself->pgid, myself->ctty);
d2108 1
a2108 1
        {
d2565 1
a2565 1
      				  shared_name (mutex_name, "wtmp_mutex", 0));
d2606 1
a2606 1
        {
d2610 1
a2610 1
        }
d2656 1
a2656 1
        return NULL;
d2673 1
a2673 1
        return NULL;
d2710 1
a2710 1
        return NULL;
d2757 12
a2768 12
                       0x10293412,
                       0x29602018,
                       0x81928167,
                       0x34601329,
                       0x75630198,
                       0x89860395,
                       0x62897564,
                       0x00194362,
                       0x20548593,
                       0x96839102,
                       0x12219854,
                       0x00290012};
d2783 4
a2786 4
        {
          debug_printf ("processor supports CPUID instruction");
          has_cpuid = true;
        }
d2788 1
a2788 1
        debug_printf ("processor does not support CPUID instruction");
d2796 16
a2811 16
        {
          unsigned features;
          cpuid (&data[0], &unused[0], &unused[1], &features, 1);
          if (features & (1 << 18))
            {
              debug_printf ("processor has psn");
              if (maxf >= 3)
                {
                  cpuid (&unused[0], &unused[1], &data[1], &data[2], 3);
                  debug_printf ("Processor PSN: %04x-%04x-%04x-%04x-%04x-%04x",
                                data[0] >> 16, data[0] & 0xffff, data[2] >> 16, data[2] & 0xffff, data[1] >> 16, data[1] & 0xffff);
                }
            }
          else
            debug_printf ("processor does not have psn");
        }
d2825 2
a2826 2
                    Uuid.Data4[2], Uuid.Data4[3], Uuid.Data4[4],
                    Uuid.Data4[5], Uuid.Data4[6], Uuid.Data4[7]);
d2842 10
a2851 10
                                "%08x %08x %08x %08x "
                                "%08x %08x %08x %08x "
                                "%08x",
                                data[0], data[1],
                                data[2], data[3],
                                data[4], data[5],
                                data[6], data[7],
                                data[8], data[9],
                                data[10], data[11],
                                data[12]);
@


1.276
log
@white space
@
text
@a2060 1
  enum impersonation new_state = IMP_BAD;
d2081 3
a2083 3
    new_state = IMP_NONE;
  /* Verify if a current token is suitable */
  else if (cygheap->user.external_token
d2085 10
a2094 5
    {
      new_token = cygheap->user.external_token;
      new_state = IMP_EXTERNAL;
    }
  else if (cygheap->user.internal_token
d2097 1
a2097 4
    {
      new_token = cygheap->user.internal_token;
      new_state = IMP_INTERNAL;
    }
d2099 1
a2099 7
  debug_printf ("New token %d, state %d", new_token, new_state);
  /* Return if current token is valid */
  if (cygheap->user.impersonation_state == new_state)
    {
      cygheap->user.reimpersonate ();
      goto success; /* No change */
    }
d2102 1
a2102 4
  char dacl_buf[MAX_DACL_LEN (5)];
  if (usersid != (origpsid = cygheap->user.orig_sid ()))
    psid2 = usersid;
  if (sec_acl ((PACL) dacl_buf, FALSE, origpsid, psid2))
d2104 12
a2115 6
      TOKEN_DEFAULT_DACL tdacl;
      tdacl.DefaultDacl = (PACL) dacl_buf;
      if (!SetTokenInformation (ptok, TokenDefaultDacl,
				&tdacl, sizeof dacl_buf))
	debug_printf ("SetTokenInformation"
		      "(TokenDefaultDacl): %E");
d2118 3
a2120 1
  if (new_state == IMP_BAD)
a2121 2
      /* If no impersonation token is available, try to
	 authenticate using NtCreateToken () or subauthentication. */
a2130 29
      new_state = IMP_INTERNAL;
    }

  /* If using the token, set info and impersonate */
  if (new_state != IMP_NONE)
    {
      /* If the token was explicitly created, all information has
	 already been set correctly. */
      if (new_state == IMP_EXTERNAL)
	{
	  /* Try setting owner to same value as user. */
	  if (!SetTokenInformation (new_token, TokenOwner,
				    &usersid, sizeof usersid))
	    debug_printf ("SetTokenInformation(user.token, "
			  "TokenOwner): %E");
	  /* Try setting primary group in token to current group */
	  if (!SetTokenInformation (new_token,
				    TokenPrimaryGroup,
				    &groups.pgsid, sizeof (cygsid)))
	    debug_printf ("SetTokenInformation(user.token, "
			  "TokenPrimaryGroup): %E");
	}
      /* Try to impersonate. */
      if (!ImpersonateLoggedOnUser (new_token))
	{
	  debug_printf ("ImpersonateLoggedOnUser %E");
	  __seterrno ();
	  goto failed;
	}
d2132 17
a2148 6
      if (new_state == IMP_INTERNAL)
        {
	  if (cygheap->user.internal_token)
	    CloseHandle (cygheap->user.internal_token);
	  cygheap->user.internal_token = new_token;
	}
a2149 1
  cygheap->user.set_sid (usersid);
a2150 1
success:
d2152 4
a2155 1
  cygheap->user.impersonation_state = new_state;
@


1.275
log
@* syscalls.cc (gethostid): Set thread affinity so that results are predictable.
@
text
@d2876 1
a2876 1
        hostid ^= ((data[i] << (i << 2)) | (data[i] >> (32 - (i << 2))));
@


1.274
log
@* Makefile.in: Remove cygserver stuff.
* acconfig.h: Add USE_CYGSERVER define.
* config.h.in: Regenerate.
* configure.in: Add --enable-server setting.
* configure: Regenerate.
* fhandler_tty.cc (fhandler_tty_slave::open): Conditionalize compilation of
cygserver stuff.
* fork.cc (fork_child): Ditto.
* shm.cc: Ditto.
* tty.cc (tty::common_init): Ditto.
* dcrt0.cc: Use bool rather than BOOL for CYGWIN environment variable
definitions.
* environ.cc: Ditto.
* ntea.cc: Ditto.
* security.cc: Ditto.
* security.h: Ditto.
* syscalls.cc (check_posix_perm): Remove externs that were already declared in
a header.
* winsup.h: Ditto.  Declare _MT_SAFE here.  Delete it someday since cygwin
should always be _MT_SAFE.
@
text
@d2790 5
d2877 3
@


1.273
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@a1516 2
  extern int allow_ntea, allow_ntsec, allow_smbntsec;

@


1.272
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d2060 1
a2060 3
  HANDLE ptok, sav_token;
  BOOL sav_impersonated, sav_token_is_internal_token;
  BOOL process_ok, explicitly_created_token = FALSE;
d2063 2
d2068 1
a2068 1
    goto success;
a2073 3
  /* Save current information */
  sav_token = cygheap->user.token;
  sav_impersonated = cygheap->user.impersonated;
d2079 1
a2079 1
      goto failed;
d2081 17
a2097 14
  /* Verify if the process token is suitable.
     Currently we do not try to differentiate between
	 internal tokens and others */
  process_ok = verify_token (ptok, usersid, groups);
  debug_printf ("Process token %sverified", process_ok ? "" : "not ");
  if (process_ok)
    {
      if (cygheap->user.issetuid ())
	cygheap->user.impersonated = FALSE;
      else
	{
	  CloseHandle (ptok);
	  goto success; /* No change */
	}
d2100 3
a2102 1
  if (!process_ok && cygheap->user.token != INVALID_HANDLE_VALUE)
d2104 2
a2105 18
      /* Verify if the current tokem is suitable */
      BOOL token_ok = verify_token (cygheap->user.token, usersid, groups,
				    &sav_token_is_internal_token);
      debug_printf ("Thread token %d %sverified",
		   cygheap->user.token, token_ok?"":"not ");
      if (!token_ok)
	cygheap->user.token = INVALID_HANDLE_VALUE;
      else
	{
	  /* Return if current token is valid */
	  if (cygheap->user.impersonated)
	    {
	      CloseHandle (ptok);
	      if (!ImpersonateLoggedOnUser (cygheap->user.token))
		system_printf ("Impersonating in seteuid failed: %E");
	      goto success; /* No change */
	    }
	}
a2120 1
  CloseHandle (ptok);
d2122 1
a2122 1
  if (!process_ok && cygheap->user.token == INVALID_HANDLE_VALUE)
d2126 2
a2127 4
      cygheap->user.token = create_token (usersid, groups, pw_new);
      if (cygheap->user.token != INVALID_HANDLE_VALUE)
	explicitly_created_token = TRUE;
      else
d2131 2
a2132 2
	  cygheap->user.token = subauth (pw_new);
	  if (cygheap->user.token == INVALID_HANDLE_VALUE)
d2135 1
d2139 1
a2139 1
  if (!process_ok)
d2143 1
a2143 1
      if (!explicitly_created_token)
d2146 1
a2146 1
	  if (!SetTokenInformation (cygheap->user.token, TokenOwner,
d2151 1
a2151 1
	  if (!SetTokenInformation (cygheap->user.token,
d2157 2
a2158 2
      /* Now try to impersonate. */
      if (!ImpersonateLoggedOnUser (cygheap->user.token))
d2164 7
a2170 1
      cygheap->user.impersonated = TRUE;
d2172 1
a2173 6
  /* If sav_token was internally created and is replaced, destroy it. */
  if (sav_token != INVALID_HANDLE_VALUE &&
      sav_token != cygheap->user.token &&
      sav_token_is_internal_token)
      CloseHandle (sav_token);
  cygheap->user.set_sid (usersid);
d2175 3
d2184 3
a2186 5
  cygheap->user.token = sav_token;
  cygheap->user.impersonated = sav_impersonated;
  if (cygheap->user.issetuid ()
      && !ImpersonateLoggedOnUser (cygheap->user.token))
    system_printf ("Impersonating in seteuid failed: %E");
d2267 1
a2267 1
      if (!SetTokenInformation (cygheap->user.token,
d2285 1
a2285 1
      && !ImpersonateLoggedOnUser (cygheap->user.token))
@


1.271
log
@	* syscalls.cc (statfs): Call GetDiskFreeSpaceEx before GetDiskFreeSpace.
@
text
@a31 1
#include <errno.h>
@


1.270
log
@	* autoload.cc (GetDiskFreeSpaceEx): Add.
	* syscalls.cc (statfs): Call full_path.root_dir() instead of
	rootdir(full_path). Use GetDiskFreeSpaceEx when available and
	report space available in addition to free space.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_by_name):
	Do not call FindFirstFile for disk root directories.
@
text
@d1879 5
d1892 1
a1892 3
  ULARGE_INTEGER availb, freeb, totalb;

  if (GetDiskFreeSpaceEx (root, &availb, &totalb, &freeb))
@


1.269
log
@	* shared_info.h: Match shared_name declaration with below change.
	* shared.cc (shared_name): Use incoming char * parameter instead of
	local static buffer.
	(open_shared): Accomodate new calling convention for shared_name.
	* exceptions.cc (events_init): Ditto.
	* sigproc.cc (getsem): Ditto.
	* syscalls.cc (login): Ditto.
	(logout): Ditto.
	(pututline): Ditto.
@
text
@d1874 2
a1875 1
  char *root = rootdir (full_path);
d1879 1
a1879 1
  DWORD spc, bps, freec, totalc;
d1887 11
d1908 2
a1909 1
  sfs->f_bfree = sfs->f_bavail = freec;
@


1.268
log
@	* Makefile.in (CYGWIN_START): Define as crt0.o.  Add to TARGET_LIBS.
	* fhandler.h (fhandler_virtual::fstat): Remove useless declaration.
	* fhandler_virtual.cc: Remove _COMPILING_NEWLIB define.
	* ipc.cc (ftok): Use stat64.
	* syscalls.cc (_fstat64): Remove alias.
	(_fstat): Ditto.
	(_stat): Ditto.
	(_fstat64_r): New function.
	(_fstat_r): Ditto.
	(_stat64_r): Ditto.
	(stat_r): Ditto.
	* crt0.o: New file, moved from newlib.
	* include/sys/param.h: Ditto.
	* include/sys/utime.h: Ditto.
	* include/sys/utmp.h: Ditto.
	* include/sys/dirent.h: Ditto.  Expose different struct dirent,
	dependening of the environment.
@
text
@d2543 3
a2545 1
  HANDLE mutex = CreateMutex (NULL, FALSE, shared_name ("wtmp_mutex", 0));
d2583 3
a2585 1
      HANDLE mutex = CreateMutex (NULL, FALSE, shared_name ("wtmp_mutex", 0));
d2754 3
a2756 1
  HANDLE mutex = CreateMutex (NULL, FALSE, shared_name ("utmp_mutex", 0));
@


1.267
log
@* dir.cc (readdir): Fill out new old_d_ino field.
* fhandler.h (fhandler_base::namehash): Define as ino_t.
(fhandler_base::get_namehash): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Accommodate new 64
bit st_ino.
* fhandler_socket.cc (fhandler_socket::fstat): Ditto.
* path.cc (hash_path_name): Return ino_t.
* syscalls.cc (stat64_to_stat32): Convert 64 bit inode to 32 bit.
* winsup.h (hash_path_name): Declare as returning ino_t.
* include/cygwin/stat.h (__stat32): Use 32 bit st_ino.
(__stat64): Use 64 bit st_ino.
* include/cygwin/types.h (__ino64_t): Define.
(__ino32_t): Ditto.
(ino_t): Define appropriately.
@
text
@d1036 10
a1045 2
extern "C" int _fstat64 (int fd, _off64_t pos, int dir)
  __attribute__ ((alias ("fstat64")));
d1057 10
a1066 2
extern "C" int _fstat (int fd, _off64_t pos, int dir)
  __attribute__ ((alias ("fstat")));
a1151 3
extern "C" int _stat (int fd, _off64_t pos, int dir)
  __attribute__ ((alias ("stat")));

d1161 11
d1178 11
@


1.266
log
@	* syscalls.cc (chown_worker): Allow chown'ing of socket files.
@
text
@d993 1
a993 1
  dst->st_ino = src->st_ino;
@


1.265
log
@* syscalls.cc (setsid): Don't call FreeConsole if ctty is already < 0.
@
text
@d802 1
a802 1
      if (win32_path.is_device ())
@


1.264
log
@* termios.cc (setspeed): New function.
(cfsetospeed): Use setspeed to set speed.
(cfsetispeed): Use setspeed to set speed.
* autoload.cc: Add load statement for UuidCreate, and UuidCreateSequential.
* cpuid.h: New file.
* cygwin.din: Export gethostid.
* fhandler_proc.cc (cpuid): Move to cpuid.h.
(can_set_flag): Move to cpuid.h.
* syscalls.cc (gethostid): New function.
* version.h: Bump DLL minor version number to 83.
@
text
@d286 1
a286 2
      myself->ctty = -1;
      if (fhandler_console::open_fhs <= 0)
d292 1
@


1.263
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@d39 1
d59 2
d2730 106
@


1.262
log
@	* syscalls.cc (login): Fix comment.
	(logout): Ditto.
@
text
@d536 2
a537 2
extern "C" __off64_t
lseek64 (int fd, __off64_t pos, int dir)
d539 1
a539 1
  __off64_t res;
d560 1
a560 1
extern "C" int _lseek64 (int fd, __off64_t pos, int dir)
d563 2
a564 2
extern "C" __off32_t
lseek (int fd, __off32_t pos, int dir)
d566 1
a566 1
  return lseek64 (fd, (__off64_t) pos, dir);
d569 1
a569 1
extern "C" __off32_t _lseek (int, __off32_t, int)
d1033 1
a1033 1
extern "C" int _fstat64 (int fd, __off64_t pos, int dir)
d1046 1
a1046 1
extern "C" int _fstat (int fd, __off64_t pos, int dir)
d1133 1
a1133 1
extern "C" int _stat (int fd, __off64_t pos, int dir)
d1739 1
a1739 1
ftruncate64 (int fd, __off64_t length)
d1756 1
a1756 1
	      __off64_t prev_loc = cfd->lseek (0, SEEK_CUR);
d1776 1
a1776 1
ftruncate (int fd, __off32_t length)
d1778 1
a1778 1
  return ftruncate64 (fd, (__off64_t)length);
d1783 1
a1783 1
truncate64 (const char *pathname, __off64_t length)
d1805 1
a1805 1
truncate (const char *pathname, __off32_t length)
d1807 1
a1807 1
  return truncate64 (pathname, (__off64_t)length);
@


1.261
log
@	* syscalls.cc: Slightly cleanup all utmp functions.
	(login): Use mutex to secure against concurrent access to wtmp file.
	(logout): Rewrite using POSIX calls.
	(utmp_fd): Initialized to -1 now.  Any value < 0 is treated as closed
	in subsequent functions.
	(utmp_readonly): New variable, indicating utmp file open for reading
	only.
	(internal_setutent): New function implementing setutent().
	(setutent): Call internal_setutent now.
	(endutent): Reset utmp_readonly.
	(getutent): Return immediately if utmp file can't be opened.
	(getutid): Ditto.
	(getutline): Ditto.
	(pututline): Ditto. Use mutex to secure against concurrent access to
	utmp file.
@
text
@d2504 1
a2504 2
  /* Read/write to utmp must be atomic to prevent overriding data
     by concurrent processes. */
d2542 1
a2542 2
      /* Read/write to utmp must be atomic to prevent overriding data
	 by concurrent processes. */
@


1.260
log
@* syscalls.cc (unlink): Be more defensive when SetFileAttributes is called.
Fix typo in debugging output.
@
text
@d2504 6
d2512 7
a2518 2
      (void) write (fd, (char *) ut, sizeof (struct utmp));
      (void) close (fd);
a2521 4
/* It isn't possible to use unix-style I/O function in logout code because
cygwin's I/O subsystem may be inaccessible at logout () call time.
FIXME (cgf): huh?
*/
d2526 1
a2526 20
  int res = 0;
  HANDLE ut_fd;
  static const char path_utmp[] = _PATH_UTMP;

  path_conv win32_path (path_utmp);
  if (win32_path.error)
    return 0;

  ut_fd = CreateFile (win32_path.get_win32 (),
		      GENERIC_READ | GENERIC_WRITE,
		      FILE_SHARE_READ | FILE_SHARE_WRITE,
		      &sec_none_nih, OPEN_EXISTING,
		      FILE_ATTRIBUTE_NORMAL, NULL);
  if (ut_fd != INVALID_HANDLE_VALUE)
    {
      struct utmp *ut;
      struct utmp ut_buf[100];
      /* FIXME: utmp file access is not 64 bit clean for now. */
      __off32_t pos = 0;		/* Position in file */
      DWORD rd;
d2528 27
a2554 2
      while (!res && ReadFile (ut_fd, ut_buf, sizeof ut_buf, &rd, NULL)
	     && rd != 0)
d2556 2
a2557 22
	  struct utmp *ut_end = (struct utmp *) ((char *) ut_buf + rd);

	  for (ut = ut_buf; ut < ut_end; ut++, pos += sizeof (*ut))
	    if (ut->ut_name[0]
		&& strncmp (ut->ut_line, line, sizeof (ut->ut_line)) == 0)
	      /* Found the entry for LINE; mark it as logged out.  */
	      {
		/* Zero out entries describing who's logged in.  */
		memset (ut->ut_name, 0, sizeof (ut->ut_name));
		memset (ut->ut_host, 0, sizeof (ut->ut_host));
		time (&ut->ut_time);

		/* Now seek back to the position in utmp at which UT occured,
		   and write the new version of UT there.  */
		if ((SetFilePointer (ut_fd, pos, 0, FILE_BEGIN) != 0xFFFFFFFF)
		    && (WriteFile (ut_fd, (char *) ut, sizeof (*ut),
				   &rd, NULL)))
		  {
		    res = 1;
		    break;
		  }
	      }
d2559 4
a2562 2

      CloseHandle (ut_fd);
d2564 1
a2564 2

  return res;
d2567 2
a2568 1
static int utmp_fd = -2;
d2573 2
a2574 2
extern "C" void
setutent ()
d2577 15
a2591 2
  if (utmp_fd == -2)
    utmp_fd = open (utmp_file, O_RDWR);
d2597 6
d2606 1
a2606 1
  if (utmp_fd != -2)
d2609 2
a2610 1
      utmp_fd = -2;
d2632 7
a2638 3
  if (utmp_fd == -2)
    setutent ();
  if (read (utmp_fd, &utmp_data, sizeof (utmp_data)) != sizeof (utmp_data))
d2649 7
a2655 1
  while (read (utmp_fd, &utmp_data, sizeof (utmp_data)) == sizeof (utmp_data))
d2686 7
a2692 1
  while (read (utmp_fd, &utmp_data, sizeof (utmp_data)) == sizeof (utmp_data))
d2697 1
a2697 1
		    sizeof (utmp_data.ut_line)))
d2709 9
a2717 1
  setutent ();
d2720 1
a2720 1
    lseek (utmp_fd, -sizeof(struct utmp), SEEK_CUR);
d2723 6
a2728 1
  (void) write (utmp_fd, (char *) ut, sizeof (struct utmp));
@


1.259
log
@* sigproc.h (signal_fixup_after_exec): Eliminate argument in declaration.
* exceptions.cc (signal_fixup_after_exec): Eliminate argument in definition.
Don't reset signal handlers after spawm.  Just treat like fork/exec.
* dcrt0.cc (dll_crt0_1): Don't pass PROC_SPAWN argument to
signal_fixup_after_exec.
* syscalls.cc (unlink): Don't change attributes of file if not readonly/system.
Ditto for resetting of arguments.
@
text
@d155 4
a158 2
      SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
      setattrs = true;
d188 1
a188 1
      syscall_printf ("DeleteFile after CreateFile/ClosHandle succeeded");
@


1.258
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Fix
	wrong usage of S_IFDIR.
	* security.cc (get_attribute_from_acl): Ditto.
	(get_file_attribute): Fix wrong usage of S_IFLNK.
	(get_object_attribute): Ditto.
	(alloc_sd): Fix wrong usage of S_IFDIR.
	* syscalls.cc (chmod): Allow chmod'ing of socket files.
@
text
@d149 9
a157 2
  /* Allow us to delete even if read-only */
  SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
d165 2
a166 1
      (void) SetFileAttributes (win32_name, (DWORD) win32_name);
d169 2
a170 3
      if (!win32_name.isremote ()
	  || (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	      || wincap.has_delete_on_close ()))
d178 2
a179 1
	  SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
@


1.257
log
@* cygwin.din: Export btowc, trunc.
* include/cygwin/version.h: Reflect new exports.
* syscalls.cc (_stat): Rename to stat to avoid newlib wrapper.
* syscalls.cc (_fstat): Ditto.
* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
* syscalls.cc (rename): Revert assumption that DELETE_ON_CLOSE works on Win9x.
@
text
@d907 1
a907 1
  if (win32_path.is_device ())
@


1.256
log
@* include/cygwin/version.h: Bump DLL minor number to 23.
@
text
@d11 2
d34 2
d39 4
a52 1
#include <unistd.h>
a55 1
#include <setjmp.h>
d162 2
a163 1
	  || GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES)
d1027 1
a1027 1
_fstat (int fd, struct __stat32 *buf)
d1036 3
d1123 3
d1135 1
a1135 1
_stat (const char *name, struct __stat32 *buf)
@


1.255
log
@* syscalls.cc (rename): Assume that DELETE_ON_CLOSE works on Win9x.
* fhandler_tty.cc (fhandler_tty_slave::close): Fix typo in debug output.
@
text
@d268 5
a272 1
	FreeConsole ();
@


1.254
log
@	Switch to 32/64 datatypes:
	* Makefile.in (OBSOLETE_FUNCTIONS): Add open acl aclcheck aclfrommode
	aclfrompbits aclfromtext aclsort acltomode acltopbits acltotext chown
	facl fchown fgetpos fopen freopen fseeko fsetpos fstat ftello
	ftruncate getegid geteuid getgid getgrent getgrgid getgrnam getgroups
	getpwuid getpwuid_r getuid initgroups lchown lseek lstat mknod mmap
	seekdir setegid seteuid setgid setgroups setregid setreuid setuid stat
	telldir truncate.
	(NEW_FUNCTIONS): Add _open64 acl32 aclcheck32 aclfrommode32
	aclfrompbits32 aclfromtext32 aclsort32 acltomode32 acltopbits32
	acltotext32 chown32 facl32 fchown32 fgetpos64 fopen64 freopen64
	fseeko64 fsetpos64 fstat64 ftello64 ftruncate64 getegid32 geteuid32
	getgid32 getgrent32 getgrgid32 getgrnam32 getgroups32 getpwuid32
	getpwuid_r32 getuid32 initgroups32 lchown32 lseek64 lstat64 mknod32
	mmap64 seekdir64 setegid32 seteuid32 setgid32 setgroups32 setregid32
	setreuid32 setuid32 stat64 telldir64 truncate64 to substitute the
	above.
	* cygserver_shm.h (class client_request_shm): Change uid_t and gid_t
	members to __uid32_t and __gid32_t.
	* cygwin.din: Add symbols acl32 aclcheck32 aclfrommode32
	aclfrompbits32 aclfromtext32 aclsort32 acltomode32 acltopbits32
	acltotext32 facl32 fgetpos64 fopen64 freopen64 fseeko64 fsetpos64
	_fstat64 ftello64 _lseek64 mknod32 _open64.
	* glob.c: Include perprocess.h.
	(globtilde): Call getpwuid32 and getuid32 instead of getpwuid and
	getuid.
	(g_lstat): Check for applications API version to call the appropriate
	typed gl_lstat function.
	(g_stat): Ditto for gl_stat.
	* shm.cc (client_request_shm::client_request_shm): Call geteuid32
	and getegid32 instead of geteuid and getegid throughout.
	* syscalls.cc (_open64): New alias for open.
	(_lseek64): New alias for lseek64.
	(_fstat64): New alias for fseek64.
	(mknod32): New function.
	(mknod): Calls mknod32 now.
	* winsup.h: Make function declarations for getuid32, geteuid32,
	and getpwuid32 accessible for plain C sources.  Add declarations
	for getegid32 and getpwnam.
	* include/cygwin/version.h: Bum API minor number to 78.
	* include/sys/cygwin.h: Guard C++ specific members of struct
	per_process against inclusion in plain C sources.
	* include/sys/mman.h (mman): Add guard to avoid type clash when
	compiling Cygwin.
@
text
@d155 2
a156 2
      if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	  || (!win32_name.isremote () && wincap.has_delete_on_close ()))
@


1.253
log
@whitespace cleanup
@
text
@d16 3
d58 3
d512 3
d539 3
d1012 3
d1946 1
a1946 1
mknod (const char *_path, mode_t mode, dev_t dev)
d1950 6
@


1.253.2.1
log
@* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
@
text
@d262 1
a262 5
	{
	  syscall_printf ("open_fhs %d, freeing console",
			  fhandler_console::open_fhs);
	  FreeConsole ();
	}
@


1.253.2.2
log
@* cygwin.din: Export btowc, trunc.
* include/cygwin/version.h: Reflect new exports.
* syscalls.cc (_stat): Rename to stat to avoid newlib wrapper.
* syscalls.cc (_fstat): Ditto.
@
text
@a10 2
#define fstat __FOOfstat__
#define stat __FOOstat__
a15 3
#define _open64 __FOO_open64__
#define _lseek64 __FOO_lseek64__
#define _fstat64 __FOO_fstat64__
a28 2
#include <unistd.h>
#include <setjmp.h>
a36 4

#undef fstat
#undef stat

d42 1
d46 1
a54 3
#undef _open64
#undef _lseek64
#undef _fstat64
d1005 1
a1005 1
fstat (int fd, struct __stat32 *buf)
a1013 3
extern "C" int _fstat (int fd, __off64_t pos, int dir)
  __attribute__ ((alias ("fstat")));

a1097 3
extern "C" int _stat (int fd, __off64_t pos, int dir)
  __attribute__ ((alias ("stat")));

d1107 1
a1107 1
stat (const char *name, struct __stat32 *buf)
@


1.252
log
@* syscalls.cc (unlink): Attempt to be more clever about setting attributes of
file.  Only open file in query mode to avoid having to mess with security stuff
for reading.
@
text
@a161 1

@


1.251
log
@* syscalls.cc (unlink): Always attempt to use FILE_FLAG_CLOSE_ON_DELETE to
delete files since this allows us to preserve the protection of hard linked
files.
(link): Generate full path for potentially recalculated .lnk target.
@
text
@d133 1
d137 1
d142 1
a142 1
  h = CreateFile (win32_name, GENERIC_READ, FILE_SHARE_DELETE, &sec_none_nih,
a143 5

  (void) SetFileAttributes (win32_name, (DWORD) win32_name);
  (void) DeleteFile (win32_name);
  DWORD lasterr;
  lasterr = GetLastError ();
a144 4
    CloseHandle (h);

  if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
      || (!win32_name.isremote () && wincap.has_delete_on_close ()))
d146 14
a159 2
      syscall_printf ("DeleteFile succeeded");
      goto ok;
d162 2
d169 5
@


1.250
log
@* path.h (PATH_LNK): New enum val.
(path_conv::is_lnk_symlink): New function.  True if path represents .lnk style
symlink.
* path.cc (check_shortcut): Set PATH_LNK in pflags when appropriate.
(symlink_info::check): Ditto.  Remove PATH_LNK from pflags initially.
* syscalls.cc (unlink): Always remove readonly attribute from a symlink
regardless of type.
(link): (from Corinna Vinschen) Allow links to symlinks.  Reset attributes on a
symlink after successful link creation.
(chmod): Use is_lnk_symlink where appropriate.
(rename): Ditto.
* tty.cc (create_tty_master): Call GetComputerName instead of
cygwin_gethostname.  Set ut_id.
* syscalls.cc (login): Call endutent.
(setutent): Do not seek after a fresh open.
@
text
@d136 6
a141 3
  /* Check for shortcut as symlink condition. */
  if (win32_name.issymlink ())
    SetFileAttributes (win32_name, (DWORD) win32_name & ~FILE_ATTRIBUTE_READONLY);
d143 2
d146 6
a151 2
  lasterr = 0;
  for (int i = 0; i < 2; i++)
d153 3
a155 5
      if (DeleteFile (win32_name))
	{
	  syscall_printf ("DeleteFile succeeded");
	  goto ok;
	}
d157 4
a160 7
      lasterr = GetLastError ();
      if (i || lasterr != ERROR_ACCESS_DENIED)
	break;		/* Couldn't delete it. */

      /* if access denied, chmod to be writable, in case it is not,
	 and try again */
      (void) chmod (win32_name, 0777);
a169 39
  /* Tried to delete file by normal DeleteFile and by resetting protection
     and then deleting.  That didn't work.

     There are two possible reasons for this:  1) The file may be opened and
     Windows is not allowing it to be deleted, or 2) We may not have permissions
     to delete the file.

     So, first assume that it may be 1) and try to remove the file using the
     Windows FILE_FLAG_DELETE_ON_CLOSE semantics.  This seems to work only
     spottily on Windows 9x/Me but it does seem to work reliably on NT as
     long as the file doesn't exist on a remote drive. */

  bool delete_on_close_ok;

  delete_on_close_ok  = !win32_name.isremote ()
			&& wincap.has_delete_on_close ();

  /* Attempt to use "delete on close" semantics to handle removing
     a file which may be open. */
  HANDLE h;
  h = CreateFile (win32_name, GENERIC_READ, FILE_SHARE_READ, &sec_none_nih,
		  OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
  if (h == INVALID_HANDLE_VALUE)
    {
      if (GetLastError () == ERROR_FILE_NOT_FOUND)
	goto ok;
    }
  else
    {
      CloseHandle (h);
      syscall_printf ("CreateFile/CloseHandle succeeded");
      /* Everything is fine if the file has disappeared or if we know that the
	 FILE_FLAG_DELETE_ON_CLOSE will eventually work. */
      if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	  || delete_on_close_ok)
	goto ok;	/* The file is either gone already or will eventually be
			   deleted by the OS. */
    }

d617 1
a617 1
      real_b.check (b, PC_SYM_NOFOLLOW);
@


1.249
log
@	* syscalls.cc (seteuid32): Fix formatting.
@
text
@d137 2
a138 6
  if (win32_name.has_attribute (FILE_ATTRIBUTE_READONLY))
    {
      int len = strlen (win32_name);
      if (len > 4 && strcasematch ((char *) win32_name + len - 4, ".lnk"))
	SetFileAttributes (win32_name, (DWORD) win32_name & ~FILE_ATTRIBUTE_READONLY);
    }
d151 1
a151 1
      if (i || lasterr != ERROR_ACCESS_DENIED || win32_name.issymlink ())
d615 1
a615 1
  path_conv real_a (a, PC_SYM_FOLLOW | PC_FULL);
d617 1
d645 9
d658 1
a658 4
	{
	  res = 0;
	  goto done;
	}
d740 1
d742 5
d935 1
a935 1
      if (S_ISLNK (mode) || S_ISSOCK (mode))
d1269 1
a1269 1
  if (real_old.issymlink () && !real_new.error && !real_new.case_clash)
d1271 4
a1274 8
      int len_old = strlen (real_old.get_win32 ());
      if (strcasematch (real_old.get_win32 () + len_old - 4, ".lnk"))
	{
	  strcpy (new_lnk_buf, newpath);
	  strcat (new_lnk_buf, ".lnk");
	  newpath = new_lnk_buf;
	  real_new.check (newpath, PC_SYM_NOFOLLOW);
	}
d1304 2
a1305 3
  if (!real_old.issymlink () && !real_new.error && real_new.issymlink () &&
      real_new.known_suffix && strcasematch (real_new.known_suffix, ".lnk") &&
      (lnk_suffix = strrchr (real_new.get_win32 (), '.')))
d1392 1
a1392 1
}  
d2479 1
d2527 2
a2528 2
		bzero (ut->ut_name, sizeof (ut->ut_name));
		bzero (ut->ut_host, sizeof (ut->ut_host));
d2559 3
a2561 4
    {
      utmp_fd = open (utmp_file, O_RDWR);
    }
  lseek (utmp_fd, 0, SEEK_SET);
@


1.248
log
@* dll_init.cc (dll_list::load_after_fork): Don't revert to LoadLibrary if
LoadLibraryEx fails.
* dtable.cc (dtable::dec_console_fds): Eliminate.
(dtable::release): Don't treat console specially.
(dtable::build_fhandler): Ditto.
* dtable.h (console_fds): Eliminate.
(dtable::dec_console_fds): Eliminate.
(dtable::inc_console_fds): Eliminate.
* fhandler.h (fhandler_console::open_fhs): New static element.
* fhandler_console.cc (fhandler_console::open): Increment open_fs.
(fhandler_console::close): Call FreeConsole if no more open consoles and ctty
is not associated with the console.
* syscalls.cc (setsid): Simplify check for when to call FreeConsole.
(check_pty_fds): Eliminate definition.
* winsup.h (check_pty_fds): Eliminate declaration.
@
text
@d2043 2
a2044 1
  if (usersid != (origpsid =  cygheap->user.orig_sid ())) psid2 = usersid;
d2114 1
a2114 1
 failed:
d2118 1
a2118 1
       && !ImpersonateLoggedOnUser (cygheap->user.token))
@


1.247
log
@
2003-02-28  Pierre Humblet  <pierre.humblet@@ieee.org>

	* syscalls.cc (fstat64): Pass get_name () to pc.
	(access): Pass fn to stat_worker.
@
text
@a79 17
BOOL __stdcall
check_pty_fds (void)
{
  int res = FALSE;
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK, "check_pty_fds");
  fhandler_base *fh;
  for (int i = 0; i < (int) cygheap->fdtab.size; i++)
    if ((fh = cygheap->fdtab[i]) != NULL &&
	(fh->get_device () == FH_TTYS || fh->get_device () == FH_PTYM))
      {
	res = TRUE;
	break;
      }
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK, "check_pty_fds");
  return res;
}

d288 2
a289 3
      if (myself->ctty == TTY_CONSOLE
	  && !cygheap->fdtab.has_console_fds ()
	  && !check_pty_fds ())
a290 1
      myself->ctty = -1;
@


1.246
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@d1016 1
a1016 1
      path_conv pc (cfd->get_win32_name (), PC_SYM_NOFOLLOW);
d1203 1
a1203 1
  int r = stat_worker (real_path, &st, 0);
@


1.245
log
@* include/cygwin/in.h (in_attr_t): Define new type.
* include/arpa/inet.h (inet_addr): Change return type to in_addr_t.
(inet_lnaof): Ditto.
(inet_netof): Ditto.
(inet_network): Ditto.
* include/cygwin/types.h: Move many *_t typedefs here.  Protect them with
ifdefs.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Change ntsec_atts to
mode_t.
* security.cc (get_attribute_from_acl): Accept mode_t attribute.
(get_nt_attribute): Ditto.
(get_file_attribute): Ditto.
(get_nt_object_attribute): Ditto.
(get_object_attribute): Ditto.
* security.h: Reflect above changes.
* syscalls.cc (chown_worker): Change attrib to mode_t.
@
text
@d1019 1
a1019 1
      if (!res)
d1109 1
a1109 1
      if (!res)
a1165 2
extern int acl_access (const char *, int);

d1177 24
a1200 2
  if (allow_ntsec)
    return acl_access (fn, flags);
d1203 1
a1203 1
  int r = stat_worker (fn, &st, 0);
@


1.244
log
@* syscalls.cc (struct system_cleanup_args): New struct.
(system_cleanup): New function.
(system): Use pthread_cleanup_push and _pop to save and restore
signal handlers and sigprocmask.
@
text
@d806 1
a806 1
      DWORD attrib = 0;
d811 1
a811 1
				(int *) &attrib);
@


1.243
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d1374 15
d1400 2
a1401 2
  _sig_func_ptr oldint, oldquit;
  sigset_t child_block, old_mask;
d1406 2
a1407 2
  oldint = signal (SIGINT, SIG_IGN);
  oldquit = signal (SIGQUIT, SIG_IGN);
d1410 1
a1410 1
  (void) sigprocmask (SIG_BLOCK, &child_block, &old_mask);
d1417 2
d1426 2
a1427 3
  signal (SIGINT, oldint);
  signal (SIGQUIT, oldquit);
  (void) sigprocmask (SIG_SETMASK, &old_mask, 0);
@


1.242
log
@	* syscalls.cc (seteuid32): On Win95 get the pw entry. If it exists
	update the euid and call cygheap->user.set_name. Remove special
	handling of ILLEGAL_UID.
	(setgid32): Add a debug_printf. On Win95, always set the egid.
	Remove special handling of ILLEGAL_GID. Do not compare gid and gr_gid.
	* child_info.h (class cygheap_exec_info): Remove uid.
	* spawn.cc (spawn_guts): Do not set ciresrv.moreinfo->uid.
	* dcrto.cc (dll_crt0_1): Always call uinfo_init.
	* uinfo.cc (uinfo_init): Reorganize and close handle if needed.
	(cygheap_user::ontherange): Do not call internal_getpwnam if pw is NULL.
@
text
@d813 1
a813 1
         res = set_file_attribute (win32_path.has_acls (), win32_path, uid,
@


1.241
log
@	* cygwin.din: Export setreuid32, setreuid, setregid32, setregid.
	* syscalls.cc (setreuid32): New function.
	(setreuid): Ditto.
	(setregid32): Ditto.
	(setregid): Ditto.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1951 1
d1953 1
a1953 4
  debug_printf ("uid: %d myself->gid: %d", uid, myself->gid);

  if (!wincap.has_security ()
      || (uid == myself->uid && !cygheap->user.groups.ischanged))
a1958 6
  if (uid == ILLEGAL_UID)
    {
      set_errno (EINVAL);
      return -1;
    }

d1969 2
a2088 1
  cygheap->user.set_name (pw_new->pw_name);
d2091 1
d2157 1
a2157 2
  if (!wincap.has_security () || gid == myself->gid)
    return 0;
d2159 1
a2159 1
  if (gid == ILLEGAL_GID)
d2161 2
a2162 2
      set_errno (EINVAL);
      return -1;
d2169 1
d2171 1
a2171 2
  struct __group32 * gr = internal_getgrgid (gid);
  if (!gr || gr->gr_gid != gid || !gsid.getfromgr (gr))
@


1.240
log
@	* autoload.cc: Fix copyright date.
	* fhandler_dsp.cc: Ditto.
	* mmap.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* signal.cc: Ditto.
	* syscalls.cc: Ditto.
	* uname.cc: Ditto.
	* wait.cc: Ditto.
@
text
@d2134 25
d2235 25
@


1.240.2.1
log
@merge from trunk
@
text
@a57 3
static int __stdcall mknod_worker (const char *, mode_t, mode_t, _major_t,
				   _minor_t);

a535 5
	  else if (fh->is_fs_special () && fh->device_access_denied (flags))
	    {
	      fd.release ();
	      res = -1;
	    }
d800 1
a800 1
      if (win32_path.is_auto_device ())
a900 6
int
chmod_device (path_conv& pc, mode_t mode)
{
  return mknod_worker (pc, pc.dev.mode & S_IFMT, mode, pc.dev.major, pc.dev.minor);
}

d918 1
a918 1
  if (win32_path.is_auto_device ())
a922 5
  if (win32_path.is_fs_special ())
    {
      res = chmod_device (win32_path, mode);
      goto done;
    }
d1024 1
a1024 1
	    buf->st_dev = cfd->get_device ();
d1114 1
a1114 1
	    buf->st_dev = fh->get_device ();
d1510 1
a1510 1
      if (cfd->get_device () == FH_FS)
d1552 1
a1552 1
	if (full_path.is_auto_device ())
d1570 3
a1572 1
    return 0;
d1607 1
a1607 1
  if (cfd->get_device () != FH_FS)
a1926 10
static int __stdcall
mknod_worker (const char *path, mode_t type, mode_t mode, _major_t major,
	      _minor_t minor)
{
  char buf[sizeof (":00000000:00000000:00000000") + MAX_PATH];
  sprintf (buf, ":%x:%x:%x", major, minor,
	   type | (mode & (S_IRWXU | S_IRWXG | S_IRWXO)));
  return symlink_worker (buf, path, true, true);
}

d1934 1
a1934 1
mknod (const char *path, mode_t mode, dev_t dev)
d1936 2
a1937 43
  if (check_null_empty_str_errno (path))
    return -1;

  if (strlen (path) >= MAX_PATH)
    return -1;

  path_conv w32path (path, PC_SYM_NOFOLLOW | PC_FULL);
  if (w32path.exists ())
    {
      set_errno (EEXIST);
      return -1;
    }

  mode_t type = mode & S_IFMT;
  _major_t major = dev >> 8 /* SIGH.  _major (dev) */;
  _minor_t minor = dev & 0xff /* SIGH _minor (dev) */;
  switch (type)
    {
    case S_IFCHR:
    case S_IFBLK:
      break;

    case S_IFIFO:
      major = _major (FH_FIFO);
      minor = _minor (FH_FIFO) & 0xff; /* SIGH again */
      break;

    case 0:
    case S_IFREG:
      {
	int fd = open (path, O_CREAT, mode);
	if (fd < 0)
	  return -1;
	close (fd);
	return 0;
      }

    default:
      set_errno (EINVAL);
      return -1;
    }

  return mknod_worker (w32path, type, mode, major, minor);
d1943 1
d1951 1
@


1.240.2.2
log
@merge from trunk
@
text
@a2199 25
extern "C" int
setreuid32 (__uid32_t ruid, __uid32_t euid)
{
  int ret = 0;
  bool tried = false;
  __uid32_t old_euid = myself->uid;

  if (ruid != ILLEGAL_UID && cygheap->user.real_uid != ruid && euid != ruid)
    tried = !(ret = seteuid32 (ruid));
  if (!ret && euid != ILLEGAL_UID)
    ret = seteuid32 (euid);
  if (tried && (ret || euid == ILLEGAL_UID) && seteuid32 (old_euid))
    system_printf ("Cannot restore original euid %u", old_euid);
  if (!ret && ruid != ILLEGAL_UID)
    cygheap->user.real_uid = ruid;
  debug_printf ("real: %u, effective: %u", cygheap->user.real_uid, myself->uid);
  return ret;
}

extern "C" int
setreuid (__uid16_t ruid, __uid16_t euid)
{
  return setreuid32 (uid16touid32 (ruid), uid16touid32 (euid));
}

a2275 25
}

extern "C" int
setregid32 (__gid32_t rgid, __gid32_t egid)
{
  int ret = 0;
  bool tried = false;
  __gid32_t old_egid = myself->gid;

  if (rgid != ILLEGAL_GID && cygheap->user.real_gid != rgid && egid != rgid)
    tried = !(ret = setegid32 (rgid));
  if (!ret && egid != ILLEGAL_GID)
    ret = setegid32 (egid);
  if (tried && (ret || egid == ILLEGAL_GID) && setegid32 (old_egid))
    system_printf ("Cannot restore original egid %u", old_egid);
  if (!ret && rgid != ILLEGAL_GID)
    cygheap->user.real_gid = rgid;
  debug_printf ("real: %u, effective: %u", cygheap->user.real_gid, myself->gid);
  return ret;
}

extern "C" int
setregid (__gid16_t rgid, __gid16_t egid)
{
  return setregid32 (gid16togid32 (rgid), gid16togid32 (egid));
@


1.240.2.3
log
@merge from trunk
@
text
@d2018 1
a2018 1
  debug_printf ("uid: %u myself->gid: %u", uid, myself->gid);
d2020 2
a2021 1
  if (uid == myself->uid && !cygheap->user.groups.ischanged)
d2027 6
a2042 2
  if (!wincap.has_security () && pw_new)
    goto success;
d2161 1
a2163 1
  cygheap->user.set_name (pw_new->pw_name);
d2229 2
a2230 1
  debug_printf ("new egid: %u current: %u", gid, myself->gid);
d2232 1
a2232 1
  if (gid == myself->gid || !wincap.has_security ())
d2234 2
a2235 2
      myself->gid = gid;
      return 0;
d2242 1
d2244 1
a2244 2

  if (!gsid.getfromgr (gr))
@


1.240.2.4
log
@merge from trunk
@
text
@d821 1
a821 1
	 res = set_file_attribute (win32_path.has_acls (), win32_path, uid,
@


1.240.2.5
log
@merge from trunk
@
text
@a1392 15
struct system_cleanup_args
{
  _sig_func_ptr oldint, oldquit;
  sigset_t old_mask;
};

static void system_cleanup (void *args)
{
  struct system_cleanup_args *cleanup_args = (struct system_cleanup_args *) args;

  signal (SIGINT, cleanup_args->oldint);
  signal (SIGQUIT, cleanup_args->oldquit);
  (void) sigprocmask (SIG_SETMASK, &cleanup_args->old_mask, 0);
}  

d1404 2
a1405 2
  struct system_cleanup_args cleanup_args;
  sigset_t child_block;
d1410 2
a1411 2
  cleanup_args.oldint = signal (SIGINT, SIG_IGN);
  cleanup_args.oldquit = signal (SIGQUIT, SIG_IGN);
d1414 1
a1414 1
  (void) sigprocmask (SIG_BLOCK, &child_block, &cleanup_args.old_mask);
a1420 2
  pthread_cleanup_push (system_cleanup, (void *) &cleanup_args);

d1428 3
a1430 2
  pthread_cleanup_pop (1);

@


1.240.2.6
log
@merge from trunk
@
text
@d814 1
a814 1
      mode_t attrib = 0;
d819 1
a819 1
				&attrib);
@


1.240.2.7
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d37 1
a38 1
#include "fhandler.h"
a60 3
static int __stdcall stat_worker (const char *name, struct __stat64 *buf,
				  int nofollow) __attribute__ ((regparm (3)));

d535 3
a537 1
	  if (!(fh = build_fh_name (unix_path)))
d541 1
a541 1
	      delete fh;
d544 1
a544 1
	  else if (!fh->open (flags, (mode & 07777) & ~cygheap->umask))
d546 1
a546 1
	      delete fh;
d549 2
a550 6
	  else
	    {
	      cygheap->fdtab[fd] = fh;
	      if ((res = fd) <= 2)
		set_std_handle (res);
	    }
d1035 1
d1037 1
a1037 1
      res = cfd->fstat (buf);
d1098 3
a1100 2
static int __stdcall
stat_worker (const char *name, struct __stat64 *buf, int nofollow)
d1103 1
d1109 7
a1115 2
  fh = build_fh_name (name, NULL, (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)
		      		  | PC_FULL, stat_suffixes);
d1117 1
a1117 1
  if (fh->error ())
d1119 2
a1120 2
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
d1125 1
a1125 1
		    fh, (DWORD) *fh);
d1127 1
a1127 1
      res = fh->fstat (buf);
@


1.240.2.8
log
@merge from trunk
@
text
@d1182 2
d1195 2
a1196 24
  path_conv real_path (fn, PC_SYM_FOLLOW | PC_FULL, stat_suffixes);
  if (real_path.error)
    {
      set_errno (real_path.error);
      return -1;
    }

  if (!real_path.exists ())
    {
      set_errno (ENOENT);
      return -1;
    }

  if (!(flags & (R_OK | W_OK | X_OK)))
    return 0;

  if (real_path.has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK))
    {
      set_errno (EACCES);
      return -1;
    }

  if (real_path.has_acls () && allow_ntsec)
    return check_file_access (real_path, flags);
d1199 1
a1199 1
  int r = stat_worker (real_path, &st, 0);
d1827 1
a1827 1
  const char *root = full_path.root_dir ();
@


1.240.2.9
log
@* cygwin-gperf: Fix typo in FH_FS static storage.
* devices.gperf (device::parse): Default to fs "device" when nothing else is
found.
* fhandler.cc (fhandler_base::device_access_denied): Use access_worker rather
than access to avoid reparsing pc.
* fhandler_nodevice.cc (fhandler_nodevice::open): Set errno to ENXIO rather
than ENODEV.
* path.cc (path_conv::check): Default to FH_FS rather than FH_BAD.
(mount_info::conv_to_win32_path): Ditto.
(win32_device_name): Don't do device handling if FH_FS.
* path.h (path_conv::get_devn): Just return raw device number.
* syscalls.cc (access_worker): New function, split from access().  Correctly
deal with special devices in light of recent ntsec changes.
(access): Use access_worker.
@
text
@d1182 2
a1183 2
int
access_worker (path_conv& real_path, int flags)
d1185 9
d1209 1
a1209 3
  if (real_path.is_fs_special ())
    /* short circuit */;
  else if (real_path.has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK))
d1214 2
a1215 1
  else if (real_path.has_acls () && allow_ntsec)
a1275 15
access (const char *fn, int flags)
{
  sigframe thisframe (mainthread);
  // flags were incorrectly specified
  if (flags & ~(F_OK|R_OK|W_OK|X_OK))
    {
      set_errno (EINVAL);
      return -1;
    }

  path_conv pc (fn, PC_SYM_FOLLOW | PC_FULL, stat_suffixes);
  return access_worker (pc, flags);
}

extern "C" int
d1416 1
a1416 2
static void
system_cleanup (void *args)
d1423 1
a1423 1
}
@


1.240.2.10
log
@merge from trunk
@
text
@d86 17
d311 4
a315 2
      if (fhandler_console::open_fhs <= 0)
	FreeConsole ();
@


1.240.2.11
log
@merge from trunk
@
text
@d1976 6
@


1.240.2.12
log
@merge from trunk
@
text
@d142 7
a148 6
  SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
  /* Attempt to use "delete on close" semantics to handle removing
     a file which may be open. */
  HANDLE h;
  h = CreateFile (win32_name, GENERIC_READ, FILE_SHARE_DELETE, &sec_none_nih,
		  OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
a149 2
  (void) SetFileAttributes (win32_name, (DWORD) win32_name);
  (void) DeleteFile (win32_name);
d151 8
a158 3
  lasterr = GetLastError ();
  if (h != INVALID_HANDLE_VALUE)
    CloseHandle (h);
d160 3
a162 6
  if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
      || (!win32_name.isremote () && wincap.has_delete_on_close ()))
    {
      syscall_printf ("DeleteFile succeeded");
      goto ok;
    }
d164 3
a166 4
  if (DeleteFile (win32_name))
    {
      syscall_printf ("DeleteFile after CreateFile/ClosHandle succeeded");
      goto ok;
d176 39
d632 1
a632 1
  path_conv real_a (a, PC_SYM_NOFOLLOW | PC_FULL);
a633 1
  extern BOOL allow_winsymlinks;
a660 9
  /* Shortcut hack. */
  char new_lnk_buf[MAX_PATH + 5];
  if (allow_winsymlinks && real_a.is_lnk_symlink () && !real_b.case_clash)
    {
      strcpy (new_lnk_buf, b);
      strcat (new_lnk_buf, ".lnk");
      b = new_lnk_buf;
      real_b.check (b, PC_SYM_NOFOLLOW | PC_FULL);
    }
d665 4
a668 1
	goto success;
a749 1
    success:
a750 5
      if (!allow_winsymlinks && real_a.is_lnk_symlink ())
	SetFileAttributes (real_b, (DWORD) real_a
			           | FILE_ATTRIBUTE_SYSTEM
				   | FILE_ATTRIBUTE_READONLY);

d950 1
a950 1
      if (!win32_path.is_lnk_symlink () && S_ISLNK (mode) || S_ISSOCK (mode))
d1283 1
a1283 1
  if (real_old.is_lnk_symlink () && !real_new.error && !real_new.case_clash)
d1285 8
a1292 4
      strcpy (new_lnk_buf, newpath);
      strcat (new_lnk_buf, ".lnk");
      newpath = new_lnk_buf;
      real_new.check (newpath, PC_SYM_NOFOLLOW);
d1322 3
a1324 2
  if (!real_old.issymlink () && !real_new.error && real_new.is_lnk_symlink ()
      && (lnk_suffix = strrchr (real_new.get_win32 (), '.')))
d2109 1
a2109 2
  if (usersid != (origpsid = cygheap->user.orig_sid ()))
    psid2 = usersid;
d2179 1
a2179 1
failed:
d2183 1
a2183 1
      && !ImpersonateLoggedOnUser (cygheap->user.token))
a2539 1
  endutent ();
d2587 2
a2588 2
		memset (ut->ut_name, 0, sizeof (ut->ut_name));
		memset (ut->ut_host, 0, sizeof (ut->ut_host));
d2619 4
a2622 3
    utmp_fd = open (utmp_file, O_RDWR);
  else
    lseek (utmp_fd, 0, SEEK_SET);
@


1.240.2.13
log
@Merge from trunk.
* Makefile.in: Explicitly call perl to run cygwin-gperf.
* path.cc: Move some device stuff.
* cygwin-gperf: Define some device stuff.
* devices.h: Declare some device stuff.
@
text
@a138 1
      set_errno (EPERM);
a141 1
  /* Allow us to delete even if read-only */
d146 1
a146 1
  h = CreateFile (win32_name, 0, FILE_SHARE_READ, &sec_none_nih,
d148 5
d154 4
d159 2
a160 14
      (void) SetFileAttributes (win32_name, (DWORD) win32_name);
      BOOL res = CloseHandle (h);
      syscall_printf ("%d = CloseHandle (%p)", res, h);
      if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	  || (!win32_name.isremote () && wincap.has_delete_on_close ()))
	{
	  syscall_printf ("CreateFile (FILE_FLAG_DELETE_ON_CLOSE) succeeded");
	  goto ok;
	}
      else
	{
	  syscall_printf ("CreateFile (FILE_FLAG_DELETE_ON_CLOSE) failed");
	  SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
	}
a162 2

  /* Try a delete with attributes reset */
a167 5

  DWORD lasterr;
  lasterr = GetLastError ();

  (void) SetFileAttributes (win32_name, (DWORD) win32_name);
@


1.240.2.14
log
@merge from trunk
@
text
@d168 1
@


1.240.2.15
log
@merge from trunk
@
text
@a15 3
#define _open64 __FOO_open64__
#define _lseek64 __FOO_lseek64__
#define _fstat64 __FOO_fstat64__
a54 3
#undef _open64
#undef _lseek64
#undef _fstat64
a518 3
extern "C" int _open64 (const char *, int flags, ...)
  __attribute__ ((alias ("open")));

a542 3
extern "C" int _lseek64 (int fd, __off64_t pos, int dir)
  __attribute__ ((alias ("lseek64")));

a1022 3
extern "C" int _fstat64 (int fd, __off64_t pos, int dir)
  __attribute__ ((alias ("fstat64")));

d1957 1
a1957 1
mknod32 (const char *path, mode_t mode, __dev32_t dev)
d1973 2
a1974 2
  _major_t major = _major (dev);
  _minor_t minor = _minor (dev);
d1983 1
a1983 1
      minor = _minor (FH_FIFO);
a2001 6
}

extern "C" int
mknod (const char *_path, mode_t mode, __dev16_t dev)
{
  return mknod32 (_path, mode, (__dev32_t) dev);
@


1.240.2.16
log
@merge from trunk
@
text
@a10 2
#define fstat __FOOfstat__
#define stat __FOOstat__
a31 2
#include <unistd.h>
#include <setjmp.h>
a34 4

#undef fstat
#undef stat

d45 1
d49 1
d161 2
a162 3
      if (!win32_name.isremote ()
	  || (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	      || wincap.has_delete_on_close ()))
d274 1
a274 5
	{
	  syscall_printf ("open_fhs %d, freeing console",
			  fhandler_console::open_fhs);
	  FreeConsole ();
	}
d1039 1
a1039 1
fstat (int fd, struct __stat32 *buf)
a1047 3
extern "C" int _fstat (int fd, __off64_t pos, int dir)
  __attribute__ ((alias ("fstat")));

a1124 3
extern "C" int _stat (int fd, __off64_t pos, int dir)
  __attribute__ ((alias ("stat")));

d1134 1
a1134 1
stat (const char *name, struct __stat32 *buf)
@


1.240.2.17
log
@merge from trunk
@
text
@d155 2
a156 9
  bool setattrs;
  if (!((DWORD) win32_name & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
    setattrs = false;
  else
    {
      /* Allow us to delete even if read-only */
      SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
      setattrs = true;
    }
d164 1
a164 2
      if (wincap.has_hard_links () && setattrs)
	(void) SetFileAttributes (win32_name, (DWORD) win32_name);
d167 3
a169 2
      if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
	  || !win32_name.isremote ())
d177 1
a177 2
	  if (setattrs)
	    SetFileAttributes (win32_name, (DWORD) win32_name & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
@


1.240.2.18
log
@merge from trunk
@
text
@d161 2
a162 4
      setattrs = SetFileAttributes (win32_name,
				    (DWORD) win32_name
				    & ~(FILE_ATTRIBUTE_READONLY
					| FILE_ATTRIBUTE_SYSTEM));
d192 1
a192 1
      syscall_printf ("DeleteFile after CreateFile/CloseHandle succeeded");
@


1.240.2.19
log
@merge from trunk
@
text
@d474 1
a474 1
  if (res > (int) bg_eof)
d549 2
a550 2
extern "C" _off64_t
lseek64 (int fd, _off64_t pos, int dir)
d552 1
a552 1
  _off64_t res;
d573 1
a573 1
extern "C" int _lseek64 (int fd, _off64_t pos, int dir)
d576 2
a577 2
extern "C" _off_t
lseek (int fd, _off_t pos, int dir)
d579 1
a579 1
  return lseek64 (fd, (_off64_t) pos, dir);
d582 1
a582 1
extern "C" _off_t _lseek (int, _off_t, int)
d1056 1
a1056 1
extern "C" int _fstat64 (int fd, _off64_t pos, int dir)
d1069 1
a1069 1
extern "C" int _fstat (int fd, _off64_t pos, int dir)
d1149 1
a1149 1
extern "C" int _stat (int fd, _off64_t pos, int dir)
d1761 1
a1761 1
ftruncate64 (int fd, _off64_t length)
d1778 1
a1778 1
	      _off64_t prev_loc = cfd->lseek (0, SEEK_CUR);
d1798 1
a1798 1
ftruncate (int fd, _off_t length)
d1800 1
a1800 1
  return ftruncate64 (fd, (_off64_t)length);
d1805 1
a1805 1
truncate64 (const char *pathname, _off64_t length)
d1827 1
a1827 1
truncate (const char *pathname, _off_t length)
d1829 1
a1829 1
  return truncate64 (pathname, (_off64_t)length);
a2569 5
  /* Writing to wtmp must be atomic to prevent mixed up data. */
  HANDLE mutex = CreateMutex (NULL, FALSE, shared_name ("wtmp_mutex", 0));
  if (mutex)
    while (WaitForSingleObject (mutex, INFINITE) == WAIT_ABANDONED)
      ;
d2572 2
a2573 7
      write (fd, ut, sizeof *ut);
      close (fd);
    }
  if (mutex)
    {
      ReleaseMutex (mutex);
      CloseHandle (mutex);
d2577 4
d2585 3
a2587 1
  struct utmp ut_buf, *ut;
d2589 43
a2631 7
  memset (&ut_buf, 0, sizeof ut_buf);
  strncpy (ut_buf.ut_line, line, sizeof ut_buf.ut_line);
  setutent ();
  ut = getutline (&ut_buf);
  if (ut)
    {
      int fd;
d2633 1
a2633 26
      /* We can't use ut further since it's a pointer to the static utmp_data
	 area (see below) and would get overwritten in pututline().  So we
	 copy it back to the local ut_buf. */
      memcpy (&ut_buf, ut, sizeof ut_buf);
      ut_buf.ut_type = DEAD_PROCESS;
      memset (ut_buf.ut_user, 0, sizeof ut_buf.ut_user);
      time (&ut_buf.ut_time);
      /* Writing to wtmp must be atomic to prevent mixed up data. */
      HANDLE mutex = CreateMutex (NULL, FALSE, shared_name ("wtmp_mutex", 0));
      if (mutex)
	while (WaitForSingleObject (mutex, INFINITE) == WAIT_ABANDONED)
	  ;
      if ((fd = open (_PATH_WTMP, O_WRONLY | O_APPEND | O_BINARY, 0)) >= 0)
	{
	  write (fd, &ut_buf, sizeof ut_buf);
	  close (fd);
	}
      if (mutex)
	{
	  ReleaseMutex (mutex);
	  CloseHandle (mutex);
	}
      memset (ut_buf.ut_line, 0, sizeof ut_buf.ut_line);
      ut_buf.ut_time = 0;
      pututline (&ut_buf);
      endutent ();
d2635 2
a2636 1
  return 1;
d2639 1
a2639 2
static int utmp_fd = -1;
static bool utmp_readonly = false;
d2644 2
a2645 2
static void
internal_setutent (bool force_readwrite)
d2648 2
a2649 15
  if (force_readwrite && utmp_readonly)
    endutent ();
  if (utmp_fd < 0)
    {
      utmp_fd = open (utmp_file, O_RDWR | O_BINARY);
      /* If open fails, we assume an unprivileged process (who?).  In this
	 case we try again for reading only unless the process calls
	 pututline() (==force_readwrite) in which case opening just fails. */
      if (utmp_fd < 0 && !force_readwrite)
        {
	  utmp_fd = open (utmp_file, O_RDONLY | O_BINARY);
	  if (utmp_fd >= 0)
	    utmp_readonly = true;
        }
    }
a2654 6
setutent ()
{
  internal_setutent (false);
}

extern "C" void
d2658 1
a2658 1
  if (utmp_fd >= 0)
d2661 1
a2661 2
      utmp_fd = -1;
      utmp_readonly = false;
d2683 3
a2685 7
  if (utmp_fd < 0)
    {
      internal_setutent (false);
      if (utmp_fd < 0)
        return NULL;
    }
  if (read (utmp_fd, &utmp_data, sizeof utmp_data) != sizeof utmp_data)
d2696 1
a2696 7
  if (utmp_fd < 0)
    {
      internal_setutent (false);
      if (utmp_fd < 0)
        return NULL;
    }
  while (read (utmp_fd, &utmp_data, sizeof utmp_data) == sizeof utmp_data)
d2727 1
a2727 7
  if (utmp_fd < 0)
    {
      internal_setutent (false);
      if (utmp_fd < 0)
        return NULL;
    }
  while (read (utmp_fd, &utmp_data, sizeof utmp_data) == sizeof utmp_data)
d2732 1
a2732 1
		    sizeof utmp_data.ut_line))
d2744 1
a2744 9
  internal_setutent (true);
  if (utmp_fd < 0)
    return;
  /* Read/write to utmp must be atomic to prevent overriding data
     by concurrent processes. */
  HANDLE mutex = CreateMutex (NULL, FALSE, shared_name ("utmp_mutex", 0));
  if (mutex)
    while (WaitForSingleObject (mutex, INFINITE) == WAIT_ABANDONED)
      ;
d2747 1
a2747 1
    lseek (utmp_fd, -sizeof *ut, SEEK_CUR);
d2750 1
a2750 6
  write (utmp_fd, ut, sizeof *ut);
  if (mutex)
    {
      ReleaseMutex (mutex);
      CloseHandle (mutex);
    }
@


1.240.2.20
log
@merge from trunk
@
text
@a38 1
#include <rpc.h>
a57 2
#include "cpuid.h"
#include "registry.h"
d289 2
a290 1
      if (myself->ctty >= 0 && fhandler_console::open_fhs <= 0)
a295 1
      myself->ctty = -1;
d812 1
a812 1
      if (win32_path.is_auto_device () && !win32_path.issocket ())
a2792 106
}

extern "C"
long gethostid(void)
{
  unsigned data[13] = {0x92895012,
                       0x10293412,
                       0x29602018,
                       0x81928167,
                       0x34601329,
                       0x75630198,
                       0x89860395,
                       0x62897564,
                       0x00194362,
                       0x20548593,
                       0x96839102,
                       0x12219854,
                       0x00290012};

  bool has_cpuid = false;

  if (!can_set_flag (0x00040000))
    debug_printf ("386 processor - no cpuid");
  else
    {
      debug_printf ("486 processor");
      if (can_set_flag (0x00200000))
        {
          debug_printf ("processor supports CPUID instruction");
          has_cpuid = true;
        }
      else
        debug_printf ("processor does not support CPUID instruction");
    }
  if (has_cpuid)
    {
      unsigned maxf, unused[3];
      cpuid (&maxf, &unused[0], &unused[1], &unused[2], 0);
      maxf &= 0xffff;
      if (maxf >= 1)
        {
          unsigned features;
          cpuid (&data[0], &unused[0], &unused[1], &features, 1);
          if (features & (1 << 18))
            {
              debug_printf ("processor has psn");
              if (maxf >= 3)
                {
                  cpuid (&unused[0], &unused[1], &data[1], &data[2], 3);
                  debug_printf ("Processor PSN: %04x-%04x-%04x-%04x-%04x-%04x",
                                data[0] >> 16, data[0] & 0xffff, data[2] >> 16, data[2] & 0xffff, data[1] >> 16, data[1] & 0xffff);
                }
            }
          else
            debug_printf ("processor does not have psn");
        }
    }

  UUID Uuid;
  RPC_STATUS status = UuidCreateSequential (&Uuid);
  if (GetLastError () == ERROR_PROC_NOT_FOUND)
    status = UuidCreate (&Uuid);
  if (status == RPC_S_OK)
    {
      data[4] = *(unsigned *)&Uuid.Data4[2];
      data[5] = *(unsigned short *)&Uuid.Data4[6];
      // Unfortunately Windows will sometimes pick a virtual Ethernet card
      // e.g. VMWare Virtual Ethernet Adaptor
      debug_printf ("MAC address of first Ethernet card: %02x:%02x:%02x:%02x:%02x:%02x",
                    Uuid.Data4[2], Uuid.Data4[3], Uuid.Data4[4],
                    Uuid.Data4[5], Uuid.Data4[6], Uuid.Data4[7]);
    }
  else
    {
      debug_printf ("no Ethernet card installed");
    }

  reg_key key (HKEY_LOCAL_MACHINE, KEY_READ, "SOFTWARE", "Microsoft", "Windows", "CurrentVersion", NULL);
  key.get_string ("ProductId", (char *)&data[6], 24, "00000-000-0000000-00000");
  debug_printf ("Windows Product ID: %s", (char *)&data[6]);

  GetDiskFreeSpaceEx ("C:\\", NULL, (PULARGE_INTEGER) &data[11], NULL);
  if (GetLastError () == ERROR_PROC_NOT_FOUND)
    GetDiskFreeSpace ("C:\\", NULL, NULL, NULL, (DWORD *)&data[11]);

  debug_printf ("hostid entropy: %08x %08x %08x %08x "
                                "%08x %08x %08x %08x "
                                "%08x %08x %08x %08x "
                                "%08x",
                                data[0], data[1],
                                data[2], data[3],
                                data[4], data[5],
                                data[6], data[7],
                                data[8], data[9],
                                data[10], data[11],
                                data[12]);

  long hostid = 0x40291372;
  // a random hashing algorithm
  // dependancy on md5 is probably too costly
  for (int i=0;i<13;i++)
        hostid ^= ((data[i] << (i << 2)) | (data[i] >> (32 - (i << 2))));

  debug_printf ("hostid: %08x", hostid);

  return hostid;
@


1.240.2.21
log
@merge from trunk
@
text
@d1017 1
a1017 1
  dst->st_ino = ((unsigned) (src->st_ino >> 32)) | (unsigned) src->st_ino;
d1059 2
a1060 10
extern "C" int
_fstat64_r (struct _reent *ptr, int fd, struct __stat64 *buf)
{
  int ret;

  set_errno (0);
  if ((ret = fstat64 (fd, buf)) == -1 && get_errno () != 0)
    ptr->_errno = get_errno ();
  return ret;
}
d1072 2
a1073 10
extern "C" int
_fstat_r (struct _reent *ptr, int fd, struct __stat32 *buf)
{
  int ret;

  set_errno (0);
  if ((ret = fstat (fd, buf)) == -1 && get_errno () != 0)
    ptr->_errno = get_errno ();
  return ret;
}
d1152 3
a1163 11
_stat64_r (struct _reent *ptr, const char *name, struct __stat64 *buf)
{
  int ret;

  set_errno (0);
  if ((ret = stat64 (name, buf)) == -1 && get_errno () != 0)
    ptr->_errno = get_errno ();
  return ret;
}

extern "C" int
a1172 11
extern "C" int
_stat_r (struct _reent *ptr, const char *name, struct __stat32 *buf)
{
  int ret;

  set_errno (0);
  if ((ret = stat (name, buf)) == -1 && get_errno () != 0)
    ptr->_errno = get_errno ();
  return ret;
}

d1865 1
a1865 6
  /* GetDiskFreeSpaceEx must be called before GetDiskFreeSpace on
     WinME, to avoid the MS KB 314417 bug */
  ULARGE_INTEGER availb, freeb, totalb;
  BOOL status = GetDiskFreeSpaceEx (root, &availb, &totalb, &freeb);

  DWORD spc, bps, availc, freec, totalc;
a1872 9
  if (status)
    {
      availc = availb.QuadPart / (spc*bps);
      totalc = totalb.QuadPart / (spc*bps);
      freec = freeb.QuadPart / (spc*bps);
    }
  else
    availc = freec;

d1883 1
a1883 2
  sfs->f_bavail = availc;
  sfs->f_bfree = freec;
d2574 1
a2574 3
  char mutex_name[MAX_PATH];
  HANDLE mutex = CreateMutex (NULL, FALSE,
			      shared_name (mutex_name, "wtmp_mutex", 0));
d2612 1
a2612 3
      char mutex_name[MAX_PATH];
      HANDLE mutex = CreateMutex (NULL, FALSE,
      				  shared_name (mutex_name, "wtmp_mutex", 0));
d2781 1
a2781 3
  char mutex_name[MAX_PATH];
  HANDLE mutex = CreateMutex (NULL, FALSE,
			      shared_name (mutex_name, "utmp_mutex", 0));
@


1.240.2.22
log
@merge from trunk
@
text
@d32 1
d1542 2
d2126 3
a2128 1
  HANDLE ptok, new_token = INVALID_HANDLE_VALUE;
a2130 2
  enum impersonation new_state = IMP_BAD;
  BOOL token_is_internal;
d2134 1
a2134 1
    goto success_9x;
d2140 3
d2148 1
a2148 1
      goto failed_ptok;;
d2150 6
a2155 7

  /* Verify if the process token is suitable. */
  if (verify_token (ptok, usersid, groups))
    new_state = IMP_NONE;
  /* Verify if a current token is suitable */
  else if (cygheap->user.external_token
	   && verify_token (cygheap->user.external_token, usersid, groups))
d2157 7
a2163 9
      new_token = cygheap->user.external_token;
      new_state = IMP_EXTERNAL;
    }
  else if (cygheap->user.internal_token
	   && verify_token (cygheap->user.internal_token, usersid, groups,
			    &token_is_internal))
    {
      new_token = cygheap->user.internal_token;
      new_state = IMP_INTERNAL;
d2166 1
a2166 3
  debug_printf ("New token %d, state %d", new_token, new_state);
  /* Return if current token is valid */
  if (cygheap->user.impersonation_state == new_state)
d2168 18
a2185 2
      cygheap->user.reimpersonate ();
      goto success; /* No change */
d2201 1
d2203 1
a2203 1
  if (new_state == IMP_BAD)
d2207 4
a2210 2
      new_token = create_token (usersid, groups, pw_new);
      if (new_token == INVALID_HANDLE_VALUE)
d2214 2
a2215 2
	  new_token = subauth (pw_new);
	  if (new_token == INVALID_HANDLE_VALUE)
a2217 1
      new_state = IMP_INTERNAL;
d2221 1
a2221 1
  if (new_state != IMP_NONE)
d2225 1
a2225 1
      if (new_state == IMP_EXTERNAL)
d2228 1
a2228 1
	  if (!SetTokenInformation (new_token, TokenOwner,
d2233 1
a2233 1
	  if (!SetTokenInformation (new_token,
d2239 2
a2240 2
      /* Try to impersonate. */
      if (!ImpersonateLoggedOnUser (new_token))
d2246 1
a2246 7
      /* Keep at most one internal token */
      if (new_state == IMP_INTERNAL)
        {
	  if (cygheap->user.internal_token)
	    CloseHandle (cygheap->user.internal_token);
	  cygheap->user.internal_token = new_token;
	}
d2248 6
a2254 1

a2255 3
  CloseHandle (ptok);
  cygheap->user.impersonation_state = new_state;
success_9x:
d2262 5
a2266 3
  CloseHandle (ptok);
failed_ptok:
  cygheap->user.reimpersonate ();
d2347 1
a2347 1
      if (!SetTokenInformation (cygheap->user.token (),
d2365 1
a2365 1
      && !ImpersonateLoggedOnUser (cygheap->user.token ()))
@


1.240.2.23
log
@merge from trunk
@
text
@a2854 5
  sigframe thisframe (mainthread);

  DWORD opmask = SetThreadAffinityMask (GetCurrentThread (), 1);
  if (!opmask)
    debug_printf ("SetThreadAffinityMask to 1 failed, %E");
d2936 1
a2936 4
    hostid ^= ((data[i] << (i << 2)) | (data[i] >> (32 - (i << 2))));

  if (opmask && !SetThreadAffinityMask (GetCurrentThread (), opmask))
    debug_printf ("SetThreadAffinityMask to %p failed, %E", opmask);
@


1.240.2.24
log
@merge from trunk
@
text
@d293 2
a294 1
	  syscall_printf ("freeing console");
d300 1
a300 2
      syscall_printf ("sid %d, pgid %d, ctty %d, open_fhs %d", myself->sid,
		      myself->pgid, myself->ctty, fhandler_console::open_fhs);
d2126 1
d2147 3
a2149 3
    new_token = ptok;
  /* Verify if the external token is suitable */
  else if (cygheap->user.external_token != INVALID_HANDLE_VALUE
d2151 5
a2155 10
    new_token = cygheap->user.external_token;
  /* Verify if the current token (internal or former external) is suitable */
  else if (cygheap->user.current_token != INVALID_HANDLE_VALUE
	   && cygheap->user.current_token != cygheap->user.external_token
	   && verify_token (cygheap->user.current_token, usersid, groups,
			    &token_is_internal))
    new_token = cygheap->user.current_token;
  /* Verify if the internal token is suitable */
  else if (cygheap->user.internal_token != INVALID_HANDLE_VALUE
	   && cygheap->user.internal_token != cygheap->user.current_token
d2158 4
a2161 1
    new_token = cygheap->user.internal_token;
d2163 7
a2169 1
  debug_printf ("Found token %d", new_token);
d2172 11
a2182 14
  if (cygheap->user.current_token != new_token)
    {
      char dacl_buf[MAX_DACL_LEN (5)];
      if (usersid != (origpsid = cygheap->user.orig_sid ()))
	psid2 = usersid;
      if (sec_acl ((PACL) dacl_buf, FALSE, origpsid, psid2))
	{
	  TOKEN_DEFAULT_DACL tdacl;
	  tdacl.DefaultDacl = (PACL) dacl_buf;
	  if (!SetTokenInformation (ptok, TokenDefaultDacl,
				    &tdacl, sizeof dacl_buf))
	    debug_printf ("SetTokenInformation"
			  "(TokenDefaultDacl): %E");
	}
d2185 1
a2185 3
  /* If no impersonation token is available, try to
     authenticate using NtCreateToken () or subauthentication. */
  if (new_token == INVALID_HANDLE_VALUE)
d2187 2
d2198 29
d2228 6
a2233 17
      if (cygheap->user.internal_token != INVALID_HANDLE_VALUE)
	CloseHandle (cygheap->user.internal_token);
      cygheap->user.internal_token = new_token;
    }
  else if (new_token != ptok)
    {
      /* Try setting owner to same value as user. */
      if (!SetTokenInformation (new_token, TokenOwner,
				&usersid, sizeof usersid))
	debug_printf ("SetTokenInformation(user.token, "
		      "TokenOwner): %E");
      /* Try setting primary group in token to current group */
      if (!SetTokenInformation (new_token,
				TokenPrimaryGroup,
				&groups.pgsid, sizeof (cygsid)))
	debug_printf ("SetTokenInformation(user.token, "
		      "TokenPrimaryGroup): %E");
d2235 1
d2237 1
d2239 1
a2239 4
  cygheap->user.set_sid (usersid);
  cygheap->user.current_token = new_token == ptok ? INVALID_HANDLE_VALUE
						  : new_token;
  cygheap->user.reimpersonate ();
a2634 1

d2639 7
a2645 3
      ut->ut_type = DEAD_PROCESS;
      memset (ut->ut_user, 0, sizeof ut->ut_user);
      time (&ut->ut_time);
d2649 1
a2649 1
				  shared_name (mutex_name, "wtmp_mutex", 0));
a2655 1
	  debug_printf ("set logout time for %s", line);
d2663 3
a2665 3
      memset (ut->ut_line, 0, sizeof ut_buf.ut_line);
      ut->ut_time = 0;
      pututline (ut);
d2675 2
d2690 1
a2690 1
	{
d2694 1
a2694 1
	}
a2731 10
/* Note: do not make NO_COPY */
static struct utmp utmp_data_buf[16];
static unsigned utix = 0;
#define nutdbuf (sizeof (utmp_data_buf) / sizeof (utmp_data_buf[0]))
#define utmp_data ({ \
  if (utix > nutdbuf) \
    utix = 0; \
  utmp_data_buf + utix++; \
})

d2740 1
a2740 1
	return NULL;
d2742 1
a2742 3

  utmp *ut = utmp_data;
  if (read (utmp_fd, ut, sizeof *ut) != sizeof *ut)
d2744 1
a2744 1
  return ut;
d2757 1
a2757 1
	return NULL;
d2759 1
a2759 3

  utmp *ut = utmp_data;
  while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
d2767 2
a2768 2
	  if (id->ut_type == ut->ut_type)
	    return ut;
d2774 2
a2775 2
	   if (strncmp (id->ut_id, ut->ut_id, UT_IDLEN) == 0)
	    return ut;
d2794 9
a2802 1
	return NULL;
a2803 8

  utmp *ut = utmp_data;
  while (read (utmp_fd, ut, sizeof *ut) == sizeof *ut)
    if ((ut->ut_type == LOGIN_PROCESS ||
	 ut->ut_type == USER_PROCESS) &&
	!strncmp (ut->ut_line, line->ut_line, sizeof (ut->ut_line)))
      return ut;

d2815 1
a2815 8
    {
      debug_printf ("error: utmp_fd %d", utmp_fd);
      return;
    }
  debug_printf ("ut->ut_type %d, ut->ut_pid %d, ut->ut_line '%s', ut->ut_id '%s'\n",
		ut->ut_type, ut->ut_pid, ut->ut_line, ut->ut_id);
  debug_printf ("ut->ut_user '%s', ut->ut_host '%s'\n",
		ut->ut_user, ut->ut_host);
d2841 12
a2852 12
		       0x10293412,
		       0x29602018,
		       0x81928167,
		       0x34601329,
		       0x75630198,
		       0x89860395,
		       0x62897564,
		       0x00194362,
		       0x20548593,
		       0x96839102,
		       0x12219854,
		       0x00290012};
d2867 4
a2870 4
	{
	  debug_printf ("processor supports CPUID instruction");
	  has_cpuid = true;
	}
d2872 1
a2872 1
	debug_printf ("processor does not support CPUID instruction");
d2880 16
a2895 16
	{
	  unsigned features;
	  cpuid (&data[0], &unused[0], &unused[1], &features, 1);
	  if (features & (1 << 18))
	    {
	      debug_printf ("processor has psn");
	      if (maxf >= 3)
		{
		  cpuid (&unused[0], &unused[1], &data[1], &data[2], 3);
		  debug_printf ("Processor PSN: %04x-%04x-%04x-%04x-%04x-%04x",
				data[0] >> 16, data[0] & 0xffff, data[2] >> 16, data[2] & 0xffff, data[1] >> 16, data[1] & 0xffff);
		}
	    }
	  else
	    debug_printf ("processor does not have psn");
	}
d2909 2
a2910 2
		    Uuid.Data4[2], Uuid.Data4[3], Uuid.Data4[4],
		    Uuid.Data4[5], Uuid.Data4[6], Uuid.Data4[7]);
d2926 10
a2935 10
				"%08x %08x %08x %08x "
				"%08x %08x %08x %08x "
				"%08x",
				data[0], data[1],
				data[2], data[3],
				data[4], data[5],
				data[6], data[7],
				data[8], data[9],
				data[10], data[11],
				data[12]);
@


1.240.2.25
log
@merge from trunk
@
text
@a11 1
#define lstat __FOOlstat__
a40 1
#undef lstat
a238 15
_remove_r (struct _reent *, const char *ourname)
{
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW | PC_FULL);

  if (win32_name.error)
    {
      set_errno (win32_name.error);
      syscall_printf ("-1 = remove (%s)", ourname);
      return -1;
    }

  return win32_name.isdir () ? rmdir (ourname) : unlink (ourname);
}

extern "C" int
d376 1
a376 1
      sig_dispatch_pending ();
d448 1
a448 1
  sig_dispatch_pending ();
d504 1
a504 1
  sig_dispatch_pending ();
d1218 1
a1218 1
lstat (const char *name, struct __stat32 *buf)
@


1.240.2.26
log
@merge from trunk
@
text
@a32 2
#include <errno.h>
#include <ctype.h>
a2429 2
  if (path.normalized_path)
    cfree (path.normalized_path);
d2597 1
a2597 1
updwtmp (const char *wtmp_file, const struct utmp *ut)
d2599 5
d2606 2
a2607 4
  HANDLE mutex;
  int fd;

  mutex = CreateMutex (NULL, FALSE, shared_name (mutex_name, "wtmp_mutex", 0));
d2611 1
a2611 1
  if ((fd = open (wtmp_file, O_WRONLY | O_APPEND | O_BINARY, 0)) >= 0)
a2622 27
extern "C" void
logwtmp (const char *line, const char *user, const char *host)
{
  sigframe thisframe (mainthread);
  struct utmp ut;
  memset (&ut, 0, sizeof ut);
  ut.ut_type = USER_PROCESS;
  ut.ut_pid = getpid ();
  if (line)
    strncpy (ut.ut_line, line, sizeof ut.ut_line);
  time (&ut.ut_time);
  if (user)
    strncpy (ut.ut_user, user, sizeof ut.ut_user);
  if (host)
    strncpy (ut.ut_host, host, sizeof ut.ut_host);
  updwtmp (_PATH_WTMP, &ut);
}

extern "C" void
login (struct utmp *ut)
{
  sigframe thisframe (mainthread);
  pututline (ut);
  endutent ();
  updwtmp (_PATH_WTMP, ut);
}

d2636 2
d2641 18
a2658 2
      updwtmp (_PATH_WTMP, &ut_buf);
      debug_printf ("set logout time for %s", line);
a2963 64
}

#define ETC_SHELLS "/etc/shells"
static int shell_index;
static FILE *shell_fp;

extern "C" char *
getusershell ()
{
  /* List of default shells if no /etc/shells exists, defined as on Linux.
     FIXME: SunOS has a far longer list, containing all shells which
     might be shipped with the OS.  Should we do the same for the Cygwin
     distro, adding bash, tcsh, ksh, pdksh and zsh?  */
  static NO_COPY const char *def_shells[] = {
    "/bin/sh",
    "/bin/csh",
    "/usr/bin/sh",
    "/usr/bin/csh",
    NULL
  };
  static char buf[MAX_PATH];
  int ch, buf_idx;

  if (!shell_fp && !(shell_fp = fopen (ETC_SHELLS, "rt")))
    {
      if (def_shells[shell_index])
        return strcpy (buf, def_shells[shell_index++]);
      return NULL;
    }
  /* Skip white space characters. */
  while ((ch = getc (shell_fp)) != EOF && isspace (ch))
    ;
  /* Get each non-whitespace character as part of the shell path as long as
     it fits in buf. */
  for (buf_idx = 0;
       ch != EOF && !isspace (ch) && buf_idx < MAX_PATH;
       buf_idx++, ch = getc (shell_fp))
    buf[buf_idx] = ch;
  /* Skip any trailing non-whitespace character not fitting in buf.  If the
     path is longer than MAX_PATH, it's invalid anyway. */
  while (ch != EOF && !isspace (ch))
    ch = getc (shell_fp);
  if (buf_idx)
    {
      buf[buf_idx] = '\0';
      return buf;
    }
  return NULL;
}

extern "C" void
setusershell ()
{
  if (shell_fp)
    fseek (shell_fp, 0L, SEEK_SET);
  shell_index = 0;
}

extern "C" void
endusershell ()
{
  if (shell_fp)
    fclose (shell_fp);
  shell_index = 0;
@


1.240.2.27
log
@merge from trunk
@
text
@d2144 3
a2146 3
  cygpsid origpsid, psid2 (NO_SID);
  BOOL token_is_internal, issamesid;
  
a2221 3
      /* Avoid having HKCU use default user */
      load_registry_hive (usersid);
      
a2235 1
  issamesid = (usersid == (psid2 = cygheap->user.sid ())); 
d2238 1
a2238 3
                                                  : new_token;
  if (!issamesid) /* MS KB 199190 */
    RegCloseKey(HKEY_CURRENT_USER); 
a2239 3
  if (!issamesid)
    user_shared_initialize ();

d2978 1
a2978 1
static struct __sFILE64 *shell_fp;
d2997 1
a2997 1
  if (!shell_fp && !(shell_fp = fopen64 (ETC_SHELLS, "rt")))
@


1.240.2.28
log
@merge from trunk
@
text
@d1985 1
a1985 1
      pinfo p (pid, PID_MAP_RW);
d2441 1
a2441 1
  if (!path.normalized_path_size && path.normalized_path)
@


1.239
log
@Apply system_cancel patch
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.238
log
@2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* pwdgrp.h (pwdgrp_check::pwdgrp_state): Replace by
	pwdgrp_check::isinitializing ().
	(pwdgrp_check::isinitializing): Create.
	* passwd.cc (grab_int): Change type to unsigned, use strtoul and
	set the pointer content to 0 if the field is invalid.
	(parse_pwd): Move validity test after getting pw_gid.
	(read_etc_passwd): Replace "passwd_state <= " by
	passwd_state::isinitializing ().
	(internal_getpwuid): Ditto.
	(internal_getpwnam): Ditto.
	(getpwent): Ditto.
	(getpass): Ditto.
	* grp.cc (parse_grp): Use strtoul for gr_gid and verify the validity.
	(read_etc_group): Replace "group_state <= " by
	group_state::isinitializing ().
	(internal_getgrgid): Ditto.
	(getgrent32): Ditto.
	(internal_getgrent): Ditto.

2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h: Move declarations of internal_getgrent,
	internal_getpwsid and internal_getgrsid to pwdgrp.h.
	* pwdgrp.h: Declare internal_getpwsid, internal_getpwnam,
	internal_getpwuid, internal_getgrsid, internal_getgrgid,
	internal_getgrnam, internal_getgrent and internal_getgroups.
	Delete "emulated" from enum pwdgrp_state.
	(pwdgrp_check::isuninitialized): Create.
	(pwdgrp_check::pwdgrp_state): Change state to initializing
	rather than to uninitialized.
	(pwdgrp_read::gets): Remove trailing CRs.
	* passwd.cc (grab_string): Don't look for NLs.
	(grab_int): Ditto.
	(parse_pwd): Don't look for CRs. Return 0 if entry is too short.
	(search_for): Delete.
	(read_etc_passwd): Simplify tests to actually read the file.
	Set state to loaded before making internal_getpwXX calls.
	Replace search_for calls by equivalent internal_pwgetXX calls.
	(internal_getpwsid): Use passwd_state.isuninitialized to decide
	to call read_etc_passwd.
	(internal_getpwuid): Create.
	(internal_getpwnam): Create.
	(getpwuid32): Simply call internal_getpwuid.
	(getpwuid_r32): Call internal_getpwuid.
	(getpwnam): Simply call internal_getpwnam.
	(getpwnam_r): Call internal_getpwnam.
	* grp.cc (parse_grp): Don't look for CRs. Adjust blank space.
	(add_grp_line): Adjust blank space.
	(class group_lock): Ditto.
	(read_etc_group): Simplify tests to actually read the file.
	Set state to loaded before making internal_getgrXX calls.
	Replace getgrXX calls by equivalent internal calls.
	(internal_getgrsid): Use group_state.isuninitialized to decide
	to call read_etc_group.
	(internal_getgrgid): Create.
	(internal_getgrnam): Create.
	(getgroups32): Simply call internal_getgrgid.
	(getgrnam32): Simply call internal_getgrnam.
	(internal_getgrent): Call group_state.isuninitialized.
	(internal_getgroups): Create from the former getgroups32, using
	two of the four arguments. Set gid to myself->gid and username
	to cygheap->user.name ().
	(getgroups32): Simply call internal_getgroup.
	(getgroups): Call internal_getgroup instead of getgroups32.
	(setgroups32): Call internal versions of get{pw,gr}XX.
	* sec_helper.cc: Include pwdgrp.h.
	(is_grp_member): Call internal versions of get{pw,gr}XX.
	* security.cc: Include pwdgrp.h.
	(alloc_sd): Call internal versions of get{pw,gr}XX.
	* syscalls.cc: Include pwdgrp.h.
	(seteuid32): Call internal versions of get{pw,gr}XX.
	(setegid32): Ditto.
	* uinfo.cc: Include pwdgrp.h.
	(internal_getlogin): Call internal versions of get{pw,gr}XX.
	(cygheap_user::ontherange): Ditto.
	* sec_acl.cc: Include pwdgrp.h.
	(setacl): Call internal versions of get{pw,gr}XX.
	(acl_access): Ditto and simplify logic.
	(aclfromtext): Ditto.
@
text
@d1377 2
@


1.238.4.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d1024 1
a1024 1
	    buf->st_dev = cfd->get_device ();
d1114 1
a1114 1
	    buf->st_dev = fh->get_device ();
d1508 1
a1508 1
      if (cfd->get_device () == FH_FS)
d1605 1
a1605 1
  if (cfd->get_device () != FH_FS)
@


1.238.4.2
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d1568 3
a1570 1
    return 0;
@


1.238.4.3
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@d800 1
a800 1
      if (win32_path.is_auto_device ())
d918 1
a918 1
  if (win32_path.is_auto_device ())
d1550 1
a1550 1
	if (full_path.is_auto_device ())
d1930 1
a1930 1
mknod (const char *path, mode_t mode, dev_t dev)
d1932 2
a1933 60
  if (check_null_empty_str_errno (path))
    return -1;

  if (strlen (path) >= MAX_PATH)
    return -1;

  path_conv w32path (path, PC_SYM_NOFOLLOW | PC_FULL);
  if (w32path.exists ())
    {
      set_errno (EEXIST);
      return -1;
    }

  mode_t prot = mode & (S_IRWXU | S_IRWXG | S_IRWXO);
  mode &= S_IFMT;
  if (!mode || mode == S_IFREG)
    {
      int fd = open (path, O_CREAT, prot);
      if (fd < 0)
	return -1;
      close (fd);
      return 0;
    }

  char buf[sizeof (":00000000:00000000:X") + MAX_PATH];

  _devtype_t ch;
  if (mode == S_IFCHR)
    ch = 'c';
  else if (mode == S_IFBLK)
    ch = 'b';
  else if (mode == S_IFIFO)
    {
      dev = FH_FIFO;
      ch = 's';
    }
  else
    {
      set_errno (EINVAL);
      return -1;
    }

  _major_t major = dev >> 8 /* SIGH.  _major (dev) */;
  _minor_t minor = dev & 0xff /* SIGH _minor (dev) */;

  sprintf (buf, ":%x:%x:%c", major, minor, ch);
  if (symlink_worker (buf, w32path, true, true))
    return -1;

  strcat (w32path, ".lnk");
  if (chmod (w32path, prot))
    return -1;

  if (!SetFileAttributes (w32path, FILE_ATTRIBUTE_READONLY))
    {
      __seterrno ();
      return -1;
    }

  return 0;
d1939 1
d1947 1
@


1.238.4.4
log
@* devices.h (_devtype_t): Eliminate.
(_mode_t): New typedef.
(device::mode): Replace type.
* fhandler.h (fhandler_base::device_access_denied): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Define new function.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Just copy mode directly
from dev.mode to st_mode if it is a disk device.
* path.cc (path_conv::check): Set device mode from sym mode.
(symlink_worker): Let "exists" check happen when file is attempted to be
opened, or not, in the case of creating a device.
(symlink_info::parse_device): Change device type argument to device mode
argument.
(mknod_worker): New function.
(chmod_device): Ditto.
(chmod): Use chmod_device to set protection if it is an fs device.
(mknod): Use mknod_worker to actually create the device.  Don't take any
special action with the protection since it is now implicit.
@
text
@a57 3
static int __stdcall mknod_worker (const char *, mode_t, mode_t, _major_t,
				   _minor_t);

a535 5
	  else if (fh->is_fs_device () && fh->device_access_denied (flags))
	    {
	      fd.release ();
	      res = -1;
	    }
a900 6
int
chmod_device (path_conv& pc, mode_t mode)
{
  return mknod_worker (pc, pc.dev.mode & S_IFMT, mode, pc.dev.major, pc.dev.minor);
}

a922 5
  if (win32_path.is_fs_device ())
    {
      res = chmod_device (win32_path, mode);
      goto done;
    }
a1922 10
static int __stdcall
mknod_worker (const char *path, mode_t type, mode_t mode, _major_t major,
	      _minor_t minor)
{
  char buf[sizeof (":00000000:00000000:00000000") + MAX_PATH];
  sprintf (buf, ":%x:%x:%x", major, minor,
	   type | (mode & (S_IRWXU | S_IRWXG | S_IRWXO)));
  return symlink_worker (buf, path, true, true);
}

d1945 3
a1947 2
  mode_t type = mode & S_IFMT;
  switch (type)
d1949 6
a1954 4
    case S_IFCHR:
    case S_IFBLK:
    case S_IFIFO:
      break;
d1956 1
a1956 9
    case 0:
    case S_IFREG:
      {
	int fd = open (path, O_CREAT, mode);
	if (fd < 0)
	  return -1;
	close (fd);
	return 0;
      }
d1958 12
a1969 1
    default:
d1976 16
a1991 1
  return mknod_worker (w32path, type, mode, major, minor);
@


1.238.4.5
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@d539 1
a539 1
	  else if (fh->is_fs_special () && fh->device_access_denied (flags))
d937 1
a937 1
  if (win32_path.is_fs_special ())
a1974 2
  _major_t major = dev >> 8 /* SIGH.  _major (dev) */;
  _minor_t minor = dev & 0xff /* SIGH _minor (dev) */;
a1978 2
      break;

a1979 2
      major = _major (FH_FIFO);
      minor = _minor (FH_FIFO) & 0xff; /* SIGH again */
d1997 2
@


1.237
log
@* pinfo.h (winpids::set): Renamed from init.
(winpids::init): New declaration.
(winpids::cs): Ditto.
(winpids::winpids): Use set rather than init.
* external.cc (fillout_pinfo): Ditto.
* dcrt0.cc (dll_crt0_1): Call winpids::init.
* pinfo.cc (winpids::set): Renamed from init.  Wrap calls in critical section.
(winpids::init): New function.
(winpids::cs): Define.
@
text
@d48 1
d1974 1
a1974 1
  pw_new = getpwuid32 (uid);
d2150 1
a2150 1
  struct __group32 * gr = getgrgid32 (gid);
@


1.236
log
@* exceptions.cc (handle_sigsuspend): Force pending signal delivery before
waiting for signals to happen.
* signal.cc (sleep): Force pending signal delivery before sleeping.
(usleep): Ditto.
(signal): Force pending signal delivery before manipulating signal stuff.
(sigprocmask): Ditto.
(kill_worker): Ditto.
(abort): Ditto.
(sigaction): Ditto.
* syscalls.cc (readv): Force pending signal delivery before I/O.
(writev): Ditto.
(open): Ditto.
* net.cc: Ditto, throughout.
* sigproc.cc (sig_dispatch_pending): Deliver any pending signals prior to
returning.
* tty.cc (tty::make_pipes): Increase pipe buffer size.
@
text
@d342 1
a342 1
  const struct iovec iov =
@


1.235
log
@	* security.cc (get_attribute_from_acl): Always test "anti",
	just in case an access_denied ACE follows an access_allowed.
	Handle the case owner_sid == group_sid, with a FIXME.
	Remove unnecessary tests for non-NULL PSIDs.
	(alloc_sd): Use existing owner and group sids if {ug}id == -1.
	Handle case where owner_sid == group_sid.
	Do not call is_grp_member. Try to preserve canonical ACE order.
	Remove unnecessary tests for non-NULL PSIDs. Reorganize
	debug_printf's.
	(get_initgroups_sidlist): Put well_known_system_sid on left
	side of ==.
	(add_access_denied_ace): Only call GetAce if inherit != 0.
	(add_access_allowed_ace): Ditto. Use appropriate sizeof.
	* syscalls.cc (chown_worker): Pass {ug}id equal to -1 to
	alloc_sd, which removes the need to obtain old_{ug}id.
	(chmod): Remove call to get_file_attribute (), simply pass
	{ug}id equal to -1 to alloc_sd.
@
text
@d387 1
d459 1
d515 1
@


1.234
log
@	* syscalls.cc (chmod): Simplify conditional.
	* sec_helper (cygsid::getfromstr): Reorganize to remove
	calls to strcpy and strtok_r.
	(cygsid::getfromgr): Change type to __uid32_t instead of int.
	Keep only the allow_ntsec branch. Never call LookupAccountSid
	which calls PDCs, simply return -1 in case of failure.
	Use cygsid == instead of calling EqualSid and remove test
	for NULL psid.
	* security.h: Declare cygsid::getfromgr as __uid32_t.
@
text
@a775 2
  __uid32_t old_uid;
  __gid32_t old_gid;
d807 1
a807 3
				(int *) &attrib,
				&old_uid,
				&old_gid);
d809 2
a810 10
	{
	  if (uid == ILLEGAL_UID)
	    uid = old_uid;
	  if (gid == ILLEGAL_GID)
	    gid = old_gid;
	  if (win32_path.isdir ())
	    attrib |= S_IFDIR;
	  res = set_file_attribute (win32_path.has_acls (), win32_path, uid,
				    gid, attrib);
	}
a926 9
      __uid32_t uid;
      __gid32_t gid;

      if (win32_path.isdir ())
	mode |= S_IFDIR;
      get_file_attribute (win32_path.has_acls (),
			  win32_path.get_win32 (),
			  NULL, &uid, &gid);
      /* FIXME: Do we really need this to be specified twice? */
d929 2
a930 2
      if (!set_file_attribute (win32_path.has_acls (), win32_path, uid, gid,
				mode)
@


1.233
log
@* syscalls.cc (getutid): Use UT_IDLEN where appropriate.
@
text
@d967 3
a969 6
      else
	{
	  /* Correct NTFS security attributes have higher priority */
	  if (res == 0 || !allow_ntsec)
	    res = 0;
	}
@


1.232
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
@
text
@d2574 1
a2574 1
   if (strncmp (id->ut_id, utmp_data.ut_id, 2) == 0)
@


1.231
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@a2429 1
  int currtty = ttyslot ();
d2431 1
a2431 7
  if (currtty >= 0 && (fd = open (_PATH_UTMP, O_WRONLY | O_CREAT | O_BINARY,
					 0644)) >= 0)
    {
      (void) lseek (fd, (long) (currtty * sizeof (struct utmp)), SEEK_SET);
      (void) write (fd, (char *) ut, sizeof (struct utmp));
      (void) close (fd);
    }
d2512 1
a2512 1
      utmp_fd = open (utmp_file, O_RDONLY);
d2521 5
a2525 2
  close (utmp_fd);
  utmp_fd = -2;
d2537 1
a2562 1
#if 0 /* Not available in Cygwin. */
a2569 1
#endif
d2574 1
a2574 1
	  if (id->ut_id == utmp_data.ut_id)
d2599 15
@


1.231.4.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d2430 1
d2432 7
a2438 1
  pututline (ut);
d2519 1
a2519 1
      utmp_fd = open (utmp_file, O_RDWR);
d2528 2
a2529 5
  if (utmp_fd != -2)
    {
      close (utmp_fd);
      utmp_fd = -2;
    }
a2540 1
  endutent ();
d2566 1
d2574 1
d2579 1
a2579 1
	   if (strncmp (id->ut_id, utmp_data.ut_id, UT_IDLEN) == 0)
a2603 15
}

extern "C" void
pututline (struct utmp *ut)
{
  sigframe thisframe (mainthread);
  if (check_null_invalid_struct (ut))
    return;
  setutent ();
  struct utmp *u;
  if ((u = getutid (ut)))
    lseek (utmp_fd, -sizeof(struct utmp), SEEK_CUR);
  else
    lseek (utmp_fd, 0, SEEK_END);
  (void) write (utmp_fd, (char *) ut, sizeof (struct utmp));
@


1.230
log
@Rename _kill() to kill() throughout.  Rename _raise() to raise() throughout.
Rename _pid() to pid() throughout.
* Makefile.in: Compile some objects with -fomit-frame-pointer.
* cygwin.din: Reverse aliasing for _kill.
* syscalls.cc (_getpid_r): New function, implemented for newlib compatibility.
* shared.cc (open_shared): Remove reserving of memory since previous change
eliminate the need for this hack.
@
text
@d11 6
d49 6
d109 1
a109 1
_unlink (const char *ourname)
d263 1
a263 1
  return win32_name.isdir () ? rmdir (ourname) : _unlink (ourname);
d340 1
a340 1
_read (int fd, void *ptr, size_t len)
d351 3
d355 1
a355 1
_write (int fd, const void *ptr, size_t len)
d366 3
d508 1
a508 1
_open (const char *unix_path, int flags, ...)
d546 3
d574 1
a574 1
_lseek (int fd, __off32_t pos, int dir)
d579 3
d583 1
a583 1
_close (int fd)
d605 2
d630 1
a630 1
_link (const char *a, const char *b)
d1260 1
a1260 1
_rename (const char *oldpath, const char *newpath)
d2519 1
a2519 1
      utmp_fd = _open (utmp_file, O_RDONLY);
d2521 1
a2521 1
  _lseek (utmp_fd, 0, SEEK_SET);
d2528 1
a2528 1
  _close (utmp_fd);
d2551 1
a2551 1
  if (_read (utmp_fd, &utmp_data, sizeof (utmp_data)) != sizeof (utmp_data))
d2562 1
a2562 1
  while (_read (utmp_fd, &utmp_data, sizeof (utmp_data)) == sizeof (utmp_data))
d2595 1
a2595 1
  while (_read (utmp_fd, &utmp_data, sizeof (utmp_data)) == sizeof (utmp_data))
@


1.229
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d255 1
a255 1
_getpid ()
d260 6
d297 2
a298 2
      myself->sid = _getpid ();
      myself->pgid = _getpid ();
@


1.228
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d382 1
a382 1
	debug_printf ("no need to call ready_for_read\n");
d1579 1
a1579 1
  syscall_printf ("_cygwin_istext_for_stdio (%d)\n", fd);
d1582 1
a1582 1
      syscall_printf (" _cifs: old API\n");
d1589 1
a1589 1
      syscall_printf (" _cifs: fd not open\n");
d1595 1
a1595 1
      syscall_printf (" _cifs: fd not disk file\n");
d1601 1
a1601 1
      syscall_printf (" _cifs: get_*_binary\n");
d1605 1
a1605 1
  syscall_printf ("_cygwin_istext_for_stdio says yes\n");
d1620 1
a1620 1
  syscall_printf ("setmode: file was %s now %s\n",
d1680 1
a1680 1
  syscall_printf ("setmode (%d<%s>, %p) returns %s\n", fd, cfd->get_name (),
d2158 1
a2158 1
    debug_printf ("OpenProcessToken(): %E\n");
@


1.227
log
@Cleanup calls to CreateFile throughout.
* dcrt0.cc (__api_fatal): Correctly check for failing return from CreateFile.
* assert.cc (__assert): Don't check return value from CreateFile for NULL.
* fhandler_console.cc (set_console_state_for_spawn): Ditto.
* fork.cc (fork_parent): Ditto.
@
text
@d786 1
a786 1
	  if (win32_path.isdir())
d1972 1
a1972 1
  RevertToSelf();
d1982 1
a1982 1
  debug_printf("Process token %sverified", process_ok ? "" : "not ");
d1999 1
a1999 1
      debug_printf("Thread token %d %sverified",
d2017 2
a2018 2
  char dacl_buf[MAX_DACL_LEN(5)];
  if (usersid != (origpsid =  cygheap->user.orig_sid())) psid2 = usersid;
d2033 1
a2033 1
	 authenticate using NtCreateToken() or subauthentication. */
d2062 1
a2062 1
				    &groups.pgsid, sizeof(cygsid)))
@


1.226
log
@	* syscalls.cc (seteuid32): Treat ILLEGAL_UID invalid.
	(setegid32): Treat ILLEGAL_GID invalid.
@
text
@d651 4
a654 9
      hFileSource = CreateFile (
	real_a,
	FILE_WRITE_ATTRIBUTES,
	FILE_SHARE_READ | FILE_SHARE_WRITE /*| FILE_SHARE_DELETE*/,
	&sec_none_nih, // sa
	OPEN_EXISTING,
	0,
	NULL
	);
d2431 4
a2434 6
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			&sec_none_nih,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL);
@


1.225
log
@* miscfuncs.cc (check_iovec_for_read): Don't check buffer when zero length
iov_len.
(check_iovec_for_write): Ditto.
* fhandler.h (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* fhandler.cc (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* syscalls.cc (_read): Delegate to readv(2).
(_write): Ditto, mutatis mutandi.
(readv): Rewrite, based on the old _read code, to use the new
fhandler_base::readv method.  Improve access mode handling and ensure all calls
reach the final strace statement.
(writev): Ditto, mutatis mutandi.
* include/sys/uio.h (struct iovec): Change field types to match SUSv3.
* winsup.h (check_iovec_for_read): New function.
(check_iovec_for_write): Ditto.
* miscfuncs.cc (check_iovec_for_read): Ditto.
(check_iovec_for_write): Ditto.
@
text
@d1946 1
a1946 3
      || (uid == myself->uid
	  && !cygheap->user.groups.ischanged)
      || uid == ILLEGAL_UID)
d1952 6
d2129 1
a2129 3
  if ((!wincap.has_security ()) ||
      (gid == myself->gid) ||
      (gid == ILLEGAL_GID))
d2131 6
@


1.224
log
@* perthread.h (vfork_save): Add ctty, sid, pgid, exitval fields.
(vfork_save::restore_pid): New method.
(vfork_save::restore_exit): New method.
* fork.cc (vfork): Save ctty, sid, pgid and restore them when returning to
"parent".  Use exitval field if exiting but never created a new process.
* syscalls.cc (setsid): Detect when in "vfork" and force an actual fork so that
pid will be allocated (UGLY!).
(getsid): New function.
* dcrt0.cc (do_exit): Use vfork_save::restore_exit method for returning from a
vfork.
* spawn.cc (spawnve): Use vfork_save::{restore_pid,restore_exit} methods for
returning from vfork.
* cygwin.din: Export getsid.
* include/cygwin/version.h: Bump api minor number.
* malloc.cc: #ifdef sYSTRIm for when MORECORE_CANNOT_TRIM is true.
@
text
@d324 8
a331 2
  if (len == 0)
    return 0;
d333 11
a343 2
  if (__check_null_invalid_struct_errno (ptr, len))
    return -1;
d345 3
a347 1
  int res;
d349 11
a359 1
  int e = get_errno ();
d367 7
a373 1
	return -1;
d378 2
a379 2
      syscall_printf ("read (%d, %p, %d) %sblocking, sigcatchers %d",
		      fd, ptr, len, wait ? "" : "non", sigcatchers);
d393 1
a393 1
	return -1;
d400 4
a403 1
	return -1;
d409 5
a413 2
	    return -1;
	  res = cfd->read (ptr, len);
a417 8

      if (res && get_errno () == EACCES &&
	  !(cfd->get_flags () & (O_RDONLY | O_RDWR)))
	{
	  set_errno (EBADF);
	  break;
	}

d423 2
a424 1
  syscall_printf ("%d = read (%d, %p, %d), errno %d", res, fd, ptr, len,
d431 1
a431 1
_write (int fd, const void *ptr, size_t len)
d434 1
d441 1
a441 2
  /* No further action required for len == 0 */
  if (len == 0)
d443 1
a443 1
      res = 0;
d447 5
a451 2
  if (len && __check_invalid_read_ptr_errno (ptr, len))
    goto done;
d455 1
a455 1
    paranoid_printf ("write (%d, %p, %d)", fd, ptr, len);
d457 1
a457 1
    syscall_printf  ("write (%d, %p, %d)", fd, ptr, len);
d464 1
a464 1
      res = cfd->write (ptr, len);
a465 3
      if (res && get_errno () == EACCES &&
	  !(cfd->get_flags () & (O_WRONLY | O_RDWR)))
	set_errno (EBADF);
d470 2
a471 1
    paranoid_printf ("%d = write (%d, %p, %d)", res, fd, ptr, len);
d473 2
a474 1
    syscall_printf ("%d = write (%d, %p, %d)", res, fd, ptr, len);
d476 2
a477 89
  return (ssize_t) res;
}

/*
 * FIXME - should really move this interface into fhandler, and implement
 * write in terms of it. There are devices in Win32 that could do this with
 * overlapped I/O much more efficiently - we should eventually use
 * these.
 */

extern "C" ssize_t
writev (int fd, const struct iovec *iov, int iovcnt)
{
  int i;
  ssize_t len, total;
  char *base;

  if (iovcnt < 1 || iovcnt > IOV_MAX)
    {
      set_errno (EINVAL);
      return -1;
    }

  /* Ensure that the sum of the iov_len values is less than
     SSIZE_MAX (per spec), if so, we must fail with no output (per spec).
  */
  total = 0;
  for (i = 0; i < iovcnt; ++i)
    {
    total += iov[i].iov_len;
    if (total > SSIZE_MAX)
      {
      set_errno (EINVAL);
      return -1;
      }
    }
  /* Now write the data */
  for (i = 0, total = 0; i < iovcnt; i++, iov++)
    {
      len = iov->iov_len;
      base = iov->iov_base;
      while (len > 0)
	{
	  register int nbytes;
	  nbytes = write (fd, base, len);
	  if (nbytes < 0 && total == 0)
	    return -1;
	  if (nbytes <= 0)
	    return total;
	  len -= nbytes;
	  total += nbytes;
	  base += nbytes;
	}
    }
  return total;
}

/*
 * FIXME - should really move this interface into fhandler, and implement
 * read in terms of it. There are devices in Win32 that could do this with
 * overlapped I/O much more efficiently - we should eventually use
 * these.
 */

extern "C" ssize_t
readv (int fd, const struct iovec *iov, int iovcnt)
{
  int i;
  ssize_t len, total;
  char *base;

  for (i = 0, total = 0; i < iovcnt; i++, iov++)
    {
      len = iov->iov_len;
      base = iov->iov_base;
      while (len > 0)
	{
	  register int nbytes;
	  nbytes = read (fd, base, len);
	  if (nbytes < 0 && total == 0)
	    return -1;
	  if (nbytes <= 0)
	    return total;
	  len -= nbytes;
	  total += nbytes;
	  base += nbytes;
	}
    }
  return total;
@


1.223
log
@	* security.cc (verify_token): Do not reject a token just because
	the supplementary group list is missing Everyone or a groupsid
	equal to usersid, or because the primary group is not in the token,
	as long as it is equal to the usersid.
	* syscalls.cc (seteuid32): Use common code for all successful returns.
	* grp.cc (getgroups32): Never includes Everyone in the output.
@
text
@d39 3
d271 3
a273 1
  if (myself->pgid != _getpid ())
d275 14
a288 3
      if (myself->ctty == TTY_CONSOLE &&
	  !cygheap->fdtab.has_console_fds () &&
	  !check_pty_fds ())
d296 1
d299 20
@


1.222
log
@* cygthread.cc (cygthread::exit_thread): Define new method.
* cygthread.h (cygthread::exit_thread): Declare new method.
* fhandler.h (fhandler_tty_master::hThread): Delete.
(fhandler_tty_master::output_thread): Define.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Adjust
constructor.
(fhandler_tty_master::init): Use cygthread rather than handle.
(process_output): Use cygthread method to exit.
(fhandler_tty_master::fixup_after_fork): Set output_thread to NULL after fork.
(fhandler_tty_master::fixup_after_exec): Set output_thread to NULL after
spawn/exec.
* tty.cc (tty_list::terminate): Detach from output_thread using cygthread
method.
@
text
@d2007 1
a2007 1
	  return 0; /* No change */
d2028 1
a2028 1
	      return 0; /* No change */
d2100 1
@


1.221
log
@* syscalls.cc (_link): Revert previous change and just always dereference the
oldpath.
@
text
@d308 2
a309 1
      syscall_printf ("read (%d, %p, %d) %sblocking, sigcatchers %d", fd, ptr, len, wait ? "" : "non", sigcatchers);
d312 1
a312 1
	debug_printf ("non-interruptible read\n");
d322 1
a322 1
      if (!cfd.isopen())
d335 1
a335 1
	  if (!cfd.isopen())
@


1.220
log
@* syscalls.cc (link): Properly deal with a link to a symlink.
@
text
@d308 1
a308 2
      syscall_printf ("read (%d, %p, %d) %sblocking, sigcatchers %d",
		      fd, ptr, len, wait ? "" : "non", sigcatchers);
d311 1
a311 1
	debug_printf ("no need to call ready_for_read\n");
d321 1
a321 1
      if (!cfd.isopen ())
d334 1
a334 1
	  if (!cfd.isopen ())
d617 1
a618 2
  path_conv real_a (a, PC_SYM_NOFOLLOW | PC_FULL);
  extern BOOL allow_winsymlinks;
a648 2
      if (allow_winsymlinks && real_b.issymlink ())
	strcat (real_a, ".lnk");
@


1.219
log
@* syscalls.cc (_read): Clarify debugging output.
@
text
@d620 1
d651 2
@


1.218
log
@	* security.cc: Change some formatting.
	* include/cygwin/version.h: Bump API minor version.

        * cygheap.h (class cygheap_user): Add member groups.
        * security.h (class cygsidlist): Add members type and maxcount,
        methods position, addfromgr, alloc_sids and free_sids and
        operator+= (const PSID psid). Modify contains () to call
        position () and optimize add () to use maxcount.
        (class user_groups): Create.
        Update declarations of verify_token and create_token.
        * security.cc (cygsidlist::alloc_sids): New.
        (cygsidlist::free_sids): New.
        (get_token_group_sidlist): Create from get_group_sidlist.
        (get_initgroups_sidlist): Create from get_group_sidlist.
        (get_group_sidlist): Suppress.
        (get_setgroups_sidlist): Create.
        (verify_token): Modify arguments. Add setgroups case.
        (create_token): Modify arguments. Call get_initgroups_sidlist and
        get_setgroups_sidlist as needed. Set SE_GROUP_LOGON_ID from auth_pos
        outside of the loop. Rename the various group sid lists consistently.
        * syscalls.cc (seteuid32): Modify to use cygheap->user.groups.
        (setegid32): Call cygheap->user.groups.update_pgrp.
        * grp.cc (setgroups): Create.
        (setgroups32): Create.
        * uinfo.cc (internal_getlogin): Initialize and update user.groups.pgsid.
        * cygwin.din: Add setgroups and setgroups32.
@
text
@d308 2
a309 1
      syscall_printf ("read (%d, %p, %d) %sblocking, sigcatchers %d", fd, ptr, len, wait ? "" : "non", sigcatchers);
d312 1
a312 1
	debug_printf ("non-interruptible read\n");
d322 1
a322 1
      if (!cfd.isopen())
d335 1
a335 1
	  if (!cfd.isopen())
@


1.217
log
@* fhandler_console.cc (fhandler_console::read): Use appropriate kill_pgrp
method.
* select.cc (peek_console): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Send "stopped" signal to
entire process group as dictated by SUSv3.
* termios.cc (tcsetattr): Detect when stopped signal sent and force a stop
before setting anything.
@
text
@d1961 2
a1962 3
      || (!cygheap->user.issetuid ()
	  && uid == myself->uid
	  && myself->gid == cygheap->user.orig_gid)
d1970 2
a1971 1
  cygsid usersid, pgrpsid;
d1979 1
a1979 2
  if (!usersid.getfrompw (pw_new) ||
      (!pgrpsid.getfromgr (getgrgid32 (myself->gid))))
d1997 1
a1997 1
  process_ok = verify_token (ptok, usersid, pgrpsid);
d2013 2
a2014 2
      BOOL token_ok = verify_token (cygheap->user.token, usersid, pgrpsid,
				    & sav_token_is_internal_token);
d2050 1
a2050 1
      cygheap->user.token = create_token (usersid, pgrpsid, pw_new);
d2078 1
a2078 1
				    &pgrpsid, sizeof pgrpsid))
d2100 1
d2145 1
d2157 1
@


1.216
log
@* fhandler_registry.cc (fhandler_registry::close): Return any error result to
the caller.
* syscalls.cc (_close): Return result of fhandler::close to the caller.
@
text
@d328 1
a328 1
      if (!cfd.isopen())
@


1.215
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d581 1
a581 1
      cfd->close ();
a582 1
      res = 0;
@


1.214
log
@* syscalls.c (seteuid32): Return immediately if the program is not impersonated
and both uid and gid are original.
(setegid32): Return immediately if the new gid is the current egid.
@
text
@d1025 1
a1025 1
      path_conv pc (cfd->get_win32_name ());
@


1.213
log
@* syscalls.cc (seteuid32): Fix incorrect placement of Pierre's patch below.
@
text
@d620 1
a620 1
  
a1957 1
  if (!wincap.has_security ()) return 0;
d1959 7
a1965 1
  if (uid == ILLEGAL_UID)
d1967 1
a1967 1
      debug_printf ("new euid == illegal euid, nothing happens");
a1978 2
  debug_printf ("uid: %d myself->gid: %d", uid, myself->gid);

a2109 5
  if (uid == myself->uid)
    {
      syscall_printf ("special case, returning 0");
      return 0;
    }
d2141 1
@


1.212
log
@* syscalls.cc (seteuid32): Fix incorrect use of system_printf.
@
text
@d2102 5
a2111 5
  cygheap->user.token = sav_token;
  cygheap->user.impersonated = sav_impersonated;
  if (cygheap->user.issetuid ()
       && !ImpersonateLoggedOnUser (cygheap->user.token))
    system_printf ("Impersonating in seteuid failed: %E");
@


1.211
log
@* syscalls.c (seteuid32): Do not return an error when the token cannot be
created only because of a problem with the gid.
@
text
@d2104 1
a2104 1
      system_printf ("special case, returning 0");
@


1.210
log
@* cygheap.cc (cfree_and_set): New function.
(cygheap_user::set_name): Use cfree_and_set to reset members.
* cygheap.h (cygheap_user): Delete static members.
(cygheap_user::puserprof): New member.
(cfree_and_set): Declare.
* dcrt0.cc (almost_null): Define.
* winsup.h (almost_null): Declare.
* syscalls.cc (cfree_and_set): Remove unused variable.
* uinfo.cc (cygheap_user::homepath_env_buf): Eliminate.
(cygheap_user::homedrive_env_buf): Ditto.
(cygheap_user::userprofile_env_buf): Ditto.
(cygheap_user::ontherange): YA change to try to preserve existing HOMEPATH and
HOMEDRIVE.  Return almost_null values when variables should not actually exist.
(cygheap_user::env_logsrv): Ditto.
(cygheap_user::env_domain): Ditto.
(cygheap_user::env_userprofile): Ditto.
@
text
@d2057 2
a2058 1
	  if (cygheap->user.token == INVALID_HANDLE_VALUE) goto failed;
d2102 5
@


1.209
log
@* winsup.h: Minor cleanup.
* path.h (path_conv::[]): New operator.
* syscalls.cc (_link): Use path_conv operators rather than methods, where
appropriate.  Minor white space cleanup.
* include/cygwin/version.h: Bump DLL minor number.
* dcrt0.cc (sm): Make NO_COPY.
@
text
@a1971 1
  cygheap_user user;
@


1.208
log
@	* syscalls.cc (chown): Convert uid to 32 bit.
	(lchown): Ditto.
	(fchown): Ditto.
@
text
@d618 1
d620 1
a620 2
  path_conv real_b (b, PC_SYM_NOFOLLOW | PC_FULL);

d626 1
d635 1
a635 1
      syscall_printf ("file '%s' exists?", (char *)real_b);
d639 2
a640 1
  if (real_b.get_win32 ()[strlen (real_b.get_win32 ()) - 1] == '.')
d650 1
a650 1
      if (CreateHardLinkA (real_b.get_win32 (), real_a.get_win32 (), NULL))
d668 1
a668 1
	real_a.get_win32 (),
d683 1
a683 2
      lpContext = NULL;
      cbPathLen = sys_mbstowcs (wbuf, real_b.get_win32 (), MAX_PATH) * sizeof (WCHAR);
d692 1
a692 1
					    StreamId.dwStreamNameSize;
d694 1
d746 1
a746 1
  if (CopyFileA (real_a.get_win32 (), real_b.get_win32 (), 1))
@


1.207
log
@* security.cc (get_group_sidlist): Add pw argument and use pw->pw_name in call
to get_supplementary_group_sidlist.
(create_token): Add pw argument and use it in call to get_group_sidlist.
* security.h: Add pw argument in declaration of create_token.
* syscalls.cc (seteuid32): Add pw argument in call to create_token.
@
text
@d835 2
a836 1
  return chown_worker (name, PC_SYM_FOLLOW, uid, gid16togid32 (gid));
d850 2
a851 1
  return chown_worker (name, PC_SYM_NOFOLLOW, uid, gid16togid32 (gid));
d882 1
a882 1
  return fchown32 (fd, uid, gid16togid32 (gid));
@


1.206
log
@	* syscalls.cc (stat64_to_stat32): Correctly evaluate st_rdev.
	(fstat64): Set st_rdev to same value as st_dev.
	(stat_worker): Ditto.
@
text
@d2046 1
a2046 1
      cygheap->user.token = create_token (usersid, pgrpsid);
@


1.205
log
@Use hMainProc where appropriate, throughout.
* environ.cc (spenv::retrieve): Add debugging statements.
* pinfo.cc (set_myself): Don't call strace.hello if already stracing.
* strace.cc (strace): Move NO_COPY keyword so that it will actually take
effect.
@
text
@d1001 1
a1001 1
  dst->st_rdev = src->st_rdev;
d1030 2
d1120 2
@


1.204
log
@* cygheap.h (cygheap_user::issetuid): New method.
* dtable.cc (dtable::vfork_child_dup): Use new method to determine if we are in
"setuid mode."
* fork.cc (fork_parent): Ditto.
* spawn.cc (spawn_guts): Ditto.
* syscalls.cc (seteuid32): Ditto.
(setegid32): Ditto.
* environ.cc (spenv::retrieve): (Suggested by Pierre Humblet) Do potential
recalculation of cygheap_user stuff when in setuid mode.  Return special value
when environment variable exists but should not be added.
(build_env): Don't add retrieved value to dstp if it is 'dont_add'.
@
text
@d1981 1
a1981 2
  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, &ptok))
d1989 2
a1990 2
  process_ok = verify_token(ptok, usersid, pgrpsid);
  debug_printf("Process token %sverified", process_ok?"":"not ");
d1993 3
a1995 2
      if (cygheap->user.token == INVALID_HANDLE_VALUE ||
	  !cygheap->user.impersonated)
a1999 1
      else cygheap->user.impersonated = FALSE;
d2009 3
a2011 1
      if (token_ok)
a2021 1
      else cygheap->user.token = INVALID_HANDLE_VALUE;
d2155 1
a2155 3
  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_ADJUST_DEFAULT,
			 &ptok))
@


1.203
log
@* cygheap.cc (cygheap_user::set_logsrv): Remove.
(cygheap_user::set_domain): Ditto.
* cygheap.h (cygheap_user::set_logsrv): Remove declaration.
(cygheap_user::set_domain): Ditto.
(cygheap_user::env_domain): Declare new method.
(cygheap_user::env_name): Ditto.
* environ.cc (spenvs): Add two environment variables.
* spawn.cc (spawn_guts): Call build_env after RevertToSelf.  Always set
ciresrv.mount_h.
(cygheap_user::ontherange): Recalculate homedrive/homepath if they are empty.
Use env_logsrv to get logon server.
(cygheap_user::env_logsrv): Calculate server name here rather than relying on
it having been previously calculated.
(cygheap_user::env_domain): Ditto for domain name.
(cygheap-user::env_name): New method.
* syscalls.cc (seteuid32): Do not get or set the environment.  Do not call
LookupAccountSid nor internal_getlogin.  Set cygheap->user name and sid from
the passwd entry.
* uinfo.cc (uinfo_init): Only call internal_getlogin when starting from a non
Cygwin process and use the values returned in user.
(internal_getlogin): Simplify to case where starting from a non Cygwin process.
Store return values in user and return void.  Do not set the Windows default
environment.
* dcrt0.cc (dll_crt0_1): Call uinfo_init only when needed.  Do not set
myself->uid nor reset user.sid.
* spawn.cc (spawn_guts): Get the sid from cygheap->user.  Always
RevertToSelf().  Don't set uid in impersonated case.
* cygheap.cc (cygheap_user::set_sid): Do not set orig_sig.
(cygheap_user::set_orig_sid): New.
* cygheap.h: Declare cygheap_user::set_sid.
* winsup.h: Add argument to uinfo_init().
@
text
@d2096 2
a2097 3
  if ( cygheap->user.token != INVALID_HANDLE_VALUE &&
       cygheap->user.impersonated &&
       !ImpersonateLoggedOnUser (cygheap->user.token))
d2146 1
a2146 2
  if (cygheap->user.token != INVALID_HANDLE_VALUE
      && cygheap->user.impersonated)
d2167 1
a2167 2
  if (cygheap->user.token != INVALID_HANDLE_VALUE
      && cygheap->user.impersonated
@


1.202
log
@* spawn.cc (spawn_guts): More hToken removal cleanup.
@
text
@a1945 2
extern struct passwd *internal_getlogin (cygheap_user &user);

a1958 6
  DWORD ulen = UNLEN + 1;
  DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  char orig_username[UNLEN + 1];
  char orig_domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  char username[UNLEN + 1];
  char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
d1963 1
a1963 1
  struct passwd * pw_new, * pw_cur;
a1978 6
  char *env;
  orig_username[0] = orig_domain[0] = '\0';
  if ((env = getenv ("USERNAME")))
    strlcpy (orig_username, env, sizeof(orig_username));
  if ((env = getenv ("USERDOMAIN")))
    strlcpy (orig_domain, env, sizeof(orig_domain));
a2053 10
  /* Lookup username and domain before impersonating,
     LookupAccountSid() returns a different answer afterwards. */
  SID_NAME_USE use;
  if (!LookupAccountSid (NULL, usersid, username, &ulen,
			 domain, &dlen, &use))
    {
      debug_printf ("LookupAccountSid (): %E");
      __seterrno ();
      goto failed;
    }
d2083 9
a2091 28
  /* user.token is used in internal_getlogin () to determine if
     impersonation is active. If so, the token is used for
     retrieving user's SID. */
  user.token = cygheap->user.impersonated ? cygheap->user.token
					  : INVALID_HANDLE_VALUE;
  /* Unsetting these two env vars is necessary to get NetUserGetInfo()
     called in internal_getlogin ().  Otherwise the wrong path is used
     after a user switch, probably. */
  unsetenv ("HOMEDRIVE");
  unsetenv ("HOMEPATH");
  setenv ("USERDOMAIN", domain, 1);
  setenv ("USERNAME", username, 1);
  pw_cur = internal_getlogin (user);
  if (pw_cur == pw_new)
    {
      /* If sav_token was internally created and is replaced, destroy it. */
      if (sav_token != INVALID_HANDLE_VALUE &&
	  sav_token != cygheap->user.token &&
	  sav_token_is_internal_token)
	CloseHandle (sav_token);
      myself->uid = uid;
      cygheap->user = user;
      return 0;
    }
  debug_printf ("Diffs!!! token: %d, cur: %d, new: %d, orig: %d",
		cygheap->user.token, pw_cur->pw_uid,
		pw_new->pw_uid, cygheap->user.orig_uid);
  set_errno (EPERM);
a2093 2
  setenv ("USERNAME", orig_username, 1);
  setenv ("USERDOMAIN", orig_domain, 1);
@


1.201
log
@	* fhandler.cc (fhandler_base::fstat): Initialise tv_nsec member of
	st_atim, st_mtim, and st_ctim fields.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* glob.c (stat32_to_STAT): Copy across the whole st_atim,
	st_mtime, and st_ctim fields.
	* syscalls.cc (stat64_to_stat32): Ditto.
	* times.cc (to_timestruc_t): New function.
	(time_as_timestruc_t): New function.
	* winsup.h: Add to_timestruc_t and time_as_timestruc_t functions.
	* include/cygwin/stat.h: Replace time_t with timestruc_t
	throughout for all file times, removing the st_spare1, st_spare2,
	and st_spare3 fields in the process. Add macros to access tv_sec
	fields by old names.
	* include/cygwin/types.h: Typedef timespec_t and timestruc_t as
	struct timespec.
@
text
@d1192 1
a1192 1
	  if (! (st.st_mode & S_IRUSR))
d1197 1
a1197 1
	  if (! (st.st_mode & S_IRGRP))
d1200 1
a1200 1
      else if (! (st.st_mode & S_IROTH))
d1207 1
a1207 1
	  if (! (st.st_mode & S_IWUSR))
d1212 1
a1212 1
	  if (! (st.st_mode & S_IWGRP))
d1215 1
a1215 1
      else if (! (st.st_mode & S_IWOTH))
d1222 1
a1222 1
	  if (! (st.st_mode & S_IXUSR))
d1227 1
a1227 1
	  if (! (st.st_mode & S_IXGRP))
d1230 1
a1230 1
      else if (! (st.st_mode & S_IXOTH))
d2009 1
a2009 1
	  ! cygheap->user.impersonated )
d2028 6
a2033 6
	  {
	    CloseHandle (ptok);
	    if (!ImpersonateLoggedOnUser (cygheap->user.token))
	      system_printf ("Impersonating in seteuid failed: %E");
	    return 0; /* No change */
	  }
d2079 1
a2079 1
  if (! process_ok )
@


1.200
log
@	* sec_helper.cc (lookup_name): Suppress.
	* security.cc (alloc_sd): Remove logsrv argument.
	Remove two calls to lookup_name.
	(set_security_attribute): Remove logsrv argument.
	Remove logsrv argument in call to alloc_sd.
	(set_nt_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_security_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_nt_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_file_attribute.
	* syscalls.cc (chown_worker): Remove logserver argument in
	call to set_file_attribute.
	(chmod): Ditto.
	* shm.cc (shmget): Remove logsrv argument in call to alloc_sd.
	* uinfo.cc (internal_getlogin): Replace calls to
	lookup_name by call to LookupAccountName.
	* security.h: Remove logsrv in declarations of set_file_attribute
	and alloc_sd. Remove declaration of lookup_name.
@
text
@d1003 3
a1005 3
  dst->st_atime = src->st_atime;
  dst->st_mtime = src->st_mtime;
  dst->st_ctime = src->st_ctime;
@


1.199
log
@* dir.cc (rmdir): Streamline.  Detect attempts to remove directories from
"read-only" virtual devices.  (Suggested by Pavel Tsekov)
* syscalls.cc (unlink): Detect attempts to remove directories from "read-only"
virtual devices.  (From Pavel Tsekov)
@
text
@d808 1
a808 1
				    gid, attrib, cygheap->user.logsrv ());
d936 1
a936 1
				mode, cygheap->user.logsrv ())
@


1.198
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d97 1
d105 7
@


1.197
log
@	* syscalls.cc (stat64_to_stat32): Transform st_dev correctly.
	(fstat64): Add evaluating st_ino and st_dev.
	(stat_worker): Evaluate st_dev as 32 bit value.
	* include/cygwin/stat.h: Use new dev_t definition throughout.
	* include/cygwin/types.h: Define __dev16_t and __dev32_t.  Define
	dev_t according to __CYGWIN_USE_BIG_TYPES__ setting.
	* include/sys/sysmacros.h: Define major, minor and makedev
	according to __CYGWIN_USE_BIG_TYPES__ setting.
@
text
@a13 1
#include <fcntl.h>
d1626 2
a1627 2
		 f->_flags & __SCLE ? "cle" : "raw",
		 setmode_mode & O_TEXT ? "cle" : "raw");
a1674 5
  else if (mode & O_BINARY)
    {
      cfd->set_w_binary (1);
      cfd->set_r_binary (1);
    }
d1676 1
a1676 4
    {
      cfd->set_w_binary (0);
      cfd->set_r_binary (0);
    }
d1685 2
a1686 3
  syscall_printf ("setmode (%d<%s>, %s) returns %s\n", fd, cfd->get_name (),
		  mode & O_TEXT ? "text" : "binary",
		  res & O_TEXT ? "text" : "binary");
@


1.196
log
@	* syscalls.cc (setegid32): Verify the correctness of the gid
	of the group returned by getgrgid32.
@
text
@d988 1
a988 1
  dst->st_dev = src->st_dev;
d1017 7
d1110 1
a1110 1
	    buf->st_dev = FHDEVN (fh->get_device ()) << 8 | (fh->get_unit () & 0xff);
@


1.195
log
@* fhandler.cc (fhandler_base::fstat): Move dev and ino calculation into caller.
* syscalls.cc (stat_worker): Calculate dev and ino calculation here, if zero.
* fhandler_proc.cc (fhandler_proc::fhandler_proc): Minor reorg for debugging.
* fhandler_process.cc (fhandler_process::exists): Return 0 on nonexistence.
(fhandler_process::fstat): Simplify pid logic.
* fhandler_tape.cc (fhandler_dev_tape::fstat): Minor reformatting.
@
text
@d2178 2
a2179 1
  if (!(gsid.getfromgr (getgrgid32 (gid))))
@


1.194
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@d1076 3
a1081 4
  MALLOC_CHECK;
  if (check_null_invalid_struct_errno (buf))
    goto done;

d1083 2
a1084 3
						(nofollow ?
						 PC_SYM_NOFOLLOW
						 : PC_SYM_FOLLOW)
d1086 1
d1096 1
a1096 1
      memset (buf, 0, sizeof (struct __stat64));
d1098 7
@


1.193
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@d753 1
a753 1
chown_worker (const char *name, unsigned fmode, __uid16_t uid, __gid32_t gid)
d756 1
a756 1
  __uid16_t old_uid;
d818 1
a818 1
chown32 (const char * name, __uid16_t uid, __gid32_t gid)
d828 1
a828 1
  return chown_worker (name, PC_SYM_FOLLOW, uid, (__gid32_t) gid);
d832 1
a832 1
lchown32 (const char * name, __uid16_t uid, __gid32_t gid)
d842 1
a842 1
  return chown_worker (name, PC_SYM_NOFOLLOW, uid, (__gid32_t) gid);
d846 1
a846 1
fchown32 (int fd, __uid16_t uid, __gid32_t gid)
d873 1
a873 1
  return fchown32 (fd, uid, (__gid32_t) gid);
d917 1
a917 1
      __uid16_t uid;
a1934 11
/* setuid: POSIX 4.2.2.1 */
extern "C" int
setuid (__uid16_t uid)
{
  int ret = seteuid (uid);
  if (!ret)
    cygheap->user.real_uid = myself->uid;
  debug_printf ("real: %d, effective: %d", cygheap->user.real_uid, myself->uid);
  return ret;
}

d1939 1
a1939 1
seteuid (__uid16_t uid)
d1966 1
a1966 1
  pw_new = getpwuid (uid);
d2137 23
d2212 1
a2212 1
  return setegid32 ((__gid32_t) gid);
d2228 1
a2228 1
  int ret = setegid32 ((__gid32_t) gid);
@


1.192
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d753 1
a753 1
chown_worker (const char *name, unsigned fmode, __uid16_t uid, __gid16_t gid)
d757 1
a757 1
  __gid16_t old_gid;
d818 7
d828 8
a835 1
  return chown_worker (name, PC_SYM_FOLLOW, uid, gid);
d842 1
a842 1
  return chown_worker (name, PC_SYM_NOFOLLOW, uid, gid);
d846 1
a846 1
fchown (int fd, __uid16_t uid, __gid16_t gid)
d870 6
d918 1
a918 1
      __gid16_t gid;
a1934 10
/* setgid: POSIX 4.2.2.1 */
extern "C" int
setgid (__gid16_t gid)
{
  int ret = setegid (gid);
  if (!ret)
    cygheap->user.real_gid = myself->gid;
  return ret;
}

d1979 1
a1979 1
      (!pgrpsid.getfromgr (getgrgid (myself->gid))))
d2150 1
a2150 1
setegid (__gid16_t gid)
d2160 1
a2160 1
  if (!(gsid.getfromgr (getgrgid (gid))))
d2195 25
@


1.191
log
@	* syscalls.cc (seteuid): Do not take allow_ntsec into account.
	Attempt to use an existing or new token even when the uid
	matches orig_uid, but the gid is not in the process token.
	Major reorganization after several incremental changes.
	(setegid): Do not take allow_ntsec into account. Minor
	reorganization after several incremental changes.
@
text
@d198 1
a198 1
          || delete_on_close_ok)
d994 1
d996 1
a996 1
      res = cfd->fstat (buf, NULL);
d1312 1
a1312 1
        attr &= ~FILE_ATTRIBUTE_HIDDEN;
d1315 1
a1315 1
        attr |= FILE_ATTRIBUTE_HIDDEN;
d1486 1
a1486 1
          return -1;
d2000 1
a2000 1
        {
d2015 1
a2015 1
        {
d2050 1
a2050 1
        {
d2074 1
a2074 1
        {
d2089 1
a2089 1
        {
d2101 1
a2101 1
                                          : INVALID_HANDLE_VALUE;
@


1.190
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d1941 8
d1950 19
a1968 1
  if (wincap.has_security ())
d1970 32
a2001 12
      char orig_username[UNLEN + 1];
      char orig_domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      char username[UNLEN + 1];
      DWORD ulen = UNLEN + 1;
      char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
      SID_NAME_USE use;

      if (uid == ILLEGAL_UID || uid == myself->uid)
	{
	  debug_printf ("new euid == current euid, nothing happens");
	  return 0;
d2003 20
a2022 5
      struct passwd *pw_new = getpwuid (uid);
      if (!pw_new)
	{
	  set_errno (EINVAL);
	  return -1;
d2024 2
d2027 13
a2039 2
      cygsid tok_usersid;
      DWORD siz;
d2041 7
a2047 32
      char *env;
      orig_username[0] = orig_domain[0] = '\0';
      if ((env = getenv ("USERNAME")))
	strncat (orig_username, env, UNLEN + 1);
      if ((env = getenv ("USERDOMAIN")))
	strncat (orig_domain, env, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      if (uid == cygheap->user.orig_uid)
	{

	  debug_printf ("RevertToSelf () (uid == orig_uid, token=%d)",
			cygheap->user.token);
	  RevertToSelf ();
	  if (cygheap->user.token != INVALID_HANDLE_VALUE)
	    cygheap->user.impersonated = FALSE;

	  HANDLE ptok = INVALID_HANDLE_VALUE;
	  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
	    debug_printf ("OpenProcessToken(): %E\n");
	  else if (!GetTokenInformation (ptok, TokenUser, &tok_usersid,
					 sizeof tok_usersid, &siz))
	    debug_printf ("GetTokenInformation(): %E");
	  else if (!LookupAccountSid (NULL, tok_usersid, username, &ulen,
				      domain, &dlen, &use))
	    debug_printf ("LookupAccountSid(): %E");
	  else
	    {
	      setenv ("USERNAME", username, 1);
	      setenv ("USERDOMAIN", domain, 1);
	    }
	  if (ptok != INVALID_HANDLE_VALUE)
	    CloseHandle (ptok);
	}
d2049 5
a2053 120
	{
	  cygsid usersid, pgrpsid, origsid;
	  HANDLE sav_token = INVALID_HANDLE_VALUE;
	  BOOL sav_impersonation;
	  BOOL current_token_is_internal_token = FALSE;
	  BOOL explicitely_created_token = FALSE;

	  struct __group16 *gr = getgrgid (myself->gid);
	  debug_printf ("myself->gid: %d, gr: %d", myself->gid, gr);

	  usersid.getfrompw (pw_new);
	  pgrpsid.getfromgr (gr);

	  /* Only when ntsec is ON! */
	  /* Check if new user == user of impersonation token and
	     - if reasonable - new pgrp == pgrp of impersonation token. */
	  if (allow_ntsec && cygheap->user.token != INVALID_HANDLE_VALUE)
	    {
	      if (!verify_token(cygheap->user.token, usersid, pgrpsid,
				& current_token_is_internal_token))
		{
		  /* If not, RevertToSelf and close old token. */
		  debug_printf ("tsid != usersid");
		  RevertToSelf ();
		  sav_token = cygheap->user.token;
		  sav_impersonation = cygheap->user.impersonated;
		  cygheap->user.token = INVALID_HANDLE_VALUE;
		  cygheap->user.impersonated = FALSE;
		}
	    }

	  /* Only when ntsec is ON! */
	  /* If no impersonation token is available, try to
	     authenticate using NtCreateToken() or subauthentication. */
	  if (allow_ntsec && cygheap->user.token == INVALID_HANDLE_VALUE)
	    {
	      HANDLE ptok = INVALID_HANDLE_VALUE;

	      ptok = create_token (usersid, pgrpsid);
	      if (ptok != INVALID_HANDLE_VALUE)
		explicitely_created_token = TRUE;
	      else
		{
		  /* create_token failed. Try subauthentication. */
		  debug_printf ("create token failed, try subauthentication.");
		  ptok = subauth (pw_new);
		}
	      if (ptok != INVALID_HANDLE_VALUE)
		{
		  cygwin_set_impersonation_token (ptok);
		  /* If sav_token was internally created, destroy it. */
		  if (sav_token != INVALID_HANDLE_VALUE &&
		      current_token_is_internal_token)
		    CloseHandle (sav_token);
		}
	      else if (sav_token != INVALID_HANDLE_VALUE)
		cygheap->user.token = sav_token;
	    }
	  /* If no impersonation is active but an impersonation
	     token is available, try to impersonate. */
	  if (cygheap->user.token != INVALID_HANDLE_VALUE &&
	      !cygheap->user.impersonated)
	    {
	      debug_printf ("Impersonate (uid == %d)", uid);
	      RevertToSelf ();

	      /* If the token was explicitely created, all information has
		 already been set correctly. */
	      if (!explicitely_created_token)
		{
		  /* Try setting owner to same value as user. */
		  if (usersid &&
		      !SetTokenInformation (cygheap->user.token, TokenOwner,
					    &usersid, sizeof usersid))
		    debug_printf ("SetTokenInformation(user.token, "
				  "TokenOwner): %E");
		  /* Try setting primary group in token to current group
		     if token not explicitely created. */
		  if (pgrpsid &&
		      !SetTokenInformation (cygheap->user.token,
					    TokenPrimaryGroup,
					    &pgrpsid, sizeof pgrpsid))
		    debug_printf ("SetTokenInformation(user.token, "
				  "TokenPrimaryGroup): %E");
		}
	      /* Set process def dacl to allow access to impersonated token */
	      char dacl_buf[MAX_DACL_LEN(5)];
	      origsid = cygheap->user.orig_sid ();
	      if (usersid && origsid &&
		  sec_acl((PACL) dacl_buf, FALSE, origsid, usersid))
	        {
		  HANDLE ptok = INVALID_HANDLE_VALUE;
		  TOKEN_DEFAULT_DACL tdacl;
		  tdacl.DefaultDacl = (PACL) dacl_buf;
		  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_DEFAULT,
					 &ptok))
		    debug_printf ("OpenProcessToken(): %E");
		  else
		    {
		      if (!SetTokenInformation (ptok, TokenDefaultDacl,
						&tdacl, sizeof dacl_buf))
			debug_printf ("SetTokenInformation"
				      "(TokenDefaultDacl): %E");
		    }
		  if (ptok != INVALID_HANDLE_VALUE) CloseHandle (ptok);
		}
	      /* Now try to impersonate. */
	      if (!LookupAccountSid (NULL, usersid, username, &ulen,
				     domain, &dlen, &use))
		debug_printf ("LookupAccountSid (): %E");
	      else if (!ImpersonateLoggedOnUser (cygheap->user.token))
		system_printf ("Impersonating (%d) in set(e)uid failed: %E",
			       cygheap->user.token);
	      else
		{
		  cygheap->user.impersonated = TRUE;
		  setenv ("USERNAME", username, 1);
		  setenv ("USERDOMAIN", domain, 1);
		}
	    }
d2055 1
d2057 35
a2091 21
      cygheap_user user;
      /* user.token is used in internal_getlogin () to determine if
	 impersonation is active. If so, the token is used for
	 retrieving user's SID. */
      user.token = cygheap->user.impersonated ? cygheap->user.token
					      : INVALID_HANDLE_VALUE;
      /* Unsetting these both env vars is necessary to get NetUserGetInfo()
	 called in internal_getlogin ().  Otherwise the wrong path is used
	 after a user switch, probably. */
      unsetenv ("HOMEDRIVE");
      unsetenv ("HOMEPATH");
      struct passwd *pw_cur = internal_getlogin (user);
      if (pw_cur != pw_new)
	{
	  debug_printf ("Diffs!!! token: %d, cur: %d, new: %d, orig: %d",
			cygheap->user.token, pw_cur->pw_uid,
			pw_new->pw_uid, cygheap->user.orig_uid);
	  setenv ("USERNAME", orig_username, 1);
	  setenv ("USERDOMAIN", orig_domain, 1);
	  set_errno (EPERM);
	  return -1;
d2093 23
d2118 1
d2120 15
a2134 4
  else
    set_errno (ENOSYS);
  debug_printf ("real: %d, effective: %d", cygheap->user.real_uid, myself->uid);
  return 0;
d2141 4
d2146 13
a2158 1
  if (wincap.has_security ())
d2160 6
a2165 46
      if (gid != ILLEGAL_GID)
	{
	  struct __group16 *gr;

	  if (!(gr = getgrgid (gid)))
	    {
	      set_errno (EINVAL);
	      return -1;
	    }
	  myself->gid = gid;
	  if (allow_ntsec)
	    {
	      cygsid gsid;
	      HANDLE ptok;

	      if (gsid.getfromgr (gr))
		{
		  /* Remove impersonation */
		  if (cygheap->user.token != INVALID_HANDLE_VALUE
		      && cygheap->user.impersonated)
		    {
		      if (!SetTokenInformation (cygheap->user.token,
						TokenPrimaryGroup,
						&gsid, sizeof gsid))
			debug_printf ("SetTokenInformation(primary, "
				      "TokenPrimaryGroup): %E");
		      RevertToSelf ();
		    }
		  if (!OpenProcessToken (GetCurrentProcess (),
					 TOKEN_ADJUST_DEFAULT,
					 &ptok))
		    debug_printf ("OpenProcessToken(): %E\n");
		  else
		    {
		      if (!SetTokenInformation (ptok, TokenPrimaryGroup,
						&gsid, sizeof gsid))
			debug_printf ("SetTokenInformation(process, "
				      "TokenPrimaryGroup): %E");
		      CloseHandle (ptok);
		    }
		  if (cygheap->user.token != INVALID_HANDLE_VALUE
		      && cygheap->user.impersonated)
		    ImpersonateLoggedOnUser (cygheap->user.token);
		}
	    }
	}
d2167 4
d2172 11
a2182 1
    set_errno (ENOSYS);
@


1.189
log
@* fhandler.h (fhandler_virtual::exists): Eliminate path argument.
(fhandler_proc::exists): Ditto.
(fhandler_registry::exists): Ditto.
(fhandler_process::exists): Ditto.
* fhandler_proc.cc (fhandler_proc::exists): Ditto.  Use built-in name.
* fhandler_process.cc (fhandler_process::exists): Ditto.
(fstat): Ditto.
* fhandler_registry.cc (fhandler_registry::exists): Ditto.
(fhandler_registry::fstat): Ditto.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* path.cc (path_conv::check): Ditto.  Add debugging.
* syscalls.cc (dup): Always call dup2 for error handling.
@
text
@a34 1
#include "sync.h"
@


1.188
log
@	* syscalls.cc (seteuid): Set default dacl in process token.
	Replace in-line code by call to verify_token().
	(setegid): Reverse change from 2002-01-21. Add call to
	RevertToSelf and set primary group in impersonation token.
	* security.cc (create_token): Store pgrpsid in token security
	descriptor, except if it already appears in my_grps.
	Use sec_acl() in place of get_dacl().
	(verify_token): Create from code in seteuid(), with tighter checks.
	(get_dacl) Deleted.
	(get_group_sidlist): Add argument to indicate if pgrpsid is already
	in the groups.
	* security.h: Define verify_token().
	* autoload.cc: Load GetKernelObjectSecurity().
@
text
@d86 1
a86 9
  int res;
  cygheap_fdnew newfd;

  if (newfd < 0)
    res = -1;
  else
    res = dup2 (fd, newfd);

  return res;
@


1.187
log
@* syscalls.cc (_read): Change error to EBADF if attempt to write to a
non-writable fd.
@
text
@d2010 1
a2010 1
	  cygsid usersid, pgrpsid, tok_pgrpsid;
d2027 2
a2028 25
	      if (!GetTokenInformation (cygheap->user.token, TokenUser,
					&tok_usersid, sizeof tok_usersid, &siz))
		{
		  debug_printf ("GetTokenInformation(): %E");
		  tok_usersid = NO_SID;
		}
	      if (!GetTokenInformation (cygheap->user.token, TokenPrimaryGroup,
					&tok_pgrpsid, sizeof tok_pgrpsid, &siz))
		{
		  debug_printf ("GetTokenInformation(): %E");
		  tok_pgrpsid = NO_SID;
		}
	      /* Check if the current user token was internally created. */
	      TOKEN_SOURCE ts;
	      if (!GetTokenInformation (cygheap->user.token, TokenSource,
					&ts, sizeof ts, &siz))
		debug_printf ("GetTokenInformation(): %E");
	      else if (!memcmp (ts.SourceName, "Cygwin.1", 8))
		current_token_is_internal_token = TRUE;
	      if ((usersid && tok_usersid && usersid != tok_usersid) ||
		  /* Check for pgrp only if current token is an internal
		     token. Otherwise the external provided token is
		     very likely overwritten here. */
		  (current_token_is_internal_token &&
		   pgrpsid && tok_pgrpsid && pgrpsid != tok_pgrpsid))
a2092 1

d2094 21
a2114 1

a2178 1
#if 0	  // Setting the primary group in token here isn't foolproof enough.
d2186 11
d2205 1
a2205 1
			debug_printf ("SetTokenInformation(myself, "
d2209 3
a2213 1
#endif
@


1.186
log
@* syscalls.cc (_write): Change error to EBADF if attempt to write to a
non-writable fd.
@
text
@d343 8
@


1.185
log
@* path.h (pathconv_arg): Add PC_POSIX.
(path_conv): Add normalized_path field.
* path.cc (path_conv::~path_conv): New destructor.
(path_conv::check): Set normalized_path, where appropriate.
* dtable.cc (build_fhandler_from_name): Use normalized path from path_conv.
* syscalls.cc (chroot): Ditto.
* cygheap.h: Remove path_prefix_p declaration.  Christopher Faylor
<cgf@@redhat.com> (minor fixups)
* Makefile.in: Add fhandler_proc.o, fhandler_registry.o, fhandler_process.o and
fhandler_virtual.o.
* dtable.cc (dtable::build_fhandler): Add entries for FH_PROC, FH_REGISTRY and
FH_PROCESS.  Set unix_name to the normalized posix path.
* fhandler.h: Add constants for FH_PROC, FH_REGISTRY and FH_PROCESS.  Add class
declarations for fhandler_virtual, fhandler_proc, fhandler_registry and
fhandler_virtual.  Update fhandler_union accordingly.
* fhandler_proc.cc: New file.  Add implementation for fhandler_proc.
* fhandler_virtual.cc: New file.  Add implementation for fhandler_virtual.
* fhandler_process.cc: New file.  Add implementation for fhandler_process.
* fhandler_registry.cc: New file.  Add implementation for fhandler_registry.
* path.cc: Add isproc and isvirtual_dev macros.
* path.cc (path_conv::check): Add check for virtual devices.
* path.cc (mount_info::conv_to_win32_path): Convert paths in /proc to empty
Win32 paths.
* path.cc (chdir): Replace check for FH_CYGDRIVE with more generic
isvirtual_dev macro.  Force setting of posix path for virtual fhandlers.
* path.h: Add externally visible path_prefix_p and normalized_posix_path
prototypes.
@
text
@d387 3
@


1.184
log
@	* syscalls.cc (truncate64): Use ftruncate64 directly to not lose
	upper 32 bits.
@
text
@a41 2
extern int normalize_posix_path (const char *, char *);

d2208 1
a2208 1
  path_conv path (newroot, PC_SYM_FOLLOW | PC_FULL);
d2225 1
a2225 3
      char buf[MAX_PATH];
      normalize_posix_path (newroot, buf);
      cygheap->root.set (buf, path);
@


1.183
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d1723 1
a1723 1
      res = ftruncate (fd, length);
@


1.182
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d530 2
a531 2
extern "C" __off32_t
_lseek (int fd, __off32_t pos, int dir)
d533 1
a533 1
  __off32_t res;
d549 1
a549 1
  syscall_printf ("%d = lseek (%d, %d, %d)", res, fd, pos, dir);
d554 6
d965 18
d984 1
a984 1
_fstat (int fd, struct stat *buf)
d994 1
a994 1
      memset (buf, 0, sizeof (struct stat));
d1002 10
d1048 2
a1049 1
stat_worker (const char *name, struct stat *buf, int nofollow, path_conv *pc)
d1076 1
a1076 1
      memset (buf, 0, sizeof (struct stat));
d1089 1
a1089 1
_stat (const char *name, struct stat *buf)
d1096 10
d1108 1
a1108 1
lstat (const char *name, struct stat *buf)
d1115 11
d1142 1
a1142 1
  struct stat st;
a1665 1
/* ftruncate: P96 5.6.7.1 */
d1667 1
a1667 1
ftruncate (int fd, __off32_t length)
d1684 1
a1684 1
	      __off32_t prev_loc = cfd->lseek (0, SEEK_CUR);
d1693 1
a1693 1
	      cfd->lseek (prev_loc, 0);
d1702 7
d1711 1
a1711 1
truncate (const char *pathname, __off32_t length)
d1731 7
d2449 1
@


1.181
log
@	* grp.cc (getgrent): Don't return default gid entry when ntsec is on.
	* syscalls.cc (setegid): Don't set primary group in process token.
@
text
@d530 2
a531 2
extern "C" off_t
_lseek (int fd, off_t pos, int dir)
d533 1
a533 1
  off_t res;
d747 1
a747 1
chown_worker (const char *name, unsigned fmode, uid_t uid, gid_t gid)
d750 2
a751 2
  uid_t old_uid;
  gid_t old_gid;
d788 1
a788 1
	  if (uid == (uid_t) -1)
d790 1
a790 1
	  if (gid == (gid_t) -1)
d812 1
a812 1
chown (const char * name, uid_t uid, gid_t gid)
d819 1
a819 1
lchown (const char * name, uid_t uid, gid_t gid)
d826 1
a826 1
fchown (int fd, uid_t uid, gid_t gid)
d891 2
a892 2
      uid_t uid;
      gid_t gid;
d1612 1
a1612 1
ftruncate (int fd, off_t length)
d1629 1
a1629 1
	      off_t prev_loc = cfd->lseek (0, SEEK_CUR);
d1649 1
a1649 1
truncate (const char *pathname, off_t length)
d1847 1
a1847 1
setgid (gid_t gid)
d1857 1
a1857 1
setuid (uid_t uid)
d1870 1
a1870 1
seteuid (uid_t uid)
d1883 1
a1883 1
      if (uid == (uid_t) -1 || uid == myself->uid)
d1938 1
a1938 1
	  struct group *gr = getgrgid (myself->gid);
d2090 1
a2090 1
setegid (gid_t gid)
d2095 1
a2095 1
      if (gid != (gid_t) -1)
d2097 1
a2097 1
	  struct group *gr;
d2380 1
a2380 1
      off_t pos = 0;		/* Position in file */
@


1.180
log
@* syscalls.cc (regfree): Make dll_export.
@
text
@d2105 1
d2127 1
@


1.179
log
@	* dir.cc: Use INVALID_FILE_ATTRIBUTES instead of "(DWORD) -1"
	for file attributes throughout.
	* fhandler.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* syscalls.cc: Ditto.
	* times.cc (utimes): Use path_conv::isdir() instead of explicit
	GetFileAttributes() call.
@
text
@d1819 1
a1819 1
extern "C" int
@


1.178
log
@Add copyright stuff
@
text
@d208 2
a209 1
      if (GetFileAttributes (win32_name) == (DWORD) -1 || delete_on_close_ok)
@


1.177
log
@	* syscalls.cc (pathconf): Guard _PC_PATH_MAX branch against invalid
	file parameter.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.176
log
@	* cygwin.din: Add symbols for endutent(), getutent(), getutid(),
	getutline(), setutent() and utmpname().
	* syscalls.cc (setutent): New function.
	(endutent): Ditto.
	(utmpname): Ditto.
	(getutent): Ditto.
	(getutid): Ditto.
	(getutline): Ditto.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d1427 2
@


1.175
log
@* exceptions.cc: Add stdlib.h include for alloca declaration.
* poll.cc: Ditto.
* termios.cc: Ditto.
* syscalls.cc (_write): Only allow zero length when fd is valid.
@
text
@d2410 98
@


1.174
log
@* syscalls.cc (_write): Allow zero length as per SUSv2.
@
text
@a357 6
  if (len == 0)
    return 0;

  if (__check_invalid_read_ptr_errno (ptr, len))
    return -1;

d363 10
@


1.173
log
@	* dir.cc (mkdir): Add HIDDEN file attribute if file has leading dot
	and HIDDEN_DOT_FILES is defined.
	* fhandler.cc (fhandler_base::open): Ditto.
	* path.cc (symlink): Ditto.
	* syscalls.cc (_rename): Ditto and remove HIDDEN file attribute if
	new filename does not begin with a dot.
@
text
@d358 3
@


1.172
log
@	* select.cc: Set errno using set_sig_errno() throughout.
	* signal.cc (signal): Always set SA_RESTART flag.
	* syscalls.cc (_read): Revert previous patch.
@
text
@d1243 10
a1252 1
      SetFileAttributes (real_new, real_old);
@


1.172.4.1
log
@* syscalls.cc (_write): Allow zero length as per SUSv2.
@
text
@a357 3
  if (len == 0)
    return 0;

@


1.171
log
@	* select.cc (fhandler_tty_slave::ready_for_read):  Return 0 on EBADF.
	* syscalls.cc (_read): If ready_for_read() failed, save errno from
	being overwritten by signal handler call.
@
text
@a316 1
	  set_sig_errno (get_errno ());
@


1.170
log
@Eliminate excess whitespace.
@
text
@d317 1
@


1.169
log
@* fhandler.h (fhandler_base::ready_for_read): Remove unused argument.
(fhandler_tty_slave::ready_for_read): Ditto.
(select_record): Remove poll, initialize peek.
* select.cc: Remove all poll functions, throughout.  Change second argument of
peek_* functions to 'bool' throughout.  Specifically initialize *_ready
variables throughout.
(select_stuff::poll): Subsume previous poll functionality.
(peek_pipe): Don't grab guard mutex when in select loop.  select()/read() is
racy by design so there is no need to worry about a race in select().
(fhandler_base::ready_for_read): Remove unused argument.
(fhandler_tty_slave::ready_for_read): Ditto.
* syscalls.cc (_read): Eliminate third argument in ready_for_read call.
@
text
@d190 1
a190 1
  			&& wincap.has_delete_on_close ();
d322 1
a322 1
         ensure that an fd, closed in another thread, aborts I/O
d350 1
a350 1
      		  get_errno ());
d506 1
a506 1
		  					      NULL, pc)))
d579 1
a579 1
  else 
d787 1
a787 1
	      			    gid, attrib, cygheap->user.logsrv ());
d1032 1
a1032 1
	  	    pc, (DWORD) real_path);
d2045 1
a2045 1
         called in internal_getlogin ().  Otherwise the wrong path is used
@


1.168
log
@* dll_init.h (class dll_list): Reorder functions to avoid compiler "can't
inline" warnings.
* security.h (class cygsid): Ditto.
* sigproc.cc (get_proc_lock): Ditto.
* sigproc.h (class sigframe): Ditto.
* sync.h (class muto): Ditto.
* fhandler.h (fhandler_base::get_guard): Actually MAKE virtual as previously
indicated.
* pipe.cc (make_pipe): Remove extraneous set_errno.
* syscalls.cc (_open): Ditto.
* select.cc (peek_pipe): Need to check that there is still something to read
from the pipe after acquiring the mutex since another process/thread could have
eaten the input before we got to acquiring the lock.  (Thanks to Nick Duffek
for this inspiration.)
@
text
@d315 1
a315 1
      else if (!cfd->ready_for_read (fd, wait, 0))
@


1.167
log
@* cygheap.h (cygheap_fdmanip::isopen): Set appropriate errno if fd not open.
* select.cc (fhandler_base::ready_for_read): Release an open guard mutex when
exiting with an error condition.
* syscalls.cc (_read): Check frequently for closed fd as a kludge until
something better is invented.
@
text
@d502 1
a502 3
      if (fd < 0)
	set_errno (ENMFILE);
      else
@


1.166
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d313 1
a313 1
      if (wait && (/*!sigcatchers || */!cfd->is_slow () || cfd->get_r_no_interrupt ()))
d321 3
d330 4
d337 2
@


1.165
log
@* cygheap.h (cygheap_fdmanip::cygheap_fdmanip): Clear fh.
(cygheap_fdmanip::isopen): New method.
* syscalls.cc (_read): Avoid accessing closed fd.
* path.h (fe_types): New enum.
(path_conv::set_path): New method.
(find_exec): Change null_if_not_found argument to something more generic.
* spawn.cc (find_exec): Default to returning the POSIX path rather than the
windows path, unless instructed otherwise.
(spawn_guts): Force call to find_exec to use native paths.
* dlfcn.cc (check_path_access): Accommodate new find_exec arguments.
* environ.h (win_env::get_posix): New method.
@
text
@a316 4
	  if (!wait)
	    set_sig_errno (EAGAIN);	/* Don't really need 'set_sig_errno' here, but... */
	  else
	    set_sig_errno (EINTR);
@


1.164
log
@* dtable.cc (dtable::dup2): Add some debugging.  Use methods from passed in
class rather than cygheap->fdtab.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Add more
debugging output.
(fhandler_socket::dup): Allocate new space for prot_info_ptr for duplicated
entry.
* syscalls.cc (stat_worker): Always delete fh if it has been created.
@
text
@d325 3
@


1.163
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@a1028 1
      delete fh;
d1032 2
@


1.162
log
@	Patch suggested by Ian Ray <ian.ray@@nokia.com>:
	* syscalls.cc (seteuid): Unset environment variables HOMEDRIVE and
	HOMEPATH before calling internal_getlogin().
	* uinfo.cc (internal_getlogin): Use default HOMEPATH and HOMEDRIVE
	from environment if both are present, else query NetUserGetInfo().
@
text
@d290 3
@


1.161
log
@* miscfuncs.cc (+__check_invalid_read_ptr_errno): New function.
* syscalls.c (_write): Validate that write buffer is accessible for reading,
not writing.
* winsup.h: Declare new function, increase regparmization of check_* functions.
@
text
@d2034 5
@


1.160
log
@* syscalls.cc (_read): Validate input pointer.
(_write): Ditto.
(system): Ditto.
@
text
@d347 1
a347 1
  if (__check_null_invalid_struct_errno (ptr, len))
@


1.159
log
@* cygerrno.h (set_errno): Define more informative version of this function for
debugging.
(__set_errno): Declare when DEBUGGING.
* cygheap.h (cygheap_fdget::cygheap_fdget): Add a flag to control when errno is
set.
* debug.cc (__set_errno): New function.
* fcntl.cc (_fcntl): Fix so that correct fd is used for second argument to
dup2.
* syscalls.cc (_cygwin_istext_for_stdio): Don't set errno here when using
cygheap_fdget.
@
text
@d290 3
d347 3
d351 1
a352 1

d1254 3
@


1.158
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d1464 1
a1464 1
  cygheap_fdget cfd (fd);
@


1.157
log
@* autoload.cc (load_wsock32): Declare dummy function to force loading of
winsock.
* fhandler.cc (fhandler_base::set_inheritance): Make debugging output more
verbose.
* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Force loading of
winsock32 if winsock2 not available.
* net.cc (set_socket_inheritance): Use DuplicateHandle in all cases to set
inheritance correctly.
(fdsock): Use winsock2_active macro to determine when to set socket
inheritance.  Remove fdtab resource locking since this function should already
be protected.
(cygwin_accept): Simplify logic.  Ensure that fdtab unlock is not called
inappropriately.
(cygwin_rcmd): Use fdtab locking.
(cygwin_rresvport): Ditto.
(cygwin_rexec): Ditto.
* select.cc (peek_socket): Set errno appropriately if winsock select fails.
* winsup.h: Declare check_pty_fds.
* syscalls.cc (check_pty_fds): Rename from check_ttys_fds.  Also check pty
master.
(setsid): Use check_pty_fds.
* dtable.cc (dtable::dec_console_fds): Add check on pty fds.
@
text
@d76 1
a76 1
	(fh->get_device() == FH_TTYS || fh->get_device() == FH_PTYM))
d89 1
a89 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
d91 4
a94 3
  res = dup2 (fd, cygheap->fdtab.find_unused_handle ());

  ReleaseResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");
a290 1
  fhandler_base *fh;
d298 3
a300 5
      if (cygheap->fdtab.not_open (fd))
	{
	  set_errno (EBADF);
	  return -1;
	}
d302 1
a302 3
      // set_sig_errno (0);
      fh = cygheap->fdtab[fd];
      DWORD wait = fh->is_nonblocking () ? 0 : INFINITE;
d307 1
a307 1
      if (wait && (/*!sigcatchers || */!fh->is_slow () || fh->get_r_no_interrupt ()))
d309 1
a309 1
      else if (!fh->ready_for_read (fd, wait, 0))
d321 1
a321 1
      res = fh->bg_check (SIGTTIN);
d325 1
a325 1
	  res = fh->read (ptr, len);
d335 2
a336 2
  syscall_printf ("%d = read (%d<%s>, %p, %d), bin %d, errno %d", res, fd, fh->get_name (),
		  ptr, len, fh->get_r_binary (), get_errno ());
d347 3
a349 5
  if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
      goto done;
    }
d357 1
a357 4
  fhandler_base *fh;
  fh = cygheap->fdtab[fd];

  res = fh->bg_check (SIGTTOU);
d362 1
a362 1
      res = fh->write (ptr, len);
d372 1
a372 1
  return (ssize_t)res;
a468 1
  int fd;
a471 1
  fhandler_base *fh;
a476 2
      SetResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, " open ");

d482 2
a483 1
      fd = cygheap->fdtab.find_unused_handle ();
d495 1
a495 1
	      cygheap->fdtab.release (fd);
a500 1
      ReleaseResourceLock (LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," open");
a517 5
  else if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
      res = -1;
    }
d520 5
a524 1
      res = cygheap->fdtab[fd]->lseek (pos, dir);
d540 3
a542 6
  if (cygheap->fdtab.not_open (fd))
    {
      debug_printf ("handle %d not open", fd);
      set_errno (EBADF);
      res = -1;
    }
d545 3
a547 4
      SetResourceLock (LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
      res = cygheap->fdtab[fd]->close ();
      cygheap->fdtab.release (fd);
      ReleaseResourceLock (LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
d561 5
a565 7
  if (cygheap->fdtab.not_open (fd))
    {
      syscall_printf ("0 = isatty (%d)", fd);
      return 0;
    }

  res = cygheap->fdtab[fd]->is_tty ();
d806 2
a807 1
  if (cygheap->fdtab.not_open (fd))
a809 1
      set_errno (EBADF);
d813 1
a813 1
  const char *path = cygheap->fdtab[fd]->get_name ();
d915 2
a916 1
  if (cygheap->fdtab.not_open (fd))
a918 1
      set_errno (EBADF);
d922 1
a922 1
  const char *path = cygheap->fdtab[fd]->get_name ();
d939 1
a939 1
  int r;
d942 3
a944 6
  if (cygheap->fdtab.not_open (fd))
    {
      syscall_printf ("-1 = fstat (%d, %p)", fd, buf);
      set_errno (EBADF);
      r = -1;
    }
d948 1
a948 2
      r = cygheap->fdtab[fd]->fstat (buf, NULL);
      syscall_printf ("%d = fstat (%d, %x)", r, fd, buf);
d951 2
a952 1
  return r;
d960 2
a961 1
  if (cygheap->fdtab.not_open (fd))
a963 1
      set_errno (EBADF);
d967 1
a967 3
  HANDLE h = cygheap->fdtab[fd]->get_handle ();

  if (FlushFileBuffers (h) == 0)
d1342 3
a1344 5
  if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
      return -1;
    }
d1367 1
a1367 1
      if (isatty (fd))
d1376 4
a1379 7
      {
	fhandler_base *fh = cygheap->fdtab[fd];
	if (fh->get_device () == FH_DISK)
	  return check_posix_perm (fh->get_win32_name (), v);
	set_errno (EINVAL);
	return -1;
      }
d1432 2
a1433 1
  if (cygheap->fdtab.not_open (fd) || !cygheap->fdtab[fd]->is_tty ())
d1437 1
a1437 1
  return (char *) (cygheap->fdtab[fd]->ttyname ());
d1464 2
a1465 1
  if (cygheap->fdtab.not_open (fd))
d1471 1
a1471 3
  fhandler_base *p = cygheap->fdtab[fd];

  if (p->get_device () != FH_DISK)
d1477 1
a1477 1
  if (p->get_w_binary () || p->get_r_binary ())
d1511 3
a1513 5
  if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
      return -1;
    }
d1515 1
a1515 1
  return cygheap->fdtab[fd]->get_flags () & (O_BINARY | O_TEXT);
d1524 3
a1526 5
  if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
      return -1;
    }
a1532 2
  fhandler_base *p = cygheap->fdtab[fd];

d1539 1
a1539 1
  if (p->get_w_binary () && p->get_r_binary ())
d1541 1
a1541 1
  else if (p->get_w_binset () && p->get_r_binset ())
d1547 1
a1547 1
    p->reset_to_open_binmode ();
d1550 2
a1551 2
      p->set_w_binary (1);
      p->set_r_binary (1);
d1555 2
a1556 2
      p->set_w_binary (0);
      p->set_r_binary (0);
d1566 1
a1566 1
  syscall_printf ("setmode (%d<%s>, %s) returns %s\n", fd, p->get_name (),
d1580 1
a1580 7
    {
      set_errno (EINVAL);
    }
  else if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
    }
d1583 2
a1584 4
      HANDLE h = cygheap->fdtab[fd]->get_handle ();
      off_t prev_loc;

      if (h)
d1586 1
a1586 2
	  /* remember curr file pointer location */
	  prev_loc = cygheap->fdtab[fd]->lseek (0, SEEK_CUR);
d1588 1
a1588 2
	  cygheap->fdtab[fd]->lseek (length, SEEK_SET);
	  if (!SetEndOfFile (h))
d1590 11
a1600 1
	      __seterrno ();
a1601 5
	  else
	    res = 0;

	  /* restore original file pointer location */
	  cygheap->fdtab[fd]->lseek (prev_loc, 0);
d1604 1
a1605 1

d1634 1
a1634 1
  long res = -1;
d1636 3
a1638 2
  if (cygheap->fdtab.not_open (fd))
    set_errno (EBADF);
d1640 1
a1640 1
    res = (long) cygheap->fdtab[fd]->get_handle ();
d1691 4
a1694 7
  if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
      return -1;
    }
  fhandler_disk_file *f = (fhandler_disk_file *) cygheap->fdtab[fd];
  return statfs (f->get_name (), sfs);
d1774 4
a1777 6
  if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EBADF);
      return 0;
    }
  return (char *) (cygheap->fdtab[fd]->ptsname ());
@


1.156
log
@* path.cc (normalize_posix_path): Don't eat a '.' after a '\\' since it has
special meaning on NT.
* syscalls.cc (access): Use stat_worker.
@
text
@d68 2
a69 2
static BOOL __stdcall
check_ttys_fds (void)
d72 1
a72 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "close_all_files");
d75 2
a76 1
    if ((fh = cygheap->fdtab[i]) != NULL && fh->get_device() == FH_TTYS)
d81 1
a81 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "close_all_files");
d274 1
a274 1
	  !check_ttys_fds ())
@


1.155
log
@Add second path_conv * argument to fstat()s throughout.
* fhandler.h: Change read and fstat to regparm/stdcall throughout.
(fhandler_base::fstat): Just declare.  Don't define.
(fhandler_disk_file::fstat_helper): Declare.
* fhandler.cc (fhandler_base::fstat): Move here from fhandler.h, adapt from
former stat_dev().
(fhandler_disk_file::fstat): Move most of the disk-file-specific logic from
stat_worker to here.  Use fstat_helper to derive final fstat output.
(fhandler_disk_file::fstat_helper): New method, renamed from former fstat
method.
(num_entries): Moved here from syscalls.cc.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Use base class to initialize most
stuff.  Invert has_physical_mem_access test for establishing permissions.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Eliminate unneed test and memory
clearing.  Use base class to initialize most stuff.
* syscalls.cc (stat_dev): Eliminate.
(stat_worker): Simply call fstat method to generate fstat output.  Move all
device specific code to appropriate fstats.
* dir.cc (opendir): Pass correct arg to stat_worker to allow following
symlinks.
@
text
@d1077 1
a1077 1
  if (flags & ~ (F_OK|R_OK|W_OK|X_OK))
d1087 1
a1087 1
  int r = stat (fn, &st);
@


1.154
log
@* syscalls.cc (stat_worker): Make global.  Accept path_conv parameter for
passing information back to caller.
* winsup.h: Declare stat_worker.
* dir.cc (opendir): Use stat_worker rather than stat and pass path_conv
parameter to stat_worker for later inspection.
* syslog.cc (syslog): Teach syslog about syslog priorities other than LOG_ERR,
LOG_WARNING and LOG_INFO
* path.cc (path_conv::check): Don't perform file system or rootdir checks on
devices.
@
text
@a954 30
/* Cygwin internal */
static int
num_entries (const char *win32_name)
{
  WIN32_FIND_DATA buf;
  HANDLE handle;
  char buf1[MAX_PATH];
  int count = 0;

  strcpy (buf1, win32_name);
  int len = strlen (buf1);
  if (len == 0 || isdirsep (buf1[len - 1]))
    strcat (buf1, "*");
  else
    strcat (buf1, "/*");	/* */

  handle = FindFirstFileA (buf1, &buf);

  if (handle == INVALID_HANDLE_VALUE)
    return 0;
  count ++;
  while (FindNextFileA (handle, &buf))
    {
      if ((buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	count ++;
    }
  FindClose (handle);
  return count;
}

d970 1
a970 1
      r = cygheap->fdtab[fd]->fstat (buf);
a1005 26
int __stdcall
stat_dev (DWORD devn, int unit, unsigned long ino, struct stat *buf)
{
  sigframe thisframe (mainthread);
  switch (devn)
    {
    case FH_PIPEW:
      buf->st_mode = STD_WBITS | S_IWGRP | S_IWOTH;
      break;
    case FH_PIPER:
      buf->st_mode = STD_RBITS;
      break;
    default:
      buf->st_mode = STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
      break;
    }

  buf->st_mode |= devn == FH_FLOPPY ? S_IFBLK : S_IFCHR;
  buf->st_blksize = S_BLKSIZE;
  buf->st_nlink = 1;
  buf->st_dev = buf->st_rdev = FHDEVN (devn) << 8 | (unit & 0xff);
  buf->st_ino = ino;
  buf->st_atime = buf->st_mtime = buf->st_ctime = time (NULL);
  return 0;
}

a1017 3
  int oret;
  uid_t uid;
  gid_t gid;
d1023 1
a1024 3
  int open_flags = O_RDONLY | O_BINARY | O_DIROPEN
    		   | (nofollow ? O_NOSYMLINK : 0);

d1035 1
a1036 1
      goto done;
a1037 14

  debug_printf ("(%s, %p, %d, %p)", name, buf, nofollow, pc);

  memset (buf, 0, sizeof (struct stat));

  if (pc->is_device ())
    return stat_dev (pc->get_devn (), pc->get_unitn (),
		     hash_path_name (0, pc->get_win32 ()), buf);

  debug_printf ("%d = file_attributes for '%s'", (DWORD) real_path,
		(char *) real_path);

  if ((oret = fh->open (pc, open_flags, 0)))
    /* ok */;
d1040 5
a1044 80
      int ntsec_atts = 0;
      /* If we couldn't open the file, try a "query open" with no permissions.
	 This will allow us to determine *some* things about the file, at least. */
      fh->set_query_open (TRUE);
      if ((oret = fh->open (pc, open_flags, 0)))
        /* ok */;
      else if (allow_ntsec && pc->has_acls () && get_errno () == EACCES
		&& !get_file_attribute (TRUE, real_path, &ntsec_atts, &uid, &gid)
		&& !ntsec_atts && uid == myself->uid && gid == myself->gid)
        {
	  /* Check a special case here. If ntsec is ON it happens
	     that a process creates a file using mode 000 to disallow
	     other processes access. In contrast to UNIX, this results
	     in a failing open call in the same process. Check that
	     case. */
	  set_file_attribute (TRUE, real_path, 0400);
	  oret = fh->open (pc, open_flags, 0);
	  set_file_attribute (TRUE, real_path, ntsec_atts);
        }
    }
  if (oret)
    {
      res = fh->fstat (buf);
      /* The number of links to a directory includes the
	 number of subdirectories in the directory, since all
	 those subdirectories point to it.
	 This is too slow on remote drives, so we do without it and
	 set the number of links to 2. */
      /* Unfortunately the count of 2 confuses `find (1)' command. So
	 let's try it with `1' as link count. */
      if (pc->isdir ())
	buf->st_nlink = (pc->isremote ()
			 ? 1 : num_entries (pc->get_win32 ()));
      fh->close ();
    }
  else if (pc->exists ())
    {
      /* Unfortunately, the above open may fail if the file exists, though.
	 So we have to care for this case here, too. */
      WIN32_FIND_DATA wfd;
      HANDLE handle;
      buf->st_nlink = 1;
      if (pc->isdir () && pc->isremote ())
	buf->st_nlink = num_entries (pc->get_win32 ());
      buf->st_dev = FHDEVN (FH_DISK) << 8;
      buf->st_ino = hash_path_name (0, pc->get_win32 ());
      if (pc->isdir ())
	buf->st_mode = S_IFDIR;
      else if (pc->issymlink ())
	buf->st_mode = S_IFLNK;
      else if (pc->issocket ())
	buf->st_mode = S_IFSOCK;
      else
	buf->st_mode = S_IFREG;
      if (!pc->has_acls ()
	  || get_file_attribute (TRUE, pc->get_win32 (),
				 &buf->st_mode,
				 &buf->st_uid, &buf->st_gid))
	{
	  buf->st_mode |= STD_RBITS | STD_XBITS;
	  if (!(pc->has_attribute (FILE_ATTRIBUTE_READONLY)))
	    buf->st_mode |= STD_WBITS;
	  if (pc->issymlink ())
	    buf->st_mode |= S_IRWXU | S_IRWXG | S_IRWXO;
	  get_file_attribute (FALSE, pc->get_win32 (),
			      NULL, &buf->st_uid, &buf->st_gid);
	}
      if ((handle = FindFirstFile (pc->get_win32 (), &wfd))
	  != INVALID_HANDLE_VALUE)
	{
	  buf->st_atime   = to_time_t (&wfd.ftLastAccessTime);
	  buf->st_mtime   = to_time_t (&wfd.ftLastWriteTime);
	  buf->st_ctime   = to_time_t (&wfd.ftCreationTime);
	  buf->st_size    = wfd.nFileSizeLow;
	  buf->st_blksize = S_BLKSIZE;
	  buf->st_blocks  = ((unsigned long) buf->st_size +
			    S_BLKSIZE-1) / S_BLKSIZE;
	  FindClose (handle);
	}
      res = 0;
a1047 2
  if (fh)
    delete fh;
@


1.153
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d1070 2
a1071 3
static int
stat_worker (const char *caller, const char *name, struct stat *buf,
	     int nofollow)
d1080 2
a1085 2
  debug_printf ("%s (%s, %p)", caller, name, buf);

d1089 1
a1089 1
  fh = cygheap->fdtab.build_fhandler_from_name (-1, name, NULL, real_path,
d1094 1
a1094 1
  if (real_path.error)
d1096 1
a1096 1
      set_errno (real_path.error);
d1100 2
d1104 3
a1106 3
  if (real_path.is_device ())
    return stat_dev (real_path.get_devn (), real_path.get_unitn (),
		     hash_path_name (0, real_path.get_win32 ()), buf);
d1111 1
a1111 1
  if ((oret = fh->open (&real_path, open_flags, 0)))
d1119 1
a1119 1
      if ((oret = fh->open (&real_path, open_flags, 0)))
d1121 1
a1121 1
      else if (allow_ntsec && real_path.has_acls () && get_errno () == EACCES
d1131 1
a1131 1
	  oret = fh->open (&real_path, open_flags, 0);
d1145 3
a1147 3
      if (real_path.isdir ())
	buf->st_nlink = (real_path.isremote ()
			 ? 1 : num_entries (real_path.get_win32 ()));
d1150 1
a1150 1
  else if (real_path.exists ())
d1157 2
a1158 2
      if (real_path.isdir () && real_path.isremote ())
	buf->st_nlink = num_entries (real_path.get_win32 ());
d1160 2
a1161 2
      buf->st_ino = hash_path_name (0, real_path.get_win32 ());
      if (real_path.isdir ())
d1163 1
a1163 1
      else if (real_path.issymlink ())
d1165 1
a1165 1
      else if (real_path.issocket ())
d1169 2
a1170 2
      if (!real_path.has_acls ()
	  || get_file_attribute (TRUE, real_path.get_win32 (),
d1175 1
a1175 1
	  if (!(real_path.has_attribute (FILE_ATTRIBUTE_READONLY)))
d1177 1
a1177 1
	  if (real_path.issymlink ())
d1179 1
a1179 1
	  get_file_attribute (FALSE, real_path.get_win32 (),
d1182 1
a1182 1
      if ((handle = FindFirstFile (real_path.get_win32 (), &wfd))
d1201 1
a1201 1
  syscall_printf ("%d = %s (%s, %p)", res, caller, name, buf);
d1209 2
a1210 1
  return stat_worker ("stat", name, buf, 0);
d1218 2
a1219 1
  return stat_worker ("lstat", name, buf, 1);
@


1.152
log
@* cygheap.cc (cfree): Remove malloc debugging probe.
* dlmalloc.c (errprint): Remove abort() call which causes interesting error
message printing to abort prematurely.
* environ.cc: Sprinkle MALLOC_CHECKs liberally throughout.
(_addenv): Allocate two empty elements at end of environ to
(apparently) work around problems with some buggy applications.
(winenv): Avoid calling alloca if no forced environment variable is present.

* exceptions.cc (open_stackdumpfile): Don't print "Dumping stack trace to..."
when running in a cygwin environment (i.e., the parent is a cygwin process).

* dtable.cc (dtable::init_std_file_from_handle): Move device type detection
code from build_fhandler here since it is only used by this function.
(dtable::build_fhandler_from_name): New method.  Renamed from
dtable::build_fhandler.
(dtable::build_fhandler): Use build_fhandler_from_name.
(cygwin_attach_handle_to_fd): Ditto.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
* dtable.h (dtable::build_fhandler_from_name): Rename declaration from
dtable::build_fhandler.
@
text
@d504 1
a504 1
	  else if (!fh->open (pc, flags, (mode & 07777) & ~cygheap->umask))
d1110 1
a1110 1
  if ((oret = fh->open (real_path, open_flags, 0)))
d1118 1
a1118 1
      if ((oret = fh->open (real_path, open_flags, 0)))
d1130 1
a1130 1
	  oret = fh->open (real_path, open_flags, 0);
@


1.151
log
@* dtable.h (dtable::build_fhandler): Make path_conv parameter non-optional.
(dtable::init_std_file_from_handle): Eliminate name parameter.
* dtable.cc (stdio_init): Don't pass bogus name to init_std_file_from_handle.
The function will figure out the name itself.
(dtable::init_std_file_from_handle): Eliminate name parameter.  Assume that
we're always called with an appropriate fd.  Pass name as NULL if we can't
simply figure it out from context.
(cygwin_attach_handle_to_fd): Pass path_conv argument to build_fhandler.
(dtable::build_fhandler): Make path_conv argument mandatory.  Eliminate
specific call to get_device_number.  With unknown device names, set name from
handle context for parsing by path_conv.
(dtable::build_fhandler): Pass path_conv argument to build_fhandler.
* path.h (path_conv::set_isdisk): Set disk device type.
(path_conv::is_device): Don't consider FH_DISK a "device".
* syscalls.cc (_open): Pass path_conv argument by reference.
(stat_worker): Ditto.
(_rename): Use path_conv operators.  Add bounds to DeleteFile/MoveFile for
loop.
@
text
@a379 1
  MALLOC_CHECK;
d501 2
a502 1
	  if (!(fh = cygheap->fdtab.build_fhandler (fd, unix_path, NULL, pc)))
d1090 5
a1094 4
  fh = cygheap->fdtab.build_fhandler (-1, name, NULL, real_path,
				      (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)
				      | PC_FULL, stat_suffixes);

@


1.150
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d502 1
a502 1
	  if (!(fh = cygheap->fdtab.build_fhandler (fd, unix_path, NULL, &pc)))
d1090 1
a1090 1
  fh = cygheap->fdtab.build_fhandler (-1, name, NULL, &real_path,
d1330 1
a1330 2
  if (!writable_directory (real_old.get_win32 ())
      || !writable_directory (real_new.get_win32 ()))
d1355 1
a1355 1
  if (!MoveFile (real_old.get_win32 (), real_new.get_win32 ()))
d1371 1
a1371 1
      for (;;)
d1380 1
a1380 1
	  else
d1382 2
a1383 5
	      if (MoveFile (real_old.get_win32 (), real_new.get_win32 ()))
		{
		  res = 0;
		  break;
		}
@


1.149
log
@* fhandler.h (fhandler_pipe::hit_eof): New method.
(writepipe_exists): New class element.
(orig_pid): Ditto.
(id): Ditto.
(is_slow): Eliminate.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance on
writepipe_exists, if it exists.
(fhandler_pipe::hit_eof): New method, modelled after tty.
(fhandler_pipe::dup): Duplicate writepipe_exists, if it exists.
(make_pipe): Set up a dummy event for pipes on windows 9x.  The nonexistence
of this event means that the write side of the pipe has closed.
(_dup): Move to syscalls.cc
(_dup2): Ditto.

* dtable.cc (dtable::build_fhandler): Fill out set_names here, if appropriate.
* syscalls.cc (_open): Call set_names in build_fhandler.
@
text
@d119 1
a119 3
  DWORD atts;
  atts = win32_name.file_attributes ();
  if (atts == 0xffffffff)
d121 1
a121 1
      syscall_printf ("unlinking a nonexistant file");
d125 1
a125 2

  if (atts & FILE_ATTRIBUTE_DIRECTORY)
d140 1
a140 1
  if (atts & FILE_ATTRIBUTE_READONLY)
d143 2
a144 2
      if (len > 4 && strcasematch (win32_name + len - 4, ".lnk"))
	SetFileAttributes (win32_name, atts & ~FILE_ATTRIBUTE_READONLY);
d249 1
a249 5
  DWORD atts = win32_name.file_attributes ();
  if (atts != 0xffffffff && atts & FILE_ATTRIBUTE_DIRECTORY)
    return rmdir (ourname);

  return _unlink (ourname);
d615 1
a615 1
  if (real_b.file_attributes () != (DWORD)-1)
d775 1
a775 1
      if (win32_path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
d788 1
a788 1
	  if (win32_path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
d790 2
a791 4
	  res = set_file_attribute (win32_path.has_acls (),
				    win32_path.get_win32 (),
				    uid, gid, attrib,
				    cygheap->user.logsrv ());
d880 1
a880 1
  if (win32_path.file_attributes () == (DWORD)-1)
a883 1
      DWORD attr = win32_path.file_attributes ();
d885 1
a885 2
      SetFileAttributesA (win32_path.get_win32 (),
			  attr & ~FILE_ATTRIBUTE_READONLY);
d890 1
a890 1
      if (win32_path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
d895 2
a896 1
      if (win32_path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
d898 1
a898 3
      if (!set_file_attribute (win32_path.has_acls (),
				win32_path.get_win32 (),
				uid, gid,
d906 1
a906 1
	attr &= ~FILE_ATTRIBUTE_READONLY;
d908 1
a908 1
	attr |= FILE_ATTRIBUTE_READONLY;
d911 1
a911 1
	attr |= FILE_ATTRIBUTE_SYSTEM;
d913 1
a913 1
      if (!SetFileAttributesA (win32_path.get_win32 (), attr))
d1075 1
a1075 4
  int oret = 1;
  int atts;

  int attribute = 0;
d1078 2
a1079 3

  UINT dtype;
  fhandler_disk_file fh (NULL);
d1082 2
d1087 6
a1092 2
  path_conv real_path (name, (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW) |
					 PC_FULL, stat_suffixes);
a1099 3
  if (check_null_invalid_struct_errno (buf))
    goto done;

d1106 2
a1107 1
  atts = real_path.file_attributes ();
d1109 3
a1111 8
  debug_printf ("%d = file_attributes for '%s'", atts, real_path.get_win32 ());

  dtype = real_path.get_drive_type ();

  if ((atts == -1 || ! (atts & FILE_ATTRIBUTE_DIRECTORY) ||
       (wincap.can_open_directories ()
	&& dtype != DRIVE_NO_ROOT_DIR
	&& dtype != DRIVE_UNKNOWN)))
d1113 1
a1113 2
      oret = fh.open (real_path, O_RDONLY | O_BINARY | O_DIROPEN |
				 (nofollow ? O_NOSYMLINK : 0), 0);
d1116 12
a1127 15
      if (!oret)
	{
	  fh.set_query_open (TRUE);
	  oret = fh.open (real_path, O_RDONLY | O_BINARY | O_DIROPEN |
				     (nofollow ? O_NOSYMLINK : 0), 0);
	}
      /* Check a special case here. If ntsec is ON it happens
	 that a process creates a file using mode 000 to disallow
	 other processes access. In contrast to UNIX, this results
	 in a failing open call in the same process. Check that
	 case. */
      if (!oret && allow_ntsec && get_errno () == EACCES
	  && !get_file_attribute (TRUE, real_path, &attribute, &uid, &gid)
	  && !attribute && uid == myself->uid && gid == myself->gid)
	{
d1129 18
a1146 21
	  oret = fh.open (real_path, O_RDONLY | O_BINARY | O_DIROPEN |
				     (nofollow ? O_NOSYMLINK : 0), 0);
	  set_file_attribute (TRUE, real_path.get_win32 (), 0);
	}
      if (oret)
	{
	  res = fh.fstat (buf);
	  fh.close ();
	  /* The number of links to a directory includes the
	     number of subdirectories in the directory, since all
	     those subdirectories point to it.
	     This is too slow on remote drives, so we do without it and
	     set the number of links to 2. */
	  /* Unfortunately the count of 2 confuses `find (1)' command. So
	     let's try it with `1' as link count. */
	  if (atts != -1 && (atts & FILE_ATTRIBUTE_DIRECTORY))
	    buf->st_nlink = (dtype == DRIVE_REMOTE
			     ? 1
			     : num_entries (real_path.get_win32 ()));
	  goto done;
	}
d1148 1
a1148 2
  if (atts != -1 && (oret || (!oret && get_errno () != ENOENT
				    && get_errno () != ENOSHARE)))
d1155 1
a1155 3
      if (atts != -1
	  && (atts & FILE_ATTRIBUTE_DIRECTORY)
	  && dtype != DRIVE_REMOTE)
d1159 1
a1159 1
      if (atts != -1 && (atts & FILE_ATTRIBUTE_DIRECTORY))
d1173 1
a1173 1
	  if ((atts & FILE_ATTRIBUTE_READONLY) == 0)
d1196 2
d1338 1
a1338 1
  if (real_old.file_attributes () == (DWORD) -1) /* file to move doesn't exist */
d1347 2
a1348 4
  if (real_new.file_attributes () != (DWORD) -1 &&
      real_new.file_attributes () & FILE_ATTRIBUTE_READONLY)
    SetFileAttributesA (real_new.get_win32 (),
			real_new.file_attributes () & ~FILE_ATTRIBUTE_READONLY);
d1397 2
a1398 3
      if (real_new.file_attributes () != (DWORD) -1 &&
	  real_new.file_attributes () & FILE_ATTRIBUTE_READONLY)
	SetFileAttributesA (real_new.get_win32 (), real_new.file_attributes ());
d1403 1
a1403 1
      SetFileAttributesA (real_new.get_win32 (), real_old.file_attributes ());
d1411 1
a1411 1
	  DeleteFile (real_new.get_win32 ());
d1415 2
a1416 2
  syscall_printf ("%d = rename (%s, %s)", res, real_old.get_win32 (),
		  real_new.get_win32 ());
a2291 1
  int ret = -1;
d2294 1
d2296 2
a2297 2
    goto done;
  if (path.file_attributes () == (DWORD)-1)
d2300 1
a2300 1
      goto done;
d2302 1
a2302 1
  if (!(path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY))
d2305 8
a2312 1
      goto done;
a2313 4
  char buf[MAX_PATH];
  normalize_posix_path (newroot, buf);
  cygheap->root.set (buf, path);
  ret = 0;
a2314 1
done:
@


1.149.2.1
log
@Merged changes from HEAD
@
text
@d119 3
a121 1
  if (!win32_name.exists ())
d123 1
a123 1
      syscall_printf ("unlinking a nonexistent file");
d127 2
a128 1
  else if (win32_name.isdir ())
d143 1
a143 1
  if (win32_name.has_attribute (FILE_ATTRIBUTE_READONLY))
d146 2
a147 2
      if (len > 4 && strcasematch ((char *) win32_name + len - 4, ".lnk"))
	SetFileAttributes (win32_name, (DWORD) win32_name & ~FILE_ATTRIBUTE_READONLY);
d252 5
a256 1
  return win32_name.isdir () ? rmdir (ourname) : _unlink (ourname);
d509 1
a509 1
	  if (!(fh = cygheap->fdtab.build_fhandler (fd, unix_path, NULL, pc)))
d622 1
a622 1
  if (real_b.exists ())
d782 1
a782 1
      if (win32_path.isdir ())
d795 1
a795 1
	  if (win32_path.isdir())
d797 4
a800 2
	  res = set_file_attribute (win32_path.has_acls (), win32_path, uid,
	      			    gid, attrib, cygheap->user.logsrv ());
d889 1
a889 1
  if (!win32_path.exists ())
d893 1
d895 2
a896 1
      SetFileAttributes (win32_path, (DWORD) win32_path & ~FILE_ATTRIBUTE_READONLY);
d901 1
a901 1
      if (win32_path.isdir ())
d906 1
a906 2
      /* FIXME: Do we really need this to be specified twice? */
      if (win32_path.isdir ())
d908 3
a910 1
      if (!set_file_attribute (win32_path.has_acls (), win32_path, uid, gid,
d918 1
a918 1
	(DWORD) win32_path &= ~FILE_ATTRIBUTE_READONLY;
d920 1
a920 1
	(DWORD) win32_path |= FILE_ATTRIBUTE_READONLY;
d923 1
a923 1
	(DWORD) win32_path |= FILE_ATTRIBUTE_SYSTEM;
d925 1
a925 1
      if (!SetFileAttributes (win32_path, win32_path))
d1087 4
a1090 1
  int oret;
d1093 3
a1095 2
  path_conv real_path;
  fhandler_base *fh = NULL;
a1097 2
  int open_flags = O_RDONLY | O_BINARY | O_DIROPEN
    		   | (nofollow ? O_NOSYMLINK : 0);
d1101 2
a1102 6
  if (check_null_invalid_struct_errno (buf))
    goto done;

  fh = cygheap->fdtab.build_fhandler (-1, name, NULL, real_path,
				      (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW)
				      | PC_FULL, stat_suffixes);
d1110 3
d1119 3
a1121 2
  debug_printf ("%d = file_attributes for '%s'", (DWORD) real_path,
		(char *) real_path);
d1123 6
a1128 3
  if ((oret = fh->open (real_path, open_flags, 0)))
    /* ok */;
  else
d1130 2
a1131 1
      int ntsec_atts = 0;
d1134 15
a1148 12
      fh->set_query_open (TRUE);
      if ((oret = fh->open (real_path, open_flags, 0)))
        /* ok */;
      else if (allow_ntsec && real_path.has_acls () && get_errno () == EACCES
		&& !get_file_attribute (TRUE, real_path, &ntsec_atts, &uid, &gid)
		&& !ntsec_atts && uid == myself->uid && gid == myself->gid)
        {
	  /* Check a special case here. If ntsec is ON it happens
	     that a process creates a file using mode 000 to disallow
	     other processes access. In contrast to UNIX, this results
	     in a failing open call in the same process. Check that
	     case. */
d1150 21
a1170 18
	  oret = fh->open (real_path, open_flags, 0);
	  set_file_attribute (TRUE, real_path, ntsec_atts);
        }
    }
  if (oret)
    {
      res = fh->fstat (buf);
      /* The number of links to a directory includes the
	 number of subdirectories in the directory, since all
	 those subdirectories point to it.
	 This is too slow on remote drives, so we do without it and
	 set the number of links to 2. */
      /* Unfortunately the count of 2 confuses `find (1)' command. So
	 let's try it with `1' as link count. */
      if (real_path.isdir ())
	buf->st_nlink = (real_path.isremote ()
			 ? 1 : num_entries (real_path.get_win32 ()));
      fh->close ();
d1172 2
a1173 1
  else if (real_path.exists ())
d1180 3
a1182 1
      if (real_path.isdir () && real_path.isremote ())
d1186 1
a1186 1
      if (real_path.isdir ())
d1200 1
a1200 1
	  if (!(real_path.has_attribute (FILE_ATTRIBUTE_READONLY)))
a1222 2
  if (fh)
    delete fh;
d1355 2
a1356 1
  if (!writable_directory (real_old) || !writable_directory (real_new))
d1363 1
a1363 1
  if (!real_old.exists ()) /* file to move doesn't exist */
d1372 4
a1375 2
  if (real_new.has_attribute (FILE_ATTRIBUTE_READONLY))
    SetFileAttributes (real_new, (DWORD) real_new & ~FILE_ATTRIBUTE_READONLY);
d1383 1
a1383 1
  if (!MoveFile (real_old, real_new))
d1399 1
a1399 1
      for (int i = 0; i < 2; i++)
d1408 1
a1408 1
	  else if (MoveFile (real_old.get_win32 (), real_new.get_win32 ()))
d1410 5
a1414 2
	      res = 0;
	      break;
d1424 3
a1426 2
      if (real_new.has_attribute (FILE_ATTRIBUTE_READONLY))
	SetFileAttributes (real_new, real_new);
d1431 1
a1431 1
      SetFileAttributes (real_new, real_old);
d1439 1
a1439 1
	  DeleteFile (real_new);
d1443 2
a1444 2
  syscall_printf ("%d = rename (%s, %s)", res, (char *) real_old,
		  (char *) real_new);
d2320 1
a2322 1
  int ret;
d2324 2
a2325 2
    ret = -1;
  else if (!path.exists ())
d2328 1
a2328 1
      ret = -1;
d2330 1
a2330 1
  else if (!path.isdir ())
d2333 1
a2333 8
      ret = -1;
    }
  else
    {
      char buf[MAX_PATH];
      normalize_posix_path (newroot, buf);
      cygheap->root.set (buf, path);
      ret = 0;
d2335 4
d2340 1
@


1.149.2.2
log
@Merged changes from HEAD
@
text
@d68 2
a69 2
BOOL __stdcall
check_pty_fds (void)
d72 1
a72 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK, "check_pty_fds");
d75 1
a75 2
    if ((fh = cygheap->fdtab[i]) != NULL &&
	(fh->get_device () == FH_TTYS || fh->get_device () == FH_PTYM))
d80 1
a80 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK, "check_pty_fds");
d88 1
a88 1
  cygheap_fdnew newfd;
d90 3
a92 4
  if (newfd < 0)
    res = -1;
  else
    res = dup2 (fd, newfd);
d188 1
a188 1
			&& wincap.has_delete_on_close ();
d273 1
a273 1
	  !check_pty_fds ())
a287 6
  if (len == 0)
    return 0;

  if (__check_null_invalid_struct_errno (ptr, len))
    return -1;

d289 1
d297 5
a301 3
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	return -1;
d303 3
a305 1
      DWORD wait = cfd->is_nonblocking () ? 0 : INFINITE;
d310 1
a310 1
      if (wait && (!cfd->is_slow () || cfd->get_r_no_interrupt ()))
d312 1
a312 1
      else if (!cfd->ready_for_read (fd, wait))
d314 4
a321 6
      /* FIXME: This is not thread safe.  We need some method to
	 ensure that an fd, closed in another thread, aborts I/O
	 operations. */
      if (!cfd.isopen())
	return -1;

d324 1
a324 5
      res = cfd->bg_check (SIGTTIN);

      if (!cfd.isopen())
	return -1;

d328 1
a328 3
	  if (!cfd.isopen())
	    return -1;
	  res = cfd->read (ptr, len);
d338 2
a339 2
  syscall_printf ("%d = read (%d, %p, %d), errno %d", res, fd, ptr, len,
		  get_errno ());
a347 1

a348 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    goto done;
d350 1
a350 2
  /* No further action required for len == 0 */
  if (len == 0)
d352 1
a352 1
      res = 0;
a355 3
  if (len && __check_invalid_read_ptr_errno (ptr, len))
    goto done;

d362 4
a365 1
  res = cfd->bg_check (SIGTTOU);
d370 1
a370 1
      res = cfd->write (ptr, len);
d380 2
a381 1
  return (ssize_t) res;
d478 1
d482 1
d488 2
d495 1
a495 2
      fhandler_base *fh;
      cygheap_fdnew fd;
d497 3
a499 1
      if (fd >= 0)
d502 1
a502 2
	  if (!(fh = cygheap->fdtab.build_fhandler_from_name (fd, unix_path,
							      NULL, pc)))
d504 1
a504 1
	  else if (!fh->open (&pc, flags, (mode & 07777) & ~cygheap->umask))
d506 1
a506 1
	      fd.release ();
d512 1
d530 5
d537 1
a537 5
      cygheap_fdget cfd (fd);
      if (cfd >= 0)
	res = cfd->lseek (pos, dir);
      else
	res = -1;
d553 6
a558 3
  cygheap_fdget cfd (fd, true);
  if (cfd < 0)
    res = -1;
d561 4
a564 3
      cfd->close ();
      cfd.release ();
      res = 0;
d578 7
a584 5
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = 0;
  else
    res = cfd->is_tty ();
d791 1
a791 1
				    gid, attrib, cygheap->user.logsrv ());
d825 1
a825 2
  cygheap_fdget cfd (fd);
  if (cfd < 0)
d828 1
d832 1
a832 1
  const char *path = cfd->get_name ();
d934 1
a934 2
  cygheap_fdget cfd (fd);
  if (cfd < 0)
d937 1
d941 1
a941 1
  const char *path = cfd->get_name ();
d955 30
d988 1
a988 1
  int res;
d991 6
a996 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
d1000 2
a1001 1
      res = cfd->fstat (buf, NULL);
d1004 1
a1004 2
  syscall_printf ("%d = fstat (%d, %p)", res, fd, buf);
  return res;
d1012 1
a1012 2
  cygheap_fdget cfd (fd);
  if (cfd < 0)
d1015 1
a1018 1
<<<<<<< syscalls.cc
a1021 3
=======
  if (FlushFileBuffers (cfd->get_handle ()) == 0)
>>>>>>> 1.176
d1036 26
d1070 3
a1072 2
int __stdcall
stat_worker (const char *name, struct stat *buf, int nofollow, path_conv *pc)
d1075 3
d1081 5
a1085 2
  if (!pc)
    pc = &real_path;
a1086 1
  MALLOC_CHECK;
d1090 5
a1094 6
  fh = cygheap->fdtab.build_fhandler_from_name (-1, name, NULL, *pc,
						(nofollow ?
						 PC_SYM_NOFOLLOW
						 : PC_SYM_FOLLOW)
						| PC_FULL, stat_suffixes);
  if (pc->error)
d1096 2
a1097 2
      debug_printf ("got %d error from build_fhandler_from_name", pc->error);
      set_errno (pc->error);
d1099 94
a1192 6
  else
    {
      debug_printf ("(%s, %p, %d, %p), file_attributes %d", name, buf, nofollow,
		    pc, (DWORD) real_path);
      memset (buf, 0, sizeof (struct stat));
      res = fh->fstat (buf, pc);
d1199 1
a1199 1
  syscall_printf ("%d = (%s, %p)", res, name, buf);
d1207 1
a1207 2
  syscall_printf ("entering");
  return stat_worker (name, buf, 0);
d1215 1
a1215 2
  syscall_printf ("entering");
  return stat_worker (name, buf, 1);
d1225 1
a1225 1
  if (flags & ~(F_OK|R_OK|W_OK|X_OK))
d1235 1
a1235 1
  int r = stat_worker (fn, &st, 0);
d1399 1
a1399 10
      DWORD attr = real_old;
#ifdef HIDDEN_DOT_FILES
      char *c = strrchr (real_old.get_win32 (), '\\');
      if ((c && c[1] == '.') || *real_old.get_win32 () == '.')
        attr &= ~FILE_ATTRIBUTE_HIDDEN;
      c = strrchr (real_new.get_win32 (), '\\');
      if ((c && c[1] == '.') || *real_new.get_win32 () == '.')
        attr |= FILE_ATTRIBUTE_HIDDEN;
#endif
      SetFileAttributes (real_new, attr);
a1419 3
  if (check_null_empty_str_errno (cmdstring))
    return -1;

d1514 5
a1518 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
d1541 1
a1541 1
      if (cfd->is_tty ())
d1550 7
a1556 4
      if (cfd->get_device () == FH_DISK)
	return check_posix_perm (cfd->get_win32_name (), v);
      set_errno (EINVAL);
      return -1;
d1609 1
a1609 2
  cygheap_fdget cfd (fd);
  if (cfd < 0 || !cfd->is_tty ())
d1613 1
a1613 1
  return (char *) (cfd->ttyname ());
d1640 1
a1640 2
  cygheap_fdget cfd (fd, false, false);
  if (cfd < 0)
d1646 3
a1648 1
  if (cfd->get_device () != FH_DISK)
d1654 1
a1654 1
  if (cfd->get_w_binary () || cfd->get_r_binary ())
d1688 5
a1692 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
d1694 1
a1694 1
  return cfd->get_flags () & (O_BINARY | O_TEXT);
d1703 5
a1707 3
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
d1714 2
d1722 1
a1722 1
  if (cfd->get_w_binary () && cfd->get_r_binary ())
d1724 1
a1724 1
  else if (cfd->get_w_binset () && cfd->get_r_binset ())
d1730 1
a1730 1
    cfd->reset_to_open_binmode ();
d1733 2
a1734 2
      cfd->set_w_binary (1);
      cfd->set_r_binary (1);
d1738 2
a1739 2
      cfd->set_w_binary (0);
      cfd->set_r_binary (0);
d1749 1
a1749 1
  syscall_printf ("setmode (%d<%s>, %s) returns %s\n", fd, cfd->get_name (),
d1763 7
a1769 1
    set_errno (EINVAL);
d1772 4
a1775 2
      cygheap_fdget cfd (fd);
      if (cfd >= 0)
d1777 2
a1778 1
	  HANDLE h = cygheap->fdtab[fd]->get_handle ();
d1780 2
a1781 1
	  if (cfd->get_handle ())
d1783 4
a1786 2
	      /* remember curr file pointer location */
	      off_t prev_loc = cfd->lseek (0, SEEK_CUR);
d1788 2
a1789 9
	      cfd->lseek (length, SEEK_SET);
	      if (!SetEndOfFile (h))
		__seterrno ();
	      else
		res = 0;

	      /* restore original file pointer location */
	      cfd->lseek (prev_loc, 0);
	    }
d1792 1
a1793 1
  syscall_printf ("%d = ftruncate (%d, %d)", res, fd, length);
d1822 1
a1822 1
  long res;
d1824 2
a1825 3
  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = (long) cfd->get_handle ();
d1827 1
a1827 1
    res = -1;
d1878 7
a1884 4
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return -1;
  return statfs (cfd->get_name (), sfs);
d1964 6
a1969 4
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return 0;
  return (char *) (cfd->ptsname ());
a2216 5
      /* Unsetting these both env vars is necessary to get NetUserGetInfo()
	 called in internal_getlogin ().  Otherwise the wrong path is used
	 after a user switch, probably. */
      unsetenv ("HOMEDRIVE");
      unsetenv ("HOMEPATH");
a2560 98
}

static int utmp_fd = -2;
static char *utmp_file = (char *) _PATH_UTMP;

static struct utmp utmp_data;

extern "C" void
setutent ()
{
  sigframe thisframe (mainthread);
  if (utmp_fd == -2)
    {
      utmp_fd = _open (utmp_file, O_RDONLY);
    }
  _lseek (utmp_fd, 0, SEEK_SET);
}

extern "C" void
endutent ()
{
  sigframe thisframe (mainthread);
  _close (utmp_fd);
  utmp_fd = -2;
}

extern "C" void
utmpname (_CONST char *file)
{
  sigframe thisframe (mainthread);
  if (check_null_empty_str (file))
    {
      debug_printf ("Invalid file");
      return;
    }
  utmp_file = strdup (file);
  debug_printf ("New UTMP file: %s", utmp_file);
}

extern "C" struct utmp *
getutent ()
{
  sigframe thisframe (mainthread);
  if (utmp_fd == -2)
    setutent ();
  if (_read (utmp_fd, &utmp_data, sizeof (utmp_data)) != sizeof (utmp_data))
    return NULL;
  return &utmp_data;
}

extern "C" struct utmp *
getutid (struct utmp *id)
{
  sigframe thisframe (mainthread);
  if (check_null_invalid_struct_errno (id))
    return NULL;
  while (_read (utmp_fd, &utmp_data, sizeof (utmp_data)) == sizeof (utmp_data))
    {
      switch (id->ut_type)
	{
#if 0 /* Not available in Cygwin. */
	case RUN_LVL:
	case BOOT_TIME:
	case OLD_TIME:
	case NEW_TIME:
	  if (id->ut_type == utmp_data.ut_type)
	    return &utmp_data;
	  break;
#endif
	case INIT_PROCESS:
	case LOGIN_PROCESS:
	case USER_PROCESS:
	case DEAD_PROCESS:
	  if (id->ut_id == utmp_data.ut_id)
	    return &utmp_data;
	  break;
	default:
	  return NULL;
	}
    }
  return NULL;
}

extern "C" struct utmp *
getutline (struct utmp *line)
{
  sigframe thisframe (mainthread);
  if (check_null_invalid_struct_errno (line))
    return NULL;
  while (_read (utmp_fd, &utmp_data, sizeof (utmp_data)) == sizeof (utmp_data))
    {
      if ((utmp_data.ut_type == LOGIN_PROCESS ||
	   utmp_data.ut_type == USER_PROCESS) &&
	  !strncmp (utmp_data.ut_line, line->ut_line,
		    sizeof (utmp_data.ut_line)))
	return &utmp_data;
    }
  return NULL;
@


1.149.2.3
log
@fixup merge failure
@
text
@d989 5
d995 1
@


1.149.2.4
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d208 1
a208 2
      if (GetFileAttributes (win32_name) == INVALID_FILE_ATTRIBUTES
          || delete_on_close_ok)
a1426 2
      if (check_null_empty_str_errno (file))
          return -1;
@


1.149.2.5
log
@Merged changes from HEAD
@
text
@d1819 1
a1819 1
extern "C" int __declspec(dllexport)
a2104 1
#if 0	  // Setting the primary group in token here isn't foolproof enough.
a2125 1
#endif
@


1.149.2.6
log
@Merged changes from HEAD
@
text
@d530 2
a531 2
extern "C" __off64_t
lseek64 (int fd, __off64_t pos, int dir)
d533 1
a533 1
  __off64_t res;
d549 1
a549 1
  syscall_printf ("%d = lseek (%d, %D, %d)", res, fd, pos, dir);
a553 6
extern "C" __off32_t
_lseek (int fd, __off32_t pos, int dir)
{
  return lseek64 (fd, (__off64_t) pos, dir);
}

d747 1
a747 1
chown_worker (const char *name, unsigned fmode, __uid16_t uid, __gid16_t gid)
d750 2
a751 2
  __uid16_t old_uid;
  __gid16_t old_gid;
d788 1
a788 1
	  if (uid == ILLEGAL_UID)
d790 1
a790 1
	  if (gid == ILLEGAL_GID)
d812 1
a812 1
chown (const char * name, __uid16_t uid, __gid16_t gid)
d819 1
a819 1
lchown (const char * name, __uid16_t uid, __gid16_t gid)
d826 1
a826 1
fchown (int fd, __uid16_t uid, __gid16_t gid)
d891 2
a892 2
      __uid16_t uid;
      __gid16_t gid;
a958 18
static void
stat64_to_stat32 (struct __stat64 *src, struct __stat32 *dst)
{
  dst->st_dev = src->st_dev;
  dst->st_ino = src->st_ino;
  dst->st_mode = src->st_mode;
  dst->st_nlink = src->st_nlink;
  dst->st_uid = src->st_uid;
  dst->st_gid = src->st_gid;
  dst->st_rdev = src->st_rdev;
  dst->st_size = src->st_size;
  dst->st_atime = src->st_atime;
  dst->st_mtime = src->st_mtime;
  dst->st_ctime = src->st_ctime;
  dst->st_blksize = src->st_blksize;
  dst->st_blocks = src->st_blocks;
}

d960 1
a960 1
fstat64 (int fd, struct __stat64 *buf)
d970 1
a970 1
      memset (buf, 0, sizeof (struct __stat64));
a977 10
extern "C" int
_fstat (int fd, struct __stat32 *buf)
{
  struct __stat64 buf64;
  int ret = fstat64 (fd, &buf64);
  if (!ret)
    stat64_to_stat32 (&buf64, buf);
  return ret;
}

d1014 1
a1014 2
stat_worker (const char *name, struct __stat64 *buf, int nofollow,
	     path_conv *pc)
d1041 1
a1041 1
      memset (buf, 0, sizeof (struct __stat64));
d1054 1
a1054 1
stat64 (const char *name, struct __stat64 *buf)
a1060 10
extern "C" int
_stat (const char *name, struct __stat32 *buf)
{
  struct __stat64 buf64;
  int ret = stat64 (name, &buf64);
  if (!ret)
    stat64_to_stat32 (&buf64, buf);
  return ret;
}

d1063 1
a1063 1
lstat64 (const char *name, struct __stat64 *buf)
a1069 11
/* lstat: Provided by SVR4 and 4.3+BSD, POSIX? */
extern "C" int
cygwin_lstat (const char *name, struct __stat32 *buf)
{
  struct __stat64 buf64;
  int ret = lstat64 (name, &buf64);
  if (!ret)
    stat64_to_stat32 (&buf64, buf);
  return ret;
}

d1086 1
a1086 1
  struct __stat64 st;
d1610 1
d1612 1
a1612 1
ftruncate64 (int fd, __off64_t length)
d1629 1
a1629 1
	      __off64_t prev_loc = cfd->lseek (0, SEEK_CUR);
d1638 1
a1638 1
	      cfd->lseek (prev_loc, SEEK_SET);
a1646 7
/* ftruncate: P96 5.6.7.1 */
extern "C" int
ftruncate (int fd, __off32_t length)
{
  return ftruncate64 (fd, (__off64_t)length);
}

d1649 1
a1649 1
truncate64 (const char *pathname, __off64_t length)
a1668 7
/* truncate: Provided by SVR4 and 4.3+BSD.  Not part of POSIX.1 or XPG3 */
extern "C" int
truncate (const char *pathname, __off32_t length)
{
  return truncate64 (pathname, (__off64_t)length);
}

d1847 1
a1847 1
setgid (__gid16_t gid)
d1857 1
a1857 1
setuid (__uid16_t uid)
d1870 1
a1870 1
seteuid (__uid16_t uid)
d1883 1
a1883 1
      if (uid == ILLEGAL_UID || uid == myself->uid)
d1938 1
a1938 1
	  struct __group16 *gr = getgrgid (myself->gid);
d2090 1
a2090 1
setegid (__gid16_t gid)
d2095 1
a2095 1
      if (gid != ILLEGAL_GID)
d2097 1
a2097 1
	  struct __group16 *gr;
d2380 1
a2380 2
      /* FIXME: utmp file access is not 64 bit clean for now. */
      __off32_t pos = 0;		/* Position in file */
@


1.149.2.7
log
@Merged changes from HEAD
@
text
@d14 1
d35 1
d42 2
d88 9
a96 1
  return cygheap->fdtab.dup2 (fd, cygheap_fdnew ());
a108 1
  DWORD devn;
a118 7
  if ((devn = win32_name.get_devn ()) == FH_PROC || devn == FH_REGISTRY
      || devn == FH_PROCESS)
    {
      set_errno (EROFS);
      goto done;
    }

d209 1
a209 1
	  || delete_on_close_ok)
a344 8

      if (res && get_errno () == EACCES &&
	  !(cfd->get_flags () & (O_RDONLY | O_RDWR)))
	{
	  set_errno (EBADF);
	  break;
	}

a388 3
      if (res && get_errno () == EACCES &&
	  !(cfd->get_flags () & (O_WRONLY | O_RDWR)))
	set_errno (EBADF);
d753 1
a753 1
chown_worker (const char *name, unsigned fmode, __uid32_t uid, __gid32_t gid)
d756 2
a757 2
  __uid32_t old_uid;
  __gid32_t old_gid;
d801 1
a801 1
				    gid, attrib);
d818 1
a818 1
chown32 (const char * name, __uid32_t uid, __gid32_t gid)
d825 1
a825 8
chown (const char * name, __uid16_t uid, __gid16_t gid)
{
  sigframe thisframe (mainthread);
  return chown_worker (name, PC_SYM_FOLLOW, uid, gid16togid32 (gid));
}

extern "C" int
lchown32 (const char * name, __uid32_t uid, __gid32_t gid)
d832 1
a832 8
lchown (const char * name, __uid16_t uid, __gid16_t gid)
{
  sigframe thisframe (mainthread);
  return chown_worker (name, PC_SYM_NOFOLLOW, uid, gid16togid32 (gid));
}

extern "C" int
fchown32 (int fd, __uid32_t uid, __gid32_t gid)
a855 6
extern "C" int
fchown (int fd, __uid16_t uid, __gid16_t gid)
{
  return fchown32 (fd, uid, gid16togid32 (gid));
}

d897 2
a898 2
      __uid32_t uid;
      __gid32_t gid;
d909 1
a909 1
				mode)
d968 1
a968 1
  dst->st_dev = ((src->st_dev >> 8) & 0xff00) | (src->st_dev & 0xff);
d976 3
a978 3
  dst->st_atim = src->st_atim;
  dst->st_mtim = src->st_mtim;
  dst->st_ctim = src->st_ctim;
a993 1
      path_conv pc (cfd->get_win32_name ());
d995 1
a995 8
      res = cfd->fstat (buf, &pc);
      if (!res)
	{
	  if (!buf->st_ino)
	    buf->st_ino = hash_path_name (0, cfd->get_win32_name ());
	  if (!buf->st_dev)
	    buf->st_dev = (cfd->get_device () << 16) | cfd->get_unit ();
	}
d1055 4
a1061 3
  if (!pc)
    pc = &real_path;

d1063 3
a1065 2
						(nofollow ? PC_SYM_NOFOLLOW
							  : PC_SYM_FOLLOW)
a1066 1

d1076 1
a1076 1
      memset (buf, 0, sizeof (*buf));
a1077 7
      if (!res)
	{
	  if (!buf->st_ino)
	    buf->st_ino = hash_path_name (0, fh->get_win32_name ());
	  if (!buf->st_dev)
	    buf->st_dev = (fh->get_device () << 16) | fh->get_unit ();
	}
d1151 1
a1151 1
	  if (!(st.st_mode & S_IRUSR))
d1156 1
a1156 1
	  if (!(st.st_mode & S_IRGRP))
d1159 1
a1159 1
      else if (!(st.st_mode & S_IROTH))
d1166 1
a1166 1
	  if (!(st.st_mode & S_IWUSR))
d1171 1
a1171 1
	  if (!(st.st_mode & S_IWGRP))
d1174 1
a1174 1
      else if (!(st.st_mode & S_IWOTH))
d1181 1
a1181 1
	  if (!(st.st_mode & S_IXUSR))
d1186 1
a1186 1
	  if (!(st.st_mode & S_IXGRP))
d1189 1
a1189 1
      else if (!(st.st_mode & S_IXOTH))
d1311 1
a1311 1
	attr &= ~FILE_ATTRIBUTE_HIDDEN;
d1314 1
a1314 1
	attr |= FILE_ATTRIBUTE_HIDDEN;
d1485 1
a1485 1
	  return -1;
d1593 2
a1594 2
		 f->_flags & __SCLE ? "text" : "raw",
		 setmode_mode & O_TEXT ? "text" : "raw");
d1642 5
d1648 4
a1651 1
    cfd->set_flags ((cfd->get_flags () & ~(O_TEXT | O_BINARY)) | mode);
d1660 3
a1662 2
  syscall_printf ("setmode (%d<%s>, %p) returns %s\n", fd, cfd->get_name (),
		  mode, res & O_TEXT ? "text" : "binary");
d1723 1
a1723 1
      res = ftruncate64 (fd, length);
d1914 21
d1939 1
a1939 1
seteuid32 (__uid32_t uid)
d1941 2
a1942 3
  if (!wincap.has_security ()) return 0;

  if (uid == ILLEGAL_UID)
d1944 7
a1950 3
      debug_printf ("new euid == illegal euid, nothing happens");
      return 0;
    }
d1952 7
a1958 50
  sigframe thisframe (mainthread);
  DWORD ulen = UNLEN + 1;
  DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  char orig_username[UNLEN + 1];
  char orig_domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  char username[UNLEN + 1];
  char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  cygsid usersid, pgrpsid;
  HANDLE ptok, sav_token;
  BOOL sav_impersonated, sav_token_is_internal_token;
  BOOL process_ok, explicitly_created_token = FALSE;
  struct passwd * pw_new, * pw_cur;
  cygheap_user user;
  PSID origpsid, psid2 = NO_SID;

  debug_printf ("uid: %d myself->gid: %d", uid, myself->gid);

  pw_new = getpwuid32 (uid);
  if (!usersid.getfrompw (pw_new) ||
      (!pgrpsid.getfromgr (getgrgid32 (myself->gid))))
    {
      set_errno (EINVAL);
      return -1;
    }
  /* Save current information */
  sav_token = cygheap->user.token;
  sav_impersonated = cygheap->user.impersonated;
  char *env;
  orig_username[0] = orig_domain[0] = '\0';
  if ((env = getenv ("USERNAME")))
    strlcpy (orig_username, env, sizeof(orig_username));
  if ((env = getenv ("USERDOMAIN")))
    strlcpy (orig_domain, env, sizeof(orig_domain));

  RevertToSelf();
  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, &ptok))
    {
      __seterrno ();
      goto failed;
    }
  /* Verify if the process token is suitable.
     Currently we do not try to differentiate between
	 internal tokens and others */
  process_ok = verify_token(ptok, usersid, pgrpsid);
  debug_printf("Process token %sverified", process_ok?"":"not ");
  if (process_ok)
    {
      if (cygheap->user.token == INVALID_HANDLE_VALUE ||
	  !cygheap->user.impersonated)
d1960 2
a1961 2
	  CloseHandle (ptok);
	  return 0; /* No change */
a1962 2
      else cygheap->user.impersonated = FALSE;
    }
d1964 28
a1991 11
  if (!process_ok && cygheap->user.token != INVALID_HANDLE_VALUE)
    {
      /* Verify if the current tokem is suitable */
      BOOL token_ok = verify_token (cygheap->user.token, usersid, pgrpsid,
				    & sav_token_is_internal_token);
      debug_printf("Thread token %d %sverified",
		   cygheap->user.token, token_ok?"":"not ");
      if (token_ok)
	{
	  /* Return if current token is valid */
	  if (cygheap->user.impersonated)
d1993 2
a1994 4
	      CloseHandle (ptok);
	      if (!ImpersonateLoggedOnUser (cygheap->user.token))
		system_printf ("Impersonating in seteuid failed: %E");
	      return 0; /* No change */
d1996 2
a1998 24
      else cygheap->user.token = INVALID_HANDLE_VALUE;
    }

  /* Set process def dacl to allow access to impersonated token */
  char dacl_buf[MAX_DACL_LEN(5)];
  if (usersid != (origpsid =  cygheap->user.orig_sid())) psid2 = usersid;
  if (sec_acl ((PACL) dacl_buf, FALSE, origpsid, psid2))
    {
      TOKEN_DEFAULT_DACL tdacl;
      tdacl.DefaultDacl = (PACL) dacl_buf;
      if (!SetTokenInformation (ptok, TokenDefaultDacl,
				&tdacl, sizeof dacl_buf))
	debug_printf ("SetTokenInformation"
		      "(TokenDefaultDacl): %E");
    }
  CloseHandle (ptok);

  if (!process_ok && cygheap->user.token == INVALID_HANDLE_VALUE)
    {
      /* If no impersonation token is available, try to
	 authenticate using NtCreateToken() or subauthentication. */
      cygheap->user.token = create_token (usersid, pgrpsid);
      if (cygheap->user.token != INVALID_HANDLE_VALUE)
	explicitly_created_token = TRUE;
d2001 123
a2123 4
	  /* create_token failed. Try subauthentication. */
	  debug_printf ("create token failed, try subauthentication.");
	  cygheap->user.token = subauth (pw_new);
	  if (cygheap->user.token == INVALID_HANDLE_VALUE) goto failed;
a2124 1
    }
d2126 22
a2147 59
  /* Lookup username and domain before impersonating,
     LookupAccountSid() returns a different answer afterwards. */
  SID_NAME_USE use;
  if (!LookupAccountSid (NULL, usersid, username, &ulen,
			 domain, &dlen, &use))
    {
      debug_printf ("LookupAccountSid (): %E");
      __seterrno ();
      goto failed;
    }
  /* If using the token, set info and impersonate */
  if (!process_ok)
    {
      /* If the token was explicitly created, all information has
	 already been set correctly. */
      if (!explicitly_created_token)
	{
	  /* Try setting owner to same value as user. */
	  if (!SetTokenInformation (cygheap->user.token, TokenOwner,
				    &usersid, sizeof usersid))
	    debug_printf ("SetTokenInformation(user.token, "
			  "TokenOwner): %E");
	  /* Try setting primary group in token to current group */
	  if (!SetTokenInformation (cygheap->user.token,
				    TokenPrimaryGroup,
				    &pgrpsid, sizeof pgrpsid))
	    debug_printf ("SetTokenInformation(user.token, "
			  "TokenPrimaryGroup): %E");
	}
      /* Now try to impersonate. */
      if (!ImpersonateLoggedOnUser (cygheap->user.token))
	{
	  debug_printf ("ImpersonateLoggedOnUser %E");
	  __seterrno ();
	  goto failed;
	}
      cygheap->user.impersonated = TRUE;
    }

  /* user.token is used in internal_getlogin () to determine if
     impersonation is active. If so, the token is used for
     retrieving user's SID. */
  user.token = cygheap->user.impersonated ? cygheap->user.token
					  : INVALID_HANDLE_VALUE;
  /* Unsetting these two env vars is necessary to get NetUserGetInfo()
     called in internal_getlogin ().  Otherwise the wrong path is used
     after a user switch, probably. */
  unsetenv ("HOMEDRIVE");
  unsetenv ("HOMEPATH");
  setenv ("USERDOMAIN", domain, 1);
  setenv ("USERNAME", username, 1);
  pw_cur = internal_getlogin (user);
  if (pw_cur == pw_new)
    {
      /* If sav_token was internally created and is replaced, destroy it. */
      if (sav_token != INVALID_HANDLE_VALUE &&
	  sav_token != cygheap->user.token &&
	  sav_token_is_internal_token)
	CloseHandle (sav_token);
a2149 1
      return 0;
d2151 2
a2152 30
  debug_printf ("Diffs!!! token: %d, cur: %d, new: %d, orig: %d",
		cygheap->user.token, pw_cur->pw_uid,
		pw_new->pw_uid, cygheap->user.orig_uid);
  set_errno (EPERM);

 failed:
  setenv ("USERNAME", orig_username, 1);
  setenv ("USERDOMAIN", orig_domain, 1);
  cygheap->user.token = sav_token;
  cygheap->user.impersonated = sav_impersonated;
  if ( cygheap->user.token != INVALID_HANDLE_VALUE &&
       cygheap->user.impersonated &&
       !ImpersonateLoggedOnUser (cygheap->user.token))
    system_printf ("Impersonating in seteuid failed: %E");
  return -1;
}

extern "C" int
seteuid (__uid16_t uid)
{
  return seteuid32 (uid16touid32 (uid));
}

/* setuid: POSIX 4.2.2.1 */
extern "C" int
setuid32 (__uid32_t uid)
{
  int ret = seteuid32 (uid);
  if (!ret)
    cygheap->user.real_uid = myself->uid;
d2154 1
a2154 7
  return ret;
}

extern "C" int
setuid (__uid16_t uid)
{
  return setuid32 (uid16touid32 (uid));
d2159 1
a2159 1
setegid32 (__gid32_t gid)
d2161 6
a2166 3
  if ((!wincap.has_security ()) ||
      (gid == ILLEGAL_GID))
    return 0;
d2168 11
a2178 3
  sigframe thisframe (mainthread);
  cygsid gsid;
  HANDLE ptok;
d2180 18
a2197 5
  struct __group32 * gr = getgrgid32 (gid);
  if (!gr || gr->gr_gid != gid || !gsid.getfromgr (gr))
    {
      set_errno (EINVAL);
      return -1;
d2199 2
a2200 29
  myself->gid = gid;

  /* If impersonated, update primary group and revert */
  if (cygheap->user.token != INVALID_HANDLE_VALUE
      && cygheap->user.impersonated)
    {
      if (!SetTokenInformation (cygheap->user.token,
				TokenPrimaryGroup,
				&gsid, sizeof gsid))
	debug_printf ("SetTokenInformation(thread, "
		      "TokenPrimaryGroup): %E");
      RevertToSelf ();
    }
  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_ADJUST_DEFAULT,
			 &ptok))
    debug_printf ("OpenProcessToken(): %E\n");
  else
    {
      if (!SetTokenInformation (ptok, TokenPrimaryGroup,
				&gsid, sizeof gsid))
	debug_printf ("SetTokenInformation(process, "
		      "TokenPrimaryGroup): %E");
      CloseHandle (ptok);
    }
  if (cygheap->user.token != INVALID_HANDLE_VALUE
      && cygheap->user.impersonated
      && !ImpersonateLoggedOnUser (cygheap->user.token))
    system_printf ("Impersonating in setegid failed: %E");
a2203 25
extern "C" int
setegid (__gid16_t gid)
{
  return setegid32 (gid16togid32 (gid));
}

/* setgid: POSIX 4.2.2.1 */
extern "C" int
setgid32 (__gid32_t gid)
{
  int ret = setegid32 (gid);
  if (!ret)
    cygheap->user.real_gid = myself->gid;
  return ret;
}

extern "C" int
setgid (__gid16_t gid)
{
  int ret = setegid32 (gid16togid32 (gid));
  if (!ret)
    cygheap->user.real_gid = myself->gid;
  return ret;
}

d2210 1
a2210 1
  path_conv path (newroot, PC_SYM_FOLLOW | PC_FULL | PC_POSIX);
d2227 3
a2229 1
      cygheap->root.set (path.normalized_path, path);
@


1.149.2.8
log
@Merged changes from HEAD
@
text
@d1946 2
d1961 6
d1971 1
a1971 1
  struct passwd * pw_new;
d1987 6
d2068 10
d2107 28
a2134 9
  /* If sav_token was internally created and is replaced, destroy it. */
  if (sav_token != INVALID_HANDLE_VALUE &&
      sav_token != cygheap->user.token &&
      sav_token_is_internal_token)
      CloseHandle (sav_token);
  cygheap->user.set_name (pw_new->pw_name);
  cygheap->user.set_sid (usersid);
  myself->uid = uid;
  return 0;
d2137 2
@


1.149.2.9
log
@Merged changes from HEAD
@
text
@d2096 3
a2098 2
  if (cygheap->user.issetuid ()
       && !ImpersonateLoggedOnUser (cygheap->user.token))
d2147 2
a2148 1
  if (cygheap->user.issetuid ())
d2169 2
a2170 1
  if (cygheap->user.issetuid ()
@


1.149.2.10
log
@Merged changes from HEAD
@
text
@d1981 2
a1982 1
  if (!OpenProcessToken (hMainProc, TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, &ptok))
d1990 2
a1991 2
  process_ok = verify_token (ptok, usersid, pgrpsid);
  debug_printf("Process token %sverified", process_ok ? "" : "not ");
d1994 2
a1995 3
      if (cygheap->user.issetuid ())
	cygheap->user.impersonated = FALSE;
      else
d2000 1
d2010 1
a2010 3
      if (!token_ok)
	cygheap->user.token = INVALID_HANDLE_VALUE;
      else
d2021 1
d2155 3
a2157 1
  if (!OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT, &ptok))
@


1.149.2.11
log
@Merged changes from HEAD
@
text
@d1001 1
a1001 1
  dst->st_rdev = ((src->st_rdev >> 8) & 0xff00) | (src->st_rdev & 0xff);
a1029 2
	  if (!buf->st_rdev)
	    buf->st_rdev = buf->st_dev;
a1117 2
	  if (!buf->st_rdev)
	    buf->st_rdev = buf->st_dev;
@


1.149.2.12
log
@Merged changes from HEAD
@
text
@d835 1
a835 2
  return chown_worker (name, PC_SYM_FOLLOW,
		       uid16touid32 (uid), gid16togid32 (gid));
d849 1
a849 2
  return chown_worker (name, PC_SYM_NOFOLLOW,
		       uid16touid32 (uid), gid16togid32 (gid));
d880 1
a880 1
  return fchown32 (fd, uid16touid32 (uid), gid16togid32 (gid));
d2046 1
a2046 1
      cygheap->user.token = create_token (usersid, pgrpsid, pw_new);
@


1.149.2.13
log
@Merged changes from HEAD
@
text
@d618 1
d620 1
a620 2
  path_conv real_a (a, PC_SYM_NOFOLLOW | PC_FULL);
  
a625 1

d634 1
a634 1
      syscall_printf ("file '%s' exists?", (char *) real_b);
d638 1
a638 2

  if (real_b[strlen (real_b) - 1] == '.')
d648 1
a648 1
      if (CreateHardLinkA (real_b, real_a, NULL))
d666 1
a666 1
	real_a,
d681 2
a682 1
      cbPathLen = sys_mbstowcs (wbuf, real_b, MAX_PATH) * sizeof (WCHAR);
d691 1
a691 1
		   StreamId.dwStreamNameSize;
a692 1
      lpContext = NULL;
d744 1
a744 1
  if (CopyFileA (real_a, real_b, 1))
@


1.149.2.14
log
@Merged changes from HEAD
@
text
@d1972 1
@


1.149.2.15
log
@Merged changes from HEAD
@
text
@d620 1
a620 1

d1958 1
d1960 1
a1960 7
  debug_printf ("uid: %d myself->gid: %d", uid, myself->gid);

  if (!wincap.has_security ()
      || (!cygheap->user.issetuid ()
	  && uid == myself->uid
	  && myself->gid == cygheap->user.orig_gid)
      || uid == ILLEGAL_UID)
d1962 1
a1962 1
      debug_printf ("Nothing happens");
d1974 2
d2057 1
a2057 2
	  if (cygheap->user.token == INVALID_HANDLE_VALUE)
	    goto failed;
a2136 1
      (gid == myself->gid) ||
@


1.149.2.16
log
@Merged changes from HEAD
@
text
@d1025 1
a1025 1
      path_conv pc (cfd->get_win32_name (), PC_SYM_NOFOLLOW);
@


1.149.2.17
log
@Merged changes from HEAD
@
text
@d328 1
a328 1
      if (!cfd.isopen ())
d581 1
a581 1
      res = cfd->close ();
d583 1
@


1.149.2.18
log
@Merged changes from HEAD
@
text
@d1961 3
a1963 2
      || (uid == myself->uid
	  && !cygheap->user.groups.ischanged)
d1971 1
a1971 2
  cygsid usersid;
  user_groups &groups = cygheap->user.groups;
d1979 2
a1980 1
  if (!usersid.getfrompw (pw_new))
d1998 1
a1998 1
  process_ok = verify_token (ptok, usersid, groups);
d2014 2
a2015 2
      BOOL token_ok = verify_token (cygheap->user.token, usersid, groups,
				    &sav_token_is_internal_token);
d2051 1
a2051 1
      cygheap->user.token = create_token (usersid, groups, pw_new);
d2079 1
a2079 1
				    &groups.pgsid, sizeof(cygsid)))
a2100 1
  groups.ischanged = FALSE;
a2144 1
  user_groups * groups = &cygheap->user.groups;
a2155 1
  groups->update_pgrp (gsid);
@


1.149.2.19
log
@Merged changes from HEAD
@
text
@d308 1
a308 2
      syscall_printf ("read (%d, %p, %d) %sblocking, sigcatchers %d",
		      fd, ptr, len, wait ? "" : "non", sigcatchers);
d311 1
a311 1
	debug_printf ("no need to call ready_for_read\n");
d321 1
a321 1
      if (!cfd.isopen ())
d334 1
a334 1
	  if (!cfd.isopen ())
@


1.149.2.20
log
@Merged changes from HEAD
@
text
@a617 1
  path_conv real_a (a, PC_SYM_FOLLOW | PC_FULL);
d619 1
@


1.149.2.21
log
@Merged changes from HEAD
@
text
@d2007 1
a2007 1
	  goto success; /* No change */
d2028 1
a2028 1
	      goto success; /* No change */
a2099 1
success:
@


1.149.2.22
log
@Merged changes from HEAD
@
text
@a38 3
#define NEED_VFORK
#include <setjmp.h>
#include "perthread.h"
d268 1
a268 3
  vfork_save *vf = vfork_storage.val ();
  /* This is a horrible, horrible kludge */
  if (vf && vf->pid < 0)
d270 3
a272 14
      pid_t pid = fork ();
      if (pid > 0)
	{
	  syscall_printf ("longjmping due to vfork");
	  vf->restore_pid (pid);
	}
      /* assuming that fork was successful */
    }

  if (myself->pgid != myself->pid)
    {
      if (myself->ctty == TTY_CONSOLE
	  && !cygheap->fdtab.has_console_fds ()
	  && !check_pty_fds ())
a279 1

a281 20
}

extern "C" pid_t
getsid (pid_t pid)
{
  pid_t res;
  if (!pid)
    res = myself->sid;
  else
    {
      pinfo p (pid);
      if (p)
	res = p->sid;
      else
	{
	  set_errno (ESRCH);
	  res = -1;
	}
    }
  return res;
@


1.149.2.23
log
@Merged changes from HEAD
@
text
@d324 2
a325 8
  const struct iovec iov =
    {
      iov_base: ptr,
      iov_len: len
    };

  return readv (fd, &iov, 1);
}
d327 2
a328 11
extern "C" ssize_t
_write (int fd, const void *ptr, size_t len)
{
  const struct iovec iov =
    {
      iov_base: (void *) ptr,	// const_cast
      iov_len: len
    };

  return writev (fd, &iov, 1);
}
d330 1
a330 3
extern "C" ssize_t
readv (int fd, const struct iovec *const iov, const int iovcnt)
{
d332 1
a332 11
  const int e = get_errno ();

  int res = -1;

  const ssize_t tot = check_iovec_for_read (iov, iovcnt);

  if (tot <= 0)
    {
      res = tot;
      goto done;
    }
d340 1
a340 7
	break;

      if ((cfd->get_flags () & O_ACCMODE) == O_WRONLY)
	{
	  set_errno (EBADF);
	  break;
	}
d345 2
a346 2
      syscall_printf ("readv (%d, %p, %d) %sblocking, sigcatchers %d",
		      fd, iov, iovcnt, wait ? "" : "non", sigcatchers);
d360 1
a360 1
	break;
d367 1
a367 4
	{
	  res = -1;
	  break;
	}
d373 2
a374 5
	    {
	      res = -1;
	      break;
	    }
	  res = cfd->readv (iov, iovcnt, tot);
d379 8
d392 1
a392 2
done:
  syscall_printf ("%d = readv (%d, %p, %d), errno %d", res, fd, iov, iovcnt,
d399 1
a399 1
writev (const int fd, const struct iovec *const iov, const int iovcnt)
a401 1
  const ssize_t tot = check_iovec_for_write (iov, iovcnt);
d408 2
a409 1
  if (tot <= 0)
d411 1
a411 1
      res = tot;
d415 2
a416 5
  if ((cfd->get_flags () & O_ACCMODE) == O_RDONLY)
    {
      set_errno (EBADF);
      goto done;
    }
d420 1
a420 1
    paranoid_printf ("writev (%d, %p, %d)", fd, iov, iovcnt);
d422 1
a422 1
    syscall_printf  ("writev (%d, %p, %d)", fd, iov, iovcnt);
d429 1
a429 1
      res = cfd->writev (iov, iovcnt, tot);
d431 3
d438 1
a438 2
    paranoid_printf ("%d = write (%d, %p, %d), errno %d",
		     res, fd, iov, iovcnt, get_errno ());
d440 58
a497 2
    syscall_printf ("%d = write (%d, %p, %d), errno %d",
		    res, fd, iov, iovcnt, get_errno ());
d499 32
a530 2
  MALLOC_CHECK;
  return res;
@


1.149.2.24
log
@Merged changes from HEAD
@
text
@d1946 3
a1948 1
      || (uid == myself->uid && !cygheap->user.groups.ischanged))
a1953 6
  if (uid == ILLEGAL_UID)
    {
      set_errno (EINVAL);
      return -1;
    }

d2125 3
a2127 1
  if (!wincap.has_security () || gid == myself->gid)
a2128 6

  if (gid == ILLEGAL_GID)
    {
      set_errno (EINVAL);
      return -1;
    }
@


1.149.2.25
log
@Merged changes from HEAD
@
text
@d651 9
a659 4
      hFileSource = CreateFile (real_a, FILE_WRITE_ATTRIBUTES,
				FILE_SHARE_READ | FILE_SHARE_WRITE /*| FILE_SHARE_DELETE*/,
				&sec_none_nih, // sa
				OPEN_EXISTING, 0, NULL);
d2436 6
a2441 4
		      GENERIC_READ | GENERIC_WRITE,
		      FILE_SHARE_READ | FILE_SHARE_WRITE,
		      &sec_none_nih, OPEN_EXISTING,
		      FILE_ATTRIBUTE_NORMAL, NULL);
@


1.149.2.26
log
@Merged changes from HEAD
@
text
@d786 1
a786 1
	  if (win32_path.isdir ())
d1972 1
a1972 1
  RevertToSelf ();
d1982 1
a1982 1
  debug_printf ("Process token %sverified", process_ok ? "" : "not ");
d1999 1
a1999 1
      debug_printf ("Thread token %d %sverified",
d2017 2
a2018 2
  char dacl_buf[MAX_DACL_LEN (5)];
  if (usersid != (origpsid =  cygheap->user.orig_sid ())) psid2 = usersid;
d2033 1
a2033 1
	 authenticate using NtCreateToken () or subauthentication. */
d2062 1
a2062 1
				    &groups.pgsid, sizeof (cygsid)))
@


1.148
log
@        * syscalls.cc (_open): Set name in fhandler object after successful
        creation.
        (stat_dev): Set device type to block device in FH_FLOPPY case.
@
text
@d84 19
d511 1
a511 1
	  else 
d513 2
a514 8
	      fh->set_name (unix_path, pc.get_win32 ());
	      if (!fh->open (pc, flags, (mode & 07777) & ~cygheap->umask))
		{
		  cygheap->fdtab.release (fd);
		  res = -1;
		}
	      else if ((res = fd) <= 2)
		set_std_handle (res);
d516 2
@


1.147
log
@* dtable.cc (dtable::build_fhandler): Accept an optional path_conv argument.
If available, use this to calculate path name and device number.
* dtable.h (dtable): Reflect above change.
* fhandler.h (fhandler_base): Declare virtual method which accepts path_conv
rather than path string as first argument.
* fhandler.cc (fhandler_base::open): Define above new method.
* syscalls.cc (_open): Set aside a path_conv variable for use in build_fhandler
and subsequent call to open.
@
text
@d490 1
a490 1
	  if ((fh = cygheap->fdtab.build_fhandler (fd, unix_path, NULL, &pc)) == NULL)
d492 1
a492 1
	  else if (!fh->open (pc, flags, (mode & 07777) & ~cygheap->umask))
d494 8
a501 2
	      cygheap->fdtab.release (fd);
	      res = -1;
a502 2
	  else if ((res = fd) <= 2)
	    set_std_handle (res);
d1050 1
a1050 1
  buf->st_mode |= S_IFCHR;
@


1.146
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@d487 1
a487 3
      else if ((fh = cygheap->fdtab.build_fhandler (fd, unix_path, NULL)) == NULL)
	res = -1;		// errno already set
      else if (!fh->open (unix_path, flags, (mode & 07777) & ~cygheap->umask))
d489 10
a498 2
	  cygheap->fdtab.release (fd);
	  res = -1;
a499 2
      else if ((res = fd) <= 2)
	set_std_handle (res);
@


1.145
log
@* path.cc (symlink): Check arguments for validity.
(getcwd): Ditto.
* syscalls.cc (ftruncate): Ditto.
* times.cc (times): Ditto.
* uname.cc (uname): Ditto.
@
text
@d298 1
a298 1
      if (wait && (!sigcatchers || !fh->is_slow () || fh->get_r_no_interrupt ()))
@


1.144
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d1771 5
a1775 1
  if (cygheap->fdtab.not_open (fd))
@


1.143
log
@* exceptions.cc (call_signal_handler_now): Add additional guard against
inappropriately calling signal handler.
* syscalls.cc (_read): Reset errno if not exiting due to signal.
@
text
@d153 1
a153 1
  if (!iswinnt && lasterr == ERROR_ACCESS_DENIED
d171 2
a172 1
  delete_on_close_ok  = !win32_name.isremote () && iswinnt;
d613 1
a613 1
  if (iswinnt)
d615 6
d736 1
a736 1
  if (!iswinnt)    // real chown only works on NT
d1103 1
a1103 1
       (iswinnt
d1367 1
a1367 1
  if (iswinnt)
d1491 1
a1491 1
  if (!iswinnt)
d2032 1
a2032 1
  if (iswinnt)
d2247 1
a2247 1
  if (iswinnt)
@


1.142
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d278 1
d322 1
@


1.141
log
@        * include/limits.h: Define PIPE_BUF.
        * syscalls.cc (fpathconf): Use PIPE_BUF instead of numerical constant.
        (pathconf): Ditto.
@
text
@d1141 1
a1141 1
			            && get_errno () != ENOSHARE)))
d1343 1
a1343 1
    			real_new.file_attributes () & ~FILE_ATTRIBUTE_READONLY);
d1403 1
a1403 1
         new filename is equal to the shortcut name without .lnk suffix. */
d1405 1
a1405 1
        {
d1497 1
a1497 1
          || GetDriveType (root) == DRIVE_REMOTE))
d1587 1
a1587 1
        path_conv full_path (file, PC_SYM_FOLLOW | PC_FULL);
d1598 1
a1598 1
        return check_posix_perm (full_path, v);
d2051 1
a2051 1
        strncat (orig_username, env, UNLEN + 1);
d2053 1
a2053 1
        strncat (orig_domain, env, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d2067 1
a2067 1
	  				 sizeof tok_usersid, &siz))
d2103 1
a2103 1
	          tok_usersid = NO_SID;
d2122 1
a2122 1
	          (current_token_is_internal_token &&
d2146 1
a2146 1
	        {
d2152 1
a2152 1
	        {
d2158 1
a2158 1
	        }
d2171 1
a2171 1
	         already been set correctly. */
d2173 1
a2173 1
	        {
d2189 1
a2189 1
	        }
d2199 1
a2199 1
	        {
d2203 1
a2203 1
	        }
d2256 1
a2256 1
	        {
d2264 1
a2264 1
		      				&gsid, sizeof gsid))
d2269 1
a2269 1
	        }
@


1.140
log
@* child_info.h: Modify magic number.
* dcrt0.cc (_cygwin_testing): Define.
(_dll_crt0): Set _cygwin_testing if CYGWIN_TESTING environment variable exists.
Don't issue "conflicting versions" error if _cygwin_testing is true.
* shared.cc (shared_name): Use _cygwin_testing global rather than testing the
environment.
* syscalls.cc (_write): Remove debugging info.
@
text
@d1536 1
a1536 1
      return 4096;
d1578 1
a1578 1
      return 4096;
@


1.139
log
@* syscalls.cc (check_tty_fds): New function.  Check whether there is a fd
referring to pty slave.
(setsid): Don't detach console if the process has a pty slave.
@
text
@d351 1
a351 1
syscall_printf ("write fh %p, name '%s' bg_check %d, bg_eof %d", fh, fh->get_name(), res, bg_eof);
@


1.138
log
@* dtable.cc (dtable::dup2): Allow extension of fd table by dup2.
* syscalls.cc: Minor code cleanup.
(fpathconf): Check for bad fd before doing anything else.
* termios.cc (tcsetattr): Don't convert to new termios if bad fd.
(tcgetattr): Minor debugging tweak.
@
text
@d68 16
a255 1
  /* FIXME: for now */
d258 3
a260 1
      if (myself->ctty == TTY_CONSOLE && !cygheap->fdtab.has_console_fds ())
@


1.137
log
@        * resource.cc (getrlimit): Return getdtablesize () as current limit
        on RLIMIT_NOFILE.
        * syscalls.cc (getdtablesize): Return OPEN_MAX if current dtable size
        is less than OPEN_MAX, the current dtable size otherwise.
        * sysconf.cc (sysconf): Return getdtablesize () on _SC_OPEN_MAX.
@
text
@d1497 5
d1533 7
a1539 10
      if (cygheap->fdtab.not_open (fd))
	set_errno (EBADF);
      else
        {
          fhandler_base *fh = cygheap->fdtab[fd];
	  if (fh->get_device () == FH_DISK)
	    return check_posix_perm (fh->get_win32_name (), v);
	  set_errno (EINVAL);
        }
      return -1;
a1776 1
/* FIXME: untested */
d1787 1
a1787 3
    {
      set_errno (EBADF);
    }
d1804 1
a1804 3
    {
      set_errno (EBADF);
    }
d1806 2
a1807 3
    {
      res = (long) cygheap->fdtab[fd]->get_handle ();
    }
a1808 1

@


1.136
log
@        * resource.cc (getrlimit): Return OPEN_MAX as current limit
        on RLIMIT_NOFILE.
        * syscalls.cc (getdtablesize): Return OPEN_MAX.
        * sysconf.cc (sysconf): Return OPEN_MAX on _SC_OPEN_MAX.
        * include/limits.h (OPEN_MAX): Define as 256.
@
text
@d1448 1
a1448 1
  return OPEN_MAX;
@


1.135
log
@        * fhandler.cc (fhandler_base::is_nonblocking): New method.
        (fhandler_base::set_nonblocking): Ditto.
        * fhandler.h (fhandler_base): Declare new methods `is_nonblocking' and
        `set_nonblocking'.
        * fhandler_socket.cc (fhandler_socket::ioctl): Use `set_nonblocking'.
        * fhandler_tty.cc (fhandler_pty_master::process_slave_output):
        Use `is_nonblocking'.
        (fhandler_tty_slave::read): Ditto.
        (fhandler_tty_slave::ioctl): Use `set_nonblocking'.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (cygwin_sendto): Fallback to winsock 1 functionality
        in case of nonblocking IO.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * syscalls.cc (_read): Use `is_nonblocking'.
@
text
@d1448 1
a1448 1
  return cygheap->fdtab.size;
@


1.134
log
@        * fhandler.cc (fhandler_base::fcntl): Use new O_NONBLOCK_MASK define.
        * fhandler.h: Move definitions of O_NOSYMLINK, O_DIROPEN and
        OLD_O_NDELAY from winsup.h to here. Add O_NONBLOCK_MASK define.
        * fhandler_socket.cc (fhandler_socket::close): Add hack to allow
        a graceful shutdown even if shutdown() hasn't been called by the
        application. Add debug output.
        (fhandler_socket::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_socket::fcntl): Use new O_NONBLOCK_MASK define. Actually
        set `request' before using it.
        * fhandler_tty.cc: Use new O_NONBLOCK_MASK define throughout.
        (fhandler_tty_slave::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (wsock_event::prepare): Compare WSACreateEvent return code
        with `WSA_INVALID_EVENT' according to MSDN.
        * syscalls.cc (_read): Use new O_NONBLOCK_MASK define.
@
text
@d274 1
a274 1
      DWORD wait = (fh->get_flags () & O_NONBLOCK_MASK) ? 0 : INFINITE;
@


1.133
log
@        * security.cc (alloc_sd): Don't set FILE_DELETE_CHILD for group
        if S_ISVTX attribute is given.
        * dir.cc (mkdir): Allow immediate setting of S_ISUID, S_ISGID and
        S_ISVTX attribute.
        * syscalls.cc (_open): Ditto.
@
text
@d274 1
a274 1
      DWORD wait = (fh->get_flags () & (O_NONBLOCK | OLD_O_NDELAY)) ? 0 : INFINITE;
@


1.132
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d469 1
a469 1
      else if (!fh->open (unix_path, flags, (mode & 0777) & ~cygheap->umask))
@


1.131
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d137 1
a137 1
  if (os_being_run != winNT && lasterr == ERROR_ACCESS_DENIED
d155 1
a155 1
  delete_on_close_ok  = !win32_name.isremote () && os_being_run == winNT;
d593 1
a593 1
  if (os_being_run == winNT)
d710 1
a710 1
  if (os_being_run != winNT)    // real chown only works on NT
d1077 1
a1077 1
       (os_being_run == winNT
d1341 1
a1341 1
  if (os_being_run == winNT)
d1465 1
a1465 1
  if (os_being_run != winNT)
d2011 1
a2011 1
  if (os_being_run == winNT)
d2226 1
a2226 1
  if (os_being_run == winNT)
@


1.130
log
@* syscalls.cc (setsid): Detach process from its console if the current
controlling tty is the console and already closed.
* dtable.h (class dtable): Add members to count descriptors referring to the
console.
* dtable.cc (dtable::dec_console_fds): New function to detach process from its
console.
(dtable::release): Decrement the counter of console descriptors.
(dtable::build_fhandler): Increment it.
* exception.cc (ctrl_c_handler): Send SIGTERM to myself when catch
CTRL_SHUTDOWN_EVENT.
@
text
@d31 1
a39 1
#include "security.h"
@


1.129
log
@        * syscalls.cc (_unlink): Explicitely check for non-existant file.
@
text
@d243 2
@


1.128
log
@* syscalls.cc (stat_worker): Simplify previous change.
@
text
@d86 8
a93 1
  if (atts != 0xffffffff && atts & FILE_ATTRIBUTE_DIRECTORY)
d108 1
a108 1
  if (atts != 0xffffffff && atts & FILE_ATTRIBUTE_READONLY)
@


1.127
log
@* syscalls.cc (_unlink): Correct (?) logic which determines when to report an
access violation and when to queue file for eventual deletion.
(stat_worker): Check for invalid buf argument.
@
text
@a1034 1
  int err;
d1052 3
a1054 5
  if ((err = check_null_invalid_struct_errno (buf)))
    {
      set_errno (err);
      goto done;
    }
@


1.126
log
@Change check_null_empty_path* to check_null_empty_str* throughout.
* path.cc (path_conv::check): Add signal protection here since retrieving info
about remote shares can take some time.
* path.h (check_null_empty_str_errno): Convert to a function prototype.
* path.cc (check_null_empty_str): Move to miscfuncs.cc.
* miscfuncs.cc (check_null_empty_str_errno): New function.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(check_null_empty_str): Change from VirtualQuery to IsBadWritePtr.
* thread.cc (check_valid_pointer): Ditto.
* resource.cc (getrlimit): Use check_null_invalid_struct macro for checking
validity of pointer.
(setrlimit): Ditto.
@
text
@d127 7
d171 4
a174 6
  /* FILE_FLAGS_DELETE_ON_CLOSE was a bust.  If delete_on_close_ok is
     true then it should have worked.  If it didn't work, that was an
     error.  Windows 9x seems to return ERROR_ACCESS_DENIED in "sharing
     violation" type of situations. */
  if (delete_on_close_ok
      || (lasterr != ERROR_ACCESS_DENIED && lasterr != ERROR_SHARING_VIOLATION))
a176 8
  /* Can't reliably detect sharing violations on remote shares, so if we
     didn't specifically get that error, then punt. */
  if (lasterr != ERROR_SHARING_VIOLATION && win32_name.isremote ())
    {
      syscall_printf ("access denied on remote drive");
      goto err;  /* Can't detect this, unfortunately */
    }

d1035 1
d1053 5
@


1.125
log
@* fhandler.cc (fhandler_disk_file::fstat): Don't rely on exactly 3 characters
being read for executable test since we could be checking for less than that.
* syscalls.cc (stat_worker): Try opening the file the "correct" way first so
that #! processing can potentially happen.  If that fails, then use "query
open" method.
* spawn.cc (spawn_guts): Delay processing of signal until after we've notified
parent about reparenting.
@
text
@d448 1
a448 1
  if (!check_null_empty_path_errno (unix_path))
d701 1
a701 1
  if (check_null_empty_path_errno (name))
@


1.124
log
@forced commit
@
text
@a1071 1
      fh.set_query_open (TRUE);
d1074 8
@


1.123
log
@* fhandler_tty.cc (fhandler_tty_slave::init): Revert 2001-06-16 change.
* fork.cc (fork_copy): Print more debugging info.
(fork_parent): Change order of arguments to accomdate buggy gcc.
(fork): Ditto.
* syscalls.cc (_unlink): Reorganize to try harder to delete file with
DeleteFile and to recover more gracefully if FILE_FLAG_DELETE_ON_CLOSE doesn't
work properly.
@
text
@@


1.122
log
@* fhandler.cc (fhandler_base::open): Set win32 access flags
to 0, when requested.
* fhandler.h: New status flag FH_QUERYOPEN.
(fhandler::get_query_open): New function.
(fhandler::set_query_open): Ditto.
* syscalls.cc (stat_worker): Request query-only open mode.
@
text
@d103 3
a105 4
      int len = strlen (win32_name.get_win32 ());
      if (len > 4 && strcasematch (win32_name.get_win32 () + len - 4, ".lnk"))
	SetFileAttributes (win32_name.get_win32 (),
		      win32_name.file_attributes () & ~FILE_ATTRIBUTE_READONLY);
d108 2
d115 1
a115 2
	  res = 0;
	  break;
a117 1
      DWORD lasterr;
d119 2
d122 4
a125 15
      /* FIXME: There's a race here. */
      HANDLE h = CreateFile (win32_name, GENERIC_READ,
			    FILE_SHARE_READ,
			    &sec_none_nih, OPEN_EXISTING,
			    FILE_FLAG_DELETE_ON_CLOSE, 0);
      if (h != INVALID_HANDLE_VALUE)
	{
	  CloseHandle (h);
	  syscall_printf ("CreateFile/CloseHandle succeeded");
	  if (os_being_run == winNT || GetFileAttributes (win32_name) == (DWORD) -1)
	    {
	      res = 0;
	      break;
	    }
	}
d127 2
a128 4
      if (i > 0)
	{
	  if (os_being_run == winNT || lasterr != ERROR_ACCESS_DENIED)
	    goto err;
d130 3
a132 7
	  if (win32_name.isremote ())
	    {
	      syscall_printf ("access denied on remote drive");
	      goto err;  /* Can't detect this, unfortunately */
	    }
	  lasterr = ERROR_SHARING_VIOLATION;
	}
d134 4
a137 1
      syscall_printf ("i %d, couldn't delete file, %E", i);
d139 1
a139 8
      /* If we get ERROR_SHARING_VIOLATION, the file may still be open -
	 Windows NT doesn't support deleting a file while it's open.  */
      if (lasterr == ERROR_SHARING_VIOLATION)
	{
	  cygwin_shared->delqueue.queue_file (win32_name);
	  res = 0;
	  break;
	}
d141 1
a141 6
      /* if access denied, chmod to be writable in case it is not
	 and try again */
      /* FIXME: Should check whether ourname is directory or file
	 and only try again if permissions are not sufficient */
      if (lasterr == ERROR_ACCESS_DENIED && chmod (win32_name, 0777) == 0)
	continue;
d143 9
a151 4
    err:
      __seterrno ();
      res = -1;
      break;
d153 41
d195 1
a195 1
done:
d2108 1
a2108 1
	  /* If no impersonation token is available, try to 
@


1.121
log
@        * syscalls.cc (seteuid): Set environment variables USERNAME and
        USERDOMAIN before impersonation to workaround a LookupAccountSid()
        misbehaviour.
        * uinfo.cc (internal_getlogin): Revert most of the previous change.
        Don't set environment variables USERNAME and USERDOMAIN. That's
        the job of seteuid() now. Try to get logon server from Lsa
        only if logon server isn't already known.
@
text
@d1051 1
@


1.120
log
@* security.h (NTWriteEA): Change prototype.
* ntea.cc (NTReadEA): Don't check for global ntea setting, now
it's caller responsibility.
(NTWriteEA): Ditto.
* security.cc (get_file_attribute): Read attribute from EA only
if 'ntea' is enabled.
(set_file_attribute): Ditto.
* path.h: (class path_conv): Add members to store file system
information.
(path_conv::get_drive_type): New function.
* syscalls.cc (stat_worker): Use it.
* path.cc (path_conv::update_fs_info): New functions.
(path_conv::check): Get file system information from device where
file resides. On NTFS, try to read symlink contents from EA.
(get_symlink_ea): New function.
(set_symlink_ea): Ditto.
(symlink): Store symlink in extended attribute, if possible.
@
text
@d25 1
d1975 8
d1995 9
d2006 1
d2012 17
d2032 1
a2032 2
	  cygsid usersid, pgrpsid, tok_usersid, tok_pgrpsid;
	  DWORD siz;
d2142 4
a2145 1
	      if (!ImpersonateLoggedOnUser (cygheap->user.token))
d2149 5
a2153 1
		cygheap->user.impersonated = TRUE;
d2169 2
@


1.119
log
@* cygheap.cc (cygheap_root::cygheap_rot): Remove constructor.
(cygheap_root::~cygheap_root): Remove destructor.
(cygheap_root::operator =): Remove.
(cygheap_root::set): New method.
* cygheap.h (cygheap_root): Reflect above changes.  Store root info in
mount-like structure.
(cygheap_root:posix_ok): New method.
(cygheap_root::ischroot_native): Ditto.
(cygheap_root::unchroot): Ditto.
(cygheap_root::exists): Ditto.
(cygheap_root::posix_length): Ditto.
(cygheap_root::posix_path): Ditto.
(cygheap_root::native_length): Ditto.
(cygheap_root::native_path): Ditto.
* dir.cc (opendir): Remove special chroot test.
* path.cc (path_prefix_p): Remove front end.
(normalize_posix_path): Reorganize chroot tests to accomodate new convention of
allowing paths using posix chroot prefix.
(path_conv::check): Pass a "already ran normalize" option to
conv_to_win32_path.  Return if there is an error from this function.
(mount_info::conv_to_win32_path): Add extra argument.  Don't call
normalize_posix_path if caller has already done so.  Substitute chroot setting,
if any, for root translation.  Add chroot checking to final output step.
* shared_info (mount_info): Accomodate additional argument to
conv_to_win32_path.
* syscalls.cc (chroot): Store both normalized posix path and native path in
chroot.
@
text
@d1043 1
a1043 1
  dtype = real_path.drive_type;
@


1.118
log
@        * syscalls.cc (_rename): Handle the case that `foo' is renamed to
        `bar' while `bar.lnk' is an existing shortcut-symlink.
@
text
@d41 2
d2200 1
a2200 1
  if (! (path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY))
d2205 3
a2207 8
  char buf[MAX_PATH + 1];
  ret = mount_table->conv_to_posix_path (path.get_win32 (), buf, 0);
  if (ret)
    {
      set_errno (ret);
      goto done;
    }
  cygheap->root = buf;
@


1.117
log
@* path.cc (chdir): Always send unsigned chars to isspace since newlib's isspace
doesn't deal well with "negative" chars.
* fhandler.cc (fhandler_disk_file::open): Propagate remote status of file
garnered from path_conv.  Move #! checking to fstat.
(fhandler_disk_file::fstat): Reorganize st_mode setting to eliminate
duplication.  Move check for #! here from fhandler::open.
* fhandler.h (fhandler_base::isremote): New method.
(fhandler_base::set_isremote): Ditto.
(fhandler_base::set_execable_p): Also record "don't care if executable state".
(fhandler_base::dont_care_if_execable): New method.
* path.cc (path_conv::check): Clear new flags.  Appropriately set vol_flags,
drive_type, and is_remote_drive.
* path.h: Add new flags and methods for manipulating them.
* syscalls.cc (_unlink): Use isremote() to determine if a path is remote rather
than calling GetDriveType.
(stat_worker): Ditto.
* security.cc (get_file_attribute): Or attribute with result of NTReadEA to be
consistent with get_nt_attribute.
@
text
@d1231 1
d1280 2
d1284 8
a1291 5
    {
      /* Destination file exists and is read only, change that or else
	 the rename won't work. */
      SetFileAttributesA (real_new.get_win32 (), real_new.file_attributes () & ~ FILE_ATTRIBUTE_READONLY);
    }
d1331 8
a1338 3
    __seterrno ();

  if (res == 0)
d1342 9
@


1.116
log
@        * syscalls.cc (seteuid): Restrict overriding external provided
        user tokens to ntsec. Don't test external tokens for primary
        group to evaluate if it should be overridden. Restrict creating
        internal tokens to ntsec.
@
text
@a135 1
	  DWORD dtype;
d139 1
a139 4
	  char root[MAX_PATH];
	  strcpy (root, win32_name);
	  dtype = GetDriveType (rootdir (root));
	  if (dtype & DRIVE_REMOTE)
d707 1
a707 1
				 (int *) &attrib,
a1014 1
  char root[MAX_PATH];
d1041 1
a1041 2
  strcpy (root, real_path.get_win32 ());
  dtype = GetDriveType (rootdir (root));
d1105 3
a1107 2
	  || get_file_attribute (real_path.has_acls (), real_path.get_win32 (),
				 &buf->st_mode, &buf->st_uid, &buf->st_gid))
@


1.115
log
@        * syscalls.cc (chown_worker): Don't check for ENOSYS.
@
text
@d1983 1
d1992 1
d1994 2
a1995 2
	     - if available - new pgrp == pgrp of impersonation token. */
	  if (cygheap->user.token != INVALID_HANDLE_VALUE)
d2009 7
d2017 5
a2021 1
	          (pgrpsid && tok_pgrpsid && pgrpsid != tok_pgrpsid))
d2033 1
d2036 1
a2036 1
	  if (cygheap->user.token == INVALID_HANDLE_VALUE)
d2053 3
a2055 9
		  if (sav_token != INVALID_HANDLE_VALUE)
		    {
		      TOKEN_SOURCE ts;
		      if (!GetTokenInformation (sav_token, TokenSource,
		      				&ts, sizeof ts, &siz))
			debug_printf ("GetTokenInformation(): %E");
		      else if (!memcmp (ts.SourceName, "Cygwin.1", 8))
		        CloseHandle (sav_token);
		    }
@


1.114
log
@        * autoload.cc: Add load statements for `LookupAccountNameW',
        `LsaClose', `LsaEnumerateAccountRights', `LsaFreeMemory',
        `LsaOpenPolicy', `LsaQueryInformationPolicy', `NetLocalGroupEnum',
        `NetLocalGroupGetMembers', `NetServerEnum', `NetUserGetGroups' and
        `NtCreateToken'.
        * ntdll.h: Add declaration for `NtCreateToken'.
        * sec_helper.cc: Add `well_known_local_sid', `well_known_dialup_sid',
        `well_known_network_sid', `well_known_batch_sid',
        `well_known_interactive_sid', `well_known_service_sid' and
        `well_known_authenticated_users_sid'.
        (cygsid::string): Define as const method.
        (cygsid::get_sid): Set psid to NO_SID on error.
        (cygsid::getfromstr): Ditto.
        (cygsid::getfrompw): Simplify.
        (cygsid::getfromgr): Check for gr == NULL.
        (legal_sid_type): Move to security.h.
        (set_process_privilege): Return -1 on error, otherwise 0 or 1 related
        to previous privilege setting.
        * security.cc (extract_nt_dom_user): Remove `static'.
        (lsa2wchar): New function.
        (open_local_policy): Ditto.
        (close_local_policy): Ditto.
        (get_lsa_srv_inf): Ditto.
        (get_logon_server): Ditto.
        (get_logon_server_and_user_domain): Ditto.
        (get_user_groups): Ditto.
        (is_group_member): Ditto.
        (get_user_local_groups): Ditto.
        (sid_in_token_groups): Ditto.
        (get_user_primary_group): Ditto.
        (get_group_sidlist): Ditto.
        (get_system_priv_list): Ditto.
        (get_priv_list): Ditto.
        (get_dacl): Ditto.
        (create_token): Ditto.
        (subauth): Return immediately if SE_TCB_NAME can't be assigned.
        Change all return statements in case of error to jumps to `out'
        label. Add `out' label to support cleanup.
        * security.h: Add extern declarations for `well_known_local_sid',
        `well_known_dialup_sid', `well_known_network_sid',
        `well_known_batch_sid', `well_known_interactive_sid',
        `well_known_service_sid' and `well_known_authenticated_users_sid'.
        Add extern declarations for functions `create_token',
        `extract_nt_dom_user' and `get_logon_server_and_user_domain'.
        (class cygsid): Add method `assign'. Change operator= to call new
        `assign' method. Add `debug_print' method.
        (class cygsidlist): New class.
        (legal_sid_type): Moved from sec_helper.cc to here.
        * spawn.cc (spawn_guts) Revert reversion of previous patch.
        Call `RevertToSelf' and `ImpersonateLoggedOnUser' instead of `seteuid'
        again.
        * syscalls.cc (seteuid): Rearranged. Call `create_token' now when
        needed. Call `subauth' if `create_token' fails. Try setting token
        owner and primary group only if token was not explicitely created
        by `create_token'.
        * uinfo.cc (internal_getlogin): Try harder to generate correct user
        information. Especially don't trust return value of `GetUserName'.
@
text
@d727 6
a732 6
      if (res != 0 && get_errno () == ENOSYS)
      {
	/* fake - if not supported, pretend we're like win95
	   where it just works */
	res = 0;
      }
@


1.113
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@d1957 1
a1957 1
      if (uid != (uid_t) -1)
d1959 9
a1967 6
	  struct passwd *pw_new = getpwuid (uid);
	  if (!pw_new)
	    {
	      set_errno (EINVAL);
	      return -1;
	    }
d1969 25
a1993 1
	  if (uid != myself->uid)
d1995 14
a2008 1
	      if (uid == cygheap->user.orig_uid)
d2010 2
a2011 2
		  debug_printf ("RevertToSelf () (uid == orig_uid, token=%d)",
				cygheap->user.token);
d2013 4
a2016 2
		  if (cygheap->user.token != INVALID_HANDLE_VALUE)
		    cygheap->user.impersonated = FALSE;
d2018 11
d2031 9
a2039 5
		  cygsid tsid, psid, gsid;
		  DWORD siz;

		  /* Check if new user == user of impersonation token. */
		  if (cygheap->user.token != INVALID_HANDLE_VALUE)
d2041 3
a2043 2
		      if (!GetTokenInformation (cygheap->user.token, TokenUser,
						&tsid, sizeof tsid, &siz))
d2045 2
a2046 9
		      else if (psid.getfrompw (pw_new) && tsid != psid)
		        {
			  /* If not, RevertToSelf and close old token. */
			  char tstr[256], pstr[256];
			  debug_printf ("tsid (%s) != psid (%s)",
			  		tsid.string (tstr), psid.string (pstr));
			  RevertToSelf ();
			  cygwin_set_impersonation_token (INVALID_HANDLE_VALUE);
			}
d2048 11
a2058 17
		  /* If no impersonation token is available, try to 
		     authenticate using subauthentication. */
		  if (cygheap->user.token == INVALID_HANDLE_VALUE)
		    {
		      HANDLE ptok = subauth (pw_new);
		      if (ptok != INVALID_HANDLE_VALUE)
			cygwin_set_impersonation_token (ptok);
		      else
		        cygheap->user.impersonated = TRUE;
		    }
		  /* If no impersonation is active but an impersonation
		     token is available, try to impersonate. */
		  if (cygheap->user.token != INVALID_HANDLE_VALUE &&
		      !cygheap->user.impersonated)
		    {
		      debug_printf ("Impersonate (uid == %d)", uid);
		      RevertToSelf ();
d2060 29
a2088 1
		      struct group *gr;
d2090 14
a2103 42
		      /* Try setting owner to same value as user. */
		      if (!SetTokenInformation (cygheap->user.token,
		      				TokenOwner,
						&tsid, sizeof tsid))
			debug_printf ("SetTokenInformation(user.token, "
				      "TokenOwner): %E");
		      /* Try setting primary group in token to current group. */
		      if ((gr = getgrgid (myself->gid)) &&
			  gsid.getfromgr (gr) &&
			  !SetTokenInformation (cygheap->user.token,
						TokenPrimaryGroup,
						&gsid, sizeof gsid))
			debug_printf ("SetTokenInformation(user.token, "
				      "TokenPrimaryGroup): %E");

		      /* Now try to impersonate. */
		      if (!ImpersonateLoggedOnUser (cygheap->user.token))
			system_printf ("Impersonating (%d) in set(e)uid "
				       "failed: %E", cygheap->user.token);
		      else
			cygheap->user.impersonated = TRUE;
		    }
		}

	      cygheap_user user;
	      /* user.token is used in internal_getlogin () to determine if
		 impersonation is active. If so, the token is used for
		 retrieving user's SID. */
	      user.token = cygheap->user.impersonated ? cygheap->user.token
						      : INVALID_HANDLE_VALUE;
	      struct passwd *pw_cur = internal_getlogin (user);
	      if (pw_cur != pw_new)
		{
		  debug_printf ("Diffs!!! token: %d, cur: %d, new: %d, orig: %d",
				cygheap->user.token, pw_cur->pw_uid,
				pw_new->pw_uid, cygheap->user.orig_uid);
		  set_errno (EPERM);
		  return -1;
		}
	      myself->uid = uid;
	      cygheap->user = user;
	    }
d2105 2
@


1.112
log
@        * autoload.cc: Add LoadDLLinitfunc for secur32.dll.
        Add LoadDLLfuncEx statements for AllocateLocallyUniqueId@@4,
        DuplicateTokenEx@@24, LsaNtStatusToWinError@@4,
        LsaDeregisterLogonProcess@@4, LsaFreeReturnBuffer@@4,
        LsaLogonUser@@56, LsaLookupAuthenticationPackage@@12,
        LsaRegisterLogonProcess@@12,
        * environ.cc: Add extern declaration for `subauth_id'.
        (subauth_id_init): New function for setting `subauth_id'.
        (struct parse_thing): Add entry for `subauth_id'.
        * fork.cc (fork_parent): Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * security.cc: Define global variable `subauth_id'.
        (extract_nt_dom_user): New function.
        (cygwin_logon_user): Call `extract_nt_dom_user' now.
        (str2lsa): New static function.
        (str2buf2lsa): Ditto.
        (str2buf2uni): Ditto.
        (subauth): Ditto.
        * security.h: Add prototype for `subauth'.
        * spawn.cc (spawn_guts): Use cygheap->user.token only if impersonated.
        Use `cygsid' type. Remove impersonation before allowing access to
        workstation/desktop to everyone. Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * syscalls.cc (seteuid): Rearranged to allow using subauthentication
        to retrieve user tokens when needed.
@
text
@d1987 1
a1987 1
		      else if (get_pw_sid (psid, pw_new) && tsid != psid)
d1990 3
d2009 2
a2010 1
		  if (!cygheap->user.impersonated)
d2014 24
a2037 26
		      if (cygheap->user.token != INVALID_HANDLE_VALUE)
			{
			  struct group *gr;

			  /* Try setting owner to same value as user. */
			  if (!SetTokenInformation (cygheap->user.token,
							 TokenOwner,
							 &tsid, sizeof tsid))
			    debug_printf ("SetTokenInformation(user.token, "
					  "TokenOwner): %E");
			  /* Try setting primary group in token to current group. */
			  if ((gr = getgrgid (myself->gid)) &&
			      get_gr_sid (gsid, gr) &&
			      !SetTokenInformation (cygheap->user.token,
						    TokenPrimaryGroup,
						    &gsid, sizeof gsid))
			    debug_printf ("SetTokenInformation(user.token, "
					  "TokenPrimaryGroup): %E");

			  /* Now try to impersonate. */
			  if (!ImpersonateLoggedOnUser (cygheap->user.token))
			    system_printf ("Impersonating (%d) in set(e)uid "
			    		   "failed: %E", cygheap->user.token);
			  else
			    cygheap->user.impersonated = TRUE;
			}
d2089 1
a2089 1
	      if (get_gr_sid (gsid, gr))
@


1.111
log
@Throughout, change 'tty_attached' to 'real_tty_attached', for clarity.
Throughout, change 'OutputStopped' to 'output_stopped', for consistency.
* dtable.cc (stdio_init): Set controlling tty if not set by stdio opens.
* exceptions.cc (ctrl_c_handler): Avoid special pgid checking if no tty is
associated with the process.
(Suggested by Tim Baker <dbaker@@direct.ca>)
* external.cc (fillout_pinfo): Return actual tty number for ctty.
* fhandler_console.cc (get_tty_stuff): Set ctty when shared memory is
allocated.  Accept flags input from open().
(set_console_ctty): New function.
(fhandler_console::open): Pass flags to get_tty_stuff and rely on this function
to set the ctty, if appropriate.
* fhandler_termios.cc (fhandler_termios::set_ctty): Move to tty_min class.
* fhandler_tty.cc (fhandler_tty_slave::open): Use tc field to access
set_ctty().
* tty.h (TTY_CONSOLE): Move to include/sys/cygwin.h.
(tty_min): Add set_ctty class here.
* include/sys/cygwin.h (TTY_CONSOLE): New home here.
* path.cc (symlink_info): Make contents an actual buffer.  Pass more flags to
case_check.
(path_conv::check): Reorganize to do parsing based on posix path rather than
native path.
(symlink_info::check): Expect posix path as input.  Translate to native path
here.  Accept path_conv flags.  Stop parsing if not a symlink regardless of
whether previous path was a symlink.
@
text
@d1967 46
a2012 17
	    if (uid == cygheap->user.orig_uid)
	      {
		debug_printf ("RevertToSelf () (uid == orig_uid, token=%d)",
			      cygheap->user.token);
		RevertToSelf ();
		if (cygheap->user.token != INVALID_HANDLE_VALUE)
		  cygheap->user.impersonated = FALSE;
	      }
	    else if (!cygheap->user.impersonated)
	      {
		debug_printf ("Impersonate (uid == %d)", uid);
		RevertToSelf ();
		if (cygheap->user.token != INVALID_HANDLE_VALUE)
		  {
		    struct group *gr;
		    cygsid sid;
		    DWORD siz;
d2014 14
a2027 17
		    /* Try setting owner to same value as user. */
		    if (!GetTokenInformation (cygheap->user.token, TokenUser,
					      &sid, sizeof sid, &siz))
		      debug_printf ("GetTokenInformation(): %E");
		    else if (!SetTokenInformation (cygheap->user.token,
		    				   TokenOwner,
						   &sid, sizeof sid))
		      debug_printf ("SetTokenInformation(user.token, "
		      		    "TokenOwner): %E");
		    /* Try setting primary group in token to current group. */
	            if ((gr = getgrgid (myself->gid)) &&
		        get_gr_sid (sid, gr) &&
		        !SetTokenInformation (cygheap->user.token,
		      			      TokenPrimaryGroup,
					      &sid, sizeof sid))
		      debug_printf ("SetTokenInformation(user.token, "
		    		    "TokenPrimaryGroup): %E");
d2029 9
a2037 8
		    /* Now try to impersonate. */
		    if (!ImpersonateLoggedOnUser (cygheap->user.token))
		      system_printf ("Impersonate (%d) in set(e)uid failed: %E",
				     cygheap->user.token);
		    else
		      cygheap->user.impersonated = TRUE;
	          }
	      }
d2039 17
a2055 14
	  cygheap_user user;
	  /* user.token is used in internal_getlogin () to determine if
	     impersonation is active. If so, the token is used for
	     retrieving user's SID. */
	  user.token = cygheap->user.impersonated ? cygheap->user.token
						  : INVALID_HANDLE_VALUE;
	  struct passwd *pw_cur = internal_getlogin (user);
	  if (pw_cur != pw_new)
	    {
	      debug_printf ("Diffs!!! token: %d, cur: %d, new: %d, orig: %d",
			    cygheap->user.token, pw_cur->pw_uid,
			    pw_new->pw_uid, cygheap->user.orig_uid);
	      set_errno (EPERM);
	      return -1;
a2056 2
	  myself->uid = uid;
	  cygheap->user = user;
@


1.110
log
@        * uinfo.cc (internal_getlogin): Return pointer to struct passwd.
        (uinfo_init): Accommodate the above change.
        * syscalls.cc (seteuid): Ditto.
@
text
@d1547 1
a1547 1
  if (!tty_attached (myself))
@


1.109
log
@        * autoload.cc: Add LoadDLLfunc statements for SetTokenInformation@@16.
        * cygheap.cc: Include security.h.
        * grp.cc (internal_getgrent): New function.
        (getgroups): Rearranged using `internal_getgrent' and the new
        `cygsid' class.
        * passwd.cc (internal_getpwent): New function.
        * sec_acl.cc: Use new `cygsid' class throughout.
        (acl_access): Use `internal_getgrent' instead of `getgrent'.
        * sec_helper.cc: Use new `cygsid' class throughout.
        (get_id_from_sid): Use `internal_getgrent' instead of `getgrent'.
        Use `internal_getpwent' instead of `getpwent'.
        * security.cc: Use new `cygsid' class throughout.
        * security.h: Move `MAX_SID_LEN' from winsup.h to here.
        Add extern declarations for `internal_getgrent' and `internal_getpwent'.
        (class cygsid): New class.
        * shared.cc (sec_user): Use new `cygsid' class.
        * syscalls.cc (seteuid): Try to set owner to user and primary group to
        current group in impersonation token before performing impersonation.
        (setegid): Try to set primary group in process token to the new group
        if ntsec is on.
        * uinfo.cc (internal_getlogin): Use new `cygsid' class.
        Try to set owner to user and primary group to current group in process
        token if the process has been started from a non cygwin process.
        (uinfo_init): Set primary group only if the process has been started
        from a non cygwin process.
        * winsup.h: Move define for `MAX_SID_LEN' to security.h.
@
text
@d1948 1
a1948 1
extern const char *internal_getlogin (cygheap_user &user);
d2018 1
a2018 1
	  struct passwd *pw_cur = getpwnam (internal_getlogin (user));
@


1.108
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@d1980 30
a2009 5
		  if (!ImpersonateLoggedOnUser (cygheap->user.token))
		    system_printf ("Impersonate (%d) in set (e)uid failed: %E",
				   cygheap->user.token);
		  else
		    cygheap->user.impersonated = TRUE;
d2046 3
a2048 1
	  if (!getgrgid (gid))
d2054 21
@


1.107
log
@* fhandler.h (fhandler_base::clear_r_binary): New method.
(fhandler_base::clear_w_binary): New method.
* syscalls.cc (setmode): Accept 0 as mode value.  Resets text/binary behavior
for fd to default.
@
text
@d1654 3
a1656 1
  if (mode & O_BINARY)
d1661 1
a1661 1
  else if (mode & O_TEXT)
a1665 5
  else
    {
      p->clear_w_binary ();
      p->clear_r_binary ();
    }
a1676 1

@


1.106
log
@* net.cc [errmap]: Add '0' condition.
(find_winsock_errno): Don't translate no error to EPERM.
@
text
@d1649 2
d1652 1
a1652 1
    res = O_TEXT;
d1659 1
a1659 1
  else
d1663 5
@


1.105
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d1633 1
a1633 1
  if (mode != O_BINARY  && mode != O_TEXT)
@


1.104
log
@        * path.cc (path_conv::check): Set case_clash even if pcheck_case
        is set to PCHECK_ADJUST when a case clash is given for the last
        component in path.
        (symlink_info::case_check): Ditto.
        * syscalls.cc (_rename): Avoid overwriting an already existing file
        if a case clash is given even if pcheck_case is set to PCHECK_ADJUST.
@
text
@d51 1
a51 1
  SetResourceLock (LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
d54 2
a55 2
  for (int i = 0; i < (int) fdtab.size; i++)
    if ((fh = fdtab[i]) != NULL)
d58 1
a58 1
	fdtab.release (i);
d61 1
a61 1
  ReleaseResourceLock (LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
d240 1
a240 1
      if (fdtab.not_open (fd))
d247 1
a247 1
      fh = fdtab[fd];
d292 1
a292 1
  if (fdtab.not_open (fd))
d305 1
a305 1
  fh = fdtab[fd];
d308 1
d437 1
a437 1
      fd = fdtab.find_unused_handle ();
d441 1
a441 1
      else if ((fh = fdtab.build_fhandler (fd, unix_path, NULL)) == NULL)
d445 1
a445 1
	  fdtab.release (fd);
d468 1
a468 1
  else if (fdtab.not_open (fd))
d475 1
a475 1
      res = fdtab[fd]->lseek (pos, dir);
d491 1
a491 1
  if (fdtab.not_open (fd))
d500 2
a501 2
      res = fdtab[fd]->close ();
      fdtab.release (fd);
d516 1
a516 1
  if (fdtab.not_open (fd))
d522 1
a522 1
  res = fdtab[fd]->is_tty ();
d759 1
a759 1
  if (fdtab.not_open (fd))
d766 1
a766 1
  const char *path = fdtab[fd]->get_name ();
d871 1
a871 1
  if (fdtab.not_open (fd))
d878 1
a878 1
  const char *path = fdtab[fd]->get_name ();
d928 1
a928 1
  if (fdtab.not_open (fd))
d937 1
a937 1
      r = fdtab[fd]->fstat (buf);
d949 1
a949 1
  if (fdtab.not_open (fd))
d956 1
a956 1
  HANDLE h = fdtab[fd]->get_handle ();
d1383 1
a1383 1
  if (size <= (int)fdtab.size || fdtab.extend (size - fdtab.size))
d1392 1
a1392 1
  return fdtab.size;
d1472 1
a1472 1
      if (fdtab.not_open (fd))
d1476 1
a1476 1
          fhandler_base *fh = fdtab[fd];
d1534 1
a1534 1
  if (fdtab.not_open (fd) || !fdtab[fd]->is_tty ())
d1538 1
a1538 1
  return (char *) (fdtab[fd]->ttyname ());
d1565 1
a1565 1
  if (fdtab.not_open (fd))
d1571 1
a1571 1
  fhandler_base *p = fdtab[fd];
d1613 1
a1613 1
  if (fdtab.not_open (fd))
d1619 1
a1619 1
  return fdtab[fd]->get_flags () & (O_BINARY | O_TEXT);
d1628 1
a1628 1
  if (fdtab.not_open (fd))
d1639 1
a1639 1
  fhandler_base *p = fdtab[fd];
d1684 1
a1684 1
  if (fdtab.not_open (fd))
d1690 1
a1690 1
      HANDLE h = fdtab[fd]->get_handle ();
d1696 1
a1696 1
	  prev_loc = fdtab[fd]->lseek (0, SEEK_CUR);
d1698 1
a1698 1
	  fdtab[fd]->lseek (length, SEEK_SET);
d1707 1
a1707 1
	  fdtab[fd]->lseek (prev_loc, 0);
d1745 1
a1745 1
  if (fdtab.not_open (fd))
d1751 1
a1751 1
      res = (long) fdtab[fd]->get_handle ();
d1803 1
a1803 1
  if (fdtab.not_open (fd))
d1808 1
a1808 1
  fhandler_disk_file *f = (fhandler_disk_file *) fdtab[fd];
d1889 1
a1889 1
  if (fdtab.not_open (fd))
d1894 1
a1894 1
  return (char *) (fdtab[fd]->ptsname ());
@


1.103
log
@        * dir.cc (mkdir): Check for case clash.
        * environ.cc: Add extern declaration for `pcheck_case'.
        (check_case_init): New function.
        (struct parse_thing): Add "check_case" option.
        * errno.cc (_sys_nerrlist): Add text for ECASECLASH.
        (strerror): Add case branch for ECASECLASH.
        * fhandler.cc (fhandler_disk_file::open): Check for case clash.
        * path.cc: Add global variable `pcheck_case'.
        (struct symlink_info): Add member `case_clash' and method `case_check'.
        (path_prefix_p_): Call `pathnmatch' instead of `strncasematch'.
        (pathnmatch): New funtion.
        (pathmatch): Ditto.
        (path_conv::check): Add handling for case checking.
        (symlink): Check for case clash.
        (symlink_info::check): Add parameter for case checking.
        Handle case checking.
        (symlink_info::case_check): New method.
        (chdir): Don't use unconverted path if pcheck_case==PCHECK_STRICT.
        * path.h: Add extern declarations for `pathmatch' and
        `pathnmatch'.
        (enum case_checking): New enumeration type describing
        the case checking behaviour of path conversion routines.
        (class path_conv): Add member `case_clash'.
        * syscalls.cc (_link): Check for case clash.
@
text
@d1249 1
a1249 1
  if (real_old.issymlink () && !real_new.error)
d1261 1
a1261 1
  if (real_new.error)
d1264 1
a1264 1
      set_errno (real_new.error);
@


1.102
log
@* syscalls.cc (mkfifo): New function stub.
@
text
@d548 1
a548 1
      set_errno (real_b.error);
@


1.101
log
@        * syscalls.cc (stat_worker): Fix conditional which still allowed
        successful stat'ing of non-existant files.
@
text
@d1916 7
@


1.100
log
@* cygrun.c (main): Fix compiler warning.
* gmon.c (_mcleanup): Ditto.
* profil.c (profile_off): Ditto.
* net.cc (find_winsock_errno): New function.
(__set_winsock_errno): Use find_winsock_errno.
(cygwin_setsockopt): Detect SO_ERROR for debugging.
(cygwin_getsockopt): Ditto.  Translate error when getsockopt returns SO_ERROR.
* winsup.h: regparmize __set_winsock_errno.
* include/sys/strace.h: Document that strace functions can't use regparm.
@
text
@d1087 2
a1088 2
  if (atts != -1 || (!oret && get_errno () != ENOENT
			   && get_errno () != ENOSHARE))
@


1.99
log
@* exceptions.cc (sigframe::call_signal_handler): Return value of
call_signal_handler_now.
* sigproc.h (sigframe): Use constructor.
* syscalls.cc (_read): Correct errno test prior to calling signal handler.
@
text
@d1669 3
a1671 3
  syscall_printf ("setmode (%d, %s) returns %s\n", fd,
		  mode&O_TEXT ? "text" : "binary",
		  res&O_TEXT ? "text" : "binary");
@


1.98
log
@* thread.h (struct _winsup_t): Remove obsolete elements.  Add available_drives
element.
* path.cc (mount_info::getmntent): Report "/cygdrive" drives when mounted
drives are exhausted.
(fillout_mntent): New function.
(mount_item::getmntent): Use fillout_mntent.
(cygdrives_mntent): New function.  Returns next available "/cygdrive".
(setmntent): Initialize available "/cygdrives".
* syscalls.cc: Remove some if 0'ed code.
* times.cc (timezone): Use more descriptive variable name.
@
text
@d276 1
a276 1
      if (res >= 0 || get_errno () == EINTR || !thisframe.call_signal_handler ())
@


1.97
log
@* sigproc.h (class sigframe): Implement 'unregister()' method.
(sigframe::~sigframe): Use unregister method.
(sigframe::call_signal_handler): Declare new method.
* exceptions.cc (sigframe::call_signal_handler): New method.  Unregisters
current sigframe before calling signal handler.
(setup_handler): Clear waiting threads prior to arming signal_arrived.
* syscalls.cc (_read): Change goto to loop.  Recalculate sigframe inside of
loop so that constructor is called when appropriate.
* wait.cc (wait4): Ditto.
* signal.cc: Change "sig" to "signal" in debugging messages throughout.
* sigproc.cc: Ditto.
@
text
@a667 32
#if 0
static BOOL
rel2abssd (PSECURITY_DESCRIPTOR psd_rel, PSECURITY_DESCRIPTOR psd_abs,
		DWORD abslen)
{
#ifdef _MT_SAFE
  struct _winsup_t *r=_reent_winsup ();
  char *dacl_buf=r->_dacl_buf;
  char *sacl_buf=r->_sacl_buf;
  char *ownr_buf=r->_ownr_buf;
  char *grp_buf=r->_grp_buf;
#else
  static char dacl_buf[1024];
  static char sacl_buf[1024];
  static char ownr_buf[1024];
  static char grp_buf[1024];
#endif
  DWORD dacl_len = 1024;
  DWORD sacl_len = 1024;
  DWORD ownr_len = 1024;
  DWORD grp_len = 1024;

  BOOL res = MakeAbsoluteSD (psd_rel, psd_abs, &abslen, (PACL) dacl_buf,
			     &dacl_len, (PACL) sacl_buf, &sacl_len,
			     (PSID) ownr_buf, &ownr_len, (PSID) grp_buf,
			     &grp_len);

  syscall_printf ("%d = rel2abssd (...)", res);
  return res;
}
#endif

@


1.96
log
@        * syscalls.cc (check_posix_perm): New static function.
        (fpathconf): Add _PC_POSIX_PERMISSIONS and _PC_POSIX_SECURITY
        support.
        (pathconf): Ditto.
        * include/cygwin/version.h: Bump API minor number to 37.
@
text
@d232 2
a233 1
  sigframe thisframe (mainthread);
a234 1
  bool sawsig;
d236 1
a236 3
beg:
  sawsig = 0;
  if (fdtab.not_open (fd))
d238 1
a238 7
      set_errno (EBADF);
      return -1;
    }

  // set_sig_errno (0);
  fhandler_base *fh = fdtab[fd];
  DWORD wait = (fh->get_flags () & (O_NONBLOCK | OLD_O_NDELAY)) ? 0 : INFINITE;
d240 38
a277 24
  /* Could block, so let user know we at least got here.  */
  syscall_printf ("read (%d, %p, %d) %sblocking, sigcatchers %d", fd, ptr, len, wait ? "" : "non", sigcatchers);

  int res;
  if (wait && (!sigcatchers || !fh->is_slow () || fh->get_r_no_interrupt ()))
    debug_printf ("non-interruptible read\n");
  else if (!fh->ready_for_read (fd, wait, 0))
    {
      if (!wait)
	set_sig_errno (EAGAIN);	/* Don't really need 'set_sig_errno' here, but... */
      else
	set_sig_errno (EINTR);
      res = -1;
      goto out;
    }

  /* Check to see if this is a background read from a "tty",
     sending a SIGTTIN, if appropriate */
  res = fh->bg_check (SIGTTIN);
  if (res > bg_eof)
    {
      myself->process_state |= PID_TTYIN;
      res = fh->read (ptr, len);
      myself->process_state &= ~PID_TTYIN;
a279 3
out:
  if (res < 0 && get_errno () == EINTR && call_signal_handler ())
    goto beg;
@


1.95
log
@Fix spacing, copyrights.
@
text
@d1431 34
d1498 12
d1529 1
a1529 1
	return _POSIX_MAX_CANON;
d1536 17
a1552 1
	return -1;
@


1.94
log
@        * net.cc (get_95_ifconf): Use strcasematch instead of strcasecmp.
        * syscalls.cc (_unlink): Ditto.
        (_rename): Ditto.
@
text
@d55 1
a55 1
    if ( (fh = fdtab[i]) != NULL)
d437 1
a437 1
      else if ( (fh = fdtab.build_fhandler (fd, unix_path, NULL)) == NULL)
d444 1
a444 1
      else if ( (res = fd) <= 2)
d943 1
a943 1
      if ( (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
d1077 1
a1077 1
  if ( (atts == -1 || ! (atts & FILE_ATTRIBUTE_DIRECTORY) ||
d1143 1
a1143 1
	  if ( (atts & FILE_ATTRIBUTE_READONLY) == 0)
d1150 1
a1150 1
      if ( (handle = FindFirstFile (real_path.get_win32 (), &wfd))
d1158 1
a1158 1
	  buf->st_blocks  = ( (unsigned long) buf->st_size +
d1395 1
a1395 1
  if ( (res = spawnvp (_P_WAIT, "sh", command)) == -1)
d2204 1
a2204 1
  if ( (fd = open (_PATH_WTMP, O_WRONLY | O_APPEND | O_BINARY, 0)) >= 0)
d2244 1
a2244 1
	  struct utmp *ut_end = (struct utmp *) ( (char *) ut_buf + rd);
d2258 1
a2258 1
		if ( (SetFilePointer (ut_fd, pos, 0, FILE_BEGIN) != 0xFFFFFFFF)
@


1.93
log
@Accomodate all devices.
@
text
@d101 1
a101 1
      if (len > 4 && !strcasecmp (win32_name.get_win32 () + len - 4, ".lnk"))
d1281 1
a1281 1
      if (!strcasecmp (real_old.get_win32 () + len_old - 4, ".lnk"))
@


1.92
log
@* syscalls.cc (stat_dev): Give devices full read/write.
@
text
@d1013 1
a1013 2
    case FH_CONIN:
    case FH_CONOUT:
@


1.91
log
@        * path.cc (lnk_suffixes): Remove.
        (class suffix_scan): Add `lnk_state' flag.
        (suffix_scan::lnk_match): Return state of `lnk_state' now.
        (suffix_scan::has): Changed behaviour if file has `.lnk' suffix.
        (suffix_scan::next): Set `lnk_state' where appropriate.
        (symlink_info::check): Fix a wrong `break'.
        * syscalls.cc (chown_worker): Change debug statement to reflect
        lchown fix.
        (lchown): Call chown_worker with `PC_SYM_NOFOLLOW' instead of
        `PC_SYM_IGNORE'.
@
text
@d1008 1
a1008 1
      buf->st_mode = STD_WBITS;
d1015 1
a1015 1
      buf->st_mode = STD_RBITS | STD_WBITS;
@


1.90
log
@* spawn.cc (spawn_guts): Don't set EXIT_REPARENTING if parent process is not a
cygwin process (suggested by Jason Gouger <cygwin@@jason-gouger.com>).
@
text
@d765 1
a765 1
		  res, (fmode & PC_SYM_IGNORE) ? "l" : "", name);
d780 1
a780 1
  return chown_worker (name, PC_SYM_IGNORE, uid, gid);
d1282 1
a1282 3
      int len_new = strlen (real_new.get_win32 ());
      if (!strcasecmp (real_old.get_win32 () + len_old - 4, ".lnk") &&
	  strcasecmp (real_new.get_win32 () + len_new - 4, ".lnk"))
@


1.89
log
@* syscalls.cc (_rename): Set errno to ENOENT when an old path doesn't exist
(from Kazuhiro Fujieda <fujieda@@jaist.ac.jp>).  Also set EACCES when directory
is not writable.
@
text
@a1006 1
    case FH_CONOUT:
a1009 1
    case FH_CONIN:
d1013 3
a1015 2
    default:
      buf->st_mode = STD_RBITS | S_IWUSR | S_IWGRP | S_IWOTH;
@


1.88
log
@* syscalls.cc (_read): Change definition to return ssize_t to be consistent
with read.
(_write): Change definition to return ssize_t to be consistent with write.
@
text
@d1271 1
a1272 1
      syscall_printf ("-1 = rename (%s, %s)", oldpath, newpath);
d1296 1
a1297 1
      syscall_printf ("-1 = rename (%s, %s)", oldpath, newpath);
d1305 1
d1312 1
@


1.87
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d229 1
a229 1
extern "C" int
d283 1
a283 1
extern "C" int
@


1.86
log
@*** empty log message ***
@
text
@d29 1
a37 1
#include "perprocess.h"
d1074 1
a1074 1
  debug_printf ("%d = GetFileAttributesA (%s)", atts, real_path.get_win32 ());
@


1.85
log
@        * cygerrno.h: Revert previous patch.
        * errno.cc: Ditto.
        * dir.cc: Eliminate `dir_suffixes'.
        (opendir): Remove usage of `dir_suffixes'.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::open): Remove usage of
        `inner_suffixes'.
        * path.cc: Rename `inner_suffixes' to `lnk_suffixes'.
        (path_conv::check): Remove usage of `inner_suffixes'.
        (symlink): Ditto.
        (symlink_info::check): Handle checking for `.lnk' in path_conv
        exclusively here.
        (chdir): Remove usage of `dir_suffixes'.
        * shortcut.c: Eliminate debug_printf lines.
        (check_shortcut): Don't set error except on failing ReadFile.
        * spawn.cc: Remove ".lnk" from `std_suffixes'.
        * syscalls.cc (_unlink): Remove usage of `inner_suffixes'.
        Remove ".lnk" from `stat_suffixes'.
        (_rename): Add check for renaming a symlink to keep the ".lnk"
        suffix after renaming.
@
text
@d51 1
a51 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
d55 1
a55 1
    if ((fh = fdtab[i]) != NULL)
d61 1
a61 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
d103 1
a103 1
	              win32_name.file_attributes () & ~FILE_ATTRIBUTE_READONLY);
d424 1
a424 1
  if (!check_null_empty_path_errno(unix_path))
d426 1
a426 1
      SetResourceLock(LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, " open ");
d437 1
a437 1
      else if ((fh = fdtab.build_fhandler (fd, unix_path, NULL)) == NULL)
d444 1
a444 1
      else if ((res = fd) <= 2)
d446 1
a446 1
      ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," open");
d459 1
a459 1
  if ( dir != SEEK_SET && dir != SEEK_CUR && dir != SEEK_END )
d461 1
a461 1
      set_errno ( EINVAL );
d495 1
a495 1
      SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
d498 1
a498 1
      ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," close");
d607 1
a607 1
	(LPBYTE) &StreamId,	// buffer to write
d621 1
a621 1
		(LPBYTE) wbuf,	// buffer to write
d671 1
a671 1
  struct _winsup_t *r=_reent_winsup();
d699 1
a699 1
 * chown() is only implemented for Windows NT.  Under other operating
d709 1
a709 1
  if (check_null_empty_path_errno(name))
d739 1
a739 1
				(int *) &attrib,
d943 1
a943 1
      if ((buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
d1079 1
a1079 1
  if ((atts == -1 || !(atts & FILE_ATTRIBUTE_DIRECTORY) ||
d1092 1
a1092 1
          && !get_file_attribute (TRUE, real_path, &attribute, &uid, &gid)
d1101 1
a1101 1
        {
d1109 1
a1109 1
	  /* Unfortunately the count of 2 confuses `find(1)' command. So
d1113 1
a1113 1
	                     ? 1
d1116 1
a1116 1
        }
d1130 1
a1130 1
      buf->st_dev = FHDEVN(FH_DISK) << 8;
d1145 1
a1145 1
	  if ((atts & FILE_ATTRIBUTE_READONLY) == 0)
d1152 1
a1152 1
      if ((handle = FindFirstFile (real_path.get_win32(), &wfd))
d1160 1
a1160 1
	  buf->st_blocks  = ((unsigned long) buf->st_size +
d1195 1
a1195 1
  if (flags & ~(F_OK|R_OK|W_OK|X_OK))
d1213 1
a1213 1
	  if (!(st.st_mode & S_IRUSR))
d1218 1
a1218 1
	  if (!(st.st_mode & S_IRGRP))
d1221 1
a1221 1
      else if (!(st.st_mode & S_IROTH))
d1228 1
a1228 1
	  if (!(st.st_mode & S_IWUSR))
d1233 1
a1233 1
	  if (!(st.st_mode & S_IWGRP))
d1236 1
a1236 1
      else if (!(st.st_mode & S_IWOTH))
d1243 1
a1243 1
	  if (!(st.st_mode & S_IXUSR))
d1248 1
a1248 1
	  if (!(st.st_mode & S_IXGRP))
d1251 1
a1251 1
      else if (!(st.st_mode & S_IXOTH))
d1397 1
a1397 1
  if ((res = spawnvp (_P_WAIT, "sh", command)) == -1)
d1429 1
a1429 1
    GetSystemInfo(&system_info);
d1506 1
a1506 1
  return (char *)(fdtab[fd]->ttyname ());
d1526 1
a1526 1
  syscall_printf("_cygwin_istext_for_stdio (%d)\n", fd);
d1529 1
a1529 1
      syscall_printf(" _cifs: old API\n");
d1535 1
a1535 1
      syscall_printf(" _cifs: fd not open\n");
d1541 1
a1541 1
  if (p->get_device() != FH_DISK)
d1543 1
a1543 1
      syscall_printf(" _cifs: fd not disk file\n");
d1549 1
a1549 1
      syscall_printf(" _cifs: get_*_binary\n");
d1553 1
a1553 1
  syscall_printf("_cygwin_istext_for_stdio says yes\n");
d1558 1
a1558 1
extern "C" int _fwalk (struct _reent *ptr, int (*function)(FILE *));
d1566 1
a1566 1
  if (fileno(f) != setmode_file)
d1568 1
a1568 1
  syscall_printf("setmode: file was %s now %s\n",
d1636 1
a1636 1
  _fwalk(_REENT, setmode_helper);
d1721 1
a1721 1
  syscall_printf ("%d = get_osfhandle(%d)", res, fd);
d1736 1
a1736 1
  path_conv full_path(fname, PC_SYM_FOLLOW | PC_FULL);
d1862 1
a1862 1
  return (char *)(fdtab[fd]->ptsname ());
d1927 1
a1927 1
		debug_printf ("RevertToSelf() (uid == orig_uid, token=%d)",
d1929 1
a1929 1
		RevertToSelf();
d1935 2
a1936 2
		debug_printf ("Impersonate(uid == %d)", uid);
		RevertToSelf();
d1939 1
a1939 1
		    system_printf ("Impersonate(%d) in set(e)uid failed: %E",
d1946 1
a1946 1
	  /* user.token is used in internal_getlogin() to determine if
d1950 1
a1950 1
					          : INVALID_HANDLE_VALUE;
d1999 1
a1999 1
  path_conv path(newroot, PC_SYM_FOLLOW | PC_FULL);
d2008 1
a2008 1
  if (!(path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY))
d2071 1
a2071 1
  return (*(unsigned short *) s1) - (*(unsigned short *) s2);
d2206 1
a2206 1
  if ((fd = open (_PATH_WTMP, O_WRONLY | O_APPEND | O_BINARY, 0)) >= 0)
d2214 1
a2214 1
cygwin's I/O subsystem may be inaccessible at logout() call time.
d2246 1
a2246 1
	  struct utmp *ut_end = (struct utmp *) ((char *) ut_buf + rd);
d2260 1
a2260 1
		if ((SetFilePointer (ut_fd, pos, 0, FILE_BEGIN) != 0xFFFFFFFF)
@


1.84
log
@        * Makefile.in: Add `-lshell32 -luuid' to link pass for new-cygwin1.dll.
        * autoload.cc: Add LoadDLLinitfunc for ole32.dll.
        Add LoadDLLfuncEx statements for CoInitialize@@4, CoUninitialize@@0
        and CoCreateInstance@@20.
        * dir.cc (dir_suffixes): New datastructure.
        (readdir): Check for R/O *.lnk files to hide the suffix.
        (opendir): Use `dir_suffixes' in path conversion.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::fstat): Add S_IFLNK flag
        before calling `get_file_attribute'. Take FILE_ATTRIBUTE_READONLY
        into account only if the file is no symlink.
        * path.cc (inner_suffixes): New datastructure.
        (SYMLINKATTR): Eliminated.
        (path_conv::check): Use `inner_suffixes' on inner path components.
        (shortcut_header): New global static variable.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): New function.
        (cmp_shortcut_header): Ditto.
        (symlink): Create symlinks by creating windows shortcuts. Preserve
        the old code.
        (symlink_info::check_shortcut): New method.
        (symlink_info::check_sysfile): Ditto.
        (symlink_info::check): Check for shortcuts. Move code reading
        old system attribute symlinks into symlink_info::check_sysfile().
        (chdir): Use `dir_suffixes' in path conversion.
        * security.cc (get_file_attribute): Check for S_IFLNK flag.
        Force 0777 permissions then.
        * spawn.cc (std_suffixes): Add ".lnk" suffix.
        * syscalls.cc (_unlink): Use `inner_suffixes' in path conversion.
        Check for shortcut symlinks to eliminate R/O attribute before
        calling DeleteFile().
        (stat_suffixes): Add ".lnk" suffix.
        (stat_worker): Force 0777 permissions if file is a symlink.
@
text
@a67 1
  extern suffix_info inner_suffixes[];
d71 1
a71 1
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW | PC_FULL, inner_suffixes);
a1032 1
  suffix_info (".lnk", 1),
d1277 16
@


1.83
log
@* signal.cc (signal): Prohibit setting handlers for SIGKILL and SIGSTOP
* signal.cc (sigaction): Ditto
* syscalls.cc (_lseek): Return EINVAL on invalid input
@
text
@d68 1
d72 1
a72 1
  path_conv win32_name (ourname, PC_SYM_NOFOLLOW | PC_FULL);
d98 9
d1034 1
d1149 2
@


1.82
log
@* syscalls.cc (mknod): Add valid parameters.
@
text
@d450 6
a455 1
  if (fdtab.not_open (fd))
@


1.81
log
@        * syscalls.cc (stat_worker): Add a check for the special case when
        a process creates a file using mode 000 using ntsec.
@
text
@d1847 1
a1847 1
mknod ()
@


1.80
log
@* syscalls.cc (_link): Make sure that newpath does not exist.  Set errno if it
does.
* cygheap.cc (init_cheap): Don't specify a load address for the heap.  It
doesn't work on #!*& Windows 9x.
(cygheap_init): Move GetUserName to memory_init.
* dcrt0.cc (dll_crt0_1): Call new memory_init functin, eliminate call to
heap_init.
* heap.cc (heap_init): Improve error output.
* heap.h: Correct some declarations.
* shared.cc (mount_table_init): Remove.
(memory_init): Renamed from shared_init.  Reorganize to accomodate strange
Windows 9x problems with cygheap/heap interaction.
* shared_info.h: Rename shared_init to memory_init.
@
text
@d1030 5
d1068 1
a1068 3
	&& dtype != DRIVE_UNKNOWN))
      && (oret = fh.open (real_path, O_RDONLY | O_BINARY | O_DIROPEN |
			  (nofollow ? O_NOSYMLINK : 0), 0)))
d1070 33
a1102 12
      res = fh.fstat (buf);
      fh.close ();
      /* The number of links to a directory includes the
	 number of subdirectories in the directory, since all
	 those subdirectories point to it.
	 This is too slow on remote drives, so we do without it and
	 set the number of links to 2. */
      /* Unfortunately the count of 2 confuses `find(1)' command. So
	 let's try it with `1' as link count. */
      if (atts != -1 && (atts & FILE_ATTRIBUTE_DIRECTORY))
	buf->st_nlink =
	    (dtype == DRIVE_REMOTE ? 1 : num_entries (real_path.get_win32 ()));
d1104 2
a1105 2
  else if (atts != -1 || (!oret && get_errno () != ENOENT
				&& get_errno () != ENOSHARE))
@


1.79
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d534 7
@


1.78
log
@* include/cygwin/version.h: Bump API to reflect setlogmask.
@
text
@d41 2
d840 1
a840 1
      if (! set_file_attribute (win32_path.has_acls (),
d1238 2
a1239 2
  if (! writable_directory (real_old.get_win32 ())
      || ! writable_directory (real_new.get_win32 ()))
d1365 3
a1367 9
  static DWORD sys_page_size = 0;

  if (!sys_page_size)
    {
      SYSTEM_INFO si;
      GetSystemInfo(&si);
      sys_page_size = si.dwPageSize;
    }
  return (int)sys_page_size;
d1951 1
a1951 2
  ret = cygwin_shared->mount.conv_to_posix_path (path.get_win32 (),
						 buf, 0);
@


1.77
log
@* syscalls.cc (setdtablesize): Call with amount to increment not total amount.
Return success or failure error code.
@
text
@d248 1
a248 4
	{
	  set_sig_errno (EINTR);
	  sawsig = 1;
	}
d264 1
a264 1
  if (sawsig && call_signal_handler ())
@


1.76
log
@* autoload.cc (LoadDLLinitfunc): Remove debugging statement.
* exceptions.cc (sig_handle_tty_stop): Move setting of PID_STOPPED to earlier
in interrupt.
((interrupt_setup): i.e., here.
(sig_handle): Don't queue multiple SIGSTOPS.
* fhandler.h (bg_check_types): Enumerate return value of bg_check for clarity.
* signal.cc (kill_pgrp): Minor cleanup.
* fhandler_termios.cc (fhandler_termios::bg_check): Use enumerated type for
function return.  Don't raise signal if a signal is already queued.
* fhandler_console.cc (fhandler_console::read): Use enumerated return type for
bg_check.
* select.cc: Ditto, throughout.
* read.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
(_read): YA interrupt detect simplification.
* wait.cc (wait4): Ditto.
@
text
@d1348 1
a1348 1
extern "C" void
d1351 4
a1354 2
  if (size > (int)fdtab.size)
    fdtab.extend (size);
@


1.75
log
@        * heap.cc (heap_init): Fix extern declaration of getpagesize.
	* syscalls.cc (getpagesize): Fix another typo.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
d223 1
d226 1
d248 4
a251 1
	set_sig_errno (EINTR);
d259 1
a259 1
  if (res > 0)
d267 1
a267 1
  if (res < 0 && get_errno () == EINTR && call_signal_handler ())
d297 1
a297 1
  if (res > 0)
@


1.74
log
@        * syscalls.cc (getpagesize): Save pagesize in global variable to
        avoid calling GetSystemInfo too often.
        * heap.cc (getpagesize): Eliminate.
        (heap_init): Use getpagesize function from syscalls.cc.
@
text
@a1355 2
static DWORD sys_page_size = 0;

d1359 2
a1360 1
  return sysconf (_SC_PAGESIZE);
@


1.73
log
@* syscalls.cc (_read): Use more lightweight method for determining if read has
been interrupted by a signal.
@
text
@d1356 2
d1362 7
@


1.72
log
@* debug.h: Add regparm attributes to some functions.
* signal.cc (sigaction): Don't treat SIGCONT specially.
* exceptions.cc (interrupt_setup): Save sa_flags of interrupted signal for
later use.
(sig_handler): Default any stopping signal to SIGSTOP.
(call_signal_handler): New function.
(sigdelayed0): New function.
* sigproc.cc (sigproc_init): Initialize SIGSTOP sigaction for special behavior.
* sigproc.h: Define call_signal_handler.
* syscalls.cc (_read): Allow restartable signal behavior.
@
text
@d262 1
a262 2
  if (res < 0 && WaitForSingleObject (signal_arrived, 0) == WAIT_OBJECT_0 &&
      call_signal_handler ())
@


1.71
log
@        * syscalls.cc (remove): New function, overriding the newlib
	implementation.
@
text
@d223 2
d262 5
a266 2
  syscall_printf ("%d = read (%d<%s>, %p, %d), errno %d", res, fd, fh->get_name (),
		  ptr, len, get_errno ());
@


1.70
log
@        * environ.cc (struct parse_thing): Add entry for new CYGWIN option
        `smbntsec'.
        * path.cc (path_conv::check): Check path for being a remote path.
        If so and `allow_smbntsec' is set to FALSE, set has_acls to FALSE.
        * security.cc: Add global definition for `allow_smbntsec'.
        * security.h: Add extern declaration for `allow_smbntsec'.
        * fhandler.cc (fhandler_disk_file::open): Eliminate extern declaration
        of `allow_ntsec'.
        * syscalls.cc: Ditto.
@
text
@d169 19
@


1.69
log
@        * uinfo.cc (internal_getlogin): Change parameter list to reflect
        that `token' is member of cygheap_user now.
        (uinfo_init): Use modified internal_getlogin.
        * syscalls.cc (seteuid): Ditto.
@
text
@a40 2
extern BOOL allow_ntsec;

@


1.68
log
@        * cygheap.h: Move `token' and `impersonated' from class _pinfo
        to class cygheap_user.
        * pinfo.h: Ditto.
        * fork.cc (fork_child): Change usage of `token' and `impersonated'
        accordingly.
        (fork_parent): Ditto.
        * security.cc (cygwin_set_impersonation_token): Ditto.
        * sigproc.cc (proc_subproc): Ditto.
        * spawn.cc (spawn_guts): Ditto.
        * syscalls.cc (seteuid): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
@
text
@d1814 1
a1814 1
extern const char *internal_getlogin (cygheap_user &user, HANDLE token);
d1854 1
a1854 1
	  /* token is used in internal_getlogin() to determine if
d1857 3
a1859 3
	  HANDLE token = cygheap->user.impersonated ? cygheap->user.token
					      : INVALID_HANDLE_VALUE;
	  struct passwd *pw_cur = getpwnam (internal_getlogin (user, token));
@


1.67
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d1836 1
a1836 1
			      myself->token);
d1838 2
a1839 2
		if (myself->token != INVALID_HANDLE_VALUE)
		  myself->impersonated = FALSE;
d1841 1
a1841 1
	    else if (!myself->impersonated)
d1845 2
a1846 2
		if (myself->token != INVALID_HANDLE_VALUE)
		  if (!ImpersonateLoggedOnUser (myself->token))
d1848 1
a1848 1
				   myself->token);
d1850 1
a1850 1
		    myself->impersonated = TRUE;
d1857 1
a1857 1
	  HANDLE token = myself->impersonated ? myself->token
d1863 1
a1863 1
			    myself->token, pw_cur->pw_uid,
@


1.66
log
@* cygheap.h (init_cygheap): New struct holding values that live in the Cygwin
heap.
* child_info.h (child_info): Change pointer type of cygheap to init_cygheap.
* cygheap.cc (init_cheap): Point cygheap_max after contents of cygheap.  Move
some stuff into cygheap.h.
* dir.cc (opendir): Change to use root and rootlen in cygheap rather than in
myself.
(mkdir): Change to use umask in cygheap rather than in myself.
* path.cc: Ditto, throughout.
* syscalls.cc (_open): Ditto.  Change to use umask in cygheap rather than in
myself.
(chroot): Change to allocate root dir on the cygwin heap.
(umask): Change to use umask in cygheap rather than in myself.
(cygwin_bind): Ditto.
* sigproc.cc (proc_subproc): Don't copy umask or root stuff as this happens
automatically now.
* pinfo.h (_pinfo): Migrate stuff out of here and into init_cheap.
* dcrt0.cc (dll_crt0_1): Call cygheap_init later in startup for first cygwin
process.
@
text
@d707 1
a707 1
				    myself->logsrv);
d818 1
a818 1
				mode, myself->logsrv)
d1799 1
a1799 1
    myself->real_gid = myself->gid;
d1809 2
a1810 2
    myself->real_uid = myself->uid;
  debug_printf ("real: %d, effective: %d", myself->real_uid, myself->uid);
d1814 1
a1814 1
extern char *internal_getlogin (_pinfo *pi);
d1833 1
a1833 1
	    if (uid == myself->orig_uid)
d1853 2
a1854 2
	  struct _pinfo pi;
	  /* pi.token is used in internal_getlogin() to determine if
d1857 3
a1859 3
	  pi.token = myself->impersonated ? myself->token
					  : INVALID_HANDLE_VALUE;
	  struct passwd *pw_cur = getpwnam (internal_getlogin (&pi));
d1864 1
a1864 1
			    pw_new->pw_uid, myself->orig_uid);
d1869 1
a1869 5
	  strcpy (myself->username, pi.username);
	  strcpy (myself->logsrv, pi.logsrv);
	  strcpy (myself->domain, pi.domain);
	  memcpy (myself->psid, pi.psid, MAX_SID_LEN);
	  myself->use_psid = 1;
d1874 1
a1874 1
  debug_printf ("real: %d, effective: %d", myself->real_uid, myself->uid);
d1929 1
a1929 5
  cygheap->rootlen = strlen (cygheap->root);
  if (cygheap->rootlen > 1 && buf[cygheap->rootlen - 1] == '/')
    buf[--cygheap->rootlen] = '\0';
  cygheap->root = (char *) crealloc (cygheap->root, cygheap->rootlen + 1);
  strcpy (cygheap->root, buf);
@


1.65
log
@* pinfo.cc (pinfo::init): Reverse order of setting status and pid info in an
execed process to avoid a race.
* sigproc.cc (wait_subproc): Print more info when a WFSO error occurs.
* automode.c: New file.
* syscalls.cc (close_all_files): Streamline slightly.
* cygheap.cc (ccalloc): Clear *entire* allocated array.
@
text
@d39 1
d405 1
a405 1
      else if (!fh->open (unix_path, flags, (mode & 0777) & ~myself->umask))
d768 2
a769 2
  oldmask = myself->umask;
  myself->umask = mask & 0777;
d1925 1
d1927 1
a1927 1
						 myself->root, 0);
d1933 5
a1937 3
  myself->rootlen = strlen (myself->root);
  if (myself->root[myself->rootlen - 1] == '/')
    myself->root[--myself->rootlen] = '\0';
@


1.64
log
@* dcrt0.cc (do_exit): Don't bother looking for pgrp children to send SIGHUP if
process has never created any children.
* fork.cc (fork): Set flag indicating that there is another process with our
process group.
* spawn.cc (spawn_guts): Ditto.
* pinfo.h (set_has_pgid_children): New methods for setting when process has
children in its process group.
* syscalls.cc (setpgid): Clear has_gid_children if pgid changes.
@
text
@d52 1
d54 1
a54 1
    if (!fdtab.not_open (i))
d56 1
a56 1
	fdtab[i]->close ();
@


1.63
log
@        * fhandler.cc (fhandler_base::fcntl): Behave properly when passed
        previous version of O_NDELAY.
        * syscalls.cc: Move OLD_O_NDELAY to winsup.h.
        * winsup.h: Define OLD_O_NDELAY now.
@
text
@d1714 2
@


1.62
log
@* exceptions.cc (call_handler): Make signal pending if sigsave.sig is still
active.
* syscalls.cc (_read): Don't clear errno.
* sigproc.cc (wait_sig): Don't scan the waiting process list after a SIGCHLD if
there are no zombies to reap.
* winsup.h: Use __builtin_strcmp.
* environ.cc (posify): Don't initialize len unless it is required
(from DJ Delorie <dj@@redhat.com>).
@
text
@a39 5
/* newlib used to define O_NDELAY differently from O_NONBLOCK.  Now it
   properly defines both to be the same.  Unfortunately, we have to
   behave properly the old version, too, to accomodate older executables. */
#define OLD_O_NDELAY	4

@


1.61
log
@* sigproc.cc (proc_subproc): Remove unneeded test for correct process in
PROC_ADDCHILD.  Return 0 when terminated child has just been reparented.
(wait_subproc): Only send SIGCHLD when proc_subproc returns != 0.
* strace.cc (strace::vsprntf): Only strip .exe extension from program name.
@
text
@d215 1
a215 1
  set_sig_errno (0);
d228 1
a228 1
	set_sig_errno (EAGAIN);
@


1.60
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d923 1
a923 1
      syscall_printf ("%d = fstat (%d, %x)", r,fd,buf);
@


1.59
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@a31 1
#include "thread.h"
@


1.58
log
@* errno.cc (seterrno_from_win_error): Fix debugging output.
* fhandler.cc (fhandler_base::fstat): Move to inline method in fhandler.h.
(fhandler_base::set_io_handle): Ditto.
* fhandler.h (fhandler_base): Make some methods inline.
* fhandler_console.cc (fhandler_console::write_normal): Make buffer larger.
* sigproc.h (sigframe::sigframe): Actually use set ebp parameter correctly.
* spawn.cc (spawn_guts): Set dwProcessId when exec'ing.  Just exit immediately
after reparenting.
* syscalls.cc: Sprinkle sigframe stuff throughout.
* wait.cc (wait4): Set signal frame here.
* dcrt0.cc (__api_fatal): Don't rely on small_printf to display errors.  Always
display problems to the console, if possible.
@
text
@d56 3
a58 1
  for (int i = 0; i < (int)fdtab.size; i++)
d60 4
a63 1
      _close (i);
d65 1
d209 1
d221 1
a221 1
  syscall_printf ("read (%d, %p, %d) %sblocking", fd, ptr, len, wait ? "" : "non");
d224 1
a224 1
  if (wait && (!fh->is_slow () || fh->get_r_no_interrupt ()))
a245 1

d997 1
a997 1
	      int nofollow)
@


1.57
log
@* syscalls.cc (_read): Behave properly when passed previous version of
O_NDELAY.  Fix up debugging output.
@
text
@d67 1
d251 1
d385 1
d421 1
d441 1
d469 1
d493 1
d724 1
d731 1
d738 1
d776 1
d850 1
d906 1
d928 1
d956 1
d1102 1
d1110 1
d1119 1
d1190 1
d1287 1
d1555 1
d1594 1
d1635 1
d1676 1
d1690 1
d1730 1
d1746 1
d1753 1
d1760 1
d1816 1
d1882 1
d1905 1
d1942 1
d1955 1
d1964 1
d2035 1
d2105 1
d2130 1
@


1.56
log
@* path.cc (symlink_info::check): Set executable bit for a file if the first two
characters are 'MZ' to mirror spawn_guts check.
@
text
@d41 5
d210 1
a210 1
  DWORD wait = fh->get_flags () & (O_NONBLOCK | O_NDELAY) ? 0 : INFINITE;
d213 1
a213 1
  syscall_printf ("read (%d, %p, %d)", fd, ptr, len);
d240 1
a240 1
  syscall_printf ("%d = read (%d<%s>, %p, %d), errno %d", -1, fd, fh->get_name (),
@


1.55
log
@* spawn.cc (av::dup_maybe): Make function void rather than void *.
* environ.cc (environ_init): Remember to reparse CYGWIN if envp is
supplied.
* heap.cc (_sbrk): Remember frame for signal handling.
* syscalls.cc (read_handler): Eliminate.
(_read): Move read_handler code here.  Reorganize for one path through
'ready_for_read'.
@
text
@d58 1
a58 2
extern "C"
int
d163 1
a163 2
extern "C"
pid_t
d170 1
a170 2
extern "C"
pid_t
d177 1
a177 2
extern "C"
pid_t
d241 1
a241 2
extern "C"
int
d286 1
a286 2
extern "C"
ssize_t
d340 1
a340 2
extern "C"
ssize_t
d370 1
a370 2
extern "C"
int
d409 1
a409 2
extern "C"
off_t
d428 1
a428 2
extern "C"
int
d455 1
a455 2
extern "C"
int
d478 1
a478 2
extern "C"
int
d709 1
a709 2
extern "C"
int
d715 1
a715 2
extern "C"
int
d721 1
a721 2
extern "C"
int
d746 1
a746 2
extern "C"
mode_t
d757 1
a757 2
extern "C"
int
d831 1
a831 2
extern "C"
int
d885 1
a885 2
extern "C"
int
d907 1
a907 2
extern "C"
int
d928 1
a928 2
extern "C"
int
d1079 1
a1079 2
extern "C"
int
d1086 1
a1086 2
extern "C"
int
d1094 1
a1094 2
extern "C"
int
d1164 1
a1164 2
extern "C"
int
d1260 1
a1260 2
extern "C"
int
d1295 1
a1295 2
extern "C"
void
d1302 1
a1302 2
extern "C"
int
d1308 1
a1308 2
extern "C"
size_t
d1315 1
a1315 2
extern "C"
long int
d1353 1
a1353 2
extern "C"
long int
d1844 1
a1844 2
extern "C"
int
d1866 1
a1866 2
extern "C"
int
d1902 1
a1902 2
extern "C"
int
d1908 1
a1908 2
extern "C"
void
d1914 1
a1914 2
extern "C"
int
d1922 1
a1922 2
extern "C"
int
d1932 1
a1932 2
extern "C"
int
d1944 1
a1944 2
extern "C"
size_t
d1956 1
a1956 2
extern "C"
int
d1968 1
a1968 2
extern "C"
int
d1975 1
a1975 2
extern "C"
_PTR
d1992 1
a1992 2
extern "C"
int
d2039 1
a2039 2
extern "C"
int
d2061 1
a2061 2
extern "C"
void
d2083 1
d2085 1
a2085 2
extern "C"
int
@


1.54
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d197 2
a198 2
static int
read_handler (int fd, void *ptr, size_t len)
a199 1
  int res;
a200 2
  fhandler_base *fh = fdtab[fd];

d207 11
a217 1
  if ((fh->get_flags() & (O_NONBLOCK | O_NDELAY)) && !fh->ready_for_read (fd, 0, 0))
d219 6
a224 3
      syscall_printf ("nothing to read");
      set_errno (EAGAIN);
      return -1;
a235 3
  syscall_printf ("%d = read (%d<%s>, %p, %d)", res, fd, fh->get_name (), ptr, len);
  return res;
}
a236 11
extern "C" int
_read (int fd, void *ptr, size_t len)
{
  if (fdtab.not_open (fd))
    {
      set_errno (EBADF);
      return -1;
    }

  set_sig_errno (0);
  fhandler_base *fh = fdtab[fd];
d238 1
a238 14
  /* Could block, so let user know we at least got here.  */
  syscall_printf ("read (%d, %p, %d)", fd, ptr, len);

  if (!fh->is_slow () || (fh->get_flags () & (O_NONBLOCK | O_NDELAY)) ||
      fh->get_r_no_interrupt ())
    {
      debug_printf ("non-interruptible read\n");
      return read_handler (fd, ptr, len);
    }

  if (fh->ready_for_read (fd, INFINITE, 0))
    return read_handler (fd, ptr, len);

  set_sig_errno (EINTR);
d242 1
a242 1
  return -1;
@


1.53
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d26 2
a36 1
#include "tty.h"
d38 2
@


1.52
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d35 2
@


1.51
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d604 1
a604 2
	    &lpContext
	    );
d1637 1
a1637 1
      set_errno ( EBADF);
@


1.50
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@a23 1
#include <unistd.h>
d34 1
d1018 2
a1019 2
  path_conv real_path (name, (nofollow ? PC_SYM_NOFOLLOW : PC_SYM_FOLLOW) | PC_FULL,
		       stat_suffixes);
d1425 10
a1446 11
extern "C"
char *
ttyname (int fd)
{
  if (fdtab.not_open (fd) || !fdtab[fd]->is_tty ())
    {
      return 0;
    }
  return (char *)(fdtab[fd]->ttyname ());
}

d1448 1
a1448 2
extern "C" int _cygwin_istext_for_stdio (int fd);
int
d1571 1
a1571 2
extern "C"
int
d1609 1
a1609 2
extern "C"
int
d1631 1
a1631 2
extern "C"
long
d1649 1
a1649 2
extern "C"
int
d1689 1
a1689 2
extern "C"
int
d1702 1
a1702 2
extern "C"
int
d1741 1
a1741 2
extern "C"
pid_t
d1756 1
a1756 2
extern "C"
int
d1762 1
a1762 2
extern "C"
pid_t
d1768 1
a1768 2
extern "C"
char *
d1780 1
a1780 2
extern "C"
int
d1792 1
a1792 2
extern "C"
int
d1800 1
a1800 2
extern "C"
int
d1810 1
a1810 2
extern "C"
int
d1823 1
a1823 2
extern "C"
int
@


1.49
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d27 3
d31 3
a34 1
#include "cygerrno.h"
@


1.48
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d29 1
@


1.47
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d27 2
@


1.46
log
@* select.cc (allocfd_set): Zero allocated fd_set.
(cygwin_select): Move fd_set copying logic from ::wait to here.  Use common
return through sell.poll.
(select_stuff::wait): Just return success or failure and let caller fill in
fd_set.
* pinfo.h (pinfo): Eliminate self-referential pointer to sidbuf since pinfo
structure exists at random locations now.
* fork.cc (fork): Use 'use_psid' element to control when the psid is relevant.
* shared.cc (sec_user): Ditto.
* spawn.cc (spawn_guts): Ditto.
* uinfo.cc (internal_getlogin): Ditto.
* syscall.cc (seteuid): Ditto.  Set use_psid element.
@
text
@d38 2
a39 2
  for (int i = 0; i < (int)dtable.size; i++)
    if (!dtable.not_open (i))
d189 1
a189 1
  fhandler_base *fh = dtable[fd];
d191 1
a191 1
  if (dtable.not_open (fd))
d220 1
a220 1
  if (dtable.not_open (fd))
d227 1
a227 1
  fhandler_base *fh = dtable[fd];
d255 1
a255 1
  if (dtable.not_open (fd))
d268 1
a268 1
  fh = dtable[fd];
d401 1
a401 1
      fd = dtable.find_unused_handle ();
d405 1
a405 1
      else if ((fh = dtable.build_fhandler (fd, unix_path, NULL)) == NULL)
d409 1
a409 1
	  dtable.release (fd);
d427 1
a427 1
  if (dtable.not_open (fd))
d434 1
a434 1
      res = dtable[fd]->lseek (pos, dir);
d450 1
a450 1
  if (dtable.not_open (fd))
d459 2
a460 2
      res = dtable[fd]->close ();
      dtable.release (fd);
d475 1
a475 1
  if (dtable.not_open (fd))
d481 1
a481 1
  res = dtable[fd]->is_tty ();
d744 1
a744 1
  if (dtable.not_open (fd))
d751 1
a751 1
  const char *path = dtable[fd]->get_name ();
d857 1
a857 1
  if (dtable.not_open (fd))
d864 1
a864 1
  const char *path = dtable[fd]->get_name ();
d914 1
a914 1
  if (dtable.not_open (fd))
d923 1
a923 1
      r = dtable[fd]->fstat (buf);
d935 1
a935 1
  if (dtable.not_open (fd))
d942 1
a942 1
  HANDLE h = dtable[fd]->get_handle ();
d1330 2
a1331 2
  if (size > (int)dtable.size)
    dtable.extend (size);
d1338 1
a1338 1
  return dtable.size;
d1433 1
a1433 1
  if (dtable.not_open (fd) || !dtable[fd]->is_tty ())
d1437 1
a1437 1
  return (char *)(dtable[fd]->ttyname ());
d1452 1
a1452 1
  if (dtable.not_open (fd))
d1458 1
a1458 1
  fhandler_base *p = dtable[fd];
d1500 1
a1500 1
  if (dtable.not_open (fd))
d1506 1
a1506 1
  return dtable[fd]->get_flags () & (O_BINARY | O_TEXT);
d1515 1
a1515 1
  if (dtable.not_open (fd))
d1526 1
a1526 1
  fhandler_base *p = dtable[fd];
d1571 1
a1571 1
  if (dtable.not_open (fd))
d1577 1
a1577 1
      HANDLE h = dtable[fd]->get_handle ();
d1583 1
a1583 1
	  prev_loc = dtable[fd]->lseek (0, SEEK_CUR);
d1585 1
a1585 1
	  dtable[fd]->lseek (length, SEEK_SET);
d1594 1
a1594 1
	  dtable[fd]->lseek (prev_loc, 0);
d1633 1
a1633 1
  if (dtable.not_open (fd))
d1639 1
a1639 1
      res = (long) dtable[fd]->get_handle ();
d1691 1
a1691 1
  if (dtable.not_open (fd))
d1696 1
a1696 1
  fhandler_disk_file *f = (fhandler_disk_file *) dtable[fd];
d1775 1
a1775 1
  if (dtable.not_open (fd))
d1780 1
a1780 1
  return (char *)(dtable[fd]->ptsname ());
@


1.45
log
@* hinfo.cc (hinfo::find_unused_handle): Just check for table entry == NULL
since we are already bounds checked by default.
* thread.cc (ResourceLocks::Lock): Streamline this function since it is called
a lot.
(ReleaseResourceLock): Ditto.
@
text
@a1867 1
	  pi.psid = (PSID) pi.sidbuf;
d1886 2
a1887 1
	  memcpy (myself->sidbuf, pi.sidbuf, MAX_SID_LEN);
@


1.44
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d394 1
a394 1
      SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," open ");
@


1.43
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d11 1
a23 1
#include "winsup.h"
@


1.42
log
@* testsuite/winsup.api/winsup.exp: ignore stdout by default
* testsuite/winsup.api/crlf.c: non-verbose by default

* winsup.h: prune out windows headers we don't normally need
* assert.cc: add wingdi.h and winuser.h
* fhandler_console.cc: ditto
* fhandler_windows.cc: ditto
* select.cc: ditto
* spawn.cc: ditto
* strace.cc: ditto
* tty.cc: ditto
* window.cc: ditto
* hinfo.cc: add winsock.h
* syscalls.cc: add winnls.h
* uinfo.cc: ditto

* include/windows.h: optimize non-inclusion of repeat headers
@
text
@d24 1
a26 1
#include <unistd.h>
d1416 1
a1416 2
extern "C"
char *
a1715 13
  pinfo *p;
  p = procinfo (pid);
  if (p == NULL)
    {
      set_errno (ESRCH);
      goto out;
    }
  /* A process may only change the process group of itself and its children */
  if (p == myself || p->ppid == myself->pid)
    {
      p->pgid = pgid;
      res = 0;
    }
d1718 17
a1734 2
      set_errno (EPERM);
      goto out;
d1748 1
a1748 1
  pinfo *p = procinfo (pid);
d1828 1
a1828 1
extern char *internal_getlogin (struct pinfo *pi);
d1867 1
a1867 1
	  struct pinfo pi;
@


1.41
log
@* syscalls.cc (stat_worker): Make stat return correct st_blocks for files with
size bigger than 2Gb and less than 4Gb
@
text
@d24 1
@


1.40
log
@* syscalls.cc (statfs): Use path_conv method to convert input path.
@
text
@d692 1
a692 1
        attrib |= S_IFDIR;
d694 4
a697 4
                                win32_path.get_win32 (),
                                (int *) &attrib,
                                &old_uid,
                                &old_gid);
d699 7
a705 7
        {
          if (uid == (uid_t) -1)
            uid = old_uid;
          if (gid == (gid_t) -1)
            gid = old_gid;
          if (win32_path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
            attrib |= S_IFDIR;
d707 1
a707 1
                                    win32_path.get_win32 (),
d709 2
a710 2
                                    myself->logsrv);
        }
d713 3
a715 3
        /* fake - if not supported, pretend we're like win95
           where it just works */
        res = 0;
d721 1
a721 1
                  res, (fmode & PC_SYM_IGNORE) ? "l" : "", name);
d760 1
a760 1
                  fd, path);
d812 1
a812 1
        mode |= S_IFDIR;
d814 2
a815 2
                          win32_path.get_win32 (),
                          NULL, &uid, &gid);
d817 1
a817 1
        mode |= S_IFDIR;
d819 1
a819 1
                                win32_path.get_win32 (),
d1033 2
a1034 2
        && dtype != DRIVE_NO_ROOT_DIR
        && dtype != DRIVE_UNKNOWN))
d1042 3
a1044 3
         those subdirectories point to it.
         This is too slow on remote drives, so we do without it and
         set the number of links to 2. */
d1046 1
a1046 1
         let's try it with `1' as link count. */
d1048 2
a1049 2
        buf->st_nlink =
            (dtype == DRIVE_REMOTE ? 1 : num_entries (real_path.get_win32 ()));
d1052 1
a1052 1
                                && get_errno () != ENOSHARE))
d1055 1
a1055 1
         So we have to care for this case here, too. */
d1060 3
a1062 3
          && (atts & FILE_ATTRIBUTE_DIRECTORY)
          && dtype != DRIVE_REMOTE)
        buf->st_nlink = num_entries (real_path.get_win32 ());
d1066 1
a1066 1
        buf->st_mode = S_IFDIR;
d1068 1
a1068 1
        buf->st_mode = S_IFLNK;
d1070 1
a1070 1
        buf->st_mode = S_IFSOCK;
d1072 1
a1072 1
        buf->st_mode = S_IFREG;
d1074 9
a1082 9
          || get_file_attribute (real_path.has_acls (), real_path.get_win32 (),
                                 &buf->st_mode, &buf->st_uid, &buf->st_gid))
        {
          buf->st_mode |= STD_RBITS | STD_XBITS;
          if ((atts & FILE_ATTRIBUTE_READONLY) == 0)
            buf->st_mode |= STD_WBITS;
          get_file_attribute (FALSE, real_path.get_win32 (),
                              NULL, &buf->st_uid, &buf->st_gid);
        }
d1084 11
a1094 10
          != INVALID_HANDLE_VALUE)
        {
          buf->st_atime   = to_time_t (&wfd.ftLastAccessTime);
          buf->st_mtime   = to_time_t (&wfd.ftLastWriteTime);
          buf->st_ctime   = to_time_t (&wfd.ftCreationTime);
          buf->st_size    = wfd.nFileSizeLow;
          buf->st_blksize = S_BLKSIZE;
          buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
          FindClose (handle);
        }
d1143 4
a1146 4
        {
          if (!(st.st_mode & S_IRUSR))
            goto done;
        }
d1148 4
a1151 4
        {
          if (!(st.st_mode & S_IRGRP))
            goto done;
        }
d1153 1
a1153 1
        goto done;
d1158 4
a1161 4
        {
          if (!(st.st_mode & S_IWUSR))
            goto done;
        }
d1163 4
a1166 4
        {
          if (!(st.st_mode & S_IWGRP))
            goto done;
        }
d1168 1
a1168 1
        goto done;
d1173 4
a1176 4
        {
          if (!(st.st_mode & S_IXUSR))
            goto done;
        }
d1178 4
a1181 4
        {
          if (!(st.st_mode & S_IXGRP))
            goto done;
        }
d1183 1
a1183 1
        goto done;
d1241 1
a1241 1
                   && GetLastError () != ERROR_FILE_EXISTS))
d1836 51
a1886 51
        {
          struct passwd *pw_new = getpwuid (uid);
          if (!pw_new)
            {
              set_errno (EINVAL);
              return -1;
            }

          if (uid != myself->uid)
            if (uid == myself->orig_uid)
              {
                debug_printf ("RevertToSelf() (uid == orig_uid, token=%d)",
                              myself->token);
                RevertToSelf();
                if (myself->token != INVALID_HANDLE_VALUE)
                  myself->impersonated = FALSE;
              }
            else if (!myself->impersonated)
              {
                debug_printf ("Impersonate(uid == %d)", uid);
                RevertToSelf();
                if (myself->token != INVALID_HANDLE_VALUE)
                  if (!ImpersonateLoggedOnUser (myself->token))
                    system_printf ("Impersonate(%d) in set(e)uid failed: %E",
                                   myself->token);
                  else
                    myself->impersonated = TRUE;
              }

          struct pinfo pi;
          pi.psid = (PSID) pi.sidbuf;
          /* pi.token is used in internal_getlogin() to determine if
             impersonation is active. If so, the token is used for
             retrieving user's SID. */
          pi.token = myself->impersonated ? myself->token
                                          : INVALID_HANDLE_VALUE;
          struct passwd *pw_cur = getpwnam (internal_getlogin (&pi));
          if (pw_cur != pw_new)
            {
              debug_printf ("Diffs!!! token: %d, cur: %d, new: %d, orig: %d",
                            myself->token, pw_cur->pw_uid,
                            pw_new->pw_uid, myself->orig_uid);
              set_errno (EPERM);
              return -1;
            }
          myself->uid = uid;
          strcpy (myself->username, pi.username);
          strcpy (myself->logsrv, pi.logsrv);
          strcpy (myself->domain, pi.domain);
          memcpy (myself->sidbuf, pi.sidbuf, MAX_SID_LEN);
        }
d1902 8
a1909 8
        {
          if (!getgrgid (gid))
            {
              set_errno (EINVAL);
              return -1;
            }
          myself->gid = gid;
        }
d1924 1
a1924 1
  
d1938 1
a1938 1
                                                 myself->root, 0);
d1951 1
a1951 1
                                      newroot ? newroot : "NULL");
@


1.39
log
@* syscalls.cc (_link): Avoid extraneous call to cygwin_conv_to_win32_path.
@
text
@a1648 2
  char full_path[MAX_PATH];

a1653 1
  cygwin_conv_to_full_win32_path (fname, full_path);
d1655 1
@


1.38
log
@        * syscalls.cc (_link): Corrected previous patch.
@
text
@d497 2
a498 2
  path_conv real_a (a, PC_SYM_NOFOLLOW);
  path_conv real_b (b, PC_SYM_NOFOLLOW);
a527 1
      char buf[MAX_PATH];
d548 1
a548 2
      cygwin_conv_to_full_win32_path (real_b.get_win32 (), buf);
      cbPathLen = sys_mbstowcs (wbuf, buf, MAX_PATH) * sizeof (WCHAR);
@


1.37
log
@        Patch suggested by Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>.
        * winsup.h: Add new macros sys_wcstombs and sys_mbstowcs.
        * syscalls.cc (_link): Replace calls to mbstowcs by call to
        sys_mbstowcs.
        * uinfo.cc (internal_getlogin): Replace calls to wcstombs and
        mbstowcs by calls to sys_wcstombs and sys_mbstowcs. Replace
        usage of constants by meaningful defines. Use result of
        GetSystemDirectory for HOMEPATH and HOMEDRIVE as a last resort.
@
text
@d550 1
a550 1
      cbPathLen = sys_mbstowcs (wbuf, buf, MAX_PATH);
@


1.36
log
@        * shared.h (class pinfo): New members `root' and `rootlen'.
        * syscalls.cc (chroot): Set new root for process.
        * path.cc (getcwd_inner): Add parameter to force use of
        new root from chroot() call.
        (ischrootpath): New macro.
        (normalize_posix_path): Care for changed root dir.
        (normalize_win32_path): Ditto.
        (getcwd_inner): Ditto.
        (chdir): Eliminate trailing path component consisting
        entirely of dots.
        * fork.cc (fork): Copy pinfo members regarding chroot().
        * spawn.cc (_spawnve): Ditto.
        * dir.cc (opendir): Don't use computed win32 path if
        chroot() took place.
@
text
@d550 1
a550 1
      cbPathLen = MultiByteToWideChar (CP_ACP, 0, buf, -1, wbuf, MAX_PATH) * sizeof (WCHAR);
@


1.35
log
@Throughout, eliminate third argument to path_conv and use new PC_* constants
for second argument.
* path.h: Generalize SYMLINK_* constants to PC_*.
(path_conv): Create a new method.  Fold third argument into second.
* dll_init.cc (dll_list::alloc): Try harder to find space to allocate dll
struct.
(dll_dllcrt0): Don't check sanity if we've already called dll_crt0.
* path.cc (path_conv::check): Don't check for a null or empty path unless
specifically told with a flag setting.
(check_null_empty_path): New function, adapted from macro.
* syscalls.cc (_rename): Use already-determined file attributes rather than
checking again.
* lib/cygwin/cygwin_attach.dll.c (cygwin_attach_dll): Use a static per_process
structure since this is apparently supposed to be zeroed.
* lib/cygwin_crt0.c (cygwin_crt0): Zero per_process structure sent to older
DLLs.
@
text
@d1920 1
d1923 1
a1923 1
chroot (const char *)
d1925 31
a1955 2
  set_errno (ENOSYS);
  return -1;
@


1.34
log
@        * spawn.cc (spawn_guts): Close handle `hToken' only if it's not
        copied from myself->token.
        * syscalls.cc (seteuid): Replace CopySid by memcpy which is foolproof
        here.
@
text
@d50 1
a50 1
  path_conv win32_name (ourname, SYMLINK_NOFOLLOW, 1);
d497 2
a498 2
  path_conv real_a (a, SYMLINK_NOFOLLOW);
  path_conv real_b (b, SYMLINK_NOFOLLOW);
d661 1
a661 1
chown_worker (const char *name, symlink_follow fmode, uid_t uid, gid_t gid)
d667 3
d675 1
a675 1
      path_conv win32_path (name, fmode);
d723 1
a723 1
                  res, fmode == SYMLINK_IGNORE ? "l" : "", name);
d731 1
a731 1
  return chown_worker (name, SYMLINK_FOLLOW, uid, gid);
d738 1
a738 1
  return chown_worker (name, SYMLINK_IGNORE, uid, gid);
d763 1
a763 1
  return chown_worker (path, SYMLINK_FOLLOW, uid, gid);
d1011 1
a1011 1
  path_conv real_path (name, nofollow ? SYMLINK_NOFOLLOW : SYMLINK_FOLLOW, 1,
d1199 1
a1199 1
  path_conv real_old (oldpath, SYMLINK_NOFOLLOW);
d1208 1
a1208 1
  path_conv real_new (newpath, SYMLINK_NOFOLLOW);
d1224 1
a1224 4
  int oldatts = GetFileAttributesA (real_old.get_win32 ());
  int newatts = GetFileAttributesA (real_new.get_win32 ());

  if (oldatts == -1) /* file to move doesn't exist */
d1230 2
a1231 1
  if (newatts != -1 && newatts & FILE_ATTRIBUTE_READONLY)
d1235 1
a1235 1
      SetFileAttributesA (real_new.get_win32 (), newatts & ~ FILE_ATTRIBUTE_READONLY);
d1281 1
a1281 1
      SetFileAttributesA (real_new.get_win32 (), oldatts);
@


1.33
log
@* cygwin.din: Export _getmode and getmode to allow querying of binary state of
an fd.
* external.cc (cygwin_internal): Add handling of perfile_table setting.
* fhandler.cc (perfile_table): New global.
(fhandler_base::get_default_fmode): New method to return a file's default mode
based on its name.
(fhandler_base::open): Use get_default_mode method to determine a file's mode.
Record file mode in file flags.
* fhandler.h (fhandler_base): Declare get_default_fmode
* syscalls.cc (getmode): New function.
* sys/cygwin.h (__cygwin_perfile): New structure.
(cygwin_getinfo_types): Move outside of WINVER conditional.
(per_process): Move inside of WINVER conditional.
@
text
@a1884 1
          CopySid (MAX_SID_LEN, myself->psid, pi.psid);
d1887 1
@


1.32
log
@* dcrt0.cc (dll_crt0_1): Eliminate SetFileApisToOEM and CharToOem.
* (dummy_autoload): Add functions used in fhandler_console.
* fhandler_console.cc (fhandler_console::read): Use ENCHANCED_KEY flag to
distinguish extended keys.  Translate an input character from the OEM code page
to the ANSI code page.
* (fhandler_console::write_normal): Translate output characters from the ANSI
code page to the OEM code page.
* syscalls.cc (_link): Use MultiByteToWideChar instead of OemToCharW.
@
text
@d1497 12
d1512 1
a1512 2
extern "C"
int
@


1.31
log
@        * winsup.h: Define MAX_SID_LEN and new MAX_HOST_NAME.
        * fork.cc (fork): Use above defines instead of numerical constants.
        * shared.cc (sec_user): Ditto.
        * shared.h (class pinfo): Ditto.
        * syscall.cc (seteuid): Ditto.
        * spawn.cc (_spawnve): Ditto. Eliminate conditional.
        (spawn_guts): Set child->uid = USHRT_MAX when user context will be
        changed in child process.
        * uinfo.cc (uinfo_init): Check for myself->uid instead of myself->psid
        to avoid reloading of /etc/passwd on process startup if ntsec is off.
        Use above defines instead of numerical constants.
        * security.cc: Move define for MAX_SID_LEN to winsup.h.
@
text
@d550 1
a550 2
      OemToCharW (buf, wbuf);
      cbPathLen = (strlen (buf) + 1) * sizeof (WCHAR);
@


1.30
log
@        * syscalls.cc (seteuid): Initialize pi.token before calling
        internal_getlogin().
        * uinfo.cc (internal_getlogin): Use impersonation token instead
        of process token in case of active impersonation. Add some comments.
        (uinfo_init): Initializing myself->token and myself->impersonated
        before calling internal_getlogin(). Add some comments.
@
text
@d1875 1
a1875 1
          CopySid (40, myself->psid, pi.psid);
@


1.29
log
@        * cygwin.din: Define symbols for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        * dcrt0.cc (dll_crt0_1): Eliminate superfluous conditional
        statements.
        Add load statements for `ImpersonateLoggedOnUser', `LogonUserA'
        and `RevertToSelf'.
        * fork.cc (fork): Care for correct impersonation of parent
        and child process.
        * security.cc (cygwin_set_impersonation_token): New function.
        (cygwin_logon_user): Ditto.
        shared.h (class pinfo): New members `orig_uid', `orig_gid',
        `real_uid' nad `real_gid'.
        spawn.cc (spawn_guts): Care for impersonation when starting
        child process in a different user context.
        * syscalls.cc (setgid): Call `setegid' now. Set real_gid.
        (setuid): Call `seteuid' now. Set real_uid.
        (seteuid): Functionality moved from setuid to here. Care for
        correct impersonation.
        (setegid): Functionality moved from setgid to here.
        * uinfo.cc (uinfo_init): Initialization of additional pinfo
        members.
        (getuid): Return real uid.
        (getgid): Return real gid.
        (geteuid): Return effective uid.
        (getegid): Return effective gid.
        include/sys/cygwin.h: Add prototypes for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        include/cygwin/version.h: Bumb API minor version to 22.
@
text
@d1859 5
@


1.28
log
@        * dir.cc (writable_directory): Comment out previous code,
        return always 1 for now.
        (mkdir): Call set_file_attribute explicitely with S_IFDIR mode bit.
        * syscalls.cc (chown_worker): Ditto.
        (chmod): Ditto.
        * security.cc (get_nt_attribute): Fix error in debug output.
        Never set FILE_DELETE_CHILD for files.
        Construct appropriate inherit attribute according to file type.
@
text
@d1800 16
a1815 15
  if (os_being_run == winNT)
    {
      if (gid != (gid_t) -1)
        {
          if (!getgrgid (gid))
            {
              set_errno (EINVAL);
              return -1;
            }
          myself->gid = gid;
        }
    }
  else
    set_errno (ENOSYS);
  return 0;
d1820 1
a1820 1
/* setuid: POSIX 4.2.2.1 */
d1823 1
a1823 1
setuid (uid_t uid)
d1836 21
d1862 3
d1877 1
a1880 8
/* seteuid: standards? */
extern "C"
int
seteuid (uid_t uid)
{
  return setuid (uid);
}

d1886 15
a1900 1
  return setgid (gid);
@


1.27
log
@* syscalls.cc (_cygwin_istext_for_stdio): New, for newlib
* include/cygwin/version.h: Bump API number for detect old
programs using old getc/putc macros
@
text
@d704 2
d810 3
d816 2
@


1.26
log
@        * dir.cc (rmdir): Care for misleading error messages
        when trying to remove a directory on a samba share.
        Eliminate superfluous else branch.
        * syscalls.cc (_rename): Additional check for ERROR_FILE_EXISTS
        if MoveFile fails.
@
text
@d1434 36
d1481 3
d1533 4
a1536 1
  setmode_mode = mode;
d1539 4
@


1.25
log
@* syscalls.cc (setmode): change mode of any matching FILE* also.
@
text
@d1234 2
a1235 1
  if (res == 0 || GetLastError () != ERROR_ALREADY_EXISTS)
@


1.24
log
@* path.cc (mount_info::cygdrive_posix_path): Don't add trailing slash if
referring to something like c:\.
* dcrt0.cc (dll_crt0_1): Move uinfo initialization prior to sig_send
initialization to give signal thread a chance to finish.
* debug.cc (WFSO): Move to sigproc.cc
(WFMO): Ditto.
* exceptions.cc (interruptible): Allocate slightly more space for directory
just for paranoia's sake.
(call_handler): Eliminate nonmain argument.  Determine if main thread has set a
frame pointer and use it if so.
(sig_handle): Eliminate nonmain argument.
* net.cc: Record frame information in appropriate routines throughout.
* select.cc (select): Ditto.
* sigproc.cc: Use sigthread structure to record mainthread id throughout.
(sig_send): Record frame information for signal handler.
(wait_sig): Reflect argument change in sig_handle.
(WFSO): Move here and record frame information for signal handler.
(WFMO): Ditto.
* sigproc.h: Implement new "sigthread" class.  Implement "sigframe" class for
manipulating signal frame info.
* thread.cc (__pthread_kill): Use standard _kill() function rather than calling
sig_send directly.
* winsup.h: Eliminate ebp element from signal_dispatch class.
@
text
@d1433 18
d1492 4
@


1.23
log
@2000-05-06  Mumit Khan  <khan@@xraylith.wisc.edu>

	* include/wchar.h (wcscmp, wcslen): Fix prototypes.
	* syscalls.cc (wcslen, wcscmp): Adjust.
@
text
@d187 1
@


1.22
log
@* configure.in: Use -gstabs+ as compile debug option.  This seems to promote
better handling of symbols.
* configure: Regenerate.
* delqueue.cc (delqueue_list::process_queue): Allow ERROR_ACCESS_DENIED to
indicate that a file is being shared under Windows 95.
* syscalls.cc (_unlink): Use full path name.  Take special action for Windows
95.  Assume that an ERROR_ACCESS_DENIED indicates a sharing violation unless
it's on a remote drive.  Punt if there is an ERROR_ACCESS_DENIED on a remote
drive.
@
text
@d1839 1
a1839 1
wcscmp (wchar_t *s1, wchar_t *s2)
d1851 2
a1852 2
int
wcslen (wchar_t *s1)
@


1.21
log
@        * errno.cc (errmap): Map ERROR_BAD_NETPATH to new errno ENOSHARE.
        (_sys_errlist): Add entry for ENOSHARE.
        (strerror): Add case for ENOSHARE.
        * syscalls.cc (stat_worker): Check for errno ENOSHARE.
@
text
@d50 1
a50 1
  path_conv win32_name (ourname, SYMLINK_NOFOLLOW);
d85 3
d97 1
a97 1
	  if (i > 0 || GetFileAttributes (win32_name) == (DWORD) -1)
a104 10
	goto err;

      res = GetLastError ();
      syscall_printf ("couldn't delete file, %E");

      /* if access denied, chmod to be writable in case it is not
	 and try again */
      /* FIXME!!! Should check whether ourname is directory or file
	 and only try again if permissions are not sufficient */
      if (res == ERROR_ACCESS_DENIED)
d106 2
a107 4
	  /* chmod file to be writable here */
	  if (chmod (win32_name, 0777) == 0)
	    continue;
	  else
d109 10
d121 2
d125 1
a125 1
      if (res == ERROR_SHARING_VIOLATION)
d132 7
d978 1
a978 1
suffix_info stat_suffixes[] = 
@


1.20
log
@        * syscalls.cc (stat_worker): Previous patch could succeed
        in stating a non-existant file.
@
text
@d1033 2
a1034 1
  else if (atts != -1 || (!oret && get_errno () != ENOENT))
@


1.19
log
@        * syscalls.cc (stat_worker): Previous patch failed to stat
        each drives root dir on 9X.
@
text
@d981 1
d1017 2
a1018 2
      && fh.open (real_path, O_RDONLY | O_BINARY | O_DIROPEN |
			     (nofollow ? O_NOSYMLINK : 0), 0))
d1033 1
a1033 1
  else if (atts != -1 || GetLastError () != ERROR_FILE_NOT_FOUND)
d1035 2
a1036 2
      /* Unfortunately, the above open may fail. So we have
         to care for this case here, too. */
@


1.18
log
@        * fhandler.cc (fhandler_disk_file::open): Check for allow_ntsec
        when determining exec flag.
        * path.cc (symlink_info::check): Remove call to get_file_attribute().
        * security.cc (read_sd): Rename, ditto for variables to conform
        to common naming convention. Use GetFileSecurity() instead of
        BackupRead() to avoid permission problems when reading ACLs.
        (write_sd): Same renaming as for read_sd().
        (alloc_sd): Change default permissions according to Linux permissions
        for group and world when write permission is set.
        * syscalls.cc (stat_worker): Avoid different permission problems
        when requesting file informations.
@
text
@a981 1
  char *win32_name;
a1000 1
  win32_name = real_path.get_win32 ();
d1003 1
a1003 1
		     hash_path_name (0, win32_name), buf);
d1007 1
a1007 1
  debug_printf ("%d = GetFileAttributesA (%s)", atts, win32_name);
d1009 1
a1009 1
  strcpy (root, win32_name);
d1030 1
a1030 1
            (dtype == DRIVE_REMOTE ? 1 : num_entries (win32_name));
d1042 1
a1042 1
        buf->st_nlink = num_entries (win32_name);
d1064 1
a1064 1
          == INVALID_HANDLE_VALUE)
d1066 7
a1072 2
          __seterrno ();
          goto done;
a1073 7
      buf->st_atime   = to_time_t (&wfd.ftLastAccessTime);
      buf->st_mtime   = to_time_t (&wfd.ftLastWriteTime);
      buf->st_ctime   = to_time_t (&wfd.ftCreationTime);
      buf->st_size    = wfd.nFileSizeLow;
      buf->st_blksize = S_BLKSIZE;
      buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
      FindClose (handle);
@


1.17
log
@        * syscalls.cc (_link): Check new link path for trailing dot.
@
text
@d985 2
d1014 6
a1019 4
  if (atts == -1 || !(atts & FILE_ATTRIBUTE_DIRECTORY) ||
      (os_being_run == winNT
       && dtype != DRIVE_NO_ROOT_DIR
       && dtype != DRIVE_UNKNOWN))
d1021 2
a1022 17
      fhandler_disk_file fh (NULL);

      if (fh.open (real_path, O_RDONLY | O_BINARY | O_DIROPEN |
			      (nofollow ? O_NOSYMLINK : 0), 0))
	{
	  res = fh.fstat (buf);
	  fh.close ();
          /* See the comment 10 lines below */
	  if (atts != -1 && (atts & FILE_ATTRIBUTE_DIRECTORY))
            buf->st_nlink =
                (dtype == DRIVE_REMOTE ? 1 : num_entries (win32_name));
	}
    }
  else
    {
      WIN32_FIND_DATA wfd;
      HANDLE handle;
d1030 15
a1044 1
      buf->st_nlink = (dtype == DRIVE_REMOTE ? 1 : num_entries (win32_name));
d1047 31
a1077 17
      buf->st_mode = S_IFDIR | STD_RBITS | STD_XBITS;
      if ((atts & FILE_ATTRIBUTE_READONLY) == 0)
	buf->st_mode |= STD_WBITS;

      get_file_attribute (real_path.has_acls (), real_path.get_win32 (),
                          NULL, &buf->st_uid, &buf->st_gid);

      if ((handle = FindFirstFile (real_path.get_win32(), &wfd)) != INVALID_HANDLE_VALUE)
	{
	  buf->st_atime   = to_time_t (&wfd.ftLastAccessTime);
	  buf->st_mtime   = to_time_t (&wfd.ftLastWriteTime);
	  buf->st_ctime   = to_time_t (&wfd.ftCreationTime);
	  buf->st_size    = wfd.nFileSizeLow;
	  buf->st_blksize = S_BLKSIZE;
	  buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
	  FindClose (handle);
	}
@


1.16
log
@	* syscalls.cc (setuid): Allow switching user context after
	successful call to ImpersonateLogedOnUser (NT only).
	(setgid): Ditto.
	(seteuid): Call setuid.
	(setegid): Call setgid.
@
text
@d487 1
d492 1
a492 2
      syscall_printf ("-1 = link (%s, %s)", a, b);
      return -1;
a493 3

  path_conv real_b (b, SYMLINK_NOFOLLOW);

d497 7
a503 2
      syscall_printf ("-1 = link (%s, %s)", a, b);
      return -1;
@


1.15
log
@* syscalls.cc (_rename): Try MoveFile() at first before
MoveFileEx(..., MOVEFILE_REPLACE_EXISTING).
@
text
@a1691 1
/* FIXME: unimplemented! */
d1694 1
a1694 1
setgid (gid_t)
d1696 14
a1709 1
  set_errno (ENOSYS);
d1713 2
a1715 1
/* FIXME: unimplemented! */
d1718 1
a1718 1
setuid (uid_t)
d1720 28
a1747 1
  set_errno (ENOSYS);
d1754 1
a1754 1
seteuid (uid_t)
d1756 1
a1756 2
  set_errno (ENOSYS);
  return 0;
d1762 1
a1762 1
setegid (gid_t)
d1764 1
a1764 2
  set_errno (ENOSYS);
  return 0;
@


1.14
log
@* init.cc (dll_entry): Use better check for determining when to set thread
specific stuff.
* syscalls.cc (_unlink): Continue with chmod'ing file even if DELETE_ON_CLOSE
succeeds, if file still exists.
@
text
@d1203 13
a1215 2
  /* First make sure we have the permissions */
  if (!MoveFileEx (real_old.get_win32 (), real_new.get_win32 (), MOVEFILE_REPLACE_EXISTING))
d1217 2
a1218 4
      res = -1;

      /* !!! fixme, check for windows version before trying this.. */
      if (GetLastError () == ERROR_CALL_NOT_IMPLEMENTED)
d1220 8
a1227 3
	  /* How sad, we must be on win95, try it the stupid way */
	  syscall_printf ("try win95 hack");
	  for (;;)
a1233 14

	      if (GetLastError () != ERROR_ALREADY_EXISTS)
		{
		  syscall_printf ("%s already_exists", real_new.get_win32 ());
		  break;
		}

	      if (!DeleteFileA (real_new.get_win32 ()) &&
		  GetLastError () != ERROR_FILE_NOT_FOUND)
		{
		  syscall_printf ("deleting %s to be paranoid",
				  real_new.get_win32 ());
		  break;
		}
a1235 2
      if (res)
	__seterrno ();
d1237 4
@


1.13
log
@* dcrt0.cc (insert_file): Avoid freeing previously allocated argument list.
* path.cc (symlink_info::check): Rename from symlink_check_one.  Use new
symlink_info struct for communication.
(path_conv::path_conv): Use symlink_info structure for communication with
symlink_info::check.  Fix typo which resulted in symbolic links always being
resolved.
(readlink): Use stat_suffixes array when resolving a link.
* syscalls.cc (stat_suffixes): Make global.
@
text
@d94 5
a98 2
	  res = 0;
	  break;
@


1.12
log
@        * newlib/libc/include/sys/unistd.h: Add prototypes for
        fchmod, fchown, lchown.
        * winsup/cygwin/syscalls.cc (chown_worker): Use previous
        uid/gid if new uid/gid is -1.
        New static function with chown functionality.
        (chown): Call chown_worker with SYMLINK_FOLLOW.
        (fchown): New function. Call chown_worker with SYMLINK_FOLLOW.
        (lchown): New function. Call chown_worker with SYMLINK_IGNORE.
        * cygwin.din: Add symbols for fchown, lchown.
        * path.cc (symlink): Call `set_file_attribute()' and
        `SetFileAttributeA()' instead of `chmod()' to set
        uid/gid correct.
@
text
@d963 1
a963 1
static suffix_info stat_suffixes[] = 
@


1.11
log
@* Makefile.in: Use default rules when compiling cygrun.o.
* dcrt0.cc (host_dependent_constants::init): Limit non-NT platforms to 32K
chunks when copying regions during a fork.
* path.cc (symlink_check_one): Add temporary debugging output.  Simplify
PATH_EXEC test.
* syscalls.cc (stat_suffixes): Null terminate this list.
@
text
@a643 3
 *
 * Note: the SetFileSecurity API in NT can only set the current
 * user as file owner so we have to use the Backup API instead.
d645 2
a646 3
extern "C"
int
chown (const char * name, uid_t uid, gid_t gid)
d649 2
d657 1
a657 1
      path_conv win32_path (name);
d677 1
a677 3
      int has_acls;
      has_acls = allow_ntsec && win32_path.has_acls ();
      res = get_file_attribute (has_acls,
d679 3
a681 1
                                (int *) &attrib);
d683 10
a692 5
	res = set_file_attribute (win32_path.has_acls (),
                                  win32_path.get_win32 (),
				  uid, gid, attrib,
                                  myself->logsrv);

d702 2
a703 1
  syscall_printf ("%d = chown (%s,...)", res, name);
d705 39
@


1.10
log
@* path.cc (symlink_check_one): Recognize symlink settings from the mount table.
* path.h: Make PATH_SYMLINK an alias for MOUNT_SYMLINK.
* syscalls.cc (stat_worker): Use extension search mechanism in path_conv to
look for .exe rather than trying to special case it here.
* mount.h: Make MOUNT_SYMLINK a real option.
@
text
@d923 2
a924 1
  suffix_info (".exe", 1)
@


1.9
log
@* syscalls.cc (stat_worker): Set st_nlink to 1 on remote drives.
@
text
@d920 6
d940 3
a942 1
  path_conv real_path (name, nofollow ? SYMLINK_NOFOLLOW : SYMLINK_FOLLOW, 1);
a956 19

/* FIXME: this is of dubious merit and is fundamentally flawed.
   E.g., what if the .exe file is a symlink?  This is not accounted
   for here.  Also, what about all of the other special extensions?

   This could be "fixed" by passing the appropriate extension list
   to path_conv but I'm not sure that this is really justified.  */

  /* If we can't find the name, try again with a .exe suffix
     [but only if not already present].  */
  if (atts == -1 && GetLastError () == ERROR_FILE_NOT_FOUND &&
      !(strrchr (win32_name, '.') > strrchr (win32_name, '\\')))
    {
      debug_printf ("trying with .exe suffix");
      strcat (win32_name, ".exe");
      atts = (int) GetFileAttributesA (win32_name);
      if (atts == -1)
	strchr (win32_name, '\0')[4] = '\0';
    }
@


1.8
log
@* delqueue.cc (delqueue_list::queue_file): Add some debugging.
* path.h (class path_conv): Add a char * operator for the most common case.
* syscalls.cc (_unlink): Rewrite to use FILE_FLAG_DELETE_ON_CLOSE when possible
(i.e., on NT).
@
text
@d989 1
a989 1
                (dtype == DRIVE_REMOTE ? 2 : num_entries (win32_name));
d1001 3
a1003 1
      buf->st_nlink = (dtype == DRIVE_REMOTE ? 2 : num_entries (win32_name));
@


1.7
log
@        * security.cc (set_process_privileges): Removed `static'.
        (get_nt_attribute): Returns uid and gid additionally. Removed call
        to set_process_privileges().
        (get_file_attribute): Returns uid and gid additionally. Don't
        call ntea if ntsec is ON.
        (set_nt_attribute): Removed call to set_process_privileges().
        Don't call ntea if ntsec is ON.
        (acl): Removed call to set_process_privileges().
        * dcrt0.cc (dll_crt0_1): Calls set_process_privileges() now.
        * winsup.h: New prototype for set_process_privileges(),
        changed prototype for get_file_attribute().
        * fhandler.cc (get_file_owner): Discarded.
        (get_file_group): Ditto.
        (fhandler_disk_file::fstat): Discard calls to get_file_owner() and
        get_file_group().
        * path.cc (path_conv::path_conv): Added debugging output for result
        of GetVolumeInformation().
        (mount_info::conv_to_win32_path): Call backslashify() with pathbuf
        instead of src_path.
        * syscalls.cc (chown): Reformatted.
        (chmod): Replace get_file_owner() and get_file_group() calls
        by a call to get_file_attribute(). Discard local variable has_acls.
        Slightly reformatted.
        (stat_worker): Replaced idiot's (it's me) root dir check by call
        to rootdir(). Don't call num_entries() on remote drives.
        Discard local variable has_acls.
@
text
@d70 1
a70 1
  if (! writable_directory (win32_name.get_win32 ()))
d76 1
a76 3
  if (DeleteFileA (win32_name.get_win32 ()))
    res = 0;
  else
d78 23
d102 1
d110 5
a114 9
	  /* chmod ourname to be writable here */
	  res = chmod (ourname, 0777);

	  if (DeleteFileA (win32_name.get_win32 ()))
	    {
	      res = 0;
	      goto done;
	    }
	  res = GetLastError ();
d121 1
a121 1
	  cygwin_shared->delqueue.queue_file (win32_name.get_win32 ());
d123 1
d125 5
a129 5
      else
	{
	  __seterrno ();
	  res = -1;
	}
@


1.6
log
@* environ.cc: Eliminate oldstack CYGWIN option.
* exceptions.cc (sfta): Eliminate obsolete function.
(sgmb): Eliminate obsolete function.
(class stack_info): Remove MS method for walking the stack.
(stack_info::init): Just initialize required fields.
(stack_info::brute_force): Rename to stack_info::walk.
(handle_exceptions): Pass derived frame pointer to sig_send.
(interrupt_setup): Clear saved frame pointer here.
(interrupt_on_return): thestack is no longer a pointer.
(call_handler): Accept a flag to indicate when a signal was sent from other
than the main thread.  Use saved frame pointer for determining where to place
signal handler call.
(sig_handle): Accept "nonmain" argument.  Pass it to call_handler.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Change
debugging output slightly.
* (fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_tty_slave::read): Fix a comment, remove a goto.
* sigproc.cc (sig_send): Accept an optional frame pointer argument for use when
suspending the main process.  sigcomplete_main is an autoreset event now.  Save
frame pointer for non-main operation.
(wait_sig): Make sigcomplete_main an autoreset event.  Eliminate NOSIGQUEUE.
Pass rc to sig_handle to signify if this was a nonmain process.
* sigproc.h: Reflect change to sig_send argument.
* syscalls.cc (swab): Eliminate swab function since it is now available in
newlib.
* winsup.h (signal_dispatch): Change CONTEXT cx to DWORD ebp.
@
text
@d662 3
a664 1
      res = get_file_attribute (has_acls, win32_path.get_win32 (), (int *) &attrib);
d728 9
a736 8
      int has_acls = allow_ntsec && win32_path.has_acls ();
      uid_t uid = get_file_owner (has_acls, win32_path.get_win32 ());
      if (! set_file_attribute (has_acls, win32_path.get_win32 (),
				uid,
				get_file_group (has_acls,
                                                win32_path.get_win32 ()),
				mode,
                                myself->logsrv)
d909 2
a910 1
  char drive[4] = "X:\\";
d952 2
a953 2
  drive[0] = win32_name[0];
  UINT dtype;
d957 2
a958 3
       && (((dtype = GetDriveType (drive)) != DRIVE_NO_ROOT_DIR
	     //&& dtype != DRIVE_REMOTE
	     && dtype != DRIVE_UNKNOWN))))
d967 1
d969 2
a970 1
	    buf->st_nlink = num_entries (win32_name);
d977 6
a982 4
      /* hmm, the number of links to a directory includes the
	 number of entries in the directory, since all the things
	 in the directory point to it */
      buf->st_nlink += num_entries (win32_name);
d989 2
a990 4
      int has_acls = allow_ntsec && real_path.has_acls ();

      buf->st_uid = get_file_owner (has_acls, real_path.get_win32 ());
      buf->st_gid = get_file_group (has_acls, real_path.get_win32 ());
@


1.5
log
@*** empty log message ***
@
text
@a1845 15
swab (const void *src, void *dst, ssize_t n)
{
  const char *from = (const char *) src;
  char *to = (char *) dst;

  while (n > 1)
    {
      const char b0 = from[--n], b1 = from[--n];
      to[n] = b0;
      to[n + 1] = b1;
    }
}

extern "C"
void
@


1.4
log
@* syscalls.c (_read): Clear errno before doing any read operation.
@
text
@d192 1
a192 1
  // set_sig_errno (0);
@


1.3
log
@Respond to more g++ warnings relating to initializing structures.
@
text
@d192 1
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d1630 1
a1630 1
setgid (gid_t a)
d1640 1
a1640 1
setuid (uid_t b)
d1649 1
a1649 1
seteuid (uid_t c)
d1658 1
a1658 1
setegid (gid_t a)
d1667 1
a1667 1
chroot (const char *path)
@


1.1
log
@Initial revision
@
text
@d152 1
a152 1
read_handler (int fd, void *ptr, size_t len, int blocksigs)
d172 1
a172 1
  res = fh->bg_check (SIGTTIN, blocksigs);
d201 1
a201 1
      return read_handler (fd, ptr, len, 0);
d205 1
a205 1
    return read_handler (fd, ptr, len, 1);
d235 1
a235 1
  res = fh->bg_check (SIGTTOU, 0);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
