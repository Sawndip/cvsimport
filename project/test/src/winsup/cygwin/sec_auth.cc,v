head	1.63;
access;
symbols
	cygwin-1_7_35-release:1.63
	cygwin-1_7_34-release:1.62
	cygwin-1_7_33-release:1.49.2.2
	cygwin-1_7_32-release:1.49.2.2
	cygwin-1_7_31-release:1.49.2.2
	cygwin-1_7_30-release:1.49.2.2
	cygwin-1_7_29-release:1.49.2.1
	cygwin-1_7_29-release-branchpoint:1.49.0.2
	cygwin-pre-user-db:1.49
	cygwin-1_7_28-release:1.49
	cygwin-1_7_27-release:1.48
	cygwin-1_7_26-release:1.48
	cygwin-1_7_25-release:1.48
	cygwin-1_7_24-release:1.48
	cygwin-1_7_23-release:1.48
	cygwin-1_7_22-release:1.48
	cygwin-1_7_21-release:1.48
	cygwin-1_7_20-release:1.47
	cygwin-1_7_19-release:1.47
	cygwin-64bit-postmerge:1.47
	cygwin-64bit-premerge-branch:1.46.0.2
	cygwin-64bit-premerge:1.46
	cygwin-1_7_18-release:1.46
	post-ptmalloc3:1.44.2.4
	pre-ptmalloc3:1.44.2.4
	cygwin-1_7_17-release:1.44
	cygwin-64bit-branch:1.44.0.2
	cygwin-1_7_16-release:1.44
	cygwin-1_7_15-release:1.44
	cygwin-1_7_14_2-release:1.44
	cygwin-1_7_14-release:1.44
	cygwin-1_7_12-release:1.44
	cygwin-1_7_11-release:1.44
	cygwin-1_7_10-release:1.44
	signal-rewrite:1.41.0.2
	pre-notty:1.41
	cygwin-1_7_9-release:1.32
	cv-post-1_7_9:1.32.0.2
	cygwin-1_7_8-release:1.32
	cygwin-1_7_7-release:1.31
	cygwin-1_7_5-release:1.31
	cygwin-1_7_4-release:1.31
	cygwin-1_7_3-release:1.31
	cygwin-1_7_2-release:1.31
	fifo_doover3:1.26.0.2
	cygwin-1_7_1-release:1.26
	prefifo:1.25
	cv-branch-2:1.23.0.2
	pre-ripout-set_console_state_for_spawn:1.7
	EOL_registry_mounts:1.4;
locks; strict;
comment	@// @;


1.63
date	2015.03.03.12.58.33;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2015.01.21.16.31.38;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2014.12.02.10.49.47;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2014.12.02.10.04.53;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2014.10.21.19.17.09;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2014.09.05.11.47.33;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2014.05.22.16.40.13;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2014.05.20.10.21.34;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2014.05.14.11.27.47;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2014.05.06.12.28.33;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2014.03.28.20.34.04;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2014.02.19.18.29.52;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2014.02.16.16.02.18;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2014.01.23.17.02.30;	author corinna;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2013.06.10.15.33.12;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.27.12.09.38;	author ktietz;	state Exp;
branches;
next	1.44;

1.44
date	2011.12.22.11.02.34;	author corinna;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2011.10.15.16.31.57;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.29.10.38.12;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.29.07.34.04;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.28.09.53.11;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.28.09.30.36;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.28.08.34.49;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.04.12.23.36;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.04.09.00.02;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.01.08.41.26;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2011.02.26.20.47.56;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2010.02.24.17.30.18;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2010.02.12.17.40.41;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.06.13.13.15;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.29.19.51.11;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.08.15.55.27;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.13.10.23.31;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.25.08.22.09;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.23.10.23.16;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.09.15.08.16;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.24.10.53.57;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.18.13.58.35;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.23.18.27.48;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.20.16.10.45;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.15.20.25.44;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.26.17.21.04;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.26.10.18.10;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.30.12.10.20;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.11.10.00.36;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.10.18.01.25;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2008.07.09.15.45.08;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.09.11.58.38;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.09.08.10.25;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.17.18.54.16;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.10.15.16.01;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.22.10.45.34;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.25.18.32.23;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.20.14.29.43;	author corinna;	state Exp;
branches;
next	;

1.49.2.1
date	2014.03.28.20.58.58;	author corinna;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2014.05.20.10.21.40;	author corinna;	state Exp;
branches;
next	;

1.44.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2012.10.27.12.11.51;	author ktietz;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.44.2.4;

1.44.2.4
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.44.2.5;

1.44.2.5
date	2013.03.01.16.32.33;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.63
log
@	* common.din (issetugid): Export.
	* glob.cc (issetugid): Drop macro.
	* sec_auth.cc (issetugid): New exported function.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@/* sec_auth.cc: NT authentication functions

   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <wchar.h>
#include <wininet.h>
#include <ntsecapi.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "registry.h"
#include "ntdll.h"
#include "tls_pbuf.h"
#include <lm.h>
#include <iptypes.h>
#include <wininet.h>
#include <userenv.h>
#include "cyglsa.h"
#include "cygserver_setpwd.h"
#include <cygwin/version.h>

/* OpenBSD 2.0 and later. */
extern "C"
int
issetugid (void)
{
  return cygheap->user.issetuid () ? 1 : 0;
}

/* Starting with Windows Vista, the token returned by system functions
   is a restricted token.  The full admin token is linked to it and can
   be fetched with NtQueryInformationToken.  This function returns the original
   token on pre-Vista, and the elevated token on Vista++ if it's available,
   the original token otherwise.  The token handle is also made inheritable
   since that's necessary anyway. */
static HANDLE
get_full_privileged_inheritable_token (HANDLE token)
{
  if (wincap.has_mandatory_integrity_control ())
    {
      TOKEN_LINKED_TOKEN linked;
      ULONG size;

      /* When fetching the linked token without TCB privs, then the linked
	 token is not a primary token, only an impersonation token, which is
	 not suitable for CreateProcessAsUser.  Converting it to a primary
	 token using DuplicateTokenEx does NOT work for the linked token in
	 this case.  So we have to switch on TCB privs to get a primary token.
	 This is generally performed in the calling functions.  */
      if (NT_SUCCESS (NtQueryInformationToken (token, TokenLinkedToken,
					       (PVOID) &linked, sizeof linked,
					       &size)))
	{
	  debug_printf ("Linked Token: %p", linked.LinkedToken);
	  if (linked.LinkedToken)
	    {
	      TOKEN_TYPE type;

	      /* At this point we don't know if the user actually had TCB
		 privileges.  Check if the linked token is a primary token.
		 If not, just return the original token. */
	      if (NT_SUCCESS (NtQueryInformationToken (linked.LinkedToken,
						       TokenType, (PVOID) &type,
						       sizeof type, &size))
		  && type != TokenPrimary)
		debug_printf ("Linked Token is not a primary token!");
	      else
		{
		  CloseHandle (token);
		  token = linked.LinkedToken;
		}
	    }
	}
    }
  if (!SetHandleInformation (token, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))
    {
      __seterrno ();
      CloseHandle (token);
      token = NULL;
    }
  return token;
}

void
set_imp_token (HANDLE token, int type)
{
  debug_printf ("set_imp_token (%p, %d)", token, type);
  cygheap->user.external_token = (token == INVALID_HANDLE_VALUE
				  ? NO_IMPERSONATION : token);
  cygheap->user.ext_token_is_restricted = (type == CW_TOKEN_RESTRICTED);
}

extern "C" void
cygwin_set_impersonation_token (const HANDLE hToken)
{
  set_imp_token (hToken, CW_TOKEN_IMPERSONATION);
}

void
extract_nt_dom_user (const struct passwd *pw, PWCHAR domain, PWCHAR user)
{

  cygsid psid;
  DWORD ulen = UNLEN + 1;
  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;
  SID_NAME_USE use;

  debug_printf ("pw_gecos %p (%s)", pw->pw_gecos, pw->pw_gecos);

  if (psid.getfrompw (pw)
      && LookupAccountSidW (NULL, psid, user, &ulen, domain, &dlen, &use))
    return;

  char *d, *u, *c;
  domain[0] = L'\0';
  sys_mbstowcs (user, UNLEN + 1, pw->pw_name);
  if ((d = strstr (pw->pw_gecos, "U-")) != NULL &&
      (d == pw->pw_gecos || d[-1] == ','))
    {
      c = strchrnul (d + 2, ',');
      if ((u = strchrnul (d + 2, '\\')) >= c)
       u = d + 1;
      else if (u - d <= MAX_DOMAIN_NAME_LEN + 2)
       sys_mbstowcs (domain, MAX_DOMAIN_NAME_LEN + 1, d + 2, u - d - 1);
      if (c - u <= UNLEN + 1)
       sys_mbstowcs (user, UNLEN + 1, u + 1, c - u);
    }
}

extern "C" HANDLE
cygwin_logon_user (const struct passwd *pw, const char *password)
{
  if (!pw || !password)
    {
      set_errno (EINVAL);
      return INVALID_HANDLE_VALUE;
    }

  WCHAR nt_domain[MAX_DOMAIN_NAME_LEN + 1];
  WCHAR nt_user[UNLEN + 1];
  PWCHAR passwd;
  HANDLE hToken;
  tmp_pathbuf tp;

  extract_nt_dom_user (pw, nt_domain, nt_user);
  debug_printf ("LogonUserW (%W, %W, ...)", nt_user, nt_domain);
  sys_mbstowcs (passwd = tp.w_get (), NT_MAX_PATH, password);
  /* CV 2005-06-08: LogonUser should run under the primary process token,
     otherwise it returns with ERROR_ACCESS_DENIED. */
  cygheap->user.deimpersonate ();
  if (!LogonUserW (nt_user, *nt_domain ? nt_domain : NULL, passwd,
		   LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,
		   &hToken))
    {
      __seterrno ();
      hToken = INVALID_HANDLE_VALUE;
    }
  else
    {
      /* See the comment in get_full_privileged_inheritable_token for a
      description why we enable TCB privileges here. */
      push_self_privilege (SE_TCB_PRIVILEGE, true);
      hToken = get_full_privileged_inheritable_token (hToken);
      pop_self_privilege ();
      if (!hToken)
	hToken = INVALID_HANDLE_VALUE;
    }
  RtlSecureZeroMemory (passwd, NT_MAX_PATH);
  cygheap->user.reimpersonate ();
  debug_printf ("%R = logon_user(%s,...)", hToken, pw->pw_name);
  return hToken;
}

/* The buffer path points to should be at least MAX_PATH bytes. */
PWCHAR
get_user_profile_directory (PCWSTR sidstr, PWCHAR path, SIZE_T path_len)
{
  if (!sidstr || !path)
    return NULL;

  UNICODE_STRING buf;
  tmp_pathbuf tp;
  tp.u_get (&buf);
  NTSTATUS status;

  RTL_QUERY_REGISTRY_TABLE tab[2] = {
    { NULL, RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT
           | RTL_QUERY_REGISTRY_REQUIRED,
      L"ProfileImagePath", &buf, REG_NONE, NULL, 0 },
    { NULL, 0, NULL, NULL, 0, NULL, 0 }
  };

  WCHAR key[wcslen (sidstr) + 16];
  wcpcpy (wcpcpy (key, L"ProfileList\\"), sidstr);
  status = RtlQueryRegistryValues (RTL_REGISTRY_WINDOWS_NT, key, tab,
                                  NULL, NULL);
  if (!NT_SUCCESS (status) || buf.Length == 0)
    {
      debug_printf ("ProfileImagePath for %W not found, status %y", sidstr,
		    status);
      return NULL;
    }
  ExpandEnvironmentStringsW (buf.Buffer, path, path_len);
  debug_printf ("ProfileImagePath for %W: %W", sidstr, path);
  return path;
}

/* The CreateProfile prototype is for some reason missing in our w32api headers,
   even though it's defined upstream since Dec-2013. */
extern "C" {
  HRESULT WINAPI CreateProfile (LPCWSTR pszUserSid, LPCWSTR pszUserName,
				LPWSTR pszProfilePath, DWORD cchProfilePath);
}

/* Load user profile if it's not already loaded.  If the user profile doesn't
   exist on the machine, and if we're running Vista or later, try to create it. 

   Return a handle to the loaded user registry hive only if it got actually
   loaded here, not if it already existed.  There's no reliable way to know
   when to unload the hive yet, so we're leaking this registry handle for now.
   TODO: Try to find a way to reliably unload the user profile again. */
HANDLE
load_user_profile (HANDLE token, struct passwd *pw, cygpsid &usersid)
{
  WCHAR domain[DNLEN + 1];
  WCHAR username[UNLEN + 1];
  WCHAR sid[128];
  HKEY hkey;
  WCHAR userpath[MAX_PATH];
  PROFILEINFOW pi;
  WCHAR server[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  NET_API_STATUS nas = NERR_UserNotFound;
  PUSER_INFO_3 ui;

  extract_nt_dom_user (pw, domain, username);
  usersid.string (sid);
  debug_printf ("user: <%W> <%W>", username, sid);
  /* Check if user hive is already loaded. */
  if (!RegOpenKeyExW (HKEY_USERS, sid, 0, KEY_READ, &hkey))
    {
      debug_printf ("User registry hive for %W already exists", username);
      RegCloseKey (hkey);
      return NULL;
    }
  /* Check if the local profile dir has already been created. */
  if (!get_user_profile_directory (sid, userpath, MAX_PATH))
   {
     /* No, try to create it.  This function exists only on Vista and later. */
     HRESULT res = CreateProfile (sid, username, userpath, MAX_PATH);
     if (res != S_OK)
       {
	 /* If res is 1 (S_FALSE), autoloading failed (XP or 2K3). */
	 if (res != S_FALSE)
	   debug_printf ("CreateProfile, HRESULT %x", res);
	 return NULL;
       }
    }
  /* Fill PROFILEINFO */
  memset (&pi, 0, sizeof pi);
  pi.dwSize = sizeof pi;
  pi.dwFlags = PI_NOUI;
  pi.lpUserName = username;
  /* Check if user has a roaming profile and fill in lpProfilePath, if so. */
  if (get_logon_server (domain, server, DS_IS_FLAT_NAME))
    {
      nas = NetUserGetInfo (server, username, 3, (PBYTE *) &ui);
      if (NetUserGetInfo (server, username, 3, (PBYTE *) &ui) != NERR_Success)
	debug_printf ("NetUserGetInfo, %u", nas);
      else if (ui->usri3_profile && *ui->usri3_profile)
	pi.lpProfilePath = ui->usri3_profile;
    }

  if (!LoadUserProfileW (token, &pi))
    debug_printf ("LoadUserProfileW, %E");
  /* Free buffer created by NetUserGetInfo */
  if (nas == NERR_Success)
    NetApiBufferFree (ui);
  return pi.hProfile;
}

HANDLE
lsa_open_policy (PWCHAR server, ACCESS_MASK access)
{
  LSA_UNICODE_STRING srvbuf;
  PLSA_UNICODE_STRING srv = NULL;
  static LSA_OBJECT_ATTRIBUTES oa = { 0, 0, 0, 0, 0, 0 };
  HANDLE lsa;

  if (server)
    {
      srv = &srvbuf;
      RtlInitUnicodeString (srv, server);
    }
  NTSTATUS status = LsaOpenPolicy (srv, &oa, access, &lsa);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      lsa = NULL;
    }
  return lsa;
}

void
lsa_close_policy (HANDLE lsa)
{
  if (lsa)
    LsaClose (lsa);
}

bool
get_logon_server (PCWSTR domain, PWCHAR server, ULONG flags)
{
  DWORD ret;
  PDOMAIN_CONTROLLER_INFOW pci;

  /* Empty domain is interpreted as local system */
  if (cygheap->dom.init ()
      && (!domain[0]
	  || !wcscasecmp (domain, cygheap->dom.account_flat_name ())))
    {
      wcpcpy (wcpcpy (server, L"\\\\"), cygheap->dom.account_flat_name ());
      return true;
    }

  /* Try to get any available domain controller for this domain */
  ret = DsGetDcNameW (NULL, domain, NULL, NULL, flags, &pci);
  if (ret == ERROR_SUCCESS)
    {
      wcscpy (server, pci->DomainControllerName);
      NetApiBufferFree (pci);
      debug_printf ("DC: server: %W", server);
      return true;
    }
  __seterrno_from_win_error (ret);
  return false;
}

static bool
get_user_groups (WCHAR *logonserver, cygsidlist &grp_list,
		 PWCHAR user, PWCHAR domain)
{
  WCHAR dgroup[MAX_DOMAIN_NAME_LEN + GNLEN + 2];
  LPGROUP_USERS_INFO_0 buf;
  DWORD cnt, tot, len;
  NET_API_STATUS ret;

  /* Look only on logonserver */
  ret = NetUserGetGroups (logonserver, user, 0, (LPBYTE *) &buf,
			  MAX_PREFERRED_LENGTH, &cnt, &tot);
  if (ret)
    {
      __seterrno_from_win_error (ret);
      /* It's no error when the user name can't be found.
	 It's also no error if access has been denied.  Yes, sounds weird, but
	 keep in mind that ERROR_ACCESS_DENIED means the current user has no
	 permission to access the AD user information.  However, if we return
	 an error, Cygwin will call DsGetDcName with DS_FORCE_REDISCOVERY set
	 to ask for another server.  This is not only time consuming, it's also
	 useless; the next server will return access denied again. */
      return ret == NERR_UserNotFound || ret == ERROR_ACCESS_DENIED;
    }

  len = wcslen (domain);
  wcscpy (dgroup, domain);
  dgroup[len++] = L'\\';

  for (DWORD i = 0; i < cnt; ++i)
    {
      cygsid gsid;
      DWORD glen = SECURITY_MAX_SID_SIZE;
      WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
      DWORD dlen = sizeof (dom);
      SID_NAME_USE use = SidTypeInvalid;

      wcscpy (dgroup + len, buf[i].grui0_name);
      if (!LookupAccountNameW (NULL, dgroup, gsid, &glen, dom, &dlen, &use))
	debug_printf ("LookupAccountName(%W), %E", dgroup);
      else if (well_known_sid_type (use))
	grp_list *= gsid;
      else if (legal_sid_type (use))
	grp_list += gsid;
      else
	debug_printf ("Global group %W invalid. Use: %u", dgroup, use);
    }

  NetApiBufferFree (buf);
  return true;
}

static bool
get_user_local_groups (PWCHAR logonserver, PWCHAR domain,
		       cygsidlist &grp_list, PWCHAR user)
{
  LPLOCALGROUP_INFO_0 buf;
  DWORD cnt, tot;
  NET_API_STATUS ret;

  ret = NetUserGetLocalGroups (logonserver, user, 0, LG_INCLUDE_INDIRECT,
			       (LPBYTE *) &buf, MAX_PREFERRED_LENGTH,
			       &cnt, &tot);
  if (ret)
    {
      __seterrno_from_win_error (ret);
      return false;
    }

  WCHAR domlocal_grp[MAX_DOMAIN_NAME_LEN + GNLEN + 2];
  WCHAR builtin_grp[2 * GNLEN + 2];
  PWCHAR dg_ptr, bg_ptr = NULL;
  SID_NAME_USE use;

  dg_ptr = wcpcpy (domlocal_grp, domain);
  *dg_ptr++ = L'\\';

  for (DWORD i = 0; i < cnt; ++i)
    {
      cygsid gsid;
      DWORD glen = SECURITY_MAX_SID_SIZE;
      WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
      DWORD domlen = MAX_DOMAIN_NAME_LEN + 1;

      use = SidTypeInvalid;
      wcscpy (dg_ptr, buf[i].lgrpi0_name);
      if (LookupAccountNameW (NULL, domlocal_grp, gsid, &glen,
			      dom, &domlen, &use))
	{
	  if (well_known_sid_type (use))
	    grp_list *= gsid;
	  else if (legal_sid_type (use))
	    grp_list += gsid;
	  else
	    debug_printf ("Rejecting local %W. use: %u", dg_ptr, use);
	}
      else if (GetLastError () == ERROR_NONE_MAPPED)
	{
	  /* Check if it's a builtin group. */
	  if (!bg_ptr)
	    {
	      /* Retrieve name of builtin group from system since it's
		 localized. */
	      glen = 2 * GNLEN + 2;
	      if (!LookupAccountSidW (NULL, well_known_builtin_sid,
				      builtin_grp, &glen, domain, &domlen, &use))
		debug_printf ("LookupAccountSid(BUILTIN), %E");
	      else
		{
		  bg_ptr = builtin_grp + wcslen (builtin_grp);
		  bg_ptr = wcpcpy (builtin_grp, L"\\");
		}
	    }
	  if (bg_ptr)
	    {
	      wcscpy (bg_ptr, dg_ptr);
	      glen = SECURITY_MAX_SID_SIZE;
	      domlen = MAX_DOMAIN_NAME_LEN + 1;
	      if (LookupAccountNameW (NULL, builtin_grp, gsid, &glen,
				      dom, &domlen, &use))
		{
		  if (!legal_sid_type (use))
		    debug_printf ("Rejecting local %W. use: %u", dg_ptr, use);
		  else
		    grp_list *= gsid;
		}
	      else
		debug_printf ("LookupAccountName(%W), %E", builtin_grp);
	    }
	}
      else
	debug_printf ("LookupAccountName(%W), %E", domlocal_grp);
    }
  NetApiBufferFree (buf);
  return true;
}

static bool
sid_in_token_groups (PTOKEN_GROUPS grps, cygpsid sid)
{
  if (!grps)
    return false;
  for (DWORD i = 0; i < grps->GroupCount; ++i)
    if (sid == grps->Groups[i].Sid)
      return true;
  return false;
}

static void
get_token_group_sidlist (cygsidlist &grp_list, PTOKEN_GROUPS my_grps,
			 LUID auth_luid, int &auth_pos)
{
  auth_pos = -1;
  if (my_grps)
    {
      grp_list += well_known_local_sid;
      if (wincap.has_console_logon_sid ())
	grp_list += well_known_console_logon_sid;
      if (sid_in_token_groups (my_grps, well_known_dialup_sid))
	grp_list *= well_known_dialup_sid;
      if (sid_in_token_groups (my_grps, well_known_network_sid))
	grp_list *= well_known_network_sid;
      if (sid_in_token_groups (my_grps, well_known_batch_sid))
	grp_list *= well_known_batch_sid;
      grp_list *= well_known_interactive_sid;
#if 0
      /* Don't add the SERVICE group when switching the user context.
	 That's much too dangerous, since the service group adds the
	 SE_IMPERSONATE_NAME privilege to the user.  After all, the
	 process started with this token is not the service process
	 anymore anyway. */
      if (sid_in_token_groups (my_grps, well_known_service_sid))
	grp_list *= well_known_service_sid;
#endif
      if (sid_in_token_groups (my_grps, well_known_this_org_sid))
	grp_list *= well_known_this_org_sid;
      grp_list *= well_known_users_sid;
    }
  else
    {
      grp_list += well_known_local_sid;
      grp_list *= well_known_interactive_sid;
      grp_list *= well_known_users_sid;
    }
  if (get_ll (auth_luid) != 999LL) /* != SYSTEM_LUID */
    {
      for (DWORD i = 0; i < my_grps->GroupCount; ++i)
	if (my_grps->Groups[i].Attributes & SE_GROUP_LOGON_ID)
	  {
	    grp_list += my_grps->Groups[i].Sid;
	    auth_pos = grp_list.count () - 1;
	    break;
	  }
    }
}

bool
get_server_groups (cygsidlist &grp_list, PSID usersid, struct passwd *pw)
{
  WCHAR user[UNLEN + 1];
  WCHAR domain[MAX_DOMAIN_NAME_LEN + 1];
  WCHAR server[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  DWORD ulen = UNLEN + 1;
  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;
  SID_NAME_USE use;

  if (well_known_system_sid == usersid)
    {
      grp_list *= well_known_admins_sid;
      return true;
    }

  grp_list *= well_known_world_sid;
  grp_list *= well_known_authenticated_users_sid;

  if (!LookupAccountSidW (NULL, usersid, user, &ulen, domain, &dlen, &use))
    {
      __seterrno ();
      return false;
    }
  /* If the SID does NOT start with S-1-5-21, the domain is some builtin
     domain.  The search for a logon server and fetching group accounts
     is moot. */
  if (sid_id_auth (usersid) == 5 /* SECURITY_NT_AUTHORITY */
      && sid_sub_auth (usersid, 0) == SECURITY_NT_NON_UNIQUE
      && get_logon_server (domain, server, DS_IS_FLAT_NAME))
    {
      get_user_groups (server, grp_list, user, domain);
      get_user_local_groups (server, domain, grp_list, user);
    }
  return true;
}

static bool
get_initgroups_sidlist (cygsidlist &grp_list,
			PSID usersid, PSID pgrpsid, struct passwd *pw,
			PTOKEN_GROUPS my_grps, LUID auth_luid, int &auth_pos)
{
  grp_list *= well_known_world_sid;
  grp_list *= well_known_authenticated_users_sid;
  if (well_known_system_sid == usersid)
    auth_pos = -1;
  else
    get_token_group_sidlist (grp_list, my_grps, auth_luid, auth_pos);
  if (!get_server_groups (grp_list, usersid, pw))
    return false;

  /* special_pgrp true if pgrpsid is not in normal groups */
  grp_list += pgrpsid;
  return true;
}

static void
get_setgroups_sidlist (cygsidlist &tmp_list, PSID usersid, struct passwd *pw,
		       PTOKEN_GROUPS my_grps, user_groups &groups,
		       LUID auth_luid, int &auth_pos)
{
  tmp_list *= well_known_world_sid;
  tmp_list *= well_known_authenticated_users_sid;
  get_token_group_sidlist (tmp_list, my_grps, auth_luid, auth_pos);
  get_server_groups (tmp_list, usersid, pw);
  for (int gidx = 0; gidx < groups.sgsids.count (); gidx++)
    tmp_list += groups.sgsids.sids[gidx];
  tmp_list += groups.pgsid;
}

static ULONG sys_privs[] = {
  SE_CREATE_TOKEN_PRIVILEGE,
  SE_ASSIGNPRIMARYTOKEN_PRIVILEGE,
  SE_LOCK_MEMORY_PRIVILEGE,
  SE_INCREASE_QUOTA_PRIVILEGE,
  SE_TCB_PRIVILEGE,
  SE_SECURITY_PRIVILEGE,
  SE_TAKE_OWNERSHIP_PRIVILEGE,
  SE_LOAD_DRIVER_PRIVILEGE,
  SE_SYSTEM_PROFILE_PRIVILEGE,		/* Vista ONLY */
  SE_SYSTEMTIME_PRIVILEGE,
  SE_PROF_SINGLE_PROCESS_PRIVILEGE,
  SE_INC_BASE_PRIORITY_PRIVILEGE,
  SE_CREATE_PAGEFILE_PRIVILEGE,
  SE_CREATE_PERMANENT_PRIVILEGE,
  SE_BACKUP_PRIVILEGE,
  SE_RESTORE_PRIVILEGE,
  SE_SHUTDOWN_PRIVILEGE,
  SE_DEBUG_PRIVILEGE,
  SE_AUDIT_PRIVILEGE,
  SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
  SE_CHANGE_NOTIFY_PRIVILEGE,
  SE_UNDOCK_PRIVILEGE,
  SE_MANAGE_VOLUME_PRIVILEGE,
  SE_IMPERSONATE_PRIVILEGE,
  SE_CREATE_GLOBAL_PRIVILEGE,
  SE_INCREASE_WORKING_SET_PRIVILEGE,
  SE_TIME_ZONE_PRIVILEGE,
  SE_CREATE_SYMBOLIC_LINK_PRIVILEGE
};

#define SYSTEM_PRIVILEGES_COUNT (sizeof sys_privs / sizeof *sys_privs)

static PTOKEN_PRIVILEGES
get_system_priv_list (size_t &size)
{
  ULONG max_idx = 0;
  while (max_idx < SYSTEM_PRIVILEGES_COUNT
	 && sys_privs[max_idx] != wincap.max_sys_priv ())
    ++max_idx;
  if (max_idx >= SYSTEM_PRIVILEGES_COUNT)
    api_fatal ("Coding error: wincap privilege %u doesn't exist in sys_privs",
	       wincap.max_sys_priv ());
  size = sizeof (ULONG) + (max_idx + 1) * sizeof (LUID_AND_ATTRIBUTES);
  PTOKEN_PRIVILEGES privs = (PTOKEN_PRIVILEGES) malloc (size);
  if (!privs)
    {
      debug_printf ("malloc (system_privs) failed.");
      return NULL;
    }
  privs->PrivilegeCount = 0;
  for (ULONG i = 0; i <= max_idx; ++i)
    {
      privs->Privileges[privs->PrivilegeCount].Luid.HighPart = 0L;
      privs->Privileges[privs->PrivilegeCount].Luid.LowPart = sys_privs[i];
      privs->Privileges[privs->PrivilegeCount].Attributes =
	SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
      ++privs->PrivilegeCount;
    }
  return privs;
}

static PTOKEN_PRIVILEGES
get_priv_list (LSA_HANDLE lsa, cygsid &usersid, cygsidlist &grp_list,
	       size_t &size, cygpsid *mandatory_integrity_sid)
{
  PLSA_UNICODE_STRING privstrs;
  ULONG cnt;
  PTOKEN_PRIVILEGES privs = NULL;

  if (usersid == well_known_system_sid)
    {
      if (mandatory_integrity_sid)
	*mandatory_integrity_sid = mandatory_system_integrity_sid;
      return get_system_priv_list (size);
    }

  if (mandatory_integrity_sid)
    *mandatory_integrity_sid = mandatory_medium_integrity_sid;

  for (int grp = -1; grp < grp_list.count (); ++grp)
    {
      if (grp == -1)
	{
	  if (LsaEnumerateAccountRights (lsa, usersid, &privstrs, &cnt)
	      != STATUS_SUCCESS)
	    continue;
	}
      else if (LsaEnumerateAccountRights (lsa, grp_list.sids[grp],
					  &privstrs, &cnt) != STATUS_SUCCESS)
	continue;
      for (ULONG i = 0; i < cnt; ++i)
	{
	  LUID priv;
	  PTOKEN_PRIVILEGES tmp;
	  DWORD tmp_count;
	  bool high_integrity;

	  if (!privilege_luid (privstrs[i].Buffer, priv, high_integrity))
	    continue;

	  if (privs)
	    {
	      DWORD pcnt = privs->PrivilegeCount;
	      LUID_AND_ATTRIBUTES *p = privs->Privileges;
	      for (; pcnt > 0; --pcnt, ++p)
		if (priv.HighPart == p->Luid.HighPart
		    && priv.LowPart == p->Luid.LowPart)
		  goto next_account_right;
	    }

	  tmp_count = privs ? privs->PrivilegeCount : 0;
	  size = sizeof (DWORD)
		 + (tmp_count + 1) * sizeof (LUID_AND_ATTRIBUTES);
	  tmp = (PTOKEN_PRIVILEGES) realloc (privs, size);
	  if (!tmp)
	    {
	      if (privs)
		free (privs);
	      LsaFreeMemory (privstrs);
	      debug_printf ("realloc (privs) failed.");
	      return NULL;
	    }
	  tmp->PrivilegeCount = tmp_count;
	  privs = tmp;
	  privs->Privileges[privs->PrivilegeCount].Luid = priv;
	  privs->Privileges[privs->PrivilegeCount].Attributes =
	    SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
	  ++privs->PrivilegeCount;
	  if (mandatory_integrity_sid && high_integrity)
	    *mandatory_integrity_sid = mandatory_high_integrity_sid;

	next_account_right:
	  ;
	}
      LsaFreeMemory (privstrs);
    }
  return privs;
}

/* Accept a token if
   - the requested usersid matches the TokenUser and
   - if setgroups has been called:
	the token groups that are listed in /etc/group match the union of
	the requested primary and supplementary groups in gsids.
   - else the (unknown) implicitly requested supplementary groups and those
	in the token are the groups associated with the usersid. We assume
	they match and verify only the primary groups.
	The requested primary group must appear in the token.
	The primary group in the token is a group associated with the usersid,
	except if the token is internal and the group is in the token SD
	(see create_token). In that latter case that group must match the
	requested primary group.  */
bool
verify_token (HANDLE token, cygsid &usersid, user_groups &groups, bool *pintern)
{
  NTSTATUS status;
  ULONG size;
  bool intern = false;

  if (pintern)
    {
      TOKEN_SOURCE ts;
      status = NtQueryInformationToken (token, TokenSource, &ts, sizeof ts,
					&size);
      if (!NT_SUCCESS (status))
	debug_printf ("NtQueryInformationToken(), %y", status);
      else
	*pintern = intern = !memcmp (ts.SourceName, "Cygwin.1", 8);
    }
  /* Verify usersid */
  cygsid tok_usersid (NO_SID);
  status = NtQueryInformationToken (token, TokenUser, &tok_usersid,
				    sizeof tok_usersid, &size);
  if (!NT_SUCCESS (status))
    debug_printf ("NtQueryInformationToken(), %y", status);
  if (usersid != tok_usersid)
    return false;

  /* For an internal token, if setgroups was not called and if the sd group
     is not well_known_null_sid, it must match pgrpsid */
  if (intern && !groups.issetgroups ())
    {
      const DWORD sd_buf_siz = SECURITY_MAX_SID_SIZE
			       + sizeof (SECURITY_DESCRIPTOR);
      PSECURITY_DESCRIPTOR sd_buf = (PSECURITY_DESCRIPTOR) alloca (sd_buf_siz);
      cygpsid gsid (NO_SID);
      NTSTATUS status;
      status = NtQuerySecurityObject (token, GROUP_SECURITY_INFORMATION,
				      sd_buf, sd_buf_siz, &size);
      if (!NT_SUCCESS (status))
	debug_printf ("NtQuerySecurityObject(), %y", status);
      else
	{
	  BOOLEAN dummy;
	  status = RtlGetGroupSecurityDescriptor (sd_buf, (PSID *) &gsid,
						  &dummy);
	  if (!NT_SUCCESS (status))
	    debug_printf ("RtlGetGroupSecurityDescriptor(), %y", status);
	}
      if (well_known_null_sid != gsid)
	return gsid == groups.pgsid;
    }

  PTOKEN_GROUPS my_grps;

  status = NtQueryInformationToken (token, TokenGroups, NULL, 0, &size);
  if (!NT_SUCCESS (status) && status != STATUS_BUFFER_TOO_SMALL)
    {
      debug_printf ("NtQueryInformationToken(token, TokenGroups), %y", status);
      return false;
    }
  my_grps = (PTOKEN_GROUPS) alloca (size);
  status = NtQueryInformationToken (token, TokenGroups, my_grps, size, &size);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQueryInformationToken(my_token, TokenGroups), %y",
		    status);
      return false;
    }

  bool sawpg = false;

  if (groups.issetgroups ()) /* setgroups was called */
    {
      cygpsid gsid;
      bool saw[groups.sgsids.count ()];

      /* Check that all groups in the setgroups () list are in the token.
	 A token created through ADVAPI should be allowed to contain more
	 groups than requested through setgroups(), especially since Vista
	 and the addition of integrity groups. */
      memset (saw, 0, sizeof(saw));
      for (int gidx = 0; gidx < groups.sgsids.count (); gidx++)
	{
	  gsid = groups.sgsids.sids[gidx];
	  if (sid_in_token_groups (my_grps, gsid))
	    {
	      int pos = groups.sgsids.position (gsid);
	      if (pos >= 0)
		saw[pos] = true;
	      else if (groups.pgsid == gsid)
		sawpg = true;
	    }
	}
      /* user.sgsids groups must be in the token, except for builtin groups.
	 These can be different on domain member machines compared to
	 domain controllers, so these builtin groups may be validly missing
	 from a token created through password or lsaauth logon. */
      for (int gidx = 0; gidx < groups.sgsids.count (); gidx++)
	if (!saw[gidx]
	    && !groups.sgsids.sids[gidx].is_well_known_sid ()
	    && !sid_in_token_groups (my_grps, groups.sgsids.sids[gidx]))
	  return false;
    }
  /* The primary group must be in the token */
  return sawpg
	 || sid_in_token_groups (my_grps, groups.pgsid)
	 || groups.pgsid == usersid;
}

HANDLE
create_token (cygsid &usersid, user_groups &new_groups, struct passwd *pw)
{
  NTSTATUS status;
  LSA_HANDLE lsa = NULL;

  cygsidlist tmp_gsids (cygsidlist_auto, 12);

  SECURITY_QUALITY_OF_SERVICE sqos =
    { sizeof sqos, SecurityImpersonation, SECURITY_STATIC_TRACKING, FALSE };
  OBJECT_ATTRIBUTES oa = { sizeof oa, 0, 0, 0, 0, &sqos };
  LUID auth_luid = SYSTEM_LUID;
  LARGE_INTEGER exp = { QuadPart:INT64_MAX };

  TOKEN_USER user;
  PTOKEN_GROUPS new_tok_gsids = NULL;
  PTOKEN_PRIVILEGES privs = NULL;
  TOKEN_OWNER owner;
  TOKEN_PRIMARY_GROUP pgrp;
  TOKEN_DEFAULT_DACL dacl = {};
  TOKEN_SOURCE source;
  TOKEN_STATISTICS stats;
  memcpy (source.SourceName, "Cygwin.1", 8);
  source.SourceIdentifier.HighPart = 0;
  source.SourceIdentifier.LowPart = 0x0101;

  HANDLE token = INVALID_HANDLE_VALUE;
  HANDLE primary_token = INVALID_HANDLE_VALUE;

  PTOKEN_GROUPS my_tok_gsids = NULL;
  cygpsid mandatory_integrity_sid;
  ULONG size;
  size_t psize = 0;

  /* SE_CREATE_TOKEN_NAME privilege needed to call NtCreateToken. */
  push_self_privilege (SE_CREATE_TOKEN_PRIVILEGE, true);

  /* Open policy object. */
  if (!(lsa = lsa_open_policy (NULL, POLICY_EXECUTE)))
    goto out;

  /* User, owner, primary group. */
  user.User.Sid = usersid;
  user.User.Attributes = 0;
  owner.Owner = usersid;

  /* Retrieve authentication id and group list from own process. */
  if (hProcToken)
    {
      /* Switching user context to SYSTEM doesn't inherit the authentication
	 id of the user account running current process. */
      if (usersid == well_known_system_sid)
	/* nothing to do */;
      else
	{
	  status = NtQueryInformationToken (hProcToken, TokenStatistics,
					    &stats, sizeof stats, &size);
	  if (!NT_SUCCESS (status))
	    debug_printf ("NtQueryInformationToken(hProcToken, "
			  "TokenStatistics), %y", status);
	  else
	    auth_luid = stats.AuthenticationId;
	}

      /* Retrieving current processes group list to be able to inherit
	 some important well known group sids. */
      status = NtQueryInformationToken (hProcToken, TokenGroups, NULL, 0,
					&size);
      if (!NT_SUCCESS (status) && status != STATUS_BUFFER_TOO_SMALL)
	debug_printf ("NtQueryInformationToken(hProcToken, TokenGroups), %y",
		      status);
      else if (!(my_tok_gsids = (PTOKEN_GROUPS) malloc (size)))
	debug_printf ("malloc (my_tok_gsids) failed.");
      else
	{
	  status = NtQueryInformationToken (hProcToken, TokenGroups,
					    my_tok_gsids, size, &size);
	  if (!NT_SUCCESS (status))
	    {
	      debug_printf ("NtQueryInformationToken(hProcToken, TokenGroups), "
			    "%y", status);
	      free (my_tok_gsids);
	      my_tok_gsids = NULL;
	    }
	}
    }

  /* Create list of groups, the user is member in. */
  int auth_pos;
  if (new_groups.issetgroups ())
    get_setgroups_sidlist (tmp_gsids, usersid, pw, my_tok_gsids, new_groups,
			   auth_luid, auth_pos);
  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid, pw,
				    my_tok_gsids, auth_luid, auth_pos))
    goto out;

  /* Primary group. */
  pgrp.PrimaryGroup = new_groups.pgsid;

  /* Create a TOKEN_GROUPS list from the above retrieved list of sids. */
  new_tok_gsids = (PTOKEN_GROUPS)
		  alloca (sizeof (DWORD) + (tmp_gsids.count () + 1)
					   * sizeof (SID_AND_ATTRIBUTES));
  new_tok_gsids->GroupCount = tmp_gsids.count ();
  for (DWORD i = 0; i < new_tok_gsids->GroupCount; ++i)
    {
      new_tok_gsids->Groups[i].Sid = tmp_gsids.sids[i];
      new_tok_gsids->Groups[i].Attributes = SE_GROUP_MANDATORY
					    | SE_GROUP_ENABLED_BY_DEFAULT
					    | SE_GROUP_ENABLED;
    }
  if (auth_pos >= 0)
    new_tok_gsids->Groups[auth_pos].Attributes |= SE_GROUP_LOGON_ID;

  /* Retrieve list of privileges of that user.  Based on the usersid and
     the returned privileges, get_priv_list sets the mandatory_integrity_sid
     pointer to the correct MIC SID for UAC. */
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize,
			       &mandatory_integrity_sid)))
    goto out;

  /* On systems supporting Mandatory Integrity Control, add the MIC SID. */
  if (wincap.has_mandatory_integrity_control ())
    {
      new_tok_gsids->Groups[new_tok_gsids->GroupCount].Attributes =
	SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED;
      new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
	= mandatory_integrity_sid;
    }

  /* Let's be heroic... */
  status = NtCreateToken (&token, TOKEN_ALL_ACCESS, &oa, TokenImpersonation,
			  &auth_luid, &exp, &user, new_tok_gsids, privs, &owner,
			  &pgrp, &dacl, &source);
  if (status)
    __seterrno_from_nt_status (status);
  else
    {
      /* Convert to primary token. */
      if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, &sec_none,
			     SecurityImpersonation, TokenPrimary,
			     &primary_token))
	{
	  __seterrno ();
	  debug_printf ("DuplicateTokenEx %E");
	}
    }

out:
  pop_self_privilege ();
  if (token != INVALID_HANDLE_VALUE)
    CloseHandle (token);
  if (privs)
    free (privs);
  if (my_tok_gsids)
    free (my_tok_gsids);
  lsa_close_policy (lsa);

  debug_printf ("%p = create_token ()", primary_token);
  return primary_token;
}

HANDLE
lsaauth (cygsid &usersid, user_groups &new_groups, struct passwd *pw)
{
  cygsidlist tmp_gsids (cygsidlist_auto, 12);
  cygpsid pgrpsid;
  LSA_STRING name;
  HANDLE lsa_hdl = NULL, lsa = NULL;
  LSA_OPERATIONAL_MODE sec_mode;
  NTSTATUS status, sub_status;
  ULONG package_id, size;
  LUID auth_luid = SYSTEM_LUID;
  struct {
    LSA_STRING str;
    CHAR buf[16];
  } origin;
  DWORD ulen = UNLEN + 1;
  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;
  SID_NAME_USE use;
  cyglsa_t *authinf = NULL;
  ULONG authinf_size;
  TOKEN_SOURCE ts;
  PCYG_TOKEN_GROUPS gsids = NULL;
  PTOKEN_PRIVILEGES privs = NULL;
  PACL dacl = NULL;
  PVOID profile = NULL;
  LUID luid;
  QUOTA_LIMITS quota;
  size_t psize = 0, gsize = 0, dsize = 0;
  OFFSET offset, sids_offset;
  int tmpidx, non_well_known_cnt;

  HANDLE user_token = NULL;

  push_self_privilege (SE_TCB_PRIVILEGE, true);

  /* Register as logon process. */
  RtlInitAnsiString (&name, "Cygwin");
  SetLastError (0);
  status = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);
  if (status != STATUS_SUCCESS)
    {
      debug_printf ("LsaRegisterLogonProcess: %y", status);
      __seterrno_from_nt_status (status);
      goto out;
    }
  else if (GetLastError () == ERROR_PROC_NOT_FOUND)
    {
      debug_printf ("Couldn't load Secur32.dll");
      goto out;
    }
  /* Get handle to our own LSA package. */
  RtlInitAnsiString (&name, CYG_LSA_PKGNAME);
  status = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);
  if (status != STATUS_SUCCESS)
    {
      debug_printf ("LsaLookupAuthenticationPackage: %y", status);
      __seterrno_from_nt_status (status);
      goto out;
    }

  /* Open policy object. */
  if (!(lsa = lsa_open_policy (NULL, POLICY_EXECUTE)))
    goto out;

  /* Create origin. */
  stpcpy (origin.buf, "Cygwin");
  RtlInitAnsiString (&origin.str, origin.buf);
  /* Create token source. */
  memcpy (ts.SourceName, "Cygwin.1", 8);
  ts.SourceIdentifier.HighPart = 0;
  ts.SourceIdentifier.LowPart = 0x0103;

  /* Create list of groups, the user is member in. */
  int auth_pos;
  if (new_groups.issetgroups ())
    get_setgroups_sidlist (tmp_gsids, usersid, pw, NULL, new_groups, auth_luid,
			   auth_pos);
  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid, pw,
				    NULL, auth_luid, auth_pos))
    goto out;

  tmp_gsids.debug_print ("tmp_gsids");

  /* Evaluate size of TOKEN_GROUPS list */
  non_well_known_cnt =  tmp_gsids.non_well_known_count ();
  gsize = sizeof (DWORD) + non_well_known_cnt * sizeof (SID_AND_ATTRIBUTES);
  tmpidx = -1;
  for (int i = 0; i < non_well_known_cnt; ++i)
    if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) >= 0)
      gsize += RtlLengthSid (tmp_gsids.sids[tmpidx]);

  /* Retrieve list of privileges of that user.  The MIC SID is created by
     the LSA here. */
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize, NULL)))
    goto out;

  /* Create DefaultDacl. */
  dsize = sizeof (ACL) + 3 * sizeof (ACCESS_ALLOWED_ACE)
	  + RtlLengthSid (usersid)
	  + RtlLengthSid (well_known_admins_sid)
	  + RtlLengthSid (well_known_system_sid);
  dacl = (PACL) alloca (dsize);
  if (!NT_SUCCESS (RtlCreateAcl (dacl, dsize, ACL_REVISION)))
    goto out;
  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,
					   usersid)))
    goto out;
  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,
					   well_known_admins_sid)))
    goto out;
  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,
					   well_known_system_sid)))
    goto out;

  /* Evaluate authinf size and allocate authinf. */
  authinf_size = (authinf->data - (PBYTE) authinf);
  authinf_size += RtlLengthSid (usersid);	    /* User SID */
  authinf_size += gsize;			    /* Groups + Group SIDs */
  /* When trying to define the admins group as primary group on Vista,
     LsaLogonUser fails with error STATUS_INVALID_OWNER.  As workaround
     we define "Local" as primary group here.  Seteuid32 sets the primary
     group to the group set in /etc/passwd anyway. */
  if (new_groups.pgsid == well_known_admins_sid)
    pgrpsid = well_known_local_sid;
  else
    pgrpsid = new_groups.pgsid;

  authinf_size += RtlLengthSid (pgrpsid);	    /* Primary Group SID */

  authinf_size += psize;			    /* Privileges */
  authinf_size += 0;				    /* Owner SID */
  authinf_size += dsize;			    /* Default DACL */

  authinf = (cyglsa_t *) alloca (authinf_size);
  authinf->inf_size = authinf_size - ((PBYTE) &authinf->inf - (PBYTE) authinf);

  authinf->magic = CYG_LSA_MAGIC;

  if (!LookupAccountSidW (NULL, usersid, authinf->username, &ulen,
			  authinf->domain, &dlen, &use))
    {
      __seterrno ();
      goto out;
    }

  /* Store stuff in authinf with offset relative to start of "inf" member,
     instead of using pointers. */
  offset = authinf->data - (PBYTE) &authinf->inf;

  authinf->inf.ExpirationTime.LowPart = 0xffffffffL;
  authinf->inf.ExpirationTime.HighPart = 0x7fffffffL;
  /* User SID */
  authinf->inf.User.User.Sid = offset;
  authinf->inf.User.User.Attributes = 0;
  RtlCopySid (RtlLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),
	      usersid);
  offset += RtlLengthSid (usersid);
  /* Groups */
  authinf->inf.Groups = offset;
  gsids = (PCYG_TOKEN_GROUPS) ((PBYTE) &authinf->inf + offset);
  sids_offset = offset + sizeof (ULONG) + non_well_known_cnt
					  * sizeof (SID_AND_ATTRIBUTES);
  gsids->GroupCount = non_well_known_cnt;
  /* Group SIDs */
  tmpidx = -1;
  for (int i = 0; i < non_well_known_cnt; ++i)
    {
      if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) < 0)
	break;
      gsids->Groups[i].Sid = sids_offset;
      gsids->Groups[i].Attributes = SE_GROUP_MANDATORY
				    | SE_GROUP_ENABLED_BY_DEFAULT
				    | SE_GROUP_ENABLED;
      RtlCopySid (RtlLengthSid (tmp_gsids.sids[tmpidx]),
		  (PSID) ((PBYTE) &authinf->inf + sids_offset),
		  tmp_gsids.sids[tmpidx]);
      sids_offset += RtlLengthSid (tmp_gsids.sids[tmpidx]);
    }
  offset += gsize;
  /* Primary Group SID */
  authinf->inf.PrimaryGroup.PrimaryGroup = offset;
  RtlCopySid (RtlLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),
	      pgrpsid);
  offset += RtlLengthSid (pgrpsid);
  /* Privileges */
  authinf->inf.Privileges = offset;
  memcpy ((PBYTE) &authinf->inf + offset, privs, psize);
  offset += psize;
  /* Owner */
  authinf->inf.Owner.Owner = 0;
  /* Default DACL */
  authinf->inf.DefaultDacl.DefaultDacl = offset;
  memcpy ((PBYTE) &authinf->inf + offset, dacl, dsize);

  authinf->checksum = CYG_LSA_MAGIC;
  PDWORD csp;
  PDWORD csp_end;
  csp = (PDWORD) &authinf->username;
  csp_end = (PDWORD) ((PBYTE) authinf + authinf_size);
  while (csp < csp_end)
    authinf->checksum += *csp++;

  /* Try to logon... */
  status = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Interactive,
			 package_id, authinf, authinf_size, NULL, &ts,
			 &profile, &size, &luid, &user_token, &quota,
			 &sub_status);
  if (status != STATUS_SUCCESS)
    {
      debug_printf ("LsaLogonUser: %y (sub-status %y)", status, sub_status);
      __seterrno_from_nt_status (status);
      goto out;
    }
  if (profile)
    {
#ifdef JUST_ANOTHER_NONWORKING_SOLUTION
      /* See ../lsaauth/cyglsa.c. */
      cygprf_t *prf = (cygprf_t *) profile;
      if (prf->magic_pre == MAGIC_PRE && prf->magic_post == MAGIC_POST
	  && prf->token)
	{
	  CloseHandle (user_token);
	  user_token = prf->token;
	  system_printf ("Got token through profile: %p", user_token);
	}
#endif /* JUST_ANOTHER_NONWORKING_SOLUTION */
      LsaFreeReturnBuffer (profile);
    }
  user_token = get_full_privileged_inheritable_token (user_token);

out:
  if (privs)
    free (privs);
  lsa_close_policy (lsa);
  if (lsa_hdl)
    LsaDeregisterLogonProcess (lsa_hdl);
  pop_self_privilege ();

  debug_printf ("%p = lsaauth ()", user_token);
  return user_token;
}

#define SFU_LSA_KEY_SUFFIX	L"_microsoft_sfu_utility"

HANDLE
lsaprivkeyauth (struct passwd *pw)
{
  NTSTATUS status;
  HANDLE lsa = NULL;
  HANDLE token = NULL;
  WCHAR sid[256];
  WCHAR domain[MAX_DOMAIN_NAME_LEN + 1];
  WCHAR user[UNLEN + 1];
  WCHAR key_name[MAX_DOMAIN_NAME_LEN + UNLEN + wcslen (SFU_LSA_KEY_SUFFIX) + 2];
  UNICODE_STRING key;
  PUNICODE_STRING data = NULL;
  cygsid psid;
  BOOL ret;

  push_self_privilege (SE_TCB_PRIVILEGE, true);

  /* Open policy object. */
  if (!(lsa = lsa_open_policy (NULL, POLICY_GET_PRIVATE_INFORMATION)))
    goto out;

  /* Needed for Interix key and LogonUser. */
  extract_nt_dom_user (pw, domain, user);

  /* First test for a Cygwin entry. */
  if (psid.getfrompw (pw) && psid.string (sid))
    {
      wcpcpy (wcpcpy (key_name, CYGWIN_LSA_KEY_PREFIX), sid);
      RtlInitUnicodeString (&key, key_name);
      status = LsaRetrievePrivateData (lsa, &key, &data);
      if (!NT_SUCCESS (status))
	data = NULL;
    }
  /* No Cygwin key, try Interix key. */
  if (!data && *domain)
    {
      __small_swprintf (key_name, L"%W_%W%W",
			domain, user, SFU_LSA_KEY_SUFFIX);
      RtlInitUnicodeString (&key, key_name);
      status = LsaRetrievePrivateData (lsa, &key, &data);
      if (!NT_SUCCESS (status))
	data = NULL;
    }
  /* Found an entry?  Try to logon. */
  if (data)
    {
      /* The key is not 0-terminated. */
      PWCHAR passwd;
      size_t pwdsize = data->Length + sizeof (WCHAR);

      passwd = (PWCHAR) alloca (pwdsize);
      *wcpncpy (passwd, data->Buffer, data->Length / sizeof (WCHAR)) = L'\0';
      /* Weird:  LsaFreeMemory invalidates the content of the UNICODE_STRING
	 structure, but it does not invalidate the Buffer content. */
      RtlSecureZeroMemory (data->Buffer, data->Length);
      LsaFreeMemory (data);
      debug_printf ("Try logon for %W\\%W", domain, user);
      ret = LogonUserW (user, domain, passwd, LOGON32_LOGON_INTERACTIVE,
			LOGON32_PROVIDER_DEFAULT, &token);
      RtlSecureZeroMemory (passwd, pwdsize);
      if (!ret)
	{
	  __seterrno ();
	  token = NULL;
	}
      else
	token = get_full_privileged_inheritable_token (token);
    }
  lsa_close_policy (lsa);

out:
  pop_self_privilege ();
  return token;
}
@


1.62
log
@	* sec_auth.cc (get_logon_server): Constify domain parameter.
	* security.h (get_logon_server): Same in prototype.
@
text
@d34 8
@


1.61
log
@	* autoload.cc (CreateProfile): Import.
	(LoadUserProfileW): Import.
	* registry.cc (get_registry_hive_path): Move to sec_auth.cc.
	(load_registry_hive): Remove.
	* registry.h (get_registry_hive_path): Drop declaration.
	(load_registry_hive): Ditto.
	* sec_auth.cc (get_user_profile_directory): Moved from registry.cc and
	renamed.  Take third parameter with buffer length.
	(load_user_profile): New function taking over for load_registry_hive.
	Use official functions to load profile.  If profile is missing, create
	it on Vista and later.
	* security.h (get_user_profile_directory): Declare.
	(load_user_profile): Declare.
	* syscalls.cc (seteuid32): Replace call to load_registry_hive with call
	to load_user_profile.
	* uinfo.cc (cygheap_user::env_userprofile): Replace call to
	get_registry_hive_path with call to get_user_profile_directory.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d315 1
a315 1
get_logon_server (PWCHAR domain, WCHAR *server, ULONG flags)
@


1.60
log
@	* sec_auth.cc (str2lsa): Remove.
	(str2buf2lsa): Remove.
	(lsaauth): Call RtlInitAnsiString instead of str2lsa and str2buf2lsa.
@
text
@d23 1
d28 2
d178 107
@


1.59
log
@	* sec_auth.cc (get_user_groups): Remove experimental exception handler
	added 2014-09-05.
	(get_user_local_groups): Ditto.
@
text
@a174 17
static void
str2lsa (LSA_STRING &tgt, const char *srcstr)
{
  tgt.Length = strlen (srcstr);
  tgt.MaximumLength = tgt.Length + 1;
  tgt.Buffer = (PCHAR) srcstr;
}

static void
str2buf2lsa (LSA_STRING &tgt, char *buf, const char *srcstr)
{
  tgt.Length = strlen (srcstr);
  tgt.MaximumLength = tgt.Length + 1;
  tgt.Buffer = (PCHAR) buf;
  memcpy (buf, srcstr, tgt.MaximumLength);
}

d957 1
a957 1
  str2lsa (name, "Cygwin");
d972 1
a972 1
  str2lsa (name, CYG_LSA_PKGNAME);
d986 2
a987 1
  str2buf2lsa (origin.str, origin.buf, "Cygwin");
@


1.58
log
@	* exception.h (class exception): Remove unnecessary #ifdef.
	* uinfo.cc (client_request_pwdgrp::client_request_pwdgrp): Fix length
	counter to include trailing NUL.

	* sec_auth.cc (get_user_groups): Add experimental exception handler.
	(get_user_local_groups): Ditto.
@
text
@a22 1
#include "exception.h"
d258 3
a260 7
  {
    /* Experimental SEH */
    exception protect;
    /* Look only on logonserver */
    ret = NetUserGetGroups (logonserver, user, 0, (LPBYTE *) &buf,
			    MAX_PREFERRED_LENGTH, &cnt, &tot);
  }
d309 3
a311 8
  {
    /* Experimental SEH */
    exception protect;

    ret = NetUserGetLocalGroups (logonserver, user, 0, LG_INCLUDE_INDIRECT,
				 (LPBYTE *) &buf, MAX_PREFERRED_LENGTH,
				 &cnt, &tot);
  }
@


1.57
log
@	* sec_auth.cc (get_server_groups): Call get_user_local_groups only if
	get_logon_server succeeded.
@
text
@d23 1
d259 7
a265 3
  /* Look only on logonserver */
  ret = NetUserGetGroups (logonserver, user, 0, (LPBYTE *) &buf,
			  MAX_PREFERRED_LENGTH, &cnt, &tot);
d314 8
a321 3
  ret = NetUserGetLocalGroups (logonserver, user, 0, LG_INCLUDE_INDIRECT,
			       (LPBYTE *) &buf, MAX_PREFERRED_LENGTH,
			       &cnt, &tot);
@


1.56
log
@	* scandir.cc (scandir): Assume namelist is always valid, per POSIX.
	(CID 60021).
	* sec_auth.cc (cygwin_logon_user): Securely erase password copy.
	(lsaprivkeyauth): Avoid trying to dereference data if no key is stored
	in the registry (CID 60122).  Securely erase passwords after usage.
@
text
@d470 2
a471 1
     domain.  The search for a logon server is moot. */
d475 4
a478 2
    get_user_groups (server, grp_list, user, domain);
  get_user_local_groups (server, domain, grp_list, user);
@


1.55
log
@	* sec_auth.cc (get_server_groups): Call get_logon_server only for
	non-builtin accounts.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Check incoming
	account name for validity in terms of the current name prefixing rules
	and refuse invalid names.
@
text
@d169 1
d1189 1
a1189 1
  PUNICODE_STRING data;
d1191 1
d1209 30
d1240 2
a1241 9
	  /* No Cygwin key, try Interix key. */
	  if (!*domain)
	    goto out;
	  __small_swprintf (key_name, L"%W_%W%W",
			    domain, user, SFU_LSA_KEY_SUFFIX);
	  RtlInitUnicodeString (&key, key_name);
	  status = LsaRetrievePrivateData (lsa, &key, &data);
	  if (!NT_SUCCESS (status))
	    goto out;
d1243 2
d1246 1
a1246 15

  /* The key is not 0-terminated. */
  PWCHAR passwd;
  passwd = (PWCHAR) alloca (data->Length + sizeof (WCHAR));
  *wcpncpy (passwd, data->Buffer, data->Length / sizeof (WCHAR)) = L'\0';
  LsaFreeMemory (data);
  debug_printf ("Try logon for %W\\%W", domain, user);
  if (!LogonUserW (user, domain, passwd, LOGON32_LOGON_INTERACTIVE,
		   LOGON32_PROVIDER_DEFAULT, &token))
    {
      __seterrno ();
      token = NULL;
    }
  else
    token = get_full_privileged_inheritable_token (token);
a1248 1
  lsa_close_policy (lsa);
@


1.54
log
@	* security.h (MAX_SUBAUTH_CNT): Drop.  Use SID_MAX_SUB_AUTHORITIES
	instead throughout.
	(MAX_SID_LEN): Drop.  Use SECURITY_MAX_SID_SIZE instead throughout.
@
text
@d468 5
a472 1
  if (get_logon_server (domain, server, DS_IS_FLAT_NAME))
@


1.53
log
@	* sec_auth.cc (create_token): Initialize lsa handle to NULL, rather than
	to INVALID_HANDLE_VALUE.
	(lsaauth): Ditto.
	(lsaprivkeyauth): Ditto.
	* setlsapwd.cc (setlsapwd): Don't initialize lsa handle.
@
text
@d280 1
a280 1
      DWORD glen = MAX_SID_LEN;
d328 1
a328 1
      DWORD glen = MAX_SID_LEN;
d364 1
a364 1
	      glen = MAX_SID_LEN;
d690 2
a691 1
      const DWORD sd_buf_siz = MAX_SID_LEN + sizeof (SECURITY_DESCRIPTOR);
@


1.52
log
@	* passwd.cc (pg_ent::setent): Initialize cygheap domain info.
	* sec_auth.cc (get_logon_server): Ditto.
@
text
@d771 1
a771 1
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;
d935 1
a935 1
  HANDLE lsa_hdl = NULL, lsa = INVALID_HANDLE_VALUE;
d1176 1
a1176 1
  HANDLE lsa = INVALID_HANDLE_VALUE;
@


1.51
log
@	* miscfuncs.h (NT_readline::close): New function to close handle.
	(NT_readline::~NT_readline): Call close.
	* sec_auth.cc (verify_token): Use constructor to initialize tok_usersid.
	* security.h (cygsid::cygsid): Add copy constructor taking cygsid as
	source.
@
text
@d227 3
a229 1
  if (!domain[0] || !wcscasecmp (domain, cygheap->dom.account_flat_name ()))
@


1.50
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d676 1
a676 1
  cygsid tok_usersid = NO_SID;
@


1.49
log
@	* security.h (open_local_policy): Remove declaration.
	(lsa_open_policy): Declare.
	(lsa_close_policy): Declare.
	* sec_auth.cc (lsa_open_policy): Rename from open_local_policy.  Take
	server name as parameter.  Return NULL in case of error, rather than
	INVALID_HANDLE_VALUE.
	(lsa_close_policy): Rename from close_local_policy.  Make externally
	available.  Get handle by value.
	(create_token): Convert call to open_local_policy/close_local_policy
	according to aforementioned changes.
	(lsaauth): Ditto.
	(lsaprivkeyauth): Ditto.
	* setlsapwd.cc (setlsapwd): Ditto.
@
text
@a16 1
#include <dsgetdc.h>
a26 1
#include "pwdgrp.h"
d221 1
a221 1
get_logon_server (PWCHAR domain, WCHAR *server, bool rediscovery)
a224 1
  DWORD size = MAX_COMPUTERNAME_LENGTH + 1;
d227 1
a227 2
  if ((GetComputerNameW (server + 2, &size)) &&
      (!wcscasecmp (domain, server + 2) || !domain[0]))
d229 1
a229 1
      server[0] = server[1] = L'\\';
d234 1
a234 2
  ret = DsGetDcNameW (NULL, domain, NULL, NULL,
		      rediscovery ? DS_FORCE_REDISCOVERY : 0, &pci);
d239 1
a239 1
      debug_printf ("DC: rediscovery: %d, server: %W", rediscovery, server);
a394 22
get_unix_group_sidlist (struct passwd *pw, cygsidlist &grp_list)
{
  struct group *gr;
  cygsid gsid;

  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
    {
      if (gr->gr_gid == pw->pw_gid)
	goto found;
      else if (gr->gr_mem)
	for (int gi = 0; gr->gr_mem[gi]; ++gi)
	  if (strcasematch (pw->pw_name, gr->gr_mem[gi]))
	    goto found;
      continue;
    found:
      if (gsid.getfromgr (gr))
	grp_list += gsid;

    }
}

static void
a454 1
      get_unix_group_sidlist (pw, grp_list);
d466 1
a466 3
  if (get_logon_server (domain, server, false)
      && !get_user_groups (server, grp_list, user, domain)
      && get_logon_server (domain, server, true))
a468 1
  get_unix_group_sidlist (pw, grp_list);
d729 1
a729 2
      cygsid gsid;
      struct group *gr;
d731 5
d737 12
a748 25

      /* token groups found in /etc/group match the user.gsids ? */
      for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	if (gsid.getfromgr (gr) && sid_in_token_groups (my_grps, gsid))
	  {
	    int pos = groups.sgsids.position (gsid);
	    if (pos >= 0)
	      saw[pos] = true;
	    else if (groups.pgsid == gsid)
	      sawpg = true;
#if 0
	    /* With this `else', verify_token returns false if we find
	       groups in the token, which are not in the group list set
	       with setgroups().  That's rather dangerous.  What we're
	       really interested in is that all groups in the setgroups()
	       list are in the token.  A token created through ADVAPI
	       should be allowed to contain more groups than requested
	       through setgroups(), esecially since Vista and the
	       addition of integrity groups. So we disable this statement
	       for now. */
	    else if (gsid != well_known_world_sid
		     && gsid != usersid)
	      goto done;
#endif
	  }
@


1.49.2.1
log
@2014-03-28  Corinna Vinschen  <corinna@@vinschen.de>

	* sec_auth.cc (create_token): Initialize lsa handle to NULL, rather than
	to INVALID_HANDLE_VALUE.
	(lsaauth): Ditto.
	(lsaprivkeyauth): Ditto.
	* setlsapwd.cc (setlsapwd): Don't initialize lsa handle.

2014-03-28  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (_cygtls::signal_debugger): Move memcpy to copy context
	from incoming siginfo_t to thread_context, too.

2014-03-27  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (_sigbe/x86_64): Fix typo in .seh_proc pseudo-op.
	(setjmp/x86_64): Drop storing ExceptionList pointer in jmp_buf->Frame.
	Drop comment.  Store likely frame in rdx.  Jump to __setjmpex.
	(__setjmpex): New function providing setjmp functionality.  Fetch
	jmp_buf->Frame from rdx, like MSVCRT setjmpex.
	(__sjfault/x86_64): Store rdx content in jmp_buf->Frame.
	(__ljfault/x86_64): Don't restore ExceptionList pointer.
	(longjmp/x86_64): Ditto.
@
text
@d809 1
a809 1
  LSA_HANDLE lsa = NULL;
d973 1
a973 1
  HANDLE lsa_hdl = NULL, lsa = NULL;
d1214 1
a1214 1
  HANDLE lsa = NULL;
@


1.49.2.2
log
@	* sec_auth.cc (cygwin_logon_user): Securely erase password copy.
	(lsaprivkeyauth): Avoid trying to dereference data if no key is stored
	in the registry (CID 60122).  Securely erase passwords after usage.
@
text
@a170 1
  RtlSecureZeroMemory (passwd, NT_MAX_PATH);
d1221 1
a1221 1
  PUNICODE_STRING data = NULL;
a1222 1
  BOOL ret;
d1240 11
a1250 1
	data = NULL;
d1252 9
a1260 2
  /* No Cygwin key, try Interix key. */
  if (!data && *domain)
d1262 2
a1263 6
      __small_swprintf (key_name, L"%W_%W%W",
			domain, user, SFU_LSA_KEY_SUFFIX);
      RtlInitUnicodeString (&key, key_name);
      status = LsaRetrievePrivateData (lsa, &key, &data);
      if (!NT_SUCCESS (status))
	data = NULL;
d1265 2
a1266 26
  /* Found an entry?  Try to logon. */
  if (data)
    {
      /* The key is not 0-terminated. */
      PWCHAR passwd;
      size_t pwdsize = data->Length + sizeof (WCHAR);

      passwd = (PWCHAR) alloca (pwdsize);
      *wcpncpy (passwd, data->Buffer, data->Length / sizeof (WCHAR)) = L'\0';
      /* Weird:  LsaFreeMemory invalidates the content of the UNICODE_STRING
	 structure, but it does not invalidate the Buffer content. */
      RtlSecureZeroMemory (data->Buffer, data->Length);
      LsaFreeMemory (data);
      debug_printf ("Try logon for %W\\%W", domain, user);
      ret = LogonUserW (user, domain, passwd, LOGON32_LOGON_INTERACTIVE,
			LOGON32_PROVIDER_DEFAULT, &token);
      RtlSecureZeroMemory (passwd, pwdsize);
      if (!ret)
	{
	  __seterrno ();
	  token = NULL;
	}
      else
	token = get_full_privileged_inheritable_token (token);
    }
  lsa_close_policy (lsa);
d1269 1
@


1.48
log
@	* sec_auth.cc (get_user_groups): Don't handle ERROR_ACCESS_DENIED as
	error.  Explain why.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d194 1
a194 1
open_local_policy (ACCESS_MASK access)
d196 4
a199 2
  LSA_OBJECT_ATTRIBUTES oa = { 0, 0, 0, 0, 0, 0 };
  HANDLE lsa = INVALID_HANDLE_VALUE;
d201 6
a206 1
  NTSTATUS status = LsaOpenPolicy (NULL, &oa, access, &lsa);
d210 1
a210 3
      /* Some versions of Windows set the lsa handle to NULL when
	 LsaOpenPolicy fails. */
      lsa = INVALID_HANDLE_VALUE;
d215 2
a216 2
static void
close_local_policy (LSA_HANDLE &lsa)
d218 1
a218 1
  if (lsa != INVALID_HANDLE_VALUE)
a219 1
  lsa = INVALID_HANDLE_VALUE;
d843 1
a843 1
  if ((lsa = open_local_policy (POLICY_EXECUTE)) == INVALID_HANDLE_VALUE)
d961 1
a961 1
  close_local_policy (lsa);
d1028 1
a1028 1
  if ((lsa = open_local_policy (POLICY_EXECUTE)) == INVALID_HANDLE_VALUE)
d1199 1
a1199 1
  close_local_policy (lsa);
d1227 1
a1227 2
  if ((lsa = open_local_policy (POLICY_GET_PRIVATE_INFORMATION))
      == INVALID_HANDLE_VALUE)
d1269 1
a1269 1
  close_local_policy (lsa);
@


1.47
log
@	* Merge in cygwin-64bit-branch.
@
text
@d262 8
a269 2
      /* It's no error when the user name can't be found. */
      return ret == NERR_UserNotFound;
@


1.46
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d90 1
a90 1
  debug_printf ("set_imp_token (%d, %d)", token, type);
d111 1
a111 1
  debug_printf ("pw_gecos %x (%s)", pw->pw_gecos, pw->pw_gecos);
d286 1
a286 1
	debug_printf ("Global group %W invalid. Use: %d", dgroup, use);
d335 1
a335 1
	    debug_printf ("Rejecting local %W. use: %d", dg_ptr, use);
d363 1
a363 1
		    debug_printf ("Rejecting local %W. use: %d", dg_ptr, use);
d392 1
a392 1
  struct __group32 *gr;
d397 1
a397 1
      if (gr->gr_gid == (__gid32_t) pw->pw_gid)
d692 1
a692 1
	debug_printf ("NtQueryInformationToken(), %p", status);
d701 1
a701 1
    debug_printf ("NtQueryInformationToken(), %p", status);
d716 1
a716 1
	debug_printf ("NtQuerySecurityObject(), %p", status);
d723 1
a723 1
	    debug_printf ("RtlGetGroupSecurityDescriptor(), %p", status);
d734 1
a734 1
      debug_printf ("NtQueryInformationToken(token, TokenGroups), %p", status);
d741 1
a741 1
      debug_printf ("NtQueryInformationToken(my_token, TokenGroups), %p",
d751 1
a751 1
      struct __group32 *gr;
d854 1
a854 1
			  "TokenStatistics), %p", status);
d864 1
a864 1
	debug_printf ("NtQueryInformationToken(hProcToken, TokenGroups), %p",
d875 1
a875 1
			    "%p", status);
d998 1
a998 1
      debug_printf ("LsaRegisterLogonProcess: %p", status);
d1012 1
a1012 1
      debug_printf ("LsaLookupAuthenticationPackage: %p", status);
a1035 5
  /* The logon SID entry is not generated automatically on Windows 2000
     and earlier for some reason.  So add fake logon sid here, which is
     filled with logon id values in the authentication package. */
  if (wincap.needs_logon_sid_in_sid_list ())
    tmp_gsids += fake_logon_sid;
a1128 4
      /* Mark logon SID as logon SID :) */
      if (wincap.needs_logon_sid_in_sid_list ()
	  && tmp_gsids.sids[tmpidx] == fake_logon_sid)
	gsids->Groups[i].Attributes += SE_GROUP_LOGON_ID;
d1165 1
a1165 1
      debug_printf ("LsaLogonUser: %p (sub-status %p)", status, sub_status);
@


1.45
log
@        * dcrt0.cc (quoted): Renamed strechr to strchrnul.
        * environ.cc (environ_init): Likewise.
        * sec_acl.cc (aclfromtext32): Likewise.
        * sec_auth.cc (extract_nt_dom_user): Likewise.
        * uinfo.cc (pwdgrp::next_str): Likewise.
        * string.h (strechr): Likewise.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.44
log
@	Throughout use wincap.allocation_granularity instead of getpagesize.
	Throughout use wincap.page_size instead of getsystempagesize.
	Throughout use "status" as variable name to hold NTSTATUS values.
	* fhandler_mem.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	Fix debug_printf output.  Rectify long statements.  Fix comment
	formatting.
	* fhandler_proc.cc: Ditto.
	(format_proc_swaps): Drop useless test for ERROR_PROC_NOT_FOUND.
	* fhandler_process.cc: Ditto as in fhandler_mem.cc.
	(get_process_state): Rearrange allocation loop.  Use malloc/realloc.
	(get_mem_values): Fix potential NULL pointer usage.  Drop unused
	variable.
	* pinfo.cc (winpids::enum_processes): Handle low memory gracefully.
	* sec_auth.cc (get_priv_list): Drop local variable ret.
	* shared.cc (memory_init): Drop outdated call to getpagesize.
	* syscalls.cc (getsystempagesize): Remove.
	* sysconf.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	(sysinfo): Constify sizeof_stodi.  Drop useless test for
	ERROR_PROC_NOT_FOUND.
	* thread.cc (pthread_getattr_np): Cast pointers to uintptr_t rather
	than to int for pointer arithmetic.
	* winsup.h (getsystempagesize): Drop declaration.
@
text
@d123 2
a124 2
      c = strechr (d + 2, ',');
      if ((u = strechr (d + 2, '\\')) >= c)
@


1.44.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d392 1
a392 1
  struct group *gr;
d397 1
a397 1
      if (gr->gr_gid == pw->pw_gid)
d751 1
a751 1
      struct group *gr;
@


1.44.2.2
log
@        * dcrt0.cc (quoted): Renamed strechr to strchrnul.
        * environ.cc (environ_init): Likewise.
        * sec_acl.cc (aclfromtext32): Likewise.
        * sec_auth.cc (extract_nt_dom_user): Likewise.
        * uinfo.cc (pwdgrp::next_str): Likewise.
        * string.h (strechr): Likewise.
@
text
@d123 2
a124 2
      c = strchrnul (d + 2, ',');
      if ((u = strchrnul (d + 2, '\\')) >= c)
@


1.44.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d90 1
a90 1
  debug_printf ("set_imp_token (%p, %d)", token, type);
d111 1
a111 1
  debug_printf ("pw_gecos %p (%s)", pw->pw_gecos, pw->pw_gecos);
d286 1
a286 1
	debug_printf ("Global group %W invalid. Use: %u", dgroup, use);
d335 1
a335 1
	    debug_printf ("Rejecting local %W. use: %u", dg_ptr, use);
d363 1
a363 1
		    debug_printf ("Rejecting local %W. use: %u", dg_ptr, use);
d692 1
a692 1
	debug_printf ("NtQueryInformationToken(), %y", status);
d701 1
a701 1
    debug_printf ("NtQueryInformationToken(), %y", status);
d716 1
a716 1
	debug_printf ("NtQuerySecurityObject(), %y", status);
d723 1
a723 1
	    debug_printf ("RtlGetGroupSecurityDescriptor(), %y", status);
d734 1
a734 1
      debug_printf ("NtQueryInformationToken(token, TokenGroups), %y", status);
d741 1
a741 1
      debug_printf ("NtQueryInformationToken(my_token, TokenGroups), %y",
d854 1
a854 1
			  "TokenStatistics), %y", status);
d864 1
a864 1
	debug_printf ("NtQueryInformationToken(hProcToken, TokenGroups), %y",
d875 1
a875 1
			    "%y", status);
d998 1
a998 1
      debug_printf ("LsaRegisterLogonProcess: %y", status);
d1012 1
a1012 1
      debug_printf ("LsaLookupAuthenticationPackage: %y", status);
d1174 1
a1174 1
      debug_printf ("LsaLogonUser: %y (sub-status %y)", status, sub_status);
@


1.44.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.44.2.5
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1036 5
d1134 4
@


1.43
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@a594 1
  NTSTATUS ret;
d610 2
a611 2
	  if ((ret = LsaEnumerateAccountRights (lsa, usersid, &privstrs,
						&cnt)) != STATUS_SUCCESS)
d614 2
a615 3
      else if ((ret = LsaEnumerateAccountRights (lsa, grp_list.sids[grp],
						 &privstrs, &cnt))
	       != STATUS_SUCCESS)
@


1.42
log
@	* sec_auth.cc (get_token_group_sidlist): Add CONSOLE LOGON SID on
	systems supporting it.  Never add SERVICE SID but keep code in for
	future reference.  Explain why.
	(get_priv_list): Add cygpsid pointer parameter.  Point it to the
	mandatory integrity SID which matches account and privileges.
	(create_token): Fetch mandatory integrity SID from call to
	get_priv_list.
	(lsaauth): Call get_priv_list with additional NULL pointer.  Change
	comment accordingly.
	* sec_helper.cc (well_known_console_logon_sid): New static SID.
	(cygpriv): Change to structure containing extra flag to store info
	about required integrity level.
	(privilege_luid): Accommodate changes to cygpriv.  Return integrity
	level in new high_integrity parameter.
	(privilege_name): Accommodate changes to cygpriv.
	(set_privilege): Drop trailing \n from debug output.
	(set_cygwin_privileges): Don't set SE_CREATE_GLOBAL_PRIVILEGE anymore
	since it's just not needed, but keep code in for future reference.
	Change comment accordingly.
	* security.h (well_known_console_logon_sid): Declare.
	(privilege_luid): Align declaration to above change.
	* wincap.h (wincaps::has_console_logon_sid): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d172 1
a172 1
  debug_printf ("%d = logon_user(%s,...)", hToken, pw->pw_name);
@


1.41
log
@whitespace elimination
@
text
@d419 2
d428 6
d436 1
d590 1
a590 1
	       size_t &size)
d598 8
a605 1
    return get_system_priv_list (size);
d624 1
d626 1
a626 1
	  if (!privilege_luid (privstrs[i].Buffer, &priv))
d657 2
d827 1
d911 8
a918 1
  /* On systems supporting Mandatory Integrity Control, add a MIC SID. */
d923 2
a924 9
      if (usersid == well_known_system_sid)
	new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
	  = mandatory_system_integrity_sid;
      else if (tmp_gsids.contains (well_known_admins_sid))
	new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
	  = mandatory_high_integrity_sid;
      else
	new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid
	  = mandatory_medium_integrity_sid;
a926 4
  /* Retrieve list of privileges of that user. */
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize)))
    goto out;

d1054 3
a1056 2
  /* Retrieve list of privileges of that user. */
  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize)))
@


1.40
log
@	* advapi32.cc: Add comment.
	(EqualSid): Remove.
	(CopySid): Remove.
	(AddAccessAllowedAce): Remove.
	(AddAccessDeniedAce): Remove.
	(MakeSelfRelativeSD): Remove.
	* flock.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
	* security.h: Ditto.
	(RtlEqualSid): Declare.  Explain why.
	(RtlCopySid): Ditto.
@
text
@d204 1
a204 1
         LsaOpenPolicy fails. */
d343 1
a343 1
	         localized. */
d555 1
a555 1
  	 && sys_privs[max_idx] != wincap.max_sys_priv ())
@


1.39
log
@	* advapi32.cc (GetTokenInformation): Remove.
	(SetTokenInformation): Remove.
	* grp.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_auth.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d1050 2
a1051 1
  if (!AddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL, usersid))
d1053 2
a1054 2
  if (!AddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,
			    well_known_admins_sid))
d1056 2
a1057 2
  if (!AddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,
			    well_known_system_sid))
d1100 2
a1101 2
  CopySid (RtlLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),
	   usersid);
d1123 3
a1125 3
      CopySid (RtlLengthSid (tmp_gsids.sids[tmpidx]),
	       (PSID) ((PBYTE) &authinf->inf + sids_offset),
	       tmp_gsids.sids[tmpidx]);
d1131 2
a1132 2
  CopySid (RtlLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),
	   pgrpsid);
@


1.38
log
@	* advapi32.cc (GetSecurityDescriptorDacl): Remove.
	(GetSecurityDescriptorGroup): Remove.
	(GetSecurityDescriptorOwner): Remove.
	* sec_acl.cc: Replace above functions throughout with their ntdll.dll
	equivalent.  Remove redundant debug output.
	* sec_auth.cc: Ditto.
	* security.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d35 1
a35 1
   be fetched with GetTokenInformation.  This function returns the original
d45 1
a45 1
      DWORD size;
d53 3
a55 2
      if (GetTokenInformation (token, TokenLinkedToken,
			       (PVOID) &linked, sizeof linked, &size))
d65 3
a67 2
	      if (GetTokenInformation (linked.LinkedToken, TokenType,
				       (PVOID) &type, sizeof type, &size)
d665 2
a666 1
  DWORD size;
d672 4
a675 3
      if (!GetTokenInformation (token, TokenSource,
				&ts, sizeof ts, &size))
	debug_printf ("GetTokenInformation(), %E");
d681 4
a684 3
  if (!GetTokenInformation (token, TokenUser,
			    &tok_usersid, sizeof tok_usersid, &size))
    debug_printf ("GetTokenInformation(), %E");
a712 1
  bool sawpg = false, ret = false;
d714 18
a731 8
  if (!GetTokenInformation (token, TokenGroups, NULL, 0, &size) &&
      GetLastError () != ERROR_INSUFFICIENT_BUFFER)
    debug_printf ("GetTokenInformation(token, TokenGroups), %E");
  else if (!(my_grps = (PTOKEN_GROUPS) alloca (size)))
    debug_printf ("alloca (my_grps) failed.");
  else if (!GetTokenInformation (token, TokenGroups, my_grps, size, &size))
    debug_printf ("GetTokenInformation(my_token, TokenGroups), %E");
  else
d733 14
a746 16
      if (groups.issetgroups ()) /* setgroups was called */
	{
	  cygsid gsid;
	  struct __group32 *gr;
	  bool saw[groups.sgsids.count ()];
	  memset (saw, 0, sizeof(saw));

	  /* token groups found in /etc/group match the user.gsids ? */
	  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	    if (gsid.getfromgr (gr) && sid_in_token_groups (my_grps, gsid))
	      {
		int pos = groups.sgsids.position (gsid);
		if (pos >= 0)
		  saw[pos] = true;
		else if (groups.pgsid == gsid)
		  sawpg = true;
d748 12
a759 12
		/* With this `else', verify_token returns false if we find
		   groups in the token, which are not in the group list set
		   with setgroups().  That's rather dangerous.  What we're
		   really interested in is that all groups in the setgroups()
		   list are in the token.  A token created through ADVAPI
		   should be allowed to contain more groups than requested
		   through setgroups(), esecially since Vista and the
		   addition of integrity groups. So we disable this statement
		   for now. */
		else if (gsid != well_known_world_sid
			 && gsid != usersid)
		  goto done;
d761 15
a775 17
	      }
	  /* user.sgsids groups must be in the token, except for builtin groups.
	     These can be different on domain member machines compared to
	     domain controllers, so these builtin groups may be validly missing
	     from a token created through password or lsaauth logon. */
	  for (int gidx = 0; gidx < groups.sgsids.count (); gidx++)
	    if (!saw[gidx]
	    	&& !groups.sgsids.sids[gidx].is_well_known_sid ()
		&& !sid_in_token_groups (my_grps, groups.sgsids.sids[gidx]))
	      return false;
	}
      /* The primary group must be in the token */
      ret = sawpg
	|| sid_in_token_groups (my_grps, groups.pgsid)
	|| groups.pgsid == usersid;
    }
  return ret;
d808 1
a808 1
  DWORD size;
a829 4
      else if (!GetTokenInformation (hProcToken, TokenStatistics,
				     &stats, sizeof stats, &size))
	debug_printf
	  ("GetTokenInformation(hProcToken, TokenStatistics), %E");
d831 9
a839 1
	auth_luid = stats.AuthenticationId;
d843 5
a847 3
      if (!GetTokenInformation (hProcToken, TokenGroups, NULL, 0, &size)
	  && GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	debug_printf ("GetTokenInformation(hProcToken, TokenGroups), %E");
d850 1
a850 2
      else if (!GetTokenInformation (hProcToken, TokenGroups, my_tok_gsids,
				     size, &size))
d852 9
a860 3
	  debug_printf ("GetTokenInformation(hProcToken, TokenGroups), %E");
	  free (my_tok_gsids);
	  my_tok_gsids = NULL;
@


1.37
log
@	* advapi32.cc (InitializeAcl): Remove.
	(AddAce): Remove.
	(FindFirstFreeAce): Remove.
	(GetAce): Remove.
	(InitializeSecurityDescriptor): Remove.
	(OpenProcessToken): Remove.
	* dcrt0.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* fhandler_tty.cc: Ditto.
	* flock.cc: Ditto.
	* pinfo.cc: Ditto.  Drop unnecessary error handling.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d695 8
a702 3
      else if (!GetSecurityDescriptorGroup (sd_buf, (PSID *) &gsid,
					    (BOOL *) &size))
	debug_printf ("GetSecurityDescriptorGroup(), %E");
@


1.36
log
@	* advapi32.cc (InitializeSid): Remove.
	(EqualPrefixSid): Remove.
	(GetLengthSid): Remove.
	(GetSidSubAuthority): Remove.
	(GetSidSubAuthorityCount): Remove.
	(GetSidIdentifierAuthority): Remove.
	* fhandler_disk_file.cc: Remove above functions throughout with their
	ntdll.dll equivalent.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d1022 1
a1022 1
  if (!InitializeAcl (dacl, dsize, ACL_REVISION))
@


1.35
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d1010 1
a1010 1
      gsize += GetLengthSid (tmp_gsids.sids[tmpidx]);
d1018 3
a1020 3
	  + GetLengthSid (usersid)
	  + GetLengthSid (well_known_admins_sid)
	  + GetLengthSid (well_known_system_sid);
d1035 1
a1035 1
  authinf_size += GetLengthSid (usersid);	    /* User SID */
d1046 1
a1046 1
  authinf_size += GetLengthSid (pgrpsid);	    /* Primary Group SID */
d1073 1
a1073 1
  CopySid (GetLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),
d1075 1
a1075 1
  offset += GetLengthSid (usersid);
d1096 1
a1096 1
      CopySid (GetLengthSid (tmp_gsids.sids[tmpidx]),
d1099 1
a1099 1
      sids_offset += GetLengthSid (tmp_gsids.sids[tmpidx]);
d1104 1
a1104 1
  CopySid (GetLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),
d1106 1
a1106 1
  offset += GetLengthSid (pgrpsid);
@


1.34
log
@	* sec_auth.cc (get_user_groups): Mark well-known groups as well-known.
	(get_user_local_groups): Ditto.
	(verify_token): Drop useless label.
	* sec_helper.cc (cygsid::get_sid): Check for well-known SID if
	well_known isn't set.
	* security.h (well_known_sid_type): New inline function.
@
text
@d219 1
a219 1
  DWORD dret;
a220 1
  WCHAR *buf;
d232 3
a234 3
  dret = DsGetDcNameW (NULL, domain, NULL, NULL,
		       rediscovery ? DS_FORCE_REDISCOVERY : 0, &pci);
  if (dret == ERROR_SUCCESS)
d241 1
a241 16
  else if (dret == ERROR_PROC_NOT_FOUND)
    {
      /* NT4 w/o DSClient */
      if (rediscovery)
	dret = NetGetAnyDCName (NULL, domain, (LPBYTE *) &buf);
      else
	dret = NetGetDCName (NULL, domain, (LPBYTE *) &buf);
      if (dret == NERR_Success)
	{
	  wcscpy (server, buf);
	  NetApiBufferFree (buf);
	  debug_printf ("NT: rediscovery: %d, server: %W", rediscovery, server);
	  return true;
	}
    }
  __seterrno_from_win_error (dret);
d959 1
a959 2
      __seterrno_from_nt_status (status == ERROR_PROC_NOT_FOUND
				 ? STATUS_PROCEDURE_NOT_FOUND : status);
@


1.33
log
@	* fhandler_random.cc (fhandler_dev_random::crypt_gen_random):
	Use CryptAcquireContextW.
	* ntdll.h (STATUS_PROCEDURE_NOT_FOUND): Define.
	* sec_auth.cc (open_local_policy): Rename NTSTATUS variable ret to
	status.  Drop usage of LsaNtStatusToWinError.
	(verify_token): Call NtQuerySecurityObject instead of
	GetKernelObjectSecurity.
	(create_token): Rename NTSTATUS variable ret to status.  Rename ret2 to
	sub_status.  Drop usage of LsaNtStatusToWinError.  In case LsaLogonUser
	fails, report the sub_status as well.
@
text
@d295 2
d344 5
a348 1
	  if (!legal_sid_type (use))
a349 2
	  else
	    grp_list += gsid;
d769 1
a769 1
	      goto done;
a775 1
done:
@


1.32
log
@	* autoload.cc: Make autoloaded ntdll function non-optional.  Ditto for
	secur32 functions, except for LsaRegisterLogonProcess.  Change return
	value to ERROR_PROC_NOT_FOUND.  Explain why.
	* sec_auth.cc (lsaauth): Handle ERROR_PROC_NOT_FOUND from call to
	LsaRegisterLogonProcess when generating the errno value.
@
text
@d197 2
a198 2
  NTSTATUS ret = LsaOpenPolicy (NULL, &oa, access, &lsa);
  if (ret != STATUS_SUCCESS)
d200 1
a200 1
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
d702 5
a706 3
      if (!GetKernelObjectSecurity (token, GROUP_SECURITY_INFORMATION,
				    sd_buf, sd_buf_siz, &size))
	debug_printf ("GetKernelObjectSecurity(), %E");
d779 1
a779 1
  NTSTATUS ret;
d899 5
a903 5
  ret = NtCreateToken (&token, TOKEN_ALL_ACCESS, &oa, TokenImpersonation,
		       &auth_luid, &exp, &user, new_tok_gsids, privs, &owner,
		       &pgrp, &dacl, &source);
  if (ret)
    __seterrno_from_nt_status (ret);
d938 1
a938 1
  NTSTATUS ret, ret2;
d968 2
a969 2
  ret = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);
  if (ret != STATUS_SUCCESS)
d971 3
a973 3
      debug_printf ("LsaRegisterLogonProcess: %p", ret);
      __seterrno_from_win_error (ret == ERROR_PROC_NOT_FOUND
				 ? ret : LsaNtStatusToWinError (ret));
d983 2
a984 2
  ret = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);
  if (ret != STATUS_SUCCESS)
d986 2
a987 2
      debug_printf ("LsaLookupAuthenticationPackage: %p", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
d1140 5
a1144 4
  ret = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Interactive, package_id,
		      authinf, authinf_size, NULL, &ts, &profile, &size, &luid,
		      &user_token, &quota, &ret2);
  if (ret != STATUS_SUCCESS)
d1146 2
a1147 2
      debug_printf ("LsaLogonUser: %p", ret);
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
@


1.31
log
@	* sec_auth.cc (get_full_privileged_inheritable_token): Fix dumb typo
	when checking linked token for being a primary token.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d970 2
a971 1
      __seterrno_from_win_error (LsaNtStatusToWinError (ret));
@


1.30
log
@	* sec_auth.cc (get_user_local_groups): Retrieve name of well known
	builtin group from system.  Explain why.
	* sec_helper.cc (well_known_builtin_sid): New SID for BUILTIN group.
	* security.h (well_known_builtin_sid): Declare.
@
text
@d64 2
a65 2
	      if (GetTokenInformation (token, TokenType, (PVOID) &type,
				       sizeof type, &size)
@


1.29
log
@	* sec_auth.cc (get_full_privileged_inheritable_token): New function
	to fetch token with full privileges from logon token in Vista and
	later, and to make token inheritable.  Add lengthy comments to explain
	the function's job.
	(cygwin_logon_user): Drop calling SetHandleInformation.  Enable TCB
	privilege and call get_full_privileged_inheritable_token.
	(lsaauth): Don't fetch linked token and don't make handle inheritable
	here, just call get_full_privileged_inheritable_token instead.
	(lsaprivkeyauth): Ditto.
@
text
@d323 2
a324 2
  WCHAR builtin_grp[sizeof ("BUILTIN\\") + GNLEN + 2];
  PWCHAR dg_ptr, bg_ptr;
a328 1
  bg_ptr = wcpcpy (builtin_grp, L"BUILTIN\\");
d335 1
a335 1
      DWORD domlen = sizeof (dom);
d350 1
a350 3
	  wcscpy (bg_ptr, dg_ptr);
	  if (LookupAccountNameW (NULL, builtin_grp, gsid, &glen,
				  dom, &domlen, &use))
d352 6
a357 2
	      if (!legal_sid_type (use))
		debug_printf ("Rejecting local %W. use: %d", dg_ptr, use);
d359 20
a378 1
		grp_list *= gsid;
a379 2
	  else
	    debug_printf ("LookupAccountName(%W), %E", builtin_grp);
@


1.28
log
@	* sec_auth.cc (lsaauth): Use CYG_LSA_MAGIC as checksum start value to
	decouple from Cygwin release.
@
text
@d33 52
d159 1
a159 3
  else if (!SetHandleInformation (hToken,
				  HANDLE_FLAG_INHERIT,
				  HANDLE_FLAG_INHERIT))
d161 7
a167 3
      __seterrno ();
      CloseHandle (hToken);
      hToken = INVALID_HANDLE_VALUE;
d1143 1
a1143 21

  if (wincap.has_mandatory_integrity_control ())
    {
      TOKEN_LINKED_TOKEN linked;

      if (GetTokenInformation (user_token, TokenLinkedToken,
			       (PVOID) &linked, sizeof linked, &size))
	{
	  debug_printf ("Linked Token: %p", linked.LinkedToken);
	  if (linked.LinkedToken)
	    {
	      CloseHandle (user_token);
	      user_token = linked.LinkedToken;
	    }
	}
    }

  /* The token returned by LsaLogonUser is not inheritable.  Make it so. */
  if (!SetHandleInformation (user_token, HANDLE_FLAG_INHERIT,
			     HANDLE_FLAG_INHERIT))
    system_printf ("SetHandleInformation %E");
d1216 1
a1216 25
    {
      if (wincap.has_mandatory_integrity_control ())
	{
	  TOKEN_LINKED_TOKEN linked;
	  DWORD size;

	  if (GetTokenInformation (token, TokenLinkedToken,
				   (PVOID) &linked, sizeof linked, &size))
	    {
	      debug_printf ("Linked Token: %p", linked.LinkedToken);
	      if (linked.LinkedToken)
		{
		  CloseHandle (token);
		  token = linked.LinkedToken;
		}
	    }
	}
      if (!SetHandleInformation (token, HANDLE_FLAG_INHERIT,
				 HANDLE_FLAG_INHERIT))
	{
	  __seterrno ();
	  CloseHandle (token);
	  token = NULL;
	}
    }
@


1.27
log
@	* sec_auth.cc (get_token_group_sidlist): Add BUILTIN\Users account
	to all created tokens.
	* sec_helper.cc (well_known_users_sid): Define as BUILTIN\Users.
	* security.h (well_known_users_sid): Declare.
@
text
@d1056 1
a1056 2
  authinf->checksum = CYGWIN_VERSION_MAGIC (CYGWIN_VERSION_DLL_MAJOR,
					    CYGWIN_VERSION_DLL_MINOR);
@


1.26
log
@	* include/sys/cygwin.h: Add new cygwin_getinfo_type
	CW_SET_EXTERNAL_TOKEN.
	Add new enum CW_TOKEN_IMPERSONATION, CW_TOKEN_RESTRICTED.
	* cygheap.h (cyguser): New flags ext_token_is_restricted,
	curr_token_is_restricted and setuid_to_restricted.
	* external.cc (cygwin_internal): Add CW_SET_EXTERNAL_TOKEN.
	* sec_auth.cc (set_imp_token): New function.
	(cygwin_set_impersonation_token): Call set_imp_token ().
	* security.h (set_imp_token): New prototype.
	* spawn.cc (spawn_guts): Use CreateProcessAsUserW if restricted token
	was enabled by setuid().  Do not create new window station in this case.
	* syscalls.cc (seteuid32): Add handling of restricted external tokens.
	Set HANDLE_FLAG_INHERIT for primary token.
	(setuid32): Set setuid_to_restricted flag.
	* uinfo.cc (uinfo_init): Do not reimpersonate if restricted token was
	enabled by setuid ().  Initialize user.*_restricted flags.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
d368 1
d374 1
@


1.25
log
@	* sec_auth.cc (lsaauth): Close unused handle.
	(lsaprivkeyauth): Ditto.
@
text
@d33 9
d45 1
a45 2
  debug_printf ("set_impersonation_token (%d)", hToken);
  cygheap->user.external_token = hToken == INVALID_HANDLE_VALUE ? NO_IMPERSONATION : hToken;
@


1.24
log
@	* sec_auth.cc (get_server_groups): Ignore errors from
	get_user_local_groups.
@
text
@d1090 4
a1093 1
	    user_token = linked.LinkedToken;
d1184 4
a1187 1
		token = linked.LinkedToken;
@


1.23
log
@	* sec_auth.cc (str2uni_cat): Move from here...
	* path.cc (str2uni_cat): ...to here.  Simplify.  Make static inline.
	(get_nt_native_path): Use RtlAppendUnicodeToString rather than
	str2uni_cat for constant strings for speed.
	* security.h (str2uni_cat): Drop declaration.
@
text
@d407 3
a409 6
  if (get_user_local_groups (server, domain, grp_list, user))
    {
      get_unix_group_sidlist (pw, grp_list);
      return true;
    }
  return false;
@


1.22
log
@	* sec_auth.cc (str2buf2uni): Remove.
	* security.h (str2buf2uni): Remove declaration.
@
text
@a128 12
void
str2uni_cat (UNICODE_STRING &tgt, const char *srcstr)
{
  int len = sys_mbstowcs (tgt.Buffer + tgt.Length / sizeof (WCHAR),
			  (tgt.MaximumLength - tgt.Length) / sizeof (WCHAR),
			  srcstr);
  if (len)
    tgt.Length += (len - 1) * sizeof (WCHAR);
  else
    tgt.Length = tgt.MaximumLength = 0;
}

@


1.21
log
@	* sec_auth.cc (lsaauth): Remove local definitions of struct
	_TOKEN_LINKED_TOKEN and TokenLinkedToken in favor of definitions
	from winnt.h.
	(lsaprivkeyauth): As in lsaauth, fetch linked token if available and
	return that in favor of default token.
@
text
@a128 13
/* The dimension of buf is assumed to be at least strlen(srcstr) + 1,
   The result will be shorter if the input has multibyte chars */
void
str2buf2uni (UNICODE_STRING &tgt, WCHAR *buf, const char *srcstr)
{
  tgt.Buffer = (PWCHAR) buf;
  tgt.MaximumLength = (strlen (srcstr) + 1) * sizeof (WCHAR);
  tgt.Length = sys_mbstowcs (buf, tgt.MaximumLength / sizeof (WCHAR), srcstr)
	       * sizeof (WCHAR);
  if (tgt.Length)
    tgt.Length -= sizeof (WCHAR);
}

@


1.20
log
@	* sec_auth.cc (get_user_local_groups): Simplify LookupAccountName code.
@
text
@a1110 6
      typedef struct _TOKEN_LINKED_TOKEN
      {
	HANDLE LinkedToken;
      } TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;
#     define TokenLinkedToken ((TOKEN_INFORMATION_CLASS) 19)

d1197 1
a1197 3
  else if (!SetHandleInformation (token,
				  HANDLE_FLAG_INHERIT,
				  HANDLE_FLAG_INHERIT))
d1199 20
a1218 3
      __seterrno ();
      CloseHandle (token);
      token = NULL;
@


1.19
log
@	* autoload.cc (NetLocalGroupEnum): Remove.
	(NetLocalGroupGetMembers): Remove.
	(NetUserGetLocalGroups): Add.
	* sec_auth.cc (is_group_member): Remove function.
	(get_user_local_groups): Get user as string instead of as SID.
	Call NetUserGetLocalGroups instead of NetLocalGroupEnum.  Drop call
	to is_group_member.
	(get_server_groups): Call get_user_local_groups with user name instead
	of user SID.
@
text
@a299 1
      bool builtin = false;
d303 2
a304 2
      if (!LookupAccountNameW (NULL, domlocal_grp, gsid, &glen,
			       dom, &domlen, &use))
d306 8
a313 2
	  if (GetLastError () != ERROR_NONE_MAPPED)
	    debug_printf ("LookupAccountName(%W), %E", domlocal_grp);
d315 9
a323 2
	  if (!LookupAccountNameW (NULL, builtin_grp, gsid, &glen,
				   dom, &domlen, &use))
a324 1
	  builtin = true;
a325 4
      if (!legal_sid_type (use))
	debug_printf ("Rejecting local %W. use: %d", dg_ptr, use);
      else if (builtin)
	grp_list *= gsid;
d327 1
a327 1
	grp_list += gsid;
@


1.18
log
@	* sec_auth.cc (open_local_policy): Set lsa handle to
	INVALID_HANDLE_VALUE when LsaOpenPolicy fails.  Explain why.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
a268 44
is_group_member (PWCHAR logonserver, PWCHAR group, PSID pusersid,
		 cygsidlist &grp_list)
{
  LPLOCALGROUP_MEMBERS_INFO_1 buf;
  DWORD cnt, tot;
  NET_API_STATUS ret;

  /* Members can be users or global groups */
  ret = NetLocalGroupGetMembers (logonserver, group, 1, (LPBYTE *) &buf,
				 MAX_PREFERRED_LENGTH, &cnt, &tot, NULL);
  if (ret)
    return false;

  bool retval = true;
  for (DWORD bidx = 0; bidx < cnt; ++bidx)
    if (EqualSid (pusersid, buf[bidx].lgrmi1_sid))
      goto done;
    else
      {
	/* The extra test for the group being a global group or a well-known
	   group is necessary, since apparently also aliases (for instance
	   Administrators or Users) can be members of local groups, even
	   though MSDN states otherwise.  The GUI refuses to put aliases into
	   local groups, but the CLI interface allows it.  However, a normal
	   logon token does not contain groups, in which the user is only
	   indirectly a member by being a member of an alias in this group.
	   So we also should not put them into the token group list.
	   Note: Allowing those groups in our group list renders external
	   tokens invalid, so that it becomes impossible to logon with
	   password and valid logon token. */
	for (int glidx = 0; glidx < grp_list.count (); ++glidx)
	  if ((buf[bidx].lgrmi1_sidusage == SidTypeGroup
	       || buf[bidx].lgrmi1_sidusage == SidTypeWellKnownGroup)
	      && EqualSid (grp_list.sids[glidx], buf[bidx].lgrmi1_sid))
	    goto done;
      }

  retval = false;
 done:
  NetApiBufferFree (buf);
  return retval;
}

static bool
d270 1
a270 1
		       cygsidlist &grp_list, PSID pusersid)
d276 3
a278 2
  ret = NetLocalGroupEnum (logonserver, 0, (LPBYTE *) &buf,
			   MAX_PREFERRED_LENGTH, &cnt, &tot, NULL);
d295 27
a321 28
    if (is_group_member (logonserver, buf[i].lgrpi0_name, pusersid, grp_list))
      {
	cygsid gsid;
	DWORD glen = MAX_SID_LEN;
	WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
	DWORD domlen = sizeof (dom);
	bool builtin = false;

	use = SidTypeInvalid;
	wcscpy (dg_ptr, buf[i].lgrpi0_name);
	if (!LookupAccountNameW (NULL, domlocal_grp, gsid, &glen,
				 dom, &domlen, &use))
	  {
	    if (GetLastError () != ERROR_NONE_MAPPED)
	      debug_printf ("LookupAccountName(%W), %E", domlocal_grp);
	    wcscpy (bg_ptr, dg_ptr);
	    if (!LookupAccountNameW (NULL, builtin_grp, gsid, &glen,
				     dom, &domlen, &use))
	      debug_printf ("LookupAccountName(%W), %E", builtin_grp);
	    builtin = true;
	  }
	if (!legal_sid_type (use))
	  debug_printf ("Rejecting local %W. use: %d", dg_ptr, use);
	else if (builtin)
	  grp_list *= gsid;
	else
	  grp_list += gsid;
      }
d425 1
a425 1
  if (get_user_local_groups (server, domain, grp_list, usersid))
@


1.17
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d162 6
a167 1
    __seterrno_from_win_error (LsaNtStatusToWinError (ret));
@


1.16
log
@	* Makefile.in (DLL_OFILES): Add setlsapwd.o.
	* cygserver.h (CYGWIN_SERVER_VERSION_API): Bump.
	(request_code_t): Define CYGSERVER_REQUEST_SETPWD request type.
	* cygserver_msg.h (client_request_msg::retval): Use default value of -1
	for retval if msglen is 0.
	* cygserver_sem.h (client_request_sem::retval): Ditto.
	* cygserver_shm.h (client_request_shm::retval): Ditto.
	* cygserver_setpwd.h: New file.
	* external.cc (cygwin_internal): Implement new CW_SET_PRIV_KEY type.
	* sec_auth.cc (open_local_policy): Make externally available.
	Get ACCESS_MASK as argument.
	(create_token): Accommodate change to open_local_policy.
	(lsaauth): Ditto.
	(lsaprivkeyauth): New function fetching token by retrieving
	password stored in Cygwin or Interix LSA private data area and
	calling LogonUser with it.
	* security.h (lsaprivkeyauth): Declare.
	(open_local_policy): Declare.
	* setlsapwd.cc: New file implementing setting LSA private data password
	using LsaStorePrivateData or by calling cygserver if available.
	* syscalls.cc (seteuid32): Add workaround to get the original token
	when switching back to the original privileged user, even if
	setgroups group list is still active.  Add long comment to explain why.
	Call lsaprivkeyauth first, only if that fails call lsaauth or
	create_token.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_SET_PRIV_KEY.
@
text
@d723 1
a723 1
		   list are in the token.  A token created through ADVAPI 
d1224 2
a1225 1
  PWCHAR passwd = (PWCHAR) alloca (data->Length + sizeof (WCHAR));
@


1.15
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d30 1
d154 2
a155 2
static LSA_HANDLE
open_local_policy ()
d158 1
a158 1
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;
d160 1
a160 1
  NTSTATUS ret = LsaOpenPolicy (NULL, &oa, POLICY_EXECUTE, &lsa);
d789 1
a789 1
  if ((lsa = open_local_policy ()) == INVALID_HANDLE_VALUE)
d967 1
a967 1
  if ((lsa = open_local_policy ()) == INVALID_HANDLE_VALUE)
d1176 72
@


1.14
log
@	* sec_auth.cc (extract_nt_dom_user): Return domain and user name as
	WCHAR.
	(cygwin_logon_user): Accommodate above change.  Convert password to
	WCHAR and call LogonUserW.
	* external.cc (cygwin_internal): Accommodate above change.
	* security.h (extract_nt_dom_user): Change prototype accordingly.
@
text
@d801 8
a808 7
      if (usersid != well_known_system_sid)
	if (!GetTokenInformation (hProcToken, TokenStatistics,
				  &stats, sizeof stats, &size))
	  debug_printf
	    ("GetTokenInformation(hProcToken, TokenStatistics), %E");
	else
	  auth_luid = stats.AuthenticationId;
d1107 4
a1110 2
  PDWORD csp = (PDWORD) &authinf->username;
  PDWORD csp_end = (PDWORD) ((PBYTE) authinf + authinf_size);
@


1.13
log
@	Change length for domain buffers from INTERNET_MAX_HOST_NAME_LENGTH to
	MAX_DOMAIN_NAME_LEN throughout.
	* cyglsa.h (CYG_LSA_MAGIC): New value.
	(cyglsa_t): Define username and domain as WCHAR arrays.
	* errno.cc (errmap): Add mapping for ERROR_NONE_MAPPED.
	* sec_auth.cc: Drop 'w' prefix from WCHAR string variable names where
	appropriate.
	(extract_nt_dom_user): Prefer resolving by SID before resolving by
	domain\name pair.
	(cygwin_logon_user): Don't print cleartext password in debug output.
	Change comment.
	(get_user_groups): Revert calls to LookupAccountNameW to use NULL
	server instead of explicit server name, according to MSDN.
	(get_user_local_groups): Ditto.
	(get_server_groups): Fetch domain and user name from usersid per
	LookupAccountSidW instead of calling extract_nt_dom_user.
	(lsaauth): Fetch domain and user name from usersid per LookupAccountSidW
	instead of calling extract_nt_dom_user.
	* sec_helper.cc (cygpriv): Convert to wchar_t pointer array.
	(privilege_luid): Convert first parameter to  PWCHAR.
	(privilege_name): Return wchar_t pointer.
	(set_privileges): Accommodate debug output.
	* security.h (privilege_luid): Change prototype accordingly.
@
text
@d25 1
d40 1
a40 1
extract_nt_dom_user (const struct passwd *pw, char *domain, char *user)
d51 1
a51 1
      && LookupAccountSid (NULL, psid, user, &ulen, domain, &dlen, &use))
d55 2
a56 2
  domain[0] = '\0';
  strlcpy (user, pw->pw_name, UNLEN + 1);
d64 1
a64 1
       strlcpy (domain, d + 2, u - d - 1);
d66 1
a66 1
       strlcpy (user, u + 1, c - u);
d73 1
a73 1
  if (!pw)
d79 3
a81 2
  char nt_domain[MAX_DOMAIN_NAME_LEN + 1];
  char nt_user[UNLEN + 1];
d83 1
d86 2
a87 1
  debug_printf ("LogonUserA (%s, %s, ...)", nt_user, nt_domain);
d91 2
a92 3
  if (!LogonUserA (nt_user, *nt_domain ? nt_domain : NULL, (char *) password,
		   LOGON32_LOGON_INTERACTIVE,
		   LOGON32_PROVIDER_DEFAULT,
@


1.12
log
@	* cyglsa.h (SECURITY_STRING): Define.
	(enum _SECPKG_NAME_TYPE): Define.
	(struct _SECPKG_CALL_INFO): Define.
	(struct _LSA_SECPKG_FUNCS): Extend to full size.  Define unused
	functions lazily.
	(cygprf_t): Define.
	* sec_auth.cc (lsaauth): Use actual primary group if no admins group.
	Add (disabled) code to fetch token from profil data.
@
text
@d25 2
a26 1
#include "lm.h"
a40 1
  char *d, *u, *c;
d42 5
a46 2
  domain[0] = 0;
  strlcpy (user, pw->pw_name, UNLEN + 1);
d49 7
d61 3
a63 3
	u = d + 1;
      else if (u - d <= INTERNET_MAX_HOST_NAME_LENGTH + 2)
	strlcpy (domain, d + 2, u - d - 1);
d65 1
a65 1
	strlcpy (user, u + 1, c - u);
a66 9
  if (domain[0])
    return;

  cygsid psid;
  DWORD ulen = UNLEN + 1;
  DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  SID_NAME_USE use;
  if (psid.getfrompw (pw))
    LookupAccountSid (NULL, psid, user, &ulen, domain, &dlen, &use);
d78 1
a78 1
  char nt_domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
d83 1
a83 1
  debug_printf ("LogonUserA (%s, %s, %s, ...)", nt_user, nt_domain, password);
d85 2
a86 2
     otherwise it returns with ERROR_ACCESS_DENIED on W2K. Don't ask me why. */
  RevertToSelf ();
d171 1
a171 1
get_logon_server (PWCHAR wdomain, WCHAR *wserver, bool rediscovery)
d176 1
a176 1
  DWORD size = INTERNET_MAX_HOST_NAME_LENGTH + 1;
d179 2
a180 2
  if ((GetComputerNameW (wserver + 2, &size)) &&
      (!wcscasecmp (wdomain, wserver + 2) || !wdomain[0]))
d182 1
a182 1
      wserver[0] = wserver[1] = L'\\';
d187 1
a187 1
  dret = DsGetDcNameW (NULL, wdomain, NULL, NULL,
d191 1
a191 1
      wcscpy (wserver, pci->DomainControllerName);
d193 1
a193 1
      debug_printf ("DC: rediscovery: %d, server: %W", rediscovery, wserver);
d200 1
a200 1
	dret = NetGetAnyDCName (NULL, wdomain, (LPBYTE *) &buf);
d202 1
a202 1
	dret = NetGetDCName (NULL, wdomain, (LPBYTE *) &buf);
d205 1
a205 1
	  wcscpy (wserver, buf);
d207 1
a207 1
	  debug_printf ("NT: rediscovery: %d, server: %W", rediscovery, wserver);
d216 2
a217 2
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list,
		 PWCHAR wuser, PWCHAR wdomain)
d219 1
a219 1
  WCHAR dgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
d225 1
a225 1
  ret = NetUserGetGroups (wlogonserver, wuser, 0, (LPBYTE *) &buf,
d234 2
a235 2
  len = wcslen (wdomain);
  wcscpy (dgroup, wdomain);
d242 2
a243 2
      WCHAR domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      DWORD dlen = sizeof (domain);
d247 2
a248 3
      if (!LookupAccountNameW (wlogonserver, dgroup, gsid, &glen,
			       domain, &dlen, &use))
	debug_printf ("LookupAccountName(%s), %E", dgroup);
d252 1
a252 1
	debug_printf ("Global group %s invalid. Use: %d", dgroup, use);
d260 1
a260 1
is_group_member (PWCHAR wlogonserver, PWCHAR wgroup, PSID pusersid,
d268 1
a268 1
  ret = NetLocalGroupGetMembers (wlogonserver, wgroup, 1, (LPBYTE *) &buf,
d304 1
a304 1
get_user_local_groups (PWCHAR wlogonserver, PWCHAR wdomain,
d311 1
a311 1
  ret = NetLocalGroupEnum (wlogonserver, 0, (LPBYTE *) &buf,
d319 1
a319 1
  WCHAR domlocal_grp[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
d324 1
a324 1
  dg_ptr = wcpcpy (domlocal_grp, wdomain);
d329 1
a329 1
    if (is_group_member (wlogonserver, buf[i].lgrpi0_name, pusersid, grp_list))
d333 1
a333 1
	WCHAR dom[INTERNET_MAX_HOST_NAME_LENGTH + 1];
d339 1
a339 1
	if (!LookupAccountNameW (wlogonserver, domlocal_grp, gsid, &glen,
d345 1
a345 1
	    if (!LookupAccountNameW (wlogonserver, builtin_grp, gsid, &glen,
d434 6
a439 5
  char user[UNLEN + 1];
  WCHAR wuser[UNLEN + 1];
  char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  WCHAR wdomain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  WCHAR wserver[INTERNET_MAX_HOST_NAME_LENGTH + 3];
d450 11
a460 8
  extract_nt_dom_user (pw, domain, user);
  sys_mbstowcs (wdomain, INTERNET_MAX_HOST_NAME_LENGTH + 1, domain);
  sys_mbstowcs (wuser, UNLEN + 1, user);
  if (get_logon_server (wdomain, wserver, false)
      && !get_user_groups (wserver, grp_list, wuser, wdomain)
      && get_logon_server (wdomain, wserver, true))
    get_user_groups (wserver, grp_list, wuser, wdomain);
  if (get_user_local_groups (wserver, wdomain, grp_list, usersid))
a570 1
  char buf[INTERNET_MAX_HOST_NAME_LENGTH + 1];
d593 1
a593 3
	  sys_wcstombs (buf, sizeof (buf),
			privstrs[i].Buffer, privstrs[i].Length / 2);
	  if (!privilege_luid (buf, &priv))
d897 1
a897 1
  debug_printf ("0x%x = create_token ()", primary_token);
d916 3
d1041 6
a1046 1
  extract_nt_dom_user (pw, authinf->domain, authinf->username);
d1147 1
a1147 1
	  debug_printf ("Linked Token: %lu", linked.LinkedToken);
d1166 1
a1166 1
  debug_printf ("0x%x = lsaauth ()", user_token);
@


1.11
log
@	* sec_auth.cc (verify_token): Allow builtin groups missing in a token
	and it's still valid.  Explain why.
@
text
@d1019 7
a1025 4
     we define "Local" as primary group here.  First, this adds the otherwise
     missing "Local" group to the group list and second, seteuid32
     sets the primary group to the group set in /etc/passwd anyway. */
  pgrpsid = well_known_local_sid;
d1110 14
a1123 1
    LsaFreeReturnBuffer (profile);
@


1.10
log
@	* autoload.cc (DsGetDcNameW): Replace DsGetDcNameA.
	* dcrt0.cc (child_info_spawn::handle_spawn): Drop artificial
	supplementary group list from calling setgroups in parent.
	* grp.cc (internal_getgroups): Drop 9x-only code.  Reformat.
	* sec_auth.cc (get_logon_server): Do everything in WCHAR only.
	(get_user_groups): Ditto.  Use wlogonserver in LookupAccountNameW
	calls, too.
	(is_group_member): Get logon server as first argument and use in call
	to NetLocalGroupGetMembers.
	(get_user_local_groups): Get logon server as first argument and use in
	calls to NetLocalGroupEnum and LookupAccountNameW.  Revamp to work
	more correctly in domain environments.
	(get_server_groups): Accommodate aforementioned changed function calls.
	* security.h (get_logon_server): Change prototype accordingly.
	* uinfo.cc (cygheap_user::env_logsrv): Accommodate changed
	get_logon_server call.
@
text
@d728 4
a731 1
	  /* user.sgsids groups must be in the token */
d733 3
a735 1
	    if (!saw[gidx] && !sid_in_token_groups (my_grps, groups.sgsids.sids[gidx]))
@


1.9
log
@	* sec_auth.cc (verify_token): Disable code which returns false if
	the token contains additional groups not requested by setgroups.
	Explain why.
@
text
@d14 1
d170 1
a170 2
get_logon_server (const char *domain, char *server, WCHAR *wserver,
		  bool rediscovery)
d173 1
a173 1
  PDOMAIN_CONTROLLER_INFOA pci;
a175 1
  WCHAR wdomain[size];
d178 2
a179 2
  if ((GetComputerName (server + 2, &size)) &&
      (strcasematch (domain, server + 2) || !domain[0]))
d181 1
a181 3
      server[0] = server[1] = '\\';
      if (wserver)
	sys_mbstowcs (wserver, INTERNET_MAX_HOST_NAME_LENGTH + 1, server);
d186 1
a186 1
  dret = DsGetDcNameA (NULL, domain, NULL, NULL,
d190 1
a190 2
      strcpy (server, pci->DomainControllerName);
      sys_mbstowcs (wserver, INTERNET_MAX_HOST_NAME_LENGTH + 1, server);
d192 1
a192 1
      debug_printf ("DC: rediscovery: %d, server: %s", rediscovery, server);
a197 1
      sys_mbstowcs (wdomain, INTERNET_MAX_HOST_NAME_LENGTH + 1, domain);
d204 1
a204 4
	  sys_wcstombs (server, INTERNET_MAX_HOST_NAME_LENGTH + 1, buf);
	  if (wserver)
	    for (WCHAR *ptr1 = buf; (*wserver++ = *ptr1++);)
	      ;
d206 1
a206 1
	  debug_printf ("NT: rediscovery: %d, server: %s", rediscovery, server);
d215 2
a216 2
get_user_groups (WCHAR *wlogonserver, cygsidlist &grp_list, char *user,
		 char *domain)
d218 1
a218 3
  char dgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
  WCHAR wuser[UNLEN + 1];
  sys_mbstowcs (wuser, UNLEN + 1, user);
d233 3
a235 3
  len = strlen (domain);
  strcpy (dgroup, domain);
  dgroup[len++] = '\\';
d241 1
a241 1
      char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
d245 3
a247 2
      sys_wcstombs (dgroup + len, GNLEN + 1, buf[i].grui0_name);
      if (!LookupAccountName (NULL, dgroup, gsid, &glen, domain, &dlen, &use))
d252 1
a252 2
	debug_printf ("Global group %s invalid. Domain: %s Use: %d",
		      dgroup, domain, use);
d260 2
a261 1
is_group_member (WCHAR *wgroup, PSID pusersid, cygsidlist &grp_list)
d268 1
a268 1
  ret = NetLocalGroupGetMembers (NULL, wgroup, 1, (LPBYTE *) &buf,
d304 2
a305 1
get_user_local_groups (cygsidlist &grp_list, PSID pusersid)
d311 1
a311 1
  ret = NetLocalGroupEnum (NULL, 0, (LPBYTE *) &buf,
d319 3
a321 3
  char bgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
  char lgroup[INTERNET_MAX_HOST_NAME_LENGTH + GNLEN + 2];
  DWORD blen, llen;
d324 3
a326 8
  blen = llen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
  if (!LookupAccountSid (NULL, well_known_admins_sid, lgroup, &llen, bgroup, &blen, &use)
      || !GetComputerNameA (lgroup, &(llen = INTERNET_MAX_HOST_NAME_LENGTH + 1)))
    {
      __seterrno ();
      return false;
    }
  bgroup[blen++] = lgroup[llen++] = '\\';
d329 1
a329 1
    if (is_group_member (buf[i].lgrpi0_name, pusersid, grp_list))
d333 3
a335 2
	char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
	DWORD dlen = sizeof (domain);
d338 3
a340 2
	sys_wcstombs (bgroup + blen, GNLEN + 1, buf[i].lgrpi0_name);
	if (!LookupAccountName (NULL, bgroup, gsid, &glen, domain, &dlen, &use))
d343 6
a348 5
	      debug_printf ("LookupAccountName(%s), %E", bgroup);
	    strcpy (lgroup + llen, bgroup + blen);
	    if (!LookupAccountName (NULL, lgroup, gsid, &glen,
				    domain, &dlen, &use))
	      debug_printf ("LookupAccountName(%s), %E", lgroup);
d351 5
a355 2
	  debug_printf ("Rejecting local %s. use: %d", bgroup + blen, use);
	grp_list *= gsid;
d435 1
d437 1
a438 1
  char server[INTERNET_MAX_HOST_NAME_LENGTH + 3];
d450 7
a456 5
  if (get_logon_server (domain, server, wserver, false)
      && !get_user_groups (wserver, grp_list, user, domain)
      && get_logon_server (domain, server, wserver, true))
    get_user_groups (wserver, grp_list, user, domain);
  if (get_user_local_groups (grp_list, usersid))
@


1.8
log
@	* sec_auth.cc (DsGetDcNameA): Drop declaration.
	(DS_FORCE_REDISCOVERY): Drop definition.
@
text
@d717 10
d730 1
@


1.7
log
@	* sec_auth.cc (lsaauth): Make returned token inheritable.
@
text
@a167 5
/* CV, 2006-07-06: Missing in w32api. */
extern "C" DWORD WINAPI DsGetDcNameA (LPCSTR, LPCSTR, GUID *, LPCSTR, ULONG,
				      PDOMAIN_CONTROLLER_INFOA *);
#define DS_FORCE_REDISCOVERY	1

@


1.6
log
@	* sec_auth.cc (create_token): Add integrity level SID to token on
	systems supporting that.  Remove useless check for dynamically loading
	NtCreateToken function.
	* sec_helper.cc (mandatory_medium_integrity_sid): Define.
	(mandatory_high_integrity_sid): Define.
	(mandatory_system_integrity_sid): Define.
	* sec_helper.h (mandatory_medium_integrity_sid): Declare.
	(mandatory_high_integrity_sid): Declare.
	(mandatory_system_integrity_sid): Declare.
@
text
@d1121 5
@


1.5
log
@Remove unneeded header files from source files throughout.
@
text
@d828 1
a828 1
		  alloca (sizeof (DWORD) + tmp_gsids.count ()
d840 17
a866 5
  else if (GetLastError () == ERROR_PROC_NOT_FOUND)
    {
      __seterrno ();
      debug_printf ("Loading NtCreateToken failed.");
    }
@


1.4
log
@	* Fix copyright dates.
@
text
@a21 1
#include "pinfo.h"
@


1.3
log
@	* dcrt0.cc (initial_env): Only use local buffer "buf" if DEBUGGING is
	enabled.  Replace calls to GetEnvironmentVariable by calls to
	GetEnvironmentVariableA for clarity.  Call GetEnvironmentVariableA
	with NULL buffer.
	(cygbench): Ditto, drop local buffer.
	* environ.cc (getearly): Call GetEnvironmentVariableA.
	(environ_init): Retrieve unicode environment and convert to current
	codepage locally.
	(getwinenveq): Ditto.
	* exceptions.cc (try_to_debug): Accommodate new sys_mbstowcs calling
	convention.
	* fhandler_clipboard.cc (set_clipboard): Call sys_mbstowcs to retrieve
	required buffer length.
	* fork.cc (frok::child): Call GetEnvironmentVariableA.
	* miscfuncs.cc: Accommodate changed arguments in calls to sys_mbstowcs.
	* sec_auth.cc: Ditto.
	* strfuncs.cc (sys_wcstombs_alloc): Fix formatting.
	(sys_mbstowcs): Change arguments to allow specifying a source string
	length.
	(sys_mbstowcs_alloc): Ditto.
	* uinfo.cc (cygheap_user::ontherange): Accommodate changed arguments in
	calls to sys_mbstowcs.
	* winsup.h (sys_mbstowcs): Adjust declaration.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
@


1.2
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d131 1
a131 1
  tgt.Length = sys_mbstowcs (buf, srcstr, tgt.MaximumLength / sizeof (WCHAR))
d140 3
a142 2
  int len = sys_mbstowcs (tgt.Buffer + tgt.Length / sizeof (WCHAR), srcstr,
			  (tgt.MaximumLength - tgt.Length) / sizeof (WCHAR));
d190 1
a190 1
	sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d200 1
a200 1
      sys_mbstowcs (wserver, server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d208 1
a208 1
      sys_mbstowcs (wdomain, domain, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d234 1
a234 1
  sys_mbstowcs (wuser, user, UNLEN + 1);
@


1.1
log
@	* fhandler.cc (fhandler_base::fhaccess): Accommodate interface changes
	of access control functions throughout.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* sec_acl.cc: Drop unnecessary includes.
	(setacl): Take path_conv instead of file name as parameter.
	Accommodate interface changes of access control functions.
	(getacl): Ditto.
	* sec_auth.cc: New file, taking over all authentication related
	functions from security.cc.
	* sec_helper.cc: Drop unnecessary includes.
	* security.cc: Ditto.  Move all authentication related functions to
	sec_auth.cc.
	(ALL_SECURITY_INFORMATION): New define.  Use throughout.
	(set_file_sd): New function, replacing read_sd and the file related
	part of get_nt_object_security.
	(get_reg_sd): Rename from get_reg_security.  Drop type parameter.
	(get_reg_attribute): New function, replacing the registry related part
	of get_nt_object_security.
	(get_file_attribute): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(set_file_attribute): Ditto plus new set_file_sd.  Drop unnecessary
	implementation without uid/gid parameters.
	(check_file_access): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(check_registry_access): Use new get_reg_sd call.
	* security.h: Accommodate above interface changes.
@
text
@d508 7
a514 7
  SE_ASSIGNPRIMARYTOKEN_PRIVILEGE,		
  SE_LOCK_MEMORY_PRIVILEGE,		
  SE_INCREASE_QUOTA_PRIVILEGE,		
  SE_TCB_PRIVILEGE,		
  SE_SECURITY_PRIVILEGE,		
  SE_TAKE_OWNERSHIP_PRIVILEGE,		
  SE_LOAD_DRIVER_PRIVILEGE,		
d516 12
a527 12
  SE_SYSTEMTIME_PRIVILEGE,		
  SE_PROF_SINGLE_PROCESS_PRIVILEGE,		
  SE_INC_BASE_PRIORITY_PRIVILEGE,		
  SE_CREATE_PAGEFILE_PRIVILEGE,		
  SE_CREATE_PERMANENT_PRIVILEGE,		
  SE_BACKUP_PRIVILEGE,		
  SE_RESTORE_PRIVILEGE,		
  SE_SHUTDOWN_PRIVILEGE,		
  SE_DEBUG_PRIVILEGE,		
  SE_AUDIT_PRIVILEGE,		
  SE_SYSTEM_ENVIRONMENT_PRIVILEGE,		
  SE_CHANGE_NOTIFY_PRIVILEGE,		
@

