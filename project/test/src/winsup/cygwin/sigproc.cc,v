head	1.428;
access;
symbols
	cygwin-1_7_35-release:1.428
	cygwin-1_7_34-release:1.428
	cygwin-1_7_33-release:1.420.2.6
	cygwin-1_7_32-release:1.420.2.6
	cygwin-1_7_31-release:1.420.2.6
	cygwin-1_7_30-release:1.420.2.3
	cygwin-1_7_29-release:1.420.2.3
	cygwin-1_7_29-release-branchpoint:1.420.0.2
	cygwin-pre-user-db:1.420
	cygwin-1_7_28-release:1.420
	cygwin-1_7_27-release:1.417
	cygwin-1_7_26-release:1.417
	cygwin-1_7_25-release:1.417
	cygwin-1_7_24-release:1.416
	cygwin-1_7_23-release:1.416
	cygwin-1_7_22-release:1.416
	cygwin-1_7_21-release:1.416
	cygwin-1_7_20-release:1.415
	cygwin-1_7_19-release:1.415
	cygwin-64bit-postmerge:1.413
	cygwin-64bit-premerge-branch:1.412.0.2
	cygwin-64bit-premerge:1.412
	cygwin-1_7_18-release:1.412
	post-ptmalloc3:1.388.2.12
	pre-ptmalloc3:1.388.2.12
	cygwin-1_7_17-release:1.388
	cygwin-64bit-branch:1.388.0.2
	cygwin-1_7_16-release:1.386
	cygwin-1_7_15-release:1.384
	cygwin-1_7_14_2-release:1.381
	cygwin-1_7_14-release:1.381
	cygwin-1_7_12-release:1.381
	cygwin-1_7_11-release:1.377
	cygwin-1_7_10-release:1.375
	signal-rewrite:1.342.0.2
	pre-notty:1.337
	cygwin-1_7_9-release:1.331
	cv-post-1_7_9:1.331.0.2
	cygwin-1_7_8-release:1.331
	cygwin-1_7_7-release:1.327
	cygwin-1_7_5-release:1.325
	cygwin-1_7_4-release:1.325
	cygwin-1_7_3-release:1.325
	cygwin-1_7_2-release:1.324
	fifo_doover3:1.319.0.2
	cygwin-1_7_1-release:1.318
	prefifo:1.315
	cv-branch-2:1.312.0.2
	pre-ripout-set_console_state_for_spawn:1.312
	EOL_registry_mounts:1.310
	preoverlapped:1.303
	drop_9x_support_start:1.303
	cr-0x5f1:1.297.0.2
	cv-branch:1.295.0.2
	pre-ptymaster-archetype:1.295
	cr-0x3b58:1.272.0.4
	cr-0x5ef:1.272.0.2
	after-mmap-privanon-noreserve:1.263
	after-mmap-revamp:1.263
	before-mmap-revamp:1.263
	cgf-more-exit-sync:1.256
	post_wait_sig_exit:1.248
	pre_wait_sig_exit:1.239
	reparent-point:1.201
	noreparent:1.201.0.2
	cr-0x5e6:1.197.0.2
	cr-0x9e:1.175.0.4
	cr-0x9d:1.175.0.2
	cgf-deleteme:1.174.0.2
	pre-sigrewrite:1.163
	corinna-01:1.161
	cr-0x9c:1.154.0.4
	cr-0x9b:1.154.0.2
	cr-0x99:1.151
	Z-emcb-cygwin_daemon:1.148.0.2
	w32api-2_2:1.132
	mingw-runtime-2_4:1.132
	pre-cgf-merge:1.157
	cgf-dev-branch:1.132.0.4
	predaemon:1.111
	cygwin_daemon_merge_HEAD:1.111
	pregp02r1:1.110.0.2
	cygnus_cvs_20020108_pre:1.102
	Z-cygwin_daemon_merge-new_HEAD:1.119
	Z-cygwin_daemon_merge_HEAD:1.119
	cygwin_daemon:1.95.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.428
date	2014.11.28.20.46.13;	author corinna;	state Exp;
branches;
next	1.427;

1.427
date	2014.11.21.21.41.37;	author corinna;	state Exp;
branches;
next	1.426;

1.426
date	2014.07.15.22.11.23;	author cgf;	state Exp;
branches;
next	1.425;

1.425
date	2014.07.15.14.57.30;	author cgf;	state Exp;
branches;
next	1.424;

1.424
date	2014.07.14.18.16.15;	author cgf;	state Exp;
branches;
next	1.423;

1.423
date	2014.03.17.04.41.35;	author cgf;	state Exp;
branches;
next	1.422;

1.422
date	2014.03.09.19.25.38;	author cgf;	state Exp;
branches;
next	1.421;

1.421
date	2014.02.09.18.31.37;	author cgf;	state Exp;
branches;
next	1.420;

1.420
date	2013.12.18.03.58.11;	author cgf;	state Exp;
branches
	1.420.2.1;
next	1.419;

1.419
date	2013.12.18.03.01.39;	author cgf;	state Exp;
branches;
next	1.418;

1.418
date	2013.12.09.20.32.24;	author cgf;	state Exp;
branches;
next	1.417;

1.417
date	2013.08.30.15.44.57;	author cgf;	state Exp;
branches;
next	1.416;

1.416
date	2013.06.07.15.37.11;	author cgf;	state Exp;
branches;
next	1.415;

1.415
date	2013.06.03.09.48.54;	author corinna;	state Exp;
branches;
next	1.414;

1.414
date	2013.05.16.05.36.15;	author cgf;	state Exp;
branches;
next	1.413;

1.413
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.412;

1.412
date	2013.04.09.01.01.19;	author cgf;	state Exp;
branches;
next	1.411;

1.411
date	2013.03.31.12.35.44;	author cgf;	state Exp;
branches;
next	1.410;

1.410
date	2013.03.29.13.18.25;	author cgf;	state Exp;
branches;
next	1.409;

1.409
date	2013.03.29.01.22.14;	author cgf;	state Exp;
branches;
next	1.408;

1.408
date	2013.01.21.04.34.52;	author cgf;	state Exp;
branches;
next	1.407;

1.407
date	2013.01.20.06.34.59;	author cgf;	state Exp;
branches;
next	1.406;

1.406
date	2013.01.19.05.57.06;	author cgf;	state Exp;
branches;
next	1.405;

1.405
date	2013.01.16.23.04.28;	author cgf;	state Exp;
branches;
next	1.404;

1.404
date	2013.01.14.06.03.59;	author cgf;	state Exp;
branches;
next	1.403;

1.403
date	2013.01.04.02.21.03;	author cgf;	state Exp;
branches;
next	1.402;

1.402
date	2013.01.03.05.05.10;	author cgf;	state Exp;
branches;
next	1.401;

1.401
date	2013.01.03.03.33.18;	author cgf;	state Exp;
branches;
next	1.400;

1.400
date	2013.01.02.18.34.06;	author cgf;	state Exp;
branches;
next	1.399;

1.399
date	2012.12.31.19.07.03;	author cgf;	state Exp;
branches;
next	1.398;

1.398
date	2012.12.28.18.06.17;	author cgf;	state Exp;
branches;
next	1.397;

1.397
date	2012.12.22.03.14.37;	author cgf;	state Exp;
branches;
next	1.396;

1.396
date	2012.12.21.21.30.56;	author cgf;	state Exp;
branches;
next	1.395;

1.395
date	2012.12.21.19.32.43;	author cgf;	state Exp;
branches;
next	1.394;

1.394
date	2012.12.21.18.52.00;	author cgf;	state Exp;
branches;
next	1.393;

1.393
date	2012.12.10.22.13.26;	author cgf;	state Exp;
branches;
next	1.392;

1.392
date	2012.12.07.17.37.33;	author cgf;	state Exp;
branches;
next	1.391;

1.391
date	2012.12.05.10.37.17;	author corinna;	state Exp;
branches;
next	1.390;

1.390
date	2012.11.08.18.41.58;	author corinna;	state Exp;
branches;
next	1.389;

1.389
date	2012.11.08.17.27.00;	author cgf;	state Exp;
branches;
next	1.388;

1.388
date	2012.07.30.03.44.40;	author cgf;	state Exp;
branches
	1.388.2.1;
next	1.387;

1.387
date	2012.07.21.22.58.20;	author cgf;	state Exp;
branches;
next	1.386;

1.386
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.385;

1.385
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.384;

1.384
date	2012.05.02.16.39.39;	author cgf;	state Exp;
branches;
next	1.383;

1.383
date	2012.04.30.15.38.45;	author cgf;	state Exp;
branches;
next	1.382;

1.382
date	2012.04.28.19.49.58;	author cgf;	state Exp;
branches;
next	1.381;

1.381
date	2012.03.28.17.28.27;	author cgf;	state Exp;
branches;
next	1.380;

1.380
date	2012.03.21.15.54.50;	author cgf;	state Exp;
branches;
next	1.379;

1.379
date	2012.03.21.05.23.13;	author cgf;	state Exp;
branches;
next	1.378;

1.378
date	2012.03.20.15.07.30;	author cgf;	state Exp;
branches;
next	1.377;

1.377
date	2012.02.12.22.43.33;	author cgf;	state Exp;
branches;
next	1.376;

1.376
date	2012.02.08.19.43.14;	author corinna;	state Exp;
branches;
next	1.375;

1.375
date	2012.01.26.18.14.11;	author cgf;	state Exp;
branches;
next	1.374;

1.374
date	2012.01.26.16.35.34;	author cgf;	state Exp;
branches;
next	1.373;

1.373
date	2012.01.11.19.07.10;	author cgf;	state Exp;
branches;
next	1.372;

1.372
date	2011.12.10.01.33.56;	author cgf;	state Exp;
branches;
next	1.371;

1.371
date	2011.12.09.06.49.10;	author cgf;	state Exp;
branches;
next	1.370;

1.370
date	2011.12.08.06.17.49;	author cgf;	state Exp;
branches;
next	1.369;

1.369
date	2011.12.05.15.59.06;	author cgf;	state Exp;
branches;
next	1.368;

1.368
date	2011.12.04.17.58.24;	author cgf;	state Exp;
branches;
next	1.367;

1.367
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.366;

1.366
date	2011.11.29.17.41.01;	author cgf;	state Exp;
branches;
next	1.365;

1.365
date	2011.11.29.15.34.48;	author cgf;	state Exp;
branches;
next	1.364;

1.364
date	2011.11.26.19.14.21;	author cgf;	state Exp;
branches;
next	1.363;

1.363
date	2011.11.26.02.35.49;	author cgf;	state Exp;
branches;
next	1.362;

1.362
date	2011.11.24.21.36.52;	author cgf;	state Exp;
branches;
next	1.361;

1.361
date	2011.11.24.02.17.54;	author cgf;	state Exp;
branches;
next	1.360;

1.360
date	2011.11.23.21.58.43;	author cgf;	state Exp;
branches;
next	1.359;

1.359
date	2011.11.23.18.56.57;	author cgf;	state Exp;
branches;
next	1.358;

1.358
date	2011.11.21.21.09.33;	author cgf;	state Exp;
branches;
next	1.357;

1.357
date	2011.11.21.19.13.30;	author cgf;	state Exp;
branches;
next	1.356;

1.356
date	2011.11.16.04.09.32;	author cgf;	state Exp;
branches;
next	1.355;

1.355
date	2011.11.14.01.45.42;	author cgf;	state Exp;
branches;
next	1.354;

1.354
date	2011.11.14.01.29.49;	author cgf;	state Exp;
branches;
next	1.353;

1.353
date	2011.11.07.20.05.48;	author cgf;	state Exp;
branches;
next	1.352;

1.352
date	2011.11.05.18.47.39;	author cgf;	state Exp;
branches;
next	1.351;

1.351
date	2011.11.04.17.07.21;	author cgf;	state Exp;
branches;
next	1.350;

1.350
date	2011.11.04.16.52.43;	author cgf;	state Exp;
branches;
next	1.349;

1.349
date	2011.11.03.21.44.05;	author cgf;	state Exp;
branches;
next	1.348;

1.348
date	2011.11.03.18.48.27;	author cgf;	state Exp;
branches;
next	1.347;

1.347
date	2011.10.26.19.42.39;	author cgf;	state Exp;
branches;
next	1.346;

1.346
date	2011.10.22.16.26.30;	author cgf;	state Exp;
branches;
next	1.345;

1.345
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.344;

1.344
date	2011.10.17.15.35.26;	author cgf;	state Exp;
branches;
next	1.343;

1.343
date	2011.10.06.19.47.45;	author corinna;	state Exp;
branches;
next	1.342;

1.342
date	2011.08.13.10.28.15;	author corinna;	state Exp;
branches;
next	1.341;

1.341
date	2011.08.03.17.58.59;	author cgf;	state Exp;
branches;
next	1.340;

1.340
date	2011.08.01.00.02.04;	author cgf;	state Exp;
branches;
next	1.339;

1.339
date	2011.07.06.12.39.36;	author corinna;	state Exp;
branches;
next	1.338;

1.338
date	2011.06.14.21.48.43;	author cgf;	state Exp;
branches;
next	1.337;

1.337
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.336;

1.336
date	2011.05.28.20.09.04;	author cgf;	state Exp;
branches;
next	1.335;

1.335
date	2011.05.28.18.17.09;	author cgf;	state Exp;
branches;
next	1.334;

1.334
date	2011.05.06.19.13.22;	author cgf;	state Exp;
branches;
next	1.333;

1.333
date	2011.05.05.15.03.54;	author cgf;	state Exp;
branches;
next	1.332;

1.332
date	2011.05.05.00.31.20;	author cgf;	state Exp;
branches;
next	1.331;

1.331
date	2010.09.12.19.13.09;	author cgf;	state Exp;
branches;
next	1.330;

1.330
date	2010.09.12.15.49.30;	author cgf;	state Exp;
branches;
next	1.329;

1.329
date	2010.09.02.05.34.02;	author cgf;	state Exp;
branches;
next	1.328;

1.328
date	2010.09.01.18.24.11;	author cgf;	state Exp;
branches;
next	1.327;

1.327
date	2010.08.10.16.44.37;	author cgf;	state Exp;
branches;
next	1.326;

1.326
date	2010.08.01.19.10.52;	author cgf;	state Exp;
branches;
next	1.325;

1.325
date	2010.03.31.18.06.02;	author cgf;	state Exp;
branches;
next	1.324;

1.324
date	2010.03.15.15.46.46;	author cgf;	state Exp;
branches;
next	1.323;

1.323
date	2010.03.15.15.31.32;	author cgf;	state Exp;
branches;
next	1.322;

1.322
date	2010.03.13.19.34.35;	author cgf;	state Exp;
branches;
next	1.321;

1.321
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.320;

1.320
date	2010.02.03.19.57.05;	author cgf;	state Exp;
branches;
next	1.319;

1.319
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.318;

1.318
date	2009.10.07.15.47.38;	author cwilson;	state Exp;
branches;
next	1.317;

1.317
date	2009.08.02.21.38.40;	author cgf;	state Exp;
branches;
next	1.316;

1.316
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.315;

1.315
date	2009.07.18.20.25.07;	author cgf;	state Exp;
branches;
next	1.314;

1.314
date	2009.07.12.21.15.47;	author cgf;	state Exp;
branches;
next	1.313;

1.313
date	2009.06.14.05.38.55;	author cgf;	state Exp;
branches;
next	1.312;

1.312
date	2008.04.07.18.45.58;	author cgf;	state Exp;
branches;
next	1.311;

1.311
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.310;

1.310
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.309;

1.309
date	2008.03.27.01.50.40;	author cgf;	state Exp;
branches;
next	1.308;

1.308
date	2008.03.01.14.53.44;	author cgf;	state Exp;
branches;
next	1.307;

1.307
date	2008.02.19.21.42.48;	author cgf;	state Exp;
branches;
next	1.306;

1.306
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.305;

1.305
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.304;

1.304
date	2007.07.14.15.58.32;	author cgf;	state Exp;
branches;
next	1.303;

1.303
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.302;

1.302
date	2007.01.30.21.53.05;	author corinna;	state Exp;
branches;
next	1.301;

1.301
date	2006.12.12.15.10.56;	author corinna;	state Exp;
branches;
next	1.300;

1.300
date	2006.12.11.19.59.05;	author corinna;	state Exp;
branches;
next	1.299;

1.299
date	2006.12.11.19.17.20;	author cgf;	state Exp;
branches;
next	1.298;

1.298
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.297;

1.297
date	2006.07.14.00.50.55;	author cgf;	state Exp;
branches
	1.297.2.1;
next	1.296;

1.296
date	2006.07.13.20.56.24;	author cgf;	state Exp;
branches;
next	1.295;

1.295
date	2006.05.29.00.21.58;	author cgf;	state Exp;
branches
	1.295.2.1;
next	1.294;

1.294
date	2006.05.22.04.50.54;	author cgf;	state Exp;
branches;
next	1.293;

1.293
date	2006.05.16.03.14.24;	author cgf;	state Exp;
branches;
next	1.292;

1.292
date	2006.03.30.00.57.59;	author cgf;	state Exp;
branches;
next	1.291;

1.291
date	2006.03.29.06.35.25;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2006.03.27.01.10.48;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2006.03.23.15.55.59;	author cgf;	state Exp;
branches;
next	1.288;

1.288
date	2006.03.22.16.42.45;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2006.03.22.04.13.55;	author cgf;	state Exp;
branches;
next	1.286;

1.286
date	2006.03.22.03.20.28;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2006.03.20.18.01.17;	author cgf;	state Exp;
branches;
next	1.284;

1.284
date	2006.03.20.02.01.50;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2006.03.20.01.59.23;	author cgf;	state Exp;
branches;
next	1.282;

1.282
date	2006.03.18.19.28.59;	author cgf;	state Exp;
branches;
next	1.281;

1.281
date	2006.03.18.19.17.21;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2006.03.15.00.29.14;	author cgf;	state Exp;
branches;
next	1.279;

1.279
date	2006.03.14.19.07.36;	author cgf;	state Exp;
branches;
next	1.278;

1.278
date	2006.03.13.21.10.14;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2006.03.13.18.29.48;	author cgf;	state Exp;
branches;
next	1.276;

1.276
date	2006.03.12.23.57.05;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2006.02.28.01.28.28;	author cgf;	state Exp;
branches;
next	1.274;

1.274
date	2006.02.24.21.40.28;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2006.02.06.18.24.06;	author cgf;	state Exp;
branches;
next	1.272;

1.272
date	2006.01.05.22.38.51;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2006.01.05.16.26.22;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2006.01.02.02.57.54;	author cgf;	state Exp;
branches;
next	1.269;

1.269
date	2005.12.29.20.46.34;	author cgf;	state Exp;
branches;
next	1.268;

1.268
date	2005.12.23.22.50.20;	author cgf;	state Exp;
branches;
next	1.267;

1.267
date	2005.12.23.01.24.14;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2005.12.19.04.34.13;	author cgf;	state Exp;
branches;
next	1.265;

1.265
date	2005.12.13.16.01.57;	author cgf;	state Exp;
branches;
next	1.264;

1.264
date	2005.12.03.04.23.35;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2005.10.29.15.19.34;	author cgf;	state Exp;
branches;
next	1.262;

1.262
date	2005.10.23.23.47.45;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2005.10.19.22.25.45;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2005.10.19.00.22.08;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2005.10.18.15.13.13;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2005.10.18.04.20.46;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2005.10.02.00.13.41;	author cgf;	state Exp;
branches;
next	1.255;

1.255
date	2005.09.28.22.56.42;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2005.09.28.19.22.24;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2005.09.28.19.02.51;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2005.09.26.14.51.48;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2005.09.26.01.27.36;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2005.09.24.19.17.49;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2005.09.23.23.37.52;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2005.09.23.15.18.22;	author cgf;	state Exp;
branches;
next	1.247;

1.247
date	2005.09.23.03.35.41;	author cgf;	state Exp;
branches;
next	1.246;

1.246
date	2005.09.20.02.06.57;	author cgf;	state Exp;
branches;
next	1.245;

1.245
date	2005.09.19.14.15.06;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2005.09.16.03.16.17;	author cgf;	state Exp;
branches;
next	1.243;

1.243
date	2005.09.16.01.47.09;	author cgf;	state Exp;
branches;
next	1.242;

1.242
date	2005.09.15.16.06.18;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2005.09.14.14.00.05;	author cgf;	state Exp;
branches;
next	1.240;

1.240
date	2005.09.13.17.08.54;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2005.09.13.15.05.53;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2005.09.02.17.35.22;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2005.09.02.17.12.36;	author cgf;	state Exp;
branches;
next	1.236;

1.236
date	2005.09.02.04.51.09;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2005.09.02.04.46.51;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2005.08.29.03.12.39;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2005.08.25.03.12.48;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2005.07.17.00.51.03;	author cgf;	state Exp;
branches;
next	1.231;

1.231
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2005.07.05.20.20.48;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2005.07.05.03.16.45;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2005.06.15.22.50.31;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2005.06.07.19.31.40;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2005.06.01.03.46.56;	author cgf;	state Exp;
branches;
next	1.225;

1.225
date	2005.05.02.03.50.08;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2005.04.20.20.43.36;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2005.04.05.06.04.57;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2005.04.05.04.31.00;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2005.04.01.15.27.52;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2005.02.27.04.30.08;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2005.02.26.20.50.25;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.217;

1.217
date	2005.02.13.18.17.29;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2005.01.17.04.12.08;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2005.01.16.17.00.27;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2005.01.15.23.43.42;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2005.01.11.15.31.04;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2004.12.27.17.19.25;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2004.12.27.02.13.30;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2004.12.27.00.35.19;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2004.12.24.18.31.23;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2004.12.23.14.57.07;	author cgf;	state Exp;
branches;
next	1.207;

1.207
date	2004.12.17.17.42.03;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2004.12.06.00.29.39;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2004.12.05.21.29.37;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2004.12.05.19.41.24;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2004.12.03.04.46.00;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2004.11.26.04.15.08;	author cgf;	state Exp;
branches;
next	1.201;

1.201
date	2004.09.20.04.58.36;	author cgf;	state Exp;
branches
	1.201.2.1;
next	1.200;

1.200
date	2004.09.12.19.34.08;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2004.09.12.03.47.57;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2004.03.26.16.15.23;	author cgf;	state Exp;
branches;
next	1.196;

1.196
date	2004.03.26.05.43.11;	author cgf;	state Exp;
branches;
next	1.195;

1.195
date	2004.03.25.15.15.27;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2004.03.16.05.05.22;	author cgf;	state Exp;
branches;
next	1.193;

1.193
date	2004.03.15.02.47.35;	author cgf;	state Exp;
branches;
next	1.192;

1.192
date	2004.03.14.06.34.05;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2004.03.12.03.09.28;	author cgf;	state Exp;
branches;
next	1.190;

1.190
date	2004.03.09.01.24.08;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2004.02.26.05.10.47;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2004.02.15.02.44.16;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2004.02.14.04.58.31;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2004.02.13.19.34.32;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2004.02.01.18.29.12;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2004.01.25.05.17.21;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2004.01.24.03.40.33;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2004.01.23.23.05.33;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2004.01.22.19.03.19;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2004.01.21.06.28.35;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2004.01.19.23.03.43;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches
	1.175.4.1;
next	1.174;

1.174
date	2003.12.30.03.59.45;	author cgf;	state Exp;
branches
	1.174.2.1;
next	1.173;

1.173
date	2003.12.26.04.40.52;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2003.12.18.04.42.31;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2003.12.17.22.47.32;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2003.12.16.23.28.03;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2003.12.07.22.37.12;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2003.11.29.00.31.37;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2003.11.29.00.26.40;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2003.11.28.22.13.57;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2003.11.23.05.42.47;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2003.11.23.05.34.00;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2003.09.28.15.46.00;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2003.09.25.03.06.36;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2003.09.25.02.29.04;	author phumblet;	state Exp;
branches;
next	1.158;

1.158
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2003.09.23.04.02.07;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2003.09.17.02.10.13;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2003.09.17.01.15.55;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2003.09.09.03.11.31;	author cgf;	state Exp;
branches
	1.154.4.1;
next	1.153;

1.153
date	2003.09.08.21.10.23;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2003.09.03.14.15.55;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2003.09.01.02.05.32;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2003.08.31.18.26.58;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2003.08.30.20.43.06;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2003.08.29.02.59.06;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2003.08.29.02.05.00;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2003.08.28.02.04.16;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2003.08.27.20.42.52;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2003.08.22.03.40.49;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2003.08.22.01.07.01;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2003.08.21.03.18.46;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2003.08.20.05.15.33;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2003.08.20.02.31.26;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2003.08.19.05.47.44;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2003.08.19.04.10.41;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2003.05.21.08.01.56;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2003.03.26.04.18.01;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2003.03.17.19.08.10;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2003.02.21.04.33.53;	author cgf;	state Exp;
branches
	1.133.2.1;
next	1.132;

1.132
date	2002.11.29.00.43.50;	author cgf;	state Exp;
branches
	1.132.4.1;
next	1.131;

1.131
date	2002.11.22.20.51.13;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2002.11.22.04.43.47;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2002.11.15.04.35.13;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2002.11.05.04.23.41;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2002.11.05.02.58.10;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2002.10.30.21.05.17;	author cgf;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2002.10.21.01.00.57;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2002.10.20.04.17.59;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2002.10.14.03.51.44;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2002.10.10.05.23.23;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2002.10.09.05.55.40;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2002.08.19.14.59.27;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2002.08.18.04.13.57;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2002.08.11.19.19.29;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2002.08.06.05.48.33;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2002.08.06.05.08.55;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2002.08.01.16.20.31;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2002.07.13.20.00.26;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2002.02.22.19.33.41;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2002.02.19.05.58.44;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2002.02.17.04.59.55;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2002.02.14.21.20.06;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2002.01.29.02.02.01;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2002.01.19.18.15.23;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2002.01.13.20.03.03;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2002.01.11.02.24.06;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2002.01.07.22.18.36;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2002.01.07.16.47.12;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2001.12.26.21.35.16;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2001.12.26.04.53.34;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2001.11.03.03.32.27;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2001.10.31.02.58.38;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2001.10.01.04.10.07;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2001.09.15.00.47.44;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2001.09.10.00.19.06;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2001.09.09.03.34.36;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2001.09.06.03.39.18;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2001.08.31.18.16.16;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2001.08.31.05.06.14;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2001.07.17.03.41.52;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2001.06.24.21.57.50;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2001.06.11.17.57.10;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2001.06.10.16.00.23;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2001.05.04.21.02.15;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2001.05.04.20.39.38;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2001.05.03.15.00.38;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2001.04.27.18.50.58;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2001.04.25.19.11.37;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2001.04.18.21.10.13;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2001.04.01.00.06.17;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2001.03.10.23.37.50;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2001.02.21.11.40.22;	author duda;	state Exp;
branches;
next	1.72;

1.72
date	2001.02.10.04.20.52;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.01.17.14.57.09;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.01.12.05.38.25;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.01.10.13.53.38;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2001.01.08.04.02.01;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.16.05.16.59;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2000.11.15.21.04.02;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2000.11.15.06.27.48;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2000.11.15.00.13.09;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2000.11.14.05.53.32;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2000.11.06.23.12.05;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2000.11.06.06.36.32;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2000.11.05.18.47.28;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2000.11.05.16.47.00;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2000.11.05.03.08.39;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2000.11.04.19.25.55;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2000.11.04.05.54.57;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2000.11.04.01.08.23;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2000.11.03.04.27.01;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2000.10.27.15.38.32;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2000.10.23.20.50.36;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2000.10.23.16.50.21;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2000.10.18.04.53.37;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2000.10.17.18.55.58;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2000.10.17.01.42.04;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2000.10.14.05.52.38;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2000.10.12.22.15.47;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2000.10.09.02.53.44;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.05.04.53.17;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.16.02.36.11;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2000.09.08.03.12.13;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.07.16.23.51;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.06.21.03.10;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.02.01.19.58;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.01.21.04.34;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.01.20.54.22;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.26.03.48.37;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.26.01.36.20;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.25.02.27.41;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.02.03.42.31;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.29.16.24.39;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.16.17.38.41;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.26.06.24.58;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.18.03.20.01;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.17.05.49.51;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.25.05.25.27;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.12.04.44.37;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.11.15.51.46;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.10.18.04.20;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.09.21.04.05;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.07.18.32.40;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.07.05.33.09;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.05.06.34.55;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.29.05.47.17;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.28.16.25.34;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.28.05.05.33;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.26.01.11.54;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.24.19.54.01;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.24.06.45.32;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.04.07.13;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.38;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.420.2.1
date	2014.02.19.14.36.25;	author cgf;	state Exp;
branches;
next	1.420.2.2;

1.420.2.2
date	2014.03.09.19.25.52;	author cgf;	state Exp;
branches;
next	1.420.2.3;

1.420.2.3
date	2014.03.17.04.36.17;	author cgf;	state Exp;
branches;
next	1.420.2.4;

1.420.2.4
date	2014.07.15.14.34.38;	author corinna;	state Exp;
branches;
next	1.420.2.5;

1.420.2.5
date	2014.07.15.15.48.45;	author corinna;	state Exp;
branches;
next	1.420.2.6;

1.420.2.6
date	2014.07.16.10.28.48;	author corinna;	state Exp;
branches;
next	;

1.388.2.1
date	2012.10.23.11.37.23;	author corinna;	state Exp;
branches;
next	1.388.2.2;

1.388.2.2
date	2012.10.26.10.49.52;	author corinna;	state Exp;
branches;
next	1.388.2.3;

1.388.2.3
date	2012.11.08.18.51.28;	author corinna;	state Exp;
branches;
next	1.388.2.4;

1.388.2.4
date	2012.12.04.17.11.33;	author corinna;	state Exp;
branches;
next	1.388.2.5;

1.388.2.5
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.388.2.6;

1.388.2.6
date	2012.12.10.12.19.45;	author corinna;	state Exp;
branches;
next	1.388.2.7;

1.388.2.7
date	2012.12.11.12.03.13;	author corinna;	state Exp;
branches;
next	1.388.2.8;

1.388.2.8
date	2013.01.09.16.27.21;	author corinna;	state Exp;
branches;
next	1.388.2.9;

1.388.2.9
date	2013.01.14.12.57.05;	author corinna;	state Exp;
branches;
next	1.388.2.10;

1.388.2.10
date	2013.01.17.17.17.10;	author corinna;	state Exp;
branches;
next	1.388.2.11;

1.388.2.11
date	2013.01.19.15.41.55;	author corinna;	state Exp;
branches;
next	1.388.2.12;

1.388.2.12
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.388.2.13;

1.388.2.13
date	2013.03.29.09.12.13;	author corinna;	state Exp;
branches;
next	1.388.2.14;

1.388.2.14
date	2013.03.29.13.52.04;	author corinna;	state Exp;
branches;
next	1.388.2.15;

1.388.2.15
date	2013.04.11.12.13.01;	author corinna;	state Exp;
branches;
next	;

1.297.2.1
date	2007.01.15.11.56.07;	author corinna;	state Exp;
branches;
next	1.297.2.2;

1.297.2.2
date	2007.01.30.22.10.16;	author corinna;	state Exp;
branches;
next	1.297.2.3;

1.297.2.3
date	2007.11.12.15.30.20;	author corinna;	state Exp;
branches;
next	1.297.2.4;

1.297.2.4
date	2008.02.18.14.08.37;	author corinna;	state Exp;
branches;
next	1.297.2.5;

1.297.2.5
date	2008.02.21.11.43.33;	author corinna;	state Exp;
branches;
next	1.297.2.6;

1.297.2.6
date	2008.03.02.10.40.39;	author corinna;	state Exp;
branches;
next	;

1.295.2.1
date	2006.07.14.08.23.32;	author corinna;	state Exp;
branches;
next	;

1.201.2.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	1.201.2.2;

1.201.2.2
date	2004.11.16.06.24.44;	author cgf;	state Exp;
branches;
next	1.201.2.3;

1.201.2.3
date	2004.11.16.15.16.57;	author cgf;	state Exp;
branches;
next	1.201.2.4;

1.201.2.4
date	2004.11.18.00.48.40;	author cgf;	state Exp;
branches;
next	1.201.2.5;

1.201.2.5
date	2004.11.20.02.56.34;	author cgf;	state Exp;
branches;
next	1.201.2.6;

1.201.2.6
date	2004.11.20.04.17.22;	author cgf;	state Exp;
branches;
next	1.201.2.7;

1.201.2.7
date	2004.11.20.05.28.31;	author cgf;	state Exp;
branches;
next	1.201.2.8;

1.201.2.8
date	2004.11.24.05.48.30;	author cgf;	state Exp;
branches;
next	;

1.175.4.1
date	2004.01.20.19.57.29;	author cgf;	state Exp;
branches;
next	1.175.4.2;

1.175.4.2
date	2004.01.21.04.14.42;	author cgf;	state Exp;
branches;
next	1.175.4.3;

1.175.4.3
date	2004.01.22.20.41.27;	author cgf;	state Exp;
branches;
next	1.175.4.4;

1.175.4.4
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	1.175.4.5;

1.175.4.5
date	2004.01.24.03.41.29;	author cgf;	state Exp;
branches;
next	1.175.4.6;

1.175.4.6
date	2004.01.25.05.18.11;	author cgf;	state Exp;
branches;
next	;

1.174.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	1.174.2.2;

1.174.2.2
date	2004.01.12.05.15.19;	author cgf;	state Exp;
branches;
next	1.174.2.3;

1.174.2.3
date	2004.01.15.18.29.37;	author cgf;	state Exp;
branches;
next	1.174.2.4;

1.174.2.4
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	;

1.154.4.1
date	2003.09.24.17.10.21;	author cgf;	state Exp;
branches;
next	;

1.133.2.1
date	2003.03.16.23.38.19;	author cgf;	state Exp;
branches;
next	;

1.132.4.1
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.132.4.2;

1.132.4.2
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.132.4.3;

1.132.4.3
date	2003.03.19.19.59.55;	author cgf;	state Exp;
branches;
next	1.132.4.4;

1.132.4.4
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.132.4.5;

1.132.4.5
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.132.4.6;

1.132.4.6
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.132.4.7;

1.132.4.7
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.132.4.8;

1.132.4.8
date	2003.09.02.02.31.09;	author cgf;	state Exp;
branches;
next	1.132.4.9;

1.132.4.9
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.125.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.95.2.1
date	2001.10.02.12.09.56;	author rbcollins;	state Exp;
branches;
next	1.95.2.2;

1.95.2.2
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.95.2.3;

1.95.2.3
date	2002.01.15.12.52.51;	author rbcollins;	state Exp;
branches;
next	1.95.2.4;

1.95.2.4
date	2002.01.22.04.52.40;	author rbcollins;	state Exp;
branches;
next	1.95.2.5;

1.95.2.5
date	2002.02.28.12.53.27;	author rbcollins;	state Exp;
branches;
next	1.95.2.6;

1.95.2.6
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.95.2.7;

1.95.2.7
date	2002.08.01.20.34.07;	author scottc;	state Exp;
branches;
next	1.95.2.8;

1.95.2.8
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	1.95.2.9;

1.95.2.9
date	2002.08.12.14.06.35;	author scottc;	state Exp;
branches;
next	1.95.2.10;

1.95.2.10
date	2002.08.18.12.09.27;	author scottc;	state Exp;
branches;
next	1.95.2.11;

1.95.2.11
date	2002.08.24.12.25.31;	author scottc;	state Exp;
branches;
next	1.95.2.12;

1.95.2.12
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.428
log
@	* cygheap.cc (init_cygheap::init_tls_list): Accommodate threadlist
	having a new type threadlist_t *.  Convert commented out code into an
	#if 0.  Create thread mutex.  Explain why.
	(init_cygheap::remove_tls): Drop timeout value.  Always wait infinitely
	for tls_sentry.  Return mutex HANDLE of just deleted threadlist entry.
	(init_cygheap::find_tls): New implementation taking tls pointer as
	search parameter.  Return threadlist_t *.
	(init_cygheap::find_tls): Return threadlist_t *.  Define ix as auto
	variable.  Drop exception handling since crash must be made impossible
	due to correct synchronization.  Return with locked mutex.
	* cygheap.h (struct threadlist_t): Define.
	(struct init_cygheap): Convert threadlist to threadlist_t type.
	(init_cygheap::remove_tls): Align declaration to above change.
	(init_cygheap::find_tls): Ditto.
	(init_cygheap::unlock_tls): Define.
	* cygtls.cc (_cygtls::remove): Unlock and close mutex when finishing.
	* exceptions.cc (sigpacket::process): Lock _cygtls area of thread before
	accessing it.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* sigproc.cc (sig_send): Ditto.
	* thread.cc (pthread::exit): Ditto.  Add comment.
	(pthread::cancel): Ditto.
@
text
@/* sigproc.cc: inter/intra signal and sub process handler

   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <stdlib.h>
#include <sys/cygwin.h>
#include "cygerrno.h"
#include "sigproc.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "child_info_magic.h"
#include "shared_info.h"
#include "cygtls.h"
#include "ntdll.h"
#include "exception.h"

/*
 * Convenience defines
 */
#define WSSC		  60000	// Wait for signal completion
#define WPSP		  40000	// Wait for proc_subproc mutex

/*
 * Global variables
 */
struct sigaction *global_sigs;

const char *__sp_fn ;
int __sp_ln;

bool no_thread_exit_protect::flag;

char NO_COPY myself_nowait_dummy[1] = {'0'};// Flag to sig_send that signal goes to
					//  current process but no wait is required

#define Static static NO_COPY


Static int nprocs;			// Number of deceased children
Static char cprocs[(NPROCS + 1) * sizeof (pinfo)];// All my children info
#define procs ((pinfo *) cprocs)	// All this just to avoid expensive
					// constructor operation  at DLL startup
Static waitq waitq_head;		// Start of queue for wait'ing threads

Static muto sync_proc_subproc;	// Control access to subproc stuff

_cygtls NO_COPY *_sig_tls;

Static HANDLE my_sendsig;
Static HANDLE my_readsig;

/* Function declarations */
static int __reg1 checkstate (waitq *);
static __inline__ bool get_proc_lock (DWORD, DWORD);
static bool __stdcall remove_proc (int);
static bool __stdcall stopped_or_terminated (waitq *, _pinfo *);
static void WINAPI wait_sig (VOID *arg);

/* wait_sig bookkeeping */

class pending_signals
{
  sigpacket sigs[NSIG + 1];
  sigpacket start;
  bool retry;

public:
  void add (sigpacket&);
  bool pending () {retry = true; return !!start.next;}
  void clear (int sig) {sigs[sig].si.si_signo = 0;}
  friend void __reg1 sig_dispatch_pending (bool);;
  friend void WINAPI wait_sig (VOID *arg);
  friend void sigproc_init ();
};

Static pending_signals sigq;

/* Functions */
void __stdcall
sigalloc ()
{
  cygheap->sigs = global_sigs =
    (struct sigaction *) ccalloc_abort (HEAP_SIGS, NSIG, sizeof (struct sigaction));
  global_sigs[SIGSTOP].sa_flags = SA_RESTART | SA_NODEFER;
}

void __stdcall
signal_fixup_after_exec ()
{
  global_sigs = cygheap->sigs;
  /* Set up child's signal handlers */
  for (int i = 0; i < NSIG; i++)
    {
      global_sigs[i].sa_mask = 0;
      if (global_sigs[i].sa_handler != SIG_IGN)
	{
	  global_sigs[i].sa_handler = SIG_DFL;
	  global_sigs[i].sa_flags &= ~ SA_SIGINFO;
	}
    }
}

/* Get the sync_proc_subproc muto to control access to
 * children, proc arrays.
 * Attempt to handle case where process is exiting as we try to grab
 * the mutex.
 */
static bool
get_proc_lock (DWORD what, DWORD val)
{
  if (!cygwin_finished_initializing)
    return true;
  Static int lastwhat = -1;
  if (!sync_proc_subproc)
    {
      sigproc_printf ("sync_proc_subproc is NULL");
      return false;
    }
  if (sync_proc_subproc.acquire (WPSP))
    {
      lastwhat = what;
      return true;
    }
  system_printf ("Couldn't acquire %s for(%d,%d), last %d, %E",
		 sync_proc_subproc.name, what, val, lastwhat);
  return false;
}

static bool __stdcall
proc_can_be_signalled (_pinfo *p)
{
  if (!(p->exitcode & EXITCODE_SET))
    {
      if (ISSTATE (p, PID_INITIALIZING) ||
	  (((p)->process_state & (PID_ACTIVE | PID_IN_USE)) ==
	   (PID_ACTIVE | PID_IN_USE)))
	return true;
    }

  set_errno (ESRCH);
  return false;
}

bool __reg1
pid_exists (pid_t pid)
{
  return pinfo (pid)->exists ();
}

/* Return true if this is one of our children, false otherwise.  */
static inline bool __stdcall
mychild (int pid)
{
  for (int i = 0; i < nprocs; i++)
    if (procs[i]->pid == pid)
      return true;
  return false;
}

/* Handle all subprocess requests
 */
int __reg2
proc_subproc (DWORD what, uintptr_t val)
{
  int rc = 1;
  int potential_match;
  int clearing;
  waitq *w;

#define wval	 ((waitq *) val)
#define vchild (*((pinfo *) val))

  sigproc_printf ("args: %x, %d", what, val);

  if (!get_proc_lock (what, val))	// Serialize access to this function
    {
      system_printf ("couldn't get proc lock. what %d, val %d", what, val);
      goto out1;
    }

  switch (what)
    {
    /* Add a new subprocess to the children arrays.
     * (usually called from the main thread)
     */
    case PROC_ADDCHILD:
      /* Filled up process table? */
      if (nprocs >= NPROCS)
	{
	  sigproc_printf ("proc table overflow: hit %d processes, pid %d\n",
			  nprocs, vchild->pid);
	  rc = 0;
	  set_errno (EAGAIN);
	  break;
	}
      /* fall through intentionally */

    case PROC_DETACHED_CHILD:
      if (vchild != myself)
	{
	  vchild->uid = myself->uid;
	  vchild->gid = myself->gid;
	  vchild->pgid = myself->pgid;
	  vchild->sid = myself->sid;
	  vchild->ctty = myself->ctty;
	  vchild->cygstarted = true;
	  vchild->process_state |= PID_INITIALIZING;
	  vchild->ppid = what == PROC_DETACHED_CHILD ? 1 : myself->pid;	/* always set last */
	}
      if (what == PROC_DETACHED_CHILD)
	break;
      /* fall through intentionally */

    case PROC_REATTACH_CHILD:
      procs[nprocs] = vchild;
      rc = procs[nprocs].wait ();
      if (rc)
	{
	  sigproc_printf ("added pid %d to proc table, slot %d", vchild->pid,
			  nprocs);
	  nprocs++;
	}
      break;

    /* Handle a wait4() operation.  Allocates an event for the calling
     * thread which is signaled when the appropriate pid exits or stops.
     * (usually called from the main thread)
     */
    case PROC_WAIT:
      wval->ev = NULL;		// Don't know event flag yet

      if (wval->pid != -1 && wval->pid && !mychild (wval->pid))
	goto out;		// invalid pid.  flag no such child

      wval->status = 0;		// Don't know status yet
      sigproc_printf ("wval->pid %d, wval->options %d", wval->pid, wval->options);

      /* If the first time for this thread, create a new event, otherwise
       * reset the event.
       */
      if ((wval->ev = wval->thread_ev) == NULL)
	{
	  wval->ev = wval->thread_ev = CreateEvent (&sec_none_nih, TRUE, FALSE,
						    NULL);
	  ProtectHandle1 (wval->ev, wq_ev);
	}

      ResetEvent (wval->ev);
      w = waitq_head.next;
      waitq_head.next = wval;	/* Add at the beginning. */
      wval->next = w;		/* Link in rest of the list. */
      clearing = false;
      goto scan_wait;

    case PROC_EXEC_CLEANUP:
      while (nprocs)
	remove_proc (0);
      for (w = &waitq_head; w->next != NULL; w = w->next)
	CloseHandle (w->next->ev);
      break;

    /* Clear all waiting threads.  Called from exceptions.cc prior to
       the main thread's dispatch to a signal handler function.
       (called from wait_sig thread) */
    case PROC_CLEARWAIT:
      /* Clear all "wait"ing threads. */
      if (val)
	sigproc_printf ("clear waiting threads");
      else
	sigproc_printf ("looking for processes to reap, nprocs %d", nprocs);
      clearing = val;

    scan_wait:
      /* Scan the linked list of wait()ing threads.  If a wait's parameters
	 match this pid, then activate it.  */
      for (w = &waitq_head; w->next != NULL; w = w->next)
	{
	  if ((potential_match = checkstate (w)) > 0)
	    sigproc_printf ("released waiting thread");
	  else if (!clearing && !(w->next->options & WNOHANG) && potential_match < 0)
	    sigproc_printf ("only found non-terminated children");
	  else if (potential_match <= 0)		// nothing matched
	    {
	      sigproc_printf ("waiting thread found no children");
	      HANDLE oldw = w->next->ev;
	      w->next->pid = 0;
	      if (clearing)
		w->next->status = -1;		/* flag that a signal was received */
	      else if (!potential_match || !(w->next->options & WNOHANG))
		w->next->ev = NULL;
	      if (!SetEvent (oldw))
		system_printf ("couldn't wake up wait event %p, %E", oldw);
	      w->next = w->next->next;
	    }
	  if (w->next == NULL)
	    break;
	}

      if (!clearing)
	sigproc_printf ("finished processing terminated/stopped child");
      else
	{
	  waitq_head.next = NULL;
	  sigproc_printf ("finished clearing");
	}

      if (global_sigs[SIGCHLD].sa_handler == (void *) SIG_IGN)
	for (int i = 0; i < nprocs; i += remove_proc (i))
	  continue;
  }

out:
  sync_proc_subproc.release ();	// Release the lock
out1:
  sigproc_printf ("returning %d", rc);
  return rc;
#undef wval
#undef vchild
}

// FIXME: This is inelegant
void
_cygtls::remove_wq (DWORD wait)
{
  if (wq.thread_ev)
    {
      if (exit_state < ES_FINAL && waitq_head.next && sync_proc_subproc
	  && sync_proc_subproc.acquire (wait))
	{
	  ForceCloseHandle1 (wq.thread_ev, wq_ev);
	  wq.thread_ev = NULL;
	  for (waitq *w = &waitq_head; w->next != NULL; w = w->next)
	    if (w->next == &wq)
	      {
		w->next = wq.next;
		break;
	      }
	  sync_proc_subproc.release ();
	}
    }

}

/* Terminate the wait_subproc thread.
   Called on process exit.
   Also called by spawn_guts to disassociate any subprocesses from this
   process.  Subprocesses will then know to clean up after themselves and
   will not become procs.  */
void __stdcall
proc_terminate ()
{
  sigproc_printf ("nprocs %d", nprocs);
  if (nprocs)
    {
      sync_proc_subproc.acquire (WPSP);

      proc_subproc (PROC_CLEARWAIT, 1);

      /* Clean out proc processes from the pid list. */
      for (int i = 0; i < nprocs; i++)
	{
	  /* If we've execed then the execed process will handle setting ppid
	     to 1 iff it is a Cygwin process.  */
	  if (!have_execed || !have_execed_cygwin)
	    procs[i]->ppid = 1;
	  if (procs[i].wait_thread)
	    procs[i].wait_thread->terminate_thread ();
	  /* Release memory associated with this process unless it is 'myself'.
	     'myself' is only in the procs table when we've execed.  We reach
	     here when the next process has finished initializing but we still
	     can't free the memory used by 'myself' since it is used later on
	     during cygwin tear down.  */
	  if (procs[i] != myself)
	    procs[i].release ();
	}
      nprocs = 0;
      sync_proc_subproc.release ();
    }
  sigproc_printf ("leaving");
}

/* Clear pending signal */
void __reg1
sig_clear (int sig)
{
  sigq.clear (sig);
}

extern "C" int
sigpending (sigset_t *mask)
{
  sigset_t outset = (sigset_t) sig_send (myself, __SIGPENDING, &_my_tls);
  if (outset == SIG_BAD_MASK)
    return -1;
  *mask = outset;
  return 0;
}

/* Force the wait_sig thread to wake up and scan for pending signals */
void __reg1
sig_dispatch_pending (bool fast)
{
  /* Non-atomically test for any signals pending and wake up wait_sig if any are
     found.  It's ok if there's a race here since the next call to this function
     should catch it.  */
  if (sigq.pending () && &_my_tls != _sig_tls)
    sig_send (myself, fast ? __SIGFLUSHFAST : __SIGFLUSH);
}

/* Signal thread initialization.  Called from dll_crt0_1.
   This routine starts the signal handling thread.  */
void __stdcall
sigproc_init ()
{
  char char_sa_buf[1024];
  PSECURITY_ATTRIBUTES sa = sec_user_nih ((PSECURITY_ATTRIBUTES) char_sa_buf, cygheap->user.sid());
  DWORD err = fhandler_pipe::create (sa, &my_readsig, &my_sendsig,
				     NSIG * sizeof (sigpacket), "sigwait",
				     PIPE_ADD_PID);
  if (err)
    {
      SetLastError (err);
      api_fatal ("couldn't create signal pipe, %E");
    }
  ProtectHandle (my_readsig);
  myself->sendsig = my_sendsig;
  /* sync_proc_subproc is used by proc_subproc.  It serializes
     access to the children and proc arrays.  */
  sync_proc_subproc.init ("sync_proc_subproc");
  new cygthread (wait_sig, cygself, "sig");
}

/* Exit the current thread very carefully.
   See cgf-000017 in DevNotes for more details on why this is
   necessary.  */
void
exit_thread (DWORD res)
{
# undef ExitThread
  if (no_thread_exit_protect ())
    ExitThread (res);
  sigfillset (&_my_tls.sigmask);	/* No signals wanted */

  /* CV 2014-11-21: Disable the code sending a signal.  The problem with
     this code is that it allows deadlocks under signal-rich multithreading
     conditions.
     The original problem reported in 2012 couldn't be reproduced anymore,
     even disabling this code.  Tested on XP 32, Vista 32, W7 32, WOW64, 64,
     W8.1 WOW64, 64. */
#if 0
  lock_process for_now;			/* May block indefinitely when exiting. */
  HANDLE h;
  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
                        GetCurrentProcess (), &h,
                        0, FALSE, DUPLICATE_SAME_ACCESS))
    {
#ifdef DEBUGGING
      system_printf ("couldn't duplicate the current thread, %E");
#endif
      for_now.release ();
      ExitThread (res);
    }
  ProtectHandle1 (h, exit_thread);
  /* Tell wait_sig to wait for this thread to exit.  It can then release
     the lock below and close the above-opened handle. */
  siginfo_t si = {__SIGTHREADEXIT, SI_KERNEL};
  si.si_cyg = h;
  sig_send (myself_nowait, si, &_my_tls);
#endif
  ExitThread (res);
}

int __reg3
sig_send (_pinfo *p, int sig, _cygtls *tls)
{
  siginfo_t si = {};
  si.si_signo = sig;
  si.si_code = SI_KERNEL;
  return sig_send (p, si, tls);
}

/* Send a signal to another process by raising its signal semaphore.
   If pinfo *p == NULL, send to the current process.
   If sending to this process, wait for notification that a signal has
   completed before returning.  */
int __reg3
sig_send (_pinfo *p, siginfo_t& si, _cygtls *tls)
{
  int rc = 1;
  bool its_me;
  HANDLE sendsig;
  sigpacket pack;
  bool communing = si.si_signo == __SIGCOMMUNE;

  pack.wakeup = NULL;
  bool wait_for_completion;
  if (!(its_me = p == NULL || p == myself || p == myself_nowait))
    {
      /* It is possible that the process is not yet ready to receive messages
       * or that it has exited.  Detect this.
       */
      if (!proc_can_be_signalled (p))	/* Is the process accepting messages? */
	{
	  sigproc_printf ("invalid pid %d(%x), signal %d",
			  p->pid, p->process_state, si.si_signo);
	  goto out;
	}
      wait_for_completion = false;
    }
  else
    {
      wait_for_completion = p != myself_nowait;
      p = myself;
    }


  if (its_me)
    sendsig = my_sendsig;
  else
    {
      HANDLE dupsig;
      DWORD dwProcessId;
      for (int i = 0; !p->sendsig && i < 10000; i++)
	yield ();
      if (p->sendsig)
	{
	  dupsig = p->sendsig;
	  dwProcessId = p->dwProcessId;
	}
      else
	{
	  dupsig = p->exec_sendsig;
	  dwProcessId = p->exec_dwProcessId;
	}
      if (!dupsig)
	{
	  set_errno (EAGAIN);
	  sigproc_printf ("sendsig handle never materialized");
	  goto out;
	}
      HANDLE hp = OpenProcess (PROCESS_DUP_HANDLE, false, dwProcessId);
      if (!hp)
	{
	  __seterrno ();
	  sigproc_printf ("OpenProcess failed, %E");
	  goto out;
	}
      VerifyHandle (hp);
      if (!DuplicateHandle (hp, dupsig, GetCurrentProcess (), &sendsig, 0,
			    false, DUPLICATE_SAME_ACCESS) || !sendsig)
	{
	  __seterrno ();
	  sigproc_printf ("DuplicateHandle failed, %E");
	  CloseHandle (hp);
	  goto out;
	}
      VerifyHandle (sendsig);
      if (!communing)
	{
	  CloseHandle (hp);
	  DWORD flag = PIPE_NOWAIT;
	  /* Set PIPE_NOWAIT here to avoid blocking when sending a signal.
	     (Yes, I know MSDN says not to use this)
	     We can't ever block here because it causes a deadlock when
	     debugging with gdb.  */
	  BOOL res = SetNamedPipeHandleState (sendsig, &flag, NULL, NULL);
	  sigproc_printf ("%d = SetNamedPipeHandleState (%y, PIPE_NOWAIT, NULL, NULL)", res, sendsig);
	}
      else
	{
	  si._si_commune._si_process_handle = hp;

	  HANDLE& tome = si._si_commune._si_write_handle;
	  HANDLE& fromthem = si._si_commune._si_read_handle;
	  if (!CreatePipeOverlapped (&fromthem, &tome, &sec_all_nih))
	    {
	      sigproc_printf ("CreatePipe for __SIGCOMMUNE failed, %E");
	      __seterrno ();
	      goto out;
	    }
	  if (!DuplicateHandle (GetCurrentProcess (), tome, hp, &tome, 0, false,
				DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
	    {
	      sigproc_printf ("DuplicateHandle for __SIGCOMMUNE failed, %E");
	      __seterrno ();
	      goto out;
	    }
	}
    }

  sigproc_printf ("sendsig %p, pid %d, signal %d, its_me %d", sendsig, p->pid,
		  si.si_signo, its_me);

  sigset_t pending;
  if (!its_me)
    pack.mask = NULL;
  else if (si.si_signo == __SIGPENDING)
    pack.mask = &pending;
  else if (si.si_signo == __SIGFLUSH || si.si_signo > 0)
    {
      threadlist_t *tl_entry = cygheap->find_tls (tls ? tls : _main_tls);
      pack.mask = tls ? &tls->sigmask : &_main_tls->sigmask;
      cygheap->unlock_tls (tl_entry);
    }
  else
    pack.mask = NULL;

  pack.si = si;
  if (!pack.si.si_pid)
    pack.si.si_pid = myself->pid;
  if (!pack.si.si_uid)
    pack.si.si_uid = myself->uid;
  pack.pid = myself->pid;
  pack.sigtls = tls;
  if (wait_for_completion)
    {
      pack.wakeup = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
      sigproc_printf ("wakeup %p", pack.wakeup);
      ProtectHandle (pack.wakeup);
    }

  char *leader;
  size_t packsize;
  if (!communing || !(si._si_commune._si_code & PICOM_EXTRASTR))
    {
      leader = (char *) &pack;
      packsize = sizeof (pack);
    }
  else
    {
      size_t n = strlen (si._si_commune._si_str);
      packsize = sizeof (pack) + sizeof (n) + n;
      char *p = leader = (char *) alloca (packsize);
      memcpy (p, &pack, sizeof (pack)); p += sizeof (pack);
      memcpy (p, &n, sizeof (n)); p += sizeof (n);
      memcpy (p, si._si_commune._si_str, n); p += n;
    }

  DWORD nb;
  BOOL res;
  /* Try multiple times to send if packsize != nb since that probably
     means that the pipe buffer is full.  */
  for (int i = 0; i < 100; i++)
    {
      res = WriteFile (sendsig, leader, packsize, &nb, NULL);
      if (!res || packsize == nb)
	break;
      Sleep (10);
      res = 0;
    }

  if (!res)
    {
      /* Couldn't send to the pipe.  This probably means that the
	 process is exiting.  */
      if (!its_me)
	{
	  sigproc_printf ("WriteFile for pipe %p failed, %E", sendsig);
	  ForceCloseHandle (sendsig);
	}
      else if (!p->exec_sendsig && !exit_state)
	system_printf ("error sending signal %d, pid %u, pipe handle %p, nb %u, packsize %u, %E",
		       si.si_signo, p->pid, sendsig, nb, packsize);
      if (GetLastError () == ERROR_BROKEN_PIPE)
	set_errno (ESRCH);
      else
	__seterrno ();
      goto out;
    }


  /* No need to wait for signal completion unless this was a signal to
     this process.

     If it was a signal to this process, wait for a dispatched signal.
     Otherwise just wait for the wait_sig to signal that it has finished
     processing the signal.  */
  if (wait_for_completion)
    {
      sigproc_printf ("Waiting for pack.wakeup %p", pack.wakeup);
      rc = WaitForSingleObject (pack.wakeup, WSSC);
      ForceCloseHandle (pack.wakeup);
    }
  else
    {
      rc = WAIT_OBJECT_0;
      sigproc_printf ("Not waiting for sigcomplete.  its_me %d signal %d",
		      its_me, si.si_signo);
      if (!its_me)
	ForceCloseHandle (sendsig);
    }

  pack.wakeup = NULL;
  if (rc == WAIT_OBJECT_0)
    rc = 0;		// Successful exit
  else
    {
      set_errno (ENOSYS);
      rc = -1;
    }

  if (wait_for_completion && si.si_signo != __SIGFLUSHFAST)
    _my_tls.call_signal_handler ();

out:
  if (communing && rc)
    {
      if (si._si_commune._si_process_handle)
	CloseHandle (si._si_commune._si_process_handle);
      if (si._si_commune._si_read_handle)
	CloseHandle (si._si_commune._si_read_handle);
    }
  if (pack.wakeup)
    ForceCloseHandle (pack.wakeup);
  if (si.si_signo != __SIGPENDING)
    /* nothing */;
  else if (!rc)
    rc = (int) pending;
  else
    rc = SIG_BAD_MASK;
  sigproc_printf ("returning %p from sending signal %d", rc, si.si_signo);
  return rc;
}

int child_info::retry_count = 0;

/* Initialize some of the memory block passed to child processes
   by fork/spawn/exec. */
child_info::child_info (unsigned in_cb, child_info_types chtype,
			bool need_subproc_ready):
  cb (in_cb), intro (PROC_MAGIC_GENERIC), magic (CHILD_INFO_MAGIC),
  type (chtype), cygheap (::cygheap), cygheap_max (::cygheap_max),
  flag (0), retry (child_info::retry_count), rd_proc_pipe (NULL),
  wr_proc_pipe (NULL)
{
  /* It appears that when running under WOW64 on Vista 64, the first DWORD
     value in the datastructure lpReserved2 is pointing to (msv_count in
     Cygwin), has to reflect the size of that datastructure as used in the
     Microsoft C runtime (a count value, counting the number of elements in
     two subsequent arrays, BYTE[count and HANDLE[count]), even though the C
     runtime isn't used.  Otherwise, if msv_count is 0 or too small, the
     datastructure gets overwritten.

     This seems to be a bug in Vista's WOW64, which apparently copies the
     lpReserved2 datastructure not using the cbReserved2 size information,
     but using the information given in the first DWORD within lpReserved2
     instead.  32 bit Windows and former WOW64 don't care if msv_count is 0
     or a sensible non-0 count value.  However, it's not clear if a non-0
     count doesn't result in trying to evaluate the content, so we do this
     really only for Vista 64 for now.

     Note: It turns out that a non-zero value *does* harm operation on
     XP 64 and 2K3 64 (Crash in CreateProcess call).

     The value is sizeof (child_info_*) / 5 which results in a count which
     covers the full datastructure, plus not more than 4 extra bytes.  This
     is ok as long as the child_info structure is cosily stored within a bigger
     datastructure. */
  msv_count = wincap.needs_count_in_si_lpres2 () ? in_cb / 5 : 0;

  fhandler_union_cb = sizeof (fhandler_union);
  user_h = cygwin_user_h;
  if (strace.active ())
    flag |= _CI_STRACED;
  if (need_subproc_ready)
    {
      subproc_ready = CreateEvent (&sec_all, FALSE, FALSE, NULL);
      flag |= _CI_ISCYGWIN;
    }
  sigproc_printf ("subproc_ready %p", subproc_ready);
  /* Create an inheritable handle to pass to the child process.  This will
     allow the child to duplicate handles from the parent to itself. */
  parent = NULL;
  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentProcess (),
			GetCurrentProcess (), &parent, 0, true,
			DUPLICATE_SAME_ACCESS))
    system_printf ("couldn't create handle to myself for child, %E");
}

child_info::~child_info ()
{
  cleanup ();
}

child_info_fork::child_info_fork () :
  child_info (sizeof *this, _CH_FORK, true),
  forker_finished (NULL)
{
}

child_info_spawn::child_info_spawn (child_info_types chtype, bool need_subproc_ready) :
  child_info (sizeof *this, chtype, need_subproc_ready)
{
  if (type == _CH_EXEC)
    {
      hExeced = NULL;
      if (my_wr_proc_pipe)
	ev = NULL;
      else if (!(ev = CreateEvent (&sec_none_nih, false, false, NULL)))
	api_fatal ("couldn't create signalling event for exec, %E");

      get_proc_lock (PROC_EXECING, 0);
      /* exit with lock held */
    }
}

cygheap_exec_info *
cygheap_exec_info::alloc ()
{
  cygheap_exec_info *res =
    (cygheap_exec_info *) ccalloc_abort (HEAP_1_EXEC, 1,
					 sizeof (cygheap_exec_info)
					 + (nprocs * sizeof (children[0])));
  res->sigmask = _my_tls.sigmask;
  return res;
}

void
child_info_spawn::wait_for_myself ()
{
  postfork (myself);
  myself.remember (false);
  WaitForSingleObject (ev, INFINITE);
}

void
child_info::cleanup ()
{
  if (subproc_ready)
    {
      CloseHandle (subproc_ready);
      subproc_ready = NULL;
    }
  if (parent)
    {
      CloseHandle (parent);
      parent = NULL;
    }
  if (rd_proc_pipe)
    {
      ForceCloseHandle (rd_proc_pipe);
      rd_proc_pipe = NULL;
    }
  if (wr_proc_pipe)
    {
      ForceCloseHandle (wr_proc_pipe);
      wr_proc_pipe = NULL;
    }
}

void
child_info_spawn::cleanup ()
{
  if (moreinfo)
    {
      if (moreinfo->envp)
	{
	  for (char **e = moreinfo->envp; *e; e++)
	    cfree (*e);
	  cfree (moreinfo->envp);
	}
      if (type != _CH_SPAWN && moreinfo->myself_pinfo)
	CloseHandle (moreinfo->myself_pinfo);
      cfree (moreinfo);
    }
  moreinfo = NULL;
  if (ev)
    {
      CloseHandle (ev);
      ev = NULL;
    }
  if (type == _CH_EXEC)
    {
      if (iscygwin () && hExeced)
	proc_subproc (PROC_EXEC_CLEANUP, 0);
      sync_proc_subproc.release ();
    }
  type = _CH_NADA;
  child_info::cleanup ();
}

/* Record any non-reaped subprocesses to be passed to about-to-be-execed
   process.  FIXME: There is a race here if the process exits while we
   are recording it.  */
inline void
cygheap_exec_info::record_children ()
{
  for (nchildren = 0; nchildren < nprocs; nchildren++)
    {
      children[nchildren].pid = procs[nchildren]->pid;
      children[nchildren].p = procs[nchildren];
    }
}

void
child_info_spawn::record_children ()
{
  if (type == _CH_EXEC && iscygwin ())
    moreinfo->record_children ();
}

/* Reattach non-reaped subprocesses passed in from the cygwin process
   which previously operated under this pid.  FIXME: Is there a race here
   if the process exits during cygwin's exec handoff?  */
inline void
cygheap_exec_info::reattach_children (HANDLE parent)
{
  for (int i = 0; i < nchildren; i++)
    {
      pinfo p (parent, children[i].p, children[i].pid);
      if (!p)
	debug_only_printf ("couldn't reattach child %d from previous process", children[i].pid);
      else if (!p.reattach ())
	debug_only_printf ("attach of child process %d failed", children[i].pid);
      else
	debug_only_printf ("reattached pid %d<%u>, process handle %p, rd_proc_pipe %p->%p",
			   p->pid, p->dwProcessId, p.hProcess,
			   children[i].p.rd_proc_pipe, p.rd_proc_pipe);
    }
}

void
child_info_spawn::reattach_children ()
{
  moreinfo->reattach_children (parent);
}

void
child_info::ready (bool execed)
{
  if (!subproc_ready)
    {
      sigproc_printf ("subproc_ready not set");
      return;
    }

  if (dynamically_loaded)
    sigproc_printf ("not really ready");
  else if (!SetEvent (subproc_ready))
    api_fatal ("SetEvent failed, %E");
  else
    sigproc_printf ("signalled %p that I was ready", subproc_ready);

  if (execed)
    {
      CloseHandle (subproc_ready);
      subproc_ready = NULL;
    }
}

bool
child_info::sync (pid_t pid, HANDLE& hProcess, DWORD howlong)
{
  bool res;
  HANDLE w4[2];
  unsigned n = 0;
  unsigned nsubproc_ready;

  if (!subproc_ready)
    nsubproc_ready = WAIT_OBJECT_0 + 3;
  else
    {
      w4[n++] = subproc_ready;
      nsubproc_ready = 0;
    }
  w4[n++] = hProcess;

  sigproc_printf ("n %d, waiting for subproc_ready(%p) and child process(%p)", n, w4[0], w4[1]);
  DWORD x = WaitForMultipleObjects (n, w4, FALSE, howlong);
  x -= WAIT_OBJECT_0;
  if (x >= n)
    {
      system_printf ("wait failed, pid %u, %E", pid);
      res = false;
    }
  else
    {
      if (x != nsubproc_ready)
	{
	  res = false;
	  GetExitCodeProcess (hProcess, &exit_code);
	}
      else
	{
	  res = true;
	  exit_code = STILL_ACTIVE;
	  if (type == _CH_EXEC && my_wr_proc_pipe)
	    {
	      ForceCloseHandle1 (hProcess, childhProc);
	      hProcess = NULL;
	    }
	}
      sigproc_printf ("pid %u, WFMO returned %d, exit_code %y, res %d", pid, x,
		      exit_code, res);
    }
  return res;
}

DWORD
child_info::proc_retry (HANDLE h)
{
  if (!exit_code)
    return EXITCODE_OK;
  sigproc_printf ("exit_code %y", exit_code);
  switch (exit_code)
    {
    case STILL_ACTIVE:	/* shouldn't happen */
      sigproc_printf ("STILL_ACTIVE?  How'd we get here?");
      break;
    case STATUS_DLL_NOT_FOUND:
    case STATUS_ACCESS_VIOLATION:
    case STATUS_ILLEGAL_INSTRUCTION:
    case STATUS_ILLEGAL_DLL_PSEUDO_RELOCATION: /* pseudo-reloc.c specific */
      return exit_code;
    case STATUS_CONTROL_C_EXIT:
      if (saw_ctrl_c ())
	return EXITCODE_OK;
      /* fall through intentionally */
    case STATUS_DLL_INIT_FAILED:
    case STATUS_DLL_INIT_FAILED_LOGOFF:
    case EXITCODE_RETRY:
      if (retry-- > 0)
	exit_code = 0;
      break;
    case EXITCODE_FORK_FAILED: /* windows prevented us from forking */
      break;

    /* Count down non-recognized exit codes more quickly since they aren't
       due to known conditions.  */
    default:
      if (!iscygwin () && (exit_code & 0xffff0000) != 0xc0000000)
	break;
      if ((retry -= 2) < 0)
	retry = 0;
      else
	exit_code = 0;
    }
  if (!exit_code)
    ForceCloseHandle1 (h, childhProc);
  return exit_code;
}

bool
child_info_fork::abort (const char *fmt, ...)
{
  if (fmt)
    {
      va_list ap;
      va_start (ap, fmt);
      strace_vprintf (SYSTEM, fmt, ap);
      TerminateProcess (GetCurrentProcess (), EXITCODE_FORK_FAILED);
    }
  if (retry > 0)
    TerminateProcess (GetCurrentProcess (), EXITCODE_RETRY);
  return false;
}

/* Check the state of all of our children to see if any are stopped or
 * terminated.
 */
static int __reg1
checkstate (waitq *parent_w)
{
  int potential_match = 0;

  sigproc_printf ("nprocs %d", nprocs);

  /* Check already dead processes first to see if they match the criteria
   * given in w->next.  */
  int res;
  for (int i = 0; i < nprocs; i++)
    if ((res = stopped_or_terminated (parent_w, procs[i])))
      {
	remove_proc (i);
	potential_match = 1;
	goto out;
      }

  sigproc_printf ("no matching terminated children found");
  potential_match = -!!nprocs;

out:
  sigproc_printf ("returning %d", potential_match);
  return potential_match;
}

/* Remove a proc from procs by swapping it with the last child in the list.
   Also releases shared memory of exited processes.  */
static bool __stdcall
remove_proc (int ci)
{
  if (have_execed)
    {
      if (_my_tls._ctinfo != procs[ci].wait_thread)
	procs[ci].wait_thread->terminate_thread ();
    }
  else if (procs[ci]->exists ())
    return true;

  sigproc_printf ("removing procs[%d], pid %d, nprocs %d", ci, procs[ci]->pid,
		  nprocs);
  if (procs[ci] != myself)
    procs[ci].release ();
  if (ci < --nprocs)
    {
      /* Wait for proc_waiter thread to make a copy of this element before
	 moving it or it may become confused.  The chances are very high that
	 the proc_waiter thread has already done this by the time we
	 get here.  */
      if (!have_execed && !exit_state)
	while (!procs[nprocs].waiter_ready)
	  yield ();
      procs[ci] = procs[nprocs];
    }
  return 0;
}

/* Check status of child process vs. waitq member.

   parent_w is the pointer to the parent of the waitq member in question.
   child is the subprocess being considered.

   Returns non-zero if waiting thread released.  */
static bool __stdcall
stopped_or_terminated (waitq *parent_w, _pinfo *child)
{
  int might_match;
  waitq *w = parent_w->next;

  sigproc_printf ("considering pid %d, pgid %d, w->pid %d", child->pid, child->pgid, w->pid);
  if (w->pid == -1)
    might_match = 1;
  else if (w->pid == 0)
    might_match = child->pgid == myself->pgid;
  else if (w->pid < 0)
    might_match = child->pgid == -w->pid;
  else
    might_match = (w->pid == child->pid);

  if (!might_match)
    return false;

  int terminated;

  if (!((terminated = (child->process_state == PID_EXITED))
	|| ((w->options & WCONTINUED) && child->stopsig == SIGCONT)
	|| ((w->options & WUNTRACED) && child->stopsig && child->stopsig != SIGCONT)))
    return false;

  parent_w->next = w->next;	/* successful wait.  remove from wait queue */
  w->pid = child->pid;

  if (!terminated)
    {
      sigproc_printf ("stopped child, stop signal %d", child->stopsig);
      if (child->stopsig == SIGCONT)
	w->status = __W_CONTINUED;
      else
	w->status = (child->stopsig << 8) | 0x7f;
      child->stopsig = 0;
    }
  else
    {
      child->process_state = PID_REAPED;
      w->status = (__uint16_t) child->exitcode;

      add_rusage (&myself->rusage_children, &child->rusage_children);
      add_rusage (&myself->rusage_children, &child->rusage_self);

      if (w->rusage)
	{
	  add_rusage ((struct rusage *) w->rusage, &child->rusage_children);
	  add_rusage ((struct rusage *) w->rusage, &child->rusage_self);
	}
    }

  if (!SetEvent (w->ev))	/* wake up wait4 () immediately */
    system_printf ("couldn't wake up wait event %p, %E", w->ev);
  return true;
}

static void
talktome (siginfo_t *si)
{
  unsigned size = sizeof (*si);
  sigproc_printf ("pid %d wants some information", si->si_pid);
  if (si->_si_commune._si_code & PICOM_EXTRASTR)
    {
      size_t n;
      DWORD nb;
      if (!ReadFile (my_readsig, &n, sizeof (n), &nb, NULL) || nb != sizeof (n))
	return;
      siginfo_t *newsi = (siginfo_t *) alloca (size += n + 1);
      *newsi = *si;
      newsi->_si_commune._si_str = (char *) (newsi + 1);
      if (!ReadFile (my_readsig, newsi->_si_commune._si_str, n, &nb, NULL) || nb != n)
	return;
      newsi->_si_commune._si_str[n] = '\0';
      si = newsi;
    }

  pinfo pi (si->si_pid);
  if (pi)
    new cygthread (commune_process, size, si, "commune");
}

/* Add a packet to the beginning of the queue.
   Should only be called from signal thread.  */
void
pending_signals::add (sigpacket& pack)
{
  sigpacket *se;

  se = sigs + pack.si.si_signo;
  if (se->si.si_signo)
    return;
  *se = pack;
  se->next = start.next;
  start.next = se;
}

/* Process signals by waiting for signal data to arrive in a pipe.
   Set a completion event if one was specified. */
static void WINAPI
wait_sig (VOID *)
{
  _sig_tls = &_my_tls;
  bool sig_held = false;

  sigproc_printf ("entering ReadFile loop, my_readsig %p, my_sendsig %p",
		  my_readsig, my_sendsig);

  hntdll = GetModuleHandle ("ntdll.dll");

  for (;;)
    {
      DWORD nb;
      sigpacket pack = {};
      if (sigq.retry)
	pack.si.si_signo = __SIGFLUSH;
      else if (!ReadFile (my_readsig, &pack, sizeof (pack), &nb, NULL))
	Sleep (INFINITE);	/* Assume were exiting.  Never exit this thread */
      else if (nb != sizeof (pack) || !pack.si.si_signo)
	{
	  system_printf ("garbled signal pipe data nb %u, sig %d", nb, pack.si.si_signo);
	  continue;
	}

      sigq.retry = false;
      /* Don't process signals when we start exiting */
      if (exit_state > ES_EXIT_STARTING && pack.si.si_signo > 0)
	continue;

      sigset_t dummy_mask;
      threadlist_t *tl_entry;
      if (!pack.mask)
	{
	  tl_entry = cygheap->find_tls (_main_tls);
	  dummy_mask = _main_tls->sigmask;
	  cygheap->unlock_tls (tl_entry);
	  pack.mask = &dummy_mask;
	}

      sigpacket *q = &sigq.start;
      bool clearwait = false;
      switch (pack.si.si_signo)
	{
	case __SIGCOMMUNE:
	  talktome (&pack.si);
	  break;
	case __SIGSTRACE:
	  strace.activate (false);
	  break;
	case __SIGPENDING:
	  {
	    unsigned bit;

	    *pack.mask = 0;
	    tl_entry = cygheap->find_tls (pack.sigtls);
	    while ((q = q->next))
	      if (pack.sigtls->sigmask & (bit = SIGTOMASK (q->si.si_signo)))
		*pack.mask |= bit;
	    cygheap->unlock_tls (tl_entry);
	  }
	  break;
	case __SIGHOLD:
	  sig_held = true;
	  break;
	case __SIGSETPGRP:
	  init_console_handler (true);
	  break;
	case __SIGTHREADEXIT:
	  {
	    /* Serialize thread exit as the thread exit code can be interpreted
	       as the process exit code in some cases when racing with
	       ExitProcess/TerminateProcess.
	       So, wait for the thread which sent this signal to exit, then
	       release the process lock which it held and close it's handle.
	       See cgf-000017 in DevNotes for more details.
	       */
	    HANDLE h = (HANDLE) pack.si.si_cyg;
	    DWORD res = WaitForSingleObject (h, 5000);
	    lock_process::force_release (pack.sigtls);
	    ForceCloseHandle1 (h, exit_thread);
	    if (res != WAIT_OBJECT_0)
	      {
#ifdef DEBUGGING
		try_to_debug();
#endif
		system_printf ("WaitForSingleObject(%p) for thread exit returned %u", h, res);
	      }
	  }
	  break;
	default:	/* Normal (positive) signal */
	  if (pack.si.si_signo < 0)
	    sig_clear (-pack.si.si_signo);
	  else
	    sigq.add (pack);
	case __SIGNOHOLD:
	  sig_held = false;
	case __SIGFLUSH:
	case __SIGFLUSHFAST:
	  if (!sig_held)
	    {
	      sigpacket *qnext;
	      /* Check the queue for signals.  There will always be at least one
		 thing on the queue if this was a valid signal.  */
	      while ((qnext = q->next))
		{
		  if (qnext->si.si_signo && qnext->process () <= 0)
		    q = qnext;
		  else
		    {
		      q->next = qnext->next;
		      qnext->si.si_signo = 0;
		    }
		}
	      if (pack.si.si_signo == SIGCHLD)
		clearwait = true;
	    }
	  break;
	}
      if (clearwait && !have_execed)
	proc_subproc (PROC_CLEARWAIT, 0);
      if (pack.wakeup)
	{
	  sigproc_printf ("signalling pack.wakeup %p", pack.wakeup);
	  SetEvent (pack.wakeup);
	}
    }
}
@


1.427
log
@	* init.cc (dll_entry): Revert previous patch.  This requires another
	solution.
	* miscfuncs.cc (thread_wrapper): Ditto.
	* sigproc.cc (exit_thread): Disable sending a signal for synchronization
	with process exit.  Explain why.  Keep code in for later inspection,
	should the problem show up again.
	(sig_send): Use "tls", rather than "tid" as name for _cygtls arg.
@
text
@d611 5
a615 1
    pack.mask = tls ? &tls->sigmask : &_main_tls->sigmask;
d1266 1
d1269 1
d1271 1
d1286 10
a1295 5
	  *pack.mask = 0;
	  unsigned bit;
	  while ((q = q->next))
	    if (pack.sigtls->sigmask & (bit = SIGTOMASK (q->si.si_signo)))
	      *pack.mask |= bit;
@


1.426
log
@* sigproc.cc (sigproc_init): Set aside more buffer space for signal pipes.
(sig_send): Retry WriteFiles which fail when there is no error but packbytes
have not been sent.
@
text
@d454 8
d480 1
d485 1
a485 1
sig_send (_pinfo *p, int sig, _cygtls *tid)
d490 1
a490 1
  return sig_send (p, si, tid);
@


1.425
log
@* sigproc.cc (send_sig): Don't report an error if WriteFile succeeds.
@
text
@d429 1
a429 1
				     sizeof (sigpacket), "sigwait",
d638 13
a650 1
  if (!WriteFile (sendsig, leader, packsize, &nb, NULL))
@


1.424
log
@* sigproc.cc (send_sig): Fix bad format in diagnostic output.
@
text
@d638 1
a638 1
  if (!WriteFile (sendsig, leader, packsize, &nb, NULL) || nb != packsize)
@


1.423
log
@* sigproc.h (no_thread_exit_protect): New class.
* sigproc.cc (thread_exit): Use no_thread_exit_protect to determine if we need
to coordinate ThreadExit/ExitProcess.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::stop): Use
no_thread_exit_protect to kludge around waiting for waveOutClose as it waits
for a thread that never exits.
(fhandler_dev_dsp::Audio_in::stop): Ditto for waveInClose.
* fhandler.h (fhandler_dev_dsp::base): New method.
(fhandler_dev_dsp::_read): Ditto.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::read): Call real function via base()
pointer.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
(fhandler_dev_dsp::_read): Rename by adding an leading underscore.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
@
text
@d630 2
a631 1
      char *p = leader = (char *) alloca (sizeof (pack) + sizeof (n) + n);
a634 1
      packsize = p - leader;
d648 1
a648 1
	system_printf ("error sending signal %d, pipe handle %p, nb %u, packsize %u, %E",
@


1.422
log
@* sigproc.cc (_cygtls::remove_wq): Reset thread_ev inside of lock.  Set to NULL
when done.
@
text
@d42 2
d451 2
d472 1
a472 1
  ExitThread (0);
@


1.421
log
@* sigproc.cc (sig_send): Don't bother with an error message if we are exiting.
@
text
@d339 2
a348 1
      ForceCloseHandle1 (wq.thread_ev, wq_ev);
@


1.420
log
@* external.cc (fillout_pinfo): Remove nonsensical loop.
* fork.cc (frok::parent): When initializing pinfo for child new PID_NEW flag +
actual defined constant rather than raw number.  Don't set start_time here.
* pinfo.cc (pinfo::thisproc): Use PID_NEW when initializing pinfo.  Avoid
checking h for NULL multiple times.  Don't set start_time here.
(pinfo_init): Aways set ppid last.  Tweak strace output.
(pinfo::init): Handle new PID_NEW flag.  Wait for shared memory to contain
useful information.  Set start_time if PID_NEW.
(_onreturn:h): Define as HANDLE rather than HANDLE *.
(_onreturn::~onreturn): Accommodate h definition change.
(_onreturn::no_close_handle): Rename from no_close_p_handle.  Take a pinfo arg
and set hProcess to h before zeroing.
(winpids::add): Don't open a handle to our own process.  Change logic
associated with when a handle gets closed.  Accommodate no_close_handle
changes.
(winpids::enum_processes): Simplify process enumeration loop.
(winpids::set): Eliminate ill-considered malloc locking.
* sigproc.cc (proc_subproc): Always set ppid last.
@
text
@d642 3
a644 6
      else
	{
	  if (!p->exec_sendsig)
	    system_printf ("error sending signal %d to pid %d, pipe handle %p, %E",
			   si.si_signo, p->pid, sendsig);
	}
@


1.420.2.1
log
@* sigproc.cc (sig_send): Don't bother with an error message if we are exiting.
@
text
@d642 6
a647 3
      else if (!p->exec_sendsig && !exit_state)
	system_printf ("error sending signal %d, pipe handle %p, nb %u, packsize %u, %E",
		       si.si_signo, p->pid, sendsig, nb, packsize);
@


1.420.2.2
log
@* sigproc.cc (_cygtls::remove_wq): Reset thread_ev inside of lock.  Set to NULL
when done.
@
text
@a338 2
	  ForceCloseHandle1 (wq.thread_ev, wq_ev);
	  wq.thread_ev = NULL;
d347 1
@


1.420.2.3
log
@* sigproc.h (no_thread_exit_protect): New class.
* sigproc.cc (thread_exit): Use no_thread_exit_protect to determine if we need
to coordinate ThreadExit/ExitProcess.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::stop): Use
no_thread_exit_protect to kludge around waiting for waveOutClose as it waits
for a thread that never exits.
(fhandler_dev_dsp::Audio_in::stop): Ditto for waveInClose.
@
text
@a41 2
bool no_thread_exit_protect::flag;

a448 2
  if (no_thread_exit_protect ())
    ExitThread (res);
d468 1
a468 1
  ExitThread (res);
@


1.420.2.4
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d630 1
a630 2
      packsize = sizeof (pack) + sizeof (n) + n;
      char *p = leader = (char *) alloca (packsize);
d634 1
d648 1
a648 1
	system_printf ("error sending signal %d, pid %u, pipe handle %p, nb %u, packsize %u, %E",
@


1.420.2.5
log
@	* sigproc.cc (send_sig): Don't report an error if WriteFile succeeds.
@
text
@d638 1
a638 1
  if (!WriteFile (sendsig, leader, packsize, &nb, NULL))
@


1.420.2.6
log
@2014-07-16  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Handle stackaddr as upper bound address.
	Add comment.
	(pthread_attr_setstack): Store upper bound address in stackaddr.
	Explain why.
	(pthread_attr_getstack): Handle stackaddr as upper bound address.
	Add comment.
	(pthread_attr_setstackaddr): Add comment.
	(pthread_attr_getstackaddr): Add comment.
	(pthread_attr_getstacksize): Return default stacksize if stacksize has
	not been set by the application, just as on Linux.  Add comment.
	(pthread_getattr_np): Store upper bound address in stackaddr.  Explain
	why.
	* include/pthread.h: Remove outdated comment.
	(pthread_attr_getstackaddr): Mark as deprecated, as on Linux.
	(pthread_attr_setstackaddr): Ditto.

2014-07-15  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (sigproc_init): Set aside more buffer space for signal
	pipes.
	(sig_send): Retry WriteFiles which fail when there is no error but
	packbytes have not been sent.
@
text
@d429 1
a429 1
				     NSIG * sizeof (sigpacket), "sigwait",
d638 1
a638 13
  BOOL res;
  /* Try multiple times to send if packsize != nb since that probably
     means that the pipe buffer is full.  */
  for (int i = 0; i < 100; i++)
    {
      res = WriteFile (sendsig, leader, packsize, &nb, NULL);
      if (!res || packsize == nb)
	break;
      Sleep (10);
      res = 0;
    }

  if (!res)
@


1.419
log
@* sigproc.cc (sig_send): Set PIPE_NOWAIT for pipes which are not us.
@
text
@a209 1
	  vchild->ppid = what == PROC_DETACHED_CHILD ? 1 : myself->pid;
d217 1
@


1.418
log
@* globals.cc (hntdll): Define/declare.
* exceptions.cc (inside_kernel): Don't call GetModuleFileName if we know we're
in ntdll.
* sigproc.cc (wait_sig): Initialize hntdll.
@
text
@d556 10
a565 1
	CloseHandle (hp);
@


1.417
log
@* sigproc.cc (pending_signals::add): Properly maintain linked list.
(wait_sig): Use already calculated 'next' element when signal is blocked.
@
text
@d1208 2
@


1.416
log
@* DevNotes: Add entry cgf-000023.
* sigproc.cc (exit_thread): Remove now-unneeded sleep code.
@
text
@d1193 1
a1193 1
  se->next = NULL;
d1279 1
a1279 1
	default:
d1296 1
a1296 1
		    q = q->next;
@


1.415
log
@	* sigproc.cc (exit_thread): Allow to exit the thread while running
	global dtors.  Explain why.
@
text
@a449 15
  /* ES_EXIT_STARTING indicates that exit is in progress.  After setting
     exit_state to ES_EXIT_STARTING, the global dtors are running first,
     then the exit state is set to the next level in do_exit.  We must not
     block the thread exit while the global dtors are running, because
     one of them might have called pthread_join, which is perfectly valid
     for a global C++ destructor.
     FIXME: Do we need another state between ES_EXIT_STARTING and
            ES_SIGNAL_EXIT to narrow the gap in which the thread exit
	    is still valid? */
  if (exit_state > ES_EXIT_STARTING)
    {
      for_now.release ();
      Sleep (INFINITE);
    }

@


1.414
log
@* sigproc.cc (sig_hold): Delete.
(sigheld): Delete.
(sig_send): Eliminate special-case __SIGHOLD handling.
(wait_sig): Just flag when signals are on hold and add them to the queue rather
than stalling the wait_sig loop.  Clear the flag when __SIGNOHOLD is specified.
@
text
@d450 10
a459 1
  if (exit_state)
@


1.413
log
@	* Merge in cygwin-64bit-branch.
@
text
@a46 2
Static HANDLE sig_hold;			// Used to stop signal processing
Static bool sigheld;			// True if holding signals
a478 18
  if (sig == __SIGHOLD)
    sigheld = true;
  else if (!sigheld)
    /* nothing */;
  else if (sig == __SIGFLUSH || sig == __SIGFLUSHFAST)
    return 0;
  else if (sig == __SIGNOHOLD)
    {
      SetEvent (sig_hold);
      sigheld = false;
    }
  else if (&_my_tls == _main_tls)
    {
#ifdef DEBUGGING
      system_printf ("signal %d sent to %p while signals are on hold", sig, p);
#endif
      return -1;
    }
d1209 1
a1209 1
  sig_hold = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d1258 1
a1258 27
	  goto loop;
	  break;
	default:
	  if (pack.si.si_signo < 0)
	    sig_clear (-pack.si.si_signo);
	  else
	    sigq.add (pack);
	case __SIGNOHOLD:
	case __SIGFLUSH:
	case __SIGFLUSHFAST:
	  {
	    sigpacket *qnext;
	    /* Check the queue for signals.  There will always be at least one
	       thing on the queue if this was a valid signal.  */
	    while ((qnext = q->next))
	      {
		if (qnext->si.si_signo && qnext->process () <= 0)
		  q = q->next;
		else
		  {
		    q->next = qnext->next;
		    qnext->si.si_signo = 0;
		  }
	      }
	    if (pack.si.si_signo == SIGCHLD)
	      clearwait = true;
	  }
d1285 28
a1315 1
    loop:
a1320 2
      if (pack.si.si_signo == __SIGHOLD)
	WaitForSingleObject (sig_hold, INFINITE);
@


1.412
log
@* cygtls.h (_cygtls::reset_signal_arrived): Actually reset the signal_arrived
event.
(_cygtls::handle_SIGCONT): Declare ew function.
* cygwait.cc (is_cw_sig_handle): Delete.
(is_cw_sig_cont): New convenience define.
(cygwait): Clear signal if is_cw_sig_cont and we got a SIGCONT.
* cygwait.h (cw_wait_mask): Add cw_sig_cont.
* exceptions.cc (sig_handle_tty_stop): Tighten "incyg" region.  Use cw_sig_cont
param for cygwait.  Don't zero signal here outside of lock.
(sigpacket::setup_handler): Don't check for in_forkee since we will now never
get here in that state.
(_cygtls::handle_SIGCONT): Define new function.
(sigpacket::process): Call handle_SIGCONT early to deal with SIGCONT.  Nuke
continue_now handling.  Allow SIGKILL to kill a suspended process.  Delete a
couple of now-unneeded labels.
(_cygtls::call_signal_handler): Reorganize setting of incyg within lock.
* sigproc.cc (pending_signals): Simplify.
(pending_signals::clear): New method.
(_cygtls::remove_wq): Reorganize to always close wq.thread_ev if it exists to
avoid handle leaks.
(sig_clear): Simplify by just calling sigq.clear().
(sig_dispatch_pending): Always call sigq.pending even in signal thread to force
another loop in wait_sig.
(sig_send): Remove a "goto out" just before out: label.
(pending_signals::add): Simplify.
(pending_signals::del): Delete.
(pending_signals::next): Delete.
(wait_sig): Define variable q to be the start of the signal queue.  Just
iterate through sigq queue, deleting processed or zeroed signals.  Only set
clearwait when the current signal is SIGCHLD.
* sigproc.h: Add a comment about an unused enum.
@
text
@d174 1
a174 1
proc_subproc (DWORD what, DWORD val)
d994 1
a994 1
      sigproc_printf ("pid %u, WFMO returned %d, exit_code %p, res %d", pid, x,
d1005 1
a1005 1
  sigproc_printf ("exit_code %p", exit_code);
@


1.411
log
@* child_info.h (cygheap_exec_info::sigmask): Declare new field.
* cygheap.cc (init_cygheap::find_tls): Rename threadlist_ix -> ix.  Only take
one pass through thread list, looking for eligible threads to signal.  Set a
new param indicating that function has found a sigwait* mask.
* cygheap.h (init_cygheap::find_tls): Reflect new parameter.
* dcrt0.cc (parent_sigmask): New variable.
(child_info_spawn::handle_spawn): Save parent's signal mask here.
(dll_crt0_1): Restore parent's signal mask to tls sigmask as appropriate.  Call
sig_dispatch_pending to flush signal queue when we can finally do something
with signals.
* exceptions.cc (sigpacket::process): Avoid attempting to handle signals if we
haven't finished initializing.  Rely on the fact that find_tls will do mask
checking and don't do it again.  Delete ill-named 'dummy' variable.
* sigproc.cc (cygheap_exec_info::alloc): Save calling thread's signal mask in
new sigmask field.
(wait_sig): Try to debug when WFSO fails and DEBUGGING is defined.
* thread.cc (pthread::set_tls_self_pointer): Make this a true automatic method
rather than inexplicably relying on a thread parameter.
(pthread::thread_init_wrapper): Accommodate set_tls_self_pointer change to
non-static.  Initialize sigmask before setting tid or suffer signal races.
* ehread.h (pthread::set_tls_self_pointer): Make non-static, delete parameter.
@
text
@a75 3
  sigpacket *end;
  sigpacket *prev;
  sigpacket *curr;
d77 1
a78 1
  void reset () {curr = &start; prev = &start;}
a79 1
  void del ();
d81 1
a81 3
  sigpacket *next ();
  sigpacket *save () const {return curr;}
  void restore (sigpacket *saved) {curr = saved;}
d84 1
d336 1
a336 2
  if (exit_state < ES_FINAL && waitq_head.next && sync_proc_subproc
      && sync_proc_subproc.acquire (wait))
d338 12
a349 8
      for (waitq *w = &waitq_head; w->next != NULL; w = w->next)
	if (w->next == &wq)
	  {
	    ForceCloseHandle1 (wq.thread_ev, wq_ev);
	    w->next = wq.next;
	    break;
	  }
      sync_proc_subproc.release ();
d351 1
d394 1
a394 1
sig_clear (int target_sig)
d396 1
a396 15
  if (&_my_tls != _sig_tls)
    sig_send (myself, -target_sig);
  else
    {
      sigpacket *q;
      sigpacket *save = sigq.save ();
      sigq.reset ();
      while ((q = sigq.next ()))
	if (q->si.si_signo == target_sig)
	  {
	    q->si.si_signo = __SIGDELETE;
	    break;
	  }
      sigq.restore (save);
    }
a412 9
  if (&_my_tls == _sig_tls)
    {
#ifdef DEBUGGING
      sigproc_printf ("exit_state %d, cur thread id %p, _sig_tls %p, sigq.start.next %p",
		      exit_state, GetCurrentThreadId (), _sig_tls, sigq.start.next);
#endif
      return;
    }

d415 2
a416 4
     should catch it.
     FIXME: Eventually, wait_sig should wake up on its own to deal with pending
     signals. */
  if (sigq.pending ())
a704 1
  goto out;
d1208 2
d1214 1
d1220 1
a1220 31
  if (end)
    end->next = se;
  end = se;
  if (!start.next)
    start.next = se;
}

void
pending_signals::del ()
{
  sigpacket *next = curr->next;
  prev->next = next;
  curr->si.si_signo = 0;
#ifdef DEBUGGING
  curr->next = NULL;
#endif
  if (end == curr)
    end = prev;
  curr = next;
}

sigpacket *
pending_signals::next ()
{
  sigpacket *res;
  prev = curr;
  if (!curr || !(curr = curr->next))
    res = NULL;
  else
    res = curr;
  return res;
d1260 1
a1260 1
      sigpacket *q;
d1273 1
a1273 2
	  sigq.reset ();
	  while ((q = sigq.next ()))
d1288 17
a1304 9
	  sigq.reset ();
	  while ((q = sigq.next ()))
	    {
	      int sig = q->si.si_signo;
	      if (sig == __SIGDELETE || q->process () > 0)
		sigq.del ();
	      if (sig == SIGCHLD)
		clearwait = true;
	    }
@


1.410
log
@* sigproc.cc (wait_sig): Avoid uninitialized use of nb when retrying.
Consolidate two error messages into one.
@
text
@d838 6
a843 3
 return (cygheap_exec_info *) ccalloc_abort (HEAP_1_EXEC, 1,
					     sizeof (cygheap_exec_info)
					     + (nprocs * sizeof (children[0])));
a1242 1
  se->mask = &pack.sigtls->sigmask;
d1370 6
a1375 1
	      system_printf ("WaitForSingleObject(%p) for thread exit returned %u", h, res);
@


1.409
log
@* sigproc.cc (pending_signals::retry): Declare new element.
(pending_signals::pending): Force an additional loop through wait_sig by
setting retry whenever this function is called.
(sig_send): Reorganize to wait for SIGHOLD at bottom.  Always add signal to
pending queue and work on whole queue rather than just the one signal.  Loop
when sigq.retry is set.  Fix long-broken check for SIGCHLD after queued
signals.
@
text
@d1291 1
a1291 4
	{
	  sigq.retry = false;
	  pack.si.si_signo = __SIGFLUSH;
	}
d1293 2
a1294 9
	Sleep (INFINITE);	/* Never exit this thread */
      if (nb != sizeof (pack))
	{
	  system_printf ("short read from signal pipe: %d != %d", nb,
			 sizeof (pack));
	  continue;
	}

      if (!pack.si.si_signo)
d1296 1
a1296 3
#ifdef DEBUGGING
	  system_printf ("zero signal?");
#endif
d1300 1
@


1.408
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d79 1
d84 1
a84 1
  bool pending () const {return !!start.next;}
d631 2
a632 1
  sigproc_printf ("sendsig %p, pid %d, signal %d, its_me %d", sendsig, p->pid, si.si_signo, its_me);
d1236 2
a1237 1
  if (sigs[pack.si.si_signo].si.si_signo)
a1238 1
  se = sigs + pack.si.si_signo;
a1285 2
  sigpacket pack;
  pack.si.si_signo = 0;
a1287 3
      if (pack.si.si_signo == __SIGHOLD)
	WaitForSingleObject (sig_hold, INFINITE);

d1289 8
a1296 4
      pack.sigtls = NULL;
      if (!ReadFile (my_readsig, &pack, sizeof (pack), &nb, NULL))
	break;

d1344 5
d1358 1
a1358 1
	      if (sig == __SIGNOHOLD && q->si.si_signo == SIGCHLD)
a1381 27
	default:
	  if (pack.si.si_signo < 0)
	    sig_clear (-pack.si.si_signo);
	  else
	    {
	      int sig = pack.si.si_signo;
	      // FIXME: REALLY not right when taking threads into consideration.
	      // We need a per-thread queue since each thread can have its own
	      // list of blocked signals.  CGF 2005-08-24
	      if (sigq.sigs[sig].si.si_signo && sigq.sigs[sig].sigtls == pack.sigtls)
		sigproc_printf ("signal %d already queued", pack.si.si_signo);
	      else
		{
		  int sigres = pack.process ();
		  if (sigres <= 0)
		    {
#ifdef DEBUGGING2
		      if (!sigres)
			system_printf ("Failed to arm signal %d from pid %d", pack.si.si_signo, pack.pid);
#endif
		      sigq.add (pack);	// FIXME: Shouldn't add this in !sh condition
		    }
		}
	      if (sig == SIGCHLD)
		clearwait = true;
	    }
	  break;
d1391 2
@


1.407
log
@* sigproc.cc (sig_dispatch_pending): Add correct regparm attributes to match
declaration.
(pid_exists): Ditto.
(proc_subproc): Ditto.
(sig_clear): Ditto.
(sig_send): Ditto.
(checkstate): Ditto.
@
text
@d64 1
a64 1
static int __stdcall checkstate (waitq *) __attribute__ ((regparm (1)));
d87 1
a87 1
  friend void __stdcall sig_dispatch_pending (bool) __attribute__ ((regparm (1)));;
d159 1
a159 1
bool __stdcall __attribute__ ((regparm(1)))
d177 1
a177 1
int __stdcall __attribute__ ((regparm (2)))
d393 1
a393 1
void __stdcall __attribute__ ((regparm (1)))
d424 1
a424 1
void __stdcall __attribute__ ((regparm (1)))
d503 1
a503 1
int __stdcall __attribute__ ((regparm (3)))
d534 1
a534 1
int __stdcall __attribute__ ((regparm (3)))
d1084 1
a1084 1
static int __stdcall __attribute__ ((regparm (1)))
@


1.406
log
@* exceptions.cc (ctrl_c_handler): Remove special-case handler for
"cygwin_finished_initializing".
* sigproc.cc (exit_thread): Undefine ExitThread earlier to avoid recursion on
error return.
@
text
@d87 1
a87 1
  friend void __stdcall sig_dispatch_pending (bool);
d159 1
a159 1
bool __stdcall
d177 1
a177 1
int __stdcall
d393 1
a393 1
void __stdcall
d424 1
a424 1
void __stdcall
d503 1
a503 1
int __stdcall
d534 1
a534 1
int __stdcall
d1084 1
a1084 1
static int __stdcall
@


1.405
log
@* sigproc.cc (no_signals_available): Finally remove this macro entirely.
(exit_thread): Ensure process lock is released on error exit.
(sig_send): Simplify "its_me" test.  Remove no_signals_available tests.
@
text
@d474 1
a499 1
# undef ExitThread
@


1.404
log
@* exceptions.cc (signal_exit): Move captive process termintation...
(_cygtls::interrupt_setup): ...into here.
(sigpacket::process): Simplify setting of handler when have_execed.
(_cygtls::interrupt_setup): Don't call proc_subproc when we've execed.
* globals.cc (exit_states): Delete unneeded ES_EXEC_EXIT.
* pinfo.cc (pinfo::exit): Change debugging output.  Call proc_terminate rather
than the now-obsolete sigproc_terminate.  Don't set exit_state to ES_EXEC_EXIT.
Set exit_state to ES_FINAL later.
* sigproc.cc (sigproc_terminate): Delete function.
(wait_sig): Don't call proc_subproc if have_execed.
* sigproc.h (sigproc_terminate): Delete declaration.
* sync.h (lock_process::lock_process): Don't set exit_state to
ES_PROCESS_LOCKED.
(lock_process::operator LONG): Define.
@
text
@a33 2
#define no_signals_available() ((myself->exitcode & EXITCODE_SET) || (&_my_tls == _sig_tls))

d490 1
d545 1
a545 1
  if (!(its_me = (!have_execed && (p == NULL || p == myself || p == myself_nowait))))
a559 5
      if (no_signals_available ())
	{
	  set_errno (EAGAIN);
	  goto out;		// Either exiting or not yet initializing
	}
d685 1
a685 3
	  if (no_signals_available ())
	    sigproc_printf ("I'm going away now");
	  else if (!p->exec_sendsig)
a722 3
      if (!no_signals_available ())
	system_printf ("wait for sig_complete event failed, signal %d, rc %d, %E",
		       si.si_signo, rc);
@


1.403
log
@* globals.cc (exit_states): Renumber so that ES_EXIT_STARTING is first, as
intended.
* sigproc.cc (wait_sig): Only stop accepting signals after exit_state >
ES_EXIT_STARTING.
@
text
@a469 15
/* Called on process termination to terminate signal and process threads.
 */
void __stdcall
sigproc_terminate (exit_states es)
{
  exit_states prior_exit_state = exit_state;
  exit_state = es;
  if (!cygwin_finished_initializing)
    /* nothing to do */;
  else if (prior_exit_state >= ES_FINAL)
    sigproc_printf ("already performed");
  else
    proc_terminate ();		// clean up process stuff
}

d1415 1
a1415 1
      if (clearwait)
@


1.402
log
@* sigproc.cc (exit_thread): Set thread signal mask so that no signals are sent
to an exiting thread.
@
text
@d1338 1
a1338 1
      if (exit_state && pack.si.si_signo > 0)
@


1.401
log
@* sigproc.cc (no_signals_available): Remove exit_state test since signals are
available in a limited fashion when exiting.
(sig_dispatch_pending): Ditto.
(sig_send): Ditto.
(exit_thread): Rearrange to avoid an unnecessary DuplicateProcess when exiting.
(wait_sig): Allow special signals when exiting.
@
text
@d491 2
a492 1
  lock_process for_now;		/* May block indefinitely if we're exiting. */
@


1.400
log
@* cygtls.h (_cygtls::signal_exit): Delete from class.
* exception.h (cygwin_exception): New class.
(cygwin_exception::dumpstack): Declare new function.
(cygwin_exception::context): Ditto.
(cygwin_exception::dump_exception): Ditto.
* exceptions.cc (cygwin_exception::dump_exception): Move into cygwin_exception
class.  Accommodate new variable names.
(cygwin_exception::dumpstack): Ditto stackdump -> dumpstack.
(exception::handle): Move andreas processing earlier.  Defer signal processing
decisions to the signal thread where they belong.  Pass exception information
to sig_send via new siginfo_t si_cyg field.
(ctrl_c_handler): Wait for SIGHUP signal to be processed since it could cause a
process exit and we don't want races with thread exit lock.
(signal_exit): Move back here from sigproc.cc.  Modify arguments and remove
from sigpacket class.  Decide when to dump core based on signal type.
(sigpacket::process): Handle exiting signals in context of threads rather than
in the signal thread.  Signal debugger on non-Windows signals.  Remove
setup_signal_exit call.
* sigproc.cc (no_signals_available): Remove argument.
(signal_exit_code): Delete.
(close_my_readsig): Ditto.
(_cygtls::signal_exit): Move to exceptions.cc.
(sigproc_terminate): Don't attempt to terminate signal thread.
(setup_signal_exit): Delete.
(exit_thread): Use new si_cyg entry in siginfo_t.
(sig_send): Just use empty initializer for si.  Accommodate change in
no_signals_available argument.
(wait_sig): Remove attempt to "go asynchronous" on process exit.  Delete
__SIGEXIT handling.  Don't ever exit.
* sigproc.h: Remove __SIGEXIT from signal enum.  Renumber.
* include/cygwin/signal.h (siginfo_t): Add si_cyg entry.
@
text
@d34 1
a34 1
#define no_signals_available() (exit_state || (myself->exitcode & EXITCODE_SET) || (&_my_tls == _sig_tls))
d429 1
a429 1
  if (exit_state || &_my_tls == _sig_tls)
d491 7
a498 3

# undef ExitThread

d509 2
a512 9
  lock_process for_now;		/* May block indefinitely if we're exiting. */
  if (exit_state)
    {
      for_now.release ();
      Sleep (INFINITE);
    }

  /* Tell wait_sig to wait for this thread to exit.  It can then release
     the lock below and close the above-opened handle. */
d514 1
d580 1
a580 1
      wait_for_completion = p != myself_nowait && _my_tls.isinitialized () && !exit_state;
d1337 1
a1337 1
      if (exit_state && pack.si.si_signo)
@


1.399
log
@* sigproc.cc (wait_sig): Remove spurious extern.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d34 1
a34 1
#define no_signals_available(x) (!my_sendsig || ((x) && myself->exitcode & EXITCODE_SET) || (&_my_tls == _sig_tls))
a63 1
Static int signal_exit_code;
a355 47
inline void
close_my_readsig ()
{
  HANDLE h;
  if ((h = InterlockedExchangePointer (&my_readsig, NULL)))
    ForceCloseHandle1 (h, my_readsig);
}

/* Exit due to a signal, even in presence of more exceptions.  We used to just
   call exit, but a SIGSEGV shouldn't cause atexit routines to run.
   Should only be called from the signal thread.  */
void
_cygtls::signal_exit (int rc)
{
  signal_debugger (rc & 0x7f);

  if (rc == SIGQUIT || rc == SIGABRT)
    {
      CONTEXT c;
      c.ContextFlags = CONTEXT_FULL;
      GetThreadContext (hMainThread, &c);
      copy_context (&c);
      if (cygheap->rlim_core > 0UL)
	rc |= 0x80;
    }

  if (have_execed)
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (ch_spawn, sigExeced = rc);
    }

  if ((rc & 0x80) && !try_to_debug ())
    stackdump (thread_context.ebp, true);

  lock_process until_exit (true);
  if (have_execed || exit_state > ES_PROCESS_LOCKED)
    myself.exit (rc);

  /* Starve other threads in a vain attempt to stop them from doing something
     stupid. */
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL);

  sigproc_printf ("about to call do_exit (%x)", rc);
  do_exit (rc);
}

d478 1
a478 1
    sigproc_printf ("don't worry about signal thread");
d482 1
a482 26
    {
      sigproc_printf ("entering");
      sig_send (myself_nowait, __SIGEXIT);
      proc_terminate ();		// clean up process stuff
    }
}

/* Set up stuff so that the signal thread will know that we are
   exiting due to a signal.  */
void
setup_signal_exit (int sig)
{
  signal_exit_code = sig;	/* Tell wait_sig() that we are exiting. */
  exit_state = ES_SIGNAL_EXIT;	/* Tell the rest of the world that we are exiting. */

  if (&_my_tls != _sig_tls)
    {
      sigpacket sp = {};
      sp.si.si_signo = __SIGEXIT;
      DWORD len;
      /* Write a packet to the wait_sig thread.  It will eventuall cause
	 the process to exit too.  So just wait for that to happen after
	 sending the packet. */
      WriteFile (my_sendsig, &sp, sizeof (sp), &len, NULL);
      Sleep (INFINITE);
    }
d506 1
a506 1
  si.si_value.sival_ptr = h;
d529 1
a529 1
  else if (sig == __SIGNOHOLD || sig == __SIGEXIT)
d541 1
a541 1
  siginfo_t si = {0};
a543 1
  si.si_pid = si.si_uid = si.si_errno = 0;
d577 1
a577 1
      if (no_signals_available (si.si_signo != __SIGEXIT))
d707 1
a707 1
	  if (no_signals_available (true))
d747 1
a747 1
      if (!no_signals_available (true))
a1318 6
      /* If signal_exit_code is set then we are shutting down due to a signal.
	 We'll exit this loop iff there is nothing more in the signal queue.  */
      if (signal_exit_code
	  && (!PeekNamedPipe (my_readsig, NULL, 0, NULL, &nb, NULL) || !nb))
	break;

d1338 3
a1340 2
      if (signal_exit_code && pack.si.si_signo > 0)
	continue;		/* No more real signals allowed */
a1382 4
	case __SIGEXIT:
	  my_sendsig = NULL;
	  sigproc_printf ("saw __SIGEXIT");
	  break;	/* handle below */
d1395 1
a1395 1
	    HANDLE h = (HANDLE) pack.si.si_value.sival_ptr;
a1438 2
      if (pack.si.si_signo == __SIGEXIT)
	break;
a1439 13

  sigproc_printf ("signal thread exiting");

  my_sendsig = NULL;		/* Make no_signals_allowed return true */
  close_my_readsig ();		/* Cause any sig_send's to stop */

  if (signal_exit_code)
    _my_tls.signal_exit (signal_exit_code);

  /* Just wait for the process to go away.  Otherwise, this thread's
     exit value could be interpreted as the process exit value.
     See cgf-000017 in DevNotes for more details.  */
  Sleep (INFINITE);
@


1.398
log
@* DevNotes: Add entry cgf-000019.
* dcrt0.cc (do_exit): Just set exit_state to ES_EVENTS_TERMINATE and nuke call
to events_terminate which just set a superfluous flag.
* sigproc.cc (signal_exit_code): New variable.
(setup_signal_exit): Define new function.
(_cygtls::signal_exit): Remove accommodations for closing the signal pipe
handle.
(exit_thread): Just sleep if we're exiting.
(wait_sig): If signal_exit_code is set, just handle bookkeeping signals and
exit ReadFile loop if there is nothing more to process.  Call signal_exit at
end if signal_exit_code is non-zero.
* sigproc.h (setup_signal_exit): Declare new function.
* exceptions.cc (sigpacket::process): Use setup_signal_exit to control exiting
due to a signal.
(exception::handle): Ditto.  Query exit_state rather than defunct exit_already
to determine if we are exiting.
* globals.cc (ES_SIGNAL_EXIT): New enum.
* sync.h (lock_process::release): New function for explicitly unlocking muto.
(lock_process::~lock_process): Use release method.
@
text
@a1378 1
  extern int signal_exit_code;
@


1.397
log
@* sigproc.cc (exit_thread): undef ExitThread or suffer recursion.  Attempt to
lock process prior to calling sig_send.
@
text
@d64 1
d365 3
a367 3
/* Cover function to `do_exit' to handle exiting even in presence of more
   exceptions.  We used to call exit, but a SIGSEGV shouldn't cause atexit
   routines to run.  */
a370 20
  HANDLE myss = my_sendsig;
  my_sendsig = NULL;		 /* Make no_signals_allowed return true */

  /* This code used to try to always close my_readsig but it ended up
     blocking for reasons that people in google think make sense.
     It's possible that it was blocking because ReadFile was still active
     but it isn't clear why this only caused random hangs rather than
     consistent hangs.  So, for now at least, avoid closing my_readsig
     unless this is the signal thread.  */
  if (&_my_tls == _sig_tls)
    close_my_readsig ();	/* Stop any currently executing sig_sends */
  else
    {
      sigpacket sp = {};
      sp.si.si_signo = __SIGEXIT;
      DWORD len;
      /* Write a packet to the wait_sig thread which tells it to exit and
	 close my_readsig.  */
      WriteFile (myss, &sp, sizeof (sp), &len, NULL);
    }
d537 21
d581 6
d590 1
a590 1
  ExitThread (0);		/* Should never hit this */
d1379 1
d1392 1
d1394 6
d1419 3
a1526 1
  close_my_readsig ();
d1528 7
@


1.396
log
@Revert the reversion and go with implementation described in cgf-000017, with
some modifications.
* init.cc (dll_entry): Revert previous change.
* miscfuncs.cc: Include sigproc.h for exit_thread declaration.
* winsup.h (ExitThread): Define as 'exit_thread' to ensure no accidental use.
* sigproc.cc (exit_thread): New function.
(wait_sig): Handle __SIGTHREADEXIT case.  Don't just block rather than
returning from this function.
* sigproc.h (__SIGTHREADEXIT): New enum.
(exit_thread): Declare.
* sync.cc (muto::release): Accept a tls command-line argument.
* sync.h (muto::release): Accept a tls command-line parameter.  Default to
&_my_tls.
* cygerrno.h (__set_errno): Define as extern so that no function code is ever
emitted.
* cygserver_ipc.h (cygserver_ipc.h): Ditto.
* miscfuncs.h (transform_chars): Ditto.
* path.h (has_attribute): Ditto.
* security.h (privilege_luid): Ditto.
* winsup.h (flush_file_buffers): Ditto.
@
text
@d564 2
d578 1
d582 1
a582 2
  lock_process for_now;
  ExitThread (0);	/* Should never hit this */
@


1.395
log
@* DevNotes: Add entry cgf-000018.
* init.cc (dll_entry): Grab process lock before exiting to ensure that thread
doesn't exit before parent if parent is exiting.
* _cygtls.cc (_cygtls::call2): Revert previous 2012-12-21 change.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
* sigproc.cc (exit_thread): Ditto.
(wait_sig): Ditto.
* sync.cc (muto::release): Ditto.
* sync.h (muto::release): Ditto.
* sigproc.h (__SIGTHREADEXIT): Delete enum.
(exit_thread): Delete declaration.
@
text
@d556 27
d1449 17
d1508 4
a1511 1
  ExitThread (0);
@


1.394
log
@* DevNotes: Add entry cgf-000017.
* _cygtls.cc (_cygtls::call2): Use new exit_thread function in place of
ExitThread.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
(pthread_mutex::unlock): Set tid to NULL rather than 0.
(pthread_spinlock::unlock): Ditto.
* pinfo.cc (commune_process): Actually call lock_process constructor.
* sigproc.cc (exit_thread): New function.
(wait_sig): Handle __SIGTHREADEXIT case.  Don't just block rather than
returning from this function.
* sigproc.h (__SIGTHREADEXIT): New enum.
(exit_thread): Declare.
* sync.cc (muto::release): Accept a tls command-line argument.
* sync.h (muto::release): Accept a tls command-line parameter.  Default to
&_my_tls.
@
text
@a555 27
/* Exit the current thread very carefully.
   See cgf-000017 in DevNotes for more details on why this is
   necessary.  */
void
exit_thread (DWORD res)
{
  HANDLE h;

  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
                        GetCurrentProcess (), &h,
                        0, FALSE, DUPLICATE_SAME_ACCESS))
    {
#ifdef DEBUGGING
      system_printf ("couldn't duplicate the current thread, %E");
#endif
      ExitThread (res);
    }
  ProtectHandle1 (h, exit_thread);
  siginfo_t si = {__SIGTHREADEXIT, SI_KERNEL};
  si.si_value.sival_ptr = h;
  /* Tell wait_sig to wait for this thread to exit.  It can then release
     the lock below and close the above-opened handle. */
  sig_send (myself_nowait, si, &_my_tls);
  lock_process for_now;
  ExitThread (0);	/* Should never hit this */
}

a1421 17
	case __SIGTHREADEXIT:
	  {
	    /* Serialize thread exit as the thread exit code can be interpreted
	       as the process exit code in some cases when racing with
	       ExitProcess/TerminateProcess.
	       So, wait for the thread which sent this signal to exit, then
	       release the process lock which it held and close it's handle.
	       See cgf-000017 in DevNotes for more details.
	       */
	    HANDLE h = (HANDLE) pack.si.si_value.sival_ptr;
	    DWORD res = WaitForSingleObject (h, 5000);
	    lock_process::force_release (pack.sigtls);
	    ForceCloseHandle1 (h, exit_thread);
	    if (res != WAIT_OBJECT_0)
	      system_printf ("WaitForSingleObject(%p) for thread exit returned %u", h, res);
	  }
	  break;
d1464 1
a1464 4
  /* Just wait for the process to go away.  Otherwise, this thread's
     exit value could be interpreted as the process exit value.
     See cgf-000017 in DevNotes for more details.  */
  Sleep (INFINITE);
@


1.393
log
@* sigproc.h (sig_send): Accept tid as argument #3.  Default to NULL.
* sigproc.cc (sig_send): Ditto.  Pass tid to other sig_send.
(sigpending): Send current thread as arg #3.
@
text
@d556 27
d1449 17
d1508 4
a1511 1
  ExitThread (0);
@


1.392
log
@* sigproc.h (sigpacket): Remove parameter names from declarations.
(sigpacket::sigtls): Rename from 'tls'.
* exceptions.cc (sigpacket::process): Define local tls variable and assign that
to sigtls if appropriate.  Clarify debugging output.
* sigproc.cc (sig_send): Accommodate tls -> sigtls rename.
(pending_signals::add): Ditto.
(wait_sig): Ditto.
@
text
@d485 1
a485 1
  sigset_t outset = (sigset_t) sig_send (myself, __SIGPENDING);
d557 1
a557 1
sig_send (_pinfo *p, int sig)
d581 1
a581 1
  return sig_send (p, si);
@


1.391
log
@	* child_info.h (class child_info_spawn): Drop unused member lock.
	(CURR_CHILD_INFO_MAGIC): Update.
	* sigproc.cc (child_info_spawn::child_info_spawn): Drop setting lock.
@
text
@d707 1
a707 1
  pack.tls = tls;
d1302 1
a1302 1
  se->mask = &pack.tls->sigmask;
d1355 1
a1355 1
      pack.tls = NULL;
d1396 1
a1396 1
	    if (pack.tls->sigmask & (bit = SIGTOMASK (q->si.si_signo)))
d1431 1
a1431 1
	      if (sigq.sigs[sig].si.si_signo && sigq.sigs[sig].tls == pack.tls)
@


1.390
log
@	* sigproc.cc (proc_subproc): Delete unused variable child.
@
text
@a892 1
      lock = &sync_proc_subproc;
@


1.389
log
@* fhandler_termios.cc (fhandler_termios::line_edit): Don't do special character
handling when stopped by CTRL-S.
* fhandler_tty.cc (bytes_available): Add arguments to debug_only_printf call.
* sigproc.cc (proc_subproc): Simplify some if logic.
@
text
@a183 1
  _pinfo *child;
@


1.388
log
@* cygwait.cc (cancelable_wait): Add some debugging-only output.
* exceptions.cc (sig_handle_tty_stop): Make sure that incyg is cleared when
exiting if we have no parent process.  Only wait for signal_arrived.
(sigpacket::process): Make continue_now a bool.  Delay sending signal_arrived
until the end.  Make code more defensive to avoid calling signal handler when
stopped.  Only set signal_arrived when stopped.
* sigproc.cc (sig_hold): Rename from sigCONT.  Make static.
(sig_send): Accommodate sigCONT -> sig_hold rename.
(wait_sig): Ditto.
* sigproc.h (sigCONT): Delete declaration.
* fhandler_console.cc (fhandler_console::write): Use new '%0c' facility to
print characters.  Change to paranoid to avoid excessive strace output.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Make frequent strace
printf "paranoid" to help cut down on strace output size.
* signal.cc (sigsuspend): Add standard syscall strace output.
(sigpause): Ditto.
(pause): Ditto.
* cygtls.h (_cygtls::reset_signal_arrived): New function.
@
text
@d250 1
a250 3
      if (wval->pid == -1 || !wval->pid)
	child = NULL;		// Not looking for a specific pid
      else if (!mychild (wval->pid))
@


1.388.2.1
log
@	* cygtls.h (__stack_t): Define as uintptr_t.
	* dcrt0.cc (child_info_fork::alloc_stack): Conditionalize assembler
	code on a per-CPU base.  Rename esp to stackp.
	(get_cygwin_startup_info): Cast pointers to uintptr_t in
	multiple_cygwin_problem call.  Minor formatting change.
	(_dll_crt0): Conditionalize assembler code on a per-CPU base.
	(multiple_cygwin_problem): Change parameters from unsigned to uintptr_t.
	* winsup.h (multiple_cygwin_problem): Change declaration accordingly.
	* pinfo.h (pinfo::reattach): Cast 2nd argument in proc_subproc call
	to uintptr_t.
	(pinfo::remember): Ditto.
	* sigproc.cc (proc_subproc): Change 2nd parameter to uintptr_t to allow
	pointer values.
	* sigproc.h (proc_subproc): Change declaration accordingly.
	* include/sys/cygwin.h (per_process_overwrite): Use offsetof to compute
	value.
@
text
@d180 1
a180 1
proc_subproc (DWORD what, uintptr_t val)
@


1.388.2.2
log
@	* exception.h (stackdump): Change first parameter to PUINT_PTR.
	* exceptions.cc: Define cpu specific macros _GR, _AFMT and _ADDR.
	Use throughout to avoid ifdef's.  Fix debug printfs to work in
	64 bit mode as well, throughout.
	(status_info): Define member code as NTSTATUS.  Add casts where
	necessary throughout.
	(dump_exception): Dump all x86_64 registers if building for it.
	(class stack_info): Define dummy_frame as PUINT_PTR.
	(stack_info::init): Change first parameter to PUINT_PTR.  Rename
	ebp to framep for CPU independent naming.  Drop debp macro.
	(stack_info::walk): Rename ebp to framep for CPU independent naming.
	Disable WOW64 hack in 64 bit mode.
	(stackdump): Change first parameter to PUINT_PTR.  Rename ebp to framep
	for CPU independent naming.
	(_cygtls::inside_kernel): Ignore system_wow64_directory on 64 bit.
	(rtl_unwind): Redefine for x86_64 cpu.
	(_except_list): Drop redundant definition.
	(_cygtls::copy_context): Just use __COPY_CONTEXT_SIZE.
	* sigproc.cc (_cygtls::signal_exit): Conditionalize stackdump call per
	cpu.
	* smallprint.cc (__small_vsprintf): Fix up for 64 bit.  Handle 'l' size
	modifier in 'd', 'o', 'u', 'x' conversion to print "long" values on a
	per cpu base.  Add 'O' conversion.  Change comment accrdingly.
	* include/cygwin/signal.h (struct _uc_fpxreg): Define for 64 bit.
	(struct _uc_xmmreg): Ditto.
	(struct _fpstate): Ditto.
	(struct ucontext): Ditto.
	(struct _uc_fpreg): Define for 32 bit.
	(struct _fpstate): Use struct _uc_fpreg for _st.  Use explicit sized
	types.
	(struct ucontext): Use explicit sized types.
	(__COPY_CONTEXT_SIZE): Cast safely.
	(sigset_t): Define as __uint64_t on 64 bit.  Add FIXME comment in 32
	bit case.
@
text
@d412 1
a412 5
#ifdef __x86_64__
    stackdump ((PUINT_PTR) thread_context.rbp, true);
#else
    stackdump ((PUINT_PTR) thread_context.ebp, true);
#endif
@


1.388.2.3
log
@	* tty.h (class tty): Store from_master and to_master HANDLEs in
	unions to make sure the storage is 64 bit compatible.  Add comment to
	explain why.
	(from_master): Convert to read accessor method.
	(to_master): Ditto.
	(set_from_master): New method to store HANDLE value 64 bit clean.
	(set_to_master): Ditto.
	* fhandler_tty.cc: Fix debug printfs to work in 64 bit mode as well.
	Change usage of from_master and to_master throughout to accommodate
	aforementioned change.
	* fhandler_termios.cc (fhandler_termios::ioctl): Add cast to avoid
	compiler warning.

	Pull in changes from HEAD.
@
text
@d184 1
d250 3
a252 1
      if (wval->pid != -1 && wval->pid && !mychild (wval->pid))
@


1.388.2.4
log
@	* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
	(class child_info_spawn): Drop unused member lock.
	* sigproc.cc (child_info_spawn::child_info_spawn): Don't set lock.

	* winlean.h (_TYPE64): Define.
	* cygserver_ipc.h (struct proc): Rearrange to use same structure on
	32 and 64 bit.  Add member is_64bit.
	(ipc_set_proc_info): Change accordingly.
@
text
@d897 1
@


1.388.2.5
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d1084 1
a1084 1
      sigproc_printf ("pid %u, WFMO returned %d, exit_code %y, res %d", pid, x,
d1095 1
a1095 1
  sigproc_printf ("exit_code %y", exit_code);
d1365 1
a1365 1
	  system_printf ("short read from signal pipe: %u != %lu", nb,
@


1.388.2.6
log
@Pull in changes from HEAD
@
text
@d711 1
a711 1
  pack.sigtls = tls;
d1306 1
a1306 1
  se->mask = &pack.sigtls->sigmask;
d1359 1
a1359 1
      pack.sigtls = NULL;
d1400 1
a1400 1
	    if (pack.sigtls->sigmask & (bit = SIGTOMASK (q->si.si_signo)))
d1435 1
a1435 1
	      if (sigq.sigs[sig].si.si_signo && sigq.sigs[sig].sigtls == pack.sigtls)
@


1.388.2.7
log
@Pull in changes from HEAD
@
text
@d489 1
a489 1
  sigset_t outset = (sigset_t) sig_send (myself, __SIGPENDING, &_my_tls);
d561 1
a561 1
sig_send (_pinfo *p, int sig, _cygtls *tid)
d585 1
a585 1
  return sig_send (p, si, tid);
@


1.388.2.8
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d34 1
a34 1
#define no_signals_available() ((myself->exitcode & EXITCODE_SET) || (&_my_tls == _sig_tls))
d356 71
d500 1
a500 1
  if (&_my_tls == _sig_tls)
d549 1
a549 1
    /* nothing to do */;
a552 12
    proc_terminate ();		// clean up process stuff
}

/* Exit the current thread very carefully.
   See cgf-000017 in DevNotes for more details on why this is
   necessary.  */
void
exit_thread (DWORD res)
{
  sigfillset (&_my_tls.sigmask);	/* No signals wanted */
  lock_process for_now;			/* May block indefinitely when exiting. */
  if (exit_state)
d554 3
a556 2
      for_now.release ();
      Sleep (INFINITE);
a557 19

  HANDLE h;
  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
                        GetCurrentProcess (), &h,
                        0, FALSE, DUPLICATE_SAME_ACCESS))
    {
#ifdef DEBUGGING
      system_printf ("couldn't duplicate the current thread, %E");
#endif
      ExitThread (res);
    }
  ProtectHandle1 (h, exit_thread);
  /* Tell wait_sig to wait for this thread to exit.  It can then release
     the lock below and close the above-opened handle. */
  siginfo_t si = {__SIGTHREADEXIT, SI_KERNEL};
  si.si_cyg = h;
  sig_send (myself_nowait, si, &_my_tls);
# undef ExitThread
  ExitThread (0);
d569 1
a569 1
  else if (sig == __SIGNOHOLD)
d581 1
a581 1
  siginfo_t si = {};
d584 1
d618 1
a618 1
      if (no_signals_available ())
d623 1
a623 1
      wait_for_completion = p != myself_nowait;
d748 1
a748 1
	  if (no_signals_available ())
d788 1
a788 1
      if (!no_signals_available ())
a1357 1

a1377 4
      /* Don't process signals when we start exiting */
      if (exit_state > ES_EXIT_STARTING && pack.si.si_signo > 0)
	continue;

d1419 4
a1425 17
	case __SIGTHREADEXIT:
	  {
	    /* Serialize thread exit as the thread exit code can be interpreted
	       as the process exit code in some cases when racing with
	       ExitProcess/TerminateProcess.
	       So, wait for the thread which sent this signal to exit, then
	       release the process lock which it held and close it's handle.
	       See cgf-000017 in DevNotes for more details.
	       */
	    HANDLE h = (HANDLE) pack.si.si_cyg;
	    DWORD res = WaitForSingleObject (h, 5000);
	    lock_process::force_release (pack.sigtls);
	    ForceCloseHandle1 (h, exit_thread);
	    if (res != WAIT_OBJECT_0)
	      system_printf ("WaitForSingleObject(%p) for thread exit returned %u", h, res);
	  }
	  break;
d1462 2
d1465 4
@


1.388.2.9
log
@Pull in changes from HEAD
@
text
@d470 15
d1430 1
a1430 1
      if (clearwait && !have_execed)
@


1.388.2.10
log
@Pull in changes from HEAD
@
text
@d34 2
a491 1
      for_now.release ();
d546 1
a546 1
  if (!(its_me = p == NULL || p == myself || p == myself_nowait))
d561 5
d691 3
a693 1
	  if (!p->exec_sendsig)
d731 3
@


1.388.2.11
log
@Pull in changes from HEAD
@
text
@a473 1
# undef ExitThread
d499 1
@


1.388.2.12
log
@Pull in changes from HEAD
@
text
@d64 1
a64 1
static int __reg1 checkstate (waitq *);
d87 1
a87 1
  friend void __reg1 sig_dispatch_pending (bool);;
d159 1
a159 1
bool __reg1
d177 1
a177 1
int __reg2
d393 1
a393 1
void __reg1
d424 1
a424 1
void __reg1
d503 1
a503 1
int __reg3
d534 1
a534 1
int __reg3
d1084 1
a1084 1
static int __reg1
@


1.388.2.13
log
@Pull in changes from HEAD
@
text
@a78 1
  bool retry;
d83 1
a83 1
  bool pending () {retry = true; return !!start.next;}
d630 1
a630 2
  sigproc_printf ("sendsig %p, pid %d, signal %d, its_me %d", sendsig, p->pid,
		  si.si_signo, its_me);
d1234 2
a1236 2
  if (se->si.si_signo)
    return;
d1284 2
d1288 3
d1292 4
a1295 8
      sigpacket pack = {};
      if (sigq.retry)
	{
	  sigq.retry = false;
	  pack.si.si_signo = __SIGFLUSH;
	}
      else if (!ReadFile (my_readsig, &pack, sizeof (pack), &nb, NULL))
	Sleep (INFINITE);	/* Never exit this thread */
a1342 5
	default:
	  if (pack.si.si_signo < 0)
	    sig_clear (-pack.si.si_signo);
	  else
	    sigq.add (pack);
d1352 1
a1352 1
	      if (sig == SIGCHLD)
d1376 27
a1411 2
      if (pack.si.si_signo == __SIGHOLD)
	WaitForSingleObject (sig_hold, INFINITE);
@


1.388.2.14
log
@Pull in changes from HEAD
@
text
@d1291 4
a1294 1
	pack.si.si_signo = __SIGFLUSH;
d1296 9
a1304 2
	Sleep (INFINITE);	/* Assume were exiting.  Never exit this thread */
      else if (nb != sizeof (pack) || !pack.si.si_signo)
d1306 3
a1308 1
	  system_printf ("garbled signal pipe data nb %u, sig %d", nb, pack.si.si_signo);
a1311 1
      sigq.retry = false;
@


1.388.2.15
log
@Pull in changes from HEAD
@
text
@d76 3
a79 1

d81 1
d83 1
d85 3
a87 1
  void clear (int sig) {sigs[sig].si.si_signo = 0;}
a89 1
  friend void sigproc_init ();
d341 2
a342 1
  if (wq.thread_ev)
d344 8
a351 12
      if (exit_state < ES_FINAL && waitq_head.next && sync_proc_subproc
	  && sync_proc_subproc.acquire (wait))
	{
	  for (waitq *w = &waitq_head; w->next != NULL; w = w->next)
	    if (w->next == &wq)
	      {
		w->next = wq.next;
		break;
	      }
	  sync_proc_subproc.release ();
	}
      ForceCloseHandle1 (wq.thread_ev, wq_ev);
a352 1

d395 1
a395 1
sig_clear (int sig)
d397 15
a411 1
  sigq.clear (sig);
d428 9
d439 4
a442 2
     should catch it.  */
  if (sigq.pending () && &_my_tls != _sig_tls)
d731 1
d838 3
a840 6
  cygheap_exec_info *res =
    (cygheap_exec_info *) ccalloc_abort (HEAP_1_EXEC, 1,
					 sizeof (cygheap_exec_info)
					 + (nprocs * sizeof (children[0])));
  res->sigmask = _my_tls.sigmask;
  return res;
a1231 2
/* Add a packet to the beginning of the queue.
   Should only be called from signal thread.  */
a1235 1

d1240 1
d1242 31
a1272 1
  start.next = se;
d1312 1
a1312 1
      sigpacket *q = &sigq.start;
d1325 2
a1326 1
	  while ((q = q->next))
d1341 9
a1349 17
	  {
	    sigpacket *qnext;
	    /* Check the queue for signals.  There will always be at least one
	       thing on the queue if this was a valid signal.  */
	    while ((qnext = q->next))
	      {
		if (qnext->si.si_signo && qnext->process () <= 0)
		  q = q->next;
		else
		  {
		    q->next = qnext->next;
		    qnext->si.si_signo = 0;
		  }
	      }
	    if (pack.si.si_signo == SIGCHLD)
	      clearwait = true;
	  }
d1368 1
a1368 6
	      {
#ifdef DEBUGGING
		try_to_debug();
#endif
		system_printf ("WaitForSingleObject(%p) for thread exit returned %u", h, res);
	      }
@


1.387
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d49 1
a49 2
HANDLE NO_COPY sigCONT;			// Used to "STOP" a process

d570 1
a570 1
      SetEvent (sigCONT);
d1347 1
a1347 1
  sigCONT = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d1357 1
a1357 1
	WaitForSingleObject (sigCONT, INFINITE);
@


1.386
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@a45 3
HANDLE NO_COPY signal_arrived;		// Event signaled when a signal has
					//  resulted in a user-specified
					//  function call
a517 11
void __stdcall
create_signal_arrived ()
{
  if (signal_arrived)
    return;
  /* local event signaled when main thread has been dispatched
     to a signal handler function. */
  signal_arrived = CreateEvent (&sec_none_nih, false, false, NULL);
  ProtectHandle (signal_arrived);
}

d1222 1
a1222 1
  sigproc_printf ("considering pid %d", child->pid);
@


1.385
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d46 3
d521 11
@


1.384
log
@* ChangeNotes: New file.  Add entry cgf-000001.
* sigproc.cc (proc_terminate): Don't set parent pid of child to 1 if we've
execed since the execed process is still considered the parent.
* child_info.h: Bump copyright.
@
text
@a45 3
HANDLE NO_COPY signal_arrived;		// Event signaled when a signal has
					//  resulted in a user-specified
					//  function call
a517 11
void __stdcall
create_signal_arrived ()
{
  if (signal_arrived)
    return;
  /* local event signaled when main thread has been dispatched
     to a signal handler function. */
  signal_arrived = CreateEvent (&sec_none_nih, false, false, NULL);
  ProtectHandle (signal_arrived);
}

@


1.383
log
@* fhandler.h (PIPE_ADD_PID): Define new flag.
* pipe.cc (fhandler_pipe::create): Don't indiscriminately add process id to
every pipe since some pipe names (fifo, tty) don't need it.
* sigproc.cc (sigproc_init): Pass PIPE_ADD_PID to fhandler_pipe::create to
ensure that pid is always part of sigwait pipe name.
@
text
@d448 4
a451 1
	  procs[i]->ppid = 1;
d454 5
@


1.382
log
@* environ.cc (struct parse_thing): Add temporary (?) "pipe_byte" option.
* globals.cc (pipe_byte): Declare.
* pipe.cc (fhandler_pipe::create): Use current process id in pipe name rather
than pid for simple name collision avoidance.  Do this only once to avoid extra
overhead when a busy pipe is found.  Honor pipe_byte to create non-message
pipes if set.
* sigproc.cc (sigproc_init): Use a specific name for the signal pipe.
@
text
@d532 2
a533 1
				     sizeof (sigpacket), "sigwait", 0);
@


1.381
log
@* sigproc.cc (proc_terminate): Avoid releasing myself.
@
text
@d532 1
a532 1
				     sizeof (sigpacket), NULL, 0);
@


1.380
log
@* child_info.h (child_info::postfork): Define new function.
* fork.cc (frok::parent): Call postfork to do all of the manipulation required
prior to calling pinfo::remember.
* pinfo.h (pinfo::set_rd_proc_pipe): Just set pinfo's rd_proc_pipe.  Don't
bother setting it to NULL.
* sigproc.cc (child_info_spawn::wait_for_myself): Call postfork to set up
myself for waiting.
* spawn.cc (child_info_spawn::worker): Avoid now-unnecessary global lock.
Consistently test mode rather than chtype when making wr_proc_pipe decisions.
Call postfork() to set up stuff prior to pinfo::remember.
@
text
@d451 2
a452 1
	  procs[i].release ();
@


1.379
log
@* child_info.h: Reset magic number.
(child_info_spawn::wait_for_myself): Move function to sigproc.cc.
* pinfo.cc (is_toplevel_proc): Delete unneeded variable.
* sigproc.cc (child_info_spawn::wait_for_myself): Move function from header to
here.  Do all setup required to properly wait for top-level execed process to
exit.
* spawn.cc (child_info_spawn::worker): Attempt to properly handle _P_DETACH.
Set wr_proc_pipe if top-level process even when execing.  Just call
wait_for_myself() to...  wait for myself.  Don't call cleanup twice.
@
text
@d917 1
a917 3
  myself.set_rd_proc_pipe (rd_proc_pipe);
  ForceCloseHandle (wr_proc_pipe);
  wr_proc_pipe = NULL;
@


1.378
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::rd_proc_pipe): Declare new field.
(child_info::wr_proc_pipe): Ditto.
(child_info::prefork): Declare new function, derived from previous pinfo
version.
* dcrt0.cc (child_info_fork::handle_fork): Close previous wr_proc_pipe when
appropriate and assign new one from passed-in child_info block.
(child_info_spawn::handle_spawn): Assign our wr_proc_pipe handle from passed-in
child_info block.
* fork.cc (child_info::prefork): Define new function.
(frok::child): Clear rd_proc_pipe and wr_proc_pipe so they will not be closed
by the child_info destructor.
(frok::parent): Use child_info prefork handling, outside of retry loop.  Set
rd_proc_pipe in child's pinfo after successful CreateProcess.  Eliminate
postfork call.
* globals.cc (my_wr_proc_pipe): Define/declare new variable.
* pinfo.cc (pinfo::pending_rd_proc_pipe): Delete.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wait): Assume that rd_proc_pipe is set up correctly prior to call.
(_pinfo::alert_parent): Replace "wr_proc_pipe" with "my_wr_proc_pipe".
* pinfo.h (_pinfo::_wr_proc_pipe): Delete declaration.
(_pinfo::set_rd_proc_pipe): Define new function.
(pinfo::pending_rd_proc_pipe): Delete declaration.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wr_proc_pipe): Ditto.
* sigproc.cc (child_info::child_info): Clear rd_proc_pipe and wr_proc_pipe.
(child_info::cleanup): Close rd_proc_pipe and wr_proc_pipe if necessary.
(child_info_fork::child_info_fork): Set forker_finished to NULL by default.
(child_info_spawn::child_info_spawn): Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.
(child_info::sync): Ditto.
(child_info_spawn::cleanup): Call child_info::cleanup.
* spawn.cc (child_info_spawn::worker): Remove call to myself.prefork().  Set
wr_proc_pipe when execing or set up new rd_proc_pipe/wr_proc_pipe via
child_info::prefork when spawning.  Remove call to pinfo::postexec.  Set
rd_proc_pipe in child pinfo when spawning.  Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.  Remove call to postfork.
@
text
@d915 10
@


1.377
log
@* exception.h (stackdump): Declare.
* exceptions.cc (stackdump): Rework to perform all operations needed for a
stackdump and to avoid recursion.
(exception::handle): Use simplified stackdump interface.
* sigproc.cc (signal::exit): Ditto.  Delete now, uneeded declaration.
@
text
@d831 2
a832 1
  flag (0), retry (child_info::retry_count)
d880 1
a880 4
  if (subproc_ready)
    CloseHandle (subproc_ready);
  if (parent)
    CloseHandle (parent);
d884 2
a885 1
  child_info (sizeof *this, _CH_FORK, true)
d895 1
a895 1
      if (myself->wr_proc_pipe)
d915 25
d967 1
d1075 1
a1075 1
	  if (type == _CH_EXEC && myself->wr_proc_pipe)
@


1.376
log
@	* sigproc.cc (child_info_fork::abort): Call TerminateProcess rather
	than ExitProcess.
@
text
@d26 1
a376 2
  extern void stackdump (DWORD, int, bool);

d416 1
a416 1
    stackdump (thread_context.ebp, 1, 1);
@


1.375
log
@* sigproc.cc (child_info::retry_count): Actually that should have been 0.
@
text
@d1115 1
a1115 1
      ExitProcess (EXITCODE_FORK_FAILED);
d1118 1
a1118 1
    ExitProcess (EXITCODE_RETRY);
@


1.374
log
@* sigproc.cc (child_info::retry_count): Default to 1.
@
text
@d824 1
a824 1
int child_info::retry_count = 1;
@


1.373
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@d824 1
a824 1
int child_info::retry_count = 10;
@


1.372
log
@* exceptions.cc (ctrl_c_handler): YA in a series or reversions.  Put back
_my_tls.remove along with a comment.
(sigpacket::process): Remove code which now causes a gdb deadlock.
* sigproc.cc (_cygtls::signal_exit): Signal debugger with signal number
earlier.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d17 1
a20 1
#include "sigproc.h"
a24 1
#include "pinfo.h"
@


1.371
log
@* sigproc.cc (signal_exit): Revert reversion of 2011-12-04 change since,
otherwise, you see hangs when the signal pipe is closed.
@
text
@d399 1
a416 1
  signal_debugger (rc & 0x7f);
@


1.370
log
@* dll_init.cc (dll_dllcrt0): Don't try to initialize dll data if we're
dynamically loaded since fork() doesn't work in that scenario anyway.
(dll_dllcrt0_1): Don't accommodate dynamically loaded dlls.
* exceptions.cc (ctrl_c_handler): Don't lock the process; there's too much risk
of deadlock.
* sigproc.cc (_cygtls::remove_wq): Don't try to remove anything from the waitq
if there is obviously nothing there.
* strace.cc (strace::activate): Allow stracing dynamically loaded cygwin1.dll.
@
text
@d379 1
a380 1
  close_my_readsig ();
d382 17
a398 1
  SetEvent (signal_arrived);	 /* Avoid potential deadlock with proc_lock */
@


1.369
log
@* sigproc.cc (close_my_readsig): New function.
(_cygtls::signal_exit): Close my_readsig via close_my_readsig(), avoiding
communication with the signal pipe.
(wait_sig): Close my_readsig via close_my_readsig().
@
text
@d349 1
a349 1
  if (exit_state < ES_FINAL && sync_proc_subproc
@


1.368
log
@* exceptions.cc (exception::handle): Drop abbreviation for "exception" since I
never remember what it stands for.
(sig_handle_tty_stop): Remove obsolete call to sig_handle_tty_stop.
(_cygtls::call_signal_handler): Rework to grab signal information from
_main_tls if none is set for _my_tls.  Try harder to keep thread locked.
(reset_signal_arrived): Delete.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use new cygWFMO call
to wait for an event + standard cygwin stuff.  Modify debug output to
acccomodate new function.
* fhandler_console.cc (fhandler_console::read): Replace WaitForMultipleObjects
with cygWFMO.
* fhandler_socket.cc (get_inet_addr): Add comment.
* gendef (_sigdelayed): Remove call to reset_signal_arrived.
* sigproc.cc (_cygtls::signal_exit): Don't close my_readsig here unless we're
in the signal thread.
(create_signal_arrived): Create signal_arrived as auto-reset so that only one
thread is woken when a signal arrives.
* sigproc.h (cygWFMO): New function.
(reset_signal_arrived): Delete declaration.
@
text
@d363 8
a378 1
  HANDLE myss = my_sendsig;
d380 1
a380 9
  if (&_my_tls == _sig_tls)
    ForceCloseHandle (my_readsig); /* Stop any currently executing sig_sends */
  else
    {
      sigpacket sp = {};
      sp.si.si_signo = __SIGEXIT;
      DWORD len;
      WriteFile (myss, &sp, sizeof (sp), &len, NULL);
    }
d1424 1
a1424 1
  ForceCloseHandle (my_readsig);
@


1.367
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d371 1
d373 10
a382 1
  ForceCloseHandle (my_readsig); /* Stop any currently executing sig_sends */
d506 1
a506 1
  signal_arrived = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
@


1.366
log
@* sigproc.cc (get_proc_lock): Remove extra NULL check.  Return false on
failure.
@
text
@d1244 1
a1244 1
    new cygthread (commune_process, size, si, "commune_process");
@


1.365
log
@* sigproc.cc (remove_proc): Don't terminate the currently executing thread.
@
text
@d137 1
a137 1
      sigproc_printf ("sync_proc_subproc is NULL (1)");
d145 3
a147 8
  if (!sync_proc_subproc)
    {
      sigproc_printf ("sync_proc_subproc is NULL (2)");
      return false;
    }
  system_printf ("Couldn't acquire sync_proc_subproc for(%d,%d), last %d, %E",
		  what, val, lastwhat);
  return true;
@


1.364
log
@* exceptions.cc (stackdump): Make global.
(signal_exit): Move to sigproc.cc.
* sigproc.cc (signal_exit): Move here.  Declare stackdump extern.  Set
my_sendsig to indicate that signals are no longer available.
(my_readsig): Make Static again.
(sig_send): Interpret ERROR_BROKEN_PIPE as ESRCH.  Remove special-case EACCESS
errno setting, just setting errno generally, even for "its_me" case.
@
text
@d1138 4
a1141 1
    procs[ci].wait_thread->terminate_thread ();
@


1.363
log
@* exceptions.cc (sigpacket::process): Move signal_exit processing into...
(_cygtls::signal_exit): ...here.  Close my_readsig and comment on why.
* pinfo.cc (pinfo::exit): Move sigproc_terminate earlier.  Set exiting flag in
lock_process.
* sigproc.cc (my_readsig): Make global.
* sync.cc (muto::exiting_thread): Delete.
(muto::acquire): Delete #if 0'ed code.
* sync.h (muto::exiting_thread): Delete.
(set_exiting_thread): Ditto.
(lock_process::lock_process): Don't worry about setting the exiting thread
since it had no meaning.
@
text
@d67 1
a67 1
HANDLE NO_COPY my_readsig;
d368 44
a728 1
	  __seterrno ();
a738 1
	  set_errno (EACCES);
d740 4
@


1.362
log
@* cygthread.h (cygthread::name): Default name to "main" if we are early in the
process of setting up the DLL and no name is known.
* dcrt0.cc (initial_env): Remove CYGWIN_SLEEP stuff.
(get_cygwin_startup_info): Activate strace here as appropriate.
(dll_crt0_0): Move get_cygwin_startup_info as early as possible to avoid
missing strace output.
* fork.cc (frok::child): Move debugging statement to point where ppid will be
set.
* pinfo.cc (pinfo::thisproc): Remove obsolete call to strace.hello.  Tweak
debug output slightly.
* select.cc (select_stuff::wait): Allow APCS to be triggered while waiting
since we use them now.  Report when that happens.
* sigproc.cc (child_info::child_info): Use strace.active() rather than
strace.attached().
* spawn.cc (child_info_spawn::worker): Only write strace child pid when we know
it's a cygwin process.  Accommodate change to write_child argument list.
* strace.cc (strace::hello): Delete.  Move functionality...
(strace::activate): ...to here.
(mypid): Just use raw GetCurrentProcessId () if myself isn't set.
(strace::write_childpid): Don't wait for subproc_ready.  Remove arg which was
required for it.
* include/sys/strace.h (strace::hello): Delete.
(strace::write_childpid): Delete first argument.
@
text
@d67 1
a67 1
Static HANDLE my_readsig;
@


1.361
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset for previous changes.
* dcrt0.cc (get_cygwin_startup_info): Signal readiness when stracing since
strace::write_child relies on it.  Use strace.activate to notify strace
process, passing in arg indicating whether we're forked.
* sigproc.cc (wait_sig): Accommodate new strace::activate argument.
* spawn.cc (child_info_spawn::worker): Oops.  Previous suspended test was
actually correct.  Revert and document.
* strace.cc (strace::activate): Send additional flag indicating whether this is
an attempt to activate a forked process.
(strace::hello): Report on windows pid.
* include/sys/strace.h (strace::strace): Make a dummy.
(strace::activate): Modify declaration to accept an argument.
(strace::write_childpid): Set regparm.
@
text
@d796 1
a796 1
  if (strace.attached ())
a1298 1
	  strace.hello ();
@


1.360
log
@* pipe.cc (fhandler_pipe::create): Avoid derefencing a NULL pointer.
* child_info.h (child_info): Reorganize some elements so that the ones which
are initialized in a constructor are all together.
* sigproc.cc (child_info::child_info): Initialize values via the constructor
rather than as C statements and make sure that flags is set to zero initially.
* spawn.cc (child_info_spawn::worker): Use iscygwin() test for determining when
to send strace info since it is more foolproof than checking the suspend state.
@
text
@d1298 1
a1298 1
	  strace.activate ();
@


1.359
log
@* fhandler.h (fhandler_pipe::create): Rename from the misnamed
"create_selectable".  Change return to DWORD.
(fhandler_pty_common::pipesize): New constant.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Reflect create_selectable
name change.
* miscfuncs.cc (CreatePipeOverlapped): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Rename from the misnamed "create_selectable".  Return
DWORD.  Only set pipe size to default when it is passed in as zero.
* fhandler_tty.cc (fhandler_pty_master::setup): Ditto.  Use
fhandler_pty_common::pipesize rather than a raw constant.
* tty.cc (tty::not_allocated): Ditto.
* sigproc.cc (sigproc_init): Use create_selectable to create the signal pipe to
get a more appropriate message based pipe.
@
text
@d764 4
a767 1
			bool need_subproc_ready)
a768 2
  cb = in_cb;

a793 3
  intro = PROC_MAGIC_GENERIC;
  magic = CHILD_INFO_MAGIC;
  type = chtype;
a803 3
  cygheap = ::cygheap;
  cygheap_max = ::cygheap_max;
  retry = child_info::retry_count;
@


1.358
log
@* sigproc.cc (remove_proc): Don't do busy loop when exiting since it doesn't
matter.
@
text
@d467 6
a472 5
  PSECURITY_ATTRIBUTES sa_buf = sec_user_nih ((PSECURITY_ATTRIBUTES) char_sa_buf, cygheap->user.sid());
  for (int i = 5;
       i > 0 && !CreatePipe (&my_readsig, &my_sendsig, sa_buf, 0);
       i--)
    if (i == 1)
d474 1
@


1.357
log
@* sigproc.cc (remove_proc): Don't do busy loop when execing since thread could
have been terminated prior to setting flag.
* signal.cc (sigwaitinfo): Zero event before closing to signal other threads
that it is no longer available.
@
text
@d1109 1
a1109 1
      if (!have_execed)
@


1.356
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(cygheap_exec_info::nchildren): Move from child_info_spawn.
(cygheap_exec_info::cchildren): Ditto.
(cygheap_exec_info::record_children): Declare new function.
(cygheap_exec_info::reattach_children): Ditto.
(cygheap_exec_info::alloc): Ditto.
(child_info_spawn::nchildren): Move to cygheap_exec_info.
(child_info_spawn::cchildren): Ditto.
* sigproc.cc (cygheap_exec_info::alloc): Define new function.
(child_info_spawn::cleanup): Accommodate move of children info to
cygheap_exec_info.
(cygheap_exec_info::record_children): Define new function.
(cygheap_exec_info::reattach_children): Ditto.
(child_info_spawn::record_children): Use cygheap_exec_info function to
accomplish this task.
(child_info_spawn::reattach_children): Ditto.
* spawn.cc (child_info_spawn::worker): Allocate moreinfo using
cygheap_exec_info::alloc.
* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Use abort for the error to
avoid a retry.
@
text
@d1109 3
a1111 2
      while (!procs[nprocs].waiter_ready)
	yield ();
@


1.355
log
@Remove erroneously checked-in debugging statements.
* cygheap.cc (cygheap_fixup_in_child): Here.
* debug.cc (delete_handle): Here.
* sigproc.cc (child_info_spawn::cleanup): Here.
* spawn.cc (child_info_spawn::worker): Here.
@
text
@d846 8
a869 1
  nchildren = 0;
d887 10
d901 1
a901 5
    for (nchildren = 0; nchildren < nprocs; nchildren++)
      {
	children[nchildren].pid = procs[nchildren]->pid;
	children[nchildren].p = procs[nchildren];
      }
d907 2
a908 2
void
child_info_spawn::reattach_children ()
d925 6
@


1.354
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@a867 1
debug_printf ("type %d, type == _CH_EXEC == %d, hExeced %p", type, type == _CH_EXEC, hExeced);
a870 1
{debug_printf ("cleaning up");
a871 1
}
@


1.353
log
@* cygwin.din (ptsname_r): Export.
* fhandler.cc (fhandler_base::ptsname_r): Define.
* fhandler.h (fhandler_base::ptsname): Delete.
(fhandler_base::ptsname_r): Declare.
(fhandler_pty_master::ptsname_r): Declare.
* fhandler_tty.cc (fhandler_pty_master::ptsname): Delete.
(fhandler_pty_master::ptsname_r): New reentrant function derived from previous
ptsname.
* syscalls.cc (ptsname_r): Implement new function with functionality similar to
Linux.
(ptsname): Use ptsname_r () to fill out buf.
* include/cygwin/stdlib.h (ptsname_r): Declare.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 255 to reflect
export of ptsname_r.
* pinfo.cc (pinfo::wait): Return bool rather than int.
* pinfo.h (info::wait): Ditto.
(pinfo::reattach): Define !defined(_SIGPROC_H) case for consistency.
* sigproc.cc (child_info_spawn::reattach_children): Use correct dwProcessId
rather than pid when duplicating handle.
@
text
@d20 1
a24 1
#include "sigproc.h"
d281 1
a281 1
      clearing = 0;
d284 7
d384 1
a384 2
      int i;
      for (i = 0; i < nprocs; i++)
d386 1
a386 9
	  /* FIXME: Resetting the ppid to 1 when this process execs is decidedly
	     non-UNIXy.  We should, at the very least, keep a list of pids
	     for the exec process to reset when *it* exits.  However, avoiding
	     setting ppid when we are exec'ing causes the ppid to *never* be
	     set to 1 so we don't do that either.
	  if (!hExeced)
	     */
	  if (!hExeced || ISSTATE (myself, PID_NOTCYGWIN))
	    procs[i]->ppid = 1;
d388 1
a388 4
	    {
	      // CloseHandle (procs[i].rd_proc_pipe);
	      procs[i].wait_thread->terminate_thread ();
	    }
a474 1
  new cygthread (wait_sig, cygself, "sig");
d478 1
d543 1
a543 1
  if (!(its_me = (!hExeced && (p == NULL || p == myself || p == myself_nowait))))
d758 1
d761 2
a762 2

child_info::child_info (unsigned in_cb, child_info_types chtype, bool need_subproc_ready)
a763 1
  memset (this, 0, in_cb);
d825 1
a825 1
  child_info (sizeof *this, _PROC_FORK, true)
d832 46
d886 6
a891 6
  /* FIXME: locking */
  for (nchildren = 0; nchildren < nprocs; nchildren++)
    {
      children[nchildren].pid = procs[nchildren]->pid;
      children[nchildren].rd_proc_pipe = procs[nchildren].rd_proc_pipe;
    }
d902 1
a902 1
      pinfo p (children[i].pid, PID_MAP_RW);
d904 1
a904 8
	/* pid no longer exists */;
      else if (!DuplicateHandle (parent, children[i].rd_proc_pipe,
				GetCurrentProcess (), &p.rd_proc_pipe, 0,
				false, DUPLICATE_SAME_ACCESS))
	debug_printf ("couldn't duplicate parent %p handles for forked children after exec, %E",
		       children[i].rd_proc_pipe);
      else if (!(p.hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, false, p->dwProcessId)))
	CloseHandle (p.rd_proc_pipe);
d906 5
a910 4
	{
	  CloseHandle (p.hProcess);
	  CloseHandle (p.rd_proc_pipe);
	}
d926 1
a926 1
    api_fatal ("SetEvent failed");
d973 1
a973 1
	  if (type == _PROC_EXEC && myself->wr_proc_pipe)
d1078 3
a1080 1
  if (procs[ci]->exists ())
d1086 1
a1086 5
    {
      procs[ci].release ();
      if (procs[ci].hProcess)
	ForceCloseHandle1 (procs[ci].hProcess, childhProc);
    }
d1137 1
a1137 1
      sigproc_printf ("stopped child, stopsig %d", child->stopsig);
d1328 1
a1328 1
		sigproc_printf ("sig %d already queued", pack.si.si_signo);
@


1.352
log
@* pinfo.cc (status_exit): Recognize STATUS_ILLEGAL_INSTRUCTION.
(child_info::proc_retry): Ditto.
@
text
@d869 1
a869 1
      else if (!(p.hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, false, p->pid)))
@


1.351
log
@* pinfo.h (pinfo::reattach): Only set destroy to false when proc_subproc
succeeds.  Return true for success.
* sigproc.cc (child_info_spawn::reattach_children): Try harder to clean up on
error by detecting reattach failures too.
@
text
@d963 1
@


1.350
log
@* sigproc.cc (child_info_spawn::reattach_children): Clean up handle when can't
open parent process or suffer handle leak.
@
text
@d869 1
a869 3
      else if ((p.hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, false, p->pid)))
	p.reattach ();
      else
d871 5
@


1.349
log
@* sigproc.cc (child_info::sync): Report on exit code in strace output.
(child_info::proc_retry): Don't consider STATUS_ACCESS_VIOLATION as a
restartable event.
@
text
@d871 2
@


1.348
log
@* sigproc.cc (child_info_spawn::reattach_children): Avoid issuing an error when
we can't duplicate from "parent" since it is probably ok if children of the
previous owner of the pid disappear.
@
text
@d939 2
a940 1
      sigproc_printf ("pid %u, WFMO returned %d, res %d", pid, x, res);
d950 1
d957 1
a957 1
      return exit_code;
@


1.347
log
@* child_info.h (cchildren): New struct.
(child_info_spawn::nchildren): Rename from nprocs.
(child_info_spawn::children): Change type to cchildren for more bookkeeping
possibilities.
(child_info_spawn::child_info_spawn): Clear nchildren.
(child_info_spawn::record_children): Declare new function.
(child_info_spawn::reattach_children): Ditto.
* dcrt0.cc (child_info_spawn::handle_spawn): Call reattach_children to gather
list of processes we are potentially waiting for.
* pinfo.h (pinfo::pinfo): Make sure that rd_proc_pipe is always cleared.
(pinfo::reattach): New function.
* sigproc.cc: Move pinfo.h earlier so that it can be used in sigproc.h.
(get_proc_lock): Don't bother with a lock during DLL initialization.
(proc_subproc): Handle PROC_REATTACH_CHILD.
(proc_terminate): Orphan children only when we are not an execed process or
when the pid is about to be occupied by a non-cygwin process.
(child_info_spawn::record_children): Define new function.
(child_info_spawn::reattach_children): Ditto.
* sigproc.h (procstuff): Define PROC_REATTACH_CHILD and renumber other
elements.
* spawn.cc (spawn_guts): Record any to-be-waited-for subprocesses if about to
exec a cygwin process.
* sigproc.cc (sig_send): Fix harmless transposition of fifth and six arguments
to DuplicateHandle().
(child_info::child_info): Ditto.
* globals.cc (hExeced): Make NO_COPY.
@
text
@d862 3
a864 3
      if (p)
	{
	  if (!DuplicateHandle (parent, children[i].rd_proc_pipe,
d867 4
a870 5
	    system_printf ("couldn't duplicate parent %p handles for forked children after exec, %E",
			   children[i].rd_proc_pipe);
	  p.hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, false, p->pid);
	  p.reattach ();
	}
@


1.346
log
@* dtable.cc (dtable::delete_archetype): Improve debugging output.
(dtable::init_std_file_from_handle): Close console handle early, before
initialization.  Build up openflags for passing to open_setup, just to be safe.
(last_tty_dev): New variable.
(fh_last_tty_dev): New macro.
(fh_alloc): Try again to keep track of previously opened tty, this time by just
saving the device and using that to potentially open an archetype.  Avoid
setting the "/dev/tty" name if the creation of the fhandler failed.
(build_fh_pc): Remove unused second argument.  Reorganize how and where the
name is set.  Set last_tty_dev as appropriate.  Avoid a NULL dereference in a
debug printf.
* dtable.h (build_fh_pc): Reflect removal of second parameter.
* fhandler.cc (fhandler_base::reset): Use new '<<' operator to copy pc since it
preserves any potentially previously set name.
(fhandler_base::set_name): Ditto.
* fhandler.h (fhandler_*::clone): Throughout use ccalloc to allocate new
fhandler, primarily to make sure that pc field is properly zeroed.
(fhandler_termios::last): Eliminate.
(fhandler_termios): Remove setting of last.
(fhandler_base::~fhandler_termios): Ditto.
* fhandler_console.cc (fhandler_console::open): Don't make decisions about
opening close-on-exec handles here since it makes no sense for archetypes.
(fhandler_console::init): Assume that input handle has already been opened.
* fhandler_termios.cc (fhandler_termios::last): Delete.
* path.h (path_conv::eq_worker): New function.  Move bulk of operator = here.
(operator <<): New function.
(operator =): Use eq_worker to perform old functionality.
@
text
@a16 1
#include "pinfo.h"
d25 1
d132 2
d239 3
d387 1
d605 2
a606 2
      if (!DuplicateHandle (hp, dupsig, GetCurrentProcess (), &sendsig, false,
			    0, DUPLICATE_SAME_ACCESS) || !sendsig)
d628 1
a628 1
	  if (!DuplicateHandle (GetCurrentProcess (), tome, hp, &tome, false, 0,
d816 1
a816 1
			GetCurrentProcess (), &parent, 0, TRUE,
d839 36
@


1.345
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@a35 2
#define NPROCS	256

@


1.344
log
@* sigproc.cc (proc_terminate): Avoid setting ppid to 1 if we're execing.
@
text
@d377 7
a383 8
	  extern child_info_spawn *chExeced;
	  /* Don't reset the ppid to 1 if this pid is still going to be
	     associated with a process.
	     FIXME: The problem with this simplistic approach is that the
	     ppid for any surviving children will never be set to 1 in
	     this scenario.  A potential fix would be to move procs into
	     cygheap but that would complicate startup.  What else is new? */
	  if (!chExeced)
@


1.343
log
@	* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Send __SIGSETPGRP
	pseudo signal to process group instead of just calling
	init_console_handler.
	* sigproc.cc (wait_sig): Call init_console_handler here on __SIGSETPGRP
	signal.
	* sigproc.h (__SIGSETPGRP): Define.
@
text
@d377 9
a385 1
	  procs[i]->ppid = 1;
@


1.342
log
@	* miscfuncs.cc (CreatePipeOverlapped): New function.
	(ReadPipeOverlapped): Ditto.
	(WritePipeOverlapped): Ditto.
	* miscfuncs.h: Declare new functions.
	* pinfo.cc (commune_process): Call WritePipeOverlapped instead of
	WriteFile.  Set timeout to 1 sec.
	(_pinfo::commune_request): Call ReadPipeOverlapped instead of ReadFile.
	Set timeout to 0.5 secs.
	* sigproc.cc (sig_send): Create pipe using CreatePipeOverlapped.
@
text
@d1228 3
@


1.341
log
@* dll_init.cc: Use fabort in favor of api_fatal and fork_info->abort where
appropriate throughout.
(fabort): Define.
(dll_list::topsort): Don't print sorting information.  Fix formatting.
(dll_list::topsort_visit): Fix formatting.
(dll_list::load_after_fork_impl): Perform comment fixups.
* sigproc.cc (child_info_fork::abort): (for now?) Always print cause of fork
failure.
* include/sys/strace.h (strace_vprintf): Remove _STRACE_NOTALL when printing.
We really do want to see this.
@
text
@d611 1
a611 1
	  if (!CreatePipe (&fromthem, &tome, &sec_all_nih, 0))
@


1.340
log
@* sigproc.cc (pending_signals::pending): Define new function.
(sig_dispatch_pending): Avoid calling sig_send if there are no pending signals.
@
text
@d947 1
a947 1
      strace_vprintf (SIGP, fmt, ap);
@


1.339
log
@	* sigproc.cc (wait_sig): Fix debug output.
@
text
@d91 1
d435 7
a441 1
  sig_send (myself, fast ? __SIGFLUSHFAST : __SIGFLUSH);
@


1.338
log
@* cygheap.h (init_cygheap::ctty_on_hold): Remove conditionalized variable.
* dcrt0.cc (do_exit): Remove code which handled CYGWIN=tty style ttys.
* devices.in: Remove "/dev/ttym".
* dtable.cc: Rename tty to pty where appropriate throughout.
(dtable::stdio_init): Use new t->is_console rather than using now-deleted hwnd
element in tty structure.
(dtable::init_std_file_from_handle): Remove code which handled CYGWIN=tty style
ttys.
(fh_alloc): Ditto.
* fhandler.h: Rename tty to pty where appropriate.
(fhandler_pty_common): Delete output_done_event, ioctl_request_event,
ioctl_done_event.
(fhandler_pty_master::setup): Delete argument.
(fhandler_tty_master): Delete.
(fhandler_union): Delete __tty_master.
* fhandler_console.cc (use_tty): Delete.
(fhandler_console::get_tty_stuff): Set is_console to true rather than calling
sethwnd.
(fhandler_console::send_winch_maybe): Remove CYGWIN=tty considerations.
(fhandler_console::input_tcsetattr): Ditto.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use new t->is_console
rather than using now-deleted hwnd element in tty structure.
* fhandler_tty.cc: Rename tty to pty where appropriate throughout.
(tty_master): Delete.
(process_input): Ditto.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::*): Ditto.
(fhandler_pty_master::process_slave_output): Remove CYGWIN=tty considerations.
(fhandler_pty_slave::open): Ditto for *_done_event.
(fhandler_pty_slave::write): Ditto.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_slave::fch_open_handles): Ditto.
(fhandler_pty_slave::fch_set_sd): Ditto.
(fhandler_pty_slave::fch_close_handles): Ditto.
(fhandler_pty_common::close): Ditto.
(fhandler_pty_master::setup): Ditto.  Remove now-unneeded ispty parameter.
(fhandler_pty_master::open): Reflect argument removal for tty::allocate.
* select.cc: Rename tty to pty where appropriate throughout.
* sigproc.cc (proc_subproc): Remove CYGWIN=tty considerations.
* tty.cc (ttyslot): Accommodate CYGWIN=tty removal.
(tty_list::init_session): Ditto.
(tty_list::attach): Ditto.
(tty::create_master): Delete.
(tty_list::terminate): Ditto.
(tty_list::allocate): Delete "with_console" parameter.  Remove CYGWIN=tty
considerations.
(tty::init): Set is_console = false.  Use 'false' for was_opened since it is a
boolean.
* tty.h (*_{DONE,REQUEST}_EVENT): Delete.
(tty_min::is_console): Declare new field which replaces hwnd.
(tty_min::gethwnd): Delete.
(tty_min::sethwnd): Ditto.
(tty_list::allocate): Delete parameter.
(tty_list::terminate): Delete declaration.
* include/sys/cygwin.h (PID_USETTY): Redefine to PID_UNUSED1 and change comment
to reflect its availability.
@
text
@d1239 1
a1239 1
			system_printf ("Failed to arm signal %d from pid %d", pack.sig, pack.pid);
@


1.337
log
@whitespace elimination
@
text
@d234 1
a234 1
	  vchild->process_state |= PID_INITIALIZING | (myself->process_state & PID_USETTY);
@


1.336
log
@* dll_init.c (dll_list::load_after_fork): Don't clear in_forkee here.
* fork.cc (frok::errmsg): Rename from 'error'.
(frok::error): New function.  Handle conditional printing of error messages.
(frok::parent): Record hchild handle for use by error function.  Use
throughout.  Use error function rather than setting error pointer directly.
(fork): Clear is_forkee here.  Accommodate rename of 'error' to 'errmsg'.
* sigproc.cc (child_info::proc_retry): Detect EXITCODE_FORK_FAILED.
@
text
@d917 1
a917 1
      
@


1.335
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d915 3
@


1.334
log
@* fhandler.h (fhandler_dev_dsp): Cosmetic change.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Put back
Sleep(10) for tty_master case.
* sigproc.cc (stopped_or_terminated): Don't consider a pid which has been
reaped to be terminated.
@
text
@d4 1
a4 3
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.

   Written by Christopher Faylor
d931 1
a931 1
child_info_fork::handle_failure (DWORD err)
d933 7
d942 1
a942 1
  return 0;
@


1.333
log
@* fork.cc (fork): Clear PID_REAPED.
* pinfo.cc (pinfo_init): Ditto.
(pinfo::init): Check for PID_REAPED.
* sigproc.cc (stopped_or_terminated): Ditto.
@
text
@d1025 1
a1025 1
  if (!((terminated = (child->process_state & (PID_REAPED | PID_EXITED)))
@


1.332
log
@* signal.cc (_pinfo::kill): Return success on kill(0) only if pid exists or is
in PID_EXITED state.  Report pid 0 when pid does not exist rather than pid -1.
Make debug output reflect actual function call.
* sigproc.cc (stopped_or_terminated): Set process state to reaped when we've
finished waiting for it.
* include/sys/cygwin.h (PID_REAPED): New enum.
@
text
@d1025 1
a1025 1
  if (!((terminated = (child->process_state == PID_EXITED))
@


1.331
log
@* sigproc.cc (sig_dispatch_pending): Remove debugging statement.
(sigproc_init): Wrap a long line.
@
text
@d1044 1
@


1.330
log
@* cygthread.h (cygthread::cygthread): Reorganize slightly.
* dcrt0.cc (dll_crt0_0): Move sigproc initialization later to ensure everything
we need has been set up.
(dll_crt0_1): Streamline some logic slightly.
* sigproc.cc (no_signals_available): Add back dropped test for macro parameter.
* fhandler_console.cc (fhandler_console::write): Show a little bit of what's
being written to the console in debugging output.
@
text
@a435 3
#ifdef DEBUGGING
  sigproc_printf ("flushing");
#endif
d457 3
a459 1
  for (int i = 5; i > 0 && !CreatePipe (&my_readsig, &my_sendsig, sa_buf, 0); i--)
@


1.329
log
@* sigoproc.cc (sigproc_init): Use American spelling in comment.
@
text
@d36 1
a36 1
#define no_signals_available(x) (!my_sendsig ||( myself->exitcode & EXITCODE_SET) || (&_my_tls == _sig_tls) || !cygwin_finished_initializing)
@


1.328
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d466 1
a466 1
  /* sync_proc_subproc is used by proc_subproc.  It serialises
@


1.327
log
@* sigproc.cc (init_sig_pipe): Add retry loop.
@
text
@d36 1
a36 1
#define no_signals_available(x) (!hwait_sig || (hwait_sig == INVALID_HANDLE_VALUE) || ((x) && myself->exitcode & EXITCODE_SET) || (&_my_tls == _sig_tls) || !cygwin_finished_initializing)
a57 3
cygthread NO_COPY *hwait_sig;
Static HANDLE wait_sig_inited;		// Control synchronization of
					//  message queue startup
d78 1
a78 1
static DWORD WINAPI wait_sig (VOID *arg);
d97 1
a97 1
  friend DWORD WINAPI wait_sig (VOID *arg);
a126 14
void __stdcall
wait_for_sigthread ()
{
  sigproc_printf ("wait_sig_inited %p", wait_sig_inited);
  HANDLE hsig_inited = wait_sig_inited;
  WaitForSingleObject (hsig_inited, INFINITE);
  wait_sig_inited = NULL;
  myself->sendsig = my_sendsig;
  myself->process_state |= PID_ACTIVE;
  myself->process_state &= ~PID_INITIALIZING;
  ForceCloseHandle1 (hsig_inited, wait_sig_inited);
  sigproc_printf ("process/signal handling enabled, state %p", myself->process_state);
}

d454 1
a454 5

   This routine starts the signal handling thread.  The wait_sig_inited
   event is used to signal that the thread is ready to handle signals.
   We don't wait for this during initialization but instead detect it
   in sig_send to gain a little concurrency.  */
d458 8
a465 3
  wait_sig_inited = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  ProtectHandle (wait_sig_inited);

a468 3

  hwait_sig = new cygthread (wait_sig, 0, cygself, "sig");
  hwait_sig->zap_h ();
a549 2
	  sigproc_printf ("my_sendsig %p, myself->sendsig %p, exit_state %d",
			  my_sendsig, myself->sendsig, exit_state);
a552 2
      if (wait_sig_inited)
	wait_for_sigthread ();
a1129 17
/* Called separately to allow stack space reutilization by wait_sig.
   This function relies on the fact that it will be called after cygheap
   has been set up.  For the case of non-dynamic DLL initialization this
   means that it relies on the implicit serialization guaranteed by being
   run as part of DLL_PROCESS_ATTACH. */
static void __attribute__ ((noinline))
init_sig_pipe()
{
  char char_sa_buf[1024];
  PSECURITY_ATTRIBUTES sa_buf = sec_user_nih ((PSECURITY_ATTRIBUTES) char_sa_buf, cygheap->user.sid());
  for (int i = 5; i > 0 && !CreatePipe (&my_readsig, &my_sendsig, sa_buf, 0); i--)
    if (i == 1)
      api_fatal ("couldn't create signal pipe, %E");
  ProtectHandle (my_readsig);
}


d1132 1
a1132 1
static DWORD WINAPI
d1135 1
a1135 4
  init_sig_pipe ();
  /* Initialization */
  SetThreadPriority (GetCurrentThread (), WAIT_SIG_PRIORITY);

a1137 3
  SetEvent (wait_sig_inited);

  _sig_tls = &_my_tls;
d1210 1
a1210 1
	  hwait_sig = (cygthread *) INVALID_HANDLE_VALUE;
@


1.326
log
@* exceptions.cc (_cygtls::interrupt_now): Revert to checking for "spinning"
when choosing to defer signal.
(_cygtls::call_signal_handler): Grab func when we have the lock.
* gendef: Update copyright.
(__sigbe): Simplify slightly.
(_sigdelayed): Grab a lock before manipulating stuff.
(_cygtls::pop): Properly return popped value.
(stabilize_sig_stack): Set incyg when we have the lock.
* sigproc.cc: Update copyright.
@
text
@d1156 1
a1156 1
   means that it relies on the implicit serialization guarantted by being
d1163 3
a1165 2
  if (!CreatePipe (&my_readsig, &my_sendsig, sa_buf, 0))
    api_fatal ("couldn't create signal pipe, %E");
@


1.325
log
@* sigproc.cc (wait_sig): Make sure that strace is activated on __SIGSTRACE by
calling new strace::activate function.
* strace.cc (strace::activate): Rename from strace::strace.
* strace.h (strace::activate): Define new function.
(strace::strace): Call activate.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
@


1.324
log
@* sigproc.cc (no_signals_available): Get sense of the test right for previous
botched change.
@
text
@d1227 1
@


1.323
log
@* sigproc.cc (no_signals_available): Don't try to send a signal if still in
cygwin startup code.
@
text
@d36 1
a36 1
#define no_signals_available(x) (!hwait_sig || hwait_sig == INVALID_HANDLE_VALUE || ((x) && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls && cygwin_finished_initializing)
@


1.322
log
@* spinlock.h: New file.
(spinlock): New class.
* shared.cc: Include spinlock.h.
(memory_init): Use new spinlock methods rather than roll-your-own.  Time out
after ten seconds if shared_mem_inited is not initialized.
* sync.h: Update copyright.  Remove vanity attribution.
* sigproc.cc (sigproc_terminate): Avoid attempts to kill the signal thread
while we're still initializing or suffer a deadlock.
@
text
@d36 1
a36 1
#define no_signals_available(x) (!hwait_sig || hwait_sig == INVALID_HANDLE_VALUE || ((x) && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls)
@


1.321
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d497 3
a499 1
  if (prior_exit_state >= ES_FINAL)
@


1.320
log
@* sigproc.cc (get_proc_lock): Fix error message typo.
@
text
@d586 1
a586 1
	low_priority_sleep (0);
d1014 1
a1014 1
	low_priority_sleep (0);
@


1.319
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d168 1
a168 1
  system_printf ("Couldn't aquire sync_proc_subproc for(%d,%d), last %d, %E",
@


1.318
log
@Support pseudo-reloc version 2
@
text
@d611 2
a612 2
      if (!DuplicateHandle (hp, dupsig, hMainProc, &sendsig, false, 0,
			    DUPLICATE_SAME_ACCESS) || !sendsig)
d634 1
a634 1
	  if (!DuplicateHandle (hMainProc, tome, hp, &tome, false, 0,
d821 2
a822 1
  if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &parent, 0, TRUE,
@


1.317
log
@* sigproc.cc (stopped_or_terminated): Don't return a match when stopsig ==
SIGCONT and not WCONTINUED.
* termios.cc (tcsetpgrp): Improve debugging output.
@
text
@d926 2
@


1.316
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d1044 3
a1046 2
  if (!((terminated = (child->process_state == PID_EXITED)) ||
      ((w->options & (WUNTRACED | WCONTINUED)) && child->stopsig)))
d1054 1
a1054 1
      sigproc_printf ("stopped child");
@


1.315
log
@* exceptions.cc (sig_handle_tty_stop): Set stopsig to SIGCONT when continuing.
(stopped_or_terminated): Honor WCONTINUED.
* wait.cc (wait4): Ditto.
* include/cygwin/wait.h (WCONTINUED): Define.
(__W_CONTINUED): Ditto.
(WIFCONTINUED): Ditto.
@
text
@d131 1
a131 1
wait_for_sigthread (bool forked)
a132 10
  char char_sa_buf[1024];
  PSECURITY_ATTRIBUTES sa_buf = sec_user_nih ((PSECURITY_ATTRIBUTES) char_sa_buf, cygheap->user.sid());
  if (!CreatePipe (&my_readsig, &my_sendsig, sa_buf, 0))
    api_fatal ("couldn't create signal pipe%s, %E", forked ? " for forked process" : "");
  ProtectHandle (my_readsig);
  myself->sendsig = my_sendsig;

  myself->process_state |= PID_ACTIVE;
  myself->process_state &= ~PID_INITIALIZING;

d137 3
a140 1
  SetEvent (sigCONT);
d1147 16
d1168 1
d1181 1
a1181 1
  pack.si.si_signo = __SIGHOLD;
@


1.314
log
@* Makefile.in: Don't do anything special with any RCS directories.
* ntdll.h (PROCESSINFOCLASS): Remove unneeded trailing comma.
* pinfo.cc (_pinfo::dup_proc_pipe): Remove unneeded assignment.
* sigproc.cc (sig_send): Don't send signal to myself if this is an exec stub.
@
text
@d1053 1
a1053 1
      ((w->options & WUNTRACED) && child->stopsig)))
d1062 4
a1065 1
      w->status = (child->stopsig << 8) | 0x7f;
@


1.313
log
@* fhandler.cc (fhandler_base::wait_overlapped): Honor nonblocking flag for
writes.  Don't reset event handle when we see a ERROR_IO_PENDING.
* sigproc.cc (stopped_or_terminated): Use bool constants for consistency.
* wait.cc (wait4): Remove nonsensical comment.
@
text
@d558 1
a558 1
  if (!(its_me = (p == NULL || p == myself || p == myself_nowait)))
@


1.312
log
@Remove unneeded header files from source files throughout.
@
text
@d1048 1
a1048 1
    return 0;
d1054 1
a1054 1
    return 0;
@


1.311
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a16 3
#include <time.h>
#include <sys/wait.h>
#include <stdlib.h>
a17 2
#include <assert.h>
#include <sys/signal.h>
a18 1
#include "sync.h"
a19 1
#include "security.h"
a27 1
#include "exceptions.h"
@


1.310
log
@	* Fix copyright dates.
@
text
@d15 1
@


1.309
log
@* hookapi.cc (find_first_notloaded_dll): New function.
* pinfo.cc (status_exit): New function.  Issue message when dll not found.  Use
find_first_notloaded_dll to find a nonexistent dll.
(pinfo::maybe_set_exit_code_from_windows): Call status_exit when exit code >=
0xc0000000UL.
* sigproc.cc (child_info::proc_retry): Return exit code when
STATUS_DLL_NOT_FOUND.
* spawn.cc (spawn_guts): Minor cleanup.
* syscalls.cc (close_all_files): Don't actually close stderr filehandle.  Just
make it noninheritable.
* winsup.h (find_first_notloaded_dll): Declare new function.
* ntdll.h: Add several missing NTSTATUS defines.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
@


1.308
log
@* cygtls.h (_cygtls::handle_threadlist_exception): Eliminate.
(_cygtls::init_threadlist_exceptions): Ditto.
* cygtls.cc (_cygtls::handle_threadlist_exception): Eliminate.
(_cygtls::init_threadlist_exceptions): Ditto.
(_cygtls::find_tls): Use myfault handling to deal with errors caused by
nonexistent threads.
@
text
@d35 1
d939 2
@


1.307
log
@* sigproc.cc (sig_send): Use sigmask of target thread if it is specified
otherwise default to main sigmask.
@
text
@a1168 1
  _sig_tls->init_threadlist_exceptions ();
@


1.306
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d666 1
a666 1
    pack.mask = &_my_tls.sigmask;
d676 1
a676 1
  pack.tls = (_cygtls *) tls;
@


1.305
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d666 1
a666 1
    pack.mask = &myself->getsigmask ();
d1121 1
a1121 1
  se->mask = &myself->getsigmask ();
d1202 1
a1202 1
	  dummy_mask = myself->getsigmask ();
d1221 1
a1221 1
	    if (myself->getsigmask () & (bit = SIGTOMASK (q->si.si_signo)))
@


1.304
log
@* init.cc (in_dllentry): Delete.
(dll_entry): Remove assignment to deleted variable.
* winsup.h (in_dllentry): Delete declaration.
* exceptions.cc (inside_kernel): Use another method to see if we are in
dll_entry phase.
@
text
@d116 1
a116 1
    (struct sigaction *) ccalloc (HEAP_SIGS, NSIG, sizeof (struct sigaction));
@


1.303
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d42 1
a42 1
#define no_signals_available(x) (!hwait_sig || hwait_sig == INVALID_HANDLE_VALUE || ((x) && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls || in_dllentry)
@


1.302
log
@	* sigproc.cc (child_info::child_info): Set msv_count to non-zero
	value only on systems requiring it.
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
@


1.301
log
@	Revert erroneous checkin.
@
text
@d807 2
a808 2
     However, since this doesn't seem to harm normal windows operation we'll
     just set it unconditionally until we hear complaints.
d814 1
a814 1
  msv_count = in_cb / 5;
@


1.300
log
@	* Makefile.in (DLL_OFILES): Add minires-os-if.o and minires.o.
	(SUBLIBS): Add libresolv.a.
	Add rule for libresolv.a.
	* autoload.cc: Fix return code handling for IP Helper API in case
	of being unable to load iphlpapi.dll.
	(DnsQuery_A): Define.
	(DnsRecordListFree): Define.
	* cygwin.din: Export resolver functions.
	* include/resolv.h: New header.
	* include/arpa/nameser.h: New header.
	* include/arpa/nameser_compat.h: New header.
	* include/cygwin/version.h: Bump API minor number.
	* libc/minires-os-if.c: New file.
	* libc/minires.c: New file.
	* libc/minires.h: New file.
@
text
@a517 1
      CloseHandle (my_sendsig);
@


1.299
log
@* sigproc.cc (child_info::child_info): Move old comment about msv_count here.
Edit it slightly to reflect new sensibilities.
@
text
@d518 1
@


1.298
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d791 23
@


1.297
log
@* sigproc.cc (waitq_head): Don't initialize to zero.
* sigproc.h: Update copyright, fix whitespace.
@
text
@d790 3
@


1.297.2.1
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@a789 26

  /* It appears that when running under WOW64 on Vista 64, the first DWORD
     value in the datastructure lpReserved2 is pointing to (msv_count in
     Cygwin), has to reflect the size of that datastructure as used in the
     Microsoft C runtime (a count value, counting the number of elements in
     two subsequent arrays, BYTE[count and HANDLE[count]), even though the C
     runtime isn't used.  Otherwise, if msv_count is 0 or too small, the
     datastructure gets overwritten.

     This seems to be a bug in Vista's WOW64, which apparently copies the
     lpReserved2 datastructure not using the cbReserved2 size information,
     but using the information given in the first DWORD within lpReserved2
     instead.  32 bit Windows and former WOW64 don't care if msv_count is 0
     or a sensible non-0 count value.  However, it's not clear if a non-0
     count doesn't result in trying to evaluate the content, so we do this
     really only for Vista 64 for now.

     However, since this doesn't seem to harm normal windows operation we'll
     just set it unconditionally until we hear complaints.

     The value is sizeof (child_info_*) / 5 which results in a count which
     covers the full datastructure, plus not more than 4 extra bytes.  This
     is ok as long as the child_info structure is cosily stored within a bigger
     datastructure. */
  msv_count = in_cb / 5;

@


1.297.2.2
log
@	* sigproc.cc (child_info::child_info): Set msv_count to non-zero
	value only on systems requiring it.
@
text
@d807 2
a808 2
     Note: It turns out that a non-zero value *does* harm operation on
     XP 64 and 2K3 64.
d814 1
a814 1
  msv_count = wincap.needs_count_in_si_lpres2 () ? in_cb / 5 : 0;
@


1.297.2.3
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d42 1
a42 1
#define no_signals_available(x) (!hwait_sig || hwait_sig == INVALID_HANDLE_VALUE || ((x) && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls)
@


1.297.2.4
log
@	* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and
	use either main sigmask or current thread sigmask.
	(set_process_mask): Ditto.
	(sighold): Ditto.
	(sigrelse): Ditto.
	(sigset): Ditto.
	(set_process_mask_delta): Ditto.
	(_cygtls::call_signal_handler): Ditto.
	* fhandler_process.cc (format_process_status): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* pinfo.h (class pinfo): Ditto.
	* select.cc (pselect): Ditto.
	* signal.cc (sigprocmask): Ditto.
	(abort): Ditto.
	(sigpause): Ditto.
	(sigsend): Ditto.
	(wait_sig): Ditto.
	* sigproc.cc (sig_send): Ditto.
	(pending_signals::add): Ditto.
	(wait_sig): Ditto.
	* thread.h (pthread::parent_tls): New member.
	* thread.cc (pthread::pthread): Record parent_tls here.
	(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d666 1
a666 1
    pack.mask = &_my_tls.sigmask;
d1121 1
a1121 1
  se->mask = &pack.tls->sigmask;
d1202 1
a1202 1
	  dummy_mask = _main_tls->sigmask;
d1221 1
a1221 1
	    if (pack.tls->sigmask & (bit = SIGTOMASK (q->si.si_signo)))
@


1.297.2.5
log
@	* sigproc.cc (sig_send): Use sigmask of target thread if it is
	specified otherwise default to main sigmask.
@
text
@d666 1
a666 1
    pack.mask = tls ? &tls->sigmask : &_main_tls->sigmask;
d676 1
a676 1
  pack.tls = tls;
@


1.297.2.6
log
@2008-03-01  Christopher Faylor  <me+cygwin@@cgf.cx>

	* cygtls.h (_cygtls::handle_threadlist_exception): Eliminate.
	(_cygtls::init_threadlist_exceptions): Ditto.
	* cygtls.cc (_cygtls::handle_threadlist_exception): Eliminate.
	(_cygtls::init_threadlist_exceptions): Ditto.
	(_cygtls::find_tls): Use myfault handling to deal with errors caused by
	nonexistent threads.
	* sigproc.cc (wait_sig): Eliminate call to init_threadlist_exceptions.

2008-03-01  Christopher Faylor  <me+cygwin@@cgf.cx>

	* cygtls.cc (_cygtls::init_exception_handler): Just return.

2008-03-01  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (_cygtls::handle_exceptions): Only call rtl_unwind when
	exiting.  Just return, don't set thread context.
	* gendef (_setjmp): Store %fs:0 in jmp_buf.
	(_sjfault): Ditto.
	(_ljfault): Restore %fs:0 from jmp_buf.
	(_longjmp): Ditto.
@
text
@d1169 1
@


1.296
log
@* fhandler.cc (fhandler_base::raw_read): Only return EISDIR when we're really
trying to read a directory.
* sigproc.cc: Use "Static" where appropriate.
@
text
@d73 1
a73 1
Static waitq waitq_head = {0, 0, 0, 0, 0, 0, 0};// Start of queue for wait'ing threads
@


1.295
log
@* sigproc.cc (child_info::proc_retry): Mask all of the bits we're interested
in, which includes bits above and below 0xc0000000.
@
text
@d64 1
a64 1
cygthread *hwait_sig;
d67 1
a67 1
static NO_COPY bool sigheld;		// True if holding signals
d75 1
a75 1
static muto NO_COPY sync_proc_subproc;	// Control access to subproc stuff
d109 1
a109 1
static pending_signals sigq;
@


1.295.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d64 1
a64 1
cygthread NO_COPY *hwait_sig;
d67 1
a67 1
Static bool sigheld;			// True if holding signals
d73 1
a73 1
Static waitq waitq_head;		// Start of queue for wait'ing threads
d75 1
a75 1
Static muto sync_proc_subproc;	// Control access to subproc stuff
d109 1
a109 1
Static pending_signals sigq;
@


1.294
log
@* child_info.h (_CI_SAW_CTRL_C): New enum.
(CURR_CHILD_INFO_MAGIC): Reset.
(saw_ctrl_c): New function.
(set_saw_ctrl_c): Ditto.
* sigproc.cc (child_info::proc_retry): Return EXITCODE_OK if we get
STATUS_CONTROL_C_EXIT and we actually saw a CTRL-C.
* spawn.cc (dwExeced): Delete.
(chExeced): New variable.
(spawn_guts): Set chExeced;
* exceptions.cc (dwExeced): Delete declaration.
(chExeced): Declare.
(ctrl_c_handler): Detect if we're an exec stub process and set a flag, if so.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Add extra
DEBUGGING test.
* pinfo.cc: Fix comment.
@
text
@d925 1
a925 1
      if (!iscygwin () && (exit_code & 0xc0000000) != 0xc0000000)
@


1.293
log
@* sigproc.cc (no_signals_available): Detect hwait_sig == INVALID_HANDLE_VALUE.
(wait_sig): Set hwait_sig to INVALID_HANDLE_VALUE on __SIGEXIT.
* cygtls.cc (_cygtls::init_thread): Zero entire _my_tls structure and no more.
* cygtls.h (_my_tls::padding): Delete.
(CYGTLS_PADSIZE): Redefine concept of padding to mean padding at the end of the
stack.
* dcrt0.cc (initialize_main_tls): Change return to void.
* gentls_offsets: Treat const specially, too.  Keep going after a '}' is found.
Change negative offset calculation to use CYGTLS_PADSIZE.
* init.cc (_my_oldfunc): New variable.
(threadfunc_fe): Use stored tls value for oldfunc rather than blindly writing
to the stack.
(munge_threadfunc): Set oldfunc in tls.
(dll_entry): Initialize tls allocation.
* tlsoffsets.h: Regenerate.
@
text
@d913 3
@


1.292
log
@* sigproc.cc (wait_for_sigthread): Use the current user sid when setting up the
signal pipe rather than relying on (eventually) the effective sid.
@
text
@d42 1
a42 1
#define no_signals_available(x) (!hwait_sig || ((x) && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls || in_dllentry)
d1212 1
a1212 1
	  hwait_sig = NULL;
@


1.291
log
@* dcrt0.cc (child_info_fork::handle_fork): Set uid/gid in myself so that it can
be used by subsequent startup functions.
(dll_crt0_0): Issue a warning if DuplicateTokenEx fails and DEBUGGING.
(dll_crt0_1): Move user_data->{resourcelocks,threadinterface} initialization
here from dll_crt0_0.
* fork.cc (frok::child): Tell wait_for_sigthread that this is fork.
(frok::parent): Only initialize start_time once.  Tighten time when we're
"deimpersonated".
* sigproc.cc (signal_fixup_after_exec): Rework (futiley) sa_buf stuff.  Add
debugging output.
(wait_for_sigthread): Accept an argument which illustrates whether we are
forked or not.
(wait_sig): Avoid using myself pointer.
* winsup.h ((wait_for_sigthread): Reflect change to argument.
@
text
@d140 1
a140 1
  PSECURITY_ATTRIBUTES sa_buf = sec_user_nih ((PSECURITY_ATTRIBUTES) char_sa_buf);
@


1.290
log
@* sigproc.cc (wait_sig): Move myself manipulation...
(wait_for_sigthread): ...to here.
@
text
@d137 1
a137 1
wait_for_sigthread ()
d139 4
a142 3
  PSECURITY_ATTRIBUTES sa_buf = (PSECURITY_ATTRIBUTES) alloca (1024);
  if (!CreatePipe (&my_readsig, &my_sendsig, sec_user_nih (sa_buf), 0))
    api_fatal ("couldn't create signal pipe, %E");
d155 1
a501 2

  sigproc_printf ("process/signal handling enabled, state %p", myself->process_state);
a1136 1
  sigproc_printf ("myself->dwProcessId %u", myself->dwProcessId);
d1141 2
a1142 2
  debug_printf ("entering ReadFile loop, my_readsig %p, myself->sendsig %p",
		my_readsig, myself->sendsig);
@


1.289
log
@* sigproc.cc (sigalloc): Don't set SA_RESTART here.
* signal.cc (_SA_NORESTART): New flag.
(sigaction_worker): New function, derived from sigaction.  Don't set internal
flags unless called internally.
(sigaction): Use sigaction_worker.
(signal): Honor new _SA_NORESTART flag.
(siginterrupt): Set _SA_NORESTART flag appropriately.  Use sigaction_worker to
set flags.
* include/cygwin/signal.h: Define _SA_INTERNAL_MASK here.
@
text
@d144 4
a1136 8
  /* Setting dwProcessId flags that this process is now capable of receiving
     signals.  Prior to this, dwProcessId was set to the windows pid of
     of the original windows process which spawned us unless this was a
     "toplevel" process.  */
  myself->process_state |= PID_ACTIVE;
  myself->process_state &= ~PID_INITIALIZING;

  _sig_tls = &_my_tls;
d1140 1
@


1.288
log
@* fhandler.cc (fcntl): Print flags in hex.
* dcrt0.cc (dll_crt0_0): Semi-revert 2006-03-14 change which moved pinfo_init
and uinfo_init here.
(dll_crt0_1): Ditto.
(__dll_crt0): Ditto.  Don't call update_envptrs here.
(dll_crt0_1): Ditto.  Move wait_for_sigthread call here from dll_crt0_0.
* environ.cc (environ_init): Call it here instead.
* sigproc.cc (my_readsig): New static variable.
(wait_for_sigthread): Set up read pipe here since we are assured that we have
the proper privileges when this is called.
(talktome): Eliminate second argument since it is available as a global now.
(wait_sig): Reflect use of my_readsig.
@
text
@a117 4
  for (int i = 0; i < NSIG; i++)
    /* SA_RESTART is set to maintain BSD compatible signal behaviour by default.
       This is also compatible with the behaviour of signal(2) in Linux. */
    global_sigs[i].sa_flags = SA_RESTART;
@


1.287
log
@* signal.cc (signal): Don't set SA_RESTART here.
(siginterrupt): White space.
* sigproc.cc (sigalloc): Set SA_RESTART here, on initialization.
@
text
@d67 1
a67 1
static bool sigheld;			// True if holding signals
d79 3
a87 1
static HANDLE NO_COPY my_sendsig;
d143 5
d153 1
d1060 1
a1060 1
talktome (siginfo_t *si, HANDLE readsig)
d1068 1
a1068 1
      if (!ReadFile (readsig, &n, sizeof (n), &nb, NULL) || nb != sizeof (n))
d1073 1
a1073 1
      if (!ReadFile (readsig, newsi->_si_commune._si_str, n, &nb, NULL) || nb != n)
a1131 3
  HANDLE readsig;
  PSECURITY_ATTRIBUTES sa_buf = (PSECURITY_ATTRIBUTES) alloca (1024);

a1135 4
  if (!CreatePipe (&readsig, &my_sendsig, sec_user_nih (sa_buf), 0))
    api_fatal ("couldn't create signal pipe, %E");
  ProtectHandle (readsig);
  myself->sendsig = my_sendsig;
d1149 2
a1150 2
  debug_printf ("entering ReadFile loop, readsig %p, myself->sendsig %p",
		readsig, myself->sendsig);
d1153 1
a1153 2
  if (in_forkee)
    pack.si.si_signo = __SIGHOLD;
d1160 1
a1160 1
      if (!ReadFile (readsig, &pack, sizeof (pack), &nb, NULL))
d1190 1
a1190 1
	  talktome (&pack.si, readsig);
d1263 1
a1263 1
  ForceCloseHandle (readsig);
@


1.286
log
@* child_info.h (child_status): Fix typo which made it impossible to set
iscygwin.
(child_info::isstraced): Booleanize.
(child_info::iscygwin): Ditto.
* sigproc.cc (child_info::child_info): Minor cleanup of flag setting.
* spawn.cc (spawn_guts): Only close_all_files when we know the process has
started successfully.
* exceptions.cc (init_console_handler): Fix indentation.
@
text
@d116 4
@


1.285
log
@* child_info.h (child_status): New enum.
(child_info::flag): Rename from 'straced'.
(child_info::isstraced): New function.
(child_info::iscygwin): Ditto.
(child_info_fork::handle_fork): Reparmize.
(child_info_fork::handle_failure): Ditto.
(child_info_spawn::handle_spawn): New function.
* dcrt0.cc (get_cygwin_startup_info): Use isstraced method.
(child_info_spawn::handle_spawn): Define new function from code previously in
dll_crt0_0.
(dll_crt0_0): Move spawn stuff into handle_spawn.  Only call
init_console_handler for fork case.
* sigproc.cc (child_info::child_info): Set flag appropriately.
(child_info::proc_retry): Treat exit code as "funny" if it's a cygwin process.
* spawn.cc (spawn_guts): Remove commented out flag setting.
@
text
@d783 2
d786 4
a789 1
    subproc_ready = CreateEvent (&sec_all, FALSE, FALSE, NULL);
a792 5
  flag = 0;
  if (strace.attached ())
    flag |= _CI_STRACED;
  if (need_subproc_ready)
    flag |= _CI_ISCYGWIN;
@


1.284
log
@revert previous debugging checkin
@
text
@d788 5
a792 1
  straced = strace.attached ();
d910 1
a910 1
      if ((exit_code & 0xc0000000) != 0xc0000000)
@


1.283
log
@* pinfo.cc (commune_process): Fix randomly invalid pointer which caused fifos
to work incorrectly.
@
text
@d682 4
a685 8
      char *p = leader = (char *) alloca (sizeof (pack) + sizeof (n) + n /*DELETEME*/ + 1);
      memcpy (p, &pack, sizeof (pack));
      p += sizeof (pack);
      memcpy (p, &n, sizeof (n));
      p += sizeof (n);
      memcpy (p, si._si_commune._si_str, n);
p[n] = '\0'; sigproc_printf ("n %d, si_str %s", n, p);
      p += n;
@


1.282
log
@* pinfo.h (EXITCODE_OK): Define new constant.
* sigproc.cc (child_info::sync): Return EXITCODE_OK if entering with exit_code
== 0.
(sig_send): Don't complain if sending signals while blocked if the sender isn't
in the main thread.
@
text
@d682 8
a689 4
      char *p = leader = (char *) alloca (sizeof (pack) + sizeof (n) + n);
      memcpy (p, &pack, sizeof (pack)); p += sizeof (pack);
      memcpy (p, &n, sizeof (n)); p += sizeof (n);
      memcpy (p, si._si_commune._si_str, n); p += n;
@


1.281
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Regenerate.
(child_info::retry): Move here from fork subclass.
(child_info::exit_code): New field.
(child_info::retry_count): Max retry count for process start.
(child_info::proc_retry): Declare new function.
(child_info_fork::retry): Move to parent.
(child_info_fork::fork_retry): Ditto.
* dcrt0.cc (child_info::fork_retry): Rename and move.
(child_info_fork::handle_failure): Move.
(dll_crt0_0): Initialize console handler based on whether we have a controlling
tty or not.  Avoid nonsensical check for fork where it can never occur.
* environ.cc (set_proc_retry): Rename from set_fork_retry.  Set retry_count in
child_info.
(parse_thing): Reflect above change.
* exceptions.cc (dummy_ctrl_c_handler): Remove unused variable name.
(ctrl_c_handler): Always return TRUE for the annoying CTRL_LOGOFF_EVENT.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Remove call to
init_console_handler.
* fhandler_tty.cc (fhandler_tty_slave::open): Just call mange_console_count
here and let it decide what to do with initializing console control handling.
* fork.cc (fork_retry): Remove definition.
(frok::parent): Define static errbuf and use in error messages (not thread safe
yet).  Close pi.hThread as soon as possible.  Protect pi.hProcess as soon as
possible.  Don't set retry_count.  That happens automatically in the
constructor now.  Accommodate name change from fork_retry to proc_retry.
* init.cc (dll_entry): Turn off ctrl-c handling early until we know how it is
supposed to be handled.
* pinfo.cc (_pinfo::dup_proc_pipe): Remember original proc pipe value for
failure error message.  Tweak debug message slightly.
* sigproc.cc (child_info::retry_count): Define.
(child_info::child_info): Initialize retry count.
(child_info::sync): Set exit code if process dies before synchronization.
(child_info::proc_retry): Rename from child_info_fork::fork_retry.  Use
previously derived exit code.  Be more defensive about what is classified as an
error exit.
(child_info_fork::handle_failure): Move here from dcrt0.cc.
* spawn.cc (spawn_guts): Maintain error mode when starting new process to avoid
annoying pop ups.  Move deimpersonate call within new loop.  Move envblock
freeing to end.  Loop if process dies prematurely with bad exit code.
* syscalls.cc (init_console_handler): Remove hopefully unneeded call to
init_console_handler.
@
text
@d523 1
a523 1
  else
d889 2
@


1.280
log
@* child_info.h (child_info_fork::fork_retry): Declare new function.
* dcrt0.cc (child_info_fork::fork_retry): Define new function.
* fork.cc (frok::parent): Move retry decision into child_info_fork::fork_retry
and honor what it tells us to do.
* sigproc.cc (sig_send): Unhold signals on __SIGEXIT.
@
text
@d526 1
a526 1
      system_printf ("signal %d sent to %p while signals are on hold", p, sig);
d770 1
d789 1
d867 4
a870 1
	res = type != _PROC_FORK;
d873 2
a879 1
	  res = true;
d886 38
@


1.279
log
@* dcrt0.cc (main_environ): Initialize to &__cygwin_environment.
(dll_crt0_1): Move resourcelocks, thread interface, pinfo_init, and
uinfo_init...
(dll_crt0_0): ...to here.
(_dll_crt0): Call update_envptrs here after setting main_environ.
* environ.cc (environ_init): Eliminate initted variable.  Don't call
update_envptrs here.
* sigproc.cc (wait_sig): Use my_sendsig when calling CreatePipe to avoid a
dereference.
@
text
@d518 1
a518 1
  else if (sig == __SIGNOHOLD)
@


1.278
log
@* child_info.h (child_info_fork::handle_failure): Declare new function.
(child_info_fork::retry): New field.
* dcrt0.cc (__api_fatal_exit_val): Define.
(child_info_fork::handle_failure): Define new function.
(__api_fatal): Exit using __api_fatal_exit_val value.
* environ.cc (set_fork_retry): Set fork_retry based on CYGWIN environment
variable.
(parse_thing): Add "fork_retry" setting.
* fork.cc (fork_retry): Define.
(frok::parent): Reorganize to allow retry of failed child creation if child
signalled that it was ok to do so.
* heap.cc (heap_init): Signal parent via handle_failure when VirtualAlloc
fails.
* pinfo.h (EXITCODE_RETRY): Declare.
* sigproc.cc (child_info::sync): Properly exit with failure condition if called
for fork and didn't see subproc_ready.
* spawn.cc (spawn_guts): Use windows pid as first argument.
* winsup.h: Remove obsolete NEW_MACRO_VARARGS define.
(__api_fatal_exit_val): Declare.
(set_api_fatal_return): Define.
(in_dllentry): Declare.
* exceptions.cc (inside_kernel): Remove unneeded in_dllentry declaration.
@
text
@d526 1
a526 1
      system_printf ("internal signal sent while signals are on hold");
d1076 2
a1077 1
  if (!CreatePipe (&readsig, &myself->sendsig, sec_user_nih (sa_buf), 0))
d1080 1
a1080 2
  sigCONT = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
  my_sendsig = myself->sendsig;
@


1.277
log
@* dcrt0.cc (dll_crt0_0): Reorganize so that sigproc_init is called a little
later.  Add a comment.
* fork.cc (resume_child): Make void.
(frok::parent): Only zero pi when necessary.  Explicitly zero si.  Set
this_errno when child_copy fails.  Accommodate change to resume_child.
* sigproc.cc (sigalloc): Move global_sigs initialization here.
(sigproc_init): Move global_sigs.
(sig_send): Just check for flush signals once.
* wincap.h: Define supports_setconsolectrlhandler_null throughout.
* wincap.cc: Ditto.
@
text
@d42 1
a42 1
#define no_signals_available(x) (!hwait_sig || ((x) && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls)
d859 1
a859 1
      system_printf ("wait failed, pid %d, %E", pid);
d864 3
a866 1
      if (type == _PROC_EXEC && x == nsubproc_ready && myself->wr_proc_pipe)
d868 6
a873 2
	  ForceCloseHandle1 (hProcess, childhProc);
	  hProcess = NULL;
d875 1
a875 2
      sigproc_printf ("process %d synchronized, WFMO returned %d", pid, x);
      res = true;
@


1.276
log
@* cygtls.h (CYGTLS_INITIALIZED): Change to a little more unlikely value.
(CYGTLSMAGIC): Delete.
* dcrt0.cc (dll_crt0_0): Call sigproc_init during init startup.
(_dll_crt0): Don't worry about sync_startup.  Just wait for sigthread here.
* dll_init.cc (cygwin_detach_dll): Only pick up tls version of retaddr if we
have a valid tls.
* fork.cc (frok::child): Remove sigproc_init initialization since it happens
much earlier now.
* gendef: Recognize SIGFE_MAYBE.
(fefunc): Generate calls to _sigfe_maybe, if appropriate.
(_sigfe_maybe): New function.
* init.cc (search_for): Always initialize search_for, even on fork.
(calibration_thread): Delete.
(calibration_id): Delete.
(prime_threads): Delete.
(munge_threadfunc): Remove calibration_thread special case.  Avoid calling
thread function if we haven't yet hit the "search_for" thread.
(dll_entry): Remove prime_threads call.  Only call munge_threadfunc when
hwait_sig is active.  Ditto.  for _my_tls.remove ();
* sigproc.cc (hwait_sig): Make global.
(sigproc_init): Don't bother with sync_startup.
(sig_send): Treat flush as a no-op when signals are held.
(wait_sig): Cause signals to be held after fork.
@
text
@d115 1
d483 1
a483 2
   * access to the children and proc arrays.
   */
a488 1
  global_sigs[SIGSTOP].sa_flags = SA_RESTART | SA_NODEFER;
d516 8
a523 1
  else if (sig != __SIGNOHOLD && sig != __SIGFLUSH && sig != __SIGFLUSHFAST)
a529 7
  else if (sig == __SIGFLUSH || sig == __SIGFLUSHFAST)
    return 0;
  else
    {
      SetEvent (sigCONT);
      sigheld = false;
    }
@


1.275
log
@* sigproc.cc: Fix a comment.
@
text
@d64 1
a64 1
Static cygthread *hwait_sig;
d67 1
a67 1
Static bool sigheld;			// True if holding signals
a477 1
  extern HANDLE sync_startup;
a485 1
  sync_startup = NULL;
d524 2
d1094 2
d1098 2
a1200 2
      if (pack.si.si_signo == __SIGHOLD)
	WaitForSingleObject (sigCONT, INFINITE);
@


1.274
log
@* sigproc.cc (sigheld): Define new variable.
(sig_dispatch_pending): Don't check sigq since that's racy.
(sig_send): Set sigheld flag if __SIGHOLD is specified, reset it if __SIGNOHOLD
is specified.  Ignore flush signals if we're holding signals.
@
text
@d376 4
a379 5
 * Called on process exit.
 * Also called by spawn_guts to disassociate any subprocesses from this
 * process.  Subprocesses will then know to clean up after themselves and
 * will not become procs.
 */
@


1.273
log
@Always zero all elements of siginfo_t throughout.
* cygtls.h (_cygtls::thread_context): Declare new field.
(_cygtls::thread_id): Ditto.
(_cygtls::signal_exit): Move into this class.
(_cygtls::copy_context): Declare new function.
(_cygtls::signal_debugger): Ditto.
* cygtls.cc (_cygtls::init_thread): Fill out thread id field.
* exceptions.cc (exception): Change message when exception info is unknown.
Copy context to thread local storage.
(_cygtls::handle_exceptions): Avoid double test for fault_guarded.  Reflect
move of signal_exit to _cygtls class.
(sigpacket::process): Copy context to thread local storage.
(_cygtls::signal_exit): Move to _cygtls class.  Call signal_debugger to notify
debugger of exiting signal (WIP).  Call stackdump here (WIP).
(_cygtls::copy_context): Define new function.
(_cygtls::signal_debugger): Ditto.
* tlsoffsets.h: Regenerate.
* include/cygwin.h (_fpstate): New internal structure.
(ucontext): Declare new structure (WIP).
(__COPY_CONTEXT_SIZE): New define.
* exceptions.cc (_cygtls::interrupt_setup): Clear "threadkill" field when there
is no sigwaiting thread.
(setup_handler): Move event handling into interrupt_setup.
@
text
@d67 1
d444 1
a444 1
  if (exit_state || &_my_tls == _sig_tls || !sigq.start.next)
d516 16
a531 2
  if (sig == __SIGNOHOLD)
    SetEvent (sigCONT);
@


1.272
log
@* sigproc.cc (no_signals_available): Use existence of signal thread handle to
figure out if we can actually send signals rather than relying on my_sendsig.
(hwait_sig): Make static.
(sigproc_init): Don't set my_sendsig to anything special.  Use new global
static hwait_sig.
(wait_sig): Set hwait_sig to NULL when we are exiting.
@
text
@d517 1
a517 1
  siginfo_t si;
@


1.271
log
@(fix ChangeLog and check in remaining files)
* sigproc.cc (sigproc_init): Move clearing of sync_startup here to lessen the
likelihood of trying to deal with non-cygwin threads in dll_entry.
* fhandler_console: Fix set_console_state_for_spawn comment.
@
text
@d42 1
a42 1
#define no_signals_available(x) (!my_sendsig || ((x) && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls)
d64 1
a486 1
  my_sendsig = INVALID_HANDLE_VALUE;	// changed later
d488 1
a488 1
  cygthread *hwait_sig = new cygthread (wait_sig, 0, cygself, "sig");
d1144 1
@


1.270
log
@add copyright
@
text
@d477 1
d487 1
@


1.269
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@d3 2
a4 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
@


1.268
log
@* cygtls.cc (_cygtls::handle_threadlist_exception): Make an error fatal.
* cygtls.h (sockaddr_in): Use header rather than defining our own structure.
* exceptions.cc (_cygtls::interrupt_setup): Use exact contents of sa_mask
rather than assuming tht current sig should be masked, too.
(_cygtls::call_signal_handler): Use more aggressive locking.
* gendef (_sigbe): Wait until later before releasing incyg.
(_sigreturn): Remove more arguments to accommodate quasi-sa_sigaction support.
(_sigdelayed): Push arguments for sa_sigaction.  More work needed here.
* signal.cc (sigaction): Implement SA_NODEFER.
* tlsoffsets.h: Regenerate.

* sigproc.cc (wait_sig): Use default buffer size of Windows 9x complains.
* pinfo.cc (_onreturn::dummy_handle): Remove.
(_onreturn::h): Make this a pointer.
(_onreturn::~_onreturn): Detect whether pointer is NULL rather than value is
NULL.
(_onreturn::_onreturn): Set h to NULL initially.
(_onreturn::no_close_p_handle): Set h to NULL.
(winpids::add): Initialize onreturn with value from p.hProcess immediately.
@
text
@d771 1
a771 1
  dwProcessId = myself->dwProcessId;
@


1.267
log
@* fork.cc (fork): Honor error return from sig_send.  Don't continue with fork
if we couldn't suspend signals.
* sigproc.cc (sig_send): Set sigCONT event when we see __SIGNOHOLD.
(wait_sig): Remove holding_signals.  Create pipe with a buffer which will
theoretically cause blocking if there is nothing reading on the pipe.  Wait for
sigCONT at end of loop when we have a __SIGHOLD.
@
text
@d1055 1
a1055 1
  if (!CreatePipe (&readsig, &myself->sendsig, sec_user_nih (sa_buf), sizeof (sigpacket) - 4))
@


1.266
log
@* fhandler.h (fhandler_pipe::fixup_in_child): Declare new function.
(fhandler_console::invisible_console): Declare new variable.
(fhandler_console::need_invisible): Ditto.
(fhandler_console::has_a): Ditto.
* fhandler_console.cc (set_console_state_for_spawn): Eliminate return value.
Set up an invisible console if necessary prior to spawning.
(fhandler_console::invisible_console): Define.
* fhandler_tty.cc (fhandler_tty_slave::open): Use
fhandler_console::invisible_console to setup an invisible console.
* pipe.cc (fhandler_pipe::fixup_in_child): Define new function from
fixup_after_exec.
(fhandler_pipe::fixup_after_exec): Use fixup_in_child when appropriate.
(fhandler_pipe::fixup_after_fork): Ditto.
* spawn.cc (handle): Reorganize and modernize a little.
(spawn_guts): Rely on set_console_state_for_spawn to set the console into the
right state but don't create the process with "detached" flag if we have no
controlling tty since that confuses 'cmd'.
* dtable.cc (dtable::stdio_init): Don't set console as controlling terminal if
we have an invisible console.
* sigproc.cc (child_info::sync): Use correct name in ForceCloseHandle1.
@
text
@d512 2
a1050 1
  Static bool holding_signals;
d1055 1
a1055 1
  if (!CreatePipe (&readsig, &myself->sendsig, sec_user_nih (sa_buf), 0))
d1125 1
a1125 1
	  holding_signals = 1;
a1127 2
	  holding_signals = 0;
	  /* fall through, intentionally */
a1145 2
	  else if (holding_signals)
	    sigq.add (pack);
d1173 1
d1179 2
@


1.265
log
@* cygtls.cc (_cygtls::remove): Don't bother if we're exiting.
* sigproc.cc (_cygtls::remove_wq): Ditto.
@
text
@d848 1
a848 1
	  ForceCloseHandle1 (hProcess, childhProcess);
@


1.264
log
@* cygtls.h (_cygtls::el): New field.
(_cygtls::handle_exceptions): New function declaration.
(_cygtls::handle_threadlist_exception): Ditto.
(_cygtls::init_exception_handler): Ditto.
(_cygtls::init_threadlist_exceptions): Remove arg from declaration.
* cygtls.cc (_cygtls::call2): Don't initialize exceptions here.
(_cygtls::init_thread): Do it here instead and use member function.
(_cygtls::handle_threadlist_exception): Move into _cygtls class.
(_cygtls::init_exception_handler): Ditto.  Rely on existence of 'el' memmber in
_cygtls.
(_cygtls::init_threadlist_exceptions): Ditto.
* dcrt0.cc (dll_crt0_1): Remove exception_list definition and setting since it
now commonly resides in the tls.
* exceptions.cc (init_exception_handler): Move to cygtls.cc.
(init_exceptions): Ditto.
(rtl_unwind): New, safe wrapper function for RtlUnwind.
(_cygtls::handle_exceptions): Move to _cygtls.  Call rtl_unwind to unwind
frames and eliminate copying of structures.  Put address of failing instruction
in si_addr, not the address on the stack.  Return 0 to indicate that we've
handled this exception.
* external.cc (cygwin_internal): Make CW_INIT_EXCEPTIONS a no-op.
* sigproc.cc (wait_sig): Accommodate argument change to
_cygtls::init_threadlist_exceptions.
* tlsoffsets.h: Regenerate.
* include/exceptions.h (exception_list): Add more stuff to the exception list.
Apparently windows needs this?
(init_exceptions): Remove bogus declaration.
* include/cygwin/signal.h (SI_USER): Redefine as zero as per SUSv3.
* thread.cc (pthread_kill): Set si_pid and si_uid.
* timer.cc (timer_thread): Set si_code to SI_TIMER.
@
text
@d358 2
a359 1
  if (sync_proc_subproc && sync_proc_subproc.acquire (wait))
@


1.263
log
@* fork.cc (frok::child): Change order of cleanup prior to return.
(fork): Save more of the stack.
* gendef: Fix some comments.
* sigproc.cc (wait_sig): Clarify debug output.
@
text
@d1070 1
a1070 2
  exception_list el;
  _sig_tls->init_threadlist_exceptions (&el);
@


1.262
log
@* cygheap.h (cygheap_fdenum::cygheap_fdenum): Record locked state or suffer
deadlocks.
(class locked_process): Move to another header.
* sync.h (lock_process): Define here.
* cygtls.cc (_cygtls::fixup_after_fork): Reset spinning state as well as
stacklock state.
* dcrt0.cc (lock_process::locker): Define.
(dtable::lock_cs): Delete.
* dtable.cc (dtable_init): Eliminate call to init_lock().
(dtable::fixup_after_fork): Ditto.
(dtable::init_lock): Delete definition.
* dtable.h (dtable::init_lock): Delete declaration.
(dtable::lock): Use process lock rather than dtable-specific lock.
(dtable::unlock): Ditto.
* sigproc.cc (sigproc_init): Minor change to debugging output.
* times.cc (utime_worker): Use build_fh_pc rather than reinterpreting the posix
path name again.  Return any error from path_conv immediately.
@
text
@d1178 1
a1179 1
	  sigproc_printf ("signalled %p", pack.wakeup);
@


1.261
log
@* sigproc.cc (child_info::sync): Move check for !wr_proc_pipe lower.
* spawn.cc (spawn_guts): Correct check for top-level process.
@
text
@d488 1
a488 1
  sigproc_printf ("process/signal handling enabled(%x)", myself->process_state);
@


1.260
log
@* cygtls.cc (handle_threadlist_exception): Improve diagnostic output.
* sigproc.cc (child_info::sync): Only clear hProcess when execing.
(wait_sig): Protect readsig handle.
@
text
@d822 6
a827 2
  if (!subproc_ready && !myself->wr_proc_pipe)
    res = false;
d830 4
a833 12
      HANDLE w4[2];
      unsigned n = 0;
      unsigned nsubproc_ready;

      if (!subproc_ready)
	nsubproc_ready = WAIT_OBJECT_0 + 3;
      else
	{
	  w4[n++] = subproc_ready;
	  nsubproc_ready = 0;
	}
      w4[n++] = hProcess;
d835 11
a845 9
      sigproc_printf ("n %d, waiting for subproc_ready(%p) and child process(%p)", n, w4[0], w4[1]);
      DWORD x = WaitForMultipleObjects (n, w4, FALSE, howlong);
      x -= WAIT_OBJECT_0;
      if (x >= n)
	{
	  system_printf ("wait failed, pid %d, %E", pid);
	  res = false;
	}
      else
d847 2
a848 7
	  if (type == _PROC_EXEC && x == nsubproc_ready)
	    {
	      ForceCloseHandle1 (hProcess, childhProcess);
	      hProcess = NULL;
	    }
	  sigproc_printf ("process %d synchronized, WFMO returned %d", pid, x);
	  res = true;
d850 2
@


1.259
log
@* sigproc.cc (child_info::sync): Use correct name when closing to prevent
warnings when DEBUGGING.
* spawn.cc (spawn_guts): Set myself.hProcess to pi.hProcess since this may have
been zeroed by the previous sync.
@
text
@d849 1
a849 1
	  if (type != _PROC_FORK && x == nsubproc_ready)
d1060 1
d1190 1
a1190 1
  CloseHandle (readsig);
@


1.258
log
@* sigproc.cc (child_info::sync): Fix typo which caused hProcess to never be
cleared.  Only clear hProcess when not forking.
@
text
@d851 1
a851 1
	      ForceCloseHandle (hProcess);
@


1.257
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d839 1
a839 1
      sigproc_printf ("waiting for subproc_ready(%p) and child process(%p)", w4[0], w4[1]);
d849 1
a849 1
	  if (n == nsubproc_ready)
d851 1
a851 1
	      CloseHandle (hProcess);
@


1.256
log
@* dcrt0.cc (get_exit_lock): Use myself.lock rather than exit_lock.
* exceptions.cc (exit_lock): Delete.
(events_init): Don't init exit_lock.
* (_pinfo::commune_process): Add per-PICOM debugging.
* sigproc.cc (talktome): Add some temporary debugging statements.
* fhandler_proc.cc (format_proc_cpuinfo): Cosmetic change.
(format_proc_partitions): Ditto.
* syscalls.cc (locked_append): Ditto.
@
text
@d484 1
a484 1
  cygthread *hwait_sig = new cygthread (wait_sig, cygself, "sig");
d819 1
a819 1
child_info::sync (pid_t pid, HANDLE hProcess, DWORD howlong)
d821 4
a824 1
  if (!subproc_ready)
d826 3
a828 3
      sigproc_printf ("not waiting.  subproc_ready is NULL");
      return false;
    }
d830 8
a837 3
  HANDLE w4[2];
  w4[0] = subproc_ready;
  w4[1] = hProcess;
d839 18
a856 18
  bool res;
  sigproc_printf ("waiting for subproc_ready(%p) and child process(%p)", w4[0], w4[1]);
  switch (WaitForMultipleObjects (2, w4, FALSE, howlong))
    {
    case WAIT_OBJECT_0:
      sigproc_printf ("got subproc_ready for pid %d", pid);
      res = true;
      break;
    case WAIT_OBJECT_0 + 1:
      sigproc_printf ("process exited before subproc_ready");
      if (WaitForSingleObject (subproc_ready, 0) == WAIT_OBJECT_0)
	sigproc_printf ("should never happen.  noticed subproc_ready after process exit");
      res = false;
      break;
    default:
      system_printf ("wait failed, pid %d, %E", pid);
      res = false;
      break;
d979 1
a979 1
talktome (siginfo_t& si, HANDLE readsig)
d981 3
a983 4
  sigproc_printf ("pid %d wants some information", si.si_pid);
  pinfo pi (si.si_pid);
  sigproc_printf ("pid %d pi %p", si.si_pid, (_pinfo *) pi); // DELETEME
  if (si._si_commune._si_code & PICOM_EXTRASTR)
d989 4
a992 3
      // FIXME: Is alloca here?
      si._si_commune._si_str = (char *) alloca (n + 1);
      if (!ReadFile (readsig, si._si_commune._si_str, n, &nb, NULL) || nb != n)
d994 2
a995 1
      si._si_commune._si_str[n] = '\0';
d997 2
d1000 1
a1000 1
    pi->commune_process (si);
d1114 1
a1114 1
	  talktome (pack.si, readsig);
@


1.255
log
@Change name from commune_recv to commune_process throughout.  Change name from
commune_send to commune_request throughout.
* pinfo.h (PICOM_EXTRASTR): New flag.
(PICOM_FIFO): Define with new flag.
(_pinfo::hello_pid): Delete.
(_pinfo::tothem): Delete.
(_pinfo::fromthem): Delete.
(_pinfo::commune_process): Rename from commune_recv.  Add a siginfo_t argument
to declaration.
(_pinfo::commune_request): Rename from commune_send.  Change DWORD to
__uint32_t in declaration.
* pinfo.cc (_pinfo::commune_process): Rename from commune_recv.  Add siginfo_t
argument.  Use information from argument rather than reading from another pipe.
Synchronize with other process's commune event.
(_pinfo::commune_request): Rename from commune_send.  Change DWORD to __uint32
in argument.  Fill out information in new siginfo_t element and rely on
extended operation of sig_send rather than trying to deal with synchronization
issues here.  Use process handle and read pipe information filled out by
sig_send to gather information from the other process.
* sigproc.cc (sig_send): Take special action if "communing" to ensure
synchronization with the other process and to return information about the
other process to the caller.
(talktome): Accept a siginfo_t and handle arguments.  Read additional
information from the signal pipe when _si_commune._si_code has the
PICOM_EXTRASTR flag set.
(wait_sig): Pass the transmitted siginfo_t struct and the pipe handle to
talktome.  Close pipe read handle as soon as possible after we detect that
we're exiting.
@
text
@d973 1
d975 1
d1178 1
@


1.254
log
@	Revert erroneous checkin.
@
text
@d529 1
a601 1
      CloseHandle (hp);
d603 22
d653 17
d671 1
a671 1
  if (!WriteFile (sendsig, &pack, sizeof (pack), &nb, NULL) || nb != sizeof (pack))
d729 1
d732 7
d971 1
a971 1
talktome (siginfo_t& si)
d973 15
a987 3
  pinfo p (si.si_pid, PID_MAP_RW);
  if (p)
    p->commune_recv ();
d1101 1
a1101 1
	  talktome (pack.si);
@


1.253
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d585 1
a585 2
      HANDLE hp = OpenProcess (PROCESS_DUP_HANDLE | SYNCHRONIZE,
			       false, dwProcessId);
d601 1
a601 53
      if (si.si_signo == __SIGCOMMUNE)
        {
	  if (!(myself->gotit = CreateEvent (&sec_none_nih, true, false, NULL)))
	    {
	      __seterrno ();
	      sigproc_printf ("CreateEvent failed, %E");
	      CloseHandle (hp);
	      goto out;
	    }
	  if (!DuplicateHandle (hMainProc, myself->gotit, hp,
	  			&myself->__gotit, false, 0,
				DUPLICATE_SAME_ACCESS))
	    {
	      __seterrno ();
	      sigproc_printf ("DuplicateHandle failed, %E");
	      CloseHandle (myself->gotit);
	      CloseHandle (hp);
	      goto out;
	    }
	  if (!DuplicateHandle (hMainProc, myself->tothem, hp,
	  			&myself->__tothem, false, 0,
				DUPLICATE_SAME_ACCESS))
	    {
	      __seterrno ();
	      sigproc_printf ("DuplicateHandle failed, %E");
	      CloseHandle (myself->gotit);
	      CloseHandle (hp);
	      goto out;
	    }
	  if (!DuplicateHandle (hMainProc, myself->fromthem, hp,
	  			&myself->__fromthem, false, 0,
				DUPLICATE_SAME_ACCESS))
	    {
	      __seterrno ();
	      sigproc_printf ("DuplicateHandle failed, %E");
	      CloseHandle (myself->gotit);
	      CloseHandle (hp);
	      goto out;
	    }
	  if (!DuplicateHandle (hMainProc, hMainProc, hp,
	  			&myself->__them, false, 0,
				DUPLICATE_SAME_ACCESS))
	    {
	      __seterrno ();
	      sigproc_printf ("DuplicateHandle failed, %E");
	      CloseHandle (myself->gotit);
	      CloseHandle (hp);
	      goto out;
	    }
	  myself->them = hp;
        }
      else
	CloseHandle (hp);
@


1.252
log
@* exceptions.cc (handle_exceptions): Just si_code to SI_KERNEL first and let it
be overridden.
* exceptions.cc (_cygtls::call_signal_handler): Call signal handler with extra
siginfo_t * and void * parameters when SA_SIGINFO flag is set.
* signal.cc (signal): Clear SA_SIGINFO flag.
(sigqueue): Fix incorrect setting of si_code.
* sigproc.cc (signal_fixup_after_exec): Clear SA_SIGINFO flag when setting
handler to SIG_DFL.
@
text
@d585 2
a586 1
      HANDLE hp = OpenProcess (PROCESS_DUP_HANDLE, false, dwProcessId);
d602 53
a654 1
      CloseHandle (hp);
@


1.251
log
@* sigproc.cc (wait_sig): Cosmetic change.
* pinfo.cc (pinfo::exit): Don't explicitly remove myself since some other
thread may still be using it.
@
text
@d123 4
a126 1
	global_sigs[i].sa_handler = SIG_DFL;
@


1.250
log
@* sigproc.cc (sigproc_terminate): More reversion of always-exit-from-sigthread
change.
@
text
@d974 1
a974 1
wait_sig (VOID *self)
@


1.249
log
@Semi-reversion of always-exit-from-sigthread change of 2005-09-15.
* exceptions.cc (sigpacket::process): Eliminate return after call to reinstated
noreturn function.
(signal_exit): Allow function to exit when a captive process has been
terminated.
* pinfo.cc (pinfo::exit): Enter exit_lock here.  Once again exit here under
control of exit_lock.
* sigproc.cc (sig_send): Don't wait for completion if process is exiting.
Remove special __SIGEXIT accommodations.
(wait_sig): Just exit the thread when a __SIGEXIT has been detected.  Don't
exit the process.
@
text
@d500 1
a500 4
      siginfo_t si;
      memset (&si, 0, sizeof (si));
      si.si_signo = __SIGEXIT;
      sig_send (myself_nowait, si, &_my_tls);
@


1.248
log
@* cygtls.h (struct _cygtls::thread_handle): Remove/revert.
* sigproc.h (struct sipacket::thread_handle): Put thread_handle here.
* sigproc.cc (sigproc_terminate): Move setting of thread_handle...
(sig_send): ...to here.  Put it in packet being sent.  Only close pack.wakeup
when we're waiting for completion.
(wait_sig): Use thread_handle directly from received packet.
@
text
@d556 1
a556 1
      wait_for_completion = p != myself_nowait && _my_tls.isinitialized ();
d624 1
a624 9
  if (si.si_signo == __SIGEXIT)
    {
      if (&_my_tls == _main_tls)
	pack.thread_handle = hMainThread;
      else
	DuplicateHandle (hMainProc, GetCurrentThread (), hMainProc, &pack.thread_handle, 0,
			 FALSE, DUPLICATE_SAME_ACCESS);
    }
  else if (wait_for_completion)
d1117 2
a1118 25
  my_sendsig = NULL;
  HANDLE& h = pack.thread_handle;
  if (!h)
    api_fatal ("no thread handle set on exit");
  DWORD res = WaitForSingleObject (h, INFINITE);

  DWORD exitcode = 1;

  myself.release ();
  if (res == WAIT_OBJECT_0)
    {
      GetExitCodeThread (h, &exitcode);
#ifdef DEBUGGING
      hMainThread = INVALID_HANDLE_VALUE;
#endif
    } else {
#ifdef DEBUGGING
      console_printf ("wait for main thread %p returned %d", h, res);
#else
      debug_printf ("wait for main thread %p returned %d", h, res);
#endif
    }

  sigproc_printf ("calling ExitProcess, exitcode %p", exitcode);
  ExitProcess (exitcode);
@


1.247
log
@* cygheap.cc (cygheap_fixup_in_child): It's not just for exec.
* cygtls.h (struct _cygtls::thread_handle): New field.
* dcrt0.cc (exit_lock): Remove declaration.
* winsup.h (exit_lock): Add declaration.
* exceptions.cc (sigpacket::process): Properly return after signal_exit.
* pinfo.cc (pinfo::exit): Only exit the process if _my_tls.thread_handle has
not been filled out -- which should be an impossible event.
* sigproc.cc (sigproc_terminate): Fillout _my_tls.thread_handle to provide
something for wait_sig to wait for.  Use the siginfo_t version of sig_send and
fill out the tls argument with _my_tls.
(wait_sig): Wait for the thread specified in pack.tls or (for now) complain
bitterly if it doesn't exit.
@
text
@a502 5
      if (&_my_tls == _main_tls)
	_my_tls.thread_handle = hMainThread;
      else
	DuplicateHandle (hMainProc, GetCurrentThread (), hMainProc, &_my_tls.thread_handle, 0,
			 FALSE, DUPLICATE_SAME_ACCESS);
d624 9
a632 1
  if (wait_for_completion)
d673 1
d684 1
a684 6
  if (pack.wakeup)
    {
      ForceCloseHandle (pack.wakeup);
      pack.wakeup = NULL;
    }

d1126 2
a1127 3
  if (!pack.tls)
    api_fatal ("no exit packet received");
  if (!pack.tls->thread_handle)
a1128 1
  HANDLE h = pack.tls->thread_handle;
@


1.246
log
@* dcrt0.cc (do_exit): Only call sigproc_terminate from one location --
pinfo::exit.
* pinfo.cc (pinfo::exit): Move sigproc_terminate later so that signals can be
processed while waiting for hExeced child.
(pinfo::maybe_set_exit_code_from_windows): Set exit code from sigExeced if it
is non-zero.  Set exit_state to ES_EXEC_EXIT prior to waiting for captive
process exit code.
* exceptions.cc (sigExeced): New global variable.
(signal_exit): Remove noreturn attribute from declaration.
(signal_exit): Just terminate captive process and return if hExeced on the
theory that the exit will be subsequently handled in the main thread.
* sigproc.cc (sigproc_terminate): Eliminate test for ES_SIGPROCTERMINATE and
use ES_FINAL instead.
(sig_send): Use no_signals_available instead of duplicate test.
* winsup.h (ES_EXEC_EXIT): New enum.
(ES_SIGPROCTERMINATE): Delete.
@
text
@d500 9
a508 1
      sig_send (myself_nowait, __SIGEXIT);
d1016 1
d1020 1
a1020 1
      sigpacket pack;
d1126 7
a1132 3
  HANDLE h = hMainThread;
  my_sendsig = hMainThread = NULL;
  DWORD res = !h ? WAIT_OBJECT_0 : WaitForSingleObject (h, INFINITE);
@


1.245
log
@* sigproc.cc (talktome): Take siginfo_t argument.  Don't scan all pids trying
to find one that's talking to me.  Just use the pid from siginfo_t.
(wait_pid): Pass siginfo_t argument to talktome.
@
text
@d495 1
a495 1
  if (prior_exit_state > ES_SIGPROCTERMINATE)
d544 1
a544 1
      if (!my_sendsig || (si.si_signo != __SIGEXIT && myself->exitcode & EXITCODE_SET) || &_my_tls == _sig_tls)
d641 1
a641 1
	  if (no_signals_available (si.si_signo != __SIGEXIT))
@


1.244
log
@* pinfo.h (EXITCODE_SET): Move out of range of Windows error.
(EXITCODE_NOSET): Ditto.
* sigproc.cc (no_signals_available): Remove check for hwait_sig.  Just rely on
my_sendsig.  Pass in an argument controlling when it is appropriate to test
EXITCODE_SET.
(proc_can_be_signalled): Remove checks for myself since this function is never
called in that context.
(sigproc_init): Pre-initialize my_sendsig to non-zero so that
proc_can_be_signalled will know that we expect to be signalable soon.
(sig_send): Change debugging output.
@
text
@d925 1
a925 1
talktome ()
d927 3
a929 5
  winpids pids ((DWORD) PID_MAP_RW);
  for (unsigned i = 0; i < pids.npids; i++)
    if (pids[i]->hello_pid == myself->pid)
      if (!IsBadWritePtr (pids[i], sizeof (_pinfo)))
	pids[i]->commune_recv ();
d1042 1
a1042 1
	  talktome ();
@


1.243
log
@* sigproc.cc (no_signals_available): Return true if sending to self from the
signal thread.
(wait_sig): Correct so that WaitForSingleObject is called when hMainThread is
!= 0, rather than the reverse.
* cygheap.cc (cygheap_fixup_in_child): Clarify potential error message.
* fork.cc (fork_copy): Cosmetic change.
@
text
@d41 1
a41 1
#define no_signals_available() (!hwait_sig || (myself->exitcode & EXITCODE_SET) || !my_sendsig || &_my_tls == _sig_tls)
a61 1
Static cygthread *hwait_sig;		// Handle of wait_sig thread
a170 9
      if (p == myself_nowait || p == myself)
	if (hwait_sig)
	  return true;
	else
	  {
	    set_errno (EAGAIN);
	    return hwait_sig;
	  }

d480 2
a481 1
  hwait_sig = new cygthread (wait_sig, cygself, "sig");
d544 1
a544 1
      if (no_signals_available ())
d546 2
a547 2
	  sigproc_printf ("hwait_sig %p, myself->sendsig %p, exit_state %d",
			  hwait_sig, myself->sendsig, exit_state);
d641 1
a641 1
	  if (no_signals_available ())
d682 1
a682 1
      if (!no_signals_available ())
@


1.242
log
@* sigproc.cc (wait_sig): Reorganize exit case so that ExitProcess is always
called, since that is the intent of sending a __SIGEXIT.  Wait forever for main
thread to go away since, presumably, the main thread told us it was going away.
@
text
@d41 1
a41 1
#define no_signals_available() (!hwait_sig || (myself->exitcode & EXITCODE_SET) && !my_sendsig)
d1130 1
a1130 1
  DWORD res = h ? WAIT_OBJECT_0 : WaitForSingleObject (h, INFINITE);
@


1.241
log
@* exceptions.cc (sigtid): Remove declaration.
(handle_exceptions): Use _sig_tls rather than sigtid to determine if this is
the signal thread.
(set_signal_mask): Ditto for conditionalized CGF code.
* pinfo.cc (pinfo::exit): Exit the thread if we forcefully terminated the main
thread
* sigproc.cc (sigtid): Delete.
(_sig_tls): Define.
(sig_clear): Use _sig_tls rather than sigtid to determine if this is the signal
thread.
(sig_dispatch_pending): Ditto.
(wait_sig): Set _sig_tls here.
* dcrt0.cc (do_exit): Move sigproc_terminate call later since signal handling
was still needed for subsequent stuff.  Call sigproc_terminate with new
exit_state value.
* pinfo.cc (pinfo::exit): Call sigproc_terminate with new exit_state value.
* sigproc.cc (proc_terminate): Remove unnecessary (void) parameter.
(sigproc_terminate): Ditto.  Add new argument to accept exit state to be set.
(wait_sig): Reorganize __SIGEXIT handling.  Add more debugging output.
* winsup.h (sigproc_terminate): Declare with new exit_state argument.
(exit_states): Reorganize to reflect new exit ordering of sigproc_terminate.
@
text
@d1128 3
a1130 2
  my_sendsig = NULL;
  DWORD res = WaitForSingleObject (hMainThread, 10000);
d1132 4
a1135 3
  if (res != WAIT_OBJECT_0)
    sigproc_printf ("wait for main thread returned %d", res);
  else
d1137 10
a1146 5
      DWORD exitcode = 1;
      myself.release ();
      sigproc_printf ("calling ExitProcess, exitcode %p", exitcode);
      GetExitCodeThread (hMainThread, &exitcode);
      ExitProcess (exitcode);
d1148 3
a1150 2
  sigproc_printf ("exiting thread");
  ExitThread (0);
@


1.240
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@d75 1
a75 1
DWORD NO_COPY sigtid = 0;		// ID of the signal thread
d385 1
a385 1
proc_terminate (void)
a387 1
  /* Signal processing is assumed to be blocked in this routine. */
d416 1
a416 1
  if (GetCurrentThreadId () != sigtid)
d447 1
a447 1
  if (exit_state || GetCurrentThreadId () == sigtid || !sigq.start.next)
d450 2
a451 2
      sigproc_printf ("exit_state %d, cur thread id %p, sigtid %p, sigq.start.next %p",
		      exit_state, GetCurrentThreadId (), sigtid, sigq.start.next);
d500 1
a500 1
sigproc_terminate (void)
d502 3
a504 1
  if (exit_state > ES_SIGPROCTERMINATE)
a507 1
      exit_state = ES_SIGPROCTERMINATE;
d1010 1
a1012 1
  sigtid = GetCurrentThreadId ();
d1015 1
a1015 1
  _my_tls.init_threadlist_exceptions (&el);
a1024 2
      if (exit_state || pack.si.si_signo == __SIGEXIT)
	break;
d1084 3
d1124 2
d1129 5
a1133 2
  sigproc_printf ("done");
  if (WaitForSingleObject (hMainThread, 5000) == WAIT_OBJECT_0)
d1137 1
a1138 2
      sigproc_printf ("Calling ExitProcess, exitcode %p",
		      exitcode);
d1141 1
@


1.239
log
@* sigproc.cc (wait_sig): Be more defensive about detecting when we're exiting.
@
text
@d41 1
a41 1
#define no_signals_available() (!hwait_sig || (myself->sendsig == INVALID_HANDLE_VALUE) || exit_state)
d83 1
d170 1
a170 1
  if (p->sendsig != INVALID_HANDLE_VALUE)
a431 1
  return;
a495 1
  return;
d503 2
a504 4
  hwait_sig = NULL;

  if (myself->sendsig == INVALID_HANDLE_VALUE)
    sigproc_printf ("sigproc handling not active");
d507 1
d509 2
a510 6
      if (!hExeced)
	{
	  HANDLE sendsig = myself->sendsig;
	  myself->sendsig = INVALID_HANDLE_VALUE;
	  CloseHandle (sendsig);
	}
a511 3
  proc_terminate ();		// clean up process stuff

  return;
d539 12
a550 1
    wait_for_completion = false;
a565 9
  /* It is possible that the process is not yet ready to receive messages
   * or that it has exited.  Detect this.
   */
  if (!proc_can_be_signalled (p))	/* Is the process accepting messages? */
    {
      sigproc_printf ("invalid pid %d(%x), signal %d",
		  p->pid, p->process_state, si.si_signo);
      goto out;
    }
d568 1
a568 1
    sendsig = myself->sendsig;
d1001 1
d1025 1
a1025 1
      if (exit_state || myself->sendsig == INVALID_HANDLE_VALUE)
d1125 1
d1127 9
@


1.238
log
@Grr.  REVERT erroneous checkin.  AGAIN.
@
text
@d1031 1
a1031 1
      if (myself->sendsig == INVALID_HANDLE_VALUE)
@


1.237
log
@* Makefile.in (CXXFLAGS): Use 'override' to correctly set flags to generate
dependencies when invoked from top-level make.
@
text
@a348 9
      break;
    case PROC_KILLFORKED:
      for (int i = 0; i < nprocs; i++)
	if (ISSTATE (procs[i], PID_INITIALIZING))
	  {
	    TerminateProcess (procs[i].hProcess, 1);
	    procs[i]->process_state = PID_EXITED;
	  }
      break;
@


1.236
log
@revert inexplicable previous checkin
@
text
@d349 9
@


1.235
log
@bad_addresses
@
text
@a348 9
      break;
    case PROC_KILLFORKED:
      for (int i = 0; i < nprocs; i++)
	if (ISSTATE (procs[i], PID_INITIALIZING))
	  {
	    TerminateProcess (procs[i].hProcess, 1);
	    procs[i]->process_state = PID_EXITED;
	  }
      break;
@


1.234
log
@* exceptions.cc (set_process_mask_delta): Conditionalize debugging output.
* sigproc.cc (proc_subproc): Make strace output a little more verbose.
@
text
@d349 9
@


1.233
log
@* exceptions.cc (handle_sigsuspend): Just sleep forever if called from non-main
thread.
(sigpacket:process): Simplify logic which determines when and how a signal is
masked.  Don't trigger sigwait if there is a signal handler.
* sigproc.cc (wait_sig): Update comment.  Try to process a signal which is in
the queue if it isn't queued for the target thread (this is still not right).
@
text
@d309 1
a309 1
	sigproc_printf ("looking for processes to reap");
@


1.232
log
@* child_info.h (child_info::sync): Pass pid and HANDLE rather than using pinfo.
(child_info::child_info): Accept an argument controlling whether to create
proc_subproc.
(child_info_spawn::child_info_spawn): Ditto.
* sigproc.cc (child_info::child_info): Ditto.
(child_info_spawn::child_info_spawn): Ditto.
(child_info::sync): Use passed in pid and HANDLE.
* fork.cc (fork_parent): Reflect additional arguments required for
child_info::sync.
* hookapi.cc (hook_or_detect_cygwin): Rename.  Change so that NULL 'fn'
argument just returns "true", indicating that program uses cygwin1.dll.
* spawn.cc (av::win16_exe): New element.
* spawn.cc (av::iscygwin): New element.
(av::fixup): New function.
(spawn_guts): Protect against SEGV.  Use fixup function to detect when it is
safe to wait for a spawned (as opposed to an execed) program.  Reflect changes
in child_info::sync arguments.
* external.cc (cygwin_internal): Reflect function renaming to
hook_or_detect_cygwin.
* cygheap.cc (cygheap_fixup_in_child): Close handle after debug fixup has been
done to prevent false positives in handle collision.
* exceptions.cc (try_to_debug): Notify debugger if already being debugged.
@
text
@d1100 4
a1103 3
	      // FIXME: Not quite right when taking threads into consideration.
	      // Do we need a per-thread queue?
	      if (sigq.sigs[sig].si.si_signo)
@


1.231
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d724 1
a724 1
child_info::child_info (unsigned in_cb, child_info_types chtype)
d733 1
a733 1
  if (chtype != PROC_SPAWN)
d756 1
a756 1
  child_info (sizeof *this, _PROC_FORK)
d760 2
a761 2
child_info_spawn::child_info_spawn (child_info_types chtype) :
  child_info (sizeof *this, chtype)
d789 1
a789 1
child_info::sync (pinfo& vchild, DWORD howlong)
d799 1
a799 1
  w4[1] = vchild.hProcess;
d806 1
a806 1
      sigproc_printf ("got subproc_ready for pid %d", vchild->pid);
d816 1
a816 1
      system_printf ("wait failed, pid %d, %E", vchild->pid);
@


1.230
log
@* dcrt0.cc (cygwin_exit): Mark as "noreturn".
* sigproc.cc (child_info::ready): Don't signal parent that we are a cygwin
process if we are dynamically loaded.
@
text
@d132 1
a132 1
  (void) WaitForSingleObject (hsig_inited, INFINITE);
d134 1
a134 1
  (void) ForceCloseHandle1 (hsig_inited, wait_sig_inited);
d392 1
a392 1
      (void) proc_subproc (PROC_CLEARWAIT, 1);
d460 1
a460 1
  (void) sig_send (myself, fast ? __SIGFLUSHFAST : __SIGFLUSH);
d1003 1
a1003 1
  (void) SetThreadPriority (GetCurrentThread (), WAIT_SIG_PRIORITY);
@


1.229
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d774 3
a776 1
  if (!SetEvent (subproc_ready))
@


1.228
log
@* cygthread.cc (cygthread::detach): Fix debugging output.
* dcrt0.cc (dll_crt0_1): Create signal_arrived early -- before any filename
manipulation.
* sigproc.cc (sigproc_init): Don't create signal_arrived here.
* fork.cc (fork_child): Ditto.
@
text
@a83 2
extern HANDLE hExeced;

@


1.227
log
@	* pinfo.cc (pinfo::init): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	(pinfo::set_acl): Replace sa_buf by dynamically allocated acl_buf.
	* sec_acl.cc (setacl): Allocate acl dynamically.
	* sec_helper.cc (sec_acl): Add test for alignment of acl when
	DEBUGGING is defined.
	(__sec_user): Same for sa_buf.
	* security.cc (verify_token): Define sd_buf as PSECURITY_DESCRIPTOR
	and allocate dynamically.
	(alloc_sd): Allocate acl dynamically.
	security.h (sec_user_nih): Change first parameter to
	SECURITY_ATTRIBUTES *.
	(sec_user): Ditto.
	* sigproc.cc (wait_sig): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	* syscalls.cc (seteuid32): Define dacl_buf as PACL and allocate
	dynamically.
	* uinfo.cc (cygheap_user::init): Define sa_buf as PSECURITY_ATTRIBUTES
	and allocate dynamically.
	* winbase.h (ilockincr): Mark first argument of inline assembly as
	earlyclobber.
	(ilockdecr): Ditto.
@
text
@a492 2
  create_signal_arrived ();

@


1.226
log
@* child_info.h (child_info::cygheap_h): Delete.
(child_info::dwProcessId): New field.
* cygheap.cc (init_cheap): Delete.
(dup_now): Ditto.
(cygheap_setup_for_child): Ditto.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_fixup_in_child): Simplify.  Use new "child_copy" function to copy heap
from parent.
(_csbrk): Don't attempt allocation if within cygheap section.  Fix so that more
than one allocation will succeed.
(cygheap_init): Reset possibly-nonzero region to zero.
* cygheap.h (cygheap_setup_for_child): Delete declaration.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_start): Define as an array.
* cygwin.sc: Modernize.  Remove unneeded sections.  Define cygheap here.
* dcrt0.cc (do_exit): Reflect argument change to close_all_files.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* fork.cc (fork_copy): Call ReadProcessMemory if there is no thread
(indicating that we're execing).
(fork_child): Don't mess with hParent.
(fork_parent): Remove hParent stuff.  It happens earlier now.  Remove call to
cygheap_setup_for_child* stuff.
(fork): Put child_info_stuff in grouped structure.  Issue error if parent
handle is not set.
(child_copy): New function.
* sigproc.cc (child_info::child_info): Put cygheap settings here.  Set parent
handle.
(child_info::~child_info): Close parent handle if it exists.
* spawn.cc (spawn_guts): Reorganize so that ciresrv is allocated at only the
last minute so that cygheap changes are reflected.  Delete cygheap_setup*
calls.
* syscalls.cc (close_all_files): Add an argument to flag when the fd entry
should be released.
* winsup.h (close_all_files): Add an argument to close_all_files declaration.
Declare child_copy.
@
text
@d1001 1
a1001 1
  char sa_buf[1024];
@


1.225
log
@white space and minor comment cleanup.
@
text
@d740 9
d755 2
@


1.224
log
@* sigproc.cc (proc_subproc): Fix handling of waiting for pids with zero value.
* strace.cc (strace::hello): Report parent pid of executing process.
@
text
@d476 2
a477 2
/* Message initialization.  Called from dll_crt0_1
  
@


1.223
log
@* sync.h (muto::initforce): Delete flawed implementation.
* pwdgrp.h (pwdgrp::pglock): Make static.
* grp.cc (pwdgrp::pwdgrp): Eliminate use of initforce.
@
text
@d278 1
a278 1
      if (wval->pid == -1)
@


1.222
log
@* sync.h (muto::operator int): New operator.
(locker): Remove unused class.
(new_muto): Delete.
(new_muto1): Ditto.
(new_muto_name): Ditto.
* cygheap.cc (cygheap_setup_for_child): Reflect use of static storage for muto
rather than pointer.
(_csbrk): Ditto.
(_cmalloc): Ditto.
(_cmalloc): Ditto.
(_cfree): Ditto.
* cygheap.h (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_drive): Ditto.
* cygmalloc.h (__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* cygtls.cc (sentry::lock): Ditto.
(sentry::sentry): Ditto.
(~sentry): Ditto.
(_cygtls::init): Ditto.
* dcrt0.cc: Ditto.
(cygwin_atexit): Ditto.
(cygwin_exit): Ditto.
* debug.cc (lock_debug::locker): Ditto.
(lock_debug::lock_debug): Ditto.
(lock_debug::unlock): Ditto.
(debug_init): Ditto.
* dtable.cc (dtable::init_lock): Ditto.
* dtable.h (dtable::lock_cs): Ditto.
(dtable::lock): Ditto.
(dtable::unlock): Ditto.
* exceptions.cc (mask_sync): Ditto.
(sighold): Ditto.
(set_process_mask_delta): Ditto.
(set_signal_mask): Ditto.
(events_init): Ditto.
* grp.cc (pwdgrp::pwdgrp): Ditto.
* malloc_wrapper.cc (mallock): Ditto.
(malloc_init): Ditto.
* path.cc (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::init): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* pwdgrp.h (pwdgrp::pglock): Ditto.
(pwdgrp::refresh): Ditto.
* sigproc.cc (sync_proc_subproc): Ditto.
(get_proc_lock): Ditto.
(proc_subproc): Ditto.
(_cygtls::remove_wq): Ditto.
(proc_terminate): Ditto.
(sigproc_init): Ditto.
* timer.cc (lock_timer_tracker::protect): Ditto.
(lock_timer_tracker::lock_timer_tracker): Ditto.
(lock_timer_tracker::~lock_timer_tracker): Ditto.
* wininfo.cc (wininfo::_lock;): Ditto.
(wininfo::winthread): Ditto.
(operator HWND): Ditto.
(wininfo::lock): Ditto.
(wininfo::release): Ditto.
* wininfo.h (wininfo::_lock;): Ditto.
@
text
@d73 1
a73 1
muto NO_COPY sync_proc_subproc;		// Control access to subproc stuff
@


1.221
log
@* sigproc.cc (create_signal_arrive): New (temporary?) function to create
signal_arrived event.
(sigproc_init): Use create_signal_arrived.
* fork.cc (fork_child): Create signal_arrived early.
@
text
@d73 1
a73 1
muto NO_COPY *sync_proc_subproc = NULL;	// Control access to subproc stuff
d153 1
a153 1
  if (sync_proc_subproc->acquire (WPSP))
d354 1
a354 1
  sync_proc_subproc->release ();	// Release the lock
d366 1
a366 1
  if (sync_proc_subproc && sync_proc_subproc->acquire (wait))
d375 1
a375 1
      sync_proc_subproc->release ();
d392 1
a392 1
      sync_proc_subproc->acquire (WPSP);
d409 1
a409 1
      sync_proc_subproc->release ();
d491 1
a491 1
  new_muto (sync_proc_subproc);
@


1.220
log
@* sigproc.cc (_pinfo::set_ctty): Move function
* pinfo.cc (_pinfo::set_ctty): to here.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Don't fill out structure if this
is an on-disk device rather than an "auto" device.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.
* path.cc (normalize_posix_path): Don't treat a standalone '//' as introducing
a UNC path.
(normalize_win32_path): Ditto.
@
text
@d465 11
d477 5
a481 6
 *
 * This routine starts the signal handling thread.  The wait_sig_inited
 * event is used to signal that the thread is ready to handle signals.
 * We don't wait for this during initialization but instead detect it
 * in sig_send to gain a little concurrency.
 */
d493 1
a493 4
  /* local event signaled when main thread has been dispatched
     to a signal handler function. */
  signal_arrived = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  ProtectHandle (signal_arrived);
@


1.219
log
@* debug.cc (delete_handle): Report on handle value in debugging output.
* pinfo.h (_pinfo::exists): Declare "new" function.
(_pinfo::kill): Ditto.
* fhandler_termios.cc (tty_min::kill_pgrp): Use _pinfo::exists rather than
proc_exists.
* pinfo.cc (pinfo::init): Ditto.  Don't do a low_priority_sleep(0) when looping
to find exec'ed procinfo.
(pinfo::release): Be more careful about unmapping and closing.
* signal.cc (_pinfo::kill): Rename from kill_worker.  Accommodate entry into
_pinfo class.
(kill0): Use _pinfo::kill rather than kill_worker.
(kill_pgrp): Ditto.  Use _pinfo::exists rather than proc_exists.
* sigproc.cc (_pinfo::exists): Rename from proc_exists.
(pid_exists): Use _pinfo::exists rather than proc_exists.
(remove_proc): Ditto.
* sigproc.h (proc_exists): Delete declaration.
@
text
@a197 8
/* Test to determine if a process really exists and is processing signals.
 */
bool __stdcall
_pinfo::exists ()
{
  return this && !(process_state & PID_EXITED);
}

@


1.218
log
@copyright
@
text
@d195 1
a195 2
  pinfo p (pid);
  return proc_exists (p);
d201 1
a201 1
proc_exists (_pinfo *p)
d203 1
a203 1
  return p && !(p->process_state & PID_EXITED);
d849 1
a849 1
  if (proc_exists (procs[ci]))
@


1.217
log
@white space
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.216
log
@* pinfo.h (maybe_set_exit_code_from_windows): Renamed from set_exit_state.
* pinfo.cc (pinfo::exit): Use renamed function.
(proc_waiter): Ditto.  Make a copy of input argument to avoid problems when
procs array is shuffled.  Flag when copy is made so that remove_proc knows when
it is safe to reshuffle.
* sigproc.cc (proc_terminate): Don't flag process_state as PID_EXITED.
(remove_proc): Wait for waiter to finish copying pinfo element before moving it
(an actual wait should be an extremely rare event).
@
text
@d875 1
a875 1
  
d878 1
a878 1
  
@


1.215
log
@* init.cc (dll_entry): Remove unused extern.
* include/sys/cygwin.h: Remove PID_ZOMBIE.
* pinfo.h: Rename EXITCODE_* defines.
(pinfo::set_exit_state): Remove parameter.
* pinfo.cc (set_exit_state): Remove parameter.  Reverse sense of test so that
exitcode is checked for having been set rather than not having been set.  Set
flag when exitcode has been established.  Don't set PID_STATE here.
(pinfo::init): Remove exitcode initialization.
(pinfo::exit): Reflect change in EXITCODE_* naming.  Set flag when exitcode has
been established.  Reflect change in arguments to set_process_state.
(proc_waiter): Reflect change in arguments to set_process_state.  Set
process_state here and only here.
* fhandler_process.cc (fhandler_process::fill_filebuf): Reflect removal of
PID_ZOMBIE define.
(format_process_stat): Ditto.
(format_process_status): Ditto.
* sigproc.cc (pid_exists): Ditto.
(stopped_or_terminated): Ditto.  Make sure that only low-order 16 bits of
exitcode are used.
* spawn.cc (spawn_guts): Reflect change in EXITCODE_* naming.
@
text
@d68 3
a70 2
Static char cprocs[(NPROCS + 1) * sizeof (pinfo)];		// All my deceased children info
#define procs ((pinfo *) cprocs)
a409 2
	  if (!proc_exists (procs[i]))
	    procs[i]->process_state = PID_EXITED;	/* CGF FIXME - still needed? */
d862 9
a870 1
    procs[ci] = procs[nprocs];
@


1.214
log
@* sigproc.cc (sig_send): Don't complain if attempt to send signal to myself
fails after I've "execed".
@
text
@d203 1
a203 1
  return p && !(p->process_state & (PID_EXITED | PID_ZOMBIE));
d894 1
a894 1
  if (!((terminated = (child->process_state == PID_ZOMBIE)) ||
d907 1
a907 1
  else /* Should only get here when child has been moved to the procs array */
d909 1
a909 1
      w->status = child->exitcode;
@


1.213
log
@* pinfo.h (_pinfo::set_exit_state): Declare new function.
(pinfo::exit): Move here from _pinfo::exit.
* sigproc.cc (child_info::sync): Use new function to set exitcode and
process_state.
* pinfo.cc (_pinfo::exit): Ditto.
(proc_waiter): Ditto.
(_pinfo::set_exit_state): Define new function.
(_pinfo::dup_proc_pipe): Close handle when there is no parent process around to
care about the exit value.
* dcrt0.cc (dll_crt0_0): Move subproc_ready synchronization later to make sure
that myself is still mapped in parent.
(do_exit): Reflect movement to pinfo::exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* errno.cc (errmap): Map PROC_NOT_FOUND.
* init.cc (dll_entry): Release myself before exiting.
* sigproc.cc (proc_can_be_signalled): Set errno appropriately.
(sig_send): Ditto.  Also remove ill-advised test for !myself->sendsig since
this is an indication of a process which is still initializating -- it is not
an error.
(child_info::sync): Don't set exitcode here.  Assume that will happen in
proc_waiter, if necessary.
* spawn.cc (spawn_guts): Delay "wait_for_myself" logic until later.  Don't wait
at all if the process has already exited.  Reflect movement to pinfo::exit.
@
text
@d666 1
a666 1
	  else if (!hExeced)
d668 1
a668 1
			  si.si_signo, p->pid, sendsig);
@


1.212
log
@* pinfo.cc (_pinfo::exit): Beef up debugging output.
* sigproc.cc (proc_subproc): Detached children apparently need a ppid of 1.
@
text
@d173 7
a179 1
	return hwait_sig;
a552 3
  if (!myself->sendsig)	// FIXME: This catches the exec case but what if the exec is going to fail?
    goto out;

d562 1
d608 1
a609 1
	  __seterrno ();
d658 1
a659 1
	  __seterrno ();
d669 1
d804 1
a806 7
      else
	{
	  DWORD exitcode = 0;
	  (void) GetExitCodeProcess (vchild.hProcess, &exitcode);
	  vchild->exitcode = (exitcode & 0xff) << 8;
	  sigproc_printf ("non-cygwin exit value is %p", exitcode);
	}
@


1.211
log
@* init.cc (dll_entry): Previous code reversion was ill-advised.  Revert it.
* sigproc.cc (child_info::sync): Ditto.
* pinfo.cc (_pinfo::exit): Don't set myself.procinfo to NULL since it is no
longer required.
@
text
@d252 1
a252 1
	  vchild->ppid = myself->pid;
@


1.210
log
@* init.cc (dll_entry): Remove exit code setting.
* pinfo.cc (pinfo::init): Initialize exitcode to unset state rather than
SIGTERM.
(proc_waiter): Detect if exit code is unset and use status from
GetExitCodeProcess.
* sigproc.cc (child_info::sync): Remove exit code detection here since
proc_waiter now (again) detects it.
@
text
@d801 7
@


1.209
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
(child_info::parent_wr_proc_pipe): Eliminate.
* pinfo.h (_pinfo::alert_parent): Move here from pinfo class.
(_pinfo::dup_proc_pipe): New method.
(_pinfo::sync_proc_pipe): Ditto.
* exceptions.cc (sig_handle_tty_stop): Reflect move of alert_parent.
* init.cc (dll_entry): Exit with status one if main process called ExitProcess.
* pinfo.cc (set_myself): Remove handling of parent_wr_proc_pipe.
(_pinfo::exit): Reflect move of alert_parent.  Set procinfo to NULL to flag
that we are exiting normally.  Always use exitcode when exiting
(although this could be a little racy).
(pinfo::init): Set default exit to SIGTERM.  This will be the exit code
reported if process is terminated.
(_pinfo::dup_proc_pipe): New function.
(pinfo::wait): Duplicate wr_proc_pipe to the right place.  Use dup_proc_pipe to
move the pipe to the child.
(_pinfo::sync_proc_pipe): New function.
(_pinfo::alert_parent): Move to _pinfo.  Make sure that wr_proc_pipe is ours
before using it.
* sigproc.cc (child_info::child_info): Remove handling of parent_wr_proc_pipe.
* spawn.cc (spawn_guts): Pass our wr_proc_pipe to the child when execing.
Ensure that exit code of cygwin process started from windows is correctly set.
@
text
@a800 7
      else
	{
	  DWORD exitcode = 0;
	  (void) GetExitCodeProcess (vchild.hProcess, &exitcode);
	  vchild->exitcode = (exitcode & 0xff) << 8;
	  sigproc_printf ("non-cygwin exit value is %p", exitcode);
	}
@


1.208
log
@* cygthread.cc (cygthread::stub): Detect if thread function wants to release
itself here, to avoid a race.
(cygthread::release): Clear more stuff.  Add a diagnostic for an internal
error.
* cygthread.h (auto_release): New function.
* pinfo.h (pinfo::remember): Add an argument to denote whether child is
detached.
* fork.cc (fork_parent): Reflect change in arguments to pinfo::remember.
* pinfo.cc (_pinfo::exit): Signal exit more forcibly.
(proc_waiter): Use cygthread::auto_release to signify that cygthread::stub
should release the thread.  This should avoid a race.
(pinfo::alert_parent): Don't signify an error when wr_proc_pipe == NULL.
* sigproc.cc (proc_subproc): Add support for PROC_DETACHED_CHILD.
* sigproc.h: Ditto.
* spawn.cc (spawn_guts): Specify whether child is detached or not when calling
pinfo::remember.
@
text
@a737 2
  if (chtype != PROC_EXEC && myself->wr_proc_pipe != INVALID_HANDLE_VALUE)
    parent_wr_proc_pipe = myself->wr_proc_pipe;
@


1.207
log
@* sigproc.cc (proc_subproc): Fix long-standing problem.  Only wait for "all
processes" if pid == -1 -- not just if pid is negative.
(proc_can_be_signalled): Fix another long-standing problem.  Set correct errno
when detecting an exited process.
@
text
@a40 2
#define PSIZE 63		// Number of processes

d247 1
d249 1
d261 2
@


1.206
log
@* fork.cc (fork_parent): Reinstate "childhProc" protection.  Don't close
hProcess handle here since it is used to ensure that a new process isn't
created with the old pid after the old pid exits.
* spawn.cc (spawn_guts): Ditto.
* pinfo.cc (proc_waiter): Don't send any signals if we've execed since this
process doesn't officially exist.
* pinfo.h (pinfo::pid_handle): Eliminate.  Just use hProc.
* sigproc.cc (sig_send): Don't send any signals if our sendsig doesn't exist.
That's a sign that we are execing.
(remove_proc): Eliminate pid_handle close.
@
text
@d172 1
a172 1
  if (p->sendsig == INVALID_HANDLE_VALUE)
d174 7
a180 2
      set_errno (EPERM);
      return false;
a182 8
  if (p == myself_nowait || p == myself)
    return hwait_sig;

  if (ISSTATE (p, PID_INITIALIZING) ||
      (((p)->process_state & (PID_ACTIVE | PID_IN_USE)) ==
       (PID_ACTIVE | PID_IN_USE)))
    return true;

d278 1
a278 1
      if (wval->pid <= 0)
@


1.205
log
@* cygthread.cc (cygthread::terminate_thread): Make public.
* pinfo.h (pinfo::wait_thread): New element.
* pinfo.cc (pinfo::wait): Store "handle" to started thread in pinfo.
* sigproc.cc (proc_terminate): Kill any threads waiting for a process pipe.
@
text
@d85 2
a505 1
  extern HANDLE hExeced;
a512 1
				//  finished with anything it is doing
d548 3
d663 1
a663 1
	  else
a862 2
      if (procs[ci].pid_handle)
	ForceCloseHandle1 (procs[ci].pid_handle, childhProc);
@


1.204
log
@* sigproc.cc (mychild): Reimplement as list scan.
(proc_subproc): Don't mess with pinfo if it's myself.
* child_info.h (child_info_types): Label enum for _PROC constants.
(child_info::child_info): New constructor.
(child_info::~child_info): New destructor.
(child_info::sync): Declare new function.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): Remove old constructor.
(child_info_spawn::child_info_spawn): New constructor.
* dcrt0.cc (dll_crt0_0): Use correct sizeof when doing sanity check on passed
in child_info.  Signal readiness to parent when not forking (and not spawning).
* fork.cc (sync_with_child): Delete.
(resume_child): Remove extra argument.
(sync_with_parent): Use child_info method to sync with parent.
(fork_child): Don't close fork_info->subproc_ready since that is now handled by
the destructor.
(fork_parent): Remove subproc_ready stuff.  Use child_info sync method for
waiting..  Set start time here for child.  Rename "forked" to "child".
(fork): Check ch.subproc_ready for validity here.
* pinfo.h (_pinfo::exec_sendsig): Temp storage for exec stub which may be
staying around to handle non-cygwin captive process.
(_pinfo::exec_dwProcessId): Ditto.
(_pinfo::_lock): Renamed from lock.
(_pinfo::lock): New method.
(_pinfo::unlock): Ditto.
(_pinfo::initialize_lock): Ditto.
* pinfo.cc (set_myself): Use initialize_lock method to initialize myself lock.
Set "exec" fields in _pinfo to zero to indicate that we've started
successfully.  Set start time here when appropriate.
(_pinfo::commune_send): Use pinfo lock/unlock methods.
(proc_waiter): Remove special case for non-cywin processes.  Reinstitute
handling for PID_NOCLDSTOP.
* sigproc.cc (proc_subproc): Set proper EAGAIN errno when process table is
filled.
(sig_send): Use exec_* fields from _pinfo for sending signals if the the _pinfo
sendsig never materializes.
(child_info::child_info): New constructor, renamed from init_child_info.
Zeroes child_info structure and sets appropriate fields in structure based on
chtype.
(child_info::~child_info): New destructor.  Closes subproc_ready if it exists.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): New constructor.
(child_info::ready): New function.  Signals parent when child is ready.
(child_info::sync): New function.  Wait for child to signal us or process to
die.
(remove_proc): Remove closing of hProcess since this should now be handled
shortly after process creation.
* spawn.cc (spawn_guts): Use child_info_spawn constructor rather than
init_child_info.  Save exec_sendsig and exec_dwProcessId in execing _pinfo.
Rely on child_info constructor to properly set parent_wr_proc_pipe in ciresrv.
Revert to previous determination on whether to start a process in suspended
mode.  Remove reparenting stuff.  Just keep a stub around if starting a
non-cygwin process.
@
text
@d404 5
@


1.203
log
@* child_info.h (child_info_fork::parent_wr_proc_pipe): New element.
* fork.cc (fork_parent): Set parent_wr_proc.
* pinfo.cc (set_myself): Close child_proc_info->parent_wr_proc if it exists
rather than trying to get value from parent _pinfo.
* pinfo.h (enum parent_aleter): New enum.
(pinfo::alert_parent): Declare as returning a value.
(pinfo::parent_alive): New function.
* pinfo.cc (pinfo::alert_parent): Set wr_proc_pipe to invalid non-NULL value
when parent disappears.  Return success of operation.
(proc_waiter): Use __ALERT_* enum for control since these are not really
signals.  Implement __ALERT_ALIVE.
* sigproc.cc (my_parent_is_alive): Eliminate.
* sigproc.h (my_parent_is_alive): Ditto for declaration.
(__SIGREPARENT): Eliminate.
@
text
@d203 2
a204 4
/* Return 1 if this is one of our children, zero otherwise.
   FIXME: This really should be integrated with the rest of the proc_subproc
   testing.  Scanning these lists twice is inefficient. */
bool __stdcall
d207 4
a210 2
  pinfo p (pid);
  return p && p->ppid == myself->pid;
a214 1
#define vchild (*((pinfo *) val))
d225 1
d247 1
a247 1
	  set_errno (EMFILE);	// FIXMENOW - what's the right errno?
d251 11
a261 8
      vchild->ppid = myself->pid;
      vchild->uid = myself->uid;
      vchild->gid = myself->gid;
      vchild->pgid = myself->pgid;
      vchild->sid = myself->sid;
      vchild->ctty = myself->ctty;
      vchild->cygstarted = true;
      vchild->process_state |= PID_INITIALIZING | (myself->process_state & PID_USETTY);
d359 2
d574 3
a576 1
      for (int i = 0; !p->dwProcessId && i < 10000; i++)
d578 17
a594 1
      HANDLE hp = OpenProcess (PROCESS_DUP_HANDLE, false, p->dwProcessId);
d602 1
a602 3
      for (int i = 0; !p->sendsig && i < 10000; i++)
	low_priority_sleep (0);
      if (!DuplicateHandle (hp, p->sendsig, hMainProc, &sendsig, false, 0,
d605 2
a607 2
	  sigproc_printf ("DuplicateHandle failed, %E");
	  __seterrno ();
d719 55
a773 2
void __stdcall
init_child_info (DWORD chtype, child_info *ch, HANDLE subproc_ready)
d775 36
a810 8
  memset (ch, 0, sizeof *ch);
  ch->cb = chtype == PROC_FORK ? sizeof (child_info_fork) : sizeof (child_info);
  ch->intro = PROC_MAGIC_GENERIC;
  ch->magic = CHILD_INFO_MAGIC;
  ch->type = chtype;
  ch->subproc_ready = subproc_ready;
  ch->fhandler_union_cb = sizeof (fhandler_union);
  ch->user_h = cygwin_user_h;
@


1.202
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@a127 17
/* Determine if the parent process is alive.
 */

bool __stdcall
my_parent_is_alive ()
{
  bool res;
  if (myself->cygstarted)
    res = pid_exists (myself->ppid);
  else
    {
      debug_printf ("Not started by cygwin app");
      res = false;
    }
  return res;
}

@


1.201
log
@* exceptions.cc (sig_handle_tty_stop): Set flag that we are in a cygwin
function to avoid a probably erroneous stack walk.
@
text
@a30 1
#include "cygthread.h"
a32 1
#include "perthread.h"
a42 2
#define wake_wait_subproc() SetEvent (events[0])

d45 1
a45 1
#define NZOMBIES	256
a62 5
/* How long to wait for message/signals.  Normally this is infinite.
  On termination, however, these are set to zero as a flag to exit.  */

Static DWORD proc_loop_wait = 1000;	// Wait for subprocesses to exit

a64 1
Static cygthread *hwait_subproc;	// Handle of sig_subproc thread
d69 3
a71 12
/* Used by WaitForMultipleObjects.  These are handles to child processes.
 */
Static HANDLE events[PSIZE + 1];	  // All my children's handles++
#define hchildren (events + 1)		// Where the children handles begin
Static int nchildren;			// Number of active children
Static char cpchildren[PSIZE * sizeof (pinfo)];		// All my children info
Static int nzombies;			// Number of deceased children
Static char czombies[(NZOMBIES + 1) * sizeof (pinfo)];		// All my deceased children info

#define pchildren ((pinfo *) cpchildren)
#define zombies ((pinfo *) czombies)

d81 2
a82 3
static void __stdcall remove_zombie (int);
static int __stdcall stopped_or_terminated (waitq *, _pinfo *);
static DWORD WINAPI wait_subproc (VOID *);
d135 3
a137 1
  if (!myself->ppid_handle)
d139 1
a139 1
      debug_printf ("No myself->ppid_handle");
a141 22
  else
    for (int i = 0; i < 2; i++)
      switch (res = WaitForSingleObject (myself->ppid_handle, 0))
	{
	  case WAIT_OBJECT_0:
	    debug_printf ("parent dead.");
	    res = false;
	    goto out;
	  case WAIT_TIMEOUT:
	    debug_printf ("parent still alive");
	    res = true;
	    goto out;
	  case WAIT_FAILED:
	    DWORD werr = GetLastError ();
	    if (werr == ERROR_INVALID_HANDLE && i == 0)
	      continue;
	    system_printf ("WFSO for myself->ppid_handle(%p) failed, error %d",
			   myself->ppid_handle, werr);
	    res = false;
	    goto out;
	}
out:
d156 1
a156 1
 * children, zombie arrays.
d223 1
a223 1
int __stdcall
d226 2
a227 7
  for (int i = 0; i < nchildren; i++)
    if (pchildren[i]->pid == pid)
      return 1;
  for (int i = 0; i < nzombies; i++)
    if (zombies[i]->pid == pid)
      return 1;
  return 0;
a240 1
  int thiszombie;
d258 2
a259 1
      if (nchildren >= PSIZE - 1)
d261 2
d264 1
d267 1
a267 10
      pchildren[nchildren] = vchild;
      hchildren[nchildren] = vchild->hProcess;
      if (!DuplicateHandle (hMainProc, vchild->hProcess, hMainProc, &vchild->pid_handle,
			    0, 0, DUPLICATE_SAME_ACCESS))
	system_printf ("Couldn't duplicate child handle for pid %d, %E", vchild->pid);
      ProtectHandle1 (vchild->pid_handle, pid_handle);

      if (!DuplicateHandle (hMainProc, hMainProc, vchild->hProcess, &vchild->ppid_handle,
			    SYNCHRONIZE | PROCESS_DUP_HANDLE, TRUE, 0))
	system_printf ("Couldn't duplicate my handle<%p> for pid %d, %E", hMainProc, vchild->pid);
d274 1
d276 7
a282 52

      sigproc_printf ("added pid %d to wait list, slot %d, winpid %p, handle %p",
		  vchild->pid, nchildren, vchild->dwProcessId,
		  vchild->hProcess);
      nchildren++;

      wake_wait_subproc ();
      break;

    /* A child process had terminated.
       Possibly this is just due to an exec().  Cygwin implements an exec()
       as a "handoff" from one windows process to another.  If child->hProcess
       is different from what is recorded in hchildren, then this is an exec().
       Otherwise this is a normal child termination event.
       (called from wait_subproc thread) */
    case PROC_CHILDTERMINATED:
      if (hchildren[val] != pchildren[val]->hProcess)
	{
	  sigproc_printf ("pid %d[%d], reparented old hProcess %p, new %p",
			  pchildren[val]->pid, val, hchildren[val], pchildren[val]->hProcess);
	  HANDLE h = hchildren[val];
	  hchildren[val] = pchildren[val]->hProcess; /* Filled out by child */
	  ForceCloseHandle1 (h, childhProc);
	  ProtectHandle1 (pchildren[val]->hProcess, childhProc);
	  rc = 0;
	  goto out;			// This was an exec()
	}

      sigproc_printf ("pid %d[%d] terminated, handle %p, nchildren %d, nzombies %d",
		  pchildren[val]->pid, val, hchildren[val], nchildren, nzombies);

      thiszombie = nzombies;
      zombies[nzombies] = pchildren[val];	// Add to zombie array
      zombies[nzombies++]->process_state = PID_ZOMBIE;// Walking dead

      sigproc_printf ("zombifying [%d], pid %d, handle %p, nchildren %d",
		      val, pchildren[val]->pid, hchildren[val], nchildren);
      if ((int) val < --nchildren)
	{
	  hchildren[val] = hchildren[nchildren];
	  pchildren[val] = pchildren[nchildren];
	}

      /* See if we should care about the this terminated process.  If we've
	 filled up our table or if we're ignoring SIGCHLD, then we immediately
	 remove the process and move on. Otherwise, this process becomes a zombie
	 which must be reaped by a wait() call.  FIXME:  This is a very inelegant
	 way to deal with this and could lead to process hangs.  */
      if (nzombies >= NZOMBIES)
	{
	  sigproc_printf ("zombie table overflow %d", thiszombie);
	  remove_zombie (thiszombie);
a283 3

      /* Don't scan the wait queue yet.  Caller will send SIGCHLD to this process.
	 This will cause an eventual scan of waiters. */
d306 2
a307 2
	  wval->ev = wval->thread_ev = CreateEvent (&sec_none_nih, TRUE,
						    FALSE, NULL);
d364 2
a365 3
	while (nzombies)
	  remove_zombie (0);
      break;
d396 1
a396 1
 * will not become zombies.
d401 1
a401 1
  sigproc_printf ("nchildren %d, nzombies %d", nchildren, nzombies);
d403 1
a403 1
  if (hwait_subproc)
a404 1
      proc_loop_wait = 0;	// Tell wait_subproc thread to exit
a405 2
      wake_wait_subproc ();	// Wake wait_subproc loop
      hwait_subproc = NULL;
d409 1
a409 1
      /* Clean out zombie processes from the pid list. */
d411 1
a411 14
      for (i = 0; i < nzombies; i++)
	{
	  if (zombies[i]->hProcess)
	    {
	      ForceCloseHandle1 (zombies[i]->hProcess, childhProc);
	      ForceCloseHandle1 (zombies[i]->pid_handle, pid_handle);
	    }
	  zombies[i]->ppid = 1;
	  zombies[i]->process_state = PID_EXITED;	/* CGF FIXME - still needed? */
	  zombies[i].release ();	// FIXME: this breaks older gccs for some reason
	}

      /* Disassociate my subprocesses */
      for (i = 0; i < nchildren; i++)
d413 4
a416 13
	  if (!pchildren[i]->hProcess)
	    sigproc_printf ("%d(%d) hProcess cleared already?", pchildren[i]->pid,
			pchildren[i]->dwProcessId);
	  else
	    {
	      ForceCloseHandle1 (pchildren[i]->hProcess, childhProc);
	      sigproc_printf ("%d(%d) closed child handle", pchildren[i]->pid,
			      pchildren[i]->dwProcessId);
	      pchildren[i]->ppid = 1;
	      if (pchildren[i]->pgid == myself->pid)
		pchildren[i]->process_state |= PID_ORPHANED;
	    }
	  pchildren[i].release ();
d418 1
a418 1
      nchildren = nzombies = 0;
d489 1
a489 1
   * access to the children and zombie arrays.
d527 1
a527 1
  proc_terminate ();		// Terminate process handling thread
a711 19
/* Initialize the wait_subproc thread.
 * Called from fork() or spawn() to initialize the handling of subprocesses.
 */
void __stdcall
subproc_init (void)
{
  if (hwait_subproc)
    return;

  /* A "wakeup" handle which can be toggled to make wait_subproc reexamine
   * the hchildren array.
   */
  events[0] = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
  hwait_subproc = new cygthread (wait_subproc, NULL, "proc");
  hwait_subproc->zap_h ();
  ProtectHandle (events[0]);
  sigproc_printf ("started wait_subproc thread");
}

a723 1
  ch->pppid_handle = myself->ppid_handle;
d736 1
a736 1
  sigproc_printf ("nchildren %d, nzombies %d", nchildren, nzombies);
d739 4
a742 4
   * given in w->next.
   */
  for (int i = 0; i < nzombies; i++)
    switch (stopped_or_terminated (parent_w, zombies[i]))
d744 1
a744 5
      case -1:
	potential_match = -1;
	break;
      case 1:
	remove_zombie (i);
d749 2
a750 13
  sigproc_printf ("checking alive children");

  /* No dead terminated children matched.  Check for stopped children. */
  for (int i = 0; i < nchildren; i++)
    switch (stopped_or_terminated (parent_w, pchildren[i]))
      {
      case -1:
	potential_match = -1;
	break;
      case 1:
	potential_match = 1;
	goto out;
      }
d757 4
a760 4
/* Remove a zombie from zombies by swapping it with the last child in the list.
 */
static void __stdcall
remove_zombie (int ci)
d762 2
a763 2
  sigproc_printf ("removing %d, pid %d, nzombies %d", ci, zombies[ci]->pid,
		  nzombies);
d765 9
a773 5
  if (zombies[ci])
    {
      ForceCloseHandle1 (zombies[ci]->hProcess, childhProc);
      ForceCloseHandle1 (zombies[ci]->pid_handle, pid_handle);
      zombies[ci].release ();
d775 3
a777 5

  if (ci < --nzombies)
    zombies[ci] = zombies[nzombies];

  return;
d781 6
a786 10
 *
 * parent_w is the pointer to the parent of the waitq member in question.
 * child is the subprocess being considered.
 *
 * Returns
 *   1 if stopped or terminated child matches parent_w->next criteria
 *  -1 if a non-stopped/terminated child matches parent_w->next criteria
 *   0 if child does not match parent_w->next criteria
 */
static int __stdcall
d789 1
a789 1
  int potential_match;
d794 1
a794 1
    potential_match = 1;
d796 1
a796 1
    potential_match = child->pgid == myself->pgid;
d798 1
a798 1
    potential_match = child->pgid == -w->pid;
d800 1
a800 1
    potential_match = (w->pid == child->pid);
d802 1
a802 1
  if (!potential_match)
d805 5
a809 1
  bool terminated;
d811 10
a820 2
  if ((terminated = child->process_state == PID_ZOMBIE) ||
      ((w->options & WUNTRACED) && child->stopsig))
d822 1
a822 2
      parent_w->next = w->next;	/* successful wait.  remove from wait queue */
      w->pid = child->pid;
d824 4
a827 7
      if (!terminated)
	{
	  sigproc_printf ("stopped child");
	  w->status = (child->stopsig << 8) | 0x7f;
	  child->stopsig = 0;
	}
      else /* Should only get here when child has been moved to the zombies array */
d829 2
a830 16
	  DWORD status;
	  if (!GetExitCodeProcess (child->hProcess, &status))
	    status = 0xffff;
	  if (status & EXIT_SIGNAL)
	    w->status = (status >> 8) & 0xff;	/* exited due to signal */
	  else
	    w->status = (status & 0xff) << 8;	/* exited via "exit ()" */

	  add_rusage (&myself->rusage_children, &child->rusage_children);
	  add_rusage (&myself->rusage_children, &child->rusage_self);

	  if (w->rusage)
	    {
	      add_rusage ((struct rusage *) w->rusage, &child->rusage_children);
	      add_rusage ((struct rusage *) w->rusage, &child->rusage_self);
	    }
a831 4

      if (!SetEvent (w->ev))	/* wake up wait4 () immediately */
	system_printf ("couldn't wake up wait event %p, %E", w->ev);
      return 1;
d834 3
a836 1
  return -potential_match;
a911 1
  myself->dwProcessId = GetCurrentProcessId ();
a915 16
  /* If we've been execed, then there is still a stub left in the previous
     windows process waiting to see if it's started a cygwin process or not.
     Signalling subproc_ready indicates that we are a cygwin process.  */
  if (child_proc_info && child_proc_info->type == PROC_EXEC)
    {
      debug_printf ("subproc_ready %p", child_proc_info->subproc_ready);
      if (!SetEvent (child_proc_info->subproc_ready))
	system_printf ("SetEvent (subproc_ready) failed, %E");
      ForceCloseHandle1 (child_proc_info->subproc_ready, subproc_ready);
      /* Initialize an "indirect" pid block so that if someone looks up this
	 process via its Windows PID it will be redirected to the appropriate
	 Cygwin PID shared memory block. */
      static pinfo NO_COPY myself_identity;
      myself_identity.init (cygwin_pid (myself->dwProcessId), PID_EXECED);
    }

a1031 82

/* Wait for subprocesses to terminate. Executes in a separate thread. */
static DWORD WINAPI
wait_subproc (VOID *)
{
  sigproc_printf ("starting");
  int errloop = 0;

  for (;;)
    {
      DWORD rc = WaitForMultipleObjects (nchildren + 1, events, FALSE,
					 proc_loop_wait);
      if (!proc_loop_wait)
	break;
      if (rc == WAIT_TIMEOUT)
	continue;

      if (rc == WAIT_FAILED)
	{
	  /* It's ok to get an ERROR_INVALID_HANDLE since another thread may have
	     closed a handle in the children[] array.  So, we try looping a couple
	     of times to stabilize. FIXME - this is not foolproof.  Probably, this
	     thread should be responsible for closing the children. */
	  if (!errloop++)
	    proc_subproc (PROC_NOTHING, 0);	// Just synchronize and continue
	  if (errloop < 10)
	    continue;

	  system_printf ("wait failed. nchildren %d, wait %d, %E",
			nchildren, proc_loop_wait);

	  for (int i = 0; i <= nchildren; i++)
	    if ((rc = WaitForSingleObject (events[i], 0)) == WAIT_OBJECT_0 ||
		rc == WAIT_TIMEOUT)
	      continue;
	    else if (i == 0)
		system_printf ("nchildren %d, event[%d] %p, %E", nchildren, i, events[i]);
	    else
	      {
		system_printf ("nchildren %d, event[%d] %p, pchildren[%d] %p, events[0] %p, %E",
			       nchildren, i, events[i], i - 1, (_pinfo *) pchildren[i - 1], events[0]);
		system_printf ("pid %d, dwProcessId %u, hProcess %p, progname '%s'",
			       pchildren[i - 1]->pid, pchildren[i - 1]->dwProcessId,
			       pchildren[i - 1]->hProcess, pchildren[i - 1]->progname);
	      }
	  break;
	}

      errloop = 0;
      rc -= WAIT_OBJECT_0;
      if (rc-- != 0)
	{
	  siginfo_t si;
	  si.si_signo = SIGCHLD;
	  si.si_code = SI_KERNEL;
	  si.si_pid = pchildren[rc]->pid;
	  si.si_uid = pchildren[rc]->uid;
	  si.si_errno = 0;
	  GetExitCodeProcess (hchildren[rc], (DWORD *) &si.si_status);
#if 0	// FIXME: This is tricky to get right
	  si.si_utime = pchildren[rc]->rusage_self.ru_utime;
	  si.si_stime = pchildren[rc].rusage_self.ru_stime;
#else
	  si.si_utime = 0;
	  si.si_stime = 0;
#endif
	  rc = proc_subproc (PROC_CHILDTERMINATED, rc);

	  /* Send a SIGCHLD to myself.   We do this here, rather than in proc_subproc
	     to avoid the proc_subproc lock since the signal thread will eventually
	     be calling proc_subproc and could unnecessarily block. */
	  if (rc)
	    sig_send (myself_nowait, si);
	}
      sigproc_printf ("looping");
    }

  ForceCloseHandle (events[0]);
  events[0] = NULL;
  sigproc_printf ("done");
  ExitThread (0);
}
@


1.201.2.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@d45 2
d49 1
a49 1
#define NPROCS	256
d67 5
d74 1
d79 12
a90 3
Static int nprocs;			// Number of deceased children
Static char cprocs[(NPROCS + 1) * sizeof (pinfo)];		// All my deceased children info
#define procs ((pinfo *) cprocs)
d100 3
a102 2
static void __stdcall remove_proc (int);
static bool __stdcall stopped_or_terminated (waitq *, _pinfo *);
d155 1
a155 3
  if (myself->cygstarted)
    res = pid_exists (myself->ppid);
  else
d157 1
a157 1
      debug_printf ("Not started by cygwin app");
d160 22
d196 1
a196 1
 * children, proc arrays.
d263 1
a263 1
bool __stdcall
d266 7
a272 2
  pinfo p (pid);
  return p && p->ppid == myself->pid;
d286 1
d304 1
a304 2
      /* Filled up process table? */
      if (nprocs >= NPROCS)
a305 2
	  sigproc_printf ("proc table overflow: hit %d processes, pid %d\n",
			  nprocs, vchild->pid);
a306 1
	  set_errno (EMFILE);	// FIXMENOW - what's the right errno?
d309 10
a318 1

a324 1
      vchild->cygstarted = true;
d326 41
a366 7
      procs[nprocs] = vchild;
      rc = procs[nprocs].wait ();
      if (rc)
	{
	  sigproc_printf ("added pid %d to proc table, slot %d", vchild->pid,
			  nprocs);
	  nprocs++;
d368 14
a460 1
      // FIXMENOW: What is supposed to happen here?
d462 2
a463 2
	while (nprocs)
	  remove_proc (0);
d495 1
a495 1
 * will not become procs.
d500 1
a500 1
  sigproc_printf ("nprocs %d", nprocs);
d502 1
a502 1
  if (nprocs)
d504 1
d506 2
d511 1
a511 1
      /* Clean out proc processes from the pid list. */
d513 1
a513 1
      for (i = 0; i < nprocs; i++)
d515 8
a522 4
	  procs[i]->ppid = 1;
	  if (!proc_exists (procs[i]))
	    procs[i]->process_state = PID_EXITED;	/* CGF FIXME - still needed? */
	  procs[i].release ();
d524 19
a542 1
      nprocs = 0;
d613 1
a613 1
   * access to the children and proc arrays.
d836 19
d867 1
d880 1
a880 1
  sigproc_printf ("nprocs %d", nprocs);
d883 4
a886 4
   * given in w->next.  */
  int res;
  for (int i = 0; i < nprocs; i++)
    if ((res = stopped_or_terminated (parent_w, procs[i])))
d888 5
a892 1
	remove_proc (i);
d897 13
a909 1
  potential_match = -!!nprocs;
d916 2
a917 2
/* Remove a proc from procs by swapping it with the last child in the list.
   Also releases shared memory of exited processes.  */
d919 1
a919 1
remove_proc (int ci)
d921 8
a928 7
  if (!proc_exists (procs[ci]))
    { 
      sigproc_printf ("removing procs[%d], pid %d, nprocs %d", ci, procs[ci]->pid,
		      nprocs);
      procs[ci].release ();
      if (ci < --nprocs)
	procs[ci] = procs[nprocs];
d930 5
d938 10
a947 6
  
   parent_w is the pointer to the parent of the waitq member in question.
   child is the subprocess being considered.
  
   Returns non-zero if waiting thread released.  */
static bool __stdcall
d950 1
a950 1
  int might_match;
d955 1
a955 1
    might_match = 1;
d957 1
a957 1
    might_match = child->pgid == myself->pgid;
d959 1
a959 1
    might_match = child->pgid == -w->pid;
d961 1
a961 1
    might_match = (w->pid == child->pid);
d963 1
a963 1
  if (!might_match)
d966 1
a966 1
  int terminated;
d968 5
a972 3
  if (!((terminated = child->process_state == PID_ZOMBIE) ||
      ((w->options & WUNTRACED) && child->stopsig)))
    return 0;
d974 15
a988 2
  parent_w->next = w->next;	/* successful wait.  remove from wait queue */
  w->pid = child->pid;
d990 2
a991 9
  if (!terminated)
    {
      sigproc_printf ("stopped child");
      w->status = (child->stopsig << 8) | 0x7f;
      child->stopsig = 0;
    }
  else /* Should only get here when child has been moved to the procs array */
    {
      w->status = child->exitcode;
d993 6
a998 2
      add_rusage (&myself->rusage_children, &child->rusage_children);
      add_rusage (&myself->rusage_children, &child->rusage_self);
d1000 3
a1002 5
      if (w->rusage)
	{
	  add_rusage ((struct rusage *) w->rusage, &child->rusage_children);
	  add_rusage ((struct rusage *) w->rusage, &child->rusage_self);
	}
d1005 1
a1005 3
  if (!SetEvent (w->ev))	/* wake up wait4 () immediately */
    system_printf ("couldn't wake up wait event %p, %E", w->ev);
  return true;
a1085 1
#if 0
a1100 1
#endif
d1218 82
@


1.201.2.2
log
@guess ignoring SIGCHLD really is important.
@
text
@d83 1
a83 1
static bool __stdcall remove_proc (int);
d367 3
a369 2
	for (int i = 0; i < nprocs; i += remove_proc (i))
	  continue;
a752 1
  sigproc_printf ("no matching terminated children found");
d762 1
a762 1
static bool __stdcall
d765 8
a772 9
  if (proc_exists (procs[ci]))
    return true;

  sigproc_printf ("removing procs[%d], pid %d, nprocs %d", ci, procs[ci]->pid,
		  nprocs);
  procs[ci].release ();
  if (ci < --nprocs)
    procs[ci] = procs[nprocs];
  return 0;
@


1.201.2.3
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d31 1
@


1.201.2.4
log
@checkpoint
@
text
@d33 1
d364 1
d529 1
a529 1
  proc_terminate ();		// clean up process stuff
d907 1
d912 18
@


1.201.2.5
log
@experiment
@
text
@d277 1
a277 7
      if (!CGFFAST)
	rc = procs[nprocs].wait ();
      else
	{
	  procs[nprocs].preserve ();
	  rc = 1;
	}
d800 1
a800 1
  if (!((terminated = (child->process_state == PID_ZOMBIE | child->process_state == PID_EXITED)) ||
@


1.201.2.6
log
@unexperiment
@
text
@d277 7
a283 1
      rc = procs[nprocs].wait ();
d806 1
a806 1
  if (!((terminated = (child->process_state == PID_ZOMBIE)) ||
@


1.201.2.7
log
@fix wait when invoked from non-cygwin process.
@
text
@d767 1
a767 2
  if (procs[ci] != myself)
    procs[ci].release ();
@


1.201.2.8
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
@
text
@d306 2
a307 2
	  wval->ev = wval->thread_ev = CreateEvent (&sec_none_nih, TRUE, FALSE,
						    NULL);
d768 1
a768 7
    {
      procs[ci].release ();
      if (procs[ci].pid_handle)
	ForceCloseHandle1 (procs[ci].pid_handle, childhProc);
      if (procs[ci].hProcess)
	ForceCloseHandle1 (procs[ci].hProcess, childhProc);
    }
@


1.200
log
@* sigproc.cc (wait_sig): Ensure that waiting threads are awoken after returning
from a hold condition.
@
text
@d1185 2
@


1.199
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d1142 1
a1158 7
	case __SIGFLUSH:
	case __SIGFLUSHFAST:
	  sigq.reset ();
	  while ((q = sigq.next ()))
	    if (q->si.si_signo == __SIGDELETE || q->process () > 0)
	      sigq.del ();
	  break;
d1164 12
d1200 1
a1200 1
		proc_subproc (PROC_CLEARWAIT, 0);
d1204 2
@


1.198
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d710 2
d859 1
a859 1
init_child_info (DWORD chtype, child_info *ch, pid_t pid, HANDLE subproc_ready)
a865 1
  ch->cygpid = pid;
d1068 1
d1085 1
d1165 6
d1174 2
@


1.197
log
@* sigproc.cc (wait_sig): Make sure that SIGCHLD is handled regardless of
whether a signal is queued.
@
text
@d429 1
a429 1
         match this pid, then activate it.  */
d762 1
a762 1
         process is exiting.  */
@


1.196
log
@* sigproc.cc (wait_sig): Report if not trying to send signal due to queued
signal.
@
text
@a1164 2
	  else if (sigq.sigs[pack.si.si_signo].si.si_signo)
	    sigproc_printf ("sig %d already queued", pack.si.si_signo);
d1168 3
a1170 2
	      int sigres = pack.process ();
	      if (sigres <= 0)
d1172 3
d1176 2
a1177 2
		  if (!sigres)
		    system_printf ("Failed to arm signal %d from pid %d", pack.sig, pack.pid);
d1179 2
a1180 1
		  sigq.add (pack);	// FIXME: Shouldn't add this in !sh condition
@


1.195
log
@* path.cc (normalize_posix_path): Reorganize to short circuit to DOS path
handling whenever a '\' is detected.
* signal.cc (sigaction): Make strace output more informative.
* sigproc.cc (pending_signals::add): Just index directly into signal array
rather than treating the array as a heap.
(pending_signals::del): Ditto.
(wait_sig): Don't send signal if we already have a similar signal queued.
* sigproc.h (call_signal_handler_now): Remove obsolete declaration.
@
text
@d1165 3
a1167 1
	  else if (!sigq.sigs[pack.si.si_signo].si.si_signo)
@


1.194
log
@* sigproc.cc (proc_terminate): Release sync_proc_subproc when done terminating
or suffer potential hangs.
(get_proc_lock): Reorganize debugging output slightly.
@
text
@a50 22
class pending_signals
{
  sigpacket sigs[NSIG + 1];
  sigpacket start;
  sigpacket *end;
  sigpacket *prev;
  sigpacket *curr;
  int empty;
public:
  void reset () {curr = &start; prev = &start;}
  void add (sigpacket&);
  void del ();
  sigpacket *next ();
  sigpacket *save () const {return curr;}
  void restore (sigpacket *saved) {curr = saved;}
  friend void __stdcall sig_dispatch_pending (bool);
};

static pending_signals sigq;

struct sigaction *global_sigs;

d54 2
d97 1
a97 2
/* Functions
 */
a100 1
static DWORD WINAPI wait_sig (VOID *arg);
d103 3
d107 21
a1016 8
/* Process signals by waiting for a semaphore to become signaled.
   Then scan an in-memory array representing queued signals.
   Executes in a separate thread.

   Signals sent from this process are sent a completion signal so
   that returns from kill/raise do not occur until the signal has
   has been handled, as per POSIX.  */

d1021 3
a1023 7
  for (se = start.next; se; se = se->next)
    if (se->si.si_signo == pack.si.si_signo)
      return;
  while (sigs[empty].si.si_signo)
    if (++empty == NSIG)
      empty = 0;
  se = sigs + empty;
a1031 1
  empty++;
a1044 1
  empty = curr - sigs;
d1165 1
a1165 1
	  else
@


1.193
log
@* cygtls.cc (_cygtls::remove): Call remove_wq even when we can't necessarily
get the cygtls table lock.
* cygtls.h (_cygtls::remove_wq): Add wait argument.
* sigproc.cc (_cygtls::remove_wq): Honor wait argument when acquiring lock.
(proc_terminate): Don't NULL sync_proc_subproc since other threads may still
try to access it.
@
text
@d217 1
a217 1
  system_printf ("Couldn't aquire sync_proc_subproc for(%d,%d), %E, last %d",
d541 1
@


1.192
log
@* cygtls.cc (_cygtls::remove): Call remove_wq to ensure that wait stuff is
removed from proc_subproc linked list.
* cygtls.h (_cygtls::remove_wq): Declare.
* sigproc.cc (_cygtls::remove_wq): Define.
(proc_subproc): Label event handle appropriately.
* spawn.cc (spawn_guts): Return -1 when wait() fails for spawn types that
require waiting.
@
text
@d474 1
a474 1
_cygtls::remove_wq ()
d476 11
a486 9
  sync_proc_subproc->acquire ();
  for (waitq *w = &waitq_head; w->next != NULL; w = w->next)
    if (w->next == &wq)
      {
	ForceCloseHandle1 (wq.thread_ev, wq_ev);
	w->next = wq.next;
	break;
      }
  sync_proc_subproc->release ();
a540 1
      sync_proc_subproc = NULL;
@


1.191
log
@* cygtls.h (waitq): Declare structure here.
(_cygtls::wq): Declare.
* cygtls.cc (_cygtls::fixup_after_fork): Clear wq.thread_ev to avoid using an
invalid event handle in forked process.
* dcrt0.cc (waitq_storage): Delete.
(threadstuff): Remove waitq_storage.
* perthread.h (per_thread_waitq): Delete.
(waitq_storage): Delete declaration.
* sigproc.cc (sigproc_init): Remove perthread waitq consideration.
* sigproc.h (waitq): Delete declaration.
* wait.cc (wait4): Use _my_tls waitq structure rather than per_thread.
* cygtls.h (_cygtls::newmask): Delete member.
(_cygtls::deltamask): New member.
* gendef (_sigdelayed): Replace the call to set_process_mask by a call to
set_process_mask_delta.
* exceptions.cc (handle_sigsuspend): Do not filter tempmask.  Or
SIG_NONMASKABLE in deltamask as a flag.
(_cygtls::interrupt_setup): Set deltamask only.
(set_process_mask_delta): New function.
(_cygtls::call_signal_handler): Replace the first call to set_process_mask by a
call to set_process_mask_delta.
* tlsoffsets.h: Regenerate.
@
text
@d404 1
a404 1
	  ProtectHandle (wval->ev);
d470 15
@


1.190
log
@* exceptions.cc (setup_handler): Avoid suspending a thread if it in a cygwin
function, in an exception, spinning, or locked.
* gendef (_sigfe): Move incyg setting earlier.
(sigreturn): Set incyg flag to avoid interrupting called cygwin functions.
(sigdelayed): Ditto.
(stabilize_sig_stack): Ditto.
* sigproc.cc (proc_subproc): Don't restore process lock early in exec case.
* cygtls.h: Reorganize fields in _cygtls slightly.
* tlsoffsets.h: Regenerate.
@
text
@a111 1
Static waitq waitq_main;		// Storage for main thread
a604 12

  /* Initialize waitq structure for main thread.  A waitq structure is
   * allocated for each thread that executes a wait to allow multiple threads
   * to perform waits.  Pre-allocate a waitq structure for the main thread.
   */
  waitq *w;
  if ((w = (waitq *)waitq_storage.get ()) == NULL)
    {
      w = &waitq_main;
      waitq_storage.set (w);
    }
  memset (w, 0, sizeof *w);	// Just to be safe
@


1.189
log
@* exceptions.cc (setup_handler): Signal event for any sigwaitinfo if it exists
to force signal to be handled.  Zero event here to prevent races.
* signal.cc (sigwaitinfo): Use local handle value for everything since signal
thread could zero event element at any time.  Detect when awaking due to thread
not in mask and set return value and errno accordingly.  Don't set signal
number to zero unless we've recognized the signal.
* sigproc.cc (sigq): Rename from sigqueue throughout.
* thread.cc (pthread::join): Handle signals received while waiting for thread
to terminate.
* cygwin.din: Export sighold, sigqueue.
* exceptions.cc (sighold): Define new function.
* signal.cc (handle_sigprocmask): Set correct errno for invalid signal.
Simplify debugging output.
(sigqueue): Define new function.
* include/cygwin/signal.h (sighold): Declare new function.
(sigqueue): Ditto.
* include/cygwin/version.h: Bump API minor version number.
* include/limits.h (TIMER_MAX): Define.
(_POSIX_TIMER_MAX): Ditto.
@
text
@a346 1
	  sync_proc_subproc->release ();	// Release the lock ASAP
@


1.188
log
@* Makefile.in: Compile syscalls.o with -fomit-frame-pointer.
* sigproc.cc: Eliminate unused variable.
@
text
@d69 1
a69 1
static pending_signals sigqueue;
d540 3
a542 3
      sigpacket *save = sigqueue.save ();
      sigqueue.reset ();
      while ((q = sigqueue.next ()))
d548 1
a548 1
      sigqueue.restore (save);
d567 1
a567 1
  if (exit_state || GetCurrentThreadId () == sigtid || !sigqueue.start.next)
d570 2
a571 2
      sigproc_printf ("exit_state %d, cur thread id %p, sigtid %p, sigqueue.start.next %p",
		      exit_state, GetCurrentThreadId (), sigtid, sigqueue.start.next);
d1159 2
a1160 2
	  sigqueue.reset ();
	  while ((q = sigqueue.next ()))
d1166 2
a1167 2
	  sigqueue.reset ();
	  while ((q = sigqueue.next ()))
d1169 1
a1169 1
	      sigqueue.del ();
d1184 1
a1184 1
		  sigqueue.add (pack);	// FIXME: Shouldn't add this in !sh condition
@


1.187
log
@* sigproc.cc (proc_subproc): Change warning back to silent debug output.
@
text
@a91 1
Static HANDLE sendsig_tome;
@


1.186
log
@* Makefile.in (clean): Remove sigfe.s.
(sigfe.s): Ensure that sigfe.s will be regenerated if it does not exist.
* dll_init.cc (dll_dllcrt0): Simplify initializing tests.
* exceptions.cc (setup_handler): Detect when stub caller is either spinning or
has acquired the lock after being suspended to avoid windows problems with
suspending a win32 API call.
* cygtls.h (_cygtls::spinning): Declare new element.
* gendef: Remove unused _siglist_index and _siglist declaration.
(_sigfe): Set spinning element when potentially looping, waiting for lock.
(_sigbe): Ditto.
(_cygtls::lock): Ditto.
(_longjmp): Ditto.
* tlsoffsets.h: Regenerate.
* pinfo.cc (_pinfo::exit): Set final exit state here.  Call sigproc_terminate
if invoked with 'norecord'.  Clear any residual _cygtls stuff.
* winsup.h (exit_states): Define ES_FINAL.
* spawn.cc (spawn_guts): Don't call proc_terminate specifically when execing.
Let _pinfo::exit handle that case.
* sigproc.cc (wait_subproc): Always exit loop early when proc_loop_wait.
* init.cc (munge_threadfunc): Eliminate unused argument.
(dll_entry): Reflect above change in call to munge_threadfunc.
@
text
@d377 1
a377 1
	  system_printf ("zombie table overflow %d", thiszombie);
@


1.185
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@a72 20
void __stdcall
sigalloc ()
{
  cygheap->sigs = global_sigs =
    (struct sigaction *) ccalloc (HEAP_SIGS, NSIG, sizeof (struct sigaction));
}

void __stdcall
signal_fixup_after_exec ()
{
  global_sigs = cygheap->sigs;
  /* Set up child's signal handlers */
  for (int i = 0; i < NSIG; i++)
    {
      global_sigs[i].sa_mask = 0;
      if (global_sigs[i].sa_handler != SIG_IGN)
	global_sigs[i].sa_handler = SIG_DFL;
    }
}

a83 3
/*
 * Common variables
 */
d85 1
d88 1
a88 4
 * On termination, however, these are set to zero as a flag to exit.
 */

#define Static static NO_COPY
d92 1
d128 20
d1214 2
d1217 1
a1217 4
	if (!proc_loop_wait)
	  break;			// Exiting
	else
	  continue;
a1220 3
	  if (!proc_loop_wait)
	    break;

a1268 2
	  if (!proc_loop_wait)		// Don't bother if wait_subproc is
	    break;			//  exiting
@


1.184
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d671 1
a671 1
sig_send (_pinfo *p, siginfo_t& si, _threadinfo *tls)
d750 1
a750 1
  pack.tls = (_threadinfo *) tls;
d819 1
a819 1
    call_signal_handler_now ();
@


1.183
log
@* cygerrno.h (set_errno): Set global errno whenever setting thread specific
version.
* debug.cc (__set_errno): Ditto.
* exceptions.cc (handle_sigsuspend): Remove spurious sig_dispatch_pending call.
(set_signal_mask): When there seem to be pending signals to dispatch, tell
signal_dispatch_pending/sig_send not to specifically call any handlers.
* sigproc.h (sig_dispatch_pending): Change declaration to void.
* sigproc.cc (sig_dispatch_pending): Change definition to void.  Take an
argument to determine whether to tell sig_send to wait for handler to be
called.
* sigproc.cc (sig_send): Don't call signal handler when sig == __SIGFLUSHFAST.
(wait_sig): Honor __SIGFLUSHFAST.  Guard against sigpacket::process nuking
si_signo.
* sigproc.h (__SIGFLUSHFAST): Define new special signal.
(sig_dispatch_pending): Change declaration to void.  Take optional boolean
argument.
* fork.cc (vfork): Add debugging output.
@
text
@d128 1
d130 1
a130 1
Static int nchildren;			// Number of active children
a131 1
Static int nzombies;			// Number of deceased children
d381 1
a381 1
	  sigproc_printf ("zombie table overflow %d", thiszombie);
@


1.182
log
@* sigproc.cc (proc_subproc): Don't protect *child's* handle.
@
text
@d66 1
a66 1
  friend int __stdcall sig_dispatch_pending ();
d434 1
a434 2
       * match this pid, then activate it.
       */
d569 2
a570 2
int __stdcall
sig_dispatch_pending ()
d578 1
a578 1
      return 0;
d584 1
a584 2
  (void) sig_send (myself, __SIGFLUSH);
  return call_signal_handler_now ();
d801 6
d818 1
a818 1
  if (wait_for_completion)
a823 1

d1170 1
d1181 1
d1191 1
a1191 1
	      if (pack.si.si_signo == SIGCHLD)
@


1.181
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@a322 1
      VerifyHandle (vchild->ppid_handle);
@


1.180
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d577 1
a577 1
      sigproc_printf ("exit_state %d, GetCurrentThreadId () %p, sigtid %p, sigqueue.start.next %p",
@


1.179
log
@* cygtls.cc (_threadinfo::remove): Don't assume that we are removing _my_tls.
* exceptions.cc (setup_handler): Improve debugging output.
(call_signal_handler_now): Remove ill-advised debugger call.
* sigproc.cc (sigcomplete_main): Delete.
(sig_send): Honor FIXME and avoid using main thread's completion event for
everything or suffer races.
(pending_signals::add): Default stored mask to current process mask rather than
mask at time of signal send.
(wait_sig): Add debugging output.
* sigproc.h (sigpacket::mask_storage): Delete.
@
text
@d323 1
d720 1
d726 1
d732 1
a732 1
      pack.wakeup = NULL;
@


1.178
log
@* fhandler_tty.cc (fhandler_tty::ioctl): Semi-revert 2003-09-26 change for
TIOCSWINSZ.  It is not an error for ioctl_request_event to be missing.
* sigproc.cc (pending_signals::save): New function.
(pending_signals::restore): Ditto.
(sig_clear): Save/restore current queue pointer.
(wait_sig): Delete signals marked as such.
* sigproc.h (__SIGDELETE): New enum.
@
text
@a116 3
Static HANDLE sigcomplete_main;		// Event signaled when a signal has
					//  finished processing for the main
					//  thread
a645 1
      ForceCloseHandle (sigcomplete_main);
d680 1
a681 1
  // FIXMENOW: Avoid using main thread's completion event!
d709 1
a709 5
    {
      sendsig = myself->sendsig;
      if (wait_for_completion)
	pack.wakeup = sigcomplete_main;
    }
d751 7
a757 1
  pack.mask_storage = 0;
d816 3
d1032 1
a1032 2
  se->mask_storage = *(pack.mask);
  se->mask = &se->mask_storage;
a1079 2
  /* sigcomplete_main	   - event used to signal main thread on signal
    			     completion */
a1081 2
  sigcomplete_main = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
  sigproc_printf ("sigcomplete_main %p", sigcomplete_main);
a1091 2
  ProtectHandle (sigcomplete_main);

d1190 4
a1193 1
	SetEvent (pack.wakeup);
@


1.177
log
@* sigproc.cc (sigproc_terminate): Don't close sendsig handle when execing since
we're not closing what we think we're closing.
(sig_send): Improve debugging when exiting due to no_signals_available.
* wincap.h (wincaps::cant_debug_dll_entry): New element.
* wincap.cc: Implement above element throughout.
* dcrt0.cc (initial_env): Accommodate changes necessary to allow initial
debugging for systems which do not allow debugging in dll_entry.
(dll_crt0_0): Add initial_env call back here.
* Makefile.in (install-man): Use mandir as target for installation.
* include/cygwin/version.h: Bump DLL minor number to 7 (should have been done
earlier).
@
text
@d64 2
d548 2
a550 1
      sigpacket *q;
d554 1
a554 1
	    sigqueue.del ();
d557 1
d1173 1
a1173 1
	    if (q->process () > 0)
@


1.176
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d636 1
d646 6
a651 3
      HANDLE sendsig = myself->sendsig;
      myself->sendsig = INVALID_HANDLE_VALUE;
      CloseHandle (sendsig);
d687 5
a691 1
	goto out;		// Either exiting or not yet initializing
a707 2
  sigproc_printf ("pid %d, signal %d, its_me %d", p->pid, si.si_signo, its_me);

d736 2
d1115 2
@


1.175
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@a50 10
struct sigelem
{
  int sig;
  int pid;
  _threadinfo *tls;
  class sigelem *next;
  friend class pending_signals;
  friend int __stdcall sig_dispatch_pending ();
};

d53 5
a57 5
  sigelem sigs[NSIG + 1];
  sigelem start;
  sigelem *end;
  sigelem *prev;
  sigelem *curr;
d61 1
a61 1
  void add (int sig, int pid, _threadinfo *tls);
d63 1
a63 1
  sigelem *next ();
a66 9
struct sigpacket
{
  int sig;
  pid_t pid;
  HANDLE wakeup;
  sigset_t *mask;
  _threadinfo *tls;
};

d547 1
a547 1
      sigelem *q;
d549 1
a549 1
	if (q->sig == target_sig)
d654 10
d665 3
a667 4
 * If pinfo *p == NULL, send to the current process.
 * If sending to this process, wait for notification that a signal has
 * completed before returning.
 */
d669 1
a669 1
sig_send (_pinfo *p, int sig, void *tls)
d696 1
a696 1
		  p->pid, p->process_state, sig);
d700 1
a700 1
  sigproc_printf ("pid %d, signal %d, its_me %d", p->pid, sig, its_me);
d733 1
a733 1
  else if (sig == __SIGPENDING)
d735 1
a735 1
  else if (sig == __SIGFLUSH || sig > 0)
d740 5
a744 1
  pack.sig = sig;
d747 1
d765 1
a765 1
			  sig, p->pid, sendsig);
d785 2
a786 1
      sigproc_printf ("Not waiting for sigcomplete.  its_me %d signal %d", its_me, sig);
d797 1
a797 1
		      sig, rc);
d806 1
a806 1
  if (sig != __SIGPENDING)
d812 1
a812 1
  sigproc_printf ("returning %p from sending signal %d", rc, sig);
d1008 1
a1008 1
pending_signals::add (int sig, int pid, _threadinfo *tls)
d1010 1
a1010 1
  sigelem *se;
d1012 1
a1012 1
    if (se->sig == sig)
d1014 1
a1014 1
  while (sigs[empty].sig)
d1018 3
a1020 1
  se->sig = sig;
a1021 2
  se->tls = tls;
  se->pid = pid;
d1033 1
a1033 1
  sigelem *next = curr->next;
d1035 1
a1035 1
  curr->sig = 0;
d1045 1
a1045 1
sigelem *
d1048 1
a1048 1
  sigelem *res;
d1124 1
a1124 1
      if (!pack.sig)
d1139 2
a1140 2
      sigelem *q;
      switch (pack.sig)
d1153 1
a1153 1
	    if (myself->getsigmask () & (bit = SIGTOMASK (q->sig)))
d1159 1
a1159 1
	    if (sig_handle (q->sig, *pack.mask, q->pid, q->tls) > 0)
d1163 2
a1164 2
	  if (pack.sig < 0)
	    sig_clear (-pack.sig);
d1167 1
a1167 1
	      int sigres = sig_handle (pack.sig, *pack.mask, pack.pid, pack.tls);
d1174 1
a1174 1
		  sigqueue.add (pack.sig, pack.pid, pack.tls);// FIXME: Shouldn't add this in !sh condition
d1176 1
a1176 1
	      if (pack.sig == SIGCHLD)
d1244 14
d1266 1
a1266 1
	    sig_send (myself_nowait, SIGCHLD);
@


1.175.4.1
log
@merge from trunk.
@
text
@a654 1
  extern HANDLE hExeced;
d664 3
a666 6
      if (!hExeced)
	{
	  HANDLE sendsig = myself->sendsig;
	  myself->sendsig = INVALID_HANDLE_VALUE;
	  CloseHandle (sendsig);
	}
d693 1
a693 5
	{
	  sigproc_printf ("hwait_sig %p, myself->sendsig %p, exit_state %d",
			  hwait_sig, myself->sendsig, exit_state);
	  goto out;		// Either exiting or not yet initializing
	}
d710 2
a739 3
  sigproc_printf ("sendsig %p, pid %d, signal %d, its_me %d", sendsig, p->pid,
		  sig, its_me);

a1110 2
  debug_printf ("entering ReadFile loop, readsig %p, myself->sendsig %p",
		readsig, myself->sendsig);
@


1.175.4.2
log
@* sigproc.cc (pending_signals::save): New function.
(pending_signals::restore): Ditto.
(sig_clear): Save/restore current queue pointer.
(wait_sig): Delete signals marked as such.
* sigproc.h (__SIGDELETE): New enum.
@
text
@a73 2
  sigelem *save () const {return curr;}
  void restore (sigelem *saved) {curr = saved;}
d565 1
a566 2
      sigelem *save = sigqueue.save ();
      sigqueue.reset ();
d570 1
a570 1
	    q->sig = __SIGDELETE;
a572 1
      sigqueue.restore (save);
d1174 1
a1174 2
	    if (q->sig == __SIGDELETE
		|| (sig_handle (q->sig, *pack.mask, q->pid, q->tls) > 0))
@


1.175.4.3
log
@* dcrt0.cc (reent_data): Make global.
* cygwin.din: Reexport reent_data.
* cygtls.cc (_threadinfo::remove): Don't assume that we are removing _my_tls.
* exceptions.cc (setup_handler): Improve debugging output.
(call_signal_handler_now): Remove ill-advised debugger call.
* sigproc.cc (sigcomplete_main): Delete.
(sig_send): Honor FIXME and avoid using main thread's completion event for
everything or suffer races.
(pending_signals::add): Default stored mask to current process mask rather than
mask at time of signal send.
(wait_sig): Add debugging output.
* sigproc.h (sigpacket::mask_storage): Delete.
* fhandler.cc (fhandler_base::open): Revert isfs change.
@
text
@d136 3
d668 1
a693 1
  pack.wakeup = NULL;
d695 1
d723 5
a727 1
    sendsig = myself->sendsig;
a765 7
  if (wait_for_completion)
     {
       pack.wakeup = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
       sigproc_printf ("wakeup %p", pack.wakeup);
       ProtectHandle (pack.wakeup);
     }

d770 1
a770 1
	 process is exiting.  */
a822 3
  if (pack.wakeup)
    ForceCloseHandle (pack.wakeup);

d1085 2
d1089 2
d1101 2
d1202 1
a1202 4
	{
	  SetEvent (pack.wakeup);
	  sigproc_printf ("signalled %p", pack.wakeup);
	}
@


1.175.4.4
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a341 1
      VerifyHandle (vchild->ppid_handle);
a728 1
      VerifyHandle (hp);
a733 1
	  CloseHandle (hp);
d739 1
a739 1
      VerifyHandle (sendsig);
@


1.175.4.5
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d596 1
a596 1
      sigproc_printf ("exit_state %d, cur thread id %p, sigtid %p, sigqueue.start.next %p",
@


1.175.4.6
log
@* sigproc.cc (proc_subproc): Don't protect *child's* handle.
@
text
@d342 1
@


1.174
log
@* cygtls.h (_threadinfo::stack): Increase stack size to accommodate nested
signal handlers.  Reorganize to cause potential SEGV on stack overflow.
* sigproc.cc (no_signals_available): Check sendsig value rather than relying on
obsolete sig_loop_wait.
(sigproc_terminate): Ditto.
(proc_can_be_signalled): Check sendsig value even for myself.
* tlsoffsets.h: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
d35 1
d1109 3
d1117 2
@


1.174.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
a34 1
#include "exceptions.h"
a1106 3

  exception_list el;
  _my_tls.init_threadlist_exceptions (&el);
@


1.174.2.2
log
@* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
@
text
@a1117 2
      if (myself->sendsig == INVALID_HANDLE_VALUE)
	break;
@


1.174.2.3
log
@* gentls_offsets: Reinstate unlink of temp files.
@
text
@d51 10
d63 5
a67 5
  sigpacket sigs[NSIG + 1];
  sigpacket start;
  sigpacket *end;
  sigpacket *prev;
  sigpacket *curr;
d71 1
a71 1
  void add (sigpacket&);
d73 1
a73 1
  sigpacket *next ();
d77 9
d566 1
a566 1
      sigpacket *q;
d568 1
a568 1
	if (q->si.si_signo == target_sig)
a672 10
int __stdcall
sig_send (_pinfo *p, int sig)
{
  siginfo_t si;
  si.si_signo = sig;
  si.si_code = SI_KERNEL;
  si.si_pid = si.si_uid = si.si_errno = 0;
  return sig_send (p, si);
}

d674 4
a677 3
   If pinfo *p == NULL, send to the current process.
   If sending to this process, wait for notification that a signal has
   completed before returning.  */
d679 1
a679 1
sig_send (_pinfo *p, siginfo_t& si, _threadinfo *tls)
d706 1
a706 1
		  p->pid, p->process_state, si.si_signo);
d710 1
a710 1
  sigproc_printf ("pid %d, signal %d, its_me %d", p->pid, si.si_signo, its_me);
d743 1
a743 1
  else if (si.si_signo == __SIGPENDING)
d745 1
a745 1
  else if (si.si_signo == __SIGFLUSH || si.si_signo > 0)
d750 1
a750 5
  pack.si = si;
  if (!pack.si.si_pid)
    pack.si.si_pid = myself->pid;
  if (!pack.si.si_uid)
    pack.si.si_uid = myself->uid;
d770 1
a770 1
			  si.si_signo, p->pid, sendsig);
d790 1
a790 2
      sigproc_printf ("Not waiting for sigcomplete.  its_me %d signal %d",
		      its_me, si.si_signo);
d801 1
a801 1
		       si.si_signo, rc);
d810 1
a810 1
  if (si.si_signo != __SIGPENDING)
d816 1
a816 1
  sigproc_printf ("returning %p from sending signal %d", rc, si.si_signo);
d1012 1
a1012 1
pending_signals::add (sigpacket& pack)
d1014 1
a1014 1
  sigpacket *se;
d1016 1
a1016 1
    if (se->si.si_signo == pack.si.si_signo)
d1018 1
a1018 1
  while (sigs[empty].si.si_signo)
d1022 1
a1022 3
  *se = pack;
  se->mask_storage = *(pack.mask);
  se->mask = &se->mask_storage;
d1024 2
d1037 1
a1037 1
  sigpacket *next = curr->next;
d1039 1
a1039 1
  curr->si.si_signo = 0;
d1049 1
a1049 1
sigpacket *
d1052 1
a1052 1
  sigpacket *res;
d1128 1
a1128 1
      if (!pack.si.si_signo)
d1143 2
a1144 2
      sigpacket *q;
      switch (pack.si.si_signo)
d1157 1
a1157 1
	    if (myself->getsigmask () & (bit = SIGTOMASK (q->si.si_signo)))
d1163 1
a1163 1
	    if (q->process () > 0)
d1167 2
a1168 2
	  if (pack.si.si_signo < 0)
	    sig_clear (-pack.si.si_signo);
d1171 1
a1171 1
	      int sigres = pack.process ();
d1178 1
a1178 1
		  sigqueue.add (pack);	// FIXME: Shouldn't add this in !sh condition
d1180 1
a1180 1
	      if (pack.si.si_signo == SIGCHLD)
a1247 7
	  siginfo_t si;
	  si.si_signo = SIGCHLD;
	  si.si_code = SI_KERNEL;
	  si.si_pid = pchildren[rc]->pid;
	  si.si_uid = pchildren[rc]->uid;
	  si.si_errno = 0;
	  si.si_status = si.si_utime = si.si_stime = 0;	// FIXME fill these in someday
d1256 1
a1256 1
	    sig_send (myself_nowait, si);
@


1.174.2.4
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@a746 1
  pack.mask_storage = 0;
d1249 1
a1249 8
	  GetExitCodeProcess (hchildren[rc], (DWORD *) &si.si_status);
#if 0	// FIXME: This is tricky to get right
	  si.si_utime = pchildren[rc]->rusage_self.ru_utime;
	  si.si_stime = pchildren[rc].rusage_self.ru_stime;
#else
	  si.si_utime = 0;
	  si.si_stime = 0;
#endif
@


1.173
log
@* dcrt0.cc (reent_data): Reluctantly resurrect.
(__cygwin_user_data::impure_ptr): Ditto.
(_dll_crt0): Reluctantly initialize _impure_ptr here.
(initialize_main_tls): Eliminate local_clib initialization since it now happens
in init_thread.
* init.cc (dll_entry): Reluctantly remove code which set _impure_ptr to the
main thread's local_clib.
* perthread.h (reent_data): Remove obsolete declaration.
* sigproc.cc (proc_subproc): Add more debugging output.
(get_proc_lock): Ditto.
*dcrt0.cc (dll_crt0_1): Allocate argv[0] via malloc since main thread could
exit.
@
text
@d46 1
a46 1
#define no_signals_available() (!hwait_sig || !sig_loop_wait || exit_state)
a131 1
Static DWORD sig_loop_wait = INFINITE;	// Wait for signals to arrive
a249 6
  if (p == myself_nowait || p == myself)
    {
      assert (!wait_sig_inited);
      return true;
    }

d256 3
d656 1
a656 1
  if (!sig_loop_wait)
a660 1
      sig_loop_wait = 0;	// Tell wait_sig to exit when it is
a797 1
      /* It's an error unless sig_loop_wait == 0 (the process is exiting). */
@


1.172
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d229 4
a232 1
    return false;
d239 4
a242 1
    return false;
d321 1
a321 1
      system_printf ("couldn't get proc lock.  Something is wrong.");
d555 1
a555 3
      /* Just zero sync_proc_subproc as the delete below seems to cause
	 problems for older gccs. */
	sync_proc_subproc = NULL;
d1174 1
a1174 1
#ifdef DEBUGGING
d1176 1
a1176 1
		    system_printf ("Failed to arm signal %d from pid %d");
@


1.171
log
@* sigproc.cc (proc_subproc): Simplify code to just remove all zombies if
SIGCHLD == SIG_IGN.
@
text
@d591 7
a597 1
    return 0;
d599 3
d1167 9
a1175 2
	      if (sig_handle (pack.sig, *pack.mask, pack.pid, pack.tls) <= 0)
		sigqueue.add (pack.sig, pack.pid, pack.tls);// FIXME: Shouldn't add this in !sh condition
@


1.170
log
@* pinfo.h (pinfo::operator ==): Add a way to check for _pinfo types.
* sigproc.cc (proc_subproc): Ensure that zombie is removed when SIGCHLD ==
SIG_IGN but still allow wait()ing threads to wake up.
@
text
@a307 1
  _pinfo *zombie_proc = NULL;
d380 1
a380 1
      zombie_proc = zombies[nzombies] = pchildren[val];	// Add to zombie array
a479 4
	  if (zombie_proc && zombies[thiszombie]
	      && zombies[thiszombie] == zombie_proc
	      && global_sigs[SIGCHLD].sa_handler == (void *) SIG_IGN)
	    remove_zombie (thiszombie);
d483 4
@


1.169
log
@* exceptions.cc (set_signal_mask): Report on input argument rather than
getsigmask.
* fhandler.h (fhandler_base): Make friends with close_all_files.
* pinfo.cc (_pinfo::set_ctty): Add more debugging.
* sigproc.cc (proc_can_be_signalled): Detect state when signal handler thread
is gone in target process as an EPERM situation.  Set errno to ESRCH if process
doesn't exist.
(sigproc_terminate): Set sendsig to illegal value when closed.
(sig_send): Rely on proc_can_be_signalled setting the proper errno.
* syscalls.cc (close_all_files): Detect when all ttys are closed prior to
calling close_all_files.  The ctty needs to be closed explicitly in this case.
@
text
@d307 2
a379 1
      int thiszombie;
d381 1
a381 1
      zombies[nzombies] = pchildren[val];	// Add to zombie array
d395 3
a397 3
	 which must be reaped by a wait() call. */
      if (nzombies >= NZOMBIES
	  || global_sigs[SIGCHLD].sa_handler == (void *) SIG_IGN)
d399 1
a399 1
	  sigproc_printf ("automatically removing zombie %d", thiszombie);
d481 4
@


1.168
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d251 13
a263 3
  return ISSTATE (p, PID_INITIALIZING) ||
	 (((p)->process_state & (PID_ACTIVE | PID_IN_USE)) ==
	  (PID_ACTIVE | PID_IN_USE));
d651 3
a653 1
      CloseHandle (myself->sendsig);
a693 1
      set_errno (ESRCH);
@


1.167
log
@* sigproc.cc (no_signals_available): Fix so that non-zero exit state is a true
condition rather than errnoneously only checking other states when exist_state
was zero.
@
text
@d166 1
a166 1
static __inline__ BOOL get_proc_lock (DWORD, DWORD);
d175 1
a175 1
BOOL __stdcall
d178 1
a178 1
  DWORD res;
d182 1
a182 1
      res = FALSE;
d190 1
a190 1
	    res = FALSE;
d194 1
a194 1
	    res = TRUE;
d202 1
a202 1
	    res = FALSE;
d224 1
a224 1
static BOOL
d229 1
a229 1
    return FALSE;
d233 1
a233 1
      return TRUE;
d236 1
a236 1
    return FALSE;
d239 1
a239 1
  return TRUE;
d242 1
a242 1
static BOOL __stdcall
d248 1
a248 1
      return 1;
d256 1
a256 1
BOOL __stdcall
d265 1
a265 1
BOOL __stdcall
d657 1
a657 1
  BOOL its_me;
d928 1
a928 1
  BOOL terminated;
@


1.166
log
@* pinfo.h (_pinfo::getthread2signal): Remove obsolete function.
* cygtls.h (_threadinfo): Define tid more precisely.
(_threadinfo::operator HANDLE): Define.
* exceptions.cc (_threadinfo::interupt_now): Use _threadinfo HANDLE operator to
derive thread handle.
(setup_handler): Ditto.
* sigproc.cc: Reorganize includes.
@
text
@d39 4
a42 2
#define WSSC		   60000 // Wait for signal completion
#define WPSP		   40000 // Wait for proc_subproc mutex
d46 1
a46 1
#define no_signals_available() (!hwait_sig || !sig_loop_wait && !exit_state)
@


1.165
log
@* pinfo.h (_pinfo::getsig): Remove obsolete function, here and throughout.
* exceptions.cc: Ditto.
* fhandler_termios.cc: Ditto.
* signal.cc: Ditto.
* sigproc.cc: Ditto.
* Makefile.in: Revert previous change which made a cygwin.din newer than a
version.h a warning rather than an error.
@
text
@a22 2
#include "cygtls.h"
#include "sigproc.h"
a29 1
#include "perthread.h"
d32 3
@


1.164
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d101 3
a103 3
      myself->getsig (i).sa_mask = 0;
      if (myself->getsig (i).sa_handler != SIG_IGN)
	myself->getsig (i).sa_handler = SIG_DFL;
d384 1
a384 1
	  || myself->getsig (SIGCHLD).sa_handler == (void *) SIG_IGN)
d619 1
a619 1
  myself->getsig (SIGSTOP).sa_flags = SA_RESTART | SA_NODEFER;
@


1.163
log
@* sigproc.cc (sig_send): Correct below checkin.  Use
thisframe.call_signal_handler.
@
text
@d23 1
a40 4
#define WSPX		   20000 // Wait for wait_sig to terminate
#define WWSP		   20000 // Wait for wait_subproc to terminate

#define TOTSIGS	(NSIG + __SIGOFFSET)
d48 1
a48 1
class sigelem
d51 2
d68 1
a68 1
  void add (int sig);
d70 1
a70 1
  int next ();
d80 1
a114 4
char NO_COPY myself_nowait_nonmain_dummy[1] = {'1'};// Flag to sig_send that signal goes to
					//  current process but no wait is required
					//  if this is the main thread.

d243 1
a243 1
  if (p == myself_nowait || p == myself_nowait_nonmain || p == myself)
a547 1
      int sig;
d549 3
a551 2
      while ((sig = sigqueue.next ()))
	if (sig == target_sig)
a576 1
  sigframe thisframe (mainthread);
d578 1
a578 1
  return thisframe.call_signal_handler ();
d652 1
a652 1
sig_send (_pinfo *p, int sig, DWORD ebp, bool exception)
a654 1
  DWORD tid = GetCurrentThreadId ();
a656 2
  bool wait_for_completion;
  sigframe thisframe;
d659 2
a660 2
  if (p == myself_nowait_nonmain)
    p = (tid == mainthread.id) ? (_pinfo *) myself : myself_nowait;
d669 1
a669 1
      wait_for_completion = p != myself_nowait;
d690 1
a690 5
	{
	  if (tid == mainthread.id)
	    thisframe.init (mainthread, ebp, exception);
	  pack.wakeup = sigcomplete_main;
	}
d726 1
d782 1
a782 1
    thisframe.call_signal_handler ();
d987 1
a987 1
pending_signals::add (int sig)
d999 2
d1024 1
a1024 1
int
d1027 1
a1027 1
  int sig;
d1030 1
a1030 1
    sig = 0;
d1032 2
a1033 2
    sig = curr->sig;
  return sig;
d1099 6
a1104 1
	continue;		/* Just checking to see if we exist */
d1113 1
d1118 1
a1118 1
	  continue;
d1121 1
a1121 1
	  continue;
d1126 2
a1127 2
	  while ((pack.sig = sigqueue.next ()))
	    if (myself->getsigmask () & (bit = SIGTOMASK (pack.sig)))
d1130 6
d1141 2
a1142 5
	      int sh;
	      for (int i = 0; !(sh = sig_handle (pack.sig, *pack.mask)) && i < 100 ; i++)
		low_priority_sleep (0);		// hopefully a temporary condition
	      if (sh <= 0)
		sigqueue.add (pack.sig);	// FIXME: Shouldn't add this in !sh condition
a1145 5
	case __SIGFLUSH:
	  sigqueue.reset ();
	  while ((pack.sig = sigqueue.next ()))
	    if (sig_handle (pack.sig, *pack.mask) > 0)
	      sigqueue.del ();
a1227 26
}

extern "C" {
/* Provide a stack frame when calling WaitFor* functions */

#undef WaitForSingleObject

DWORD __stdcall
WFSO (HANDLE hHandle, DWORD dwMilliseconds)
{
  DWORD ret;
  sigframe thisframe (mainthread);
  ret = WaitForSingleObject (hHandle, dwMilliseconds);
  return ret;
}

#undef WaitForMultipleObjects

DWORD __stdcall
WFMO (DWORD nCount, CONST HANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds)
{
  DWORD ret;
  sigframe thisframe (mainthread);
  ret = WaitForMultipleObjects (nCount, lpHandles, fWaitAll, dwMilliseconds);
  return ret;
}
@


1.162
log
@* sigproc.cc (proc_exists): A zombie process does not exist.
(sig_send): Improve debugging output.  Wait for pipe to be created before
trying to send to it.  Call call_signal_handler_now if sending a signal to
myself.
@
text
@d793 1
a793 1
    call_signal_handler_now ();
@


1.161
log
@* sigproc.cc (proc_subproc): Restrict permissions on ppid_handle.
* devices.shilka (device::parse): Restore check for tty in unit handling, but
without the previous typo.
* devices.cc: Regenerate.
* devices.h (DEV_CYGDRIVE_MAJOR): Change major number to one used by linux for
"user-mode virtual block device".
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d5 1
a5 1
   Written by Christopher Faylor <cgf@@cygnus.com>
d47 1
a47 1
#define no_signals_available() (!hwait_sig || !sig_loop_wait)
d270 1
a270 1
  return p && !(p->process_state & PID_EXITED);
d431 2
a432 3
     * the main thread's dispatch to a signal handler function.
     * (called from wait_sig thread)
     */
d709 1
d713 2
d718 1
d722 1
d745 1
d791 3
@


1.160
log
@* shared_info.h (CURR_MOUNT_MAGIC): Fix.
* sigproc.cc (sigpacket): New structure.
(sig_send): Fill out sigpacket structure to send to signal thread rather than
racily sending separate packets.
(wait_sig): Use sigpacket structure to receive info from signal sender.
@
text
@d329 1
a329 1
			    0, TRUE, DUPLICATE_SAME_ACCESS))
@


1.159
log
@2003-09-24  Pierre Humblet <pierre.humblet@@ieee.org>

	* shared_info.h (class user_info): New.
	(cygwin_user_h): New.
	(user_shared): New.
	(enum shared_locations): Replace SH_MOUNT_TABLE by SH_USER_SHARED;
	(mount_table): Change from variable to macro.
	* shared.cc: Use sizeof(user_info) in "offsets".
	(user_shared_initialize): Add "reinit" argument to indicate need
	to reinitialize the mapping. Replace "mount_table" by "user_shared"
	throughout. Call user_shared->mountinfo.init and
	user_shared->delqueue.init.
	(shared_info::initialize): Do not call delqueue.init.
	(memory_init): Add argument to user_shared_initialize.
	* child_info.h (child_info::mount_h): Delete.
	(child_info::user_h): New.
	* sigpproc.cc (init_child_info): Use user_h instead of mount_h.
	* dcrt0.cc (_dll_crt0): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Use
	user_shared->delqueue instead of cygwin_shared->delqueue.
	* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
	* syscalls.cc (close_all_files): Ditto.
	(unlink): Ditto.
	(seteuid32): Add argument to user_shared_initialize.
@
text
@d75 8
a662 1
  HANDLE thiscomplete;
d666 1
d702 1
a702 1
	  thiscomplete = sigcomplete_main;
d719 1
a719 1
      thiscomplete = NULL;
d722 12
d735 1
a735 1
  if (!WriteFile (sendsig, &sig, sizeof (sig), &nb, NULL) || nb != sizeof (sig))
d737 2
a738 3
      /* Couldn't signal the semaphore.  This probably means that the
       * process is exiting.
       */
d755 8
a762 3
  /* Write completion handle or NULL */
  if (!WriteFile (sendsig, &thiscomplete, sizeof (thiscomplete), &nb, NULL)
      || nb != sizeof (thiscomplete))
d764 2
a765 2
      __seterrno ();
      goto out;
a766 7

  sigset_t pending;
  sigset_t *mask;
  if (sig == __SIGPENDING)
    mask = &pending;
  else if (sig == __SIGFLUSH || sig > 0)
    mask = &myself->getsigmask ();
a767 16
    mask = NULL;
  if (mask && !WriteFile (sendsig, &mask, sizeof (mask), &nb, NULL)
      || nb != sizeof (pending))
    {
      __seterrno ();
      goto out;
    }

  /* No need to wait for signal completion unless this was a signal to
   * this process.
   *
   * If it was a signal to this process, wait for a dispatched signal.
   * Otherwise just wait for the wait_sig to signal that it has finished
   * processing the signal.
   */
  if (!wait_for_completion)
a773 5
  else
    {
      sigproc_printf ("Waiting for thiscomplete %p", thiscomplete);
      rc = WaitForSingleObject (thiscomplete, WSSC);
    }
a1086 1
      int sig;
d1088 2
a1089 1
      if (!ReadFile (readsig, &sig, sizeof (sig), &nb, NULL))
d1092 1
a1092 3
      HANDLE wakeup;
      if (!ReadFile (readsig, &wakeup, sizeof (wakeup), &nb, NULL)
	  || nb != sizeof (wakeup))
d1094 2
a1095 1
	  system_printf ("signal notification handle read failure, %E");
d1099 1
a1099 1
      if (!sig)
d1102 2
a1103 4
      sigset_t *mask;
      if ((sig == __SIGFLUSH || sig == __SIGPENDING || sig > 0)
	  && (!ReadFile (readsig, &mask, sizeof (mask), &nb, NULL)
	      || nb != sizeof (mask)))
d1105 2
a1106 2
	  system_printf ("signal mask handle read failure, %E");
	  continue;
d1109 1
a1109 1
      switch (sig)
d1118 1
a1118 1
	  *mask = 0;
d1121 3
a1123 3
	  while ((sig = sigqueue.next ()))
	    if (myself->getsigmask () & (bit = SIGTOMASK (sig)))
	      *mask |= bit;
d1126 2
a1127 2
	  if (sig < 0)
	    sig_clear (-sig);
d1131 1
a1131 1
	      for (int i = 0; !(sh = sig_handle (sig, *mask)) && i < 100 ; i++)
d1134 2
a1135 2
		sigqueue.add (sig);		// FIXME: Shouldn't add this in !sh condition
	      if (sig == SIGCHLD)
d1140 2
a1141 2
	  while ((sig = sigqueue.next ()))
	    if (sig_handle (sig, *mask) > 0)
d1145 2
a1146 2
      if (wakeup)
	SetEvent (wakeup);
@


1.158
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d836 1
a836 1
  ch->mount_h = cygwin_mount_h;
@


1.157
log
@* dcrt0.cc (do_exit): Eliminate "C" linkage.  Call events_terminate early.
(exit_states): Move out of source file into header file.
* winsup.h: Move exit_states here.  Remove "C" linkage from do_exit
declaration.
* debug.cc (lock_debug): Remove explicit (and incorrect) external for
exit_state.
* sigproc.cc (sig_dispatch_pending): Don't flush signals if exiting.
@
text
@d26 1
a27 1
#include "path.h"
a30 1
#define NEED_VFORK
d51 26
a76 1
static LONG local_sigtodo[TOTSIGS];
a78 6
inline LONG *
getlocal_sigtodo (int sig)
{
  return local_sigtodo + __SIGOFFSET + sig;
}

d109 1
a109 1
					//  if this is not the main thread.
a127 8
Static HANDLE sigcatch_nonmain;		// The semaphore signaled when
					//  signals are available for
					//  processing from non-main thread
Static HANDLE sigcatch_main;		// Signalled when main thread sends a
					//  signal
Static HANDLE sigcatch_nosync;		// Signal wait_sig to scan sigtodo
					//  but not to bother with any
					//  synchronization
a130 3
Static HANDLE sigcomplete_nonmain;	// Semaphore raised for non-main
					//  threads when a signal has finished
					//  processing
a156 2
bool NO_COPY pending_signals = false;	// true if signals pending

a160 1
static HANDLE __stdcall getevent (_pinfo *, const char *) __attribute__ ((regparm (2)));
d537 1
a537 2
/* Clear pending signal from the sigtodo array
 */
d539 1
a539 1
sig_clear (int sig)
d541 13
a553 2
  (void) InterlockedExchange (myself->getsigtodo (sig), 0L);
  (void) InterlockedExchange (getlocal_sigtodo (sig), 0L);
d558 1
a558 1
sigpending (sigset_t *set)
d560 4
a563 6
  unsigned bit;
  *set = 0;
  for (int sig = 1; sig < NSIG; sig++)
    if ((*getlocal_sigtodo (sig) || *myself->getsigtodo (sig))
        && (myself->getsigmask () & (bit = SIGTOMASK (sig))))
      *set |= bit;
d567 2
a568 3
/* Force the wait_sig thread to wake up and scan the sigtodo array.
 */
extern "C" int __stdcall
d571 1
a571 1
  if (exit_state || !hwait_sig || GetCurrentThreadId () == sigtid)
d575 1
a575 19

#ifdef DEBUGGING
  sigproc_printf ("pending_signals %d", pending_signals);
#endif

  if (!pending_signals)
#ifdef DEBUGGING
    sigproc_printf ("no need to wake anything up");
#else
    ;
#endif
  else
    {
      (void) sig_send (myself, __SIGFLUSH);
#ifdef DEBUGGING
      sigproc_printf ("woke up wait_sig");
#endif
    }

d637 1
a637 6
      for (int i = 0; i < 20; i++)
	(void) ReleaseSemaphore (sigcomplete_nonmain, 1, NULL);
      // ForceCloseHandle (sigcomplete_nonmain);
      // ForceCloseHandle (sigcatch_main);
      // ForceCloseHandle (sigcatch_nonmain);
      // ForceCloseHandle (sigcatch_nosync);
d655 3
a657 3
  HANDLE thiscatch = NULL;
  HANDLE thiscomplete = NULL;
  BOOL wait_for_completion;
d663 1
a663 1
    wait_for_completion = FALSE;
a686 2
  LONG *todo;
  bool issem;
d689 2
a690 1
      if (!wait_for_completion)
d692 2
a693 14
	  thiscatch = sigcatch_nosync;
	  todo = myself->getsigtodo (sig);
	  issem = false;
	}
      else if (tid != mainthread.id)
	{
	  thiscatch = sigcatch_nonmain;
	  thiscomplete = sigcomplete_nonmain;
	  todo = getlocal_sigtodo (sig);
	  issem = true;
	}
      else
	{
	  thiscatch = sigcatch_main;
a694 3
	  thisframe.init (mainthread, ebp, exception);
	  todo = getlocal_sigtodo (sig);
	  issem = true;
d697 1
a697 1
  else if ((thiscatch = getevent (p, "sigcatch")))
d699 8
a706 2
      todo = p->getsigtodo (sig);
      if (IsBadWritePtr (todo, sizeof (*todo)))
d708 1
a708 1
	  set_errno (EACCES);
d711 1
a711 1
      issem = false;
a712 3
  else
    goto out;		  // Couldn't get the semaphore.  getevent issued
			  //  an error, if appropriate.
d714 2
a715 14
#if WHEN_MULTI_THREAD_SIGNALS_WORK
  signal_dispatch *sd;
  sd = signal_dispatch_storage.get ();
  if (sd == NULL)
    sd = signal_dispatch_storage.create ();
#endif

  /* Increment the sigtodo array to signify which signal to assert.
   */
  (void) InterlockedIncrement (todo);

  /* Notify the process that a signal has arrived.
   */
  if (issem ? !ReleaseSemaphore (thiscatch, 1, NULL) : !SetEvent (thiscatch))
d721 4
a724 1
	ForceCloseHandle (thiscatch);
a728 2
	  else if ((int) GetLastError () == -1)
	    rc = WaitForSingleObject (thiscomplete, 500);
d730 2
a731 2
	    system_printf ("error sending signal %d to pid %d, semaphore %p, %E",
			  sig, p->pid, thiscatch);
d736 23
d771 1
a771 1
	ForceCloseHandle (thiscatch);
d792 7
a798 1
  sigproc_printf ("returning %d from sending signal %d", rc, sig);
a801 9
/* Set pending signal from the sigtodo array
 */
void __stdcall
sig_set_pending (int sig)
{
  (void) InterlockedIncrement (getlocal_sigtodo (sig));
  return;
}

a882 65
/* Get or create a process specific semaphore used in message passing.
 */
static HANDLE __stdcall
getevent (_pinfo *p, const char *str)
{
  HANDLE h;
  char sem_name[MAX_PATH];

  if (p != NULL)
    {
      if (!proc_can_be_signalled (p))
	{
	  set_errno (ESRCH);
	  return NULL;
	}
      int wait = 1000;
      /* Wait for new process to generate its semaphores. */
      sigproc_printf ("pid %d, ppid %d, wait %d, initializing %x", p->pid, p->ppid, wait,
		  ISSTATE (p, PID_INITIALIZING));
      for (int i = 0; ISSTATE (p, PID_INITIALIZING) && i < wait; i++)
	low_priority_sleep (1);
    }

  if (p == NULL)
    {
      char sa_buf[1024];

      DWORD winpid = GetCurrentProcessId ();
#if 0
      h = CreateSemaphore (sec_user_nih (sa_buf), init, max,
			   str = shared_name (sem_name, str, winpid));
#else
      h = CreateEvent (sec_user_nih (sa_buf), FALSE, FALSE,
		       str = shared_name (sem_name, str, winpid));
#endif
      p = myself;
      if (!h)
	{
	  system_printf ("can't create semaphore %s, %E", str);
	  __seterrno ();
	}
    }
  else
    {
#if 0
      h = OpenSemaphore (SEMAPHORE_ALL_ACCESS, FALSE,
			 shared_name (sem_name, str, p->dwProcessId));
#else
      h = OpenEvent (EVENT_ALL_ACCESS, FALSE,
		     shared_name (sem_name, str, p->dwProcessId));
#endif

      if (!h)
	{
	  if (GetLastError () == ERROR_FILE_NOT_FOUND && !proc_exists (p))
	    set_errno (ESRCH);	/* No such process */
	  else
	    set_errno (EPERM);	/* Couldn't access the semaphore --
				   different cygwin DLL maybe? */
	}
    }

  return h;
}

a984 3
#define RC_MAIN 0
#define RC_NONMAIN 1
#define RC_NOSYNC 2
d986 57
a1042 7
 * Then scan an in-memory array representing queued signals.
 * Executes in a separate thread.
 *
 * Signals sent from this process are sent a completion signal so
 * that returns from kill/raise do not occur until the signal has
 * has been handled, as per POSIX.
 */
d1046 3
a1048 1
  LONG *todos[] = {getlocal_sigtodo (0), myself->getsigtodo (0)};
d1052 4
a1055 15
  /* sigcatch_nosync       - semaphore incremented by sig_dispatch_pending and
   *			     by foreign processes to force an examination of
   *			     the sigtodo array.
   * sigcatch_main	   - ditto for local main thread.
   * sigcatch_nonmain      - ditto for local non-main threads.
   *
   * sigcomplete_main	   - event used to signal main thread on signal
   *			     completion
   * sigcomplete_nonmain   - semaphore signaled for non-main thread on signal
   *			     completion
   */
  sigcatch_nosync = getevent (NULL, "sigcatch");
  sigcatch_nonmain = CreateSemaphore (&sec_none_nih, 0, MAXLONG, NULL);
  sigcatch_main = CreateSemaphore (&sec_none_nih, 0, MAXLONG, NULL);
  sigcomplete_nonmain = CreateSemaphore (&sec_none_nih, 0, MAXLONG, NULL);
d1057 1
a1057 1
  sigproc_printf ("sigcatch_nonmain %p, sigcatch_main %p", sigcatch_nonmain, sigcatch_main);
d1061 3
a1063 4
   * signals.  Prior to this, dwProcessId was set to the windows pid of
   * of the original windows process which spawned us unless this was a
   * "toplevel" process.
   */
a1067 4
  ProtectHandle (sigcatch_nosync);
  ProtectHandle (sigcatch_nonmain);
  ProtectHandle (sigcatch_main);
  ProtectHandle (sigcomplete_nonmain);
d1071 2
a1072 3
   * windows process waiting to see if it's started a cygwin process or not.
   * Signalling subproc_ready indicates that we are a cygwin process.
   */
a1088 4
  HANDLE catchem[] = {sigcatch_main, sigcatch_nonmain, sigcatch_nosync};
  sigproc_printf ("Ready.  dwProcessid %d", myself->dwProcessId);
  DWORD rc = RC_NOSYNC;
  bool flush = false;
d1091 4
a1094 11
      DWORD i;
      if (rc == RC_MAIN || rc == RC_NONMAIN)
	i = RC_NOSYNC;
      else
	i = RC_MAIN;
      rc = WaitForSingleObject (catchem[i], 0);
      if (rc != WAIT_OBJECT_0)
	rc = WaitForMultipleObjects (3, catchem, FALSE, sig_loop_wait);
      else
	rc = i + WAIT_OBJECT_0;
      (void) SetThreadPriority (GetCurrentThread (), WAIT_SIG_PRIORITY);
d1096 39
a1134 6
      /* sigproc_terminate sets sig_loop_wait to zero to indicate that
         this thread should terminate.  */
      if (rc == WAIT_TIMEOUT)
	{
	  if (!sig_loop_wait)
	    break;			// Exiting
a1135 27
	    continue;
	}

      if (rc == WAIT_FAILED)
	{
	  if (sig_loop_wait != 0)
	    system_printf ("WFMO failed, %E");
	  break;
	}

      rc -= WAIT_OBJECT_0;
      sigproc_printf ("awake, rc %d", rc);
      LONG *todo;
      if (rc != RC_NOSYNC)
	todo = todos[0];
      else
	todo = todos[1];

      /* A sigcatch semaphore has been signaled.  Scan the sigtodo
         array looking for any unprocessed signals.  */
      pending_signals = false;
      unsigned more_signals = 0;
      bool saw_failed_interrupt = false;
      do
	{
	  more_signals = 0;
	  for (int sig = -__SIGOFFSET; sig < NSIG; sig++)
d1137 7
a1143 63
	      LONG x = InterlockedDecrement (todo + sig);
	      if (x < 0)
		InterlockedIncrement (todo + sig);
	      else if (x >= 0)
		{
		  /* If x > 0, we have to deal with a signal at some later point */
		  if (rc != RC_NOSYNC && x > 0)
		    /*pending_signals = true*/;	// There should be an armed semaphore, in this case

		  if (sig > 0 && sig != SIGKILL && sig != SIGSTOP &&
		      (sigismember (&myself->getsigmask (), sig) ||
		       main_vfork->pid ||
		       (sig != SIGCONT && ISSTATE (myself, PID_STOPPED))))
		    {
		      sigproc_printf ("signal %d blocked", sig);
		      x = InterlockedIncrement (myself->getsigtodo (sig));
		      /* pending_signals = true;*/  // will be set by set_process_mask
		    }
		  else
		    {
		      sigproc_printf ("processing signal %d", sig);
		      switch (sig)
			{
			case __SIGFLUSH:
			  if (rc == RC_MAIN)
			    {
			      flush = true;
			      SetEvent (sigcatch_nosync);
			      goto out1;
			    }
			  break;

			/* Internal signal to turn on stracing. */
			case __SIGSTRACE:
			  strace.hello ();
			  break;

			case __SIGCOMMUNE:
			  talktome ();
			  break;

			/* A normal UNIX signal */
			default:
			  sigproc_printf ("Got signal %d", sig);
			  if (!sig_handle (sig))
			    {
			      pending_signals = true;
			      saw_failed_interrupt = true;
			      x = InterlockedIncrement (myself->getsigtodo (sig));
			    }
			}
		      if (rc == RC_NOSYNC && x > 0)
			more_signals++;
		    }

		  if (sig == SIGCHLD)
		    proc_subproc (PROC_CLEARWAIT, 0);

		  /* Need to take special action if an interrupt failed due to main thread not
		     getting around to calling handler yet.  */
		  if (saw_failed_interrupt || rc != RC_NOSYNC)
		    goto out;
		}
d1145 6
a1150 24
#ifdef DEBUGGING
	  if (more_signals > 100)
	    system_printf ("hmm.  infinite loop? more_signals %u\n", more_signals);
#endif
	}
      while (more_signals && sig_loop_wait);

    out:
      /* Signal completion of signal handling depending on which semaphore
	 woke up the WaitForMultipleObjects above.  */
      if (rc == RC_NONMAIN)	// FIXME: This is broken
	ReleaseSemaphore (sigcomplete_nonmain, 1, NULL);
      else if (rc == RC_MAIN || flush)
	{
	  SetEvent (sigcomplete_main);
	  sigproc_printf ("set main thread completion event");
	  flush = false;
	}

    out1:
      if (saw_failed_interrupt)
	{
	  SetEvent (sigcatch_nosync);
	  low_priority_sleep (0);	/* Hopefully, other thread will be waking up soon. */
d1152 2
a1153 1
      sigproc_printf ("looping");
@


1.156
log
@* fhandler_process.cc (fhandler_process::fill_filebuf): Open pinfo with
PID_MAP_RW.
* sigproc.cc (talktome): Ditto for winpids.
@
text
@d560 1
a560 1
  if (!hwait_sig || GetCurrentThreadId () == sigtid)
@


1.155
log
@* pinfo.h (winpids::pid_access): New element.
(winpids::winpids): Rejigger to set pinfo_access.
* pinfo.cc (winpids::add): Try to open shared memory region with supplied
pinfo_access first, then default to readonly.
* fhandler_termios.cc (tty_min::kill_pgrp): When getting list of pids to work
with, suggest opening with PID_MAP_RW.
* signal.cc (kill_pgrp): Ditto.
* sigproc.cc (sig_send): Perform a write check on todo prior to attempting to
increment it.  Return EACCES if we can't write to it.
@
text
@d1059 1
a1059 1
  winpids pids;
d1062 2
a1063 1
      pids[i]->commune_recv ();
@


1.154
log
@* dcrt0.cc (dlL_crt0_1): Set __argc_safe after __argc is absolutely know to be
set.
* exceptions.cc (sig_handle_tty_stop): Don't reset sigCONT event since it is
reset automatically.
* fork.cc (fork): Remove obsolete usage of PID_SPLIT_HEAP.
* include/sys/cygwin.h: Ditto.
* sigproc.cc (sig_send): Use sigframe init method to set frame since it checks
for previous ownership of the frame.
* sigproc.h (sigframe::init): Accept an "is_exception" argument.
@
text
@d728 5
@


1.154.4.1
log
@* dcrt0.cc (do_exit): Eliminate "C" linkage.  Call events_terminate early.
(exit_states): Move out of source file into header file.
* winsup.h: Move exit_states here.  Remove "C" linkage from do_exit
declaration.
* debug.cc (lock_debug): Remove explicit (and incorrect) external for
exit_state.
* sigproc.cc (sig_dispatch_pending): Don't flush signals if exiting.
@
text
@d560 1
a560 1
  if (exit_state || !hwait_sig || GetCurrentThreadId () == sigtid)
@


1.153
log
@* sigproc.cc (wait_sig_inited): Remove assertion since it is racy.
@
text
@d720 1
a720 1
	  thisframe.set (mainthread, ebp, exception);
@


1.152
log
@* exceptions.cc (set_process_mask): Set pending signals only when signals
become unmasked.
* sigproc.cc (pending_signals): Flip back to a global.
(wait_sig): Don't set pending signals when there is an armed semaphore or
signal is blocked.
* shared.cc (shared_info::initialize): Add a username parameter for user-mode
mounts.  Reorganize to try to avoid startup race.
(memory_init): Move some stuff into shared_info::initialize.
* shared_info.h (shared_info::initialize): Change declaration.
(CURR_SHARED_MAGIC): Update.
@
text
@a203 1
  assert (hsig_inited);
@


1.151
log
@* cygheap.cc (cygheap_init): Allocate space for sigaction array in cygheap.
* cygheap.h (cygheap_types): Add HEAP_SIGS.
* exceptions.cc (signal_fixup_after_exec): Remove from this file.
* pinfo.h (pinfo::getsig): Just return global_sigs array.
(pinfo::sigs): Delete.
* sigproc.cc (signal_fixup_after_exec): Move it here.
(global_sigs): New global array, moved from pinfo structure.
(sigalloc): New function.  Allocate global sigaction array here.
(proc_subproc): Remove copysigs call.  It's automatic now.
* include/sys/cygwin.h (PID_NOCLDSTOP): New value.
* signal.cc (sigaction): Set myself->PID_NODCLDSTOP when appropriate.
* sigproc.h (sigalloc): Declare.
* fnmatch.c (fnmatch): Use C90 parameters.
(rangematch): Ditto.
* fhandler.cc (fhandler_base::raw_read): Use right coercion to avoid a compiler
warning.
@
text
@d150 1
a150 1
static bool NO_COPY pending_signals = false;	// true if signals pending
d1193 1
a1193 1
		    pending_signals = true;	// There should be an armed semaphore, in this case
d1202 1
a1202 1
		      pending_signals = true;
d1232 1
a1234 1
			      pending_signals = true;
@


1.150
log
@* Makefile.in (MALLOC_OFILES): Always fill in with correct malloc object.
* configure.in: Fill in MALLOC_OFILES with either debugging or regular malloc.
* configure: Regenerate.
* dlmalloc.c: Make various fruitless changes to attempt to get to work.
* dlmalloc.h: Ditto.
* malloc.cc (free): Check malloc pool when debugging.
* path.cc (win32_device_name): Eliminate compiler warning.
* sigproc.cc (sig_dispatch_pending): Remove use of was_pending.  Let
thisframe.call_signal_handler decide if handler should be called rather than
using bogus was_pending check.
* exceptions.cc (interrupt_setup): Remove accidentally checked in debugging
code.
* heap.cc (sbrk): Save rounded addess in user_heap_max.
@
text
@d20 1
d52 5
a56 2
LONG local_sigtodo[TOTSIGS];
inline LONG* getlocal_sigtodo (int sig)
d61 20
a326 1
      vchild->copysigs (myself);
@


1.149
log
@* sigproc.cc (sig_dispatch_pending): Remove explicit call to
thisframe.call_signal_handler.
@
text
@a542 1
  int was_pending = pending_signals;
d544 1
a544 1
  sigproc_printf ("pending_signals %d", was_pending);
d547 1
a547 1
  if (!was_pending)
d561 1
a561 1
  return was_pending;
@


1.148
log
@* sigproc.h: Make some functions regparm.
* sigproc.cc (checkstate): Make regparm.
(getevent): Change parameters in declaration, rename from getsem, make regparm.
(sig_send): Recognize that nosync is now an event.  Remove some old cruft from
previous interrupt anywhere signal handler.
(getevent): Change parameters in definition, rename from getsem.  Allocate
event rather than semaphore.
(wait_sig): Treat sigcatch_nosync as an event.
@
text
@a561 3
  if (was_pending)
    thisframe.call_signal_handler ();

@


1.147
log
@* exceptions.cc (sigreturn): Fix problem where old return address was not
properly restored for a nested signal.
@
text
@d130 1
a130 1
static int __stdcall checkstate (waitq *);
d132 1
a132 1
static HANDLE __stdcall getsem (_pinfo *, const char *, int, int);
d682 1
d689 1
d696 1
d704 1
d707 5
a711 2
  else if ((thiscatch = getsem (p, "sigcatch", 0, 0)))
    todo = p->getsigtodo (sig);
d713 1
a713 1
    goto out;		  // Couldn't get the semaphore.  getsem issued
d729 1
a729 9
  SetLastError (0);

#if 0
  int prio;
  prio = GetThreadPriority (GetCurrentThread ());
  (void) SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL);
#endif

  if (!ReleaseSemaphore (thiscatch, 1, NULL) && (int) GetLastError () > 0)
a765 2

      SetLastError (0);
a766 9
#if 0 // STILL NEEDED?
      /* Check for strangeness due to this thread being redirected by the
	 signal handler.  Sometimes a WAIT_TIMEOUT will occur when the
	 thread hasn't really timed out.  So, check again.
	 FIXME: This isn't foolproof. */
      if (rc != WAIT_OBJECT_0 &&
	  WaitForSingleObject (thiscomplete, 0) == WAIT_OBJECT_0)
	rc = WAIT_OBJECT_0;
#endif
a768 4
#if 0
  SetThreadPriority (GetCurrentThread (), prio);
#endif

d879 1
a879 1
getsem (_pinfo *p, const char *str, int init, int max)
a898 1
  SetLastError (0);
d904 1
d907 4
d920 1
d923 4
d1071 1
a1071 1
  sigcatch_nosync = getsem (NULL, "sigcatch", 0, MAXLONG);
d1194 1
a1194 1
			      ReleaseSemaphore (sigcatch_nosync, 1, NULL);
d1253 1
a1253 1
	  ReleaseSemaphore (sigcatch_nosync, 1, NULL);
@


1.146
log
@* syscalls.cc (mount): Don't check win32_path when doing cygdrive mount.
@
text
@d1160 1
a1160 1
	todo = *todos;
@


1.145
log
@* sigproc.cc (wait_sig): Count number of iterations through 'more_signals' loop
and issue a warning if DEBUGGING and excessive.
(WFSO): When debugging and infinite timeout, loop.
@
text
@a1220 1
			      sigproc_printf ("couldn't send signal %d", sig);
@


1.144
log
@* sigproc.cc (wait_sig): Remove redundant test in do/while.
@
text
@d703 1
a703 1
  else if (thiscatch = getsem (p, "sigcatch", 0, 0))
d1140 1
a1140 2
       * this thread should terminate.
       */
d1165 1
a1165 2
       * array looking for any unprocessed signals.
       */
d1167 1
a1167 1
      bool more_signals = false;
d1170 75
a1244 64
	for (int sig = -__SIGOFFSET, more_signals = false; sig < NSIG; sig++)
	  {
	    LONG x = InterlockedDecrement (todo + sig);
	    if (x < 0)
	      InterlockedIncrement (todo + sig);
	    else if (x >= 0)
	      {
		if (sig > 0 && sig != SIGKILL && sig != SIGSTOP &&
		    (sigismember (&myself->getsigmask (), sig) ||
		     main_vfork->pid ||
		     (sig != SIGCONT && ISSTATE (myself, PID_STOPPED))))
		  {
		    sigproc_printf ("signal %d blocked", sig);
		    pending_signals = true;	// FIXME: This will cause unnecessary sig_dispatch_pending spins
		    InterlockedIncrement (myself->getsigtodo (sig));
		  }
		else
		  {
		    /* Found a signal to process */
		    if (rc != RC_NOSYNC)
		      pending_signals = true;	// There should be an armed semaphore, in this case

		    sigproc_printf ("processing signal %d", sig);
		    switch (sig)
		      {
		      case __SIGFLUSH:
			if (rc == RC_MAIN)
			  {
			    flush = true;
			    ReleaseSemaphore (sigcatch_nosync, 1, NULL);
			    goto out1;
			  }
			break;

		      /* Internal signal to turn on stracing. */
		      case __SIGSTRACE:
			strace.hello ();
			break;

		      case __SIGCOMMUNE:
			talktome ();
			break;

		      /* A normal UNIX signal */
		      default:
			sigproc_printf ("Got signal %d", sig);
			if (!sig_handle (sig))
			  {
			    pending_signals = saw_failed_interrupt = true;
			    sigproc_printf ("couldn't send signal %d", sig);
			    InterlockedIncrement (myself->getsigtodo (sig));
			  }
		      }
		    if (rc == RC_NOSYNC)
		      more_signals = x > 0;
		  }

		if (sig == SIGCHLD)
		  proc_subproc (PROC_CLEARWAIT, 0);
		if (saw_failed_interrupt || rc != RC_NOSYNC)
		  goto out;
	      }
	  }
      while (more_signals);
d1257 1
@


1.143
log
@* sigproc.cc (wait_sig): Avoid infinite loop.
@
text
@d1235 1
a1235 1
      while (more_signals && !saw_failed_interrupt);
@


1.142
log
@* miscfuncs.cc (low_priority_sleep): Sleep at same priority as main thread.
* sigproc.cc (wait_sig): Keep looping if there are more signals to consider and
we are flushing signals.
(sig_send): Put nonsync signals in the correct bucket.
@
text
@d1169 1
a1170 1
      bool more_signals = false;
d1172 1
a1172 1
	for (int sig = -__SIGOFFSET; sig < NSIG; sig++)
d1235 1
a1235 1
      while (more_signals);
@


1.141
log
@* sigproc.cc (wait_sig): Ensure that myself->getsigtodo array is flushed on a
__SIGFLUSH.  Christopher Faylor <cgf@@redhat.com>
* exceptions.cc (_sigreturn): Handle nested signals without growing the stack.
@
text
@d685 4
a688 1
	thiscatch = sigcatch_nosync;
d693 1
d700 1
a701 1
      todo = getlocal_sigtodo (sig);
d1159 5
a1163 14
      LONG **start_todo, **end_todo;
      switch (rc)
	{
	case RC_MAIN:
	case RC_NONMAIN:
	  start_todo = todos;
	  end_todo = todos;
	  break;
	case RC_NOSYNC:
	default:	// silence compiler warning
	  start_todo = todos + 1;
	  end_todo = todos + 1;
	  break;
	}
d1168 1
a1168 1
      pending_signals = 0;
d1170 2
a1171 1
      for (LONG **todo = todos; todo <= end_todo; todo++)
d1174 1
a1174 1
	    LONG x = InterlockedDecrement (*todo + sig);
d1176 1
a1176 1
	      InterlockedIncrement (*todo + sig);
a1178 3
		if (x > 0)
		  pending_signals = true;	/* semaphore should already be armed */

d1191 3
d1220 1
a1221 3
			    ReleaseSemaphore (sigcatch_nosync, 1, NULL);
			    saw_failed_interrupt = true;
			    pending_signals = true;
d1225 2
d1231 2
a1232 1
		goto out;
d1235 1
d1250 4
a1253 1
	low_priority_sleep (SLEEP_0_STAY_LOW);	/* Hopefully, other thread will be waking up soon. */
@


1.140
log
@* exceptions.cc (pending_signals): Remove unneeded declaration.
* sigproc.cc (pending_signals): Make static.
(wait_sig): Use defined values rather than integers for rc.  Never scan both
todo arrays as this could cause hangs if signals arrive from two different
sources.  Rename saw_pending_signals to saw_failed_interrupt.  Exit loop when
signal found.  Enter low-priority sleep, if necessary, after finished
signalling completion.  Set pending_signals when blocked
(from Pierre Humblet).
@
text
@d1119 2
d1123 10
a1132 1
      DWORD rc = WaitForMultipleObjects (3, catchem, FALSE, sig_loop_wait);
d1173 1
a1173 1
      pending_signals = false;
a1191 1
		    InterlockedIncrement (*todo + sig);
d1193 1
d1202 6
a1207 1
			/* just forcing the loop */
a1224 1
			    pending_signals = saw_failed_interrupt = true;
d1226 2
d1242 3
a1244 1
      switch (rc)
a1245 1
	case RC_MAIN:
d1248 1
a1248 7
	  break;
	case RC_NONMAIN:
	  ReleaseSemaphore (sigcomplete_nonmain, 1, NULL);
	  break;
	default:
	  /* Signal from another process.  No need to synchronize. */
	  break;
d1250 1
@


1.139
log
@* signal.cc (sigpending): Move.
* sigproc.cc (sigpending): To here.
(getlocal_sigtodo): Return process-local signal array.
(sigpending): Accommodate new process-local signal array.
(sig_send): Ditto.
(sig_set_pending): Ditto.
(wait_sig): Ditto.
@
text
@d126 1
a126 1
int NO_COPY pending_signals = 0;	// TRUE if signals pending
d1045 3
d1147 2
a1148 1
	case 0:
d1152 2
a1153 1
	case 1:
d1156 1
a1156 3
	default:
	  start_todo = todos;
	  end_todo = todos + 1;
d1162 3
a1164 4
      pending_signals = -1;
      bool saw_pending_signals = false;
      bool saw_sigchld = false;
      for (LONG **todo = start_todo; todo <= end_todo; todo++)
d1173 1
a1173 4
		  pending_signals = 1;

		if (sig == SIGCHLD)
		  saw_sigchld = true;
d1182 1
d1209 1
a1209 2
			    low_priority_sleep (SLEEP_0_STAY_LOW);	/* Hopefully, other process will be waking up soon. */
			    saw_pending_signals = true;
d1211 1
a1211 1
			    InterlockedIncrement (*todo + sig);
a1212 1
			break;
d1215 4
d1222 1
a1222 8
      if (saw_pending_signals)
	pending_signals = 1;
      else if (pending_signals < 0)
	pending_signals = 0;

      if (saw_sigchld)
	proc_subproc (PROC_CLEARWAIT, 0);

d1224 1
a1224 2
       * woke up the WaitForMultipleObjects above.
       */
d1227 1
a1227 1
	case 0:
d1231 1
a1231 1
	case 1:
d1238 2
@


1.138
log
@Throughout, eliminate argument to sig_dispatch_pending.
* exceptions.cc (setup_handler): Move non-interruptible condition handling
(back) to wait_sig (as suggested by Pierre Humblet).
(set_process_mask): Don't worry about calling sig_dispatch_pending from
sigthread since it is detected in the function anyway.
(sig_handle): Eliminate thisproc arg.  Don't call sig_dispatch_pending on
SIGCONT since that should happen automatically.
* sigproc.cc (sig_dispatch_pending): Eliminate justwake argument.  Just return
when called from sigthread.
(wait_sig): Change some variables to bool.  Change inner while to an if.  Move
uninterruptible signal handling here.
(sigproc_terminate): Don't call sig_dispatch_pending.  Just increment semaphore
on exit.
* speclib: Use slightly different (but still flawed) method for determining
symbols to extract from libraries.
@
text
@d51 6
d517 1
d521 12
d681 1
d697 1
d699 3
a701 1
  else if (!(thiscatch = getsem (p, "sigcatch", 0, 0)))
d714 1
a714 1
  (void) InterlockedIncrement (p->getsigtodo (sig));
d766 1
d774 1
d803 1
a803 1
  (void) InterlockedIncrement (myself->getsigtodo (sig));
d1056 1
d1140 16
a1155 1
      sigproc_printf ("awake");
d1162 57
a1218 56
      for (int sig = -__SIGOFFSET; sig < NSIG; sig++)
	{
	  LONG x = InterlockedDecrement (myself->getsigtodo (sig));
	  if (x < 0)
	    InterlockedIncrement (myself->getsigtodo (sig));
	  else if (x >= 0)
	    {
	      if (x > 0)
		pending_signals = 1;

	      if (sig == SIGCHLD)
		saw_sigchld = true;

	      if (sig > 0 && sig != SIGKILL && sig != SIGSTOP &&
		  (sigismember (&myself->getsigmask (), sig) ||
		   main_vfork->pid ||
		   (sig != SIGCONT && ISSTATE (myself, PID_STOPPED))))
		{
		  sigproc_printf ("signal %d blocked", sig);
		  InterlockedIncrement (myself->getsigtodo (sig));
		}
	      else
		{
		  /* Found a signal to process */
		  sigproc_printf ("processing signal %d", sig);
		  switch (sig)
		    {
		    case __SIGFLUSH:
		      /* just forcing the loop */
		      break;

		    /* Internal signal to turn on stracing. */
		    case __SIGSTRACE:
		      strace.hello ();
		      break;

		    case __SIGCOMMUNE:
		      talktome ();
		      break;

		    /* A normal UNIX signal */
		    default:
		      sigproc_printf ("Got signal %d", sig);
		      if (!sig_handle (sig))
			{
			  sigproc_printf ("couldn't send signal %d", sig);
			  low_priority_sleep (SLEEP_0_STAY_LOW);	/* Hopefully, other process will be waking up soon. */
			  saw_pending_signals = true;
			  ReleaseSemaphore (sigcatch_nosync, 1, NULL);
			  InterlockedIncrement (myself->getsigtodo (sig));
			}
		      break;
		    }
		}
	    }
	}
@


1.137
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d517 1
a517 1
sig_dispatch_pending (int justwake)
d519 1
a519 1
  if (!hwait_sig)
a520 1
  DWORD tid = GetCurrentThreadId ();
a523 3
  if (tid == sigtid && !justwake)
    justwake = 1;

d528 2
a529 1
  if (!was_pending && !justwake)
d537 1
a537 3
      if (!justwake)
	(void) sig_send (myself, __SIGFLUSH);
      else if (ReleaseSemaphore (sigcatch_nosync, 1, NULL))
d539 1
a539 3
	sigproc_printf ("woke up wait_sig");
#else
	;
d541 1
a541 4
      else if (no_signals_available ())
	/*sigproc_printf ("I'm going away now")*/;
      else
	system_printf ("%E releasing sigcatch_nosync(%p)", sigcatch_nosync);
d543 1
a543 2
    }
  if (was_pending && !justwake)
a605 5
      sig_dispatch_pending (1);
    }

  if (GetCurrentThreadId () == sigtid)
    {
d1119 2
a1120 2
      int saw_pending_signals = 0;
      int saw_sigchld = 0;
d1123 4
a1126 1
	  while (InterlockedDecrement (myself->getsigtodo (sig)) >= 0)
d1128 3
d1132 1
a1132 1
		saw_sigchld = 1;
d1140 1
a1140 1
		  break;
d1142 1
a1142 4

	      /* Found a signal to process */
	      sigproc_printf ("processing signal %d", sig);
	      switch (sig)
d1144 30
a1173 21
		case __SIGFLUSH:
		  /* just forcing the loop */
		  break;

		/* Internal signal to turn on stracing. */
		case __SIGSTRACE:
		  strace.hello ();
		  break;

		case __SIGCOMMUNE:
		  talktome ();
		  break;

		/* A normal UNIX signal */
		default:
		  sigproc_printf ("Got signal %d", sig);
		  sig_handle (sig, rc != 2);
		  /* Need to decrement again to offset increment below since
		     we really do want to decrement in this case. */
		  InterlockedDecrement (myself->getsigtodo (sig));
		  goto nextsig;		/* FIXME: shouldn't this allow the loop to continue? */
a1175 5

	nextsig:
	  /* Decremented too far. */
	  if (InterlockedIncrement (myself->getsigtodo (sig)) > 0)
	    saw_pending_signals = 1;
d1178 3
a1180 1
      if (pending_signals < 0 && !saw_pending_signals)
@


1.136
log
@	* shared_info.h: Match shared_name declaration with below change.
	* shared.cc (shared_name): Use incoming char * parameter instead of
	local static buffer.
	(open_shared): Accomodate new calling convention for shared_name.
	* exceptions.cc (events_init): Ditto.
	* sigproc.cc (getsem): Ditto.
	* syscalls.cc (login): Ditto.
	(logout): Ditto.
	(pututline): Ditto.
@
text
@a16 1
#include <errno.h>
@


1.135
log
@Joe Buehler <jhpb@@draco.hekimian.com>
* fork.cc (fork_parent): Don't copy signals from parent to child here.
* sigproc.cc (proc_subproc): Copy signals from parent to child pinfo here.
@
text
@d886 1
d910 1
a910 1
			   str = shared_name (str, winpid));
d921 1
a921 1
			 shared_name (str, p->dwProcessId));
@


1.134
log
@* cygwin.din: Export btowc, trunc.
* include/cygwin/version.h: Reflect new exports.
* syscalls.cc (_stat): Rename to stat to avoid newlib wrapper.
* syscalls.cc (_fstat): Ditto.
* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
* syscalls.cc (rename): Revert assumption that DELETE_ON_CLOSE works on Win9x.
@
text
@d298 1
@


1.133
log
@* fhandler.cc (fhandler_base::open): Move some filesystem specific stuff.
(fhandler_disk_file::open): Accept some filesystem specific stuff.
* sigproc.cc (wait_for_sigthread): Become slightly more thread safe.
(sig_send): Don't assume that signal thread is ready.
@
text
@d611 1
a611 1
    sigproc_printf ("sigproc_terminate: sigproc handling not active");
@


1.133.2.1
log
@* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
@
text
@d611 1
a611 1
    sigproc_printf ("sigproc handling not active");
@


1.132
log
@* sigproc.cc (sig_dispatch_pending): Remove assertion.
@
text
@d173 4
a176 3
  assert (wait_sig_inited);
  (void) WaitForSingleObject (wait_sig_inited, INFINITE);
  (void) ForceCloseHandle (wait_sig_inited);
d178 1
d659 2
a660 1
      assert (!wait_sig_inited);
@


1.132.4.1
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d26 1
a27 1
#include "fhandler.h"
@


1.132.4.2
log
@merge from trunk
@
text
@d173 3
a175 4
  sigproc_printf ("wait_sig_inited %p", wait_sig_inited);
  HANDLE hsig_inited = wait_sig_inited;
  assert (hsig_inited);
  (void) WaitForSingleObject (hsig_inited, INFINITE);
a176 1
  (void) ForceCloseHandle1 (hsig_inited, wait_sig_inited);
d657 1
a657 2
      if (wait_sig_inited)
	wait_for_sigthread ();
@


1.132.4.3
log
@merge from trunk
@
text
@d611 1
a611 1
    sigproc_printf ("sigproc handling not active");
@


1.132.4.4
log
@merge from trunk
@
text
@a297 1
      vchild->copysigs (myself);
@


1.132.4.5
log
@merge from trunk
@
text
@a885 1
  char sem_name[MAX_PATH];
d909 1
a909 1
			   str = shared_name (sem_name, str, winpid));
d920 1
a920 1
			 shared_name (sem_name, str, p->dwProcessId));
@


1.132.4.6
log
@merge from trunk
@
text
@d17 1
@


1.132.4.7
log
@merge from trunk
@
text
@a50 6
LONG local_sigtodo[TOTSIGS];
inline LONG* getlocal_sigtodo (int sig)
{
  return local_sigtodo + __SIGOFFSET + sig;
}

d120 1
a120 1
static bool NO_COPY pending_signals = false;	// true if signals pending
a510 1
  (void) InterlockedExchange (getlocal_sigtodo (sig), 0L);
a513 12
extern "C" int
sigpending (sigset_t *set)
{
  unsigned bit;
  *set = 0;
  for (int sig = 1; sig < NSIG; sig++)
    if ((*getlocal_sigtodo (sig) || *myself->getsigtodo (sig))
        && (myself->getsigmask () & (bit = SIGTOMASK (sig))))
      *set |= bit;
  return 0;
}

d517 1
a517 1
sig_dispatch_pending ()
d519 1
a519 1
  if (!hwait_sig || GetCurrentThreadId () == sigtid)
d521 1
d525 3
d532 1
a532 2

  if (!was_pending)
d540 3
a542 1
      (void) sig_send (myself, __SIGFLUSH);
d544 3
a546 1
      sigproc_printf ("woke up wait_sig");
d548 5
d554 1
a554 2

  if (was_pending)
d617 5
a677 1
  LONG *todo;
d681 1
a681 4
	{
	  thiscatch = sigcatch_nosync;
	  todo = myself->getsigtodo (sig);
	}
a685 1
	  todo = getlocal_sigtodo (sig);
a691 1
	  todo = getlocal_sigtodo (sig);
d694 1
a694 3
  else if (thiscatch = getsem (p, "sigcatch", 0, 0))
    todo = p->getsigtodo (sig);
  else
d707 1
a707 1
  (void) InterlockedIncrement (todo);
a758 1
#if 0 // STILL NEEDED?
a765 1
#endif
d794 1
a794 1
  (void) InterlockedIncrement (getlocal_sigtodo (sig));
a1035 3
#define RC_MAIN 0
#define RC_NONMAIN 1
#define RC_NOSYNC 2
a1046 1
  LONG *todos[] = {getlocal_sigtodo (0), myself->getsigtodo (0)};
a1105 2
  DWORD rc = RC_NOSYNC;
  bool flush = false;
d1108 1
a1108 10
      DWORD i;
      if (rc == RC_MAIN || rc == RC_NONMAIN)
	i = RC_NOSYNC;
      else
	i = RC_MAIN;
      rc = WaitForSingleObject (catchem[i], 0);
      if (rc != WAIT_OBJECT_0)
	rc = WaitForMultipleObjects (3, catchem, FALSE, sig_loop_wait);
      else
	rc = i + WAIT_OBJECT_0;
d1130 1
a1130 7
      sigproc_printf ("awake, rc %d", rc);
      LONG *todo;
      if (rc != RC_NOSYNC)
	todo = *todos;
      else
	todo = todos[1];

d1134 58
a1191 68
      pending_signals = false;
      bool more_signals = false;
      bool saw_failed_interrupt = false;
      do
	for (int sig = -__SIGOFFSET, more_signals = false; sig < NSIG; sig++)
	  {
	    LONG x = InterlockedDecrement (todo + sig);
	    if (x < 0)
	      InterlockedIncrement (todo + sig);
	    else if (x >= 0)
	      {
		if (sig > 0 && sig != SIGKILL && sig != SIGSTOP &&
		    (sigismember (&myself->getsigmask (), sig) ||
		     main_vfork->pid ||
		     (sig != SIGCONT && ISSTATE (myself, PID_STOPPED))))
		  {
		    sigproc_printf ("signal %d blocked", sig);
		    pending_signals = true;	// FIXME: This will cause unnecessary sig_dispatch_pending spins
		    InterlockedIncrement (myself->getsigtodo (sig));
		  }
		else
		  {
		    /* Found a signal to process */
		    if (rc != RC_NOSYNC)
		      pending_signals = true;	// There should be an armed semaphore, in this case

		    sigproc_printf ("processing signal %d", sig);
		    switch (sig)
		      {
		      case __SIGFLUSH:
			if (rc == RC_MAIN)
			  {
			    flush = true;
			    ReleaseSemaphore (sigcatch_nosync, 1, NULL);
			    goto out1;
			  }
			break;

		      /* Internal signal to turn on stracing. */
		      case __SIGSTRACE:
			strace.hello ();
			break;

		      case __SIGCOMMUNE:
			talktome ();
			break;

		      /* A normal UNIX signal */
		      default:
			sigproc_printf ("Got signal %d", sig);
			if (!sig_handle (sig))
			  {
			    pending_signals = saw_failed_interrupt = true;
			    sigproc_printf ("couldn't send signal %d", sig);
			    InterlockedIncrement (myself->getsigtodo (sig));
			  }
		      }
		    if (rc == RC_NOSYNC)
		      more_signals = x > 0;
		  }

		if (sig == SIGCHLD)
		  proc_subproc (PROC_CLEARWAIT, 0);
		if (saw_failed_interrupt || rc != RC_NOSYNC)
		  goto out;
	      }
	  }
      while (more_signals);
a1192 1
    out:
d1194 3
a1196 4
	 woke up the WaitForMultipleObjects above.  */
      if (rc == RC_NONMAIN)	// FIXME: This is broken
	ReleaseSemaphore (sigcomplete_nonmain, 1, NULL);
      else if (rc == RC_MAIN || flush)
d1198 1
d1201 7
a1207 7
	  flush = false;
	}
    out1:
      if (saw_failed_interrupt)
	{
	  ReleaseSemaphore (sigcatch_nosync, 1, NULL);
	  low_priority_sleep (0);	/* Hopefully, other thread will be waking up soon. */
@


1.132.4.8
log
@merge from trunk
@
text
@a19 1
#include <sys/signal.h>
d51 2
a52 5
static LONG local_sigtodo[TOTSIGS];
struct sigaction *global_sigs;

inline LONG *
getlocal_sigtodo (int sig)
a56 20
void __stdcall
sigalloc ()
{
  cygheap->sigs = global_sigs =
    (struct sigaction *) ccalloc (HEAP_SIGS, NSIG, sizeof (struct sigaction));
}

void __stdcall
signal_fixup_after_exec ()
{
  global_sigs = cygheap->sigs;
  /* Set up child's signal handlers */
  for (int i = 0; i < NSIG; i++)
    {
      myself->getsig (i).sa_mask = 0;
      if (myself->getsig (i).sa_handler != SIG_IGN)
	myself->getsig (i).sa_handler = SIG_DFL;
    }
}

d130 1
a130 1
static int __stdcall checkstate (waitq *) __attribute__ ((regparm (1)));
d132 1
a132 1
static HANDLE __stdcall getevent (_pinfo *, const char *) __attribute__ ((regparm (2)));
d303 1
d543 1
d545 1
a545 1
  sigproc_printf ("pending_signals %d", pending_signals);
d548 1
a548 1
  if (!pending_signals)
d562 4
a565 1
  return thisframe.call_signal_handler ();
a681 1
  bool issem;
a687 1
	  issem = false;
a693 1
	  issem = true;
a700 1
	  issem = true;
d703 2
a704 5
  else if ((thiscatch = getevent (p, "sigcatch")))
    {
      todo = p->getsigtodo (sig);
      issem = false;
    }
d706 1
a706 1
    goto out;		  // Couldn't get the semaphore.  getevent issued
d722 9
a730 1
  if (issem ? !ReleaseSemaphore (thiscatch, 1, NULL) : !SetEvent (thiscatch))
d767 2
d770 9
d781 4
d895 1
a895 1
getevent (_pinfo *p, const char *str)
d915 1
a920 1
#if 0
a922 4
#else
      h = CreateEvent (sec_user_nih (sa_buf), FALSE, FALSE,
		       str = shared_name (sem_name, str, winpid));
#endif
a931 1
#if 0
a933 4
#else
      h = OpenEvent (EVENT_ALL_ACCESS, FALSE,
		     shared_name (sem_name, str, p->dwProcessId));
#endif
d1078 1
a1078 1
  sigcatch_nosync = getevent (NULL, "sigcatch");
d1140 2
a1141 1
         this thread should terminate.  */
d1161 1
a1161 1
	todo = todos[0];
d1166 2
a1167 1
         array looking for any unprocessed signals.  */
d1169 1
a1169 1
      unsigned more_signals = 0;
d1172 64
a1235 74
	{
	  more_signals = 0;
	  for (int sig = -__SIGOFFSET; sig < NSIG; sig++)
	    {
	      LONG x = InterlockedDecrement (todo + sig);
	      if (x < 0)
		InterlockedIncrement (todo + sig);
	      else if (x >= 0)
		{
		  /* If x > 0, we have to deal with a signal at some later point */
		  if (rc != RC_NOSYNC && x > 0)
		    pending_signals = true;	// There should be an armed semaphore, in this case

		  if (sig > 0 && sig != SIGKILL && sig != SIGSTOP &&
		      (sigismember (&myself->getsigmask (), sig) ||
		       main_vfork->pid ||
		       (sig != SIGCONT && ISSTATE (myself, PID_STOPPED))))
		    {
		      sigproc_printf ("signal %d blocked", sig);
		      x = InterlockedIncrement (myself->getsigtodo (sig));
		      pending_signals = true;
		    }
		  else
		    {
		      sigproc_printf ("processing signal %d", sig);
		      switch (sig)
			{
			case __SIGFLUSH:
			  if (rc == RC_MAIN)
			    {
			      flush = true;
			      SetEvent (sigcatch_nosync);
			      goto out1;
			    }
			  break;

			/* Internal signal to turn on stracing. */
			case __SIGSTRACE:
			  strace.hello ();
			  break;

			case __SIGCOMMUNE:
			  talktome ();
			  break;

			/* A normal UNIX signal */
			default:
			  sigproc_printf ("Got signal %d", sig);
			  if (!sig_handle (sig))
			    {
			      saw_failed_interrupt = true;
			      x = InterlockedIncrement (myself->getsigtodo (sig));
			      pending_signals = true;
			    }
			}
		      if (rc == RC_NOSYNC && x > 0)
			more_signals++;
		    }

		  if (sig == SIGCHLD)
		    proc_subproc (PROC_CLEARWAIT, 0);

		  /* Need to take special action if an interrupt failed due to main thread not
		     getting around to calling handler yet.  */
		  if (saw_failed_interrupt || rc != RC_NOSYNC)
		    goto out;
		}
	    }
#ifdef DEBUGGING
	  if (more_signals > 100)
	    system_printf ("hmm.  infinite loop? more_signals %u\n", more_signals);
#endif
	}
      while (more_signals && sig_loop_wait);
a1247 1

d1251 1
a1251 1
	  SetEvent (sigcatch_nosync);
@


1.132.4.9
log
@merge from trunk
@
text
@d31 1
d52 5
a56 1
class sigelem
d58 2
a59 25
  int sig;
  class sigelem *next;
  friend class pending_signals;
  friend int __stdcall sig_dispatch_pending ();
};

class pending_signals
{
  sigelem sigs[NSIG + 1];
  sigelem start;
  sigelem *end;
  sigelem *prev;
  sigelem *curr;
  int empty;
public:
  void reset () {curr = &start; prev = &start;}
  void add (int sig);
  void del ();
  int next ();
  friend int __stdcall sig_dispatch_pending ();
};

static pending_signals sigqueue;

struct sigaction *global_sigs;
d110 8
d121 3
d150 2
d156 1
d204 1
d534 2
a535 1
/* Clear pending signal */
d537 1
a537 1
sig_clear (int target_sig)
d539 2
a540 13
  if (GetCurrentThreadId () != sigtid)
    sig_send (myself, -target_sig);
  else
    {
      int sig;
      sigqueue.reset ();
      while ((sig = sigqueue.next ()))
	if (sig == target_sig)
	  {
	    sigqueue.del ();
	    break;
	  }
    }
d545 1
a545 1
sigpending (sigset_t *mask)
d547 6
a552 4
  sigset_t outset = (sigset_t) sig_send (myself, __SIGPENDING);
  if (outset == SIG_BAD_MASK)
    return -1;
  *mask = outset;
d556 3
a558 2
/* Force the wait_sig thread to wake up and scan for pending signals */
int __stdcall
d561 1
a561 1
  if (!hwait_sig || GetCurrentThreadId () == sigtid || !sigqueue.start.next)
d565 19
a583 1
  (void) sig_send (myself, __SIGFLUSH);
d645 6
a650 1
      CloseHandle (myself->sendsig);
d668 1
d670 1
a670 2
  HANDLE sendsig;
  bool wait_for_completion;
d676 1
a676 1
    wait_for_completion = false;
d700 2
d704 1
a704 1
      if (wait_for_completion)
d706 3
a708 2
	  thisframe.set (mainthread, ebp, exception);
	  thiscomplete = sigcomplete_main;
d710 1
a710 6
      sendsig = myself->sendsig;
    }
  else
    {
      HANDLE hp = OpenProcess (PROCESS_DUP_HANDLE, false, p->dwProcessId);
      if (!hp)
d712 4
a715 2
	  __seterrno ();
	  goto out;
d717 1
a717 2
      if (!DuplicateHandle (hp, p->sendsig, hMainProc, &sendsig, false, 0,
			    DUPLICATE_SAME_ACCESS) || !sendsig)
d719 5
a723 2
	  __seterrno ();
	  goto out;
d726 19
d746 3
a748 2
  DWORD nb;
  if (!WriteFile (sendsig, &sig, sizeof (sig), &nb, NULL) || nb != sizeof (sig))
d754 1
a754 4
	{
	  __seterrno ();
	  ForceCloseHandle (sendsig);
	}
d759 2
d762 2
a763 2
	    system_printf ("error sending signal %d to pid %d, pipe handle %p, %E",
			  sig, p->pid, sendsig);
a767 23
  /* Write completion handle or NULL */
  if (!WriteFile (sendsig, &thiscomplete, sizeof (thiscomplete), &nb, NULL)
      || nb != sizeof (thiscomplete))
    {
      __seterrno ();
      goto out;
    }

  sigset_t pending;
  sigset_t *mask;
  if (sig == __SIGPENDING)
    mask = &pending;
  else if (sig == __SIGFLUSH || sig > 0)
    mask = &myself->getsigmask ();
  else
    mask = NULL;
  if (mask && !WriteFile (sendsig, &mask, sizeof (mask), &nb, NULL)
      || nb != sizeof (pending))
    {
      __seterrno ();
      goto out;
    }

d780 1
a780 1
	ForceCloseHandle (sendsig);
d801 1
a801 7
  if (sig != __SIGPENDING)
    /* nothing */;
  else if (!rc)
    rc = (int) pending;
  else
    rc = SIG_BAD_MASK;
  sigproc_printf ("returning %p from sending signal %d", rc, sig);
d805 9
d895 65
d1061 3
d1065 7
a1071 57
   Then scan an in-memory array representing queued signals.
   Executes in a separate thread.

   Signals sent from this process are sent a completion signal so
   that returns from kill/raise do not occur until the signal has
   has been handled, as per POSIX.  */

void
pending_signals::add (int sig)
{
  sigelem *se;
  for (se = start.next; se; se = se->next)
    if (se->sig == sig)
      return;
  while (sigs[empty].sig)
    if (++empty == NSIG)
      empty = 0;
  se = sigs + empty;
  se->sig = sig;
  se->next = NULL;
  if (end)
    end->next = se;
  end = se;
  if (!start.next)
    start.next = se;
  empty++;
}

void
pending_signals::del ()
{
  sigelem *next = curr->next;
  prev->next = next;
  curr->sig = 0;
#ifdef DEBUGGING
  curr->next = NULL;
#endif
  if (end == curr)
    end = prev;
  empty = curr - sigs;
  curr = next;
}

int
pending_signals::next ()
{
  int sig;
  prev = curr;
  if (!curr || !(curr = curr->next))
    sig = 0;
  else
    sig = curr->sig;
  return sig;
}

/* Process signals by waiting for signal data to arrive in a pipe.
   Set a completion event if one was specified. */
d1075 1
a1075 3
  HANDLE readsig;
  char sa_buf[1024];

d1079 15
a1093 4
  /* sigcomplete_main	   - event used to signal main thread on signal
    			     completion */
  if (!CreatePipe (&readsig, &myself->sendsig, sec_user_nih (sa_buf), 0))
    api_fatal ("couldn't create signal pipe, %E");
d1095 1
a1095 1
  sigproc_printf ("sigcomplete_main %p", sigcomplete_main);
d1099 4
a1102 3
     signals.  Prior to this, dwProcessId was set to the windows pid of
     of the original windows process which spawned us unless this was a
     "toplevel" process.  */
d1107 4
d1114 3
a1116 2
     windows process waiting to see if it's started a cygwin process or not.
     Signalling subproc_ready indicates that we are a cygwin process.  */
d1133 4
d1139 21
a1159 4
      int sig;
      DWORD nb;
      if (!ReadFile (readsig, &sig, sizeof (sig), &nb, NULL))
	break;
d1161 4
a1164 35
      HANDLE wakeup;
      if (!ReadFile (readsig, &wakeup, sizeof (wakeup), &nb, NULL)
	  || nb != sizeof (wakeup))
	{
	  system_printf ("signal notification handle read failure, %E");
	  continue;
	}

      if (!sig)
	continue;		/* Just checking to see if we exist */

      sigset_t *mask;
      if ((sig == __SIGFLUSH || sig == __SIGPENDING || sig > 0)
	  && (!ReadFile (readsig, &mask, sizeof (mask), &nb, NULL)
	      || nb != sizeof (mask)))
	{
	  system_printf ("signal mask handle read failure, %E");
	  continue;
	}

      switch (sig)
	{
	case __SIGCOMMUNE:
	  talktome ();
	  continue;
	case __SIGSTRACE:
	  strace.hello ();
	  continue;
	case __SIGPENDING:
	  *mask = 0;
	  unsigned bit;
	  sigqueue.reset ();
	  while ((sig = sigqueue.next ()))
	    if (myself->getsigmask () & (bit = SIGTOMASK (sig)))
	      *mask |= bit;
d1166 19
a1184 2
	default:
	  if (sig > 0)
d1186 63
a1248 9
	      int sh;
	      for (int i = 0; !(sh = sig_handle (sig, *mask)) && i < 100 ; i++)
		low_priority_sleep (0);		// hopefully a temporary condition
	      if (sh <= 0)
{if (!sh) small_printf ("*********sh == 0\n");
		sigqueue.add (sig);		// FIXME: Shouldn't add this in !sh condition
}
	      if (sig == SIGCHLD)
		proc_subproc (PROC_CLEARWAIT, 0);
d1250 24
a1273 17
	  else
	    {
	      int target_sig = -sig;
	      sigqueue.reset ();
	      while ((sig = sigqueue.next ()))
		if (sig == target_sig)
		  {
		    sigqueue.del ();
		    break;
		  }
	    }
	case __SIGFLUSH:
	  sigqueue.reset ();
	  while ((sig = sigqueue.next ()))
	    if (sig_handle (sig, *mask) > 0)
	      sigqueue.del ();
	  break;
d1275 1
a1275 2
      if (wakeup)
	SetEvent (wakeup);
@


1.131
log
@* exceptions.cc (handle_sigsuspend): Force pending signal delivery before
waiting for signals to happen.
* signal.cc (sleep): Force pending signal delivery before sleeping.
(usleep): Ditto.
(signal): Force pending signal delivery before manipulating signal stuff.
(sigprocmask): Ditto.
(kill_worker): Ditto.
(abort): Ditto.
(sigaction): Ditto.
* syscalls.cc (readv): Force pending signal delivery before I/O.
(writev): Ditto.
(open): Ditto.
* net.cc: Ditto, throughout.
* sigproc.cc (sig_dispatch_pending): Deliver any pending signals prior to
returning.
* tty.cc (tty::make_pipes): Increase pipe buffer size.
@
text
@a537 1
      assert (!wait_sig_inited);
@


1.130
log
@* exceptions.cc (sigthread::get_winapi_lock): Just do standard 'give up
timeslice' wait.
(setup_handler): Revamp YA to attempt to deliver signal multiple times on
failure rather than punting to wait_sig.
* miscfuncs.cc (low_priority_sleep): Accept INFINITE sleep to mean "don't reset
the priority after setting it to idle".  Return previous priority.
* winsup.h (SLEEP_0_STAY_LOW): Define.
(low_priority_sleep): Return an int.
* sigproc.h: Define WAIT_SIG_PRIORITY here.
* sigproc.cc: Remove WAIT_SIG_PRIORITY definition.
@
text
@d519 6
d553 3
@


1.129
log
@* exceptions.cc (setup_handler): Add debugging output.  Set thread priority to
idle if pending signals to allow other threads to get into interruptible state.
* miscfuncs.cc (sys_mbstowcs): Save current thread in variable to avoid an OS
call.
* wait.cc (wait_sig): Reset thread priority each time through loop since the
priority may have been set down to deal with pending signals.
@
text
@a43 2
#define WAIT_SIG_PRIORITY		THREAD_PRIORITY_TIME_CRITICAL

@


1.128
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d1099 1
@


1.127
log
@* sigproc.cc (WAIT_SIG_PRIORITY): Bump to THREAD_PRIORITY_TIME_CRITICAL.
@
text
@d889 1
a889 1
	Sleep (1);
@


1.126
log
@* sigproc.cc (WAIT_SIG_PRIORITY): Bump to highest priority.
@
text
@d44 1
a44 1
#define WAIT_SIG_PRIORITY		THREAD_PRIORITY_HIGHEST
@


1.125
log
@* external.cc (cygwin_internal): Implement CW_CMDLINE.
* pinfo.h (SIGCOMMUNE): New signal type.
(commune_result): New structure for commune functions.
(picom): New enum for commune functions.
(_pinfo::hello_pid): New.  Pid who's communicating with me.
(_pinfo::tothem): New.  Handle of communicating pipe.
(_pinfo::fromthem): Ditto.
(_pinfo::commune_recv): Declare.
(_pinfo::commune_send): Declare.
(_pinfo::alive): Declare.
(_pinfo::cmdline): Declare.
(_pinfo::lock): Declare.
* pinfo.cc (set_myself): Initialize new _pinfo lock.
(_pinfo::alive): Define.  Determines if process still exists.
(_pinfo::commune_recv): Define.  Receive info from another cooperating process.
(_pinfo::commune_send): Define.  Send info to another cooperating process.
(_pinfo::cmdline): Define.  Determine command line of a given process.
* include/sys/cygwin.h (CW_CMDLINE): Define.
*sigproc.cc (talktome): Communicate with any processes who want to talk to me.
(wait_sig): Honor __SIGCOMMUNE.
* fhandler.cc (fhandler_virtual::fixup_after_exec): Declare.
* fhandler_proc.cc: Use malloc/free/realloc throughout rather than cmalloc
since buffers don't need to be propagated to subprocesses.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
(fhandler_virtual::fixup_after_exec): Define.
* fhandler_process.cc: Ditto for malloc/free/realloc.
(process_listin): Add "cmdline".
(fhandler_process::fill_filebuf): Implement PROCESS_CMDLINE.
* miscfuncs.cc (isalpha_array): New array populated with xor values for alpha
characters to switch from one case to another.
* string.h (cygwin_strcasematch): New asm implementation of case match.
* string.h (cygwin_nstrcasematch): New asm implementation of counted case
match.
@
text
@d44 1
a44 1
#define WAIT_SIG_PRIORITY		THREAD_PRIORITY_NORMAL
@


1.125.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d44 1
a44 1
#define WAIT_SIG_PRIORITY		THREAD_PRIORITY_TIME_CRITICAL
d1017 9
d1153 4
@


1.124
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@d1017 9
d1153 4
@


1.123
log
@* sigproc.cc (wait_sig): Remove obsolete sigchld logic.
@
text
@d475 1
d565 5
a577 5
  /* sync_proc_subproc is used by proc_subproc.  It serialises
   * access to the children and zombie arrays.
   */
  new_muto (sync_proc_subproc);

d602 10
a622 16

  if (!sig_loop_wait)
    sigproc_printf ("sigproc_terminate: sigproc handling not active");
  else
    {
      sigproc_printf ("entering");
      sig_loop_wait = 0;	// Tell wait_sig to exit when it is
				//  finished with anything it is doing
      sigproc_printf ("done");
    }

#if 0
  /* Set this so that subsequent tests will succeed. */
  if (!myself->dwProcessId)
    myself->dwProcessId = GetCurrentProcessId ();
#endif
@


1.122
log
@* cygthread.cc (cygthread::stub): Reintroduce clearing of __name but do it
before SetEvent to eliminate a race.
(cygthread::terminate): Accumulate list of threads to check for termination and
call WaitForMultipleObjects on list rather than waiting for each thread
individually.
* sigproc.cc (subproc_init): Zap hwait_subproc thread handle since it is no
longer used.
* spawn.cc (spawn_guts): Fix so that cygthread::terminate is *really* called
only for exec.
@
text
@a1121 1
      int dispatched_sigchld = 0;
d1154 1
a1154 3
		  int wasdispatched = sig_handle (sig, rc != 2);
		  if (sig == SIGCHLD && wasdispatched)
		    dispatched_sigchld = 1;
@


1.121
log
@* Makefile.in (new-cygwin1.dll): Reorganize library order.
* dcrt0.cc (do_exit): Move thread stuff after vfork stuff or threads are
terminated during vfork.
* sigproc.cc (proc_terminate): Grab proc lock prior to signalling subproc
thread exit to avoid an extra "wait-for-thread-to-exit".
@
text
@d808 1
d810 1
a810 1
  sigproc_printf ("started wait_subproc thread %p", (HANDLE) *hwait_subproc);
@


1.120
log
@* cygthread.cc (cygthread::stub): Don't create an event for "cygself" threads.
Assume that they exit via an ExitThread call.
* cygthread.h (cygthread::SetThreadPriority): New function.
(cygthread::zap_h): New function.
* dcrt0.cc (do_exit): Move cygthread::terminate earlier and establish
exit_state guard.
* fhandler.h (fhandler_tty_master::output_thread): Delete.
* fhandler_tty.cc (fhandler_tty_master::init): Set priority for threads via
method.  Zap handles when done.  Don't treat process_output specially.
(process_output): Call ExitThread directly.
(fhandler_tty_master::fixup_after_fork): Don't worry about output_thread.
(fhandler_tty_master::fixup_after_exec): Ditto.
* sigproc.cc (proc_terminate): Don't detach from hwait_subproc.  Just let it
exit.
(sigproc_init): Close thread handle after initialization.
(wait_sig): Use GetCurrentThread() as SetThreadPriority call rather than
*event* handle.  Call ExitThread directly on termination.
(wait_subproc): Call ExitThread directly on termination.
* tty.cc (tty_list::terminate): Don't attempt t detach from output_thread.
@
text
@d460 1
a463 1
      sync_proc_subproc->acquire (WPSP);
@


1.119
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@a460 1
      hwait_subproc->detach ();
d570 1
d1033 1
a1033 1
  (void) SetThreadPriority (*((cygthread *) self), WAIT_SIG_PRIORITY);
d1196 1
a1196 1
  return 0;
d1270 1
a1270 1
  return 0;
@


1.118
log
@* pinfo.h (pinfo::remember): Arrange for destructor call if proc_subproc
returns error.
* sigproc.cc (zombies): Store 1 + total zombies since proc_subproc uses
NZOMBIES element.
@
text
@d464 1
a464 1
      sync_proc_subproc->acquire(WPSP);
d477 1
a477 1
	  zombies[i].release();		// FIXME: this breaks older gccs for some reason
d567 1
a567 1
  signal_arrived = CreateEvent(&sec_none_nih, TRUE, FALSE, NULL);
@


1.117
log
@* sigproc.cc (sigCONT): Define.
* sigproc.h (sigCONT): Declare.
(wait_sig): Create sigCONT event here.
* exceptions.cc (sig_handle_tty_stop): Wait for sigCONT event rather than
stopping thread.
(sig_handle): Set sigCONT event as appropriate on SIGCONT rather than calling
ResumeThread.
@
text
@d110 1
a110 1
Static char czombies[NZOMBIES * sizeof (pinfo)];		// All my deceased children info
@


1.116
log
@* assert.cc (__assert): Call debugger on assertion failure if debugging.
* dcrt0.cc (dll_crt0_1): Just wait for signal thread to go live rather than
going through the overhead of invoking it.
* fork.cc (fork_child): Ditto.
* exceptions.cc (signal_fixup_after_fork): Call sigproc_init here.
* sigproc.cc (proc_can_be_signalled): Assume that the signal thread is live.
(sig_dispatch): Ditto.
(sig_send): Ditto.
(wait_for_sigthread): Renamed from "wait_for_me".  Assume that wait_sig_inited
has been set and that this function is only called from the main thread.
* winsup.h (wait_for_sigthread): Declare new function.
@
text
@d83 1
a83 1
Static HANDLE sigcatch_nonmain = NULL;	// The semaphore signaled when
d86 1
a86 1
Static HANDLE sigcatch_main = NULL;	// Signalled when main thread sends a
d88 1
a88 1
Static HANDLE sigcatch_nosync = NULL;	// Signal wait_sig to scan sigtodo
d91 1
a91 1
Static HANDLE sigcomplete_main = NULL;	// Event signaled when a signal has
d94 1
a94 1
Static HANDLE sigcomplete_nonmain = NULL;// Semaphore raised for non-main
d97 1
d101 1
a101 1
Static HANDLE wait_sig_inited = NULL;	// Control synchronization of
d106 1
a106 1
Static HANDLE events[PSIZE + 1] = {0};  // All my children's handles++
d109 1
a109 1
Static int nchildren = 0;		// Number of active children
d111 1
a111 1
Static int nzombies = 0;		// Number of deceased children
d1052 1
@


1.115
log
@* spawn.cc (spawn_guts): Don't set mount_h here.
* sigproc.cc (init_child_info): Set it here instead.
* shared.cc (cygwin_mount_h): Make NO_COPY.
@
text
@d20 1
d171 2
a172 2
__inline static void
wait_for_me ()
d174 4
a177 10
  /* See if this is the first signal call after initialization.
   * If so, wait for notification that all initialization has completed.
   * Then set the handle to NULL to avoid checking this again.
   */
  if (wait_sig_inited)
    {
      (void) WaitForSingleObject (wait_sig_inited, INFINITE);
      (void) ForceCloseHandle (wait_sig_inited);
      wait_sig_inited = NULL;
    }
d208 1
a208 1
      wait_for_me ();
d533 1
a533 1
      wait_for_me ();
d655 1
a655 1
      wait_for_me ();
@


1.114
log
@* cygthread.cc (cygthread::stub): Accept flag to pass info structure to thread
function.
(cygthread::operator new): Add defense debugging output.
(cygthread::cygthread): Add debugging output.  Set name after thread has been
awakened to avoid a race.
(cygthread::exit_thread): Use handle operator rather than using ev directly.
(cygthread::exit_thread): Reorganize to provide debugging.  Set __name to NULL.
* cygthread.h (cygself): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Use cygself as argument so that
invoked thread can access its own info.
(process_output): Derive cygthread info of thread from thread argument.
* sigproc.cc (sigproc_init): Use cygself as argument so that invoked thread can
access its own info.
(wait_sig): Derive cygthread info of thread from thread argument.
@
text
@d831 1
@


1.113
log
@* Makefile.in (DLL_OFILES): Add cygthread.o.
* dcrt0.cc (dll_crt0_1): Eliminate various thread initialization functions in
favor of new cygthread class.
* debug.cc: Remove thread manipulation functions.
* debug.h: Ditto.
* external.cc (cygwin_internal): Use cygthread method for determining thread
name.  Remove capability for setting thread name.
* fhandler_console.cc (fhandler_console::read): Use cygthread method rather
than iscygthread function.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Use cygthread
methods to create threads.
(fhandler_tty_common::__acquire_output_mutex): Use cygthread method to retrieve
thread name.
* select.cc (pipeinf): Use cygthread pointer rather than handle.
(start_thread_pipe): Ditto.
(pipe_cleanup): Ditto.
(serialinf): Ditto.
(start_thread_serial): Ditto.
(serial_cleanup): Ditto.
(socketinf): Ditto.
(start_thread_socket): Ditto.
(socket_cleanup): Ditto.
* sigproc.cc (hwait_sig): Ditto.
(hwait_subproc): Ditto.
(proc_terminate): Ditto.
(sigproc_terminate): Ditto.
(sigproc_init): Initialize cygthread hwait_sig pointer.
(subproc_init): Initialize cygthread hwait_subproc pointer.
(wait_sig): Rely on cygthread HANDLE operator.
* strace.cc (strace::vsprntf): Use cygthread::name rather than threadname.
* window.cc (gethwnd): Use cygthread method to initialize thread.
@
text
@d574 1
a574 1
  hwait_sig = new cygthread (wait_sig, NULL, "sig");
d1033 1
a1033 1
wait_sig (VOID *)
d1036 1
a1036 1
  (void) SetThreadPriority (*hwait_sig, WAIT_SIG_PRIORITY);
@


1.112
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d33 1
d96 2
a97 2
Static HANDLE hwait_sig = NULL;		// Handle of wait_sig thread
Static HANDLE hwait_subproc = NULL;	// Handle of sig_subproc thread
a462 1
      int rc;
d465 1
a465 9

      /* Wait for wait_subproc thread to exit (but not *too* long) */
      if ((rc = WaitForSingleObject (hwait_subproc, WWSP)) != WAIT_OBJECT_0)
	if (rc == WAIT_TIMEOUT)
	  system_printf ("WFSO(hwait_subproc) timed out");
	else
	  system_printf ("WFSO(hwait_subproc), rc %d, %E", rc);

      HANDLE h = hwait_subproc;
a466 1
      ForceCloseHandle1 (h, hwait_subproc);
d574 1
a574 7
  if (!(hwait_sig = makethread (wait_sig, NULL, 0, "sig")))
    {
      system_printf ("cannot create wait_sig thread, %E");
      api_fatal ("terminating");
    }

  ProtectHandle (hwait_sig);
a602 1
  HANDLE h = hwait_sig;
a623 23
      // sig_dispatch_pending (TRUE);	// wake up and die
      /* In case of a sigsuspend */
      // SetEvent (signal_arrived);

      /* If !hwait_sig, then the process probably hasn't even finished
       * its initialization phase.
       */
      if (0 && hwait_sig)
	{
	  if (GetCurrentThreadId () != sigtid)
	    WaitForSingleObject (h, 10000);
	  ForceCloseHandle1 (h, hwait_sig);


	  if (GetCurrentThreadId () != sigtid)
	    {
	      ForceCloseHandle (sigcomplete_main);
	      ForceCloseHandle (sigcomplete_nonmain);
	      ForceCloseHandle (sigcatch_main);
	      ForceCloseHandle (sigcatch_nonmain);
	      ForceCloseHandle (sigcatch_nosync);
	    }
	}
d811 1
a811 2
  if (!(hwait_subproc = makethread (wait_subproc, NULL, 0, "proc")))
    system_printf ("cannot create wait_subproc thread, %E");
d813 1
a813 2
  ProtectHandle (hwait_subproc);
  sigproc_printf ("started wait_subproc thread %p", hwait_subproc);
d1036 1
a1036 1
  (void) SetThreadPriority (hwait_sig, WAIT_SIG_PRIORITY);
@


1.111
log
@* sync.h (new_muto): Just accept an argument which denotes the name of the
muto.  Use this argument to construct static storage.
* cygheap.cc (cygheap_init): Reflect above change.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* cygheap.h (cwdstuff): Change name of lock element to make it less generic.
* path.cc (cwdstuff::get_hash): Ditto.
(cwdstuff::get_initial): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* sigproc.cc (proc_subproc): Ditto.
* debug.cc (lock_debug): Change to method.  Use method rather than macro
throughout.
* tty.h (tty_min::kill_pgrp): Declare new method.
* fhandler_termios.cc (tty_min::kill_pgrp): New method.
(fhandler_termios::line_edit): Use new method for killing process.
* dcrt0.cc (do_exit): Ditto.
* dtable.cc (dtable::get_debugger_info): New method for inheriting dtable info
from a debugger.
* tty.cc (tty_init): Attempt to grab file handle info from parent debugger, if
appropriate.  # dtable.cc (dtable::stdio_init): Make this a method.
(dtable::init_std_file_from_handle): Don't set fd unless it's not open.
(dtable::build_fhandler_from_name): Move name setting to
dtable::build_fhandler.
(dtable::build_fhandler): Add win32 name parameter.
* dcrt0.cc (dll_crt0_1): Change to use dtable stdio_init.
* dtable.h (dtable): Reflect build_fhandler parameter change.
* mmap.cc (mmap_record::alloc_fh): Don't set name parameter in build_fhandler.
* net.cc (fdsock): Remove set_name call since it is now handled by
build_fhandler.
* sigproc.cc (proc_subproc): Release muto as early as possible.
@
text
@a31 1
#include <assert.h>
d1121 1
a1121 1
      ForceCloseHandle (child_proc_info->subproc_ready);
@


1.110
log
@* fork.cc (fork_parent): Use sec_user_nih to control process/thread
inheritance/permission.
* spawn.cc (spawn_guts): Ditto.
* security.cc (create_token): Initialize token so that it is not tested for
bogus value later.  Use sec_user to control process/thread creation.
* security.h (__sec_user): Rename declaration from sec_user.
(sec_user_nih): Declare here as inline function wrapper for __sec_user.
(sec_user): Ditto.
* sigproc.cc (czombies): Allocate a character array for zombies to avoid
constructor overhead
(extremely hackish, I know).
(cpchildren): Ditto.
(pchildren): New define.
(zombies): Ditto.
(getsem): Use sec_user_nih to control semaphore inheritance/permission.
@
text
@d321 2
a322 2
		      pchildren[val]->pid, val, hchildren[val], pchildren[val]->hProcess);
	  ForceCloseHandle1 (hchildren[val], childhProc);
d324 2
d328 1
a328 1
	  break;			// This was an exec()
d595 1
a595 1
  sync_proc_subproc = new_muto ("sync_proc_subproc");
@


1.109
log
@* times.cc (hires::prime): Restore thread priority on failure condition.
* uinfo.cc (uinfo_init): Use more robust method for determining if process was
invoked from a non-cygwin process.
* sync.h (muto::init): Eliminate "inheritance" parameter.
(new_muto): Reflect removal of parameter.
* sync.cc (muto::init): Ditto.
* cygheap.cc (cygheap_init): Ditto.
* debug.cc (threadname_init): Ditto.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* grp.cc (group_lock): Use different method for locking with static member.
(read_etc_group): REALLY ensure that read lock mutex is released.
* passwd.cc (passwd_lock): Use different method for locking with static member.
(read_etc_passwd): REALLY ensure that read lock mutex is released.
* shared.cc (sec_user): Correct reversed inheritance test.
@
text
@d106 1
a106 1
Static pinfo pchildren[PSIZE];		// All my children info
d108 1
a108 1
Static pinfo zombies[NZOMBIES];		// All my deceased children info
d111 3
d945 2
a946 2
      h = CreateSemaphore (allow_ntsec ? sec_user_nih (sa_buf) : &sec_none_nih,
			   init, max, str = shared_name (str, winpid));
@


1.108
log
@* exceptions.cc (unused_sig_wrapper): Eliminate unused parameter to asm.
* external.cc (cygwin_internal): Change CW_STRACE_ON to CW_STRACE_TOGGLE.
* strace.cc (strace::hello): Toggle strace on and off.
* sync.cc (muto::init): Renamed from constructor.
* sync.h (muto::new): Delete.
(muto::delete): Ditto.
(new_muto): Simplify.  Use muto.init for nearly everything.
* uinfo.cc (uinfo_init): Avoid closing a NULL handle.
* include/sys/cygwin.h (cygwin_getinfo_types): Rename CW_STRACE_OFF to
CW_STRACE_TOGGLE.  Delete CW_STRACE_OFF.
* include/sys/strace.h (strace): Add "inited" field.
@
text
@d590 1
a590 1
  sync_proc_subproc = new_muto (FALSE, "sync_proc_subproc");
@


1.107
log
@* external.cc (cygwin_internal): Initialize various internal settings if
required to allow use of some things from user loaded DLL.
(CW_STRACE_ON): Add new feature.
(CW_CYGWIN_PID_TO_WINPID): Ditto.
* pinfo.cc (set_myself): Call "strace.hello" to initiate possible strace
session.
(pinfo::init): Guard against dereferencing uninitialized myself.
* sigproc.cc (wait_sig): Call strace.hello() when __SIGTRACE "signal" received.
* strace.cc (strace::hello): New method.
* wincap.cc (wincapc::init): Avoid initializing if already initialized.
* wincap.h (wincapc::wincapc): New method.
* include/sys/cygwin.h: Add new CW_ enums.  Kludge typedefs of {g,u}id_t if
required.
* strace.h (strace::hello): Declare new method.
@
text
@d1185 1
a1185 1
		/* Internal signal to force a flush of strace data to disk. */
@


1.106
log
@* Makefile.in (new-cygwin1.dll): Just use -lsupc++ for link.
* sigproc.cc (proc_exists): Change existence criteria.
* sync.h (new_muto): Add volatile to definition to avoid gcc optimization
problems.
@
text
@d1187 1
a1187 1
		  // proc_strace ();	// Dump cached strace.prntf stuff.
@


1.105
log
@Add copyright stuff
@
text
@d231 1
a231 1
  return p && !(p->process_state & (PID_INITIALIZING | PID_EXITED));
@


1.104
log
@* exceptions.cc (sig_handle): Accept a second argument indicating whether the
signal came from this process or not.
* sigproc.h: Reflect sig_handle arg change.
* signal.cc (kill_pgrp): Add sigframe info.
(abort): New function.  Eliminates newlib function of same name.
* sigproc.cc (wait_sig): Pass "signal from this process" value as arg 2.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.103
log
@* sigproc.cc (getsem): Clean up debugging output.
@
text
@d1193 1
a1193 1
		  int wasdispatched = sig_handle (sig);
@


1.102
log
@* sigproc.cc (getsem): Set errno when unable to create own semaphore.
Reorganize to make clearer that error should only come from initial creation of
process semaphore.
@
text
@d947 1
a947 1
	  system_printf ("can't %s %s, %E", p ? "open" : "create", str);
@


1.101
log
@* cygmagic: Add define name to warning.
* dcrt0.cc (_dll_crt0): Check for changes in child_info size.
(multiple_cygwin_problem): Avoid "proc" errors when testing.  Just assume new
cygwin proc.
* shared_info.h (mount_info): Add 'cb' element for sanity checks.
(shared_info): Ditto.
* child_info.h (child_info): Add fhandler_union_size element for sanity
checking.
* shared.cc (open_shared): Detect shared region size mismatch between parent
and child.
(shared_info::initialize): Detect shared region size mismatch with expectation.
(memory_Init): Ditto.
* sigproc.cc (init_child_info): Correctly set cb in passed structure.
* shared.cc (open_shared):
@
text
@d929 1
d945 5
d954 1
a954 1
			 str = shared_name (str, p->dwProcessId));
d956 1
a956 1
      if (h == NULL)
d959 1
a959 1
	    set_errno (ESRCH);
d961 2
a962 2
	    set_errno (EPERM);
	  return NULL;
a965 5
  if (!h)
    {
      system_printf ("can't %s %s, %E", p ? "open" : "create", str);
      set_errno (ESRCH);
    }
@


1.100
log
@* Makefile.in: Autogenerate some header files which provide magic numbers.
Force dependencies for files which depend on autogenerated headers to ensure
that they are always built.
* child_info.h (child_info): Add new fields to accommodate new magic number
header stuff.
* dcrt0.cc: Rely on "child_info_magic.h" to ensure that correct child_info
magic numbers are used.
(dll_crt0_1): Temporarily remove _cygwin_testing_magic test.
(_dll_crt0): Do more testing on magic numbers from fork_info structure.  Call
"multiple_cygwin_problem" where appropriate.
(multiple_cygwin_problem): Rename from multiple_cygwin_die.  Issue a warning or
die, as appropriate based on cygwin version/magic number mismatch.
* pinfo.cc (pinfo::exit): Don't attempt to dereference `this' if it doesn't
exist.  This can happen when a fatal error occurs early in process
initialization.
* shared.cc: Rely on "shared_info_magic.h" to accommodate that new magic number
header stuff.
(shared_info::initialize): Use new magic number stuff, for shared region.
(memory_init): Ditto, for mount table.
* shared_info.h: Accomodate new magic number stuff for shared region and mount
table.
* sigproc.cc: Rely on "child_info_magic.h" to accommodate new magic number
header stuff.
(init_child_info): Initialize new fields in child_info) to accomodate magic
numbers.
* winsup.h: Rename multiple_cygwin_die to multiple_cygwin_problem.
* include/cygwin/version.h: Define macros for manipulating version magic.
* cygmagic: New shell script for generating magic numbers.
@
text
@d860 1
a860 1
  ch->cb = sizeof *ch;
d867 1
@


1.99
log
@* dll_init.h (class dll_list): Reorder functions to avoid compiler "can't
inline" warnings.
* security.h (class cygsid): Ditto.
* sigproc.cc (get_proc_lock): Ditto.
* sigproc.h (class sigframe): Ditto.
* sync.h (class muto): Ditto.
* fhandler.h (fhandler_base::get_guard): Actually MAKE virtual as previously
indicated.
* pipe.cc (make_pipe): Remove extraneous set_errno.
* syscalls.cc (_open): Ditto.
* select.cc (peek_pipe): Need to check that there is still something to read
from the pipe after acquiring the mutex since another process/thread could have
eaten the input before we got to acquiring the lock.  (Thanks to Nick Duffek
for this inspiration.)
@
text
@d29 1
a29 1
#include "child_info.h"
d861 2
@


1.98
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d182 23
a962 23
}

/* Get the sync_proc_subproc muto to control access to
 * children, zombie arrays.
 * Attempt to handle case where process is exiting as we try to grab
 * the mutex.
 */
static BOOL
get_proc_lock (DWORD what, DWORD val)
{
  Static int lastwhat = -1;
  if (!sync_proc_subproc)
    return FALSE;
  if (sync_proc_subproc->acquire (WPSP))
    {
      lastwhat = what;
      return TRUE;
    }
  if (!sync_proc_subproc)
    return FALSE;
  system_printf ("Couldn't aquire sync_proc_subproc for(%d,%d), %E, last %d",
		  what, val, lastwhat);
  return TRUE;
@


1.97
log
@* sigproc.cc (sigproc_terminate): Don't signal main thread when exiting.
* sigproc.h (sigframe): Decorate some methods with `inline'.
(new_muto): Coerce pointer to new to void *.
@
text
@d902 1
a902 1
      int wait = 10000;
@


1.96
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d615 1
a615 1
      SetEvent (signal_arrived);
@


1.95
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@d26 1
@


1.95.2.1
log
@Merged changes from HEAD
@
text
@a25 1
#include "path.h"
@


1.95.2.2
log
@Merged changes from HEAD
@
text
@d29 1
a29 1
#include "child_info_magic.h"
a181 23
/* Get the sync_proc_subproc muto to control access to
 * children, zombie arrays.
 * Attempt to handle case where process is exiting as we try to grab
 * the mutex.
 */
static BOOL
get_proc_lock (DWORD what, DWORD val)
{
  Static int lastwhat = -1;
  if (!sync_proc_subproc)
    return FALSE;
  if (sync_proc_subproc->acquire (WPSP))
    {
      lastwhat = what;
      return TRUE;
    }
  if (!sync_proc_subproc)
    return FALSE;
  system_printf ("Couldn't aquire sync_proc_subproc for(%d,%d), %E, last %d",
		  what, val, lastwhat);
  return TRUE;
}

d615 1
a615 1
      // SetEvent (signal_arrived);
d837 1
a837 3
  ch->cb = chtype == PROC_FORK ? sizeof (child_info_fork) : sizeof (child_info);
  ch->intro = PROC_MAGIC_GENERIC;
  ch->magic = CHILD_INFO_MAGIC;
a841 1
  ch->fhandler_union_cb = sizeof (fhandler_union);
d902 1
a902 1
      int wait = 1000;
d940 23
@


1.95.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a928 1
      /* Wait for new process to generate its semaphores. */
a943 5
      if (!h)
	{
	  system_printf ("can't create semaphore %s, %E", str);
	  __seterrno ();
	}
d948 1
a948 1
			 shared_name (str, p->dwProcessId));
d950 1
a950 1
      if (!h)
d953 1
a953 1
	    set_errno (ESRCH);	/* No such process */
d955 2
a956 2
	    set_errno (EPERM);	/* Couldn't access the semaphore --
				   different cygwin DLL maybe? */
d960 5
d1192 1
a1192 1
		  int wasdispatched = sig_handle (sig, rc != 2);
@


1.95.2.4
log
@Merged changes from HEAD
@
text
@d231 1
a231 1
  return p && !(p->process_state & PID_EXITED);
@


1.95.2.5
log
@Merged changes from HEAD
@
text
@d106 1
a106 1
Static char cpchildren[PSIZE * sizeof (pinfo)];		// All my children info
d108 1
a108 1
Static char czombies[NZOMBIES * sizeof (pinfo)];		// All my deceased children info
a110 3
#define pchildren ((pinfo *) cpchildren)
#define zombies ((pinfo *) czombies)

d318 2
a319 2
			  pchildren[val]->pid, val, hchildren[val], pchildren[val]->hProcess);
	  HANDLE h = hchildren[val];
a320 2
	  sync_proc_subproc->release ();	// Release the lock ASAP
	  ForceCloseHandle1 (h, childhProc);
d323 1
a323 1
	  goto out;			// This was an exec()
d590 1
a590 1
  new_muto (sync_proc_subproc);
d942 2
a943 2
      h = CreateSemaphore (sec_user_nih (sa_buf), init, max,
			   str = shared_name (str, winpid));
d1185 1
a1185 1
		/* Internal signal to turn on stracing. */
d1187 1
a1187 1
		  strace.hello ();
@


1.95.2.6
log
@Merged changes from HEAD
@
text
@d32 1
d1122 1
a1122 1
      ForceCloseHandle1 (child_proc_info->subproc_ready, subproc_ready);
@


1.95.2.7
log
@Merged changes from HEAD
@
text
@a32 1
#include "cygthread.h"
d95 2
a96 2
Static cygthread *hwait_sig;		// Handle of wait_sig thread
Static cygthread *hwait_subproc;	// Handle of sig_subproc thread
d462 1
d465 9
a473 1
      hwait_subproc->detach ();
d475 1
d583 7
a589 1
  hwait_sig = new cygthread (wait_sig, NULL, "sig");
d618 1
d640 23
d850 2
a851 1
  hwait_subproc = new cygthread (wait_subproc, NULL, "proc");
d853 2
a854 1
  sigproc_printf ("started wait_subproc thread %p", (HANDLE) *hwait_subproc);
d1077 1
a1077 1
  (void) SetThreadPriority (*hwait_sig, WAIT_SIG_PRIORITY);
@


1.95.2.8
log
@Merged changes from HEAD
@
text
@d574 1
a574 1
  hwait_sig = new cygthread (wait_sig, cygself, "sig");
a830 1
  ch->mount_h = cygwin_mount_h;
d1033 1
a1033 1
wait_sig (VOID *self)
d1036 1
a1036 1
  (void) SetThreadPriority (*((cygthread *) self), WAIT_SIG_PRIORITY);
@


1.95.2.9
log
@Merged changes from HEAD
@
text
@a19 1
#include <assert.h>
d170 2
a171 2
void __stdcall
wait_for_sigthread ()
d173 10
a182 4
  assert (wait_sig_inited);
  (void) WaitForSingleObject (wait_sig_inited, INFINITE);
  (void) ForceCloseHandle (wait_sig_inited);
  wait_sig_inited = NULL;
d213 1
a213 1
      assert (!wait_sig_inited);
d538 1
a538 1
      assert (!wait_sig_inited);
d660 1
a660 1
      assert (!wait_sig_inited);
@


1.95.2.10
log
@Merged changes from HEAD
@
text
@d83 1
a83 1
Static HANDLE sigcatch_nonmain;		// The semaphore signaled when
d86 1
a86 1
Static HANDLE sigcatch_main;		// Signalled when main thread sends a
d88 1
a88 1
Static HANDLE sigcatch_nosync;		// Signal wait_sig to scan sigtodo
d91 1
a91 1
Static HANDLE sigcomplete_main;		// Event signaled when a signal has
d94 1
a94 1
Static HANDLE sigcomplete_nonmain;	// Semaphore raised for non-main
a96 1
HANDLE NO_COPY sigCONT;			// Used to "STOP" a process
d100 1
a100 1
Static HANDLE wait_sig_inited;		// Control synchronization of
d105 1
a105 1
Static HANDLE events[PSIZE + 1];	  // All my children's handles++
d108 1
a108 1
Static int nchildren;			// Number of active children
d110 1
a110 1
Static int nzombies;			// Number of deceased children
a1050 1
  sigCONT = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
@


1.95.2.11
log
@Merged changes from HEAD
@
text
@d110 1
a110 1
Static char czombies[(NZOMBIES + 1) * sizeof (pinfo)];		// All my deceased children info
@


1.95.2.12
log
@Merged changes from HEAD
@
text
@d464 1
a464 1
      sync_proc_subproc->acquire (WPSP);
d477 1
a477 1
	  zombies[i].release ();	// FIXME: this breaks older gccs for some reason
d567 1
a567 1
  signal_arrived = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
@


1.94
log
@* dcrt0.cc (dll_crt0_1): Create vfork main storage here so that it can be
queried in waitsig later.
* sigproc.cc (wait_sig): Don't deliver a signal if in a vfork.
* fork.cc (vfork): Deliver all signals on parent return from vfork.
@
text
@d822 1
a822 1
  if (!(hwait_subproc = makethread (wait_subproc, NULL, 0, "+proc")))
@


1.93
log
@* sigproc.cc (NZOMBIES): Reduce substantially to minimize memory use.
@
text
@d29 1
d1165 1
@


1.92
log
@* fork.cc (fork_parent): Stop malloc activity while fork is in control of the
heap.
* sigproc.cc (NZOMBIES): Rename from ZOMBIEMAX for clarity.
(zombies): Revert to original behavior.  Allocating zombie array resulted in
performance hit.
* winsup.h: Declare malloc lock routines.
@
text
@d49 1
a49 1
#define NZOMBIES	4096
@


1.91
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d49 1
a49 1
#define ZOMBIEMAX	4096
d102 1
a102 1
Static HANDLE events[PSIZE + 1] = {0};	// All my children's handles++
d106 2
a107 2
static pinfo *zombies;			// All my deceased children info
static int nzombies;			// Number of deceased children
d321 1
a321 1
      if (nzombies >= ZOMBIEMAX
a545 5
  if (!zombies)
    zombies = (pinfo *) malloc (sizeof (pinfo) * ZOMBIEMAX);
  else
    nzombies = 0;

@


1.90
log
@* cygheap.h (init_cygheap): Move bucket array here from cygheap.cc.
* cygheap.cc: Throughout use bucket array from cygheap.
* sigproc.cc (proc_subproc): Dynamically allocate zombie buffer to save DLL
space.
(sigproc_fixup_after_fork): Free zombie array after a fork.
* sigproc.h (sigproc_fixup_after_fork): Declare.
* dir.cc (mkdir): Expand buffer for security descriptor to 4K to avoid stack
corruption.
* fhandler.cc (fhandler_base::open): Ditto.
* path.cc (symlink): Ditto.
@
text
@a305 2
      if (!zombies)
	zombies = (pinfo *) malloc (sizeof (pinfo) * ZOMBIEMAX);
d546 5
a1307 11
}

void __stdcall
sigproc_fixup_after_fork ()
{
  if (zombies)
    {
      free (zombies);
      nzombies = 0;
      zombies = NULL;
    }
@


1.89
log
@* cygwin.sc: Revert to previous NO_COPY behavior.
* winsup.h: Ditto.
* sigproc.cc: Ditto.
* autoload.cc: Ditto.
@
text
@d49 1
a49 1
#define ZOMBIEMAX	((int) (sizeof (zombies) / sizeof (zombies[0])) - 1)
a104 1
Static pinfo zombies[16384];		// All my deceased children info
d106 2
a107 1
Static int nzombies = 0;		// Number of deceased children
d306 2
d1305 11
@


1.88
log
@* cygwin.sc: New file -- linker script for building cygwin DLL.
* Makefile.in: Use linker script to control location of cygheap.
* cygheap.cc (buckets): Make static.
(init_cheap): Remove special iswinnt handling.  Allocate cygheap at a fixed
location.  Display more info when allocation fails.
(cygheap_fixup_in_child): Try harder to move cygheap to correct location.
Display more info when allocation fails.
* fhandler.h (fhandler_socket): Add macros for tracking socket shutdown state.
* net.cc (cygwin_shutdown): Set appropriate shutdown value for future use.
* select.cc (select_stuff::cleanup): New method.
(cygwin_select): Call cleanup explicitly to avoid a race.
(select_stuff:~select_stuff): Call cleanup chain via cleanup method.
(fhandler_socket::select_read): Set *_ready when shutdown has been called on
the socket.
(fhandler_socket::select_write): Ditto.
(fhandler_socket::select_except): Ditto.
* winsup.h: Move NO_COPY to "COMMON" section.
* autoload.cc (wsock_started): Avoid initializing NO_COPY value.
* sigproc.cc: Remove initialization from NO_COPY variables.
(sigproc_init): Initialize sig_loop_wait here, rather than via initialization.
(subproc_init): Initialize proc_loop_wait here, rather than via initialization.
@
text
@d77 2
a78 2
Static DWORD proc_loop_wait;		// Wait for subprocesses to exit
Static DWORD sig_loop_wait;		// Wait for signals to arrive
d80 1
a80 1
Static HANDLE sigcatch_nonmain;		// The semaphore signaled when
d83 1
a83 1
Static HANDLE sigcatch_main;		// Signalled when main thread sends a
d85 1
a85 1
Static HANDLE sigcatch_nosync;		// Signal wait_sig to scan sigtodo
d88 1
a88 1
Static HANDLE sigcomplete_main;		// Event signaled when a signal has
d91 1
a91 1
Static HANDLE sigcomplete_nonmain;	// Semaphore raised for non-main
d94 2
a95 2
Static HANDLE hwait_sig;		// Handle of wait_sig thread
Static HANDLE hwait_subproc;		// Handle of sig_subproc thread
d97 1
a97 1
Static HANDLE wait_sig_inited;		// Control synchronization of
d102 1
a102 1
Static HANDLE events[PSIZE + 1];	// All my children's handles++
d109 1
a109 1
Static waitq waitq_head;		// Start of queue for wait'ing threads
d112 1
a112 1
muto NO_COPY *sync_proc_subproc;	// Control access to subproc stuff
d114 1
a114 1
DWORD NO_COPY sigtid;			// ID of the signal thread
d116 1
a116 1
int NO_COPY pending_signals;		// TRUE if signals pending
a545 1
  sig_loop_wait = INFINITE;
a816 1
  proc_loop_wait = 1000;
@


1.87
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d77 2
a78 2
Static DWORD proc_loop_wait = 1000;	// Wait for subprocesses to exit
Static DWORD sig_loop_wait = INFINITE;	// Wait for signals to arrive
d80 1
a80 1
Static HANDLE sigcatch_nonmain = NULL;	// The semaphore signaled when
d83 1
a83 1
Static HANDLE sigcatch_main = NULL;	// Signalled when main thread sends a
d85 1
a85 1
Static HANDLE sigcatch_nosync = NULL;	// Signal wait_sig to scan sigtodo
d88 1
a88 1
Static HANDLE sigcomplete_main = NULL;	// Event signaled when a signal has
d91 1
a91 1
Static HANDLE sigcomplete_nonmain = NULL;// Semaphore raised for non-main
d94 2
a95 2
Static HANDLE hwait_sig = NULL;		// Handle of wait_sig thread
Static HANDLE hwait_subproc = NULL;	// Handle of sig_subproc thread
d97 1
a97 1
Static HANDLE wait_sig_inited = NULL;	// Control synchronization of
d102 1
a102 1
Static HANDLE events[PSIZE + 1] = {0};	// All my children's handles++
d109 1
a109 1
Static waitq waitq_head = {0, 0, 0, 0, 0, 0, 0};// Start of queue for wait'ing threads
d112 1
a112 1
muto NO_COPY *sync_proc_subproc = NULL;	// Control access to subproc stuff
d114 1
a114 1
DWORD NO_COPY sigtid = 0;		// ID of the signal thread
d116 1
a116 1
int NO_COPY pending_signals = 0;	// TRUE if signals pending
d546 1
d818 1
@


1.86
log
@* child_info.h: Bump magic number.
(class child_info): Add an element.
* cygheap.cc (init_cheap): Allocate cygwin heap in shared memory area.
(cygheap_fixup_in_child): Map cygwin heap, passed from parent via shared memory
into correct address.
(cygheap_setup_for_child): New function.
* cygheap.h: Declare new functions.
* dcrt0.cc (dll_crt0_1): Accomodate new cygheap_fixup_in_child arguments.
Avoid protecting subproc_ready unless it is spawn/nowait.
* fork.cc (fork_parent): Use new cygheap_setup_for_child function to setup
cygwin heap info.  Close passed cygheap shared memory handle.
* spawn.cc (spawn_guts): Ditto.  Also, reorganize to avoid synchronization
between parent and child in non-P_OVERLAY case.
* sigproc.cc (wait_sig): Only signal subproc_ready when execing.
@
text
@d24 1
a31 1
#include "security.h"
@


1.85
log
@forced commit
@
text
@d1106 1
a1106 2
  if (child_proc_info &&
      (child_proc_info->type == PROC_EXEC || child_proc_info->type == PROC_SPAWN))
@


1.84
log
@* exceptions.cc (interrupt_setup): Move actions from setup_handler to here.
(setup_handler): Move actions after a successful interrupt to interrupt_setup.
* fork.cc (vfork): Augment debugging output.
* sigproc.cc (proc_subproc): Ditto.
* spawn.cc (spawn_guts): Ditto.  Correctly fill out progname when spawn
NO_WAIT.  Call signal handler when a signal arrives.
* sigproc.h: Declare a function.
@
text
@@


1.83
log
@* pinfo.cc: Use autoloaded ToolHelp functions throughout for Win9x.
* autoload.cc: Autoload ToolHelp functions.
@
text
@d309 1
a309 1
      sigproc_printf ("removing [%d], pid %d, handle %p, nchildren %d",
@


1.82
log
@* exceptions.cc (sigdelayed): Ensure that signal is cleared as the last
operation or suffer races.
* sigproc.cc (proc_subproc): Deal with zombie array overflow.
@
text
@d49 1
a49 1
#define ZOMBIEMAX	((int) (sizeof (zombies) / sizeof (zombies[0])))
d303 6
a308 7
      if (nzombies >= ZOMBIEMAX)
	sigproc_printf ("Hit zombie maximum %d", nzombies);
      else
	{
	  zombies[nzombies] = pchildren[val];	// Add to zombie array
	  zombies[nzombies++]->process_state = PID_ZOMBIE;// Walking dead
	}
d316 12
@


1.81
log
@Revert much of previous erroneous checkin.  Add ChangeLog entry.

* pinfo.h: Correctly set __SIGOFFSET.
* path.cc (hash_path_name): Avoid calling library functions for simple copying
of characters.
* shortcut.c: Use WIN32_LEAN_AND_MEAN.
* smallprint.c: Ditto.
* environ.cc (getwinenv): Minor clarity fix.
* localtime.c: No need to include windows.h
* string.h: New file.
@
text
@d49 2
d105 1
a105 1
Static pinfo zombies[PSIZE];		// All my deceased children info
d303 7
a309 2
      zombies[nzombies] = pchildren[val];	// Add to zombie array
      zombies[nzombies++]->process_state = PID_ZOMBIE;// Walking dead
@


1.80
log
@* exceptions.cc (ctrl_c_handler): Always send signal to process if it has no
tty.
@
text
@d476 1
a476 1
  (void) ilockexch (myself->getsigtodo (sig), 0L);
d699 1
a699 1
  (void) ilockincr (p->getsigtodo (sig));
d786 1
a786 1
  (void) ilockincr (myself->getsigtodo (sig));
d1140 1
a1140 1
	  while (ilockdecr (myself->getsigtodo (sig)) >= 0)
d1174 1
a1174 1
		  ilockdecr (myself->getsigtodo (sig));
d1181 1
a1181 1
	  if (ilockincr (myself->getsigtodo (sig)) > 0)
@


1.79
log
@* exceptions.cc (handle_exceptions): Break out of "loop" if the debugger
doesn't seem to be attaching to our process.
@
text
@d476 1
a476 1
  (void) InterlockedExchange (myself->getsigtodo (sig), 0L);
d699 1
a699 1
  (void) InterlockedIncrement (p->getsigtodo (sig));
d786 1
a786 1
  (void) InterlockedIncrement (myself->getsigtodo (sig));
d1140 1
a1140 1
	  while (InterlockedDecrement (myself->getsigtodo (sig)) >= 0)
d1174 1
a1174 1
		  InterlockedDecrement (myself->getsigtodo (sig));
d1181 1
a1181 1
	  if (InterlockedIncrement (myself->getsigtodo (sig)) > 0)
@


1.78
log
@* thread.cc (thread_init_wrapper): Use _REENT_INIT to initialize the reent
structure of newlib.
* sigproc.h (sig_send): Add exception parameter to sig_send.
* sigproc.cc (sig_send): Ditto.  Use it when setting frame info.
* exceptions.cc (handle_exceptions): Use exception flag when calling sig_send.
@
text
@d1147 1
a1147 1
		  (sig != SIGCONT && ISSTATE (myself, PID_STOPPED))))
d1175 1
a1175 1
		  goto nextsig;
@


1.77
log
@* sigproc.h [sigthread]: Add exception field.
[sigframe::~sigframe]: Clear exception field.
[sigframe::set]: Set exception field from caller.
* sigproc.cc (sig_send): Set exception field when frame pointer is passed in.
* exceptions.cc (interrupt_on_return): Always treat exception as interruptible.
@
text
@d634 1
a634 1
sig_send (_pinfo *p, int sig, DWORD ebp)
d683 1
a683 1
	  thisframe.set (mainthread, ebp, 1);
@


1.76
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d683 1
a683 1
	  thisframe.set (mainthread, ebp);
@


1.75
log
@* sigproc.h (class sigframe): Implement 'unregister()' method.
(sigframe::~sigframe): Use unregister method.
(sigframe::call_signal_handler): Declare new method.
* exceptions.cc (sigframe::call_signal_handler): New method.  Unregisters
current sigframe before calling signal handler.
(setup_handler): Clear waiting threads prior to arming signal_arrived.
* syscalls.cc (_read): Change goto to loop.  Recalculate sigframe inside of
loop so that constructor is called when appropriate.
* wait.cc (wait4): Ditto.
* signal.cc: Change "sig" to "signal" in debugging messages throughout.
* sigproc.cc: Ditto.
@
text
@d24 2
@


1.74
log
@* shortcut.c (PATH_ALL_EXEC): Add parentheses to avoid a compiler warning.
* exceptions.cc (setup_handler): Clarify debugging message.
* sigproc.cc (proc_subproc): Remove PROC_CHILDSTOPPED test.  It is handled by
normal PROC_CLEARWAIT case.
(wait_sig): Eliminate "dispatched" tracking.  Remove __SIGCHILDSTOPPED test.
Decrement counter again before jumping out of InterlockedDecrement loop so that
subsequent InterlockedIncrement will keep the counter at the correctly
decremented value and also detect when there are pending signals.
* sigproc.h: Remove __SIGCHILDSTOPPED element.
(procstuff): Remove PROC_CHILDSTOPPED element.
@
text
@d739 1
a739 1
      sigproc_printf ("Not waiting for sigcomplete.  its_me %d sig %d", its_me, sig);
d768 1
a768 1
	system_printf ("wait for sig_complete event failed, sig %d, rc %d, %E",
d1147 1
a1147 1
		  sigproc_printf ("sig %d blocked", sig);
@


1.73
log
@* sigproc.cc (getsem): Make semaphore always non-inheritable.
@
text
@a311 9
    /* A child is in the stopped state.  Scan wait() queue to see if anyone
     * should be notified.  (Called from wait_sig thread)
     */
    case PROC_CHILDSTOPPED:
      child = myself;		// Just to avoid accidental NULL dereference
      sigproc_printf ("Received stopped notification");
      clearing = 0;
      goto scan_wait;

d474 1
a474 1
  (void) InterlockedExchange (myself->getsigtodo(sig), 0L);
d697 1
a697 1
  (void) InterlockedIncrement (p->getsigtodo(sig));
d784 1
a784 1
  (void) InterlockedIncrement (myself->getsigtodo(sig));
a1127 1
      int dispatched = FALSE;
d1138 1
a1138 1
	  while (InterlockedDecrement (myself->getsigtodo(sig)) >= 0)
a1163 8
		/* Signalled from a child process that it has stopped */
		case __SIGCHILDSTOPPED:
		  sigproc_printf ("Received child stopped notification");
		  dispatched |= sig_handle (SIGCHLD);
		  if (proc_subproc (PROC_CHILDSTOPPED, 0))
		    dispatched |= 1;
		  break;

a1167 1
		  dispatched |= wasdispatched;
d1170 3
d1176 2
d1179 1
a1179 1
	  if (InterlockedIncrement (myself->getsigtodo(sig)) > 0)
a1180 2
	nextsig:
	  continue;
d1183 1
a1183 2
      /* FIXME: The dispatched stuff probably isn't needed anymore. */
      if (dispatched >= 0 && pending_signals < 0 && !saw_pending_signals)
d1186 1
a1186 1
      if (nzombies && saw_sigchld && !dispatched_sigchld)
d1188 1
d1196 1
a1204 1

@


1.72
log
@* fork.cc (fork_parent): Return EAGAIN when can't record pid.
* pinfo.h (pinfo::remember): Return value of call to proc_subproc.
* sigproc.cc (proc_subproc): Return error if can't record pid.
@
text
@d902 1
a902 1
      h = CreateSemaphore (allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
@


1.71
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d249 4
a252 1
	system_printf ("nchildren too large %d", nchildren);
@


1.70
log
@* autoload.cc (LoadDLLinitfunc): Remove debugging statement.
* exceptions.cc (sig_handle_tty_stop): Move setting of PID_STOPPED to earlier
in interrupt.
((interrupt_setup): i.e., here.
(sig_handle): Don't queue multiple SIGSTOPS.
* fhandler.h (bg_check_types): Enumerate return value of bg_check for clarity.
* signal.cc (kill_pgrp): Minor cleanup.
* fhandler_termios.cc (fhandler_termios::bg_check): Use enumerated type for
function return.  Don't raise signal if a signal is already queued.
* fhandler_console.cc (fhandler_console::read): Use enumerated return type for
bg_check.
* select.cc: Ditto, throughout.
* read.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
(_read): YA interrupt detect simplification.
* wait.cc (wait4): Ditto.
@
text
@a823 2
  ch->shared_h = cygwin_shared_h;
  ch->console_h = console_shared_h;
@


1.69
log
@* debug.h: Add regparm attributes to some functions.
* signal.cc (sigaction): Don't treat SIGCONT specially.
* exceptions.cc (interrupt_setup): Save sa_flags of interrupted signal for
later use.
(sig_handler): Default any stopping signal to SIGSTOP.
(call_signal_handler): New function.
(sigdelayed0): New function.
* sigproc.cc (sigproc_init): Initialize SIGSTOP sigaction for special behavior.
* sigproc.h: Define call_signal_handler.
* syscalls.cc (_read): Allow restartable signal behavior.
@
text
@d1153 2
a1154 2
		  (sigismember (& myself->getsigmask (), sig) ||
		  (sig != SIGCONT && myself->process_state & PID_STOPPED)))
@


1.68
log
@* sigproc.cc (wait_sig): Allow SIGCONT when stopped.
@
text
@d565 1
@


1.67
log
@* pinfo.cc (codepage_init): Move function.
* environ.cc (codepage_init): To here.
* exceptoins.cc (SIG_NONMASKABLE): Remove SIGCONT from consideration since it
is supposed to be maskable.
* signal.cc (sigaction): Ditto.
* sigproc.cc (wait_sig): Ditto.
* winsup.h: Eliminate global declaration of codepage_init.
@
text
@d1153 1
a1153 1
		   myself->process_state & PID_STOPPED))
@


1.66
log
@* sigproc.cc (wait_sig): Remove unneeded for loop iteration.
* exceptions.cc (interrupt_setup): Don't set signal mask here or races occur
with main thread.  Set it in sigdelayed instead.
(sigreturn): Reflect change in stack order of ebp and flags.
(sigdelayed): Set stack frame correctly.  Call set_process_mask here with flags
for last trapped signal.
(signal_dispatch): Add newmask.
* sigproc.cc (wait_sig): Eliminate ill-considered attempt to halt looping
signal processors.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000 Cygnus Solutions.
d1151 1
a1151 1
	      if (sig > 0 && sig != SIGCONT && sig != SIGKILL && sig != SIGSTOP &&
@


1.65
log
@        * cygheap.h: Move `token' and `impersonated' from class _pinfo
        to class cygheap_user.
        * pinfo.h: Ditto.
        * fork.cc (fork_child): Change usage of `token' and `impersonated'
        accordingly.
        (fork_parent): Ditto.
        * security.cc (cygwin_set_impersonation_token): Ditto.
        * sigproc.cc (proc_subproc): Ditto.
        * spawn.cc (spawn_guts): Ditto.
        * syscalls.cc (seteuid): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
@
text
@d73 2
a74 2
Static DWORD proc_loop_wait = 500;	// Wait for subprocesses to exit
Static DWORD sig_loop_wait = 500;	// Wait for signals to arrive
d1112 1
a1112 1
  for (int i = 0; ; i++)
d1199 1
a1199 12
	{
	  pending_signals = 0;
	  /* FIXME FIXME FIXME FIXME FIXME
	     This is a real kludge designed to handle runaway processes who
	     missed a signal and never processed a signal handler.  We have
	     to reset signal_arrived or stuff goes crazy. */
	  if (i >= 20)
	    {
	      i = 0;
	      ResetEvent (signal_arrived);
	    }
	}
@


1.64
log
@Throughout use myself->ppid_handle rather than parent_alive.
* child_info.h (child_info): Eliminate parent_alive.
* dcrt0.cc (dll_crt0_1): Call fork_init for debugging pid creation.
* fork.cc (fork_child): Reflect change to fixup_mmaps_after_fork arguments.
(slow_pid_reuse): New function to grab last 'n' pids to prevent pid reuse.
(fork_parent): Move last_fork_proc into slow_pid_reuse.  Handle fork_pids
debugging.  Eliminate unnecessary call to set_child_mmap_ptr.
(fork_init): New debugging function.
* mmap.cc (fixup_mmaps_after_fork): Renamed from recreate_mmaps_after_fork.
Rely on copied data after a fork.
(set_child_mmap_ptr): Eliminate.
* pinfo.h (_pinfo): Eliminate parent_alive, mmap_ptr and reflect above changes.
* spawn.cc (spawn_guts): Eliminate vestiges of "old way" of sending new hProc
to parent process.
@
text
@a265 2
      vchild->impersonated = myself->impersonated;
      vchild->token = myself->token;
@


1.63
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d131 1
a131 1
  if (!parent_alive)
d133 1
a133 1
      debug_printf ("No parent_alive mutex");
d138 1
a138 1
      switch (res = WaitForSingleObject (parent_alive, 0))
d152 2
a153 2
	    system_printf ("WFSO for parent_alive(%p) failed, error %d",
			   parent_alive, werr);
d307 2
a820 1
  subproc_init ();
a828 5
  if (chtype != PROC_EXEC || !parent_alive)
    ch->parent_alive = hwait_subproc;
  else
    DuplicateHandle (hMainProc, parent_alive, hMainProc, &ch->parent_alive,
		     0, 1, DUPLICATE_SAME_ACCESS);
@


1.62
log
@* cygheap.h (init_cygheap): New struct holding values that live in the Cygwin
heap.
* child_info.h (child_info): Change pointer type of cygheap to init_cygheap.
* cygheap.cc (init_cheap): Point cygheap_max after contents of cygheap.  Move
some stuff into cygheap.h.
* dir.cc (opendir): Change to use root and rootlen in cygheap rather than in
myself.
(mkdir): Change to use umask in cygheap rather than in myself.
* path.cc: Ditto, throughout.
* syscalls.cc (_open): Ditto.  Change to use umask in cygheap rather than in
myself.
(chroot): Change to allocate root dir on the cygwin heap.
(umask): Change to use umask in cygheap rather than in myself.
(cygwin_bind): Ditto.
* sigproc.cc (proc_subproc): Don't copy umask or root stuff as this happens
automatically now.
* pinfo.h (_pinfo): Migrate stuff out of here and into init_cheap.
* dcrt0.cc (dll_crt0_1): Call cygheap_init later in startup for first cygwin
process.
@
text
@a265 4
      vchild->orig_uid = myself->orig_uid;
      vchild->orig_gid = myself->orig_gid;
      vchild->real_uid = myself->real_uid;
      vchild->real_gid = myself->real_gid;
a266 7
      if (myself->use_psid)
        {
          vchild->use_psid = 1;
          memcpy (vchild->psid, myself->psid, MAX_SID_LEN);
        }
      memcpy (vchild->logsrv, myself->logsrv, MAX_HOST_NAME);
      memcpy (vchild->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
@


1.61
log
@* dcrt0.cc (sigthread::init): Reinstitute sigthread lock as a critical section.
(dll_crt0_1): Move sigthread lock initialization to earlier in startup.
* exceptions.cc (interrupt_on_return): Remove previous kludgy attempt to detect
an invalid frame.
(call_handler): Eliminate inner for loop.  Grab signal critical section lock
where appropriate.
* sigproc.cc (proc_subproc): Restore uid setting.
* sigproc.h (sigthread): Reinstitute sigthread lock as a critical section.
(sigframe): Grab the sigthread lock before clearing frame to avoid having the
signal thread use an invalid frame.
@
text
@a265 1
      vchild->umask = myself->umask;
a277 1
      memcpy (vchild->root, myself->root, MAX_PATH+1);
a278 1
      vchild->rootlen = myself->rootlen;
@


1.60
log
@* child_info.h (child_info): Add pppid_handle for closing the parent's of the
parent handle.
* dcrt0.cc (_dll_crt0): Close parent's parent handle when spawned or forked.
* debug.cc (add_handle): Correct erroneous reference to handle structure when
printing warning.
* exceptions.cc (interrupt_now): Always return 1.
(interrupt_on_return): Accept a sigthread argument.  Check to see if this
argument has been trashed prior to setting up the stack return.
(call_handler): Add a loop around attempts to dispatch signals to detect case
where interrupt_on_return fails.
(_sigdelayed): Set up a temporary frame pointer prior to calling stuff that
could trigger an interrupt or the stack walking code will be very confused.
* fork.cc (fork_parent): Move a lot of the setup of the child process into
proc_subproc.
* spawn.cc (spawn_guts): Ditto.  Use ppid_handle to contact logical parent when
reparenting.
* pinfo.h (_pinfo): Remember the logical handle of the parent process.
* sigproc.cc (proc_subproc): Record most stuff necessary for the _pinfo
structure that is inferrable from myself when adding children.
(wait_sig): Always set 'pending_signals' flag when about to kick off the signal
scanning loop.  Reset it only if there are no pending signals.
@
text
@d261 1
@


1.59
log
@* pinfo (wait_subproc): Son of neverending debug tweaking.
@
text
@d238 1
a238 1
      sigproc_printf ("I am not ready");
d256 27
d840 1
d1131 1
a1131 1
  for (;;)
d1159 2
a1160 1
      pending_signals = 0;
d1211 1
a1211 1
	    pending_signals = 1;
d1216 15
a1248 2
      if (dispatched < 0)
	pending_signals = 1;
a1302 1
		Sleep (10000);
@


1.58
log
@* pinfo (wait_subproc): Neverending debug tweaking.
@
text
@d1252 2
d1258 1
a1258 1
		system_printf ("pid %d, dwProcessId %u, progname '%s'",
d1260 2
a1261 1
			       pchildren[i - 1]->progname);
@


1.57
log
@* exceptions.cc (handle_sigsuspend): Record frame here for signalling.
(set_process_mask): Ditto.
@
text
@d1255 1
a1255 1
			       nchildren, i, events[i], i, (_pinfo *) pchildren[i], events[0]);
d1257 2
a1258 2
			       pchildren[i]->pid, pchildren[i]->dwProcessId,
			       pchildren[i]->progname);
@


1.56
log
@* sigproc.cc (wait_subproc): Still more debugging cleanup.
@
text
@d265 5
a269 6
     * Possibly this is just due to an exec().  Cygwin implements an exec()
     * as a "handoff" from one windows process to another.  If child->hProcess
     * is different from what is recorded in hchildren, then this is an exec().
     * Otherwise this is a normal child termination event.
     * (called from wait_subproc thread)
     */
@


1.55
log
@* pinfo.cc (EnumProcessesNT): Avoid 0 pids.
(EnumProcesses9x): Ditto.
* sigproc.cc (remove_childe): Eliminate.
(proc_subproc): Move remove_child stuff here.
(wait_subproc): Synchronize with proc_subproc when error occurs.  Add more
debugging info.
* sigproc.h (procstuff): Add an entry.
* spawn.cc (spawn_guts): Add sigframe here.
@
text
@d1249 1
a1249 1
	  for (int i = 0; i < nchildren + 1; i++)
d1255 2
a1256 2
		system_printf ("nchildren %d, event[%d] %p, pchildren[%d] %p, %E",
			       nchildren, i, events[0], i, (_pinfo *) pchildren[i]);
@


1.54
log
@* sigproc.cc (wait_subproc): Refine debug output.
@
text
@a118 1
static void __stdcall remove_child (int);
d287 7
a293 1
      remove_child (val);		// Remove from children array
a941 17
/* Remove a child from pchildren/hchildren by swapping it with the
 * last child in the list.
 */
static void __stdcall
remove_child (int ci)
{
  sigproc_printf ("removing [%d], pid %d, handle %p, nchildren %d",
	      ci, pchildren[ci]->pid, hchildren[ci], nchildren);
  if (ci < --nchildren)
    {
      pchildren[ci] = pchildren[nchildren];
      hchildren[ci] = hchildren[nchildren];
    }

  return;
}

d1241 3
a1243 1
	  if (++errloop < 10)
d1255 4
a1258 3
		system_printf ("event[%d] %p, pchildren[%d] %p, %E", i, i, pchildren[i]);
		system_printf ("pid %d, dwProcessId %u, progname '%s'", i,
			       events[0], pchildren[i]->pid, pchildren[i]->dwProcessId,
@


1.53
log
@* pinfo.cc (pinfo::init): Reverse order of setting status and pid info in an
execed process to avoid a race.
* sigproc.cc (wait_subproc): Print more info when a WFSO error occurs.
* automode.c: New file.
* syscalls.cc (close_all_files): Streamline slightly.
* cygheap.cc (ccalloc): Clear *entire* allocated array.
@
text
@d1264 6
a1269 3
	      system_printf ("event[%d] %p, pid %d, dwProcessId %u, progname '%s', %E", i,
			     events[0], pchildren[i]->pid, pchildren[i]->dwProcessId,
			     pchildren[i]->progname);
@


1.52
log
@* sigproc.cc (wait_sig): Add braces to avoid confusion.
@
text
@d1253 1
a1253 1
	  if (++errloop < 10 && GetLastError () == ERROR_INVALID_HANDLE)
d1264 3
a1266 1
	      system_printf ("event[%d] %p, %E", i, events[0]);
@


1.51
log
@* sigproc.cc (proc_subproc): Don't send a false positive if WNOHANG and no
processes are available for waiting.
@
text
@d1124 6
a1129 4
	if (!sig_loop_wait)
	  break;			// Exiting
	else
	  continue;
@


1.50
log
@* sigproc.cc (proc_subproc): Correctly handle flags for WNOHANG case.
@
text
@d361 1
a361 1
	      else if (!(w->next->options & WNOHANG))
@


1.49
log
@* exceptions.cc (call_handler): Make signal pending if sigsave.sig is still
active.
* syscalls.cc (_read): Don't clear errno.
* sigproc.cc (wait_sig): Don't scan the waiting process list after a SIGCHLD if
there are no zombies to reap.
* winsup.h: Use __builtin_strcmp.
* environ.cc (posify): Don't initialize len unless it is required
(from DJ Delorie <dj@@redhat.com>).
@
text
@d361 1
a361 1
	      else
d1007 1
a1007 1
      (w->options & WUNTRACED) && child->stopsig)
@


1.48
log
@* sigproc.cc (proc_subproc): Remove unneeded test for correct process in
PROC_ADDCHILD.  Return 0 when terminated child has just been reparented.
(wait_subproc): Only send SIGCHLD when proc_subproc returns != 0.
* strace.cc (strace::vsprntf): Only strip .exe extension from program name.
@
text
@d1198 1
a1198 1
      if (saw_sigchld && !dispatched_sigchld)
@


1.47
log
@* debug.cc (add_handle): Issue warning on attempts to add the same handle more
than once.
* fhandler_tty.cc (fhandler_tty_slave::open): Protect some handles.
(fhandler_tty_common::close): Use proper name when closing handles.
(fhandler_pty_master::close): Don't close to_slave or from_slave since they've
already been closed earlier in the function.
* sigproc.cc (proc_subproc): Don't protect vchild->hProcess.  Expect that the
caller will do this, instead.
* tty.cc (tty_list::terminate): Use proper name when closing handles.
(tty::make_pipes): Protect some handles.
@
text
@a250 8
      if (WaitForSingleObject (vchild->hProcess, 0) != WAIT_TIMEOUT)
	{
	  system_printf ("invalid process handle %p.  pid %d, win pid %d",
			vchild->hProcess, vchild->pid, vchild->dwProcessId);
	  rc = 0;
	  break;
	}

a272 1
      rc = 0;
d280 1
d1270 1
a1270 1
	  (void) proc_subproc (PROC_CHILDTERMINATED, rc);
d1274 5
a1278 2
	  /* Send a SIGCHLD to myself. */
	  rc = sig_send (myself_nowait, SIGCHLD);
@


1.46
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@a260 1
      ProtectHandle1 (vchild->hProcess, childhProc);
@


1.45
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@a458 1

a460 1
      #if 1
a461 11
      #else
      /* Attempt to close and release sync_proc_subproc in a
       * non-raceable manner.
       */
      muto *m = sync_proc_subproc;
      if (m)
	{
	  sync_proc_subproc = NULL;
	  // delete m;
	}
      #endif
@


1.44
log
@* cygheap.cc (cygheap_fixup_in_child): Don't page round cygheap copied from
parent.
* dcrt0.cc (do_exit): Don't cleanup pinfo on exit.  That happens automatically
now.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_parent): Use stack_here value passed in from fork().
(fork): Figure out top of stack here and pass it to fork_parent.
* pinfo.cc (_pinfo::record_death): Eliminate.
* pinfo.h (_pinfo): Ditto.
* sigproc.cc (proc_exists): Simplify.
(proc_terminate): Ditto.
(remove_zombie): Don't cleanup pinfo stuff.
(wait_sig): Send subproc_ready signal whether execed or spawned.
* spawn.cc (spawn_guts): Always create subproc_ready event.  Use it for both
exec and spawn.
(_spawnve): Send proper mode to spawn_guts when mode != _P_OVERLAY.
@
text
@d100 2
a101 2
Static pinfo pchildren[PSIZE] = {pinfo ()};// All my children info
Static pinfo zombies[PSIZE] = {pinfo ()};	// All my deceased children info
d198 1
a198 2
/* Test to determine if a process really exists and is processing
 * signals.
d203 1
a203 6
  HANDLE h;

  if (p == NULL)
    return FALSE;
  else
    return TRUE;
d263 1
a263 1
		     0, 0, DUPLICATE_SAME_ACCESS))
a297 5
      if (!proc_loop_wait)		// Don't bother if wait_subproc is
	break;				//  exiting

      /* Send a SIGCHLD to myself. */
      rc = sig_send (myself_nowait, SIGCHLD);	// Send a SIGCHLD
d437 1
a437 1
	  zombies[i]->process_state = PID_NOT_IN_USE;	/* CGF FIXME - still needed? */
a443 2
	  if (pchildren[i]->process_state == PID_NOT_IN_USE)
	    continue;		// Should never happen
d586 4
a589 4
      ForceCloseHandle (sigcomplete_nonmain);
      ForceCloseHandle (sigcatch_main);
      ForceCloseHandle (sigcatch_nonmain);
      ForceCloseHandle (sigcatch_nosync);
d600 3
a602 1
      sig_dispatch_pending (TRUE);	// wake up and die
d607 1
a607 1
      if (hwait_sig)
a612 2
	  /* In case of a sigsuspend */
	  SetEvent (signal_arrived);
d626 1
d630 1
d1120 1
a1120 1
      (child_proc_info->type == PROC_FORK || child_proc_info->type == PROC_SPAWN))
a1135 7
  /* If we got something like a SIGINT while we were initializing, the
     signal thread should be waiting for this event.  This signals the
     thread that it's ok to send the signal since the wait_sig thread
     is now active. */
  extern HANDLE console_handler_thread_waiter;
  SetEvent (console_handler_thread_waiter);

d1291 8
a1298 1
	(void)proc_subproc (PROC_CHILDTERMINATED, rc);
a1318 1
if (dwMilliseconds > 10 && ret == WAIT_TIMEOUT) system_printf ("TIMED OUT %d\n", dwMilliseconds);
a1329 1
if (dwMilliseconds > 10 && ret == WAIT_TIMEOUT) system_printf ("TIMED OUT %d\n", dwMilliseconds);
@


1.43
log
@* child_info: Bump child_info "version".
(child_info): Move some fields from child_info_spawn to here.
* cygheap.cc: Make cygheap pointers NOCOPY.
* dcrt0.cc (dll_crt0_1): Copy cygwin heap here regardless of whether we've been
forked or execed.
* dtable.cc (dtable::fixup_after_fork): Just release close-on-exec fds.
* exceptions.cc (stackdump): Respond to C warning.
* fork.cc: Reorganize to minimize stack copying.
(fork_child): New function.
(fork_parent): Ditto.
(sync_with_child): Don't suspend the forkee.
(sync_with_parent): Ditto.  Make into a function.
* heap.cc (heap_init): Add some debugging output.
* path.cc (path_conv::check): Add an assertion.
(has_suffix): Ditto.
* security.cc (get_pw_sid): Defend against NULL.
* sigproc.cc (proc_subproc): Fix debugging output.
(wait_sig): Ditto.
* strace.cc: Make statics NO_COPY throughout.
(strace::vsprntf): Defend against NULL.
@
text
@d208 1
a208 2

  if (p == myself || p == myself_nowait_nonmain || p == myself_nowait)
a209 39

  if (p->process_state == PID_NOT_IN_USE || !p->dwProcessId)
    return FALSE;

  sigproc_printf ("checking for existence of pid %d, window pid %d", p->pid,
	      p->dwProcessId);
  if (p->ppid == myself->pid && p->hProcess != NULL)
    {
      sigproc_printf ("it's mine, process_state %x", p->process_state);
      return proc_can_be_signalled (p);
    }

  /* Note: Process is alive if OpenProcess() call fails due to permissions */
  if (((h = OpenProcess (STANDARD_RIGHTS_REQUIRED, FALSE, p->dwProcessId))
      != NULL) || (GetLastError () == ERROR_ACCESS_DENIED))
    {
      sigproc_printf ("it exists, %p", h);
      if (h)
	{
	  DWORD rc = WaitForSingleObject (h, 0);
	  CloseHandle (h);
	  if (rc == WAIT_OBJECT_0)
	    return 0;
	}
      return proc_can_be_signalled (p);
    }

  sigproc_printf ("it doesn't exist");
#if 0
  /* If the parent pid does not exist, clean this process out of the pinfo
   * table.  It must have died abnormally.
   */
  if ((p->pid == p->ppid) || (p->ppid == 1) || !pid_exists (p->ppid))
    {
      p->hProcess = NULL;
      p->process_state = PID_NOT_IN_USE;
    }
#endif
  return FALSE;
d463 1
a463 3
	      if (!proc_exists (pchildren[i]))
		{
		  sigproc_printf ("%d(%d) doesn't exist", pchildren[i]->pid,
d465 3
a467 10
		  pchildren[i]->process_state = PID_NOT_IN_USE;	/* a reaped child  CGF FIXME -- still needed? */
		}
	      else
		{
		  sigproc_printf ("%d(%d) closing active child handle", pchildren[i]->pid,
			      pchildren[i]->dwProcessId);
		  pchildren[i]->ppid = 1;
		  if (pchildren[i]->pgid == myself->pid)
		    pchildren[i]->process_state |= PID_ORPHANED;
		}
d469 1
a469 1
	  pchildren[i].release (); // FIXME: this breaks older gccs for some reason
d555 1
a623 8
	  /* Exiting thread.  Cleanup.  Don't set to inactive if a child has been
	     execed with the same pid. */
	  if (!myself->dwProcessId || myself->dwProcessId == GetCurrentProcessId ())
	    myself->process_state &= ~PID_ACTIVE;
	  else
	    sigproc_printf ("Did not clear PID_ACTIVE since %d != %d",
			myself->dwProcessId, GetCurrentProcessId ());

a998 1
      zombies[ci]->process_state = PID_NOT_IN_USE;	/* a reaped child */
d1130 2
a1131 1
  if (child_proc_info && child_proc_info->type == PROC_EXEC)
d1330 1
d1342 1
@


1.42
log
@* dtable.cc (set_std_handle): Use std_consts array to control SetStdHandle
settings.
(dtable::fixup_after_fork): Ditto.
* exceptions.cc (set_sig_errno): Remove some debugging output.
* path.cc (path_conv::check): Don't OR need_directory with flags sent to
symlink_info::check.
(symlink_info::check): Use PATH_ALL_EXEC to determine when a file is
executable.
* path.h (path_types): Add PATH_ALL_EXEC.
(isexec): Use PATH_ALL_EXEC so that cygexec types will be considered
executable.
* pinfo.h (_pinfo): Add a process handle that is kept open throughout the life
of a cygwin pid.
* sigproc.cc (proc_exists): Remove hopefully obsolete stuff.
(proc_subproc): Set up process handle that is kept open throughout the life of
a cygwin pid.  Reorganize PROC_WAIT stuff to use common code.
(proc_terminate): Close pid lifetime process handle.
(checkstate): Cleanup.
(stopped_or_terminated): Move zombie cleanup.
(remove_zombie): To here.
* spawn.cc (spawn_guts): Reorganize reparenting code for 1247th time.
@
text
@a307 1
      nchildren++;
d315 1
d1166 1
a1166 1
  sigproc_printf ("sigcatch_nonmain %p", sigcatch_nonmain);
@


1.41
log
@* exceptions.cc (interruptible): Add extra debugging.
* sigproc.h (wait_sig): Fill in frame pointer, by default, prior to calling or
suffer confusion due to September 7 change below.
@
text
@d239 1
d248 1
d308 5
a316 1
      nchildren++;
d360 32
d412 1
a412 1
	  else if (!clearing && potential_match < 0)
d418 1
a438 69

    /* Handle a wait4() operation.  Allocates an event for the calling
     * thread which is signaled when the appropriate pid exits or stops.
     * (usually called from the main thread)
     */
    case PROC_WAIT:
      wval->ev = NULL;		// Don't know event flag yet

      if (wval->pid <= 0)
	child = NULL;		// Not looking for a specific pid
      else if (!mychild (wval->pid))
	goto out;		// invalid pid.  flag no such child

      wval->status = 0;		// Don't know status yet

      /* Put waitq structure at the end of a linked list. */
      for (w = &waitq_head; w->next != NULL; w = w->next)
	if (w->next == wval && (w->next = w->next->next) == NULL)
	  break;

      wval->next = NULL;	/* This will be last in the list */
      sigproc_printf ("wval->pid %d, wval->options %d", wval->pid, wval->options);

      /* If the first time for this thread, create a new event, otherwise
       * reset the event.
       */
      if ((wval->ev = wval->thread_ev) == NULL)
	{
	  wval->ev = wval->thread_ev = CreateEvent (&sec_none_nih, TRUE,
						    FALSE, NULL);
	  ProtectHandle (wval->ev);
	}
      ResetEvent (wval->ev);

      /* Scan list of children to see if any have died.
       * If so, the event flag is set so that the wait* ()
       * process will return immediately.
       *
       * If no children were found and the wait option was WNOHANG,
       * then set the pid to 0 and remove the waitq value from
       * consideration.
       */
      w->next = wval;		/* set at end of wait queue */
      if ((potential_match = checkstate (w)) <= 0)
	{
	  if (!potential_match)
	    {
	      w->next = NULL;		// don't want to keep looking
	      wval->ev = NULL;		// flag that there are no children
	      sigproc_printf ("no appropriate children, %p, %p",
			  wval->thread_ev, wval->ev);
	    }
	  else if (wval->options & WNOHANG)
	    {
	      w->next = NULL;		// don't want to keep looking
	      wval->pid = 0;		// didn't find a pid
	      if (!SetEvent (wval->ev))	// wake up wait4 () immediately
		system_printf ("Couldn't wake up wait event, %E");
	      sigproc_printf ("WNOHANG and no terminated children, %p, %p",
			  wval->thread_ev, wval->ev);
	    }
	}
      if (w->next != NULL)
	sigproc_printf ("wait activated %p, %p", wval->thread_ev, wval->ev);
      else if (wval->ev != NULL)
	sigproc_printf ("wait activated %p.  Reaped zombie.", wval->ev);
      else
	sigproc_printf ("wait not activated %p, %p", wval->thread_ev, wval->ev);
      break;
d486 1
a486 1
	      zombies[i]->hProcess = NULL;
a502 1
	      pchildren[i]->hProcess = NULL;
d909 1
a909 1
checkstate (waitq *w)
d911 1
a911 2
  int i, x, potential_match = 0;
  _pinfo *child;
d918 2
a919 4
  for (i = 0; i < nzombies; i++)
    if ((x = stopped_or_terminated (w, child = zombies[i])) < 0)
      potential_match = -1;
    else if (x > 0)
d921 4
d933 2
a934 4
  for (i = 0; i < nchildren; i++)
    if ((x = stopped_or_terminated (w, pchildren[i])) < 0)
      potential_match = -1;
    else if (x > 0)
d936 4
d941 1
a941 1
	break;
d1049 1
a1049 1
	      nzombies);
d1052 6
a1057 1
    zombies[ci].release ();
a1125 3
	  ForceCloseHandle1 (child->hProcess, childhProc);
	  child->hProcess = NULL;
	  child->process_state = PID_NOT_IN_USE;	/* a reaped child */
@


1.40
log
@* exceptions.cc (handle_exceptions): Just "core dump" if SIGSEGV in signal
thread.
* external.cc (fillout_pinfo): Fix compiler warning.
* sigproc.h: Eliminate special asm naming for sig_dispatch_pending.
* sigproc.cc (sig_send): Remove debugging statements.
@
text
@d1273 1
@


1.39
log
@* sigproc.h (sigframe::set): Eliminate second argument.  Default bp to current
frame pointer rather than using this within the function, which is unstable
when this method is not inlined.
* net.cc: Eliminate use of second argument to sigframe.set throughout.
* select.cc (cygwin_select): Ditto.
* sigproc.cc (sig_send): Ditto.
@
text
@a817 1
sigproc_printf ("ReleaseSemaphore failed, %E");
a834 1
sigproc_printf ("ReleaseSemaphore succeeded");
@


1.38
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d788 1
a788 1
	  thisframe.set (mainthread, 1, ebp);
@


1.37
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d19 1
a27 1
#include "tty.h"
d29 1
@


1.36
log
@* sigproc.cc: Add include file for proper definitions.
* spawn.cc: Ditto.
* winsup.h: Define cfree to avoid newlib pollution.
@
text
@d27 2
@


1.35
log
@* sigproc.cc (mychild): New function.
(proc_subproc): Use mychild() to determine if a specific pid is valid for
wait()ing.
@
text
@d23 1
@


1.34
log
@* sigproc.cc (sigproc_init): Create wait_sig_inited without auto-reset to avoid
potential races.
(init_child_info): Avoid unneeded test.
@
text
@d25 1
a25 2

extern BOOL allow_ntsec;
d246 15
a268 1
  DWORD exitcode;
d319 1
a319 2
      if (GetExitCodeProcess (hchildren[val], &exitcode) &&
	  hchildren[val] != pchildren[val]->hProcess)
d406 1
a406 1
      else if (!pid_exists (wval->pid)) /* CGF FIXME -- test that this is one of mine */
d610 1
a610 1
 
@


1.33
log
@* sigproc.cc (proc_info): Rename proc_exists which takes a pid to "pid_exists".
* shared.h: Split out "child_info" stuff into a new header file and use where
necessary.  Declare pid_exists.
* child_info.h: New file.
@
text
@d613 1
a613 1
  wait_sig_inited = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d917 1
a917 1
  else if (parent_alive)
@


1.32
log
@* pinfo.h (pinfo): Un-inline release.
* pinfo.cc (pinfo::release): Move here from pinfo.h.
* sigproc.cc (proc_terminate): Remove bogus 'pinfo child' which caused strange
destruction of random regions of memory when destructor was invoked.
@
text
@d23 1
d189 1
a189 1
proc_exists (pid_t pid)
d239 1
a239 1
  if ((p->pid == p->ppid) || (p->ppid == 1) || !proc_exists (p->ppid))
d394 1
a394 1
      else if (!proc_exists (wval->pid)) /* CGF FIXME -- test that this is one of mine */
@


1.31
log
@* dcrt0.cc (dll_crt0_1): Move set_os_type.
(_dll_crt0): To here.
(cygwin_dll_init): And here.
* external.cc (fillout_pinfo): Use more foolproof method for scanning for pids.
* pinfo.cc (set_myself): Eliminate myself_identity.init.
* sigproc.cc (wait_sig): Do it here instead to reduce the amount of time where
there could potentially be two processes with the same pid.
* spawn.cc (spawn_guts): Eliminate duplicate initialization.
* include/sys/cygwin.h: Mark unused PID_* elements.
@
text
@d502 1
a502 1
	  // zombies[i].release();	// FIXME: this breaks older gccs for some reason
a507 1
	  pinfo child; /* CGF FIXME */
d532 1
a532 1
	  // pchildren[i].release (); // FIXME: this breaks older gccs for some reason
@


1.30
log
@* external.cc (cygwin_internal): Add CW_INIT_EXCEPTIONS to allow cygwin
exception handling on threads not created by cygwin.
* sigproc.cc (proc_terminate): Don't release pinfo structs since we are
exiting.
* include/sys/cygwin.h: Add CW_INIT_EXCEPTIONS.
@
text
@d1205 5
@


1.29
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d502 1
a502 1
	  zombies[i].release();
d533 1
a533 1
	  pchildren[i].release ();
d537 5
d549 1
a549 1
	  delete m;
d551 1
@


1.28
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d19 3
d23 1
a23 1
#include "cygerrno.h"
@


1.27
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d20 1
@


1.26
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d19 1
@


1.25
log
@* strace.h: Add kludgy workarounds to avoid using deprecated methods for
variable argument macros when possible.
* sigproc.cc: Throughout, use sigproc_printf rather than sip_printf.
* strace.cc (strace::prntf): Remove 'active' check, since callers are supposed
to ensure this.
(__system_printf): Remove.  Subsumed by strace::prntf.
* winsup.h: Define "NEW_MACRO_VARARGS" to indicate when to use new macro
varargs capability.
@
text
@d13 1
a18 1
#include "winsup.h"
@


1.24
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@a33 2
#define sip_printf(fmt, args...) sigproc_printf (fmt , ## args)

d206 1
a206 1
  sip_printf ("checking for existence of pid %d, window pid %d", p->pid,
d210 1
a210 1
      sip_printf ("it's mine, process_state %x", p->process_state);
d218 1
a218 1
      sip_printf ("it exists, %p", h);
d229 1
a229 1
  sip_printf ("it doesn't exist");
d256 1
a256 1
  sip_printf ("args: %x, %d", what, val);
d260 1
a260 1
      sip_printf ("I am not ready");
d283 1
a283 1
      sip_printf ("added pid %d to wait list, slot %d, winpid %p, handle %p",
d303 1
a303 1
	  sip_printf ("pid %d[%d], reparented old hProcess %p, new %p",
d311 1
a311 1
      sip_printf ("pid %d[%d] terminated, handle %p, nchildren %d, nzombies %d",
d328 1
a328 1
      sip_printf ("Received stopped notification");
d339 1
a339 1
	sip_printf ("clear waiting threads");
d341 1
a341 1
	sip_printf ("looking for processes to reap");
d351 1
a351 1
	    sip_printf ("released waiting thread");
d353 1
a353 1
	    sip_printf ("only found non-terminated children");
d356 1
a356 1
	      sip_printf ("waiting thread found no children");
d371 1
a371 1
	sip_printf ("finished processing terminated/stopped child");
d375 1
a375 1
	  sip_printf ("finished clearing");
d399 1
a399 1
      sip_printf ("wval->pid %d, wval->options %d", wval->pid, wval->options);
d427 1
a427 1
	      sip_printf ("no appropriate children, %p, %p",
d436 1
a436 1
	      sip_printf ("WNOHANG and no terminated children, %p, %p",
d441 1
a441 1
	sip_printf ("wait activated %p, %p", wval->thread_ev, wval->ev);
d443 1
a443 1
	sip_printf ("wait activated %p.  Reaped zombie.", wval->ev);
d445 1
a445 1
	sip_printf ("wait not activated %p, %p", wval->thread_ev, wval->ev);
d452 1
a452 1
  sip_printf ("returning %d", rc);
d465 1
a465 1
  sip_printf ("nchildren %d, nzombies %d", nchildren, nzombies);
d507 1
a507 1
	    sip_printf ("%d(%d) hProcess cleared already?", pchildren[i]->pid,
d515 1
a515 1
		  sip_printf ("%d(%d) doesn't exist", pchildren[i]->pid,
d521 1
a521 1
		  sip_printf ("%d(%d) closing active child handle", pchildren[i]->pid,
d542 1
a542 1
  sip_printf ("leaving");
d564 1
a564 1
  sip_printf ("pending_signals %d", was_pending);
d568 1
a568 1
    sip_printf ("no need to wake anything up");
d579 1
a579 1
	sip_printf ("woke up wait_sig");
d584 1
a584 1
	/*sip_printf ("I'm going away now")*/;
d634 1
a634 1
  sip_printf ("process/signal handling enabled(%x)", myself->process_state);
d659 1
a659 1
    sip_printf ("sigproc_terminate: sigproc handling not active");
d681 1
a681 1
	    sip_printf ("Did not clear PID_ACTIVE since %d != %d",
d696 1
a696 1
      sip_printf ("done");
d740 1
a740 1
      sip_printf ("invalid pid %d(%x), signal %d",
d746 1
a746 1
  sip_printf ("pid %d, signal %d, its_me %d", p->pid, sig, its_me);
d800 1
a800 1
	    sip_printf ("I'm going away now");
d821 1
a821 1
      sip_printf ("Not waiting for sigcomplete.  its_me %d sig %d", its_me, sig);
d827 1
a827 1
      sip_printf ("Waiting for thiscomplete %p", thiscomplete);
d857 1
a857 1
  sip_printf ("returning %d from sending signal %d", rc, sig);
d887 1
a887 1
  sip_printf ("started wait_subproc thread %p", hwait_subproc);
d920 1
a920 1
  sip_printf ("nchildren %d, nzombies %d", nchildren, nzombies);
d935 1
a935 1
  sip_printf ("checking alive children");
d948 1
a948 1
  sip_printf ("returning %d", potential_match);
d967 1
a967 1
      sip_printf ("pid %d, ppid %d, wait %d, initializing %x", p->pid, p->ppid, wait,
d1011 1
a1011 1
static __inline__ BOOL
d1035 1
a1035 1
  sip_printf ("removing [%d], pid %d, handle %p, nchildren %d",
d1051 1
a1051 1
  sip_printf ("removing %d, pid %d, nzombies %d", ci, zombies[ci]->pid,
d1079 1
a1079 1
  sip_printf ("considering pid %d", child->pid);
d1102 1
a1102 1
	  sip_printf ("stopped child");
d1230 1
a1230 1
      sip_printf ("awake");
d1247 1
a1247 1
		  sip_printf ("sig %d blocked", sig);
d1252 1
a1252 1
	      sip_printf ("processing signal %d", sig);
d1266 1
a1266 1
		  sip_printf ("Received child stopped notification");
d1274 1
a1274 1
		  sip_printf ("Got signal %d", sig);
d1309 1
a1309 1
      sip_printf ("looping");
d1312 1
a1312 1
  sip_printf ("done");
d1320 1
a1320 1
  sip_printf ("starting");
d1361 1
a1361 1
      sip_printf ("looping");
d1366 1
a1366 1
  sip_printf ("done");
@


1.23
log
@* acconfig.h: Add support for NEWVFORK.
* config.h.in: Ditto.
* configure.in: Add --enable-vfork option.
* configure: Regenerate.
* dcrt0.cc (quoted): Detect and fix up quoted backslashes.
* sigproc.cc (proc_subproc): Correctly name handle of newly added child process
to avoid erroneous debugging messages about closing the wrong handle.
@
text
@d93 2
a94 2
Static pinfo *pchildren[PSIZE] = {NULL};// All my children info
Static pinfo *zombies[PSIZE] = {NULL};	// All my deceased children info
d111 1
a111 1
static HANDLE __stdcall getsem (pinfo *, const char *, int, int);
d115 1
a115 1
static int __stdcall stopped_or_terminated (waitq *, pinfo *);
d171 1
a171 1
proc_can_be_signalled (pinfo *p)
d184 7
d195 1
a195 1
proc_exists (pinfo *p)
d235 1
a235 1
  if ((p->pid == p->ppid) || (p->ppid == 1) || !proc_exists (procinfo (p->ppid)))
d245 1
a245 1
#define vchild ((pinfo *) val)
d252 1
a252 1
  pinfo *child;
a301 1
      child = pchildren[val];
d303 1
a303 1
	  hchildren[val] != child->hProcess)
d306 1
a306 1
		      child->pid, val, hchildren[val], child->hProcess);
d308 2
a309 2
	  hchildren[val] = child->hProcess; /* Filled out by child */
	  ProtectHandle1 (child->hProcess, childhProc);
d314 4
a317 4
		  child->pid, val, hchildren[val], nchildren, nzombies);
      remove_child (val);		// Remove from children arrays
      zombies[nzombies++] = child;	// Add to zombie array
      child->process_state = PID_ZOMBIE;// Walking dead
d390 1
a390 1
      else if ((child = procinfo (wval->pid)) == NULL)
a488 1
      lock_pinfo_for_update (INFINITE);
d493 1
a493 2
	  pinfo *child;
	  if ((child = zombies[i])->hProcess)
d495 2
a496 2
	      ForceCloseHandle1 (child->hProcess, childhProc);
	      child->hProcess = NULL;
d498 2
a499 1
	  child->process_state = PID_NOT_IN_USE;
d505 2
a506 2
	  pinfo *child;
	  if ((child = pchildren[i])->process_state == PID_NOT_IN_USE)
d508 3
a510 3
	  if (!child->hProcess)
	    sip_printf ("%d(%d) hProcess cleared already?", child->pid,
			child->dwProcessId);
d513 3
a515 3
	      ForceCloseHandle1 (child->hProcess, childhProc);
	      child->hProcess = NULL;
	      if (!proc_exists (child))
d517 3
a519 3
		  sip_printf ("%d(%d) doesn't exist", child->pid,
			      child->dwProcessId);
		  child->process_state = PID_NOT_IN_USE;	/* a reaped child */
d523 5
a527 5
		  sip_printf ("%d(%d) closing active child handle", child->pid,
			      child->dwProcessId);
		  child->ppid = 1;
		  if (child->pgid == myself->pid)
		    child->process_state |= PID_ORPHANED;
d530 1
a531 1
      unlock_pinfo ();
d714 1
a714 1
sig_send (pinfo *p, int sig, DWORD ebp)
d725 1
a725 1
    p = (tid == mainthread.id) ? myself : myself_nowait;
d896 1
a896 1
init_child_info (DWORD chtype, child_info *ch, int pid, HANDLE subproc_ready)
d920 1
a920 1
  pinfo *child;
d957 1
a957 1
getsem (pinfo *p, const char *str, int init, int max)
d1055 4
d1076 1
a1076 1
stopped_or_terminated (waitq *parent_w, pinfo *child)
d1108 1
a1108 1
      else
@


1.22
log
@* sigproc.h (sigframe::set): Accept a default frame pointer.
* sigproc.cc (sig_send): Use passed in frame pointer, if appropriate.
@
text
@d277 1
a277 1
      ProtectHandle (vchild->hProcess);
@


1.21
log
@* dcrt0.cc (dll_crt0_1): Initialize mainthread stuff here before anything needs
it.
* sigproc.cc (sigproc_init): Move mainthread initialization out of here.
* sigproc.h (sigthread): Add init() method.
(sigframe): Don't try to initialize muto.
* sync.cc: Undef WaitForSingleObject to avoid recursion.
@
text
@d758 1
a758 1
	  thisframe.set (mainthread);
@


1.20
log
@* path.cc (mount_info::cygdrive_posix_path): Don't add trailing slash if
referring to something like c:\.
* dcrt0.cc (dll_crt0_1): Move uinfo initialization prior to sig_send
initialization to give signal thread a chance to finish.
* debug.cc (WFSO): Move to sigproc.cc
(WFMO): Ditto.
* exceptions.cc (interruptible): Allocate slightly more space for directory
just for paranoia's sake.
(call_handler): Eliminate nonmain argument.  Determine if main thread has set a
frame pointer and use it if so.
(sig_handle): Eliminate nonmain argument.
* net.cc: Record frame information in appropriate routines throughout.
* select.cc (select): Ditto.
* sigproc.cc: Use sigthread structure to record mainthread id throughout.
(sig_send): Record frame information for signal handler.
(wait_sig): Reflect argument change in sig_handle.
(WFSO): Move here and record frame information for signal handler.
(WFMO): Ditto.
* sigproc.h: Implement new "sigthread" class.  Implement "sigframe" class for
manipulating signal frame info.
* thread.cc (__pthread_kill): Use standard _kill() function rather than calling
sig_send directly.
* winsup.h: Eliminate ebp element from signal_dispatch class.
@
text
@a102 1
sigthread NO_COPY mainthread;		// ID of the main thread
a604 3

  mainthread.id = GetCurrentThreadId ();// For use in determining if signals
				  //  should be blocked.
@


1.19
log
@* environ.cc: Add TMPDIR to the list of environment variables which are
converted to POSIX format.
* sigproc.cc (proc_terminate): Don't attempt to delete when a muto pointer is
NULL.
@
text
@a18 1
#include "sync.h"
d103 1
a103 1
DWORD NO_COPY maintid = 0;		// ID of the main thread
d607 1
a607 1
  maintid = GetCurrentThreadId ();// For use in determining if signals
d721 1
a721 1
  extern signal_dispatch sigsave;
d724 1
a724 1
    p = (tid == maintid) ? myself : myself_nowait;
d753 1
a753 1
      else if (tid != maintid)
d762 1
a762 1
	  sigsave.ebp = ebp ?: (DWORD) __builtin_frame_address (1);
d1264 1
a1264 1
		  dispatched |= sig_handle (SIGCHLD, rc);
d1272 1
a1272 1
		  int wasdispatched = sig_handle (sig, rc);
a1294 1
sigproc_printf ("signalled sigcomplete_main %p", sigcomplete_main);
a1297 1
sigproc_printf ("signalled sigcomplete_nonmain %p", sigcomplete_nonmain);
a1299 1
sigproc_printf ("Did not signal anyone");
d1365 26
@


1.18
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@d535 5
a539 2
      sync_proc_subproc = NULL;
      delete m;
@


1.17
log
@* fhandler_console.cc (fhandler_console::read): Don't even think about breaking
on interrupt if executing in a "cygwin" thread.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Streamline,
simplify code.
* sigproc.cc (sig_send): Remove debugging statement.
@
text
@d619 1
a619 1
  sync_proc_subproc = new_muto (FALSE, NULL);
@


1.16
log
@* sigproc.cc: Set wait_sig priority to normal.
@
text
@a828 1
Sleep (0);
@


1.15
log
@* sigproc.cc (wait_sig): Add addtional debugging output.
@
text
@d31 1
a31 1
#define WAIT_SIG_PRIORITY		THREAD_PRIORITY_HIGHEST
@


1.14
log
@* environ.cc: Eliminate oldstack CYGWIN option.
* exceptions.cc (sfta): Eliminate obsolete function.
(sgmb): Eliminate obsolete function.
(class stack_info): Remove MS method for walking the stack.
(stack_info::init): Just initialize required fields.
(stack_info::brute_force): Rename to stack_info::walk.
(handle_exceptions): Pass derived frame pointer to sig_send.
(interrupt_setup): Clear saved frame pointer here.
(interrupt_on_return): thestack is no longer a pointer.
(call_handler): Accept a flag to indicate when a signal was sent from other
than the main thread.  Use saved frame pointer for determining where to place
signal handler call.
(sig_handle): Accept "nonmain" argument.  Pass it to call_handler.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Change
debugging output slightly.
* (fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_tty_slave::read): Fix a comment, remove a goto.
* sigproc.cc (sig_send): Accept an optional frame pointer argument for use when
suspending the main process.  sigcomplete_main is an autoreset event now.  Save
frame pointer for non-main operation.
(wait_sig): Make sigcomplete_main an autoreset event.  Eliminate NOSIGQUEUE.
Pass rc to sig_handle to signify if this was a nonmain process.
* sigproc.h: Reflect change to sig_send argument.
* syscalls.cc (swab): Eliminate swab function since it is now available in
newlib.
* winsup.h (signal_dispatch): Change CONTEXT cx to DWORD ebp.
@
text
@d1294 1
a1294 1
sigproc_printf ("signalled sigcomplete_main");
d1298 1
a1298 1
sigproc_printf ("signalled sigcomplete_nonmain");
@


1.13
log
@* sigproc.cc (sig_send): Eliminate sync_sig_send synchronization since it
didn't seem to affect the "bash hangs" problem.
@
text
@d711 1
a711 1
sig_send (pinfo *p, int sig)
d719 1
d760 1
a760 1
	  ResetEvent (thiscomplete);
d1162 1
a1162 1
  sigcomplete_main = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
a1234 3
#ifdef NOSIGQUEUE
	  if (InterlockedExchange (myself->getsigtodo(sig), 0L) > 0)
#else
a1235 1
#endif
d1263 1
a1263 1
		  dispatched |= sig_handle (SIGCHLD);
d1271 1
a1271 1
		  int wasdispatched = sig_handle (sig);
a1277 1
#ifndef NOSIGQUEUE
a1280 1
#endif
@


1.12
log
@Throughout use strace class in place of individual functions and variables.
* cygwin.din: Eliminate _strace_wm.
* sigproc.cc (wait_sig): Temporarily add more debugging output.
* include/cygwin/version.h: Bump minor api to reflect export change.
@
text
@a102 1
muto NO_COPY *sync_sig_send = NULL;	// Control access to sig_send
a619 1
  sync_sig_send = new_muto (FALSE, NULL);
a772 1
  sync_sig_send->acquire ();
a819 1
      sync_sig_send->release ();
a827 1
      sync_sig_send->release ();
@


1.11
log
@* exceptions.cc (call_handler): Streamline to use only one call to
ResumeThread.
* sigproc.cc (sig_send): Use a muto around the ReleaseSemaphore.  Remove
priority setting since it didn't solve anything.
@
text
@d1265 1
a1265 1
		  // proc_strace ();	// Dump cached strace_printf stuff.
d1304 1
d1308 1
d1311 1
@


1.10
log
@* sigproc.cc (sig_send): Temporarily set priority to highest while sending a
signal.
@
text
@d102 2
a103 2
muto NO_COPY *sync_proc_subproc = NULL;	// Control access to
					//  subproc stuff
d621 1
d774 2
d782 3
a785 1
  SetLastError (0);
d788 2
d792 1
d810 1
d821 5
a825 4
    rc = WAIT_OBJECT_0;
    sip_printf ("Not waiting for sigcomplete.  its_me %d sig %d", its_me, sig);
    if (!its_me)
      ForceCloseHandle (thiscatch);
d832 2
d844 1
d846 1
@


1.9
log
@* pinfo.cc (set_myself): Add build date to strace output.
* sigproc.cc (proc_subproc): Only clear wait event when not attending to a
signal.
@
text
@d779 1
d781 2
d831 2
@


1.8
log
@* dcrt0.cc (set_os_type): Record OS name string.
(getprogname): Eliminate obsolete function.
(dll_crt0_1): Move initial strace initialization output to set_myself.
* exceptions.cc (interruptible): Add debugging output.
(interrupt_setup): New function.
(interrupt_now): Use interrupt_setup to set up common interrupt handler stuff.
(interrupt_on_return): Ditto.
(call_handler): Move signal_arrived arm and clear threads to region where
signalled thread is suspended or suffer races.
* pinfo.cc (set_myself): Output interesting information when strace is first
initialized.  Initialize progname here.
* sigproc.cc (sig_dispatch_pending): Modify to ensure that flush signal are
sent synchronously.
* strace.cc (strace_vsprintf): Move code into strace program.
* uname.cc (uname): Use 'osname' global to construct cygwin name + Windows type
+ version.
@
text
@a356 1
	      w->next->ev = NULL;
d359 2
@


1.7
log
@* exceptions.cc (interruptible): Make a little more structured.
(call_handler): Allow signals to be sent even if signalled thread is stopped.
Change order of signal_arrived arming/waiting threads clearing to eliminate a
race.
(reset_signal_arrived): New helper function.
* malloc.cc (malloc_init): Use mutos so that signal handler can keep track of
who owns the lock.
(__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* sync.h (new_muto): Actually use a muto for the "buffer".
* Makefile.in: Fix a dependency.
@
text
@d553 1
a553 1
sig_dispatch_pending (int force)
d562 1
a562 1
  if (!was_pending && !force)
d571 3
a573 1
      if (ReleaseSemaphore (sigcatch_nosync, 1, NULL))
d583 1
d964 1
a964 1
                           init, max, str = shared_name (str, winpid));
@


1.6
log
@* exceptions.cc (call_handler): Use new muto linked list to look for all
potential mutos owned by suspended thread.  Clear waiting threads while thread
is stopped.
(proc_subproc): Clarify debugging output.
* sync.h (class muto): Add 'next' field.
(new_muto): Keep linked list alive.
@
text
@d19 1
@


1.5
log
@Fix final round of gcc warnings relating to unused parameters.
* debug.cc (iscygthread): New function.
* debug.h: Declare it.
* exceptions.cc (set_process_mask): Flush pending signals.
(handle_sigsuspend): No need to flush pending signals.
(call_handler): Refine previous tests of muto ownership.  Only clear wait()'s
when we have definitely responded to a signal.
* fhandler_console.cc (fhandler_console::read): Don't set EINTR if executing in
a "cygwin" thread.
* sigproc.cc (proc_subproc): Use second argument to control whether CLEARWAIT
actually sets "signalled" flag.
* sync.h (muto): Add 'unstable' method.
@
text
@d336 4
a339 1
      sip_printf ("clear waiting threads");
@


1.4
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d105 1
a105 1
Static DWORD sigtid = 0;		// ID of the signal thread
d248 1
a248 1
  int clearing = 0;
d319 1
a319 1
      break;	// Don't try to unlock.  We don't have a lock.
d327 1
d337 1
a337 1
      clearing = 1;
a338 1
    case PROC_SIGCHLD:
d479 1
a479 1
      (void) proc_subproc (PROC_CLEARWAIT, 0);
d1208 2
d1218 2
d1254 2
a1255 3
		  if (sig == SIGCHLD && !wasdispatched)
		    proc_subproc (PROC_SIGCHLD, 0);
		  dispatched |= sig_handle (sig);
d1268 2
@


1.3
log
@Respond to more g++ warnings relating to initializing structures.
@
text
@a87 2
Static muto *sync_proc_subproc = NULL;	// Control access to
					//  subproc stuff
d101 3
d248 1
a248 1
  int send_sigchld = 0;
a287 8
    /* A child is in the stopped state.  Scan wait() queue to see if anyone
     * should be notified.  (Called from wait_sig thread)
     */
    case PROC_CHILDSTOPPED:
      child = myself;		// Just to avoid accidental NULL dereference
      sip_printf ("Received stopped notification");
      goto scan_wait;

a305 1
	  wake_wait_subproc ();
a312 2
      wake_wait_subproc ();		// Notify wait_subproc thread that
					//  nchildren has changed.
d317 11
a327 1
      send_sigchld = 1;
d329 10
d347 1
a347 1
	  else if (potential_match < 0)
d349 1
a349 1
	  else if (potential_match == 0)		// nothing matched
d354 2
d364 3
a366 18
      sip_printf ("finished processing terminated/stopped child");
      if (!send_sigchld)
	break;		// No need to send a SIGCHLD

      /* Send a SIGCHLD to myself. */
      sync_proc_subproc->release ();	// Avoid a potential deadlock
      rc = sig_send (NULL, SIGCHLD);	// Send a SIGCHLD
      goto out1;	// Don't try to unlock.  We don't have a lock.


    /* Clear all waiting threads.  Called from exceptions.cc prior to
     * the main thread's dispatch to a signal handler function.
     * (called from wait_sig thread)
     */
    case PROC_CLEARWAIT:
      /* Clear all "wait"ing threads. */
      sip_printf ("clear waiting threads");
      for (w = &waitq_head; w->next != NULL; w = w->next)
d368 2
a369 4
	  sip_printf ("clearing waiting thread, pid %d", w->next->pid);
	  w->next->status = -1;		/* flag that a signal was received */
	  if (!SetEvent (w->next->ev))
	    system_printf ("Couldn't wake up wait event, %E");
a370 2
      waitq_head.next = NULL;
      sip_printf ("finished clearing");
d1248 4
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d100 1
a100 1
Static waitq waitq_head = {0};		// Start of queue for wait'ing threads
@


1.1
log
@Initial revision
@
text
@d111 1
a111 1
static BOOL __inline get_proc_lock (DWORD, DWORD);
d995 1
a995 1
static BOOL __inline
d1126 1
a1126 1
wait_sig (VOID *arg)
d1295 1
a1295 1
wait_subproc (VOID *arg)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
