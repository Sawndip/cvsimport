head	1.96;
access;
symbols
	cygwin-1_7_35-release:1.96
	cygwin-1_7_34-release:1.96
	cygwin-1_7_33-release:1.93
	cygwin-1_7_32-release:1.93
	cygwin-1_7_31-release:1.93
	cygwin-1_7_30-release:1.93
	cygwin-1_7_29-release:1.93
	cygwin-1_7_29-release-branchpoint:1.93.0.2
	cygwin-pre-user-db:1.93
	cygwin-1_7_28-release:1.93
	cygwin-1_7_27-release:1.93
	cygwin-1_7_26-release:1.93
	cygwin-1_7_25-release:1.93
	cygwin-1_7_24-release:1.93
	cygwin-1_7_23-release:1.93
	cygwin-1_7_22-release:1.93
	cygwin-1_7_21-release:1.93
	cygwin-1_7_20-release:1.93
	cygwin-1_7_19-release:1.93
	cygwin-64bit-postmerge:1.93
	cygwin-64bit-premerge-branch:1.92.0.2
	cygwin-64bit-premerge:1.92
	cygwin-1_7_18-release:1.92
	post-ptmalloc3:1.87.2.8
	pre-ptmalloc3:1.87.2.8
	cygwin-1_7_17-release:1.90
	cygwin-64bit-branch:1.87.0.2
	cygwin-1_7_16-release:1.87
	cygwin-1_7_15-release:1.87
	cygwin-1_7_14_2-release:1.87
	cygwin-1_7_14-release:1.87
	cygwin-1_7_12-release:1.87
	cygwin-1_7_11-release:1.87
	cygwin-1_7_10-release:1.87
	signal-rewrite:1.86.0.2
	pre-notty:1.85
	cygwin-1_7_9-release:1.79
	cv-post-1_7_9:1.79.0.2
	cygwin-1_7_8-release:1.77
	cygwin-1_7_7-release:1.73
	cygwin-1_7_5-release:1.72
	cygwin-1_7_4-release:1.72
	cygwin-1_7_3-release:1.72
	cygwin-1_7_2-release:1.72
	fifo_doover3:1.72.0.2
	cygwin-1_7_1-release:1.72
	prefifo:1.72
	cv-branch-2:1.71.0.2
	pre-ripout-set_console_state_for_spawn:1.65
	EOL_registry_mounts:1.64
	preoverlapped:1.62
	drop_9x_support_start:1.62
	cr-0x5f1:1.61.0.8
	cv-branch:1.61.0.6
	pre-ptymaster-archetype:1.61
	cr-0x3b58:1.61.0.4
	cr-0x5ef:1.61.0.2
	after-mmap-privanon-noreserve:1.61
	after-mmap-revamp:1.61
	before-mmap-revamp:1.61
	cgf-more-exit-sync:1.61
	post_wait_sig_exit:1.60
	pre_wait_sig_exit:1.59
	reparent-point:1.45
	noreparent:1.45.0.2
	cr-0x5e6:1.43.0.2
	cr-0x9e:1.39.0.6
	cr-0x9d:1.39.0.4
	cgf-deleteme:1.39.0.2
	pre-sigrewrite:1.38
	corinna-01:1.38
	cr-0x9c:1.38.0.6
	cr-0x9b:1.38.0.4
	cr-0x99:1.38
	Z-emcb-cygwin_daemon:1.38.0.2
	w32api-2_2:1.30
	mingw-runtime-2_4:1.30
	pre-cgf-merge:1.38
	cgf-dev-branch:1.30.0.16
	predaemon:1.24
	cygwin_daemon_merge_HEAD:1.24
	pregp02r1:1.24.0.30
	cygnus_cvs_20020108_pre:1.24
	Z-cygwin_daemon_merge-new_HEAD:1.29
	Z-cygwin_daemon_merge_HEAD:1.29
	cygwin_daemon:1.23.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.96
date	2014.08.15.13.50.52;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2014.06.25.10.01.58;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2014.06.25.09.59.38;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2013.01.21.04.34.50;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.18.16.09.51;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2012.08.14.18.38.22;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2012.08.14.14.56.19;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2012.08.13.19.33.17;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2011.06.15.17.36.10;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2011.05.25.18.47.32;	author ericb;	state Exp;
branches;
next	1.83;

1.83
date	2011.05.23.20.43.06;	author ericb;	state Exp;
branches;
next	1.82;

1.82
date	2011.05.18.01.25.41;	author yselkowitz;	state Exp;
branches;
next	1.81;

1.81
date	2011.04.29.18.54.23;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2011.04.28.12.13.41;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2011.03.09.16.47.44;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2011.03.03.09.50.13;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2011.02.10.20.25.54;	author ericb;	state Exp;
branches;
next	1.76;

1.76
date	2011.02.10.17.36.51;	author ericb;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.19.09.15.17;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.24.12.41.33;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.16.15.42.29;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.14.23.42.08;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.15.13.46.56;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2009.01.16.12.17.27;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2009.01.11.16.13.11;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.19.23.29.24;	author ericb;	state Exp;
branches;
next	1.67;

1.67
date	2008.09.11.06.22.31;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.11.10.00.36;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2008.02.10.15.43.04;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2006.09.07.20.42.53;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.26.15.27.15;	author corinna;	state Exp;
branches
	1.61.8.1;
next	1.60;

1.60
date	2005.09.13.17.08.53;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.28.17.30.33;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.25.15.27.10;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.18.08.35.19;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.22.03.54.29;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.30.04.10.39;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.30.03.40.26;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.30.22.07.20;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.28.18.06.49;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.28.16.57.13;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.16.01.00.05;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.15.21.58.44;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.20.04.25.31;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.11.15.31.03;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.10.17.43.00;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.19.18.26.58;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.03.14.37.26;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.19.19.29.10;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.26.21.43.48;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.14.18.01.45;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.13.18.15.06;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.17.17.12.18;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.11.00.10.10;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.09.17.58.20;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.09.17.56.58;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.27.03.14.02;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.27.03.09.17;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.24.01.57.07;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.24.14.17.50;	author corinna;	state Exp;
branches
	1.30.16.1;
next	1.29;

1.29
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.01.23.42.04;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.21.05.47.09;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.05.18.11.20;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.06.24.22.26.50;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.14.19.39.57;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.12.21.21.37;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.03.18.20.38;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.18.03.34.05;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.22.14.51.16;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.22.12.56.36;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.06.16.13.44;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.12.04.38.29;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.31.20.07.53;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.02.19.26.01;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.26.09.17.08;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.09.10.14.17;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.06.03.33.10;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.03.16.11.11;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.20.40.07;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.05.33.09;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.87.2.1
date	2012.08.14.09.54.31;	author corinna;	state Exp;
branches;
next	1.87.2.2;

1.87.2.2
date	2012.08.14.17.16.55;	author corinna;	state Exp;
branches;
next	1.87.2.3;

1.87.2.3
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.87.2.4;

1.87.2.4
date	2012.10.31.17.00.07;	author corinna;	state Exp;
branches;
next	1.87.2.5;

1.87.2.5
date	2012.12.10.11.45.46;	author corinna;	state Exp;
branches;
next	1.87.2.6;

1.87.2.6
date	2013.01.18.16.23.59;	author corinna;	state Exp;
branches;
next	1.87.2.7;

1.87.2.7
date	2013.01.21.13.52.04;	author corinna;	state Exp;
branches;
next	1.87.2.8;

1.87.2.8
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	;

1.61.8.1
date	2006.10.16.12.46.34;	author corinna;	state Exp;
branches;
next	;

1.30.16.1
date	2003.02.11.03.13.08;	author cgf;	state Exp;
branches;
next	1.30.16.2;

1.30.16.2
date	2003.05.10.17.20.52;	author cgf;	state Exp;
branches;
next	1.30.16.3;

1.30.16.3
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.30.16.4;

1.30.16.4
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	;

1.23.4.1
date	2002.01.04.03.56.07;	author rbcollins;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2002.06.13.14.34.02;	author rbcollins;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2002.06.21.12.18.51;	author scottc;	state Exp;
branches;
next	1.23.4.4;

1.23.4.4
date	2002.07.02.10.58.17;	author scottc;	state Exp;
branches;
next	1.23.4.5;

1.23.4.5
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.96
log
@	* cygerrno.h (seterrno): Define as (always) inline function.
	* errno.cc (seterrno): Remove.
@
text
@/* errno.cc: errno-related functions

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#define _sys_nerr FOO_sys_nerr
#define sys_nerr FOOsys_nerr
#define _sys_errlist FOO_sys_errlist
#define strerror_r FOO_strerror_r
#define __INSIDE_CYGWIN__
#include <errno.h>
#include <error.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "winsup.h"
#include "cygtls.h"
#include "ntdll.h"
#undef _sys_nerr
#undef sys_nerr
#undef _sys_errlist
#undef strerror_r

/* Table to map Windows error codes to Errno values.  */
/* FIXME: Doing things this way is a little slow.  It's trivial to change
   this into a big case statement if necessary.  Left as is for now. */

#define X(w, e) {ERROR_##w, #w, e}

static const struct
{
  DWORD w;		 /* windows version of error */
  const char *s;	 /* text of windows version */
  int e;		 /* errno version of error */
} errmap[] =
{
  /* FIXME: Some of these choices are arbitrary! */
  X (ACCESS_DENIED,		EACCES),
  X (ACTIVE_CONNECTIONS,	EAGAIN),
  X (ALREADY_EXISTS,		EEXIST),
  X (BAD_DEVICE,		ENODEV),
  X (BAD_EXE_FORMAT,		ENOEXEC),
  X (BAD_NETPATH,		ENOENT),
  X (BAD_NET_NAME,		ENOENT),
  X (BAD_NET_RESP,		ENOSYS),
  X (BAD_PATHNAME,		ENOENT),
  X (BAD_PIPE,			EINVAL),
  X (BAD_UNIT,			ENODEV),
  X (BAD_USERNAME,		EINVAL),
  X (BEGINNING_OF_MEDIA,	EIO),
  X (BROKEN_PIPE,		EPIPE),
  X (BUSY,			EBUSY),
  X (BUS_RESET,			EIO),
  X (CALL_NOT_IMPLEMENTED,	ENOSYS),
  X (CANCELLED,			EINTR),
  X (CANNOT_MAKE,		EPERM),
  X (CHILD_NOT_COMPLETE,	EBUSY),
  X (COMMITMENT_LIMIT,		EAGAIN),
  X (CONNECTION_REFUSED,	ECONNREFUSED),
  X (CRC,			EIO),
  X (DEVICE_DOOR_OPEN,		EIO),
  X (DEVICE_IN_USE,		EAGAIN),
  X (DEVICE_REQUIRES_CLEANING,	EIO),
  X (DEV_NOT_EXIST,		ENOENT),
  X (DIRECTORY,			ENOTDIR),
  X (DIR_NOT_EMPTY,		ENOTEMPTY),
  X (DISK_CORRUPT,		EIO),
  X (DISK_FULL,			ENOSPC),
  X (DS_GENERIC_ERROR,		EIO),
  X (DUP_NAME,			ENOTUNIQ),
  X (EAS_DIDNT_FIT,		ENOSPC),
  X (EAS_NOT_SUPPORTED,		ENOTSUP),
  X (EA_LIST_INCONSISTENT,	EINVAL),
  X (EA_TABLE_FULL,		ENOSPC),
  X (END_OF_MEDIA,		ENOSPC),
  X (EOM_OVERFLOW,		EIO),
  X (EXE_MACHINE_TYPE_MISMATCH,	ENOEXEC),
  X (EXE_MARKED_INVALID,	ENOEXEC),
  X (FILEMARK_DETECTED,		EIO),
  X (FILENAME_EXCED_RANGE,	ENAMETOOLONG),
  X (FILE_CORRUPT,		EEXIST),
  X (FILE_EXISTS,		EEXIST),
  X (FILE_INVALID,		ENXIO),
  X (FILE_NOT_FOUND,		ENOENT),
  X (HANDLE_DISK_FULL,		ENOSPC),
  X (HANDLE_EOF,		ENODATA),
  X (INVALID_ADDRESS,		EINVAL),
  X (INVALID_AT_INTERRUPT_TIME,	EINTR),
  X (INVALID_BLOCK_LENGTH,	EIO),
  X (INVALID_DATA,		EINVAL),
  X (INVALID_DRIVE,		ENODEV),
  X (INVALID_EA_NAME,		EINVAL),
  X (INVALID_EXE_SIGNATURE,	ENOEXEC),
  X (INVALID_FUNCTION,		EBADRQC),
  X (INVALID_HANDLE,		EBADF),
  X (INVALID_NAME,		ENOENT),
  X (INVALID_PARAMETER,		EINVAL),
  X (INVALID_SIGNAL_NUMBER,	EINVAL),
  X (IOPL_NOT_ENABLED,		ENOEXEC),
  X (IO_DEVICE,			EIO),
  X (IO_INCOMPLETE,		EAGAIN),
  X (IO_PENDING,		EAGAIN),
  X (LOCK_VIOLATION,		EBUSY),
  X (MAX_THRDS_REACHED,		EAGAIN),
  X (META_EXPANSION_TOO_LONG,	EINVAL),
  X (MOD_NOT_FOUND,		ENOENT),
  X (MORE_DATA,			EMSGSIZE),
  X (NEGATIVE_SEEK,		EINVAL),
  X (NETNAME_DELETED,		ENOENT),
  X (NOACCESS,			EFAULT),
  X (NONE_MAPPED,		EINVAL),
  X (NONPAGED_SYSTEM_RESOURCES,	EAGAIN),
  X (NOT_CONNECTED,		ENOLINK),
  X (NOT_ENOUGH_MEMORY,		ENOMEM),
  X (NOT_ENOUGH_QUOTA,		EIO),
  X (NOT_OWNER,			EPERM),
  X (NOT_READY,			ENOMEDIUM),
  X (NOT_SAME_DEVICE,		EXDEV),
  X (NOT_SUPPORTED,		ENOSYS),
  X (NO_DATA,			EPIPE),
  X (NO_DATA_DETECTED,		EIO),
  X (NO_MEDIA_IN_DRIVE,		ENOMEDIUM),
  X (NO_MORE_FILES,		ENMFILE),
  X (NO_MORE_ITEMS,		ENMFILE),
  X (NO_MORE_SEARCH_HANDLES,	ENFILE),
  X (NO_PROC_SLOTS,		EAGAIN),
  X (NO_SIGNAL_SENT,		EIO),
  X (NO_SYSTEM_RESOURCES,	EFBIG),
  X (NO_TOKEN,			EINVAL),
  X (OPEN_FAILED,		EIO),
  X (OPEN_FILES,		EAGAIN),
  X (OUTOFMEMORY,		ENOMEM),
  X (PAGED_SYSTEM_RESOURCES,	EAGAIN),
  X (PAGEFILE_QUOTA,		EAGAIN),
  X (PATH_NOT_FOUND,		ENOENT),
  X (PIPE_BUSY,			EBUSY),
  X (PIPE_CONNECTED,		EBUSY),
  X (PIPE_LISTENING,		ECOMM),
  X (PIPE_NOT_CONNECTED,	ECOMM),
  X (POSSIBLE_DEADLOCK,		EDEADLOCK),
  X (PRIVILEGE_NOT_HELD,	EPERM),
  X (PROCESS_ABORTED,		EFAULT),
  X (PROC_NOT_FOUND,		ESRCH),
  X (REM_NOT_LIST,		ENONET),
  X (SECTOR_NOT_FOUND,		EINVAL),
  X (SEEK,			EINVAL),
  X (SERVICE_REQUEST_TIMEOUT,	EBUSY),
  X (SETMARK_DETECTED,		EIO),
  X (SHARING_BUFFER_EXCEEDED,	ENOLCK),
  X (SHARING_VIOLATION,		EBUSY),
  X (SIGNAL_PENDING,		EBUSY),
  X (SIGNAL_REFUSED,		EIO),
  X (SXS_CANT_GEN_ACTCTX,	ELIBBAD),
  X (THREAD_1_INACTIVE,		EINVAL),
  X (TIMEOUT,			EBUSY),
  X (TOO_MANY_LINKS,		EMLINK),
  X (TOO_MANY_OPEN_FILES,	EMFILE),
  X (UNEXP_NET_ERR,		EIO),
  X (WAIT_NO_CHILDREN,		ECHILD),
  X (WORKING_SET_QUOTA,		EAGAIN),
  X (WRITE_PROTECT,		EROFS),
  { 0, NULL, 0}
};

extern "C" {
const char *_sys_errlist[] =
{
/* NOERROR 0 */		  "No error",
/* EPERM 1 */		  "Operation not permitted",
/* ENOENT 2 */		  "No such file or directory",
/* ESRCH 3 */		  "No such process",
/* EINTR 4 */		  "Interrupted system call",
/* EIO 5 */		  "Input/output error",
/* ENXIO 6 */		  "No such device or address",
/* E2BIG 7 */		  "Argument list too long",
/* ENOEXEC 8 */		  "Exec format error",
/* EBADF 9 */		  "Bad file descriptor",
/* ECHILD 10 */		  "No child processes",
/* EAGAIN 11 */		  "Resource temporarily unavailable",
/* ENOMEM 12 */		  "Cannot allocate memory",
/* EACCES 13 */		  "Permission denied",
/* EFAULT 14 */		  "Bad address",
/* ENOTBLK 15 */	  "Block device required",
/* EBUSY 16 */		  "Device or resource busy",
/* EEXIST 17 */		  "File exists",
/* EXDEV 18 */		  "Invalid cross-device link",
/* ENODEV 19 */		  "No such device",
/* ENOTDIR 20 */	  "Not a directory",
/* EISDIR 21 */		  "Is a directory",
/* EINVAL 22 */		  "Invalid argument",
/* ENFILE 23 */		  "Too many open files in system",
/* EMFILE 24 */		  "Too many open files",
/* ENOTTY 25 */		  "Inappropriate ioctl for device",
/* ETXTBSY 26 */	  "Text file busy",
/* EFBIG 27 */		  "File too large",
/* ENOSPC 28 */		  "No space left on device",
/* ESPIPE 29 */		  "Illegal seek",
/* EROFS 30 */		  "Read-only file system",
/* EMLINK 31 */		  "Too many links",
/* EPIPE 32 */		  "Broken pipe",
/* EDOM 33 */		  "Numerical argument out of domain",
/* ERANGE 34 */		  "Numerical result out of range",
/* ENOMSG 35 */		  "No message of desired type",
/* EIDRM 36 */		  "Identifier removed",
/* ECHRNG 37 */		  "Channel number out of range",
/* EL2NSYNC 38 */	  "Level 2 not synchronized",
/* EL3HLT 39 */		  "Level 3 halted",
/* EL3RST 40 */		  "Level 3 reset",
/* ELNRNG 41 */		  "Link number out of range",
/* EUNATCH 42 */	  "Protocol driver not attached",
/* ENOCSI 43 */		  "No CSI structure available",
/* EL2HLT 44 */		  "Level 2 halted",
/* EDEADLK 45 */	  "Resource deadlock avoided",
/* ENOLCK 46 */		  "No locks available",
			  NULL,
			  NULL,
			  NULL,
/* EBADE 50 */		  "Invalid exchange",
/* EBADR 51 */		  "Invalid request descriptor",
/* EXFULL 52 */		  "Exchange full",
/* ENOANO 53 */		  "No anode",
/* EBADRQC 54 */	  "Invalid request code",
/* EBADSLT 55 */	  "Invalid slot",
/* EDEADLOCK 56 */	  "File locking deadlock error",
/* EBFONT 57 */		  "Bad font file format",
			  NULL,
			  NULL,
/* ENOSTR 60 */		  "Device not a stream",
/* ENODATA 61 */	  "No data available",
/* ETIME 62 */		  "Timer expired",
/* ENOSR 63 */		  "Out of streams resources",
/* ENONET 64 */		  "Machine is not on the network",
/* ENOPKG 65 */		  "Package not installed",
/* EREMOTE 66 */	  "Object is remote",
/* ENOLINK 67 */	  "Link has been severed",
/* EADV 68 */		  "Advertise error",
/* ESRMNT 69 */		  "Srmount error",
/* ECOMM 70 */		  "Communication error on send",
/* EPROTO 71 */		  "Protocol error",
			  NULL,
			  NULL,
/* EMULTIHOP 74 */	  "Multihop attempted",
/* ELBIN 75 */		  "Inode is remote (not really error)",
/* EDOTDOT 76 */	  "RFS specific error",
/* EBADMSG 77 */	  "Bad message",
			  NULL,
/* EFTYPE 79 */		  "Inappropriate file type or format",
/* ENOTUNIQ 80 */	  "Name not unique on network",
/* EBADFD 81 */		  "File descriptor in bad state",
/* EREMCHG 82 */	  "Remote address changed",
/* ELIBACC 83 */	  "Can not access a needed shared library",
/* ELIBBAD 84 */	  "Accessing a corrupted shared library",
/* ELIBSCN 85 */	  ".lib section in a.out corrupted",
/* ELIBMAX 86 */	  "Attempting to link in too many shared libraries",
/* ELIBEXEC 87 */	  "Cannot exec a shared library directly",
/* ENOSYS 88 */		  "Function not implemented",
/* ENMFILE 89 */	  "No more files",
/* ENOTEMPTY 90	*/	  "Directory not empty",
/* ENAMETOOLONG 91 */	  "File name too long",
/* ELOOP 92 */		  "Too many levels of symbolic links",
			  NULL,
			  NULL,
/* EOPNOTSUPP 95 */	  "Operation not supported",
/* EPFNOSUPPORT 96 */	  "Protocol family not supported",
			  NULL,
			  NULL,
			  NULL,
			  NULL,
			  NULL,
			  NULL,
			  NULL,
/* ECONNRESET 104 */	  "Connection reset by peer",
/* ENOBUFS 105 */	  "No buffer space available",
/* EAFNOSUPPORT 106 */	  "Address family not supported by protocol",
/* EPROTOTYPE 107 */	  "Protocol wrong type for socket",
/* ENOTSOCK 108 */	  "Socket operation on non-socket",
/* ENOPROTOOPT 109 */	  "Protocol not available",
/* ESHUTDOWN 110 */	  "Cannot send after transport endpoint shutdown",
/* ECONNREFUSED 111 */	  "Connection refused",
/* EADDRINUSE 112 */	  "Address already in use",
/* ECONNABORTED 113 */	  "Software caused connection abort",
/* ENETUNREACH 114 */	  "Network is unreachable",
/* ENETDOWN 115 */	  "Network is down",
/* ETIMEDOUT 116 */	  "Connection timed out",
/* EHOSTDOWN 117 */	  "Host is down",
/* EHOSTUNREACH 118 */	  "No route to host",
/* EINPROGRESS 119 */	  "Operation now in progress",
/* EALREADY 120 */	  "Operation already in progress",
/* EDESTADDRREQ 121 */	  "Destination address required",
/* EMSGSIZE 122 */	  "Message too long",
/* EPROTONOSUPPORT 123 */ "Protocol not supported",
/* ESOCKTNOSUPPORT 124 */ "Socket type not supported",
/* EADDRNOTAVAIL 125 */	  "Cannot assign requested address",
/* ENETRESET 126 */	  "Network dropped connection on reset",
/* EISCONN 127 */	  "Transport endpoint is already connected",
/* ENOTCONN 128 */	  "Transport endpoint is not connected",
/* ETOOMANYREFS 129 */	  "Too many references: cannot splice",
/* EPROCLIM 130 */	  "Too many processes",
/* EUSERS 131 */	  "Too many users",
/* EDQUOT 132 */	  "Disk quota exceeded",
/* ESTALE 133 */	  "Stale NFS file handle",
/* ENOTSUP 134 */	  "Not supported",
/* ENOMEDIUM 135 */	  "No medium found",
/* ENOSHARE 136 */	  "No such host or network path",
/* ECASECLASH 137 */	  "Filename exists with different case",
/* EILSEQ 138 */	  "Invalid or incomplete multibyte or wide character",
/* EOVERFLOW 139 */	  "Value too large for defined data type",
/* ECANCELED 140 */	  "Operation canceled",
/* ENOTRECOVERABLE 141 */ "State not recoverable",
/* EOWNERDEAD 142 */	  "Previous owner died",
/* ESTRPIPE 143 */	  "Streams pipe error"
};

int NO_COPY_INIT _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
};

int __reg2
geterrno_from_win_error (DWORD code, int deferrno)
{
  for (int i = 0; errmap[i].w != 0; ++i)
    if (code == errmap[i].w)
      {
	syscall_printf ("windows error %u == errno %d", code, errmap[i].e);
	return errmap[i].e;
      }

  syscall_printf ("unknown windows error %u, setting errno to %d", code,
		  deferrno);
  return deferrno;	/* FIXME: what's so special about EACCESS? */
}

/* seterrno_from_win_error: Given a Windows error code, set errno
   as appropriate. */
void __reg3
seterrno_from_win_error (const char *file, int line, DWORD code)
{
  syscall_printf ("%s:%d windows error %u", file, line, code);
  errno = _impure_ptr->_errno =  geterrno_from_win_error (code, EACCES);
}

int __reg2
geterrno_from_nt_status (NTSTATUS status, int deferrno)
{
  return geterrno_from_win_error (RtlNtStatusToDosError (status));
}

/* seterrno_from_nt_status: Given a NT status code, set errno
   as appropriate. */
void __reg3
seterrno_from_nt_status (const char *file, int line, NTSTATUS status)
{
  DWORD code = RtlNtStatusToDosError (status);
  SetLastError (code);
  syscall_printf ("%s:%d status %y -> windows error %u",
		  file, line, status, code);
  errno = _impure_ptr->_errno =  geterrno_from_win_error (code, EACCES);
}

static char *
strerror_worker (int errnum)
{
  char *res;
  if (errnum >= 0 && errnum < _sys_nerr)
    res = (char *) _sys_errlist [errnum];
  else
    res = NULL;
  return res;
}

/* Newlib requires this override for perror and friends to avoid
   clobbering strerror() buffer, without having to differentiate
   between strerror_r signatures.  This function is intentionally not
   exported, so that only newlib can use it.  */
extern "C" char *
_strerror_r (struct _reent *, int errnum, int internal, int *errptr)
{
  char *errstr = strerror_worker (errnum);
  if (!errstr)
    {
      errstr = internal ? _my_tls.locals.strerror_r_buf
	: _my_tls.locals.strerror_buf;
      __small_sprintf (errstr, "Unknown error %d", errnum);
      if (errptr)
	*errptr = EINVAL;
    }
  return errstr;
}

/* strerror: convert from errno values to error strings.  Newlib's
   strerror_r returns "" for unknown values, so we override it to
   provide a nicer thread-safe result string and set errno.  */
extern "C" char *
strerror (int errnum)
{
  int error = 0;
  char *result = _strerror_r (NULL, errnum, 0, &error);
  if (error)
    set_errno (error);
  return result;
}

/* Newlib's <string.h> provides declarations for two strerror_r
   variants, according to preprocessor feature macros.  However, it
   returns "" instead of "Unknown error ...", so we override both
   versions.  */
extern "C" char *
strerror_r (int errnum, char *buf, size_t n)
{
  int error = 0;
  char *errstr = _strerror_r (NULL, errnum, 1, &error);
  if (error)
    set_errno (error);
  if (strlen (errstr) >= n)
    return errstr;
  return strcpy (buf, errstr);
}

extern "C" int
__xpg_strerror_r (int errnum, char *buf, size_t n)
{
  if (!n)
    return ERANGE;
  int result = 0;
  char *error = strerror_worker (errnum);
  char tmp[sizeof "Unknown error -2147483648"];
  if (!error)
    {
      __small_sprintf (error = tmp, "Unknown error %d", errnum);
      result = EINVAL;
    }
  if (strlen (error) >= n)
    {
      memcpy (buf, error, n - 1);
      buf[n - 1] = '\0';
      return ERANGE;
    }
  strcpy (buf, error);
  return result;
}

unsigned int error_message_count = 0;
int error_one_per_line = 0;
void (*error_print_progname) (void) = NULL;

static void
_verror (int status, int errnum, const char *filename, unsigned int lineno, const char *fmt, va_list ap)
{
  error_message_count++;

  fflush (stdout);

  if (error_print_progname)
    (*error_print_progname) ();
  else
    fprintf (stderr, "%s:%s", program_invocation_name, filename ? "" : " ");

  if (filename)
    fprintf (stderr, "%s:%d: ", filename, lineno);

  vfprintf (stderr, fmt, ap);

  if (errnum != 0)
    fprintf (stderr, ": %s", strerror (errnum));

  fprintf (stderr, "\n");

  if (status != 0)
    exit (status);
}

extern "C" void
error (int status, int errnum, const char *fmt, ...)
{
  va_list ap;
  va_start (ap, fmt);
  _verror (status, errnum, NULL, 0, fmt, ap);
  va_end (ap);
}

extern "C" void
error_at_line (int status, int errnum, const char *filename, unsigned int lineno, const char *fmt, ...)
{
  va_list ap;

  if (error_one_per_line != 0)
    {
      static const char *last_filename;
      static unsigned int last_lineno;

      /* strcmp(3) will SEGV if filename or last_filename are NULL */
      if (lineno == last_lineno
	  && ((!filename && !last_filename)
	      || (filename && last_filename && strcmp (filename, last_filename) == 0)))
	return;

      last_filename = filename;
      last_lineno = lineno;
    }

  va_start (ap, fmt);
  _verror (status, errnum, filename, lineno, fmt, ap);
  va_end (ap);
}
@


1.95
log
@	* errno.cc (errmap): Fix order of SERVICE_REQUEST_TIMEOUT.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a365 7
/* seterrno: Set `errno' based on GetLastError (). */
void __reg2
seterrno (const char *file, int line)
{
  seterrno_from_win_error (file, line, GetLastError ());
}

@


1.94
log
@	* errno.cc (errmap): Handle Windows error codes ERROR_CANCELLED,
	ERROR_CONNECTION_REFUSED, ERROR_DEV_NOT_EXIST, ERROR_DS_GENERIC_ERROR,
	ERROR_NOT_ENOUGH_QUOTA, ERROR_SERVICE_REQUEST_TIMEOUT, ERROR_TIMEOUT,
	ERROR_UNEXP_NET_ERR.
	* ldap.cc (cyg_ldap::map_ldaperr_to_errno): Drop explicit LDAP_TIMEOUT
	handling.
@
text
@d154 1
a157 1
  X (SERVICE_REQUEST_TIMEOUT,	EBUSY),
@


1.93
log
@	* Merge in cygwin-64bit-branch.
@
text
@d62 1
d66 1
d71 1
d76 1
d122 1
d157 1
d162 1
d165 1
@


1.92
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d37 1
a37 1
static NO_COPY struct
d165 1
a165 1
const char *_sys_errlist[] NO_COPY_INIT =
d336 1
a336 1
  syscall_printf ("%s:%d windows error %d", file, line, code);
d353 1
a353 1
  syscall_printf ("%s:%d status %p -> windows error %d",
@


1.91
log
@	* errno.cc (errmap): Map ERROR_LOCK_VIOLATION to EBUSY.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d316 1
a316 1
int __stdcall
d333 1
a333 1
void __stdcall
d340 1
a340 1
int __stdcall
d348 1
a348 1
void __stdcall
d359 1
a359 1
void __stdcall
@


1.90
log
@* errno.cc (errmap): Keep sorted.
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010, 2011 Red Hat, Inc.
d106 1
a106 1
  X (LOCK_VIOLATION,		EACCES),
@


1.89
log
@* errno.cc (errmap): Keep sorted.
@
text
@d143 1
a160 1
  X (PRIVILEGE_NOT_HELD,	EPERM),
@


1.88
log
@* errno.cc (errmap): Map ERROR_SXS_CANT_GEN_ACTCTX to ELIBBAD.
@
text
@d153 1
a160 1
  X (SXS_CANT_GEN_ACTCTX,	ELIBBAD),
@


1.87
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d160 1
@


1.87.2.1
log
@Pull in changes from HEAD
@
text
@a159 1
  X (SXS_CANT_GEN_ACTCTX,	ELIBBAD),
@


1.87.2.2
log
@Pull in changes from HEAD
@
text
@a152 1
  X (SXS_CANT_GEN_ACTCTX,	ELIBBAD),
@


1.87.2.3
log
@Pull in changes from HEAD
@
text
@a142 1
  X (PRIVILEGE_NOT_HELD,	EPERM),
d160 2
@


1.87.2.4
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d353 1
a353 1
  syscall_printf ("%s:%d status %y -> windows error %d",
@


1.87.2.5
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d336 1
a336 1
  syscall_printf ("%s:%d windows error %u", file, line, code);
d353 1
a353 1
  syscall_printf ("%s:%d status %y -> windows error %u",
@


1.87.2.6
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d106 1
a106 1
  X (LOCK_VIOLATION,		EBUSY),
@


1.87.2.7
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d316 1
a316 1
int __reg2
d333 1
a333 1
void __reg3
d340 1
a340 1
int __reg2
d348 1
a348 1
void __reg3
d359 1
a359 1
void __reg2
@


1.87.2.8
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d37 1
a37 1
static const struct
d165 1
a165 1
const char *_sys_errlist[] =
@


1.86
log
@* errno.cc (EIO): Lowercase "o" representative string.
@
text
@d159 1
@


1.85
log
@whitespace elimination
@
text
@d170 1
a170 1
/* EIO 5 */		  "Input/Output error",
@


1.84
log
@perror: fix POSIX compliance and work with recent newlib change

* cygtls.h (strerror_r_buf): New buffer.
* errno.cc (strerror): Move guts...
(_strerror_r): ...to new function demanded by newlib.
(strerror_r): Don't clobber strerror buffer.
(_user_strerror): Drop unused declaration.
* tlsoffsets.h: Regenerate.
@
text
@d385 1
a385 1
        : _my_tls.locals.strerror_buf;
d388 1
a388 1
        *errptr = EINVAL;
d496 3
a498 3
          && ((!filename && !last_filename)
              || (filename && last_filename && strcmp (filename, last_filename) == 0)))
        return;
@


1.83
log
@strerror: match recent glibc changes

* errno.cc (strerror): Print unknown errno as int.
(__xpg_strerror_r): Likewise, and don't clobber strerror buffer.
@
text
@a362 2
extern char *_user_strerror _PARAMS ((int));

d374 4
a377 3
/* strerror: convert from errno values to error strings.  Newlib's
   strerror_r returns "" for unknown values, so we override it to
   provide a nicer thread-safe result string and set errno.  */
d379 1
a379 1
strerror (int errnum)
d384 5
a388 3
      __small_sprintf (errstr = _my_tls.locals.strerror_buf, "Unknown error %d",
                       errnum);
      errno = _impure_ptr->_errno = EINVAL;
d393 13
d413 7
a419 4
  char *error = strerror (errnum);
  if (strlen (error) >= n)
    return error;
  return strcpy (buf, error);
@


1.82
log
@* cygwin.din (error): Export.
(error_at_line): Export.
(error_message_count): Export.
(error_one_per_line): Export.
(error_print_progname): Export.
* errno.cc (error_message_count): Define.
(error_one_per_line): Define.
(error_print_progname): Define.
(_verror): New static function.
(error): New function.
(error_at_line): New function.
* posix.sgml (std-gnu): Add error, error_at_line.
* include/error.h: New header.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d385 2
a386 2
      __small_sprintf (errstr = _my_tls.locals.strerror_buf, "Unknown error %u",
		       (unsigned) errnum);
d412 1
d415 1
a415 2
      __small_sprintf (error = _my_tls.locals.strerror_buf, "Unknown error %u",
		       (unsigned) errnum);
@


1.81
log
@	* errno.cc (errmap): Sort.  Map ERROR_EXE_MACHINE_TYPE_MISMATCH to
	ENOEXEC.
@
text
@d16 7
d427 64
@


1.80
log
@	* cygerrno.h (geterrno_from_nt_status): Declare.
	* errno.cc (geterrno_from_nt_status): Define.
	* flock.cc: Fix copyright dates.
	* ntdll.h (enum _TIMER_TYPE): Define.
	(PTIMER_APC_ROUTINE): Define.
	(NtCancelTimer): Declare.
	(NtCreateTimer): Declare.
	(NtSetTimer): Declare.
	* posix_ipc.cc (ipc_cond_timedwait): Rewrite to make interruptible and
	restartable.  Call pthread_testcancel in case of timeout to enable
	pthread_cancel on waiting thread.  Replace WFMO timeout with waiting
	for a waitable timer.  Explain why.  Replace single call to WFMO with
	two calls, one for the event, one for the mutex.  Don't lock mutex in
	case of error.
	(ipc_cond_signal): Make void function.
	(ipc_cond_close): Ditto.
	(_mq_send): Immediately return -1 in case of error from
	ipc_cond_timedwait.
	(_mq_receive): Ditto.
@
text
@d73 1
d97 1
d107 1
a108 1
  X (NONE_MAPPED,		EINVAL),
d139 2
a151 3
  X (SEEK,			EINVAL),
  X (SECTOR_NOT_FOUND,		EINVAL),
  X (IO_INCOMPLETE,		EAGAIN),
@


1.79
log
@* errno.cc (errmap): Change mapping of NO_SYSTEM_RESOURCES to EFBIG.
* fhandler.cc (MAX_OVERLAPPED_WRITE_LEN): New constant.
(MIN_OVERLAPPED_WRITE_LEN): Ditto.
(fhandler_base_overlapped::close): Accommodate change in arguments to
wait_overlapped.
(fhandler_base_overlapped::setup_overlapped): Add __stdcall and regparm
modifiers.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::wait_overlapped): Modify to return an enum returning
various states.  Accept nonblocking parameter.
(fhandler_base_overlapped::read_overlapped): Add __stdcall and regparm
modifiers.  Rework to attempt to be smarter about reacting to states returned
by wait_overlapped.
(fhandler_base_overlapped::write_overlapped): Ditto.  Add fallback option for
when wait_overlapped detects that smaller chunks must be written.
(fhandler_base_overlapped::write_overlapped_fallback): Ditto.
* fhandler.h (DEFAULT_PIPEBUFSIZE): Move definition here from pipe.cc.
(fhandler_base::has_ongoing_io): Define with __stdcall and regparm modifiers.
(fhandler_base_overlapped::wait_return): New enum.
(fhandler_base_overlapped::max_atomic_write): New variable.
(fhandler_base_overlapped:: wait_overlapped): Accommodate changes mentioned
above to arguments and modifiers.
(fhandler_base_overlapped::setup_overlapped): Ditto for modifiers.
(fhandler_base_overlapped::read_overlapped): Ditto.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::fhandler_base_overlapped): Zero max_atomic_write.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Set max_atomic_write to the
size of the DEFAULT_PIPEBUFSIZE.
(fhandler_fifo::wait): Accommodate change in arguments to wait_overlapped.
* pipe.cc (fhandler_pipe::fhandler_pipe): Set max_atomic_write to the size of
the DEFAULT_PIPEBUFSIZE.
(fhandler_pipe::create_selectable): Allow minimum size of DEFAULT_PIPEBUFSIZE.
(DEFAULT_PIPEBUFSIZE): Delete here, move to fhandler.h.
@
text
@d330 6
@


1.78
log
@	* errno.cc (__xpg_strerror_r): Add accidentally missing condition.
@
text
@d121 1
a121 1
  X (NO_SYSTEM_RESOURCES,	EAGAIN),
@


1.77
log
@strerror_r: fix compilation bug in previous patch

* errno.cc (includes): Avoid compilation failure if <string.h>
settles on wrong strerror_r signature.
@
text
@d398 1
@


1.76
log
@strerror_r: obey POSIX, and match newlib header change

* errno.cc (__xpg_strerror_r): New function.
(strerror_r): Update to copy newlib's fixes.
(strerror): Set errno on failure.
(_sys_errlist): Cause EINVAL failure for reserved values.
* cygwin.din: Export new function.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Combine
this into minor 236.
@
text
@d15 1
d22 1
@


1.75
log
@	* errno.cc (errmap): Add error codes for invalid binaries.
	* exec.cc (execvp): Call spawnve with _P_PATH_TYPE_EXEC flag
	from here.
	(execvpe): Ditto.
	* spawn.cc (spawn_guts): Filter _P_PATH_TYPE_EXEC from mode and
	store in p_type_exec.  Call av::fixup with addtional p_type_exec
	argument.
	(spawnve): Check for filtered mode.
	(spawnvpe): Add _P_PATH_TYPE_EXEC flag when calling spawnve.
	(av::fixup): Accept additional bool parameter p_type_exec.  Only check
	for script if p_type_exec is true.
	* winf.h (_P_PATH_TYPE_EXEC): Define.
	(_P_MODE): Define.
	(av::fixup): Declare with additional bool parameter.
@
text
@d202 3
a204 3
			  "error 47",
			  "error 48",
			  "error 49",
d213 2
a214 2
			  "error 58",
			  "error 59",
d227 2
a228 2
			  "error 72",
			  "error 73",
d233 1
a233 1
			  "error 78",
d248 2
a249 2
			  "error 93",
			  "error 94",
d252 7
a258 7
			  "error 97",
			  "error 98",
			  "error 99",
			  "error 100",
			  "error 101",
			  "error 102",
			  "error 103",
d360 3
a362 1
/* strerror: convert from errno values to error strings */
d368 5
a372 2
    __small_sprintf (errstr = _my_tls.locals.strerror_buf, "Unknown error %u",
		     (unsigned) errnum);
d376 13
a388 1
#if 0
d390 1
a390 1
strerror_r (int errnum, char *buf, size_t n)
d392 1
a392 4
  char *errstr = strerror_worker (errnum);
  if (!errstr)
    return EINVAL;
  if (strlen (errstr) >= n)
d394 15
a408 2
  strcpy (buf, errstr);
  return 0;
a409 1
#endif
@


1.74
log
@	* errno.cc (errmap): Map ERROR_BAD_NET_RESP to ENOSYS.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Handle ENOSYS and
	point to  the explanation.
	* ntdll.h (STATUS_NOT_IMPLEMENTED): Define.
	* path.cc (symlink_info::check): Handle the inability of NT4 to use
	FileNetworkOpenInformation on share root dirs in either direction.
	* path.h (slash_unc_prefix_p): Remove unused declaration.
	* security.cc (get_info_from_sd): Handle ENOSYS from get_file_sd.
	Explain when this happens.
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010 Red Hat, Inc.
d40 1
d71 1
d86 1
d92 1
@


1.73
log
@	* cygerrno.h (seterrno_from_nt_status): Declare.
	(__seterrno_from_nt_status): Call seterrno_from_nt_status.
	* errno.cc (seterrno_from_win_error): Set errno without calling
	set_errno to avoid packing strace output with errno messages.
	(seterrno_from_nt_status): New function to print NT status as well as
	resulting Windows error.
@
text
@d42 1
@


1.72
log
@* errno.cc (errmap): Add mapping for ERROR_IO_INCOMPLETE.
* fhandler.cc (fhandler_base::fcntl): Fix comment.
(fhandler_base::wait_overlapped): Accept an optional len parameter.  Use the
len parameter when WriteFile fails with ERROR_IO_PENDING.  Make debug output
less alarming.
(fhandler_base::write_overlapped): Pass len to wait_overlapped.
* fhandler.h (fhandler_base::wait_overlapped): Add an optional argument
denoting the number of characters intended to be written.
* fhandler_tty.cc (fhandler_pty_master::close): Don't close archetype handles
when cygwin is still initializing since the handles aren't actually opened at
that point.
@
text
@d4 1
a4 1
   2006, 2008, 2009 Red Hat, Inc.
d17 1
d320 13
a332 1
  set_errno (geterrno_from_win_error (code, EACCES));
@


1.71
log
@	* errno.cc (_sys_errlist): Add ESTRPIPE.
@
text
@d142 1
@


1.70
log
@	* Fix copyright dates.
@
text
@d290 2
a291 1
/* EOWNERDEAD 142 */	  "Previous owner died"
@


1.69
log
@	* errno.cc (errmap): Set errno to ENOENT instead of ENOSHARE throughout.
	* path.cc (path_conv::check): Set to and check for ENOENT instead of
	ENOSHARE.

	* path.cc (symlink_info::check): Fix Samba 3.2.x comment.
@
text
@d4 1
a4 1
   2006, 2008 Red Hat, Inc.
@


1.68
log
@* errno.cc (_sys_errlist): Add ECANCELED, ENOTRECOVERABLE, EOWNERDEAD.
@
text
@d39 2
a40 2
  X (BAD_NETPATH,		ENOSHARE),
  X (BAD_NET_NAME,		ENOSHARE),
d95 1
a95 1
  X (NETNAME_DELETED,		ENOSHARE),
@


1.67
log
@* cygwin.din (sys_sigabbrev): Add this here.
* dcrt0.cc (__argc,__argv,_check_for_executable): Remove dllexport decoration
since it is already handled in cygwin.din.
* errno.cc (_sys_errlist): Ditto.
* strsig.cc (sys_sigabbrev): Ditto.
* include/cygwin/signal.h: Protect use of dllimport when __INSIDE_CYGWIN__.
* libc/getopt.c: Revert previous changes.  Define __INSIDE_CYGWIN__.
@
text
@d195 3
a197 3
		  	  "error 47",
		  	  "error 48",
		  	  "error 49",
d206 2
a207 2
		  	  "error 58",
		  	  "error 59",
d220 2
a221 2
		  	  "error 72",
		  	  "error 73",
d226 1
a226 1
		  	  "error 78",
d241 2
a242 2
		  	  "error 93",
		  	  "error 94",
d245 7
a251 7
		  	  "error 97",
		  	  "error 98",
		  	  "error 99",
		  	  "error 100",
		  	  "error 101",
		  	  "error 102",
		  	  "error 103",
d256 1
a256 1
/* ENOTSOCK 108 */ 	  "Socket operation on non-socket",
d282 1
a282 1
/* ENOTSUP 134 */  	  "Not supported",
d284 1
a284 1
/* ENOSHARE 136 */  	  "No such host or network path",
d287 4
a290 1
/* EOVERFLOW 139 */	  "Value too large for defined data type"
@


1.66
log
@	Change length for domain buffers from INTERNET_MAX_HOST_NAME_LENGTH to
	MAX_DOMAIN_NAME_LEN throughout.
	* cyglsa.h (CYG_LSA_MAGIC): New value.
	(cyglsa_t): Define username and domain as WCHAR arrays.
	* errno.cc (errmap): Add mapping for ERROR_NONE_MAPPED.
	* sec_auth.cc: Drop 'w' prefix from WCHAR string variable names where
	appropriate.
	(extract_nt_dom_user): Prefer resolving by SID before resolving by
	domain\name pair.
	(cygwin_logon_user): Don't print cleartext password in debug output.
	Change comment.
	(get_user_groups): Revert calls to LookupAccountNameW to use NULL
	server instead of explicit server name, according to MSDN.
	(get_user_local_groups): Ditto.
	(get_server_groups): Fetch domain and user name from usersid per
	LookupAccountSidW instead of calling extract_nt_dom_user.
	(lsaauth): Fetch domain and user name from usersid per LookupAccountSidW
	instead of calling extract_nt_dom_user.
	* sec_helper.cc (cygpriv): Convert to wchar_t pointer array.
	(privilege_luid): Convert first parameter to  PWCHAR.
	(privilege_name): Return wchar_t pointer.
	(set_privileges): Accommodate debug output.
	* security.h (privilege_luid): Change prototype accordingly.
@
text
@d146 1
a146 1
const char __declspec(dllexport) * _sys_errlist[] NO_COPY_INIT =
@


1.65
log
@Remove unneeded header files from source files throughout.
@
text
@d98 1
@


1.64
log
@	* Fix copyright dates.
@
text
@a15 3
#include <stdio.h>
#include "cygerrno.h"
#include "thread.h"
@


1.63
log
@	* Makefile.in (DLL_OFILES): Add ntea.o.
	* cygwin.din (getxattr, listxattr, removexattr, setxattr, lgetxattr,
	llistxattr, lremovexattr, lsetxattr, fgetxattr, flistxattr,
	fremovexattr, fsetxattr): Export Linux extended attribute functions.
	Sort.
	* errno.cc (errmap): Add mappings for ERROR_EAS_DIDNT_FIT,
	ERROR_EAS_NOT_SUPPORTED, ERROR_EA_LIST_INCONSISTENT,
	ERROR_EA_TABLE_FULL, ERROR_FILE_CORRUPT, ERROR_INVALID_EA_NAME.
	* fhandler.h (class fhandler_base): Declare new fgetxattr and
	fsetxattr methods.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::fgetxattr): New method.
	(fhandler_base::fsetxattr): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fgetxattr): New method.
	(fhandler_disk_file::fsetxattr): New method.
	* ntdll.h (STATUS_EA_TOO_LARGE): Define.
	(STATUS_NONEXISTENT_EA_ENTRY): Define.
	(STATUS_NO_EAS_ON_FILE): Define.
	* ntea.cc (read_ea): Rewrite for long pathnames and for using with
	Linux extended attribute functions.
	(write_ea): Ditto.
	(getxattr_worker): New static function.
	(getxattr): New function.
	(lgetxattr): New function.
	(fgetxattr): New function.
	(listxattr): New function.
	(llistxattr): New function.
	(flistxattr): New function.
	(setxattr_worker): New static function.
	(setxattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	(removexattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	* security.h (read_ea): Change declaration according to above changes.
	(write_ea): Ditto.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Red Hat, Inc.
@


1.62
log
@* environ.cc (build_env): Don't put an empty environment variable into the
environment.  Optimize use of "len".
* errno.cc (ERROR_MORE_DATA): Translate to EMSGSIZE rather than EAGAIN.
@
text
@d65 4
d73 1
d84 1
@


1.61
log
@	* errno.cc (errmap): Map ERROR_SEEK and ERROR_SECTOR_NOT_FOUND.
@
text
@d90 1
a90 1
  X (MORE_DATA,			EAGAIN),
@


1.61.8.1
log
@	* include/asm/byteorder.h: Fix copyright dates.

	* autoload.cc (PrivilegeCheck): Define.
	* fhandler.cc (fhandler_base::open): Always try opening with backup
	resp. restore intent.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Always try
	opening with backup intent.
	(fhandler_disk_file::readdir): Ditto when trying to retrieve file id
	explicitely.
	* security.cc (check_file_access): Replace pbuf with correctly
	PPRIVILEGE_SET typed pset.  Check explicitely for backup and/or restore
	privileges when AccessCheck fails, to circumvent AccessCheck
	shortcoming.  Add comment to explain.

	* include/asm/byteorder.h: Correct typo.

	* include/asm/byteorder.h: Don't #define n* macros if -fnoinline is
	specified.

	* environ.cc (build_env): Don't put an empty environment variable into
	the environment.  Optimize use of "len".
	* errno.cc (ERROR_MORE_DATA): Translate to EMSGSIZE rather than EAGAIN.
@
text
@d90 1
a90 1
  X (MORE_DATA,			EMSGSIZE),
@


1.60
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@d136 2
@


1.59
log
@* cygwin.din: Correct readdir_r typo.
@
text
@a308 1
  return;
@


1.58
log
@* errno.cc (errmap): Translate ERROR_NO_MORE_ITEMS to ENMFILE.
@
text
@d321 10
a330 6
/* FIXME: Why is strerror() a long switch and not just:
	return sys_errlist[errnum];
	(or moral equivalent).
	Some entries in sys_errlist[] don't match the corresponding
	entries in strerror().  This seems odd.
*/
a331 1
/* CYGWIN internal */
d336 18
a353 11
  const char *error;
  if (errnum >= 0 && errnum < _sys_nerr)
    error = _sys_errlist [errnum];
  else
    {
      __small_sprintf (_my_tls.locals.strerror_buf, "error %d", errnum);
      error = _my_tls.locals.strerror_buf;
    }
  /* FIXME: strerror should really be const in the appropriate newlib
     include files. */
  return (char *) error;
d355 1
@


1.57
log
@	* errno.cc (strerror): Check errnum for underflow.
@
text
@d105 1
@


1.56
log
@* spawn.cc (find_exec): Accept a PATH-like string in place of an environment
variable.
* dlfcn.cc (get_full_path_of_dll): Search /usr/bin (for windows compatibility)
and /usr/lib (for UNIX compatibility) when looking for shared libraries.
* environ.cc (conv_envvars): Put back LD_LIBRARY_PATH since it is used by
get_full_path_of_dll().
* errno.cc (errmap): Map MOD_NOT_FOUND to ENOENT.
* cygmagic: Remove debugging cruft.
@
text
@d333 1
a333 1
  if (errnum < _sys_nerr)
@


1.55
log
@* errno.cc (errmap): Sort table.
@
text
@d89 1
@


1.54
log
@* errno.cc (errmap): Map ERROR_NETNAME_DELETED to ENOSHARE.
@
text
@a37 4
  X (INVALID_FUNCTION,		EBADRQC),
  X (FILE_NOT_FOUND,		ENOENT),
  X (PATH_NOT_FOUND,		ENOENT),
  X (TOO_MANY_OPEN_FILES,	EMFILE),
d39 3
a41 17
  X (INVALID_HANDLE,		EBADF),
  X (NOT_ENOUGH_MEMORY,		ENOMEM),
  X (INVALID_DATA,		EINVAL),
  X (OUTOFMEMORY,		ENOMEM),
  X (INVALID_DRIVE,		ENODEV),
  X (NOT_SAME_DEVICE,		EXDEV),
  X (NO_MORE_FILES,		ENMFILE),
  X (WRITE_PROTECT,		EROFS),
  X (BAD_UNIT,			ENODEV),
  X (SHARING_VIOLATION,		EBUSY),
  X (LOCK_VIOLATION,		EACCES),
  X (SHARING_BUFFER_EXCEEDED,	ENOLCK),
  X (HANDLE_EOF,		ENODATA),
  X (HANDLE_DISK_FULL,		ENOSPC),
  X (NOT_SUPPORTED,		ENOSYS),
  X (REM_NOT_LIST,		ENONET),
  X (DUP_NAME,			ENOTUNIQ),
d44 5
a48 4
  X (FILE_EXISTS,		EEXIST),
  X (CANNOT_MAKE,		EPERM),
  X (INVALID_PARAMETER,		EINVAL),
  X (NO_PROC_SLOTS,		EAGAIN),
d50 2
a51 2
  X (OPEN_FAILED,		EIO),
  X (NO_MORE_SEARCH_HANDLES,	ENFILE),
d53 1
a53 2
  X (INVALID_NAME,		ENOENT),
  X (WAIT_NO_CHILDREN,		ECHILD),
d55 6
d62 25
a86 3
  X (SIGNAL_REFUSED,		EIO),
  X (BAD_PATHNAME,		ENOENT),
  X (SIGNAL_PENDING,		EBUSY),
a87 4
  X (BUSY,			EBUSY),
  X (ALREADY_EXISTS,		EEXIST),
  X (NO_SIGNAL_SENT,		EIO),
  X (FILENAME_EXCED_RANGE,	ENAMETOOLONG),
a88 6
  X (INVALID_SIGNAL_NUMBER,	EINVAL),
  X (THREAD_1_INACTIVE,		EINVAL),
  X (BAD_PIPE,			EINVAL),
  X (PIPE_BUSY,			EBUSY),
  X (NO_DATA,			EPIPE),
  X (PIPE_NOT_CONNECTED,	ECOMM),
d90 4
a93 7
  X (DIRECTORY,			ENOTDIR),
  X (PIPE_CONNECTED,		EBUSY),
  X (PIPE_LISTENING,		ECOMM),
  X (NO_TOKEN,			EINVAL),
  X (PROCESS_ABORTED,		EFAULT),
  X (BAD_DEVICE,		ENODEV),
  X (BAD_USERNAME,		EINVAL),
d95 1
a95 5
  X (OPEN_FILES,		EAGAIN),
  X (ACTIVE_CONNECTIONS,	EAGAIN),
  X (DEVICE_IN_USE,		EAGAIN),
  X (INVALID_AT_INTERRUPT_TIME,	EINTR),
  X (IO_DEVICE,			EIO),
d97 4
a100 4
  X (END_OF_MEDIA,		ENOSPC),
  X (EOM_OVERFLOW,		EIO),
  X (BEGINNING_OF_MEDIA,	EIO),
  X (SETMARK_DETECTED,		EIO),
a101 11
  X (POSSIBLE_DEADLOCK,		EDEADLOCK),
  X (CRC,			EIO),
  X (NEGATIVE_SEEK,		EINVAL),
  X (NOT_READY,			ENOMEDIUM),
  X (DISK_FULL,			ENOSPC),
  X (NOACCESS,			EFAULT),
  X (FILE_INVALID,		ENXIO),
  X (INVALID_ADDRESS,		EINVAL),
  X (INVALID_BLOCK_LENGTH,	EIO),
  X (BUS_RESET,			EIO),
  X (FILEMARK_DETECTED,		EIO),
d103 4
a106 6
  X (DEVICE_REQUIRES_CLEANING,	EIO),
  X (DEVICE_DOOR_OPEN,		EIO),
  X (IO_PENDING,		EAGAIN),
  X (TOO_MANY_LINKS,		EMLINK),
  X (PROC_NOT_FOUND,		ESRCH),
  X (DISK_CORRUPT,		EIO),
d108 4
a111 1
  X (NONPAGED_SYSTEM_RESOURCES,	EAGAIN),
d113 19
d133 1
a133 3
  X (PAGEFILE_QUOTA,		EAGAIN),
  X (COMMITMENT_LIMIT,		EAGAIN),
  X (NETNAME_DELETED,		ENOSHARE),
@


1.53
log
@	* errno.cc (NO_SYSTEM_RESOURCES): Map to EAGAIN.
	(NONPAGED_SYSTEM_RESOURCES): Ditto.
	(PAGED_SYSTEM_RESOURCES): Ditto.
	(WORKING_SET_QUOTA): Ditto.
	(PAGEFILE_QUOTA): Ditto.
	(COMMITMENT_LIMIT): Ditto.
@
text
@d133 1
@


1.52
log
@* timer.cc (timer_tracker::timer_tracker): Eliminate simple constructor.
(ttstart): Fully initialize.
* errno.cc: Fix typo introduced in previous change.
@
text
@d127 6
@


1.51
log
@* errno.cc (FILENAME_EXCED_RANGE): Map to ENAMETOOLONG.
@
text
@d81 1
a81 1
  X (FILENAME_EXCED_RANGE,	ENAMETOOLONG,
@


1.50
log
@* errno.cc (errmap): Correct typo in previous change.
@
text
@d81 1
a81 1
  X (FILENAME_EXCED_RANGE,	EINVAL),
@


1.49
log
@* cygtls.cc (_cygtls::remove): Free process_ident, if it exists.
* errno.cc (errmap): ERROR_DISK_CORRUPT -> EIO.
@
text
@d126 1
a126 1
  X (ERROR_DISK_CORRUPT,	EIO),
@


1.48
log
@copyright
@
text
@d126 1
@


1.47
log
@* pinfo.h (_pinfo::set_exit_state): Declare new function.
(pinfo::exit): Move here from _pinfo::exit.
* sigproc.cc (child_info::sync): Use new function to set exitcode and
process_state.
* pinfo.cc (_pinfo::exit): Ditto.
(proc_waiter): Ditto.
(_pinfo::set_exit_state): Define new function.
(_pinfo::dup_proc_pipe): Close handle when there is no parent process around to
care about the exit value.
* dcrt0.cc (dll_crt0_0): Move subproc_ready synchronization later to make sure
that myself is still mapped in parent.
(do_exit): Reflect movement to pinfo::exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* errno.cc (errmap): Map PROC_NOT_FOUND.
* init.cc (dll_entry): Release myself before exiting.
* sigproc.cc (proc_can_be_signalled): Set errno appropriately.
(sig_send): Ditto.  Also remove ill-advised test for !myself->sendsig since
this is an indication of a process which is still initializating -- it is not
an error.
(child_info::sync): Don't set exitcode here.  Assume that will happen in
proc_waiter, if necessary.
* spawn.cc (spawn_guts): Delay "wait_for_myself" logic until later.  Don't wait
at all if the process has already exited.  Reflect movement to pinfo::exit.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.46
log
@	* errno.cc (errmap): Map ERROR_INVALID_ADDRESS to EINVAL instead of
	EOVERFLOW.
@
text
@d124 1
@


1.45
log
@	* errno.cc (_sys_errlist): Change various text to their english Linux
	counterparts.  Unify layout.
	(strerror): Remove switch statement.
@
text
@d115 1
a115 1
  X (INVALID_ADDRESS,		EOVERFLOW),
@


1.44
log
@	* errno.cc (errmap): Add ERROR_TOO_MANY_LINKS -> EMLINK mapping.
	* syscalls.cc (link): Only copy files if FS doesn't support hard links.
@
text
@d130 123
a252 123
/*      NOERROR 0       */ "No error",
/*	EPERM 1		*/ "Operation not permitted",
/*	ENOENT 2	*/ "No such file or directory",
/*	ESRCH 3		*/ "No such process",
/*	EINTR 4		*/ "Interrupted system call",
/*	EIO 5		*/ "I/O error",
/*	ENXIO 6		*/ "No such device or address",
/*	E2BIG 7		*/ "Arg list too long",
/*	ENOEXEC 8	*/ "Exec format error",
/*	EBADF 9		*/ "Bad file descriptor",
/*	ECHILD 10	*/ "No children",
/*	EAGAIN 11	*/ "Resource temporarily unavailable",
/*	ENOMEM 12	*/ "Not enough core",
/*	EACCES 13	*/ "Permission denied",
/*	EFAULT 14	*/ "Bad address",
/*	ENOTBLK 15	*/ "Block device required",
/*	EBUSY 16	*/ "Mount device busy",
/*	EEXIST 17	*/ "File exists",
/*	EXDEV 18	*/ "Cross-device link",
/*	ENODEV 19	*/ "No such device",
/*	ENOTDIR 20	*/ "Not a directory",
/*	EISDIR 21	*/ "Is a directory",
/*	EINVAL 22	*/ "Invalid argument",
/*	ENFILE 23	*/ "Too many open files in system",
/*	EMFILE 24	*/ "Too many open files",
/*	ENOTTY 25	*/ "Not a typewriter",
/*	ETXTBSY 26	*/ "Text file busy",
/*	EFBIG 27	*/ "File too large",
/*	ENOSPC 28	*/ "No space left on device",
/*	ESPIPE 29	*/ "Illegal seek",
/*	EROFS 30	*/ "Read only file system",
/*	EMLINK 31	*/ "Too many links",
/*	EPIPE 32	*/ "Broken pipe",
/*	EDOM 33		*/ "Math arg out of domain of func",
/*	ERANGE 34	*/ "Math result not representable",
/*	ENOMSG 35	*/ "No message of desired type",
/*	EIDRM 36	*/ "Identifier removed",
/*	ECHRNG 37	*/ "Channel number out of range",
/*	EL2NSYNC 38	*/ "Level 2 not synchronized",
/*	EL3HLT 39	*/ "Level 3 halted",
/*	EL3RST 40	*/ "Level 3 reset",
/*	ELNRNG 41	*/ "Link number out of range",
/*	EUNATCH 42	*/ "Protocol driver not attached",
/*	ENOCSI 43	*/ "No CSI structure available",
/*	EL2HLT 44	*/ "Level 2 halted",
/*	EDEADLK 45	*/ "Deadlock condition",
/*	ENOLCK 46	*/ "No record locks available",
			   "47",
			   "48",
			   "49",
/* EBADE 50	*/ "Invalid exchange",
/* EBADR 51	*/ "Invalid request descriptor",
/* EXFULL 52	*/ "Exchange full",
/* ENOANO 53	*/ "No anode",
/* EBADRQC 54	*/ "Invalid request code",
/* EBADSLT 55	*/ "Invalid slot",
/* EDEADLOCK 56	*/ "File locking deadlock error",
/* EBFONT 57	*/ "Bad font file fmt",
			   "58",
			   "59",
/* ENOSTR 60	*/ "Device not a stream",
/* ENODATA 61	*/ "No data (for no delay io)",
/* ETIME 62	*/ "Timer expired",
/* ENOSR 63	*/ "Out of streams resources",
/* ENONET 64	*/ "Machine is not on the network",
/* ENOPKG 65	*/ "Package not installed",
/* EREMOTE 66	*/ "The object is remote",
/* ENOLINK 67	*/ "The link has been severed",
/* EADV 68		*/ "Advertise error",
/* ESRMNT 69	*/ "Srmount error",
/*	ECOMM 70	*/ "Communication error on send",
/* EPROTO 71	*/ "Protocol error",
			   "72",
			   "73",
/*	EMULTIHOP 74	*/ "Multihop attempted",
/*	ELBIN 75	*/ "Inode is remote (not really error)",
/*	EDOTDOT 76	*/ "Cross mount point (not really error)",
/* EBADMSG 77	*/ "Trying to read unreadable message",
			   "78",
			   "79",
/* ENOTUNIQ 80	*/ "Given log. name not unique",
/* EBADFD 81	*/ "f.d. invalid for this operation",
/* EREMCHG 82	*/ "Remote address changed",
/* ELIBACC 83	*/ "Can't access a needed shared lib",
/* ELIBBAD 84	*/ "Accessing a corrupted shared lib",
/* ELIBSCN 85	*/ ".lib section in a.out corrupted",
/* ELIBMAX 86	*/ "Attempting to link in too many libs",
/* ELIBEXEC 87	*/ "Attempting to exec a shared library",
/* ENOSYS 88	*/ "Function not implemented",
/* ENMFILE 89      */ "No more files",
/* ENOTEMPTY 90	*/ "Directory not empty",
/* ENAMETOOLONG 91	*/ "File or path name too long",
/* ELOOP 92     */ "Too many symbolic links",
		   "93",
		   "94",
/* EOPNOTSUPP 95 */ "Operation not supported on transport endpoint",
/* EPFNOSUPPORT 96 */ "Protocol family not supported",
		   "97",
		   "98",
		   "99",
		   "100",
		   "101",
		   "102",
		   "103",
/* ECONNRESET 104 */ "Connection reset by peer",
/* ENOBUFS 105 */ "No buffer space available",
/* EAFNOSUPPORT 106 */ "Address family not supported by protocol",
/* EPROTOTYPE 107 */ "Protocol wrong type for transport endpoint",
/* ENOTSOCK 108 */  "Socket operation on non-socket",
/* ENOPROTOOPT 109 */ "Protocol not available",
/* ESHUTDOWN 110 */ "Cannot send after transport endpoint shutdown",
/* ECONNREFUSED 111 */ "Connection refused",
/* EADDRINUSE 112 */ "Address already in use",
/* ECONNABORTED 113 */ "Connection aborted",
/* ENETUNREACH 114 */ "Network is unreachable",
/* ENETDOWN 115 */ "Network is down",
/* ETIMEDOUT 116 */ "Connection timed out",
/* EHOSTDOWN 117 */ "Host is down",
/* EHOSTUNREACH 118 */ "No route to host",
/* EINPROGRESS 119 */ "Operation now in progress",
/* EALREADY 120 */ "Operation already in progress",
/* EDESTADDRREQ 121 */ "Destination address required",
/* EMSGSIZE 122 */ "Message too long",
d255 15
a269 15
/* EADDRNOTAVAIL 125 */ "Cannot assign requested address",
/* ENETRESET 126 */ "Network dropped connection because of reset",
/* EISCONN 127 */ "Transport endpoint is already connected",
/* ENOTCONN 128 */ "Transport endpoint is not connected",
/* ETOOMANYREFS 129 */ "Too many references: cannot splice",
/* EPROCLIM 130 */ "Process limit exceeded",
/* EUSERS 131 */ "Too many users",
/* EDQUOT 132 */ "Quota exceeded",
/* ESTALE 133 */ "Stale NFS file handle",
/* ENOTSUP 134 */   "134",
/* ENOMEDIUM 135 */ "no medium",
/* ENOSHARE 136 */   "No such host or network path",
/* ECASECLASH 137 */ "Filename exists with different case",
/* EILSEQ 138 */ "Illegal byte sequence",
/* EOVERFLOW 139 */ "Value too large for defined data type"
a324 1
  switch (errnum)
a325 365
    case EPERM:
      error = "Operation not permitted";
      break;
    case ENOENT:
      error = "No such file or directory";
      break;
    case ESRCH:
      error = "No such process";
      break;
    case EINTR:
      error = "Interrupted system call";
      break;
    case EIO:
      error = "I/O error";
      break;
    case ENXIO:
      error = "No such device or address";
      break;
    case E2BIG:
      error = "Arg list too long";
      break;
    case ENOEXEC:
      error = "Exec format error";
      break;
    case EBADF:
      error = "Bad file descriptor";
      break;
    case ECHILD:
      error = "No children";
      break;
    case EAGAIN:
      error = "Resource temporarily unavailable";
      break;
    case ENOMEM:
      error = "Not enough memory";
      break;
    case EACCES:
      error = "Permission denied";
      break;
    case EFAULT:
      error = "Bad address";
      break;
    case ENOTBLK:
      error = "Block device required";
      break;
    case EBUSY:
      error = "Device or resource busy";
      break;
    case EEXIST:
      error = "File exists";
      break;
    case EXDEV:
      error = "Cross-device link";
      break;
    case ENODEV:
      error = "No such device";
      break;
    case ENOTDIR:
      error = "Not a directory";
      break;
    case EISDIR:
      error = "Is a directory";
      break;
    case EINVAL:
      error = "Invalid argument";
      break;
    case ENFILE:
      error = "Too many open files in system";
      break;
    case EMFILE:
      error = "Too many open files";
      break;
    case ENOTTY:
      error = "Not a character device";
      break;
    case ETXTBSY:
      error = "Text file busy";
      break;
    case EFBIG:
      error = "File too large";
      break;
    case ENOSPC:
      error = "No space left on device";
      break;
    case ESPIPE:
      error = "Illegal seek";
      break;
    case EROFS:
      error = "Read-only file system";
      break;
    case EMLINK:
      error = "Too many links";
      break;
    case EPIPE:
      error = "Broken pipe";
      break;
    case EDOM:
      error = "Math arg out of domain of func";
      break;
    case ERANGE:
      error = "Math result out of range";
      break;
    case ENOMSG:
      error = "No message of desired type";
      break;
    case EIDRM:
      error = "Identifier removed";
      break;
    case ECHRNG:
      error = "Channel number out of range";
      break;
    case EL2NSYNC:
      error = "Level 2 not synchronized";
      break;
    case EL3HLT:
      error = "Level 3 halted";
      break;
    case EL3RST:
      error = "Level 3 reset";
      break;
    case ELNRNG:
      error = "Link number out of range";
      break;
    case EUNATCH:
      error = "Protocol driver not attached";
      break;
    case ENOCSI:
      error = "No CSI structure available";
      break;
    case EL2HLT:
      error = "Level 2 halted";
      break;
    case EDEADLK:
      error = "Deadlock condition";
      break;
    case ENOLCK:
      error = "No lock";
      break;
    case EBADE:
      error = "Invalid exchange";
      break;
    case EBADR:
      error = "Invalid request descriptor";
      break;
    case EXFULL:
      error = "Exchange full";
      break;
    case ENOANO:
      error = "No anode";
      break;
    case EBADRQC:
      error = "Invalid request code";
      break;
    case EBADSLT:
      error = "Invalid slot";
      break;
    case EDEADLOCK:
      error = "File locking deadlock error";
      break;
    case EBFONT:
      error = "Bad font file fmt";
      break;
    case ENOSTR:
      error = "Not a stream";
      break;
    case ENODATA:
      error = "No data (for no delay io)";
      break;
    case ETIME:
      error = "Stream ioctl timeout";
      break;
    case ENOSR:
      error = "No stream resources";
      break;
    case ENONET:
      error = "Machine is not on the network";
      break;
    case ENOPKG:
      error = "No package";
      break;
    case EREMOTE:
      error = "Resource is remote";
      break;
    case ENOLINK:
      error = "Virtual circuit is gone";
      break;
    case EADV:
      error = "Advertise error";
      break;
    case ESRMNT:
      error = "Srmount error";
      break;
    case ECOMM:
      error = "Communication error";
      break;
    case EPROTO:
      error = "Protocol error";
      break;
    case EMULTIHOP:
      error = "Multihop attempted";
      break;
    case ELBIN:
      error = "Inode is remote (not really error)";
      break;
    case EDOTDOT:
      error = "Cross mount point (not really error)";
      break;
    case EBADMSG:
      error = "Bad message";
      break;
    case ENOTUNIQ:
      error = "Given log. name not unique";
      break;
    case EBADFD:
      error = "f.d. invalid for this operation";
      break;
    case EREMCHG:
      error = "Remote address changed";
      break;
    case ELIBACC:
      error = "Cannot access a needed shared library";
      break;
    case ELIBBAD:
      error = "Accessing a corrupted shared library";
      break;
    case ELIBSCN:
      error = ".lib section in a.out corrupted";
      break;
    case ELIBMAX:
      error = "Attempting to link in more shared libraries than system limit";
      break;
    case ELIBEXEC:
      error = "Cannot exec a shared library directly";
      break;
    case ENOSYS:
      error = "Function not implemented";
      break;
    case ENMFILE:
      error = "No more files";
      break;
    case ENOTEMPTY:
      error = "Directory not empty";
      break;
    case ENAMETOOLONG:
      error = "File or path name too long";
      break;
    case ELOOP:
      error = "Too many symbolic links";
      break;
    case EOPNOTSUPP:
      error = "Operation not supported on transport endpoint";
      break;
    case EPFNOSUPPORT:
      error = "Protocol family not supported";
      break;
    case ECONNRESET:
      error = "Connection reset by peer";
      break;
    case ENOBUFS:
      error = "No buffer space available; the socket cannot be connected";
      break;
    case EAFNOSUPPORT:
      error = "Addresses in the specified family cannot be used with this socket";
      break;
    case EPROTOTYPE:
      error = "errno EPROTOTYPE triggered";
      break;
    case ENOTSOCK:
      error = "The descriptor is a file, not a socket";
      break;
    case ENOPROTOOPT:
      error = "This option is unsupported";
      break;
    case ESHUTDOWN:
      error = "errno ESHUTDOWN triggered";
      break;
    case ECONNREFUSED:
      error = "Connection refused";
      break;
    case EADDRINUSE:
      error = "Address already in use";
      break;
    case ECONNABORTED:
      error = "The connection was aborted";
      break;
    case ENETUNREACH:
      error ="The network can't be reached from this host at this time";
      break;
    case ENETDOWN:
      error = "Network failed.";
      break;
    case ETIMEDOUT:
      error = "Attempt to connect timed out without establishing a connection";
      break;
    case EHOSTDOWN:
      error = "errno EHOSTDOWN triggered";
      break;
    case EHOSTUNREACH:
      error = "errno EHOSTUNREACH triggered";
      break;
    case EINPROGRESS:
      error = "errno EINPROGRESS triggered";
      break;
    case EALREADY:
      error = "errno EALREADY triggered";
      break;
    case EDESTADDRREQ:
      error = "errno EDESTADDRREQ triggered";
      break;
    case EMSGSIZE:
      error = "errno EMSGSIZE triggered";
      break;

    case EPROTONOSUPPORT:
      error = "errno EPROTONOSUPPORT triggered";
      break;
    case ESOCKTNOSUPPORT:
      error = "errno ESOCKTNOSUPPORT triggered";
      break;
    case EADDRNOTAVAIL:
      error = "errno EADDRNOTAVAIL triggered";
      break;
    case ENETRESET:
      error = "errno ENETRESET triggered";
      break;
    case EISCONN:
      error = "The socket is already connected";
      break;
    case ENOTCONN:
      error = "The socket is not connected";
      break;
    case ETOOMANYREFS:
      error = "errno ETOOMANYREFS triggered";
      break;
    case EPROCLIM:
      error = "errno EPROCLIM triggered";
      break;
    case EUSERS:
      error = "errno EUSERS triggered";
      break;
    case EDQUOT:
      error = "errno EDQUOT triggered";
      break;
    case ESTALE:
      error = "errno ESTALE triggered";
      break;
    case ENOTSUP:
      error = "errno ENOTSUP triggered";
      break;
    case ENOMEDIUM:
      error = "no medium";
      break;
    case ENOSHARE:
      error = "No such host or network path";
      break;
    case ECASECLASH:
      error = "Filename exists with different case";
      break;
    case EILSEQ:
      error = "Illegal byte sequence";
      break;
    case EOVERFLOW:
      error = "Value too large for defined data type";
      break;
    default:
a327 1
      break;
a328 1

@


1.43
log
@	* errno.cc (errmap): Handle ERROR_IO_PENDING.
	* fhandler.cc (fhandler_base::open): Make tape I/O asynchronous.
	* fhandler.h (class fhandler_dev_tape): Add mt_evt member.
	* fhandler_tape.cc (mtinfo_drive::initialize): Initialize async_writes.
	(mtinfo_drive::close): Handle async writes.
	(mtinfo_drive::read): Add mt_evt parameter.  Use overlapped I/O.
	(mtinfo_drive::async_wait): New function.
	(mtinfo_drive::write): Add mt_evt parameter.  Use overlapped I/O.
	Handle async writes.
	(mtinfo_drive::_set_pos): Handle async writes.
	(mtinfo_drive::set_partition): Ditto.
	(mtinfo_drive::prepare): Ditto.
	(mtinfo_drive::get_status): Drop useless "else".  Handle async_writes
	flag.
	(mtinfo_drive::set_options): Handle async_writes flags.
	(fhandler_dev_tape::close): Close mt_evt handle.
	(fhandler_dev_tape::raw_read): Create mt_evt handle and use in call
	to mtinfo_drive::read.
	(fhandler_dev_tape::raw_write): Create mt_evt handle and use in call
	to mtinfo_drive::write.
	* mtinfo.h (MTINFO_VERSION): Bump.
	(enum dirty_state): Add async_write_pending state.
	(class mtinfo_drive): Add OVERLAPPED struct "ov".  Add async_writes
	flag.
	(mtinfo_drive::async_wait): Add declaration.
	(mtinfo_drive::read): Add mt_evt parameter.
	(mtinfo_drive::write): Ditto.

	* registry.cc (load_registry_hive): Call enable_restore_privilege
	instead of set_process_privilege.
@
text
@d123 1
@


1.42
log
@	* errno.cc (errmap): Map ERROR_SHARING_VIOLATION to EBUSY,
	ERROR_EOM_OVERFLOW and ERROR_NO_DATA_DETECTED to EIO.  Add mappings
	for ERROR_NO_MEDIA_IN_DRIVE, ERROR_DEVICE_REQUIRES_CLEANING and
	ERROR_DEVICE_DOOR_OPEN.
	* fhandler.h (class fhandler_dev_raw): Drop varblkop member.
	(fhandler_dev_raw::is_eom): De-virtualize.
	(fhandler_dev_raw::is_eof): Ditto.
	(class fhandler_dev_tape): Drop lasterr and dp member.  Add mt_mtx
	member.  Drop all private methods formerly used by ioctl.
	(fhandler_dev_tape::is_rewind_device): Use get_minor for clarity.
	(fhandler_dev_tape::driveno): New method.
	(fhandler_dev_tape::drive_init): New method.
	(fhandler_dev_tape::clear): Remove method.
	(fhandler_dev_tape::is_eom): Ditto.
	(fhandler_dev_tape::is_eof): Ditto.
	(fhandler_dev_tape::write_file): Ditto.
	(fhandler_dev_tape::read_file): Ditto.
	(fhandler_dev_tape::_lock): New method.
	(fhandler_dev_tape::unlock): New method.
	(fhandler_dev_tape::raw_read): New method.
	(fhandler_dev_tape::raw_write): New method.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): New method.
	(fhandler_dev_raw::is_eof): New method.
	(fhandler_dev_raw::open): Allow setting write through option by
	using the O_TEXT flag as ... flag.
	(fhandler_dev_raw::writebuf): Remove usage of varblkop and other
	tape specific code.
	(fhandler_dev_raw::raw_read): Ditto.
	(fhandler_dev_raw::dup): Ditto.
	* fhandler_tape.cc: Rewrite tape operations entirely.  Implement
	new tape driver classes mtinfo, mtinfo_drive and mtinfo_part.
	Reduce fhandler_dev_tape methods to mostly just calling appropriate
	mtinfo_drive methods.
	(mtinfo_init): New function adding the mtinfo shared memory area.
	* mtinfo.h: New file, containing the definition of the new tape
	driver classes.
	* shared.cc: Include mtinfo.h.
	(offsets): Add entry for mtinfo shared memory area.
	(memory_init): Call mtinfo_init.
	* shared_info.h (shared_locations): Add SH_MTINFO shared location.
	* include/cygwin/mtio.h: Change and add various comments.  Add GMT_xxx
	macros for new generic flags.  Add MT_ST_xxx bitfield definitions
	for MTSETDRVBUFFER ioctl.
	* include/cygwin/version.h: Bump API minor version number.
@
text
@d122 1
@


1.41
log
@	* errno.cc (errmap): Map ERROR_BEGINNING_OF_MEDIA and
	ERROR_SETMARK_DETECTED to EIO instead of ESPIPE.
	Handle ERROR_FILEMARK_DETECTED.
	* fhandler_tape.cc (TAPE_FUNC): Add comment that ERROR_BUS_RESET
	has still to be handled correctly.
	(fhandler_dev_tape::open): Accomodate fact that get.mt_dsreg
	also contains density code.
	(fhandler_dev_tape::ioctl): Rearrange slightly.  Reset devbuf also on
	MTNOP, MTWSM, MTSETBLK, MTSETDRVBUFFER, MTSETPART and MTMKPART.
	(fhandler_dev_tape::tape_set_pos): Rearrange.  Match behaviour to
	the Linux tape driver.
	(fhandler_dev_tape::tape_status): Call IOCTL_STORAGE_GET_MEDIA_TYPES_EX
	if available.  Return device type and density code in appropriate
	mtget members.
	* wincap.h (wincaps::has_ioctl_storage_get_media_types_ex): New element.
	* wincap.cc: Implement above element throughout.
	* include/cygwin/mtio.h: Add tape device types as returned by
	IOCTL_STORAGE_GET_MEDIA_TYPES_EX.
	(MT_TAPE_INFO): Use above type codes.
	(struct mtget): Change mt_dsreg comment.
@
text
@d51 1
a51 1
  X (SHARING_VIOLATION,		EACCES),
d104 1
a104 1
  X (EOM_OVERFLOW,		ENOSPC),
d107 1
a107 1
  X (NO_DATA_DETECTED,		ENOSPC),
d119 3
@


1.40
log
@	* errno.cc (errmap): Handle ERROR_BUS_RESET.
	* fhandler.h (fhandler_dev_raw::write_file): New method, created
	from former static function.
	(fhandler_dev_raw::read_file): Ditto.
	(reset_devbuf): New inline method.
	(class fhandler_dev_tape): Add TAPE_GET_DRIVE_PARAMETERS
	member `dp'.
	(fhandler_dev_tape::write_file): New method.
	(fhandler_dev_tape::read_file): Ditto.
	(fhandler_dev_tape::tape_get_feature): Convert to inline method.
	(fhandler_dev_tape::tape_error): New method, created from former
	static function.
	(fhandler_dev_tape::tape_get_blocksize): Remove declaration.
	* fhandler_raw.cc (fhandler_dev_raw::write_file): New method, created
	from former static function.
	(fhandler_dev_raw::read_file): Ditto.
	(fhandler_dev_raw::writebuf): Accomodate the fact that no devbuf
	exists under variable block size condition.
	(fhandler_dev_raw::raw_read): Ditto. Add local p pointer to simplify
	pointer arithmetic.
	(fhandler_dev_raw::raw_write): Always set devbufend to 0 when starting
	with writing. Accomodate the fact that no devbuf exists under
	variable block size condition.
	* fhandler_tape.cc: Various formatting changes.
	(TAPE_FUNC): New macro. Use throughout as tape function loop.
	(get_ll): Convert into macro.
	(IS_EOM): New macro.
	(IS_EOF): New macro.
	(fhandler_dev_tape::is_eom): Use IS_EOM macro.
	(fhandler_dev_tape::is_eof): Use IS_EOF macro.
	(fhandler_dev_tape::write_file): New method.
	(fhandler_dev_tape::read_file): New method.
	(fhandler_dev_tape::open): Get drive information block here once.
	(fhandler_dev_tape::lseek): Remove unneeded duplicate code.
	(fhandler_dev_tape::dup): Duplicate drive information block.
	(fhandler_dev_tape::ioctl): Remove drvbuf in variable block size mode.
	Return ERROR_INVALID_BLOCK_LENGTH instead of ERROR_MORE_DATA if
	buffer contains data which would get lost on buffer size changing.
	Use absolute tape positioning also if drive only supports logical
	block positioning.
	(fhandler_dev_tape::tape_error): New method, created from former
	static function.
	(fhandler_dev_tape::tape_get_pos): Allow logical block reporting.
	Workaround tape driver bug.
	(fhandler_dev_tape::_tape_set_pos): Reset device buffer and flags
	after successful repositioning.
	(fhandler_dev_tape::tape_set_pos): Allow logical block positioning.
	Workaround tape driver bug.
	(fhandler_dev_tape::tape_erase): Use dp instead of calling
	GetTapeParameters.
	(fhandler_dev_tape::tape_prepare): Ditto.
	(fhandler_dev_tape::tape_get_blocksize): Remove.
	(fhandler_dev_tape::tape_set_blocksize): Don't call tape_get_blocksize.
	Error handling already done in fhandler_dev_tape::ioctl.
	(fhandler_dev_tape::tape_status): Remove local `dp' variable.
	Accomodate logical tape reporting.  Call tape_get_feature instead
	of accessing feature words directly.
	(fhandler_dev_tape::tape_compression): Use dp instead of calling
	GetTapeParameters.  Fix resetting datcompression.
@
text
@d105 2
a106 2
  X (BEGINNING_OF_MEDIA,	ESPIPE),
  X (SETMARK_DETECTED,		ESPIPE),
d118 1
@


1.39
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d117 1
@


1.38
log
@	* errno.cc (errmap): Map ERROR_INVALID_BLOCK_LENGTH to EIO.
	* fhandler_raw.cc (fhandler_dev_raw::raw_read): Set more accurate
	errnos instead of EACCES.
	(fhandler_dev_raw::raw_write): Ditto.
@
text
@d18 1
d685 2
a686 7
#ifdef _MT_SAFE
      char *buf= _reent_winsup ()->_strerror_buf;
#else
      static NO_COPY char buf[20];
#endif
      __small_sprintf (buf, "error %d", errnum);
      error = buf;
@


1.37
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d115 1
@


1.36
log
@* dir.cc (readdir): Fill out new old_d_ino field.
* fhandler.h (fhandler_base::namehash): Define as ino_t.
(fhandler_base::get_namehash): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Accommodate new 64
bit st_ino.
* fhandler_socket.cc (fhandler_socket::fstat): Ditto.
* path.cc (hash_path_name): Return ino_t.
* syscalls.cc (stat64_to_stat32): Convert 64 bit inode to 32 bit.
* winsup.h (hash_path_name): Declare as returning ino_t.
* include/cygwin/stat.h (__stat32): Use 32 bit st_ino.
(__stat64): Use 64 bit st_ino.
* include/cygwin/types.h (__ino64_t): Define.
(__ino32_t): Ditto.
(ino_t): Define appropriately.
@
text
@a14 1
#define _REENT_ONLY
a15 1
#include <errno.h>
@


1.35
log
@revert errnoneous checkin
@
text
@d13 1
d22 1
d30 6
a35 7
static const NO_COPY struct
  {
    DWORD w;		 /* windows version of error */
    const char *s;	 /* text of windows version */
    int e;		 /* errno version of error */
  }
errmap[] =
a119 34
int __stdcall
geterrno_from_win_error (DWORD code, int deferrno)
{
  for (int i = 0; errmap[i].w != 0; ++i)
    if (code == errmap[i].w)
      {
	syscall_printf ("windows error %u == errno %d", code, errmap[i].e);
	return errmap[i].e;
      }

  syscall_printf ("unknown windows error %u, setting errno to %d", code,
		  deferrno);
  return deferrno;	/* FIXME: what's so special about EACCESS? */
}

/* seterrno_from_win_error: Given a Windows error code, set errno
   as appropriate. */
void __stdcall
seterrno_from_win_error (const char *file, int line, DWORD code)
{
  syscall_printf ("%s:%d windows error %d", file, line, code);
  set_errno (geterrno_from_win_error (code, EACCES));
  return;
}

/* seterrno: Set `errno' based on GetLastError (). */
void __stdcall
seterrno (const char *file, int line)
{
  seterrno_from_win_error (file, line, GetLastError ());
}

extern char *_user_strerror _PARAMS ((int));

d121 1
a121 1
const NO_COPY char __declspec(dllexport) * const _sys_errlist[]=
d265 1
a265 1
extern const int NO_COPY __declspec(dllexport) _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
d267 34
@


1.34
log
@* cygthread.cc (cygthread::detach): Prioritize waiting for I/O completion over
waiting for signal delivery.
@
text
@a12 1
#define sys_errlist FOOsys_errlist
a20 1
#undef sys_errlist
d28 125
d154 1
a154 1
const char __declspec(dllexport) * _sys_errlist[] NO_COPY_INIT =
d298 1
a298 1
int NO_COPY_INIT _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
a299 125

static const NO_COPY struct
  {
    DWORD w;		 /* windows version of error */
    const char *s;	 /* text of windows version */
    int e;		 /* errno version of error */
  }
errmap[] =
{
  /* FIXME: Some of these choices are arbitrary! */
  X (INVALID_FUNCTION,		EBADRQC),
  X (FILE_NOT_FOUND,		ENOENT),
  X (PATH_NOT_FOUND,		ENOENT),
  X (TOO_MANY_OPEN_FILES,	EMFILE),
  X (ACCESS_DENIED,		EACCES),
  X (INVALID_HANDLE,		EBADF),
  X (NOT_ENOUGH_MEMORY,		ENOMEM),
  X (INVALID_DATA,		EINVAL),
  X (OUTOFMEMORY,		ENOMEM),
  X (INVALID_DRIVE,		ENODEV),
  X (NOT_SAME_DEVICE,		EXDEV),
  X (NO_MORE_FILES,		ENMFILE),
  X (WRITE_PROTECT,		EROFS),
  X (BAD_UNIT,			ENODEV),
  X (SHARING_VIOLATION,		EACCES),
  X (LOCK_VIOLATION,		EACCES),
  X (SHARING_BUFFER_EXCEEDED,	ENOLCK),
  X (HANDLE_EOF,		ENODATA),
  X (HANDLE_DISK_FULL,		ENOSPC),
  X (NOT_SUPPORTED,		ENOSYS),
  X (REM_NOT_LIST,		ENONET),
  X (DUP_NAME,			ENOTUNIQ),
  X (BAD_NETPATH,		ENOSHARE),
  X (BAD_NET_NAME,		ENOSHARE),
  X (FILE_EXISTS,		EEXIST),
  X (CANNOT_MAKE,		EPERM),
  X (INVALID_PARAMETER,		EINVAL),
  X (NO_PROC_SLOTS,		EAGAIN),
  X (BROKEN_PIPE,		EPIPE),
  X (OPEN_FAILED,		EIO),
  X (NO_MORE_SEARCH_HANDLES,	ENFILE),
  X (CALL_NOT_IMPLEMENTED,	ENOSYS),
  X (INVALID_NAME,		ENOENT),
  X (WAIT_NO_CHILDREN,		ECHILD),
  X (CHILD_NOT_COMPLETE,	EBUSY),
  X (DIR_NOT_EMPTY,		ENOTEMPTY),
  X (SIGNAL_REFUSED,		EIO),
  X (BAD_PATHNAME,		ENOENT),
  X (SIGNAL_PENDING,		EBUSY),
  X (MAX_THRDS_REACHED,		EAGAIN),
  X (BUSY,			EBUSY),
  X (ALREADY_EXISTS,		EEXIST),
  X (NO_SIGNAL_SENT,		EIO),
  X (FILENAME_EXCED_RANGE,	EINVAL),
  X (META_EXPANSION_TOO_LONG,	EINVAL),
  X (INVALID_SIGNAL_NUMBER,	EINVAL),
  X (THREAD_1_INACTIVE,		EINVAL),
  X (BAD_PIPE,			EINVAL),
  X (PIPE_BUSY,			EBUSY),
  X (NO_DATA,			EPIPE),
  X (PIPE_NOT_CONNECTED,	ECOMM),
  X (MORE_DATA,			EAGAIN),
  X (DIRECTORY,			ENOTDIR),
  X (PIPE_CONNECTED,		EBUSY),
  X (PIPE_LISTENING,		ECOMM),
  X (NO_TOKEN,			EINVAL),
  X (PROCESS_ABORTED,		EFAULT),
  X (BAD_DEVICE,		ENODEV),
  X (BAD_USERNAME,		EINVAL),
  X (NOT_CONNECTED,		ENOLINK),
  X (OPEN_FILES,		EAGAIN),
  X (ACTIVE_CONNECTIONS,	EAGAIN),
  X (DEVICE_IN_USE,		EAGAIN),
  X (INVALID_AT_INTERRUPT_TIME,	EINTR),
  X (IO_DEVICE,			EIO),
  X (NOT_OWNER,			EPERM),
  X (END_OF_MEDIA,		ENOSPC),
  X (EOM_OVERFLOW,		ENOSPC),
  X (BEGINNING_OF_MEDIA,	ESPIPE),
  X (SETMARK_DETECTED,		ESPIPE),
  X (NO_DATA_DETECTED,		ENOSPC),
  X (POSSIBLE_DEADLOCK,		EDEADLOCK),
  X (CRC,			EIO),
  X (NEGATIVE_SEEK,		EINVAL),
  X (NOT_READY,			ENOMEDIUM),
  X (DISK_FULL,			ENOSPC),
  X (NOACCESS,			EFAULT),
  X (FILE_INVALID,		ENXIO),
  X (INVALID_ADDRESS,		EOVERFLOW),
  { 0, NULL, 0}
};

int __stdcall
geterrno_from_win_error (DWORD code, int deferrno)
{
  for (int i = 0; errmap[i].w != 0; ++i)
    if (code == errmap[i].w)
      {
	syscall_printf ("windows error %u == errno %d", code, errmap[i].e);
	return errmap[i].e;
      }

  syscall_printf ("unknown windows error %u, setting errno to %d", code,
		  deferrno);
  return deferrno;	/* FIXME: what's so special about EACCESS? */
}

/* seterrno_from_win_error: Given a Windows error code, set errno
   as appropriate. */
void __stdcall
seterrno_from_win_error (const char *file, int line, DWORD code)
{
  syscall_printf ("%s:%d windows error %d", file, line, code);
  set_errno (geterrno_from_win_error (code, EACCES));
  return;
}

/* seterrno: Set `errno' based on GetLastError (). */
void __stdcall
seterrno (const char *file, int line)
{
  seterrno_from_win_error (file, line, GetLastError ());
}

extern char *_user_strerror _PARAMS ((int));
@


1.33
log
@really check in correct fix.
@
text
@d13 1
d22 1
a29 125
static const NO_COPY struct
  {
    DWORD w;		 /* windows version of error */
    const char *s;	 /* text of windows version */
    int e;		 /* errno version of error */
  }
errmap[] =
{
  /* FIXME: Some of these choices are arbitrary! */
  X (INVALID_FUNCTION,		EBADRQC),
  X (FILE_NOT_FOUND,		ENOENT),
  X (PATH_NOT_FOUND,		ENOENT),
  X (TOO_MANY_OPEN_FILES,	EMFILE),
  X (ACCESS_DENIED,		EACCES),
  X (INVALID_HANDLE,		EBADF),
  X (NOT_ENOUGH_MEMORY,		ENOMEM),
  X (INVALID_DATA,		EINVAL),
  X (OUTOFMEMORY,		ENOMEM),
  X (INVALID_DRIVE,		ENODEV),
  X (NOT_SAME_DEVICE,		EXDEV),
  X (NO_MORE_FILES,		ENMFILE),
  X (WRITE_PROTECT,		EROFS),
  X (BAD_UNIT,			ENODEV),
  X (SHARING_VIOLATION,		EACCES),
  X (LOCK_VIOLATION,		EACCES),
  X (SHARING_BUFFER_EXCEEDED,	ENOLCK),
  X (HANDLE_EOF,		ENODATA),
  X (HANDLE_DISK_FULL,		ENOSPC),
  X (NOT_SUPPORTED,		ENOSYS),
  X (REM_NOT_LIST,		ENONET),
  X (DUP_NAME,			ENOTUNIQ),
  X (BAD_NETPATH,		ENOSHARE),
  X (BAD_NET_NAME,		ENOSHARE),
  X (FILE_EXISTS,		EEXIST),
  X (CANNOT_MAKE,		EPERM),
  X (INVALID_PARAMETER,		EINVAL),
  X (NO_PROC_SLOTS,		EAGAIN),
  X (BROKEN_PIPE,		EPIPE),
  X (OPEN_FAILED,		EIO),
  X (NO_MORE_SEARCH_HANDLES,	ENFILE),
  X (CALL_NOT_IMPLEMENTED,	ENOSYS),
  X (INVALID_NAME,		ENOENT),
  X (WAIT_NO_CHILDREN,		ECHILD),
  X (CHILD_NOT_COMPLETE,	EBUSY),
  X (DIR_NOT_EMPTY,		ENOTEMPTY),
  X (SIGNAL_REFUSED,		EIO),
  X (BAD_PATHNAME,		ENOENT),
  X (SIGNAL_PENDING,		EBUSY),
  X (MAX_THRDS_REACHED,		EAGAIN),
  X (BUSY,			EBUSY),
  X (ALREADY_EXISTS,		EEXIST),
  X (NO_SIGNAL_SENT,		EIO),
  X (FILENAME_EXCED_RANGE,	EINVAL),
  X (META_EXPANSION_TOO_LONG,	EINVAL),
  X (INVALID_SIGNAL_NUMBER,	EINVAL),
  X (THREAD_1_INACTIVE,		EINVAL),
  X (BAD_PIPE,			EINVAL),
  X (PIPE_BUSY,			EBUSY),
  X (NO_DATA,			EPIPE),
  X (PIPE_NOT_CONNECTED,	ECOMM),
  X (MORE_DATA,			EAGAIN),
  X (DIRECTORY,			ENOTDIR),
  X (PIPE_CONNECTED,		EBUSY),
  X (PIPE_LISTENING,		ECOMM),
  X (NO_TOKEN,			EINVAL),
  X (PROCESS_ABORTED,		EFAULT),
  X (BAD_DEVICE,		ENODEV),
  X (BAD_USERNAME,		EINVAL),
  X (NOT_CONNECTED,		ENOLINK),
  X (OPEN_FILES,		EAGAIN),
  X (ACTIVE_CONNECTIONS,	EAGAIN),
  X (DEVICE_IN_USE,		EAGAIN),
  X (INVALID_AT_INTERRUPT_TIME,	EINTR),
  X (IO_DEVICE,			EIO),
  X (NOT_OWNER,			EPERM),
  X (END_OF_MEDIA,		ENOSPC),
  X (EOM_OVERFLOW,		ENOSPC),
  X (BEGINNING_OF_MEDIA,	ESPIPE),
  X (SETMARK_DETECTED,		ESPIPE),
  X (NO_DATA_DETECTED,		ENOSPC),
  X (POSSIBLE_DEADLOCK,		EDEADLOCK),
  X (CRC,			EIO),
  X (NEGATIVE_SEEK,		EINVAL),
  X (NOT_READY,			ENOMEDIUM),
  X (DISK_FULL,			ENOSPC),
  X (NOACCESS,			EFAULT),
  X (FILE_INVALID,		ENXIO),
  X (INVALID_ADDRESS,		EOVERFLOW),
  { 0, NULL, 0}
};

int __stdcall
geterrno_from_win_error (DWORD code, int deferrno)
{
  for (int i = 0; errmap[i].w != 0; ++i)
    if (code == errmap[i].w)
      {
	syscall_printf ("windows error %u == errno %d", code, errmap[i].e);
	return errmap[i].e;
      }

  syscall_printf ("unknown windows error %u, setting errno to %d", code,
		  deferrno);
  return deferrno;	/* FIXME: what's so special about EACCESS? */
}

/* seterrno_from_win_error: Given a Windows error code, set errno
   as appropriate. */
void __stdcall
seterrno_from_win_error (const char *file, int line, DWORD code)
{
  syscall_printf ("%s:%d windows error %d", file, line, code);
  set_errno (geterrno_from_win_error (code, EACCES));
  return;
}

/* seterrno: Set `errno' based on GetLastError (). */
void __stdcall
seterrno (const char *file, int line)
{
  seterrno_from_win_error (file, line, GetLastError ());
}

extern char *_user_strerror _PARAMS ((int));

d31 1
a31 1
const NO_COPY char __declspec(dllexport) * const _sys_errlist[]=
d175 1
a175 1
extern const int NO_COPY __declspec(dllexport) _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
d177 125
@


1.32
log
@* errno.cc (_sys_nerr): Fix compile error erroneously checked in on 2003-04-23.
@
text
@d298 1
a298 1
const int NO_COPY __declspec(dllexport) _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
@


1.31
log
@* fork.cc: Change SLOW_PID_REUSE to NO_SLOW_PID_REUSE and invert ifdef sense
throughout.
@
text
@d298 1
a298 1
int NO_COPY __declspec(dllexport) _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
@


1.30
log
@	* errno.cc (errmap): Map ERROR_INVALID_ADDRESS to new errno code
	EOVERFLOW.
	(_sys_errlist): Add entries for EILSEQ and EOVERFLOW.
	(strerror): Ditto.
	* mmap.cc (map_map): Set errno in case of error.
	(mmap64): Remove setting errno explicitely to ENOMEM.
@
text
@d293 2
a294 2
/* ECASECLASH 137 */ "Filename exists with different case"
/* EILSEQ 138 */ "Illegal byte sequence"
d298 1
a298 1
extern int const NO_COPY __declspec(dllexport) _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
@


1.30.16.1
log
@merge from trunk
@
text
@d684 1
d686 3
@


1.30.16.2
log
@merge from trunk
@
text
@d293 2
a294 2
/* ECASECLASH 137 */ "Filename exists with different case",
/* EILSEQ 138 */ "Illegal byte sequence",
d298 1
a298 1
extern const int NO_COPY __declspec(dllexport) _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
@


1.30.16.3
log
@merge from trunk
@
text
@a12 1
#define _sys_errlist FOO_sys_errlist
d14 1
d16 1
a20 1
#undef _sys_errlist
d28 7
a34 6
static NO_COPY struct
{
  DWORD w;		 /* windows version of error */
  const char *s;	 /* text of windows version */
  int e;		 /* errno version of error */
} errmap[] =
d119 34
d154 1
a154 1
const char __declspec(dllexport) * _sys_errlist[] NO_COPY_INIT =
d298 1
a298 1
int NO_COPY_INIT _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
a300 34
int __stdcall
geterrno_from_win_error (DWORD code, int deferrno)
{
  for (int i = 0; errmap[i].w != 0; ++i)
    if (code == errmap[i].w)
      {
	syscall_printf ("windows error %u == errno %d", code, errmap[i].e);
	return errmap[i].e;
      }

  syscall_printf ("unknown windows error %u, setting errno to %d", code,
		  deferrno);
  return deferrno;	/* FIXME: what's so special about EACCESS? */
}

/* seterrno_from_win_error: Given a Windows error code, set errno
   as appropriate. */
void __stdcall
seterrno_from_win_error (const char *file, int line, DWORD code)
{
  syscall_printf ("%s:%d windows error %d", file, line, code);
  set_errno (geterrno_from_win_error (code, EACCES));
  return;
}

/* seterrno: Set `errno' based on GetLastError (). */
void __stdcall
seterrno (const char *file, int line)
{
  seterrno_from_win_error (file, line, GetLastError ());
}

extern char *_user_strerror _PARAMS ((int));

a683 1
#ifdef _MT_SAFE
a684 3
#else
      static NO_COPY char buf[20];
#endif
@


1.30.16.4
log
@merge from trunk
@
text
@a114 1
  X (INVALID_BLOCK_LENGTH,	EIO),
@


1.29
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d115 1
d294 2
d676 6
@


1.28
log
@* syscalls.c (seteuid32): Do not return an error when the token cannot be
created only because of a problem with the gid.
@
text
@d676 1
a676 1
      char *buf= _reent_winsup()->_strerror_buf;
@


1.27
log
@* errno.cc: Change text description for EBADF throughout.
@
text
@d138 1
a138 1
  syscall_printf ("%s:%d errno %d", file, line, code);
@


1.26
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d164 1
a164 1
/*	EBADF 9		*/ "Bad file number",
d341 1
a341 1
      error = "Bad file number";
@


1.25
log
@* errno.cc: Change EPERM associated text to "Operation not permitted"
throughout.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.24
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d156 1
a156 1
/*	EPERM 1		*/ "Not super-user",
d311 3
d317 1
a317 1
      error = "Not owner";
@


1.23
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d11 2
d19 2
d152 2
a153 1
extern const NO_COPY char __declspec(dllexport) * const _sys_errlist[]=
d295 2
a296 2
int NO_COPY __declspec(dllexport) _sys_nerr =
  sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
@


1.23.4.1
log
@Merged changes from HEAD
@
text
@a10 2
#define _sys_nerr FOO_sys_nerr
#define sys_nerr FOOsys_nerr
a16 2
#undef _sys_nerr
#undef sys_nerr
d148 1
a148 2
extern "C" {
const NO_COPY char __declspec(dllexport) * const _sys_errlist[]=
d290 2
a291 2
extern int const NO_COPY __declspec(dllexport) _sys_nerr = sizeof (_sys_errlist) / sizeof (_sys_errlist[0]);
};
@


1.23.4.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d156 1
a156 1
/*	EPERM 1		*/ "Operation not permitted",
a310 3
  if (errnum < _sys_nerr)
    error = _sys_errlist [errnum];
  else
d314 1
a314 1
      error = "Operation not permitted";
@


1.23.4.3
log
@Merged changes from HEAD
@
text
@d164 1
a164 1
/*	EBADF 9		*/ "Bad file descriptor",
d341 1
a341 1
      error = "Bad file descriptor";
@


1.23.4.4
log
@Merged changes from HEAD
@
text
@d138 1
a138 1
  syscall_printf ("%s:%d windows error %d", file, line, code);
@


1.23.4.5
log
@Merged changes from HEAD
@
text
@d676 1
a676 1
      char *buf= _reent_winsup ()->_strerror_buf;
@


1.22
log
@forced commit
@
text
@d24 1
a24 1
static const struct
d148 1
a148 1
extern const char __declspec(dllexport) * const _sys_errlist[]=
d290 1
a290 1
int __declspec(dllexport) _sys_nerr =
@


1.21
log
@* errno.cc (_sys_errlist): Add missing commas.
@
text
@@


1.20
log
@        * dir.cc (mkdir): Check for case clash.
        * environ.cc: Add extern declaration for `pcheck_case'.
        (check_case_init): New function.
        (struct parse_thing): Add "check_case" option.
        * errno.cc (_sys_nerrlist): Add text for ECASECLASH.
        (strerror): Add case branch for ECASECLASH.
        * fhandler.cc (fhandler_disk_file::open): Check for case clash.
        * path.cc: Add global variable `pcheck_case'.
        (struct symlink_info): Add member `case_clash' and method `case_check'.
        (path_prefix_p_): Call `pathnmatch' instead of `strncasematch'.
        (pathnmatch): New funtion.
        (pathmatch): Ditto.
        (path_conv::check): Add handling for case checking.
        (symlink): Check for case clash.
        (symlink_info::check): Add parameter for case checking.
        Handle case checking.
        (symlink_info::case_check): New method.
        (chdir): Don't use unconverted path if pcheck_case==PCHECK_STRICT.
        * path.h: Add extern declarations for `pathmatch' and
        `pathnmatch'.
        (enum case_checking): New enumeration type describing
        the case checking behaviour of path conversion routines.
        (class path_conv): Add member `case_clash'.
        * syscalls.cc (_link): Check for case clash.
@
text
@d258 1
a258 1
/* ENOTSOCK 108 */  "Socket operation on non-socket"
d262 1
a262 1
/* EADDRINUSE 112 */ "Address already in use"
@


1.19
log
@        * errno.cc (errmap): Map ERROR_FILE_INVALID to ENXIO.
@
text
@d286 2
a287 1
/* ENOSHARE 136 */   "No such host or network path"
d662 3
@


1.18
log
@Update copyrights.
@
text
@d110 1
@


1.17
log
@        * cygerrno.h: Revert previous patch.
        * errno.cc: Ditto.
        * dir.cc: Eliminate `dir_suffixes'.
        (opendir): Remove usage of `dir_suffixes'.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::open): Remove usage of
        `inner_suffixes'.
        * path.cc: Rename `inner_suffixes' to `lnk_suffixes'.
        (path_conv::check): Remove usage of `inner_suffixes'.
        (symlink): Ditto.
        (symlink_info::check): Handle checking for `.lnk' in path_conv
        exclusively here.
        (chdir): Remove usage of `dir_suffixes'.
        * shortcut.c: Eliminate debug_printf lines.
        (check_shortcut): Don't set error except on failing ReadFile.
        * spawn.cc: Remove ".lnk" from `std_suffixes'.
        * syscalls.cc (_unlink): Remove usage of `inner_suffixes'.
        Remove ".lnk" from `stat_suffixes'.
        (_rename): Add check for renaming a symlink to keep the ".lnk"
        suffix after renaming.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.16
log
@        * shortcut.c: New file. Provides a C interface to reading of
        Windows shortcuts to avoid compiler flag `-fvtable-thunks'.
        * shortcut.h: Ditto.
        * Makefile.in: Add shortcut.o to DLL_OFILES.
        * cygerrno.h: Provide a C interface to `geterrno_from_win_error' for
        using in shortcut.c.
        * errno.cc (geterrno_from_win_error): Define as extern "C".
        * path.cc (struct symlink_info): Remove methods `check_shortcut' and
        `check_sysfile'.
        (shortcut_header): Move to shortcut.c.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): Ditto.
        (cmp_shortcut_header): Ditto.
        (symlink_info::check_shortcut): Ditto. Reorganize as a plain C function.
        (symlink_info::check_sysfile): Redefine as a global function using the
        same parameter list as `check_shortcut' for clearness.
        (symlink_info::check): Change parameter list for calls to
        `check_shortcut' and `check_sysfile'.
@
text
@d113 1
a113 1
extern "C" int __stdcall
@


1.15
log
@* errno.cc (strerror): Change EAGAIN case to return "Resource temporarily
unavailable" instead of "No more processes".
@
text
@d113 1
a113 1
int __stdcall
@


1.14
log
@* errno.cc (seterrno_from_win_error): Fix debugging output.
* fhandler.cc (fhandler_base::fstat): Move to inline method in fhandler.h.
(fhandler_base::set_io_handle): Ditto.
* fhandler.h (fhandler_base): Make some methods inline.
* fhandler_console.cc (fhandler_console::write_normal): Make buffer larger.
* sigproc.h (sigframe::sigframe): Actually use set ebp parameter correctly.
* spawn.cc (spawn_guts): Set dwProcessId when exec'ing.  Just exit immediately
after reparenting.
* syscalls.cc: Sprinkle sigframe stuff throughout.
* wait.cc (wait4): Set signal frame here.
* dcrt0.cc (__api_fatal): Don't rely on small_printf to display errors.  Always
display problems to the console, if possible.
@
text
@d337 1
a337 1
      error = "No more processes";
@


1.13
log
@* errno.cc (set_errno_from_win_error): Actually use arguments to strace_printf.
@
text
@d133 1
a133 1
  syscall_printf ("%s:%d \b", file, line);
@


1.12
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d105 5
a109 5
  X (CRC,                       EIO),
  X (NEGATIVE_SEEK,             EINVAL),
  X (NOT_READY,                 ENOMEDIUM),
  X (DISK_FULL,		        ENOSPC),
  X (NOACCESS,		        EFAULT),
d133 1
a133 1
  syscall_printf ("%s:%d \b");
@


1.11
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d16 1
@


1.10
log
@* strace.cc (strace::prntf): Make second argument the function name, rather
than use special format options.
(strace::vprntf): Ditto.
(getfunc): New function.
* include/sys/strace.h: Reflect above changes.
* smallprint.c (__small_vsprintf): Eliminate '%F' formatting.
* pinfo.cc (set_myself): Modify for new strace::prntf parameter.
* errno.cc (seterrno_from_win_error): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Ditto.
@
text
@d15 1
d25 1
a25 1
    int w;		 /* windows version of error */
d112 15
d129 2
a130 2
void
seterrno_from_win_error (const char *file, int line, int code)
d132 3
a134 19
  int i;

  for (i = 0; errmap[i].w != 0; ++i)
    if (code == errmap[i].w)
      break;

  if (errmap[i].w != 0)
    {
      if (strace.active)
	strace.prntf (_STRACE_SYSCALL, NULL, "%s:%d seterrno: %d (%s) -> %d",
		      file, line, code, errmap[i].s, errmap[i].e);
      set_errno (errmap[i].e);
    }
  else
    {
      if (strace.active)
	strace.prntf (_STRACE_SYSCALL, NULL, "%s:%d seterrno: unknown error %d", file, line, code);
      set_errno (EACCES);
    }
d138 1
a138 1
void
a674 1

@


1.9
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d125 1
a125 1
	strace.prntf (_STRACE_SYSCALL, "%s:%d seterrno: %d (%s) -> %d",
d132 1
a132 1
	strace.prntf (_STRACE_SYSCALL, "%s:%d seterrno: unknown error %d", file, line, code);
@


1.8
log
@        * errno.cc (errmap): Map ERROR_BAD_NET_NAME to errno ENOSHARE.
@
text
@d11 1
a13 1
#include "winsup.h"
@


1.7
log
@        * errno.cc: Change mapping of ERROR_BAD_PATHNAME to ENOENT.
@
text
@d54 1
@


1.6
log
@* errno.cc (errmap): Correct DIRECTORY mapping to ENOTDIR.
@
text
@d67 1
a67 1
  X (BAD_PATHNAME,		EINVAL),
@


1.5
log
@        * errno.cc (errmap): Map ERROR_BAD_NETPATH to new errno ENOSHARE.
        (_sys_errlist): Add entry for ENOSHARE.
        (strerror): Add case for ENOSHARE.
        * syscalls.cc (stat_worker): Check for errno ENOSHARE.
@
text
@d82 1
a82 1
  X (DIRECTORY,			EISDIR),
@


1.4
log
@* errno.cc: Map ERROR_NOACCESS to EFAULT.
@
text
@d53 1
a53 1
  X (BAD_NETPATH,		ENXIO),
d282 2
a283 1
/* ENOMEDIUM 135 */ "no medium"
d655 3
@


1.3
log
@Throughout use strace class in place of individual functions and variables.
* cygwin.din: Eliminate _strace_wm.
* sigproc.cc (wait_sig): Temporarily add more debugging output.
* include/cygwin/version.h: Bump minor api to reflect export change.
@
text
@d106 1
@


1.2
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d122 2
a123 2
      if (strace_active)
	strace_printf (_STRACE_SYSCALL, "%s:%d seterrno: %d (%s) -> %d",
d129 2
a130 2
      if (strace_active)
	strace_printf (_STRACE_SYSCALL, "%s:%d seterrno: unknown error %d", file, line, code);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Cygnus Solutions.
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
