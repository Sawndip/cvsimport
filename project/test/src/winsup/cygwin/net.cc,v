head	1.323;
access;
symbols
	cygwin-1_7_35-release:1.323
	cygwin-1_7_34-release:1.323
	cygwin-1_7_33-release:1.311.2.4
	cygwin-1_7_32-release:1.311.2.3
	cygwin-1_7_31-release:1.311.2.3
	cygwin-1_7_30-release:1.311.2.1
	cygwin-1_7_29-release:1.311
	cygwin-1_7_29-release-branchpoint:1.311.0.2
	cygwin-pre-user-db:1.311
	cygwin-1_7_28-release:1.310
	cygwin-1_7_27-release:1.310
	cygwin-1_7_26-release:1.310
	cygwin-1_7_25-release:1.306
	cygwin-1_7_24-release:1.306
	cygwin-1_7_23-release:1.306
	cygwin-1_7_22-release:1.306
	cygwin-1_7_21-release:1.306
	cygwin-1_7_20-release:1.305
	cygwin-1_7_19-release:1.305
	cygwin-64bit-postmerge:1.305
	cygwin-64bit-premerge-branch:1.304.0.2
	cygwin-64bit-premerge:1.304
	cygwin-1_7_18-release:1.304
	post-ptmalloc3:1.300.2.7
	pre-ptmalloc3:1.300.2.7
	cygwin-1_7_17-release:1.302
	cygwin-64bit-branch:1.300.0.2
	cygwin-1_7_16-release:1.300
	cygwin-1_7_15-release:1.297
	cygwin-1_7_14_2-release:1.296
	cygwin-1_7_14-release:1.296
	cygwin-1_7_12-release:1.296
	cygwin-1_7_11-release:1.294
	cygwin-1_7_10-release:1.294
	signal-rewrite:1.290.0.2
	pre-notty:1.287
	cygwin-1_7_9-release:1.282
	cv-post-1_7_9:1.282.0.2
	cygwin-1_7_8-release:1.282
	cygwin-1_7_7-release:1.274
	cygwin-1_7_5-release:1.272
	cygwin-1_7_4-release:1.272
	cygwin-1_7_3-release:1.272
	cygwin-1_7_2-release:1.271
	fifo_doover3:1.268.0.2
	cygwin-1_7_1-release:1.267
	prefifo:1.260
	cv-branch-2:1.256.0.2
	pre-ripout-set_console_state_for_spawn:1.242
	EOL_registry_mounts:1.237
	preoverlapped:1.235
	drop_9x_support_start:1.229
	cr-0x5f1:1.213.0.2
	cv-branch:1.212.0.2
	pre-ptymaster-archetype:1.207
	cr-0x3b58:1.201.0.4
	cr-0x5ef:1.201.0.2
	after-mmap-privanon-noreserve:1.198
	after-mmap-revamp:1.198
	before-mmap-revamp:1.198
	cgf-more-exit-sync:1.196
	post_wait_sig_exit:1.194
	pre_wait_sig_exit:1.191
	reparent-point:1.175
	noreparent:1.175.0.2
	cr-0x5e6:1.172.0.2
	cr-0x9e:1.159.0.6
	cr-0x9d:1.159.0.4
	cgf-deleteme:1.159.0.2
	pre-sigrewrite:1.156
	corinna-01:1.156
	cr-0x9c:1.153.0.4
	cr-0x9b:1.153.0.2
	cr-0x99:1.153
	Z-emcb-cygwin_daemon:1.149.0.2
	w32api-2_2:1.139
	mingw-runtime-2_4:1.139
	pre-cgf-merge:1.153
	cgf-dev-branch:1.138.0.2
	predaemon:1.104
	cygwin_daemon_merge_HEAD:1.104
	pregp02r1:1.103.0.2
	cygnus_cvs_20020108_pre:1.94
	Z-cygwin_daemon_merge-new_HEAD:1.126
	Z-cygwin_daemon_merge_HEAD:1.126
	cygwin_daemon:1.77.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.323
date	2015.01.23.10.46.22;	author corinna;	state Exp;
branches;
next	1.322;

1.322
date	2015.01.20.18.23.19;	author corinna;	state Exp;
branches;
next	1.321;

1.321
date	2014.11.20.08.29.31;	author corinna;	state Exp;
branches;
next	1.320;

1.320
date	2014.10.13.08.18.18;	author corinna;	state Exp;
branches;
next	1.319;

1.319
date	2014.10.11.18.28.04;	author corinna;	state Exp;
branches;
next	1.318;

1.318
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.317;

1.317
date	2014.08.21.08.59.28;	author corinna;	state Exp;
branches;
next	1.316;

1.316
date	2014.06.23.12.35.31;	author corinna;	state Exp;
branches;
next	1.315;

1.315
date	2014.05.19.15.57.22;	author corinna;	state Exp;
branches;
next	1.314;

1.314
date	2014.05.05.15.18.17;	author corinna;	state Exp;
branches;
next	1.313;

1.313
date	2014.04.24.13.44.22;	author corinna;	state Exp;
branches;
next	1.312;

1.312
date	2014.04.16.08.58.20;	author corinna;	state Exp;
branches;
next	1.311;

1.311
date	2014.02.06.20.38.34;	author corinna;	state Exp;
branches
	1.311.2.1;
next	1.310;

1.310
date	2013.11.24.12.13.35;	author corinna;	state Exp;
branches;
next	1.309;

1.309
date	2013.11.19.18.07.46;	author corinna;	state Exp;
branches;
next	1.308;

1.308
date	2013.11.19.13.29.37;	author corinna;	state Exp;
branches;
next	1.307;

1.307
date	2013.10.24.09.41.17;	author corinna;	state Exp;
branches;
next	1.306;

1.306
date	2013.06.13.19.37.14;	author corinna;	state Exp;
branches;
next	1.305;

1.305
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.303;

1.303
date	2012.11.26.13.28.53;	author corinna;	state Exp;
branches;
next	1.302;

1.302
date	2012.08.21.14.41.57;	author cgf;	state Exp;
branches;
next	1.301;

1.301
date	2012.08.16.23.34.44;	author cgf;	state Exp;
branches;
next	1.300;

1.300
date	2012.07.06.13.53.22;	author corinna;	state Exp;
branches
	1.300.2.1;
next	1.299;

1.299
date	2012.07.02.02.24.25;	author cgf;	state Exp;
branches;
next	1.298;

1.298
date	2012.05.21.14.56.02;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2012.05.03.08.34.44;	author corinna;	state Exp;
branches;
next	1.296;

1.296
date	2012.03.08.16.02.44;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2012.02.27.11.55.27;	author corinna;	state Exp;
branches;
next	1.294;

1.294
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.293;

1.293
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.292;

1.292
date	2011.10.05.06.18.16;	author corinna;	state Exp;
branches;
next	1.291;

1.291
date	2011.09.02.09.52.08;	author corinna;	state Exp;
branches;
next	1.290;

1.290
date	2011.08.16.23.32.18;	author phumblet;	state Exp;
branches;
next	1.289;

1.289
date	2011.08.04.08.22.11;	author corinna;	state Exp;
branches;
next	1.288;

1.288
date	2011.07.29.12.47.54;	author corinna;	state Exp;
branches;
next	1.287;

1.287
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.286;

1.286
date	2011.05.01.08.14.40;	author corinna;	state Exp;
branches;
next	1.285;

1.285
date	2011.04.19.08.59.30;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2011.04.04.12.23.35;	author corinna;	state Exp;
branches;
next	1.283;

1.283
date	2011.03.29.10.25.20;	author corinna;	state Exp;
branches;
next	1.282;

1.282
date	2011.02.21.17.01.05;	author corinna;	state Exp;
branches
	1.282.2.1;
next	1.281;

1.281
date	2011.02.15.15.56.01;	author corinna;	state Exp;
branches;
next	1.280;

1.280
date	2011.01.30.21.52.11;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2010.12.02.11.39.15;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2010.11.23.15.37.41;	author corinna;	state Exp;
branches;
next	1.277;

1.277
date	2010.11.22.13.03.00;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2010.09.28.16.18.57;	author corinna;	state Exp;
branches;
next	1.275;

1.275
date	2010.09.25.20.06.21;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2010.08.28.08.51.21;	author corinna;	state Exp;
branches;
next	1.273;

1.273
date	2010.07.02.14.36.43;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2010.03.30.09.25.45;	author corinna;	state Exp;
branches;
next	1.271;

1.271
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2010.01.15.21.34.27;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2010.01.15.15.40.05;	author corinna;	state Exp;
branches;
next	1.268;

1.268
date	2009.12.15.17.08.20;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2009.11.23.14.50.14;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2009.11.17.10.43.00;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2009.11.13.12.35.53;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2009.08.14.06.58.44;	author corinna;	state Exp;
branches;
next	1.263;

1.263
date	2009.08.13.10.26.42;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2009.08.06.14.55.49;	author corinna;	state Exp;
branches;
next	1.261;

1.261
date	2009.08.04.22.35.35;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2009.07.01.15.45.23;	author corinna;	state Exp;
branches;
next	1.259;

1.259
date	2009.07.01.09.16.17;	author corinna;	state Exp;
branches;
next	1.258;

1.258
date	2009.06.30.10.36.40;	author corinna;	state Exp;
branches;
next	1.257;

1.257
date	2009.06.15.20.04.15;	author corinna;	state Exp;
branches;
next	1.256;

1.256
date	2009.05.28.05.10.02;	author cgf;	state Exp;
branches;
next	1.255;

1.255
date	2009.05.20.14.56.46;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2009.04.05.04.23.50;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2009.03.27.15.20.27;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2009.03.27.15.10.18;	author corinna;	state Exp;
branches;
next	1.251;

1.251
date	2009.03.12.15.54.49;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2009.03.06.16.31.25;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2009.03.03.11.44.17;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2008.09.16.02.04.27;	author cgf;	state Exp;
branches;
next	1.247;

1.247
date	2008.09.11.04.58.45;	author cgf;	state Exp;
branches;
next	1.246;

1.246
date	2008.07.14.15.56.11;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2008.07.08.20.12.46;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2008.07.08.12.37.44;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2008.06.24.13.13.44;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2008.06.10.18.15.57;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2008.06.10.17.24.00;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2008.04.18.20.13.37;	author corinna;	state Exp;
branches;
next	1.239;

1.239
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2008.04.03.15.28.03;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2007.10.31.16.06.01;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2007.07.07.16.43.03;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2007.06.21.15.57.54;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2007.06.14.16.02.31;	author corinna;	state Exp;
branches;
next	1.232;

1.232
date	2007.02.26.12.39.25;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2007.02.22.17.09.46;	author corinna;	state Exp;
branches;
next	1.230;

1.230
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.229;

1.229
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2007.02.01.15.54.40;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2007.01.31.15.30.42;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2007.01.31.15.10.21;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2007.01.24.15.55.51;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2007.01.23.17.05.28;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2007.01.23.09.23.54;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2007.01.21.22.54.04;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2007.01.16.12.01.36;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2007.01.04.10.48.57;	author corinna;	state Exp;
branches;
next	1.219;

1.219
date	2007.01.04.10.11.27;	author corinna;	state Exp;
branches;
next	1.218;

1.218
date	2006.11.23.16.30.12;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2006.10.20.12.57.25;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2006.07.27.09.18.28;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2006.07.27.09.11.38;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2006.07.07.09.14.14;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2006.07.04.20.24.26;	author corinna;	state Exp;
branches
	1.212.2.1;
next	1.211;

1.211
date	2006.07.03.11.31.56;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2006.06.30.11.04.13;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2006.06.26.12.12.11;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2006.06.12.13.13.52;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2006.04.05.16.53.12;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2006.04.04.09.54.25;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2006.01.29.12.23.44;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2006.01.18.18.37.35;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2006.01.18.18.24.33;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2006.01.13.10.18.31;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2005.12.05.20.20.18;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2005.10.22.16.02.15;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2005.10.22.15.11.49;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2005.10.17.21.22.18;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2005.10.11.16.35.31;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2005.09.23.23.25.25;	author cgf;	state Exp;
branches;
next	1.193;

1.193
date	2005.09.17.08.55.29;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2005.09.14.21.26.15;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2005.08.12.02.39.12;	author cgf;	state Exp;
branches;
next	1.190;

1.190
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2005.06.17.20.01.58;	author corinna;	state Exp;
branches;
next	1.188;

1.188
date	2005.05.02.03.50.07;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2005.04.06.05.48.55;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2005.03.24.14.04.06;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2005.03.18.22.42.51;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2005.03.16.17.07.32;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2005.03.09.23.46.51;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2005.03.09.22.38.09;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2005.03.09.20.56.44;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2005.03.01.11.51.29;	author corinna;	state Exp;
branches;
next	1.179;

1.179
date	2005.02.28.13.11.50;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2005.02.23.17.39.46;	author corinna;	state Exp;
branches;
next	1.177;

1.177
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2005.02.07.15.27.40;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2004.08.19.10.58.37;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2004.08.11.18.34.32;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.07.07.51.31;	author corinna;	state Exp;
branches;
next	1.171;

1.171
date	2004.04.10.13.45.10;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2004.04.09.08.43.29;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2004.04.03.19.07.59;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2004.04.02.10.29.53;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2004.04.01.10.36.40;	author corinna;	state Exp;
branches;
next	1.166;

1.166
date	2004.04.01.09.48.15;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2004.03.31.12.04.07;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2004.03.31.09.13.54;	author corinna;	state Exp;
branches;
next	1.163;

1.163
date	2004.03.29.19.41.17;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2004.03.29.14.08.44;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches
	1.159.6.1;
next	1.158;

1.158
date	2003.12.03.16.35.52;	author corinna;	state Exp;
branches;
next	1.157;

1.157
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2003.11.04.13.15.47;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2003.11.03.21.43.32;	author corinna;	state Exp;
branches;
next	1.154;

1.154
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2003.09.01.16.47.03;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2003.08.31.23.23.40;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2003.08.31.23.16.34;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2003.08.31.22.02.15;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2003.08.19.04.10.41;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2003.07.05.18.20.13;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2003.06.19.00.57.26;	author phumblet;	state Exp;
branches;
next	1.145;

1.145
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2003.06.03.14.05.17;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2003.03.13.11.31.24;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches
	1.142.2.1;
next	1.141;

1.141
date	2003.02.21.14.29.18;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2003.02.20.14.14.37;	author corinna;	state Exp;
branches;
next	1.139;

1.139
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2003.01.15.10.21.23;	author corinna;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2003.01.11.01.29.18;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2003.01.10.12.55.47;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2003.01.10.11.58.52;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2002.12.12.03.09.38;	author cgf;	state Exp;
branches
	1.134.4.1;
next	1.133;

1.133
date	2002.12.10.16.36.36;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2002.11.22.20.51.13;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2002.11.19.08.01.49;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2002.11.19.01.20.58;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2002.11.10.13.43.26;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2002.09.30.04.35.18;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2002.09.04.09.39.35;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2002.08.27.09.24.50;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2002.08.26.09.57.26;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2002.08.12.13.54.12;	author scottc;	state Exp;
branches;
next	1.120;

1.120
date	2002.08.08.17.03.20;	author scottc;	state Exp;
branches;
next	1.119;

1.119
date	2002.07.31.13.18.51;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2002.07.06.11.16.07;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2002.07.05.18.26.22;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2002.07.02.23.57.05;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2002.06.26.19.25.09;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2002.06.10.19.58.19;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2002.06.10.11.07.44;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2002.05.12.01.50.37;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2002.05.04.03.24.35;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2002.04.12.14.52.36;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2002.03.15.21.49.10;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2002.02.22.19.33.41;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2002.02.09.10.40.48;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2002.02.09.09.01.18;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2002.02.08.11.54.10;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2002.02.07.15.04.32;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2002.01.29.13.39.41;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2002.01.29.13.23.09;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2002.01.21.17.47.53;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2002.01.19.16.11.00;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2002.01.09.20.57.55;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2002.01.04.16.56.53;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2002.01.01.16.25.31;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2001.12.04.22.01.03;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2001.12.03.20.09.33;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2001.11.24.21.52.28;	author corinna;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2001.11.24.21.10.00;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2001.11.24.17.31.15;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2001.11.10.19.46.15;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2001.10.22.12.23.33;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2001.10.15.23.39.32;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2001.10.14.04.14.23;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2001.10.11.09.46.21;	author duda;	state Exp;
branches;
next	1.78;

1.78
date	2001.10.10.19.28.19;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.16.02.56.58;	author cgf;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.09.05.08.16.51;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2001.08.31.05.06.13;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.24.06.57.53;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2001.08.22.21.51.48;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2001.08.22.15.31.59;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2001.08.15.07.49.15;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2001.08.14.07.41.45;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2001.08.07.00.01.42;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.03.12.06.29;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.20.06.50.13;	author duda;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.03.22.18.19;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.18.08.33.33;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.16.19.40.45;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.16.05.07.51;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.15.08.15.54;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.04.21.02.15;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.04.20.39.38;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.03.16.18.51;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.03.09.35.08;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.23.16.46.30;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.04.14.22.11.03;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.04.09.07.21.32;	author duda;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.03.02.53.24;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.20.19.50.28;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.17.19.53.51;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.17.17.13.52;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.17.17.04.45;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.07.22.50.49;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.09.16.00.58;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.11.19.45.53;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.02.21.29.00;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.29.17.15.00;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.25.10.23.55;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.14.05.53.32;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.07.20.01.09;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.27.18.53.56;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.27.09.50.33;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.26.10.13.41;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.25.08.47.23;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.23.20.16.52;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.14.08.55.44;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.06.19.11.14;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.05.05.57.00;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.02.20.21.47;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.28.06.34.38;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.26.00.52.21;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.08.03.12.13;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.29.16.24.38;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.01.05.57.54;	author cgf;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.05.30.00.38.51;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.17.05.49.51;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.25.08.50.22;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.15.44.11;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.04.07.13;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.311.2.1
date	2014.05.19.11.47.54;	author corinna;	state Exp;
branches;
next	1.311.2.2;

1.311.2.2
date	2014.06.23.12.35.39;	author corinna;	state Exp;
branches;
next	1.311.2.3;

1.311.2.3
date	2014.07.16.09.54.56;	author corinna;	state Exp;
branches;
next	1.311.2.4;

1.311.2.4
date	2014.11.13.12.53.03;	author corinna;	state Exp;
branches;
next	;

1.300.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.300.2.2;

1.300.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.300.2.3;

1.300.2.3
date	2012.11.07.20.56.05;	author corinna;	state Exp;
branches;
next	1.300.2.4;

1.300.2.4
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.300.2.5;

1.300.2.5
date	2012.12.10.11.45.49;	author corinna;	state Exp;
branches;
next	1.300.2.6;

1.300.2.6
date	2013.01.21.13.52.09;	author corinna;	state Exp;
branches;
next	1.300.2.7;

1.300.2.7
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	1.300.2.8;

1.300.2.8
date	2013.03.01.16.32.33;	author corinna;	state Exp;
branches;
next	1.300.2.9;

1.300.2.9
date	2013.03.27.14.18.58;	author corinna;	state Exp;
branches;
next	1.300.2.10;

1.300.2.10
date	2013.03.27.14.23.37;	author corinna;	state Exp;
branches;
next	1.300.2.11;

1.300.2.11
date	2013.04.08.10.03.11;	author corinna;	state Exp;
branches;
next	1.300.2.12;

1.300.2.12
date	2013.04.08.10.33.55;	author corinna;	state Exp;
branches;
next	1.300.2.13;

1.300.2.13
date	2013.04.13.18.53.52;	author corinna;	state Exp;
branches;
next	;

1.282.2.1
date	2011.03.11.09.26.27;	author corinna;	state Exp;
branches;
next	;

1.212.2.1
date	2006.07.06.14.04.32;	author corinna;	state Exp;
branches;
next	1.212.2.2;

1.212.2.2
date	2006.07.07.09.16.33;	author corinna;	state Exp;
branches;
next	1.212.2.3;

1.212.2.3
date	2006.07.07.09.24.16;	author corinna;	state Exp;
branches;
next	1.212.2.4;

1.212.2.4
date	2006.07.10.20.39.06;	author corinna;	state Exp;
branches;
next	1.212.2.5;

1.212.2.5
date	2006.07.12.13.30.47;	author corinna;	state Exp;
branches;
next	1.212.2.6;

1.212.2.6
date	2006.07.21.09.47.46;	author corinna;	state Exp;
branches;
next	;

1.159.6.1
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	;

1.142.2.1
date	2003.03.13.23.04.43;	author cgf;	state Exp;
branches;
next	;

1.138.2.1
date	2003.01.16.01.27.31;	author cgf;	state Exp;
branches;
next	1.138.2.2;

1.138.2.2
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.138.2.3;

1.138.2.3
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.138.2.4;

1.138.2.4
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.138.2.5;

1.138.2.5
date	2003.03.02.23.39.10;	author cgf;	state Exp;
branches;
next	1.138.2.6;

1.138.2.6
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.138.2.7;

1.138.2.7
date	2003.03.19.19.59.54;	author cgf;	state Exp;
branches;
next	1.138.2.8;

1.138.2.8
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.138.2.9;

1.138.2.9
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.138.2.10;

1.138.2.10
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.138.2.11;

1.138.2.11
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.138.2.12;

1.138.2.12
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	1.138.2.13;

1.138.2.13
date	2003.09.14.01.35.37;	author cgf;	state Exp;
branches;
next	;

1.134.4.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	;

1.90.2.1
date	2001.12.03.20.30.03;	author cgf;	state Exp;
branches
	1.90.2.1.4.1;
next	;

1.90.2.1.4.1
date	2001.12.04.22.02.31;	author cgf;	state Exp;
branches;
next	;

1.77.2.1
date	2002.01.04.03.56.09;	author rbcollins;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2002.01.15.12.52.50;	author rbcollins;	state Exp;
branches;
next	1.77.2.3;

1.77.2.3
date	2002.01.22.04.52.40;	author rbcollins;	state Exp;
branches;
next	1.77.2.4;

1.77.2.4
date	2002.02.28.12.53.25;	author rbcollins;	state Exp;
branches;
next	1.77.2.5;

1.77.2.5
date	2002.06.13.14.34.07;	author rbcollins;	state Exp;
branches;
next	1.77.2.6;

1.77.2.6
date	2002.06.27.11.30.15;	author scottc;	state Exp;
branches;
next	1.77.2.7;

1.77.2.7
date	2002.07.02.10.58.18;	author scottc;	state Exp;
branches;
next	1.77.2.8;

1.77.2.8
date	2002.07.03.16.01.46;	author scottc;	state Exp;
branches;
next	1.77.2.9;

1.77.2.9
date	2002.07.31.16.49.37;	author scottc;	state Exp;
branches;
next	1.77.2.10;

1.77.2.10
date	2002.08.12.14.06.35;	author scottc;	state Exp;
branches;
next	1.77.2.11;

1.77.2.11
date	2002.08.26.11.38.14;	author scottc;	state Exp;
branches;
next	1.77.2.12;

1.77.2.12
date	2002.08.27.12.28.37;	author scottc;	state Exp;
branches;
next	1.77.2.13;

1.77.2.13
date	2002.09.04.09.55.01;	author scottc;	state Exp;
branches;
next	1.77.2.14;

1.77.2.14
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.77.2.15;

1.77.2.15
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.8.2.1
date	2000.08.04.00.48.23;	author cgf;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.323
log
@	* net.cc (cygwin_inet_pton): Declare.
	(gethostby_specials): New function.
	(gethostby_helper): Change returned addrtype in 4-to-6 case.
	(gethostbyname2): Call gethostby_specials.
@
text
@/* net.cc: network-related routines.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* #define DEBUG_NEST_ON 1 */

#define  __INSIDE_CYGWIN_NET__
#define USE_SYS_TYPES_FD_SET
#define __WSA_ERR_MACROS_DEFINED
/* FIXME: Collision with different declarations of if_nametoindex and
	  if_indextoname functions in iphlpapi.h since Vista.
   TODO:  Convert if_nametoindex to cygwin_if_nametoindex and call
	  system functions on Vista and later. */
#define _INC_NETIOAPI
#include "winsup.h"
#ifdef __x86_64__
/* 2014-04-24: Current Mingw headers define sockaddr_in6 using u_long (8 byte)
   because a redefinition for LP64 systems is missing.  This leads to a wrong
   definition and size of sockaddr_in6 when building with winsock headers.
   This definition is also required to use the right u_long type in subsequent
   function calls. */
#undef u_long
#define u_long __ms_u_long
#endif
#include <ws2tcpip.h>
#include <mswsock.h>
#include <iphlpapi.h>
#include "miscfuncs.h"
#include <ctype.h>
#include <wchar.h>
#include <stdlib.h>
#define gethostname cygwin_gethostname
#include <unistd.h>
#undef gethostname
#include <netdb.h>
#include <cygwin/in.h>
#include <asm/byteorder.h>
#include <assert.h>
#include "cygerrno.h"
#include "security.h"
#include "cygwin/version.h"
#include "shared_info.h"
#include "perprocess.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "sigproc.h"
#include "registry.h"
#include "cygtls.h"
#include "ifaddrs.h"
#include "tls_pbuf.h"
#include "ntdll.h"

/* Unfortunately defined in Windows header files and arpa/nameser_compat.h. */
#undef NOERROR
#undef DELETE
#define _CYGWIN_IN_H
#include <resolv.h>

extern "C"
{
  int h_errno;

  int __stdcall rcmd (char **ahost, unsigned short inport, char *locuser,
		      char *remuser, char *cmd, SOCKET * fd2p);
  int sscanf (const char *, const char *, ...);
  int cygwin_inet_pton(int, const char *, void *);
  int cygwin_inet_aton(const char *, struct in_addr *);
  const char *cygwin_inet_ntop (int, const void *, char *, socklen_t);
  int dn_length1(const unsigned char *, const unsigned char *,
		 const unsigned char *);
}				/* End of "C" section */

const struct in6_addr in6addr_any = {{IN6ADDR_ANY_INIT}};
const struct in6_addr in6addr_loopback = {{IN6ADDR_LOOPBACK_INIT}};

static fhandler_socket *
get (const int fd)
{
  cygheap_fdget cfd (fd);

  if (cfd < 0)
    return 0;

  fhandler_socket *const fh = cfd->is_socket ();

  if (!fh)
    set_errno (ENOTSOCK);

  return fh;
}

/* exported as inet_ntoa: BSD 4.3 */
extern "C" char *
cygwin_inet_ntoa (struct in_addr in)
{
  char buf[20];
  const char *res = cygwin_inet_ntop (AF_INET, &in, buf, sizeof buf);

  if (_my_tls.locals.ntoa_buf)
    {
      free (_my_tls.locals.ntoa_buf);
      _my_tls.locals.ntoa_buf = NULL;
    }
  if (res)
    _my_tls.locals.ntoa_buf = strdup (res);
  return _my_tls.locals.ntoa_buf;
}

/* inet_netof is in the standard BSD sockets library.  It is useless
   for modern networks, since it assumes network values which are no
   longer meaningful, but some existing code calls it.  */

extern "C" unsigned long
inet_netof (struct in_addr in)
{
  unsigned long i, res;

  i = ntohl (in.s_addr);
  if (IN_CLASSA (i))
    res = (i & IN_CLASSA_NET) >> IN_CLASSA_NSHIFT;
  else if (IN_CLASSB (i))
    res = (i & IN_CLASSB_NET) >> IN_CLASSB_NSHIFT;
  else
    res = (i & IN_CLASSC_NET) >> IN_CLASSC_NSHIFT;

  return res;
}

/* inet_makeaddr is in the standard BSD sockets library.  It is
   useless for modern networks, since it assumes network values which
   are no longer meaningful, but some existing code calls it.  */

extern "C" struct in_addr
inet_makeaddr (int net, int lna)
{
  unsigned long i;
  struct in_addr in;

  if (net < IN_CLASSA_MAX)
    i = (net << IN_CLASSA_NSHIFT) | (lna & IN_CLASSA_HOST);
  else if (net < IN_CLASSB_MAX)
    i = (net << IN_CLASSB_NSHIFT) | (lna & IN_CLASSB_HOST);
  else if (net < 0x1000000)
    i = (net << IN_CLASSC_NSHIFT) | (lna & IN_CLASSC_HOST);
  else
    i = net | lna;

  in.s_addr = htonl (i);


  return in;
}

struct tl
{
  int w;
  const char *s;
  int e;
};

static const struct tl errmap[] = {
  {WSAEINTR, "WSAEINTR", EINTR},
  {WSAEWOULDBLOCK, "WSAEWOULDBLOCK", EWOULDBLOCK},
  {WSAEINPROGRESS, "WSAEINPROGRESS", EINPROGRESS},
  {WSAEALREADY, "WSAEALREADY", EALREADY},
  {WSAENOTSOCK, "WSAENOTSOCK", ENOTSOCK},
  {WSAEDESTADDRREQ, "WSAEDESTADDRREQ", EDESTADDRREQ},
  {WSAEMSGSIZE, "WSAEMSGSIZE", EMSGSIZE},
  {WSAEPROTOTYPE, "WSAEPROTOTYPE", EPROTOTYPE},
  {WSAENOPROTOOPT, "WSAENOPROTOOPT", ENOPROTOOPT},
  {WSAEPROTONOSUPPORT, "WSAEPROTONOSUPPORT", EPROTONOSUPPORT},
  {WSAESOCKTNOSUPPORT, "WSAESOCKTNOSUPPORT", ESOCKTNOSUPPORT},
  {WSAEOPNOTSUPP, "WSAEOPNOTSUPP", EOPNOTSUPP},
  {WSAEPFNOSUPPORT, "WSAEPFNOSUPPORT", EPFNOSUPPORT},
  {WSAEAFNOSUPPORT, "WSAEAFNOSUPPORT", EAFNOSUPPORT},
  {WSAEADDRINUSE, "WSAEADDRINUSE", EADDRINUSE},
  {WSAEADDRNOTAVAIL, "WSAEADDRNOTAVAIL", EADDRNOTAVAIL},
  {WSAENETDOWN, "WSAENETDOWN", ENETDOWN},
  {WSAENETUNREACH, "WSAENETUNREACH", ENETUNREACH},
  {WSAENETRESET, "WSAENETRESET", ENETRESET},
  {WSAECONNABORTED, "WSAECONNABORTED", ECONNABORTED},
  {WSAECONNRESET, "WSAECONNRESET", ECONNRESET},
  {WSAENOBUFS, "WSAENOBUFS", ENOBUFS},
  {WSAEISCONN, "WSAEISCONN", EISCONN},
  {WSAENOTCONN, "WSAENOTCONN", ENOTCONN},
  {WSAESHUTDOWN, "WSAESHUTDOWN", ESHUTDOWN},
  {WSAETOOMANYREFS, "WSAETOOMANYREFS", ETOOMANYREFS},
  {WSAETIMEDOUT, "WSAETIMEDOUT", ETIMEDOUT},
  {WSAECONNREFUSED, "WSAECONNREFUSED", ECONNREFUSED},
  {WSAELOOP, "WSAELOOP", ELOOP},
  {WSAENAMETOOLONG, "WSAENAMETOOLONG", ENAMETOOLONG},
  {WSAEHOSTDOWN, "WSAEHOSTDOWN", EHOSTDOWN},
  {WSAEHOSTUNREACH, "WSAEHOSTUNREACH", EHOSTUNREACH},
  {WSAENOTEMPTY, "WSAENOTEMPTY", ENOTEMPTY},
  {WSAEPROCLIM, "WSAEPROCLIM", EPROCLIM},
  {WSAEUSERS, "WSAEUSERS", EUSERS},
  {WSAEDQUOT, "WSAEDQUOT", EDQUOT},
  {WSAESTALE, "WSAESTALE", ESTALE},
  {WSAEREMOTE, "WSAEREMOTE", EREMOTE},
  {WSAEINVAL, "WSAEINVAL", EINVAL},
  {WSAEFAULT, "WSAEFAULT", EFAULT},
  {0, "NOERROR", 0},
  {0, NULL, 0}
};

static int
find_winsock_errno (int why)
{
  for (int i = 0; errmap[i].s != NULL; ++i)
    if (why == errmap[i].w)
      return errmap[i].e;

  return EPERM;
}

void
__set_winsock_errno (const char *fn, int ln)
{
  DWORD werr = WSAGetLastError ();
  int err = find_winsock_errno (werr);

  set_errno (err);
  syscall_printf ("%s:%d - winsock error %u -> errno %d", fn, ln, werr, err);
}

/*
 * Since the member `s' isn't used for debug output we can use it
 * for the error text returned by herror and hstrerror.
 */
static const struct tl host_errmap[] = {
  {WSAHOST_NOT_FOUND, "Unknown host", HOST_NOT_FOUND},
  {WSATRY_AGAIN, "Host name lookup failure", TRY_AGAIN},
  {WSANO_RECOVERY, "Unknown server error", NO_RECOVERY},
  {WSANO_DATA, "No address associated with name", NO_DATA},
  {0, NULL, 0}
};

static void
set_host_errno ()
{
  int i;

  int why = WSAGetLastError ();

  for (i = 0; host_errmap[i].w != 0; ++i)
    if (why == host_errmap[i].w)
      break;

  if (host_errmap[i].w != 0)
    h_errno = host_errmap[i].e;
  else
    h_errno = NETDB_INTERNAL;
}

inline int
DWORD_round (int n)
{
  return sizeof (DWORD) * (((n + sizeof (DWORD) - 1)) / sizeof (DWORD));
}

inline int
strlen_round (const char *s)
{
  if (!s)
    return 0;
  return DWORD_round (strlen (s) + 1);
}

#pragma pack(push,2)
struct pservent
{
  char *s_name;
  char **s_aliases;
  short s_port;
  char *s_proto;
};
#pragma pack(pop)

static const char *entnames[] = {"host", "proto", "serv"};

static unionent *
realloc_ent (unionent *&dst, int sz)
{
  /* Allocate the storage needed.  Allocate a rounded size to attempt to force
     reuse of this buffer so that a poorly-written caller will not be using
     a freed buffer. */
  unsigned rsz = 256 * ((sz + 255) / 256);
  unionent * ptr;
  if ((ptr = (unionent *) realloc (dst, rsz)))
    dst = ptr;
  return ptr;
}

static inline hostent *
realloc_ent (int sz, hostent *)
{
  return (hostent *) realloc_ent (_my_tls.locals.hostent_buf, sz);
}

/* Generic "dup a {host,proto,serv}ent structure" function.
   This is complicated because we need to be able to free the
   structure at any point and we can't rely on the pointer contents
   being untouched by callers.  So, we allocate a chunk of memory
   large enough to hold the structure and all of the stuff it points
   to then we copy the source into this new block of memory.
   The 'unionent' struct is a union of all of the currently used
   *ent structure.  */

#ifdef __x86_64__
/* For some baffling reason, somebody at Microsoft decided that it would be
   a good idea to exchange the s_port and s_proto members in the servent
   structure. */
struct win64_servent
{
  char  *s_name;
  char **s_aliases;
  char  *s_proto;
  short  s_port;
};
#define WIN_SERVENT(x)	((win64_servent *)(x))
#else
#define WIN_SERVENT(x)	((servent *)(x))
#endif

#ifdef DEBUGGING
static void *
#else
static inline void *
#endif
dup_ent (unionent *&dst, unionent *src, unionent::struct_type type)
{
  if (dst)
    debug_printf ("old %sent structure \"%s\" %p\n", entnames[type],
		  dst->name, dst);

  if (!src)
    {
      set_winsock_errno ();
      return NULL;
    }

  debug_printf ("duping %sent \"%s\", %p", entnames[type], src->name, src);

  /* Find the size of the raw structure minus any character strings, etc. */
  int sz, struct_sz;
  switch (type)
    {
    case unionent::t_protoent:
      struct_sz = sizeof (protoent);
      break;
    case unionent::t_servent:
      struct_sz = sizeof (servent);
      break;
    case unionent::t_hostent:
      struct_sz = sizeof (hostent);
      break;
    default:
      api_fatal ("called with invalid value %d", type);
      break;
    }

  /* Every *ent begins with a name.  Calculate its length. */
  int namelen = strlen_round (src->name);
  sz = struct_sz + namelen;

  char **av;
  /* The next field in every *ent is an argv list of "something".
     Calculate the number of components and how much space the
     character strings will take.  */
  int list_len = 0;
  for (av = src->list; av && *av; av++)
    {
      list_len++;
      sz += sizeof (char **) + strlen_round (*av);
    }

  /* NULL terminate if there actually was a list */
  if (av)
    {
      sz += sizeof (char **);
      list_len++;
    }

  /* Do servent/hostent specific processing */
  int protolen = 0;
  int addr_list_len = 0;
  if (type == unionent::t_servent)
    {
      if (WIN_SERVENT (src)->s_proto)
	sz += (protolen = strlen_round (WIN_SERVENT (src)->s_proto));
    }
  else if (type == unionent::t_hostent)
    {
      /* Calculate the length and storage used for h_addr_list */
      for (av = src->h_addr_list; av && *av; av++)
	{
	  addr_list_len++;
	  sz += sizeof (char **) + DWORD_round (src->h_len);
	}
      if (av)
	{
	  sz += sizeof (char **);
	  addr_list_len++;
	}
    }

  /* Allocate the storage needed.  */
  if (realloc_ent (dst, sz))
    {
      memset (dst, 0, sz);
      /* This field is common to all *ent structures but named differently
	 in each, of course.  Also, take 64 bit Windows servent weirdness
	 into account. */
      if (type == unionent::t_servent)
	dst->port_proto_addrtype = WIN_SERVENT (src)->s_port;
      else
	dst->port_proto_addrtype = src->port_proto_addrtype;

      char *dp = ((char *) dst) + struct_sz;
      if (namelen)
	{
	  /* Copy the name field to dst, using space just beyond the end of
	     the dst structure. */
	  strcpy (dst->name = dp, src->name);
	  dp += namelen;
	}

      /* Copy the 'list' type to dst, using space beyond end of structure
	 + storage for name. */
      if (src->list)
	{
	  char **dav = dst->list = (char **) dp;
	  dp += sizeof (char **) * list_len;
	  for (av = src->list; av && *av; av++)
	    {
	      int len = strlen (*av) + 1;
	      memcpy (*dav++ = dp, *av, len);
	      dp += DWORD_round (len);
	    }
	}

      /* Do servent/protoent/hostent specific processing. */
      if (type == unionent::t_protoent)
	debug_printf ("protoent %s %p %y", dst->name, dst->list, dst->port_proto_addrtype);
      else if (type == unionent::t_servent)
	{
	  if (WIN_SERVENT (src)->s_proto)
	    {
	      strcpy (dst->s_proto = dp, WIN_SERVENT (src)->s_proto);
	      dp += protolen;
	    }
	}
      else if (type == unionent::t_hostent)
	{
	  /* Transfer h_len and duplicate contents of h_addr_list, using
	     memory after 'list' allocation. */
	  dst->h_len = src->h_len;
	  char **dav = dst->h_addr_list = (char **) dp;
	  dp += sizeof (char **) * addr_list_len;
	  for (av = src->h_addr_list; av && *av; av++)
	    {
	      memcpy (*dav++ = dp, *av, src->h_len);
	      dp += DWORD_round (src->h_len);
	    }
	}
      /* Sanity check that we did our bookkeeping correctly. */
      assert ((dp - (char *) dst) == sz);
    }
  debug_printf ("duped %sent \"%s\", %p", entnames[type], dst ? dst->name : "<null!>", dst);
  return dst;
}

static inline hostent *
dup_ent (hostent *src)
{
  return (hostent *) dup_ent (_my_tls.locals.hostent_buf, (unionent *) src, unionent::t_hostent);
}

static inline protoent *
dup_ent (protoent *src)
{
  return (protoent *) dup_ent (_my_tls.locals.protoent_buf, (unionent *) src, unionent::t_protoent);
}

static inline servent *
dup_ent (servent *src)
{
  return (servent *) dup_ent (_my_tls.locals.servent_buf, (unionent *) src, unionent::t_servent);
}

/* exported as getprotobyname: standards? */
extern "C" struct protoent *
cygwin_getprotobyname (const char *p)
{
  __try
    {
      return dup_ent (getprotobyname (p));
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

/* exported as getprotobynumber: standards? */
extern "C" struct protoent *
cygwin_getprotobynumber (int number)
{
  return dup_ent (getprotobynumber (number));
}

#ifndef SIO_BASE_HANDLE
#define SIO_BASE_HANDLE _WSAIOR(IOC_WS2,34)
#endif

bool
fdsock (cygheap_fdmanip& fd, const device *dev, SOCKET soc)
{
  int size;

  fd = build_fh_dev (*dev);
  if (!fd.isopen ())
    return false;

  /* Usually sockets are inheritable IFS objects.  Unfortunately some virus
     scanners or other network-oriented software replace normal sockets
     with their own kind, which is running through a filter driver called
     "layered service provider" (LSP).

     LSP sockets are not kernel objects.  They are typically not marked as
     inheritable, nor are they IFS handles.  They are in fact not inheritable
     to child processes, and it does not help to mark them inheritable via
     SetHandleInformation.  Subsequent socket calls in the child process fail
     with error 10038, WSAENOTSOCK.

     The only way up to Windows Server 2003 to make these sockets usable in
     child processes is to duplicate them via WSADuplicateSocket/WSASocket
     calls.  This requires to start the child process in SUSPENDED state so
     we only do this on affected systems.  If we recognize a non-inheritable
     socket we switch to inheritance/dup via WSADuplicateSocket/WSASocket for
     that socket.

     Starting with Vista there's another neat way to workaround these annoying
     LSP sockets.  WSAIoctl allows to fetch the underlying base socket, which
     is a normal, inheritable IFS handle.  So we fetch the base socket,
     duplicate it, and close the original socket.  Now we have a standard IFS
     socket which (hopefully) works as expected. */
  DWORD flags;
  bool fixup = false;
  if (!GetHandleInformation ((HANDLE) soc, &flags)
      || !(flags & HANDLE_FLAG_INHERIT))
    {
      int ret;
      SOCKET base_soc;
      DWORD bret;

      fixup = true;
      debug_printf ("LSP handle: %p", soc);
      ret = WSAIoctl (soc, SIO_BASE_HANDLE, NULL, 0, (void *) &base_soc,
		      sizeof (base_soc), &bret, NULL, NULL);
      if (ret)
	debug_printf ("WSAIoctl: %u", WSAGetLastError ());
      else if (base_soc != soc)
	{
	  /* LSPs are often BLODAs as well.  So we print an info about
	     detecting an LSP if BLODA detection is desired. */
	  if (detect_bloda)
	    {
	      WSAPROTOCOL_INFO prot;

	      memset (&prot, 0, sizeof prot);
	      ::getsockopt (soc, SOL_SOCKET, SO_PROTOCOL_INFO, (char *) &prot,
			    (size = sizeof prot, &size));
	      small_printf ("\n\nPotential BLODA detected!  Layered Socket "
			    "Service Provider:\n  %s\n\n", prot.szProtocol);
	    }
	  if (GetHandleInformation ((HANDLE) base_soc, &flags)
	      && (flags & HANDLE_FLAG_INHERIT))
	    {
	      if (!DuplicateHandle (GetCurrentProcess (), (HANDLE) base_soc,
				    GetCurrentProcess (), (PHANDLE) &base_soc,
				    0, TRUE, DUPLICATE_SAME_ACCESS))
		debug_printf ("DuplicateHandle failed, %E");
	      else
		{
		  closesocket (soc);
		  soc = base_soc;
		  fixup = false;
		}
	    }
	}
    }
  fd->set_io_handle ((HANDLE) soc);
  if (!((fhandler_socket *) fd)->init_events ())
    return false;
  if (fixup)
    ((fhandler_socket *) fd)->init_fixup_before ();
  fd->set_flags (O_RDWR | O_BINARY);
  debug_printf ("fd %d, name '%s', soc %p", (int) fd, dev->name, soc);

  /* Raise default buffer sizes (instead of WinSock default 8K).

     64K appear to have the best size/performance ratio for a default
     value.  Tested with ssh/scp on Vista over Gigabit LAN.

     NOTE.  If the SO_RCVBUF size exceeds 65535(*), and if the socket is
     connected to a remote machine, then calling WSADuplicateSocket on
     fork/exec fails with WinSock error 10022, WSAEINVAL.  Fortunately
     we don't use WSADuplicateSocket anymore, rather we just utilize
     handle inheritance.  An explanation for this weird behaviour would
     be nice, though.

     NOTE 2.  Testing on x86_64 (XP, Vista, 2008 R2, W8) indicates that
     this is no problem on 64 bit.  So we set the default buffer size to
     the default values in current 3.x Linux versions.

     NOTE 3. Setting the window size to 65535 results in extremely bad
     performance for apps that send data in multiples of Kb, as they
     eventually end up sending 1 byte on the network and naggle + delay
     ack kicks in. For example, iperf on a 10Gb network gives only 10
     Mbits/sec with a 65535 send buffer. We want this to be a multiple
     of 1k, but since 64k breaks WSADuplicateSocket we use 63Kb.

     (*) Maximum normal TCP window size.  Coincidence?  */
#ifdef __x86_64__
  ((fhandler_socket *) fd)->rmem () = 212992;
  ((fhandler_socket *) fd)->wmem () = 212992;
#else
  ((fhandler_socket *) fd)->rmem () = 64512;
  ((fhandler_socket *) fd)->wmem () = 64512;
#endif
  if (::setsockopt (soc, SOL_SOCKET, SO_RCVBUF,
		    (char *) &((fhandler_socket *) fd)->rmem (), sizeof (int)))
    {
      debug_printf ("setsockopt(SO_RCVBUF) failed, %u", WSAGetLastError ());
      if (::getsockopt (soc, SOL_SOCKET, SO_RCVBUF,
			(char *) &((fhandler_socket *) fd)->rmem (),
			(size = sizeof (int), &size)))
	system_printf ("getsockopt(SO_RCVBUF) failed, %u", WSAGetLastError ());
    }
  if (::setsockopt (soc, SOL_SOCKET, SO_SNDBUF,
		    (char *) &((fhandler_socket *) fd)->wmem (), sizeof (int)))
    {
      debug_printf ("setsockopt(SO_SNDBUF) failed, %u", WSAGetLastError ());
      if (::getsockopt (soc, SOL_SOCKET, SO_SNDBUF,
			(char *) &((fhandler_socket *) fd)->wmem (),
			(size = sizeof (int), &size)))
	system_printf ("getsockopt(SO_SNDBUF) failed, %u", WSAGetLastError ());
    }

  /* A unique ID is necessary to recognize fhandler entries which are
     duplicated by dup(2) or fork(2).  This is used in BSD flock calls
     to identify the descriptor. */
  ((fhandler_socket *) fd)->set_unique_id ();

  return true;
}

/* exported as socket: standards? */
extern "C" int
cygwin_socket (int af, int type, int protocol)
{
  int res = -1;
  SOCKET soc = 0;

  int flags = type & _SOCK_FLAG_MASK;
  type &= ~_SOCK_FLAG_MASK;

  debug_printf ("socket (%d, %d (flags %y), %d)", af, type, flags, protocol);

  if ((flags & ~(SOCK_NONBLOCK | SOCK_CLOEXEC)) != 0)
    {
      set_errno (EINVAL);
      goto done;
    }

  soc = socket (af == AF_LOCAL ? AF_INET : af, type,
		af == AF_LOCAL ? 0 : protocol);

  if (soc == INVALID_SOCKET)
    {
      set_winsock_errno ();
      goto done;
    }

  const device *dev;

  if (af == AF_LOCAL)
    dev = type == SOCK_STREAM ? stream_dev : dgram_dev;
  else
    dev = type == SOCK_STREAM ? tcp_dev : udp_dev;

  {
    cygheap_fdnew fd;
    if (fd < 0 || !fdsock (fd, dev, soc))
      closesocket (soc);
    else
      {
	((fhandler_socket *) fd)->set_addr_family (af);
	((fhandler_socket *) fd)->set_socket_type (type);
	if (flags & SOCK_NONBLOCK)
	  ((fhandler_socket *) fd)->set_nonblocking (true);
	if (flags & SOCK_CLOEXEC)
	  ((fhandler_socket *) fd)->set_close_on_exec (true);
	if (type == SOCK_DGRAM)
	  {
	    /* Workaround the problem that a missing listener on a UDP socket
	       in a call to sendto will result in select/WSAEnumNetworkEvents
	       reporting that the socket has pending data and a subsequent call
	       to recvfrom will return -1 with error set to WSAECONNRESET.

	       This problem is a regression introduced in Windows 2000.
	       Instead of fixing the problem, a new socket IOCTL code has
	       been added, see http://support.microsoft.com/kb/263823 */
	    BOOL cr = FALSE;
	    DWORD blen;
	    if (WSAIoctl (soc, SIO_UDP_CONNRESET, &cr, sizeof cr, NULL, 0,
			  &blen, NULL, NULL) == SOCKET_ERROR)
	      debug_printf ("Reset SIO_UDP_CONNRESET: WinSock error %u",
			    WSAGetLastError ());
	  }
	res = fd;
      }
  }

done:
  syscall_printf ("%R = socket(%d, %d (flags %y), %d)",
		  res, af, type, flags, protocol);
  return res;
}

/* exported as sendto: standards? */
extern "C" ssize_t
cygwin_sendto (int fd, const void *buf, size_t len, int flags,
	       const struct sockaddr *to, socklen_t tolen)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->sendto (buf, len, flags, to, tolen);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%lR = sendto(%d, %p, %ld, %y, %p, %d)",
		  res, fd, buf, len, flags, to, tolen);
  return res;
}

/* exported as recvfrom: standards? */
extern "C" ssize_t
cygwin_recvfrom (int fd, void *buf, size_t len, int flags,
		 struct sockaddr *from, socklen_t *fromlen)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	/* Originally we shortcircuited here if res == 0.
	   Allow 0 bytes buffer.  This is valid in POSIX and handled in
	   fhandler_socket::recv_internal.  If we shortcircuit, we fail
	   to deliver valid error conditions and peer address. */
	res = fh->recvfrom (buf, len, flags, from, fromlen);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%lR = recvfrom(%d, %p, %ld, %y, %p, %p)",
		  res, fd, buf, len, flags, from, fromlen);
  return res;
}

static int
convert_ws1_ip_optname (int optname)
{
  static int ws2_optname[] =
  {
    0,
    IP_OPTIONS,
    IP_MULTICAST_IF,
    IP_MULTICAST_TTL,
    IP_MULTICAST_LOOP,
    IP_ADD_MEMBERSHIP,
    IP_DROP_MEMBERSHIP,
    IP_TTL,
    IP_TOS,
    IP_DONTFRAGMENT
  };
  return (optname < 1 || optname > _WS1_IP_DONTFRAGMENT)
	 ? optname
	 : ws2_optname[optname];
}

/* exported as setsockopt: standards? */
extern "C" int
cygwin_setsockopt (int fd, int level, int optname, const void *optval,
		   socklen_t optlen)
{
  int res = -1;

  __try
    {
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;

      /* Switch off the AF_LOCAL handshake and thus SO_PEERCRED handling
	 for AF_LOCAL/SOCK_STREAM sockets.  This allows to handle special
	 situations in which connect is called before a listening socket
	 accepts connections.
	 FIXME: In the long run we should find a more generic solution which
	 doesn't require a blocking handshake in accept/connect to exchange
	 SO_PEERCRED credentials. */
      if (level == SOL_SOCKET && optname == SO_PEERCRED)
	{
	  if (optval || optlen)
	    set_errno (EINVAL);
	  else
	    res = fh->af_local_set_no_getpeereid ();
	  __leave;
	}

      /* Old applications still use the old WinSock1 IPPROTO_IP values. */
      if (level == IPPROTO_IP && CYGWIN_VERSION_CHECK_FOR_USING_WINSOCK1_VALUES)
	optname = convert_ws1_ip_optname (optname);

      /* Per POSIX we must not be able to reuse a complete duplicate of a
	 local TCP address (same IP, same port), even if SO_REUSEADDR has been
	 set.  That's unfortunately possible in WinSock, and this has never
	 been changed to maintain backward compatibility.  Instead, the
	 SO_EXCLUSIVEADDRUSE option has been added to allow an application to
	 request POSIX standard behaviour in the non-SO_REUSEADDR case.

	 However, the WinSock standard behaviour of stream socket binding
	 is equivalent to the POSIX behaviour as if SO_REUSEADDR has been set.
	 So what we do here is to note that SO_REUSEADDR has been set, but not
	 actually hand over the request to WinSock.  This is tested in
	 fhandler_socket::bind(), so that SO_EXCLUSIVEADDRUSE can be set if
	 the application did not set SO_REUSEADDR.  This should reflect the
	 POSIX socket binding behaviour as close as possible with WinSock. */
      if (level == SOL_SOCKET && optname == SO_REUSEADDR
	  && fh->get_socket_type () == SOCK_STREAM)
	res = 0;
      else
	res = setsockopt (fh->get_socket (), level, optname,
			  (const char *) optval, optlen);

      if (optlen == sizeof (int))
	syscall_printf ("setsockopt optval=%x", *(int *) optval);

      if (res)
	{
	  /* KB 248611:

	     Windows 2000 and above don't support setting the IP_TOS field
	     with setsockopt.  Additionally, TOS was always (also under 9x
	     and NT) only implemented for UDP and ICMP, never for TCP.

	     The difference is that beginning with Windows 2000 the
	     setsockopt call returns WinSock error 10022, WSAEINVAL when
	     trying to set the IP_TOS field, instead of just ignoring the
	     call.  This is *not* explained in KB 248611, but only in KB
	     258978.

	     Either case, the official workaround is to add a new registry
	     DWORD value HKLM/System/CurrentControlSet/Services/Tcpip/...
	     ...  Parameters/DisableUserTOSSetting, set to 0, and reboot.

	     Sidenote: The reasoning for dropping ToS in Win2K is that ToS
	     per RFC 1349 is incompatible with DiffServ per RFC 2474/2475.

	     We just ignore the return value of setting IP_TOS entirely.
	     
	     CV 2014-04-16: Same for IPV6_TCLASS
	     FIXME:         Same for IPV6_RECVTCLASS? */
	  if (level == IPPROTO_IP && optname == IP_TOS
	      && WSAGetLastError () == WSAEINVAL)
	    {
	      debug_printf ("Faked IP_TOS success");
	      res = 0;
	    }
	  else if (level == IPPROTO_IPV6 && optname == IPV6_TCLASS
		   && WSAGetLastError () == WSAENOPROTOOPT)
	    {
	      debug_printf ("Faked IPV6_TCLASS success");
	      res = 0;
	    }
	  else
	    set_winsock_errno ();
	}
      else if (level == SOL_SOCKET)
	switch (optname)
	  {
	  case SO_REUSEADDR:
	    fh->saw_reuseaddr (*(int *) optval);
	    break;
	  case SO_RCVBUF:
	    fh->rmem (*(int *) optval);
	    break;
	  case SO_SNDBUF:
	    fh->wmem (*(int *) optval);
	    break;
	  default:
	    break;
	  }
    }
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
  syscall_printf ("%R = setsockopt(%d, %d, %y, %p, %d)",
		  res, fd, level, optname, optval, optlen);
  return res;
}

/* exported as getsockopt: standards? */
extern "C" int
cygwin_getsockopt (int fd, int level, int optname, void *optval,
		   socklen_t *optlen)
{
  int res = -1;

  __try
    {
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;
      if (optname == SO_PEERCRED && level == SOL_SOCKET)
	{
	  struct ucred *cred = (struct ucred *) optval;
	  res = fh->getpeereid (&cred->pid, &cred->uid, &cred->gid);
	  __leave;
	}
      /* Old applications still use the old WinSock1 IPPROTO_IP values. */
      if (level == IPPROTO_IP && CYGWIN_VERSION_CHECK_FOR_USING_WINSOCK1_VALUES)
	optname = convert_ws1_ip_optname (optname);
      res = getsockopt (fh->get_socket (), level, optname, (char *) optval,
			(int *) optlen);
      if (res == SOCKET_ERROR)
	set_winsock_errno ();
      else if (level == SOL_SOCKET && optname == SO_ERROR)
	{
	  int *e = (int *) optval;
	  debug_printf ("WinSock SO_ERROR = %d", *e);
	  *e = find_winsock_errno (*e);
	}
      else if (*optlen == 1)
	{
	  /* Regression in Vista and later:  instead of a 4 byte BOOL value,
	     a 1 byte BOOLEAN value is returned, in contrast to older systems
	     and the documentation.  Since an int type is expected by the
	     calling application, we convert the result here.  For some reason
	     only three BSD-compatible socket options seem to be affected. */
	  if ((level == SOL_SOCKET
	       && (optname == SO_KEEPALIVE || optname == SO_DONTROUTE))
	      || (level == IPPROTO_TCP && optname == TCP_NODELAY))
	    {
	      BOOLEAN *in = (BOOLEAN *) optval;
	      int *out = (int *) optval;
	      *out = *in;
	      *optlen = 4;
	    }
	}
    }
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
  syscall_printf ("%R = getsockopt(%d, %d, %y, %p, %p)",
		  res, fd, level, optname, optval, optlen);
  return res;
}

/* POSIX.1-2001 */
extern "C" int
sockatmark (int fd)
{
  int ret;

  fhandler_socket *fh = get (fd);
  if (fh && fh->ioctl (SIOCATMARK, &ret) != -1)
    return ret;
  return -1;
}

/* BSD */
extern "C" int
getpeereid (int fd, uid_t *euid, gid_t *egid)
{
  fhandler_socket *fh = get (fd);
  if (fh)
    return fh->getpeereid (NULL, euid, egid);
  return -1;
}

/* exported as connect: standards? */
extern "C" int
cygwin_connect (int fd, const struct sockaddr *name, socklen_t namelen)
{
  int res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->connect (name, namelen);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = connect(%d, %p, %d)", res, fd, name, namelen);
  return res;
}

/* exported as getservbyname: standards? */
extern "C" struct servent *
cygwin_getservbyname (const char *name, const char *proto)
{
  servent *res = NULL;

  __try
    {
      res = dup_ent (getservbyname (name, proto));
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%p = getservbyname (%s, %s)", res, name, proto);
  return res;
}

/* exported as getservbyport: standards? */
extern "C" struct servent *
cygwin_getservbyport (int port, const char *proto)
{
  servent *res = NULL;

  __try
    {
      res = dup_ent (getservbyport (port, proto));
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%p = getservbyport (%d, %s)", res, port, proto);
  return res;
}

extern "C" int
cygwin_gethostname (char *name, size_t len)
{
  int res = -1;

  __try
    {
      if (gethostname (name, len))
	{
	  DWORD local_len = len;

	  if (!GetComputerNameExA (ComputerNameDnsFullyQualified, name,
				   &local_len))
	    {
	      set_winsock_errno ();
	      __leave;
	    }
	}
      debug_printf ("name %s", name);
      res = 0;
    }
  __except (EFAULT) {}
  __endtry
  return res;
}

/* exported as gethostbyname: standards? */
extern "C" struct hostent *
cygwin_gethostbyname (const char *name)
{
  unsigned char tmp_addr[4];
  struct hostent tmp, *h;
  char *tmp_aliases[1] = {0};
  char *tmp_addr_list[2] = {0,0};
  unsigned int a, b, c, d;
  char dummy;
  hostent *res = NULL;

  __try
    {
      if (sscanf (name, "%u.%u.%u.%u%c", &a, &b, &c, &d, &dummy) != 4
	  || a >= 256 || b >= 256 || c >= 256 || d >= 256)
	h = gethostbyname (name);
      else
	{
	  /* In case you don't have DNS, at least x.x.x.x still works */
	  memset (&tmp, 0, sizeof (tmp));
	  tmp_addr[0] = a;
	  tmp_addr[1] = b;
	  tmp_addr[2] = c;
	  tmp_addr[3] = d;
	  tmp_addr_list[0] = (char *) tmp_addr;
	  tmp.h_name = name;
	  tmp.h_aliases = tmp_aliases;
	  tmp.h_addrtype = 2;
	  tmp.h_length = 4;
	  tmp.h_addr_list = tmp_addr_list;
	  h = &tmp;
	}

      res = dup_ent (h);
      if (res)
	debug_printf ("h_name %s", res->h_name);
      else
	{
	  debug_printf ("dup_ent returned NULL for name %s, h %p", name, h);
	  set_host_errno ();
	}
    }
  __except (EFAULT)
    {
      res = NULL;
    }
  __endtry
  return res;
}

/* exported as gethostbyaddr: standards? */
extern "C" struct hostent *
cygwin_gethostbyaddr (const char *addr, int len, int type)
{
  hostent *res = NULL;

  __try
    {
      res = dup_ent (gethostbyaddr (addr, len, type));
      if (res)
	debug_printf ("h_name %s", res->h_name);
      else
	set_host_errno ();
    }
  __except (EFAULT)
    {
      res = NULL;
    }
  __endtry
  return res;
}

static void
memcpy4to6 (char *dst, const u_char *src)
{
  const unsigned int h[] = {0, 0, htonl (0xFFFF)};
  memcpy (dst, h, 12);
  memcpy (dst + 12, src, NS_INADDRSZ);
}

/* gethostby_specials: RFC 6761 
   Handles numerical addresses and special names for gethostbyname2 */ 
static hostent *
gethostby_specials (const char *name, const int af,
		    const int addrsize_in, const int addrsize_out)
{
  int namelen = strlen (name);
  /* Ignore a final '.' */
  if ((namelen == 0) || ((namelen -= (name[namelen - 1] == '.')) == 0)) 
    {
      set_errno (EINVAL);
      h_errno = NETDB_INTERNAL;
      return NULL;
    }

  int res;
  u_char address[NS_IN6ADDRSZ];
  /* Test for numerical addresses */
  res = cygwin_inet_pton(af, name, address);
  /* Test for special domain names */
  if (res != 1)
    {
      {
	char const match[] = "invalid";
	int const matchlen = sizeof(match) - 1;
	int start = namelen - matchlen;
	if ((start >= 0) && ((start == 0) || (name[start-1] == '.'))
	    && (strncasecmp (&name[start], match , matchlen) == 0))
	  {
	    h_errno = HOST_NOT_FOUND;
	    return NULL;
	  }
      }
      {
	char const match[] = "localhost";
	int const matchlen = sizeof(match) - 1;
	int start = namelen - matchlen;
	if ((start >= 0) && ((start == 0) || (name[start-1] == '.'))
	    && (strncasecmp (&name[start], match , matchlen) == 0))
	  {
	    res = 1;
	    if (af == AF_INET)
	      {
		address[0] = 127;
		address[1] = address[2] = 0;
		address[3] = 1;
	      }
	    else
	      {
		memset (address, 0, NS_IN6ADDRSZ);
		address[NS_IN6ADDRSZ-1] = 1;
	      }
	  }
      }
    }
  if (res != 1)
    return NULL;  

  int const alias_count = 0, address_count = 1;
  char * string_ptr;
  int sz = DWORD_round (sizeof(hostent))
    + sizeof (char *) * (alias_count + address_count + 2)
    + namelen + 1
    + address_count * addrsize_out;
  hostent *ret = realloc_ent (sz,  (hostent *) NULL);
  if (!ret)
    {
      /* errno is already set */
      h_errno = NETDB_INTERNAL;
      return NULL;
    }

  ret->h_addrtype = af;
  ret->h_length = addrsize_out;
  ret->h_aliases = (char **) (((char *) ret) + DWORD_round (sizeof(hostent)));
  ret->h_addr_list = ret->h_aliases + alias_count + 1;
  string_ptr = (char *) (ret->h_addr_list + address_count + 1);
  ret->h_name = string_ptr;

  memcpy (string_ptr, name, namelen);
  string_ptr[namelen] = 0;
  string_ptr += namelen + 1;

  ret->h_addr_list[0] = string_ptr;
  if (addrsize_in != addrsize_out)
    {
      memcpy4to6 (string_ptr, address);
      ret->h_addrtype = AF_INET6;
    }
  else
    memcpy (string_ptr, address, addrsize_out);

  ret->h_aliases[alias_count] = NULL;
  ret->h_addr_list[address_count] = NULL;

  return ret;
}

static hostent *
gethostby_helper (const char *name, const int af, const int type,
		  const int addrsize_in, const int addrsize_out)
{
  /* Get the data from the name server */
  const int maxcount = 3;
  int old_errno, ancount = 0, anlen = 1024, msgsize = 0;
  u_char *ptr, *msg = NULL;
  int sz;
  hostent *ret;
  char *string_ptr;

  while ((anlen > msgsize) && (ancount++ < maxcount))
    {
      msgsize = anlen;
      ptr = (u_char *) realloc (msg, msgsize);
      if (ptr == NULL )
	{
	  old_errno = errno;
	  free (msg);
	  set_errno (old_errno);
	  h_errno = NETDB_INTERNAL;
	  return NULL;
	}
      msg = ptr;
      anlen = res_search (name, ns_c_in, type, msg, msgsize);
    }

  if (ancount >= maxcount)
    {
      free (msg);
      h_errno = NO_RECOVERY;
      return NULL;
    }
  if (anlen < 0) /* errno and h_errno are set */
    {
      old_errno = errno;
      free (msg);
      set_errno (old_errno);
      return NULL;
    }
  u_char *eomsg = msg + anlen - 1;

  /* We scan the answer records to determine the required memory size.
     They can be corrupted and we don't fully trust that the message
     follows the standard exactly. glibc applies some checks that
     we emulate.
     The answers are copied in the hostent structure in a second scan.
     To simplify the second scan we store information as follows:
     - "class" is replaced by the compressed name size
     - the first 16 bits of the "ttl" store the expanded name size + 1
     - the last 16 bits of the "ttl" store the offset to the next valid record.
     Note that "type" is rewritten in host byte order. */

  class record {
  public:
    unsigned type: 16;		// type
    unsigned complen: 16;       // class or compressed length
    unsigned namelen1: 16;      // expanded length (with final 0)
    unsigned next_o: 16;        // offset to next valid
    unsigned size: 16;          // data size
    u_char data[];              // data
    record * next () { return (record *) (((char *) this) + next_o); }
    void set_next ( record * nxt) { next_o = ((char *) nxt) - ((char *) this); }
    u_char * name () { return (u_char *) (((char *) this) - complen); }
  };

  record * anptr = NULL, * prevptr = NULL, * curptr;
  int i, alias_count = 0, string_size = 0, address_count = 0;
  int namelen1 = 0, address_len = 0, antype, anclass, ansize;
  unsigned complen;

  /* Get the count of answers */
  ancount = ntohs (((HEADER *) msg)->ancount);

  /* Skip the question, it was verified by res_send */
  ptr = msg + sizeof (HEADER);
  if ((complen = dn_skipname (ptr, eomsg)) < 0)
    goto corrupted;
  /* Point to the beginning of the answer section */
  ptr += complen + NS_QFIXEDSZ;

  /* Scan the answer records to determine the sizes */
  for (i = 0; i < ancount; i++, ptr = curptr->data + ansize)
    {
      if ((complen = dn_skipname (ptr, eomsg)) < 0)
	goto corrupted;

      curptr = (record *) (ptr + complen);
      antype = ntohs (curptr->type);
      anclass = ntohs (curptr->complen);
      ansize = ntohs (curptr->size);
      /* Class must be internet */
      if (anclass != ns_c_in)
	continue;

      curptr->complen = complen;
      if ((namelen1 = dn_length1 (msg, eomsg, curptr-> name())) <= 0)
	goto corrupted;

      if (antype == ns_t_cname)
	{
	  alias_count++;
	  string_size += namelen1;
	}
      else if (antype == type)
	{
	  ansize = ntohs (curptr->size);
	  if (ansize != addrsize_in)
	    continue;
	  if (address_count == 0)
	    {
	      address_len = namelen1;
	      string_size += namelen1;
	    }
	  else if (address_len != namelen1)
	    continue;
	  address_count++;
	}
      /* Update the records */
      curptr->type = antype; /* Host byte order */
      curptr->namelen1 = namelen1;
      if (! anptr)
	anptr = prevptr = curptr;
      else
	{
	  prevptr->set_next (curptr);
	  prevptr = curptr;
	}
    }

  /* If there is no address, quit */
  if (address_count == 0)
    {
      free (msg);
      h_errno = NO_DATA;
      return NULL;
    }

  /* Determine the total size */
  sz = DWORD_round (sizeof(hostent))
       + sizeof (char *) * (alias_count + address_count + 2)
       + string_size
       + address_count * addrsize_out;

  ret = realloc_ent (sz,  (hostent *) NULL);
  if (! ret)
    {
      old_errno = errno;
      free (msg);
      set_errno (old_errno);
      h_errno = NETDB_INTERNAL;
      return NULL;
    }

  ret->h_addrtype = af;
  ret->h_length = addrsize_out;
  ret->h_aliases = (char **) (((char *) ret) + DWORD_round (sizeof(hostent)));
  ret->h_addr_list = ret->h_aliases + alias_count + 1;
  string_ptr = (char *) (ret->h_addr_list + address_count + 1);

  /* Rescan the answers */
  alias_count = address_count = 0;
  prevptr->set_next (prevptr + 1);

  for (curptr = anptr; curptr <= prevptr; curptr = curptr->next ())
    {
      antype = curptr->type;
      if (antype == ns_t_cname)
	{
	  dn_expand (msg, eomsg, curptr->name (), string_ptr, curptr->namelen1);
	  ret->h_aliases[alias_count++] = string_ptr;
	  string_ptr += curptr->namelen1;
	}
      else
	{
	  if (address_count == 0)
	    {
	      dn_expand (msg, eomsg, curptr->name (), string_ptr,
			 curptr->namelen1);
	      ret->h_name = string_ptr;
	      string_ptr += curptr->namelen1;
	    }
	  ret->h_addr_list[address_count++] = string_ptr;
	  if (addrsize_in != addrsize_out)
	    {
	      memcpy4to6 (string_ptr, curptr->data);
	      ret->h_addrtype =  AF_INET6;
	    }
	  else
	    memcpy (string_ptr, curptr->data, addrsize_in);
	  string_ptr += addrsize_out;
	}
    }

  free (msg);

  ret->h_aliases[alias_count] = NULL;
  ret->h_addr_list[address_count] = NULL;

  return ret;

corrupted:
  free (msg);
  /* Hopefully message corruption errors are temporary.
     Should it be NO_RECOVERY ? */
  h_errno = TRY_AGAIN;
  return NULL;
}

/* gethostbyname2: standards? */
extern "C" struct hostent *
gethostbyname2 (const char *name, int af)
{
  hostent *res = NULL;

  __try
    {
      if (!(_res.options & RES_INIT))
	res_init();

      bool v4to6 = _res.options & RES_USE_INET6;
      int type, addrsize_in, addrsize_out;

      switch (af)
	{
	case AF_INET:
	  addrsize_in = NS_INADDRSZ;
	  addrsize_out = (v4to6) ? NS_IN6ADDRSZ : NS_INADDRSZ;
	  type = ns_t_a;
	  break;
	case AF_INET6:
	  addrsize_in = addrsize_out = NS_IN6ADDRSZ;
	  type = ns_t_aaaa;
	  break;
	default:
	  set_errno (EAFNOSUPPORT);
	  h_errno = NETDB_INTERNAL;
	  __leave;
	}

      h_errno = NETDB_SUCCESS;
      res = gethostby_specials (name, af, addrsize_in, addrsize_out);
      if ((res == NULL) && (h_errno == NETDB_SUCCESS))
	  res = gethostby_helper (name, af, type, addrsize_in, addrsize_out);
    }
  __except (EFAULT) {}
  __endtry
  return res;
}

/* exported as accept: standards? */
extern "C" int
cygwin_accept (int fd, struct sockaddr *peer, socklen_t *len)
{
  int res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->accept4 (peer, len,
			   fh->is_nonblocking () ? SOCK_NONBLOCK : 0);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = accept(%d, %p, %p)", res, fd, peer, len);
  return res;
}

extern "C" int
accept4 (int fd, struct sockaddr *peer, socklen_t *len, int flags)
{
  int res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;
      if ((flags & ~(SOCK_NONBLOCK | SOCK_CLOEXEC)) != 0)
	  set_errno (EINVAL);
      else
	res = fh->accept4 (peer, len, flags);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = accept4(%d, %p, %p, %y)", res, fd, peer, len, flags);
  return res;
}

/* exported as bind: standards? */
extern "C" int
cygwin_bind (int fd, const struct sockaddr *my_addr, socklen_t addrlen)
{
  int res = -1;

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->bind (my_addr, addrlen);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = bind(%d, %p, %d)", res, fd, my_addr, addrlen);
  return res;
}

/* exported as getsockname: standards? */
extern "C" int
cygwin_getsockname (int fd, struct sockaddr *addr, socklen_t *namelen)
{
  int res = -1;

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->getsockname (addr, namelen);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R =getsockname (%d, %p, %p)", res, fd, addr, namelen);
  return res;
}

/* exported as listen: standards? */
extern "C" int
cygwin_listen (int fd, int backlog)
{
  int res = -1;

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->listen (backlog);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = listen(%d, %d)", res, fd, backlog);
  return res;
}

/* exported as shutdown: standards? */
extern "C" int
cygwin_shutdown (int fd, int how)
{
  int res = -1;

  fhandler_socket *fh = get (fd);
  if (fh)
    res = fh->shutdown (how);
  syscall_printf ("%R = shutdown(%d, %d)", res, fd, how);
  return res;
}

/* exported as hstrerror: BSD 4.3  */
extern "C" const char *
cygwin_hstrerror (int err)
{
  int i;

  for (i = 0; host_errmap[i].e != 0; ++i)
    if (err == host_errmap[i].e)
      break;

  return host_errmap[i].s;
}

/* exported as herror: BSD 4.3  */
extern "C" void
cygwin_herror (const char *s)
{
  __try
    {
      if (cygheap->fdtab.not_open (2))
	return;

      if (s)
	{
	  write (2, s, strlen (s));
	  write (2, ": ", 2);
	}

      const char *h_errstr = cygwin_hstrerror (h_errno);

      if (!h_errstr)
	switch (h_errno)
	  {
	    case NETDB_INTERNAL:
	      h_errstr = "Resolver internal error";
	      break;
	    case NETDB_SUCCESS:
	      h_errstr = "Resolver error 0 (no error)";
	      break;
	    default:
	      h_errstr = "Unknown resolver error";
	      break;
	  }
      write (2, h_errstr, strlen (h_errstr));
      write (2, "\n", 1);
    }
  __except (NO_ERROR) {}
  __endtry
}

/* exported as getpeername: standards? */
extern "C" int
cygwin_getpeername (int fd, struct sockaddr *name, socklen_t *len)
{
  int res = -1;
  fhandler_socket *fh = NULL;

  __try
    {
      fh = get (fd);
      if (fh)
	res = fh->getpeername (name, len);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = getpeername(%d) %p", res, fd,
  		  (fh ? fh->get_socket () : (SOCKET) -1));
  return res;
}

/* exported as recv: standards? */
extern "C" ssize_t
cygwin_recv (int fd, void *buf, size_t len, int flags)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	/* Originally we shortcircuited here if res == 0.
	   Allow 0 bytes buffer.  This is valid in POSIX and handled in
	   fhandler_socket::recv_internal.  If we shortcircuit, we fail
	   to deliver valid error conditions. */
	res = fh->recvfrom (buf, len, flags, NULL, NULL);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%lR = recv(%d, %p, %ld, %y)", res, fd, buf, len, flags);
  return res;
}

/* exported as send: standards? */
extern "C" ssize_t
cygwin_send (int fd, const void *buf, size_t len, int flags)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->sendto (buf, len, flags, NULL, 0);
    }
  __except (EFAULT)
  __endtry
  syscall_printf ("%lR = send(%d, %p, %ld, %y)", res, fd, buf, len, flags);
  return res;
}

/* getdomainname: standards? */
extern "C" int
getdomainname (char *domain, size_t len)
{
  __try
    {
      PFIXED_INFO info = NULL;
      ULONG size = 0;

      if (GetNetworkParams(info, &size) == ERROR_BUFFER_OVERFLOW
	  && (info = (PFIXED_INFO) alloca(size))
	  && GetNetworkParams(info, &size) == ERROR_SUCCESS)
	{
	  strncpy(domain, info->DomainName, len);
	  return 0;
	}
      __seterrno ();
    }
  __except (EFAULT)
  __endtry
  return -1;
}

/* Fill out an ifconf struct. */

#ifndef IN_LOOPBACK
#define IN_LOOPBACK(a)	((((long int) (a)) & 0xff000000) == 0x7f000000)
#endif

static int in6_are_prefix_equal (struct in6_addr *, struct in6_addr *, int);

static int in_are_prefix_equal (struct in_addr *p1, struct in_addr *p2, int len)
{
  if (0 > len || len > 32)
    return 0;
  uint32_t pfxmask = 0xffffffff << (32 - len);
  return (ntohl (p1->s_addr) & pfxmask) == (ntohl (p2->s_addr) & pfxmask);
}

extern "C" int
ip_addr_prefix (PIP_ADAPTER_UNICAST_ADDRESS pua, PIP_ADAPTER_PREFIX pap)
{
  if (wincap.has_gaa_on_link_prefix ())
    return (int) ((PIP_ADAPTER_UNICAST_ADDRESS_LH) pua)->OnLinkPrefixLength;
  switch (pua->Address.lpSockaddr->sa_family)
    {
    case AF_INET:
      /* Prior to Vista, the loopback prefix is not available. */
      if (IN_LOOPBACK (ntohl (((struct sockaddr_in *)
			      pua->Address.lpSockaddr)->sin_addr.s_addr)))
	return 8;
      for ( ; pap; pap = pap->Next)
	if (in_are_prefix_equal (
	      &((struct sockaddr_in *) pua->Address.lpSockaddr)->sin_addr,
	      &((struct sockaddr_in *) pap->Address.lpSockaddr)->sin_addr,
	      pap->PrefixLength))
	  return pap->PrefixLength;
      break;
    case AF_INET6:
      /* Prior to Vista, the loopback prefix is not available. */
      if (IN6_IS_ADDR_LOOPBACK (&((struct sockaddr_in6 *)
				  pua->Address.lpSockaddr)->sin6_addr))
	return 128;
      for ( ; pap; pap = pap->Next)
	if (in6_are_prefix_equal (
	      &((struct sockaddr_in6 *) pua->Address.lpSockaddr)->sin6_addr,
	      &((struct sockaddr_in6 *) pap->Address.lpSockaddr)->sin6_addr,
	      pap->PrefixLength))
	  return pap->PrefixLength;
      break;
    default:
      break;
    }
  return 0;
}

#ifndef GAA_FLAG_INCLUDE_ALL_INTERFACES
#define GAA_FLAG_INCLUDE_ALL_INTERFACES 0x0100
#endif

struct gaa_wa {
  ULONG family;
  PIP_ADAPTER_ADDRESSES *pa_ret;
};

DWORD WINAPI
call_gaa (LPVOID param)
{
  DWORD ret, size = 0;
  gaa_wa *p = (gaa_wa *) param;
  PIP_ADAPTER_ADDRESSES pa0 = NULL;

  if (!p->pa_ret)
    return GetAdaptersAddresses (p->family, GAA_FLAG_INCLUDE_PREFIX
					    | GAA_FLAG_INCLUDE_ALL_INTERFACES,
				 NULL, NULL, &size);
  do
    {
      ret = GetAdaptersAddresses (p->family, GAA_FLAG_INCLUDE_PREFIX
					     | GAA_FLAG_INCLUDE_ALL_INTERFACES,
				  NULL, pa0, &size);
      if (ret == ERROR_BUFFER_OVERFLOW
	  && !(pa0 = (PIP_ADAPTER_ADDRESSES) realloc (pa0, size)))
	break;
    }
  while (ret == ERROR_BUFFER_OVERFLOW);
  if (pa0)
    {
      if (ret != ERROR_SUCCESS)
	{
	  free (pa0);
	  *p->pa_ret = NULL;
	}
      else
	*p->pa_ret = pa0;
    }
  return ret;
}

bool
get_adapters_addresses (PIP_ADAPTER_ADDRESSES *pa_ret, ULONG family)
{
  DWORD ret;
  gaa_wa param = { family, pa_ret };

  if ((uintptr_t) &param >= (uintptr_t) 0x80000000L
      && wincap.has_gaa_largeaddress_bug ())
    {
      /* In Windows Vista and Windows 7 under WOW64, GetAdaptersAddresses fails
	 if it's running in a thread with a stack located in the large address
	 area.  So, if we're running in a pthread with such a stack, we call
	 GetAdaptersAddresses in a child thread with an OS-allocated stack.
	 The OS allocates stacks bottom up, so chances are good that the new
	 stack will be located in the lower address area. */
      HANDLE thr = CreateThread (NULL, 0, call_gaa, &param, 0, NULL);
      if (!thr)
	{
	  debug_printf ("CreateThread: %E");
	  return false;
	}
      WaitForSingleObject (thr, INFINITE);
      GetExitCodeThread (thr, &ret);
      CloseHandle (thr);
    }
  else
    ret = call_gaa (&param);
  return ret == ERROR_SUCCESS || (!pa_ret && ret == ERROR_BUFFER_OVERFLOW);
}

#define WS_IFF_UP	     1
#define WS_IFF_BROADCAST     2
#define WS_IFF_LOOPBACK	     4
#define WS_IFF_POINTTOPOINT  8
#define WS_IFF_MULTICAST    16

static inline short
convert_ifr_flags (u_long ws_flags)
{
  return (ws_flags & (WS_IFF_UP | WS_IFF_BROADCAST))
	 | ((ws_flags & (WS_IFF_LOOPBACK | WS_IFF_POINTTOPOINT)) << 1)
	 | ((ws_flags & WS_IFF_MULTICAST) << 8);
}

static u_long
get_routedst (DWORD if_index)
{
  PMIB_IPFORWARDTABLE pift;
  ULONG size = 0;
  if (GetIpForwardTable (NULL, &size, FALSE) == ERROR_INSUFFICIENT_BUFFER
      && (pift = (PMIB_IPFORWARDTABLE) alloca (size))
      && GetIpForwardTable (pift, &size, FALSE) == NO_ERROR)
    for (DWORD i = 0; i < pift->dwNumEntries; ++i)
      {
	if (pift->table[i].dwForwardIfIndex == if_index
	    && pift->table[i].dwForwardMask == INADDR_BROADCAST)
	  return pift->table[i].dwForwardDest;
      }
  return INADDR_ANY;
}

struct ifall {
  struct ifaddrs          ifa_ifa;
  char                    ifa_name[IFNAMSIZ];
  struct sockaddr_storage ifa_addr;
  struct sockaddr_storage ifa_brddstaddr;
  struct sockaddr_storage ifa_netmask;
  struct sockaddr         ifa_hwaddr;
  int                     ifa_metric;
  int                     ifa_mtu;
  int                     ifa_ifindex;
  struct ifreq_frndlyname ifa_frndlyname;
};

static unsigned int
get_flags (PIP_ADAPTER_ADDRESSES pap)
{
  unsigned int flags = IFF_UP;
  if (pap->IfType == IF_TYPE_SOFTWARE_LOOPBACK)
    flags |= IFF_LOOPBACK;
  else if (pap->IfType == IF_TYPE_PPP
	   || pap->IfType == IF_TYPE_SLIP)
    flags |= IFF_POINTOPOINT | IFF_NOARP;
  if (!(pap->Flags & IP_ADAPTER_NO_MULTICAST))
    flags |= IFF_MULTICAST;
  if (pap->OperStatus == IfOperStatusUp
      || pap->OperStatus == IfOperStatusUnknown)
    flags |= IFF_RUNNING;
  if (pap->OperStatus != IfOperStatusLowerLayerDown)
    flags |= IFF_LOWER_UP;
  if (pap->OperStatus == IfOperStatusDormant)
    flags |= IFF_DORMANT;
  return flags;
}

static ULONG
get_ipv4fromreg_ipcnt (const char *name)
{
  WCHAR regkey[256], *c;

  c = wcpcpy (regkey, L"Tcpip\\Parameters\\Interfaces\\");
  sys_mbstowcs (c, 220, name);
  if (!NT_SUCCESS (RtlCheckRegistryKey (RTL_REGISTRY_SERVICES, regkey)))
    return 0;

  ULONG ifs = 1;
  DWORD dhcp = 0;
  UNICODE_STRING uipa = { 0, 0, NULL };
  RTL_QUERY_REGISTRY_TABLE tab[3] = {
    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOSTRING,
      L"EnableDHCP", &dhcp, REG_NONE, NULL, 0 },
    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND,
      L"IPAddress", &uipa, REG_NONE, NULL, 0 },
    { NULL, 0, NULL, NULL, 0, NULL, 0 }
  };

  /* If DHCP is used, we have only one address. */
  if (NT_SUCCESS (RtlQueryRegistryValues (RTL_REGISTRY_SERVICES, regkey, tab,
					  NULL, NULL))
      && uipa.Buffer)
    {
      if (dhcp == 0)
      for (ifs = 0, c = uipa.Buffer; *c; c += wcslen (c) + 1)
	ifs++;
      RtlFreeUnicodeString (&uipa);
    }
  return ifs;
}

static void
get_ipv4fromreg (struct ifall *ifp, const char *name, DWORD idx)
{
  WCHAR regkey[256], *c;

  c = wcpcpy (regkey, L"Tcpip\\Parameters\\Interfaces\\");
  sys_mbstowcs (c, 220, name);
  if (!NT_SUCCESS (RtlCheckRegistryKey (RTL_REGISTRY_SERVICES, regkey)))
    return;

  ULONG ifs;
  DWORD dhcp = 0;
  UNICODE_STRING udipa = { 0, 0, NULL };
  UNICODE_STRING udsub = { 0, 0, NULL };
  UNICODE_STRING uipa = { 0, 0, NULL };
  UNICODE_STRING usub = { 0, 0, NULL };
  RTL_QUERY_REGISTRY_TABLE tab[6] = {
    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOSTRING,
      L"EnableDHCP", &dhcp, REG_NONE, NULL, 0 },
    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND,
      L"DhcpIPAddress", &udipa, REG_NONE, NULL, 0 },
    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND,
      L"DhcpSubnetMask", &udsub, REG_NONE, NULL, 0 },
    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND,
      L"IPAddress", &uipa, REG_NONE, NULL, 0 },
    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND,
      L"SubnetMask", &usub, REG_NONE, NULL, 0 },
    { NULL, 0, NULL, NULL, 0, NULL, 0 }
  };

  if (NT_SUCCESS (RtlQueryRegistryValues (RTL_REGISTRY_SERVICES, regkey, tab,
					  NULL, NULL)))
    {
#     define addr ((struct sockaddr_in *) &ifp->ifa_addr)
#     define mask ((struct sockaddr_in *) &ifp->ifa_netmask)
#     define brdc ((struct sockaddr_in *) &ifp->ifa_brddstaddr)
#     define inet_uton(u, a) \
	{ \
	  char t[64]; \
	  sys_wcstombs (t, 64, (u)); \
	  cygwin_inet_aton (t, (a)); \
	}
      /* If DHCP is used, we have only one address. */
      if (dhcp)
	{
	  if (udipa.Buffer)
	    inet_uton (udipa.Buffer, &addr->sin_addr);
	  if (udsub.Buffer)
	    inet_uton (udsub.Buffer, &mask->sin_addr);
	}
      else
	{
	  if (uipa.Buffer)
	    {
	      for (ifs = 0, c = uipa.Buffer; *c && ifs < idx;
		   c += wcslen (c) + 1)
		ifs++;
	      if (*c)
		inet_uton (c, &addr->sin_addr);
	    }
	  if (usub.Buffer)
	    {
	      for (ifs = 0, c = usub.Buffer; *c && ifs < idx;
		   c += wcslen (c) + 1)
		ifs++;
	      if (*c)
		inet_uton (c, &mask->sin_addr);
	    }
	}
      if (ifp->ifa_ifa.ifa_flags & IFF_BROADCAST)
	brdc->sin_addr.s_addr = (addr->sin_addr.s_addr
				 & mask->sin_addr.s_addr)
				| ~mask->sin_addr.s_addr;
#undef addr
#undef mask
#undef brdc
#undef inet_uton
      if (udipa.Buffer)
	RtlFreeUnicodeString (&udipa);
      if (udsub.Buffer)
	RtlFreeUnicodeString (&udsub);
      if (uipa.Buffer)
	RtlFreeUnicodeString (&uipa);
      if (usub.Buffer)
	RtlFreeUnicodeString (&usub);
    }
}

static void
get_friendlyname (struct ifall *ifp, PIP_ADAPTER_ADDRESSES pap)
{
  struct ifreq_frndlyname *iff = (struct ifreq_frndlyname *)
				 &ifp->ifa_frndlyname;
  iff->ifrf_len = sys_wcstombs (iff->ifrf_friendlyname,
				IFRF_FRIENDLYNAMESIZ,
				pap->FriendlyName);
}

static void
get_hwaddr (struct ifall *ifp, PIP_ADAPTER_ADDRESSES pap)
{
  for (UINT i = 0; i < IFHWADDRLEN; ++i)
    if (i >= pap->PhysicalAddressLength)
      ifp->ifa_hwaddr.sa_data[i] = '\0';
    else
      ifp->ifa_hwaddr.sa_data[i] = pap->PhysicalAddress[i];
}

/*
 * Generate short, unique interface name for usage with aged
 * applications still using the old pre-1.7 ifreq structure.
 */
static void
gen_old_if_name (char *name, PIP_ADAPTER_ADDRESSES pap, DWORD idx)
{
  /* Note: The returned name must be < 16 chars. */
  const char *prefix;

  switch (pap->IfType)
    {
      case IF_TYPE_ISO88025_TOKENRING:
	prefix = "tok";
	break;
      case IF_TYPE_PPP:
	prefix = "ppp";
	break;
      case IF_TYPE_SOFTWARE_LOOPBACK:
      	prefix = "lo";
	break;
      case IF_TYPE_ATM:
      	prefix = "atm";
	break;
      case IF_TYPE_IEEE80211:
      	prefix = "wlan";
	break;
      case IF_TYPE_SLIP:
      case IF_TYPE_RS232:
      case IF_TYPE_MODEM:
	prefix = "slp";
	break;
      case IF_TYPE_TUNNEL:
      	prefix = "tun";
	break;
      default:
	prefix = "eth";
	break;
    }
  if (idx)
    __small_sprintf (name, "%s%u:%u", prefix, pap->IfIndex, idx);
  else
    __small_sprintf (name, "%s%u", prefix, pap->IfIndex, idx);
}

/*
 * Get network interfaces.  Use IP Helper function GetAdaptersAddresses.
 */
static struct ifall *
get_ifs (ULONG family)
{
  PIP_ADAPTER_ADDRESSES pa0 = NULL, pap;
  PIP_ADAPTER_UNICAST_ADDRESS pua;
  int cnt = 0;
  struct ifall *ifret = NULL, *ifp;
  struct sockaddr_in *if_sin;
  struct sockaddr_in6 *if_sin6;

  if (!get_adapters_addresses (&pa0, family))
    goto done;

  for (pap = pa0; pap; pap = pap->Next)
    if (!pap->FirstUnicastAddress)
      {
	/* FirstUnicastAddress is NULL for interfaces which are disconnected.
	   Fetch number of configured IPv4 addresses from registry and
	   store in an unused member of the adapter addresses structure. */
	pap->Ipv6IfIndex = get_ipv4fromreg_ipcnt (pap->AdapterName);
	cnt += pap->Ipv6IfIndex;
      }
    else for (pua = pap->FirstUnicastAddress; pua; pua = pua->Next)
      ++cnt;

  if (!(ifret = (struct ifall *) calloc (cnt, sizeof (struct ifall))))
    goto done;
  ifp = ifret;

  for (pap = pa0; pap; pap = pap->Next)
    {
      DWORD idx = 0;
      if (!pap->FirstUnicastAddress)
	for (idx = 0; idx < pap->Ipv6IfIndex; ++idx)
	  {
	    /* Next in chain */
	    ifp->ifa_ifa.ifa_next = (struct ifaddrs *) &ifp[1].ifa_ifa;
	    /* Interface name */

	    if (CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
	      gen_old_if_name (ifp->ifa_name, pap, idx);
	    else if (idx)
	      __small_sprintf (ifp->ifa_name, "%s:%u", pap->AdapterName, idx);
	    else
	      strcpy (ifp->ifa_name, pap->AdapterName);
	    ifp->ifa_ifa.ifa_name = ifp->ifa_name;
	    /* Flags */
	    ifp->ifa_ifa.ifa_flags = get_flags (pap);
	    if (pap->IfType != IF_TYPE_PPP
		&& pap->IfType != IF_TYPE_SOFTWARE_LOOPBACK)
	      ifp->ifa_ifa.ifa_flags |= IFF_BROADCAST;
	    /* Address */
	    ifp->ifa_addr.ss_family = AF_INET;
	    ifp->ifa_ifa.ifa_addr = (struct sockaddr *) &ifp->ifa_addr;
	    /* Broadcast/Destination address */
	    ifp->ifa_brddstaddr.ss_family = AF_INET;
	    ifp->ifa_ifa.ifa_dstaddr = NULL;
	    /* Netmask */
	    ifp->ifa_netmask.ss_family = AF_INET;
	    ifp->ifa_ifa.ifa_netmask = (struct sockaddr *) &ifp->ifa_netmask;
	    /* Try to fetch real IPv4 address information from registry. */
	    get_ipv4fromreg (ifp, pap->AdapterName, idx);
	    /* Hardware address */
	    get_hwaddr (ifp, pap);
	    /* Metric */
	    ifp->ifa_metric = 1;
	    /* MTU */
	    ifp->ifa_mtu = pap->Mtu;
	    /* Interface index */
	    ifp->ifa_ifindex = pap->IfIndex;
	    /* Friendly name */
	    get_friendlyname (ifp, pap);
	    ++ifp;
	  }
      else
	for (idx = 0, pua = pap->FirstUnicastAddress; pua; pua = pua->Next)
	  {
	    struct sockaddr *sa = (struct sockaddr *) pua->Address.lpSockaddr;
#         define sin	((struct sockaddr_in *) sa)
#         define sin6	((struct sockaddr_in6 *) sa)
	    size_t sa_size = (sa->sa_family == AF_INET6
			      ? sizeof *sin6 : sizeof *sin);
	    /* Next in chain */
	    ifp->ifa_ifa.ifa_next = (struct ifaddrs *) &ifp[1].ifa_ifa;
	    /* Interface name */
	    if (CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
	      gen_old_if_name (ifp->ifa_name, pap, idx);
	    else if (sa->sa_family == AF_INET && idx)
	      __small_sprintf (ifp->ifa_name, "%s:%u", pap->AdapterName, idx);
	    else
	      strcpy (ifp->ifa_name, pap->AdapterName);
	    if (sa->sa_family == AF_INET)
	      ++idx;
	    ifp->ifa_ifa.ifa_name = ifp->ifa_name;
	    /* Flags */
	    ifp->ifa_ifa.ifa_flags = get_flags (pap);
	    if (sa->sa_family == AF_INET
		&& pap->IfType != IF_TYPE_SOFTWARE_LOOPBACK
		&& pap->IfType != IF_TYPE_PPP)
	      ifp->ifa_ifa.ifa_flags |= IFF_BROADCAST;
	    /* Address */
	    memcpy (&ifp->ifa_addr, sa, sa_size);
	    ifp->ifa_ifa.ifa_addr = (struct sockaddr *) &ifp->ifa_addr;
	    /* Netmask */
	    int prefix = ip_addr_prefix (pua, pap->FirstPrefix);
	    switch (sa->sa_family)
	      {
	      case AF_INET:
		if_sin = (struct sockaddr_in *) &ifp->ifa_netmask;
		if_sin->sin_addr.s_addr = htonl (UINT32_MAX << (32 - prefix));
		if_sin->sin_family = AF_INET;
		break;
	      case AF_INET6:
		if_sin6 = (struct sockaddr_in6 *) &ifp->ifa_netmask;
		for (cnt = 0; cnt < 4 && prefix > 0; ++cnt, prefix -= 32)
		  {
		    if_sin6->sin6_addr.s6_addr32[cnt] = UINT32_MAX;
		    if (prefix < 32)
		      if_sin6->sin6_addr.s6_addr32[cnt] <<= 32 - prefix;
		  }
		break;
	      }
	    ifp->ifa_ifa.ifa_netmask = (struct sockaddr *) &ifp->ifa_netmask;
	    if (pap->IfType == IF_TYPE_PPP)
	      {
		/* Destination address */
		if (sa->sa_family == AF_INET)
		  {
		    if_sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
		    if_sin->sin_addr.s_addr = get_routedst (pap->IfIndex);
		    if_sin->sin_family = AF_INET;
		  }
		else
		  /* FIXME: No official way to get the dstaddr for ipv6? */
		  memcpy (&ifp->ifa_addr, sa, sa_size);
		ifp->ifa_ifa.ifa_dstaddr = (struct sockaddr *)
					   &ifp->ifa_brddstaddr;
	      }
	    else
	      {
		/* Broadcast address  */
		if (sa->sa_family == AF_INET)
		  {
		    if_sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
		    uint32_t mask =
		    ((struct sockaddr_in *) &ifp->ifa_netmask)->sin_addr.s_addr;
		    if_sin->sin_addr.s_addr = (sin->sin_addr.s_addr & mask)
					      | ~mask;
		    if_sin->sin_family = AF_INET;
		    ifp->ifa_ifa.ifa_broadaddr = (struct sockaddr *)
						 &ifp->ifa_brddstaddr;
		  }
		else /* No IPv6 broadcast */
		  ifp->ifa_ifa.ifa_broadaddr = NULL;
	      }
	    /* Hardware address */
	    get_hwaddr (ifp, pap);
	    /* Metric */
	    if (wincap.has_gaa_on_link_prefix ())
	      ifp->ifa_metric = (sa->sa_family == AF_INET
				? ((PIP_ADAPTER_ADDRESSES_LH) pap)->Ipv4Metric
				: ((PIP_ADAPTER_ADDRESSES_LH) pap)->Ipv6Metric);
	    else
	      ifp->ifa_metric = 1;
	    /* MTU */
	    ifp->ifa_mtu = pap->Mtu;
	    /* Interface index */
	    ifp->ifa_ifindex = pap->IfIndex;
	    /* Friendly name */
	    get_friendlyname (ifp, pap);
	    ++ifp;
#         undef sin
#         undef sin6
	  }
    }
  /* Since every entry is set to the next entry, the last entry points to an
     invalid next entry now.  Fix it retroactively. */
  if (ifp > ifret)
    ifp[-1].ifa_ifa.ifa_next = NULL;

done:
  if (pa0)
    free (pa0);
  return ifret;
}

extern "C" int
getifaddrs (struct ifaddrs **ifap)
{
  if (!ifap)
    {
      set_errno (EINVAL);
      return -1;
    }
  struct ifall *ifp;
  ifp = get_ifs (AF_UNSPEC);
  *ifap = &ifp->ifa_ifa;
  return ifp ? 0 : -1;
}

extern "C" void
freeifaddrs (struct ifaddrs *ifp)
{
  if (ifp)
    free (ifp);
}

int
get_ifconf (struct ifconf *ifc, int what)
{
  __try
    {
      /* Ensure we have space for at least one struct ifreqs, fail if not. */
      if (ifc->ifc_len < (int) sizeof (struct ifreq))
	{
	  set_errno (EINVAL);
	  __leave;
	}

      struct ifall *ifret, *ifp;
      ifret = get_ifs (AF_INET);
      if (!ifret)
	__leave;

      struct sockaddr_in *sin;
      struct ifreq *ifr = ifc->ifc_req;
      int cnt = 0;
      for (ifp = ifret; ifp; ifp = (struct ifall *) ifp->ifa_ifa.ifa_next)
	{
	  ++cnt;
	  strcpy (ifr->ifr_name, ifp->ifa_name);
	  switch (what)
	    {
	    case SIOCGIFFLAGS:
	      ifr->ifr_flags = ifp->ifa_ifa.ifa_flags;
	      break;
	    case SIOCGIFCONF:
	    case SIOCGIFADDR:
	      sin = (struct sockaddr_in *) &ifr->ifr_addr;
	      memcpy (sin, &ifp->ifa_addr, sizeof *sin);
	      break;
	    case SIOCGIFNETMASK:
	      sin = (struct sockaddr_in *) &ifr->ifr_netmask;
	      memcpy (sin, &ifp->ifa_netmask, sizeof *sin);
	      break;
	    case SIOCGIFDSTADDR:
	      sin = (struct sockaddr_in *) &ifr->ifr_dstaddr;
	      if (ifp->ifa_ifa.ifa_flags & IFF_POINTOPOINT)
		memcpy (sin, &ifp->ifa_brddstaddr, sizeof *sin);
	      else /* Return addr as on Linux. */
		memcpy (sin, &ifp->ifa_addr, sizeof *sin);
	      break;
	    case SIOCGIFBRDADDR:
	      sin = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	      if (!(ifp->ifa_ifa.ifa_flags & IFF_POINTOPOINT))
		memcpy (sin, &ifp->ifa_brddstaddr, sizeof *sin);
	      else
		{
		  sin->sin_addr.s_addr = INADDR_ANY;
		  sin->sin_family = AF_INET;
		  sin->sin_port = 0;
		}
	      break;
	    case SIOCGIFHWADDR:
	      memcpy (&ifr->ifr_hwaddr, &ifp->ifa_hwaddr,
		      sizeof ifr->ifr_hwaddr);
	      break;
	    case SIOCGIFMETRIC:
	      ifr->ifr_metric = ifp->ifa_metric;
	      break;
	    case SIOCGIFMTU:
	      ifr->ifr_mtu = ifp->ifa_mtu;
	      break;
	    case SIOCGIFINDEX:
	      ifr->ifr_ifindex = ifp->ifa_ifindex;
	      break;
	    case SIOCGIFFRNDLYNAM:
	      memcpy (ifr->ifr_frndlyname, &ifp->ifa_frndlyname,
		      sizeof (struct ifreq_frndlyname));
	    }
	  if ((caddr_t) ++ifr >
	      ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
	    break;
	}
      /* Set the correct length */
      ifc->ifc_len = cnt * sizeof (struct ifreq);
      free (ifret);
      return 0;
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" unsigned
if_nametoindex (const char *name)
{
  PIP_ADAPTER_ADDRESSES pa0 = NULL, pap;
  unsigned index = 0;

  __try
    {
      if (get_adapters_addresses (&pa0, AF_UNSPEC))
	{
	  char lname[IF_NAMESIZE], *c;

	  lname[0] = '\0';
	  strncat (lname, name, IF_NAMESIZE - 1);
	  if (lname[0] == '{' && (c = strchr (lname, ':')))
	    *c = '\0';
	  for (pap = pa0; pap; pap = pap->Next)
	    if (strcasematch (lname, pap->AdapterName))
	      {
		index = pap->Ipv6IfIndex ?: pap->IfIndex;
		break;
	      }
	  free (pa0);
	}
    }
  __except (EFAULT)
    {
      index = 0;
    }
  __endtry
  return index;
}

extern "C" char *
if_indextoname (unsigned ifindex, char *ifname)
{
  PIP_ADAPTER_ADDRESSES pa0 = NULL, pap;
  char *name = NULL;

  __try
    {
      if (get_adapters_addresses (&pa0, AF_UNSPEC))
	{
	  for (pap = pa0; pap; pap = pap->Next)
	    if (ifindex == (pap->Ipv6IfIndex ?: pap->IfIndex))
	      {
		/* Unfortunately the pre-Vista IPv6 stack has a distinct
		   loopback device with the same Ipv6IfIndex as the IfIndex
		   of the IPv4 loopback device, but with a different adapter
		   name.  For consistency with /proc/net/if_inet6, try to find
		   the IPv6 loopback device and use that adapter name instead.
		   We identify the loopback device by its IfIndex of 1. */
		if (pap->IfIndex == 1 && pap->Ipv6IfIndex == 0)
		  for (PIP_ADAPTER_ADDRESSES pap2 = pa0;
		       pap2;
		       pap2 = pap2->Next)
		    if (pap2->Ipv6IfIndex == 1)
		      {
			pap = pap2;
			break;
		      }
		name = strcpy (ifname, pap->AdapterName);
		break;
	      }
	  free (pa0);
	}
      else
	set_errno (ENXIO);
    }
  __except (EFAULT) {}
  __endtry
  return name;
}

extern "C" struct if_nameindex *
if_nameindex (void)
{
  PIP_ADAPTER_ADDRESSES pa0 = NULL, pap;
  struct if_nameindex *iflist = NULL;
  char (*ifnamelist)[IF_NAMESIZE];

  __try
    {
      if (get_adapters_addresses (&pa0, AF_UNSPEC))
	{
	  int cnt = 0;
	  for (pap = pa0; pap; pap = pap->Next)
	    ++cnt;
	  iflist = (struct if_nameindex *)
		   malloc ((cnt + 1) * sizeof (struct if_nameindex)
			   + cnt * IF_NAMESIZE);
	  if (!iflist)
	    set_errno (ENOBUFS);
	  else
	    {
	      ifnamelist = (char (*)[IF_NAMESIZE]) (iflist + cnt + 1);
	      for (pap = pa0, cnt = 0; pap; pap = pap->Next)
		{
		  for (int i = 0; i < cnt; ++i)
		    if (iflist[i].if_index
			== (pap->Ipv6IfIndex ?: pap->IfIndex))
		      goto outer_loop;
		  iflist[cnt].if_index = pap->Ipv6IfIndex ?: pap->IfIndex;
		  strcpy (iflist[cnt].if_name = ifnamelist[cnt],
			  pap->AdapterName);
		  /* See comment in if_indextoname. */
		  if (pap->IfIndex == 1 && pap->Ipv6IfIndex == 0)
		    for (PIP_ADAPTER_ADDRESSES pap2 = pa0;
			 pap2;
			 pap2 = pap2->Next)
		      if (pap2->Ipv6IfIndex == 1)
			{
			  strcpy (ifnamelist[cnt], pap2->AdapterName);
			  break;
			}
		  ++cnt;
		outer_loop:
		  ;
		}
	      iflist[cnt].if_index = 0;
	      iflist[cnt].if_name = NULL;
	    }
	  free (pa0);
	}
      else
	set_errno (ENXIO);
    }
  __except (EFAULT) {}
  __endtry
  return iflist;
}

extern "C" void
if_freenameindex (struct if_nameindex *ptr)
{
  free (ptr);
}

#define PORT_LOW	(IPPORT_EFSSERVER + 1)
#define PORT_HIGH	(IPPORT_RESERVED - 1)
#define NUM_PORTS	(PORT_HIGH - PORT_LOW + 1)

extern "C" int
cygwin_bindresvport_sa (int fd, struct sockaddr *sa)
{
  struct sockaddr_storage sst;
  struct sockaddr_in *sin = NULL;
  struct sockaddr_in6 *sin6 = NULL;
  in_port_t port;
  socklen_t salen;
  int ret = -1;

  __try
    {
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;

      if (!sa)
	{
	  sa = (struct sockaddr *) &sst;
	  memset (&sst, 0, sizeof sst);
	  sa->sa_family = fh->get_addr_family ();
	}

      switch (sa->sa_family)
	{
	case AF_INET:
	  salen = sizeof (struct sockaddr_in);
	  sin = (struct sockaddr_in *) sa;
	  port = sin->sin_port;
	  break;
	case AF_INET6:
	  salen = sizeof (struct sockaddr_in6);
	  sin6 = (struct sockaddr_in6 *) sa;
	  port = sin6->sin6_port;
	  break;
	default:
	  set_errno (EPFNOSUPPORT);
	  __leave;
	}

      /* If a non-zero port number is given, try this first.  If that succeeds,
	 or if the error message is serious, return. */
      if (port)
	{
	  ret = fh->bind (sa, salen);
	  if (!ret || (get_errno () != EADDRINUSE && get_errno () != EINVAL))
	    __leave;
	}

      LONG myport;

      for (int i = 0; i < NUM_PORTS; i++)
	{
	  while ((myport = InterlockedExchange (
			    &cygwin_shared->last_used_bindresvport, -1)) == -1)
	    yield ();
	  if (myport == 0 || --myport < PORT_LOW)
	    myport = PORT_HIGH;
	  InterlockedExchange (&cygwin_shared->last_used_bindresvport, myport);

	  if (sa->sa_family == AF_INET6)
	    sin6->sin6_port = htons (myport);
	  else
	    sin->sin_port = htons (myport);
	  if (!(ret = fh->bind (sa, salen)))
	    break;
	  if (get_errno () != EADDRINUSE && get_errno () != EINVAL)
	    break;
	}

    }
  __except (EFAULT) {}
  __endtry
  return ret;
}


extern "C" int
cygwin_bindresvport (int fd, struct sockaddr_in *sin)
{
  return cygwin_bindresvport_sa (fd, (struct sockaddr *) sin);
}

/* socketpair: standards? */
/* Win32 supports AF_INET only, so ignore domain and protocol arguments */
extern "C" int
socketpair (int family, int type, int protocol, int *sb)
{
  int res = -1;
  SOCKET insock = INVALID_SOCKET;
  SOCKET outsock = INVALID_SOCKET;
  SOCKET newsock = INVALID_SOCKET;
  struct sockaddr_in sock_in, sock_out;
  int len;

  __try
    {
      int flags = type & _SOCK_FLAG_MASK;
      type &= ~_SOCK_FLAG_MASK;

      if (family != AF_LOCAL && family != AF_INET)
	{
	  set_errno (EAFNOSUPPORT);
	  __leave;
	}
      if (type != SOCK_STREAM && type != SOCK_DGRAM)
	{
	  set_errno (EPROTOTYPE);
	  __leave;
	}
      if ((flags & ~(SOCK_NONBLOCK | SOCK_CLOEXEC)) != 0)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      if ((family == AF_LOCAL && protocol != PF_UNSPEC && protocol != PF_LOCAL)
	  || (family == AF_INET && protocol != PF_UNSPEC && protocol != PF_INET))
	{
	  set_errno (EPROTONOSUPPORT);
	  __leave;
	}

      /* create the first socket */
      newsock = socket (AF_INET, type, 0);
      if (newsock == INVALID_SOCKET)
	{
	  debug_printf ("first socket call failed");
	  set_winsock_errno ();
	  __leave;
	}

      /* bind the socket to any unused port */
      sock_in.sin_family = AF_INET;
      sock_in.sin_port = 0;
      sock_in.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (bind (newsock, (struct sockaddr *) &sock_in, sizeof (sock_in)) < 0)
	{
	  debug_printf ("bind failed");
	  set_winsock_errno ();
	  __leave;
	}
      len = sizeof (sock_in);
      if (getsockname (newsock, (struct sockaddr *) &sock_in, &len) < 0)
	{
	  debug_printf ("getsockname error");
	  set_winsock_errno ();
	  __leave;
	}

      /* For stream sockets, create a listener */
      if (type == SOCK_STREAM)
	listen (newsock, 2);

      /* create a connecting socket */
      outsock = socket (AF_INET, type, 0);
      if (outsock == INVALID_SOCKET)
	{
	  debug_printf ("second socket call failed");
	  set_winsock_errno ();
	  __leave;
	}

      /* For datagram sockets, bind the 2nd socket to an unused address, too */
      if (type == SOCK_DGRAM)
	{
	  sock_out.sin_family = AF_INET;
	  sock_out.sin_port = 0;
	  sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  if (bind (outsock, (struct sockaddr *) &sock_out, sizeof (sock_out)) < 0)
	    {
	      debug_printf ("bind failed");
	      set_winsock_errno ();
	      __leave;
	    }
	  len = sizeof (sock_out);
	  if (getsockname (outsock, (struct sockaddr *) &sock_out, &len) < 0)
	    {
	      debug_printf ("getsockname error");
	      set_winsock_errno ();
	      __leave;
	    }
	}

      /* Force IP address to loopback */
      sock_in.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (type == SOCK_DGRAM)
	sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);

      /* Do a connect */
      if (connect (outsock, (struct sockaddr *) &sock_in, sizeof (sock_in)) < 0)
	{
	  debug_printf ("connect error");
	  set_winsock_errno ();
	  __leave;
	}

      if (type == SOCK_STREAM)
	{
	  /* For stream sockets, accept the connection and close the listener */
	  len = sizeof (sock_in);
	  insock = accept (newsock, (struct sockaddr *) &sock_in, &len);
	  if (insock == INVALID_SOCKET)
	    {
	      debug_printf ("accept error");
	      set_winsock_errno ();
	      __leave;
	    }
	  closesocket (newsock);
	  newsock = INVALID_SOCKET;
	}
      else
	{
	  /* For datagram sockets, connect the 2nd socket */
	  if (connect (newsock, (struct sockaddr *) &sock_out,
		       sizeof (sock_out)) < 0)
	    {
	      debug_printf ("connect error");
	      set_winsock_errno ();
	      __leave;
	    }
	  insock = newsock;
	  newsock = INVALID_SOCKET;
	}

      cygheap_fdnew sb0;
      const device *dev;

      if (family == AF_INET)
	dev = (type == SOCK_STREAM ? tcp_dev : udp_dev);
      else
	dev = (type == SOCK_STREAM ? stream_dev : dgram_dev);

      if (sb0 >= 0 && fdsock (sb0, dev, insock))
	{
	  ((fhandler_socket *) sb0)->set_addr_family (family);
	  ((fhandler_socket *) sb0)->set_socket_type (type);
	  ((fhandler_socket *) sb0)->connect_state (connected);
	  if (flags & SOCK_NONBLOCK)
	    ((fhandler_socket *) sb0)->set_nonblocking (true);
	  if (flags & SOCK_CLOEXEC)
	    ((fhandler_socket *) sb0)->set_close_on_exec (true);
	  if (family == AF_LOCAL && type == SOCK_STREAM)
	    ((fhandler_socket *) sb0)->af_local_set_sockpair_cred ();

	  cygheap_fdnew sb1 (sb0, false);

	  if (sb1 >= 0 && fdsock (sb1, dev, outsock))
	    {
	      ((fhandler_socket *) sb1)->set_addr_family (family);
	      ((fhandler_socket *) sb1)->set_socket_type (type);
	      ((fhandler_socket *) sb1)->connect_state (connected);
	      if (flags & SOCK_NONBLOCK)
		((fhandler_socket *) sb1)->set_nonblocking (true);
	      if (flags & SOCK_CLOEXEC)
		((fhandler_socket *) sb1)->set_close_on_exec (true);
	      if (family == AF_LOCAL && type == SOCK_STREAM)
		((fhandler_socket *) sb1)->af_local_set_sockpair_cred ();

	      sb[0] = sb0;
	      sb[1] = sb1;
	      res = 0;
	    }
	  else
	    sb0.release ();
	}
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = socketpair(...)", res);
  if (res == -1)
    {
      if (insock != INVALID_SOCKET)
	closesocket (insock);
      if (outsock != INVALID_SOCKET)
	closesocket (outsock);
      if (newsock != INVALID_SOCKET)
	closesocket (newsock);
    }
  return res;
}

/* sethostent: standards? */
extern "C" void
sethostent (int)
{
}

/* endhostent: standards? */
extern "C" void
endhostent (void)
{
}

/* exported as recvmsg: standards? */
extern "C" ssize_t
cygwin_recvmsg (int fd, struct msghdr *msg, int flags)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	{
	  res = check_iovec_for_read (msg->msg_iov, msg->msg_iovlen);
	  /* Originally we shortcircuited here if res == 0.
	     Allow 0 bytes buffer.  This is valid in POSIX and handled in
	     fhandler_socket::recv_internal.  If we shortcircuit, we fail
	     to deliver valid error conditions and peer address. */
	  if (res >= 0)
	    res = fh->recvmsg (msg, flags);
	}
    }
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
  syscall_printf ("%lR = recvmsg(%d, %p, %y)", res, fd, msg, flags);
  return res;
}

/* exported as sendmsg: standards? */
extern "C" ssize_t
cygwin_sendmsg (int fd, const struct msghdr *msg, int flags)
{
  ssize_t res = -1;

  pthread_testcancel ();

  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	{
	  res = check_iovec_for_write (msg->msg_iov, msg->msg_iovlen);
	  if (res >= 0)
	    res = fh->sendmsg (msg, flags);
	}
    }
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
  syscall_printf ("%lR = sendmsg(%d, %p, %y)", res, fd, msg, flags);
  return res;
}

/* This is from the BIND 4.9.4 release, modified to compile by itself */

/* Copyright (c) 1996 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* int
 * inet_pton4(src, dst)
 *	like inet_aton() but without all the hexadecimal and shorthand.
 * return:
 *	1 if `src' is a valid dotted quad, else 0.
 * notice:
 *	does not touch `dst' unless it's returning 1.
 * author:
 *	Paul Vixie, 1996.
 */
static int
inet_pton4 (const char *src, u_char *dst)
{
  static const char digits[] = "0123456789";
  int saw_digit, octets, ch;
  u_char tmp[INADDRSZ], *tp;

  saw_digit = 0;
  octets = 0;
  *(tp = tmp) = 0;
  while ((ch = *src++) != '\0')
    {
      const char *pch;

      if ((pch = strchr(digits, ch)) != NULL)
	{
	  u_int ret = *tp * 10 + (pch - digits);

	  if (ret > 255)
	    return (0);
	  *tp = ret;
	  if (! saw_digit)
	    {
	      if (++octets > 4)
		return (0);
	      saw_digit = 1;
	    }
	}
      else if (ch == '.' && saw_digit)
	{
	  if (octets == 4)
	    return (0);
	  *++tp = 0;
	  saw_digit = 0;
	}
      else
	return (0);
    }
  if (octets < 4)
    return (0);

  memcpy(dst, tmp, INADDRSZ);
  return (1);
}

/* int
 * inet_pton6(src, dst)
 *	convert presentation level address to network order binary form.
 * return:
 *	1 if `src' is a valid [RFC1884 2.2] address, else 0.
 * notice:
 *	(1) does not touch `dst' unless it's returning 1.
 *	(2) :: in a full address is silently ignored.
 * credit:
 *	inspired by Mark Andrews.
 * author:
 *	Paul Vixie, 1996.
 */
static int
inet_pton6 (const char *src, u_char *dst)
{
  static const char xdigits_l[] = "0123456789abcdef",
		    xdigits_u[] = "0123456789ABCDEF";
  u_char tmp[IN6ADDRSZ], *tp, *endp, *colonp;
  const char *xdigits, *curtok;
  int ch, saw_xdigit;
  u_int val;

  memset((tp = tmp), 0, IN6ADDRSZ);
  endp = tp + IN6ADDRSZ;
  colonp = NULL;
  /* Leading :: requires some special handling. */
  if (*src == ':')
    if (*++src != ':')
      return (0);
  curtok = src;
  saw_xdigit = 0;
  val = 0;
  while ((ch = *src++) != '\0')
    {
      const char *pch;

      if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)
	pch = strchr((xdigits = xdigits_u), ch);
      if (pch != NULL)
	{
	  val <<= 4;
	  val |= (pch - xdigits);
	  if (val > 0xffff)
	    return (0);
	  saw_xdigit = 1;
	  continue;
	}
      if (ch == ':')
	{
	  curtok = src;
	  if (!saw_xdigit)
	    {
	      if (colonp)
		return (0);
	      colonp = tp;
	      continue;
	    }
	  if (tp + INT16SZ > endp)
	    return (0);
	  *tp++ = (u_char) (val >> 8) & 0xff;
	  *tp++ = (u_char) val & 0xff;
	  saw_xdigit = 0;
	  val = 0;
	  continue;
	}
      if (ch == '.' && ((tp + INADDRSZ) <= endp) && inet_pton4(curtok, tp) > 0)
	{
	  tp += INADDRSZ;
	  saw_xdigit = 0;
	  break;	/* '\0' was seen by inet_pton4(). */
	}
      return (0);
    }
  if (saw_xdigit)
    {
      if (tp + INT16SZ > endp)
	return (0);
      *tp++ = (u_char) (val >> 8) & 0xff;
      *tp++ = (u_char) val & 0xff;
    }
  if (colonp != NULL)
    {
      /*
       * Since some memmove()'s erroneously fail to handle
       * overlapping regions, we'll do the shift by hand.
       */
      const int n = tp - colonp;
      int i;

      for (i = 1; i <= n; i++)
	{
	  endp[- i] = colonp[n - i];
	  colonp[n - i] = 0;
	}
      tp = endp;
    }
  if (tp != endp)
    return (0);

  memcpy(dst, tmp, IN6ADDRSZ);
  return (1);
}

/* int
 * inet_pton(af, src, dst)
 *	convert from presentation format (which usually means ASCII printable)
 *	to network format (which is usually some kind of binary format).
 * return:
 *	1 if the address was valid for the specified address family
 *	0 if the address wasn't valid (`dst' is untouched in this case)
 *	-1 if some other error occurred (`dst' is untouched in this case, too)
 * author:
 *	Paul Vixie, 1996.
 */
extern "C" int
cygwin_inet_pton (int af, const char *src, void *dst)
{
  switch (af)
    {
    case AF_INET:
      return (inet_pton4(src, (u_char *) dst));
    case AF_INET6:
      return (inet_pton6(src, (u_char *) dst));
    default:
      errno = EAFNOSUPPORT;
      return (-1);
    }
  /* NOTREACHED */
}

/* const char *
 * inet_ntop4(src, dst, size)
 *	format an IPv4 address, more or less like inet_ntoa()
 * return:
 *	`dst' (as a const)
 * notes:
 *	(1) uses no statics
 *	(2) takes a u_char* not an in_addr as input
 * author:
 *	Paul Vixie, 1996.
 */
static const char *
inet_ntop4 (const u_char *src, char *dst, size_t size)
{
  static const char fmt[] = "%u.%u.%u.%u";
  char tmp[sizeof "255.255.255.255"];

  __small_sprintf(tmp, fmt, src[0], src[1], src[2], src[3]);
  if (strlen(tmp) > size)
    {
      errno = ENOSPC;
      return (NULL);
    }
  strcpy(dst, tmp);
  return (dst);
}

/* const char *
 * inet_ntop6(src, dst, size)
 *	convert IPv6 binary address into presentation (printable) format
 * author:
 *	Paul Vixie, 1996.
 */
static const char *
inet_ntop6 (const u_char *src, char *dst, size_t size)
{
  /*
   * Note that int32_t and int16_t need only be "at least" large enough
   * to contain a value of the specified size.  On some systems, like
   * Crays, there is no such thing as an integer variable with 16 bits.
   * Keep this in mind if you think this function should have been coded
   * to use pointer overlays.  All the world's not a VAX.
   */
  char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
  struct { int base, len; } best, cur;
  u_int words[IN6ADDRSZ / INT16SZ];
  int i;

  /*
   * Preprocess:
   *	Copy the input (bytewise) array into a wordwise array.
   *	Find the longest run of 0x00's in src[] for :: shorthanding.
   */
  memset(words, 0, sizeof words);
  for (i = 0; i < IN6ADDRSZ; i++)
    words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
  best.base = -1;
  cur.base = -1;
  best.len = 0;
  cur.len = 0;
  for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++)
    {
      if (words[i] == 0)
	{
	  if (cur.base == -1)
	    cur.base = i, cur.len = 1;
	  else
	    cur.len++;
	}
      else
	{
	  if (cur.base != -1)
	    {
	      if (best.base == -1 || cur.len > best.len)
		best = cur;
	      cur.base = -1;
	    }
	}
    }
  if (cur.base != -1)
    {
      if (best.base == -1 || cur.len > best.len)
	best = cur;
    }
  if (best.base != -1 && best.len < 2)
    best.base = -1;

  /*
   * Format the result.
   */
  tp = tmp;
  for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++)
    {
      /* Are we inside the best run of 0x00's? */
      if (best.base != -1 && i >= best.base && i < (best.base + best.len))
	{
	  if (i == best.base)
	    *tp++ = ':';
	  continue;
	}
      /* Are we following an initial run of 0x00s or any real hex? */
      if (i != 0)
	*tp++ = ':';
      /* Is this address an encapsulated IPv4? */
      if (i == 6 && best.base == 0 &&
	  (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))
	{
	  if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
	    return (NULL);
	  tp += strlen(tp);
	  break;
	}
      __small_sprintf(tp, "%x", words[i]);
      while (*tp)
	{
	  if (isupper (*tp))
	    *tp = _tolower (*tp);
	  ++tp;
	}
    }
  /* Was it a trailing run of 0x00's? */
  if (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ))
    *tp++ = ':';
  *tp++ = '\0';

  /*
   * Check for overflow, copy, and we're done.
   */
  if ((size_t) (tp - tmp) > size)
    {
      errno = ENOSPC;
      return (NULL);
    }
  strcpy(dst, tmp);
  return (dst);
}

/* char *
 * inet_ntop(af, src, dst, size)
 *	convert a network format address to presentation format.
 * return:
 *	pointer to presentation format address (`dst'), or NULL (see errno).
 * author:
 *	Paul Vixie, 1996.
 */
extern "C" const char *
cygwin_inet_ntop (int af, const void *src, char *dst, socklen_t size)
{
  switch (af)
    {
    case AF_INET:
      return (inet_ntop4((const u_char *) src, dst, size));
    case AF_INET6:
      return (inet_ntop6((const u_char *) src, dst, size));
    default:
      errno = EAFNOSUPPORT;
      return (NULL);
    }
  /* NOTREACHED */
}

extern "C" void
cygwin_freeaddrinfo (struct addrinfo *addr)
{
  struct addrinfo *ai, *ainext;

  for (ai = addr; ai != NULL; ai = ainext)
    {
      if (ai->ai_addr != NULL)
	free (ai->ai_addr);	/* socket address structure */

      if (ai->ai_canonname != NULL)
	free (ai->ai_canonname);

      ainext = ai->ai_next;	/* can't fetch ai_next after free() */
      free (ai);		/* the addrinfo{} itself */
    }
}

static struct addrinfo *
ga_dup (struct addrinfoW *ai, bool v4mapped, int idn_flags, int &err)
{
  struct addrinfo *nai;

  if ((nai = (struct addrinfo *) calloc (1, sizeof (struct addrinfo))) == NULL)
    {
      err = EAI_MEMORY;
      return NULL;
    }

  nai->ai_family = v4mapped ? AF_INET6 : ai->ai_family;
  nai->ai_socktype = ai->ai_socktype;
  nai->ai_protocol = ai->ai_protocol;
  if (ai->ai_canonname)
    {
      tmp_pathbuf tp;
      wchar_t *canonname = ai->ai_canonname;

      if (idn_flags & AI_CANONIDN)
	{
	  /* Map flags to equivalent IDN_* flags. */
	  wchar_t *canonbuf = tp.w_get ();
	  if (IdnToUnicode (idn_flags >> 16, canonname, -1,
			    canonbuf, NT_MAX_PATH))
	    canonname = canonbuf;
	  else if (GetLastError () != ERROR_PROC_NOT_FOUND)
	    {
	      free (nai);
	      err = EAI_IDN_ENCODE;
	      return NULL;
	    }
	}
      size_t len = wcstombs (NULL, canonname, 0);
      if (len == (size_t) -1)
	{
	  free (nai);
	  err = EAI_IDN_ENCODE;
	  return NULL;
	}
      nai->ai_canonname = (char *) malloc (len + 1);
      if (!nai->ai_canonname)
	{
	  free (nai);
	  err = EAI_MEMORY;
	  return NULL;
	}
      wcstombs (nai->ai_canonname, canonname, len + 1);
    }
  
  nai->ai_addrlen = v4mapped ? sizeof (struct sockaddr_in6) : ai->ai_addrlen;
  if ((nai->ai_addr = (struct sockaddr *) malloc (v4mapped
						  ? sizeof (struct sockaddr_in6)
						  : ai->ai_addrlen)) == NULL)
    {
      if (nai->ai_canonname)
	free (nai->ai_canonname);
      free (nai);
      err = EAI_MEMORY;
      return NULL;
    }
  if (v4mapped)
    {
      struct sockaddr_in6 *in = (struct sockaddr_in6 *) nai->ai_addr;
      in->sin6_family = AF_INET6;
      in->sin6_port = ((struct sockaddr_in *) ai->ai_addr)->sin_port;
      in->sin6_flowinfo = 0;
      in->sin6_addr.s6_addr32[0] = 0;
      in->sin6_addr.s6_addr32[1] = 0;
      in->sin6_addr.s6_addr32[2] = htonl (0xffff);
      in->sin6_addr.s6_addr32[3] = ((struct sockaddr_in *) ai->ai_addr)->sin_addr.s_addr;
      in->sin6_scope_id = 0;
    }
  else
    memcpy (nai->ai_addr, ai->ai_addr, ai->ai_addrlen);

  return nai;
}

static struct addrinfo *
ga_duplist (struct addrinfoW *ai, bool v4mapped, int idn_flags, int &err)
{
  struct addrinfo *tmp, *nai = NULL, *nai0 = NULL;

  for (; ai; ai = ai->ai_next, nai = tmp)
    {
      if (!(tmp = ga_dup (ai, v4mapped, idn_flags, err)))
	goto bad;
      if (!nai0)
	nai0 = tmp;
      if (nai)
	nai->ai_next = tmp;
    }
  return nai0;

bad:
  cygwin_freeaddrinfo (nai0);
  return NULL;
}

/* Cygwin specific wrappers around the gai functions. */
static struct gai_errmap_t
{
  int w32_errval;
  const char *errtxt;
} gai_errmap[] =
{
  {0,			  "Success"},
  /* EAI_ADDRFAMILY */
  {0,			  "Address family for hostname not supported"},
  /* EAI_AGAIN */
  {WSATRY_AGAIN,	  "Temporary failure in name resolution"},
  /* EAI_BADFLAGS */
  {WSAEINVAL,		  "Bad value for ai_flags"},
  /* EAI_FAIL */
  {WSANO_RECOVERY,	  "Non-recoverable failure in name resolution"},
  /* EAI_FAMILY */
  {WSAEAFNOSUPPORT,	  "ai_family not supported"},
  /* EAI_MEMORY */
  {WSA_NOT_ENOUGH_MEMORY, "Memory allocation failure"},
  /* EAI_NODATA */
  {WSANO_DATA,		  "No address associated with hostname"},
  /* EAI_NONAME */
  {WSAHOST_NOT_FOUND,	  "Name or service not known"},
  /* EAI_SERVICE */
  {WSATYPE_NOT_FOUND,	  "Servname not supported for ai_socktype"},
  /* EAI_SOCKTYPE */
  {WSAESOCKTNOSUPPORT,	  "ai_socktype not supported"},
  /* EAI_SYSTEM */
  {0,			  "System error"},
  /* EAI_BADHINTS */
  {0,                     "Invalid value for hints"},
  /* EAI_PROTOCOL */
  {0,			  "Resolved protocol is unknown"},
  /* EAI_OVERFLOW */
  {WSAEFAULT,		  "An argument buffer overflowed"},
  /* EAI_IDN_ENCODE */
  {0,			  "Parameter string not correctly encoded"}
};

extern "C" const char *
cygwin_gai_strerror (int err)
{
  if (err >= 0 && err < (int) (sizeof gai_errmap / sizeof *gai_errmap))
    return gai_errmap[err].errtxt;
  return "Unknown error";
}

static int
w32_to_gai_err (int w32_err)
{
  if (w32_err >= WSABASEERR)
    for (unsigned i = 0; i < sizeof gai_errmap / sizeof *gai_errmap; ++i)
      if (gai_errmap[i].w32_errval == w32_err)
	return i;
  return w32_err;
}

extern "C" int
cygwin_getaddrinfo (const char *hostname, const char *servname,
		    const struct addrinfo *hints, struct addrinfo **res)
{
  int ret = 0;

  /* Windows' getaddrinfo implementations lets all possible values
     in ai_flags slip through and just ignores unknown values.  So we 
     check manually here. */
#define AI_IDN_MASK (AI_IDN | \
		     AI_CANONIDN | \
		     AI_IDN_ALLOW_UNASSIGNED | \
		     AI_IDN_USE_STD3_ASCII_RULES)
#ifndef AI_DISABLE_IDN_ENCODING
#define AI_DISABLE_IDN_ENCODING 0x80000
#endif
  __try
    {
      if (hints && (hints->ai_flags
		    & ~(AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_ALL
			| AI_NUMERICSERV | AI_ADDRCONFIG | AI_V4MAPPED
			| AI_IDN_MASK)))
	return EAI_BADFLAGS;
      /* AI_NUMERICSERV is not supported prior to Windows Vista.  We just check
	 the servname parameter by ourselves here. */
      if (hints && (hints->ai_flags & AI_NUMERICSERV))
	{
	  char *p;
	  if (servname && *servname && (strtoul (servname, &p, 10), *p))
	    return EAI_NONAME;
	}

      int idn_flags = hints ? (hints->ai_flags & AI_IDN_MASK) : 0;
      const char *src;
      mbstate_t ps;
      tmp_pathbuf tp;
      wchar_t *whost = NULL, *wserv = NULL;
      struct addrinfoW whints, *wres;

      if (hostname)
	{
	  memset (&ps, 0, sizeof ps);
	  src = hostname;
	  whost = tp.w_get ();
	  if (mbsrtowcs (whost, &src, NT_MAX_PATH, &ps) == (size_t) -1)
	    return EAI_IDN_ENCODE;
	  if (src)
	    return EAI_MEMORY;
	  if (idn_flags & AI_IDN)
	    {
	      /* Map flags to equivalent IDN_* flags. */
	      wchar_t *ascbuf = tp.w_get ();
	      if (IdnToAscii (idn_flags >> 16, whost, -1, ascbuf, NT_MAX_PATH))
		whost = ascbuf;
	      else if (GetLastError () != ERROR_PROC_NOT_FOUND)
		return EAI_IDN_ENCODE;
	    }
	}
      if (servname)
	{
	  memset (&ps, 0, sizeof ps);
	  src = servname;
	  wserv = tp.w_get ();
	  if (mbsrtowcs (wserv, &src, NT_MAX_PATH, &ps) == (size_t) -1)
	    return EAI_IDN_ENCODE;
	  if (src)
	    return EAI_MEMORY;
	}

      if (!hints)
	{
	  /* Default settings per glibc man page. */
	  memset (&whints, 0, sizeof whints);
	  whints.ai_family = PF_UNSPEC;
	  whints.ai_flags = AI_V4MAPPED | AI_ADDRCONFIG;
	}
      else
	{
	  /* sizeof addrinfo == sizeof addrinfoW */
	  memcpy (&whints, hints, sizeof whints);
	  whints.ai_flags &= ~AI_IDN_MASK;
#ifdef __x86_64__
	  /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
	     Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
	  whints.ai_addrlen &= UINT32_MAX;
#endif
	  /* AI_ADDRCONFIG is not supported prior to Vista.  Rather it's
	     the default and only possible setting.
	     On Vista, the default behaviour is as if AI_ADDRCONFIG is set,
	     apparently for performance reasons.  To get the POSIX default
	     behaviour, the AI_ALL flag has to be set. */
	  if (wincap.supports_all_posix_ai_flags ()
	      && whints.ai_family == PF_UNSPEC
	      && !(whints.ai_flags & AI_ADDRCONFIG))
	    whints.ai_flags |= AI_ALL;
	}
      /* Disable automatic IDN conversion on W8 and later. */
      whints.ai_flags |= AI_DISABLE_IDN_ENCODING;
      ret = w32_to_gai_err (GetAddrInfoW (whost, wserv, &whints, &wres));
      /* Always copy over to self-allocated memory. */
      if (!ret)
	{
	  *res = ga_duplist (wres, false, idn_flags, ret);
	  FreeAddrInfoW (wres);
	  if (!*res)
	    __leave;
	}
      /* AI_V4MAPPED and AI_ALL are not supported prior to Vista.  So, what
	 we do here is to emulate AI_V4MAPPED.  If no IPv6 addresses are
	 returned, or the AI_ALL flag is set, we try with AF_INET again, and
	 convert the returned IPv4 addresses into v4-in-v6 entries.  This
	 is done in ga_dup if the v4mapped flag is set. */
      if (!wincap.supports_all_posix_ai_flags ()
	  && hints
	  && hints->ai_family == AF_INET6
	  && (hints->ai_flags & AI_V4MAPPED)
	  && (ret == EAI_NODATA || ret == EAI_NONAME
	      || (hints->ai_flags & AI_ALL)))
	{
	  /* sizeof addrinfo == sizeof addrinfoW */
	  memcpy (&whints, hints, sizeof whints);
	  whints.ai_family = AF_INET;
#ifdef __x86_64__
	  /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
	     Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
	  whints.ai_addrlen &= UINT32_MAX;
#endif
	  int ret2 = w32_to_gai_err (GetAddrInfoW (whost, wserv, &whints, &wres));
	  if (!ret2)
	    {
	      struct addrinfo *v4res = ga_duplist (wres, true, idn_flags, ret);
	      FreeAddrInfoW (wres);
	      if (!v4res)
		{
		  if (!ret)
		    cygwin_freeaddrinfo (*res);
		  __leave;
		}
	      /* If a list of v6 addresses exists, append the v4-in-v6 address
		 list.  Otherwise just return the v4-in-v6 address list. */
	      if (!ret)
		{
		  struct addrinfo *ptr;
		  for (ptr = *res; ptr->ai_next; ptr = ptr->ai_next)
		    ;
		  ptr->ai_next = v4res;
		}
	      else
		*res = v4res;
	      ret = 0;
	    }
	}
    }
  __except (EFAULT)
    {
      ret = EAI_SYSTEM;
    }
  __endtry
  return ret;
}

extern "C" int
cygwin_getnameinfo (const struct sockaddr *sa, socklen_t salen,
		    char *host, size_t hostlen, char *serv,
		    size_t servlen, int flags)
{
  int ret = 0;

  __try
    {
      /* When the incoming port number does not resolve to a well-known service,
	 WinSock's getnameinfo up to Windows 2003 returns with error WSANO_DATA
	 instead of setting `serv' to the numeric port number string, as
	 required by RFC 3493.  This is fixed on Vista and later.  To avoid the
	 error on systems up to Windows 2003, we check if the port number
	 resolves to a well-known service.  If not, we set the NI_NUMERICSERV
	 flag. */
      if (!wincap.supports_all_posix_ai_flags ())
	{
	  int port = 0;

	  switch (sa->sa_family)
	    {
	    case AF_INET:
	      port = ((struct sockaddr_in *) sa)->sin_port;
	      break;
	    case AF_INET6:
	      port = ((struct sockaddr_in6 *) sa)->sin6_port;
	      break;
	    default:
	      return EAI_FAMILY;
	    }
	  if (!port || !getservbyport (port, flags & NI_DGRAM ? "udp" : "tcp"))
	    flags |= NI_NUMERICSERV;
	}
      /* We call GetNameInfoW with local buffers and convert to locale
	 charset to allow RFC 3490 IDNs like glibc 2.3.4 and later. */
#define NI_IDN_MASK (NI_IDN | \
		     NI_IDN_ALLOW_UNASSIGNED | \
		     NI_IDN_USE_STD3_ASCII_RULES)
      int idn_flags = flags & NI_IDN_MASK;
      flags &= ~NI_IDN_MASK;
      tmp_pathbuf tp;
      wchar_t *whost = NULL, *wserv = NULL;
      DWORD whlen = 0, wslen = 0;

      if (host && hostlen)
	{
	  whost = tp.w_get ();
	  whlen = NT_MAX_PATH;
	}
      if (serv && servlen)
	{
	  wserv = tp.w_get ();
	  wslen = NT_MAX_PATH;
	}

      ret = w32_to_gai_err (GetNameInfoW (sa, salen, whost, whlen,
					  wserv, wslen, flags));
      if (!ret)
	{
	  const wchar_t *src;

	  if (whost)
	    {
	      if (idn_flags & NI_IDN)
		{
		  /* Map flags to equivalent IDN_* flags. */
		  wchar_t *idnbuf = tp.w_get ();
		  if (IdnToUnicode (idn_flags >> 16, whost, -1,
				    idnbuf, NT_MAX_PATH))
		    whost = idnbuf;
		  else if (GetLastError () != ERROR_PROC_NOT_FOUND)
		    return EAI_IDN_ENCODE;
		}
	      src = whost;
	      if (wcsrtombs (host, &src, hostlen, NULL) == (size_t) -1)
		return EAI_IDN_ENCODE;
	      if (src)
		return EAI_OVERFLOW;
	    }
	  if (wserv)
	    {
	      src = wserv;
	      if (wcsrtombs (serv, &src, servlen, NULL) == (size_t) -1)
		return EAI_IDN_ENCODE;
	      if (src)
		return EAI_OVERFLOW;
	    }
	}
      else if (ret == EAI_SYSTEM)
	set_winsock_errno ();
    }
  __except (EFAULT)
    {
      ret = EAI_SYSTEM;
    }
  __endtry
  return ret;
}

/* The below function in6_are_prefix_equal has been taken from OpenBSD's
   src/sys/netinet6/in6.c. */

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)in.c        8.2 (Berkeley) 11/15/93
 */

static int
in6_are_prefix_equal (struct in6_addr *p1, struct in6_addr *p2, int len)
{
  int bytelen, bitlen;

  /* sanity check */
  if (0 > len || len > 128)
    return 0;

  bytelen = len / 8;
  bitlen = len % 8;

  if (memcmp (&p1->s6_addr, &p2->s6_addr, bytelen))
    return 0;
  /* len == 128 is ok because bitlen == 0 then */
  if (bitlen != 0 &&
      p1->s6_addr[bytelen] >> (8 - bitlen) !=
      p2->s6_addr[bytelen] >> (8 - bitlen))
    return 0;

  return 1;
}

/* These functions are stick to the end of this file so that the
   optimization in asm/byteorder.h can be used even here in net.cc. */

#undef htonl
#undef ntohl
#undef htons
#undef ntohs

/* htonl: standards? */
extern "C" uint32_t
htonl (uint32_t x)
{
  return __htonl (x);
}

/* ntohl: standards? */
extern "C" uint32_t
ntohl (uint32_t x)
{
  return __ntohl (x);
}

/* htons: standards? */
extern "C" uint16_t
htons (uint16_t x)
{
  return __htons (x);
}

/* ntohs: standards? */
extern "C" uint16_t
ntohs (uint16_t x)
{
  return __ntohs (x);
}
@


1.322
log
@	* common.din (sockatmark): Export.
	* net.cc (sockatmark): New function.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d75 1
d1172 98
a1312 1

d1448 2
a1449 1
	      dn_expand (msg, eomsg, curptr->name (), string_ptr, curptr->namelen1);
d1455 4
a1458 1
	    memcpy4to6 (string_ptr, curptr->data);
d1472 1
a1472 1
 corrupted:
d1489 2
a1490 1
	  res_init();
d1492 1
a1493 1
      int type, addrsize_in, addrsize_out;
d1511 4
a1514 1
      res = gethostby_helper (name, af, type, addrsize_in, addrsize_out);
@


1.321
log
@	* net.cc (fdsock): Change default values for socket buffers on 32 bit
	to fix performance on 10Gb networks.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d990 13
@


1.320
log
@	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.
@
text
@d624 7
d636 2
a637 2
  ((fhandler_socket *) fd)->rmem () = 65535;
  ((fhandler_socket *) fd)->wmem () = 65535;
@


1.319
log
@	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d823 1
a823 3
	  if (optval || optlen
	      || fh->get_addr_family () != AF_LOCAL
	      || fh->get_socket_type () != SOCK_STREAM)
@


1.318
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d813 19
@


1.317
log
@	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.
@
text
@d503 7
a509 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
  return dup_ent (getprotobyname (p));
d737 1
a737 1
  ssize_t res;
d741 8
a748 8
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    res = fh->sendto (buf, len, flags, to, tolen);

d759 1
a759 1
  ssize_t res;
d763 12
a774 12
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    /* Originally we shortcircuited here if res == 0.
       Allow 0 bytes buffer.  This is valid in POSIX and handled in
       fhandler_socket::recv_internal.  If we shortcircuit, we fail
       to deliver valid error conditions and peer address. */
    res = fh->recvfrom (buf, len, flags, from, fromlen);

d806 1
a806 2
  int res;
  fhandler_socket *fh = get (fd);
d808 1
a808 4
  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
d810 3
d897 5
a901 1

d912 1
a912 2
  int res;
  fhandler_socket *fh = get (fd);
d914 1
a914 9
  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else if (optname == SO_PEERCRED && level == SOL_SOCKET)
    {
      struct ucred *cred = (struct ucred *) optval;
      res = fh->getpeereid (&cred->pid, &cred->uid, &cred->gid);
    }
  else
d916 9
d939 1
a939 1
      	{
d956 5
a960 1

d979 1
a979 1
  int res;
d983 8
a990 8
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    res = fh->connect (name, namelen);

a991 1

d999 1
a999 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
d1001 6
a1006 1
  servent *res = dup_ent (getservbyname (name, proto));
d1015 1
a1015 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
d1017 6
a1022 1
  servent *res = dup_ent (getservbyport (port, proto));
d1030 1
a1030 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d1032 1
a1032 1
  if (gethostname (name, len))
d1034 3
a1036 1
      DWORD local_len = len;
d1038 6
a1043 4
      if (!GetComputerNameExA (ComputerNameDnsFullyQualified, name, &local_len))
	{
	  set_winsock_errno ();
	  return -1;
d1045 2
d1048 3
a1050 2
  debug_printf ("name %s", name);
  return 0;
a1056 4
  myfault efault;
  if (efault.faulted (EFAULT))
      return NULL;

d1063 1
d1065 1
a1065 4
  if (sscanf (name, "%u.%u.%u.%u%c", &a, &b, &c, &d, &dummy) != 4
      || a >= 256 || b >= 256 || c >= 256 || d >= 256)
    h = gethostbyname (name);
  else
d1067 30
a1096 19
      /* In case you don't have DNS, at least x.x.x.x still works */
      memset (&tmp, 0, sizeof (tmp));
      tmp_addr[0] = a;
      tmp_addr[1] = b;
      tmp_addr[2] = c;
      tmp_addr[3] = d;
      tmp_addr_list[0] = (char *) tmp_addr;
      tmp.h_name = name;
      tmp.h_aliases = tmp_aliases;
      tmp.h_addrtype = 2;
      tmp.h_length = 4;
      tmp.h_addr_list = tmp_addr_list;
      h = &tmp;
    }

  hostent *res = dup_ent (h);
  if (res)
    debug_printf ("h_name %s", res->h_name);
  else
d1098 1
a1098 2
      debug_printf ("dup_ent returned NULL for name %s, h %p", name, h);
      set_host_errno ();
d1100 1
d1108 15
a1122 9
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;

  hostent *res = dup_ent (gethostbyaddr (addr, len, type));
  if (res)
    debug_printf ("h_name %s", res->h_name);
  else
    set_host_errno ();
d1345 1
a1345 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;

  if (!(_res.options & RES_INIT))
      res_init();
  bool v4to6 = _res.options & RES_USE_INET6;
d1347 1
a1347 2
  int type, addrsize_in, addrsize_out;
  switch (af)
d1349 23
a1371 13
    case AF_INET:
      addrsize_in = NS_INADDRSZ;
      addrsize_out = (v4to6) ? NS_IN6ADDRSZ : NS_INADDRSZ;
      type = ns_t_a;
      break;
    case AF_INET6:
      addrsize_in = addrsize_out = NS_IN6ADDRSZ;
      type = ns_t_aaaa;
      break;
    default:
      set_errno (EAFNOSUPPORT);
      h_errno = NETDB_INTERNAL;
      return NULL;
d1373 3
a1375 2

  return gethostby_helper (name, af, type, addrsize_in, addrsize_out);
d1382 1
a1382 1
  int res;
d1386 9
a1394 8
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    res = fh->accept4 (peer, len, fh->is_nonblocking () ? SOCK_NONBLOCK : 0);

d1402 1
a1402 1
  int res;
d1406 1
a1406 6
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else if ((flags & ~(SOCK_NONBLOCK | SOCK_CLOEXEC)) != 0)
d1408 7
a1414 2
      set_errno (EINVAL);
      res = -1;
d1416 2
a1417 3
  else
    res = fh->accept4 (peer, len, flags);

d1426 1
a1426 8
  int res;
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    res = fh->bind (my_addr, addrlen);
d1428 8
d1444 1
a1444 9
  int res;

  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    res = fh->getsockname (addr, namelen);
d1446 8
d1462 1
a1462 7
  int res;
  fhandler_socket *fh = get (fd);

  if (!fh)
    res = -1;
  else
    res = fh->listen (backlog);
d1464 8
d1480 1
a1480 1
  int res;
d1483 1
a1483 4

  if (!fh)
    res = -1;
  else
a1484 1

d1506 4
a1509 5
  myfault efault;
  if (efault.faulted ())
    return;
  if (cygheap->fdtab.not_open (2))
    return;
d1511 5
a1515 5
  if (s)
    {
      write (2, s, strlen (s));
      write (2, ": ", 2);
    }
d1517 1
a1517 1
  const char *h_errstr = cygwin_hstrerror (h_errno);
d1519 18
a1536 15
  if (!h_errstr)
    switch (h_errno)
      {
	case NETDB_INTERNAL:
	  h_errstr = "Resolver internal error";
	  break;
	case NETDB_SUCCESS:
	  h_errstr = "Resolver error 0 (no error)";
	  break;
	default:
	  h_errstr = "Unknown resolver error";
	  break;
      }
  write (2, h_errstr, strlen (h_errstr));
  write (2, "\n", 1);
d1543 2
a1544 9
  int res;

  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    res = fh->getpeername (name, len);
d1546 8
d1563 1
a1563 1
  ssize_t res;
d1567 12
a1578 12
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    /* Originally we shortcircuited here if res == 0.
       Allow 0 bytes buffer.  This is valid in POSIX and handled in
       fhandler_socket::recv_internal.  If we shortcircuit, we fail
       to deliver valid error conditions. */
    res = fh->recvfrom (buf, len, flags, NULL, NULL);

d1587 1
a1587 1
  ssize_t res;
d1591 8
a1598 8
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
    res = fh->sendto (buf, len, flags, NULL, 0);

d1607 4
a1610 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d1612 8
a1619 9
  PFIXED_INFO info = NULL;
  ULONG size = 0;

  if (GetNetworkParams(info, &size) == ERROR_BUFFER_OVERFLOW
      && (info = (PFIXED_INFO) alloca(size))
      && GetNetworkParams(info, &size) == ERROR_SUCCESS)
    {
      strncpy(domain, info->DomainName, len);
      return 0;
d1621 2
a1622 1
  __seterrno ();
d2217 1
a2217 6
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  /* Ensure we have space for at least one struct ifreqs, fail if not. */
  if (ifc->ifc_len < (int) sizeof (struct ifreq))
d2219 6
a2224 3
      set_errno (EINVAL);
      return -1;
    }
d2226 4
a2229 4
  struct ifall *ifret, *ifp;
  ifret = get_ifs (AF_INET);
  if (!ifret)
    return -1;
d2231 4
a2234 8
  struct sockaddr_in *sin;
  struct ifreq *ifr = ifc->ifc_req;
  int cnt = 0;
  for (ifp = ifret; ifp; ifp = (struct ifall *) ifp->ifa_ifa.ifa_next)
    {
      ++cnt;
      strcpy (ifr->ifr_name, ifp->ifa_name);
      switch (what)
d2236 3
a2238 24
	case SIOCGIFFLAGS:
	  ifr->ifr_flags = ifp->ifa_ifa.ifa_flags;
	  break;
	case SIOCGIFCONF:
	case SIOCGIFADDR:
	  sin = (struct sockaddr_in *) &ifr->ifr_addr;
	  memcpy (sin, &ifp->ifa_addr, sizeof *sin);
	  break;
	case SIOCGIFNETMASK:
	  sin = (struct sockaddr_in *) &ifr->ifr_netmask;
	  memcpy (sin, &ifp->ifa_netmask, sizeof *sin);
	  break;
	case SIOCGIFDSTADDR:
	  sin = (struct sockaddr_in *) &ifr->ifr_dstaddr;
	  if (ifp->ifa_ifa.ifa_flags & IFF_POINTOPOINT)
	    memcpy (sin, &ifp->ifa_brddstaddr, sizeof *sin);
	  else /* Return addr as on Linux. */
	    memcpy (sin, &ifp->ifa_addr, sizeof *sin);
	  break;
	case SIOCGIFBRDADDR:
	  sin = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	  if (!(ifp->ifa_ifa.ifa_flags & IFF_POINTOPOINT))
	    memcpy (sin, &ifp->ifa_brddstaddr, sizeof *sin);
	  else
d2240 46
a2285 3
	      sin->sin_addr.s_addr = INADDR_ANY;
	      sin->sin_family = AF_INET;
	      sin->sin_port = 0;
d2287 3
a2289 16
	  break;
	case SIOCGIFHWADDR:
	  memcpy (&ifr->ifr_hwaddr, &ifp->ifa_hwaddr, sizeof ifr->ifr_hwaddr);
	  break;
	case SIOCGIFMETRIC:
	  ifr->ifr_metric = ifp->ifa_metric;
	  break;
	case SIOCGIFMTU:
	  ifr->ifr_mtu = ifp->ifa_mtu;
	  break;
	case SIOCGIFINDEX:
	  ifr->ifr_ifindex = ifp->ifa_ifindex;
	  break;
	case SIOCGIFFRNDLYNAM:
	  memcpy (ifr->ifr_frndlyname, &ifp->ifa_frndlyname,
		  sizeof (struct ifreq_frndlyname));
d2291 4
a2294 3
      if ((caddr_t) ++ifr >
	  ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
	break;
d2296 3
a2298 4
  /* Set the correct length */
  ifc->ifc_len = cnt * sizeof (struct ifreq);
  free (ifret);
  return 0;
d2307 5
a2311 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return 0;
d2313 14
a2326 1
  if (get_adapters_addresses (&pa0, AF_UNSPEC))
d2328 1
a2328 13
      char lname[IF_NAMESIZE], *c;

      lname[0] = '\0';
      strncat (lname, name, IF_NAMESIZE - 1);
      if (lname[0] == '{' && (c = strchr (lname, ':')))
	*c = '\0';
      for (pap = pa0; pap; pap = pap->Next)
	if (strcasematch (lname, pap->AdapterName))
	  {
	    index = pap->Ipv6IfIndex ?: pap->IfIndex;
	    break;
	  }
      free (pa0);
d2330 1
d2340 1
a2340 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;

  if (get_adapters_addresses (&pa0, AF_UNSPEC))
d2342 27
a2368 20
      for (pap = pa0; pap; pap = pap->Next)
	if (ifindex == (pap->Ipv6IfIndex ?: pap->IfIndex))
	  {
	    /* Unfortunately the pre-Vista IPv6 stack has a distinct loopback
	       device with the same Ipv6IfIndex as the IfIndex of the IPv4
	       loopback device, but with a different adapter name.
	       For consistency with /proc/net/if_inet6, try to find the
	       IPv6 loopback device and use that adapter name instead.
	       We identify the loopback device by its IfIndex of 1. */
	    if (pap->IfIndex == 1 && pap->Ipv6IfIndex == 0)
	      for (PIP_ADAPTER_ADDRESSES pap2 = pa0; pap2; pap2 = pap2->Next)
		if (pap2->Ipv6IfIndex == 1)
		  {
		    pap = pap2;
		    break;
		  }
	    name = strcpy (ifname, pap->AdapterName);
	    break;
	  }
      free (pa0);
d2370 2
a2371 2
  else
    set_errno (ENXIO);
d2382 1
a2382 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;

  if (get_adapters_addresses (&pa0, AF_UNSPEC))
d2384 1
a2384 9
      int cnt = 0;
      for (pap = pa0; pap; pap = pap->Next)
	++cnt;
      iflist = (struct if_nameindex *)
	       malloc ((cnt + 1) * sizeof (struct if_nameindex)
		       + cnt * IF_NAMESIZE);
      if (!iflist)
	set_errno (ENOBUFS);
      else
d2386 9
a2394 2
	  ifnamelist = (char (*)[IF_NAMESIZE]) (iflist + cnt + 1);
	  for (pap = pa0, cnt = 0; pap; pap = pap->Next)
d2396 26
a2421 16
	      for (int i = 0; i < cnt; ++i)
		if (iflist[i].if_index == (pap->Ipv6IfIndex ?: pap->IfIndex))
		  goto outer_loop;
	      iflist[cnt].if_index = pap->Ipv6IfIndex ?: pap->IfIndex;
	      strcpy (iflist[cnt].if_name = ifnamelist[cnt], pap->AdapterName);
	      /* See comment in if_indextoname. */
	      if (pap->IfIndex == 1 && pap->Ipv6IfIndex == 0)
		for (PIP_ADAPTER_ADDRESSES pap2 = pa0; pap2; pap2 = pap2->Next)
		  if (pap2->Ipv6IfIndex == 1)
		    {
		      strcpy (ifnamelist[cnt], pap2->AdapterName);
		      break;
		    }
	      ++cnt;
	    outer_loop:
	      ;
d2423 1
a2423 2
	  iflist[cnt].if_index = 0;
	  iflist[cnt].if_name = NULL;
d2425 2
a2426 1
      free (pa0);
d2428 2
a2429 2
  else
    set_errno (ENXIO);
d2451 1
a2451 1
  int ret;
d2453 5
a2457 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d2459 6
a2464 3
  fhandler_socket *fh = get (fd);
  if (!fh)
    return -1;
d2466 16
a2481 6
  if (!sa)
    {
      sa = (struct sockaddr *) &sst;
      memset (&sst, 0, sizeof sst);
      sa->sa_family = fh->get_addr_family ();
    }
d2483 8
a2490 16
  switch (sa->sa_family)
    {
    case AF_INET:
      salen = sizeof (struct sockaddr_in);
      sin = (struct sockaddr_in *) sa;
      port = sin->sin_port;
      break;
    case AF_INET6:
      salen = sizeof (struct sockaddr_in6);
      sin6 = (struct sockaddr_in6 *) sa;
      port = sin6->sin6_port;
      break;
    default:
      set_errno (EPFNOSUPPORT);
      return -1;
    }
d2492 1
a2492 8
  /* If a non-zero port number is given, try this first.  If that succeeds,
     or if the error message is serious, return. */
  if (port)
    {
      ret = fh->bind (sa, salen);
      if (!ret || (get_errno () != EADDRINUSE && get_errno () != EINVAL))
	return ret;
    }
d2494 8
a2501 1
  LONG myport;
d2503 9
a2511 7
  for (int i = 0; i < NUM_PORTS; i++)
    {
      while ((myport = InterlockedExchange (&cygwin_shared->last_used_bindresvport, -1)) == -1)
	yield ();
      if (myport == 0 || --myport < PORT_LOW)
	myport = PORT_HIGH;
      InterlockedExchange (&cygwin_shared->last_used_bindresvport, myport);
a2512 8
      if (sa->sa_family == AF_INET6)
	sin6->sin6_port = htons (myport);
      else
	sin->sin_port = htons (myport);
      if (!(ret = fh->bind (sa, salen)))
	break;
      if (get_errno () != EADDRINUSE && get_errno () != EINVAL)
	break;
d2514 2
a2515 1

d2519 1
d2532 3
a2534 1
  SOCKET insock, outsock, newsock;
d2538 1
a2538 24
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  int flags = type & _SOCK_FLAG_MASK;
  type &= ~_SOCK_FLAG_MASK;

  if (family != AF_LOCAL && family != AF_INET)
    {
      set_errno (EAFNOSUPPORT);
      goto done;
    }
  if (type != SOCK_STREAM && type != SOCK_DGRAM)
    {
      set_errno (EPROTOTYPE);
      goto done;
    }
  if ((flags & ~(SOCK_NONBLOCK | SOCK_CLOEXEC)) != 0)
    {
      set_errno (EINVAL);
      goto done;
    }
  if ((family == AF_LOCAL && protocol != PF_UNSPEC && protocol != PF_LOCAL)
      || (family == AF_INET && protocol != PF_UNSPEC && protocol != PF_INET))
d2540 2
a2541 3
      set_errno (EPROTONOSUPPORT);
      goto done;
    }
d2543 21
a2563 8
  /* create the first socket */
  newsock = socket (AF_INET, type, 0);
  if (newsock == INVALID_SOCKET)
    {
      debug_printf ("first socket call failed");
      set_winsock_errno ();
      goto done;
    }
d2565 8
a2572 19
  /* bind the socket to any unused port */
  sock_in.sin_family = AF_INET;
  sock_in.sin_port = 0;
  sock_in.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
  if (bind (newsock, (struct sockaddr *) &sock_in, sizeof (sock_in)) < 0)
    {
      debug_printf ("bind failed");
      set_winsock_errno ();
      closesocket (newsock);
      goto done;
    }
  len = sizeof (sock_in);
  if (getsockname (newsock, (struct sockaddr *) &sock_in, &len) < 0)
    {
      debug_printf ("getsockname error");
      set_winsock_errno ();
      closesocket (newsock);
      goto done;
    }
d2574 5
a2578 21
  /* For stream sockets, create a listener */
  if (type == SOCK_STREAM)
    listen (newsock, 2);

  /* create a connecting socket */
  outsock = socket (AF_INET, type, 0);
  if (outsock == INVALID_SOCKET)
    {
      debug_printf ("second socket call failed");
      set_winsock_errno ();
      closesocket (newsock);
      goto done;
    }

  /* For datagram sockets, bind the 2nd socket to an unused address, too */
  if (type == SOCK_DGRAM)
    {
      sock_out.sin_family = AF_INET;
      sock_out.sin_port = 0;
      sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (bind (outsock, (struct sockaddr *) &sock_out, sizeof (sock_out)) < 0)
d2582 1
a2582 3
	  closesocket (newsock);
	  closesocket (outsock);
	  goto done;
d2584 2
a2585 2
      len = sizeof (sock_out);
      if (getsockname (outsock, (struct sockaddr *) &sock_out, &len) < 0)
d2589 1
a2589 3
	  closesocket (newsock);
	  closesocket (outsock);
	  goto done;
a2590 1
    }
d2592 3
a2594 4
  /* Force IP address to loopback */
  sock_in.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
  if (type == SOCK_DGRAM)
    sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
d2596 8
a2603 9
  /* Do a connect */
  if (connect (outsock, (struct sockaddr *) &sock_in, sizeof (sock_in)) < 0)
    {
      debug_printf ("connect error");
      set_winsock_errno ();
      closesocket (newsock);
      closesocket (outsock);
      goto done;
    }
d2605 2
a2606 6
  if (type == SOCK_STREAM)
    {
      /* For stream sockets, accept the connection and close the listener */
      len = sizeof (sock_in);
      insock = accept (newsock, (struct sockaddr *) &sock_in, &len);
      if (insock == INVALID_SOCKET)
d2608 16
a2623 5
	  debug_printf ("accept error");
	  set_winsock_errno ();
	  closesocket (newsock);
	  closesocket (outsock);
	  goto done;
d2625 8
a2632 7
      closesocket (newsock);
    }
  else
    {
      /* For datagram sockets, connect the 2nd socket */
      if (connect (newsock, (struct sockaddr *) &sock_out,
		   sizeof (sock_out)) < 0)
d2636 14
d2651 14
a2664 2
	  closesocket (outsock);
	  goto done;
a2665 2
      insock = newsock;
    }
d2667 2
a2668 3
  {
    cygheap_fdnew sb0;
    const device *dev;
d2670 4
a2673 4
    if (family == AF_INET)
      dev = (type == SOCK_STREAM ? tcp_dev : udp_dev);
    else
      dev = (type == SOCK_STREAM ? stream_dev : dgram_dev);
d2675 11
a2685 11
    if (sb0 >= 0 && fdsock (sb0, dev, insock))
      {
	((fhandler_socket *) sb0)->set_addr_family (family);
	((fhandler_socket *) sb0)->set_socket_type (type);
	((fhandler_socket *) sb0)->connect_state (connected);
	if (flags & SOCK_NONBLOCK)
	  ((fhandler_socket *) sb0)->set_nonblocking (true);
	if (flags & SOCK_CLOEXEC)
	  ((fhandler_socket *) sb0)->set_close_on_exec (true);
	if (family == AF_LOCAL && type == SOCK_STREAM)
	  ((fhandler_socket *) sb0)->af_local_set_sockpair_cred ();
d2687 1
a2687 1
	cygheap_fdnew sb1 (sb0, false);
d2689 11
a2699 19
	if (sb1 >= 0 && fdsock (sb1, dev, outsock))
	  {
	    ((fhandler_socket *) sb1)->set_addr_family (family);
	    ((fhandler_socket *) sb1)->set_socket_type (type);
	    ((fhandler_socket *) sb1)->connect_state (connected);
	    if (flags & SOCK_NONBLOCK)
	      ((fhandler_socket *) sb1)->set_nonblocking (true);
	    if (flags & SOCK_CLOEXEC)
	      ((fhandler_socket *) sb1)->set_close_on_exec (true);
	    if (family == AF_LOCAL && type == SOCK_STREAM)
	      ((fhandler_socket *) sb1)->af_local_set_sockpair_cred ();

	    sb[0] = sb0;
	    sb[1] = sb1;
	    res = 0;
	  }
	else
	  sb0.release ();
      }
d2701 14
a2714 2
    if (res == -1)
      {
d2716 1
d2718 3
a2720 5
      }
  }

done:
  syscall_printf ("%R = socketpair(...)", res);
d2740 1
a2740 1
  ssize_t res;
d2744 15
a2758 6
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
d2760 1
a2760 7
      res = check_iovec_for_read (msg->msg_iov, msg->msg_iovlen);
      /* Originally we shortcircuited here if res == 0.
	 Allow 0 bytes buffer.  This is valid in POSIX and handled in
	 fhandler_socket::recv_internal.  If we shortcircuit, we fail
	 to deliver valid error conditions and peer address. */
      if (res >= 0)
	res = fh->recvmsg (msg, flags);
d2762 1
a2762 1

d2771 1
a2771 1
  ssize_t res;
d2775 11
a2785 6
  fhandler_socket *fh = get (fd);

  myfault efault;
  if (efault.faulted (EFAULT) || !fh)
    res = -1;
  else
d2787 1
a2787 3
      res = check_iovec_for_write (msg->msg_iov, msg->msg_iovlen);
      if (res >= 0)
	res = fh->sendmsg (msg, flags);
d2789 1
a2789 1

a3163 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return;

d3339 2
a3340 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return EAI_SYSTEM;
d3351 24
a3374 31
  if (hints && (hints->ai_flags
		& ~(AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_ALL
		    | AI_NUMERICSERV | AI_ADDRCONFIG | AI_V4MAPPED
		    | AI_IDN_MASK)))
    return EAI_BADFLAGS;
  /* AI_NUMERICSERV is not supported prior to Windows Vista.  We just check
     the servname parameter by ourselves here. */
  if (hints && (hints->ai_flags & AI_NUMERICSERV))
    {
      char *p;
      if (servname && *servname && (strtoul (servname, &p, 10), *p))
	return EAI_NONAME;
    }

  int idn_flags = hints ? (hints->ai_flags & AI_IDN_MASK) : 0;
  const char *src;
  mbstate_t ps;
  tmp_pathbuf tp;
  wchar_t *whost = NULL, *wserv = NULL;
  struct addrinfoW whints, *wres;

  if (hostname)
    {
      memset (&ps, 0, sizeof ps);
      src = hostname;
      whost = tp.w_get ();
      if (mbsrtowcs (whost, &src, NT_MAX_PATH, &ps) == (size_t) -1)
	return EAI_IDN_ENCODE;
      if (src)
	return EAI_MEMORY;
      if (idn_flags & AI_IDN)
d3376 23
a3398 5
	  /* Map flags to equivalent IDN_* flags. */
	  wchar_t *ascbuf = tp.w_get ();
	  if (IdnToAscii (idn_flags >> 16, whost, -1, ascbuf, NT_MAX_PATH))
	    whost = ascbuf;
	  else if (GetLastError () != ERROR_PROC_NOT_FOUND)
d3400 10
d3411 5
a3415 24
    }
  if (servname)
    {
      memset (&ps, 0, sizeof ps);
      src = servname;
      wserv = tp.w_get ();
      if (mbsrtowcs (wserv, &src, NT_MAX_PATH, &ps) == (size_t) -1)
	return EAI_IDN_ENCODE;
      if (src)
	return EAI_MEMORY;
    }

  if (!hints)
    {
      /* Default settings per glibc man page. */
      memset (&whints, 0, sizeof whints);
      whints.ai_family = PF_UNSPEC;
      whints.ai_flags = AI_V4MAPPED | AI_ADDRCONFIG;
    }
  else
    {
      /* sizeof addrinfo == sizeof addrinfoW */
      memcpy (&whints, hints, sizeof whints);
      whints.ai_flags &= ~AI_IDN_MASK;
d3417 3
a3419 3
      /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
         Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
      whints.ai_addrlen &= UINT32_MAX;
d3421 36
a3456 36
      /* AI_ADDRCONFIG is not supported prior to Vista.  Rather it's
	 the default and only possible setting.
	 On Vista, the default behaviour is as if AI_ADDRCONFIG is set,
	 apparently for performance reasons.  To get the POSIX default
	 behaviour, the AI_ALL flag has to be set. */
      if (wincap.supports_all_posix_ai_flags ()
	  && whints.ai_family == PF_UNSPEC
	  && !(whints.ai_flags & AI_ADDRCONFIG))
	whints.ai_flags |= AI_ALL;
    }
  /* Disable automatic IDN conversion on W8 and later. */
  whints.ai_flags |= AI_DISABLE_IDN_ENCODING;
  int ret = w32_to_gai_err (GetAddrInfoW (whost, wserv, &whints, &wres));
  /* Always copy over to self-allocated memory. */
  if (!ret)
    {
      *res = ga_duplist (wres, false, idn_flags, ret);
      FreeAddrInfoW (wres);
      if (!*res)
	return ret;
    }
  /* AI_V4MAPPED and AI_ALL are not supported prior to Vista.  So, what
     we do here is to emulate AI_V4MAPPED.  If no IPv6 addresses are
     returned, or the AI_ALL flag is set, we try with AF_INET again, and
     convert the returned IPv4 addresses into v4-in-v6 entries.  This
     is done in ga_dup if the v4mapped flag is set. */
  if (!wincap.supports_all_posix_ai_flags ()
      && hints
      && hints->ai_family == AF_INET6
      && (hints->ai_flags & AI_V4MAPPED)
      && (ret == EAI_NODATA || ret == EAI_NONAME
	  || (hints->ai_flags & AI_ALL)))
    {
      /* sizeof addrinfo == sizeof addrinfoW */
      memcpy (&whints, hints, sizeof whints);
      whints.ai_family = AF_INET;
d3458 3
a3460 3
      /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
         Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
      whints.ai_addrlen &= UINT32_MAX;
d3462 2
a3463 6
      int ret2 = w32_to_gai_err (GetAddrInfoW (whost, wserv, &whints, &wres));
      if (!ret2)
	{
	  struct addrinfo *v4res = ga_duplist (wres, true, idn_flags, ret);
	  FreeAddrInfoW (wres);
	  if (!v4res)
d3465 10
d3476 9
a3484 2
		cygwin_freeaddrinfo (*res);
	      return ret;
a3485 12
	  /* If a list of v6 addresses exists, append the v4-in-v6 address
	     list.  Otherwise just return the v4-in-v6 address list. */
	  if (!ret)
	    {
	      struct addrinfo *ptr;
	      for (ptr = *res; ptr->ai_next; ptr = ptr->ai_next)
		;
	      ptr->ai_next = v4res;
	    }
	  else
	    *res = v4res;
	  ret = 0;
d3488 5
d3501 3
a3503 11
  myfault efault;
  if (efault.faulted (EFAULT))
    return EAI_SYSTEM;

  /* When the incoming port number does not resolve to a well-known service,
     WinSock's getnameinfo up to Windows 2003 returns with error WSANO_DATA
     instead of setting `serv' to the numeric port number string, as required
     by RFC 3493.  This is fixed on Vista and later.  To avoid the error on
     systems up to Windows 2003, we check if the port number resolves
     to a well-known service.  If not, we set the NI_NUMERICSERV flag. */
  if (!wincap.supports_all_posix_ai_flags ())
d3505 10
a3514 1
      int port = 0;
d3516 13
a3528 8
      switch (sa->sa_family)
	{
	case AF_INET:
	  port = ((struct sockaddr_in *) sa)->sin_port;
	  break;
	case AF_INET6:
	  port = ((struct sockaddr_in6 *) sa)->sin6_port;
	  break;
d3530 2
a3531 5
      if (!port || !getservbyport (port, flags & NI_DGRAM ? "udp" : "tcp"))
	flags |= NI_NUMERICSERV;
    }
  /* We call GetNameInfoW with local buffers and convert to locale
     charset to allow RFC 3490 IDNs like glibc 2.3.4 and later. */
d3535 5
a3539 5
  int idn_flags = flags & NI_IDN_MASK;
  flags &= ~NI_IDN_MASK;
  tmp_pathbuf tp;
  wchar_t *whost = NULL, *wserv = NULL;
  DWORD whlen = 0, wslen = 0;
d3541 10
a3550 10
  if (host && hostlen)
    {
      whost = tp.w_get ();
      whlen = NT_MAX_PATH;
    }
  if (serv && servlen)
    {
      wserv = tp.w_get ();
      wslen = NT_MAX_PATH;
    }
d3552 1
a3552 1
  int ret = w32_to_gai_err (GetNameInfoW (sa, salen, whost, whlen,
d3554 3
a3556 3
  if (!ret)
    {
      const wchar_t *src;
d3558 19
a3576 3
      if (whost)
	{
	  if (idn_flags & NI_IDN)
d3578 2
a3579 6
	      /* Map flags to equivalent IDN_* flags. */
	      wchar_t *idnbuf = tp.w_get ();
	      if (IdnToUnicode (idn_flags >> 16, whost, -1,
				idnbuf, NT_MAX_PATH))
		whost = idnbuf;
	      else if (GetLastError () != ERROR_PROC_NOT_FOUND)
d3581 2
a3583 13
	  src = whost;
	  if (wcsrtombs (host, &src, hostlen, NULL) == (size_t) -1)
	    return EAI_IDN_ENCODE;
	  if (src)
	    return EAI_OVERFLOW;
	}
      if (wserv)
	{
	  src = wserv;
	  if (wcsrtombs (serv, &src, servlen, NULL) == (size_t) -1)
	    return EAI_IDN_ENCODE;
	  if (src)
	    return EAI_OVERFLOW;
d3585 6
d3592 1
a3592 2
  else if (ret == EAI_SYSTEM)
    set_winsock_errno ();
@


1.316
log
@	* net.cc (cygwin_getaddrinfo): Fix value of hint->ai_addrlen on 64 bit.
	Explain why.
@
text
@a2382 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return;
@


1.315
log
@	* net.cc (call_gaa): Fix setting pa_ret pointer in case of an error
	from GetAdaptersAddresses (CID 60218).
	(get_ifs): Add missing braces in AF_INET6 case which broke netmask
	computation.  Break out of loop if prefix gets <= 0 (CID 59939).
@
text
@d3369 5
d3410 5
@


1.314
log
@	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.
@
text
@d1676 1
a1676 1
	  *p->pa_ret = pa0;
d1688 1
a1688 1
  gaa_wa param = { family, pa_ret ?: NULL };
d2083 6
a2088 4
		for (cnt = 0; cnt < 4 && prefix; ++cnt, prefix -= 32)
		  if_sin6->sin6_addr.s6_addr32[cnt] = UINT32_MAX;
		  if (prefix < 32)
		    if_sin6->sin6_addr.s6_addr32[cnt] <<= 32 - prefix;
@


1.313
log
@	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.
@
text
@d926 1
a926 1
      else if (level == SOL_SOCKET)
d928 14
a941 1
	  switch (optname)
d943 4
a946 22
	    case SO_ERROR:
	      {
		int *e = (int *) optval;
		debug_printf ("WinSock SO_ERROR = %d", *e);
		*e = find_winsock_errno (*e);
	      }
	      break;
	    case SO_KEEPALIVE:
	    case SO_DONTROUTE:
	      /* Regression in Vista and later:  instead of a 4 byte BOOL
		 value, a 1 byte BOOLEAN value is returned, in contrast
		 to older systems and the documentation.  Since an int
		 type is expected by the calling application, we convert
		 the result here. */
	      if (*optlen == 1)
		{
		  BOOLEAN *in = (BOOLEAN *) optval;
		  int *out = (int *) optval;
		  *out = *in;
		  *optlen = 4;
		}
	      break;
@


1.312
log
@	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.
@
text
@d23 9
@


1.311
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Fix typo in
	comment.
	* mount.cc (mount_info::from_fstab): Use tmp_pathbuf rather than
	stack for big local buffer.
	* net.cc (cygwin_gethostname): Call GetComputerNameExA rather than
	GetComputerNameA if gethostname failed.
	* shared.cc (user_info::initialize): Fix formatting.
	* include/sys/file.h: Define flock and accompanying macros if not
	already defined in sys/_default_fcntl.h.
@
text
@d851 4
a854 1
	     We just ignore the return value of setting IP_TOS entirely. */
d861 6
@


1.311.2.1
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@a22 9
#ifdef __x86_64__
/* 2014-04-24: Current Mingw headers define sockaddr_in6 using u_long (8 byte)
   because a redefinition for LP64 systems is missing.  This leads to a wrong
   definition and size of sockaddr_in6 when building with winsock headers.
   This definition is also required to use the right u_long type in subsequent
   function calls. */
#undef u_long
#define u_long __ms_u_long
#endif
d851 1
a851 4
	     We just ignore the return value of setting IP_TOS entirely.
	     
	     CV 2014-04-16: Same for IPV6_TCLASS
	     FIXME:         Same for IPV6_RECVTCLASS? */
a857 6
	  else if (level == IPPROTO_IPV6 && optname == IPV6_TCLASS
		   && WSAGetLastError () == WSAENOPROTOOPT)
	    {
	      debug_printf ("Faked IPV6_TCLASS success");
	      res = 0;
	    }
d908 1
a908 1
      else if (level == SOL_SOCKET && optname == SO_ERROR)
d910 1
a910 14
	  int *e = (int *) optval;
	  debug_printf ("WinSock SO_ERROR = %d", *e);
	  *e = find_winsock_errno (*e);
	}
      else if (*optlen == 1)
      	{
	  /* Regression in Vista and later:  instead of a 4 byte BOOL value,
	     a 1 byte BOOLEAN value is returned, in contrast to older systems
	     and the documentation.  Since an int type is expected by the
	     calling application, we convert the result here.  For some reason
	     only three BSD-compatible socket options seem to be affected. */
	  if ((level == SOL_SOCKET
	       && (optname == SO_KEEPALIVE || optname == SO_DONTROUTE))
	      || (level == IPPROTO_TCP && optname == TCP_NODELAY))
d912 22
a933 4
	      BOOLEAN *in = (BOOLEAN *) optval;
	      int *out = (int *) optval;
	      *out = *in;
	      *optlen = 4;
@


1.311.2.2
log
@	* net.cc (cygwin_getaddrinfo): Fix value of hint->ai_addrlen on 64 bit.
	Explain why.
@
text
@a3366 5
#ifdef __x86_64__
      /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
         Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
      whints.ai_addrlen &= UINT32_MAX;
#endif
a3402 5
#ifdef __x86_64__
      /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
         Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
      whints.ai_addrlen &= UINT32_MAX;
#endif
@


1.311.2.3
log
@Add more missing patches
@
text
@d1676 1
a1676 1
	  *p->pa_ret = NULL;
d1688 1
a1688 1
  gaa_wa param = { family, pa_ret };
d2083 4
a2086 6
		for (cnt = 0; cnt < 4 && prefix > 0; ++cnt, prefix -= 32)
		  {
		    if_sin6->sin6_addr.s6_addr32[cnt] = UINT32_MAX;
		    if (prefix < 32)
		      if_sin6->sin6_addr.s6_addr32[cnt] <<= 32 - prefix;
		  }
@


1.311.2.4
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d503 4
a506 7
  __try
    {
      return dup_ent (getprotobyname (p));
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
d734 1
a734 1
  ssize_t res = -1;
d738 8
a745 8
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->sendto (buf, len, flags, to, tolen);
    }
  __except (EFAULT) {}
  __endtry
d756 1
a756 1
  ssize_t res = -1;
d760 12
a771 12
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	/* Originally we shortcircuited here if res == 0.
	   Allow 0 bytes buffer.  This is valid in POSIX and handled in
	   fhandler_socket::recv_internal.  If we shortcircuit, we fail
	   to deliver valid error conditions and peer address. */
	res = fh->recvfrom (buf, len, flags, from, fromlen);
    }
  __except (EFAULT) {}
  __endtry
d803 2
a804 1
  int res = -1;
d806 4
a809 1
  __try
a810 20
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;

      /* Switch off the AF_LOCAL handshake and thus SO_PEERCRED handling
	 for AF_LOCAL/SOCK_STREAM sockets.  This allows to handle special
	 situations in which connect is called before a listening socket
	 accepts connections.
	 FIXME: In the long run we should find a more generic solution which
	 doesn't require a blocking handshake in accept/connect to exchange
	 SO_PEERCRED credentials. */
      if (level == SOL_SOCKET && optname == SO_PEERCRED)
	{
	  if (optval || optlen)
	    set_errno (EINVAL);
	  else
	    res = fh->af_local_set_no_getpeereid ();
	  __leave;
	}

d895 1
a895 5
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
d906 2
a907 1
  int res = -1;
d909 9
a917 1
  __try
a918 9
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;
      if (optname == SO_PEERCRED && level == SOL_SOCKET)
	{
	  struct ucred *cred = (struct ucred *) optval;
	  res = fh->getpeereid (&cred->pid, &cred->uid, &cred->gid);
	  __leave;
	}
d933 1
a933 1
	{
d950 1
a950 5
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
d969 1
a969 1
  int res = -1;
d973 8
a980 8
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->connect (name, namelen);
    }
  __except (EFAULT) {}
  __endtry
d982 1
d990 3
a992 1
  servent *res = NULL;
d994 1
a994 6
  __try
    {
      res = dup_ent (getservbyname (name, proto));
    }
  __except (EFAULT) {}
  __endtry
d1003 3
a1005 1
  servent *res = NULL;
d1007 1
a1007 6
  __try
    {
      res = dup_ent (getservbyport (port, proto));
    }
  __except (EFAULT) {}
  __endtry
d1015 3
a1017 1
  int res = -1;
d1019 1
a1019 1
  __try
d1021 3
a1023 1
      if (gethostname (name, len))
d1025 2
a1026 8
	  DWORD local_len = len;

	  if (!GetComputerNameExA (ComputerNameDnsFullyQualified, name,
				   &local_len))
	    {
	      set_winsock_errno ();
	      __leave;
	    }
a1027 2
      debug_printf ("name %s", name);
      res = 0;
d1029 2
a1030 3
  __except (EFAULT) {}
  __endtry
  return res;
d1037 4
a1046 1
  hostent *res = NULL;
d1048 4
a1051 1
  __try
d1053 19
a1071 30
      if (sscanf (name, "%u.%u.%u.%u%c", &a, &b, &c, &d, &dummy) != 4
	  || a >= 256 || b >= 256 || c >= 256 || d >= 256)
	h = gethostbyname (name);
      else
	{
	  /* In case you don't have DNS, at least x.x.x.x still works */
	  memset (&tmp, 0, sizeof (tmp));
	  tmp_addr[0] = a;
	  tmp_addr[1] = b;
	  tmp_addr[2] = c;
	  tmp_addr[3] = d;
	  tmp_addr_list[0] = (char *) tmp_addr;
	  tmp.h_name = name;
	  tmp.h_aliases = tmp_aliases;
	  tmp.h_addrtype = 2;
	  tmp.h_length = 4;
	  tmp.h_addr_list = tmp_addr_list;
	  h = &tmp;
	}

      res = dup_ent (h);
      if (res)
	debug_printf ("h_name %s", res->h_name);
      else
	{
	  debug_printf ("dup_ent returned NULL for name %s, h %p", name, h);
	  set_host_errno ();
	}
    }
  __except (EFAULT)
d1073 2
a1074 1
      res = NULL;
a1075 1
  __endtry
d1083 9
a1091 15
  hostent *res = NULL;

  __try
    {
      res = dup_ent (gethostbyaddr (addr, len, type));
      if (res)
	debug_printf ("h_name %s", res->h_name);
      else
	set_host_errno ();
    }
  __except (EFAULT)
    {
      res = NULL;
    }
  __endtry
d1314 7
a1320 1
  hostent *res = NULL;
d1322 2
a1323 1
  __try
d1325 14
a1338 3
      if (!(_res.options & RES_INIT))
	  res_init();
      bool v4to6 = _res.options & RES_USE_INET6;
d1340 1
a1340 23
      int type, addrsize_in, addrsize_out;
      switch (af)
	{
	case AF_INET:
	  addrsize_in = NS_INADDRSZ;
	  addrsize_out = (v4to6) ? NS_IN6ADDRSZ : NS_INADDRSZ;
	  type = ns_t_a;
	  break;
	case AF_INET6:
	  addrsize_in = addrsize_out = NS_IN6ADDRSZ;
	  type = ns_t_aaaa;
	  break;
	default:
	  set_errno (EAFNOSUPPORT);
	  h_errno = NETDB_INTERNAL;
	  __leave;
	}

      res = gethostby_helper (name, af, type, addrsize_in, addrsize_out);
    }
  __except (EFAULT) {}
  __endtry
  return res;
d1347 1
a1347 1
  int res = -1;
d1351 8
a1358 9
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->accept4 (peer, len,
			   fh->is_nonblocking () ? SOCK_NONBLOCK : 0);
    }
  __except (EFAULT) {}
  __endtry
d1366 1
a1366 1
  int res = -1;
d1370 6
a1375 1
  __try
d1377 2
a1378 7
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;
      if ((flags & ~(SOCK_NONBLOCK | SOCK_CLOEXEC)) != 0)
	  set_errno (EINVAL);
      else
	res = fh->accept4 (peer, len, flags);
d1380 3
a1382 2
  __except (EFAULT) {}
  __endtry
d1391 8
a1398 1
  int res = -1;
a1399 8
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->bind (my_addr, addrlen);
    }
  __except (EFAULT) {}
  __endtry
d1408 9
a1416 1
  int res = -1;
a1417 8
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->getsockname (addr, namelen);
    }
  __except (EFAULT) {}
  __endtry
d1426 7
a1432 1
  int res = -1;
a1433 8
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->listen (backlog);
    }
  __except (EFAULT) {}
  __endtry
d1442 1
a1442 1
  int res = -1;
d1445 4
a1448 1
  if (fh)
d1450 1
d1472 7
a1478 1
  __try
d1480 3
a1482 2
      if (cygheap->fdtab.not_open (2))
	return;
d1484 1
a1484 5
      if (s)
	{
	  write (2, s, strlen (s));
	  write (2, ": ", 2);
	}
d1486 15
a1500 20
      const char *h_errstr = cygwin_hstrerror (h_errno);

      if (!h_errstr)
	switch (h_errno)
	  {
	    case NETDB_INTERNAL:
	      h_errstr = "Resolver internal error";
	      break;
	    case NETDB_SUCCESS:
	      h_errstr = "Resolver error 0 (no error)";
	      break;
	    default:
	      h_errstr = "Unknown resolver error";
	      break;
	  }
      write (2, h_errstr, strlen (h_errstr));
      write (2, "\n", 1);
    }
  __except (NO_ERROR) {}
  __endtry
d1507 9
a1515 2
  int res = -1;
  fhandler_socket *fh = NULL;
a1516 8
  __try
    {
      fh = get (fd);
      if (fh)
	res = fh->getpeername (name, len);
    }
  __except (EFAULT) {}
  __endtry
d1526 1
a1526 1
  ssize_t res = -1;
d1530 12
a1541 12
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	/* Originally we shortcircuited here if res == 0.
	   Allow 0 bytes buffer.  This is valid in POSIX and handled in
	   fhandler_socket::recv_internal.  If we shortcircuit, we fail
	   to deliver valid error conditions. */
	res = fh->recvfrom (buf, len, flags, NULL, NULL);
    }
  __except (EFAULT) {}
  __endtry
d1550 1
a1550 1
  ssize_t res = -1;
d1554 8
a1561 8
  __try
    {
      fhandler_socket *fh = get (fd);
      if (fh)
	res = fh->sendto (buf, len, flags, NULL, 0);
    }
  __except (EFAULT)
  __endtry
d1570 10
a1579 1
  __try
d1581 2
a1582 11
      PFIXED_INFO info = NULL;
      ULONG size = 0;

      if (GetNetworkParams(info, &size) == ERROR_BUFFER_OVERFLOW
	  && (info = (PFIXED_INFO) alloca(size))
	  && GetNetworkParams(info, &size) == ERROR_SUCCESS)
	{
	  strncpy(domain, info->DomainName, len);
	  return 0;
	}
      __seterrno ();
d1584 1
a1584 2
  __except (EFAULT)
  __endtry
d2179 6
a2184 1
  __try
d2186 3
a2188 6
      /* Ensure we have space for at least one struct ifreqs, fail if not. */
      if (ifc->ifc_len < (int) sizeof (struct ifreq))
	{
	  set_errno (EINVAL);
	  __leave;
	}
d2190 4
a2193 4
      struct ifall *ifret, *ifp;
      ifret = get_ifs (AF_INET);
      if (!ifret)
	__leave;
d2195 8
a2202 4
      struct sockaddr_in *sin;
      struct ifreq *ifr = ifc->ifc_req;
      int cnt = 0;
      for (ifp = ifret; ifp; ifp = (struct ifall *) ifp->ifa_ifa.ifa_next)
d2204 24
a2227 3
	  ++cnt;
	  strcpy (ifr->ifr_name, ifp->ifa_name);
	  switch (what)
d2229 3
a2231 46
	    case SIOCGIFFLAGS:
	      ifr->ifr_flags = ifp->ifa_ifa.ifa_flags;
	      break;
	    case SIOCGIFCONF:
	    case SIOCGIFADDR:
	      sin = (struct sockaddr_in *) &ifr->ifr_addr;
	      memcpy (sin, &ifp->ifa_addr, sizeof *sin);
	      break;
	    case SIOCGIFNETMASK:
	      sin = (struct sockaddr_in *) &ifr->ifr_netmask;
	      memcpy (sin, &ifp->ifa_netmask, sizeof *sin);
	      break;
	    case SIOCGIFDSTADDR:
	      sin = (struct sockaddr_in *) &ifr->ifr_dstaddr;
	      if (ifp->ifa_ifa.ifa_flags & IFF_POINTOPOINT)
		memcpy (sin, &ifp->ifa_brddstaddr, sizeof *sin);
	      else /* Return addr as on Linux. */
		memcpy (sin, &ifp->ifa_addr, sizeof *sin);
	      break;
	    case SIOCGIFBRDADDR:
	      sin = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	      if (!(ifp->ifa_ifa.ifa_flags & IFF_POINTOPOINT))
		memcpy (sin, &ifp->ifa_brddstaddr, sizeof *sin);
	      else
		{
		  sin->sin_addr.s_addr = INADDR_ANY;
		  sin->sin_family = AF_INET;
		  sin->sin_port = 0;
		}
	      break;
	    case SIOCGIFHWADDR:
	      memcpy (&ifr->ifr_hwaddr, &ifp->ifa_hwaddr,
		      sizeof ifr->ifr_hwaddr);
	      break;
	    case SIOCGIFMETRIC:
	      ifr->ifr_metric = ifp->ifa_metric;
	      break;
	    case SIOCGIFMTU:
	      ifr->ifr_mtu = ifp->ifa_mtu;
	      break;
	    case SIOCGIFINDEX:
	      ifr->ifr_ifindex = ifp->ifa_ifindex;
	      break;
	    case SIOCGIFFRNDLYNAM:
	      memcpy (ifr->ifr_frndlyname, &ifp->ifa_frndlyname,
		      sizeof (struct ifreq_frndlyname));
d2233 16
a2248 3
	  if ((caddr_t) ++ifr >
	      ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
	    break;
d2250 3
a2252 4
      /* Set the correct length */
      ifc->ifc_len = cnt * sizeof (struct ifreq);
      free (ifret);
      return 0;
d2254 4
a2257 3
  __except (EFAULT) {}
  __endtry
  return -1;
d2266 5
a2270 1
  __try
d2272 1
a2272 3
      if (get_adapters_addresses (&pa0, AF_UNSPEC))
	{
	  char lname[IF_NAMESIZE], *c;
d2274 11
a2284 16
	  lname[0] = '\0';
	  strncat (lname, name, IF_NAMESIZE - 1);
	  if (lname[0] == '{' && (c = strchr (lname, ':')))
	    *c = '\0';
	  for (pap = pa0; pap; pap = pap->Next)
	    if (strcasematch (lname, pap->AdapterName))
	      {
		index = pap->Ipv6IfIndex ?: pap->IfIndex;
		break;
	      }
	  free (pa0);
	}
    }
  __except (EFAULT)
    {
      index = 0;
a2285 1
  __endtry
d2295 5
a2299 1
  __try
d2301 20
a2320 27
      if (get_adapters_addresses (&pa0, AF_UNSPEC))
	{
	  for (pap = pa0; pap; pap = pap->Next)
	    if (ifindex == (pap->Ipv6IfIndex ?: pap->IfIndex))
	      {
		/* Unfortunately the pre-Vista IPv6 stack has a distinct
		   loopback device with the same Ipv6IfIndex as the IfIndex
		   of the IPv4 loopback device, but with a different adapter
		   name.  For consistency with /proc/net/if_inet6, try to find
		   the IPv6 loopback device and use that adapter name instead.
		   We identify the loopback device by its IfIndex of 1. */
		if (pap->IfIndex == 1 && pap->Ipv6IfIndex == 0)
		  for (PIP_ADAPTER_ADDRESSES pap2 = pa0;
		       pap2;
		       pap2 = pap2->Next)
		    if (pap2->Ipv6IfIndex == 1)
		      {
			pap = pap2;
			break;
		      }
		name = strcpy (ifname, pap->AdapterName);
		break;
	      }
	  free (pa0);
	}
      else
	set_errno (ENXIO);
d2322 2
a2323 2
  __except (EFAULT) {}
  __endtry
d2334 5
a2338 1
  __try
d2340 9
a2348 1
      if (get_adapters_addresses (&pa0, AF_UNSPEC))
d2350 2
a2351 9
	  int cnt = 0;
	  for (pap = pa0; pap; pap = pap->Next)
	    ++cnt;
	  iflist = (struct if_nameindex *)
		   malloc ((cnt + 1) * sizeof (struct if_nameindex)
			   + cnt * IF_NAMESIZE);
	  if (!iflist)
	    set_errno (ENOBUFS);
	  else
d2353 16
a2368 26
	      ifnamelist = (char (*)[IF_NAMESIZE]) (iflist + cnt + 1);
	      for (pap = pa0, cnt = 0; pap; pap = pap->Next)
		{
		  for (int i = 0; i < cnt; ++i)
		    if (iflist[i].if_index
			== (pap->Ipv6IfIndex ?: pap->IfIndex))
		      goto outer_loop;
		  iflist[cnt].if_index = pap->Ipv6IfIndex ?: pap->IfIndex;
		  strcpy (iflist[cnt].if_name = ifnamelist[cnt],
			  pap->AdapterName);
		  /* See comment in if_indextoname. */
		  if (pap->IfIndex == 1 && pap->Ipv6IfIndex == 0)
		    for (PIP_ADAPTER_ADDRESSES pap2 = pa0;
			 pap2;
			 pap2 = pap2->Next)
		      if (pap2->Ipv6IfIndex == 1)
			{
			  strcpy (ifnamelist[cnt], pap2->AdapterName);
			  break;
			}
		  ++cnt;
		outer_loop:
		  ;
		}
	      iflist[cnt].if_index = 0;
	      iflist[cnt].if_name = NULL;
d2370 2
a2371 1
	  free (pa0);
d2373 1
a2373 2
      else
	set_errno (ENXIO);
d2375 2
a2376 2
  __except (EFAULT) {}
  __endtry
d2383 3
d2401 1
a2401 1
  int ret = -1;
d2403 3
a2405 5
  __try
    {
      fhandler_socket *fh = get (fd);
      if (!fh)
	__leave;
d2407 3
a2409 6
      if (!sa)
	{
	  sa = (struct sockaddr *) &sst;
	  memset (&sst, 0, sizeof sst);
	  sa->sa_family = fh->get_addr_family ();
	}
d2411 6
a2416 16
      switch (sa->sa_family)
	{
	case AF_INET:
	  salen = sizeof (struct sockaddr_in);
	  sin = (struct sockaddr_in *) sa;
	  port = sin->sin_port;
	  break;
	case AF_INET6:
	  salen = sizeof (struct sockaddr_in6);
	  sin6 = (struct sockaddr_in6 *) sa;
	  port = sin6->sin6_port;
	  break;
	default:
	  set_errno (EPFNOSUPPORT);
	  __leave;
	}
d2418 16
a2433 8
      /* If a non-zero port number is given, try this first.  If that succeeds,
	 or if the error message is serious, return. */
      if (port)
	{
	  ret = fh->bind (sa, salen);
	  if (!ret || (get_errno () != EADDRINUSE && get_errno () != EINVAL))
	    __leave;
	}
d2435 8
a2442 1
      LONG myport;
d2444 1
a2444 8
      for (int i = 0; i < NUM_PORTS; i++)
	{
	  while ((myport = InterlockedExchange (
			    &cygwin_shared->last_used_bindresvport, -1)) == -1)
	    yield ();
	  if (myport == 0 || --myport < PORT_LOW)
	    myport = PORT_HIGH;
	  InterlockedExchange (&cygwin_shared->last_used_bindresvport, myport);
d2446 7
a2452 9
	  if (sa->sa_family == AF_INET6)
	    sin6->sin6_port = htons (myport);
	  else
	    sin->sin_port = htons (myport);
	  if (!(ret = fh->bind (sa, salen)))
	    break;
	  if (get_errno () != EADDRINUSE && get_errno () != EINVAL)
	    break;
	}
d2454 8
d2463 1
a2463 2
  __except (EFAULT) {}
  __endtry
a2466 1

d2479 1
a2479 3
  SOCKET insock = INVALID_SOCKET;
  SOCKET outsock = INVALID_SOCKET;
  SOCKET newsock = INVALID_SOCKET;
d2483 32
a2514 1
  __try
d2516 4
a2519 2
      int flags = type & _SOCK_FLAG_MASK;
      type &= ~_SOCK_FLAG_MASK;
d2521 19
a2539 21
      if (family != AF_LOCAL && family != AF_INET)
	{
	  set_errno (EAFNOSUPPORT);
	  __leave;
	}
      if (type != SOCK_STREAM && type != SOCK_DGRAM)
	{
	  set_errno (EPROTOTYPE);
	  __leave;
	}
      if ((flags & ~(SOCK_NONBLOCK | SOCK_CLOEXEC)) != 0)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      if ((family == AF_LOCAL && protocol != PF_UNSPEC && protocol != PF_LOCAL)
	  || (family == AF_INET && protocol != PF_UNSPEC && protocol != PF_INET))
	{
	  set_errno (EPROTONOSUPPORT);
	  __leave;
	}
d2541 13
a2553 8
      /* create the first socket */
      newsock = socket (AF_INET, type, 0);
      if (newsock == INVALID_SOCKET)
	{
	  debug_printf ("first socket call failed");
	  set_winsock_errno ();
	  __leave;
	}
d2555 7
a2561 5
      /* bind the socket to any unused port */
      sock_in.sin_family = AF_INET;
      sock_in.sin_port = 0;
      sock_in.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (bind (newsock, (struct sockaddr *) &sock_in, sizeof (sock_in)) < 0)
d2565 3
a2567 1
	  __leave;
d2569 2
a2570 2
      len = sizeof (sock_in);
      if (getsockname (newsock, (struct sockaddr *) &sock_in, &len) < 0)
d2574 3
a2576 1
	  __leave;
d2578 1
d2580 4
a2583 3
      /* For stream sockets, create a listener */
      if (type == SOCK_STREAM)
	listen (newsock, 2);
d2585 16
a2600 3
      /* create a connecting socket */
      outsock = socket (AF_INET, type, 0);
      if (outsock == INVALID_SOCKET)
d2602 1
a2602 1
	  debug_printf ("second socket call failed");
d2604 3
a2606 1
	  __leave;
d2608 7
a2614 29

      /* For datagram sockets, bind the 2nd socket to an unused address, too */
      if (type == SOCK_DGRAM)
	{
	  sock_out.sin_family = AF_INET;
	  sock_out.sin_port = 0;
	  sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  if (bind (outsock, (struct sockaddr *) &sock_out, sizeof (sock_out)) < 0)
	    {
	      debug_printf ("bind failed");
	      set_winsock_errno ();
	      __leave;
	    }
	  len = sizeof (sock_out);
	  if (getsockname (outsock, (struct sockaddr *) &sock_out, &len) < 0)
	    {
	      debug_printf ("getsockname error");
	      set_winsock_errno ();
	      __leave;
	    }
	}

      /* Force IP address to loopback */
      sock_in.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (type == SOCK_DGRAM)
	sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);

      /* Do a connect */
      if (connect (outsock, (struct sockaddr *) &sock_in, sizeof (sock_in)) < 0)
a2617 14
	  __leave;
	}

      if (type == SOCK_STREAM)
	{
	  /* For stream sockets, accept the connection and close the listener */
	  len = sizeof (sock_in);
	  insock = accept (newsock, (struct sockaddr *) &sock_in, &len);
	  if (insock == INVALID_SOCKET)
	    {
	      debug_printf ("accept error");
	      set_winsock_errno ();
	      __leave;
	    }
d2619 2
a2620 14
	  newsock = INVALID_SOCKET;
	}
      else
	{
	  /* For datagram sockets, connect the 2nd socket */
	  if (connect (newsock, (struct sockaddr *) &sock_out,
		       sizeof (sock_out)) < 0)
	    {
	      debug_printf ("connect error");
	      set_winsock_errno ();
	      __leave;
	    }
	  insock = newsock;
	  newsock = INVALID_SOCKET;
d2622 2
d2625 3
a2627 2
      cygheap_fdnew sb0;
      const device *dev;
d2629 4
a2632 4
      if (family == AF_INET)
	dev = (type == SOCK_STREAM ? tcp_dev : udp_dev);
      else
	dev = (type == SOCK_STREAM ? stream_dev : dgram_dev);
d2634 11
a2644 11
      if (sb0 >= 0 && fdsock (sb0, dev, insock))
	{
	  ((fhandler_socket *) sb0)->set_addr_family (family);
	  ((fhandler_socket *) sb0)->set_socket_type (type);
	  ((fhandler_socket *) sb0)->connect_state (connected);
	  if (flags & SOCK_NONBLOCK)
	    ((fhandler_socket *) sb0)->set_nonblocking (true);
	  if (flags & SOCK_CLOEXEC)
	    ((fhandler_socket *) sb0)->set_close_on_exec (true);
	  if (family == AF_LOCAL && type == SOCK_STREAM)
	    ((fhandler_socket *) sb0)->af_local_set_sockpair_cred ();
d2646 1
a2646 1
	  cygheap_fdnew sb1 (sb0, false);
d2648 19
a2666 11
	  if (sb1 >= 0 && fdsock (sb1, dev, outsock))
	    {
	      ((fhandler_socket *) sb1)->set_addr_family (family);
	      ((fhandler_socket *) sb1)->set_socket_type (type);
	      ((fhandler_socket *) sb1)->connect_state (connected);
	      if (flags & SOCK_NONBLOCK)
		((fhandler_socket *) sb1)->set_nonblocking (true);
	      if (flags & SOCK_CLOEXEC)
		((fhandler_socket *) sb1)->set_close_on_exec (true);
	      if (family == AF_LOCAL && type == SOCK_STREAM)
		((fhandler_socket *) sb1)->af_local_set_sockpair_cred ();
d2668 2
a2669 14
	      sb[0] = sb0;
	      sb[1] = sb1;
	      res = 0;
	    }
	  else
	    sb0.release ();
	}
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = socketpair(...)", res);
  if (res == -1)
    {
      if (insock != INVALID_SOCKET)
a2670 1
      if (outsock != INVALID_SOCKET)
d2672 5
a2676 3
      if (newsock != INVALID_SOCKET)
	closesocket (newsock);
    }
d2696 1
a2696 1
  ssize_t res = -1;
d2700 6
a2705 1
  __try
d2707 7
a2713 11
      fhandler_socket *fh = get (fd);
      if (fh)
	{
	  res = check_iovec_for_read (msg->msg_iov, msg->msg_iovlen);
	  /* Originally we shortcircuited here if res == 0.
	     Allow 0 bytes buffer.  This is valid in POSIX and handled in
	     fhandler_socket::recv_internal.  If we shortcircuit, we fail
	     to deliver valid error conditions and peer address. */
	  if (res >= 0)
	    res = fh->recvmsg (msg, flags);
	}
d2715 1
a2715 5
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
d2724 1
a2724 1
  ssize_t res = -1;
d2728 6
a2733 1
  __try
d2735 3
a2737 7
      fhandler_socket *fh = get (fd);
      if (fh)
	{
	  res = check_iovec_for_write (msg->msg_iov, msg->msg_iovlen);
	  if (res >= 0)
	    res = fh->sendmsg (msg, flags);
	}
d2739 1
a2739 5
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
d3114 4
d3293 3
a3295 2
  int ret = 0;

d3306 31
a3336 24
  __try
    {
      if (hints && (hints->ai_flags
		    & ~(AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_ALL
			| AI_NUMERICSERV | AI_ADDRCONFIG | AI_V4MAPPED
			| AI_IDN_MASK)))
	return EAI_BADFLAGS;
      /* AI_NUMERICSERV is not supported prior to Windows Vista.  We just check
	 the servname parameter by ourselves here. */
      if (hints && (hints->ai_flags & AI_NUMERICSERV))
	{
	  char *p;
	  if (servname && *servname && (strtoul (servname, &p, 10), *p))
	    return EAI_NONAME;
	}

      int idn_flags = hints ? (hints->ai_flags & AI_IDN_MASK) : 0;
      const char *src;
      mbstate_t ps;
      tmp_pathbuf tp;
      wchar_t *whost = NULL, *wserv = NULL;
      struct addrinfoW whints, *wres;

      if (hostname)
d3338 5
a3342 4
	  memset (&ps, 0, sizeof ps);
	  src = hostname;
	  whost = tp.w_get ();
	  if (mbsrtowcs (whost, &src, NT_MAX_PATH, &ps) == (size_t) -1)
a3343 11
	  if (src)
	    return EAI_MEMORY;
	  if (idn_flags & AI_IDN)
	    {
	      /* Map flags to equivalent IDN_* flags. */
	      wchar_t *ascbuf = tp.w_get ();
	      if (IdnToAscii (idn_flags >> 16, whost, -1, ascbuf, NT_MAX_PATH))
		whost = ascbuf;
	      else if (GetLastError () != ERROR_PROC_NOT_FOUND)
		return EAI_IDN_ENCODE;
	    }
d3345 65
a3409 23
      if (servname)
	{
	  memset (&ps, 0, sizeof ps);
	  src = servname;
	  wserv = tp.w_get ();
	  if (mbsrtowcs (wserv, &src, NT_MAX_PATH, &ps) == (size_t) -1)
	    return EAI_IDN_ENCODE;
	  if (src)
	    return EAI_MEMORY;
	}

      if (!hints)
	{
	  /* Default settings per glibc man page. */
	  memset (&whints, 0, sizeof whints);
	  whints.ai_family = PF_UNSPEC;
	  whints.ai_flags = AI_V4MAPPED | AI_ADDRCONFIG;
	}
      else
	{
	  /* sizeof addrinfo == sizeof addrinfoW */
	  memcpy (&whints, hints, sizeof whints);
	  whints.ai_flags &= ~AI_IDN_MASK;
d3411 3
a3413 3
	  /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
	     Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
	  whints.ai_addrlen &= UINT32_MAX;
d3415 2
a3416 15
	  /* AI_ADDRCONFIG is not supported prior to Vista.  Rather it's
	     the default and only possible setting.
	     On Vista, the default behaviour is as if AI_ADDRCONFIG is set,
	     apparently for performance reasons.  To get the POSIX default
	     behaviour, the AI_ALL flag has to be set. */
	  if (wincap.supports_all_posix_ai_flags ()
	      && whints.ai_family == PF_UNSPEC
	      && !(whints.ai_flags & AI_ADDRCONFIG))
	    whints.ai_flags |= AI_ALL;
	}
      /* Disable automatic IDN conversion on W8 and later. */
      whints.ai_flags |= AI_DISABLE_IDN_ENCODING;
      ret = w32_to_gai_err (GetAddrInfoW (whost, wserv, &whints, &wres));
      /* Always copy over to self-allocated memory. */
      if (!ret)
d3418 1
a3418 1
	  *res = ga_duplist (wres, false, idn_flags, ret);
d3420 1
a3420 25
	  if (!*res)
	    __leave;
	}
      /* AI_V4MAPPED and AI_ALL are not supported prior to Vista.  So, what
	 we do here is to emulate AI_V4MAPPED.  If no IPv6 addresses are
	 returned, or the AI_ALL flag is set, we try with AF_INET again, and
	 convert the returned IPv4 addresses into v4-in-v6 entries.  This
	 is done in ga_dup if the v4mapped flag is set. */
      if (!wincap.supports_all_posix_ai_flags ()
	  && hints
	  && hints->ai_family == AF_INET6
	  && (hints->ai_flags & AI_V4MAPPED)
	  && (ret == EAI_NODATA || ret == EAI_NONAME
	      || (hints->ai_flags & AI_ALL)))
	{
	  /* sizeof addrinfo == sizeof addrinfoW */
	  memcpy (&whints, hints, sizeof whints);
	  whints.ai_family = AF_INET;
#ifdef __x86_64__
	  /* ai_addrlen is socklen_t (4 bytes) in POSIX but size_t (8 bytes) in
	     Winsock.  Sert upper 4 bytes explicitely to 0 to avoid EAI_FAIL. */
	  whints.ai_addrlen &= UINT32_MAX;
#endif
	  int ret2 = w32_to_gai_err (GetAddrInfoW (whost, wserv, &whints, &wres));
	  if (!ret2)
a3421 10
	      struct addrinfo *v4res = ga_duplist (wres, true, idn_flags, ret);
	      FreeAddrInfoW (wres);
	      if (!v4res)
		{
		  if (!ret)
		    cygwin_freeaddrinfo (*res);
		  __leave;
		}
	      /* If a list of v6 addresses exists, append the v4-in-v6 address
		 list.  Otherwise just return the v4-in-v6 address list. */
d3423 11
a3433 9
		{
		  struct addrinfo *ptr;
		  for (ptr = *res; ptr->ai_next; ptr = ptr->ai_next)
		    ;
		  ptr->ai_next = v4res;
		}
	      else
		*res = v4res;
	      ret = 0;
d3435 3
a3439 5
  __except (EFAULT)
    {
      ret = EAI_SYSTEM;
    }
  __endtry
d3448 13
a3460 1
  int ret = 0;
d3462 1
a3462 10
  __try
    {
      /* When the incoming port number does not resolve to a well-known service,
	 WinSock's getnameinfo up to Windows 2003 returns with error WSANO_DATA
	 instead of setting `serv' to the numeric port number string, as
	 required by RFC 3493.  This is fixed on Vista and later.  To avoid the
	 error on systems up to Windows 2003, we check if the port number
	 resolves to a well-known service.  If not, we set the NI_NUMERICSERV
	 flag. */
      if (!wincap.supports_all_posix_ai_flags ())
d3464 6
a3469 15
	  int port = 0;

	  switch (sa->sa_family)
	    {
	    case AF_INET:
	      port = ((struct sockaddr_in *) sa)->sin_port;
	      break;
	    case AF_INET6:
	      port = ((struct sockaddr_in6 *) sa)->sin6_port;
	      break;
	    default:
	      return EAI_FAMILY;
	    }
	  if (!port || !getservbyport (port, flags & NI_DGRAM ? "udp" : "tcp"))
	    flags |= NI_NUMERICSERV;
d3471 5
a3475 2
      /* We call GetNameInfoW with local buffers and convert to locale
	 charset to allow RFC 3490 IDNs like glibc 2.3.4 and later. */
d3479 5
a3483 5
      int idn_flags = flags & NI_IDN_MASK;
      flags &= ~NI_IDN_MASK;
      tmp_pathbuf tp;
      wchar_t *whost = NULL, *wserv = NULL;
      DWORD whlen = 0, wslen = 0;
d3485 10
a3494 10
      if (host && hostlen)
	{
	  whost = tp.w_get ();
	  whlen = NT_MAX_PATH;
	}
      if (serv && servlen)
	{
	  wserv = tp.w_get ();
	  wslen = NT_MAX_PATH;
	}
d3496 1
a3496 1
      ret = w32_to_gai_err (GetNameInfoW (sa, salen, whost, whlen,
d3498 5
a3502 1
      if (!ret)
d3504 1
a3504 3
	  const wchar_t *src;

	  if (whost)
d3506 6
a3511 12
	      if (idn_flags & NI_IDN)
		{
		  /* Map flags to equivalent IDN_* flags. */
		  wchar_t *idnbuf = tp.w_get ();
		  if (IdnToUnicode (idn_flags >> 16, whost, -1,
				    idnbuf, NT_MAX_PATH))
		    whost = idnbuf;
		  else if (GetLastError () != ERROR_PROC_NOT_FOUND)
		    return EAI_IDN_ENCODE;
		}
	      src = whost;
	      if (wcsrtombs (host, &src, hostlen, NULL) == (size_t) -1)
a3512 10
	      if (src)
		return EAI_OVERFLOW;
	    }
	  if (wserv)
	    {
	      src = wserv;
	      if (wcsrtombs (serv, &src, servlen, NULL) == (size_t) -1)
		return EAI_IDN_ENCODE;
	      if (src)
		return EAI_OVERFLOW;
d3514 13
a3527 6
      else if (ret == EAI_SYSTEM)
	set_winsock_errno ();
    }
  __except (EFAULT)
    {
      ret = EAI_SYSTEM;
d3529 2
a3530 1
  __endtry
@


1.310
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1010 1
a1010 1
      if (!GetComputerNameA (name, &local_len))
@


1.309
log
@	* net.cc (cygwin_getaddrinfo): Fix a comment.  Only memset whints if
	hints is NULL.  Add a comment and set whints.ai_family explicitely to
	AF_UNSPEC to follow glibc man page closely.  Check flags against whints
	for locality.
@
text
@a22 1
#include <winnls.h>
@


1.308
log
@	* autoload.cc (IdnToAscii): Define.
	(IdnToUnicode): Define.
	(FreeAddrInfoW): Define.
	(GetAddrInfoW): Define.
	(GetNameInfoW): Define.
	* net.cc: Drop W. Richard STEVENS libgai implementation.
	(cygwin_freeaddrinfo): Move code from ipv4_freeaddrinfo here.  Move
	definition up in file to avoid forward declaration in ga_duplist.
	(ga_dup): Take addrinfoW as input.  Add parameters to get IDN flags
	and to set error value.  Handle IDN flags and especially AI_CANONIDN.
	Convert input wchar_t ai_canonname string to multibyte for output.
	(ga_duplist): Add parameters to get IDN flags and to set error value
	and propagate to ga_dup.  Call cygwin_freeaddrinfo.
	(gai_errmap): Add comments.  Align error strings to GLibc.  Add
	EAI_IDN_ENCODE entry.
	(get_ipv6_funcs): Remove.
	(load_ipv6_guard): Remove.
	(ipv6_inited): Remove.
	(load_ipv6): Remove.
	(load_ipv6_funcs): Remove.
	(cygwin_getaddrinfo): Drop calling load_ipv6.  Handle AI_IDN* flags.
	Convert input strings to wchar_t and call GetAddrInfoW/FreeAddrInfoW.
	In case hints is NULL, set default ai_flags explicitely to
	AI_V4MAPPED | AI_ADDRCONFIG, as documented for Glibc.  Only add AI_ALL
	if AI_ADDRCONFIG is not given.  Unconditionally add Windows-specific
	AI_DISABLE_IDN_ENCODING to ai_flags to make IDN behaviour compatible
	to Glibc even on Windows 8 and later.
	(cygwin_getnameinfo): Drop calling load_ipv6.  Handle NI_IDN* flags.
	Call GetNameInfoW and convert returned strings from wchar_t to
	multibyte.
	* include/netdb.h: Add comments to describe flags and error values.
	(AI_*): Define all flags using hex values for clearness.
	(AI_IDN): Define.
	(AI_CANONIDN): Define.
	(AI_IDN_ALLOW_UNASSIGNED): Define.
	(AI_IDN_USE_STD3_ASCII_RULES): Define.
	(NI_*): Define all flags using hex values for clearness.
	(NI_IDN): Define.
	(NI_IDN_ALLOW_UNASSIGNED): Define.
	(NI_IDN_USE_STD3_ASCII_RULES): Define.
	(EAI_IDN_ENCODE): Define.
@
text
@d3297 2
a3298 3
  /* AI_NUMERICSERV is not supported in our replacement getaddrinfo, nor
     is it supported by WinSock prior to Vista.  We just check the servname
     parameter by ourselves here. */
a3342 1
  memset (&whints, 0, sizeof whints);
d3344 6
a3349 1
    whints.ai_flags = AI_V4MAPPED | AI_ADDRCONFIG;
d3361 2
a3362 2
	  && hints->ai_family == PF_UNSPEC
	  && !(hints->ai_flags & AI_ADDRCONFIG))
@


1.307
log
@	* devices.in (dev_storage): Map /dev/zero and /dev/full to \Device\Null.
	* devices.cc: Regenerate.
	* dtable.h (struct dtable): Make fhandler_base friend, rather
	than fhandler_disk_file.
	* fhandler.cc (fhandler_base::open_with_arch): Create unique id.
	(fhandler_base::cleanup): Call del_my_locks.
	(fhandler_base::fcntl): Handle F_GETLK, F_SETLK and F_SETLKW.
	* fhandler.h (fhandler_base::get_dev): Return real device number.
	(fhandler_base::set_unique_id): New inline method.
	(fhandler_disk_file::lock): Drop declaration.
	(fhandler_disk_file::get_dev): New method, return pc.fs_serial_number.
	(fhandler_dev_zero::open): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Move
	del_my_locks call to fhandler_base::open_with_arch.
	(fhandler_disk_file::fcntl): Move handling of locking commands to
	fhandler_base::fcntl.
	(fhandler_base::open_fs): Drop call to NtAllocateLocallyUniqueId.
	* fhandler_zero.cc (fhandler_dev_zero::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	* flock.cc (fixup_lockf_after_exec): Finding a single fhandler is
	enough here.
	(fhandler_base::lock): Replace fhandler_disk_file::lock.  Refuse to lock
	nohandle devices.  Handle read/write test using POSIX flags.  Explain
	why.  Never fail on SEEK_CUR or SEEK_END, rather assume position 0,
	just as Linux.
	* net.cc (fdsock): Create unique id.
@
text
@d23 1
d3095 2
a3096 23
/* W. Richard STEVENS libgai implementation, slightly tweaked for inclusion
   into Cygwin as pure IPv4 replacement.  Please note that the code is
   kept intact as much as possible.  Especially the IPv6 and AF_UNIX code
   is kept in, even though we can support neither of them.  Please don't
   activate them, they won't work correctly. */

#define IPv4
#undef IPv6
#undef UNIXdomain

#undef HAVE_SOCKADDR_SA_LEN
#define gethostbyname2(host,family) cygwin_gethostbyname((host))

#define AI_CLONE 0x8000		/* Avoid collision with AI_ values in netdb.h */

/*
 * Create and fill in an addrinfo{}.
 */

/* include ga_aistruct1 */
static int
ga_aistruct (struct addrinfo ***paipnext, const struct addrinfo *hintsp,
	     const void *addr, int family)
d3098 1
a3098 1
  struct addrinfo *ai;
d3100 3
a3102 6
  if ((ai = (struct addrinfo *) calloc (1, sizeof (struct addrinfo))) == NULL)
    return (EAI_MEMORY);
  ai->ai_next = NULL;
  ai->ai_canonname = NULL;
  **paipnext = ai;
  *paipnext = &ai->ai_next;
d3104 1
a3104 8
  if ((ai->ai_socktype = hintsp->ai_socktype) == 0)
    ai->ai_flags |= AI_CLONE;

  ai->ai_protocol = hintsp->ai_protocol;
/* end ga_aistruct1 */

/* include ga_aistruct2 */
  switch ((ai->ai_family = family))
d3106 2
a3107 4
#ifdef	IPv4
    case AF_INET:
      {
	struct sockaddr_in *sinptr;
d3109 2
a3110 18
	/* 4allocate sockaddr_in{} and fill in all but port */
	if ((sinptr = (struct sockaddr_in *)
		      calloc (1, sizeof (struct sockaddr_in))) == NULL)
	  return (EAI_MEMORY);
#ifdef	HAVE_SOCKADDR_SA_LEN
	sinptr->sin_len = sizeof (struct sockaddr_in);
#endif
	sinptr->sin_family = AF_INET;
	memcpy (&sinptr->sin_addr, addr, sizeof (struct in_addr));
	ai->ai_addr = (struct sockaddr *) sinptr;
	ai->ai_addrlen = sizeof (struct sockaddr_in);
	break;
      }
#endif /* IPV4 */
#ifdef	IPv6
    case AF_INET6:
      {
	struct sockaddr_in6 *sin6ptr;
d3112 2
a3113 37
	/* 4allocate sockaddr_in6{} and fill in all but port */
	if ((sin6ptr = calloc (1, sizeof (struct sockaddr_in6))) == NULL)
	  return (EAI_MEMORY);
#ifdef	HAVE_SOCKADDR_SA_LEN
	sin6ptr->sin6_len = sizeof (struct sockaddr_in6);
#endif
	sin6ptr->sin6_family = AF_INET6;
	memcpy (&sin6ptr->sin6_addr, addr, sizeof (struct in6_addr));
	ai->ai_addr = (struct sockaddr *) sin6ptr;
	ai->ai_addrlen = sizeof (struct sockaddr_in6);
	break;
      }
#endif /* IPV6 */
#ifdef	UNIXdomain
    case AF_LOCAL:
      {
	struct sockaddr_un *unp;

	/* 4allocate sockaddr_un{} and fill in */
/* *INDENT-OFF* */
			if (strlen(addr) >= sizeof(unp->sun_path))
				return(EAI_SERVICE);
			if ( (unp = calloc(1, sizeof(struct sockaddr_un))) == NULL)
				return(EAI_MEMORY);
/* *INDENT-ON* */
	unp->sun_family = AF_LOCAL;
	strcpy (unp->sun_path, addr);
#ifdef	HAVE_SOCKADDR_SA_LEN
	unp->sun_len = SUN_LEN (unp);
#endif
	ai->ai_addr = (struct sockaddr *) unp;
	ai->ai_addrlen = sizeof (struct sockaddr_un);
	if (hintsp->ai_flags & AI_PASSIVE)
	  unlink (unp->sun_path);	/* OK if this fails */
	break;
      }
#endif /* UNIXDOMAIN */
a3114 1
  return (0);
a3116 13
/* end ga_aistruct2 */

/*
 * Clone a new addrinfo structure from an existing one.
 */

/* include ga_clone */

/* Cygwin specific: The ga_clone function is split up to allow an easy
   duplication of addrinfo structs.  This is used to duplicate the
   structures from WinSock, so that we have the allocation of the structs
   returned to the application under control.  This is especially helpful
   for the AI_V4MAPPED case prior to Vista. */
d3118 1
a3118 1
ga_dup (struct addrinfo *ai, bool v4mapped)
d3123 4
a3126 1
    return (NULL);
a3127 1
  nai->ai_flags = 0;		/* make sure AI_CLONE is off */
d3131 1
a3131 3
  nai->ai_canonname = NULL;
  if (!(ai->ai_flags & AI_CLONE) && ai->ai_canonname
      && !(nai->ai_canonname = strdup (ai->ai_canonname)))
d3133 32
a3164 2
      free (nai);
      return NULL;
d3166 1
d3175 1
d3197 1
a3197 1
ga_clone (struct addrinfo *ai)
a3198 14
  struct addrinfo *nai;

  if ((nai = ga_dup (ai, false)))
    {
      nai->ai_next = ai->ai_next;
      ai->ai_next = nai;
    }
  return nai;
}

static struct addrinfo *
ga_duplist (struct addrinfo *ai, bool v4mapped)
{
  void ipv4_freeaddrinfo (struct addrinfo *aihead);
d3203 1
a3203 1
      if (!(tmp = ga_dup (ai, v4mapped)))
d3213 1
a3213 1
  ipv4_freeaddrinfo (nai0);
d3217 2
a3218 708
/* end ga_clone */

/*
 * Basic error checking of flags, family, socket type, and protocol.
 */

/* include ga_echeck */
static int
ga_echeck (const char *hostname, const char *servname,
	   int flags, int family, int socktype, int protocol)
{
#if 0
  if (flags & ~(AI_PASSIVE | AI_CANONNAME))
    return (EAI_BADFLAGS);	/* unknown flag bits */
#endif
  if (hostname == NULL || hostname[0] == '\0')
    {
      if (servname == NULL || servname[0] == '\0')
	return (EAI_NONAME);	/* host or service must be specified */
    }

  switch (family)
    {
    case AF_UNSPEC:
      break;
#ifdef	IPv4
    case AF_INET:
      if (socktype != 0 &&
	  (socktype != SOCK_STREAM &&
	   socktype != SOCK_DGRAM && socktype != SOCK_RAW))
	return (EAI_SOCKTYPE);	/* invalid socket type */
      break;
#endif
#ifdef	IPv6
    case AF_INET6:
      if (socktype != 0 &&
	  (socktype != SOCK_STREAM &&
	   socktype != SOCK_DGRAM && socktype != SOCK_RAW))
	return (EAI_SOCKTYPE);	/* invalid socket type */
      break;
#endif
#ifdef	UNIXdomain
    case AF_LOCAL:
      if (socktype != 0 &&
	  (socktype != SOCK_STREAM && socktype != SOCK_DGRAM))
	return (EAI_SOCKTYPE);	/* invalid socket type */
      break;
#endif
    default:
      return (EAI_FAMILY);	/* unknown protocol family */
    }
  return (0);
}

/* end ga_echeck */

struct search {
  const char *host;  /* hostname or address string */
  int        family; /* AF_xxx */
};

/*
 * Set up the search[] array with the hostnames and address families
 * that we are to look up.
 */

/* include ga_nsearch1 */
static int
ga_nsearch (const char *hostname, const struct addrinfo *hintsp,
	    struct search *search)
{
  int nsearch = 0;

  if (hostname == NULL || hostname[0] == '\0')
    {
      if (hintsp->ai_flags & AI_PASSIVE)
	{
	  /* 4no hostname and AI_PASSIVE: implies wildcard bind */
	  switch (hintsp->ai_family)
	    {
#ifdef	IPv4
	    case AF_INET:
	      search[nsearch].host = "0.0.0.0";
	      search[nsearch].family = AF_INET;
	      nsearch++;
	      break;
#endif
#ifdef	IPv6
	    case AF_INET6:
	      search[nsearch].host = "0::0";
	      search[nsearch].family = AF_INET6;
	      nsearch++;
	      break;
#endif
	    case AF_UNSPEC:
#ifdef	IPv6
	      search[nsearch].host = "0::0";	/* IPv6 first, then IPv4 */
	      search[nsearch].family = AF_INET6;
	      nsearch++;
#endif
#ifdef	IPv4
	      search[nsearch].host = "0.0.0.0";
	      search[nsearch].family = AF_INET;
	      nsearch++;
#endif
	      break;
	    }
/* end ga_nsearch1 */
/* include ga_nsearch2 */
	}
      else
	{
	  /* 4no host and not AI_PASSIVE: connect to local host */
	  switch (hintsp->ai_family)
	    {
#ifdef	IPv4
	    case AF_INET:
	      search[nsearch].host = "localhost";	/* 127.0.0.1 */
	      search[nsearch].family = AF_INET;
	      nsearch++;
	      break;
#endif
#ifdef	IPv6
	    case AF_INET6:
	      search[nsearch].host = "0::1";
	      search[nsearch].family = AF_INET6;
	      nsearch++;
	      break;
#endif
	    case AF_UNSPEC:
#ifdef	IPv6
	      search[nsearch].host = "0::1";	/* IPv6 first, then IPv4 */
	      search[nsearch].family = AF_INET6;
	      nsearch++;
#endif
#ifdef	IPv4
	      search[nsearch].host = "localhost";
	      search[nsearch].family = AF_INET;
	      nsearch++;
#endif
	      break;
	    }
	}
/* end ga_nsearch2 */
/* include ga_nsearch3 */
    }
  else
    {				/* host is specified */
      switch (hintsp->ai_family)
	{
#ifdef	IPv4
	case AF_INET:
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET;
	  nsearch++;
	  break;
#endif
#ifdef	IPv6
	case AF_INET6:
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET6;
	  nsearch++;
	  break;
#endif
	case AF_UNSPEC:
#ifdef	IPv6
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET6;	/* IPv6 first */
	  nsearch++;
#endif
#ifdef	IPv4
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET;	/* then IPv4 */
	  nsearch++;
#endif
	  break;
	}
    }
  if (nsearch < 1 || nsearch > 2)
    return -1;
  return (nsearch);
}

/* end ga_nsearch3 */

/*
 * Go through all the addrinfo structures, checking for a match of the
 * socket type and filling in the socket type, and then the port number
 * in the corresponding socket address structures.
 *
 * The AI_CLONE flag works as follows.  Consider a multihomed host with
 * two IP addresses and no socket type specified by the caller.  After
 * the "host" search there are two addrinfo structures, one per IP address.
 * Assuming a service supported by both TCP and UDP (say the daytime
 * service) we need to return *four* addrinfo structures:
 *		IP#1, SOCK_STREAM, TCP port,
 *		IP#1, SOCK_DGRAM, UDP port,
 *		IP#2, SOCK_STREAM, TCP port,
 *		IP#2, SOCK_DGRAM, UDP port.
 * To do this, when the "host" loop creates an addrinfo structure, if the
 * caller has not specified a socket type (hintsp->ai_socktype == 0), the
 * AI_CLONE flag is set.  When the following function finds an entry like
 * this it is handled as follows: If the entry's ai_socktype is still 0,
 * this is the first use of the structure, and the ai_socktype field is set.
 * But, if the entry's ai_socktype is nonzero, then we clone a new addrinfo
 * structure and set it's ai_socktype to the new value.  Although we only
 * need two socket types today (SOCK_STREAM and SOCK_DGRAM) this algorithm
 * will handle any number.  Also notice that Posix.1g requires all socket
 * types to be nonzero.
 */

/* include ga_port */
static int
ga_port (struct addrinfo *aihead, int port, int socktype)
		/* port must be in network byte order */
{
  int nfound = 0;
  struct addrinfo *ai;

  for (ai = aihead; ai != NULL; ai = ai->ai_next)
    {
      if (ai->ai_flags & AI_CLONE)
	{
	  if (ai->ai_socktype != 0)
	    {
	      if ((ai = ga_clone (ai)) == NULL)
		return (-1);	/* memory allocation error */
	      /* ai points to newly cloned entry, which is what we want */
	    }
	}
      else if (ai->ai_socktype != socktype)
	continue;		/* ignore if mismatch on socket type */

      ai->ai_socktype = socktype;

      switch (ai->ai_family)
	{
#ifdef	IPv4
	case AF_INET:
	  ((struct sockaddr_in *) ai->ai_addr)->sin_port = port;
	  nfound++;
	  break;
#endif
#ifdef	IPv6
	case AF_INET6:
	  ((struct sockaddr_in6 *) ai->ai_addr)->sin6_port = port;
	  nfound++;
	  break;
#endif
	}
    }
  return (nfound);
}

/* end ga_port */

/*
 * This function handles the service string.
 */

/* include ga_serv */
static int
ga_serv (struct addrinfo *aihead, const struct addrinfo *hintsp,
	 const char *serv)
{
  int port, rc, nfound;
  struct servent *sptr;

  nfound = 0;
  if (isdigit (serv[0]))
    {				/* check for port number string first */
      port = htons (atoi (serv));
      if (hintsp->ai_socktype)
	{
	  /* 4caller specifies socket type */
	  if ((rc = ga_port (aihead, port, hintsp->ai_socktype)) < 0)
	    return (EAI_MEMORY);
	  nfound += rc;
	}
      else
	{
	  /* 4caller does not specify socket type */
	  if ((rc = ga_port (aihead, port, SOCK_STREAM)) < 0)
	    return (EAI_MEMORY);
	  nfound += rc;
	  if ((rc = ga_port (aihead, port, SOCK_DGRAM)) < 0)
	    return (EAI_MEMORY);
	  nfound += rc;
	}
    }
  else
    {
      /* 4try service name, TCP then UDP */
      if (hintsp->ai_socktype == 0 || hintsp->ai_socktype == SOCK_STREAM)
	{
	  if ((sptr = cygwin_getservbyname (serv, "tcp")) != NULL)
	    {
	      if ((rc = ga_port (aihead, sptr->s_port, SOCK_STREAM)) < 0)
		return (EAI_MEMORY);
	      nfound += rc;
	    }
	}
      if (hintsp->ai_socktype == 0 || hintsp->ai_socktype == SOCK_DGRAM)
	{
	  if ((sptr = cygwin_getservbyname (serv, "udp")) != NULL)
	    {
	      if ((rc = ga_port (aihead, sptr->s_port, SOCK_DGRAM)) < 0)
		return (EAI_MEMORY);
	      nfound += rc;
	    }
	}
    }

  if (nfound == 0)
    {
      if (hintsp->ai_socktype == 0)
	return (EAI_NONAME);	/* all calls to getservbyname() failed */
      else
	return (EAI_SERVICE);	/* service not supported for socket type */
    }
  return (0);
}

/* end ga_serv */

#ifdef	UNIXdomain
/* include ga_unix */
static int
ga_unix (const char *path, struct addrinfo *hintsp, struct addrinfo **result)
{
  int rc;
  struct addrinfo *aihead, **aipnext;

  aihead = NULL;
  aipnext = &aihead;

  if (hintsp->ai_family != AF_UNSPEC && hintsp->ai_family != AF_LOCAL)
    return (EAI_ADDRFAMILY);

  if (hintsp->ai_socktype == 0)
    {
      /* 4no socket type specified: return stream then dgram */
      hintsp->ai_socktype = SOCK_STREAM;
      if ((rc = ga_aistruct (&aipnext, hintsp, path, AF_LOCAL)) != 0)
	return (rc);
      hintsp->ai_socktype = SOCK_DGRAM;
    }

  if ((rc = ga_aistruct (&aipnext, hintsp, path, AF_LOCAL)) != 0)
    return (rc);

  if (hintsp->ai_flags & AI_CANONNAME)
    {
      struct utsname myname;

      if (uname (&myname) < 0)
	return (EAI_SYSTEM);
      if ((aihead->ai_canonname = strdup (myname.nodename)) == NULL)
	return (EAI_MEMORY);
    }

  *result = aihead;		/* pointer to first structure in linked list */
  return (0);
}

/* end ga_unix */
#endif /* UNIXdomain */

/* include gn_ipv46 */
static int
gn_ipv46 (char *host, size_t hostlen, char *serv, size_t servlen,
	  void *aptr, size_t alen, int family, int port, int flags)
{
  char *ptr;
  struct hostent *hptr;
  struct servent *sptr;

  if (host && hostlen > 0)
    {
      if (flags & NI_NUMERICHOST)
	{
	  if (cygwin_inet_ntop (family, aptr, host, hostlen) == NULL)
	    return (1);
	}
      else
	{
	  hptr = cygwin_gethostbyaddr ((const char *) aptr, alen, family);
	  if (hptr != NULL && hptr->h_name != NULL)
	    {
	      if (flags & NI_NOFQDN)
		{
		  if ((ptr = strchr (hptr->h_name, '.')) != NULL)
		    *ptr = 0;	/* overwrite first dot */
		}
	      //snprintf (host, hostlen, "%s", hptr->h_name);
	      *host = '\0';
	      strncat (host, hptr->h_name, hostlen - 1);
	    }
	  else
	    {
	      if (flags & NI_NAMEREQD)
		return (1);
	      if (cygwin_inet_ntop (family, aptr, host, hostlen) == NULL)
		return (1);
	    }
	}
    }

  if (serv && servlen > 0)
    {
      if (flags & NI_NUMERICSERV)
	{
	  //snprintf (serv, servlen, "%d", ntohs (port));
	  char buf[32];
	  __small_sprintf (buf, "%d", ntohs (port));
	  *serv = '\0';
	  strncat (serv, buf, servlen - 1);
	}
      else
	{
	  sptr = cygwin_getservbyport (port, (flags & NI_DGRAM) ? "udp" : NULL);
	  if (sptr != NULL && sptr->s_name != NULL)
	    {
	      //snprintf (serv, servlen, "%s", sptr->s_name);
	      *serv = '\0';
	      strncat (serv, sptr->s_name, servlen - 1);
	    }
	  else
	    {
	      //snprintf (serv, servlen, "%d", ntohs (port));
	      char buf[32];
	      __small_sprintf (buf, "%d", ntohs (port));
	      *serv = '\0';
	      strncat (serv, buf, servlen - 1);
	    }
	}
    }
  return (0);
}

/* end gn_ipv46 */

/* include freeaddrinfo */
void
ipv4_freeaddrinfo (struct addrinfo *aihead)
{
  struct addrinfo *ai, *ainext;

  for (ai = aihead; ai != NULL; ai = ainext)
    {
      if (ai->ai_addr != NULL)
	free (ai->ai_addr);	/* socket address structure */

      if (ai->ai_canonname != NULL)
	free (ai->ai_canonname);

      ainext = ai->ai_next;	/* can't fetch ai_next after free() */
      free (ai);		/* the addrinfo{} itself */
    }
}

/* end freeaddrinfo */

/* include ga1 */

int
ipv4_getaddrinfo (const char *hostname, const char *servname,
		  const struct addrinfo *hintsp, struct addrinfo **result)
{
  int rc, error, nsearch;
  char **ap, *canon;
  struct hostent *hptr;
  struct search search[3], *sptr;
  struct addrinfo hints, *aihead, **aipnext;

  /*
   * If we encounter an error we want to free() any dynamic memory
   * that we've allocated.  This is our hack to simplify the code.
   */
#define	error(e) { error = (e); goto bad; }

  aihead = NULL;		/* initialize automatic variables */
  aipnext = &aihead;
  canon = NULL;

  if (hintsp == NULL)
    {
      bzero (&hints, sizeof (hints));
      hints.ai_family = AF_UNSPEC;
    }
  else
    hints = *hintsp;		/* struct copy */

  /* 4first some basic error checking */
  if ((rc = ga_echeck (hostname, servname, hints.ai_flags, hints.ai_family,
		       hints.ai_socktype, hints.ai_protocol)) != 0)
    error (rc);

#ifdef	UNIXdomain
  /* 4special case Unix domain first */
  if (hostname != NULL &&
      (strcmp (hostname, "/local") == 0 || strcmp (hostname, "/unix") == 0) &&
      (servname != NULL && servname[0] == '/'))
    return (ga_unix (servname, &hints, result));
#endif
/* end ga1 */

/* include ga3 */
  /* 4remainder of function for IPv4/IPv6 */
  nsearch = ga_nsearch (hostname, &hints, &search[0]);
  if (nsearch == -1)
    error (EAI_FAMILY);
  for (sptr = &search[0]; sptr < &search[nsearch]; sptr++)
    {
#ifdef	IPv4
      /* 4check for an IPv4 dotted-decimal string */
      if (isdigit (sptr->host[0]))
	{
	  struct in_addr inaddr;

	  if (inet_pton4 (sptr->host, (u_char *) &inaddr) == 1)
	    {
	      if (hints.ai_family != AF_UNSPEC && hints.ai_family != AF_INET)
		error (EAI_ADDRFAMILY);
	      if (sptr->family != AF_INET)
		continue;	/* ignore */
	      rc = ga_aistruct (&aipnext, &hints, &inaddr, AF_INET);
	      if (rc != 0)
		error (rc);
	      continue;
	    }
	}
#endif

#ifdef	IPv6
      /* 4check for an IPv6 hex string */
      if ((isxdigit (sptr->host[0]) || sptr->host[0] == ':') &&
	  (strchr (sptr->host, ':') != NULL))
	{
	  struct in6_addr in6addr;

	  if (inet_pton6 (sptr->host, &in6addr) == 1)
	    {
	      if (hints.ai_family != AF_UNSPEC && hints.ai_family != AF_INET6)
		error (EAI_ADDRFAMILY);
	      if (sptr->family != AF_INET6)
		continue;	/* ignore */
	      rc = ga_aistruct (&aipnext, &hints, &in6addr, AF_INET6);
	      if (rc != 0)
		error (rc);
	      continue;
	    }
	}
#endif
/* end ga3 */
/* include ga4 */
#ifdef	IPv6
      /* 4remainder of for() to look up hostname */
      if ((_res.options & RES_INIT) == 0)
	res_init ();		/* need this to set _res.options */
#endif

      if (nsearch == 2)
	{
#ifdef	IPv6
	  _res.options &= ~RES_USE_INET6;
#endif
	  hptr = gethostbyname2 (sptr->host, sptr->family);
	}
      else
	{
#ifdef  IPv6
	  if (sptr->family == AF_INET6)
	    _res.options |= RES_USE_INET6;
	  else
	    _res.options &= ~RES_USE_INET6;
#endif
	  hptr = gethostbyname (sptr->host);
	}
      if (hptr == NULL)
	{
	  if (nsearch == 2)
	    continue;		/* failure OK if multiple searches */

	  switch (h_errno)
	    {
	    case HOST_NOT_FOUND:
	      error (EAI_NONAME);
	    case TRY_AGAIN:
	      error (EAI_AGAIN);
	    case NO_RECOVERY:
	      error (EAI_FAIL);
	    case NO_DATA:
	      error (EAI_NODATA);
	    default:
	      error (EAI_NONAME);
	    }
	}

      /* 4check for address family mismatch if one specified */
      if (hints.ai_family != AF_UNSPEC && hints.ai_family != hptr->h_addrtype)
	error (EAI_ADDRFAMILY);

      /* 4save canonical name first time */
      if (hostname != NULL && hostname[0] != '\0' &&
	  (hints.ai_flags & AI_CANONNAME) && canon == NULL)
	{
	  if ((canon = strdup (hptr->h_name)) == NULL)
	    error (EAI_MEMORY);
	}

      /* 4create one addrinfo{} for each returned address */
      for (ap = hptr->h_addr_list; *ap != NULL; ap++)
	{
	  rc = ga_aistruct (&aipnext, &hints, *ap, hptr->h_addrtype);
	  if (rc != 0)
	    error (rc);
	}
    }
  if (aihead == NULL)
    error (EAI_NONAME);		/* nothing found */
/* end ga4 */

/* include ga5 */
  /* 4return canonical name */
  if (hostname != NULL && hostname[0] != '\0' &&
      hints.ai_flags & AI_CANONNAME)
    {
      if (canon != NULL)
	aihead->ai_canonname = canon;	/* strdup'ed earlier */
      else
	{
	  if ((aihead->ai_canonname = strdup (search[0].host)) == NULL)
	    error (EAI_MEMORY);
	}
    }

  /* 4now process the service name */
  if (servname != NULL && servname[0] != '\0')
    {
      if ((rc = ga_serv (aihead, &hints, servname)) != 0)
	error (rc);
    }

  *result = aihead;		/* pointer to first structure in linked list */
  return (0);

bad:
  ipv4_freeaddrinfo (aihead);	/* free any alloc'ed memory */
  return (error);
}

/* end ga5 */

/* include getnameinfo */
int
ipv4_getnameinfo (const struct sockaddr *sa, socklen_t salen,
		  char *host, size_t hostlen,
		  char *serv, size_t servlen, int flags)
{

  switch (sa->sa_family)
    {
#ifdef	IPv4
    case AF_INET:
      {
	struct sockaddr_in *sain = (struct sockaddr_in *) sa;

	return (gn_ipv46 (host, hostlen, serv, servlen,
			  &sain->sin_addr, sizeof (struct in_addr),
			  AF_INET, sain->sin_port, flags));
      }
#endif

#ifdef	IPv6
    case AF_INET6:
      {
	struct sockaddr_in6 *sain = (struct sockaddr_in6 *) sa;

	return (gn_ipv46 (host, hostlen, serv, servlen,
			  &sain->sin6_addr, sizeof (struct in6_addr),
			  AF_INET6, sain->sin6_port, flags));
      }
#endif

#ifdef	UNIXdomain
    case AF_LOCAL:
      {
	struct sockaddr_un *un = (struct sockaddr_un *) sa;

	if (hostlen > 0)
	  snprintf (host, hostlen, "%s", "/local");
	if (servlen > 0)
	  snprintf (serv, servlen, "%s", un->sun_path);
	return (0);
      }
#endif

    default:
      return (EAI_FAMILY);
    }
}

/* end getnameinfo */

/* Start of cygwin specific wrappers around the gai functions. */

struct gai_errmap_t
d3222 1
a3222 3
};

static gai_errmap_t gai_errmap[] =
d3225 1
d3227 1
d3229 3
a3231 1
  {WSAEINVAL,		  "Invalid value for ai_flags"},
d3233 1
d3235 1
d3237 1
d3239 5
a3243 2
  {WSAHOST_NOT_FOUND,	  "hostname nor servname provided, or not known"},
  {WSATYPE_NOT_FOUND,	  "servname not supported for ai_socktype"},
d3245 5
a3249 2
  {0,			  "System error returned in errno"},
  {0,			  "Invalid value for hints"},
d3251 4
a3254 1
  {WSAEFAULT,		  "An argument buffer overflowed"}
a3274 67
/* We can't use autoload here because we don't know if the functions
   are available (pre-Vista).  For those systems we redirect to the
   ipv4-only version above. */

static void (WINAPI *ws_freeaddrinfo)(const struct addrinfo *);
static int (WINAPI *ws_getaddrinfo)(const char *, const char *,
				    const struct addrinfo *,
				    struct addrinfo **);
static int (WINAPI *ws_getnameinfo)(const struct sockaddr *, socklen_t,
				    char *, size_t, char *, size_t, int);
static bool
get_ipv6_funcs (HMODULE lib)
{
  return ((ws_freeaddrinfo = (void (WINAPI *)(const struct addrinfo *))
			  GetProcAddress (lib, "freeaddrinfo"))
	  && (ws_getaddrinfo = (int (WINAPI *)(const char *, const char *,
					       const struct addrinfo *,
					       struct addrinfo **))
			    GetProcAddress (lib, "getaddrinfo"))
	  && (ws_getnameinfo = (int (WINAPI *)(const struct sockaddr *,
					       socklen_t, char *, size_t,
					       char *, size_t, int))
			    GetProcAddress (lib, "getnameinfo")));
}

static NO_COPY muto load_ipv6_guard;
static NO_COPY bool ipv6_inited = false;
#define load_ipv6()	if (!ipv6_inited) load_ipv6_funcs ();

static void
load_ipv6_funcs ()
{
  tmp_pathbuf tp;
  PWCHAR lib_path = tp.w_get ();
  PWCHAR lib_name;
  HMODULE lib;

  load_ipv6_guard.init ("klog_guard")->acquire ();
  if (ipv6_inited)
    goto out;
  WSAGetLastError ();	/* Kludge.  Enforce WSAStartup call. */
  lib_name = wcpcpy (lib_path, windows_system_directory);
  wcpcpy (lib_name, L"ws2_32.dll");
  if ((lib = LoadLibraryW (lib_path)))
    {
      if (get_ipv6_funcs (lib))
	goto out;
      FreeLibrary (lib);
    }
  ws_freeaddrinfo = NULL;
  ws_getaddrinfo = NULL;
  ws_getnameinfo = NULL;

out:
  ipv6_inited = true;
  load_ipv6_guard.release ();
}

extern "C" void
cygwin_freeaddrinfo (struct addrinfo *addr)
{
  myfault efault;
  if (efault.faulted (EFAULT))
    return;
  ipv4_freeaddrinfo (addr);
}

d3282 10
a3291 3
  /* Both subsequent getaddrinfo implementations let all possible values
     in ai_flags slip through and just ignore unknowen values.  So we have
     to check manually here. */
d3294 2
a3295 1
		    | AI_NUMERICSERV | AI_ADDRCONFIG | AI_V4MAPPED)))
d3306 36
a3341 17
  load_ipv6 ();
  if (!ws_getaddrinfo)
    return ipv4_getaddrinfo (hostname, servname, hints, res);

  struct addrinfo nhints, *dupres;

  /* AI_ADDRCONFIG is not supported prior to Vista.  Rather it's
     the default and only possible setting.
     On Vista, the default behaviour is as if AI_ADDRCONFIG is set,
     apparently for performance reasons.  To get the POSIX default
     behaviour, the AI_ALL flag has to be set. */
  if (wincap.supports_all_posix_ai_flags ()
      && hints && hints->ai_family == PF_UNSPEC)
    {
      nhints = *hints;
      hints = &nhints;
      nhints.ai_flags |= AI_ALL;
d3343 22
a3364 1
  int ret = w32_to_gai_err (ws_getaddrinfo (hostname, servname, hints, res));
d3368 4
a3371 5
      dupres = ga_duplist (*res, false);
      ws_freeaddrinfo (*res);
      *res = dupres;
      if (!dupres)
	return EAI_MEMORY;
d3385 4
a3388 5
      struct addrinfo *v4res;
      nhints = *hints;
      nhints.ai_family = AF_INET;
      int ret2 = w32_to_gai_err (ws_getaddrinfo (hostname, servname,
						 &nhints, &v4res));
d3391 3
a3393 3
	  dupres = ga_duplist (v4res, true);
	  ws_freeaddrinfo (v4res);
	  if (!dupres)
d3396 2
a3397 2
		ipv4_freeaddrinfo (*res);
	      return EAI_MEMORY;
d3406 1
a3406 1
	      ptr->ai_next = dupres;
d3409 1
a3409 1
	    *res = dupres;
a3423 3
  load_ipv6 ();
  if (!ws_getnameinfo)
    return ipv4_getnameinfo (sa, salen, host, hostlen, serv, servlen, flags);
d3447 56
a3502 3
  int ret = w32_to_gai_err (ws_getnameinfo (sa, salen, host, hostlen, serv,
					    servlen, flags));
  if (ret)
@


1.306
log
@	* net.cc (gen_old_if_name): New function to generate short interface
	names for old pre-1.7 applications.
	(get_ifs): Call gen_old_if_name for said old applications.
@
text
@d639 5
@


1.305
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1904 45
d1989 4
a1992 1
	    if (idx)
d2036 3
a2038 1
	    if (sa->sa_family == AF_INET && idx)
@


1.304
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d160 1
a160 1
static NO_COPY struct tl errmap[] = {
d222 1
a222 1
  syscall_printf ("%s:%d - winsock error %d -> errno %d", fn, ln, werr, err);
d229 1
a229 1
static NO_COPY struct tl host_errmap[] = {
d308 16
d388 2
a389 2
      if (src->s_proto)
	sz += (protolen = strlen_round (src->s_proto));
d411 6
a416 2
	 in each, of course.  */
      dst->port_proto_addrtype = src->port_proto_addrtype;
d443 1
a443 1
	debug_printf ("protoent %s %x %x", dst->name, dst->list, dst->port_proto_addrtype);
d446 1
a446 1
	  if (src->s_proto)
d448 1
a448 1
	      strcpy (dst->s_proto = dp, src->s_proto);
d557 1
a557 1
	debug_printf ("WSAIoctl: %lu", WSAGetLastError ());
d608 4
d613 4
d619 1
d623 1
a623 1
      debug_printf ("setsockopt(SO_RCVBUF) failed, %lu", WSAGetLastError ());
d627 1
a627 1
	system_printf ("getsockopt(SO_RCVBUF) failed, %lu", WSAGetLastError ());
d632 1
a632 1
      debug_printf ("setsockopt(SO_SNDBUF) failed, %lu", WSAGetLastError ());
d636 1
a636 1
	system_printf ("getsockopt(SO_SNDBUF) failed, %lu", WSAGetLastError ());
d652 1
a652 1
  debug_printf ("socket (%d, %d (flags %p), %d)", af, type, flags, protocol);
d702 1
a702 1
	      debug_printf ("Reset SIO_UDP_CONNRESET: WinSock error %lu",
d710 1
a710 1
  syscall_printf ("%R = socket(%d, %d (flags %p), %d)",
d716 1
a716 1
extern "C" int
d720 3
a722 1
  int res;
d732 1
a732 1
  syscall_printf ("%R = sendto(%d, %p, %d, %x, %p, %d)",
d738 1
a738 1
extern "C" int
d742 3
a744 1
  int res;
d758 1
a758 1
  syscall_printf ("%R = recvfrom(%d, %p, %d, %x, %p, %p)",
d822 2
a823 2
      if (optlen == 4)
	syscall_printf ("setsockopt optval=%x", *(long *) optval);
d873 1
a873 1
  syscall_printf ("%R = setsockopt(%d, %d, %x, %p, %d)",
d933 1
a933 1
  syscall_printf ("%R = getsockopt(%d, %d, 0x%x, %p, %p)",
d939 1
a939 1
getpeereid (int fd, __uid32_t *euid, __gid32_t *egid)
d953 2
d1331 2
d1350 2
d1365 1
a1365 1
  syscall_printf ("%R = accept4(%d, %p, %p, %p)", res, fd, peer, len, flags);
d1499 2
a1500 1
  syscall_printf ("%R = getpeername(%d) %d", res, fd, (fh ? fh->get_socket () : -1));
d1505 1
a1505 1
extern "C" int
d1508 3
a1510 1
  int res;
d1524 1
a1524 1
  syscall_printf ("%R = recv(%d, %p, %d, %x)", res, fd, buf, len, flags);
d1529 1
a1529 1
extern "C" int
d1532 3
a1534 1
  int res;
d1544 1
a1544 1
  syscall_printf ("%R = send(%d, %p, %d, %x)", res, fd, buf, len, flags);
d1902 1
d1904 1
a1904 2
 * Get network interfaces XP SP1 and above.
 * Use IP Helper function GetAdaptersAddresses.
d1907 1
a1907 1
get_xp_ifs (ULONG family)
a2084 195
/*
 * Get network interfaces up to XP w/o service packs.
 */
static struct ifall *
get_2k_ifs ()
{
  int ethId = 0, pppId = 0, slpId = 0, tokId = 0;

  DWORD ip_cnt;
  DWORD siz_ip_table = 0;
  PMIB_IPADDRTABLE ipt;
  PMIB_IFROW ifrow;
  struct ifall *ifret = NULL, *ifp = NULL;
  struct sockaddr_in *if_sin;

  struct ifcount_t
  {
    DWORD ifIndex;
    size_t count;
    unsigned int enumerated;	// for eth0:1
    unsigned int classId;	// for eth0, tok0 ...

  };
  ifcount_t *iflist, *ifEntry;

  if (GetIpAddrTable (NULL, &siz_ip_table, TRUE) == ERROR_INSUFFICIENT_BUFFER
      && (ifrow = (PMIB_IFROW) alloca (sizeof (MIB_IFROW)))
      && (ipt = (PMIB_IPADDRTABLE) alloca (siz_ip_table))
      && !GetIpAddrTable (ipt, &siz_ip_table, TRUE))
    {
      if (!(ifret = (struct ifall *) calloc (ipt->dwNumEntries, sizeof (struct ifall))))
	goto done;
      ifp = ifret;

      iflist =
	(ifcount_t *) alloca (sizeof (ifcount_t) * (ipt->dwNumEntries + 1));
      memset (iflist, 0, sizeof (ifcount_t) * (ipt->dwNumEntries + 1));
      for (ip_cnt = 0; ip_cnt < ipt->dwNumEntries; ++ip_cnt)
	{
	  ifEntry = iflist;
	  /* search for matching entry (and stop at first free entry) */
	  while (ifEntry->count != 0)
	    {
	      if (ifEntry->ifIndex == ipt->table[ip_cnt].dwIndex)
		break;
	      ifEntry++;
	    }
	  if (ifEntry->count == 0)
	    {
	      ifEntry->count = 1;
	      ifEntry->ifIndex = ipt->table[ip_cnt].dwIndex;
	    }
	  else
	    {
	      ifEntry->count++;
	    }
	}
      /* reset the last element. This is just the stopper for the loop. */
      iflist[ipt->dwNumEntries].count = 0;

      /* Iterate over all configured IP-addresses */
      for (ip_cnt = 0; ip_cnt < ipt->dwNumEntries; ++ip_cnt)
	{
	  memset (ifrow, 0, sizeof (MIB_IFROW));
	  ifrow->dwIndex = ipt->table[ip_cnt].dwIndex;
	  if (GetIfEntry (ifrow) != NO_ERROR)
	    continue;

	  ifcount_t *ifEntry = iflist;

	  /* search for matching entry (and stop at first free entry) */
	  while (ifEntry->count != 0)
	    {
	      if (ifEntry->ifIndex == ipt->table[ip_cnt].dwIndex)
		break;
	      ifEntry++;
	    }

	  /* Next in chain */
	  ifp->ifa_ifa.ifa_next = (struct ifaddrs *) &ifp[1].ifa_ifa;
	  /* Interface name */
	  if (ifrow->dwType == IF_TYPE_SOFTWARE_LOOPBACK)
	    strcpy (ifp->ifa_name, "lo");
	  else
	    {
	      const char *name = "";
	      switch (ifrow->dwType)
		{
		  case IF_TYPE_ISO88025_TOKENRING:
		    name = "tok";
		    if (ifEntry->enumerated == 0)
		      ifEntry->classId = tokId++;
		    break;
		  case IF_TYPE_ETHERNET_CSMACD:
		    name = "eth";
		    if (ifEntry->enumerated == 0)
		      ifEntry->classId = ethId++;
		    break;
		  case IF_TYPE_PPP:
		    name = "ppp";
		    if (ifEntry->enumerated == 0)
		      ifEntry->classId = pppId++;
		    break;
		  case IF_TYPE_SLIP:
		    name = "slp";
		    if (ifEntry->enumerated == 0)
		      ifEntry->classId = slpId++;
		    break;
		  default:
		    continue;
		}
	      __small_sprintf (ifp->ifa_name,
			       ifEntry->enumerated ? "%s%u:%u" : "%s%u",
			       name, ifEntry->classId, ifEntry->enumerated);
	      ifEntry->enumerated++;
	    }
	  ifp->ifa_ifa.ifa_name = ifp->ifa_name;
	  /* Flags */
	  if (ifrow->dwType == IF_TYPE_SOFTWARE_LOOPBACK)
	    ifp->ifa_ifa.ifa_flags |= IFF_LOOPBACK;
	  else if (ifrow->dwType == IF_TYPE_PPP
		   || ifrow->dwType == IF_TYPE_SLIP)
	    ifp->ifa_ifa.ifa_flags |= IFF_POINTOPOINT | IFF_NOARP;
	  else
	    ifp->ifa_ifa.ifa_flags |= IFF_BROADCAST;
	  if (ifrow->dwAdminStatus == IF_ADMIN_STATUS_UP)
	    {
	      ifp->ifa_ifa.ifa_flags |= IFF_UP | IFF_LOWER_UP;
	      if (ifrow->dwOperStatus >= IF_OPER_STATUS_CONNECTED)
		ifp->ifa_ifa.ifa_flags |= IFF_RUNNING;
	    }
	  /* Address */
	  if_sin = (struct sockaddr_in *) &ifp->ifa_addr;
	  if_sin->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr;
	  if_sin->sin_family = AF_INET;
	  ifp->ifa_ifa.ifa_addr = (struct sockaddr *) &ifp->ifa_addr;
	  /* Netmask */
	  if_sin = (struct sockaddr_in *) &ifp->ifa_netmask;
	  if_sin->sin_addr.s_addr = ipt->table[ip_cnt].dwMask;
	  if_sin->sin_family = AF_INET;
	  ifp->ifa_ifa.ifa_netmask = (struct sockaddr *) &ifp->ifa_netmask;
	  if_sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
	  if (ifrow->dwType == IF_TYPE_PPP
	      || ifrow->dwType == IF_TYPE_SLIP)
	    {
	      /* Destination address */
	      if_sin->sin_addr.s_addr =
		get_routedst (ipt->table[ip_cnt].dwIndex);
	      ifp->ifa_ifa.ifa_dstaddr = (struct sockaddr *)
					 &ifp->ifa_brddstaddr;
	    }
	  else
	    {
	      /* Broadcast address */
#if 0
	      /* Unfortunately, the field returns only crap. */
	      if_sin->sin_addr.s_addr = ipt->table[ip_cnt].dwBCastAddr;
#else
	      uint32_t mask = ipt->table[ip_cnt].dwMask;
	      if_sin->sin_addr.s_addr = (ipt->table[ip_cnt].dwAddr & mask) | ~mask;
#endif
	      ifp->ifa_ifa.ifa_broadaddr = (struct sockaddr *)
					   &ifp->ifa_brddstaddr;
	    }
	  if_sin->sin_family = AF_INET;
	  /* Hardware address */
	  for (UINT i = 0; i < IFHWADDRLEN; ++i)
	    if (i >= ifrow->dwPhysAddrLen)
	      ifp->ifa_hwaddr.sa_data[i] = '\0';
	    else
	      ifp->ifa_hwaddr.sa_data[i] = ifrow->bPhysAddr[i];
	  /* Metric */
	  ifp->ifa_metric = 1;
	  /* MTU */
	  ifp->ifa_mtu = ifrow->dwMtu;
	  /* Interface index */
	  ifp->ifa_ifindex = ifrow->dwIndex;
	  /* Friendly name */
	  struct ifreq_frndlyname *iff = (struct ifreq_frndlyname *)
					 &ifp->ifa_frndlyname;
	  iff->ifrf_len = sys_wcstombs (iff->ifrf_friendlyname,
					IFRF_FRIENDLYNAMESIZ,
					ifrow->wszName);
	  ++ifp;
	}
    }
  /* Since every entry is set to the next entry, the last entry points to an
     invalid next entry now.  Fix it retroactively. */
  if (ifp > ifret)
    ifp[-1].ifa_ifa.ifa_next = NULL;

done:
  return ifret;
}

d2094 1
a2094 4
  if (wincap.has_gaa_prefixes () && !CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
    ifp = get_xp_ifs (AF_UNSPEC);
  else
    ifp = get_2k_ifs ();
d2121 1
a2121 4
  if (wincap.has_gaa_prefixes () && !CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
    ifret = get_xp_ifs (AF_INET);
  else
    ifret = get_2k_ifs ();
d2200 1
a2200 2
  if (wincap.has_gaa_prefixes ()
      && get_adapters_addresses (&pa0, AF_UNSPEC))
d2229 1
a2229 2
  if (wincap.has_gaa_prefixes ()
      && get_adapters_addresses (&pa0, AF_UNSPEC))
d2268 1
a2268 2
  if (wincap.has_gaa_prefixes ()
      && get_adapters_addresses (&pa0, AF_UNSPEC))
d2623 1
a2623 1
extern "C" int
d2626 3
a2628 1
  int res;
d2646 1
a2646 1
  syscall_printf ("%R = recvmsg(%d, %p, %x)", res, fd, msg, flags);
d2651 1
a2651 1
extern "C" int
d2654 3
a2656 1
  int res;
d2670 1
a2670 1
  syscall_printf ("%R = sendmsg(%d, %p, %x)", res, fd, msg, flags);
d3991 3
a3993 5
/* We can't use autoload here because we don't know where the functions
   are loaded from.  On Win2K, the functions are available in the
   ipv6 technology preview lib called wship6.dll, in XP and above they
   are implemented in ws2_32.dll.  For older systems we use the ipv4-only
   version above. */
a4039 7
  wcpcpy (lib_name, L"wship6.dll");
  if ((lib = LoadLibraryW (lib_path)))
    {
      if (get_ipv6_funcs (lib))
	goto out;
      FreeLibrary (lib);
    }
@


1.303
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.302
log
@* net.cc (get_adapters_addresses): Drop FIXME part of comment.
@
text
@a1527 63
#ifndef __MINGW64_VERSION_MAJOR

/* Vista/Longhorn: unicast address has additional OnLinkPrefixLength member. */
typedef struct _IP_ADAPTER_UNICAST_ADDRESS_LH {
    _ANONYMOUS_UNION union {
	ULONGLONG Alignment;
	_ANONYMOUS_UNION struct {
	    ULONG Length;
	    DWORD Flags;
	} DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    struct _IP_ADAPTER_UNICAST_ADDRESS_VISTA *Next;
    SOCKET_ADDRESS Address;
    IP_PREFIX_ORIGIN PrefixOrigin;
    IP_SUFFIX_ORIGIN SuffixOrigin;
    IP_DAD_STATE DadState;
    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    ULONG LeaseLifetime;
    unsigned char OnLinkPrefixLength;
} IP_ADAPTER_UNICAST_ADDRESS_LH, *PIP_ADAPTER_UNICAST_ADDRESS_LH;

/* Vista/Longhorn: IP_ADAPTER_ADDRESSES has a lot more info.  We pick only
   what we need for now. */
typedef struct _IP_ADAPTER_ADDRESSES_LH {
  _ANONYMOUS_UNION union {
    ULONGLONG Alignment;
    _ANONYMOUS_STRUCT struct {
      ULONG Length;
      DWORD IfIndex;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  struct _IP_ADAPTER_ADDRESSES* Next;
  PCHAR AdapterName;
  PIP_ADAPTER_UNICAST_ADDRESS FirstUnicastAddress;
  PIP_ADAPTER_ANYCAST_ADDRESS FirstAnycastAddress;
  PIP_ADAPTER_MULTICAST_ADDRESS FirstMulticastAddress;
  PIP_ADAPTER_DNS_SERVER_ADDRESS FirstDnsServerAddress;
  PWCHAR DnsSuffix;
  PWCHAR Description;
  PWCHAR FriendlyName;
  BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
  DWORD PhysicalAddressLength;
  DWORD Flags;
  DWORD Mtu;
  DWORD IfType;
  IF_OPER_STATUS OperStatus;
  DWORD Ipv6IfIndex;
  DWORD ZoneIndices[16];
  PIP_ADAPTER_PREFIX FirstPrefix;

  ULONG64 TransmitLinkSpeed;
  ULONG64 ReceiveLinkSpeed;
  PVOID FirstWinsServerAddress;
  PVOID FirstGatewayAddress;
  ULONG Ipv4Metric;
  ULONG Ipv6Metric;
} IP_ADAPTER_ADDRESSES_LH,*PIP_ADAPTER_ADDRESSES_LH;

#define SIO_GET_INTERFACE_LIST  _IOR('t', 127, u_long)

#endif /* !__MINGW64_VERSION_MAJOR */

@


1.301
log
@whitespace cleanup
@
text
@d1699 1
a1699 3
	 stack will be located in the lower address area.
	 FIXME: The problem is fixed in W8CP, but needs testing before W8 goes
		gold. */
@


1.300
log
@Add files missing in previous checkin
@
text
@d18 1
a18 1
          if_indextoname functions in iphlpapi.h since Vista.
@


1.300.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d906 1
a906 1
getpeereid (int fd, uid_t *euid, gid_t *egid)
@


1.300.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d18 1
a18 1
	  if_indextoname functions in iphlpapi.h since Vista.
d1699 3
a1701 1
	 stack will be located in the lower address area. */
@


1.300.2.3
log
@	* fhandler_socket.cc: Throughout, fix casts to work on 64 bit.  Move
	calls to pthread_testcancel to upper syscall level for consistency.
	Move read, readv, write, and writev methods to keep together with
	equivalent recv and send methods.
	(fhandler_socket::read): Compute WSAMSG buffer on 64 bit to overcome
	type restriction of WSABUF len member.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Restructure for readability.
	* net.cc (cygwin_sendto): Call pthread_testcancel here.
	(cygwin_recvfrom): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
@
text
@a692 2
  pthread_testcancel ();

a712 2
  pthread_testcancel ();

a919 2
  pthread_testcancel ();

a1295 2
  pthread_testcancel ();

a1312 2
  pthread_testcancel ();

a1469 2
  pthread_testcancel ();

a1491 2
  pthread_testcancel ();

a2850 2
  pthread_testcancel ();

a2876 2
  pthread_testcancel ();

@


1.300.2.4
log
@Pull in changes from HEAD
@
text
@d1542 63
@


1.300.2.5
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d222 1
a222 1
  syscall_printf ("%s:%d - winsock error %u -> errno %d", fn, ln, werr, err);
d423 1
a423 1
	debug_printf ("protoent %s %p %y", dst->name, dst->list, dst->port_proto_addrtype);
d537 1
a537 1
	debug_printf ("WSAIoctl: %u", WSAGetLastError ());
d594 1
a594 1
      debug_printf ("setsockopt(SO_RCVBUF) failed, %u", WSAGetLastError ());
d598 1
a598 1
	system_printf ("getsockopt(SO_RCVBUF) failed, %u", WSAGetLastError ());
d603 1
a603 1
      debug_printf ("setsockopt(SO_SNDBUF) failed, %u", WSAGetLastError ());
d607 1
a607 1
	system_printf ("getsockopt(SO_SNDBUF) failed, %u", WSAGetLastError ());
d623 1
a623 1
  debug_printf ("socket (%d, %d (flags %y), %d)", af, type, flags, protocol);
d673 1
a673 1
	      debug_printf ("Reset SIO_UDP_CONNRESET: WinSock error %u",
d681 1
a681 1
  syscall_printf ("%R = socket(%d, %d (flags %y), %d)",
d703 1
a703 1
  syscall_printf ("%R = sendto(%d, %p, %ld, %y, %p, %d)",
d729 1
a729 1
  syscall_printf ("%R = recvfrom(%d, %p, %ld, %y, %p, %p)",
d794 1
a794 1
	syscall_printf ("setsockopt optval=%lx", *(long *) optval);
d844 1
a844 1
  syscall_printf ("%R = setsockopt(%d, %d, %y, %p, %d)",
d904 1
a904 1
  syscall_printf ("%R = getsockopt(%d, %d, %y, %p, %p)",
d1336 1
a1336 1
  syscall_printf ("%R = accept4(%d, %p, %p, %y)", res, fd, peer, len, flags);
d1470 1
a1470 2
  syscall_printf ("%R = getpeername(%d) %p", res, fd,
  		  (fh ? fh->get_socket () : (SOCKET) -1));
d1494 1
a1494 1
  syscall_printf ("%R = recv(%d, %p, %ld, %y)", res, fd, buf, len, flags);
d1514 1
a1514 1
  syscall_printf ("%R = send(%d, %p, %ld, %y)", res, fd, buf, len, flags);
d2820 1
a2820 1
  syscall_printf ("%R = recvmsg(%d, %p, %y)", res, fd, msg, flags);
d2844 1
a2844 1
  syscall_printf ("%R = sendmsg(%d, %p, %y)", res, fd, msg, flags);
@


1.300.2.6
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.300.2.7
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d160 1
a160 1
static const struct tl errmap[] = {
d229 1
a229 1
static const struct tl host_errmap[] = {
@


1.300.2.8
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@a1872 1

d1874 2
a1875 1
 * Get network interfaces.  Use IP Helper function GetAdaptersAddresses.
d1878 1
a1878 1
get_ifs (ULONG family)
d2056 195
d2260 4
a2263 1
  ifp = get_ifs (AF_UNSPEC);
d2290 4
a2293 1
  ifret = get_ifs (AF_INET);
d2372 2
a2373 1
  if (get_adapters_addresses (&pa0, AF_UNSPEC))
d2402 2
a2403 1
  if (get_adapters_addresses (&pa0, AF_UNSPEC))
d2442 2
a2443 1
  if (get_adapters_addresses (&pa0, AF_UNSPEC))
d4166 5
a4170 3
/* We can't use autoload here because we don't know if the functions
   are available (pre-Vista).  For those systems we redirect to the
   ipv4-only version above. */
d4217 7
@


1.300.2.9
log
@	* net.cc (struct win64_servent): Define for x86_64.  Explain why.
	(WIN_SERVENT): Define for all targets.
	(dup_ent): Use WIN_SERVENT to access critical servent members
	throughout.
@
text
@a307 16
#ifdef __x86_64__
/* For some baffling reason, somebody at Microsoft decided that it would be
   a good idea to exchange the s_port and s_proto members in the servent
   structure. */
struct win64_servent
{
  char  *s_name;
  char **s_aliases;
  char  *s_proto;
  short  s_port;
};
#define WIN_SERVENT(x)	((win64_servent *)(x))
#else
#define WIN_SERVENT(x)	((servent *)(x))
#endif

d372 2
a373 2
      if (WIN_SERVENT (src)->s_proto)
	sz += (protolen = strlen_round (WIN_SERVENT (src)->s_proto));
d395 2
a396 6
	 in each, of course.  Also, take 64 bit Windows servent weirdness
	 into account. */
      if (type == unionent::t_servent)
	dst->port_proto_addrtype = WIN_SERVENT (src)->s_port;
      else
	dst->port_proto_addrtype = src->port_proto_addrtype;
d426 1
a426 1
	  if (WIN_SERVENT (src)->s_proto)
d428 1
a428 1
	      strcpy (dst->s_proto = dp, WIN_SERVENT (src)->s_proto);
d947 1
a947 2
  servent *res = getservbyname (name, proto);
  res = dup_ent (res);
@


1.300.2.10
log
@	* net.cc (cygwin_gethostbyname): Revert accidental checkin of change
	added for debugging.
@
text
@d967 2
a968 1
  servent *res = dup_ent (getservbyname (name, proto));
@


1.300.2.11
log
@	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Use %lu as
	format specifier to match HANDLE size.
	* net.cc (cygwin_sendto): Fix return type to be ssize_t.  Change
	syscall_printf return type format specifier to %lR.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* smallprint.cc (__small_vsprintf): Handle `l' for %R, too.
	(__small_vswprintf): Ditto.
	* syscalls.cc (read): Change syscall_printf return type format specifier
	to %lR.
	(readv): Ditto.
	(pread): Ditto.
	(write): Ditto.
	(writev): Ditto.
	(pwrite): Ditto.
	(lseek64): Enhance comment.
@
text
@d707 1
a707 1
extern "C" ssize_t
d723 1
a723 1
  syscall_printf ("%lR = sendto(%d, %p, %ld, %y, %p, %d)",
d729 1
a729 1
extern "C" ssize_t
d749 1
a749 1
  syscall_printf ("%lR = recvfrom(%d, %p, %ld, %y, %p, %p)",
d1496 1
a1496 1
extern "C" ssize_t
d1515 1
a1515 1
  syscall_printf ("%lR = recv(%d, %p, %ld, %y)", res, fd, buf, len, flags);
d1520 1
a1520 1
extern "C" ssize_t
d1535 1
a1535 1
  syscall_printf ("%lR = send(%d, %p, %ld, %y)", res, fd, buf, len, flags);
d2614 1
a2614 1
extern "C" ssize_t
d2637 1
a2637 1
  syscall_printf ("%lR = recvmsg(%d, %p, %y)", res, fd, msg, flags);
d2642 1
a2642 1
extern "C" ssize_t
d2661 1
a2661 1
  syscall_printf ("%lR = sendmsg(%d, %p, %y)", res, fd, msg, flags);
@


1.300.2.12
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Change type of
	local variable res to ssize_t.
	* net.cc (cygwin_sendto): Fix local variable res, containing return
	value, to be ssize_t as well.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* syscalls.cc (write): Ditto.
	(writev): Ditto.
	* pipe.cc (fhandler_pipe::open): Fix type when reading handle value to
	accommodate 32 bit compiler.
@
text
@d711 1
a711 1
  ssize_t res;
d733 1
a733 1
  ssize_t res;
d1499 1
a1499 1
  ssize_t res;
d1523 1
a1523 1
  ssize_t res;
d2617 1
a2617 1
  ssize_t res;
d2645 1
a2645 1
  ssize_t res;
@


1.300.2.13
log
@	* net.cc (fdsock): Raise send/recv buffer sizes for x86_64.  Extend
	comment.
	(cygwin_setsockopt): Fix condition and syscall_printf.
@
text
@a607 4
     NOTE 2.  Testing on x86_64 (XP, Vista, 2008 R2, W8) indicates that
     this is no problem on 64 bit.  So we set the default buffer size to
     the default values in current 3.x Linux versions.

a608 4
#ifdef __x86_64__
  ((fhandler_socket *) fd)->rmem () = 212992;
  ((fhandler_socket *) fd)->wmem () = 212992;
#else
a610 1
#endif
d813 2
a814 2
      if (optlen == sizeof (int))
	syscall_printf ("setsockopt optval=%x", *(int *) optval);
@


1.299
log
@* Makefile.in: Add some more optimization flags for cygwait, malloc and path.  Explain
why -fomit-frame-pointer doesn't work right for passwd.o and path.o.  Add
-static to link command line for cygwin0.dll.
* fhandler_disk_file.cc (fhandler_disk_file::facl): Reorganize slightly to
silence compiler warning when compiling with -fstack-check.
* net.cc (inet_ntop6): Initialize structure members to silence compiler warning
when compiling with -fstack-check.
* pseudo-reloc.cc (_pei386_runtime_relocator): Make this a C function.  Detect
NULL u.
* winsup.h (_pei386_runtime_relocator): Declare this as extern "C".
* lib/_cygwin_crt0_common.cc (_pei386_runtime_relocator): Call with NULL
argument.
* signal.cc (sigaction_worker): Eliminate last argument.  Let callers report
their own strace info.  Regparmize.
(sigaction): Reflect sigaction_worker changes.
(siginterrupt): Ditto.
* exceptions.cc: Update copyright.
@
text
@d15 7
a21 1

d23 3
a25 6

/* unfortunately defined in windows header file but used in
   cygwin header files too */
#undef NOERROR
#undef DELETE

a28 1

d34 1
a35 3
#define USE_SYS_TYPES_FD_SET
#include <winsock2.h>
#include <iphlpapi.h>
a48 1
#include "cygwin/in6.h"
d52 4
d1528 2
a1586 2
/* We can't include ws2tcpip.h. */

d1589 1
a1589 19
struct sockaddr_in6_old {
  short   sin6_family;
  u_short sin6_port;
  u_long  sin6_flowinfo;
  struct in6_addr sin6_addr;
};

typedef union sockaddr_gen{
  struct sockaddr	  Address;
  struct sockaddr_in	  AddressIn;
  struct sockaddr_in6_old AddressIn6;
} sockaddr_gen;

typedef struct _INTERFACE_INFO {
  u_long	  iiFlags;
  sockaddr_gen	  iiAddress;
  sockaddr_gen	  iiBroadcastAddress;
  sockaddr_gen	  iiNetmask;
} INTERFACE_INFO, *LPINTERFACE_INFO;
d4218 6
a4223 6
static void (WINAPI *freeaddrinfo)(const struct addrinfo *);
static int (WINAPI *getaddrinfo)(const char *, const char *,
				  const struct addrinfo *,
				  struct addrinfo **);
static int (WINAPI *getnameinfo)(const struct sockaddr *, socklen_t,
				  char *, size_t, char *, size_t, int);
d4227 1
a4227 1
  return ((freeaddrinfo = (void (WINAPI *)(const struct addrinfo *))
d4229 3
a4231 3
	  && (getaddrinfo = (int (WINAPI *)(const char *, const char *,
					    const struct addrinfo *,
					    struct addrinfo **))
d4233 3
a4235 3
	  && (getnameinfo = (int (WINAPI *)(const struct sockaddr *,
					    socklen_t, char *, size_t,
					    char *, size_t, int))
d4270 3
a4272 3
  freeaddrinfo = NULL;
  getaddrinfo = NULL;
  getnameinfo = NULL;
d4312 1
a4312 1
  if (!getaddrinfo)
d4329 1
a4329 1
  int ret = w32_to_gai_err (getaddrinfo (hostname, servname, hints, res));
d4334 1
a4334 1
      freeaddrinfo (*res);
d4354 2
a4355 2
      int ret2 = w32_to_gai_err (getaddrinfo (hostname, servname,
					      &nhints, &v4res));
d4359 1
a4359 1
	  freeaddrinfo (v4res);
d4392 1
a4392 1
  if (!getnameinfo)
d4417 2
a4418 2
  int ret = w32_to_gai_err (getnameinfo (sa, salen, host, hostlen, serv,
					 servlen, flags));
@


1.298
log
@	* net.cc (cygwin_recvfrom): Don't shortcircuit if len == 0.  Add comment
	to explain why.
	(cygwin_recv): Ditto.
	(cygwin_recvmsg): Ditto.
@
text
@d3172 2
@


1.297
log
@	* net.cc (get_adapters_addresses): Only create thread on affected
	systems.  Change comment acordingly.
	* wincap.h (wincaps::has_gaa_largeaddress_bug): New element.
	* wincap.cc: Implement above element throughout.
	(wincap_8): New globale wincaps to support Windows 8.
	(wincapc::init): Take Windows 8 into account.  Set new
	has_gaa_largeaddress_bug member to false on 32 bit systems.
@
text
@d715 5
a719 1
  else if ((res = len) != 0)
d1472 5
a1476 1
  else if ((res = len) != 0)
d2876 5
a2880 1
      if (res > 0)
@


1.296
log
@	* net.cc (call_gaa): New thread function to call GetAdaptersAddresses.
	(get_adapters_addresses): Call call_gaa.  If necessary, call it as
	child thread.  Explain why that's necessary.
@
text
@d1698 2
a1699 1
  if ((uintptr_t) &param >= (uintptr_t) 0x80000000L)
d1701 1
a1701 1
      /* Starting with Windows Vista, GetAdaptersAddresses fails with error 998,
d1704 5
a1708 2
	 GetAdaptersAddresses in a child thread with an OS-allocated stack,
	 which is guaranteed to be located in the lower address area. */
@


1.295
log
@	* cygtls.cc (dll_cmp): New comparison function for bsearch.
	(well_known_dlls): New array containing well-known DLLs.
	(_cygtls::call2): Add code for BLODA detection.
	* net.cc (fdsock): Ditto.
@
text
@d1653 7
a1659 2
bool
get_adapters_addresses (PIP_ADAPTER_ADDRESSES *pa_ret, ULONG family)
d1662 1
d1665 2
a1666 3
  if (!pa_ret)
    return ERROR_BUFFER_OVERFLOW
	   == GetAdaptersAddresses (family, GAA_FLAG_INCLUDE_PREFIX
d1668 1
a1668 1
				    NULL, NULL, &size);
d1671 2
a1672 2
      ret = GetAdaptersAddresses (family, GAA_FLAG_INCLUDE_PREFIX
					  | GAA_FLAG_INCLUDE_ALL_INTERFACES,
d1679 20
a1698 1
  if (ret != ERROR_SUCCESS)
d1700 14
a1713 4
      if (pa0)
	free (pa0);
      *pa_ret = NULL;
      return false;
d1715 3
a1717 2
  *pa_ret = pa0;
  return true;
@


1.294
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d535 16
a550 9
      else if (base_soc != soc
	       && GetHandleInformation ((HANDLE) base_soc, &flags)
	       && (flags & HANDLE_FLAG_INHERIT))
	{
	  if (!DuplicateHandle (GetCurrentProcess (), (HANDLE) base_soc,
				GetCurrentProcess (), (PHANDLE) &base_soc,
				0, TRUE, DUPLICATE_SAME_ACCESS))
	    debug_printf ("DuplicateHandle failed, %E");
	  else
d552 10
a561 3
	      closesocket (soc);
	      soc = base_soc;
	      fixup = false;
@


1.293
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d514 1
a514 1
 
@


1.292
log
@	* net.cc (socketpair): Bind first socket to loopback only as well.
@
text
@d664 1
a664 1
  syscall_printf ("%d = socket (%d, %d (flags %p), %d)",
d684 1
a684 1
  syscall_printf ("%d = sendto (%d, %p, %d, %x, %p, %d)",
d704 1
a704 1
  syscall_printf ("%d = recvfrom (%d, %p, %d, %x, %p, %p)",
d819 1
a819 1
  syscall_printf ("%d = setsockopt (%d, %d, %x, %p, %d)",
d879 1
a879 1
  syscall_printf ("%d = getsockopt (%d, %d, 0x%x, %p, %p)",
d907 1
a907 1
  syscall_printf ("%d = connect (%d, %p, %d)", res, fd, name, namelen);
d1283 1
a1283 1
  syscall_printf ("%d = accept (%d, %p, %p)", res, fd, peer, len);
d1305 1
a1305 1
  syscall_printf ("%d = accept4 (%d, %p, %p, %p)", res, fd, peer, len, flags);
d1322 1
a1322 1
  syscall_printf ("%d = bind (%d, %p, %d)", res, fd, my_addr, addrlen);
d1340 1
a1340 1
  syscall_printf ("%d = getsockname (%d, %p, %p)", res, fd, addr, namelen);
d1356 1
a1356 1
  syscall_printf ("%d = listen (%d, %d)", res, fd, backlog);
d1373 1
a1373 1
  syscall_printf ("%d = shutdown (%d, %d)", res, fd, how);
d1439 1
a1439 1
  syscall_printf ("%d = getpeername (%d) %d", res, fd, (fh ? fh->get_socket () : -1));
d1457 1
a1457 1
  syscall_printf ("%d = recv (%d, %p, %d, %x)", res, fd, buf, len, flags);
d1475 1
a1475 1
  syscall_printf ("%d = send (%d, %p, %d, %x)", res, fd, buf, len, flags);
d2785 1
a2785 1
  syscall_printf ("%d = socketpair (...)", res);
d2819 1
a2819 1
  syscall_printf ("%d = recvmsg (%d, %p, %x)", res, fd, msg, flags);
d2841 1
a2841 1
  syscall_printf ("%d = sendmsg (%d, %p, %x)", res, fd, msg, flags);
@


1.291
log
@	* net.cc (cygwin_getsockopt): Drop erroneous double conversion of error
	code returned by SOL_SOCKET/SO_ERROR.  Fix error handling.
@
text
@d2633 1
a2633 1
  sock_in.sin_addr.s_addr = INADDR_ANY;
@


1.290
log
@2011-08-16  Pierre Humblet <Pierre.Humblet@@ieee.org>

        * net.cc (gethostby_helper): Remove DEBUGGING code from and
        streamline the second pass.
@
text
@d847 3
a849 2

      if (level == SOL_SOCKET)
a876 10
      if (optname == SO_ERROR)
	{
	  int *e = (int *) optval;

	  debug_printf ("WinSock SO_ERROR = %d", *e);
	  *e = find_winsock_errno (*e);
	}

      if (res)
	set_winsock_errno ();
@


1.289
log
@	* net.cc (socketpair): Release sb0 if there's no space left for sb1.
@
text
@a1200 1
  ancount = alias_count + address_count; /* Valid records */
d1202 1
d1204 1
a1204 1
  for (i = 0, curptr = anptr; i < ancount; i++, curptr = curptr->next ())
d1209 1
a1209 5
	  complen = dn_expand (msg, eomsg, curptr->name (), string_ptr, string_size);
#ifdef DEBUGGING
	  if (complen != curptr->complen)
	    goto debugging;
#endif
d1211 1
a1211 4
	  namelen1 = curptr->namelen1;
	  string_ptr += namelen1;
	  string_size -= namelen1;
	  continue;
d1213 3
a1215 1
      if (antype == type)
d1217 11
a1227 25
	      if (address_count == 0)
		{
		  complen = dn_expand (msg, eomsg, curptr->name(), string_ptr, string_size);
#ifdef DEBUGGING
		  if (complen != curptr->complen)
		    goto debugging;
#endif
		  ret->h_name = string_ptr;
		  namelen1 = curptr->namelen1;
		  string_ptr += namelen1;
		  string_size -= namelen1;
		}
	      ret->h_addr_list[address_count++] = string_ptr;
	      if (addrsize_in != addrsize_out)
		memcpy4to6 (string_ptr, curptr->data);
	      else
		memcpy (string_ptr, curptr->data, addrsize_in);
	      string_ptr += addrsize_out;
	      string_size -= addrsize_out;
	      continue;
	    }
#ifdef DEBUGGING
      /* Should not get here */
      goto debugging;
#endif
a1228 4
#ifdef DEBUGGING
  if (string_size < 0)
    goto debugging;
#endif
a1242 10


#ifdef DEBUGGING
 debugging:
   system_printf ("Please debug.");
   free (msg);
   free (ret);
   h_errno = NO_RECOVERY;
   return NULL;
#endif
@


1.288
log
@	Throughout change "WinSock" to "Winsock" in comments.
	* fhandler_socket.cc (fhandler_socket::sendmsg): Add missing call to
	get_inet_addr to convert AF_LOCAL to AF_INET sockets.
	* net.cc (cygwin_socket): Workaround UDP Winsock problem.  Add comment
	to explain why.
	* select.cc: Include winsock2.h rather than winsock.h.
@
text
@d2815 2
@


1.287
log
@whitespace elimination
@
text
@d642 17
d743 1
a743 1
      /* Old applications still use the old Winsock1 IPPROTO_IP values. */
d842 1
a842 1
      /* Old applications still use the old Winsock1 IPPROTO_IP values. */
d3365 1
a3365 1
   structures from Winsock, so that we have the allocation of the structs
d4291 1
a4291 1
     is it supported by Winsock prior to Vista.  We just check the servname
d4384 1
a4384 1
     Winsock's getnameinfo up to Windows 2003 returns with error WSANO_DATA
@


1.286
log
@	* net.cc (fdsock): Drop setting uninterruptible_io to true.
@
text
@d501 1
a501 1
     
d506 1
a506 1
     with error 10038, WSAENOTSOCK. 
d514 1
a514 1
     
d534 1
a534 1
      	debug_printf ("WSAIoctl: %lu", WSAGetLastError ());
d731 1
a731 1
         local TCP address (same IP, same port), even if SO_REUSEADDR has been
d845 1
a845 1
	         value, a 1 byte BOOLEAN value is returned, in contrast
@


1.285
log
@	* net.cc (get_ipv4fromreg_ipcnt): Rearrange to fetch all registry
	values at once using RtlQueryRegistryValues.
	(get_ipv4fromreg): Ditto.
@
text
@a556 1
  fd->uninterruptible_io (true);
@


1.284
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d52 1
d1765 7
a1771 3
  HKEY key;
  LONG ret;
  char regkey[256], *c;
d1773 9
a1781 1
  DWORD dhcp, size;
d1783 4
a1786 5
  c = stpcpy (regkey, "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\"
		      "Parameters\\Interfaces\\");
  stpcpy (c, name);
  if ((ret = RegOpenKeyEx (HKEY_LOCAL_MACHINE, regkey, 0, KEY_READ,
			   &key)) != ERROR_SUCCESS)
d1788 2
a1789 14
      if (ret != ERROR_FILE_NOT_FOUND)
	debug_printf ("RegOpenKeyEx(%s), win32 error %ld", regkey, ret);
      return 0;
    }
  /* If DHCP is used, we have only one address. */
  if ((ret = RegQueryValueEx (key, "EnableDHCP", NULL, NULL, (PBYTE) &dhcp,
			      (size = sizeof dhcp, &size))) == ERROR_SUCCESS
      && dhcp == 0
      && (ret = RegQueryValueEx (key, "IPAddress", NULL, NULL, NULL,
				 &size)) == ERROR_SUCCESS)
    {
      char *ipa = (char *) alloca (size);
      RegQueryValueEx (key, "IPAddress", NULL, NULL, (PBYTE) ipa, &size);
      for (ifs = 0, c = ipa; *c; c += strlen (c) + 1)
d1791 1
a1792 1
  RegCloseKey (key);
d1799 29
a1827 19
  HKEY key;
  LONG ret;
  char regkey[256], *c;
  DWORD ifs;
  DWORD dhcp, size;

  c = stpcpy (regkey, "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\"
		      "Parameters\\Interfaces\\");
  stpcpy (c, name);
  if ((ret = RegOpenKeyEx (HKEY_LOCAL_MACHINE, regkey, 0, KEY_READ, &key))
      != ERROR_SUCCESS)
    {
      if (ret != ERROR_FILE_NOT_FOUND)
	debug_printf ("RegOpenKeyEx(%s), win32 error %ld", regkey, ret);
      return;
    }
  /* If DHCP is used, we have only one address. */
  if ((ret = RegQueryValueEx (key, "EnableDHCP", NULL, NULL, (PBYTE) &dhcp,
			      (size = sizeof dhcp, &size))) == ERROR_SUCCESS)
d1829 10
a1838 3
#define addr ((struct sockaddr_in *) &ifp->ifa_addr)
#define mask ((struct sockaddr_in *) &ifp->ifa_netmask)
#define brdc ((struct sockaddr_in *) &ifp->ifa_brddstaddr)
d1841 4
a1844 8
	  if ((ret = RegQueryValueEx (key, "DhcpIPAddress", NULL, NULL,
				      (PBYTE) regkey, (size = 256, &size)))
	      == ERROR_SUCCESS)
	    cygwin_inet_aton (regkey, &addr->sin_addr);
	  if ((ret = RegQueryValueEx (key, "DhcpSubnetMask", NULL, NULL,
				      (PBYTE) regkey, (size = 256, &size)))
	      == ERROR_SUCCESS)
	    cygwin_inet_aton (regkey, &mask->sin_addr);
d1848 1
a1848 2
	  if ((ret = RegQueryValueEx (key, "IPAddress", NULL, NULL, NULL,
				     &size)) == ERROR_SUCCESS)
d1850 2
a1851 3
	      char *ipa = (char *) alloca (size);
	      RegQueryValueEx (key, "IPAddress", NULL, NULL, (PBYTE) ipa, &size);
	      for (ifs = 0, c = ipa; *c && ifs < idx; c += strlen (c) + 1)
d1854 1
a1854 1
		cygwin_inet_aton (c, &addr->sin_addr);
d1856 1
a1856 2
	  if ((ret = RegQueryValueEx (key, "SubnetMask", NULL, NULL, NULL,
				     &size)) == ERROR_SUCCESS)
d1858 2
a1859 3
	      char *ipa = (char *) alloca (size);
	      RegQueryValueEx (key, "SubnetMask", NULL, NULL, (PBYTE) ipa, &size);
	      for (ifs = 0, c = ipa; *c && ifs < idx; c += strlen (c) + 1)
d1862 1
a1862 1
		cygwin_inet_aton (c, &mask->sin_addr);
d1872 9
a1881 1
  RegCloseKey (key);
@


1.283
log
@	* net.cc (SIO_BASE_HANDLE): Define.
	(fdsock): If we got an LSP handle, try to create a copy of the base
	handle instead.  Change comment to explain.
@
text
@d2197 1
a2197 4
	      /* Bug in NT4's IP Helper lib.  The dwOperStatus has just
		 two values, 0 or 1, non operational, operational. */
	      if (ifrow->dwOperStatus >= (wincap.has_broken_if_oper_status ()
					  ? 1 : IF_OPER_STATUS_CONNECTED))
@


1.282
log
@	* fhandler_socket (fhandler_socket::readv): Call recv_internal directly,
	rather than recvmsg.
	(fhandler_socket::writev): Call send_internal directly, rather than
	sendmsg.
	* net.cc (cygwin_recv): Call fhandler_socket::recvfrom directly, rather
	than cygwin_recvfrom.
	(cygwin_send): Call fhandler_socket::sendto directly, rather than
	cygwin_sendto.
@
text
@d483 4
a494 6
  fd->set_io_handle ((HANDLE) soc);
  if (!((fhandler_socket *) fd)->init_events ())
    return false;
  fd->set_flags (O_RDWR | O_BINARY);
  fd->uninterruptible_io (true);
  debug_printf ("fd %d, name '%s', soc %p", (int) fd, dev->name, soc);
d498 15
a512 1
     with their own kind, which is running through a filter driver.
d514 5
a518 16
     The result is that these new sockets are not normal kernel objects
     anymore.  They are typically not marked as inheritable, nor are they
     IFS handles, as normal OS sockets are.  They are in fact not inheritable
     to child processes, and subsequent socket calls in the child process
     will fail with error 10038, WSAENOTSOCK.  And worse, while DuplicateHandle
     on these sockets mostly works in the process which created the socket,
     DuplicateHandle does quite often not work anymore in a child process.
     It does not help to mark them inheritable via SetHandleInformation.

     The only way to make these sockets usable in child processes is to
     duplicate them via WSADuplicateSocket/WSASocket calls.  This requires
     to start the child process in SUSPENDED state so we only do this on
     affected systems.  If we recognize a non-inheritable socket, or if
     the XP1_IFS_HANDLES flag is not set in a call to WSADuplicateSocket,
     we switch to inheritance/dup via WSADuplicateSocket/WSASocket for
     that socket. */
d520 1
a520 5
#if 0
  /* Disable checking for IFS handle for now.  In theory, checking the fact
     that the socket handle is not inheritable should be sufficient. */
  WSAPROTOCOL_INFOW wpi;
#endif
d523 31
a553 8
#if 0
      || WSADuplicateSocketW (soc, GetCurrentProcessId (), &wpi)
      /* dwProviderReserved contains the actual SOCKET value of the duplicated
	 socket.  Close it or suffer a handle leak.  Worse, one socket for each
	 connection remains in CLOSE_WAIT state. */
      || (closesocket ((SOCKET) wpi.dwProviderReserved), FALSE)
      || !(wpi.dwServiceFlags1 & XP1_IFS_HANDLES))
#endif
d555 3
@


1.282.2.1
log
@	* net.cc (SIO_BASE_HANDLE): Define.
	(fdsock): If we got an LSP handle, try to try to create a copy of the
	base handle instead.  Change comment to explain.
@
text
@a482 4
#ifndef SIO_BASE_HANDLE
#define SIO_BASE_HANDLE _WSAIOR(IOC_WS2,34)
#endif

d491 6
d500 1
a500 15
     with their own kind, which is running through a filter driver called
     "layered service provider" (LSP).
     
     LSP sockets are not kernel objects.  They are typically not marked as
     inheritable, nor are they IFS handles.  They are in fact not inheritable
     to child processes, and it does not help to mark them inheritable via
     SetHandleInformation.  Subsequent socket calls in the child process fail
     with error 10038, WSAENOTSOCK. 

     The only way up to Windows Server 2003 to make these sockets usable in
     child processes is to duplicate them via WSADuplicateSocket/WSASocket
     calls.  This requires to start the child process in SUSPENDED state so
     we only do this on affected systems.  If we recognize a non-inheritable
     socket we switch to inheritance/dup via WSADuplicateSocket/WSASocket for
     that socket.
d502 16
a517 5
     Starting with Vista there's another neat way to workaround these annoying
     LSP sockets.  WSAIoctl allows to fetch the underlying base socket, which
     is a normal, inheritable IFS handle.  So we fetch the base socket,
     duplicate it, and close the original socket.  Now we have a standard IFS
     socket which (hopefully) works as expected. */
d519 5
a523 1
  bool fixup = false;
d526 8
a533 31
    {
      int ret;
      SOCKET base_soc;
      DWORD bret;

      fixup = true;
      debug_printf ("LSP handle: %p", soc);
      ret = WSAIoctl (soc, SIO_BASE_HANDLE, NULL, 0, (void *) &base_soc,
		      sizeof (base_soc), &bret, NULL, NULL);
      if (ret)
      	debug_printf ("WSAIoctl: %lu", WSAGetLastError ());
      else if (base_soc != soc
	       && GetHandleInformation ((HANDLE) base_soc, &flags)
	       && (flags & HANDLE_FLAG_INHERIT))
	{
	  if (!DuplicateHandle (GetCurrentProcess (), (HANDLE) base_soc,
				GetCurrentProcess (), (PHANDLE) &base_soc,
				0, TRUE, DUPLICATE_SAME_ACCESS))
	    debug_printf ("DuplicateHandle failed, %E");
	  else
	    {
	      closesocket (soc);
	      soc = base_soc;
	      fixup = false;
	    }
	}
    }
  fd->set_io_handle ((HANDLE) soc);
  if (!((fhandler_socket *) fd)->init_events ())
    return false;
  if (fixup)
a534 3
  fd->set_flags (O_RDWR | O_BINARY);
  fd->uninterruptible_io (true);
  debug_printf ("fd %d, name '%s', soc %p", (int) fd, dev->name, soc);
@


1.281
log
@	* Throughout fix copyright dates.
@
text
@a645 1

a665 1

d1449 12
a1460 1
  return cygwin_recvfrom (fd, buf, len, flags, NULL, NULL);
d1467 12
a1478 1
  return cygwin_sendto (fd, buf, len, flags, NULL, 0);
@


1.280
log
@	* fhandler_socket.cc (address_in_use): Disable.  Add comment.
	(fhandler_socket::bind): Change comment to explain setting the
	SO_EXCLUSIVEADDRUSE socket option.  Remove code which checks for
	address in use.
	* net.cc (cygwin_setsockopt): Never set SO_REUSEADDR option.  Improve
	comment to compensate for the deleted comment in fhandler_socket::bind.
	* wincap.cc: Throughout, drop has_enhanced_socket_security from wincaps.
	* wincap.h (struct wincaps): Drop has_enhanced_socket_security flags
	and method.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
@


1.279
log
@	* net.cc (get_xp_ifs): Fix counting of idx to return stable interface
	alias names for interfaces with multiple IPv4 addresses.
@
text
@d709 14
a722 4
      /* On systems supporting "enhanced socket security (2K3 and later),
	 the default behaviour of stream socket binding is equivalent to the
	 POSIX behaviour with SO_REUSEADDR.  Setting SO_REUSEADDR would only
	 result in wrong behaviour.  See also fhandler_socket::bind(). */
a723 1
	  && wincap.has_enhanced_socket_security ()
@


1.278
log
@	* autoload.cc (SendARP): Remove.
	* net.cc (get_flags): Set IFF_NOARP flag for PPP and SLIP devices.
	(get_xp_ifs): Unify IFF_BROADCAST setting.  Drop calling SendARP to
	set IFF_NOARP flag.
@
text
@d1910 1
a1910 2
	for (idx = 0, pua = pap->FirstUnicastAddress; pua;
	     ++idx, pua = pua->Next)
d1920 1
a1920 1
	    if (idx && sa->sa_family == AF_INET)
d1924 2
@


1.277
log
@	* net.cc (get_ipv4fromreg_ipcnt): Fix debug output.  Only create debug
	output if error is not ERROR_FILE_NOT_FOUND.
	(get_ipv4fromreg): Ditto.
@
text
@d1694 3
a1696 2
  else if (pap->IfType == IF_TYPE_PPP)
    flags |= IFF_POINTOPOINT;
d1883 2
a1884 1
	    if (pap->IfType != IF_TYPE_PPP)
a1931 6
	    if (sa->sa_family == AF_INET)
	      {
		ULONG hwaddr[2], hwlen = 6;
		if (SendARP (sin->sin_addr.s_addr, 0, hwaddr, &hwlen))
		  ifp->ifa_ifa.ifa_flags |= IFF_NOARP;
	      }
@


1.276
log
@	* net.cc (getdomainname): Drop special case for NT4.
@
text
@d1723 2
a1724 1
      debug_printf ("RegOpenKeyEx(%s), win32 error %ld", ret);
d1758 2
a1759 1
      debug_printf ("RegOpenKeyEx(%s), win32 error %ld", ret);
@


1.275
log
@	* fhandler_socket.cc (fhandler_socket::bind): Drop has_exclusiveaddruse
	condition.  Fix comment about availability.  Move remaining comment to
	the right spot.  Drop has_ip_helper_lib condition.
	* net.cc (cygwin_setsockopt): Drop has_disabled_user_tos_setting
	condition.  Fix comment.
	(get_2k_ifs): Fix comment.
	(get_nt_ifs): Remove.
	(getifaddrs): Drop call to get_nt_ifs.
	(get_ifconf): Ditto.
	* wincap.cc: Throughout, drop has_ip_helper_lib,
	has_disabled_user_tos_setting, and has_exclusiveaddruse settings from
	wincaps.
	(wincap_unknown): Remove.
	(wincap_nt4): Remove.
	(wincap_minimal): New macro, set to wincap_nt4sp4 for now.
	(wincapc::init): Drop test for pre-SP4 NT4.  Just imply at least NT SP4.
	Replace references to wincap_unknown with references to wincap_minimal.
	* wincap.h (struct wincaps): Drop has_ip_helper_lib,
	has_disabled_user_tos_setting, and has_exclusiveaddruse flags and
	methods.
@
text
@a1469 16

  /* This is only used by NT4.
     The registry names are language independent. */
  reg_key r (HKEY_LOCAL_MACHINE, KEY_READ,
	     "SYSTEM", "CurrentControlSet", "Services",
	     "Tcpip", "Parameters", NULL);

  if (!r.error ())
    {
      int res1, res2 = 0; /* Suppress compiler warning */
      res1 = r.get_string ("Domain", domain, len, "");
      if (res1 != ERROR_SUCCESS || !domain[0])
	res2 = r.get_string ("DhcpDomain", domain, len, "");
      if (res1 == ERROR_SUCCESS || res2 == ERROR_SUCCESS)
	return 0;
    }
@


1.274
log
@	* autoload.cc (LoadDLLprime): Change dllname storage to string16.
	(struct dll_info): Convert name to WCHAR.
	(std_dll_init): Load DLLs with full path to windows system directory.
	Add hint to Microsoft security advisory.
	* dcrt0.cc (init_windows_system_directory): New function.
	(dll_crt0_0): Call init_windows_system_directory first.
	* exceptions.cc (windows_system_directory): Move to globals.cc.
	(windows_system_directory_length): Ditto.
	(events_init): Drop code fetching windows_system_directory.
	* globals.cc (windows_system_directory): New global variable.
	(windows_system_directory_length): Ditto.
	* net.cc (load_ipv6_funcs): Use windows_system_directory rather than
	GetSystemDirectoryW.
	* netdb.cc (open_system_file): Ditto.  Simplify debug output.
@
text
@d745 1
a745 2
	     We just ignore the return value of setting IP_TOS under Windows
	     2000 and above entirely. */
d747 1
a747 2
	      && WSAGetLastError () == WSAEINVAL
	      && wincap.has_disabled_user_tos_setting ())
d2035 1
a2035 2
 * Get network interfaces NTSP4, W2K, XP w/o service packs.
 * Use IP Helper Library
a2231 245
/*
 * Get network interfaces Windows NT < SP4:
 * Look at the Bind value in
 * HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Linkage\
 * This is a REG_MULTI_SZ with strings of the form:
 * \Device\<Netcard>, where netcard is the name of the net device.
 * Then look under:
 * HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\<NetCard>\
 *							Parameters\Tcpip
 * at the IPAddress, Subnetmask and DefaultGateway values for the
 * required values.
 * Also fake "lo" since there's no representation in the registry.
 */
static struct ifall *
get_nt_ifs ()
{
  HKEY key;
  LONG ret;
  struct ifall *ifret = NULL, *ifp;
  unsigned long lip, lnp;
  struct sockaddr_in *sin = NULL;
  DWORD size;
  int cnt = 0, idx;
  char *binding = NULL;

  if ((ret = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
			   "SYSTEM\\"
			   "CurrentControlSet\\"
			   "Services\\"
			   "Tcpip\\" "Linkage",
			   0, KEY_READ, &key)) == ERROR_SUCCESS)
    {
      if ((ret = RegQueryValueEx (key, "Bind", NULL, NULL,
				  NULL, &size)) == ERROR_SUCCESS)
	{
	  binding = (char *) alloca (size);
	  if ((ret = RegQueryValueEx (key, "Bind", NULL, NULL,
				      (unsigned char *) binding,
				      &size)) != ERROR_SUCCESS)
	    binding = NULL;
	}
      RegCloseKey (key);
    }

  if (!binding)
    {
      __seterrno_from_win_error (ret);
      return NULL;
    }

  char *bp, eth[2] = "/";
  char cardkey[256], ipaddress[256], netmask[256];

  for (bp = binding; *bp; bp += strlen (bp) + 1)
    {
      bp += strlen ("\\Device\\");
      strcpy (cardkey, "SYSTEM\\CurrentControlSet\\Services\\");
      strcat (cardkey, bp);
      strcat (cardkey, "\\Parameters\\Tcpip");

      if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, cardkey,
			0, KEY_READ, &key) != ERROR_SUCCESS)
	continue;

      if (RegQueryValueEx (key, "IPAddress",
			   NULL, NULL,
			   (unsigned char *) ipaddress,
			   (size = 256, &size)) == ERROR_SUCCESS
	  && RegQueryValueEx (key, "SubnetMask",
			      NULL, NULL,
			      (unsigned char *) netmask,
			      (size = 256, &size)) == ERROR_SUCCESS)
	++cnt;
      RegCloseKey (key);
    }
  ++cnt; /* loopback */
  if (!(ifret = (struct ifall *) malloc (cnt * sizeof (struct ifall))))
    return NULL;
  /* Set up lo interface first */
  idx = 0;
  ifp = ifret + idx;
  memset (ifp, 0, sizeof *ifp);
  /* Next in chain */
  ifp->ifa_ifa.ifa_next = (struct ifaddrs *) &ifp[1].ifa_ifa;
  /* Interface name */
  strcpy (ifp->ifa_name, "lo");
  ifp->ifa_ifa.ifa_name = ifp->ifa_name;
  /* Flags */
  ifp->ifa_ifa.ifa_flags = IFF_UP | IFF_LOWER_UP | IFF_RUNNING | IFF_LOOPBACK;
  /* Address */
  sin = (struct sockaddr_in *) &ifp->ifa_addr;
  sin->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
  sin->sin_family = AF_INET;
  ifp->ifa_ifa.ifa_addr = (struct sockaddr *) &ifp->ifa_addr;
  /* Netmask */
  sin = (struct sockaddr_in *) &ifp->ifa_netmask;
  sin->sin_addr.s_addr = htonl (IN_CLASSA_NET);
  sin->sin_family = AF_INET;
  ifp->ifa_ifa.ifa_netmask = (struct sockaddr *) &ifp->ifa_netmask;
  /* Broadcast address  */
  sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
  sin->sin_addr.s_addr = htonl (INADDR_LOOPBACK | IN_CLASSA_HOST);
  sin->sin_family = AF_INET;
  ifp->ifa_ifa.ifa_broadaddr = (struct sockaddr *) &ifp->ifa_brddstaddr;
  /* Hardware address */
  ; // Nothing to do... */
  /* Metric */
  ifp->ifa_metric = 1;
  /* MTU */
  ifp->ifa_mtu = 1520; /* Default value for MS TCP Loopback interface. */
  /* Interface index */
  ifp->ifa_ifindex = -1;
  /* Friendly name */
  struct ifreq_frndlyname *iff = (struct ifreq_frndlyname *)
				  &ifp->ifa_frndlyname;
  strcpy (iff->ifrf_friendlyname, "Default loopback");
  iff->ifrf_len = 16;

  for (bp = binding; *bp; bp += strlen (bp) + 1)
    {
      bp += strlen ("\\Device\\");
      strcpy (cardkey, "SYSTEM\\CurrentControlSet\\Services\\");
      strcat (cardkey, bp);
      strcat (cardkey, "\\Parameters\\Tcpip");

      if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, cardkey,
			0, KEY_READ, &key) != ERROR_SUCCESS)
	continue;

      if (RegQueryValueEx (key, "IPAddress",
			   NULL, NULL,
			   (unsigned char *) ipaddress,
			   (size = 256, &size)) == ERROR_SUCCESS
	  && RegQueryValueEx (key, "SubnetMask",
			      NULL, NULL,
			      (unsigned char *) netmask,
			      (size = 256, &size)) == ERROR_SUCCESS)
	{
	  char *ip, *np;
	  char dhcpaddress[256], dhcpnetmask[256];
	  bool ppp = false;

	  for (ip = ipaddress, np = netmask;
	       *ip && *np;
	       ip += strlen (ip) + 1, np += strlen (np) + 1)
	    {
	      bool dhcp = false;
	      if (cygwin_inet_addr (ip) == 0L
		  && RegQueryValueEx (key, "DhcpIPAddress",
				      NULL, NULL,
				      (unsigned char *) dhcpaddress,
				      (size = 256, &size))
		  == ERROR_SUCCESS
		  && RegQueryValueEx (key, "DhcpSubnetMask",
				      NULL, NULL,
				      (unsigned char *) dhcpnetmask,
				      (size = 256, &size))
		  == ERROR_SUCCESS)
		dhcp = true;
	      if (++idx == cnt
		  && !(ifp = (struct ifall *)
			     realloc (ifret, ++cnt * sizeof (struct ifall))))
		  {
		    free (ifret);
		    return NULL;
		  }
	      ifp = ifret + idx;
	      memset (ifp, 0, sizeof *ifp);
	      /* Next in chain */
	      ifp->ifa_ifa.ifa_next = (struct ifaddrs *) &ifp[1].ifa_ifa;
	      /* Interface name */
	      if (!strncmp (bp, "NdisWan", 7))
		{
		  strcpy (ifp->ifa_name, "ppp");
		  strcat (ifp->ifa_name, bp + 7);
		  ppp = true;
		}
	      else
		{
		  ++*eth;
		  strcpy (ifp->ifa_name, "eth");
		  strcat (ifp->ifa_name, eth);
		}
	      ifp->ifa_ifa.ifa_name = ifp->ifa_name;
	      /* Flags */
	      ifp->ifa_ifa.ifa_flags = IFF_UP | IFF_LOWER_UP | IFF_RUNNING;
	      if (ppp)
		ifp->ifa_ifa.ifa_flags |= IFF_POINTOPOINT | IFF_NOARP;
	      else
		ifp->ifa_ifa.ifa_flags |= IFF_BROADCAST;
	      /* Address */
	      sin = (struct sockaddr_in *) &ifp->ifa_addr;
	      sin->sin_addr.s_addr = cygwin_inet_addr (dhcp ? dhcpaddress : ip);
	      sin->sin_family = AF_INET;
	      ifp->ifa_ifa.ifa_addr = (struct sockaddr *) &ifp->ifa_addr;
	      /* Netmask */
	      sin = (struct sockaddr_in *) &ifp->ifa_netmask;
	      sin->sin_addr.s_addr = cygwin_inet_addr (dhcp ? dhcpnetmask : np);
	      sin->sin_family = AF_INET;
	      ifp->ifa_ifa.ifa_netmask = (struct sockaddr *) &ifp->ifa_netmask;
	      if (ppp)
		{
		  /* Destination address */
		  sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
		  sin->sin_addr.s_addr =
		    cygwin_inet_addr (dhcp ? dhcpaddress : ip);
		  sin->sin_family = AF_INET;
		  ifp->ifa_ifa.ifa_dstaddr = (struct sockaddr *)
					     &ifp->ifa_brddstaddr;
		}
	      else
		{
		  /* Broadcast address */
		  lip = cygwin_inet_addr (dhcp ? dhcpaddress : ip);
		  lnp = cygwin_inet_addr (dhcp ? dhcpnetmask : np);
		  sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
		  sin->sin_addr.s_addr = (lip & lnp) | ~lnp;
		  sin->sin_family = AF_INET;
		  ifp->ifa_ifa.ifa_broadaddr = (struct sockaddr *)
					       &ifp->ifa_brddstaddr;
		}
	      /* Hardware address */
	      ; // Nothing to do... */
	      /* Metric */
	      ifp->ifa_metric = 1;
	      /* MTU */
	      ifp->ifa_mtu = 1500;
	      /* Interface index */
	      ifp->ifa_ifindex = -1;
	      /* Friendly name */
	      struct ifreq_frndlyname *iff = (struct ifreq_frndlyname *)
					     &ifp->ifa_frndlyname;
	      strcpy (iff->ifrf_friendlyname, bp);
	      iff->ifrf_len = strlen (iff->ifrf_friendlyname);
	    }
	}
      RegCloseKey (key);
    }
  /* Since every entry is set to the next entry, the last entry points to an
     invalid next entry now.  Fix it retroactively. */
  if (ifp > ifret)
    ifp->ifa_ifa.ifa_next = NULL;
  return ifret;
}

d2243 1
a2243 1
  else if (wincap.has_ip_helper_lib ())
a2244 2
  else
    ifp = get_nt_ifs ();
d2273 1
a2273 1
  else if (wincap.has_ip_helper_lib ())
a2274 2
  else
    ifret = get_nt_ifs ();
@


1.273
log
@	* net.cc (cygwin_getsockopt): Make sure SO_PEERCRED is only handled
	in level SOL_SOCKET.  Workaround a return value regression in Vista
	and later.  Add comment to explain.
@
text
@d4422 2
a4423 2
  PWCHAR lib_name = tp.w_get ();
  size_t len;
d4430 3
a4432 1
  if (GetSystemDirectoryW (lib_name, NT_MAX_PATH))
d4434 10
a4443 18
      len = wcslen (lib_name);
      wcpcpy (lib_name + len, L"\\ws2_32.dll");
      if ((lib = LoadLibraryW (lib_name)))
	{
	  if (get_ipv6_funcs (lib))
	    goto out;
	  FreeLibrary (lib);
	}
      wcpcpy (lib_name + len, L"\\wship6.dll");
      if ((lib = LoadLibraryW (lib_name)))
	{
	  if (get_ipv6_funcs (lib))
	    goto out;
	  FreeLibrary (lib);
	}
      freeaddrinfo = NULL;
      getaddrinfo = NULL;
      getnameinfo = NULL;
d4445 4
@


1.272
log
@	* net.cc: Remove calls to sig_dispatch_pending throughout.
	* libc/rexec.cc: Ditto.
@
text
@d790 1
a790 1
  else if (optname == SO_PEERCRED)
d803 28
@


1.271
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@a822 1
  sig_dispatch_pending ();
a833 1
  sig_dispatch_pending ();
a851 1
  sig_dispatch_pending ();
a864 1
  sig_dispatch_pending ();
a876 1
  sig_dispatch_pending ();
a898 1
  sig_dispatch_pending ();
a944 1
  sig_dispatch_pending ();
a1208 1
  sig_dispatch_pending ();
a1242 1
  sig_dispatch_pending ();
a1259 1
  sig_dispatch_pending ();
a1282 1
  sig_dispatch_pending ();
a1299 1
  sig_dispatch_pending ();
a1317 1
  sig_dispatch_pending ();
a1333 1
  sig_dispatch_pending ();
a1398 1
  sig_dispatch_pending ();
a1429 1
  sig_dispatch_pending ();
a2480 1
  sig_dispatch_pending ();
a2712 2
  sig_dispatch_pending ();

a2792 1
  sig_dispatch_pending ();
@


1.270
log
@	* fhandler_socket.cc (fhandler_socket::accept4): Set nonblocking
	flag exactly according to flags, as on Linux.
	* net.cc (cygwin_accept): Maintain BSD semantics here.
@
text
@d2778 1
a2778 1
	low_priority_sleep (0);
@


1.269
log
@	* cygwin.din (accept4): Export.
	* fhandler.h (fhandler_socket::accept4): Rename from accept.  Take
	additional flag parameter.
	* fhandler_socket.cc (fhandler_socket::accept4): Ditto.  Handle
	SOCK_NONBLOCK and SOCK_CLOEXEC flags.
	* net.cc (cygwin_socket): Handle SOCK_NONBLOCK and SOCK_CLOEXEC flags
	in type.  Check for invalid flag values.
	(socketpair): Ditto.
	(cygwin_accept): Accommodate renaming of fhandler_socket::accept
	function to accept4.
	(accept4): New function.
	* posix.sgml: Mention accept4 as GNU extensions.
	* include/cygwin/socket.h (SOCK_NONBLOCK): Define.
	(SOCK_CLOEXEC): Define.
	(_SOCK_FLAG_MASK): Define when building Cygwin.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/socket.h (accept4): Declare.
@
text
@d1259 1
a1259 1
    res = fh->accept4 (peer, len, 0);
@


1.268
log
@	* net.cc (cygwin_setsockopt): Only skip calling setsockopt(SO_REUSEADDR)
	on stream sockets under systems supporting enhanced socket security.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d580 10
a589 1
  debug_printf ("socket (%d, %d, %d)", af, type, protocol);
d615 4
d624 2
a625 1
  syscall_printf ("%d = socket (%d, %d, %d)", res, af, type, protocol);
d1259 1
a1259 1
    res = fh->accept (peer, len);
d1265 23
d2817 3
d2830 5
d2969 4
d2983 4
@


1.267
log
@	* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Add
	socket handle value to debug output.
	(fhandler_socket::fixup_after_fork): Ditto.  Make new socket handle
	OVERLAPPED, just as if it has been created with socket().
	* net.cc (fdsock): Close duplicated socket and explain why.  Disable
	the entire WSADuplicateSocket test for now and explain why.
@
text
@d696 3
a698 3
	 the default behaviour of socket binding is equivalent to the POSIX
	 behaviour with SO_REUSEADDR.  Setting SO_REUSEADDR would only result
	 in wrong behaviour.  See also fhandler_socket::bind(). */
d700 2
a701 1
	  && wincap.has_enhanced_socket_security ())
@


1.266
log
@	Reintegrate socket duplication via WSADuplicateSocket/WSASocket.
	* autoload.cc (WSADuplicateSocketW): Define.
	(WSASocketW): Define.
	* dtable.cc (dtable::release): Call dec_need_fixup_before if necessary.
	(dtable::fixup_before_fork): New function.
	(dtable::fixup_before_exec): New function.
	* dtable.h (class dtable): Add member cnt_need_fixup_before.  Add
	declarations for above new functions.
	(dtable::dec_need_fixup_before): New inline method.
	(dtable::inc_need_fixup_before): New inline method.
	(dtable::need_fixup_before): New inline method.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): New virtual
	method.
	(fhandler_base::need_fixup_before): New virtual method.
	(class fhandler_socket): Add member prot_info_ptr.
	(fhandler_socket::init_fixup_before): Declare.
	(fhandler_socket::need_fixup_before): New inline method.
	(fhandler_socket::fixup_before_fork_exec): Declare.
	(fhandler_socket::fixup_after_exec): Declare.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	prot_info_ptr to NULL.
	(fhandler_socket::~fhandler_socket): Free prot_info_ptr conditionally.
	(fhandler_socket::init_fixup_before): New method.
	(fhandler_socket::fixup_before_fork_exec): Ditto.
	(fhandler_socket::fixup_after_fork): Use WSASocketW to duplicate
	socket if necessary.
	(fhandler_socket::fixup_after_exec): New method.
	(fhandler_socket::dup): Use fixup_before_fork_exec/fixup_after_fork
	to duplicate socket if necessary.
	* fork.cc (frok::parent): Start child suspended if some fhandler
	needs fixup before fork.  If so, call dtable::fixup_before_fork after
	CreateProcess and resume child.
	* net.cc (fdsock): Try to find out if socket needs fixup before and
	initialize socket accordingly.  Add HUGE comment to explain what happens
	and why.
	* spawn.cc (spawn_guts): Start child suspended if some fhandler needs
	fixup before exec.  If so, call dtable::fixup_before_exec after
	CreateProcess.
@
text
@d513 1
a513 1
     some incredible amount of extra processing so we only do this on
d519 3
d523 1
d525 2
a526 1
      || !(flags & HANDLE_FLAG_INHERIT)
d528 4
d533 1
@


1.265
log
@	* net.cc (fdsock): Fill _rmem and _wmem with valid values returned
	from getsockopt if setsockopt with desired values failed.
@
text
@d498 28
@


1.264
log
@	* (fhandler_socket::getsockname): Fix length returned for unbound
	AF_LOCAL sockets.
	(fhandler_socket::getpeername): Ditto.
	* net.cc (socketpair): Don't set sun_path and peer_sun_path to
	make sure getsockname and getpeername return the correct values
	for AF_LOCAL sockets.
@
text
@d486 2
a510 1

d515 7
a521 1
    debug_printf ("setsockopt(SO_RCVBUF) failed, %lu", WSAGetLastError ());
d524 7
a530 1
    debug_printf ("setsockopt(SO_SNDBUF) failed, %lu", WSAGetLastError ());
@


1.263
log
@	* fhandler.h (class fhandler_socket): Add peer_sun_path member.
	(fhandler_socket::set_peer_sun_path): New method.
	(fhandler_socket::get_peer_sun_path): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	peer_sun_path to NULL.
	(fhandler_socket::~fhandler_socket): Free peer_sun_path if necessary.
	(fhandler_socket::dup): Duplicate peer_sun_path.
	(fhandler_socket::accept): Ditto.  Return fake unbound peer content
	and len in case of AF_LOCAL sockets.
	(fhandler_socket::getsockname): Always use local sockaddr_storage to
	store socket address and copy over to incoming address.  Handle every
	namelen correctly per POSIX.
	(fhandler_socket::getpeername): Ditto.  Add code path to return
	correct value for AF_LOCAL sockets.
	(fhandler_socket::set_peer_sun_path): New method.
	* net.cc (socketpair): Set peer_sun_path to empty string, just like
	sun_path.
@
text
@a2868 2
	((fhandler_socket *) sb0)->set_sun_path ("");
	((fhandler_socket *) sb0)->set_peer_sun_path ("");
a2878 2
	    ((fhandler_socket *) sb1)->set_sun_path ("");
	    ((fhandler_socket *) sb1)->set_peer_sun_path ("");
@


1.262
log
@	* net.cc (cygwin_getnameinfo): Force setting NI_NUMERICSERV only
	on Windows 2003 and earlier, only if the port number doesn't
	resolve to a well-known service.  Change comment accordingly.
@
text
@d2870 1
d2882 1
@


1.261
log
@* fhandler_socket.cc (fhandler_socket::send_internal): Just use wmem size if
the length exceeds it.
* net.cc (fdsock): Use 65535 as window size, just like the comment says or we
run into problems with DuplicateHandle.
* path.cc (patch_conv::check): Use set_path to set invalid filename.
* path.h (path_conv::path_conv): Ditto.
@
text
@d4461 7
a4467 5
  /* When the incoming port number is set to 0, Winsock's getnameinfo
     returns with error WSANO_DATA instead of simply ignoring the port.
     To avoid this strange behaviour, we check manually, if the port number
     is 0.  If so, set the NI_NUMERICSERV flag to avoid this problem. */
  switch (sa->sa_family)
d4469 12
a4480 6
    case AF_INET:
      if (((struct sockaddr_in *) sa)->sin_port == 0)
	flags |= NI_NUMERICSERV;
      break;
    case AF_INET6:
      if (((struct sockaddr_in6 *) sa)->sin6_port == 0)
a4481 1
      break;
@


1.260
log
@	* net.cc (get_xp_ifs): Fix typo in comment.
@
text
@d510 2
a511 2
  ((fhandler_socket *) fd)->rmem () = 65536;
  ((fhandler_socket *) fd)->wmem () = 65536;
@


1.259
log
@	* fhandler.h (class fhandler_socket): Add class members and methods
	to store and retrieve the SO_RCVBUF and SO_SNDBUF sizes.
	* fhandler_socket.cc (fhandler_socket::dup): Duplicate new members.
	(fhandler_socket::send_internal): Check for SO_SNDBUF size and
	restrict send to 1 byte less per KB 823764.  Leave loop immediately
	if WSASendMsg has been used.
	* net.cc (fdsock): Change comment again.  Set buffer sizes to 65536.
	Store values in fhandler_socket.
	(cygwin_setsockopt): Store SO_RCVBUF and SO_SNDBUF sizes in
	fhandler_socket.
	(cygwin_sendto): Drop call to sig_dispatch_pending.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
@
text
@d1769 1
a1769 1
	   Fetch number of configured IPva addresses from registry and
@


1.258
log
@	* net.cc (fdsock): Set default socket buffer sizes to 65520.  Change
	comment accordingly.
	* fhandler_socket.cc (fhandler_socket::send_internal): Set maximum
	send size to 65520 as well.
@
text
@d498 3
d502 5
a506 3
     connected to a remote machine, then duplicating the socket on fork/exec
     fails with WinSock error 10022, WSAEINVAL.  An explanation for this
     weird behaviour would be nice.
d510 4
a513 3
  int rmem = 65520;
  int wmem = 65520;
  if (::setsockopt (soc, SOL_SOCKET, SO_RCVBUF, (char *) &rmem, sizeof (int)))
d515 2
a516 1
  if (::setsockopt (soc, SOL_SOCKET, SO_SNDBUF, (char *) &wmem, sizeof (int)))
a569 1
  sig_dispatch_pending ();
a590 1
  sig_dispatch_pending ();
d691 15
a705 2
      else if (level == SOL_SOCKET && optname == SO_REUSEADDR)
	fh->saw_reuseaddr (*(int *) optval);
a2921 1
  sig_dispatch_pending ();
a2943 1
  sig_dispatch_pending ();
@


1.257
log
@	* net.cc (get_flags): New static function to generate interface flags
	value.
	(get_ipv4fromreg_ipcnt): New static function to fetch number of
	configured IPv4 addresses for a given NIC from registry.
	(get_ipv4fromreg): New static function to fetch configured IPv4
	addresses for a given NIC from registry.
	(get_friendlyname): New static function to generate friendly name.
	(get_hwaddr): New static function to copy hardware address.
	(get_xp_ifs): Restructure slightly.  Add code to generate IPv4 entries
	entries for interfaces which are disconnected.
@
text
@a494 2
#if 0
  /* Same default buffer sizes as on Linux (instead of WinSock default 8K).
d496 6
a501 7
     NOT.  If the SO_RCVBUF size exceeds 65535(*), and if the socket is
     connected to a remote machine, then duplicating the socket on
     fork/exec fails with WinSock error 10022, WSAEINVAL.  Given that,
     there's not any good reason to set the buffer sizes at all.  So we
     stick with the defaults.  However, an explanation for this weird
     behaviour would be nice.  I keep this stuff in the code for later
     generations.  Archeological programmers might find it useful.
d505 2
a506 2
  int rmem = dev == tcp_dev ? 87380 : 120832;
  int wmem = dev == tcp_dev ? 16384 : 120832;
d511 1
a511 1
#endif
@


1.256
log
@* path.cc (cwdstuff::set): Avoid removing a nonexistent trailing slash.
@
text
@d1590 143
d1751 9
a1759 1
    for (pua = pap->FirstUnicastAddress; pua; pua = pua->Next)
d1768 44
a1811 4
      int idx = 0;
      for (pua = pap->FirstUnicastAddress; pua; pua = pua->Next)
	{
	  struct sockaddr *sa = (struct sockaddr *) pua->Address.lpSockaddr;
d1814 82
a1895 90
	  size_t sa_size = (sa->sa_family == AF_INET6
			    ? sizeof *sin6 : sizeof *sin);
	  /* Next in chain */
	  ifp->ifa_ifa.ifa_next = (struct ifaddrs *) &ifp[1].ifa_ifa;
	  /* Interface name */
	  if (!idx)
	    strcpy (ifp->ifa_name, pap->AdapterName);
	  else
	    __small_sprintf (ifp->ifa_name, "%s:%u", pap->AdapterName, idx);
	  ifp->ifa_ifa.ifa_name = ifp->ifa_name;
	  ++idx;
	  /* Flags */
	  ifp->ifa_ifa.ifa_flags = IFF_UP;
	  if (pap->IfType == IF_TYPE_SOFTWARE_LOOPBACK)
	    ifp->ifa_ifa.ifa_flags |= IFF_LOOPBACK;
	  else if (pap->IfType == IF_TYPE_PPP)
	    ifp->ifa_ifa.ifa_flags |= IFF_POINTOPOINT;
	  else if (sa->sa_family == AF_INET)
	    ifp->ifa_ifa.ifa_flags |= IFF_BROADCAST;
	  if (!(pap->Flags & IP_ADAPTER_NO_MULTICAST))
	    ifp->ifa_ifa.ifa_flags |= IFF_MULTICAST;
	  if (pap->OperStatus == IfOperStatusUp
	      || pap->OperStatus == IfOperStatusUnknown)
	    ifp->ifa_ifa.ifa_flags |= IFF_RUNNING;
	  if (pap->OperStatus != IfOperStatusLowerLayerDown)
	    ifp->ifa_ifa.ifa_flags |= IFF_LOWER_UP;
	  if (pap->OperStatus == IfOperStatusDormant)
	    ifp->ifa_ifa.ifa_flags |= IFF_DORMANT;
	  if (sa->sa_family == AF_INET)
	    {
	      ULONG hwaddr[2], hwlen = 6;
	      if (SendARP (sin->sin_addr.s_addr, 0, hwaddr, &hwlen))
		ifp->ifa_ifa.ifa_flags |= IFF_NOARP;
	    }
	  /* Address */
	  memcpy (&ifp->ifa_addr, sa, sa_size);
	  ifp->ifa_ifa.ifa_addr = (struct sockaddr *) &ifp->ifa_addr;
	  /* Netmask */
	  int prefix = ip_addr_prefix (pua, pap->FirstPrefix);
	  switch (sa->sa_family)
	    {
	    case AF_INET:
	      if_sin = (struct sockaddr_in *) &ifp->ifa_netmask;
	      if_sin->sin_addr.s_addr = htonl (UINT32_MAX << (32 - prefix));
	      if_sin->sin_family = AF_INET;
	      break;
	    case AF_INET6:
	      if_sin6 = (struct sockaddr_in6 *) &ifp->ifa_netmask;
	      for (cnt = 0; cnt < 4 && prefix; ++cnt, prefix -= 32)
		if_sin6->sin6_addr.s6_addr32[cnt] = UINT32_MAX;
		if (prefix < 32)
		  if_sin6->sin6_addr.s6_addr32[cnt] <<= 32 - prefix;
	      break;
	    }
	  ifp->ifa_ifa.ifa_netmask = (struct sockaddr *) &ifp->ifa_netmask;
	  if (pap->IfType == IF_TYPE_PPP)
	    {
	      /* Destination address */
	      if (sa->sa_family == AF_INET)
		{
		  if_sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
		  if_sin->sin_addr.s_addr = get_routedst (pap->IfIndex);
		  if_sin->sin_family = AF_INET;
		}
	      else
		/* FIXME: No official way to get the dstaddr for ipv6? */
		memcpy (&ifp->ifa_addr, sa, sa_size);
	      ifp->ifa_ifa.ifa_dstaddr = (struct sockaddr *)
					 &ifp->ifa_brddstaddr;
	    }
	  else
	    {
	      /* Broadcast address  */
	      if (sa->sa_family == AF_INET)
		{
		  if_sin = (struct sockaddr_in *) &ifp->ifa_brddstaddr;
		  uint32_t mask =
		  ((struct sockaddr_in *) &ifp->ifa_netmask)->sin_addr.s_addr;
		  if_sin->sin_addr.s_addr = (sin->sin_addr.s_addr & mask) | ~mask;
		  if_sin->sin_family = AF_INET;
		  ifp->ifa_ifa.ifa_broadaddr = (struct sockaddr *)
					       &ifp->ifa_brddstaddr;
		}
	      else /* No IPv6 broadcast */
		ifp->ifa_ifa.ifa_broadaddr = NULL;
	    }
	  /* Hardware address */
	  for (UINT i = 0; i < IFHWADDRLEN; ++i)
	    if (i >= pap->PhysicalAddressLength)
	      ifp->ifa_hwaddr.sa_data[i] = '\0';
d1897 8
a1904 19
	      ifp->ifa_hwaddr.sa_data[i] = pap->PhysicalAddress[i];
	  /* Metric */
	  if (wincap.has_gaa_on_link_prefix ())
	    ifp->ifa_metric = (sa->sa_family == AF_INET
			      ? ((PIP_ADAPTER_ADDRESSES_LH) pap)->Ipv4Metric
			      : ((PIP_ADAPTER_ADDRESSES_LH) pap)->Ipv6Metric);
	  else
	    ifp->ifa_metric = 1;
	  /* MTU */
	  ifp->ifa_mtu = pap->Mtu;
	  /* Interface index */
	  ifp->ifa_ifindex = pap->IfIndex;
	  /* Friendly name */
	  struct ifreq_frndlyname *iff = (struct ifreq_frndlyname *)
					 &ifp->ifa_frndlyname;
	  iff->ifrf_len = sys_wcstombs (iff->ifrf_friendlyname,
					IFRF_FRIENDLYNAMESIZ,
					pap->FriendlyName);
	  ++ifp;
d1907 1
a1907 1
	}
@


1.255
log
@* net.cc (gethostby_helper): Use correct signedness.
@
text
@a65 1

a120 1

@


1.254
log
@* net.cc: Undefine NOERROR and DELETE to avoid compiler warnings.
* shared_info.h (CURR_SHARED_MAGIC): Update.
* spawn.cc (spawn_guts): Avoid copying one line command line argument if it
hasn't been filled out.
@
text
@d52 1
a52 1
#define _CYGWIN_IN_H 
d66 1
a66 1
  
d885 1
a885 1
static void 
d893 1
a893 1
static hostent * 
d919 1
a919 1
    } 
d932 1
a932 1
      return NULL; 
d937 1
a937 1
  /* We scan the answer records to determine the required memory size. 
d944 1
a944 1
     - the first 16 bits of the "ttl" store the expanded name size + 1 
d947 1
a947 1
  
d963 2
a964 1
  int complen, namelen1 = 0, address_len = 0, antype, anclass, ansize;
d972 1
a972 1
    goto corrupted;    
d975 1
a975 1
  
d994 1
a994 1
      if (antype == ns_t_cname) 
d1032 1
a1032 1
  
d1040 1
a1040 1
  if (! ret) 
d1054 1
a1054 1
 
d1062 1
a1062 1
      if (antype == ns_t_cname) 
d1066 1
a1066 1
	  if (complen != curptr->complen)  
d1072 1
a1072 1
	  string_size -= namelen1;	  
d1081 1
a1081 1
		  if (complen != curptr->complen)  
d1087 1
a1087 1
		  string_size -= namelen1;	  
d1104 1
a1104 1
  if (string_size < 0)  
d1106 2
a1107 2
#endif      
  
d1112 1
a1112 1
 
d1147 1
a1147 1
  switch (af) 
d1163 1
a1163 1
  
d1449 2
a1450 2
  struct sockaddr         Address;
  struct sockaddr_in      AddressIn;
d1455 4
a1458 4
  u_long          iiFlags;
  sockaddr_gen    iiAddress;
  sockaddr_gen    iiBroadcastAddress;
  sockaddr_gen    iiNetmask;
d1462 1
a1462 1
#define IN_LOOPBACK(a)          ((((long int) (a)) & 0xff000000) == 0x7f000000)
d2364 1
a2364 1
	        if (pap2->Ipv6IfIndex == 1)
@


1.253
log
@	* net.cc (inet_ntop6): Convert to lowercase hex digits on the fly.
@
text
@d17 6
@


1.252
log
@	* net.cc (cygwin_getaddrinfo): Check hints for non-NULL before
	checking its content.
@
text
@d3086 6
a3091 1
      tp += strlen(tp);
@


1.251
log
@	* gethostby_helper: Fix typos in DEBUGGING case.
@
text
@d4216 1
@


1.250
log
@	* cygwin.din: Export gethostbyname2.
	* net.cc: define _CYGWIN_IN_H and include resolv.h.
	(realloc_ent): New function.
	(dup_ent): Call realloc_ent.
	(memcpy4to6): New function.
	(dn_length1): New function.
	(gethostby_helper): New function.
	(gethostbyname2): New function.
	* posix.sgml: Add gethostbyname2.
	* include/cygwin/version.h: Bump API minor number.
	* libc/minires.c (get_options): Look for "inet6" and apply bounds
	to "retry" and "retrans".
	(res_ninit): Set the default options at the beginning.
	(dn_expand): Fix "off by one".
@
text
@d1060 1
a1060 1
	    go to debugging;
d1075 1
a1075 1
		    go to debugging;
d1093 1
a1093 1
      go to debugging;
d1098 1
a1098 1
    go to debugging;
@


1.249
log
@	* net.cc: Include asm/byteorder.h.
	(htonl): Move to end of file.  Add comment to explain why.  Align
	definition to POSIX.  Use related macro from asm/byteorder.h.
	(ntohl): Ditto.
	(htons): Ditto.
	(ntohs): Ditto.
	* include/asm/byteorder.h: Revert previous patch.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d46 2
d58 3
d272 19
d337 1
a337 1
  /* Every *ent begins with a name.  Calculate it's length. */
d382 2
a383 7
  /* Allocate the storage needed.  Allocate a rounded size to attempt to force
     reuse of this buffer so that a poorly-written caller will not be using
     a freed buffer. */
  unsigned rsz = 256 * ((sz + 255) / 256);
  dst = (unionent *) realloc (dst, rsz);

  if (dst)
d879 281
a2788 4
#define	IN6ADDRSZ	16
#define	INADDRSZ	 4
#define	INT16SZ		 2

@


1.248
log
@* cygtls.h (unionent): Move from net.cc.
(unionent::struct_type): Move enum here.
(_local_storage::hostent_buf): Define as unionent.
(_local_storage::protoent_buf): Ditto.
(_local_storage::servent_buf): Ditto.
* net.cc (unionent): Move to cygtls.h.
(struct_type): Ditto.
(dup_ent): Define one function per {host,proto,serv}ent type.
(cygwin_getprotobyname): Simplify dup_ent call.  Removed now-unneeded return
type coercion.
(cygwin_getprotobynumber): Ditto.
(cygwin_getservbyname): Ditto.
(cygwin_getservbyport): Ditto.
(cygwin_gethostbyname): Ditto.
(cygwin_gethostbyaddr): Ditto.  tlsoffsets.h: Regenerate.
@
text
@d26 1
a76 32
/* htonl: standards? */
extern "C" unsigned long int
htonl (unsigned long int x)
{
  return ((((x & 0x000000ffU) << 24) |
	   ((x & 0x0000ff00U) << 8) |
	   ((x & 0x00ff0000U) >> 8) |
	   ((x & 0xff000000U) >> 24)));
}

/* ntohl: standards? */
extern "C" unsigned long int
ntohl (unsigned long int x)
{
  return htonl (x);
}

/* htons: standards? */
extern "C" unsigned short
htons (unsigned short x)
{
  return ((((x & 0x000000ffU) << 8) |
	   ((x & 0x0000ff00U) >> 8)));
}

/* ntohs: standards? */
extern "C" unsigned short
ntohs (unsigned short x)
{
  return htons (x);
}

d3991 2
a3992 1
/* The below function has been taken from OpenBSD's src/sys/netinet6/in6.c. */
d4076 36
@


1.247
log
@* net.cc (in6addr_any, in6addr_loopback): Add appropriate number of braces
around initializer.
(dup_ent): Try harder to coerce the first argument to deal with more stringent
compiler.
(get_2k_ifs): Remove extraneous typedef.
(get_2k_ifs): Reorganize expression to avoid a compiler warning.
(get_xp_ifs): Ditto.
(get_nt_ifs): Ditto.
@
text
@a295 18
struct unionent
{
  char *name;
  char **list;
  short port_proto_addrtype;
  short h_len;
  union
  {
    char *s_proto;
    char **h_addr_list;
  };
};

enum struct_type
{
  t_hostent, t_protoent, t_servent
};

a306 2
/* FIXME: Use an overloaded function or template here. */
#define dup_ent(old, src, type) __dup_ent ((unionent *&) *((unionent *) _my_tls.locals.old), (unionent *) (src), type)
d312 1
a312 1
__dup_ent (unionent *&dst, unionent *src, struct_type type)
d316 1
a316 1
		  ((unionent *) dst)->name, dst);
d330 1
a330 1
    case t_protoent:
d333 1
a333 1
    case t_servent:
d336 1
a336 1
    case t_hostent:
d369 1
a369 1
  if (type == t_servent)
d374 1
a374 1
  else if (type == t_hostent)
a394 1
  /* Hopefully, this worked. */
d426 1
a426 1
      if (type == t_protoent)
d428 1
a428 1
      else if (type == t_servent)
d436 1
a436 1
      else if (type == t_hostent)
d456 18
d481 1
a481 1
  return (protoent *) dup_ent (protoent_buf, getprotobyname (p), t_protoent);
d488 1
a488 1
  return (protoent *) dup_ent (protoent_buf, getprotobynumber (number), t_protoent);
d786 1
a786 1
  servent *res = (servent *) dup_ent (servent_buf, getservbyname (name, proto), t_servent);
d800 2
a801 2
  servent *res = (servent *) dup_ent (servent_buf, getservbyport (port, proto), t_servent);
  syscall_printf ("%p = getservbyport (%d, %s)", _my_tls.locals.servent_buf, port, proto);
d863 1
a863 1
  hostent *res = (hostent *) dup_ent (hostent_buf, h, t_hostent);
d883 1
a883 1
  hostent *res = (hostent *) dup_ent (hostent_buf, gethostbyaddr (addr, len, type), t_hostent);
d885 1
a885 1
    debug_printf ("h_name %s", _my_tls.locals.hostent_buf->h_name);
@


1.246
log
@	* autoload.cc (GetExtendedTcpTable): Define.
	* fhandler_socket.cc (address_in_use): Take const struct sockaddr
	pointer as argument.  Implement additional AF_INET6 table check.
	(fhandler_socket::bind): Drop AF_INET test before calling
	address_in_use.
	* net.cc (ipv4_getnameinfo): Return EAI_FAMILY instead of 1 if
	called with unsupported af_family.
@
text
@d57 2
a58 2
const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
d325 2
a326 1
#define dup_ent(old, src, type) __dup_ent ((unionent *&) (_my_tls.locals.old), (unionent *) (src), type)
d1430 1
a1430 1
		  if_sin->sin_addr.s_addr = sin->sin_addr.s_addr & mask | ~mask;
d1493 1
a1493 1
  typedef struct ifcount_t
d1640 1
a1640 2
	      if_sin->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr
					& mask | ~mask;
d1892 1
a1892 1
		  sin->sin_addr.s_addr = lip & lnp | ~lnp;
@


1.245
log
@	* fhandler_socket.cc (fhandler_socket::bind): Don't run explicit
	local socket test in SO_REUSEADDR case on systems supporting
	enhanced socket security.  Explain why.  Only call address_in_use
	for AF_INET sockets.
	* net.cc (cygwin_setsockopt): Don't call setsockopt to set SO_REUSEADDR
	on systems supporting enhanced socket security.  Add comment.
	* wincap.h (wincaps::has_enhanced_socket_security): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d3768 1
a3768 1
      return (1);
@


1.244
log
@	* net.cc (ipv6_inited): Make NO_COPY.
@
text
@d652 10
a661 2
      res = setsockopt (fh->get_socket (), level, optname,
			(const char *) optval, optlen);
@


1.243
log
@	* net.cc (cygwin_bindresvport_sa): Fix usage of last_used_bindresvport.
@
text
@d3839 1
a3839 1
static bool ipv6_inited = false;
@


1.242
log
@	* net.cc (if_nametoindex): Fix typo in call to get_adapters_addresses.
	(if_indextoname): Prefer IPv6 loopback device name over IPv4 loopback
	device name on pre-Vista systems.
	(if_nameindex): Ditto.
@
text
@d2222 1
a2222 1
      while ((myport = InterlockedExchange (&cygwin_shared->last_used_bindresvport, 0)) == 0)
d2224 1
a2224 1
      if (--myport < PORT_LOW)
@


1.241
log
@	* fhandler_procnet.cc (format_procnet_ifinet6): Use sprintf rather than
	__small_sprintf.
	* net.cc (if_nametoindex): Prefer IPv6IfIndex over IfIndex for
	consistency with /proc/net/if_inet6.
	(if_indextoname): Ditto.
	(if_nameindex): Ditto.
@
text
@d2040 1
a2040 1
      && get_adapters_addresses (&pap, AF_UNSPEC))
d2075 13
d2130 8
@


1.240
log
@	* fhandler.h (-struct wsa_event): Move to wsa_event.h.  Include
	wsa_event.h instead.
	* fhandler_socket.cc (NUM_SOCKS): Move to wsa_event.h.
	(wsa_events): Move from DLL shared area to cygwin_shared shared
	memory.  Accommodate throughout.
	(socket_serial_number): Ditto.
	* fhandler_tape.cc (mt): Ditto.
	(mtinfo_init): Remove.
	(mt): Define as cygwin_shared->mt.
	* flock.cc (FLOCK_PARENT_DIR_ACCESS): Remove.
	(FLOCK_INODE_DIR_ACCESS): Move up in file.
	(FLOCK_MUTANT_ACCESS): Ditto.
	(FLOCK_EVENT_ACCESS): Ditto.
	(get_lock_parent_dir): Remove.
	(inode_t::inode_t): Call get_shared_parent_dir to get parent dir handle.
	Add a "flock-" prefix to file's lock directory name for clarity.
	* mtinfo.h (mtinfo_init): Drop declaration.
	* net.cc (last_used_bindresvport): Move from DLL shared area to
	cygwin_shared shared memory.
	(cygwin_bindresvport_sa): Accommodate above change.
	* sec_helper.cc (_everyone_sd): Move here from flock.cc.
	* security.h (SD_MIN_SIZE): Ditto.
	(everyone_sd): Ditto.
	* shared.cc (cygwin_shared_area): Remove.
	(cygwin_shared_h): New handle.
	(get_shared_parent_dir): New static function.
	(shared_name): Drop session_local argument.  Call get_shared_parent_dir
	here.  Add cygwin-shared subdir to object name.
	(offsets): Reinstantiate SH_CYGWIN_SHARED member.
	(open_shared): Revert change from 2007-03-29 for systems supporting
	SeCreateGlobalPrivilege.
	(shared_info::initialize): Call mtinfo's initialize here.
	(memory_init): Drop call to mtinfo_init.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add members for global socket and tape info
	sharing.
	(enum shared_locations): Reinstantiate SH_CYGWIN_SHARED.
	(get_shared_parent_dir): Declare.
	(shared_name): Drop session_local argument from declaration.
	* wsa_event.h: New file.  Move definitions of NUM_SOCKS and
	struct wsa_event here.
@
text
@d2051 1
a2051 1
	    index = pap->IfIndex;
d2073 1
a2073 1
	if (ifindex == pap->IfIndex)
d2113 1
a2113 1
		if (iflist[i].if_index == (pap->IfIndex ?: pap->Ipv6IfIndex))
d2115 1
a2115 1
	      iflist[cnt].if_index = pap->IfIndex ?: pap->Ipv6IfIndex;
@


1.239
log
@Remove unneeded header files from source files throughout.
@
text
@d33 1
a2143 2
LONG last_used_bindresvport __attribute__((section (".cygwin_dll_common"), shared)) = IPPORT_RESERVED;

d2201 1
a2201 1
      while ((myport = InterlockedExchange (&last_used_bindresvport, 0)) == 0)
d2205 1
a2205 1
      InterlockedExchange (&last_used_bindresvport, myport);
@


1.238
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a19 3
#include <sys/socket.h>
#include <sys/un.h>
#include <syslog.h>
a38 1
#include "pinfo.h"
@


1.237
log
@	Cleanup.
	* exceptions.cc (windows_system_directory): Make static.  Convert to
	WCHAR.
	(_cygtls::inside_kernel): Accommodate above change.  Check module
	path name for leading \\?\ and skip, if so.
	(try_to_debug): Call GetEnvironmentStringsW and convert evaluation to
	WCHAR to avoid truncated environment problem.
	(has_visible_window_station): Call GetUserObjectInformationW.
	(events_init): Accommodate above conversion of windows_system_directory.
	* init.cc (respawn_wow64_process): Use WCHAR functions to start new
	process.
	* net.cc (__dup_ent): Drop Windows 9x consideration.
	(load_ipv6_funcs): Use WCHAR functions to load IPv6 libs.
	* syscalls.cc (syscalls.cc): Remove call to GetDiskFreeSpace.
@
text
@d17 1
@


1.236
log
@	* net.cc (load_ipv6_funcs): Use MAX_PATH instead of CYG_MAX_PATH.
	(cygwin_getaddrinfo): Simplify formatting.
	(cygwin_getnameinfo): Ditto.
@
text
@d18 1
d46 1
a389 1
  char *s_proto = NULL;
d393 1
a393 9
	{
	  /* Windows 95 idiocy.  Structure is misaligned on Windows 95.
	     Kludge around this by trying a different pointer alignment.  */
	  if (!IsBadStringPtr (src->s_proto, INT32_MAX))
	    s_proto = src->s_proto;
	  else if (!IsBadStringPtr (((pservent *) src)->s_proto, INT32_MAX))
	    s_proto = ((pservent *) src)->s_proto;
	  sz += (protolen = strlen_round (s_proto));
	}
d452 1
a452 1
	  if (s_proto)
d454 1
a454 1
	      strcpy (dst->s_proto = dp, s_proto);
d3828 2
a3829 2

  char lib_name[MAX_PATH];
d3837 1
a3837 1
  if (GetSystemDirectory (lib_name, MAX_PATH))
d3839 3
a3841 3
      len = strlen (lib_name);
      strcpy (lib_name + len, "\\ws2_32.dll");
      if ((lib = LoadLibrary (lib_name)))
d3847 2
a3848 2
      strcpy (lib_name + len, "\\wship6.dll");
      if ((lib = LoadLibrary (lib_name)))
@


1.235
log
@* fork.cc: White space.
* net.cc: Ditto.
* posix_ipc.cc: Ditto.
@
text
@d3836 1
a3836 1
  char lib_name[CYG_MAX_PATH];
d3844 1
a3844 1
  if (GetSystemDirectory (lib_name, CYG_MAX_PATH))
d3903 20
a3922 1
  if (getaddrinfo)
d3924 23
a3946 17
      struct addrinfo nhints, *dupres;

      /* AI_ADDRCONFIG is not supported prior to Vista.  Rather it's
	 the default and only possible setting.
	 On Vista, the default behaviour is as if AI_ADDRCONFIG is set,
	 apparently for performance reasons.  To get the POSIX default
	 behaviour, the AI_ALL flag has to be set. */
      if (wincap.supports_all_posix_ai_flags ()
	  && hints && hints->ai_family == PF_UNSPEC)
	{
	  nhints = *hints;
	  hints = &nhints;
	  nhints.ai_flags |= AI_ALL;
	}
      int ret = w32_to_gai_err (getaddrinfo (hostname, servname, hints, res));
      /* Always copy over to self-allocated memory. */
      if (!ret)
d3948 2
a3949 3
	  dupres = ga_duplist (*res, false);
	  freeaddrinfo (*res);
	  *res = dupres;
a3950 19
	    return EAI_MEMORY;
	}
      /* AI_V4MAPPED and AI_ALL are not supported prior to Vista.  So, what
	 we do here is to emulate AI_V4MAPPED.  If no IPv6 addresses are
	 returned, or the AI_ALL flag is set, we try with AF_INET again, and
	 convert the returned IPv4 addresses into v4-in-v6 entries.  This
	 is done in ga_dup if the v4mapped flag is set. */
      if (!wincap.supports_all_posix_ai_flags ()
	  && hints->ai_family == AF_INET6
	  && (hints->ai_flags & AI_V4MAPPED)
	  && (ret == EAI_NODATA || ret == EAI_NONAME
	      || (hints->ai_flags & AI_ALL)))
	{
	  struct addrinfo *v4res;
	  nhints = *hints;
	  nhints.ai_family = AF_INET;
	  int ret2 = w32_to_gai_err (getaddrinfo (hostname, servname,
						  &nhints, &v4res));
	  if (!ret2)
a3951 10
	      dupres = ga_duplist (v4res, true);
	      freeaddrinfo (v4res);
	      if (!dupres)
		{
		  if (!ret)
		    ipv4_freeaddrinfo (*res);
		  return EAI_MEMORY;
		}
	      /* If a list of v6 addresses exists, append the v4-in-v6 address
		 list.  Otherwise just return the v4-in-v6 address list. */
d3953 11
a3963 9
		{
		  struct addrinfo *ptr;
		  for (ptr = *res; ptr->ai_next; ptr = ptr->ai_next)
		    ;
		  ptr->ai_next = dupres;
		}
	      else
		*res = dupres;
	      ret = 0;
d3965 3
a3968 1
      return ret;
d3970 1
a3970 1
  return ipv4_getaddrinfo (hostname, servname, hints, res);
d3982 8
a3989 1
  if (getnameinfo)
d3991 8
a3998 20
      /* When the incoming port number is set to 0, Winsock's getnameinfo
	 returns with error WSANO_DATA instead of simply ignoring the port.
	 To avoid this strange behaviour, we check manually, if the port number
	 is 0.  If so, set the NI_NUMERICSERV flag to avoid this problem. */
      switch (sa->sa_family)
	{
	case AF_INET:
	  if (((struct sockaddr_in *) sa)->sin_port == 0)
	    flags |= NI_NUMERICSERV;
	  break;
	case AF_INET6:
	  if (((struct sockaddr_in6 *) sa)->sin6_port == 0)
	    flags |= NI_NUMERICSERV;
	  break;
	}
      int ret = w32_to_gai_err (getnameinfo (sa, salen, host, hostlen, serv,
					     servlen, flags));
      if (ret)
	set_winsock_errno ();
      return ret;
d4000 5
a4004 1
  return ipv4_getnameinfo (sa, salen, host, hostlen, serv, servlen, flags);
@


1.234
log
@	* autoload.cc (WSAIoctl): Remove.
	* cygwin.din: Export freeifaddrs, getifaddrs.
	* fhandler_socket.cc (fhandler_socket::ioctl): Drop SOCKET parameter
	from get_ifconf.
	* net.cc: Include ifaddrs.h.
	(in_are_prefix_equal): Match addresses in network byte order.
	(ip_addr_prefix): Convert address into host byte order before
	testing with IN_LOOPBACK.
	(struct ifall): Define.
	(get_xp_ifs): Replace get_xp_ifconf.  Return struct ifall array.
	(get_2k_ifs): Ditto, replace get_2k_ifconf.
	(get_nt_ifs): Ditto, replace get_nt_ifconf.
	(getifaddrs): New function.
	(freeifaddrs): New function.
	(get_ifconf): Call matching get_XX_ifs function and create
	ifc content from here.  Drop lo fake since it's now in get_nt_ifs.
	* posix.sgml: Add freeifaddrs and getifaddrs to list of implemented
	BSD functions.
	* wincap.h (wincapc::has_broken_if_oper_status): New element.
	* wincap.cc: Implement above element throughout.
	* include/ifaddrs.h: New file.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1299 1
a1299 1
        if (pift->table[i].dwForwardIfIndex == if_index
d1411 1
a1411 1
	        {
d1420 1
a1420 1
	      				 &ifp->ifa_brddstaddr;
d1428 1
a1428 1
		  uint32_t mask = 
d1607 1
a1607 1
	         two values, 0 or 1, non operational, operational. */
d1628 1
a1628 1
	      	get_routedst (ipt->table[ip_cnt].dwIndex);
d1749 1
a1749 1
        ++cnt;
d1791 1
a1791 1
  				  &ifp->ifa_frndlyname;
d1878 1
a1878 1
	        {
d1888 1
a1888 1
	        {
d1981 1
a1981 1
        {
@


1.233
log
@	* autoload.cc (GetIpForwardTable): Define.
	* fhandler_socket.cc (fhandler_socket::ioctl): Handle SIOCGIFDSTADDR.
	* net.cc (get_routedst): New static function to get destination
	address of point-to-point interfaces.
	(get_xp_ifconf): Handle SIOCGIFDSTADDR.
	(get_2k_ifconf): Ditto.
	(get_nt_ifconf): Ditto.
	(get_ifconf): Ditto.
	* include/asm/socket.h (SIOCGIFDSTADDR): Define.
	* include/cygwin/if.h (struct ifreq): Add ifru_dstaddr member.
	(ifr_dstaddr): Define.
	* include/cygwin/in.h: Cast ipv4 addresses correctly to in_addr_t in
	definitions.
@
text
@d44 1
d1199 1
a1199 1
  return (p1->s_addr & pfxmask) == (p2->s_addr & pfxmask);
d1211 2
a1212 2
      if (IN_LOOPBACK (((struct sockaddr_in *)
			pua->Address.lpSockaddr)->sin_addr.s_addr))
d1306 13
d1320 2
a1321 2
 * IFCONF XP SP1 and above.
 * Use IP Helpper function GetAdaptersAddresses.
d1323 2
a1324 3

static void
get_xp_ifconf (SOCKET s, struct ifconf *ifc, int what)
a1327 1
  LPINTERFACE_INFO iie;
d1329 3
a1331 1
  DWORD size = 0;
d1333 1
a1333 1
  if (!get_adapters_addresses (&pa0, AF_INET))
a1338 11
  /* If the size matches exactly the number of interfaces, WSAIoctl fails
     with WSAError set to WSAEFAULT, for no apparent reason.  So we allocate
     space for one more INTERFACE_INFO structure here. */
  iie = (LPINTERFACE_INFO) alloca ((cnt + 1) * sizeof (INTERFACE_INFO));
  if (WSAIoctl (s, SIO_GET_INTERFACE_LIST, NULL, 0, iie,
		(cnt + 1) * sizeof (INTERFACE_INFO), &size, NULL, NULL))
    {
      set_winsock_errno ();
      cnt = 0;
      goto done;
    }
d1340 4
a1343 1
  struct ifreq *ifr = ifc->ifc_req;
d1349 8
a1356 7
	  int iinf_idx;
	  for (iinf_idx = 0; iinf_idx < cnt; ++iinf_idx)
	    if (iie[iinf_idx].iiAddress.AddressIn.sin_addr.s_addr
		==  ((sockaddr_in *) pua->Address.lpSockaddr)->sin_addr.s_addr)
	      break;
	  if (iinf_idx >= cnt)
	    continue;
d1358 1
a1358 1
	    strcpy (ifr->ifr_name, pap->AdapterName);
d1360 2
a1361 1
	    __small_sprintf (ifr->ifr_name, "%s:%u", pap->AdapterName, idx);
d1363 29
a1391 1
	  switch (what)
d1393 4
a1396 15
	    case SIOCGIFFLAGS:
	      {
		ifr->ifr_flags = convert_ifr_flags (iie[iinf_idx].iiFlags);
		if (pap->OperStatus == IfOperStatusUp
		    || pap->OperStatus == IfOperStatusUnknown)
		  ifr->ifr_flags |= IFF_RUNNING;
		if (pap->OperStatus != IfOperStatusLowerLayerDown)
		  ifr->ifr_flags |= IFF_LOWER_UP;
		if (pap->OperStatus == IfOperStatusDormant)
		  ifr->ifr_flags |= IFF_DORMANT;
		ULONG hwaddr[2], hwlen = 6;
		if (SendARP (iie[iinf_idx].iiAddress.AddressIn.sin_addr.s_addr,
			     0, hwaddr, &hwlen))
		  ifr->ifr_flags |= IFF_NOARP;
	      }
d1398 6
a1403 5
	    case SIOCGIFCONF:
	    case SIOCGIFADDR:
	      memcpy (&ifr->ifr_addr,
		      &iie[iinf_idx].iiAddress.AddressIn,
		      sizeof (struct sockaddr_in));
d1405 21
a1425 7
	    case SIOCGIFBRDADDR:
	      memcpy (&ifr->ifr_broadaddr,
		      &iie[iinf_idx].iiBroadcastAddress.AddressIn,
		      sizeof (struct sockaddr_in));
	      break;
	    case SIOCGIFDSTADDR:
	      if (pap->IfType == IF_TYPE_PPP)
d1427 7
a1433 5
		  struct sockaddr_in *sa = (struct sockaddr_in *)
					   &ifr->ifr_dstaddr;
		  sa->sin_addr.s_addr = get_routedst (pap->IfIndex);
		  sa->sin_family = AF_INET;
		  sa->sin_port = 0;
d1435 2
a1436 39
	      else
		memcpy (&ifr->ifr_addr,
			&iie[iinf_idx].iiAddress.AddressIn,
			sizeof (struct sockaddr_in));
	      break;
	    case SIOCGIFNETMASK:
	      memcpy (&ifr->ifr_netmask,
		      &iie[iinf_idx].iiNetmask.AddressIn,
		      sizeof (struct sockaddr_in));
	      break;
	    case SIOCGIFHWADDR:
	      for (UINT i = 0; i < IFHWADDRLEN; ++i)
		if (i >= pap->PhysicalAddressLength)
		  ifr->ifr_hwaddr.sa_data[i] = '\0';
		else
		  ifr->ifr_hwaddr.sa_data[i] = pap->PhysicalAddress[i];
	      ifr->ifr_hwaddr.sa_family = AF_INET;
	      break;
	    case SIOCGIFMETRIC:
	      if (wincap.has_gaa_on_link_prefix ())
		ifr->ifr_metric = ((PIP_ADAPTER_ADDRESSES_LH) pap)->Ipv4Metric;
	      else
		ifr->ifr_metric = 1;
	      break;
	    case SIOCGIFMTU:
	      ifr->ifr_mtu = pap->Mtu;
	      break;
	    case SIOCGIFINDEX:
	      ifr->ifr_ifindex = pap->IfIndex;
	      break;
	    case SIOCGIFFRNDLYNAM:
	      {
		struct ifreq_frndlyname *iff = (struct ifreq_frndlyname *)
					       ifr->ifr_frndlyname;
		iff->ifrf_len = sys_wcstombs (iff->ifrf_friendlyname,
					      IFRF_FRIENDLYNAMESIZ,
					      pap->FriendlyName);
	      }
	      break;
d1438 32
a1469 5
	  if ((caddr_t) ++ifr >
	      ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
	    goto done;
	}
    }
d1474 1
a1474 2
  /* Set the correct length */
  ifc->ifc_len = cnt * sizeof (struct ifreq);
d1478 1
a1478 1
 * IFCONF NTSP4, W2K:
d1481 2
a1482 2
static void
get_2k_ifconf (struct ifconf *ifc, int what)
a1483 1
  int cnt = 0;
d1486 1
a1486 4
  /* Union maps buffer to correct struct */
  struct ifreq *ifr = ifc->ifc_req;

  DWORD ip_cnt, lip, lnp;
d1490 2
a1491 2
  struct sockaddr_in *sa = NULL;
  struct sockaddr *so = NULL;
d1508 4
d1535 1
a1535 1
      // reset the last element. This is just the stopper for the loop.
d1556 5
a1560 3
	  /* Setup the interface name */
	  if (ifrow->dwType == MIB_IF_TYPE_LOOPBACK)
	    strcpy (ifr->ifr_name, "lo");
d1566 1
a1566 1
		  case MIB_IF_TYPE_TOKENRING:
d1571 1
a1571 1
		  case MIB_IF_TYPE_ETHERNET:
d1576 1
a1576 1
		  case MIB_IF_TYPE_PPP:
d1581 1
a1581 1
		  case MIB_IF_TYPE_SLIP:
d1589 3
a1591 5
	      if (ifEntry->enumerated == 0)
		__small_sprintf (ifr->ifr_name, "%s%u", name, ifEntry->classId);
	      else
		__small_sprintf (ifr->ifr_name, "%s%u:%u", name,
				 ifEntry->classId, ifEntry->enumerated);
d1594 39
a1632 3

	      /* setup sockaddr struct */
	  switch (what)
d1634 1
a1634 21
	      case SIOCGIFFLAGS:
		if (ifrow->dwType == MIB_IF_TYPE_LOOPBACK)
		  ifr->ifr_flags = IFF_LOOPBACK;
		else
		  ifr->ifr_flags = IFF_BROADCAST | IFF_MULTICAST;
		if (ifrow->dwAdminStatus == MIB_IF_ADMIN_STATUS_UP)
		  {
		    ifr->ifr_flags |= IFF_UP;
		    if (ifrow->dwOperStatus >= MIB_IF_OPER_STATUS_CONNECTED)
		      ifr->ifr_flags |= IFF_RUNNING;
		  }
		break;
	      case SIOCGIFCONF:
	      case SIOCGIFADDR:
		sa = (struct sockaddr_in *) &ifr->ifr_addr;
		sa->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr;
		sa->sin_family = AF_INET;
		sa->sin_port = 0;
		break;
	      case SIOCGIFBRDADDR:
		sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
d1636 2
a1637 2
		/* Unfortunately, the field returns only crap. */
		sa->sin_addr.s_addr = ipt->table[ip_cnt].dwBCastAddr;
d1639 33
a1671 49
		lip = ipt->table[ip_cnt].dwAddr;
		lnp = ipt->table[ip_cnt].dwMask;
		sa->sin_addr.s_addr = lip & lnp | ~lnp;
		sa->sin_family = AF_INET;
		sa->sin_port = 0;
#endif
		break;
	      case SIOCGIFDSTADDR:
		sa = (struct sockaddr_in *) &ifr->ifr_dstaddr;
		if (ifrow->dwType == MIB_IF_TYPE_PPP
		    || ifrow->dwType == MIB_IF_TYPE_SLIP)
		  sa->sin_addr.s_addr =
		  	get_routedst (ipt->table[ip_cnt].dwIndex);
		else
		  sa->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr;
		sa->sin_family = AF_INET;
		sa->sin_port = 0;
	        break;
	      case SIOCGIFNETMASK:
		sa = (struct sockaddr_in *) &ifr->ifr_netmask;
		sa->sin_addr.s_addr = ipt->table[ip_cnt].dwMask;
		sa->sin_family = AF_INET;
		sa->sin_port = 0;
		break;
	      case SIOCGIFHWADDR:
		so = &ifr->ifr_hwaddr;
		for (UINT i = 0; i < IFHWADDRLEN; ++i)
		  if (i >= ifrow->dwPhysAddrLen)
		    so->sa_data[i] = '\0';
		  else
		    so->sa_data[i] = ifrow->bPhysAddr[i];
		so->sa_family = AF_INET;
		break;
	      case SIOCGIFMETRIC:
		ifr->ifr_metric = 1;
		break;
	      case SIOCGIFMTU:
		ifr->ifr_mtu = ifrow->dwMtu;
		break;
	      case SIOCGIFINDEX:
		ifr->ifr_ifindex = ifrow->dwIndex;
		break;
	    }
	  ++cnt;
	  if ((caddr_t) ++ifr >
	      ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
	    goto done;
	}
    }
d1674 1
a1674 2
  /* Set the correct length */
  ifc->ifc_len = cnt * sizeof (struct ifreq);
d1678 1
a1678 1
 * IFCONF Windows NT < SP4:
d1688 1
d1690 2
a1691 2
static void
get_nt_ifconf (struct ifconf *ifc, int what)
d1694 2
d1697 1
a1697 2
  struct sockaddr_in *sa = NULL;
  struct sockaddr *so = NULL;
d1699 2
a1700 2
  int cnt = 1;
  char *binding = (char *) 0;
d1702 6
a1707 9
  /* Union maps buffer to correct struct */
  struct ifreq *ifr = ifc->ifc_req;

  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
		    "SYSTEM\\"
		    "CurrentControlSet\\"
		    "Services\\"
		    "Tcpip\\" "Linkage",
		    0, KEY_READ, &key) == ERROR_SUCCESS)
d1709 2
a1710 3
      if (RegQueryValueEx (key, "Bind",
			   NULL, NULL,
			   NULL, &size) == ERROR_SUCCESS)
d1713 4
a1716 7
	  if (RegQueryValueEx (key, "Bind",
			       NULL, NULL,
			       (unsigned char *) binding,
			       &size) != ERROR_SUCCESS)
	    {
	      binding = NULL;
	    }
d1721 10
a1730 1
  if (binding)
d1732 4
a1735 2
      char *bp, eth[2] = "/";
      char cardkey[256], ipaddress[256], netmask[256];
d1737 3
a1739 6
      for (bp = binding; *bp; bp += strlen (bp) + 1)
	{
	  bp += strlen ("\\Device\\");
	  strcpy (cardkey, "SYSTEM\\CurrentControlSet\\Services\\");
	  strcat (cardkey, bp);
	  strcat (cardkey, "\\Parameters\\Tcpip");
d1741 64
a1804 3
	  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, cardkey,
			    0, KEY_READ, &key) != ERROR_SUCCESS)
	    continue;
d1806 43
a1848 15
	  if (RegQueryValueEx (key, "IPAddress",
			       NULL, NULL,
			       (unsigned char *) ipaddress,
			       (size = 256, &size)) == ERROR_SUCCESS
	      && RegQueryValueEx (key, "SubnetMask",
				  NULL, NULL,
				  (unsigned char *) netmask,
				  (size = 256, &size)) == ERROR_SUCCESS)
	    {
	      char *ip, *np;
	      char dhcpaddress[256], dhcpnetmask[256];

	      for (ip = ipaddress, np = netmask;
		   *ip && *np;
		   ip += strlen (ip) + 1, np += strlen (np) + 1)
d1850 47
a1896 121
		  if ((caddr_t) ++ifr > ifc->ifc_buf
		      + ifc->ifc_len - sizeof (struct ifreq))
		    break;

		  if (!strncmp (bp, "NdisWan", 7))
		    {
		      strcpy (ifr->ifr_name, "ppp");
		      strcat (ifr->ifr_name, bp + 7);
		    }
		  else
		    {
		      ++*eth;
		      strcpy (ifr->ifr_name, "eth");
		      strcat (ifr->ifr_name, eth);
		    }
		  memset (&ifr->ifr_addr, '\0', sizeof ifr->ifr_addr);
		  if (cygwin_inet_addr (ip) == 0L
		      && RegQueryValueEx (key, "DhcpIPAddress",
					  NULL, NULL,
					  (unsigned char *) dhcpaddress,
					  (size = 256, &size))
		      == ERROR_SUCCESS
		      && RegQueryValueEx (key, "DhcpSubnetMask",
					  NULL, NULL,
					  (unsigned char *) dhcpnetmask,
					  (size = 256, &size))
		      == ERROR_SUCCESS)
		    {
		      switch (what)
			{
			  case SIOCGIFFLAGS:
			    ifr->ifr_flags = IFF_UP | IFF_RUNNING
					     | IFF_BROADCAST;
			    break;
			  case SIOCGIFCONF:
			  case SIOCGIFADDR:
			  case SIOCGIFDSTADDR:
			    sa = (struct sockaddr_in *) &ifr->ifr_addr;
			    sa->sin_addr.s_addr =
			      cygwin_inet_addr (dhcpaddress);
			    sa->sin_family = AF_INET;
			    sa->sin_port = 0;
			    break;
			  case SIOCGIFBRDADDR:
			    lip = cygwin_inet_addr (dhcpaddress);
			    lnp = cygwin_inet_addr (dhcpnetmask);
			    sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
			    sa->sin_addr.s_addr = lip & lnp | ~lnp;
			    sa->sin_family = AF_INET;
			    sa->sin_port = 0;
			    break;
			  case SIOCGIFNETMASK:
			    sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			    sa->sin_addr.s_addr =
			      cygwin_inet_addr (dhcpnetmask);
			    sa->sin_family = AF_INET;
			    sa->sin_port = 0;
			    break;
			  case SIOCGIFHWADDR:
			    so = &ifr->ifr_hwaddr;
			    memset (so->sa_data, 0, IFHWADDRLEN);
			    so->sa_family = AF_INET;
			    break;
			  case SIOCGIFMETRIC:
			    ifr->ifr_metric = 1;
			    break;
			  case SIOCGIFMTU:
			    ifr->ifr_mtu = 1500;
			    break;
			  case SIOCGIFINDEX:
			    ifr->ifr_ifindex = -1;
			    break;
			}
		    }
		  else
		    {
		      switch (what)
			{
			  case SIOCGIFFLAGS:
			    ifr->ifr_flags = IFF_UP | IFF_RUNNING
					     | IFF_BROADCAST;
			    break;
			  case SIOCGIFCONF:
			  case SIOCGIFADDR:
			  case SIOCGIFDSTADDR:
			    sa = (struct sockaddr_in *) &ifr->ifr_addr;
			    sa->sin_addr.s_addr = cygwin_inet_addr (ip);
			    sa->sin_family = AF_INET;
			    sa->sin_port = 0;
			    break;
			  case SIOCGIFBRDADDR:
			    lip = cygwin_inet_addr (ip);
			    lnp = cygwin_inet_addr (np);
			    sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
			    sa->sin_addr.s_addr = lip & lnp | ~lnp;
			    sa->sin_family = AF_INET;
			    sa->sin_port = 0;
			    break;
			  case SIOCGIFNETMASK:
			    sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			    sa->sin_addr.s_addr = cygwin_inet_addr (np);
			    sa->sin_family = AF_INET;
			    sa->sin_port = 0;
			    break;
			  case SIOCGIFHWADDR:
			    so = &ifr->ifr_hwaddr;
			    memset (so->sa_data, 0, IFHWADDRLEN);
			    so->sa_family = AF_INET;
			    break;
			  case SIOCGIFMETRIC:
			    ifr->ifr_metric = 1;
			    break;
			  case SIOCGIFMTU:
			    ifr->ifr_mtu = 1500;
			    break;
			  case SIOCGIFINDEX:
			    ifr->ifr_ifindex = -1;
			    break;
			}
		    }
		  ++cnt;
d1898 13
a1911 1
	  RegCloseKey (key);
d1913 1
d1915 6
d1922 24
a1945 2
  /* Set the correct length */
  ifc->ifc_len = cnt * sizeof (struct ifreq);
d1949 1
a1949 1
get_ifconf (SOCKET s, struct ifconf *ifc, int what)
a1950 3
  unsigned long lip, lnp;
  struct sockaddr_in *sa;

d1956 2
a1957 5
  /* Union maps buffer to correct struct */
  struct ifreq *ifr = ifc->ifc_req;

  /* Ensure we have space for two struct ifreqs, fail if not. */
  if (ifc->ifc_len < (int) (2 * sizeof (struct ifreq)))
d1959 1
a1959 1
      set_errno (EFAULT);
d1963 14
a1976 1
  if (!wincap.has_ip_helper_lib ())
d1978 2
a1979 3
      /* Set up interface lo0 first */
      strcpy (ifr->ifr_name, "lo");
      memset (&ifr->ifr_addr, '\0', sizeof (ifr->ifr_addr));
d1981 46
a2026 43
	{
	  case SIOCGIFFLAGS:
	    ifr->ifr_flags = IFF_UP | IFF_RUNNING | IFF_LOOPBACK;
	    break;
	  case SIOCGIFCONF:
	  case SIOCGIFADDR:
	  case SIOCGIFDSTADDR:
	    sa = (struct sockaddr_in *) &ifr->ifr_addr;
	    sa->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	    sa->sin_family = AF_INET;
	    sa->sin_port = 0;
	    break;
	  case SIOCGIFBRDADDR:
	    lip = htonl (INADDR_LOOPBACK);
	    lnp = cygwin_inet_addr ("255.0.0.0");
	    sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	    sa->sin_addr.s_addr = lip & lnp | ~lnp;
	    sa->sin_family = AF_INET;
	    sa->sin_port = 0;
	    break;
	  case SIOCGIFNETMASK:
	    sa = (struct sockaddr_in *) &ifr->ifr_netmask;
	    sa->sin_addr.s_addr = cygwin_inet_addr ("255.0.0.0");
	    sa->sin_family = AF_INET;
	    sa->sin_port = 0;
	    break;
	  case SIOCGIFHWADDR:
	    ifr->ifr_hwaddr.sa_family = AF_INET;
	    memset (ifr->ifr_hwaddr.sa_data, 0, IFHWADDRLEN);
	    break;
	  case SIOCGIFMETRIC:
	    ifr->ifr_metric = 1;
	    break;
	  case SIOCGIFMTU:
	    /* Default value for MS TCP Loopback interface. */
	    ifr->ifr_mtu = 1520;
	    break;
	  case SIOCGIFINDEX:
	    ifr->ifr_ifindex = -1;
	    break;
	  default:
	    set_errno (EINVAL);
	    return -1;
d2028 3
d2032 3
a2034 7

  if (wincap.has_gaa_prefixes () && !CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
    get_xp_ifconf (s, ifc, what);
  else if (wincap.has_ip_helper_lib ())
    get_2k_ifconf (ifc, what);
  else
    get_nt_ifconf (ifc, what);
@


1.232
log
@	* fhandler_registry.cc (registry_listing): Drop name of HKEY_DYN_DATA.
	(registry_keys): Drop HKEY_DYN_DATA.
	* net.cc: Fix comment.
	* syslog.cc: Ditto.
@
text
@d1288 17
d1384 14
d1599 11
d1764 1
d1812 1
d1892 1
@


1.231
log
@	* fhandler.cc (fhandler_base::set_no_inheritance): Always use
	SetHandleInformation.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Always use
	UnlockFileEx/LockFileEx functions.
	* net.cc (fdsock): Don't bother to duplicate socket for inheritance.
	* sysconf.cc (get_nproc_values): Take NT for granted.
	(get_avphys): Ditto.
	* syslog.cc (WIN95_EVENT_LOG_PATH): Remove define.
	(get_win95_event_log_path): Remove.
	(vsyslog): Fix formatting.  Take NT for granted.
	* wincap.cc: Remove has_lock_file_ex, has_signal_object_and_wait,
	has_eventlog, has_set_handle_information,
	has_set_handle_information_on_console_handles and supports_smp
	throughout.
	* wincap.h: Ditto.
@
text
@d1416 1
a1416 1
 * IFCONF 98/ME, NTSP4, W2K:
@


1.230
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@a503 10
  /* NT systems apparently set sockets to inheritable by default */
  if (!wincap.has_set_handle_information ()
      && !DuplicateHandle (hMainProc, (HANDLE) soc,
			   hMainProc, (HANDLE *) &soc,
			   0, TRUE,
			   DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
    {
      debug_printf ("set socket inheritance failed, %E");
      return false;
    }
@


1.229
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@a1078 7
  /*
   * This works for Win95 only if the machine is configured to use MS-TCP.
   * If a third-party TCP is being used this will fail.
   * FIXME: On Win95, is there a way to portably check the TCP stack
   * in use and include paths for the Domain name in each ?
   * Punt for now and assume MS-TCP on Win95.
   */
d1095 2
a1096 5
  /* This is only used by Win95 and NT <=  4.0.
     The registry names are language independent.
     FIXME: Handle DHCP on Win95. The DhcpDomain(s) may be available
     in ..VxD\DHCP\DhcpInfoXX\OptionInfo, RFC 1533 format */

d1098 2
a1099 4
	     (!wincap.is_winnt ()) ? "System" : "SYSTEM",
	     "CurrentControlSet", "Services",
	     (!wincap.is_winnt ()) ? "VxD" : "Tcpip",
	     (!wincap.is_winnt ()) ? "MSTCP" : "Parameters", NULL);
a1824 171
/*
 * IFCONF Windows 95:
 * HKLM/Enum/Network/MSTCP/"*"
 *	  -> Value "Driver" enthlt Subkey relativ zu
 *	    HKLM/System/CurrentControlSet/Class/
 *	  -> In Subkey "Bindings" die Values aufzhlen
 *	    -> Enthlt Subkeys der Form "VREDIR\*"
 *	       Das * ist ein Subkey relativ zu
 *	       HKLM/System/CurrentControlSet/Class/Net/
 * HKLM/System/CurrentControlSet/Class/"Driver"
 *	  -> Value "IPAddress"
 *	  -> Value "IPMask"
 * HKLM/System/CurrentControlSet/Class/Net/"*"(aus "VREDIR\*")
 *	  -> Wenn Value "AdapterName" == "MS$PPP" -> ppp interface
 *	  -> Value "DriverDesc" enthlt den Namen
 *
 */
static void
get_95_ifconf (struct ifconf *ifc, int what)
{
  HKEY key;
  unsigned long lip, lnp;
  struct sockaddr_in *sa = NULL;
  struct sockaddr *so = NULL;
  FILETIME update;
  LONG res;
  DWORD size;
  int cnt = 1;
  char ifname[256];
  char eth[2] = "/";
  char ppp[2] = "/";

  /* Union maps buffer to correct struct */
  struct ifreq *ifr = ifc->ifc_req;

  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, "Enum\\Network\\MSTCP",
		    0, KEY_READ, &key) != ERROR_SUCCESS)
    {
      /* Set the correct length */
      ifc->ifc_len = cnt * sizeof (struct ifreq);
      return;
    }

  for (int i = 0;
       (res = RegEnumKeyEx (key, i, ifname,
			    (size = sizeof ifname, &size),
			    0, 0, 0, &update)) != ERROR_NO_MORE_ITEMS;
       ++i)
    {
      HKEY ifkey, subkey;
      char driver[256], classname[256], netname[256];
      char adapter[256], ip[256], np[256];

      if (res != ERROR_SUCCESS
	  || RegOpenKeyEx (key, ifname, 0, KEY_READ, &ifkey) != ERROR_SUCCESS)
	continue;

      if (RegQueryValueEx (ifkey, "Driver", 0,
			   NULL, (unsigned char *) driver,
			   (size = sizeof driver, &size)) != ERROR_SUCCESS)
	{
	  RegCloseKey (ifkey);
	  continue;
	}

      strcpy (classname, "System\\CurrentControlSet\\Services\\Class\\");
      strcat (classname, driver);
      if ((res = RegOpenKeyEx (HKEY_LOCAL_MACHINE, classname,
			       0, KEY_READ, &subkey)) != ERROR_SUCCESS)
	{
	  RegCloseKey (ifkey);
	  continue;
	}

      if (RegQueryValueEx (subkey, "IPAddress", 0,
			   NULL, (unsigned char *) ip,
			   (size = sizeof ip, &size)) == ERROR_SUCCESS
	  && RegQueryValueEx (subkey, "IPMask", 0,
			      NULL, (unsigned char *) np,
			      (size = sizeof np, &size)) == ERROR_SUCCESS)
	{
	  if ((caddr_t) ++ifr > ifc->ifc_buf
	      + ifc->ifc_len - sizeof (struct ifreq))
	    goto out;

	  switch (what)
	    {
	      case SIOCGIFFLAGS:
		ifr->ifr_flags = IFF_UP | IFF_RUNNING | IFF_BROADCAST;
		break;
	      case SIOCGIFCONF:
	      case SIOCGIFADDR:
		sa = (struct sockaddr_in *) &ifr->ifr_addr;
		sa->sin_addr.s_addr = cygwin_inet_addr (ip);
		sa->sin_family = AF_INET;
		sa->sin_port = 0;
		break;
	      case SIOCGIFBRDADDR:
		lip = cygwin_inet_addr (ip);
		lnp = cygwin_inet_addr (np);
		sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
		sa->sin_addr.s_addr = lip & lnp | ~lnp;
		sa->sin_family = AF_INET;
		sa->sin_port = 0;
		break;
	      case SIOCGIFNETMASK:
		sa = (struct sockaddr_in *) &ifr->ifr_netmask;
		sa->sin_addr.s_addr = cygwin_inet_addr (np);
		sa->sin_family = AF_INET;
		sa->sin_port = 0;
		break;
	      case SIOCGIFHWADDR:
		so = &ifr->ifr_hwaddr;
		memset (so->sa_data, 0, IFHWADDRLEN);
		so->sa_family = AF_INET;
		break;
	      case SIOCGIFMETRIC:
		ifr->ifr_metric = 1;
		break;
	      case SIOCGIFMTU:
		ifr->ifr_mtu = 1500;
		break;
	      case SIOCGIFINDEX:
		ifr->ifr_ifindex = -1;
		break;
	    }
	}

      RegCloseKey (subkey);

      strcpy (netname, "System\\CurrentControlSet\\Services\\Class\\Net\\");
      strcat (netname, ifname);

      if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, netname,
			0, KEY_READ, &subkey) != ERROR_SUCCESS)
	{
	  RegCloseKey (ifkey);
	  --ifr;
	  continue;
	}

      if (RegQueryValueEx (subkey, "AdapterName", 0,
			   NULL, (unsigned char *) adapter,
			   (size = sizeof adapter, &size)) == ERROR_SUCCESS
	  && strcasematch (adapter, "MS$PPP"))
	{
	  ++*ppp;
	  strcpy (ifr->ifr_name, "ppp");
	  strcat (ifr->ifr_name, ppp);
	}
      else
	{
	  ++*eth;
	  strcpy (ifr->ifr_name, "eth");
	  strcat (ifr->ifr_name, eth);
	}

      RegCloseKey (subkey);
      RegCloseKey (ifkey);

      ++cnt;
    }

out:

  RegCloseKey (key);

  /* Set the correct length */
  ifc->ifc_len = cnt * sizeof (struct ifreq);
}

d1901 1
a1901 1
  else if (wincap.is_winnt ())
a1902 2
  else
    get_95_ifconf (ifc, what);
@


1.228
log
@	* net.cc (ga_dup): New function, taken from ga_clone with v4-in-v6
	mapping addition.
	(ga_clone): Just call ga_dup from here.
	(ga_duplist): New function to duplicate list of struct addrinfo.
	(ga_echeck): Don't check a_flags, it already happened in
	cygwin_getaddrinfo.
	(cygwin_freeaddrinfo): Always call ipv4_freeaddrinfo.
	(cygwin_getaddrinfo): Use new wincap.supports_all_posix_ai_flags
	flag rather than wincap.has_gaa_on_link_prefix.  Always duplicate
	WinSock's addrinfo list to a self-allocated list.  Handle AI_V4MAPPED
	for pre-Vista platforms supporting getaddrinfo.
	* wincap.h (wincapc::supports_all_posix_ai_flags): New element.
	* wincap.cc: Implement above element throughout.
	* include/netdb.h: Note how AI_ADDRCONFIG is not supported pre-Vista.
	Remove superfluous comment.
@
text
@d556 1
a556 1
  		af == AF_LOCAL ? 0 : protocol);
d1131 5
a1135 5
        ULONGLONG Alignment;
        _ANONYMOUS_UNION struct {
            ULONG Length;
            DWORD Flags;
        } DUMMYSTRUCTNAME;
d1234 1
a1234 1
        return 8;
d1288 1
a1288 1
        free (pa0);
d1306 1
a1306 1
  	 | ((ws_flags & (WS_IFF_LOOPBACK | WS_IFF_POINTTOPOINT)) << 1)
d1326 1
a1326 1
  
d1335 1
a1335 1
  		(cnt + 1) * sizeof (INTERFACE_INFO), &size, NULL, NULL))
d1341 1
a1341 1
      
d1347 1
a1347 1
        {
d1404 1
a1404 1
	        ifr->ifr_metric = ((PIP_ADAPTER_ADDRESSES_LH) pap)->Ipv4Metric;
d1569 1
a1569 1
	        break;
d2135 1
a2135 1
        if (ifindex == pap->IfIndex)
d2163 1
a2163 1
        ++cnt;
d2170 1
a2170 1
        {
d2175 1
a2175 1
	        if (iflist[i].if_index == (pap->IfIndex ?: pap->Ipv6IfIndex))
d2258 1
a2258 1
        return ret;
d2587 1
a2587 1
        {
d2601 1
a2601 1
        {
d2657 1
a2657 1
        {
d2666 1
a2666 1
        {
d2684 1
a2684 1
        {
d2708 1
a2708 1
        {
d2809 1
a2809 1
        {
d2816 1
a2816 1
        {
d2841 1
a2841 1
        {
d3043 1
a3043 1
  						  ? sizeof (struct sockaddr_in6)
d3047 1
a3047 1
        free (nai->ai_canonname);
d3091 1
a3091 1
        goto bad;
d3093 1
a3093 1
        nai0 = tmp;
d3095 1
a3095 1
        nai->ai_next = tmp;
d3902 1
a3902 1
        {
d3909 1
a3909 1
        {
d3943 1
a3943 1
  		& ~(AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_ALL
d3967 1
a3967 1
        {
d3975 1
a3975 1
        {
d3983 1
a3983 1
         we do here is to emulate AI_V4MAPPED.  If no IPv6 addresses are
d4009 1
a4009 1
	         list.  Otherwise just return the v4-in-v6 address list. */
d4043 1
a4043 1
        {
d4056 1
a4056 1
        set_winsock_errno ();
d4132 1
a4132 1
  
@


1.227
log
@	* net.cc (cygwin_getaddrinfo): Fix thinko in AI_ADDRCONFIG handling.
@
text
@d3016 6
d3023 1
a3023 1
ga_clone (struct addrinfo *ai)
a3029 3
  nai->ai_next = ai->ai_next;
  ai->ai_next = nai;

d3031 1
a3031 1
  nai->ai_family = ai->ai_family;
d3035 63
a3097 4
  nai->ai_addrlen = ai->ai_addrlen;
  if ((nai->ai_addr = (struct sockaddr *) malloc (ai->ai_addrlen)) == NULL)
    return (NULL);
  memcpy (nai->ai_addr, ai->ai_addr, ai->ai_addrlen);
d3099 3
a3101 1
  return (nai);
d3115 1
d3118 1
a3118 1

d3929 1
a3929 5
  load_ipv6 ();
  if (freeaddrinfo)
    freeaddrinfo (addr);
  else
    ipv4_freeaddrinfo (addr);
d3958 1
a3958 1
      struct addrinfo nhints;
d3965 1
a3965 1
      if (wincap.has_gaa_on_link_prefix ()
d3972 51
a4022 1
      return w32_to_gai_err (getaddrinfo (hostname, servname, hints, res));
@


1.226
log
@	* net.cc (cygwin_getaddrinfo): Check ai_flags for valid values.
	Handle AI_NUMERICSERV.  Handle AI_ADDRCONFIG behaviour on Vista.
	* include/netdb.h (AI_NUMERICSERV): Add missing flag.
@
text
@d3905 1
a3905 2
	  && hints && (hints->ai_flags & AI_ADDRCONFIG)
	  && hints->ai_family == PF_UNSPEC)
@


1.225
log
@	* net.cc (if_nametoindex): This time, really free IP_ADAPTER_ADDRESSES
	memory.
	(if_indextoname): Ditto.
@
text
@d3878 16
d3896 18
a3913 1
    return w32_to_gai_err (getaddrinfo (hostname, servname, hints, res));
@


1.224
log
@	* net.cc (gai_errmap): Add EAI_OVERFLOW entry.  Fix formatting.
	(cygwin_gai_strerror): Drop using EAI_MAX.
	(w32_to_gai_err): Ditto.
	* include/netdb.h: Define EAI_OVERFLOW. Remove EAI_MAX.
@
text
@d2094 1
a2094 1
  PIP_ADAPTER_ADDRESSES pap = NULL;
d2110 1
a2110 1
      for (; pap; pap = pap->Next)
d2116 1
a2116 1
      free (pap);
d2124 1
a2124 1
  PIP_ADAPTER_ADDRESSES pap = NULL;
d2132 1
a2132 1
      && get_adapters_addresses (&pap, AF_UNSPEC))
d2134 1
a2134 1
      for (; pap; pap = pap->Next)
d2140 1
a2140 1
      free (pap);
@


1.223
log
@	* net.cc (if_nametoindex): Free IP_ADAPTER_ADDRESSES memory.
	(if_indextoname): Ditto.
	(if_nameindex): Ditto.  Remove duplicate indexed entries in result.
@
text
@d3754 6
a3759 6
  {0,			"Success"},
  {0,			"Address family for hostname not supported"},
  {WSATRY_AGAIN,	"Temporary failure in name resolution"},
  {WSAEINVAL,		"Invalid value for ai_flags"},
  {WSANO_RECOVERY,	"Non-recoverable failure in name resolution"},
  {WSAEAFNOSUPPORT,	"ai_family not supported"},
d3761 8
a3768 7
  {WSANO_DATA,		"No address associated with hostname"},
  {WSAHOST_NOT_FOUND,	"hostname nor servname provided, or not known"},
  {WSATYPE_NOT_FOUND,	"servname not supported for ai_socktype"},
  {WSAESOCKTNOSUPPORT,	"ai_socktype not supported"},
  {0,			"System error returned in errno"},
  {0,			"Invalid value for hints"},
  {0,			"Resolved protocol is unknown"}
d3774 1
a3774 1
  if (err >= 0 && err < EAI_MAX)
d3783 1
a3783 1
    for (int i = 0; i < EAI_MAX; ++i)
@


1.222
log
@	* autoload.cc (WSAIoctl): Define.
	(SendARP): Define.
	* cygwin.din: Export if_freenameindex, if_indextoname, if_nameindex and
	if_nametoindex.
	* fhandler_procnet.cc: Drop including wchar.h.  Drop definitions of
	GAA_FLAG_INCLUDE_ALL_INTERFACES, IP_ADAPTER_UNICAST_ADDRESS_VISTA.
	(fhandler_procnet::exists): Check for has_gaa_prefixes.  Call
	get_adapters_addresses here.
	(fhandler_procnet::readdir): Ditto.
	(prefix): Move to net.cc.
	(fhandler_procnet::fill_filebuf): Call get_adapters_addresses here.
	Simplify allocation.  Use AdapterName rather than FriendlyName as
	interface name.  Use IfIndex if available, Ipv6IfIndex otherwise.
	(in6_are_prefix_equal): Move to net.cc.
	* fhandler_socket.cc: Define old SIOCGxxx values.
	(CONV_OLD_TO_NEW_SIO): Convert old SIOCGxxx value to new one.
	(struct __old_ifreq): Define old struct ifreq.
	(fhandler_socket::ioctl): Handle old SIOCGxxx values.  Handle new
	SIOCGIFFRNDLYNAM command.  Simplify copying ifreq data to user space.
	Call get_ifconf with additional SOCKET parameter.
	* net.cc (IP_ADAPTER_UNICAST_ADDRESS_LH): Define.
	(IP_ADAPTER_ADDRESSES_LH): Define.
	(SIO_GET_INTERFACE_LIST): Define.
	(sockaddr_in6_old): Define.
	(sockaddr_gen): Define.
	(INTERFACE_INFO): Define.
	(IN_LOOPBACK): Define.
	(in_are_prefix_equal): New static function.
	(ip_addr_prefix): New function, replaces prefix function, add AF_INET
	handling.
	(GAA_FLAG_INCLUDE_ALL_INTERFACES): Define.
	(get_adapters_addresses): New function.
	(WS_IFF_xxx): Define Winsock interface flag values.
	(convert_ifr_flags): New function to convert Winsock interface flag
	values to Cygwin interface flag values.
	(get_xp_ifconf): New get_ifconf implementation for XP SP1 and above.
	(get_2k_ifconf): Fix interface index.  Fix formatting.
	(get_nt_ifconf): Fix formatting.
	(get_95_ifconf): Ditto.
	(get_ifconf): Take additional SOCKET parameter.  Call get_xp_ifconf
	on XP SP1 and above.
	(if_nametoindex): New function.
	(if_indextoname): New function.
	(if_nameindex): New function.
	(if_freenameindex): New function.
	(in6_are_prefix_equal): Moved here from fhandler_procnet.cc.
	* wincap.cc (wincap_xp): Define has_gaa_prefixes as true by default.
	(wincapc::init): Assume has_osversioninfoex by default.  Call
	GetVersionEx with OSVERSIONINFOEX first.  Call with OSVERSIONINFO only
	if that fails.  Simplify NT4 case and try to avoid strcmp.  Check XP
	Service Pack using version.wServicePackMajor to avoid strcmp.
	* include/asm/socket.h (SIOCGIFFRNDLYNAM): Define.
	* include/cygwin/if.h: Fix formatting.
	(IFF_POINTTOPOINT): Define.
	(IFF_NOARP): Define.
	(IFF_LOWER_UP): Define.
	(IFF_DORMANT): Define.
	(struct if_nameindex): Define.
	(IFRF_FRIENDLYNAMESIZ): Define.
	(struct ifreq_frndlyname): Define.
	(IFNAMSIZ): Redefine as 44.
	(IF_NAMESIZE): Define.
	(struct ifreq): Redefine ifru_flags as int.  Define ifru_data.  Pad size
	to sizeof sockaddr_in6 for further extensions.
	(ifr_data): Define.
	(ifr_frndlyname): Define.
	(if_nametoindex): Declare.
	(if_indextoname): Declare.
	(if_nameindex): Declare.
	(if_freenameindex): Declare.
	* include/cygwin/version.h: Bump API minor number.
	(CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ): Define check for old vs. new
	ifreq structure.
@
text
@d2095 1
d2112 5
a2116 1
	  return pap->IfIndex;
d2118 1
a2118 1
  return 0;
d2125 1
d2137 2
a2138 2
	    strcpy (ifname, pap->AdapterName);
	    return ifname;
d2140 1
d2142 3
a2144 2
  set_errno (ENXIO);
  return NULL;
d2168 2
d2171 14
a2184 8
	  set_errno (ENOBUFS);
	  return NULL;
	}
      ifnamelist = (char (*)[IF_NAMESIZE]) (iflist + cnt + 1);
      for (pap = pa0, cnt = 0; pap; pap = pap->Next, ++cnt)
        {
	  iflist[cnt].if_index = pap->IfIndex ?: pap->Ipv6IfIndex;
	  strcpy (iflist[cnt].if_name = ifnamelist[cnt], pap->AdapterName);
d2186 1
a2186 3
      iflist[cnt].if_index = 0;
      iflist[cnt].if_name = NULL;
      return iflist;
d2188 3
a2190 2
  set_errno (ENXIO);
  return NULL;
@


1.221
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Handle SIOCGIFINDEX.
	* net.cc (get_2k_ifconf): Ditto.
	(get_nt_ifconf): Fake SIOCGIFINDEX.
	(get_95_ifconf): Ditto.
	(get_ifconf): Handle SIOCGIFINDEX.  Fake it for loopback on systems
	not supporting IP Helper Lib.
	* include/asm/socket.h (SIOCGIFINDEX): Define.
	* include/cygwin/if.h (struct ifreq): Add member for interface index.
	(ifr_ifindex): Define.
@
text
@d1128 309
d1551 1
a1551 1
				 ifEntry->classId, ifEntry->enumerated - 1);
d1616 1
a1616 1
	  if ((caddr_t)++ ifr >
d1708 1
a1708 1
		  if ((caddr_t)++ ifr > ifc->ifc_buf
d1918 1
a1918 1
	  if ((caddr_t)++ ifr > ifc->ifc_buf
d2009 1
a2009 1
get_ifconf (struct ifconf *ifc, int what)
d2080 3
a2082 1
  if (wincap.has_ip_helper_lib ())
d2091 96
d3903 84
@


1.220
log
@	(get_ifconf): Set MTU for loopback to more correct value.
@
text
@d1302 3
d1467 3
d1512 3
d1650 3
d1762 3
@


1.219
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Don't fake results
	for SIOCGIFFLAGS here.  Call get_ifconf instead.
	* net.cc (get_2k_ifconf): Clean up code to generate interface name.
	Handle SIOCGIFFLAGS here.
	(get_nt_ifconf): Fake SIOCGIFFLAGS here.
	(get_95_ifconf): Ditto.
	(get_ifconf): Don't fake loopback on systems with IP Helper Lib.
	Set MTU for loopback to a more "modern" value.
@
text
@d1747 2
a1748 2
	    /* Default value for loopback on Linux 2.6 kernel. */
	    ifr->ifr_mtu = 16436;
@


1.218
log
@	* net.cc (get_ipv6_funcs): Fix formatting.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d1208 40
a1247 1
	  switch (ifrow->dwType)
d1249 3
a1251 22
	      case MIB_IF_TYPE_TOKENRING:
		if (ifEntry->enumerated == 0)
		  {
		    ifEntry->classId = tokId++;
		    __small_sprintf (ifr->ifr_name, "tok%u",
				     ifEntry->classId);
		  }
		else
		  {
		    __small_sprintf (ifr->ifr_name, "tok%u:%u",
				     ifEntry->classId,
				     ifEntry->enumerated - 1);
		  }
		ifEntry->enumerated++;
		break;
	      case MIB_IF_TYPE_ETHERNET:
		if (ifEntry->enumerated == 0)
		  {
		    ifEntry->classId = ethId++;
		    __small_sprintf (ifr->ifr_name, "eth%u",
				     ifEntry->classId);
		  }
d1253 2
d1256 3
a1258 12
		    __small_sprintf (ifr->ifr_name, "eth%u:%u",
				     ifEntry->classId,
				     ifEntry->enumerated - 1);
		  }
		ifEntry->enumerated++;
		break;
	      case MIB_IF_TYPE_PPP:
		if (ifEntry->enumerated == 0)
		  {
		    ifEntry->classId = pppId++;
		    __small_sprintf (ifr->ifr_name, "ppp%u",
				     ifEntry->classId);
d1260 1
a1260 32
		else
		  {
		    __small_sprintf (ifr->ifr_name, "ppp%u:%u",
				     ifEntry->classId,
				     ifEntry->enumerated - 1);
		  }
		ifEntry->enumerated++;
		break;
	      case MIB_IF_TYPE_SLIP:
		if (ifEntry->enumerated == 0)
		  {
		    ifEntry->classId = slpId++;
		    __small_sprintf (ifr->ifr_name, "slp%u",
				     ifEntry->classId);
		  }
		else
		  {
		    __small_sprintf (ifr->ifr_name, "slp%u:%u",
				     ifEntry->classId,
				     ifEntry->enumerated - 1);
		  }
		ifEntry->enumerated++;
		break;
	      case MIB_IF_TYPE_LOOPBACK:
		strcpy (ifr->ifr_name, "lo");
		break;
	      default:
		continue;
	    }
	  /* setup sockaddr struct */
	  switch (what)
	    {
d1426 4
d1470 4
d1606 3
d1708 46
a1753 40
  /* Set up interface lo0 first */
  strcpy (ifr->ifr_name, "lo");
  memset (&ifr->ifr_addr, '\0', sizeof (ifr->ifr_addr));
  switch (what)
    {
      case SIOCGIFCONF:
      case SIOCGIFADDR:
	sa = (struct sockaddr_in *) &ifr->ifr_addr;
	sa->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	sa->sin_family = AF_INET;
	sa->sin_port = 0;
	break;
      case SIOCGIFBRDADDR:
	lip = htonl (INADDR_LOOPBACK);
	lnp = cygwin_inet_addr ("255.0.0.0");
	sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	sa->sin_addr.s_addr = lip & lnp | ~lnp;
	sa->sin_family = AF_INET;
	sa->sin_port = 0;
	break;
      case SIOCGIFNETMASK:
	sa = (struct sockaddr_in *) &ifr->ifr_netmask;
	sa->sin_addr.s_addr = cygwin_inet_addr ("255.0.0.0");
	sa->sin_family = AF_INET;
	sa->sin_port = 0;
	break;
      case SIOCGIFHWADDR:
	ifr->ifr_hwaddr.sa_family = AF_INET;
	memset (ifr->ifr_hwaddr.sa_data, 0, IFHWADDRLEN);
	break;
      case SIOCGIFMETRIC:
	ifr->ifr_metric = 1;
	break;
      case SIOCGIFMTU:
	/* This funny value is returned by `ifconfig lo' on Linux 2.2 kernel. */
	ifr->ifr_mtu = 3924;
	break;
      default:
	set_errno (EINVAL);
	return -1;
@


1.217
log
@	* net.cc (cygwin_getnameinfo): Fix typo in comment.
@
text
@d3368 1
a3368 1
			  GetProcAddress(lib, "freeaddrinfo"))
d3372 1
a3372 1
			    GetProcAddress(lib, "getaddrinfo"))
d3376 1
a3376 1
			    GetProcAddress(lib, "getnameinfo")));
@


1.216
log
@	* fhandler_socket.cc (fhandler_socket::recvmsg): Remove unused tot
	argument.  All callers changed.
	(fhandler_socket::sendmsg): Likewise.
	* net.cc (cygwin_recvmsg): Likewise.
	(cygwin_sendmsg): Likewise, and prevent calling sendmsg whith an
	invalid iovec.
	* fhandler.h (fhandler_socket::recvmsg): Adjust prototype.
	(fhandler_socket::sendmsg): Likewise.
@
text
@d3459 1
a3459 1
	 returns with error WSAENO_DATA instead of simply ignoring the port.
@


1.215
log
@	* fhandler.h (class fhandler_socket): Remove prot_info_ptr.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::need_fixup_before): Remove.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Drop
	initializing prot_info_ptr.  Remove unused code.
	(fhandler_socket::~fhandler_socket): Drop free'ing prot_info_ptr.
	(struct wsa_event): Rename connect_errorcode to errorcode.
	(fhandler_socket::evaluate_events): Handle FD_CLOSE error condition
	as FD_CONNECT error condition, except, never reset an FD_CLOSE error
	condition.  Always set FD_WRITE after successfully recorded FD_CONNECT.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_fork): Revert to using handle duplication.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::dup): Revert to using handle duplication.
	(fhandler_socket::send_internal): Only call wait_for_events in case
	of WSAEWOULDBLOCK condition.
	(fhandler_socket::set_close_on_exec): Call
	fhandler_base::set_close_on_exec.
	* net.cc (fdsock): Just set socket to inheritable on non-NT.  Don't
	call inc_need_fixup_before.
	* select.cc (peek_socket): Don't set except_ready on every FD_CLOSE,
	just on error.
@
text
@d2074 1
a2074 1
	res = fh->recvmsg (msg, flags, res); // res == iovec tot
d2096 2
a2097 1
      res = fh->sendmsg (msg, flags, res); // res == iovec tot
@


1.214
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@d504 6
a509 1
  if (wincap.has_set_handle_information ())
d511 2
a512 3
      /* NT systems apparently set sockets to inheritable by default */
      SetHandleInformation ((HANDLE) soc, HANDLE_FLAG_INHERIT, 0);
      debug_printf ("reset socket inheritance");
a513 2
  else
    debug_printf ("not setting socket inheritance");
a521 1
  cygheap->fdtab.inc_need_fixup_before ();
@


1.213
log
@	* Makefile.in (DLL_OFILES): Add inet_addr.o and inet_network.o.
	* autoload.cc (inet_addr): Drop definition.
	(inet_ntoa): Ditto.
	* net.cc: Forward declare cygwin_inet_aton and cygwin_inet_ntop.
	(cygwin_inet_ntoa): Call cygwin_inet_ntop instead of Winsock inet_ntoa.
	(cygwin_inet_addr): Remove here.
	(cygwin_inet_aton): Ditto.
	(cygwin_inet_network): Ditto.
	* libc/inet_addr.c: New file implementing cygwin_inet_aton and
	cygwin_inet_addr.
	* libc/inet_network.c: New file implementing cygwin_inet_network.
@
text
@d43 1
d56 3
d516 2
d554 2
a555 1
  soc = socket (AF_INET, type, af == AF_LOCAL ? 0 : protocol);
d565 3
a567 1
  if (af == AF_INET)
a568 2
  else
    dev = type == SOCK_STREAM ? stream_dev : dgram_dev;
d781 1
a781 50
    {
      bool was_blocking = false;
      if (!fh->is_nonblocking ())
	{
	  int nonblocking = 1;
	  fh->ioctl (FIONBIO, &nonblocking);
	  was_blocking = true;
	}
      res = fh->connect (name, namelen);
      if (was_blocking)
	{
	  if (res == -1 && get_errno () == EINPROGRESS)
	    {
	      size_t fds_size = howmany (fd + 1, NFDBITS) * sizeof (fd_mask);
	      fd_set *write_fds = (fd_set *) alloca (fds_size);
	      fd_set *except_fds = (fd_set *) alloca (fds_size);
	      memset (write_fds, 0, fds_size);
	      memset (except_fds, 0, fds_size);
	      FD_SET (fd, write_fds);
	      FD_SET (fd, except_fds);
	      res = cygwin_select (fd + 1, NULL, write_fds, except_fds, NULL);
	      if (res > 0 && FD_ISSET (fd, except_fds))
		{
		  res = -1;
		  for (;;)
		    {
		      int err;
		      int len = sizeof err;
		      cygwin_getsockopt (fd, SOL_SOCKET, SO_ERROR,
					 (void *) &err, &len);
		      if (err)
			{
			  set_errno (err);
			  break;
			}
		      low_priority_sleep (0);
		    }
		}
	      else if (res > 0)
		res = 0;
	      else
		{
		  WSASetLastError (WSAEINPROGRESS);
		  set_winsock_errno ();
		}
	    }
	  int nonblocking = 0;
	  fh->ioctl (FIONBIO, &nonblocking);
	}
    }
d915 1
a915 13
    {
      if (!fh->is_nonblocking ())
	{
	  size_t fds_size = howmany (fd + 1, NFDBITS) * sizeof (fd_mask);
	  fd_set *read_fds = (fd_set *) alloca (fds_size);
	  memset (read_fds, 0, fds_size);
	  FD_SET (fd, read_fds);
	  res = cygwin_select (fd + 1, read_fds, NULL, NULL, NULL);
	  if (res == -1)
	    return -1;
	}
      res = fh->accept (peer, len);
    }
a1764 78
/* exported as rcmd: standards? */
extern "C" int
cygwin_rcmd (char **ahost, unsigned short inport, char *locuser,
	     char *remuser, char *cmd, int *fd2p)
{
  int res = -1;
  SOCKET fd2s;

  sig_dispatch_pending ();

  myfault efault;
  if (efault.faulted (EFAULT))
    return (int) INVALID_SOCKET;
  if (!*locuser)
    {
      set_errno (EINVAL);
      return (int) INVALID_SOCKET;
    }

  res = rcmd (ahost, inport, locuser, remuser, cmd, fd2p ? &fd2s : NULL);
  if (res != (int) INVALID_SOCKET)
    {
      cygheap_fdnew res_fd;

      if (res_fd >= 0 && fdsock (res_fd, tcp_dev, res))
	{
	  ((fhandler_socket *) res_fd)->connect_state (connected);
	  res = res_fd;
	}
      else
	{
	  closesocket (res);
	  res = -1;
	}

      if (res >= 0 && fd2p)
	{
	  cygheap_fdnew newfd (res_fd, false);
	  cygheap_fdget fd (*fd2p);

	  if (newfd >= 0 && fdsock (newfd, tcp_dev, fd2s))
	    {
	      *fd2p = newfd;
	      ((fhandler_socket *) fd2p)->connect_state (connected);
	    }
	  else
	    {
	      closesocket (res);
	      closesocket (fd2s);
	      res = -1;
	    }
	}
    }

  syscall_printf ("%d = rcmd (...)", res);
  return res;
}

/* The below implementation of rresvport looks pretty ugly, but there's
   a problem in Winsock.  The bind(2) call does not fail if a local
   address is still in TIME_WAIT state, and there's no way to get this
   behaviour.  Unfortunately the first time when this is detected is when
   the calling application tries to connect.

   One (also not really foolproof) way around this problem would be to use
   the iphlpapi function GetTcpTable and to check if the port in question is
   in TIME_WAIT state and if so, choose another port number.  But this method
   is as prone to races as the below one, or any other method using random
   port numbers, etc.  The below method at least tries to avoid races between
   multiple applications using rrecvport.

   As for the question "why don't you just use the Winsock rresvport?"...
   For some reason I do NOT understand, the call to WinSocks rresvport
   corrupts the stack when Cygwin is built using -fomit-frame-pointers.
   And then again, the Winsock rresvport function has the exact same
   problem with reusing ports in the TIME_WAIT state as the socket/bind
   method has.  So there's no gain in using that function. */

d1769 1
a1769 1
LONG last_used_rrecvport __attribute__((section (".cygwin_dll_common"), shared)) = IPPORT_RESERVED;
a1770 1
/* exported as rresvport: standards? */
d1772 1
a1772 1
cygwin_rresvport (int *port)
d1774 7
a1780 1
  int res;
d1787 5
a1791 2
  res = socket (AF_INET, SOCK_STREAM, 0);
  if (res != (int) INVALID_SOCKET)
d1793 4
a1796 5
      LONG myport;
      int ret = SOCKET_ERROR;
      struct sockaddr_in sin;
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = INADDR_ANY;
d1798 16
a1813 7
      for (int i = 0; i < NUM_PORTS; i++)
	{
	  while ((myport = InterlockedExchange (&last_used_rrecvport, 0)) == 0)
	    low_priority_sleep (0);
	  if (--myport < PORT_LOW)
	    myport = PORT_HIGH;
	  InterlockedExchange (&last_used_rrecvport, myport);
d1815 7
a1821 14
	  sin.sin_port = htons (myport);
	  if (!(ret = bind (res, (struct sockaddr *) &sin, sizeof sin)))
	    break;
	  int err = WSAGetLastError ();
	  if (err != WSAEADDRINUSE && err != WSAEINVAL)
	    break;
	}
      if (ret == SOCKET_ERROR)
	{
	  closesocket (res);
	  res = (int) INVALID_SOCKET;
	}
      else if (port)
	*port = myport;
d1824 3
a1826 1
  if (res != (int) INVALID_SOCKET)
d1828 5
a1832 1
      cygheap_fdnew res_fd;
d1834 2
a1835 2
      if (res_fd >= 0 && fdsock (res_fd, tcp_dev, res))
	res = res_fd;
d1837 5
a1841 1
	res = -1;
d1844 7
a1850 2
  syscall_printf ("%d = rresvport (%d)", res, port ? *port : 0);
  return res;
d1933 1
a1933 1
      sock_out.sin_addr.s_addr = INADDR_ANY;
d2102 192
a2293 2
/* See "UNIX Network Programming, Networing APIs: Sockets and XTI",
   W. Richard Stevens, Prentice Hall PTR, 1998. */
d2295 28
a2322 1
cygwin_inet_pton (int family, const char *strptr, void *addrptr)
d2324 5
a2328 1
  if (family == AF_INET)
d2330 27
a2356 1
      struct in_addr in_val;
d2358 319
a2676 1
      if (cygwin_inet_aton (strptr, &in_val))
d2678 32
a2709 2
	  memcpy (addrptr, &in_val, sizeof (struct in_addr));
	  return 1;
d2711 590
a3300 1
      return 0;
a3301 2
  set_errno (EAFNOSUPPORT);
  return -1;
d3304 28
a3331 2
/* See "UNIX Network Programming, Networing APIs: Sockets and XTI",
   W. Richard Stevens, Prentice Hall PTR, 1998. */
d3333 9
a3341 1
cygwin_inet_ntop (int family, const void *addrptr, char *strptr, socklen_t len)
d3343 37
a3379 1
  const u_char *p = (const u_char *) addrptr;
d3381 41
d3424 20
a3443 4
    return NULL;
  if (family == AF_INET)
    {
      char temp[64]; /* Big enough for 4 ints ... */
d3445 25
a3469 5
      __small_sprintf (temp, "%u.%u.%u.%u", p[0], p[1], p[2], p[3]);
      if (strlen (temp) >= (size_t) len)
	{
	  set_errno (ENOSPC);
	  return NULL;
d3471 5
a3475 2
      strcpy (strptr, temp);
      return strptr;
d3477 1
a3477 2
  set_errno (EAFNOSUPPORT);
  return NULL;
d3479 1
@


1.212
log
@	* Makefile.in (DLL_OFILES): Add rexec.o.
	* autoload.cc (inet_network): Drop definition.
	(rexec): Ditto.
	* net.cc (rexec): Drop extern declaration.
	(inet_network): Ditto.
	(cygwin_inet_network): Implement using inet_addr.
	(cygwin_rexec): Remove.
	* libc/rexec.cc: New file.
@
text
@d51 2
d107 2
a108 1
  char *res = inet_ntoa (in);
a119 40
/* exported as inet_addr: BSD 4.3 */
extern "C" unsigned long
cygwin_inet_addr (const char *cp)
{
  myfault efault;
  if (efault.faulted (EFAULT))
    return INADDR_NONE;
  unsigned long res = inet_addr (cp);

  return res;
}

/* exported as inet_aton: BSD 4.3
   inet_aton is not exported by wsock32 and ws2_32,
   so it has to be implemented here. */
extern "C" int
cygwin_inet_aton (const char *cp, struct in_addr *inp)
{
  myfault efault;
  if (efault.faulted (EFAULT))
    return 0;

  unsigned long res = inet_addr (cp);

  if (res == INADDR_NONE && strcmp (cp, "255.255.255.255"))
    return 0;
  if (inp)
    inp->s_addr = res;
  return 1;
}

extern "C" unsigned int
cygwin_inet_network (const char *cp)
{
  myfault efault;
  if (efault.faulted (EFAULT))
    return INADDR_NONE;
  return ntohl (inet_addr (cp));
}

@


1.212.2.1
log
@	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.
@
text
@a42 1
#include "cygwin/in6.h"
a52 3
const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;

d585 1
a585 2
  soc = socket (af == AF_LOCAL ? AF_INET : af, type,
  		af == AF_LOCAL ? 0 : protocol);
d595 3
a597 1
  if (af == AF_LOCAL)
a598 2
  else
    dev = type == SOCK_STREAM ? tcp_dev : udp_dev;
d2078 1
a2078 1
      sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
d2247 2
a2248 192
/* This is from the BIND 4.9.4 release, modified to compile by itself */

/* Copyright (c) 1996 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#define	IN6ADDRSZ	16
#define	INADDRSZ	 4
#define	INT16SZ		 2

/* int
 * inet_pton4(src, dst)
 *	like inet_aton() but without all the hexadecimal and shorthand.
 * return:
 *	1 if `src' is a valid dotted quad, else 0.
 * notice:
 *	does not touch `dst' unless it's returning 1.
 * author:
 *	Paul Vixie, 1996.
 */
static int
inet_pton4 (const char *src, u_char *dst)
{
  static const char digits[] = "0123456789";
  int saw_digit, octets, ch;
  u_char tmp[INADDRSZ], *tp;

  saw_digit = 0;
  octets = 0;
  *(tp = tmp) = 0;
  while ((ch = *src++) != '\0')
    {
      const char *pch;

      if ((pch = strchr(digits, ch)) != NULL)
        {
	  u_int ret = *tp * 10 + (pch - digits);

	  if (ret > 255)
	    return (0);
	  *tp = ret;
	  if (! saw_digit)
	    {
	      if (++octets > 4)
		return (0);
	      saw_digit = 1;
	    }
	}
      else if (ch == '.' && saw_digit)
        {
	  if (octets == 4)
	    return (0);
	  *++tp = 0;
	  saw_digit = 0;
	}
      else
	return (0);
    }
  if (octets < 4)
    return (0);

  memcpy(dst, tmp, INADDRSZ);
  return (1);
}

/* int
 * inet_pton6(src, dst)
 *	convert presentation level address to network order binary form.
 * return:
 *	1 if `src' is a valid [RFC1884 2.2] address, else 0.
 * notice:
 *	(1) does not touch `dst' unless it's returning 1.
 *	(2) :: in a full address is silently ignored.
 * credit:
 *	inspired by Mark Andrews.
 * author:
 *	Paul Vixie, 1996.
 */
static int
inet_pton6 (const char *src, u_char *dst)
{
  static const char xdigits_l[] = "0123456789abcdef",
		    xdigits_u[] = "0123456789ABCDEF";
  u_char tmp[IN6ADDRSZ], *tp, *endp, *colonp;
  const char *xdigits, *curtok;
  int ch, saw_xdigit;
  u_int val;

  memset((tp = tmp), 0, IN6ADDRSZ);
  endp = tp + IN6ADDRSZ;
  colonp = NULL;
  /* Leading :: requires some special handling. */
  if (*src == ':')
    if (*++src != ':')
      return (0);
  curtok = src;
  saw_xdigit = 0;
  val = 0;
  while ((ch = *src++) != '\0')
    {
      const char *pch;

      if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)
	pch = strchr((xdigits = xdigits_u), ch);
      if (pch != NULL)
        {
	  val <<= 4;
	  val |= (pch - xdigits);
	  if (val > 0xffff)
	    return (0);
	  saw_xdigit = 1;
	  continue;
	}
      if (ch == ':')
        {
	  curtok = src;
	  if (!saw_xdigit)
	    {
	      if (colonp)
		return (0);
	      colonp = tp;
	      continue;
	    }
	  if (tp + INT16SZ > endp)
	    return (0);
	  *tp++ = (u_char) (val >> 8) & 0xff;
	  *tp++ = (u_char) val & 0xff;
	  saw_xdigit = 0;
	  val = 0;
	  continue;
	}
      if (ch == '.' && ((tp + INADDRSZ) <= endp) && inet_pton4(curtok, tp) > 0)
        {
	  tp += INADDRSZ;
	  saw_xdigit = 0;
	  break;	/* '\0' was seen by inet_pton4(). */
	}
      return (0);
    }
  if (saw_xdigit)
    {
      if (tp + INT16SZ > endp)
	return (0);
      *tp++ = (u_char) (val >> 8) & 0xff;
      *tp++ = (u_char) val & 0xff;
    }
  if (colonp != NULL)
    {
      /*
       * Since some memmove()'s erroneously fail to handle
       * overlapping regions, we'll do the shift by hand.
       */
      const int n = tp - colonp;
      int i;

      for (i = 1; i <= n; i++)
        {
	  endp[- i] = colonp[n - i];
	  colonp[n - i] = 0;
	}
      tp = endp;
    }
  if (tp != endp)
    return (0);

  memcpy(dst, tmp, IN6ADDRSZ);
  return (1);
}

/* int
 * inet_pton(af, src, dst)
 *	convert from presentation format (which usually means ASCII printable)
 *	to network format (which is usually some kind of binary format).
 * return:
 *	1 if the address was valid for the specified address family
 *	0 if the address wasn't valid (`dst' is untouched in this case)
 *	-1 if some other error occurred (`dst' is untouched in this case, too)
 * author:
 *	Paul Vixie, 1996.
 */
d2250 1
a2250 521
cygwin_inet_pton (int af, const char *src, void *dst)
{
  switch (af)
    {
    case AF_INET:
      return (inet_pton4(src, (u_char *) dst));
    case AF_INET6:
      return (inet_pton6(src, (u_char *) dst));
    default:
      errno = EAFNOSUPPORT;
      return (-1);
    }
  /* NOTREACHED */
}

/* const char *
 * inet_ntop4(src, dst, size)
 *	format an IPv4 address, more or less like inet_ntoa()
 * return:
 *	`dst' (as a const)
 * notes:
 *	(1) uses no statics
 *	(2) takes a u_char* not an in_addr as input
 * author:
 *	Paul Vixie, 1996.
 */
static const char *
inet_ntop4 (const u_char *src, char *dst, size_t size)
{
  static const char fmt[] = "%u.%u.%u.%u";
  char tmp[sizeof "255.255.255.255"];

  __small_sprintf(tmp, fmt, src[0], src[1], src[2], src[3]);
  if (strlen(tmp) > size)
    {
      errno = ENOSPC;
      return (NULL);
    }
  strcpy(dst, tmp);
  return (dst);
}

/* const char *
 * inet_ntop6(src, dst, size)
 *	convert IPv6 binary address into presentation (printable) format
 * author:
 *	Paul Vixie, 1996.
 */
static const char *
inet_ntop6 (const u_char *src, char *dst, size_t size)
{
  /*
   * Note that int32_t and int16_t need only be "at least" large enough
   * to contain a value of the specified size.  On some systems, like
   * Crays, there is no such thing as an integer variable with 16 bits.
   * Keep this in mind if you think this function should have been coded
   * to use pointer overlays.  All the world's not a VAX.
   */
  char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
  struct { int base, len; } best, cur;
  u_int words[IN6ADDRSZ / INT16SZ];
  int i;

  /*
   * Preprocess:
   *	Copy the input (bytewise) array into a wordwise array.
   *	Find the longest run of 0x00's in src[] for :: shorthanding.
   */
  memset(words, 0, sizeof words);
  for (i = 0; i < IN6ADDRSZ; i++)
    words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
  best.base = -1;
  cur.base = -1;
  for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++)
    {
      if (words[i] == 0)
        {
	  if (cur.base == -1)
	    cur.base = i, cur.len = 1;
	  else
	    cur.len++;
	}
      else
        {
	  if (cur.base != -1)
	    {
	      if (best.base == -1 || cur.len > best.len)
		best = cur;
	      cur.base = -1;
	    }
	}
    }
  if (cur.base != -1)
    {
      if (best.base == -1 || cur.len > best.len)
	best = cur;
    }
  if (best.base != -1 && best.len < 2)
    best.base = -1;

  /*
   * Format the result.
   */
  tp = tmp;
  for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++)
    {
      /* Are we inside the best run of 0x00's? */
      if (best.base != -1 && i >= best.base && i < (best.base + best.len))
        {
	  if (i == best.base)
	    *tp++ = ':';
	  continue;
	}
      /* Are we following an initial run of 0x00s or any real hex? */
      if (i != 0)
	*tp++ = ':';
      /* Is this address an encapsulated IPv4? */
      if (i == 6 && best.base == 0 &&
	  (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))
	{
	  if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
	    return (NULL);
	  tp += strlen(tp);
	  break;
	}
      __small_sprintf(tp, "%x", words[i]);
      tp += strlen(tp);
    }
  /* Was it a trailing run of 0x00's? */
  if (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ))
    *tp++ = ':';
  *tp++ = '\0';

  /*
   * Check for overflow, copy, and we're done.
   */
  if ((size_t) (tp - tmp) > size)
    {
      errno = ENOSPC;
      return (NULL);
    }
  strcpy(dst, tmp);
  return (dst);
}

/* char *
 * inet_ntop(af, src, dst, size)
 *	convert a network format address to presentation format.
 * return:
 *	pointer to presentation format address (`dst'), or NULL (see errno).
 * author:
 *	Paul Vixie, 1996.
 */
extern "C" const char *
cygwin_inet_ntop (int af, const void *src, char *dst, size_t size)
{
  switch (af)
    {
    case AF_INET:
      return (inet_ntop4((const u_char *) src, dst, size));
    case AF_INET6:
      return (inet_ntop6((const u_char *) src, dst, size));
    default:
      errno = EAFNOSUPPORT;
      return (NULL);
    }
  /* NOTREACHED */
}

/* W. Richard STEVENS libgai implementation, slightly tweaked for inclusion
   into Cygwin as pure IPv4 replacement.  Please note that the code is
   kept intact as much as possible.  Especially the IPv6 and AF_UNIX code
   is kept in, even though we can support neither of them.  Please don't
   activate them, they won't work correctly. */

#define IPv4
#undef IPv6
#undef UNIXdomain

#undef HAVE_SOCKADDR_SA_LEN
#define gethostbyname2(host,family) cygwin_gethostbyname((host))

#define AI_CLONE 0x8000		/* Avoid collision with AI_ values in netdb.h */

/*
 * Create and fill in an addrinfo{}.
 */

/* include ga_aistruct1 */
static int
ga_aistruct (struct addrinfo ***paipnext, const struct addrinfo *hintsp,
	     const void *addr, int family)
{
  struct addrinfo *ai;

  if ((ai = (struct addrinfo *) calloc (1, sizeof (struct addrinfo))) == NULL)
    return (EAI_MEMORY);
  ai->ai_next = NULL;
  ai->ai_canonname = NULL;
  **paipnext = ai;
  *paipnext = &ai->ai_next;

  if ((ai->ai_socktype = hintsp->ai_socktype) == 0)
    ai->ai_flags |= AI_CLONE;

  ai->ai_protocol = hintsp->ai_protocol;
/* end ga_aistruct1 */

/* include ga_aistruct2 */
  switch ((ai->ai_family = family))
    {
#ifdef	IPv4
    case AF_INET:
      {
	struct sockaddr_in *sinptr;

	/* 4allocate sockaddr_in{} and fill in all but port */
	if ((sinptr = (struct sockaddr_in *)
		      calloc (1, sizeof (struct sockaddr_in))) == NULL)
	  return (EAI_MEMORY);
#ifdef	HAVE_SOCKADDR_SA_LEN
	sinptr->sin_len = sizeof (struct sockaddr_in);
#endif
	sinptr->sin_family = AF_INET;
	memcpy (&sinptr->sin_addr, addr, sizeof (struct in_addr));
	ai->ai_addr = (struct sockaddr *) sinptr;
	ai->ai_addrlen = sizeof (struct sockaddr_in);
	break;
      }
#endif /* IPV4 */
#ifdef	IPv6
    case AF_INET6:
      {
	struct sockaddr_in6 *sin6ptr;

	/* 4allocate sockaddr_in6{} and fill in all but port */
	if ((sin6ptr = calloc (1, sizeof (struct sockaddr_in6))) == NULL)
	  return (EAI_MEMORY);
#ifdef	HAVE_SOCKADDR_SA_LEN
	sin6ptr->sin6_len = sizeof (struct sockaddr_in6);
#endif
	sin6ptr->sin6_family = AF_INET6;
	memcpy (&sin6ptr->sin6_addr, addr, sizeof (struct in6_addr));
	ai->ai_addr = (struct sockaddr *) sin6ptr;
	ai->ai_addrlen = sizeof (struct sockaddr_in6);
	break;
      }
#endif /* IPV6 */
#ifdef	UNIXdomain
    case AF_LOCAL:
      {
	struct sockaddr_un *unp;

	/* 4allocate sockaddr_un{} and fill in */
/* *INDENT-OFF* */
			if (strlen(addr) >= sizeof(unp->sun_path))
				return(EAI_SERVICE);
			if ( (unp = calloc(1, sizeof(struct sockaddr_un))) == NULL)
				return(EAI_MEMORY);
/* *INDENT-ON* */
	unp->sun_family = AF_LOCAL;
	strcpy (unp->sun_path, addr);
#ifdef	HAVE_SOCKADDR_SA_LEN
	unp->sun_len = SUN_LEN (unp);
#endif
	ai->ai_addr = (struct sockaddr *) unp;
	ai->ai_addrlen = sizeof (struct sockaddr_un);
	if (hintsp->ai_flags & AI_PASSIVE)
	  unlink (unp->sun_path);	/* OK if this fails */
	break;
      }
#endif /* UNIXDOMAIN */
    }
  return (0);
}

/* end ga_aistruct2 */

/*
 * Clone a new addrinfo structure from an existing one.
 */

/* include ga_clone */
static struct addrinfo *
ga_clone (struct addrinfo *ai)
{
  struct addrinfo *nai;

  if ((nai = (struct addrinfo *) calloc (1, sizeof (struct addrinfo))) == NULL)
    return (NULL);

  nai->ai_next = ai->ai_next;
  ai->ai_next = nai;

  nai->ai_flags = 0;		/* make sure AI_CLONE is off */
  nai->ai_family = ai->ai_family;
  nai->ai_socktype = ai->ai_socktype;
  nai->ai_protocol = ai->ai_protocol;
  nai->ai_canonname = NULL;
  nai->ai_addrlen = ai->ai_addrlen;
  if ((nai->ai_addr = (struct sockaddr *) malloc (ai->ai_addrlen)) == NULL)
    return (NULL);
  memcpy (nai->ai_addr, ai->ai_addr, ai->ai_addrlen);

  return (nai);
}

/* end ga_clone */

/*
 * Basic error checking of flags, family, socket type, and protocol.
 */

/* include ga_echeck */
static int
ga_echeck (const char *hostname, const char *servname,
	   int flags, int family, int socktype, int protocol)
{
  if (flags & ~(AI_PASSIVE | AI_CANONNAME))
    return (EAI_BADFLAGS);	/* unknown flag bits */

  if (hostname == NULL || hostname[0] == '\0')
    {
      if (servname == NULL || servname[0] == '\0')
	return (EAI_NONAME);	/* host or service must be specified */
    }

  switch (family)
    {
    case AF_UNSPEC:
      break;
#ifdef	IPv4
    case AF_INET:
      if (socktype != 0 &&
	  (socktype != SOCK_STREAM &&
	   socktype != SOCK_DGRAM && socktype != SOCK_RAW))
	return (EAI_SOCKTYPE);	/* invalid socket type */
      break;
#endif
#ifdef	IPv6
    case AF_INET6:
      if (socktype != 0 &&
	  (socktype != SOCK_STREAM &&
	   socktype != SOCK_DGRAM && socktype != SOCK_RAW))
	return (EAI_SOCKTYPE);	/* invalid socket type */
      break;
#endif
#ifdef	UNIXdomain
    case AF_LOCAL:
      if (socktype != 0 &&
	  (socktype != SOCK_STREAM && socktype != SOCK_DGRAM))
	return (EAI_SOCKTYPE);	/* invalid socket type */
      break;
#endif
    default:
      return (EAI_FAMILY);	/* unknown protocol family */
    }
  return (0);
}

/* end ga_echeck */

struct search {
  const char *host;  /* hostname or address string */
  int        family; /* AF_xxx */
};

/*
 * Set up the search[] array with the hostnames and address families
 * that we are to look up.
 */

/* include ga_nsearch1 */
static int
ga_nsearch (const char *hostname, const struct addrinfo *hintsp,
	    struct search *search)
{
  int nsearch = 0;

  if (hostname == NULL || hostname[0] == '\0')
    {
      if (hintsp->ai_flags & AI_PASSIVE)
	{
	  /* 4no hostname and AI_PASSIVE: implies wildcard bind */
	  switch (hintsp->ai_family)
	    {
#ifdef	IPv4
	    case AF_INET:
	      search[nsearch].host = "0.0.0.0";
	      search[nsearch].family = AF_INET;
	      nsearch++;
	      break;
#endif
#ifdef	IPv6
	    case AF_INET6:
	      search[nsearch].host = "0::0";
	      search[nsearch].family = AF_INET6;
	      nsearch++;
	      break;
#endif
	    case AF_UNSPEC:
#ifdef	IPv6
	      search[nsearch].host = "0::0";	/* IPv6 first, then IPv4 */
	      search[nsearch].family = AF_INET6;
	      nsearch++;
#endif
#ifdef	IPv4
	      search[nsearch].host = "0.0.0.0";
	      search[nsearch].family = AF_INET;
	      nsearch++;
#endif
	      break;
	    }
/* end ga_nsearch1 */
/* include ga_nsearch2 */
	}
      else
	{
	  /* 4no host and not AI_PASSIVE: connect to local host */
	  switch (hintsp->ai_family)
	    {
#ifdef	IPv4
	    case AF_INET:
	      search[nsearch].host = "localhost";	/* 127.0.0.1 */
	      search[nsearch].family = AF_INET;
	      nsearch++;
	      break;
#endif
#ifdef	IPv6
	    case AF_INET6:
	      search[nsearch].host = "0::1";
	      search[nsearch].family = AF_INET6;
	      nsearch++;
	      break;
#endif
	    case AF_UNSPEC:
#ifdef	IPv6
	      search[nsearch].host = "0::1";	/* IPv6 first, then IPv4 */
	      search[nsearch].family = AF_INET6;
	      nsearch++;
#endif
#ifdef	IPv4
	      search[nsearch].host = "localhost";
	      search[nsearch].family = AF_INET;
	      nsearch++;
#endif
	      break;
	    }
	}
/* end ga_nsearch2 */
/* include ga_nsearch3 */
    }
  else
    {				/* host is specified */
      switch (hintsp->ai_family)
	{
#ifdef	IPv4
	case AF_INET:
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET;
	  nsearch++;
	  break;
#endif
#ifdef	IPv6
	case AF_INET6:
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET6;
	  nsearch++;
	  break;
#endif
	case AF_UNSPEC:
#ifdef	IPv6
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET6;	/* IPv6 first */
	  nsearch++;
#endif
#ifdef	IPv4
	  search[nsearch].host = hostname;
	  search[nsearch].family = AF_INET;	/* then IPv4 */
	  nsearch++;
#endif
	  break;
	}
    }
  if (nsearch < 1 || nsearch > 2)
    return -1;
  return (nsearch);
}

/* end ga_nsearch3 */

/*
 * Go through all the addrinfo structures, checking for a match of the
 * socket type and filling in the socket type, and then the port number
 * in the corresponding socket address structures.
 *
 * The AI_CLONE flag works as follows.  Consider a multihomed host with
 * two IP addresses and no socket type specified by the caller.  After
 * the "host" search there are two addrinfo structures, one per IP address.
 * Assuming a service supported by both TCP and UDP (say the daytime
 * service) we need to return *four* addrinfo structures:
 *		IP#1, SOCK_STREAM, TCP port,
 *		IP#1, SOCK_DGRAM, UDP port,
 *		IP#2, SOCK_STREAM, TCP port,
 *		IP#2, SOCK_DGRAM, UDP port.
 * To do this, when the "host" loop creates an addrinfo structure, if the
 * caller has not specified a socket type (hintsp->ai_socktype == 0), the
 * AI_CLONE flag is set.  When the following function finds an entry like
 * this it is handled as follows: If the entry's ai_socktype is still 0,
 * this is the first use of the structure, and the ai_socktype field is set.
 * But, if the entry's ai_socktype is nonzero, then we clone a new addrinfo
 * structure and set it's ai_socktype to the new value.  Although we only
 * need two socket types today (SOCK_STREAM and SOCK_DGRAM) this algorithm
 * will handle any number.  Also notice that Posix.1g requires all socket
 * types to be nonzero.
 */

/* include ga_port */
static int
ga_port (struct addrinfo *aihead, int port, int socktype)
		/* port must be in network byte order */
d2252 1
a2252 4
  int nfound = 0;
  struct addrinfo *ai;

  for (ai = aihead; ai != NULL; ai = ai->ai_next)
d2254 1
a2254 13
      if (ai->ai_flags & AI_CLONE)
	{
	  if (ai->ai_socktype != 0)
	    {
	      if ((ai = ga_clone (ai)) == NULL)
		return (-1);	/* memory allocation error */
	      /* ai points to newly cloned entry, which is what we want */
	    }
	}
      else if (ai->ai_socktype != socktype)
	continue;		/* ignore if mismatch on socket type */

      ai->ai_socktype = socktype;
d2256 1
a2256 1
      switch (ai->ai_family)
d2258 2
a2259 12
#ifdef	IPv4
	case AF_INET:
	  ((struct sockaddr_in *) ai->ai_addr)->sin_port = port;
	  nfound++;
	  break;
#endif
#ifdef	IPv6
	case AF_INET6:
	  ((struct sockaddr_in6 *) ai->ai_addr)->sin6_port = port;
	  nfound++;
	  break;
#endif
d2261 1
d2263 2
a2264 450
  return (nfound);
}

/* end ga_port */

/*
 * This function handles the service string.
 */

/* include ga_serv */
static int
ga_serv (struct addrinfo *aihead, const struct addrinfo *hintsp,
	 const char *serv)
{
  int port, rc, nfound;
  struct servent *sptr;

  nfound = 0;
  if (isdigit (serv[0]))
    {				/* check for port number string first */
      port = htons (atoi (serv));
      if (hintsp->ai_socktype)
	{
	  /* 4caller specifies socket type */
	  if ((rc = ga_port (aihead, port, hintsp->ai_socktype)) < 0)
	    return (EAI_MEMORY);
	  nfound += rc;
	}
      else
	{
	  /* 4caller does not specify socket type */
	  if ((rc = ga_port (aihead, port, SOCK_STREAM)) < 0)
	    return (EAI_MEMORY);
	  nfound += rc;
	  if ((rc = ga_port (aihead, port, SOCK_DGRAM)) < 0)
	    return (EAI_MEMORY);
	  nfound += rc;
	}
    }
  else
    {
      /* 4try service name, TCP then UDP */
      if (hintsp->ai_socktype == 0 || hintsp->ai_socktype == SOCK_STREAM)
	{
	  if ((sptr = cygwin_getservbyname (serv, "tcp")) != NULL)
	    {
	      if ((rc = ga_port (aihead, sptr->s_port, SOCK_STREAM)) < 0)
		return (EAI_MEMORY);
	      nfound += rc;
	    }
	}
      if (hintsp->ai_socktype == 0 || hintsp->ai_socktype == SOCK_DGRAM)
	{
	  if ((sptr = cygwin_getservbyname (serv, "udp")) != NULL)
	    {
	      if ((rc = ga_port (aihead, sptr->s_port, SOCK_DGRAM)) < 0)
		return (EAI_MEMORY);
	      nfound += rc;
	    }
	}
    }

  if (nfound == 0)
    {
      if (hintsp->ai_socktype == 0)
	return (EAI_NONAME);	/* all calls to getservbyname() failed */
      else
	return (EAI_SERVICE);	/* service not supported for socket type */
    }
  return (0);
}

/* end ga_serv */

#ifdef	UNIXdomain
/* include ga_unix */
static int
ga_unix (const char *path, struct addrinfo *hintsp, struct addrinfo **result)
{
  int rc;
  struct addrinfo *aihead, **aipnext;

  aihead = NULL;
  aipnext = &aihead;

  if (hintsp->ai_family != AF_UNSPEC && hintsp->ai_family != AF_LOCAL)
    return (EAI_ADDRFAMILY);

  if (hintsp->ai_socktype == 0)
    {
      /* 4no socket type specified: return stream then dgram */
      hintsp->ai_socktype = SOCK_STREAM;
      if ((rc = ga_aistruct (&aipnext, hintsp, path, AF_LOCAL)) != 0)
	return (rc);
      hintsp->ai_socktype = SOCK_DGRAM;
    }

  if ((rc = ga_aistruct (&aipnext, hintsp, path, AF_LOCAL)) != 0)
    return (rc);

  if (hintsp->ai_flags & AI_CANONNAME)
    {
      struct utsname myname;

      if (uname (&myname) < 0)
	return (EAI_SYSTEM);
      if ((aihead->ai_canonname = strdup (myname.nodename)) == NULL)
	return (EAI_MEMORY);
    }

  *result = aihead;		/* pointer to first structure in linked list */
  return (0);
}

/* end ga_unix */
#endif /* UNIXdomain */

/* include gn_ipv46 */
static int
gn_ipv46 (char *host, size_t hostlen, char *serv, size_t servlen,
	  void *aptr, size_t alen, int family, int port, int flags)
{
  char *ptr;
  struct hostent *hptr;
  struct servent *sptr;

  if (host && hostlen > 0)
    {
      if (flags & NI_NUMERICHOST)
	{
	  if (cygwin_inet_ntop (family, aptr, host, hostlen) == NULL)
	    return (1);
	}
      else
	{
	  hptr = cygwin_gethostbyaddr ((const char *) aptr, alen, family);
	  if (hptr != NULL && hptr->h_name != NULL)
	    {
	      if (flags & NI_NOFQDN)
		{
		  if ((ptr = strchr (hptr->h_name, '.')) != NULL)
		    *ptr = 0;	/* overwrite first dot */
		}
	      //snprintf (host, hostlen, "%s", hptr->h_name);
	      *host = '\0';
	      strncat (host, hptr->h_name, hostlen - 1);
	    }
	  else
	    {
	      if (flags & NI_NAMEREQD)
		return (1);
	      if (cygwin_inet_ntop (family, aptr, host, hostlen) == NULL)
		return (1);
	    }
	}
    }

  if (serv && servlen > 0)
    {
      if (flags & NI_NUMERICSERV)
	{
	  //snprintf (serv, servlen, "%d", ntohs (port));
	  char buf[32];
	  __small_sprintf (buf, "%d", ntohs (port));
	  *serv = '\0';
	  strncat (serv, buf, servlen - 1);
	}
      else
	{
	  sptr = cygwin_getservbyport (port, (flags & NI_DGRAM) ? "udp" : NULL);
	  if (sptr != NULL && sptr->s_name != NULL)
	    {
	      //snprintf (serv, servlen, "%s", sptr->s_name);
	      *serv = '\0';
	      strncat (serv, sptr->s_name, servlen - 1);
	    }
	  else
	    {
	      //snprintf (serv, servlen, "%d", ntohs (port));
	      char buf[32];
	      __small_sprintf (buf, "%d", ntohs (port));
	      *serv = '\0';
	      strncat (serv, buf, servlen - 1);
	    }
	}
    }
  return (0);
}

/* end gn_ipv46 */

/* include freeaddrinfo */
void
ipv4_freeaddrinfo (struct addrinfo *aihead)
{
  struct addrinfo *ai, *ainext;

  for (ai = aihead; ai != NULL; ai = ainext)
    {
      if (ai->ai_addr != NULL)
	free (ai->ai_addr);	/* socket address structure */

      if (ai->ai_canonname != NULL)
	free (ai->ai_canonname);

      ainext = ai->ai_next;	/* can't fetch ai_next after free() */
      free (ai);		/* the addrinfo{} itself */
    }
}

/* end freeaddrinfo */

/* include ga1 */

int
ipv4_getaddrinfo (const char *hostname, const char *servname,
		  const struct addrinfo *hintsp, struct addrinfo **result)
{
  int rc, error, nsearch;
  char **ap, *canon;
  struct hostent *hptr;
  struct search search[3], *sptr;
  struct addrinfo hints, *aihead, **aipnext;

  /*
   * If we encounter an error we want to free() any dynamic memory
   * that we've allocated.  This is our hack to simplify the code.
   */
#define	error(e) { error = (e); goto bad; }

  aihead = NULL;		/* initialize automatic variables */
  aipnext = &aihead;
  canon = NULL;

  if (hintsp == NULL)
    {
      bzero (&hints, sizeof (hints));
      hints.ai_family = AF_UNSPEC;
    }
  else
    hints = *hintsp;		/* struct copy */

  /* 4first some basic error checking */
  if ((rc = ga_echeck (hostname, servname, hints.ai_flags, hints.ai_family,
		       hints.ai_socktype, hints.ai_protocol)) != 0)
    error (rc);

#ifdef	UNIXdomain
  /* 4special case Unix domain first */
  if (hostname != NULL &&
      (strcmp (hostname, "/local") == 0 || strcmp (hostname, "/unix") == 0) &&
      (servname != NULL && servname[0] == '/'))
    return (ga_unix (servname, &hints, result));
#endif
/* end ga1 */

/* include ga3 */
  /* 4remainder of function for IPv4/IPv6 */
  nsearch = ga_nsearch (hostname, &hints, &search[0]);
  if (nsearch == -1)
    error (EAI_FAMILY);
  for (sptr = &search[0]; sptr < &search[nsearch]; sptr++)
    {
#ifdef	IPv4
      /* 4check for an IPv4 dotted-decimal string */
      if (isdigit (sptr->host[0]))
	{
	  struct in_addr inaddr;

	  if (inet_pton4 (sptr->host, (u_char *) &inaddr) == 1)
	    {
	      if (hints.ai_family != AF_UNSPEC && hints.ai_family != AF_INET)
		error (EAI_ADDRFAMILY);
	      if (sptr->family != AF_INET)
		continue;	/* ignore */
	      rc = ga_aistruct (&aipnext, &hints, &inaddr, AF_INET);
	      if (rc != 0)
		error (rc);
	      continue;
	    }
	}
#endif

#ifdef	IPv6
      /* 4check for an IPv6 hex string */
      if ((isxdigit (sptr->host[0]) || sptr->host[0] == ':') &&
	  (strchr (sptr->host, ':') != NULL))
	{
	  struct in6_addr in6addr;

	  if (inet_pton6 (sptr->host, &in6addr) == 1)
	    {
	      if (hints.ai_family != AF_UNSPEC && hints.ai_family != AF_INET6)
		error (EAI_ADDRFAMILY);
	      if (sptr->family != AF_INET6)
		continue;	/* ignore */
	      rc = ga_aistruct (&aipnext, &hints, &in6addr, AF_INET6);
	      if (rc != 0)
		error (rc);
	      continue;
	    }
	}
#endif
/* end ga3 */
/* include ga4 */
#ifdef	IPv6
      /* 4remainder of for() to look up hostname */
      if ((_res.options & RES_INIT) == 0)
	res_init ();		/* need this to set _res.options */
#endif

      if (nsearch == 2)
	{
#ifdef	IPv6
	  _res.options &= ~RES_USE_INET6;
#endif
	  hptr = gethostbyname2 (sptr->host, sptr->family);
	}
      else
	{
#ifdef  IPv6
	  if (sptr->family == AF_INET6)
	    _res.options |= RES_USE_INET6;
	  else
	    _res.options &= ~RES_USE_INET6;
#endif
	  hptr = gethostbyname (sptr->host);
	}
      if (hptr == NULL)
	{
	  if (nsearch == 2)
	    continue;		/* failure OK if multiple searches */

	  switch (h_errno)
	    {
	    case HOST_NOT_FOUND:
	      error (EAI_NONAME);
	    case TRY_AGAIN:
	      error (EAI_AGAIN);
	    case NO_RECOVERY:
	      error (EAI_FAIL);
	    case NO_DATA:
	      error (EAI_NODATA);
	    default:
	      error (EAI_NONAME);
	    }
	}

      /* 4check for address family mismatch if one specified */
      if (hints.ai_family != AF_UNSPEC && hints.ai_family != hptr->h_addrtype)
	error (EAI_ADDRFAMILY);

      /* 4save canonical name first time */
      if (hostname != NULL && hostname[0] != '\0' &&
	  (hints.ai_flags & AI_CANONNAME) && canon == NULL)
	{
	  if ((canon = strdup (hptr->h_name)) == NULL)
	    error (EAI_MEMORY);
	}

      /* 4create one addrinfo{} for each returned address */
      for (ap = hptr->h_addr_list; *ap != NULL; ap++)
	{
	  rc = ga_aistruct (&aipnext, &hints, *ap, hptr->h_addrtype);
	  if (rc != 0)
	    error (rc);
	}
    }
  if (aihead == NULL)
    error (EAI_NONAME);		/* nothing found */
/* end ga4 */

/* include ga5 */
  /* 4return canonical name */
  if (hostname != NULL && hostname[0] != '\0' &&
      hints.ai_flags & AI_CANONNAME)
    {
      if (canon != NULL)
	aihead->ai_canonname = canon;	/* strdup'ed earlier */
      else
	{
	  if ((aihead->ai_canonname = strdup (search[0].host)) == NULL)
	    error (EAI_MEMORY);
	}
    }

  /* 4now process the service name */
  if (servname != NULL && servname[0] != '\0')
    {
      if ((rc = ga_serv (aihead, &hints, servname)) != 0)
	error (rc);
    }

  *result = aihead;		/* pointer to first structure in linked list */
  return (0);

bad:
  ipv4_freeaddrinfo (aihead);	/* free any alloc'ed memory */
  return (error);
}

/* end ga5 */

/* include getnameinfo */
int
ipv4_getnameinfo (const struct sockaddr *sa, socklen_t salen,
		  char *host, size_t hostlen,
		  char *serv, size_t servlen, int flags)
{

  switch (sa->sa_family)
    {
#ifdef	IPv4
    case AF_INET:
      {
	struct sockaddr_in *sain = (struct sockaddr_in *) sa;

	return (gn_ipv46 (host, hostlen, serv, servlen,
			  &sain->sin_addr, sizeof (struct in_addr),
			  AF_INET, sain->sin_port, flags));
      }
#endif

#ifdef	IPv6
    case AF_INET6:
      {
	struct sockaddr_in6 *sain = (struct sockaddr_in6 *) sa;

	return (gn_ipv46 (host, hostlen, serv, servlen,
			  &sain->sin6_addr, sizeof (struct in6_addr),
			  AF_INET6, sain->sin6_port, flags));
      }
#endif

#ifdef	UNIXdomain
    case AF_LOCAL:
      {
	struct sockaddr_un *un = (struct sockaddr_un *) sa;

	if (hostlen > 0)
	  snprintf (host, hostlen, "%s", "/local");
	if (servlen > 0)
	  snprintf (serv, servlen, "%s", un->sun_path);
	return (0);
      }
#endif

    default:
      return (1);
    }
d2267 2
a2268 28
/* end getnameinfo */

/* Start of cygwin specific wrappers around the gai functions. */

struct gai_errmap_t
{
  int w32_errval;
  const char *errtxt;
};

static gai_errmap_t gai_errmap[] =
{
  {0,			"Success"},
  {0,			"Address family for hostname not supported"},
  {WSATRY_AGAIN,	"Temporary failure in name resolution"},
  {WSAEINVAL,		"Invalid value for ai_flags"},
  {WSANO_RECOVERY,	"Non-recoverable failure in name resolution"},
  {WSAEAFNOSUPPORT,	"ai_family not supported"},
  {WSA_NOT_ENOUGH_MEMORY, "Memory allocation failure"},
  {WSANO_DATA,		"No address associated with hostname"},
  {WSAHOST_NOT_FOUND,	"hostname nor servname provided, or not known"},
  {WSATYPE_NOT_FOUND,	"servname not supported for ai_socktype"},
  {WSAESOCKTNOSUPPORT,	"ai_socktype not supported"},
  {0,			"System error returned in errno"},
  {0,			"Invalid value for hints"},
  {0,			"Resolved protocol is unknown"}
};

d2270 1
a2270 88
cygwin_gai_strerror (int err)
{
  if (err >= 0 && err < EAI_MAX)
    return gai_errmap[err].errtxt;
  return "Unknown error";
}

static int
w32_to_gai_err (int w32_err)
{
  if (w32_err >= WSABASEERR)
    for (int i = 0; i < EAI_MAX; ++i)
      if (gai_errmap[i].w32_errval == w32_err)
	return i;
  return w32_err;
}

/* We can't use autoload here because we don't know where the functions
   are loaded from.  On Win2K, the functions are available in the
   ipv6 technology preview lib called wship6.dll, in XP and above they
   are implemented in ws2_32.dll.  For older systems we use the ipv4-only
   version above. */

static void (WINAPI *freeaddrinfo)(const struct addrinfo *);
static int (WINAPI *getaddrinfo)(const char *, const char *,
				  const struct addrinfo *,
				  struct addrinfo **);
static int (WINAPI *getnameinfo)(const struct sockaddr *, socklen_t,
				  char *, size_t, char *, size_t, int);
static bool
get_ipv6_funcs (HMODULE lib)
{
  return ((freeaddrinfo = (void (WINAPI *)(const struct addrinfo *))
			  GetProcAddress(lib, "freeaddrinfo"))
	  && (getaddrinfo = (int (WINAPI *)(const char *, const char *,
					    const struct addrinfo *,
					    struct addrinfo **))
			    GetProcAddress(lib, "getaddrinfo"))
	  && (getnameinfo = (int (WINAPI *)(const struct sockaddr *,
					    socklen_t, char *, size_t,
					    char *, size_t, int))
			    GetProcAddress(lib, "getnameinfo")));
}

static NO_COPY muto load_ipv6_guard;
static bool ipv6_inited = false;
#define load_ipv6()	if (!ipv6_inited) load_ipv6_funcs ();

static void
load_ipv6_funcs ()
{

  char lib_name[CYG_MAX_PATH];
  size_t len;
  HMODULE lib;

  load_ipv6_guard.init ("klog_guard")->acquire ();
  if (ipv6_inited)
    goto out;
  WSAGetLastError ();	/* Kludge.  Enforce WSAStartup call. */
  if (GetSystemDirectory (lib_name, CYG_MAX_PATH))
    {
      len = strlen (lib_name);
      strcpy (lib_name + len, "\\ws2_32.dll");
      if ((lib = LoadLibrary (lib_name)))
        {
	  if (get_ipv6_funcs (lib))
	    goto out;
	  FreeLibrary (lib);
	}
      strcpy (lib_name + len, "\\wship6.dll");
      if ((lib = LoadLibrary (lib_name)))
        {
	  if (get_ipv6_funcs (lib))
	    goto out;
	  FreeLibrary (lib);
	}
      freeaddrinfo = NULL;
      getaddrinfo = NULL;
      getnameinfo = NULL;
    }
out:
  ipv6_inited = true;
  load_ipv6_guard.release ();
}

extern "C" void
cygwin_freeaddrinfo (struct addrinfo *addr)
d2272 1
a2272 9
  myfault efault;
  if (efault.faulted (EFAULT))
    return;
  load_ipv6 ();
  if (freeaddrinfo)
    freeaddrinfo (addr);
  else
    ipv4_freeaddrinfo (addr);
}
a2273 4
extern "C" int
cygwin_getaddrinfo (const char *hostname, const char *servname,
		    const struct addrinfo *hints, struct addrinfo **res)
{
d2276 4
a2279 6
    return EAI_SYSTEM;
  load_ipv6 ();
  if (getaddrinfo)
    return w32_to_gai_err (getaddrinfo (hostname, servname, hints, res));
  return ipv4_getaddrinfo (hostname, servname, hints, res);
}
d2281 5
a2285 25
extern "C" int
cygwin_getnameinfo (const struct sockaddr *sa, socklen_t salen,
		    char *host, size_t hostlen, char *serv,
		    size_t servlen, int flags)
{
  myfault efault;
  if (efault.faulted (EFAULT))
    return EAI_SYSTEM;
  load_ipv6 ();
  if (getnameinfo)
    {
      /* When the incoming port number is set to 0, Winsock's getnameinfo
	 returns with error WSAENO_DATA instead of simply ignoring the port.
	 To avoid this strange behaviour, we check manually, if the port number
	 is 0.  If so, set the NI_NUMERICSERV flag to avoid this problem. */
      switch (sa->sa_family)
        {
	case AF_INET:
	  if (((struct sockaddr_in *) sa)->sin_port == 0)
	    flags |= NI_NUMERICSERV;
	  break;
	case AF_INET6:
	  if (((struct sockaddr_in6 *) sa)->sin6_port == 0)
	    flags |= NI_NUMERICSERV;
	  break;
d2287 2
a2288 5
      int ret = w32_to_gai_err (getnameinfo (sa, salen, host, hostlen, serv,
					     servlen, flags));
      if (ret)
        set_winsock_errno ();
      return ret;
d2290 2
a2291 1
  return ipv4_getnameinfo (sa, salen, host, hostlen, serv, servlen, flags);
a2292 1

@


1.212.2.2
log
@	* Merge HEAD into cv-branch.
@
text
@a51 2
  int cygwin_inet_aton(const char *, struct in_addr *);
  const char *cygwin_inet_ntop (int, const void *, char *, socklen_t);
d109 1
a109 2
  char buf[20];
  const char *res = cygwin_inet_ntop (AF_INET, &in, buf, sizeof buf);
d121 40
@


1.212.2.3
log
@	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.
@
text
@d2562 1
a2562 1
cygwin_inet_ntop (int af, const void *src, char *dst, socklen_t size)
@


1.212.2.4
log
@	* Merge HEAD into cv-branch.

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.
@
text
@a515 2
  if (!((fhandler_socket *) fd)->prepare ())
    return false;
d779 50
a828 1
    res = fh->connect (name, namelen);
d962 13
a974 1
    res = fh->accept (peer, len);
@


1.212.2.5
log
@	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.
@
text
@d1765 78
d1847 1
a1847 1
LONG last_used_bindresvport __attribute__((section (".cygwin_dll_common"), shared)) = IPPORT_RESERVED;
d1849 1
d1851 1
a1851 1
cygwin_bindresvport_sa (int fd, struct sockaddr *sa)
d1853 1
a1853 7
  struct sockaddr_storage sst;
  struct sockaddr_in *sin = NULL;
  struct sockaddr_in6 *sin6 = NULL;
  in_port_t port;
  socklen_t salen;
  int ret;

d1860 2
a1861 5
  fhandler_socket *fh = get (fd);
  if (!fh)
    return -1;

  if (!sa)
d1863 5
a1867 4
      sa = (struct sockaddr *) &sst;
      memset (&sst, 0, sizeof sst);
      sa->sa_family = fh->get_addr_family ();
    }
d1869 7
a1875 16
  switch (sa->sa_family)
    {
    case AF_INET:
      salen = sizeof (struct sockaddr_in);
      sin = (struct sockaddr_in *) sa;
      port = sin->sin_port;
      break;
    case AF_INET6:
      salen = sizeof (struct sockaddr_in6);
      sin6 = (struct sockaddr_in6 *) sa;
      port = sin6->sin6_port;
      break;
    default:
      set_errno (EPFNOSUPPORT);
      return -1;
    }
d1877 14
a1890 7
  /* If a non-zero port number is given, try this first.  If that succeeds,
     or if the error message is serious, return. */
  if (port)
    {
      ret = fh->bind (sa, salen);
      if (!ret || (get_errno () != EADDRINUSE && get_errno () != EINVAL))
        return ret;
d1893 1
a1893 3
  LONG myport;

  for (int i = 0; i < NUM_PORTS; i++)
d1895 1
a1895 5
      while ((myport = InterlockedExchange (&last_used_bindresvport, 0)) == 0)
	low_priority_sleep (0);
      if (--myport < PORT_LOW)
	myport = PORT_HIGH;
      InterlockedExchange (&last_used_bindresvport, myport);
d1897 2
a1898 2
      if (sa->sa_family == AF_INET6)
	sin6->sin6_port = htons (myport);
d1900 1
a1900 5
	sin->sin_port = htons (myport);
      if (!(ret = fh->bind (sa, salen)))
	break;
      if (get_errno () != EADDRINUSE && get_errno () != EINVAL)
	break;
d1903 2
a1904 7
  return ret;
}

extern "C" int
cygwin_bindresvport (int fd, struct sockaddr_in *sin)
{
  return cygwin_bindresvport_sa (fd, (struct sockaddr *) sin);
@


1.212.2.6
log
@	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.
@
text
@d516 1
a516 1
  if (!((fhandler_socket *) fd)->init_events ())
@


1.211
log
@	* net.cc (cygwin_sendto): Define appropriate parameters using
	socklen_t type according to SUSv3.
	(cygwin_recvfrom): Ditto.
	(cygwin_setsockopt): Ditto.
	(cygwin_getsockopt): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_bind): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	* include/cygwin/socket.h (socklen_t): Typedef and define.
	* include/sys/socket.h: Declare socket functions using socklen_t type.
@
text
@a49 2
  int __stdcall rexec (char **ahost, unsigned short inport, char *locuser,
		       char *password, char *cmd, SOCKET * fd2p);
a147 3
/* undocumented in wsock32.dll */
extern "C" unsigned int WINAPI inet_network (const char *);

d154 1
a154 3
  unsigned int res = inet_network (cp);

  return res;
a1997 52
/* exported as rexec: standards? */
extern "C" int
cygwin_rexec (char **ahost, unsigned short inport, char *locuser,
	      char *password, char *cmd, int *fd2p)
{
  int res = -1;
  SOCKET fd2s;
  sig_dispatch_pending ();

  myfault efault;
  if (efault.faulted (EFAULT))
    return (int) INVALID_SOCKET;

  res = rexec (ahost, inport, locuser, password, cmd, fd2p ? &fd2s : NULL);
  if (res != (int) INVALID_SOCKET)
    {
      cygheap_fdnew res_fd;

      if (res_fd >= 0 && fdsock (res_fd, tcp_dev, res))
	{
	  ((fhandler_socket *) res_fd)->connect_state (connected);
	  res = res_fd;
	}
      else
	{
	  closesocket (res);
	  res = -1;
	}

      if (res >= 0 && fd2p)
	{
	  cygheap_fdnew newfd (res_fd, false);
	  cygheap_fdget fd (*fd2p);

	  if (newfd >= 0 && fdsock (newfd, tcp_dev, fd2s))
	    {
	      ((fhandler_socket *) fd2p)->connect_state (connected);
	      *fd2p = newfd;
	    }
	  else
	    {
	      closesocket (res);
	      closesocket (fd2s);
	      res = -1;
	    }
	}
    }

  syscall_printf ("%d = rexec (...)", res);
  return res;
}

@


1.210
log
@	* net.cc (cygwin_sendto): Allow zero-sized packets.
	(cygwin_sendmsg): Ditto.
@
text
@d626 2
a627 2
cygwin_sendto (int fd, const void *buf, int len, int flags,
	       const struct sockaddr *to, int tolen)
d648 2
a649 2
cygwin_recvfrom (int fd, void *buf, int len, int flags,
		 struct sockaddr *from, int *fromlen)
d692 1
a692 1
		   int optlen)
d756 2
a757 1
cygwin_getsockopt (int fd, int level, int optname, void *optval, int *optlen)
d807 1
a807 1
cygwin_connect (int fd, const struct sockaddr *name, int namelen)
d990 1
a990 1
cygwin_accept (int fd, struct sockaddr *peer, int *len)
d1021 1
a1021 1
cygwin_bind (int fd, const struct sockaddr *my_addr, int addrlen)
d1039 1
a1039 1
cygwin_getsockname (int fd, struct sockaddr *addr, int *namelen)
d1141 1
a1141 1
cygwin_getpeername (int fd, struct sockaddr *name, int *len)
d1160 1
a1160 1
cygwin_recv (int fd, void *buf, int len, int flags)
d1167 1
a1167 1
cygwin_send (int fd, const void *buf, int len, int flags)
@


1.209
log
@	Revert patches from 2005-10-22 and 2006-06-14 to use event driven
	accept and connect back to using select:
	* fhandler.h (class fhandler_socket): Remove accept_mtx.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Drop
	initializing accept_mtx.
	(fhandler_socket::accept): Drop event handling.
	(fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::dup): Drop accept_mtx handling.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::prepare): Ditto.
	(fhandler_socket::release): Ditto.
	(fhandler_socket::close): Ditto.
	* net.cc (cygwin_accept): Revert to calling cygwin_select to
	implement interuptible accept.
	(cygwin_connect): Ditto for connect.
@
text
@d637 1
a637 1
  else if ((res = len) != 0)
d2298 1
a2298 2
      if (res > 0)
	res = fh->sendmsg (msg, flags, res); // res == iovec tot
@


1.208
log
@	* net.cc (fdsock): Disable raising buffer sizes.  Add comment to
	explain why.
@
text
@d817 50
a866 1
    res = fh->connect (name, namelen);
d1000 13
a1012 1
    res = fh->accept (peer, len);
@


1.207
log
@white space
@
text
@d560 12
a572 1
  /* Same default buffer sizes as on Linux (instead of WinSock default 8K). */
d579 1
a579 1

@


1.206
log
@* fhandler_socket.cc: Move iptypes.h include after winsock2 since it now relies
on it.
* net.cc: Ditto.
@
text
@d674 1
a674 1
  	 ? optname
d702 1
a702 1
        {
d704 1
a704 1
	  
d735 1
a735 1
        fh->saw_reuseaddr (*(int *) optval);
d1852 2
a1853 2
   the calling application tries to connect. 
   
d1915 1
a1915 1
        *port = myport;
@


1.205
log
@	* net.cc (fdsock): Raise default SO_RCVBUF/SO_SNDBUF buffer sizes to
	the same values as on Linux.
@
text
@a19 1
#include <iphlpapi.h>
d29 1
@


1.204
log
@	* fhandler.h (class fhandler_socket): Add saw_reuseaddr status flag.
	* fhandler_socket.cc (fhandler_socket::bind): Set socket to
	SO_EXCLUSIVEADDRUSE if application didn't explicitely set SO_REUSEADDR
	socket option, on systems supporting SO_EXCLUSIVEADDRUSE.
	* net.cc (cygwin_setsockopt): Set fhandler's saw_reuseaddr status flag
	if SO_REUSEADDR socket option has been successsfully set.
	* wincap.h (wincaps::has_exclusiveaddruse): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d560 9
@


1.203
log
@	* net.cc (rresvport): Remove extern declaration.
@
text
@d725 2
@


1.202
log
@	* autoload.cc (rresvport): Remove.
	* net.cc (last_used_rrecvport): New global shared variable.
	(cygwin_rresvport): Implement rresvport without using rresvport from
	wsock32.
@
text
@a51 1
  int __stdcall rresvport (int *);
@


1.201
log
@	* net.cc (cygwin_setsockopt): Ignore errors when setting IP_TOS on
	Windows 2000 and above. Clarify the comment about IP_TOS and move
	to the place where the magic happens.
	(get_ifconf): Remove unused code.
	* wincap.h (wincaps::has_disabled_user_tos_setting): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d21 1
d1838 26
d1875 32
a1906 1
  res = rresvport (port);
@


1.200
log
@whitespace cleanup to force snapshot.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
a684 1
      /* FOR THE RECORDS:
a685 13
	 Setting IP_TOS is disabled by default since W2K, the official
	 reason being that IP_TOS setting would interfere with Windows
	 QOS settings.  As result, setsockopt returns with WinSock error
	 10022, WSAEINVAL, when running under W2K or later, instead of
	 handling this gracefully.

	 The workaround is described in KB article 248611.  Add a new
	 registry DWORD value HKLM/System/CurrentControlSet/Services/...
	 ... Tcpip/Parameters/DisableUserTOSSetting, set to 0, and reboot.

	 FIXME: Maybe we should simply fake that IP_TOS could be set
	 successfully, if DisableUserTOSSetting is not set to 0 on W2K
	 and above? */
d693 32
a724 1
	set_winsock_errno ();
a1769 5
  OSVERSIONINFO os_version_info;

  memset (&os_version_info, 0, sizeof os_version_info);
  os_version_info.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
  GetVersionEx (&os_version_info);
@


1.199
log
@Remove unneeded whitespace.
* cygtls.cc (_cygtls::set_state): Delete.
(_cygtls::reset_exception): Ditto.
(_cygtls::init_thread): Set initialized state directly here.
(_cygtls::push): Remove exception argument.  Don't treat exceptions specially.
* cygtls.h (_cygtls::push): Ditto.
(_cygtls::isinitialized): Don't treat exceptions specially.
(_cygtls::reset_exception): Delete.
(_cygtls::set_state): Ditto.
(_cygtls::handle_exceptions): Don't push ebp on the stack prior to calling
sig_send.  Just set incyg instead.
(_cygtls::interrupt_setup): Accommodate _cygtls::push argument change.
(_cygtls::interrupt_now): Ditto.
(setup_handler): Don't treat exceptions specially.
* gendef (longjmp): Always zero incyg flag.
@
text
@d684 1
a684 1
        optname = convert_ws1_ip_optname (optname);
d687 1
a687 1
         Setting IP_TOS is disabled by default since W2K, the official
d734 1
a734 1
        optname = convert_ws1_ip_optname (optname);
@


1.198
log
@	* fhandler_socket.cc (fhandler_socket::connect): Don't restrict
	WSAEINVAL -> WSAEISCONN conversion to nonblocking sockets.
	(fhandler_socket::accept): Use event driven technique to implement
	interuptible accept.
	(fhandler_socket::wait): Allow FD_ACCEPT handling.
	* net.cc (cygwin_accept): Remove workaround for allowing blocking
	accept.  That's entirely in fhandler_socket::accept now.
@
text
@d696 1
a696 1
	 
@


1.197
log
@	* fhandler.h (class fhandler_socket): Add timeout parameter to wait()
	method.
	* fhandler_socket.cc (fhandler_socket::connect): Use event driven
	technique (prepare/wait/release) to implement interuptible connect.
	(fhandler_socket::wait): Add timeout parameter.  Allow FD_CONNECT
	handling.
	* net.cc (cygwin_connect): Remove braindead workaround for allowing
	blocking connect.  That's entirely in fhandler_socket::connect now.
@
text
@d912 1
a912 13
    {
      if (!fh->is_nonblocking ())
	{
	  size_t fds_size = howmany (fd + 1, NFDBITS) * sizeof (fd_mask);
	  fd_set *read_fds = (fd_set *) alloca (fds_size);
	  memset (read_fds, 0, fds_size);
	  FD_SET (fd, read_fds);
	  res = cygwin_select (fd + 1, read_fds, NULL, NULL, NULL);
	  if (res == -1)
	    return -1;
	}
      res = fh->accept (peer, len);
    }
@


1.196
log
@	* autoload.cc: Never load wsock32.dll. Load all wsock32 function
	from ws2_32.  Rearrange symbol order accordingly.  None of the ws2_32
	functions is optional right now.
	(wsadata): Move from net.cc here.  Define NO_COPY.
	(wsock_init): Drop unused symbols ws2_32_handle and wsock32_handle.
	(load_wsock32): Remove.
	(WSACleanup): Remove.
	* fhandler_socket.cc: Drop Winsock 1 accommodations throughout.
	(fhandler_socket::readv): Accomodate new POSIX style struct msghdr.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Ditto. Handle "old" applications using
	former struct msghdr correctly.
	* net.cc: Drop Winsock 1 accommodations throughout.
	(wsadata): Move definition to autoload.cc.
	(set_socket_inheritance): Remove.
	(convert_ws1_ip_optname): New static function to convert Winsock1
	IPPROTO_IP option values into Winsock2 IPPROTO_IP option values.
	(cygwin_setsockopt): Remove wrong and incomplete cleartext printing
	of optname.  For "old" applications, convert optname from Winsock1
	to Winsock2 values before using them.  Add comment to describe the
	IP_TOS weirdness on W2K and above.
	(cygwin_getsockopt): Remove wrong and incomplete cleartext printing
	of optname.  For "old" applications, convert optname from Winsock1
	to Winsock2 values before using them.
	* select.cc (start_thread_socket): Forget about winsock2_active.
	* winsup.h (wsock32_handle): Remove declaration.
	(ws2_32_handle): Ditto.
	(netapi32_handle): Ditto.
	(wsadata): Ditto.
	(winsock2_active): Remove definition.
	* include/cygwin/socket.h: Change formatting slightly.
	(socklen_t): Move definition up in file.
	(struct msghdr): Convert to POSIX style.
	(struct cmsghdr): New type.
	(CMSG_ALIGN): New macro.
	(CMSG_LEN): Ditto.
	(CMSG_SPACE): Ditto.
	(CMSG_FIRSTHDR): Ditto.
	(CMSG_NXTHDR): Ditto.
	(CMSG_DATA): Ditto.
	(SCM_RIGHTS): Ditto.
	(struct OLD_msghdr): Define old msghdr structure for Cygwin internal
	purposes.
	(MSG_TRUNC): New macro.
	(MSG_CTRUNC): Ditto.
	(IP_OPTIONS): Redefine IPPROTO_IP option values to Winsock2 values.
	Keep Winsock1 values for Cygwin internal purposes.
	* include/cygwin/version.h: Bump API minor version.
	(CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR): Define to check for
	applications using old struct msghdr.
	(CYGWIN_VERSION_CHECK_FOR_USING_WINSOCK1_VALUES): Define to check for
	applications using old Winsock1 IPPROTO_IP values.
@
text
@d778 1
a778 50
    {
      bool was_blocking = false;
      if (!fh->is_nonblocking ())
	{
	  int nonblocking = 1;
	  fh->ioctl (FIONBIO, &nonblocking);
	  was_blocking = true;
	}
      res = fh->connect (name, namelen);
      if (was_blocking)
	{
	  if (res == -1 && get_errno () == EINPROGRESS)
	    {
	      size_t fds_size = howmany (fd + 1, NFDBITS) * sizeof (fd_mask);
	      fd_set *write_fds = (fd_set *) alloca (fds_size);
	      fd_set *except_fds = (fd_set *) alloca (fds_size);
	      memset (write_fds, 0, fds_size);
	      memset (except_fds, 0, fds_size);
	      FD_SET (fd, write_fds);
	      FD_SET (fd, except_fds);
	      res = cygwin_select (fd + 1, NULL, write_fds, except_fds, NULL);
	      if (res > 0 && FD_ISSET (fd, except_fds))
		{
		  res = -1;
		  for (;;)
		    {
		      int err;
		      int len = sizeof err;
		      cygwin_getsockopt (fd, SOL_SOCKET, SO_ERROR,
					 (void *) &err, &len);
		      if (err)
			{
			  set_errno (err);
			  break;
			}
		      low_priority_sleep (0);
		    }
		}
	      else if (res > 0)
		res = 0;
	      else
		{
		  WSASetLastError (WSAEINPROGRESS);
		  set_winsock_errno ();
		}
	    }
	  int nonblocking = 0;
	  fh->ioctl (FIONBIO, &nonblocking);
	}
    }
@


1.195
log
@* net.cc (cygwin_gethostbyname): Remove debugging.
@
text
@d32 2
a54 2
WSADATA wsadata;

a70 14
static SOCKET __stdcall
set_socket_inheritance (SOCKET sock)
{
  SOCKET osock = sock;

  if (!DuplicateHandle (hMainProc, (HANDLE) sock, hMainProc, (HANDLE *) &sock,
			0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
    system_printf ("DuplicateHandle failed %E");
  else
    debug_printf ("DuplicateHandle succeeded osock %p, sock %p", osock, sock);
  VerifyHandle ((HANDLE) sock);
  return sock;
}

d544 1
a544 3
  if (!winsock2_active)
    soc = set_socket_inheritance (soc);
  else if (wincap.has_set_handle_information ())
d548 1
a548 2
      debug_printf ("reset socket inheritance since winsock2_active %d",
		    winsock2_active);
d551 1
a551 2
    debug_printf ("not setting socket inheritance since winsock2_active %d",
		  winsock2_active);
d557 1
a557 1
  fd->uninterruptible_io (winsock2_active);
d648 21
a675 36
  const char *name = "error";

  /* For the following debug_printf */
  switch (optname)
    {
      case SO_DEBUG:
	name = "SO_DEBUG";
	break;
      case SO_ACCEPTCONN:
	name = "SO_ACCEPTCONN";
	break;
      case SO_REUSEADDR:
	name = "SO_REUSEADDR";
	break;
      case SO_KEEPALIVE:
	name = "SO_KEEPALIVE";
	break;
      case SO_DONTROUTE:
	name = "SO_DONTROUTE";
	break;
      case SO_BROADCAST:
	name = "SO_BROADCAST";
	break;
      case SO_USELOOPBACK:
	name = "SO_USELOOPBACK";
	break;
      case SO_LINGER:
	name = "SO_LINGER";
	break;
      case SO_OOBINLINE:
	name = "SO_OOBINLINE";
	break;
      case SO_ERROR:
	name = "SO_ERROR";
	break;
    }
d682 18
d710 2
a711 2
  syscall_printf ("%d = setsockopt (%d, %d, %x (%s), %p, %d)",
		  res, fd, level, optname, name, optval, optlen);
a720 38
  const char *name = "error";

  /* For the following debug_printf */
  switch (optname)
    {
      case SO_DEBUG:
	name = "SO_DEBUG";
	break;
      case SO_ACCEPTCONN:
	name = "SO_ACCEPTCONN";
	break;
      case SO_REUSEADDR:
	name = "SO_REUSEADDR";
	break;
      case SO_KEEPALIVE:
	name = "SO_KEEPALIVE";
	break;
      case SO_DONTROUTE:
	name = "SO_DONTROUTE";
	break;
      case SO_BROADCAST:
	name = "SO_BROADCAST";
	break;
      case SO_USELOOPBACK:
	name = "SO_USELOOPBACK";
	break;
      case SO_LINGER:
	name = "SO_LINGER";
	break;
      case SO_OOBINLINE:
	name = "SO_OOBINLINE";
	break;
      case SO_ERROR:
	name = "SO_ERROR";
	break;
      case SO_PEERCRED:
	name = "SO_PEERCRED";
    }
d732 3
d750 2
a751 2
  syscall_printf ("%d = getsockopt (%d, %d, %x (%s), %p, %p)",
		  res, fd, level, optname, name, optval, optlen);
@


1.194
log
@* net.cc (cygwin_gethostbyname): Remove debugging cruft.
@
text
@a971 1
{
a972 2
debug_printf ("HERE");
}
@


1.193
log
@	* net.cc (cygwin_inet_ntop): Change len argument to socklen_t to
	follow SUSv3.
	* include/arpa/inet.h (inet_ntop): Ditto.
	* include/cygwin/in.h: Include cygwin/socket.h to get socklen_t.
@
text
@a940 1
{ console_printf ("OUCH!\n");
a941 1
}
@


1.192
log
@* cygtls.h (san): New structure.
(cygtls::andreas): New element.  Replaces _myfault and _myfault_errno.
(cygtls::fault_guarded): Use andreas.
(cygtls::return_from_fault): Ditto.
(cygtls::setup_fault): Add a parameter denoting where to store old fault
handler, if any and use it to "stack" faults.
(cygtls::reset_fault): Restore fault from parameter.
(myfault::sebastian): New variable.
(myfault::~myfault): Pass sebastian to reset_fault.
(myfault::myfault): Store old fault values in sebastian.
@
text
@d2293 1
a2293 1
cygwin_inet_ntop (int family, const void *addrptr, char *strptr, size_t len)
d2305 1
a2305 1
      if (strlen (temp) >= len)
@


1.191
log
@white space
@
text
@d941 3
a943 1
    return NULL;
d974 4
a977 1
    debug_printf ("h_name %s", res);
@


1.190
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d2275 1
a2275 1
        {
d2301 1
a2301 1
        {
@


1.189
log
@	* cygwin.din (inet_pton): Export.
	(inet_ntop): Export.
	* net.cc (cygwin_inet_pton): Implement inet_pton for AF_INET for now.
	(cygwin_inet_ntop): Implement inet_ntop for AF_INET for now.
	* include/arpa/inet.h (inet_pton): Declare.
	(inet_ntop): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d137 2
a138 1
  if (check_null_str_errno (cp))
d151 2
a152 1
  if (check_null_str_errno (cp) || check_null_invalid_struct_errno (inp))
d170 2
a171 1
  if (check_null_str_errno (cp))
d542 2
a543 1
  if (check_null_str_errno (p))
d632 2
a633 3
  if ((len && __check_invalid_read_ptr_errno (buf, (unsigned) len))
      || (to && __check_invalid_read_ptr_errno (to, tolen))
      || !fh)
d654 2
a655 5
  if ((len && __check_null_invalid_struct_errno (buf, (unsigned) len))
      || (from
	  && (check_null_invalid_struct_errno (fromlen)
	      || __check_null_invalid_struct_errno (from, (unsigned) *fromlen)))
      || !fh)
d710 2
a711 1
  if ((optval && __check_invalid_read_ptr_errno (optval, optlen)) || !fh)
d775 2
a776 4
  if ((optval
       && (check_null_invalid_struct_errno (optlen)
	   || __check_null_invalid_struct_errno (optval, (unsigned) *optlen)))
      || !fh)
d824 2
a825 1
  if (__check_invalid_read_ptr_errno (name, namelen) || !fh)
d889 2
a890 2
  if (check_null_str_errno (name)
      || (proto != NULL && check_null_str_errno (proto)))
d903 2
a904 1
  if (proto != NULL && check_null_str_errno (proto))
d916 2
a917 1
  if (__check_null_invalid_struct_errno (name, len))
d939 2
a940 1
  if (check_null_str_errno (name))
d986 2
a987 1
  if (__check_invalid_read_ptr_errno (addr, len))
d1007 2
a1008 3
  if ((peer && (check_null_invalid_struct_errno (len)
		|| __check_null_invalid_struct_errno (peer, (unsigned) *len)))
      || !fh)
d1037 2
a1038 1
  if (__check_invalid_read_ptr_errno (my_addr, addrlen) || !fh)
d1056 2
a1057 3
  if (check_null_invalid_struct_errno (namelen)
      || __check_null_invalid_struct_errno (addr, (unsigned) *namelen)
      || !fh)
d1118 2
a1119 1
  if (s && check_null_str (s))
d1158 2
a1159 3
  if (check_null_invalid_struct_errno (len)
      || __check_null_invalid_struct_errno (name, (unsigned) *len)
      || !fh)
d1194 2
a1195 1
  if (__check_null_invalid_struct_errno (domain, len))
d1808 2
a1809 1
  if (check_null_invalid_struct_errno (ifc))
d1888 2
a1889 4
  if (check_null_invalid_struct_errno (ahost) ||
      check_null_empty_str_errno (*ahost) ||
      (locuser && check_null_empty_str_errno (locuser)) ||
      (remuser && check_null_str_errno (remuser)))
d1891 5
d1943 2
a1944 1
  if (check_null_invalid_struct_errno (port))
d1972 2
a1973 4
  if (check_null_invalid_struct_errno (ahost) ||
      check_null_empty_str_errno (*ahost) ||
      (locuser && check_null_empty_str_errno (locuser)) ||
      (password && check_null_str_errno (password)))
d2026 2
a2027 1
  if (__check_null_invalid_struct_errno (sb, 2 * sizeof (int)))
d2228 2
a2229 5
  if (check_null_invalid_struct_errno (msg)
      || (msg->msg_name
	  && __check_null_invalid_struct_errno (msg->msg_name,
						(unsigned) msg->msg_namelen))
      || !fh)
d2251 2
a2252 5
  if (__check_invalid_read_ptr_errno (msg, sizeof msg)
      || (msg->msg_name
	  && __check_invalid_read_ptr_errno (msg->msg_name,
					     (unsigned) msg->msg_namelen))
      || !fh)
d2292 2
a2293 1
  if (__check_null_invalid_struct_errno (strptr, len))
@


1.188
log
@white space and minor comment cleanup.
@
text
@d2262 46
@


1.187
log
@* net.cc (cygwin_getservbyname): Return (possibly NULL) return value of dup_ent
rather than assuming that tls buffer is valid.
(cygwin_getservbyport): Ditto.
(cygwin_gethostbyname): Ditto.
(cygwin_gethostbyaddr): Ditto.
@
text
@d771 1
a771 1
        name = "SO_PEERCRED";
@


1.186
log
@	* fhandler.h (fhandler_socket::secret_event): Remove.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_set_cred): New method.
	(fhandler_socket::af_local_copy): New method.
	(fhandler_socket::af_local_recv_secret): New method.
	(fhandler_socket::af_local_send_secret): New method.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::af_local_accept): New method.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::set_connect_secret): Remove.
	(fhandler_socket::get_connect_secret): Remove.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	* fhandler_socket.cc (secret_event_name): Remove.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_recv_secret): New function to receive
	AF_LOCAL connect secret over socket itself.
	(fhandler_socket::af_local_send_secret): New function to send AF_LOCAL
	connect secret over socket itself.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::af_local_connect): Take over connect side handling
	of AF_LOCAL secret and credential handshake.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::af_local_accept): New method, take over accept side
	handling of AF_LOCAL secret and credential handshake.
	(fhandler_socket::af_local_set_cred): New method, set eid credentials
	to start values.
	(fhandler_socket::af_local_copy): New method, copy secret and
	credentials to another socket.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::fixup_after_fork): Drop secret_event handling.
	(fhandler_socket::bind): Call af_local_set_secret.
	(fhandler_socket::connect): Call af_local_set_cred and af_local_connect.
	(fhandler_socket::listen): Call af_local_set_cred.
	(fhandler_socket::accept): Call af_local_copy and af_local_accept on
	accepted socket.
	(fhandler_socket::close): Don't call close_secret_event.
	(fhandler_socket::set_close_on_exec): Don't set secret_event
	inheritance.
	* net.cc (cygwin_getsockopt): Add debug output.
	(socketpair): Call af_local_set_sockpair_cred instead of
	set_socketpair_eids.
	* select.cc (set_bits): Drop AF_LOCAL special handling in case
	of except bit set.
@
text
@d893 3
a895 3
  dup_ent (servent_buf, getservbyname (name, proto), t_servent);
  syscall_printf ("%p = getservbyname (%s, %s)", _my_tls.locals.servent_buf, name, proto);
  return _my_tls.locals.servent_buf;
d906 1
a906 1
  dup_ent (servent_buf, getservbyport (port, proto), t_servent);
d908 1
a908 1
  return _my_tls.locals.servent_buf;
d967 3
a969 2
  if (dup_ent (hostent_buf, h, t_hostent))
    debug_printf ("h_name %s", _my_tls.locals.hostent_buf->h_name);
d972 1
a972 1
      debug_printf ("dup_ent failed for name %s", name);
d975 1
a975 1
  return _my_tls.locals.hostent_buf;
d986 2
a987 1
  if (dup_ent (hostent_buf, gethostbyaddr (addr, len, type), t_hostent))
d991 1
a991 1
  return _my_tls.locals.hostent_buf;
@


1.185
log
@* net.cc (cygwin_getprotobyname): Don't try to be fancy with return values.
(cygwin_getprotobynumber): Ditto.
@
text
@d793 1
d2166 1
a2166 1
	  ((fhandler_socket *) sb0)->set_socketpair_eids ();
d2177 1
a2177 1
	      ((fhandler_socket *) sb1)->set_socketpair_eids ();
@


1.184
log
@* cygtls.cc (free_local): New macro.
(_cygtls::remove): Use free_local to free known-malloced local variables.
* cygtls.h: Mark some variables as "malloced".
* net.cc (enum struct_type): Rename from is_* to t_* for clarity.
(dump_protoent): Delete.
(dup_ent): New macro.
(__dup_ent): Renamed from dup_ent.  Change arguments for convenience.  Replace
first argument with newly alloced value.  Allocate a rounded number of bytes in
an attempt to try to reuse space.  Subsume "dump_protent".
(cygwin_getprotobyname): Simplify using new dup_ent functionality.
(cygwin_getprotobynumber): Ditto.
(cygwin_getservbyname): Ditto.
(cygwin_getservbyport): Ditto.
(cygwin_gethostname): Ditto.
(cygwin_gethostbyname): Ditto.
* tlsoffsets.h: Regenerate.
* syslog.cc (openlog): Use NULL rather than 0, for consistency with the rest of
cygwin.
(pass_handler::initialize): Use unbuffered I/O in pass one.
@
text
@d541 1
a541 1
  __builtin_return (dup_ent (protoent_buf, getprotobyname (p), t_protoent));
d548 1
a548 1
  __builtin_return (dup_ent (protoent_buf, getprotobynumber (number), t_protoent));
@


1.183
log
@* net.cc (dup_ent): Revert older stupid test for null.  Don't copy name if it
is NULL.
@
text
@a116 7
static void
dump_protoent (struct protoent *p)
{
  if (p)
    debug_printf ("protoent %s %x %x", p->p_name, p->p_aliases, p->p_proto);
}

d361 1
a361 1
  is_hostent, is_protoent, is_servent
d375 1
d381 1
a381 1
dup_ent (void *old, void *src0, struct_type type)
d383 5
a387 1
  if (old)
d389 2
a390 3
      debug_printf ("freeing old %sent structure \"%s\" %p\n", entnames[type],
		    ((unionent *) old)->name, old);
      free (old);
a392 4
  if (!src0)
    return NULL;

  unionent *src = (unionent *) src0;
d399 1
a399 1
    case is_protoent:
d402 1
a402 1
    case is_servent:
d405 1
a405 1
    case is_hostent:
d439 1
a439 1
  if (type == is_servent)
d452 1
a452 1
  else if (type == is_hostent)
d467 5
a471 2
  /* Allocate the storage needed */
  unionent *dst = (unionent *) calloc (1, sz);
d476 1
d504 4
a507 2
      /* Do servent/hostent specific processing. */
      if (type == is_servent)
d515 1
a515 1
      else if (type == is_hostent)
d541 1
a541 8
  _my_tls.locals.protoent_buf =
    (protoent *) dup_ent (_my_tls.locals.protoent_buf, getprotobyname (p),
			  is_protoent);
  if (!_my_tls.locals.protoent_buf)
    set_winsock_errno ();

  dump_protoent (_my_tls.locals.protoent_buf);
  return _my_tls.locals.protoent_buf;
d548 1
a548 8
  _my_tls.locals.protoent_buf =
    (protoent *) dup_ent (_my_tls.locals.protoent_buf,
			  getprotobynumber (number), is_protoent);
  if (!_my_tls.locals.protoent_buf)
    set_winsock_errno ();

  dump_protoent (_my_tls.locals.protoent_buf);
  return _my_tls.locals.protoent_buf;
d892 2
a893 6
  _my_tls.locals.servent_buf = (servent *) dup_ent (_my_tls.locals.servent_buf, getservbyname (name, proto),
				     is_servent);
  if (!_my_tls.locals.servent_buf)
    set_winsock_errno ();

  syscall_printf ("%x = getservbyname (%s, %s)", _my_tls.locals.servent_buf, name, proto);
d905 2
a906 6
  _my_tls.locals.servent_buf = (servent *) dup_ent (_my_tls.locals.servent_buf, getservbyport (port, proto),
				     is_servent);
  if (!_my_tls.locals.servent_buf)
    set_winsock_errno ();

  syscall_printf ("%x = getservbyport (%d, %s)", _my_tls.locals.servent_buf, port, proto);
d935 4
d946 4
a949 6
  sig_dispatch_pending ();
  if (check_null_str_errno (name))
    return NULL;

  if (sscanf (name, "%u.%u.%u.%u%c", &a, &b, &c, &d, &dummy) == 4
      && a < 256 && b < 256 && c < 256 && d < 256)
d965 3
a968 5
    h = gethostbyname (name);

  _my_tls.locals.hostent_buf = (hostent *) dup_ent (_my_tls.locals.hostent_buf, h, is_hostent);

  if (!_my_tls.locals.hostent_buf)
d970 1
a970 2
      debug_printf ("name %s", name);
      set_winsock_errno ();
a972 4
  else
    {
      debug_printf ("h_name %s", _my_tls.locals.hostent_buf->h_name);
    }
d984 2
a985 8
  _my_tls.locals.hostent_buf = (hostent *) dup_ent (_my_tls.locals.hostent_buf,
				     gethostbyaddr (addr, len, type),
				     is_hostent);
  if (!_my_tls.locals.hostent_buf)
    {
      set_winsock_errno ();
      set_host_errno ();
    }
d987 1
a987 3
    {
      debug_printf ("h_name %s", _my_tls.locals.hostent_buf->h_name);
    }
@


1.182
log
@* net.cc (dup_ent): Revert previous stupid change.
@
text
@d400 1
a400 2
  debug_printf ("duping %sent \"%s\", %p", entnames[type],
		src ? src->name : "<null!>", src);
a483 2
      /* Copy the name field to dst, using space just beyond the end of
	 the dst structure. */
d485 7
a491 2
      strcpy (dst->name = dp, src->name);
      dp += namelen;
@


1.181
log
@* net.cc (dup_ent): Avoid dereferencing a null pointer in a debug_printf.
@
text
@d392 1
a392 1
		    old ? ((unionent *) old)->name : "<null!>", old);
@


1.180
log
@	* fhandler_clipboard.cc (fhandler_dev_clipboard::write): Never set
	errno to 0.
	(fhandler_dev_clipboard::read): Ditto.
	* fhandler_windows.cc (fhandler_windows::read): Ditto.
	* scandir.cc (scandir): Ditto.
	* syscalls.cc (_fstat64_r): Ditto.
	(_fstat_r): Ditto.
	(_stat64_r): Ditto.
	(_stat_r): Ditto.

	* mmap.cc (mmap64): Fix /dev/zero mapping.
@
text
@d392 1
a392 1
		    ((unionent *) old)->name, old);
@


1.179
log
@	* fhandler.h (class fhandler_socket): Declare new method
	set_socketpair_eids.
	* fhandler_socket.cc (fhandler_socket::set_socketpair_eids): New method.
	(fhandler_socket::dup): Duplicate sec_pipe if necessary.
	(fhandler_socket::listen): Only create sec_pipe if named pipes are
	available. Initialized sec_peer_pid to 0 as on Linux.
	(fhandler_socket::connect): Only run eid credential transaction if
	named pipes are available.  Fake otherwise. Initialized sec_peer_pid
	to 0 as on Linux.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::close): Move closing sec_pipe handle from here...
	(fhandler_socket::~fhandler_socket): ... to here.
	* net.cc (socketpair): Set eid credentials by calling
	fhandler_socket::set_socketpair_eids() on both socket ends.
	* wincap.h (wincaps::has_named_pipes): New element.
	* wincap.cc: Implement above element throughout.
@
text
@a948 1
  h_errno = 0;
a997 1
      h_errno = 0;
a1020 1
      h_errno = 0;
@


1.178
log
@	* cygwin.din (getpeereid): Export.
	* fhandler.h (class fhandler_socket): Add pipe and id members to
	exchange eid credentials for AF_LOCAL sockets.
	(eid_pipe_name): Declare new method.
	(getpeereid): Ditto.
	* fhandler_socket.cc (fhandler_socket::eid_pipe_name): New method.
	(fhandler_socket::fhandler_socket): Initialize sec_pipe.
	(fhandler_socket::connect): Exchange eid credentials with accepting
	socket process.
	(fhandler_socket::listen): Prepare eid credential transaction.
	(fhandler_socket::accept): Exchange eid credentials with connecting
	socket process.
	(fhandler_socket::close): Close eid credentials pipe if open.
	(fhandler_socket::getpeereid): New method.
	* net.cc (cygwin_getsockopt): Add SO_PEERCRED handling.
	(getpeereid): New function.
	* include/asm/socket.h (SO_PEERCRED): Define.
	* include/cygwin/socket.h (struct ucred): Define new type.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d2201 2
d2212 2
@


1.177
log
@copyright
@
text
@d783 2
d792 5
d818 10
@


1.176
log
@* net.cc (cygwin_gethostbyname): Be more picky about what's a numeric address
string, and use tls in that case too.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.175
log
@	* fhandler_socket.cc (fhandler_socket::dup): Decrement dtable's
	need_fixup_before counter on successful dup.
	* net.cc (cygwin_getpeername): Add file descriptor to debug output.
@
text
@d939 6
a944 5
  static unsigned char tmp_addr[4];
  static struct hostent tmp;
  static char *tmp_aliases[1];
  static char *tmp_addr_list[2];
  static int a, b, c, d;
d950 2
a951 1
  if (sscanf (name, "%d.%d.%d.%d", &a, &b, &c, &d) == 4)
d965 1
a965 1
      return &tmp;
d967 4
a971 2
  _my_tls.locals.hostent_buf = (hostent *) dup_ent (_my_tls.locals.hostent_buf, gethostbyname (name),
				     is_hostent);
@


1.174
log
@* net.cc (cygwin_gethostbyname): Show failing host name on error.
@
text
@d1173 1
a1173 1
  syscall_printf ("%d = getpeername %d", res, (fh ? fh->get_socket () : -1));
@


1.173
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d970 1
@


1.172
log
@	Revert code reversion from 2004-04-03.  So, revert to async I/O again.
	* fhandler.h (status): Add "closed" flag.
	(prepare): New method declaration.
	(wait): Ditto.
	(release): Ditto.
	* fhandler_socket.cc: Don't include wsock_event.h.
	(fhandler_socket::prepare): New method, moved from wsock_event.
	(fhandler_socket::wait): Ditto.
	(fhandler_socket::release): New method.
	(fhandler_socket::recvfrom): Simplify loop.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc: Don't include wsock_event.h.
	(wsock_event::prepare): Remove.
	(wsock_event::wait): Ditto.
	* wsock_event.h: Remove.
@
text
@d1956 1
a1956 1
        res = res_fd;
@


1.171
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@a37 1
#include "wsock_event.h"
a50 55

LPWSAOVERLAPPED
wsock_event::prepare ()
{
  LPWSAOVERLAPPED ret = NULL;

  SetLastError (0);
  if ((event = WSACreateEvent ()) != WSA_INVALID_EVENT)
    {
      memset (&ovr, 0, sizeof ovr);
      ovr.hEvent = event;
      ret = &ovr;
    }
  else if (GetLastError () == ERROR_PROC_NOT_FOUND) /* winsock2 not available */
    WSASetLastError (0);

  debug_printf ("%d = wsock_event::prepare ()", ret);
  return ret;
}

int
wsock_event::wait (int socket, LPDWORD flags)
{
  int ret = SOCKET_ERROR;
  WSAEVENT ev[2] = { event, signal_arrived };
  DWORD len;

  switch (WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE, FALSE))
    {
      case WSA_WAIT_EVENT_0:
	if (WSAGetOverlappedResult (socket, &ovr, &len, FALSE, flags))
	  ret = (int) len;
	break;
      case WSA_WAIT_EVENT_0 + 1:
	if (!CancelIo ((HANDLE) socket))
	  {
	    debug_printf ("CancelIo() %E, fallback to blocking io");
	    WSAGetOverlappedResult (socket, &ovr, &len, TRUE, flags);
	  }
	else if (WSAGetOverlappedResult (socket, &ovr, &len, FALSE, flags)
	         && len > 0)
	  ret = (int) len;
	else
	  WSASetLastError (WSAEINTR);
	break;
      case WSA_WAIT_FAILED:
	break;
      default:			/* Should be impossible. *LOL* */
	WSASetLastError (WSAEFAULT);
	break;
    }
  WSACloseEvent (event);
  event = NULL;
  return ret;
}
@


1.170
log
@	* fhandler.cc (fhandler_base::write): Use bool parameter in calls to
	set_did_lseek.
	(fhandler_base::fhandler_base): Accomodate new status and open_status
	constructor.
	* fhandler.h: Remove status bit enumerator.
	(FHDEVN): Remove.
	(FHISSETF): Remove.
	(FHSETF): Remove.
	(FHCLEARF): Remove.
	(FHCONDSETF): Remove.
	(FHSTATOFF): Remove.
	(UNCONNECTED, CONNECT_PENDING, CONNECTED): Substitute by enum
	connect_state.
	(fhandler_base::status): Define as bitfield struct type status_flags.
	Remove unused flags entirely.  Accomodate all status access methods.
	(open_status): Define as bitfield struct type status_flags.
	(fhandler_socket): Move socket related status bits to here.  Redefine
	had_connect_or_listen to be part of these status bits.  Accomodate
	related access methods.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use pc.issymlink
	instead of dropped method get_symlink_p.
	(fhandler_base::open_fs): Remove setting dropped status flags.
	* fhandler_socket.cc: Use values from enum connect_state throughout.
	(fhandler_socket::fhandler_socket): Initialize status bits.
	* fhandler_virtual.cc (fhandler_virtual::open): Remove setting dropped
	status flags.
	* net.cc: Use values from enum connect_state throughout.
	* select.cc: Ditto.
	* shared_info.h: Protect struct console_state using _FHANDLER_H_
	instead of FHDEVN.
@
text
@d639 1
a639 1
  fd->set_r_no_interrupt (winsock2_active);
d1963 1
a1963 1
	  ((fhandler_socket *) res_fd)->set_connect_state (connected);
d1980 1
a1980 1
	      ((fhandler_socket *) fd2p)->set_connect_state (connected);
d2043 1
a2043 1
	  ((fhandler_socket *) res_fd)->set_connect_state (connected);
d2059 1
a2059 1
	      ((fhandler_socket *) fd2p)->set_connect_state (connected);
d2233 1
a2233 1
	((fhandler_socket *) sb0)->set_connect_state (connected);
d2242 1
a2242 1
	    ((fhandler_socket *) sb1)->set_connect_state (connected);
@


1.169
log
@	* fhandler.h (class fhandler_socket): Remove has_been_closed member.
	* fhandler_socket.cc (fhandler_socket::recvfrom): Revert to
	overlapped I/O.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Ditto.
	(wsock_event::wait): Ditto.  Evaluate overlapped result also after
	calling CancelIo (thanks to Patrick Samson <p_samson@@yahoo.com>).
	(wsock_event::release): Remove.
	* wsock_event.h: Revert to overlapped I/O.
@
text
@d1963 1
a1963 1
	  ((fhandler_socket *) res_fd)->set_connect_state (CONNECTED);
d1980 1
a1980 1
	      ((fhandler_socket *) fd2p)->set_connect_state (CONNECTED);
d2043 1
a2043 1
	  ((fhandler_socket *) res_fd)->set_connect_state (CONNECTED);
d2059 1
a2059 1
	      ((fhandler_socket *) fd2p)->set_connect_state (CONNECTED);
d2233 1
a2233 1
	((fhandler_socket *) sb0)->set_connect_state (CONNECTED);
d2242 1
a2242 1
	    ((fhandler_socket *) sb1)->set_connect_state (CONNECTED);
@


1.168
log
@	* net.cc (wsock_event::release): Use NULL handle in call to
	WSAEventSelect to resolve KB 168349.
@
text
@d53 2
a54 2
bool
wsock_event::prepare (int sock, long event_mask)
d56 4
a59 4
  WSASetLastError (0);
  if ((event = WSACreateEvent ()) == WSA_INVALID_EVENT)
    debug_printf ("WSACreateEvent: %E");
  else if (WSAEventSelect (sock, event, event_mask) == SOCKET_ERROR)
d61 3
a63 3
      debug_printf ("WSAEventSelect: %E");
      WSACloseEvent (event);
      event = WSA_INVALID_EVENT;
d65 5
a69 1
  return event != WSA_INVALID_EVENT;
d73 1
a73 1
wsock_event::wait (int sock, int &closed)
a75 1
  int wsa_err = 0;
d77 2
d82 5
a86 2
        WSANETWORKEVENTS evts;
	if (!WSAEnumNetworkEvents (sock, event, &evts))
d88 2
a89 27
	    if (evts.lNetworkEvents & FD_READ)
	      {
		if (evts.iErrorCode[FD_READ_BIT])
		  wsa_err = evts.iErrorCode[FD_READ_BIT];
		else
		  ret = 0;
	      }
	    else if (evts.lNetworkEvents & FD_WRITE)
	      {
		if (evts.iErrorCode[FD_WRITE_BIT])
		  wsa_err = evts.iErrorCode[FD_WRITE_BIT];
		else
		  ret = 0;
	      }
	    if (evts.lNetworkEvents & FD_CLOSE)
	      {
		closed = 1;
		if (!wsa_err)
		  {
		    if (evts.iErrorCode[FD_CLOSE_BIT])
		      wsa_err = evts.iErrorCode[FD_CLOSE_BIT];
		    else
		      ret = 0;
		  }
	      }
	    if (wsa_err)
	      WSASetLastError (wsa_err);
d91 5
d97 1
a97 2
      case WSA_WAIT_EVENT_0 + 1:
        WSASetLastError (WSAEINTR);
d99 1
a99 1
      default:
d101 1
d103 2
a105 14
}

void
wsock_event::release (int sock)
{
  int last_err = WSAGetLastError ();
  /* KB 168349: NT4 fails if the event parameter is not NULL. */
  WSAEventSelect (sock, NULL, 0);
  WSACloseEvent (event);
  unsigned long non_block = 0;
  if (ioctlsocket (sock, FIONBIO, &non_block))
    debug_printf ("return to blocking failed: %d", WSAGetLastError ());
  else
    WSASetLastError (last_err);
@


1.167
log
@	* net.cc (wsock_event::wait): Make wsa_err an int.  Don't set
	ret to 0 if any error has happened.
@
text
@d122 2
a123 1
  WSAEventSelect (sock, event, 0);
@


1.166
log
@	* fhandler_socket.cc (fhandler_socket::sendto): Drop out of loop if
	has_been_closed gets set.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::wait): Don't initialize evts.  Don't try to
	evaluate network events if WSAEnumNetworkEvents fails.
	(wsock_event::release): Save last WSA error and set it again unless
	resetting to blocking socket fails.
	* wsock_event.h (class wsock_event): Remove destructor.
@
text
@d72 1
a72 1
  DWORD wsa_err = 0;
d97 7
a103 4
		if (!wsa_err && evts.iErrorCode[FD_CLOSE_BIT])
		  wsa_err = evts.iErrorCode[FD_CLOSE_BIT];
		else
		  ret = 0;
@


1.165
log
@	* fhandler_tape.cc (mtinfo_drive::get_pos): Only set partition if
	GetTapePosition returned a non-zero partition number.
	(mtinfo_drive::create_partitions): Reinitialize to partition 0.
	Support TAPE_DRIVE_INITIATOR and TAPE_DRIVE_FIXED partitioning.
	(mtinfo_drive::set_partition): Initialize new partition.
	(mtinfo_drive::status): Readd accidentally dropped setting of mt_resid.

	* net.cc (wsock_event::prepare): Always print debug output in case
	of error.
@
text
@d78 1
a78 3
	memset (&evts, 0, sizeof evts);
	WSAEnumNetworkEvents (sock, event, &evts);
	if (evts.lNetworkEvents & FD_READ)
d80 24
a103 4
	    if (evts.iErrorCode[FD_READ_BIT])
	      wsa_err = evts.iErrorCode[FD_READ_BIT];
	    else
	      ret = 0;
a104 17
	else if (evts.lNetworkEvents & FD_WRITE)
	  {
	    if (evts.iErrorCode[FD_WRITE_BIT])
	      wsa_err = evts.iErrorCode[FD_WRITE_BIT];
	    else
	      ret = 0;
	  }
	if (evts.lNetworkEvents & FD_CLOSE)
	  {
	    closed = 1;
	    if (!wsa_err && evts.iErrorCode[FD_CLOSE_BIT])
	      wsa_err = evts.iErrorCode[FD_CLOSE_BIT];
	    else
	      ret = 0;
	  }
	if (wsa_err)
	  WSASetLastError (wsa_err);
d118 1
d122 4
a125 1
  ioctlsocket (sock, FIONBIO, &non_block);
@


1.164
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Initialize res to
	SOCKET_ERROR.  Use SOCKET_ERROR instead of -1 throughout.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Call WSASetLastError instead of
	SetLastError.
	(wsock_event::wait): Use SOCKET_ERROR instead of -1.
@
text
@d57 3
a59 2
  if ((event = WSACreateEvent ()) != WSA_INVALID_EVENT
      && WSAEventSelect (sock, event, event_mask) == SOCKET_ERROR)
@


1.163
log
@	* fhandler.h (class fhandler_socket): Add has_been_closed member.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	has_been_closed to 0.
	(fhandler_socket::recvfrom): Use new asynchronous I/O driven
	wsock_event methods.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Reimplement using asynchronous I/O.
	(wsock_event::wait): Ditto.
	(wsock_event::release): New method.
	* wsock_event.h (class wsock_event): Remove ovr member.  Accomodate
	new implementation of prepare and wait methods.  Add release method.
@
text
@d56 1
a56 1
  SetLastError (0);
d70 1
a70 1
  int ret = -1;
@


1.162
log
@	* net.cc (wsock_event::wait): Change scope of local "len" variable.
@
text
@d53 2
a54 2
LPWSAOVERLAPPED
wsock_event::prepare ()
a55 2
  LPWSAOVERLAPPED ret = NULL;

d57 2
a58 1
  if ((event = WSACreateEvent ()) != WSA_INVALID_EVENT)
d60 3
a62 3
      memset (&ovr, 0, sizeof ovr);
      ovr.hEvent = event;
      ret = &ovr;
d64 1
a64 5
  else if (GetLastError () == ERROR_PROC_NOT_FOUND) /* winsock2 not available */
    WSASetLastError (0);

  debug_printf ("%d = wsock_event::prepare ()", ret);
  return ret;
d68 1
a68 1
wsock_event::wait (int socket, LPDWORD flags)
d71 1
a72 2
  DWORD len;

d76 18
a93 5
	if (WSAGetOverlappedResult (socket, &ovr, &len, FALSE, flags))
	  ret = (int) len;
	break;
      case WSA_WAIT_EVENT_0 + 1:
	if (!CancelIo ((HANDLE) socket))
d95 5
a99 2
	    debug_printf ("CancelIo() %E, fallback to blocking io");
	    WSAGetOverlappedResult (socket, &ovr, &len, TRUE, flags);
d101 2
a102 2
	else
	  WSASetLastError (WSAEINTR);
d104 2
a105 1
      case WSA_WAIT_FAILED:
d107 1
a107 1
      default:			/* Should be impossible. *LOL* */
a108 1
	break;
d110 7
d118 2
a119 2
  event = NULL;
  return ret;
@


1.161
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d77 1
a81 1
	DWORD len;
@


1.160
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.159
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d133 1
@


1.159.6.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a132 1
  VerifyHandle ((HANDLE) sock);
@


1.158
log
@	Substitute 0x7fffffff and 0xffffffff by INT32_MAX and UINT32_MAX
	throughout, except in assembler code.
@
text
@d39 1
a178 6
#ifdef _MT_SAFE
#define ntoa_buf  _reent_winsup ()->_ntoa_buf
#else
  static char *ntoa_buf = NULL;
#endif

d181 1
a181 1
  if (ntoa_buf)
d183 2
a184 2
      free (ntoa_buf);
      ntoa_buf = NULL;
d187 2
a188 2
    ntoa_buf = strdup (res);
  return ntoa_buf;
a584 6
#ifdef _MT_SAFE
#define protoent_buf  _reent_winsup ()->_protoent_buf
#else
static struct protoent *protoent_buf = NULL;
#endif

d591 4
a594 3
  protoent_buf = (protoent *) dup_ent (protoent_buf, getprotobyname (p),
				       is_protoent);
  if (!protoent_buf)
d597 2
a598 2
  dump_protoent (protoent_buf);
  return protoent_buf;
d605 4
a608 3
  protoent_buf = (protoent *) dup_ent (protoent_buf, getprotobynumber (number),
				       is_protoent);
  if (!protoent_buf)
d611 2
a612 2
  dump_protoent (protoent_buf);
  return protoent_buf;
a929 6
#ifdef _MT_SAFE
#define servent_buf  _reent_winsup ()->_servent_buf
#else
static struct servent *servent_buf = NULL;
#endif

d939 1
a939 1
  servent_buf = (servent *) dup_ent (servent_buf, getservbyname (name, proto),
d941 1
a941 1
  if (!servent_buf)
d944 2
a945 2
  syscall_printf ("%x = getservbyname (%s, %s)", servent_buf, name, proto);
  return servent_buf;
d956 1
a956 1
  servent_buf = (servent *) dup_ent (servent_buf, getservbyport (port, proto),
d958 1
a958 1
  if (!servent_buf)
d961 2
a962 2
  syscall_printf ("%x = getservbyport (%d, %s)", servent_buf, port, proto);
  return servent_buf;
a986 6
#ifdef _MT_SAFE
#define hostent_buf  _reent_winsup ()->_hostent_buf
#else
static struct hostent *hostent_buf = NULL;
#endif

d1018 1
a1018 1
  hostent_buf = (hostent *) dup_ent (hostent_buf, gethostbyname (name),
d1020 1
a1020 1
  if (!hostent_buf)
d1027 1
a1027 1
      debug_printf ("h_name %s", hostent_buf->h_name);
d1030 1
a1030 1
  return hostent_buf;
d1041 1
a1041 1
  hostent_buf = (hostent *) dup_ent (hostent_buf,
d1044 1
a1044 1
  if (!hostent_buf)
d1051 1
a1051 1
      debug_printf ("h_name %s", hostent_buf->h_name);
d1054 1
a1054 1
  return hostent_buf;
@


1.157
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d509 1
a509 1
	  if (!IsBadStringPtr (src->s_proto, 0x7fffffff))
d511 1
a511 1
	  else if (!IsBadStringPtr (((pservent *) src)->s_proto, 0x7fffffff))
@


1.156
log
@* net.cc (dup_ent): Use IsBadStringPtr for alignment checks.  Don't use a known
bad pointer.
@
text
@a697 1
  sigframe thisframe (mainthread);
a720 1
  sigframe thisframe (mainthread);
a876 1
  sigframe thisframe (mainthread);
a949 1
  sigframe thisframe (mainthread);
a967 1
  sigframe thisframe (mainthread);
a983 1
  sigframe thisframe (mainthread);
a1018 1
  sigframe thisframe (mainthread);
a1058 1
  sigframe thisframe (mainthread);
a1083 1
  sigframe thisframe (mainthread);
a1115 1
  sigframe thisframe (mainthread);
a1132 1
  sigframe thisframe (mainthread);
a1152 1
  sigframe thisframe (mainthread);
a1169 1
  sigframe thisframe (mainthread);
a1234 1
  sigframe thisframe (mainthread);
a1274 1
  sigframe thisframe (mainthread);
a1887 1
  sigframe thisframe (mainthread);
a1965 1
  sigframe thisframe (mainthread);
a2017 1
  sigframe thisframe (mainthread);
a2045 1
  sigframe thisframe (mainthread);
a2102 1
  sigframe thisframe (mainthread);
a2296 1
  sigframe thisframe (mainthread);
a2322 1
  sigframe thisframe (mainthread);
@


1.155
log
@	* net.cc (dup_ent): Move Win 95 misalignment recogition before
	trying to evaluate string length.
@
text
@d509 3
a511 2
	  if (IsBadReadPtr (src->s_proto, sizeof (src->s_proto))
	      && !IsBadReadPtr (((pservent *) src)->s_proto, sizeof (src->s_proto)))
d513 1
a513 2
	  else
	    s_proto = src->s_proto;
a514 1
      sz += (protolen = strlen_round (s_proto));
@


1.154
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d502 1
d504 13
a516 1
    sz += (protolen = strlen_round (src->s_proto));
d565 1
a565 1
	  if (src->s_proto)
a566 8
	      char *s_proto;
	      /* Windows 95 idiocy.  Structure is misaligned on Windows 95.
		 Kludge around this by trying a different pointer alignment.  */
	      if (IsBadReadPtr (src->s_proto, sizeof (src->s_proto))
		  && !IsBadReadPtr (((pservent *) src)->s_proto, sizeof (src->s_proto)))
		s_proto = ((pservent *) src)->s_proto;
	      else
		s_proto = src->s_proto;
@


1.153
log
@* net.cc (dup_ent): Restore check for NULL input.
@
text
@d31 1
a32 1
#include "path.h"
d620 2
a621 2
fhandler_socket *
fdsock (int &fd, const char *name, SOCKET soc)
d635 9
a643 10
  fhandler_socket *fh = (fhandler_socket *)
	cygheap->fdtab.build_fhandler (fd, FH_SOCKET, name, NULL,
				       tolower (name[5]) - 'a');
  if (!fh)
    return NULL;
  fh->set_io_handle ((HANDLE) soc);
  fh->set_flags (O_RDWR | O_BINARY);
  fh->set_r_no_interrupt (winsock2_active);
  debug_printf ("fd %d, name '%s', soc %p", fd, name, soc);
  return fh;
a651 1
  fhandler_socket *fh = NULL;
d663 1
a663 1
  const char *name;
d666 1
a666 1
    name = (type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp");
d668 1
a668 1
    name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");
d672 3
a674 3
    if (fd >= 0)
      fh = fdsock (fd, name, soc);
    if (fh)
d676 2
a677 2
	fh->set_addr_family (af);
	fh->set_socket_type (type);
a679 2
    else
	closesocket (soc);
a1988 1
      fhandler_socket *fh = NULL;
d1991 1
a1991 3
      if (res_fd >= 0)
	fh = fdsock (res_fd, "/dev/tcp", res);
      if (fh)
d1993 1
a1993 1
	  fh->set_connect_state (CONNECTED);
d2005 1
d2007 1
a2007 4
	  fh = NULL;
	  if (newfd >= 0)
	    fh = fdsock (newfd, "/dev/tcp", fd2s);
	  if (fh)
d2010 1
a2010 1
	      fh->set_connect_state (CONNECTED);
a2039 1
      fhandler_socket *fh = NULL;
d2042 2
a2043 4
      if (res_fd >= 0)
	fh = fdsock (res_fd, "/dev/tcp", res);
      if (fh)
	res = res_fd;
a2070 1
      fhandler_socket *fh = NULL;
d2073 1
a2073 3
      if (res_fd >= 0)
	fh = fdsock (res_fd, "/dev/tcp", res);
      if (fh)
d2075 1
a2075 1
	  fh->set_connect_state (CONNECTED);
d2087 1
d2089 1
a2089 4
	  fh = NULL;
	  if (newfd >= 0)
	    fh = fdsock (newfd, "/dev/tcp", fd2s);
	  if (fh)
d2091 1
a2091 1
	      fh->set_connect_state (CONNECTED);
a2252 1
    fhandler_socket *fh = NULL;
d2254 1
a2254 1
    const char *name;
d2257 1
a2257 1
      name = (type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp");
d2259 1
a2259 1
      name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");
d2261 1
a2261 3
    if (sb0 >= 0)
      fh = fdsock (sb0, name, insock);
    if (fh)
d2263 4
a2266 4
	fh->set_sun_path ("");
	fh->set_addr_family (family);
	fh->set_socket_type (type);
	fh->set_connect_state (CONNECTED);
d2270 1
a2270 4
	fh = NULL;
	if (sb1 >= 0)
	  fh = fdsock (sb1, name, outsock);
	if (fh)
d2272 4
a2275 4
	    fh->set_sun_path ("");
	    fh->set_addr_family (family);
	    fh->set_socket_type (type);
	    fh->set_connect_state (CONNECTED);
@


1.152
log
@* net.cc (dup_ent): Make debugging output consistent.
@
text
@d452 3
@


1.151
log
@Use dup_ent rather than specific dup_*_ptr functions throughout.
* (gen_ent): Delete.
(dup_ent): Subsume gen_ent functionality.
(dup_host_ptr): Delete.
(dup_proto_ptr): Ditto.
(dup_servent_ptr): Ditto.
* net.cc (gen_ent): Invert sense of null check so that debug output makes
sense.
@
text
@d447 1
a447 1
      debug_printf ("freeing old %sent structure(%s) %p\n", entnames[type],
@


1.150
log
@* net.cc (free_char_list): Delete.
(dup_addr_list): Delete.
(dup_char_list): Delete.
(free_hostent_ptr): Delete.
(free_protoent_ptr): Delete.
(free_servent_ptr): Delete.
(DWORD_round): New function.
(strlen_round): New function.  Returns strlen rounded up to word size.
(dup_ent): New, generic function to duplicate a {host,proto,serv}ent structure.
(gen_ent): New macro.  Generates a generic dup_{host,proto,serv}ent_ptr
function.
(cygwin_getservbyname): Remove call to free_servent_ptr, pass servent_buf to
dup_servent_ptr.
(cygwin_getservbyport): Ditto.
(cygwin_gethostbyname): Ditto for hostent.
(cygwin_gethostbyaddr): Ditto.
(cygwin_getprotobyname): Ditto for protoent.
(cygwin_getprotobynumber): Ditto.
@
text
@a398 5
enum struct_type
{
  is_protoent, is_servent, is_hostent
};

d422 7
d443 1
a443 1
dup_ent (void *src0, struct_type type)
d445 7
d453 2
d579 1
a582 20
/* Generic macro to build a dup_{host,proto,serv}ent_ptr function.
   The *ent buffers are allocated by dup_ent as contiguous storage.
   Frees any previously exiting `old' storage, as well.  */
#define gen_ent(x, p)								\
static x *									\
dup_##x##_ptr (x *old, x *src)							\
{										\
  if (old)									\
    {										\
      debug_printf ("freeing %s", old->p##_name);				\
      free (old);								\
    }										\
  debug_printf ("%s", src ? "<null!>" : src->p##_name);				\
  x *dst = (x *) dup_ent (src, is_##x);						\
  debug_printf ("copied %s", dst ? "<null!>" : dst->p##_name);			\
  return dst;									\
}										\

gen_ent (protoent, p)

d595 2
a596 1
  protoent_buf = dup_protoent_ptr (protoent_buf, getprotobyname (p));
d608 2
a609 1
  protoent_buf = dup_protoent_ptr (protoent_buf, getprotobynumber (number));
a938 2
gen_ent (servent, s)

d955 2
a956 1
  servent_buf = dup_servent_ptr (servent_buf, getservbyname (name, proto));
d973 2
a974 1
  servent_buf = dup_servent_ptr (servent_buf, getservbyport (port, proto));
a1004 2
gen_ent (hostent, h)

d1043 2
a1044 1
  hostent_buf = dup_hostent_ptr (hostent_buf, gethostbyname (name));
d1067 3
a1069 1
  hostent_buf = dup_hostent_ptr (hostent_buf, gethostbyaddr (addr, len, type));
@


1.149
log
@Throughout, eliminate argument to sig_dispatch_pending.
* exceptions.cc (setup_handler): Move non-interruptible condition handling
(back) to wait_sig (as suggested by Pierre Humblet).
(set_process_mask): Don't worry about calling sig_dispatch_pending from
sigthread since it is detected in the function anyway.
(sig_handle): Eliminate thisproc arg.  Don't call sig_dispatch_pending on
SIGCONT since that should happen automatically.
* sigproc.cc (sig_dispatch_pending): Eliminate justwake argument.  Just return
when called from sigthread.
(wait_sig): Change some variables to bool.  Change inner while to an if.  Move
uninterruptible signal handling here.
(sigproc_terminate): Don't call sig_dispatch_pending.  Just increment semaphore
on exit.
* speclib: Use slightly different (but still flawed) method for determining
symbols to extract from libraries.
@
text
@d28 1
d385 8
a392 2
static void
free_char_list (char **clist)
d394 3
a396 6
  if (clist)
    {
      for (char **cl = clist; *cl; ++cl)
	free (*cl);
      free (clist);
    }
d399 1
a399 2
static char **
dup_char_list (char **src)
d401 2
a402 2
  char **dst;
  int cnt = 0;
d404 22
a425 9
  for (char **cl = src; *cl; ++cl)
    ++cnt;
  if (!(dst = (char **) calloc (cnt + 1, sizeof *dst)))
    return NULL;
  while (cnt-- > 0)
    if (!(dst[cnt] = strdup (src[cnt])))
      return NULL;
  return dst;
}
d427 8
a434 1
#define free_addr_list(addr_list)	free_char_list (addr_list)
d436 6
a441 2
static char **
dup_addr_list (char **src, unsigned int size)
d443 1
a443 2
  char **dst;
  int cnt = 0;
d445 3
a447 5
  for (char **cl = src; *cl; ++cl)
    ++cnt;
  if (!(dst = (char **) calloc (cnt + 1, sizeof *dst)))
    return NULL;
  while (cnt-- > 0)
d449 12
a460 3
      if (!(dst[cnt] = (char *) malloc (size)))
	return NULL;
      memcpy (dst[cnt], src[cnt], size);
a461 2
  return dst;
}
d463 10
a472 4
static void
free_protoent_ptr (struct protoent *&p)
{
  if (p)
d474 3
a476 1
      debug_printf ("protoent: %s", p->p_name);
d478 5
a482 5
      if (p->p_name)
	free (p->p_name);
      free_char_list (p->p_aliases);
      free ((void *) p);
      p = NULL;
a483 1
}
d485 19
a503 5
static struct protoent *
dup_protoent_ptr (struct protoent *src)
{
  if (!src)
    return NULL;
d505 2
a506 1
  struct protoent *dst = (struct protoent *) calloc (1, sizeof *dst);
d508 26
a533 2
  if (!dst)
    return NULL;
d535 35
a569 7
  debug_printf ("protoent: %s", src->p_name);

  dst->p_proto = src->p_proto;
  if (src->p_name && !(dst->p_name = strdup (src->p_name)))
    goto out;
  if (src->p_aliases && !(dst->p_aliases = dup_char_list (src->p_aliases)))
    goto out;
d571 17
a587 1
  debug_printf ("protoent: copied %s", dst->p_name);
d589 1
a589 6
  return dst;

out:
  free_protoent_ptr (dst);
  return NULL;
}
d603 1
a603 2
  free_protoent_ptr (protoent_buf);
  protoent_buf = dup_protoent_ptr (getprotobyname (p));
d615 1
a615 2
  free_protoent_ptr (protoent_buf);
  protoent_buf = dup_protoent_ptr (getprotobynumber (number));
d945 1
a945 64
static void
free_servent_ptr (struct servent *&p)
{
  if (p)
    {
      debug_printf ("servent: %s", p->s_name);

      if (p->s_name)
	free (p->s_name);
      if (p->s_proto)
	free (p->s_proto);
      free_char_list (p->s_aliases);
      free ((void *) p);
      p = NULL;
    }
}

#pragma pack(push,2)
struct pservent
{
  char *s_name;
  char **s_aliases;
  short s_port;
  char *s_proto;
};

#pragma pack(pop)
static struct servent *
dup_servent_ptr (struct servent *src)
{
  if (!src)
    return NULL;

  struct servent *dst = (struct servent *) calloc (1, sizeof *dst);

  if (!dst)
    return NULL;

  debug_printf ("servent: %s", src->s_name);

  dst->s_port = src->s_port;
  if (src->s_name && !(dst->s_name = strdup (src->s_name)))
    goto out;
  if (src->s_aliases && !(dst->s_aliases = dup_char_list (src->s_aliases)))
    goto out;
  char *s_proto;

  if (IsBadReadPtr (src->s_proto, sizeof (src->s_proto))
      && !IsBadReadPtr (((pservent *) src)->s_proto, sizeof (src->s_proto)))
    s_proto = ((pservent *) src)->s_proto;
  else
    s_proto = src->s_proto;

  if (s_proto && !(dst->s_proto = strdup (s_proto)))
    goto out;

  debug_printf ("servent: copied %s", dst->s_name);

  return dst;

out:
  free_servent_ptr (dst);
  return NULL;
}
d963 1
a963 2
  free_servent_ptr (servent_buf);
  servent_buf = dup_servent_ptr (getservbyname (name, proto));
d980 1
a980 2
  free_servent_ptr (servent_buf);
  servent_buf = dup_servent_ptr (getservbyport (port, proto));
d1011 1
a1011 47
static void
free_hostent_ptr (struct hostent *&p)
{
  if (p)
    {
      debug_printf ("hostent: %s", p->h_name);

      if (p->h_name)
	free ((void *) p->h_name);
      free_char_list (p->h_aliases);
      free_addr_list (p->h_addr_list);
      free ((void *) p);
      p = NULL;
    }
}

static struct hostent *
dup_hostent_ptr (struct hostent *src)
{
  if (!src)
    return NULL;

  struct hostent *dst = (struct hostent *) calloc (1, sizeof *dst);

  if (!dst)
    return NULL;

  debug_printf ("hostent: %s", src->h_name);

  dst->h_addrtype = src->h_addrtype;
  dst->h_length = src->h_length;
  if (src->h_name && !(dst->h_name = strdup (src->h_name)))
    goto out;
  if (src->h_aliases && !(dst->h_aliases = dup_char_list (src->h_aliases)))
    goto out;
  if (src->h_addr_list
      && !(dst->h_addr_list = dup_addr_list (src->h_addr_list, src->h_length)))
    goto out;

  debug_printf ("hostent: copied %s", dst->h_name);

  return dst;

out:
  free_hostent_ptr (dst);
  return NULL;
}
d1051 1
a1051 2
  free_hostent_ptr (hostent_buf);
  hostent_buf = dup_hostent_ptr (gethostbyname (name));
d1074 1
a1074 2
  free_hostent_ptr (hostent_buf);
  hostent_buf = dup_hostent_ptr (gethostbyaddr (addr, len, type));
@


1.148
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d586 1
a586 1
  sig_dispatch_pending (0);
d610 1
a610 1
  sig_dispatch_pending (0);
d767 1
a767 1
  sig_dispatch_pending (0);
d906 1
a906 1
  sig_dispatch_pending (0);
d925 1
a925 1
  sig_dispatch_pending (0);
d942 1
a942 1
  sig_dispatch_pending (0);
d1026 1
a1026 1
  sig_dispatch_pending (0);
d1067 1
a1067 1
  sig_dispatch_pending (0);
d1092 1
a1092 1
  sig_dispatch_pending (0);
d1125 1
a1125 1
  sig_dispatch_pending (0);
d1143 1
a1143 1
  sig_dispatch_pending (0);
d1164 1
a1164 1
  sig_dispatch_pending (0);
d1182 1
a1182 1
  sig_dispatch_pending (0);
d1248 1
a1248 1
  sig_dispatch_pending (0);
d1289 1
a1289 1
  sig_dispatch_pending (0);
d1903 1
a1903 1
  sig_dispatch_pending (0);
d1982 1
a1982 1
  sig_dispatch_pending (0);
d2040 1
a2040 1
  sig_dispatch_pending (0);
d2072 1
a2072 1
  sig_dispatch_pending (0);
d2135 1
a2135 1
  sig_dispatch_pending (0);
d2336 1
a2336 1
  sig_dispatch_pending (0);
d2363 1
a2363 1
  sig_dispatch_pending (0);
@


1.147
log
@	* fhandler.h (fhandler_socket::get_connect_state): New method to
	return socket connection state.
	* fhandler_socket.cc (dup): Copy socket connect state to new file
	handle.
	* net.cc (cygwin_rcmd): Mark file handles of sockets returned by
	rcmd() as CONNECTED state.
	(cygwin_rexec): Similarly for rexec().
	(socketpair): Mark both ends of a new socket pair as CONNECTED.
@
text
@d525 1
a525 1
  	cygheap->fdtab.build_fhandler (fd, FH_SOCKET, name, NULL,
d778 1
a778 1
        {
d785 1
a785 1
        {
d797 1
a797 1
	        {
d806 1
a806 1
		        {
d814 1
a814 1
	        res = 0;
d816 1
a816 1
	        {
d1307 1
a1307 1
     FIXME: Handle DHCP on Win95. The DhcpDomain(s) may be available 
d2017 1
a2017 1
	  if (fh) 
@


1.146
log
@2003-06-18  Pierre Humblet  <pierre.humblet@@ieee.org>

        * autoload.cc (GetNetworkParams): Add.
        * net.cc (getdomainname): Call GetNetworkParams and read the
        DhcpDomain registry value if warranted.
@
text
@d2000 4
a2003 1
	res = res_fd;
d2017 5
a2021 2
	  if (fh)
	    *fd2p = newfd;
d2090 4
a2093 1
	res = res_fd;
d2108 4
a2111 1
	    *fd2p = newfd;
d2287 1
d2299 1
@


1.145
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d1294 16
d1316 1
a1316 2
  /* FIXME: Are registry keys case sensitive? */
  if (r.error () || r.get_string ("Domain", domain, len, "") != ERROR_SUCCESS)
d1318 6
a1323 2
      __seterrno ();
      return -1;
d1325 2
a1326 2

  return 0;
@


1.144
log
@	* fhandler_socket.cc (connect_thread): Remove.
	(accept_thread): Remove.
	(fhandler_socket::connect): Remove all special blocking handling.
	(fhandler_socket::accept): Ditto.
	* net.cc (cygwin_connect): Make blocking sockets temporarily
	non-blocking and call cygwin_select on them to be interruptible.
	(cygwin_accept):  Ditto.
@
text
@a15 1
#include <errno.h>
@


1.143
log
@	* net.cc (cygwin_rcmd): Use correct file descriptor in call to fdsock.
	(cygwin_rexec): Ditto.
@
text
@d776 50
a825 1
    res = fh->connect (name, namelen);
d1103 13
a1115 1
    res = fh->accept (peer, len);
@


1.142
log
@whitespace cleanup
@
text
@d1934 1
a1934 1
	    fh = fdsock (*fd2p, "/dev/tcp", fd2s);
d2018 1
a2018 1
	    fh = fdsock (*fd2p, "/dev/tcp", fd2s);
@


1.142.2.1
log
@* fhandler_proc.cc (format_proc_cpuinfo): Fix vendor id in cpuid case.
* net.cc (cygwin_rcmd): Use correct file descriptor in call to fdsock.
(cygwin_rexec): Ditto.
@
text
@d1934 1
a1934 1
	    fh = fdsock (newfd, "/dev/tcp", fd2s);
d2018 1
a2018 1
	    fh = fdsock (newfd, "/dev/tcp", fd2s);
@


1.141
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@d1971 1
a1971 1
        res = res_fd;
d2216 1
a2216 1
        closesocket (insock);
@


1.140
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Check descriptor
	created by cygheap_fdnew constructor.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
	* fhandler_socket.cc (fhandler_socket::accept): Ditto and move
	creation of file descriptor behind blocking OS call.
	* net.cc (cygwin_socket): Ditto.
	(cygwin_rcmd): Ditto.
	(cygwin_rresvport): Ditto.
	(cygwin_rexec): Ditto.
	(socketpair): Ditto.
@
text
@d17 1
d525 3
a527 2
  fhandler_socket *fh =
    (fhandler_socket *) cygheap->fdtab.build_fhandler (fd, FH_SOCKET, name);
@


1.139
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d543 1
a543 1
  cygheap_fdnew fd;
d545 3
a547 1
  if (fd >= 0)
d549 3
a551 1
      debug_printf ("socket (%d, %d, %d)", af, type, protocol);
d553 1
a553 1
      soc = socket (AF_INET, type, af == AF_LOCAL ? 0 : protocol);
d555 4
a558 12
      if (soc == INVALID_SOCKET)
	{
	  set_winsock_errno ();
	  goto done;
	}

      const char *name;

      if (af == AF_INET)
	name = (type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp");
      else
	name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");
d560 3
d564 9
a572 12
      if (!fh)
	{
	  closesocket (soc);
	  res = -1;
	}
      else
	{
	  fh->set_addr_family (af);
	  fh->set_socket_type (type);
	  res = fd;
	}
    }
d1900 1
d1910 5
a1914 1
  cygheap_fdnew res_fd;
d1916 9
a1924 2
  if (res_fd < 0)
    goto done;
d1926 3
a1928 3
  if (fd2p)
    {
      cygheap_fdnew newfd (res_fd, false);
d1930 12
a1941 12
      if (*fd2p < 0)
	goto done;
      *fd2p = newfd;
    }

  res = rcmd (ahost, inport, locuser, remuser, cmd, fd2p ? &fd2s : NULL);
  if (res == (int) INVALID_SOCKET)
    goto done;
  else
    {
      fdsock (res_fd, "/dev/tcp", res);
      res = res_fd;
a1943 4
  if (fd2p)
    fdsock (*fd2p, "/dev/tcp", fd2s);

done:
d1959 1
a1959 1
  cygheap_fdnew res_fd;
d1961 1
a1961 3
  if (res_fd < 0)
    res = -1;
  else
d1963 2
a1964 1
      res = rresvport (port);
d1966 6
a1971 5
      if (res != (int) INVALID_SOCKET)
	{
	  fdsock (res_fd, "/dev/tcp", res);
	  res = res_fd;
	}
d1994 5
a1998 1
  cygheap_fdnew res_fd;
d2000 13
a2012 5
  if (res_fd < 0)
    goto done;
  if (fd2p)
    {
      cygheap_fdnew newfd (res_fd);
d2014 12
a2025 3
      if (newfd < 0)
	goto done;
      *fd2p = newfd;
a2026 10
  res = rexec (ahost, inport, locuser, password, cmd, fd2p ? &fd2s : NULL);
  if (res == (int) INVALID_SOCKET)
    goto done;
  else
    {
      fdsock (res_fd, "/dev/tcp", res);
      res = res_fd;
    }
  if (fd2p)
    fdsock (*fd2p, "/dev/tcp", fd2s);
a2027 1
done:
a2040 2
  cygheap_fdnew sb0;
  fhandler_socket *fh;
a2063 13
  if (sb0 < 0)
    goto done;
  else
    {
      sb[0] = sb0;
      cygheap_fdnew sb1 (sb0, false);

      if (sb1 < 0)
	goto done;

      sb[1] = sb1;
    }

d2177 34
a2210 1
  res = 0;
d2212 6
a2217 27
  if (family == AF_LOCAL)
    {

      fh = fdsock (sb[0],
		   type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket",
		   insock);
      fh->set_sun_path ("");
      fh->set_addr_family (AF_LOCAL);
      fh->set_socket_type (type);
      fh = fdsock (sb[1],
		   type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket",
		   outsock);
      fh->set_sun_path ("");
      fh->set_addr_family (AF_LOCAL);
      fh->set_socket_type (type);
    }
  else
    {
      fh = fdsock (sb[0], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
		   insock);
      fh->set_addr_family (AF_INET);
      fh->set_socket_type (type);
      fh = fdsock (sb[1], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
		   outsock);
      fh->set_addr_family (AF_INET);
      fh->set_socket_type (type);
    }
@


1.138
log
@	* autoload.cc: Fix copyright date.
	* fhandler_dsp.cc: Ditto.
	* mmap.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* signal.cc: Ditto.
	* syscalls.cc: Ditto.
	* uname.cc: Ditto.
	* wait.cc: Ditto.
@
text
@d127 1
a127 1
                        0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
d156 1
a156 1
           ((x & 0x0000ff00U) >> 8)));
@


1.138.2.1
log
@merge from trunk
@
text
@d525 1
a525 1
    (fhandler_socket *) cygheap->fdtab.build_fhandler (fd, *socket_dev, name);
@


1.138.2.2
log
@merge from trunk
@
text
@d127 1
a127 1
			0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
d156 1
a156 1
	   ((x & 0x0000ff00U) >> 8)));
@


1.138.2.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d30 1
a31 1
#include "fhandler.h"
d524 2
a525 1
  fhandler_socket *fh = (fhandler_socket *) build_fh_dev (*socket_dev, name);
a527 1
  cygheap->fdtab[fd] = fh;
@


1.138.2.4
log
@merge from trunk
@
text
@a16 1
#include <ctype.h>
d543 1
a543 1
  debug_printf ("socket (%d, %d, %d)", af, type, protocol);
d545 5
a549 1
  soc = socket (AF_INET, type, af == AF_LOCAL ? 0 : protocol);
d551 5
a555 5
  if (soc == INVALID_SOCKET)
    {
      set_winsock_errno ();
      goto done;
    }
d557 1
a557 1
  const char *name;
d559 4
a562 4
  if (af == AF_INET)
    name = (type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp");
  else
    name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");
a563 3
  {
    cygheap_fdnew fd;
    if (fd >= 0)
d565 12
a576 9
    if (fh)
      {
	fh->set_addr_family (af);
	fh->set_socket_type (type);
	res = fd;
      }
    else
	closesocket (soc);
  }
a1903 1

d1913 6
a1918 2
  res = rcmd (ahost, inport, locuser, remuser, cmd, fd2p ? &fd2s : NULL);
  if (res != (int) INVALID_SOCKET)
d1920 1
a1920 2
      fhandler_socket *fh = NULL;
      cygheap_fdnew res_fd;
d1922 4
a1925 9
      if (res_fd >= 0)
	fh = fdsock (res_fd, "/dev/tcp", res);
      if (fh)
	res = res_fd;
      else
	{
	  closesocket (res);
	  res = -1;
	}
d1927 8
a1934 3
      if (res >= 0 && fd2p)
	{
	  cygheap_fdnew newfd (res_fd, false);
d1936 2
a1937 13
	  fh = NULL;
	  if (newfd >= 0)
	    fh = fdsock (*fd2p, "/dev/tcp", fd2s);
	  if (fh)
	    *fd2p = newfd;
	  else
	    {
	      closesocket (res);
	      closesocket (fd2s);
	      res = -1;
	    }
	}
    }
d1939 1
d1955 1
a1955 1
  res = rresvport (port);
d1957 3
a1959 1
  if (res != (int) INVALID_SOCKET)
d1961 1
a1961 2
      fhandler_socket *fh = NULL;
      cygheap_fdnew res_fd;
d1963 5
a1967 6
      if (res_fd >= 0)
	fh = fdsock (res_fd, "/dev/tcp", res);
      if (fh)
        res = res_fd;
      else
	res = -1;
d1990 12
d2003 3
a2005 1
  if (res != (int) INVALID_SOCKET)
d2007 2
a2008 29
      fhandler_socket *fh = NULL;
      cygheap_fdnew res_fd;

      if (res_fd >= 0)
	fh = fdsock (res_fd, "/dev/tcp", res);
      if (fh)
	res = res_fd;
      else
	{
	  closesocket (res);
	  res = -1;
	}

      if (res >= 0 && fd2p)
	{
	  cygheap_fdnew newfd (res_fd, false);

	  fh = NULL;
	  if (newfd >= 0)
	    fh = fdsock (*fd2p, "/dev/tcp", fd2s);
	  if (fh)
	    *fd2p = newfd;
	  else
	    {
	      closesocket (res);
	      closesocket (fd2s);
	      res = -1;
	    }
	}
d2010 2
d2013 1
d2027 2
d2052 13
d2178 4
a2181 34
  {
    fhandler_socket *fh = NULL;
    cygheap_fdnew sb0;
    const char *name;

    if (family == AF_INET)
      name = (type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp");
    else
      name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");

    if (sb0 >= 0)
      fh = fdsock (sb0, name, insock);
    if (fh)
      {
	fh->set_sun_path ("");
	fh->set_addr_family (family);
	fh->set_socket_type (type);

	cygheap_fdnew sb1 (sb0, false);

	fh = NULL;
	if (sb1 >= 0)
	  fh = fdsock (sb1, name, outsock);
	if (fh)
	  {
	    fh->set_sun_path ("");
	    fh->set_addr_family (family);
	    fh->set_socket_type (type);

	    sb[0] = sb0;
	    sb[1] = sb1;
	    res = 0;
	  }
      }
d2183 24
a2206 6
    if (res == -1)
      {
        closesocket (insock);
	closesocket (outsock);
      }
  }
@


1.138.2.5
log
@Merge from trunk.
* Makefile.in (devicess.cc): Make generation dependent on cygwin-gperf.
* cygheap.h (cygheap_fdmanip): Add fhandler_socket cast.
* cygwin-gperf: Autogenerate references to network devices.
* devices.h: Create separate device types for all network types.  Export
references to global network device storage.
* dtable.cc (dtable::release): Use generic determination to control when
need_fixup_before needs to be decremented.
(dtable::init_std_file_from_handle): Replace use of 'socket_dev' with
'tcp_dev'.
(build_fh_pc): Adapt to new socket types.  Don't increment fixup_before here.
* fhandler.h (fhandler_base::need_fixup_before): Declare/define.
(fhandler_socket::need_fixup_before): Ditto.
* fhandler_socket.cc (fhandler_socket::accept): Accommodate new fdsock
definition.
* net.cc: Throughout, change use of fdsock to return true/false for
success/failure and take cygheap_fdmanip type and device
* select.cc (set_bits): Use 'is_socket ()' test rather than specificially
testing device type.
@
text
@d510 2
a511 2
bool
fdsock (cygheap_fdmanip& fd, const device *dev, SOCKET soc)
d525 9
a533 9
  fd = build_fh_dev (*dev);
  if (!fd.isopen ())
    return false;
  fd->set_io_handle ((HANDLE) soc);
  fd->set_flags (O_RDWR | O_BINARY);
  fd->set_r_no_interrupt (winsock2_active);
  cygheap->fdtab.inc_need_fixup_before ();
  debug_printf ("fd %d, name '%s', soc %p", (int) fd, dev->name, soc);
  return true;
d542 1
d554 1
a554 1
  const device *dev;
d557 1
a557 1
    dev = type == SOCK_STREAM ? tcp_dev : udp_dev;
d559 1
a559 1
    dev = type == SOCK_STREAM ? stream_dev : dgram_dev;
d563 3
a565 3
    if (fd < 0 || !fdsock (fd, dev, soc))
      closesocket (soc);
    else
d567 2
a568 2
	((fhandler_socket *) fd)->set_addr_family (af);
	((fhandler_socket *) fd)->set_socket_type (type);
d571 2
d1914 1
d1917 3
a1919 1
      if (res_fd >= 0 && fdsock (res_fd, tcp_dev, res))
a1929 1
	  cygheap_fdget fd (*fd2p);
d1931 4
a1934 1
	  if (newfd >= 0 && fdsock (fd, tcp_dev, fd2s))
d1964 1
d1967 3
a1969 1
      if (res_fd >= 0 && fdsock (res_fd, tcp_dev, res))
d1998 1
d2001 3
a2003 1
      if (res_fd >= 0 && fdsock (res_fd, tcp_dev, res))
a2013 1
	  cygheap_fdget fd (*fd2p);
d2015 4
a2018 1
	  if (newfd >= 0 && fdsock (fd, tcp_dev, fd2s))
d2179 1
d2181 1
a2181 1
    const device *dev;
d2184 1
a2184 1
      dev = (type == SOCK_STREAM ? tcp_dev : udp_dev);
d2186 1
a2186 1
      dev = (type == SOCK_STREAM ? stream_dev : dgram_dev);
d2188 3
a2190 1
    if (sb0 >= 0 && fdsock (sb0, dev, insock))
d2192 3
a2194 3
	((fhandler_socket *) sb0)->set_sun_path ("");
	((fhandler_socket *) sb0)->set_addr_family (family);
	((fhandler_socket *) sb0)->set_socket_type (type);
d2198 4
a2201 1
	if (sb1 >= 0 && fdsock (sb1, dev, outsock))
d2203 3
a2205 3
	    ((fhandler_socket *) sb1)->set_sun_path ("");
	    ((fhandler_socket *) sb1)->set_addr_family (family);
	    ((fhandler_socket *) sb1)->set_socket_type (type);
@


1.138.2.6
log
@merge from trunk
@
text
@d2193 1
a2193 1
	closesocket (insock);
@


1.138.2.7
log
@merge from trunk
@
text
@d1926 1
a1926 1
	  if (newfd >= 0 && fdsock (newfd, tcp_dev, fd2s))
d2002 1
a2002 1
	  if (newfd >= 0 && fdsock (newfd, tcp_dev, fd2s))
@


1.138.2.8
log
@merge from trunk
@
text
@d772 1
a772 50
    {
      bool was_blocking = false;
      if (!fh->is_nonblocking ())
        {
	  int nonblocking = 1;
	  fh->ioctl (FIONBIO, &nonblocking);
	  was_blocking = true;
	}
      res = fh->connect (name, namelen);
      if (was_blocking)
        {
	  if (res == -1 && get_errno () == EINPROGRESS)
	    {
	      size_t fds_size = howmany (fd + 1, NFDBITS) * sizeof (fd_mask);
	      fd_set *write_fds = (fd_set *) alloca (fds_size);
	      fd_set *except_fds = (fd_set *) alloca (fds_size);
	      memset (write_fds, 0, fds_size);
	      memset (except_fds, 0, fds_size);
	      FD_SET (fd, write_fds);
	      FD_SET (fd, except_fds);
	      res = cygwin_select (fd + 1, NULL, write_fds, except_fds, NULL);
	      if (res > 0 && FD_ISSET (fd, except_fds))
	        {
		  res = -1;
		  for (;;)
		    {
		      int err;
		      int len = sizeof err;
		      cygwin_getsockopt (fd, SOL_SOCKET, SO_ERROR,
					 (void *) &err, &len);
		      if (err)
		        {
			  set_errno (err);
			  break;
			}
		      low_priority_sleep (0);
		    }
		}
	      else if (res > 0)
	        res = 0;
	      else
	        {
		  WSASetLastError (WSAEINPROGRESS);
		  set_winsock_errno ();
		}
	    }
	  int nonblocking = 0;
	  fh->ioctl (FIONBIO, &nonblocking);
	}
    }
d1050 1
a1050 13
    {
      if (!fh->is_nonblocking ())
	{
	  size_t fds_size = howmany (fd + 1, NFDBITS) * sizeof (fd_mask);
	  fd_set *read_fds = (fd_set *) alloca (fds_size);
	  memset (read_fds, 0, fds_size);
	  FD_SET (fd, read_fds);
	  res = cygwin_select (fd + 1, read_fds, NULL, NULL, NULL);
	  if (res == -1)
	    return -1;
	}
      res = fh->accept (peer, len);
    }
@


1.138.2.9
log
@merge from trunk
@
text
@d16 1
a1290 16
  PFIXED_INFO info = NULL;
  ULONG size = 0;

  if (GetNetworkParams(info, &size) == ERROR_BUFFER_OVERFLOW
      && (info = (PFIXED_INFO) alloca(size))
      && GetNetworkParams(info, &size) == ERROR_SUCCESS)
    {
      strncpy(domain, info->DomainName, len);
      return 0;
    }

  /* This is only used by Win95 and NT <=  4.0.
     The registry names are language independent.
     FIXME: Handle DHCP on Win95. The DhcpDomain(s) may be available 
     in ..VxD\DHCP\DhcpInfoXX\OptionInfo, RFC 1533 format */

d1297 2
a1298 1
  if (!r.error ())
d1300 2
a1301 6
      int res1, res2 = 0; /* Suppress compiler warning */
      res1 = r.get_string ("Domain", domain, len, "");
      if (res1 != ERROR_SUCCESS || !domain[0])
	res2 = r.get_string ("DhcpDomain", domain, len, "");
      if (res1 == ERROR_SUCCESS || res2 == ERROR_SUCCESS)
	return 0;
d1303 2
a1304 2
  __seterrno ();
  return -1;
d1975 1
a1975 4
	{
	  ((fhandler_socket *) res_fd)->set_connect_state (CONNECTED);
	  res = res_fd;
	}
d1988 1
a1988 4
	    {
	      *fd2p = newfd;
	      ((fhandler_socket *) fd2p)->set_connect_state (CONNECTED);
	    }
d2051 1
a2051 4
	{
	  ((fhandler_socket *) res_fd)->set_connect_state (CONNECTED);
	  res = res_fd;
	}
d2064 1
a2064 4
	    {
	      ((fhandler_socket *) fd2p)->set_connect_state (CONNECTED);
	      *fd2p = newfd;
	    }
a2236 1
	((fhandler_socket *) sb0)->set_connect_state (CONNECTED);
a2244 1
	    ((fhandler_socket *) sb1)->set_connect_state (CONNECTED);
@


1.138.2.10
log
@merge from trunk
@
text
@d530 1
a530 1
  // CORINNA - needed? // cygheap->fdtab.inc_need_fixup_before ();
d774 1
a774 1
	{
d781 1
a781 1
	{
d793 1
a793 1
		{
d802 1
a802 1
			{
d810 1
a810 1
		res = 0;
d812 1
a812 1
		{
d1303 1
a1303 1
     FIXME: Handle DHCP on Win95. The DhcpDomain(s) may be available
@


1.138.2.11
log
@merge from trunk
@
text
@d582 1
a582 1
  sig_dispatch_pending ();
d606 1
a606 1
  sig_dispatch_pending ();
d763 1
a763 1
  sig_dispatch_pending ();
d902 1
a902 1
  sig_dispatch_pending ();
d921 1
a921 1
  sig_dispatch_pending ();
d938 1
a938 1
  sig_dispatch_pending ();
d1022 1
a1022 1
  sig_dispatch_pending ();
d1063 1
a1063 1
  sig_dispatch_pending ();
d1088 1
a1088 1
  sig_dispatch_pending ();
d1121 1
a1121 1
  sig_dispatch_pending ();
d1139 1
a1139 1
  sig_dispatch_pending ();
d1160 1
a1160 1
  sig_dispatch_pending ();
d1178 1
a1178 1
  sig_dispatch_pending ();
d1244 1
a1244 1
  sig_dispatch_pending ();
d1285 1
a1285 1
  sig_dispatch_pending ();
d1899 1
a1899 1
  sig_dispatch_pending ();
d1978 1
a1978 1
  sig_dispatch_pending ();
d2031 1
a2031 1
  sig_dispatch_pending ();
d2060 1
a2060 1
  sig_dispatch_pending ();
d2118 1
a2118 1
  sig_dispatch_pending ();
d2313 1
a2313 1
  sig_dispatch_pending ();
d2340 1
a2340 1
  sig_dispatch_pending ();
@


1.138.2.12
log
@merge from trunk
@
text
@a27 1
#include <assert.h>
d384 2
a385 2
inline int
DWORD_round (int n)
d387 6
a392 1
  return sizeof (DWORD) * (((n + sizeof (DWORD) - 1)) / sizeof (DWORD));
d395 2
a396 2
inline int
strlen_round (const char *s)
d398 11
a408 3
  if (!s)
    return 0;
  return DWORD_round (strlen (s) + 1);
d411 1
a411 9
#pragma pack(push,2)
struct pservent
{
  char *s_name;
  char **s_aliases;
  short s_port;
  char *s_proto;
};
#pragma pack(pop)
d413 2
a414 1
struct unionent
d416 2
a417 10
  char *name;
  char **list;
  short port_proto_addrtype;
  short h_len;
  union
  {
    char *s_proto;
    char **h_addr_list;
  };
};
d419 12
a430 4
enum struct_type
{
  is_hostent, is_protoent, is_servent
};
d432 2
a433 17
static const char *entnames[] = {"host", "proto", "serv"};

/* Generic "dup a {host,proto,serv}ent structure" function.
   This is complicated because we need to be able to free the
   structure at any point and we can't rely on the pointer contents
   being untouched by callers.  So, we allocate a chunk of memory
   large enough to hold the structure and all of the stuff it points
   to then we copy the source into this new block of memory.
   The 'unionent' struct is a union of all of the currently used
   *ent structure.  */

#ifdef DEBUGGING
static void *
#else
static inline void *
#endif
dup_ent (void *old, void *src0, struct_type type)
d435 1
a435 1
  if (old)
d437 7
a443 3
      debug_printf ("freeing old %sent structure \"%s\" %p\n", entnames[type],
		    ((unionent *) old)->name, old);
      free (old);
d445 1
d447 4
a450 1
  if (!src0)
d453 1
a453 21
  unionent *src = (unionent *) src0;
  debug_printf ("duping %sent \"%s\", %p", entnames[type],
		src ? src->name : "<null!>", src);

  /* Find the size of the raw structure minus any character strings, etc. */
  int sz, struct_sz;
  switch (type)
    {
    case is_protoent:
      struct_sz = sizeof (protoent);
      break;
    case is_servent:
      struct_sz = sizeof (servent);
      break;
    case is_hostent:
      struct_sz = sizeof (hostent);
      break;
    default:
      api_fatal ("called with invalid value %d", type);
      break;
    }
d455 2
a456 14
  /* Every *ent begins with a name.  Calculate it's length. */
  int namelen = strlen_round (src->name);
  sz = struct_sz + namelen;

  char **av;
  /* The next field in every *ent is an argv list of "something".
     Calculate the number of components and how much space the
     character strings will take.  */
  int list_len = 0;
  for (av = src->list; av && *av; av++)
    {
      list_len++;
      sz += sizeof (char **) + strlen_round (*av);
    }
d458 1
a458 6
  /* NULL terminate if there actually was a list */
  if (av)
    {
      sz += sizeof (char **);
      list_len++;
    }
d460 5
a464 19
  /* Do servent/hostent specific processing */
  int protolen = 0;
  int addr_list_len = 0;
  if (type == is_servent)
    sz += (protolen = strlen_round (src->s_proto));
  else if (type == is_hostent)
    {
      /* Calculate the length and storage used for h_addr_list */
      for (av = src->h_addr_list; av && *av; av++)
	{
	  addr_list_len++;
	  sz += sizeof (char **) + DWORD_round (src->h_len);
	}
      if (av)
	{
	  sz += sizeof (char **);
	  addr_list_len++;
	}
    }
d466 1
a466 2
  /* Allocate the storage needed */
  unionent *dst = (unionent *) calloc (1, sz);
d468 1
a468 26
  /* Hopefully, this worked. */
  if (dst)
    {
      /* This field is common to all *ent structures but named differently
	 in each, of course.  */
      dst->port_proto_addrtype = src->port_proto_addrtype;

      /* Copy the name field to dst, using space just beyond the end of
	 the dst structure. */
      char *dp = ((char *) dst) + struct_sz;
      strcpy (dst->name = dp, src->name);
      dp += namelen;

      /* Copy the 'list' type to dst, using space beyond end of structure
	 + storage for name. */
      if (src->list)
	{
	  char **dav = dst->list = (char **) dp;
	  dp += sizeof (char **) * list_len;
	  for (av = src->list; av && *av; av++)
	    {
	      int len = strlen (*av) + 1;
	      memcpy (*dav++ = dp, *av, len);
	      dp += DWORD_round (len);
	    }
	}
d470 3
a472 35
      /* Do servent/hostent specific processing. */
      if (type == is_servent)
	{
	  if (src->s_proto)
	    {
	      char *s_proto;
	      /* Windows 95 idiocy.  Structure is misaligned on Windows 95.
		 Kludge around this by trying a different pointer alignment.  */
	      if (IsBadReadPtr (src->s_proto, sizeof (src->s_proto))
		  && !IsBadReadPtr (((pservent *) src)->s_proto, sizeof (src->s_proto)))
		s_proto = ((pservent *) src)->s_proto;
	      else
		s_proto = src->s_proto;
	      strcpy (dst->s_proto = dp, s_proto);
	      dp += protolen;
	    }
	}
      else if (type == is_hostent)
	{
	  /* Transfer h_len and duplicate contents of h_addr_list, using
	     memory after 'list' allocation. */
	  dst->h_len = src->h_len;
	  char **dav = dst->h_addr_list = (char **) dp;
	  dp += sizeof (char **) * addr_list_len;
	  for (av = src->h_addr_list; av && *av; av++)
	    {
	      memcpy (*dav++ = dp, *av, src->h_len);
	      dp += DWORD_round (src->h_len);
	    }
	}
      /* Sanity check that we did our bookkeeping correctly. */
      assert ((dp - (char *) dst) == sz);
    }
  debug_printf ("duped %sent \"%s\", %p", entnames[type], dst ? dst->name : "<null!>", dst);
  return dst;
d487 2
a488 2
  protoent_buf = (protoent *) dup_ent (protoent_buf, getprotobyname (p),
				       is_protoent);
d500 2
a501 2
  protoent_buf = (protoent *) dup_ent (protoent_buf, getprotobynumber (number),
				       is_protoent);
d827 65
d908 2
a909 2
  servent_buf = (servent *) dup_ent (servent_buf, getservbyname (name, proto),
				     is_servent);
d926 2
a927 2
  servent_buf = (servent *) dup_ent (servent_buf, getservbyport (port, proto),
				     is_servent);
d958 48
d1044 2
a1045 2
  hostent_buf = (hostent *) dup_ent (hostent_buf, gethostbyname (name),
				     is_hostent);
d1068 2
a1069 3
  hostent_buf = (hostent *) dup_ent (hostent_buf,
				     gethostbyaddr (addr, len, type),
				     is_hostent);
@


1.138.2.13
log
@merge from trunk
@
text
@d641 1
a641 1
  cygheap->fdtab.inc_need_fixup_before ();
@


1.137
log
@* net.cc: Use gethostname define from winsock2.h.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.136
log
@	* autoload.cc (gethostname): Make call optional, return 1 if function
	can't get loaded.
	* net.cc (cygwin_gethostname): Call GetComputerName if return value
	of gethostname is non-zero.
@
text
@d22 1
d24 1
@


1.135
log
@	* net.cc (cygwin_gethostname): Fix call to wsock function gethostname.
@
text
@d899 1
a899 1
  if (gethostname (name, len) == SOCKET_ERROR)
@


1.134
log
@whitespace
@
text
@a893 2
  int PASCAL win32_gethostname (char *, int);

d899 1
a899 1
  if (wsock32_handle == NULL || win32_gethostname (name, len) == SOCKET_ERROR)
@


1.134.4.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d523 1
a523 1
    (fhandler_socket *) cygheap->fdtab.build_fhandler (fd, *socket_dev, name);
@


1.133
log
@	* net.cc (free_protoent_ptr): Add missing free() for base structure.
	(free_servent_pt): Ditto.
	(free_hostent_pt): Ditto.
@
text
@d524 2
d563 6
a568 1
      if (fh)
d572 1
a573 1
      res = fd;
@


1.132
log
@* exceptions.cc (handle_sigsuspend): Force pending signal delivery before
waiting for signals to happen.
* signal.cc (sleep): Force pending signal delivery before sleeping.
(usleep): Ditto.
(signal): Force pending signal delivery before manipulating signal stuff.
(sigprocmask): Ditto.
(kill_worker): Ditto.
(abort): Ditto.
(sigaction): Ditto.
* syscalls.cc (readv): Force pending signal delivery before I/O.
(writev): Ditto.
(open): Ditto.
* net.cc: Ditto, throughout.
* sigproc.cc (sig_dispatch_pending): Deliver any pending signals prior to
returning.
* tty.cc (tty::make_pipes): Increase pipe buffer size.
@
text
@d440 1
d788 1
d920 1
@


1.131
log
@* net.cc: Sprinkle sigframes throughout.
@
text
@d579 1
d603 1
d760 1
d849 1
d868 1
d887 1
d970 1
d1011 1
d1036 1
d1057 1
d1075 1
d1096 1
d1114 1
d1180 1
d1221 1
d1816 1
d1894 1
d1939 1
d1971 1
d2020 1
d2220 1
d2247 1
@


1.130
log
@remove unneeded comments
@
text
@d846 1
d864 1
d882 1
d964 1
d1004 1
d1048 1
d1085 1
d1207 1
d1801 1
d2001 1
@


1.129
log
@	* net.cc: Run indent.

	* autoload.cc (GetIfEntry): Add symbol.
	* net.cc (get_2k_ifconf): Get the interface entries with the GetIfEntry
	call intead of the GetIfTable call. Clean-up multiple IP address naming.
@
text
@a102 1
/* Cygwin internal */
a118 1
/* Cygwin internal */
a163 1
/* Cygwin internal */
a342 1
/* Cygwin internal */
a364 1
/* Cygwin internal */
a1218 1
/* Cygwin internal */
@


1.128
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d37 3
a39 2
extern "C" {
int h_errno;
d41 7
a47 7
int __stdcall rcmd (char **ahost, unsigned short inport, char *locuser,
		    char *remuser, char *cmd, SOCKET *fd2p);
int __stdcall rexec (char **ahost, unsigned short inport, char *locuser,
		     char *password, char *cmd, SOCKET *fd2p);
int __stdcall rresvport (int *);
int sscanf (const char *, const char *, ...);
} /* End of "C" section */
d76 19
a94 19
    case WSA_WAIT_EVENT_0:
      DWORD len;
      if (WSAGetOverlappedResult (socket, &ovr, &len, FALSE, flags))
	ret = (int) len;
      break;
    case WSA_WAIT_EVENT_0 + 1:
      if (!CancelIo ((HANDLE)socket))
	{
	  debug_printf ("CancelIo() %E, fallback to blocking io");
	  WSAGetOverlappedResult (socket, &ovr, &len, TRUE, flags);
	}
      else
	WSASetLastError (WSAEINTR);
      break;
    case WSA_WAIT_FAILED:
      break;
    default: /* Should be impossible. *LOL* */
      WSASetLastError (WSAEFAULT);
      break;
d108 1
d113 1
d125 1
d127 1
a127 1
			0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
d139 2
a140 2
	   ((x & 0x0000ff00U) <<  8) |
	   ((x & 0x00ff0000U) >>  8) |
d156 1
a156 1
	   ((x & 0x0000ff00U) >> 8)));
d185 1
d203 1
d217 1
d226 1
a226 1
extern "C" unsigned int	WINAPI inet_network (const char *);
d234 1
d291 43
a333 44
static NO_COPY struct tl errmap[] =
{
 {WSAEINTR, "WSAEINTR", EINTR},
 {WSAEWOULDBLOCK, "WSAEWOULDBLOCK", EWOULDBLOCK},
 {WSAEINPROGRESS, "WSAEINPROGRESS", EINPROGRESS},
 {WSAEALREADY, "WSAEALREADY", EALREADY},
 {WSAENOTSOCK, "WSAENOTSOCK", ENOTSOCK},
 {WSAEDESTADDRREQ, "WSAEDESTADDRREQ", EDESTADDRREQ},
 {WSAEMSGSIZE, "WSAEMSGSIZE", EMSGSIZE},
 {WSAEPROTOTYPE, "WSAEPROTOTYPE", EPROTOTYPE},
 {WSAENOPROTOOPT, "WSAENOPROTOOPT", ENOPROTOOPT},
 {WSAEPROTONOSUPPORT, "WSAEPROTONOSUPPORT", EPROTONOSUPPORT},
 {WSAESOCKTNOSUPPORT, "WSAESOCKTNOSUPPORT", ESOCKTNOSUPPORT},
 {WSAEOPNOTSUPP, "WSAEOPNOTSUPP", EOPNOTSUPP},
 {WSAEPFNOSUPPORT, "WSAEPFNOSUPPORT", EPFNOSUPPORT},
 {WSAEAFNOSUPPORT, "WSAEAFNOSUPPORT", EAFNOSUPPORT},
 {WSAEADDRINUSE, "WSAEADDRINUSE", EADDRINUSE},
 {WSAEADDRNOTAVAIL, "WSAEADDRNOTAVAIL", EADDRNOTAVAIL},
 {WSAENETDOWN, "WSAENETDOWN", ENETDOWN},
 {WSAENETUNREACH, "WSAENETUNREACH", ENETUNREACH},
 {WSAENETRESET, "WSAENETRESET", ENETRESET},
 {WSAECONNABORTED, "WSAECONNABORTED", ECONNABORTED},
 {WSAECONNRESET, "WSAECONNRESET", ECONNRESET},
 {WSAENOBUFS, "WSAENOBUFS", ENOBUFS},
 {WSAEISCONN, "WSAEISCONN", EISCONN},
 {WSAENOTCONN, "WSAENOTCONN", ENOTCONN},
 {WSAESHUTDOWN, "WSAESHUTDOWN", ESHUTDOWN},
 {WSAETOOMANYREFS, "WSAETOOMANYREFS", ETOOMANYREFS},
 {WSAETIMEDOUT, "WSAETIMEDOUT", ETIMEDOUT},
 {WSAECONNREFUSED, "WSAECONNREFUSED", ECONNREFUSED},
 {WSAELOOP, "WSAELOOP", ELOOP},
 {WSAENAMETOOLONG, "WSAENAMETOOLONG", ENAMETOOLONG},
 {WSAEHOSTDOWN, "WSAEHOSTDOWN", EHOSTDOWN},
 {WSAEHOSTUNREACH, "WSAEHOSTUNREACH", EHOSTUNREACH},
 {WSAENOTEMPTY, "WSAENOTEMPTY", ENOTEMPTY},
 {WSAEPROCLIM, "WSAEPROCLIM", EPROCLIM},
 {WSAEUSERS, "WSAEUSERS", EUSERS},
 {WSAEDQUOT, "WSAEDQUOT", EDQUOT},
 {WSAESTALE, "WSAESTALE", ESTALE},
 {WSAEREMOTE, "WSAEREMOTE", EREMOTE},
 {WSAEINVAL, "WSAEINVAL", EINVAL},
 {WSAEFAULT, "WSAEFAULT", EFAULT},
 {0, "NOERROR", 0},
 {0, NULL, 0}
d352 1
d361 1
a361 2
static NO_COPY struct tl host_errmap[] =
{
d376 1
d456 1
d480 1
a480 1
  static struct protoent *protoent_buf = NULL;
d512 1
a512 1
fdsock (int& fd, const char *name, SOCKET soc)
d519 3
a521 2
      SetHandleInformation ((HANDLE)soc, HANDLE_FLAG_INHERIT, 0);
      debug_printf ("reset socket inheritance since winsock2_active %d", winsock2_active);
d524 4
a527 2
    debug_printf ("not setting socket inheritance since winsock2_active %d", winsock2_active);
  fhandler_socket *fh = (fhandler_socket *) cygheap->fdtab.build_fhandler (fd, FH_SOCKET, name);
d541 1
a541 1
  fhandler_socket* fh = NULL;
d558 1
d589 1
a589 1
      || (to &&__check_invalid_read_ptr_errno (to, tolen))
d614 1
a614 1
	      ||__check_null_invalid_struct_errno (from, (unsigned) *fromlen)))
d638 30
a667 30
    case SO_DEBUG:
      name="SO_DEBUG";
      break;
    case SO_ACCEPTCONN:
      name="SO_ACCEPTCONN";
      break;
    case SO_REUSEADDR:
      name="SO_REUSEADDR";
      break;
    case SO_KEEPALIVE:
      name="SO_KEEPALIVE";
      break;
    case SO_DONTROUTE:
      name="SO_DONTROUTE";
      break;
    case SO_BROADCAST:
      name="SO_BROADCAST";
      break;
    case SO_USELOOPBACK:
      name="SO_USELOOPBACK";
      break;
    case SO_LINGER:
      name="SO_LINGER";
      break;
    case SO_OOBINLINE:
      name="SO_OOBINLINE";
      break;
    case SO_ERROR:
      name="SO_ERROR";
      break;
d700 30
a729 30
    case SO_DEBUG:
      name="SO_DEBUG";
      break;
    case SO_ACCEPTCONN:
      name="SO_ACCEPTCONN";
      break;
    case SO_REUSEADDR:
      name="SO_REUSEADDR";
      break;
    case SO_KEEPALIVE:
      name="SO_KEEPALIVE";
      break;
    case SO_DONTROUTE:
      name="SO_DONTROUTE";
      break;
    case SO_BROADCAST:
      name="SO_BROADCAST";
      break;
    case SO_USELOOPBACK:
      name="SO_USELOOPBACK";
      break;
    case SO_LINGER:
      name="SO_LINGER";
      break;
    case SO_OOBINLINE:
      name="SO_OOBINLINE";
      break;
    case SO_ERROR:
      name="SO_ERROR";
      break;
d745 1
d801 1
d810 1
d822 1
d825 1
a825 1
    s_proto = ((pservent *)src)->s_proto;
d844 1
a844 1
  static struct servent *servent_buf = NULL;
d883 1
a883 1
  int PASCAL win32_gethostname (char*, int);
d888 1
a888 2
  if (wsock32_handle == NULL ||
      win32_gethostname (name, len) == SOCKET_ERROR)
d911 1
a911 1
	free ((void *)p->h_name);
d925 1
d953 1
a953 1
  static struct hostent *hostent_buf = NULL;
d1146 9
a1154 9
      case NETDB_INTERNAL:
	h_errstr = "Resolver internal error";
	break;
      case NETDB_SUCCESS:
	h_errstr = "Resolver error 0 (no error)";
	break;
      default:
	h_errstr = "Unknown resolver error";
	break;
d1212 1
a1212 2
	     (!wincap.is_winnt ()) ? "MSTCP" : "Parameters",
	     NULL);
d1235 1
a1235 1
  char eth[2] = "/", ppp[2] = "/", slp[2] = "/", sub[2] = "0", tok[2] = "/";
d1240 1
a1240 2
  DWORD if_cnt, ip_cnt, lip, lnp;
  DWORD siz_if_table = 0;
a1241 1
  PMIB_IFTABLE ift;
d1243 1
d1247 19
a1265 9
  if (GetIfTable (NULL, &siz_if_table, TRUE) == ERROR_INSUFFICIENT_BUFFER &&
      GetIpAddrTable (NULL, &siz_ip_table, TRUE) == ERROR_INSUFFICIENT_BUFFER &&
      (ift = (PMIB_IFTABLE) alloca (siz_if_table)) &&
      (ipt = (PMIB_IPADDRTABLE) alloca (siz_ip_table)) &&
      !GetIfTable (ift, &siz_if_table, TRUE) &&
      !GetIpAddrTable (ipt, &siz_ip_table, TRUE))
    {
      /* Iterate over all known interfaces */
      for (if_cnt = 0; if_cnt < ift->dwNumEntries; ++if_cnt)
d1267 9
a1275 3
	  *sub = '0';
	  /* Iterate over all configured IP-addresses */
	  for (ip_cnt = 0; ip_cnt < ipt->dwNumEntries; ++ip_cnt)
d1277 110
a1386 51
	      /* Does the IP address belong to the interface? */
	      if (ipt->table[ip_cnt].dwIndex == ift->table[if_cnt].dwIndex)
		{
		  /* Setup the interface name */
		  switch (ift->table[if_cnt].dwType)
		    {
		      case MIB_IF_TYPE_TOKENRING:
			++*tok;
			strcpy (ifr->ifr_name, "tok");
			strcat (ifr->ifr_name, tok);
			break;
		      case MIB_IF_TYPE_ETHERNET:
			if (*sub == '0')
			  ++*eth;
			strcpy (ifr->ifr_name, "eth");
			strcat (ifr->ifr_name, eth);
			break;
		      case MIB_IF_TYPE_PPP:
			++*ppp;
			strcpy (ifr->ifr_name, "ppp");
			strcat (ifr->ifr_name, ppp);
			break;
		      case MIB_IF_TYPE_SLIP:
			++*slp;
			strcpy (ifr->ifr_name, "slp");
			strcat (ifr->ifr_name, slp);
			break;
		      case MIB_IF_TYPE_LOOPBACK:
			strcpy (ifr->ifr_name, "lo");
			break;
		      default:
			continue;
		    }
		  if (*sub > '0')
		    {
		      strcat (ifr->ifr_name, ":");
		      strcat (ifr->ifr_name, sub);
		    }
		  ++*sub;
		  /* setup sockaddr struct */
		  switch (what)
		    {
		      case SIOCGIFCONF:
		      case SIOCGIFADDR:
			sa = (struct sockaddr_in *) &ifr->ifr_addr;
			sa->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr;
			sa->sin_family = AF_INET;
			sa->sin_port = 0;
			break;
		      case SIOCGIFBRDADDR:
			sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
d1388 2
a1389 2
			/* Unfortunately, the field returns only crap. */
			sa->sin_addr.s_addr = ipt->table[ip_cnt].dwBCastAddr;
d1391 5
a1395 5
			lip = ipt->table[ip_cnt].dwAddr;
			lnp = ipt->table[ip_cnt].dwMask;
			sa->sin_addr.s_addr = lip & lnp | ~lnp;
			sa->sin_family = AF_INET;
			sa->sin_port = 0;
d1397 22
a1418 28
			break;
		      case SIOCGIFNETMASK:
			sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			sa->sin_addr.s_addr = ipt->table[ip_cnt].dwMask;
			sa->sin_family = AF_INET;
			sa->sin_port = 0;
			break;
		      case SIOCGIFHWADDR:
			so = &ifr->ifr_hwaddr;
			for (UINT i = 0; i < IFHWADDRLEN; ++i)
			  if (i >= ift->table[if_cnt].dwPhysAddrLen)
			    so->sa_data[i] = '\0';
			  else
			    so->sa_data[i] = ift->table[if_cnt].bPhysAddr[i];
			so->sa_family = AF_INET;
			break;
		      case SIOCGIFMETRIC:
			ifr->ifr_metric = 1;
			break;
		      case SIOCGIFMTU:
			ifr->ifr_mtu = ift->table[if_cnt].dwMtu;
			break;
		    }
		  ++cnt;
		  if ((caddr_t) ++ifr >
		      ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
		    goto done;
		}
d1420 4
d1426 1
d1462 1
a1462 2
		    "Tcpip\\"
		    "Linkage",
d1513 2
a1514 3
		  if ((caddr_t) ++ifr > ifc->ifc_buf
		      + ifc->ifc_len
		      - sizeof (struct ifreq))
d1517 1
a1517 1
		  if (! strncmp (bp, "NdisWan", 7))
d1543 34
a1576 33
			case SIOCGIFCONF:
			case SIOCGIFADDR:
			  sa = (struct sockaddr_in *) &ifr->ifr_addr;
			  sa->sin_addr.s_addr = cygwin_inet_addr (dhcpaddress);
			  sa->sin_family = AF_INET;
			  sa->sin_port = 0;
			  break;
			case SIOCGIFBRDADDR:
			  lip = cygwin_inet_addr (dhcpaddress);
			  lnp = cygwin_inet_addr (dhcpnetmask);
			  sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
			  sa->sin_addr.s_addr = lip & lnp | ~lnp;
			  sa->sin_family = AF_INET;
			  sa->sin_port = 0;
			  break;
			case SIOCGIFNETMASK:
			  sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			  sa->sin_addr.s_addr =
			    cygwin_inet_addr (dhcpnetmask);
			  sa->sin_family = AF_INET;
			  sa->sin_port = 0;
			  break;
			case SIOCGIFHWADDR:
			  so = &ifr->ifr_hwaddr;
			  memset (so->sa_data, 0, IFHWADDRLEN);
			  so->sa_family = AF_INET;
			  break;
			case SIOCGIFMETRIC:
			  ifr->ifr_metric = 1;
			  break;
			case SIOCGIFMTU:
			  ifr->ifr_mtu = 1500;
			  break;
d1583 32
a1614 32
			case SIOCGIFCONF:
			case SIOCGIFADDR:
			  sa = (struct sockaddr_in *) &ifr->ifr_addr;
			  sa->sin_addr.s_addr = cygwin_inet_addr (ip);
			  sa->sin_family = AF_INET;
			  sa->sin_port = 0;
			  break;
			case SIOCGIFBRDADDR:
			  lip = cygwin_inet_addr (ip);
			  lnp = cygwin_inet_addr (np);
			  sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
			  sa->sin_addr.s_addr = lip & lnp | ~lnp;
			  sa->sin_family = AF_INET;
			  sa->sin_port = 0;
			  break;
			case SIOCGIFNETMASK:
			  sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			  sa->sin_addr.s_addr = cygwin_inet_addr (np);
			  sa->sin_family = AF_INET;
			  sa->sin_port = 0;
			  break;
			case SIOCGIFHWADDR:
			  so = &ifr->ifr_hwaddr;
			  memset (so->sa_data, 0, IFHWADDRLEN);
			  so->sa_family = AF_INET;
			  break;
			case SIOCGIFMETRIC:
			  ifr->ifr_metric = 1;
			  break;
			case SIOCGIFMTU:
			  ifr->ifr_mtu = 1500;
			  break;
d1682 1
a1682 2
	  || RegOpenKeyEx (key, ifname, 0,
			   KEY_READ, &ifkey) != ERROR_SUCCESS)
d1709 2
a1710 3
	  if ((caddr_t)++ifr > ifc->ifc_buf
	      + ifc->ifc_len
	      - sizeof (struct ifreq))
d1715 32
a1746 32
	    case SIOCGIFCONF:
	    case SIOCGIFADDR:
	      sa = (struct sockaddr_in *) &ifr->ifr_addr;
	      sa->sin_addr.s_addr = cygwin_inet_addr (ip);
	      sa->sin_family = AF_INET;
	      sa->sin_port = 0;
	      break;
	    case SIOCGIFBRDADDR:
	      lip = cygwin_inet_addr (ip);
	      lnp = cygwin_inet_addr (np);
	      sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	      sa->sin_addr.s_addr = lip & lnp | ~lnp;
	      sa->sin_family = AF_INET;
	      sa->sin_port = 0;
	      break;
	    case SIOCGIFNETMASK:
	      sa = (struct sockaddr_in *) &ifr->ifr_netmask;
	      sa->sin_addr.s_addr = cygwin_inet_addr (np);
	      sa->sin_family = AF_INET;
	      sa->sin_port = 0;
	      break;
	    case SIOCGIFHWADDR:
	      so = &ifr->ifr_hwaddr;
	      memset (so->sa_data, 0, IFHWADDRLEN);
	      so->sa_family = AF_INET;
	      break;
	    case SIOCGIFMETRIC:
	      ifr->ifr_metric = 1;
	      break;
	    case SIOCGIFMTU:
	      ifr->ifr_mtu = 1500;
	      break;
d1756 2
a1757 2
		  0, KEY_READ, &subkey) != ERROR_SUCCESS)
      {
d1761 1
a1761 1
      }
d1764 4
a1767 4
		  NULL, (unsigned char *) adapter,
		  (size = sizeof adapter, &size)) == ERROR_SUCCESS
	      && strcasematch (adapter, "MS$PPP"))
      {
d1771 1
a1771 1
      }
d1773 1
a1773 1
      {
d1777 1
a1777 1
      }
d1817 35
a1851 35
    case SIOCGIFCONF:
    case SIOCGIFADDR:
      sa = (struct sockaddr_in *) &ifr->ifr_addr;
      sa->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      sa->sin_family = AF_INET;
      sa->sin_port = 0;
      break;
    case SIOCGIFBRDADDR:
      lip = htonl (INADDR_LOOPBACK);
      lnp = cygwin_inet_addr ("255.0.0.0");
      sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
      sa->sin_addr.s_addr = lip & lnp | ~lnp;
      sa->sin_family = AF_INET;
      sa->sin_port = 0;
      break;
    case SIOCGIFNETMASK:
      sa = (struct sockaddr_in *) &ifr->ifr_netmask;
      sa->sin_addr.s_addr = cygwin_inet_addr ("255.0.0.0");
      sa->sin_family = AF_INET;
      sa->sin_port = 0;
      break;
    case SIOCGIFHWADDR:
      ifr->ifr_hwaddr.sa_family = AF_INET;
      memset (ifr->ifr_hwaddr.sa_data, 0, IFHWADDRLEN);
      break;
    case SIOCGIFMETRIC:
      ifr->ifr_metric = 1;
      break;
    case SIOCGIFMTU:
      /* This funny value is returned by `ifconfig lo' on Linux 2.2 kernel. */
      ifr->ifr_mtu = 3924;
      break;
    default:
      set_errno (EINVAL);
      return -1;
d1855 1
d1871 1
a1871 1
	       char *remuser, char *cmd, int *fd2p)
d1884 1
d1891 1
d1925 1
d1946 1
a1946 1
	       char *password, char *cmd, int *fd2p)
d1959 1
d1965 1
d2024 1
d2105 1
a2105 2
  if (connect (outsock, (struct sockaddr *) &sock_in,
					   sizeof (sock_in)) < 0)
d2133 1
a2133 1
					       sizeof (sock_out)) < 0)
@


1.127
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d882 1
a882 1
  debug_printf ("name %s\n", name);
@


1.126
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d921 1
a921 1
      && !(dst->h_addr_list = dup_addr_list(src->h_addr_list, src->h_length)))
@


1.125
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d73 1
a73 1
  switch (WSAWaitForMultipleEvents(2, ev, FALSE, WSA_INFINITE, FALSE))
d77 1
a77 1
      if (WSAGetOverlappedResult(socket, &ovr, &len, FALSE, flags))
d84 1
a84 1
	  WSAGetOverlappedResult(socket, &ovr, &len, TRUE, flags);
d420 1
a420 1
      if (!(dst[cnt] = (char *) malloc(size)))
d422 1
a422 1
      memcpy(dst[cnt], src[cnt], size);
d1232 2
a1233 2
  if (GetIfTable(NULL, &siz_if_table, TRUE) == ERROR_INSUFFICIENT_BUFFER &&
      GetIpAddrTable(NULL, &siz_ip_table, TRUE) == ERROR_INSUFFICIENT_BUFFER &&
d1236 2
a1237 2
      !GetIfTable(ift, &siz_if_table, TRUE) &&
      !GetIpAddrTable(ipt, &siz_ip_table, TRUE))
d1906 1
a1906 1
  if (__check_null_invalid_struct_errno (sb, 2 * sizeof(int)))
@


1.124
log
@	* fhandler.h (fhandler_socket::read): Remove method.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::readv): New method.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Add new optional argument.
	(fhandler_socket::sendmsg): Ditto.
	* fhandler.cc (fhandler_socket::read): Remove method.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::readv): New method.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Use win32's scatter/gather IO where
	possible.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (cygwin_recvmsg): Check the msghdr's iovec fields.
	(cygwin_sendmsg): Ditto.  Add omitted sigframe.
@
text
@d727 1
a727 1
      			(int *) optlen);
d2140 1
a2140 1
  else 
@


1.123
log
@	* fhandler_socket.cc (fhandler_socket::check_peer_secret_event):
	Fix strace message.
	(fhandler_socket::connect): Remove sigframe.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::ioctl): Ditto.
	* ioctl.cc (ioctl): Add sigframe.
	*net.cc (cygwin_sendto): Ditto.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvfrom): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_shutdown): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_accept): Ditto.  Improve strace message.
	(cygwin_getsockname): Ditto.  Ditto.
	(cygwin_recvmsg): Ditto.  Ditto.
	(cygwin_sendmsg): Fix strace message.
@
text
@d2115 5
a2119 1
    res = fh->recvmsg (msg, flags);
d2130 2
d2140 6
a2145 2
  else
    res = fh->sendmsg (msg, flags);
@


1.122
log
@	* fhandler.h (fhandler_socket::recvfrom): Fix prototype.
	(fhandler_socket::sendto): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::sendto): Ditto.
	* include/sys/socket.h (recv): Fix prototype.
	(recvfrom): Ditto.
	(send): Ditto.
	(sendto): Ditto.
	* net.cc (cygwin_sendto): Ditto. Improve strace message
	(cygwin_recvfrom): Ditto.  Ditto.
	(cygwin_setsockopt): Improve strace message.
	(cygwin_getsockopt): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_bind): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_recv): Fix prototype.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Improve strace message.
	(cygwin_sendmsg): Ditto.
@
text
@d571 2
d594 2
d749 2
d1011 2
d1022 1
a1022 1
  syscall_printf ("%d = accept (%d, %p, %d)", res, fd, peer, len);
d1047 2
d1058 1
a1058 1
  syscall_printf ("%d = getsockname (%d, %p, %d)", res, fd, addr, namelen);
d1083 2
d1148 2
d2104 2
d2117 1
a2117 1
  syscall_printf ("%d = recvmsg (%d, %p, %d)", res, fd, msg, flags);
d2137 1
a2137 1
  syscall_printf ("%d = recvmsg (%d, %p, %d)", res, fd, msg, flags);
@


1.121
log
@	* fhandler.h (fhandler_socket::recv): Remove method.
	(fhandler_socket::send): Ditto.
	* fhandler_socket.cc (fhandler_socket::recv): Ditto.
	(fhandler_socket::send): Ditto.
	(fhandler_socket::read): Delegate to fhandler_socket::recvfrom.
	(fhandler_socket::write): Delegate to fhandler_socket::sendto.
	(fhandler_socket::sendto): Check for null `to' address.
	* net.cc (cygwin_sendto): Check for zero request length.
	(cygwin_recvfrom): Ditto.  Fix signature, use void *buf.
	(cygwin_recv): Delegate to cygwin_recvfrom.
	(cygwin_send): Delegate to cygwin_sendto.
@
text
@d567 1
a567 1
cygwin_sendto (int fd, const void *buf, int len, unsigned int flags,
d580 2
a581 1
  syscall_printf ("%d = sendto (%d, %x, %x, %x)", res, fd, buf, len, flags);
d588 2
a589 2
cygwin_recvfrom (int fd, void *buf, int len, int flags, struct sockaddr *from,
		 int *fromlen)
d603 2
a604 1
  syscall_printf ("%d = recvfrom (%d, %x, %x, %x)", res, fd, buf, len, flags);
d667 1
a667 1
  syscall_printf ("%d = setsockopt (%d, %d, %x (%s), %x, %d)",
d735 1
a735 1
  syscall_printf ("%d = getsockopt (%d, %d, %x (%s), %x, %d)",
d752 1
a752 1
  syscall_printf ("%d = connect (%d, %x, %x)", res, fd, name, namelen);
d1014 1
a1014 1
  syscall_printf ("%d = accept (%d, %x, %x)", res, fd, peer, len);
d1030 1
a1030 1
  syscall_printf ("%d = bind (%d, %x, %d)", res, fd, my_addr, addrlen);
d1048 1
a1048 1
  syscall_printf ("%d = getsockname (%d, %x, %d)", res, fd, addr, namelen);
d1151 1
a1151 1
cygwin_recv (int fd, void *buf, int len, unsigned int flags)
d1158 1
a1158 1
cygwin_send (int fd, const void *buf, int len, unsigned int flags)
d2101 1
a2101 1
  syscall_printf ("%d = recvmsg (%d, %x, %x)", res, fd, msg, flags);
d2121 1
a2121 1
  syscall_printf ("%d = recvmsg (%d, %x, %x)", res, fd, msg, flags);
@


1.120
log
@	* winsup.h (__check_null_invalid_struct): Make ptr argument non-const.
	(__check_null_invalid_struct_errno): Ditto.
	* miscfuncs.cc (__check_null_invalid_struct): Ditto.
	(__check_null_invalid_struct_errno): Ditto.
	(__check_invalid_read_ptr_errno): Remove superfluous cast.
	* net.cc (get): Set appropriate errno if fd is not a socket.
	(cygwin_sendto): Fix parameter checking.
	(cygwin_recvfrom): Ditto.
	(cygwin_setsockopt): Ditto.
	(cygwin_getsockopt): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_gethostbyaddr): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_bind): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_listen): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_send): Ditto.
	(cygwin_shutdown): Ditto.  Move sigframe to fhandler_socket.
	(cygwin_recvmsg): Fix parameter checking.  Add tracing.
	(cygwin_sendmsg): Ditto.
	* fhandler_socket.cc (fhandler_socket::shutdown): Add sigframe.
	* resource.cc (setrlimit): Fix parameter checking.
@
text
@d577 1
a577 1
  else
d587 1
a587 1
cygwin_recvfrom (int fd, char *buf, int len, int flags, struct sockaddr *from,
d593 1
a593 1
  if (__check_null_invalid_struct_errno (buf, (unsigned) len)
d599 1
a599 1
  else
d1151 1
a1151 10
  int res;
  fhandler_socket *fh = get (fd);

  if (__check_null_invalid_struct_errno (buf, len) || !fh)
    res = -1;
  else
    res = fh->recv (buf, len, flags);

  syscall_printf ("%d = recv (%d, %x, %x, %x)", res, fd, buf, len, flags);
  return res;
d1158 1
a1158 10
  int res;
  fhandler_socket *fh = get (fd);

  if ((len &&__check_invalid_read_ptr_errno (buf, len)) || !fh)
    res = -1;
  else
    res = fh->send (buf, len, flags);

  syscall_printf ("%d = send (%d, %x, %d, %x)", res, fd, buf, len, flags);
  return res;
@


1.119
log
@	* fhandler.h (fhandler_base::get_r_no_interrupt): Make non-virtual.
	* net.cc (fdsock): Call set_r_no_interrupt.
@
text
@d104 1
a104 1
get (int fd)
d110 5
a114 1
  return cfd->is_socket ();
d574 1
a574 1
      || __check_null_invalid_struct_errno (to, tolen)
d594 3
a596 2
      || check_null_invalid_struct_errno (fromlen)
      || (from && __check_null_invalid_struct_errno (from, (unsigned) *fromlen))
d612 1
a613 1
  int res = -1;
d616 2
a617 1
  if ((!optval || !__check_invalid_read_ptr_errno (optval, optlen)) && fh)
d619 31
a649 34
      /* For the following debug_printf */
      switch (optname)
	{
	case SO_DEBUG:
	  name="SO_DEBUG";
	  break;
	case SO_ACCEPTCONN:
	  name="SO_ACCEPTCONN";
	  break;
	case SO_REUSEADDR:
	  name="SO_REUSEADDR";
	  break;
	case SO_KEEPALIVE:
	  name="SO_KEEPALIVE";
	  break;
	case SO_DONTROUTE:
	  name="SO_DONTROUTE";
	  break;
	case SO_BROADCAST:
	  name="SO_BROADCAST";
	  break;
	case SO_USELOOPBACK:
	  name="SO_USELOOPBACK";
	  break;
	case SO_LINGER:
	  name="SO_LINGER";
	  break;
	case SO_OOBINLINE:
	  name="SO_OOBINLINE";
	  break;
	case SO_ERROR:
	  name="SO_ERROR";
	  break;
	}
d651 4
d674 1
a675 1
  int res = -1;
d677 3
a679 4
  if (!check_null_invalid_struct_errno (optlen)
      && (!optval
          || !__check_null_invalid_struct_errno (optval, (unsigned) *optlen))
      && fh)
d681 31
a711 34
      /* For the following debug_printf */
      switch (optname)
	{
	case SO_DEBUG:
	  name="SO_DEBUG";
	  break;
	case SO_ACCEPTCONN:
	  name="SO_ACCEPTCONN";
	  break;
	case SO_REUSEADDR:
	  name="SO_REUSEADDR";
	  break;
	case SO_KEEPALIVE:
	  name="SO_KEEPALIVE";
	  break;
	case SO_DONTROUTE:
	  name="SO_DONTROUTE";
	  break;
	case SO_BROADCAST:
	  name="SO_BROADCAST";
	  break;
	case SO_USELOOPBACK:
	  name="SO_USELOOPBACK";
	  break;
	case SO_LINGER:
	  name="SO_LINGER";
	  break;
	case SO_OOBINLINE:
	  name="SO_OOBINLINE";
	  break;
	case SO_ERROR:
	  name="SO_ERROR";
	  break;
	}
d713 7
d745 1
a745 4
  if (__check_invalid_read_ptr_errno (name, namelen))
    return -1;

  if (!fh)
d980 1
a980 1
  if (__check_null_invalid_struct_errno (addr, len))
d1002 2
a1003 4
  if (peer != NULL
      && (check_null_invalid_struct_errno (len)
	  || __check_null_invalid_struct_errno (peer, (unsigned) *len)))
    return -1;
d1005 5
a1009 4
  int res = -1;

  fhandler_socket *fh = get (fd);
  if (fh)
d1020 2
a1021 2
  if (__check_null_invalid_struct_errno (my_addr, addrlen))
    return -1;
d1023 3
a1025 4
  int res = -1;

  fhandler_socket *fh = get (fd);
  if (fh)
d1036 3
d1040 4
a1043 7
      || __check_null_invalid_struct_errno (addr, (unsigned) *namelen))
    return -1;

  int res = -1;

  fhandler_socket *fh = get (fd);
  if (fh)
d1054 2
a1055 1
  int res = -1;
d1057 3
a1059 2
  fhandler_socket *fh = get (fd);
  if (fh)
d1070 2
a1071 2
  int res = -1;
  sigframe thisframe (mainthread);
d1073 3
a1075 2
  fhandler_socket *fh = get (fd);
  if (fh)
d1133 2
a1134 1
  int res = -1;
d1137 4
a1140 5
      || __check_null_invalid_struct_errno (name, (unsigned) *len))
    return -1;

  fhandler_socket *fh = get (fd);
  if (fh)
a1143 1

a1159 1

d1170 1
a1170 1
  if (__check_invalid_read_ptr_errno (buf, len) || !fh)
a1175 1

d2103 1
a2103 1
cygwin_recvmsg (int s, struct msghdr *msg, int flags)
d2105 11
a2115 2
  if (check_null_invalid_struct_errno (msg))
    return -1;
d2117 2
a2118 7
  fhandler_socket *fh = get (s);
  if (!fh)
    {
      set_errno (EINVAL);
      return -1;
    }
  return fh->recvmsg (msg, flags);
d2123 1
a2123 1
cygwin_sendmsg (int s, const struct msghdr *msg, int flags)
d2125 11
a2135 2
    if (__check_invalid_read_ptr_errno (msg, sizeof msg))
      return -1;
d2137 2
a2138 7
    fhandler_socket *fh = get (s);
    if (!fh)
      {
        set_errno (EINVAL);
	return -1;
      }
    return fh->sendmsg (msg, flags);
@


1.118
log
@	* fhandler.h (fhandler_socket::is_unconnected): Constify.
	(fhandler_socket::is_connect_pending): Ditto.
	(fhandler_socket::is_connected): Ditto.
	(fhandler_socket::set_connect_state): New method.
	(struct select_record): Add member `except_on_write'.
	(select_record::select_record): Initialize all bool values to `false'.
	* fhandler_socket.cc: Use set_connect_state() method throughout.
	(fhandler_socket::connect): Set state always to connected if connection
	isn't pending.
	* net.cc (cygwin_getsockopt): Revert erroneous previous patch.
	* select.cc (set_bits): Check for `except_on_write'.  Set fd in
	write_fds if set.  Set connect state to connected if fd has been
	returned by WINSOCK_SELECT.
	(peek_socket): Check for `except_on_write'.
	(start_thread_socket): Ditto.
	(fhandler_socket::select_write): Don't set `write_ready' if connect
	is pending.  Set `except_on_write' if connect is pending.
@
text
@d514 1
@


1.117
log
@	* fhandler.h (UNCONNECTED): New define.
	(CONNECT_PENDING): Ditto.
	(CONNECTED): Ditto.
	(class fhandler_socket): Add member `had_connect_or_listen'.
	Add member functions `is_unconnected', `is_connect_pending' and
	`is_connected'.
	* fhandler_socket.cc (fhandler_socket::connect): Set member
	`had_connect_or_listen' according to return code of WinSock
	call.
	(fhandler_socket::listen): Ditto.
	* net.cc (cygwin_getsockopt): Modify SO_ERROR return value in
	case of socket with pending connect().
	* select.cc (peek_socket): Only add socket to matching fd_set
	if it's not "ready".  Call WINSOCK_SELECT only if at least one
	socket is in one of the fd_sets.
	(start_thread_socket): Only add socket to matching fd_set
	if it's not "ready".
	(fhandler_socket::select_write): Set write_ready to true also
	if socket isn't connected or listening.
@
text
@a714 2
	  if (!*e && fh->is_connect_pending ())
	    *e = WSAEINPROGRESS;
@


1.116
log
@* net.cc (cygwin_getpeername): Defend against NULL pointer dereference.
@
text
@d715 2
@


1.115
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d1134 1
a1134 1
  syscall_printf ("%d = getpeername %d", res, fh->get_socket ());
@


1.114
log
@	* fhandler.h (fhandler_socket::bind): Add method definition.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::shutdown): Ditto.
	* fhandler_socket.cc (get_inet_addr): Move here from net.cc.
	(fhandler_socket::bind): New method.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::shutdown): Ditto.
	* net.cc: Various formatting cleanups throughout.
	(get_inet_addr): Move to fhandler_socket.cc.
	(cygwin_bind): Move base functionality to appropriate fhandler_socket
	method.
	(cygwin_connect): Ditto.
	(cygwin_listen): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendto): Ditto.
	(cygwin_sendmsg): Ditto.
	(cygwin_shutdown): Ditto.
@
text
@d513 1
a513 1
  fh->set_flags (O_RDWR, O_BINARY);
@


1.113
log
@* include/sys/strace.h (strace): Avoid use of constructor.
@
text
@a35 1
#include <sys/uio.h>
a559 46
/* cygwin internal: map sockaddr into internet domain address */

static int get_inet_addr (const struct sockaddr *in, int inlen,
			   struct sockaddr_in *out, int *outlen, int* secret = 0)
{
  int secret_buf [4];
  int* secret_ptr = (secret ? : secret_buf);

  if (in->sa_family == AF_INET)
    {
      *out = * (sockaddr_in *)in;
      *outlen = inlen;
      return 1;
    }
  else if (in->sa_family == AF_LOCAL)
    {
      int fd = _open (in->sa_data, O_RDONLY);
      if (fd == -1)
	return 0;

      int ret = 0;
      char buf[128];
      memset (buf, 0, sizeof buf);
      if (read (fd, buf, sizeof buf) != -1)
	{
	  sockaddr_in sin;
	  sin.sin_family = AF_INET;
	  sscanf (buf + strlen (SOCKET_COOKIE), "%hu %08x-%08x-%08x-%08x",
		  &sin.sin_port,
		  secret_ptr, secret_ptr + 1, secret_ptr + 2, secret_ptr + 3);
	  sin.sin_port = htons (sin.sin_port);
	  sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  *out = sin;
	  *outlen = sizeof sin;
	  ret = 1;
	}
      _close (fd);
      return ret;
    }
  else
    {
      set_errno (EAFNOSUPPORT);
      return 0;
    }
}

d562 2
a563 6
cygwin_sendto (int fd,
	       const void *buf,
	       int len,
	       unsigned int flags,
	       const struct sockaddr *to,
	       int tolen)
d566 1
a566 3
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;
  fhandler_socket *h = get (fd);
d570 1
a570 1
      || !h)
d573 1
a573 33
    {
      sockaddr_in sin;
      sigframe thisframe (mainthread);

      if (get_inet_addr (to, tolen, &sin, &tolen) == 0)
	return -1;

      if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
	{
	  debug_printf ("Fallback to winsock 1 sendto call");
	  if ((res = sendto (h->get_socket (), (const char *) buf, len, flags,
			     (sockaddr *) &sin, tolen)) == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	}
      else
	{
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSASendTo (h->get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
			 (sockaddr *) &sin, tolen, ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
	}
    }
d582 2
a583 6
cygwin_recvfrom (int fd,
		   char *buf,
		   int len,
		   int flags,
		   struct sockaddr *from,
		   int *fromlen)
d586 1
a586 3
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;
  fhandler_socket *h = get (fd);
d591 1
a591 1
      || !h)
d594 1
a594 29
    {
      sigframe thisframe (mainthread);

      if (h->is_nonblocking () ||!(ovr = wsock_evt.prepare ()))
	{
	  debug_printf ("Fallback to winsock 1 recvfrom call");
	  if ((res = recvfrom (h->get_socket (), buf, len, flags, from, fromlen))
	      == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	}
      else
	{
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSARecvFrom (h->get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
			   from, fromlen, ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
	}
    }
d603 2
a604 5
cygwin_setsockopt (int fd,
		     int level,
		     int optname,
		     const void *optval,
		     int optlen)
d606 1
a606 1
  fhandler_socket *h = get (fd);
d610 1
a610 1
  if ((!optval || !__check_invalid_read_ptr_errno (optval, optlen)) && h)
d647 2
a648 2
      res = setsockopt (h->get_socket (), level, optname,
				     (const char *) optval, optlen);
d664 1
a664 5
cygwin_getsockopt (int fd,
		     int level,
		     int optname,
		     void *optval,
		     int *optlen)
d666 1
a666 1
  fhandler_socket *h = get (fd);
d670 3
a672 2
      && (!optval || !__check_null_invalid_struct_errno (optval, (unsigned) *optlen))
      && h)
d709 2
a710 2
      res = getsockopt (h->get_socket (), level, optname,
				       (char *) optval, (int *) optlen);
d729 1
a729 3
cygwin_connect (int fd,
		  const struct sockaddr *name,
		  int namelen)
d732 1
a732 6
  BOOL secret_check_failed = FALSE;
  BOOL in_progress = FALSE;
  fhandler_socket *sock = get (fd);
  sockaddr_in sin;
  int secret [4];
  sigframe thisframe (mainthread);
d737 1
a737 4
  if (get_inet_addr (name, namelen, &sin, &namelen, secret) == 0)
    return -1;

  if (!sock)
d740 1
a740 31
    {
      res = connect (sock->get_socket (), (sockaddr *) &sin, namelen);
      if (res)
	{
	  /* Special handling for connect to return the correct error code
	     when called on a non-blocking socket. */
	  if (sock->is_nonblocking ())
	    {
	      DWORD err = WSAGetLastError ();
	      if (err == WSAEWOULDBLOCK || err == WSAEALREADY)
		{
		  WSASetLastError (WSAEINPROGRESS);
		  in_progress = TRUE;
		}
	      else if (err == WSAEINVAL)
		WSASetLastError (WSAEISCONN);
	    }
	  set_winsock_errno ();
	}
      if (sock->get_addr_family () == AF_LOCAL &&
	  sock->get_socket_type () == SOCK_STREAM)
	{
	  if (!res || in_progress)
	    {
	      if (!sock->create_secret_event (secret))
		{
		  secret_check_failed = TRUE;
		}
	      else if (in_progress)
		sock->signal_secret_event ();
	    }
d742 1
a742 8
	  if (!secret_check_failed && !res)
	    {
	      if (!sock->check_peer_secret_event (&sin, secret))
		{
		  debug_printf ( "accept from unauthorized server" );
		  secret_check_failed = TRUE;
		}
	   }
a743 10
	  if (secret_check_failed)
	    {
	      sock->close_secret_event ();
	      if (res)
		closesocket (res);
	      set_errno (ECONNREFUSED);
	      res = -1;
	    }
	}
    }
a999 3
  BOOL secret_check_failed = FALSE;
  BOOL in_progress = FALSE;
  sigframe thisframe (mainthread);
d1001 3
a1003 58
  fhandler_socket *sock = get (fd);
  if (sock)
    {
      /* Allows NULL peer and len parameters. */
      struct sockaddr_in peer_dummy;
      int len_dummy;
      if (!peer)
	peer = (struct sockaddr *) &peer_dummy;
      if (!len)
	{
	  len_dummy = sizeof (struct sockaddr_in);
	  len = &len_dummy;
	}

      /* accept on NT fails if len < sizeof (sockaddr_in)
       * some programs set len to
       * sizeof (name.sun_family) + strlen (name.sun_path) for UNIX domain
       */
      if (len && ((unsigned) *len < sizeof (struct sockaddr_in)))
	*len = sizeof (struct sockaddr_in);

      res = accept (sock->get_socket (), peer, len);  // can't use a blocking call inside a lock

      if ((SOCKET) res == (SOCKET) INVALID_SOCKET &&
	  WSAGetLastError () == WSAEWOULDBLOCK)
	in_progress = TRUE;

      if (sock->get_addr_family () == AF_LOCAL &&
	  sock->get_socket_type () == SOCK_STREAM)
	{
	  if ((SOCKET) res != (SOCKET) INVALID_SOCKET || in_progress)
	    {
	      if (!sock->create_secret_event ())
		secret_check_failed = TRUE;
	      else if (in_progress)
		sock->signal_secret_event ();
	    }

	  if (!secret_check_failed &&
	      (SOCKET) res != (SOCKET) INVALID_SOCKET)
	    {
	      if (!sock->check_peer_secret_event ((struct sockaddr_in*) peer))
		{
		  debug_printf ("connect from unauthorized client");
		  secret_check_failed = TRUE;
		}
	    }

	  if (secret_check_failed)
	    {
	      sock->close_secret_event ();
	      if ((SOCKET) res != (SOCKET) INVALID_SOCKET)
		closesocket (res);
	      set_errno (ECONNABORTED);
	      res = -1;
	      goto done;
	    }
	}
a1004 17

      cygheap_fdnew res_fd;
      if (res_fd < 0)
	/* FIXME: what is correct errno? */;
      else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
	set_winsock_errno ();
      else
	{
	  fhandler_socket* res_fh = fdsock (res_fd, sock->get_name (), res);
	  if (sock->get_addr_family () == AF_LOCAL)
	    res_fh->set_sun_path (sock->get_sun_path ());
	  res_fh->set_addr_family (sock->get_addr_family ());
	  res_fh->set_socket_type (sock->get_socket_type ());
	  res = res_fd;
	}
    }
 done:
d1018 3
a1020 45
  fhandler_socket *sock = get (fd);
  if (sock)
    {
      if (my_addr->sa_family == AF_LOCAL)
	{
#define un_addr ((struct sockaddr_un *) my_addr)
	  struct sockaddr_in sin;
	  int len = sizeof sin;
	  int fd;

	  if (strlen (un_addr->sun_path) >= UNIX_PATH_LEN)
	    {
	      set_errno (ENAMETOOLONG);
	      goto out;
	    }
	  sin.sin_family = AF_INET;
	  sin.sin_port = 0;
	  sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  if (bind (sock->get_socket (), (sockaddr *) &sin, len))
	    {
	      syscall_printf ("AF_LOCAL: bind failed %d", get_errno ());
	      set_winsock_errno ();
	      goto out;
	    }
	  if (getsockname (sock->get_socket (), (sockaddr *) &sin, &len))
	    {
	      syscall_printf ("AF_LOCAL: getsockname failed %d", get_errno ());
	      set_winsock_errno ();
	      goto out;
	    }

	  sin.sin_port = ntohs (sin.sin_port);
	  debug_printf ("AF_LOCAL: socket bound to port %u", sin.sin_port);

	  /* bind must fail if file system socket object already exists
	     so _open () is called with O_EXCL flag. */
	  fd = _open (un_addr->sun_path,
		      O_WRONLY | O_CREAT | O_EXCL | O_BINARY,
		      0);
	  if (fd < 0)
	    {
	      if (get_errno () == EEXIST)
		set_errno (EADDRINUSE);
	      goto out;
	    }
a1021 31
	  sock->set_connect_secret ();

	  char buf[sizeof (SOCKET_COOKIE) + 80];
	  __small_sprintf (buf, "%s%u ", SOCKET_COOKIE, sin.sin_port);
	  sock->get_connect_secret (strchr (buf, '\0'));
	  len = strlen (buf) + 1;

	  /* Note that the terminating nul is written.  */
	  if (_write (fd, buf, len) != len)
	    {
	      save_errno here;
	      _close (fd);
	      _unlink (un_addr->sun_path);
	    }
	  else
	    {
	      _close (fd);
	      chmod (un_addr->sun_path,
		(S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO) & ~cygheap->umask);
	      sock->set_sun_path (un_addr->sun_path);
	      res = 0;
	    }
#undef un_addr
	}
      else if (bind (sock->get_socket (), my_addr, addrlen))
	set_winsock_errno ();
      else
	res = 0;
    }

out:
d1036 4
a1039 30
  fhandler_socket *sock = get (fd);
  if (sock)
    {
      if (sock->get_addr_family () == AF_LOCAL)
	{
	  struct sockaddr_un *sun = (struct sockaddr_un *) addr;
	  memset (sun, 0, *namelen);
	  sun->sun_family = AF_LOCAL;

	  if (!sock->get_sun_path ())
	    sun->sun_path[0] = '\0';
	  else
	    /* According to SUSv2 "If the actual length of the address is
	       greater than the length of the supplied sockaddr structure, the
	       stored address will be truncated."  We play it save here so
	       that the path always has a trailing 0 even if it's truncated. */
	    strncpy (sun->sun_path, sock->get_sun_path (),
		     *namelen - sizeof *sun + sizeof sun->sun_path - 1);

	  *namelen = sizeof *sun - sizeof sun->sun_path
		     + strlen (sun->sun_path) + 1;
	  res = 0;
	}
      else
	{
	  res = getsockname (sock->get_socket (), addr, namelen);
	  if (res)
	    set_winsock_errno ();
	}
    }
d1050 3
a1053 7
  fhandler_socket *sock = get (fd);
  if (sock)
    {
      res = listen (sock->get_socket (), backlog);
      if (res)
	set_winsock_errno ();
    }
d1065 4
a1068 21
  fhandler_socket *sock = get (fd);
  if (sock)
    {
      res = shutdown (sock->get_socket (), how);
      if (res)
	set_winsock_errno ();
      else
	switch (how)
	  {
	  case SHUT_RD:
	    sock->set_shutdown_read ();
	    break;
	  case SHUT_WR:
	    sock->set_shutdown_write ();
	    break;
	  case SHUT_RDWR:
	    sock->set_shutdown_read ();
	    sock->set_shutdown_write ();
	    break;
	  }
    }
d1124 2
a1125 1
  int res;
d1130 3
a1132 1
  fhandler_socket *h = get (fd);
d1134 1
a1134 8
  if (!h)
    res = -1;
  else
    {
      res = getpeername (h->get_socket (), name, len);
      if (res)
	set_winsock_errno ();
    }
a1135 1
  debug_printf ("%d = getpeername %d", res, h->get_socket ());
d2097 1
a2097 1
cygwin_recvmsg(int s, struct msghdr *msg, int flags)
d2099 2
a2100 20
    int ret, nb;
    size_t tot = 0;
    int i;
    char *buf, *p;
    struct iovec *iov = msg->msg_iov;

    for(i = 0; i < msg->msg_iovlen; ++i)
	tot += iov[i].iov_len;
    buf = (char *) malloc(tot);
    if (tot != 0 && buf == NULL)
      {
	errno = ENOMEM;
	return -1;
      }
    nb = ret = cygwin_recvfrom (s, buf, tot, flags,
      (struct sockaddr *) msg->msg_name, (int *) &msg->msg_namelen);
    p = buf;
    while (nb > 0)
      {
	ssize_t cnt = min(nb, iov->iov_len);
d2102 7
a2108 7
	memcpy (iov->iov_base, p, cnt);
	p += cnt;
	nb -= cnt;
	++iov;
      }
    free(buf);
    return ret;
d2113 1
a2113 1
cygwin_sendmsg(int s, const struct msghdr *msg, int flags)
d2115 5
a2119 10
    int ret;
    size_t tot = 0;
    int i;
    char *buf, *p;
    struct iovec *iov = msg->msg_iov;

    for(i = 0; i < msg->msg_iovlen; ++i)
	tot += iov[i].iov_len;
    buf = (char *) malloc(tot);
    if (tot != 0 && buf == NULL)
d2121 1
a2121 1
	errno = ENOMEM;
d2124 1
a2124 10
    p = buf;
    for (i = 0; i < msg->msg_iovlen; ++i)
      {
	memcpy (p, iov[i].iov_base, iov[i].iov_len);
	p += iov[i].iov_len;
      }
    ret = cygwin_sendto (s, buf, tot, flags,
      (struct sockaddr *) msg->msg_name, msg->msg_namelen);
    free (buf);
    return ret;
@


1.112
log
@	* fhandler.h (fhandler_socket::fixup_after_fork): Revert patch from
	2002-06-04.
	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Ditto.
	(fhandler_socket::dup): Ditto.
	* net.cc (fdsock): Make sockets explicitely noninheritable on NT.
@
text
@d1126 1
a1126 1
      tmp_addr_list[0] = (char *)tmp_addr;
@


1.111
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d504 6
@


1.110
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@a23 1
#include <fcntl.h>
d508 1
a508 1
  fh->set_flags (O_RDWR);
@


1.109
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d546 1
a546 1
          fh->set_socket_type (type);
d1626 1
a1626 1
		        ++*tok;
d2446 1
a2446 1
      		   insock);
@


1.108
log
@fix formatting
@
text
@a32 1
#include "sync.h"
@


1.107
log
@* net.cc (getdomainname): Change second argument of getdomainname to size_t.
* fhandler_proc.cc (proc_listing): Add '.' and '..' to directory listing.
(fhandler_proc::open): Change use of mode to flags.  If the file does not exist
already, fail with EROFS if O_CREAT flag is set.  Change EROFS error to EACCES
error when writing to a file.  Use cmalloc to allocate memory for filebuf.
(fhandler_proc::close): Use cfree to free filebuf.
(fhandler_proc::get_proc_fhandler): Properly detect attempts to access unknown
subdir.
* fhandler_process.cc (process_listing): Add '.' and '..' to directory listing.
(fhandler_process::open): Use cmalloc to allocate memory for filebuf.
(fhandler_process::close): Use cfree to free filebuf.
* fhandler_registry.cc (registry_listing): Add .  and '..' to directory
listing.
(fhandler_registry::open): Move check for open for writing before open_key.
Use cmalloc to allocate memory for filebuf.
(fhandler_registry::close): Use cfree to free filebuf.
(fhandler_registry::telldir): Use lower 16 bits of __d_position as position in
directory.
(fhandler_registry::seekdir): Ditto.
* fhandler_virtual.cc (fhandler_virtual::write): Change EROFS error to EACCES
error.
(fhandler_virtual::open): Set the NOHANDLE flag.
(fhandler_virtual::dup): Add call to fhandler_base::dup.  Allocate child's
filebuf using cmalloc.  Copy filebuf from parent to child.
(fhandler_virtual::close): Use cfree to free filebuf.
(fhandler_virtual::~fhandler_virtual): Ditto.
(from Chris Faylor <cgf@@redhat.com>).
(fhandler_registry::readdir): Add support for '.' and '..' files in
subdirectories of /proc/registry.
* path.cc (path_conv::check): Do not return ENOENT if a file is not found in
/proc.
@
text
@d2486 2
a2487 1
    if (tot != 0 && buf == NULL) {
d2490 1
a2490 1
    }
d2494 2
a2495 1
    while (nb > 0) {
d2502 1
a2502 1
    }
d2520 2
a2521 1
    if (tot != 0 && buf == NULL) {
d2524 1
a2524 1
    }
d2526 2
a2527 1
    for (i = 0; i < msg->msg_iovlen; ++i) {
d2530 1
a2530 1
    }
@


1.106
log
@	* net.cc (cygwin_accept): Set socket type for accepted socket.
	(socketpair): Set socket type for both sockets.

	From Egor Duda <deo@@logos-m.ru>:

	* fhandler.h (class fhandler_socket): New member to store socket type.
	(fhandler_socket::get_socket_type): Access it.
	(fhandler_socket::set_socket_type): Ditto.
	* net.cc (cygwin_socket): Store socket type.
	(cygwin_connect): Disable security checks for connectionless sockets.
	(cygwin_accept): Ditto.
@
text
@d1553 1
a1553 1
getdomainname (char *domain, int len)
@


1.105
log
@* pinfo.cc (pinfo::init): Use PID_ALLPIDS flag to control when a redirected
block should be marked as nonexistent.
(winpids::add): Use PID_ALLPIDS when looking for all pids.
* cygwin.h (PID_ALLPIDS): New enum element.
@
text
@d521 1
d543 6
a548 1
      fdsock (fd, name, soc)->set_addr_family (af);
d890 2
a891 1
      if (sock->get_addr_family () == AF_LOCAL)
d1209 2
a1210 1
      if (sock->get_addr_family () == AF_LOCAL)
d1253 1
d2278 1
a2429 1
      fhandler_socket *fh;
d2436 1
d2442 1
d2446 8
a2453 4
      fdsock (sb[0], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
	      insock)->set_addr_family (AF_INET);
      fdsock (sb[1], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
	      outsock)->set_addr_family (AF_INET);
@


1.104
log
@* sync.h (new_muto): Just accept an argument which denotes the name of the
muto.  Use this argument to construct static storage.
* cygheap.cc (cygheap_init): Reflect above change.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* cygheap.h (cwdstuff): Change name of lock element to make it less generic.
* path.cc (cwdstuff::get_hash): Ditto.
(cwdstuff::get_initial): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* sigproc.cc (proc_subproc): Ditto.
* debug.cc (lock_debug): Change to method.  Use method rather than macro
throughout.
* tty.h (tty_min::kill_pgrp): Declare new method.
* fhandler_termios.cc (tty_min::kill_pgrp): New method.
(fhandler_termios::line_edit): Use new method for killing process.
* dcrt0.cc (do_exit): Ditto.
* dtable.cc (dtable::get_debugger_info): New method for inheriting dtable info
from a debugger.
* tty.cc (tty_init): Attempt to grab file handle info from parent debugger, if
appropriate.  # dtable.cc (dtable::stdio_init): Make this a method.
(dtable::init_std_file_from_handle): Don't set fd unless it's not open.
(dtable::build_fhandler_from_name): Move name setting to
dtable::build_fhandler.
(dtable::build_fhandler): Add win32 name parameter.
* dcrt0.cc (dll_crt0_1): Change to use dtable stdio_init.
* dtable.h (dtable): Reflect build_fhandler parameter change.
* mmap.cc (mmap_record::alloc_fh): Don't set name parameter in build_fhandler.
* net.cc (fdsock): Remove set_name call since it is now handled by
build_fhandler.
* sigproc.cc (proc_subproc): Release muto as early as possible.
@
text
@d2459 1
a2459 1
extern "C" int 
d2475 1
a2475 1
    nb = ret = cygwin_recvfrom (s, buf, tot, flags, 
d2512 1
a2512 1
    ret = cygwin_sendto (s, buf, tot, flags, 
@


1.103
log
@	* dtable.cc (dtable::dup2): Revert previous patch.
	* fhandler.h: Ditto.
	(fhandler_socket::recv): Define new method.
	(fhandler_socket::send): Ditto.
	* fhandler_socket.cc (fhandler_socket::recv): New method.
	(fhandler_socket::send): Ditto.
	(fhandler_socket::read): Call fhandler_socket::recv() now.
	(fhandler_socket::write): Call fhandler_socket::send() now.
	* net.cc (class wsock_event): Move definition to wsock_event.h.
	(fdsock): Revert previous patch.
	(cygwin_recv): Move implementation to fhandler_socket::recv().
	(cygwin_send): Move implementation to fhandler_socket::send().
	* wsock_event.h: New file.
@
text
@a510 1
  fh->set_name (name, name);
@


1.102
log
@	* net.cc (get_2k_ifconf): Create interface entries for tokenring cards.
@
text
@d37 1
a50 17
class wsock_event
{
  WSAEVENT		event;
  WSAOVERLAPPED		ovr;
public:
  wsock_event () : event (NULL) {};
  ~wsock_event ()
    {
      if (event)
	WSACloseEvent (event);
      event = NULL;
    };

  LPWSAOVERLAPPED prepare ();
  int wait (int socket, LPDWORD flags);
};

a508 1
  fh->set_fd (fd);
d1514 1
a1514 3
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;
  fhandler_socket *h = get (fd);
d1516 1
a1516 1
  if (__check_null_invalid_struct_errno (buf, len) || !h)
d1519 1
a1519 29
    {
      sigframe thisframe (mainthread);

      if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
	{
	  debug_printf ("Fallback to winsock 1 recv call");
	  if ((res = recv (h->get_socket (), (char *) buf, len, flags))
	      == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	}
      else
	{
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSARecv (h->get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		       ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
	}
    }
d1531 1
a1531 3
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;
  fhandler_socket *h = get (fd);
d1533 1
a1533 1
  if (__check_invalid_read_ptr_errno (buf, len) || !h)
d1536 1
a1536 29
    {
      sigframe thisframe (mainthread);

      if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
	{
	  debug_printf ("Fallback to winsock 1 send call");
	  if ((res = send (h->get_socket (), (const char *) buf, len, flags))
	      == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	}
      else
	{
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSASend (h->get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
		       ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
	}
    }
@


1.101
log
@	* dtable.cc (dtable::dup2): Store fd for fhandler_socket.
	* fhandler.h (fhandler_base::set_fd): New virtual method.
	(fhandler_base::get_fd): Ditto.
	(fhandler_socket::set_fd): Ditto.
	(fhandler_socket::get_fd): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): Call cygwin_recv instead
	of native Winsock recv.
	(fhandler_socket::write): Call cygwin_send instead of native Winsock
	send.
	* net.cc (fdsock): Store fd in fhandler_socket.
@
text
@d1662 1
a1662 1
  char eth[2] = "/", ppp[2] = "/", slp[2] = "/", sub[2] = "0";
d1695 5
@


1.100
log
@	* net.cc (cygwin_getsockname): Fix handling of NULL sun_path.
@
text
@d525 1
@


1.99
log
@	* net.cc (getdomainname): Fix registry key for 9x systems, too.
@
text
@d1378 11
a1388 6
	  /* According to SUSv2 "If the actual length of the address is greater
	     than the length of the supplied sockaddr structure, the stored
	     address will be truncated."  We play it save here so that the
	     path always has a trailing 0 even if it's truncated. */
	  strncpy (sun->sun_path, sock->get_sun_path (),
		   *namelen - sizeof *sun + sizeof sun->sun_path - 1);
@


1.98
log
@	* net.cc (getdomainname): Fix registry key for NT systems.
@
text
@d1631 2
a1632 2
	     (!wincap.is_winnt ()) ? "MSTCP" : "Tcpip",
	     (!wincap.is_winnt ()) ? NULL : "Parameters",
@


1.97
log
@Add newline at EOF.
@
text
@d1632 1
@


1.96
log
@        * cygwin.din: Add recvmsg and sendmsg.
        * net.cc: Add cygwin_recvmsg and cygwin_sendmsg.
        * /usr/include/sys/socket.h: Add recvmsg and sendmsg.
@
text
@d2582 1
a2582 1
}@


1.95
log
@	* net.cc (cygwin_accept): Set sun_path for newly connected socket.
@
text
@d37 1
d2523 60
@


1.94
log
@	* net.cc: Replace usage of AF_UNIX by Posix compliant AF_LOCAL
	throughout.
	(socketpair): Explicitly allow SOCK_STREAM and SOCK_DGRAM socket types
	in families AF_UNIX and AF_LOCAL.  Explicitly allow PF_UNSPEC, PF_LOCAL
	and PF_INET protocols.  Return error otherwise.  Implement datagram
	socketpairs.
@
text
@d1258 2
@


1.93
log
@	* fhandler.h (fhandler_socket::sun_path): New private member.
	(fhandler_socket::set_sun_path): New method.
	(fhandler_socket::get_sun_path): Ditto.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	sun_path to NULL.
	(fhandler_socket::~fhandler_socket): Free sun_path if needed.
	(fhandler_socket::set_sun_path): New method.
	* net.cc (cygwin_bind): Set sun_path to path of local socket file.
	(cygwin_getsockname): Add code to return correct sockaddr for unix
	domain sockets.
@
text
@d544 1
a544 1
      soc = socket (AF_INET, type, af == AF_UNIX ? 0 : protocol);
d581 1
a581 1
  else if (in->sa_family == AF_UNIX)
d900 1
a900 1
      if (sock->get_addr_family () == AF_UNIX)
d1218 1
a1218 1
      if (sock->get_addr_family () == AF_UNIX)
d1279 1
a1279 1
      if (my_addr->sa_family == AF_UNIX)
d1296 1
a1296 1
	      syscall_printf ("AF_UNIX: bind failed %d", get_errno ());
d1302 1
a1302 1
	      syscall_printf ("AF_UNIX: getsockname failed %d", get_errno ());
d1308 1
a1308 1
	  debug_printf ("AF_UNIX: socket bound to port %u", sin.sin_port);
d1370 1
a1370 1
      if (sock->get_addr_family () == AF_UNIX)
d1374 1
a1374 1
	  sun->sun_family = AF_UNIX;
d2325 1
a2325 1
socketpair (int, int type, int, int *sb)
d2329 3
a2331 2
  struct sockaddr_in sock_in;
  int len = sizeof (sock_in);
d2336 17
a2352 1
  cygheap_fdnew sb0;
d2364 2
a2365 1
  /* create a listening socket */
a2377 1

d2385 1
a2385 1

d2394 3
a2396 1
  listen (newsock, 2);
d2408 26
d2435 2
d2438 1
a2438 1
  /* Do a connect and accept the connection */
d2449 1
a2449 2
  insock = accept (newsock, (struct sockaddr *) &sock_in, &len);
  if (insock == INVALID_SOCKET)
d2451 11
a2461 2
      debug_printf ("accept error");
      set_winsock_errno ();
d2463 14
a2476 2
      closesocket (outsock);
      goto done;
a2478 1
  closesocket (newsock);
d2481 3
a2483 1
  fdsock (sb[0], "/dev/tcp", insock);
d2485 18
a2502 1
  fdsock (sb[1], "/dev/tcp", outsock);
@


1.92
log
@* net.cc (cygwin_getsockopt): Dereference optlen pointer when passing to
__check_null_invalid_struct_errno.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d1341 1
d1370 21
a1390 4
      res = getsockname (sock->get_socket (), addr, namelen);
      if (res)
	set_winsock_errno ();

@


1.91
log
@* net.cc (cygwin_getsockopt): Allow NULL optval.
* path.cc (mount_info::read_cygdrive_info_from_registry): Don't write cygdrive
to registry if it doesn't exist.
@
text
@d802 1
a802 1
      && (!optval || !__check_null_invalid_struct_errno (optval, (unsigned) optlen))
@


1.90
log
@	* net.cc (cygwin_hstrerror): Allow s == NULL.
	(cygwin_rcmd): Add parameter checking.
	(cygwin_rexec): Ditto.
@
text
@d616 5
a620 5
		 const void *buf,
		 int len,
		 unsigned int flags,
		 const struct sockaddr *to,
		 int tolen)
d687 1
a687 1
      || __check_null_invalid_struct_errno (from, (unsigned) *fromlen)
d738 1
a738 1
  if (!__check_invalid_read_ptr_errno (optval, optlen) && h)
d802 1
a802 1
      && !__check_null_invalid_struct_errno (optval, (unsigned) optlen)
@


1.90.2.1
log
@* net.cc (cygwin_getsockopt): Allow NULL optval.
* path.cc (mount_info::read_cygdrive_info_from_registry): Don't write cygdrive
to registry if it doesn't exist.
* path.cc (mount_info::conv_to_win32_path): Avoid returning error if cygdrive
== '/'.
(mount_info::cygdrive_win32_path): Return 0 if invalid cygdrive path.
@
text
@d616 5
a620 5
	       const void *buf,
	       int len,
	       unsigned int flags,
	       const struct sockaddr *to,
	       int tolen)
d687 1
a687 1
      || (from && __check_null_invalid_struct_errno (from, (unsigned) *fromlen))
d738 1
a738 1
  if ((!optval || !__check_invalid_read_ptr_errno (optval, optlen)) && h)
d802 1
a802 1
      && (!optval || !__check_null_invalid_struct_errno (optval, (unsigned) optlen))
@


1.90.2.1.4.1
log
@* net.cc (cygwin_getsockopt): Dereference optlen pointer when passing to
__check_null_invalid_struct_errno.
@
text
@d802 1
a802 1
      && (!optval || !__check_null_invalid_struct_errno (optval, (unsigned) *optlen))
@


1.89
log
@	* net.cc (cygwin_inet_ntoa): Add parameter checking.
	(cygwin_inet_network): Return INADDR_NONE instead of 0 in case of
	EFAULT.
	(cygwin_hstrerror): Add parameter checking.
	(cygwin_rresvport): Ditto.
	(socketpair): Ditto.
	* winsup.h (check_null_str): Add extern declaration.
@
text
@d1445 1
a1445 1
  if (check_null_str (s))
d2200 6
d2271 6
@


1.88
log
@* net.cc (inet_makeaddr): Revert previous change.
@
text
@d209 2
d239 1
a239 1
    return 0;
d1445 2
d2236 3
d2301 3
@


1.87
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d271 1
a271 1
  static struct in_addr in;	/* Note -- not thread safe! */
@


1.86
log
@* dtable.cc (dtable::build_fhandler): Don't increment console fd count if new
operation fails.  Increment fork_fixup field here.
(dtable::dup2): Don't increment fork_fixup field here.
(fdsock): Ditto.
@
text
@d121 11
d219 3
d236 2
a250 1

d271 1
a271 2
  struct in_addr in;

d490 2
d623 10
a632 3
  fhandler_socket *h = (fhandler_socket *) cygheap->fdtab[fd];
  sockaddr_in sin;
  sigframe thisframe (mainthread);
d634 2
a635 2
  if (get_inet_addr (to, tolen, &sin, &tolen) == 0)
    return -1;
d637 1
a637 5
  if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
    {
      debug_printf ("Fallback to winsock 1 sendto call");
      if ((res = sendto (h->get_socket (), (const char *) buf, len, flags,
			 (sockaddr *) &sin, tolen)) == SOCKET_ERROR)
d639 7
a645 2
	  set_winsock_errno ();
	  res = -1;
d647 1
a647 9
    }
  else
    {
      WSABUF wsabuf = { len, (char *) buf };
      DWORD ret = 0;
      if (WSASendTo (h->get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
		     (sockaddr *) &sin, tolen, ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
d649 12
a660 2
	  set_winsock_errno ();
	  res = -1;
a661 2
      else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
d681 1
a681 2
  fhandler_socket *h = (fhandler_socket *) cygheap->fdtab[fd];
  sigframe thisframe (mainthread);
d683 6
a688 1
  if (h->is_nonblocking () ||!(ovr = wsock_evt.prepare ()))
d690 3
a692 3
      debug_printf ("Fallback to winsock 1 recvfrom call");
      if ((res = recvfrom (h->get_socket (), buf, len, flags, from, fromlen))
	  == SOCKET_ERROR)
d694 7
a700 2
	  set_winsock_errno ();
	  res = -1;
d702 1
a702 9
    }
  else
    {
      WSABUF wsabuf = { len, (char *) buf };
      DWORD ret = 0;
      if (WSARecvFrom (h->get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		       from, fromlen, ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
d704 12
a715 2
	  set_winsock_errno ();
	  res = -1;
a716 2
      else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
a723 11
/* Cygwin internal */
fhandler_socket *
get (int fd)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return 0;

  return cfd->is_socket ();
}

d736 1
a736 1
  if (h)
d799 3
a801 1
  if (h)
d870 3
d877 1
a877 3
    {
      res = -1;
    }
d1003 4
d1020 3
d1037 3
d1118 3
d1157 3
d1179 5
d1269 3
d1358 4
d1475 4
a1478 1
  fhandler_socket *h = (fhandler_socket *) cygheap->fdtab[fd];
d1480 10
a1489 4
  debug_printf ("getpeername %d", h->get_socket ());
  int res = getpeername (h->get_socket (), name, len);
  if (res)
    set_winsock_errno ();
d1502 1
a1502 2
  fhandler_socket *h = (fhandler_socket *) cygheap->fdtab[fd];
  sigframe thisframe (mainthread);
d1504 3
a1506 1
  if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d1508 3
a1510 3
      debug_printf ("Fallback to winsock 1 recv call");
      if ((res = recv (h->get_socket (), (char *) buf, len, flags))
	  == SOCKET_ERROR)
d1512 7
a1518 2
	  set_winsock_errno ();
	  res = -1;
d1520 1
a1520 9
    }
  else
    {
      WSABUF wsabuf = { len, (char *) buf };
      DWORD ret = 0;
      if (WSARecv (h->get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		   ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
d1522 12
a1533 2
	  set_winsock_errno ();
	  res = -1;
a1534 2
      else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
d1549 1
a1549 2
  fhandler_socket *h = (fhandler_socket *) cygheap->fdtab[fd];
  sigframe thisframe (mainthread);
d1551 3
a1553 1
  if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d1555 3
a1557 3
      debug_printf ("Fallback to winsock 1 send call");
      if ((res = send (h->get_socket (), (const char *) buf, len, flags))
	  == SOCKET_ERROR)
d1559 7
a1565 2
	  set_winsock_errno ();
	  res = -1;
d1567 1
a1567 9
    }
  else
    {
      WSABUF wsabuf = { len, (char *) buf };
      DWORD ret = 0;
      if (WSASend (h->get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
		   ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
d1569 12
a1580 2
	  set_winsock_errno ();
	  res = -1;
a1581 2
      else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
d1600 3
d2118 3
@


1.85
log
@Eliminate excess whitespace.
@
text
@a507 1
  cygheap->fdtab.inc_need_fixup_before ();
@


1.84
log
@        * net.cc (get_2k_ifconf): Change multiple IP address naming scheme
        to Linux style.

	Patch by Alexander Gottwald <ago@@informatik.tu-chemnitz.de>:
        * net.cc (get_2k_ifconf): Added support for multiple IP addresses on
        one interface.
@
text
@d1576 1
a1576 1
        {
d1579 1
a1579 1
	  for (ip_cnt = 0; ip_cnt < ipt->dwNumEntries; ++ip_cnt) 
d2000 1
a2000 1
                  0, KEY_READ, &subkey) != ERROR_SUCCESS)
d2002 3
a2004 3
          RegCloseKey (ifkey);
          --ifr;
          continue;
d2008 3
a2010 3
                  NULL, (unsigned char *) adapter,
                  (size = sizeof adapter, &size)) == ERROR_SUCCESS
              && strcasematch (adapter, "MS$PPP"))
d2012 3
a2014 3
          ++*ppp;
          strcpy (ifr->ifr_name, "ppp");
          strcat (ifr->ifr_name, ppp);
d2018 3
a2020 3
          ++*eth;
          strcpy (ifr->ifr_name, "eth");
          strcat (ifr->ifr_name, eth);
d2022 1
a2022 1
      
@


1.83
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d1554 1
a1554 1
  char eth[2] = "/", ppp[2] = "/", slp[2] = "/";
d1574 1
d1576 4
a1579 2
	{
	  switch (ift->table[if_cnt].dwType)
d1581 46
a1626 35
	    case MIB_IF_TYPE_ETHERNET:
	      ++*eth;
	      strcpy (ifr->ifr_name, "eth");
	      strcat (ifr->ifr_name, eth);
	      break;
	    case MIB_IF_TYPE_PPP:
	      ++*ppp;
	      strcpy (ifr->ifr_name, "ppp");
	      strcat (ifr->ifr_name, ppp);
	      break;
	    case MIB_IF_TYPE_SLIP:
	      ++*slp;
	      strcpy (ifr->ifr_name, "slp");
	      strcat (ifr->ifr_name, slp);
	      break;
	    case MIB_IF_TYPE_LOOPBACK:
	      strcpy (ifr->ifr_name, "lo");
	      break;
	    default:
	      continue;
	    }
	  for (ip_cnt = 0; ip_cnt < ipt->dwNumEntries; ++ip_cnt)
	    if (ipt->table[ip_cnt].dwIndex == ift->table[if_cnt].dwIndex)
	      {
		switch (what)
		  {
		  case SIOCGIFCONF:
		  case SIOCGIFADDR:
		    sa = (struct sockaddr_in *) &ifr->ifr_addr;
		    sa->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr;
		    sa->sin_family = AF_INET;
		    sa->sin_port = 0;
		    break;
		  case SIOCGIFBRDADDR:
		    sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
d1628 2
a1629 2
		    /* Unfortunately, the field returns only crap. */
		    sa->sin_addr.s_addr = ipt->table[ip_cnt].dwBCastAddr;
d1631 5
a1635 5
		    lip = ipt->table[ip_cnt].dwAddr;
		    lnp = ipt->table[ip_cnt].dwMask;
		    sa->sin_addr.s_addr = lip & lnp | ~lnp;
		    sa->sin_family = AF_INET;
		    sa->sin_port = 0;
d1637 29
a1665 29
		    break;
		  case SIOCGIFNETMASK:
		    sa = (struct sockaddr_in *) &ifr->ifr_netmask;
		    sa->sin_addr.s_addr = ipt->table[ip_cnt].dwMask;
		    sa->sin_family = AF_INET;
		    sa->sin_port = 0;
		    break;
		  case SIOCGIFHWADDR:
		    so = &ifr->ifr_hwaddr;
		    for (UINT i = 0; i < IFHWADDRLEN; ++i)
		      if (i >= ift->table[if_cnt].dwPhysAddrLen)
			so->sa_data[i] = '\0';
		      else
			so->sa_data[i] = ift->table[if_cnt].bPhysAddr[i];
		    so->sa_family = AF_INET;
		    break;
		  case SIOCGIFMETRIC:
		    ifr->ifr_metric = 1;
		    break;
		  case SIOCGIFMTU:
		    ifr->ifr_mtu = ift->table[if_cnt].dwMtu;
		    break;
		  }
		++cnt;
		if ((caddr_t) ++ifr >
		    ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
		  goto done;
		break;
	      }
@


1.82
log
@* autoload.cc (load_wsock32): Declare dummy function to force loading of
winsock.
* fhandler.cc (fhandler_base::set_inheritance): Make debugging output more
verbose.
* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Force loading of
winsock32 if winsock2 not available.
* net.cc (set_socket_inheritance): Use DuplicateHandle in all cases to set
inheritance correctly.
(fdsock): Use winsock2_active macro to determine when to set socket
inheritance.  Remove fdtab resource locking since this function should already
be protected.
(cygwin_accept): Simplify logic.  Ensure that fdtab unlock is not called
inappropriately.
(cygwin_rcmd): Use fdtab locking.
(cygwin_rresvport): Ditto.
(cygwin_rexec): Ditto.
* select.cc (peek_socket): Set errno appropriately if winsock select fails.
* winsup.h: Declare check_pty_fds.
* syscalls.cc (check_pty_fds): Rename from check_ttys_fds.  Also check pty
master.
(setsid): Use check_pty_fds.
* dtable.cc (dtable::dec_console_fds): Add check on pty fds.
@
text
@d499 1
a499 1
fdsock (int fd, const char *name, SOCKET soc)
a518 2
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "socket");

d521 1
a521 1
  int fd = cygheap->fdtab.find_unused_handle ();
d523 1
a523 3
  if (fd < 0)
    set_errno (EMFILE);
  else
a546 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "socket");
d696 3
a698 5
  if (cygheap->fdtab.not_open (fd))
    {
      set_errno (EINVAL);
      return 0;
    }
d700 1
a700 1
  return cygheap->fdtab[fd]->is_socket ();
a1201 1
      SetResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "accept");
d1203 3
a1205 4
      int res_fd = cygheap->fdtab.find_unused_handle ();
      if (res_fd == -1)
	/* FIXME: what is correct errno? */
	set_errno (EMFILE);
a1213 1
      ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "accept");
d2103 2
a2104 2
  int res_fd = cygheap->fdtab.find_unused_handle ();
  if (res_fd == -1)
d2109 2
a2110 3
      SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "cygwin_rcmd");
      *fd2p = cygheap->fdtab.find_unused_handle (res_fd + 1);
      if (*fd2p == -1)
d2112 1
d2115 1
a2115 1
  res = rcmd (ahost, inport, locuser, remuser, cmd, fd2p? &fd2s: NULL);
d2123 1
d2126 1
a2127 2
  if (fd2p)
    ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "cygwin_rcmd");
d2136 1
a2136 1
  int res = -1;
d2139 3
a2141 8
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "cygwin_rresvport");
  int res_fd = cygheap->fdtab.find_unused_handle ();
  if (res_fd == -1)
    goto done;
  res = rresvport (port);

  if (res == (int) INVALID_SOCKET)
    goto done;
d2144 7
a2150 2
      fdsock (res_fd, "/dev/tcp", res);
      res = res_fd;
d2152 1
a2152 2
done:
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "cygwin_rresvport");
d2166 2
a2167 3
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "cygwin_rexec");
  int res_fd = cygheap->fdtab.find_unused_handle ();
  if (res_fd == -1)
d2171 2
a2172 2
      *fd2p = cygheap->fdtab.find_unused_handle (res_fd + 1);
      if (*fd2p == -1)
d2174 1
a2187 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "cygwin_rexec");
d2202 9
a2210 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "socketpair");
d2212 1
a2212 5
  sb[0] = cygheap->fdtab.find_unused_handle ();
  if (sb[0] == -1)
    {
      set_errno (EMFILE);
      goto done;
a2213 7
  sb[1] = cygheap->fdtab.find_unused_handle (sb[0] + 1);
  if (sb[1] == -1)
    {
      set_errno (EMFILE);
      goto done;
    }

a2287 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "socketpair");
@


1.81
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d124 4
a127 2
  if (wincap.has_set_handle_information ())
    (void) SetHandleInformation ((HANDLE) sock, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
d129 1
a129 11
    {
      SOCKET newsock;
      if (!DuplicateHandle (hMainProc, (HANDLE) sock, hMainProc, (HANDLE *) &newsock,
			    0, TRUE, DUPLICATE_SAME_ACCESS))
	small_printf ("DuplicateHandle failed %E");
      else
	{
	  closesocket (sock);
	  sock = newsock;
	}
    }
d501 1
a501 2
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fdsock");
  if (wsadata.wVersion < 512) /* < Winsock 2.0 */
d503 2
d510 1
a510 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fdsock");
d519 1
a519 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "socket");
d521 1
a521 1
  SOCKET soc;
d551 1
a551 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "socket");
d1213 3
a1215 6
	{
	  /* FIXME: what is correct errno? */
	  set_errno (EMFILE);
	  goto lock_done;
	}
      if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
d1223 1
d1225 1
a1225 3
lock_done:
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "accept");
done:
d2119 1
d2134 1
a2134 3
    {
      fdsock (*fd2p, "/dev/tcp", fd2s);
    }
d2136 2
d2149 1
d2163 1
d2177 1
d2199 1
@


1.80
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d509 1
d516 2
@


1.79
log
@* net.cc (cygwin_sendto): Use correct socket address when sending
data to AF_UNIX socket.
@
text
@d359 1
a359 1
const static NO_COPY struct tl host_errmap[] =
@


1.78
log
@	* net.cc (get_95_ifconf): Using other registry values pointing to
	correct networkdevice identification for Windows95.
@
text
@d628 1
a628 1
			 to, tolen)) == SOCKET_ERROR)
d639 1
a639 1
		     to, tolen, ovr, NULL) != SOCKET_ERROR)
@


1.77
log
@* net.cc (dup_servent_ptr): Detect old Windows 95 misaligned structure and
realign appropriately.
@
text
@d1924 1
a1924 1
      char driver[256], classname[256], bindname[256], netname[256];
d2000 2
a2001 15
      if (RegOpenKeyEx (ifkey, "Bindings",
			 0, KEY_READ, &subkey) != ERROR_SUCCESS)
	{
	  RegCloseKey (ifkey);
	  --ifr;
	  continue;
	}

      for (int j = 0;
	   (res = RegEnumValue (subkey, j, bindname,
				(size = sizeof bindname, &size),
				0, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS;
	   ++j)
	if (!strncasecmp (bindname, "VREDIR\\", 7))
	  break;
d2003 24
a2027 34

      if (res == ERROR_SUCCESS)
	{
	  strcpy (netname, "System\\CurrentControlSet\\Services\\Class\\Net\\");
	  strcat (netname, bindname + 7);

	  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, netname,
			    0, KEY_READ, &subkey) != ERROR_SUCCESS)
	    {
	      RegCloseKey (ifkey);
	      --ifr;
	      continue;
	    }

	  if (RegQueryValueEx (subkey, "AdapterName", 0,
			       NULL, (unsigned char *) adapter,
			       (size = sizeof adapter, &size)) == ERROR_SUCCESS
	      && strcasematch (adapter, "MS$PPP"))
	    {
	      ++*ppp;
	      strcpy (ifr->ifr_name, "ppp");
	      strcat (ifr->ifr_name, ppp);
	    }
	  else
	    {
	      ++*eth;
	      strcpy (ifr->ifr_name, "eth");
	      strcat (ifr->ifr_name, eth);
	    }

	  RegCloseKey (subkey);

	}

@


1.77.2.1
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a120 11
static fhandler_socket *
get (int fd)
{
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    return 0;

  return cfd->is_socket ();
}

/* Cygwin internal */
d124 2
a125 4
  SOCKET osock = sock;
  if (!DuplicateHandle (hMainProc, (HANDLE) sock, hMainProc, (HANDLE *) &sock,
			0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
    system_printf ("DuplicateHandle failed %E");
d127 11
a137 1
    debug_printf ("DuplicateHandle succeeded osock %p, sock %p", osock, sock);
a205 2
  if (check_null_str_errno (cp))
    return INADDR_NONE;
a215 3
  if (check_null_str_errno (cp) || check_null_invalid_struct_errno (inp))
    return 0;

a229 2
  if (check_null_str_errno (cp))
    return INADDR_NONE;
d243 1
d266 1
d359 1
a359 1
static NO_COPY struct tl host_errmap[] =
a483 2
  if (check_null_str_errno (p))
    return NULL;
d507 1
a507 1
fdsock (int& fd, const char *name, SOCKET soc)
d509 1
a509 1
  if (!winsock2_active)
a510 2
  else
    debug_printf ("not setting socket inheritance since winsock2_active %d", winsock2_active);
d514 1
a514 2
  fh->set_name (name, name);
  debug_printf ("fd %d, name '%s', soc %p", fd, name, soc);
d523 1
a523 1
  SOCKET soc = 0;
d525 1
a525 1
  cygheap_fdnew fd;
d527 5
a531 1
  if (fd >= 0)
d555 1
d608 5
a612 5
	       const void *buf,
	       int len,
	       unsigned int flags,
	       const struct sockaddr *to,
	       int tolen)
d617 6
a622 1
  fhandler_socket *h = get (fd);
d624 1
a624 5
  if ((len && __check_invalid_read_ptr_errno (buf, (unsigned) len))
      || __check_null_invalid_struct_errno (to, tolen)
      || !h)
    res = -1;
  else
d626 3
a628 7
      sockaddr_in sin;
      sigframe thisframe (mainthread);

      if (get_inet_addr (to, tolen, &sin, &tolen) == 0)
	return -1;

      if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d630 2
a631 7
	  debug_printf ("Fallback to winsock 1 sendto call");
	  if ((res = sendto (h->get_socket (), (const char *) buf, len, flags,
			     (sockaddr *) &sin, tolen)) == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
d633 9
a641 1
      else
d643 2
a644 12
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSASendTo (h->get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
			 (sockaddr *) &sin, tolen, ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
d646 2
d667 2
a668 1
  fhandler_socket *h = get (fd);
d670 1
a670 6
  if (__check_null_invalid_struct_errno (buf, (unsigned) len)
      || check_null_invalid_struct_errno (fromlen)
      || (from && __check_null_invalid_struct_errno (from, (unsigned) *fromlen))
      || !h)
    res = -1;
  else
d672 3
a674 3
      sigframe thisframe (mainthread);

      if (h->is_nonblocking () ||!(ovr = wsock_evt.prepare ()))
d676 2
a677 7
	  debug_printf ("Fallback to winsock 1 recvfrom call");
	  if ((res = recvfrom (h->get_socket (), buf, len, flags, from, fromlen))
	      == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
d679 9
a687 1
      else
d689 2
a690 12
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSARecvFrom (h->get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
			   from, fromlen, ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
d692 2
d701 13
d726 1
a726 1
  if ((!optval || !__check_invalid_read_ptr_errno (optval, optlen)) && h)
d789 1
a789 3
  if (!check_null_invalid_struct_errno (optlen)
      && (!optval || !__check_null_invalid_struct_errno (optval, (unsigned) *optlen))
      && h)
a857 3
  if (__check_invalid_read_ptr_errno (name, namelen))
    return -1;

d862 3
a864 1
    res = -1;
a989 4
  if (check_null_str_errno (name)
      || (proto != NULL && check_null_str_errno (proto)))
    return NULL;

a1002 3
  if (proto != NULL && check_null_str_errno (proto))
    return NULL;

a1016 3
  if (__check_null_invalid_struct_errno (name, len))
    return -1;

a1094 3
  if (check_null_str_errno (name))
    return NULL;

a1130 3
  if (__check_null_invalid_struct_errno (addr, len))
    return NULL;

a1149 5
  if (peer != NULL
      && (check_null_invalid_struct_errno (len)
	  || __check_null_invalid_struct_errno (peer, (unsigned) *len)))
    return -1;

d1213 1
d1215 8
a1222 4
      cygheap_fdnew res_fd;
      if (res_fd < 0)
	/* FIXME: what is correct errno? */;
      else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
d1231 3
a1233 1
 done:
a1241 3
  if (__check_null_invalid_struct_errno (my_addr, addrlen))
    return -1;

a1308 1
	      sock->set_sun_path (un_addr->sun_path);
a1327 4
  if (check_null_invalid_struct_errno (namelen)
      || __check_null_invalid_struct_errno (addr, (unsigned) *namelen))
    return -1;

d1333 4
a1336 21
      if (sock->get_addr_family () == AF_UNIX)
	{
	  struct sockaddr_un *sun = (struct sockaddr_un *) addr;
	  memset (sun, 0, *namelen);
	  sun->sun_family = AF_UNIX;
	  /* According to SUSv2 "If the actual length of the address is greater
	     than the length of the supplied sockaddr structure, the stored
	     address will be truncated."  We play it save here so that the
	     path always has a trailing 0 even if it's truncated. */
	  strncpy (sun->sun_path, sock->get_sun_path (),
		   *namelen - sizeof *sun + sizeof sun->sun_path - 1);
	  *namelen = sizeof *sun - sizeof sun->sun_path
		     + strlen (sun->sun_path) + 1;
	  res = 0;
	}
      else
	{
	  res = getsockname (sock->get_socket (), addr, namelen);
	  if (res)
	    set_winsock_errno ();
	}
a1408 2
  if (s && check_null_str (s))
    return;
d1441 1
a1441 4
  int res;
  if (check_null_invalid_struct_errno (len)
      || __check_null_invalid_struct_errno (name, (unsigned) *len))
    return -1;
d1443 4
a1446 10
  fhandler_socket *h = get (fd);

  if (!h)
    res = -1;
  else
    {
      res = getpeername (h->get_socket (), name, len);
      if (res)
	set_winsock_errno ();
    }
d1459 2
a1460 1
  fhandler_socket *h = get (fd);
d1462 1
a1462 3
  if (__check_null_invalid_struct_errno (buf, len) || !h)
    res = -1;
  else
d1464 3
a1466 3
      sigframe thisframe (mainthread);

      if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d1468 2
a1469 7
	  debug_printf ("Fallback to winsock 1 recv call");
	  if ((res = recv (h->get_socket (), (char *) buf, len, flags))
	      == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
d1471 9
a1479 1
      else
d1481 2
a1482 12
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSARecv (h->get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		       ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
d1484 2
d1500 2
a1501 1
  fhandler_socket *h = get (fd);
d1503 1
a1503 3
  if (__check_invalid_read_ptr_errno (buf, len) || !h)
    res = -1;
  else
d1505 3
a1507 3
      sigframe thisframe (mainthread);

      if (h->is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d1509 2
a1510 7
	  debug_printf ("Fallback to winsock 1 send call");
	  if ((res = send (h->get_socket (), (const char *) buf, len, flags))
	      == SOCKET_ERROR)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
d1512 9
a1520 1
      else
d1522 2
a1523 12
	  WSABUF wsabuf = { len, (char *) buf };
	  DWORD ret = 0;
	  if (WSASend (h->get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
		       ovr, NULL) != SOCKET_ERROR)
	    res = ret;
	  else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	    {
	      set_winsock_errno ();
	      res = -1;
	    }
	  else if ((res = wsock_evt.wait (h->get_socket (), (DWORD *)&flags)) == -1)
	    set_winsock_errno ();
d1525 2
a1544 3
  if (__check_null_invalid_struct_errno (domain, len))
    return -1;

d1572 1
a1572 1
  char eth[2] = "/", ppp[2] = "/", slp[2] = "/", sub[2] = "0";
a1591 1
      /* Iterate over all known interfaces */
d1594 23
a1616 2
	  *sub = '0';
	  /* Iterate over all configured IP-addresses */
d1618 13
a1630 47
	    {
	      /* Does the IP address belong to the interface? */
	      if (ipt->table[ip_cnt].dwIndex == ift->table[if_cnt].dwIndex)
		{
		  /* Setup the interface name */
		  switch (ift->table[if_cnt].dwType)
		    {
		      case MIB_IF_TYPE_ETHERNET:
			if (*sub == '0')
			  ++*eth;
			strcpy (ifr->ifr_name, "eth");
			strcat (ifr->ifr_name, eth);
			break;
		      case MIB_IF_TYPE_PPP:
			++*ppp;
			strcpy (ifr->ifr_name, "ppp");
			strcat (ifr->ifr_name, ppp);
			break;
		      case MIB_IF_TYPE_SLIP:
			++*slp;
			strcpy (ifr->ifr_name, "slp");
			strcat (ifr->ifr_name, slp);
			break;
		      case MIB_IF_TYPE_LOOPBACK:
			strcpy (ifr->ifr_name, "lo");
			break;
		      default:
			continue;
		    }
		  if (*sub > '0')
		    {
		      strcat (ifr->ifr_name, ":");
		      strcat (ifr->ifr_name, sub);
		    }
		  ++*sub;
		  /* setup sockaddr struct */
		  switch (what)
		    {
		      case SIOCGIFCONF:
		      case SIOCGIFADDR:
			sa = (struct sockaddr_in *) &ifr->ifr_addr;
			sa->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr;
			sa->sin_family = AF_INET;
			sa->sin_port = 0;
			break;
		      case SIOCGIFBRDADDR:
			sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
d1632 2
a1633 2
			/* Unfortunately, the field returns only crap. */
			sa->sin_addr.s_addr = ipt->table[ip_cnt].dwBCastAddr;
d1635 5
a1639 5
			lip = ipt->table[ip_cnt].dwAddr;
			lnp = ipt->table[ip_cnt].dwMask;
			sa->sin_addr.s_addr = lip & lnp | ~lnp;
			sa->sin_family = AF_INET;
			sa->sin_port = 0;
d1641 29
a1669 29
			break;
		      case SIOCGIFNETMASK:
			sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			sa->sin_addr.s_addr = ipt->table[ip_cnt].dwMask;
			sa->sin_family = AF_INET;
			sa->sin_port = 0;
			break;
		      case SIOCGIFHWADDR:
			so = &ifr->ifr_hwaddr;
			for (UINT i = 0; i < IFHWADDRLEN; ++i)
			  if (i >= ift->table[if_cnt].dwPhysAddrLen)
			    so->sa_data[i] = '\0';
			  else
			    so->sa_data[i] = ift->table[if_cnt].bPhysAddr[i];
			so->sa_family = AF_INET;
			break;
		      case SIOCGIFMETRIC:
			ifr->ifr_metric = 1;
			break;
		      case SIOCGIFMTU:
			ifr->ifr_mtu = ift->table[if_cnt].dwMtu;
			break;
		    }
		  ++cnt;
		  if ((caddr_t) ++ifr >
		      ifc->ifc_buf + ifc->ifc_len - sizeof (struct ifreq))
		    goto done;
		}
	    }
d1924 1
a1924 1
      char driver[256], classname[256], netname[256];
d2000 3
a2002 6
      strcpy (netname, "System\\CurrentControlSet\\Services\\Class\\Net\\");
      strcat (netname, ifname);

      if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, netname,
		  0, KEY_READ, &subkey) != ERROR_SUCCESS)
      {
d2006 24
a2029 1
      }
d2031 3
a2033 3
      if (RegQueryValueEx (subkey, "AdapterName", 0,
		  NULL, (unsigned char *) adapter,
		  (size = sizeof adapter, &size)) == ERROR_SUCCESS
d2035 15
a2049 11
      {
	  ++*ppp;
	  strcpy (ifr->ifr_name, "ppp");
	  strcat (ifr->ifr_name, ppp);
      }
      else
      {
	  ++*eth;
	  strcpy (ifr->ifr_name, "eth");
	  strcat (ifr->ifr_name, eth);
      }
a2050 1
      RegCloseKey (subkey);
a2069 3
  if (check_null_invalid_struct_errno (ifc))
    return -1;

d2144 2
a2145 8
  if (check_null_invalid_struct_errno (ahost) ||
      check_null_empty_str_errno (*ahost) ||
      (locuser && check_null_empty_str_errno (locuser)) ||
      (remuser && check_null_str_errno (remuser)))
    return (int) INVALID_SOCKET;

  cygheap_fdnew res_fd;
  if (res_fd < 0)
d2150 2
a2151 2
      cygheap_fdnew newfd (res_fd, false);
      if (*fd2p < 0)
a2152 1
      *fd2p = newfd;
d2155 1
a2155 1
  res = rcmd (ahost, inport, locuser, remuser, cmd, fd2p ? &fd2s : NULL);
a2162 1

d2164 3
a2166 2
    fdsock (*fd2p, "/dev/tcp", fd2s);

d2176 1
a2176 1
  int res;
d2179 4
a2182 2
  if (check_null_invalid_struct_errno (port))
    return -1;
d2184 2
a2185 3
  cygheap_fdnew res_fd;
  if (res_fd < 0)
    res = -1;
d2188 2
a2189 7
      res = rresvport (port);

      if (res != (int) INVALID_SOCKET)
	{
	  fdsock (res_fd, "/dev/tcp", res);
	  res = res_fd;
	}
d2191 1
a2191 1

d2205 2
a2206 8
  if (check_null_invalid_struct_errno (ahost) ||
      check_null_empty_str_errno (*ahost) ||
      (locuser && check_null_empty_str_errno (locuser)) ||
      (password && check_null_str_errno (password)))
    return (int) INVALID_SOCKET;

  cygheap_fdnew res_fd;
  if (res_fd < 0)
d2210 2
a2211 2
      cygheap_fdnew newfd (res_fd);
      if (newfd < 0)
a2212 1
      *fd2p = newfd;
d2240 1
a2240 2
  if (__check_null_invalid_struct_errno (sb, 2 * sizeof(int)))
    return -1;
d2242 8
a2249 4
  cygheap_fdnew sb0;
  if (sb0 < 0)
    goto done;
  else
d2251 3
a2253 4
      sb[0] = sb0;
      cygheap_fdnew sb1 (sb0, false);
      if (sb1 < 0)
	goto done;
a2254 2
      sb[1] = sb1;
    }
d2329 1
@


1.77.2.2
log
@Merged changes from HEAD
@
text
@d544 1
a544 1
      soc = socket (AF_INET, type, af == AF_LOCAL ? 0 : protocol);
d581 1
a581 1
  else if (in->sa_family == AF_LOCAL)
d900 1
a900 1
      if (sock->get_addr_family () == AF_LOCAL)
d1218 1
a1218 1
      if (sock->get_addr_family () == AF_LOCAL)
a1257 2
	  if (sock->get_addr_family () == AF_LOCAL)
	    res_fh->set_sun_path (sock->get_sun_path ());
d1279 1
a1279 1
      if (my_addr->sa_family == AF_LOCAL)
d1296 1
a1296 1
	      syscall_printf ("AF_LOCAL: bind failed %d", get_errno ());
d1302 1
a1302 1
	      syscall_printf ("AF_LOCAL: getsockname failed %d", get_errno ());
d1308 1
a1308 1
	  debug_printf ("AF_LOCAL: socket bound to port %u", sin.sin_port);
d1370 1
a1370 1
      if (sock->get_addr_family () == AF_LOCAL)
d1374 1
a1374 1
	  sun->sun_family = AF_LOCAL;
d2325 1
a2325 1
socketpair (int family, int type, int protocol, int *sb)
d2329 2
a2330 3
  struct sockaddr_in sock_in, sock_out;
  int len;
  cygheap_fdnew sb0;
d2335 1
a2335 17
  if (family != AF_LOCAL && family != AF_INET)
    {
      set_errno (EAFNOSUPPORT);
      goto done;
    }
  if (type != SOCK_STREAM && type != SOCK_DGRAM)
    {
      set_errno (EPROTOTYPE);
      goto done;
    }
  if ((family == AF_LOCAL && protocol != PF_UNSPEC && protocol != PF_LOCAL)
      || (family == AF_INET && protocol != PF_UNSPEC && protocol != PF_INET))
    {
      set_errno (EPROTONOSUPPORT);
      goto done;
    }

d2347 1
a2347 2

  /* create the first socket */
d2360 1
d2368 1
a2368 1
  len = sizeof (sock_in);
d2377 1
a2377 3
  /* For stream sockets, create a listener */
  if (type == SOCK_STREAM)
    listen (newsock, 2);
a2388 26
  /* For datagram sockets, bind the 2nd socket to an unused address, too */
  if (type == SOCK_DGRAM)
    {
      sock_out.sin_family = AF_INET;
      sock_out.sin_port = 0;
      sock_out.sin_addr.s_addr = INADDR_ANY;
      if (bind (outsock, (struct sockaddr *) &sock_out, sizeof (sock_out)) < 0)
	{
	  debug_printf ("bind failed");
	  set_winsock_errno ();
	  closesocket (newsock);
	  closesocket (outsock);
	  goto done;
	}
      len = sizeof (sock_out);
      if (getsockname (outsock, (struct sockaddr *) &sock_out, &len) < 0)
	{
	  debug_printf ("getsockname error");
	  set_winsock_errno ();
	  closesocket (newsock);
	  closesocket (outsock);
	  goto done;
	}
    }

  /* Force IP address to loopback */
a2389 2
  if (type == SOCK_DGRAM)
    sock_out.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
d2391 1
a2391 1
  /* Do a connect */
d2402 2
a2403 1
  if (type == SOCK_STREAM)
d2405 2
a2406 11
      /* For stream sockets, accept the connection and close the listener */
      len = sizeof (sock_in);
      insock = accept (newsock, (struct sockaddr *) &sock_in, &len);
      if (insock == INVALID_SOCKET)
	{
	  debug_printf ("accept error");
	  set_winsock_errno ();
	  closesocket (newsock);
	  closesocket (outsock);
	  goto done;
	}
d2408 2
a2409 14
    }
  else
    {
      /* For datagram sockets, connect the 2nd socket */
      if (connect (newsock, (struct sockaddr *) &sock_out,
					       sizeof (sock_out)) < 0)
	{
	  debug_printf ("connect error");
	  set_winsock_errno ();
	  closesocket (newsock);
	  closesocket (outsock);
	  goto done;
	}
      insock = newsock;
d2412 1
d2415 1
a2415 3
  if (family == AF_LOCAL)
    {
      fhandler_socket *fh;
d2417 1
a2417 18
      fh = fdsock (sb[0],
		   type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket",
		   insock);
      fh->set_sun_path ("");
      fh->set_addr_family (AF_LOCAL);
      fh = fdsock (sb[1],
		   type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket",
		   outsock);
      fh->set_sun_path ("");
      fh->set_addr_family (AF_LOCAL);
    }
  else
    {
      fdsock (sb[0], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
	      insock)->set_addr_family (AF_INET);
      fdsock (sb[1], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
	      outsock)->set_addr_family (AF_INET);
    }
@


1.77.2.3
log
@Merged changes from HEAD
@
text
@a36 1
#include <sys/uio.h>
a2520 60
}

/* exported as recvmsg: standards? */
extern "C" int 
cygwin_recvmsg(int s, struct msghdr *msg, int flags)
{
    int ret, nb;
    size_t tot = 0;
    int i;
    char *buf, *p;
    struct iovec *iov = msg->msg_iov;

    for(i = 0; i < msg->msg_iovlen; ++i)
	tot += iov[i].iov_len;
    buf = (char *) malloc(tot);
    if (tot != 0 && buf == NULL) {
	errno = ENOMEM;
	return -1;
    }
    nb = ret = cygwin_recvfrom (s, buf, tot, flags, 
      (struct sockaddr *) msg->msg_name, (int *) &msg->msg_namelen);
    p = buf;
    while (nb > 0) {
	ssize_t cnt = min(nb, iov->iov_len);

	memcpy (iov->iov_base, p, cnt);
	p += cnt;
	nb -= cnt;
	++iov;
    }
    free(buf);
    return ret;
}

/* exported as sendmsg: standards? */
extern "C" int
cygwin_sendmsg(int s, const struct msghdr *msg, int flags)
{
    int ret;
    size_t tot = 0;
    int i;
    char *buf, *p;
    struct iovec *iov = msg->msg_iov;

    for(i = 0; i < msg->msg_iovlen; ++i)
	tot += iov[i].iov_len;
    buf = (char *) malloc(tot);
    if (tot != 0 && buf == NULL) {
	errno = ENOMEM;
	return -1;
    }
    p = buf;
    for (i = 0; i < msg->msg_iovlen; ++i) {
	memcpy (p, iov[i].iov_base, iov[i].iov_len);
	p += iov[i].iov_len;
    }
    ret = cygwin_sendto (s, buf, tot, flags, 
      (struct sockaddr *) msg->msg_name, msg->msg_namelen);
    free (buf);
    return ret;
@


1.77.2.4
log
@Merged changes from HEAD
@
text
@a36 1
#include "wsock_event.h"
d50 17
d527 1
d1378 6
a1383 11

	  if (!sock->get_sun_path ())
	    sun->sun_path[0] = '\0';
	  else
	    /* According to SUSv2 "If the actual length of the address is
	       greater than the length of the supplied sockaddr structure, the
	       stored address will be truncated."  We play it save here so
	       that the path always has a trailing 0 even if it's truncated. */
	    strncpy (sun->sun_path, sock->get_sun_path (),
		     *namelen - sizeof *sun + sizeof sun->sun_path - 1);

d1525 3
a1527 1
  fhandler_socket *fh = get (fd);
d1529 1
a1529 1
  if (__check_null_invalid_struct_errno (buf, len) || !fh)
d1532 29
a1560 1
    res = fh->recv (buf, len, flags);
d1572 3
a1574 1
  fhandler_socket *fh = get (fd);
d1576 1
a1576 1
  if (__check_invalid_read_ptr_errno (buf, len) || !fh)
d1579 29
a1607 1
    res = fh->send (buf, len, flags);
d1631 1
a1631 2
	     (!wincap.is_winnt ()) ? "VxD" : "Tcpip",
	     (!wincap.is_winnt ()) ? "MSTCP" : "Parameters",
d1655 1
a1655 1
  char eth[2] = "/", ppp[2] = "/", slp[2] = "/", sub[2] = "0", tok[2] = "/";
a1687 5
		      case MIB_IF_TYPE_TOKENRING:
		        ++*tok;
			strcpy (ifr->ifr_name, "tok");
			strcat (ifr->ifr_name, tok);
			break;
@


1.77.2.5
log
@Merged changes from HEAD
@
text
@d24 1
d33 1
a505 6
  else if (wincap.has_set_handle_information ())
    {
      /* NT systems apparently set sockets to inheritable by default */
      SetHandleInformation ((HANDLE)soc, HANDLE_FLAG_INHERIT, 0);
      debug_printf ("reset socket inheritance since winsock2_active %d", winsock2_active);
    }
d510 1
a510 1
  fh->set_flags (O_RDWR, O_BINARY);
a520 1
  fhandler_socket* fh = NULL;
d542 1
a542 6
      fh = fdsock (fd, name, soc);
      if (fh)
	{
	  fh->set_addr_family (af);
	  fh->set_socket_type (type);
	}
d884 1
a884 2
      if (sock->get_addr_family () == AF_LOCAL &&
	  sock->get_socket_type () == SOCK_STREAM)
d1115 1
a1115 1
      tmp_addr_list[0] = (char *) tmp_addr;
d1202 1
a1202 2
      if (sock->get_addr_family () == AF_LOCAL &&
	  sock->get_socket_type () == SOCK_STREAM)
a1244 1
	  res_fh->set_socket_type (sock->get_socket_type ());
d1544 1
a1544 1
getdomainname (char *domain, size_t len)
d1618 1
a1618 1
			++*tok;
a2268 1
  fhandler_socket *fh;
d2420 1
a2426 1
      fh->set_socket_type (type);
a2431 1
      fh->set_socket_type (type);
d2435 4
a2438 8
      fh = fdsock (sb[0], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
		   insock);
      fh->set_addr_family (AF_INET);
      fh->set_socket_type (type);
      fh = fdsock (sb[1], type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp",
		   outsock);
      fh->set_addr_family (AF_INET);
      fh->set_socket_type (type);
d2459 1
a2459 1
extern "C" int
d2471 1
a2471 2
    if (tot != 0 && buf == NULL)
      {
d2474 2
a2475 2
      }
    nb = ret = cygwin_recvfrom (s, buf, tot, flags,
d2478 1
a2478 2
    while (nb > 0)
      {
d2485 1
a2485 1
      }
d2503 1
a2503 2
    if (tot != 0 && buf == NULL)
      {
d2506 1
a2506 1
      }
d2508 1
a2508 2
    for (i = 0; i < msg->msg_iovlen; ++i)
      {
d2511 2
a2512 2
      }
    ret = cygwin_sendto (s, buf, tot, flags,
@


1.77.2.6
log
@Merged changes from HEAD
@
text
@d36 1
d561 46
d609 6
a614 2
cygwin_sendto (int fd, const void *buf, int len, unsigned int flags,
	       const struct sockaddr *to, int tolen)
d617 3
a619 1
  fhandler_socket *fh = get (fd);
d623 1
a623 1
      || !fh)
d626 33
a658 1
    res = fh->sendto (buf, len, flags, to, tolen);
d667 6
a672 2
cygwin_recvfrom (int fd, char *buf, int len, int flags, struct sockaddr *from,
		 int *fromlen)
d675 3
a677 1
  fhandler_socket *fh = get (fd);
d682 1
a682 1
      || !fh)
d685 29
a713 1
    res = fh->recvfrom (buf, len, flags, from, fromlen);
d722 5
a726 2
cygwin_setsockopt (int fd, int level, int optname, const void *optval,
		   int optlen)
d728 1
a728 1
  fhandler_socket *fh = get (fd);
d732 1
a732 1
  if ((!optval || !__check_invalid_read_ptr_errno (optval, optlen)) && fh)
d769 2
a770 2
      res = setsockopt (fh->get_socket (), level, optname,
			(const char *) optval, optlen);
d786 5
a790 1
cygwin_getsockopt (int fd, int level, int optname, void *optval, int *optlen)
d792 1
a792 1
  fhandler_socket *fh = get (fd);
d796 2
a797 3
      && (!optval
          || !__check_null_invalid_struct_errno (optval, (unsigned) *optlen))
      && fh)
d834 2
a835 2
      res = getsockopt (fh->get_socket (), level, optname, (char *) optval,
      			(int *) optlen);
d854 3
a856 1
cygwin_connect (int fd, const struct sockaddr *name, int namelen)
d859 6
a864 1
  fhandler_socket *fh = get (fd);
d869 4
a872 1
  if (!fh)
d875 31
a905 1
    res = fh->connect (name, namelen);
d907 8
a914 1
  syscall_printf ("%d = connect (%d, %x, %x)", res, fd, name, namelen);
d916 10
d1182 62
a1244 3
  fhandler_socket *fh = get (fd);
  if (fh)
    res = fh->accept (peer, len);
d1246 16
d1275 75
a1349 3
  fhandler_socket *fh = get (fd);
  if (fh)
    res = fh->bind (my_addr, addrlen);
d1351 1
d1366 30
a1395 4
  fhandler_socket *fh = get (fd);
  if (fh)
    res = fh->getsockname (addr, namelen);

a1405 3
  fhandler_socket *fh = get (fd);
  if (fh)
    res = fh->listen (backlog);
d1407 7
d1425 21
a1445 4
  fhandler_socket *fh = get (fd);
  if (fh)
    res = fh->shutdown (how);

d1501 1
a1501 2
  int res = -1;

d1506 1
a1506 3
  fhandler_socket *fh = get (fd);
  if (fh)
    res = fh->getpeername (name, len);
d1508 8
a1515 1
  syscall_printf ("%d = getpeername %d", res, fh->get_socket ());
d1517 1
d2479 1
a2479 1
cygwin_recvmsg (int s, struct msghdr *msg, int flags)
d2481 20
a2500 2
  if (check_null_invalid_struct_errno (msg))
    return -1;
d2502 7
a2508 7
  fhandler_socket *fh = get (s);
  if (!fh)
    {
      set_errno (EINVAL);
      return -1;
    }
  return fh->recvmsg (msg, flags);
d2513 1
a2513 1
cygwin_sendmsg (int s, const struct msghdr *msg, int flags)
d2515 10
a2524 5
    if (__check_invalid_read_ptr_errno (msg, sizeof msg))
      return -1;

    fhandler_socket *fh = get (s);
    if (!fh)
d2526 1
a2526 1
        set_errno (EINVAL);
d2529 10
a2538 1
    return fh->sendmsg (msg, flags);
@


1.77.2.7
log
@Merged changes from HEAD
@
text
@d513 1
a513 1
  fh->set_flags (O_RDWR | O_BINARY);
@


1.77.2.8
log
@Merged changes from HEAD
@
text
@d1134 1
a1134 1
  syscall_printf ("%d = getpeername %d", res, (fh ? fh->get_socket () : -1));
@


1.77.2.9
log
@Merged changes from HEAD
@
text
@a513 1
  fh->set_r_no_interrupt (winsock2_active);
@


1.77.2.10
log
@Merged changes from HEAD
@
text
@d104 1
a104 1
get (const int fd)
d110 1
a110 5
  fhandler_socket *const fh = cfd->is_socket ();
  if (!fh)
    set_errno (ENOTSOCK);

  return fh;
d570 1
a570 1
      || (to &&__check_invalid_read_ptr_errno (to, tolen))
d573 1
a573 1
  else if ((res = len) != 0)
d583 1
a583 1
cygwin_recvfrom (int fd, void *buf, int len, int flags, struct sockaddr *from,
d589 3
a591 4
  if ((len && __check_null_invalid_struct_errno (buf, (unsigned) len))
      || (from
	  && (check_null_invalid_struct_errno (fromlen)
	      ||__check_null_invalid_struct_errno (from, (unsigned) *fromlen)))
d594 1
a594 1
  else if ((res = len) != 0)
a606 1
  int res;
d608 1
d611 1
a611 2
  /* For the following debug_printf */
  switch (optname)
d613 34
a646 31
    case SO_DEBUG:
      name="SO_DEBUG";
      break;
    case SO_ACCEPTCONN:
      name="SO_ACCEPTCONN";
      break;
    case SO_REUSEADDR:
      name="SO_REUSEADDR";
      break;
    case SO_KEEPALIVE:
      name="SO_KEEPALIVE";
      break;
    case SO_DONTROUTE:
      name="SO_DONTROUTE";
      break;
    case SO_BROADCAST:
      name="SO_BROADCAST";
      break;
    case SO_USELOOPBACK:
      name="SO_USELOOPBACK";
      break;
    case SO_LINGER:
      name="SO_LINGER";
      break;
    case SO_OOBINLINE:
      name="SO_OOBINLINE";
      break;
    case SO_ERROR:
      name="SO_ERROR";
      break;
    }
a647 4
  if ((optval && __check_invalid_read_ptr_errno (optval, optlen)) || !fh)
    res = -1;
  else
    {
a666 1
  int res;
d668 1
d670 4
a673 3

  /* For the following debug_printf */
  switch (optname)
d675 34
a708 31
    case SO_DEBUG:
      name="SO_DEBUG";
      break;
    case SO_ACCEPTCONN:
      name="SO_ACCEPTCONN";
      break;
    case SO_REUSEADDR:
      name="SO_REUSEADDR";
      break;
    case SO_KEEPALIVE:
      name="SO_KEEPALIVE";
      break;
    case SO_DONTROUTE:
      name="SO_DONTROUTE";
      break;
    case SO_BROADCAST:
      name="SO_BROADCAST";
      break;
    case SO_USELOOPBACK:
      name="SO_USELOOPBACK";
      break;
    case SO_LINGER:
      name="SO_LINGER";
      break;
    case SO_OOBINLINE:
      name="SO_OOBINLINE";
      break;
    case SO_ERROR:
      name="SO_ERROR";
      break;
    }
a709 7
  if ((optval
       && (check_null_invalid_struct_errno (optlen)
	   || __check_null_invalid_struct_errno (optval, (unsigned) *optlen)))
      || !fh)
    res = -1;
  else
    {
d735 4
a738 1
  if (__check_invalid_read_ptr_errno (name, namelen) || !fh)
d973 1
a973 1
  if (__check_invalid_read_ptr_errno (addr, len))
d995 7
a1001 1
  int res;
d1003 1
a1003 6

  if ((peer && (check_null_invalid_struct_errno (len)
		|| __check_null_invalid_struct_errno (peer, (unsigned) *len)))
      || !fh)
    res = -1;
  else
d1014 5
a1018 1
  int res;
d1020 1
a1020 4

  if (__check_invalid_read_ptr_errno (my_addr, addrlen) || !fh)
    res = -1;
  else
d1031 6
a1036 1
  int res;
d1038 1
a1038 6

  if (check_null_invalid_struct_errno (namelen)
      || __check_null_invalid_struct_errno (addr, (unsigned) *namelen)
      || !fh)
    res = -1;
  else
d1049 2
a1050 1
  int res;
d1052 1
a1052 4

  if (!fh)
    res = -1;
  else
d1063 3
a1065 1
  int res;
d1067 1
a1067 4

  if (!fh)
    res = -1;
  else
d1125 1
a1125 2
  int res;
  fhandler_socket *fh = get (fd);
d1128 5
a1132 4
      || __check_null_invalid_struct_errno (name, (unsigned) *len)
      || !fh)
    res = -1;
  else
d1136 1
d1144 11
a1154 1
  return cygwin_recvfrom (fd, buf, len, flags, NULL, NULL);
d1161 11
a1171 1
  return cygwin_sendto (fd, buf, len, flags, NULL, 0);
d2098 1
a2098 1
cygwin_recvmsg (int fd, struct msghdr *msg, int flags)
d2100 2
a2101 2
  int res;
  fhandler_socket *fh = get (fd);
d2103 7
a2109 11
  if (check_null_invalid_struct_errno (msg)
      || (msg->msg_name
	  && __check_null_invalid_struct_errno (msg->msg_name,
						(unsigned) msg->msg_namelen))
      || !fh)
    res = -1;
  else
    res = fh->recvmsg (msg, flags);

  syscall_printf ("%d = recvmsg (%d, %x, %x)", res, fd, msg, flags);
  return res;
d2114 1
a2114 1
cygwin_sendmsg (int fd, const struct msghdr *msg, int flags)
d2116 2
a2117 2
  int res;
  fhandler_socket *fh = get (fd);
d2119 7
a2125 11
  if (__check_invalid_read_ptr_errno (msg, sizeof msg)
      || (msg->msg_name
	  && __check_invalid_read_ptr_errno (msg->msg_name,
					     (unsigned) msg->msg_namelen))
      || !fh)
    res = -1;
  else
    res = fh->sendmsg (msg, flags);

  syscall_printf ("%d = recvmsg (%d, %x, %x)", res, fd, msg, flags);
  return res;
@


1.77.2.11
log
@Merged changes from HEAD
@
text
@d567 1
a567 1
cygwin_sendto (int fd, const void *buf, int len, int flags,
d580 1
a580 2
  syscall_printf ("%d = sendto (%d, %p, %d, %x, %p, %d)",
		  res, fd, buf, len, flags, to, tolen);
d587 2
a588 2
cygwin_recvfrom (int fd, void *buf, int len, int flags,
		 struct sockaddr *from, int *fromlen)
d602 1
a602 2
  syscall_printf ("%d = recvfrom (%d, %p, %d, %x, %p, %p)",
		  res, fd, buf, len, flags, from, fromlen);
d665 1
a665 1
  syscall_printf ("%d = setsockopt (%d, %d, %x (%s), %p, %d)",
d733 1
a733 1
  syscall_printf ("%d = getsockopt (%d, %d, %x (%s), %p, %p)",
d750 1
a750 1
  syscall_printf ("%d = connect (%d, %p, %d)", res, fd, name, namelen);
d1012 1
a1012 1
  syscall_printf ("%d = accept (%d, %p, %d)", res, fd, peer, len);
d1028 1
a1028 1
  syscall_printf ("%d = bind (%d, %p, %d)", res, fd, my_addr, addrlen);
d1046 1
a1046 1
  syscall_printf ("%d = getsockname (%d, %p, %d)", res, fd, addr, namelen);
d1149 1
a1149 1
cygwin_recv (int fd, void *buf, int len, int flags)
d1156 1
a1156 1
cygwin_send (int fd, const void *buf, int len, int flags)
d2099 1
a2099 1
  syscall_printf ("%d = recvmsg (%d, %p, %d)", res, fd, msg, flags);
d2119 1
a2119 1
  syscall_printf ("%d = recvmsg (%d, %p, %d)", res, fd, msg, flags);
@


1.77.2.12
log
@Merged changes from HEAD
@
text
@a570 2
  sigframe thisframe (mainthread);

a591 2
  sigframe thisframe (mainthread);

a744 2
  sigframe thisframe (mainthread);

a1004 2
  sigframe thisframe (mainthread);

d1014 1
a1014 1
  syscall_printf ("%d = accept (%d, %p, %p)", res, fd, peer, len);
a1038 2
  sigframe thisframe (mainthread);

d1048 1
a1048 1
  syscall_printf ("%d = getsockname (%d, %p, %p)", res, fd, addr, namelen);
a1072 2
  sigframe thisframe (mainthread);

a1135 2
  sigframe thisframe (mainthread);

a2089 2
  sigframe thisframe (mainthread);

d2101 1
a2101 1
  syscall_printf ("%d = recvmsg (%d, %p, %x)", res, fd, msg, flags);
d2121 1
a2121 1
  syscall_printf ("%d = sendmsg (%d, %p, %x)", res, fd, msg, flags);
@


1.77.2.13
log
@Merged changes from HEAD
@
text
@d2115 1
a2115 5
    {
      res = check_iovec_for_read (msg->msg_iov, msg->msg_iovlen);
      if (res > 0)
	res = fh->recvmsg (msg, flags, res); // res == iovec tot
    }
a2125 2
  sigframe thisframe (mainthread);

d2134 2
a2135 6
  else 
    {
      res = check_iovec_for_write (msg->msg_iov, msg->msg_iovlen);
      if (res > 0)
	res = fh->sendmsg (msg, flags, res); // res == iovec tot
    }
@


1.77.2.14
log
@Merged changes from HEAD
@
text
@d727 1
a727 1
			(int *) optlen);
d2140 1
a2140 1
  else
@


1.77.2.15
log
@Merged changes from HEAD
@
text
@d73 1
a73 1
  switch (WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE, FALSE))
d77 1
a77 1
      if (WSAGetOverlappedResult (socket, &ovr, &len, FALSE, flags))
d84 1
a84 1
	  WSAGetOverlappedResult (socket, &ovr, &len, TRUE, flags);
d420 1
a420 1
      if (!(dst[cnt] = (char *) malloc (size)))
d422 1
a422 1
      memcpy (dst[cnt], src[cnt], size);
d1232 2
a1233 2
  if (GetIfTable (NULL, &siz_if_table, TRUE) == ERROR_INSUFFICIENT_BUFFER &&
      GetIpAddrTable (NULL, &siz_ip_table, TRUE) == ERROR_INSUFFICIENT_BUFFER &&
d1236 2
a1237 2
      !GetIfTable (ift, &siz_if_table, TRUE) &&
      !GetIpAddrTable (ipt, &siz_ip_table, TRUE))
d1906 1
a1906 1
  if (__check_null_invalid_struct_errno (sb, 2 * sizeof (int)))
@


1.76
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d935 9
d959 1
a959 1
  if (src->s_proto && !(dst->s_proto = strdup (src->s_proto)))
d961 8
a968 1
  if (src->s_aliases && !(dst->s_aliases = dup_char_list (src->s_aliases)))
@


1.75
log
@Update copyrights.
@
text
@d124 1
a124 1
  if (iswinnt)
d1530 1
a1530 1
	     (!iswinnt) ? "System" : "SYSTEM",
d1532 1
a1532 1
	     (!iswinnt) ? "MSTCP" : "Tcpip",
d2110 3
a2112 11
  /* We have a win95 version... */
  if (os_version_info.dwPlatformId != VER_PLATFORM_WIN32_NT
      && (os_version_info.dwMajorVersion < 4
	  || (os_version_info.dwMajorVersion == 4
	      && os_version_info.dwMinorVersion == 0)))
    get_95_ifconf (ifc, what);
  /* ...and a NT <= SP3 version... */
  else if (os_version_info.dwPlatformId == VER_PLATFORM_WIN32_NT
	   && (os_version_info.dwMajorVersion < 4
	       || (os_version_info.dwMajorVersion == 4
		   && strcmp (os_version_info.szCSDVersion, "Service Pack 4") < 0)))
a2113 1
  /* ...and finally a "modern" version for win98/ME, NT >= SP4 and W2K! */
d2115 1
a2115 2
    get_2k_ifconf (ifc, what);

@


1.74
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Cygnus Solutions.
@


1.73
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d391 1
a391 1
        free (*cl);
d419 1
a419 1
  
d427 1
a427 1
        return NULL;
d441 1
a441 1
        free (p->p_name);
d881 1
a881 1
	        WSASetLastError (WSAEISCONN);
d927 1
a927 1
        free (p->s_name);
d929 1
a929 1
        free (p->s_proto);
d1025 1
a1025 1
        free ((void *)p->h_name);
d1861 6
a1866 6
 *         -> Value "Driver" enthlt Subkey relativ zu
 *            HKLM/System/CurrentControlSet/Class/
 *         -> In Subkey "Bindings" die Values aufzhlen
 *            -> Enthlt Subkeys der Form "VREDIR\*"
 *               Das * ist ein Subkey relativ zu
 *               HKLM/System/CurrentControlSet/Class/Net/
d1868 2
a1869 2
 *         -> Value "IPAddress"
 *         -> Value "IPMask"
d1871 2
a1872 2
 *         -> Wenn Value "AdapterName" == "MS$PPP" -> ppp interface
 *         -> Value "DriverDesc" enthlt den Namen
@


1.72
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d289 1
a289 1
static struct tl errmap[] =
d359 1
a359 1
static struct tl host_errmap[] =
@


1.71
log
@        * net.cc (cygwin_connect): Add WSAEALREADY and WSAEINVAL handling
        for non-blocking sockets.
@
text
@d1075 2
a1076 2
  static char *tmp_aliases[1] = {0};
  static char *tmp_addr_list[2] = {0, 0};
@


1.70
log
@* cygwin.sc: New file -- linker script for building cygwin DLL.
* Makefile.in: Use linker script to control location of cygheap.
* cygheap.cc (buckets): Make static.
(init_cheap): Remove special iswinnt handling.  Allocate cygheap at a fixed
location.  Display more info when allocation fails.
(cygheap_fixup_in_child): Try harder to move cygheap to correct location.
Display more info when allocation fails.
* fhandler.h (fhandler_socket): Add macros for tracking socket shutdown state.
* net.cc (cygwin_shutdown): Set appropriate shutdown value for future use.
* select.cc (select_stuff::cleanup): New method.
(cygwin_select): Call cleanup explicitly to avoid a race.
(select_stuff:~select_stuff): Call cleanup chain via cleanup method.
(fhandler_socket::select_read): Set *_ready when shutdown has been called on
the socket.
(fhandler_socket::select_write): Ditto.
(fhandler_socket::select_except): Ditto.
* winsup.h: Move NO_COPY to "COMMON" section.
* autoload.cc (wsock_started): Avoid initializing NO_COPY value.
* sigproc.cc: Remove initialization from NO_COPY variables.
(sigproc_init): Initialize sig_loop_wait here, rather than via initialization.
(subproc_init): Initialize proc_loop_wait here, rather than via initialization.
@
text
@d871 2
a872 2
	     when called to early on a non-blocking socket. */
	  if (WSAGetLastError () == WSAEWOULDBLOCK)
d874 8
a881 2
	      WSASetLastError (WSAEINPROGRESS);
	      in_progress = TRUE;
a882 1

@


1.69
log
@        * net.cc (free_addr_list): Add define for symmetry.
        (free_hostent_ptr): Use free_addr_list to free h_addr_list element.
        (dup_addr_list): New static function.
        (dup_hostent_ptr): Use dup_addr_list instead of dup_char_list in order
        to handle embedded null characters.
@
text
@d1352 14
@


1.68
log
@        * net.cc (cygwin_inet_ntoa): Rearrange previous patch to use
        thread local buffer space when compiled thread safe.
        (cygwin_getprotobyname): Ditto.
        (cygwin_getprotobynumber): Ditto.
        (cygwin_getservbyname): Ditto.
        (cygwin_getservbyport): Ditto.
        (cygwin_gethostbyname): Ditto.
        (cygwin_gethostbyaddr): Ditto. Move near to cygwin_gethostbyname.
        * thread.h (struct _winsup_t): Add pointers for above used buffer space.
        * passwd.cc (getpwduid): Remove initializing passwd.
        (setpwent): Ditto.
        (endpwent): Ditto.
        (setpassent): Ditto.
@
text
@d412 21
d1022 1
a1022 1
      free_char_list (p->h_addr_list);
d1045 2
a1046 1
  if (src->h_addr_list && !(dst->h_addr_list = dup_char_list(src->h_addr_list)))
@


1.67
log
@        * net.cc (free_char_list): New static function.
        (dup_char_list): Ditto.
        (free_protoent_ptr): Ditto.
        (dup_protoent_ptr): Ditto.
        (free_servent_ptr): Ditto.
        (dup_servent_ptr): Ditto.
        (free_hostent_ptr): Ditto.
        (dup_hostent_ptr): Ditto.
        (cygwin_inet_ntoa): Use local static buffer to allow propagating of
        the result to child processes.
        (cygwin_getprotobyname): Ditto.
        (cygwin_getprotobynumber): Ditto.
        (cygwin_getservbyname): Ditto.
        (cygwin_getservbyport): Ditto.
        (cygwin_gethostbyname): Ditto.
        (cygwin_gethostbyaddr): Ditto.
@
text
@d185 5
a189 1
  static char *buf = NULL;
d192 1
a192 1
  if (buf)
d194 2
a195 2
      free (buf);
      buf = NULL;
d198 2
a199 2
    buf = strdup (res);
  return buf;
d453 6
d463 3
a465 4
  static struct protoent *res = NULL;
  free_protoent_ptr (res);
  res = dup_protoent_ptr (getprotobyname (p));
  if (!res)
d468 2
a469 2
  dump_protoent (res);
  return res;
d476 3
a478 4
  static struct protoent *res = NULL;
  free_protoent_ptr (res);
  res = dup_protoent_ptr (getprotobynumber (number));
  if (!res)
d481 2
a482 2
  dump_protoent (res);
  return res;
d938 6
d948 3
a950 4
  static struct servent *p = NULL;
  free_servent_ptr (p);
  p = dup_servent_ptr (getservbyname (name, proto));
  if (!p)
d953 2
a954 2
  syscall_printf ("%x = getservbyname (%s, %s)", p, name, proto);
  return p;
d961 3
a963 4
  static struct servent *p = NULL;
  free_servent_ptr (p);
  p = dup_servent_ptr (getservbyport (port, proto));
  if (!p)
d966 2
a967 2
  syscall_printf ("%x = getservbyport (%d, %s)", p, port, proto);
  return p;
d1036 6
d1069 3
a1071 4
  static struct hostent *ptr = NULL;
  free_hostent_ptr (ptr);
  ptr = dup_hostent_ptr (gethostbyname (name));
  if (!ptr)
d1078 1
a1078 1
      debug_printf ("h_name %s", ptr->h_name);
d1081 20
a1100 1
  return ptr;
a1296 20
}

/* exported as gethostbyaddr: standards? */
extern "C" struct hostent *
cygwin_gethostbyaddr (const char *addr, int len, int type)
{
  static struct hostent *ptr = NULL;
  free_hostent_ptr (ptr);
  ptr = dup_hostent_ptr (gethostbyaddr (addr, len, type));
  if (!ptr)
    {
      set_winsock_errno ();
      set_host_errno ();
    }
  else
    {
      debug_printf ("h_name %s", ptr->h_name);
      h_errno = 0;
    }
  return ptr;
@


1.66
log
@        * fhandler.cc (fhandler_base::is_nonblocking): New method.
        (fhandler_base::set_nonblocking): Ditto.
        * fhandler.h (fhandler_base): Declare new methods `is_nonblocking' and
        `set_nonblocking'.
        * fhandler_socket.cc (fhandler_socket::ioctl): Use `set_nonblocking'.
        * fhandler_tty.cc (fhandler_pty_master::process_slave_output):
        Use `is_nonblocking'.
        (fhandler_tty_slave::read): Ditto.
        (fhandler_tty_slave::ioctl): Use `set_nonblocking'.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (cygwin_sendto): Fallback to winsock 1 functionality
        in case of nonblocking IO.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * syscalls.cc (_read): Use `is_nonblocking'.
@
text
@d185 2
d188 8
a195 1
  return res;
d381 68
d453 3
a455 1
  struct protoent *res = getprotobyname (p);
d467 3
a469 1
  struct protoent *res = getprotobynumber (number);
d885 45
d934 3
a936 1
  struct servent *p = getservbyname (name, proto);
d948 3
a950 1
  struct servent *p = getservbyport (port, proto);
d979 45
d1051 3
a1053 1
  struct hostent *ptr = gethostbyname (name);
d1267 3
a1269 1
  struct hostent *ptr = gethostbyaddr (addr, len, type);
@


1.65
log
@        * fhandler.cc (fhandler_base::fcntl): Use new O_NONBLOCK_MASK define.
        * fhandler.h: Move definitions of O_NOSYMLINK, O_DIROPEN and
        OLD_O_NDELAY from winsup.h to here. Add O_NONBLOCK_MASK define.
        * fhandler_socket.cc (fhandler_socket::close): Add hack to allow
        a graceful shutdown even if shutdown() hasn't been called by the
        application. Add debug output.
        (fhandler_socket::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_socket::fcntl): Use new O_NONBLOCK_MASK define. Actually
        set `request' before using it.
        * fhandler_tty.cc: Use new O_NONBLOCK_MASK define throughout.
        (fhandler_tty_slave::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (wsock_event::prepare): Compare WSACreateEvent return code
        with `WSA_INVALID_EVENT' according to MSDN.
        * syscalls.cc (_read): Use new O_NONBLOCK_MASK define.
@
text
@a27 1
#include "perprocess.h"
d514 1
a514 1
  if (!(ovr = wsock_evt.prepare ()))
d560 1
a560 1
  if (!(ovr = wsock_evt.prepare ()))
d1210 1
a1210 1
  if (!(ovr = wsock_evt.prepare ()))
d1251 1
a1251 1
  if (!(ovr = wsock_evt.prepare ()))
@


1.64
log
@* cygheap.cc (cygheap_root::set): Avoid treating '/' specially.
* fhandler.cc (fhandler_base::fcntl): Only set specific O_NDELAY style flag
passed in from application.
* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
* fhandler.h: Set constant for future use.
* winsup.h: Define OLD_O_NDELAY only for old programs.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_OLD_O_NONBLOCK.
@
text
@d73 1
a73 1
  if ((event = WSACreateEvent ()))
@


1.63
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d907 1
a907 1
        peer = (struct sockaddr *) &peer_dummy;
d909 1
a909 1
        {
@


1.62
log
@        * net.cc (cygwin_accept): Allow NULL peer and len parameters.
        * include/cygwin/socket.h: Define socklen_t as int.
@
text
@d125 1
a125 1
  if (os_being_run == winNT)
d1295 1
a1295 1
	     (os_being_run != winNT) ? "System" : "SYSTEM",
d1297 1
a1297 1
	     (os_being_run != winNT) ? "MSTCP" : "Tcpip",
@


1.61
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d903 11
@


1.60
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d29 1
@


1.59
log
@forced commit
@
text
@d58 1
a58 1
        WSACloseEvent (event);
d80 1
a80 1
  
d103 1
a103 1
        }
d105 1
a105 1
        WSASetLastError (WSAEINTR);
d473 1
a473 1
        {
d484 1
a484 1
        }
d529 2
a530 2
                     to, tolen, ovr, NULL) != SOCKET_ERROR)
        res = ret;
d532 4
a535 4
        {
          set_winsock_errno ();
          res = -1;
        }
d537 1
a537 1
        set_winsock_errno ();
d564 1
a564 1
      	  == SOCKET_ERROR)
d575 2
a576 2
                       from, fromlen, ovr, NULL) != SOCKET_ERROR)
        res = ret;
d578 4
a581 4
        {
          set_winsock_errno ();
          res = -1;
        }
d583 1
a583 1
        set_winsock_errno ();
d759 1
a759 1
        {
d769 1
a769 1
        }
d771 5
a775 5
        {
          if (!res || in_progress)
            {
              if (!sock->create_secret_event (secret))
                {   
d780 1
a780 1
            }
d782 2
a783 2
          if (!secret_check_failed && !res)
            {
d789 1
a789 1
           }
d791 2
a792 2
          if (secret_check_failed)
            {
d794 2
a795 2
              if (res)
                closesocket (res);
d798 2
a799 2
            }
        }
d916 1
a916 1
        {
d926 2
a927 2
              (SOCKET) res != (SOCKET) INVALID_SOCKET)
            {
d932 2
a933 2
                }
            }
d935 5
a939 5
          if (secret_check_failed)
            {
              sock->close_secret_event ();
              if ((SOCKET) res != (SOCKET) INVALID_SOCKET)
                closesocket (res);
d941 4
a944 4
              res = -1;
              goto done;
            }
        }
d1023 1
a1023 1
          sock->set_connect_secret ();
d1027 1
a1027 1
          sock->get_connect_secret (strchr (buf, '\0'));
d1161 2
a1162 2
        h_errstr = "Resolver internal error";
        break;
d1164 2
a1165 2
        h_errstr = "Resolver error 0 (no error)";
        break;
d1167 2
a1168 2
        h_errstr = "Unknown resolver error";
        break;
d1203 1
a1203 1
      	  == SOCKET_ERROR)
d1255 2
a1256 2
                   ovr, NULL) != SOCKET_ERROR)
        res = ret;
d1258 4
a1261 4
        {
          set_winsock_errno ();
          res = -1;
        }
d1263 1
a1263 1
        set_winsock_errno ();
d1330 1
a1330 1
        {
d1354 2
a1355 2
          for (ip_cnt = 0; ip_cnt < ipt->dwNumEntries; ++ip_cnt)
            if (ipt->table[ip_cnt].dwIndex == ift->table[if_cnt].dwIndex)
d1357 6
a1362 6
                switch (what)
                  {
                  case SIOCGIFCONF:
                  case SIOCGIFADDR:
                    sa = (struct sockaddr_in *) &ifr->ifr_addr;
                    sa->sin_addr.s_addr = ipt->table[ip_cnt].dwAddr;
d1365 3
a1367 3
                    break;
                  case SIOCGIFBRDADDR:
                    sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
d1370 1
a1370 1
                    sa->sin_addr.s_addr = ipt->table[ip_cnt].dwBCastAddr;
d1372 3
a1374 3
                    lip = ipt->table[ip_cnt].dwAddr;
                    lnp = ipt->table[ip_cnt].dwMask;
                    sa->sin_addr.s_addr = lip & lnp | ~lnp;
d1378 4
a1381 4
                    break;
                  case SIOCGIFNETMASK:
                    sa = (struct sockaddr_in *) &ifr->ifr_netmask;
                    sa->sin_addr.s_addr = ipt->table[ip_cnt].dwMask;
d1384 1
a1384 1
                    break;
d1386 1
a1386 1
                    so = &ifr->ifr_hwaddr;
d1389 1
a1389 1
		        so->sa_data[i] = '\0';
d1391 1
a1391 1
                        so->sa_data[i] = ift->table[if_cnt].bPhysAddr[i];
d1400 3
a1402 3
                  }
                ++cnt;
	        if ((caddr_t) ++ifr >
d1405 2
a1406 2
                break;
              }
d1441 6
a1446 6
                    "SYSTEM\\"
                    "CurrentControlSet\\"
                    "Services\\"
                    "Tcpip\\"
                    "Linkage",
                    0, KEY_READ, &key) == ERROR_SUCCESS)
d1449 12
a1460 12
                           NULL, NULL,
                           NULL, &size) == ERROR_SUCCESS)
        {
          binding = (char *) alloca (size);
          if (RegQueryValueEx (key, "Bind",
                               NULL, NULL,
                               (unsigned char *) binding,
                               &size) != ERROR_SUCCESS)
            {
              binding = NULL;
            }
        }
d1470 61
a1530 61
        {
          bp += strlen ("\\Device\\");
          strcpy (cardkey, "SYSTEM\\CurrentControlSet\\Services\\");
          strcat (cardkey, bp);
          strcat (cardkey, "\\Parameters\\Tcpip");

          if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, cardkey,
                            0, KEY_READ, &key) != ERROR_SUCCESS)
            continue;

          if (RegQueryValueEx (key, "IPAddress",
                               NULL, NULL,
                               (unsigned char *) ipaddress,
                               (size = 256, &size)) == ERROR_SUCCESS
              && RegQueryValueEx (key, "SubnetMask",
                                  NULL, NULL,
                                  (unsigned char *) netmask,
                                  (size = 256, &size)) == ERROR_SUCCESS)
            {
              char *ip, *np;
              char dhcpaddress[256], dhcpnetmask[256];

              for (ip = ipaddress, np = netmask;
                   *ip && *np;
                   ip += strlen (ip) + 1, np += strlen (np) + 1)
                {
                  if ((caddr_t) ++ifr > ifc->ifc_buf
                      + ifc->ifc_len
                      - sizeof (struct ifreq))
                    break;

                  if (! strncmp (bp, "NdisWan", 7))
                    {
                      strcpy (ifr->ifr_name, "ppp");
                      strcat (ifr->ifr_name, bp + 7);
                    }
                  else
                    {
                      ++*eth;
                      strcpy (ifr->ifr_name, "eth");
                      strcat (ifr->ifr_name, eth);
                    }
                  memset (&ifr->ifr_addr, '\0', sizeof ifr->ifr_addr);
                  if (cygwin_inet_addr (ip) == 0L
                      && RegQueryValueEx (key, "DhcpIPAddress",
                                          NULL, NULL,
                                          (unsigned char *) dhcpaddress,
                                          (size = 256, &size))
                      == ERROR_SUCCESS
                      && RegQueryValueEx (key, "DhcpSubnetMask",
                                          NULL, NULL,
                                          (unsigned char *) dhcpnetmask,
                                          (size = 256, &size))
                      == ERROR_SUCCESS)
                    {
                      switch (what)
                        {
                        case SIOCGIFCONF:
                        case SIOCGIFADDR:
                          sa = (struct sockaddr_in *) &ifr->ifr_addr;
                          sa->sin_addr.s_addr = cygwin_inet_addr (dhcpaddress);
d1533 6
a1538 6
                          break;
                        case SIOCGIFBRDADDR:
                          lip = cygwin_inet_addr (dhcpaddress);
                          lnp = cygwin_inet_addr (dhcpnetmask);
                          sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
                          sa->sin_addr.s_addr = lip & lnp | ~lnp;
d1541 5
a1545 5
                          break;
                        case SIOCGIFNETMASK:
                          sa = (struct sockaddr_in *) &ifr->ifr_netmask;
                          sa->sin_addr.s_addr =
                            cygwin_inet_addr (dhcpnetmask);
d1548 2
a1549 2
                          break;
		        case SIOCGIFHWADDR:
d1554 1
a1554 1
		        case SIOCGIFMETRIC:
d1560 10
a1569 10
                        }
                    }
                  else
                    {
                      switch (what)
                        {
                        case SIOCGIFCONF:
                        case SIOCGIFADDR:
                          sa = (struct sockaddr_in *) &ifr->ifr_addr;
                          sa->sin_addr.s_addr = cygwin_inet_addr (ip);
d1572 6
a1577 6
                          break;
                        case SIOCGIFBRDADDR:
                          lip = cygwin_inet_addr (ip);
                          lnp = cygwin_inet_addr (np);
                          sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
                          sa->sin_addr.s_addr = lip & lnp | ~lnp;
d1580 4
a1583 4
                          break;
                        case SIOCGIFNETMASK:
                          sa = (struct sockaddr_in *) &ifr->ifr_netmask;
                          sa->sin_addr.s_addr = cygwin_inet_addr (np);
d1586 2
a1587 2
                          break;
		        case SIOCGIFHWADDR:
d1592 1
a1592 1
		        case SIOCGIFMETRIC:
d1598 7
a1604 7
                        }
                    }
                  ++cnt;
                }
            }
          RegCloseKey (key);
        }
d1647 1
a1647 1
                    0, KEY_READ, &key) != ERROR_SUCCESS)
d1656 2
a1657 2
                            (size = sizeof ifname, &size),
                            0, 0, 0, &update)) != ERROR_NO_MORE_ITEMS;
d1665 3
a1667 3
          || RegOpenKeyEx (key, ifname, 0,
                           KEY_READ, &ifkey) != ERROR_SUCCESS)
        continue;
d1670 6
a1675 6
                           NULL, (unsigned char *) driver,
                           (size = sizeof driver, &size)) != ERROR_SUCCESS)
        {
          RegCloseKey (ifkey);
          continue;
        }
d1680 5
a1684 5
                               0, KEY_READ, &subkey)) != ERROR_SUCCESS)
        {
          RegCloseKey (ifkey);
          continue;
        }
d1687 17
a1703 17
                           NULL, (unsigned char *) ip,
                           (size = sizeof ip, &size)) == ERROR_SUCCESS
          && RegQueryValueEx (subkey, "IPMask", 0,
                              NULL, (unsigned char *) np,
                              (size = sizeof np, &size)) == ERROR_SUCCESS)
        {
          if ((caddr_t)++ifr > ifc->ifc_buf
              + ifc->ifc_len
              - sizeof (struct ifreq))
            goto out;

          switch (what)
            {
            case SIOCGIFCONF:
            case SIOCGIFADDR:
              sa = (struct sockaddr_in *) &ifr->ifr_addr;
              sa->sin_addr.s_addr = cygwin_inet_addr (ip);
d1706 6
a1711 6
              break;
            case SIOCGIFBRDADDR:
              lip = cygwin_inet_addr (ip);
              lnp = cygwin_inet_addr (np);
              sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
              sa->sin_addr.s_addr = lip & lnp | ~lnp;
d1714 4
a1717 4
              break;
            case SIOCGIFNETMASK:
              sa = (struct sockaddr_in *) &ifr->ifr_netmask;
              sa->sin_addr.s_addr = cygwin_inet_addr (np);
d1720 1
a1720 1
              break;
d1732 2
a1733 2
            }
        }
d1738 6
a1743 6
                         0, KEY_READ, &subkey) != ERROR_SUCCESS)
        {
          RegCloseKey (ifkey);
          --ifr;
          continue;
        }
d1746 6
a1751 6
           (res = RegEnumValue (subkey, j, bindname,
                                (size = sizeof bindname, &size),
                                0, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS;
           ++j)
        if (!strncasecmp (bindname, "VREDIR\\", 7))
          break;
d1756 3
a1758 27
        {
          strcpy (netname, "System\\CurrentControlSet\\Services\\Class\\Net\\");
          strcat (netname, bindname + 7);

          if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, netname,
                            0, KEY_READ, &subkey) != ERROR_SUCCESS)
            {
              RegCloseKey (ifkey);
              --ifr;
              continue;
            }

          if (RegQueryValueEx (subkey, "AdapterName", 0,
                               NULL, (unsigned char *) adapter,
                               (size = sizeof adapter, &size)) == ERROR_SUCCESS
              && strcasematch (adapter, "MS$PPP"))
            {
              ++*ppp;
              strcpy (ifr->ifr_name, "ppp");
              strcat (ifr->ifr_name, ppp);
            }
          else
            {
              ++*eth;
              strcpy (ifr->ifr_name, "eth");
              strcat (ifr->ifr_name, eth);
            }
d1760 7
a1766 1
          RegCloseKey (subkey);
d1768 19
a1786 1
        }
d1866 2
a1867 2
          || (os_version_info.dwMajorVersion == 4
              && os_version_info.dwMinorVersion == 0)))
d1871 1
a1871 1
           && (os_version_info.dwMajorVersion < 4
d1873 1
a1873 1
	           && strcmp (os_version_info.szCSDVersion, "Service Pack 4") < 0)))
@


1.58
log
@* fhandler_socket.cc (fhandler_socket::signal_secret_event): New
function.
* fhandler.h: Declare it.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Don't
signal secret event immediately.
(fhandler_socket::check_peer_secret_event): Do it after peer event
was opened.
* net.cc (cygwin_connect): Or if socket is non-blocking.
(cygwin_accept): Ditto.
@
text
@@


1.57
log
@        * net.cc (wsock_event): Add destructor.
@
text
@d742 1
d763 4
a766 1
 	    WSASetLastError (WSAEINPROGRESS);
d772 1
a772 1
          if (!res || errno == EINPROGRESS)
d778 2
d896 1
d911 4
d917 7
a923 8
          if (((SOCKET) res != (SOCKET) INVALID_SOCKET ||
               WSAGetLastError () == WSAEWOULDBLOCK))
            {
              if (!sock->create_secret_event ())
		{
		  secret_check_failed = TRUE;
                }
            }
d925 1
a925 1
          if (!secret_check_failed &&
@


1.56
log
@        * net.cc (wsock_event::wait): Explicitely cancel IO when a signal
        arrived to avoid data loss. Fallback to blocking IO when canceling
        fails.
@
text
@d55 6
@


1.55
log
@        * net.cc (errmap): Add missing mapping from WSAEINTR to EINTR.
@
text
@d93 7
a99 1
      WSASetLastError (WSAEINTR);
@


1.54
log
@* autoload.h: Eliminate.
* autoload.cc: Pull in autoload.h.  Eliminate many macros.  Rewrite to avoid
necessity of initialization routines.  Just use a standard one.
(wsock_init): New function.  Moved from net.cc.
* net.cc (wsock_init): Move to autoload.cc.
(wsadata): Make global.
* dtable.cc (dtable::build_fhandler): Use more reliable method for checking if
net stuff has been loaded.
@
text
@d266 1
@


1.53
log
@        * autoload.cc: Add autoload statements for ws2_32 functions
        `WSACloseEvent', `WSACreateEvent', `WSAGetOverlappedResult',
        `WSARecv', `WSARecvFrom', `WSASend', `WSASendTo' and `WSASetEvent',
        `WSAWaitForMultipleEvents'.
        * net.cc: Define wsock_evt.
        (wsock_event): New class.
        (cygwin_sendto): Use overlapped socket io if available.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * security.cc (subauth): Set Win32 error to 0 to safely ask for the
        error code of dynamically loaded function `LsaRegisterLogonProcess'.
@
text
@d106 1
a106 1
static WSADATA wsadata;
a2067 39

extern "C" void
wsock_init ()
{
  static LONG NO_COPY here = -1L;
  static int NO_COPY wsock_started = 0;

  while (InterlockedIncrement (&here))
    {
      InterlockedDecrement (&here);
      Sleep (0);
    }
  if (!wsock_started && (wsock32_handle || ws2_32_handle))
    {
      /* Don't use autoload to load WSAStartup to eliminate recursion. */
      int (*wsastartup) (int, WSADATA *);

      wsastartup = (int (*)(int, WSADATA *))
      		   GetProcAddress ((HMODULE) (wsock32_handle ?: ws2_32_handle),
				   "WSAStartup");
      if (wsastartup)
        {
	  int res = wsastartup ((2<<8) | 2, &wsadata);

	  debug_printf ("res %d", res);
	  debug_printf ("wVersion %d", wsadata.wVersion);
	  debug_printf ("wHighVersion %d", wsadata.wHighVersion);
	  debug_printf ("szDescription %s", wsadata.szDescription);
	  debug_printf ("szSystemStatus %s", wsadata.szSystemStatus);
	  debug_printf ("iMaxSockets %d", wsadata.iMaxSockets);
	  debug_printf ("iMaxUdpDg %d", wsadata.iMaxUdpDg);
	  debug_printf ("lpVendorInfo %d", wsadata.lpVendorInfo);

	  wsock_started = 1;
        }
    }
  InterlockedDecrement (&here);
}

@


1.52
log
@Revert much of previous erroneous checkin.  Add ChangeLog entry.

* pinfo.h: Correctly set __SIGOFFSET.
* path.cc (hash_path_name): Avoid calling library functions for simple copying
of characters.
* shortcut.c: Use WIN32_LEAN_AND_MEAN.
* smallprint.c: Ditto.
* environ.cc (getwinenv): Minor clarity fix.
* localtime.c: No need to include windows.h
* string.h: New file.
@
text
@d49 57
d491 3
d501 11
a511 3
  int res = sendto (h->get_socket (), (const char *) buf, len,
		    flags, to, tolen);
  if (res == SOCKET_ERROR)
d513 12
a524 2
      set_winsock_errno ();
      res = -1;
d526 3
d541 3
d547 11
a557 4
  debug_printf ("recvfrom %d", h->get_socket ());

  int res = recvfrom (h->get_socket (), buf, len, flags, from, fromlen);
  if (res == SOCKET_ERROR)
d559 12
a570 2
      set_winsock_errno ();
      res = -1;
d573 2
d1170 3
d1176 1
a1176 2
  int res = recv (h->get_socket (), (char *) buf, len, flags);
  if (res == SOCKET_ERROR)
d1178 22
a1199 2
      set_winsock_errno ();
      res = -1;
a1201 6
#if 0
  if (res > 0 && res < 200)
    for (int i=0; i < res; i++)
      system_printf ("%d %x %c", i, ((char *) buf)[i], ((char *) buf)[i]);
#endif

d1211 3
d1217 1
a1217 2
  int res = send (h->get_socket (), (const char *) buf, len, flags);
  if (res == SOCKET_ERROR)
d1219 22
a1240 2
      set_winsock_errno ();
      res = -1;
@


1.51
log
@* exceptions.cc (ctrl_c_handler): Always send signal to process if it has no
tty.
@
text
@d1934 1
a1934 1
  while (ilockincr (&here))
d1936 1
a1936 1
      ilockdecr (&here);
d1963 1
a1963 1
  ilockdecr (&here);
@


1.50
log
@        * net.cc (wsock_init): Rename `was_in_progress' to `wsock_started'
        for clearness.
@
text
@d1934 1
a1934 1
  while (InterlockedIncrement (&here))
d1936 1
a1936 1
      InterlockedDecrement (&here);
d1963 1
a1963 1
  InterlockedDecrement (&here);
@


1.49
log
@        * autoload.cc: Use new definition of LoadDLLinitfunc throughout.
        Redefine wrapper for wsock32.dll and ws2_32.dll.
        (std_dll_init): New function.
        * autoload.h: Rename LoadDLLinitfunc to LoadDLLinitfuncdef.
        Add new defines LoadDLLinitfunc and LoadDLLstdfunc.
        * net.cc (wsock_init): Add guard variable handling. Take care
        to call WSAStartup only once. Load WSAStartup without using
        autoload wrapper to eliminate recursion.  Eliminate FIONBIO
        and srandom stuff.
@
text
@d1932 1
a1932 1
  static int NO_COPY was_in_progress = 0;
d1939 1
a1939 1
  if (!was_in_progress && (wsock32_handle || ws2_32_handle))
d1960 1
a1960 1
	  was_in_progress = 1;
@


1.48
log
@* net.cc [errmap]: Add '0' condition.
(find_winsock_errno): Don't translate no error to EPERM.
@
text
@d1931 2
a1932 1
  int res = WSAStartup ((2<<8) | 2, &wsadata);
d1934 9
a1942 8
  debug_printf ("res %d", res);
  debug_printf ("wVersion %d", wsadata.wVersion);
  debug_printf ("wHighVersion %d", wsadata.wHighVersion);
  debug_printf ("szDescription %s", wsadata.szDescription);
  debug_printf ("szSystemStatus %s", wsadata.szSystemStatus);
  debug_printf ("iMaxSockets %d", wsadata.iMaxSockets);
  debug_printf ("iMaxUdpDg %d", wsadata.iMaxUdpDg);
  debug_printf ("lpVendorInfo %d", wsadata.lpVendorInfo);
d1944 6
a1949 2
  if (FIONBIO  != REAL_FIONBIO)
    debug_printf ("****************  FIONBIO  != REAL_FIONBIO");
d1951 13
a1963 2
  /* FIXME: will resulting random sequence be unpredictable enough? */
  srandom (GetTickCount ());
@


1.47
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d248 1
d255 1
a255 1
  for (int i = 0; errmap[i].w != 0; ++i)
@


1.46
log
@* net.cc (cygwin_socket): Set SO_LINGER to small value so closed UNIX domain
sockets will not stay around.
* select.cc (socket_cleanup): Set SO_LINGER to small value so closed dummy
sockets do not stay around.  Use correct value for second argument to shutdown.
@
text
@a26 1
#include "cygheap.h"
d32 1
d330 1
a330 1
  fhandler_socket *fh = (fhandler_socket *) fdtab.build_fhandler (fd, FH_SOCKET, name);
d333 1
a333 1
  fdtab.inc_need_fixup_before ();
d346 1
a346 1
  int fd = fdtab.find_unused_handle ();
d366 1
a366 6
	{
	  name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");
	  /* Set LINGER with 0 timeout for hard close */
	  struct linger tmp = {1, 0}; /* On, 0 delay */
	  (void) setsockopt (soc, SOL_SOCKET, SO_LINGER, (char *)&tmp, sizeof(tmp));
	}
d433 1
a433 1
  fhandler_socket *h = (fhandler_socket *) fdtab[fd];
d459 1
a459 1
  fhandler_socket *h = (fhandler_socket *) fdtab[fd];
d478 1
a478 1
  if (fdtab.not_open (fd))
d484 1
a484 1
  return fdtab[fd]->is_socket ();
d821 1
a821 1
      int res_fd = fdtab.find_unused_handle ();
d1019 1
a1019 1
  if (fdtab.not_open (2))
d1051 1
a1051 1
  fhandler_socket *h = (fhandler_socket *) fdtab[fd];
d1066 1
a1066 1
  fhandler_socket *h = (fhandler_socket *) fdtab[fd];
d1091 1
a1091 1
  fhandler_socket *h = (fhandler_socket *) fdtab[fd];
d1726 1
a1726 1
  int res_fd = fdtab.find_unused_handle ();
d1732 1
a1732 1
      *fd2p = fdtab.find_unused_handle (res_fd + 1);
d1761 1
a1761 1
  int res_fd = fdtab.find_unused_handle ();
d1787 1
a1787 1
  int res_fd = fdtab.find_unused_handle ();
d1792 1
a1792 1
      *fd2p = fdtab.find_unused_handle (res_fd + 1);
d1824 1
a1824 1
  sb[0] = fdtab.find_unused_handle ();
d1830 1
a1830 1
  sb[1] = fdtab.find_unused_handle (sb[0] + 1);
@


1.45
log
@* fhandler.h (class fhandler_socket): Add members and methods to
support secure connections on AF_UNIX sockets.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): New method.
(fhandler_socket::get_connect_secret): Ditto.
(fhandler_socket::create_secret_event): Ditto.
(fhandler_socket::close_secret_event): Ditto.
(fhandler_socket::check_peer_secret_event): Ditto.
(fhandler_socket::fixup_after_fork): Duplicate secret event to child.
(fhandler_socket::dup): Copy address family.
(fhandler_socket::close): Close secret event.
* net.cc (get_inet_addr): Read secret cookie.
(cygwin_connect): Check if peer knows secret cookie value.
(cygwin_accept): Ditto. Copy address family to newly created socket.
(cygwin_bind): Generate and write secret cookie.
(wsock_init): Initialize random number generator.
@
text
@d366 6
a371 1
	name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");
@


1.44
log
@* cygrun.c (main): Fix compiler warning.
* gmon.c (_mcleanup): Ditto.
* profil.c (profile_off): Ditto.
* net.cc (find_winsock_errno): New function.
(__set_winsock_errno): Use find_winsock_errno.
(cygwin_setsockopt): Detect SO_ERROR for debugging.
(cygwin_getsockopt): Ditto.  Translate error when getsockopt returns SO_ERROR.
* winsup.h: regparmize __set_winsock_errno.
* include/sys/strace.h: Document that strace functions can't use regparm.
@
text
@d21 1
d381 1
a381 1
			   struct sockaddr_in *out, int *outlen)
d383 3
d399 1
a399 1
      char buf[32];
d405 3
a407 1
	  sscanf (buf + strlen (SOCKET_COOKIE), "%hu", &sin.sin_port);
d624 1
d627 1
d630 1
a630 1
  if (get_inet_addr (name, namelen, &sin, &namelen) == 0)
d649 28
d772 1
d787 32
d826 1
a826 1
	  goto done;
d832 2
a833 1
	  fdsock (res_fd, sock->get_name (), res);
d837 2
a840 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK|READ_LOCK, "accept");
d896 5
a900 2
	  char buf[sizeof (SOCKET_COOKIE) + 10];
	  __small_sprintf (buf, "%s%u", SOCKET_COOKIE, sin.sin_port);
d1943 3
@


1.43
log
@* dtable.cc: Guard against new winsock.h/winsock2.h warnings when mixing
winsock*.h and sys/types.h.
* fhandler_socket.cc: Ditto.
* net.cc: Ditto.
* select.cc: Ditto.
* exceptions.cc: Remove unneeded define.
@
text
@d250 10
d264 4
a267 16
  int i;
  int why = WSAGetLastError ();
  for (i = 0; errmap[i].w != 0; ++i)
    if (why == errmap[i].w)
      break;

  if (errmap[i].w != 0)
    {
      syscall_printf ("%s:%d - %d (%s) -> %d", fn, ln, why, errmap[i].s, errmap[i].e);
      set_errno (errmap[i].e);
    }
  else
    {
      syscall_printf ("%s:%d - unknown error %d", fn, ln, why);
      set_errno (EPERM);
    }
d525 3
d588 3
d595 6
@


1.42
log
@        * net.cc (get_95_ifconf): Use strcasematch instead of strcasecmp.
        * syscalls.cc (_unlink): Ditto.
        (_rename): Ditto.
@
text
@a14 1
#define Win32_Winsock
d24 1
@


1.41
log
@        * net.cc (cygwin_socket): Set protocol to 0 when address family is
	AF_UNIX to avoid WSAEPROTONOSUPPORT error.
@
text
@d1522 1
a1522 1
              && !strcasecmp (adapter, "MS$PPP"))
@


1.40
log
@	* net.cc (cygwin_socket): Pass protocol parameter to socket call.
@
text
@d355 1
a355 1
      soc = socket (AF_INET, type, protocol);
@


1.39
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d355 1
a355 1
      soc = socket (AF_INET, type, 0);
@


1.38
log
@        * autoload.cc: Add LoadDLLinitfunc for iphlpapi.dll.
        Add LoadDLLfuncEx statements for GetIfTable@@12 and GetIpAddrTable@@12.
        * fhandler_socket.cc (fhandler_socket::ioctl): Move variable
        definitions to the beginning of the function to allow better debugging.
        Add handling for SIOCGIFHWADDR, SIOCGIFMETRIC and SIOCGIFMTU.
        * net.cc: Include iphlpapi.h.
        (get_2k_ifconf): Rewritten. Uses IP Helper API now.
        (get_nt_ifconf): Add handling for SIOCGIFHWADDR, SIOCGIFMETRIC
        and SIOCGIFMTU.
        (get_95_ifconf): Ditto. Renamed from `get_9x_ifconf'.
        (get_ifconf): Name loopback `lo' instead of `lo0' as in Linux.
        Add handling for SIOCGIFHWADDR, SIOCGIFMETRIC and SIOCGIFMTU.
        Call `get_95_ifconf' only on Windows 95, `get_nt_ifconf' only
        on Windows NT < Service Pack 3, `get_2k_ifconf otherwise.
        * include/asm/socket.h: Add defines for SIOCGIFHWADDR, SIOCGIFMETRIC
        and SIOCGIFMTU.
        * include/cygwin/if.h: Add `ifr_hwaddr', `ifr_metric' and `ifr_mtu'.
        (struct ifreq): Add `ifru_hwaddr'.
@
text
@d28 1
@


1.37
log
@        Patch suggested by Ren Mller Fonseca <fonseca@@mip.sdu.dk>
        * include/sys/socket.h: Change prototype to have 2nd parameter `const'.
        * net.cc (cygwin_bind): Change 2nd parameter to `const'.
@
text
@d20 1
d1052 2
a1053 4
 * IFCONF Windows 2000:
 * Look at HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\
                                                        Parameters\Interfaces
 * Each subkey is an interface.
d1058 2
a1059 2
  HKEY key;
  int cnt = 1;
d1064 14
a1077 8
  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    "SYSTEM\\"
                    "CurrentControlSet\\"
                    "Services\\"
                    "Tcpip\\"
                    "Parameters\\"
                    "Interfaces",
                    0, KEY_READ, &key) == ERROR_SUCCESS)
d1079 1
a1079 11
      HKEY ikey;
      unsigned long lip, lnp;
      struct sockaddr_in *sa = NULL;
      char name[256];
      DWORD size;
      char eth[2] = "/", ppp[2] = "/";

      for (int idx = 0;
           RegEnumKeyEx (key, idx, name, (size = 256, &size),
                         NULL, NULL, 0, NULL) == ERROR_SUCCESS;
           ++idx)
d1081 77
a1157 110
          if (RegOpenKeyEx (key, name, 0, KEY_READ, &ikey) != ERROR_SUCCESS)
            continue;

          /* If the "NTEContextList" value not exists, the subkey
             is irrelevant. */
          if (RegQueryValueEx (ikey, "NTEContextList",
                               NULL, NULL, NULL, &size) != ERROR_SUCCESS)
            {
              RegCloseKey (ikey);
              continue;
            }

          if ((caddr_t) ++ifr > ifc->ifc_buf
              + ifc->ifc_len
              - sizeof (struct ifreq))
            {
              RegCloseKey (ikey);
              break;
            }

          char ipaddress[256], netmask[256];
          char dhcpaddress[256], dhcpnetmask[256];

          if (RegQueryValueEx (ikey, "IPAddress",
                               NULL, NULL,
                               (unsigned char *) ipaddress,
                               (size = 256, &size)) == ERROR_SUCCESS
              && RegQueryValueEx (ikey, "SubnetMask",
                                  NULL, NULL,
                                  (unsigned char *) netmask,
                                  (size = 256, &size)) == ERROR_SUCCESS)
            {
              /* ppp interfaces don't have the "AddressType" value. */
              if (RegQueryValueEx (ikey, "AddressType",
                                   NULL, NULL, NULL, &size) == ERROR_SUCCESS)
                {
                  ++*eth;
                  strcpy (ifr->ifr_name, "eth");
                  strcat (ifr->ifr_name, eth);
                }
              else
                {
                  ++*ppp;
                  strcpy (ifr->ifr_name, "ppp");
                  strcat (ifr->ifr_name, ppp);
                }

              memset (&ifr->ifr_addr, '\0', sizeof ifr->ifr_addr);
              if (cygwin_inet_addr (ipaddress) == 0L
                  && RegQueryValueEx (ikey, "DhcpIPAddress",
                                      NULL, NULL,
                                      (unsigned char *) dhcpaddress,
                                      (size = 256, &size))
                  == ERROR_SUCCESS
                  && RegQueryValueEx (ikey, "DhcpSubnetMask",
                                      NULL, NULL,
                                      (unsigned char *) dhcpnetmask,
                                      (size = 256, &size))
                  == ERROR_SUCCESS)
                {
                  switch (what)
                    {
                    case SIOCGIFCONF:
                    case SIOCGIFADDR:
                      sa = (struct sockaddr_in *) &ifr->ifr_addr;
                      sa->sin_addr.s_addr = cygwin_inet_addr (dhcpaddress);
                      break;
                    case SIOCGIFBRDADDR:
                      lip = cygwin_inet_addr (dhcpaddress);
                      lnp = cygwin_inet_addr (dhcpnetmask);
                      sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
                      sa->sin_addr.s_addr = lip & lnp | ~lnp;
                      break;
                    case SIOCGIFNETMASK:
                      sa = (struct sockaddr_in *) &ifr->ifr_netmask;
                      sa->sin_addr.s_addr =
                        cygwin_inet_addr (dhcpnetmask);
                      break;
                    }
                }
              else
                {
                  switch (what)
                    {
                    case SIOCGIFCONF:
                    case SIOCGIFADDR:
                      sa = (struct sockaddr_in *) &ifr->ifr_addr;
                      sa->sin_addr.s_addr = cygwin_inet_addr (ipaddress);
                      break;
                    case SIOCGIFBRDADDR:
                      lip = cygwin_inet_addr (ipaddress);
                      lnp = cygwin_inet_addr (netmask);
                      sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
                      sa->sin_addr.s_addr = lip & lnp | ~lnp;
                      break;
                    case SIOCGIFNETMASK:
                      sa = (struct sockaddr_in *) &ifr->ifr_netmask;
                      sa->sin_addr.s_addr = cygwin_inet_addr (netmask);
                      break;
                    }
                }
              sa->sin_family = AF_INET;
              sa->sin_port = 0;
              ++cnt;
            }

          RegCloseKey (ikey);
        }

      RegCloseKey (key);
d1159 1
a1159 1

d1165 1
a1165 1
 * IFCONF Windows NT:
d1182 1
d1281 2
d1289 2
d1296 2
d1299 11
d1320 2
d1328 2
d1334 2
d1337 11
a1349 2
                  sa->sin_family = AF_INET;
                  sa->sin_port = 0;
d1362 1
a1362 1
 * IFCONF Windows 9x:
d1379 1
a1379 1
get_9x_ifconf (struct ifconf *ifc, int what)
d1384 1
d1454 2
d1462 2
d1468 2
d1471 11
a1482 2
          sa->sin_family = AF_INET;
          sa->sin_port = 0;
d1568 1
a1568 1
  strcpy (ifr->ifr_name, "lo0");
d1576 2
d1584 2
d1590 13
a1607 2
  sa->sin_family = AF_INET;
  sa->sin_port = 0;
d1613 11
a1623 3
  if (os_version_info.dwPlatformId != VER_PLATFORM_WIN32_NT)
    get_9x_ifconf (ifc, what);
  else if (os_version_info.dwMajorVersion <= 4)
d1625 1
@


1.36
log
@        * net.cc (cygwin_rexec): Eliminate superfluous call to
        `set_socket_inheritance'.
        * include/sys/socket.h: Add SUS defines for option values to `shutdown'.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
d763 1
a763 1
cygwin_bind (int fd, struct sockaddr *my_addr, int addrlen)
@


1.35
log
@        * net.cc (get_inet_addr ): Close AF_UNIX socket file after reading.
@
text
@d1685 2
a1686 4
    {
      fd2s = set_socket_inheritance (fd2s);
      fdsock (*fd2p, "/dev/tcp", fd2s);
    }
@


1.34
log
@        * net.cc (cygwin_inet_aton): Return nonzero if the address
	is valid, zero if not according to Linux man page.
@
text
@d390 5
a394 1
      sockaddr_in sin;
a395 1

d397 13
a409 12
      int fd = open (in->sa_data, O_RDONLY);
      if (fd == -1)
	return 0;
      if (read (fd, buf, sizeof buf) == -1)
	return 0;
      sin.sin_family = AF_INET;
      sscanf (buf + strlen (SOCKET_COOKIE), "%hu", &sin.sin_port);
      sin.sin_port = htons (sin.sin_port);
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      *out = sin;
      *outlen = sizeof sin;
      return 1;
@


1.33
log
@        * net.cc (cygwin_inet_aton): New function.
        * cygwin.din: Export cygwin_inet_aton as inet_aton.
@
text
@d133 1
a133 1
    return -1;
d136 1
a136 1
  return 0;
@


1.32
log
@* cygheap.h (init_cygheap): New struct holding values that live in the Cygwin
heap.
* child_info.h (child_info): Change pointer type of cygheap to init_cygheap.
* cygheap.cc (init_cheap): Point cygheap_max after contents of cygheap.  Move
some stuff into cygheap.h.
* dir.cc (opendir): Change to use root and rootlen in cygheap rather than in
myself.
(mkdir): Change to use umask in cygheap rather than in myself.
* path.cc: Ditto, throughout.
* syscalls.cc (_open): Ditto.  Change to use umask in cygheap rather than in
myself.
(chroot): Change to allocate root dir on the cygwin heap.
(umask): Change to use umask in cygheap rather than in myself.
(cygwin_bind): Ditto.
* sigproc.cc (proc_subproc): Don't copy umask or root stuff as this happens
automatically now.
* pinfo.h (_pinfo): Migrate stuff out of here and into init_cheap.
* dcrt0.cc (dll_crt0_1): Call cygheap_init later in startup for first cygwin
process.
@
text
@d109 1
a109 1
/* exported as inet_ntoa: standards? */
d117 1
a117 1
/* exported as inet_addr: standards? */
d123 14
@


1.31
log
@        * autoload.cc: Add autoload statement for `WSASetLastError'.
        * net.cc (cygwin_connect): Change error code to WSAEINPROGRESS
        when connect returns WSAEWOULDBLOCK.
@
text
@d810 1
a810 1
		(S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO) & ~myself->umask);
@


1.30
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d603 8
a610 1
	set_winsock_errno ();
@


1.29
log
@        * autoload.cc: New file keeping all autoload stuff.
        * Makefile.in: Add autoload.o to dependencies.
        * dcrt0.cc: Move all autoload stuff to autoload.cc.
        * fhandler_mem.cc: Ditto.
        * net.cc: Ditto.
        * uinfo.cc: Ditto.
@
text
@d128 1
a128 1
extern "C" unsigned int 
@


1.28
log
@        * fhandler_socket.cc: New file.
        * Makefile.in: Add fhandler_socket.o to dependencies.
        * fhandler.h: Change comment.
        * net.cc Move all fhandler_socket methods to fhandler_socket.cc.
        * winsup.h: Add declaration for `ws2_32_handle'.
@
text
@a23 1
#include "autoload.h"
d1784 1
a1784 1
static void
a1801 80
extern "C" {
/* Initialize WinSock */
LoadDLLinitfunc (wsock32)
{
  HANDLE h;

  if ((h = LoadLibrary ("wsock32.dll")) != NULL)
    wsock32_handle = h;
  else if (!wsock32_handle)
    api_fatal ("could not load wsock32.dll.  Is TCP/IP installed?");
  else
    return 0;		/* Already done by another thread? */

  if (!ws2_32_handle)
    wsock_init ();

  return 0;
}

/* Initialize WinSock2.0 */
LoadDLLinitfunc (ws2_32)
{
  HANDLE h;

  if ((h = LoadLibrary ("ws2_32.dll")) == NULL)
    return 0;          /* Already done or not available. */
  ws2_32_handle = h;

  if (!wsock32_handle)
    wsock_init ();

  return 0;
}

static void dummy_autoload (void) __attribute__ ((unused));
static void
dummy_autoload (void)
{
LoadDLLinit (wsock32)
LoadDLLfunc (WSAAsyncSelect, 16, wsock32)
LoadDLLfunc (WSACleanup, 0, wsock32)
LoadDLLfunc (WSAGetLastError, 0, wsock32)
LoadDLLfunc (WSAStartup, 8, wsock32)
LoadDLLfunc (__WSAFDIsSet, 8, wsock32)
LoadDLLfunc (accept, 12, wsock32)
LoadDLLfunc (bind, 12, wsock32)
LoadDLLfunc (closesocket, 4, wsock32)
LoadDLLfunc (connect, 12, wsock32)
LoadDLLfunc (gethostbyaddr, 12, wsock32)
LoadDLLfunc (gethostbyname, 4, wsock32)
LoadDLLfunc (gethostname, 8, wsock32)
LoadDLLfunc (getpeername, 12, wsock32)
LoadDLLfunc (getprotobyname, 4, wsock32)
LoadDLLfunc (getprotobynumber, 4, wsock32)
LoadDLLfunc (getservbyname, 8, wsock32)
LoadDLLfunc (getservbyport, 8, wsock32)
LoadDLLfunc (getsockname, 12, wsock32)
LoadDLLfunc (getsockopt, 20, wsock32)
LoadDLLfunc (inet_addr, 4, wsock32)
LoadDLLfunc (inet_network, 4, wsock32)
LoadDLLfunc (inet_ntoa, 4, wsock32)
LoadDLLfunc (ioctlsocket, 12, wsock32)
LoadDLLfunc (listen, 8, wsock32)
LoadDLLfunc (rcmd, 24, wsock32)
LoadDLLfunc (recv, 16, wsock32)
LoadDLLfunc (recvfrom, 24, wsock32)
LoadDLLfunc (rexec, 24, wsock32)
LoadDLLfunc (rresvport, 4, wsock32)
LoadDLLfunc (select, 20, wsock32)
LoadDLLfunc (send, 16, wsock32)
LoadDLLfunc (sendto, 24, wsock32)
LoadDLLfunc (setsockopt, 20, wsock32)
LoadDLLfunc (shutdown, 8, wsock32)
LoadDLLfunc (socket, 12, wsock32)

LoadDLLinit (ws2_32)
LoadDLLfuncEx (WSADuplicateSocketA, 12, ws2_32, 1)
LoadDLLfuncEx (WSASocketA, 24, ws2_32, 1)
}
}
@


1.27
log
@        * dtable.cc (dtable::release): Check for socket. Change
        cnt_need_fixup_before accordingly.
        (dtable::dup2): Ditto.
        (dtable::fixup_before_fork): New method.
        (dtable::fixup_before_exec): Ditto.
        * dtable.h (class dtable): Add member `cnt_need_fixup_before'. Add
        definition for methods `dec_need_fixup_before', `inc_need_fixup_before',
        `need_fixup_before', `fixup_before_exec' and `fixup_before_fork'.
        * fhandler.h (class fhandler_base): Slight rearrangements. Add
        definitions for methods `fixup_before_fork_exec'.
        (class fhandler_socket): Eliminate superfluous constructor.
        Add member `prot_info_ptr'. Add destructor. Add definitions for
        methods `dup', `fixup_before_fork_exec', `fixup_after_fork' and
        `fixup_after_exec'.
        * fork.cc (fork_parent): Care for file types which need a fixup
        before fork. Start child in suspended state then.
        * net.cc: New global variable `ws2_32_handle' and `wsadata'.
        (fdsock): Check for Winsock version. Call `set_socket_inheritance'
        only if Winsock version < 2.0. Care for `need_fixup' count in fdtab.
        (cygwin_socket): Eliminate call to `set_socket_inheritance'.
        (cygwin_accept): Ditto.
        (cygwin_rcmd): Ditto.
        (cygwin_rresvport): Ditto.
        (cygwin_rexec): Ditto.
        (socketpair): Ditto.
        (fhandler_socket::fhandler_socket): Set `need_fork_fixup'. Allocate
        space for the WSAPROTOCOL_INFOA struct used in fixup.
        (fhandler_socket::~fhandler_socket): New destructor.
        (fhandler_socket::fixup_before_fork_exec): New method.
        (fhandler_socket::fixup_after_fork): Ditto.
        (fhandler_socket::dup): Ditto.
        (wsock_init): New static function.
        (LoadDLLinitfunc (wsock32)): Rearranged.
        (LoadDLLinitfunc (ws2_32)): New function.
        (dummy_autoload): Add autoload statemants for `WSADuplicateSocketA'
        and `WSASocketA'.
        * spawn.cc (spawn_guts): Care for file types which need a fixup
        before exec. Start child in suspended state then.
@
text
@d47 1
a47 2
extern HANDLE ws2_32_handle;
WSADATA wsadata;
d1516 1
a1516 1
static int
a1782 294
}

/**********************************************************************/
/* fhandler_socket */

fhandler_socket::fhandler_socket (const char *name) :
	fhandler_base (FH_SOCKET, name)
{
  set_cb (sizeof *this);
  set_need_fork_fixup ();
  prot_info_ptr = (LPWSAPROTOCOL_INFOA) cmalloc (HEAP_BUF,
  					         sizeof (WSAPROTOCOL_INFOA));
}

fhandler_socket::~fhandler_socket ()
{
  if (prot_info_ptr)
    cfree (prot_info_ptr);
}

void
fhandler_socket::fixup_before_fork_exec (DWORD win_proc_id)
{
  int ret = 1;

  if (prot_info_ptr &&
      (ret = WSADuplicateSocketA (get_socket (), win_proc_id, prot_info_ptr)))
    {
      debug_printf ("WSADuplicateSocket error");
      set_winsock_errno ();
    }
  if (!ret && ws2_32_handle)
    {
      debug_printf ("WSADuplicateSocket went fine, dwServiceFlags1=%d",
		    prot_info_ptr->dwServiceFlags1);
    }
  else
    {
      fhandler_base::fixup_before_fork_exec (win_proc_id);
      debug_printf ("Without Winsock 2.0");
    }
}

void
fhandler_socket::fixup_after_fork (HANDLE parent)
{
  SOCKET new_sock = INVALID_SOCKET;

  debug_printf ("WSASocket begin, dwServiceFlags1=%d",
		prot_info_ptr->dwServiceFlags1);
  if (prot_info_ptr &&
      (new_sock = WSASocketA (FROM_PROTOCOL_INFO,
                              FROM_PROTOCOL_INFO,
                              FROM_PROTOCOL_INFO,
                              prot_info_ptr, 0, 0)) == INVALID_SOCKET)
    {
      debug_printf ("WSASocket error");
      set_winsock_errno ();
    }
  if (new_sock != INVALID_SOCKET && ws2_32_handle)
    {
      debug_printf ("WSASocket went fine");
      set_io_handle ((HANDLE) new_sock);
    }
  else
    {
      fhandler_base::fixup_after_fork (parent);
      debug_printf ("Without Winsock 2.0");
    }
}

int
fhandler_socket::dup (fhandler_base *child)
{
  fhandler_socket *fhs = (fhandler_socket *) child;
  fhs->set_io_handle (get_io_handle ());
  fhs->fixup_before_fork_exec (GetCurrentProcessId ());
  if (ws2_32_handle)
    {
      fhs->fixup_after_fork (hMainProc);
      return 0;
    }
  return fhandler_base::dup (child);
}

int
fhandler_socket::read (void *ptr, size_t len)
{
  sigframe thisframe (mainthread);
  int res = recv (get_socket (), (char *) ptr, len, 0);
  if (res == SOCKET_ERROR)
    {
      set_winsock_errno ();
    }
  return res;
}

int
fhandler_socket::write (const void *ptr, size_t len)
{
  sigframe thisframe (mainthread);
  int res = send (get_socket (), (const char *) ptr, len, 0);
  if (res == SOCKET_ERROR)
    {
      set_winsock_errno ();
      if (get_errno () == ECONNABORTED || get_errno () == ECONNRESET)
	_raise (SIGPIPE);
    }
  return res;
}

/* Cygwin internal */
int
fhandler_socket::close ()
{
  int res = 0;
  sigframe thisframe (mainthread);

  if (closesocket (get_socket ()))
    {
      set_winsock_errno ();
      res = -1;
    }

  return res;
}

/* Cygwin internal */
/*
 * Return the flags settings for an interface.
 */
static int
get_if_flags (struct ifreq *ifr)
{
  struct sockaddr_in *sa = (struct sockaddr_in *) &ifr->ifr_addr;

  short flags = IFF_NOTRAILERS | IFF_UP | IFF_RUNNING;
  if (sa->sin_addr.s_addr == INADDR_LOOPBACK)
      flags |= IFF_LOOPBACK;
  else
      flags |= IFF_BROADCAST;

  ifr->ifr_flags = flags;
  return 0;
}

#define ASYNC_MASK (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT)

/* Cygwin internal */
int
fhandler_socket::ioctl (unsigned int cmd, void *p)
{
  int res;
  struct ifconf *ifc;
  struct ifreq *ifr;
  sigframe thisframe (mainthread);

  switch (cmd)
    {
    case SIOCGIFCONF:
      ifc = (struct ifconf *) p;
      if (ifc == 0)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      res = get_ifconf (ifc, cmd);
      if (res)
	debug_printf ("error in get_ifconf\n");
      break;
    case SIOCGIFFLAGS:
      ifr = (struct ifreq *) p;
      if (ifr == 0)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      res = get_if_flags (ifr);
      break;
    case SIOCGIFBRDADDR:
    case SIOCGIFNETMASK:
    case SIOCGIFADDR:
      {
	char buf[2048];
	struct ifconf ifc;
	ifc.ifc_len = sizeof (buf);
	ifc.ifc_buf = buf;
	struct ifreq *ifrp;

	struct ifreq *ifr = (struct ifreq *) p;
	if (ifr == 0)
	  {
	    debug_printf ("ifr == NULL\n");
	    set_errno (EINVAL);
	    return -1;
	  }

	res = get_ifconf (&ifc, cmd);
	if (res)
	  {
	    debug_printf ("error in get_ifconf\n");
	    break;
	  }

	debug_printf ("    name: %s\n", ifr->ifr_name);
	for (ifrp = ifc.ifc_req;
	     (caddr_t) ifrp < ifc.ifc_buf + ifc.ifc_len;
	     ++ifrp)
	  {
	    debug_printf ("testname: %s\n", ifrp->ifr_name);
	    if (! strcmp (ifrp->ifr_name, ifr->ifr_name))
	      {
		switch (cmd)
		  {
		  case SIOCGIFADDR:
		    ifr->ifr_addr = ifrp->ifr_addr;
		    break;
		  case SIOCGIFBRDADDR:
		    ifr->ifr_broadaddr = ifrp->ifr_broadaddr;
		    break;
		  case SIOCGIFNETMASK:
		    ifr->ifr_netmask = ifrp->ifr_netmask;
		    break;
		  }
		break;
	      }
	  }
	if ((caddr_t) ifrp >= ifc.ifc_buf + ifc.ifc_len)
	  {
	    set_errno (EINVAL);
	    return -1;
	  }
	break;
      }
    case FIOASYNC:
      res = WSAAsyncSelect (get_socket (), gethwnd (), WM_ASYNCIO,
	      *(int *) p ? ASYNC_MASK : 0);
      syscall_printf ("Async I/O on socket %s",
	      *(int *) p ? "started" : "cancelled");
      set_async (*(int *) p);
      break;
    default:
      /* We must cancel WSAAsyncSelect (if any) before setting socket to
       * blocking mode
       */
      if (cmd == FIONBIO && *(int *) p == 0)
	WSAAsyncSelect (get_socket (), gethwnd (), 0, 0);
      res = ioctlsocket (get_socket (), cmd, (unsigned long *) p);
      if (res == SOCKET_ERROR)
	  set_winsock_errno ();
      if (cmd == FIONBIO)
	{
	  syscall_printf ("socket is now %sblocking",
			    *(int *) p ? "un" : "");
	  /* Start AsyncSelect if async socket unblocked */
	  if (*(int *) p && get_async ())
	    WSAAsyncSelect (get_socket (), gethwnd (), WM_ASYNCIO, ASYNC_MASK);
	}
      break;
    }
  syscall_printf ("%d = ioctl_socket (%x, %x)", res, cmd, p);
  return res;
}

int
fhandler_socket::fcntl (int cmd, void *arg)
{
  int res = 0;
  int request, current;

  switch (cmd)
    {
    case F_SETFL:
      {
        /* Care for the old O_NDELAY flag. If one of the flags is set,
           both flags are set. */
        int new_flags = (int) arg;
        if (new_flags & (O_NONBLOCK | OLD_O_NDELAY))
          new_flags |= O_NONBLOCK | OLD_O_NDELAY;
        request = (new_flags & O_NONBLOCK) ? 1 : 0;
        current = (get_flags () & O_NONBLOCK) ? 1 : 0;
        if (request != current && (res = ioctl (FIONBIO, &request)))
          break;
        if (request)
          set_flags (get_flags () | O_NONBLOCK | OLD_O_NDELAY);
        else
          set_flags (get_flags () & ~(O_NONBLOCK | OLD_O_NDELAY));
        break;
      }
    default:
      res = fhandler_base::fcntl (cmd, arg);
      break;
    }
  return res;
@


1.26
log
@	* fhandler.cc (fhandler_base::fcntl): Treat O_NONBLOCK and OLD_O_NDELAY
	as exactly the same. If one is set, both are set.
	* net.cc (fhandler_socket::fcntl): Ditto.
@
text
@d25 2
a26 1
#include <winsock.h>
d47 3
d315 2
d320 1
a348 2
      soc = set_socket_inheritance (soc);

a727 2
	  res = set_socket_inheritance (res);

a1598 2
      res = set_socket_inheritance (res);

a1603 2
      fd2s = set_socket_inheritance (fd2s);

a1626 2
      res = set_socket_inheritance (res);

a1657 2
      res = set_socket_inheritance (res);

a1763 2
  insock = set_socket_inheritance (insock);

a1765 1
  outsock = set_socket_inheritance (outsock);
d1774 12
d1793 32
d1827 2
a1828 3
/* sethostent: standards? */
extern "C" void
sethostent (int)
d1830 23
d1855 2
a1856 3
/* endhostent: standards? */
extern "C" void
endhostent (void)
d1858 9
d2080 18
a2101 2
  WSADATA p;
  int res;
d2111 10
a2120 1
  res = WSAStartup ((2<<8) | 2, &p);
d2122 3
a2124 8
  debug_printf ("res %d", res);
  debug_printf ("wVersion %d", p.wVersion);
  debug_printf ("wHighVersion %d", p.wHighVersion);
  debug_printf ("szDescription %s", p.szDescription);
  debug_printf ("szSystemStatus %s", p.szSystemStatus);
  debug_printf ("iMaxSockets %d", p.iMaxSockets);
  debug_printf ("iMaxUdpDg %d", p.iMaxUdpDg);
  debug_printf ("lpVendorInfo %d", p.lpVendorInfo);
d2126 2
a2127 2
  if (FIONBIO  != REAL_FIONBIO)
    debug_printf ("****************  FIONBIO  != REAL_FIONBIO");
a2131 2
LoadDLLinit (wsock32)

d2136 1
d2172 4
@


1.25
log
@        * fcntl.cc (_fcntl): Rearrange as wrapper function. Move all
        functionality except F_DUPFD to fhandler classes.
        * fhandler.cc (fhandler_base::fcntl): New method.
        * net.cc (fhandler_socket::fcntl): Ditto.
        * fhandler.h (class fhandler_base): Add method prototype for fcntl().
        (class fhandler_socket): Ditto.
@
text
@d1991 14
a2004 3
      request = ((int) arg & O_NONBLOCK) ? 1 : 0;
      current = (get_flags () & O_NONBLOCK) ? 1 : 0;
      if (request != current && (res = ioctl (FIONBIO, &request)))
d2006 1
a2006 5
      if (request)
        set_flags (get_flags () | O_NONBLOCK);
      else
        set_flags (get_flags () & ~O_NONBLOCK);
      break;
@


1.24
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d1960 1
a1960 1
      /* We must cancel WSAAsyncSelect (if any) before settting socket to
d1979 25
@


1.23
log
@        * cygwin.din: Add symbol hstrerror.
        * net.cc: Change meaning of member `s' of struct host_errmap.
        (set_host_errno): Fix error in loop condition.
        (hstrerror): Ditto.
        (herror): Add appropriate functionality.
        * include/netdb.h: Add declaration of hstrerror.
        * include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 29.
@
text
@a29 1
#include "thread.h"
@


1.22
log
@* net.cc (set_socket_inheritance): Rename from duplicate_socket.  Use NT
specific call when appropriate.
(__set_winsock_errno): Rename from set_winsock_errno.  Accept function and line
as arguments.
* path.cc (path_conv::check): Continue the neverending battle to make cygwin
properly understand that path specs ending in a slash require that the path
refer to a directory.  Windows does not do this by default.
(symlink_info::check): Remove ENOTDIR test.  Move it to path_conv::check.
* path.h: Remove obsolete constant.
* winsup.h (set_winsock_errno): New macro.
@
text
@d255 4
d261 4
a264 4
  {WSAHOST_NOT_FOUND, "WSAHOST_NOT_FOUND", HOST_NOT_FOUND},
  {WSATRY_AGAIN, "WSATRY_AGAIN", TRY_AGAIN},
  {WSANO_RECOVERY, "WSANO_RECOVERY", NO_RECOVERY},
  {WSANO_DATA, "WSANO_DATA", NO_DATA},
d275 1
a275 1
  for (i = 0; i < host_errmap[i].w != 0; ++i)
d891 14
a904 1
/* exported as herror: standards? */
d906 1
a906 1
cygwin_herror (const char *)
d908 26
a933 1
  debug_printf ("********%d*************", __LINE__);
@


1.21
log
@* net.cc: General cleanup.
(fdsock): Return pointer to created fhandler_socket.
(cygwin_socket): Use pointer returned by fdsock.  Return correct errno when fd
< 0.
@
text
@d48 2
a49 2
static SOCKET
duplicate_socket (SOCKET sock)
a50 3
  /* Do not duplicate socket on Windows NT because of problems with
     MS winsock proxy server.
  */
d52 2
a53 5
    return sock;

  SOCKET newsock;
  if (DuplicateHandle (hMainProc, (HANDLE) sock, hMainProc, (HANDLE *) &newsock,
		       0, TRUE, DUPLICATE_SAME_ACCESS))
d55 9
a63 2
      closesocket (sock);
      sock = newsock;
a64 2
  else
    small_printf ("DuplicateHandle failed %E");
d235 1
a235 1
set_winsock_errno ()
d245 1
a245 1
      syscall_printf ("%d (%s) -> %d", why, errmap[i].s, errmap[i].e);
d250 1
a250 1
      syscall_printf ("unknown error %d", why);
d339 1
a339 1
      soc = duplicate_socket (soc);
d720 1
a720 1
	  res = duplicate_socket (res);
d1555 1
a1555 1
      res = duplicate_socket (res);
d1562 1
a1562 1
      fd2s = duplicate_socket (fd2s);
d1587 1
a1587 1
      res = duplicate_socket (res);
d1620 1
a1620 1
      res = duplicate_socket (res);
d1627 1
a1627 1
      fd2s = duplicate_socket (fd2s);
d1728 1
a1728 1
  insock = duplicate_socket (insock);
d1732 1
a1732 1
  outsock = duplicate_socket (outsock);
@


1.20
log
@        * dcrt0.cc: Add LoadDLLFunc statement for RegEnumValueA().
        * net.cc: Change comments related to get_ifconf.
        (get_2k_ifconf): Eliminate `type' variable. Eliminate `sa' parameter.
        (get_nt_ifconf): Ditto.
        (get_9x_ifconf): Ditto. Rewritten.
        (get_ifconf): Chage calls to OS specific functions.
@
text
@d36 1
a36 2
extern "C"
{
d70 1
a70 2
extern "C"
unsigned long int
d80 1
a80 2
extern "C"
unsigned long int
d87 1
a87 2
extern "C"
unsigned short
d95 1
a95 2
extern "C"
unsigned short
d110 1
a110 2
extern "C"
char *
d118 1
a118 2
extern "C"
unsigned long
d128 1
a128 2
extern "C"
unsigned int 
d139 1
a139 2
extern "C"
unsigned long
d161 1
a161 2
extern "C"
struct in_addr
d283 1
a283 2
extern "C"
struct protoent *
a285 1

d295 1
a295 2
extern "C"
struct protoent *
a297 1

d306 1
a306 1
void
d309 1
a309 1
  fhandler_base *fh = fdtab.build_fhandler(fd, FH_SOCKET, name);
d312 1
d316 1
a316 2
extern "C"
int
d320 1
a320 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," socket");
d327 1
a327 3
    {
      set_errno (ENMFILE);
    }
d348 1
a348 1
      fdsock (fd, name, soc);
a349 3
      fhandler_socket *h = (fhandler_socket *) fdtab[fd];

      h->set_addr_family (af);
d354 1
a354 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," socket");
d383 1
a383 1
      sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
d396 1
a396 2
extern "C"
int
d422 1
a422 2
extern "C"
int
d459 1
a459 2
extern "C"
int
d520 1
a520 2
extern "C"
int
d577 1
a577 2
extern "C"
int
d604 1
a604 2
extern "C"
struct servent *
d616 1
a616 2
extern "C"
struct servent *
d627 1
a627 2
extern "C"
int
d630 1
a630 1
  int PASCAL win32_gethostname(char*,int);
d649 1
a649 2
extern "C"
struct hostent *
d655 1
a655 1
  static char *tmp_addr_list[2] = {0,0};
d657 2
a658 1
  if (sscanf(name, "%d.%d.%d.%d", &a, &b, &c, &d) == 4)
d661 1
a661 1
      memset(&tmp, 0, sizeof(tmp));
d690 1
a690 2
extern "C"
int
d701 1
a701 1
       * sizeof(name.sun_family) + strlen(name.sun_path) for UNIX domain
d708 1
a708 1
      SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," accept");
d729 1
a729 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," accept");
d734 1
a734 2
extern "C"
int
d774 1
a774 1
	     so _open() is called with O_EXCL flag. */
d817 1
a817 2
extern "C"
int
d835 1
a835 2
extern "C"
struct hostent *
d853 1
a853 2
extern "C"
int
d871 1
a871 2
extern "C"
int
d889 1
a889 2
extern "C"
void
d896 1
a896 2
extern "C"
int
d911 1
a911 2
extern "C"
int
d936 1
a936 2
extern "C"
int
d955 1
a955 2
extern "C"
int
d1190 1
a1190 1
      for (bp = binding; *bp; bp += strlen(bp) + 1)
d1383 1
a1383 1
              - sizeof(struct ifreq))
d1532 1
a1532 2
extern "C"
int
d1573 1
a1573 2
extern "C"
int
d1599 1
a1599 2
extern "C"
int
a1628 1

a1629 5
#if 0 /* ??? */
      fhandler_socket *h;
      p->hmap.vec[*fd2p].h = h =
	  new (&p->hmap.vec[*fd2p].item) fhandler_socket (fd2s, "/dev/tcp");
#endif
d1638 1
a1638 2
extern "C"
int
d1646 1
a1646 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," socketpair");
d1665 1
d1677 1
d1697 1
a1697 1
      debug_printf ("can't create outsock");
d1738 1
a1738 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," socketpair");
d1752 1
a1752 2
extern "C"
void
d1758 1
a1758 2
extern "C"
void
d1863 1
a1863 1
	ifc.ifc_len = sizeof(buf);
d1870 1
a1870 1
	    debug_printf("ifr == NULL\n");
d1882 1
a1882 1
	debug_printf("    name: %s\n", ifr->ifr_name);
d1887 1
a1887 1
	    debug_printf("testname: %s\n", ifrp->ifr_name);
d1962 2
a1963 2
  debug_printf ("szDescription %s",p.szDescription);
  debug_printf ("szSystemStatus %s",p.szSystemStatus);
@


1.19
log
@        * net.cc (get_ifconf): Code cleanup. Split. Call os dependent
        subfunctions instead.
        (get_9x_ifconf): New function for 9X systems, called by get_ifconf.
        (get_nt_ifconf): New function for NT systems, called by get_ifconf.
        (get_2k_ifconf): New function for W2K systems, called by get_ifconf.
@
text
@d1020 4
a1023 3
/* Fill out an ifconf struct.
 *
 * Windows 2000:
a1026 20
 *
 * Windows NT:
 * Look at the Bind value in
 * HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Linkage\
 * This is a REG_MULTI_SZ with strings of the form:
 * \Device\<Netcard>, where netcard is the name of the net device.
 * Then look under:
 * HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\<NetCard>\
 *							Parameters\Tcpip
 * at the IPAddress, Subnetmask and DefaultGateway values for the
 * required values.
 *
 * Windows 9x:
 * We originally just did a gethostbyname, assuming that it's pretty
 * unlikely Win9x will ever have more than one netcard.  When this
 * succeeded, we got the interface plus a loopback.
 * Currently, we read all
 * "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Class\NetTrans\*"
 * entries from the Registry and use all entries that have legal
 * "IPAddress" and "IPMask" values.
d1029 1
a1029 1
get_2k_ifconf (struct ifconf *ifc, struct sockaddr_in *sa, int what)
d1048 1
d1050 1
a1050 1
      DWORD type, size;
d1064 1
a1064 1
                               NULL, &type, NULL, &size) != ERROR_SUCCESS)
d1082 1
a1082 1
                               NULL, &type,
d1086 1
a1086 1
                                  NULL, &type,
d1092 1
a1092 1
                                   NULL, &type, NULL, &size) == ERROR_SUCCESS)
d1108 1
a1108 1
                                      NULL, &type,
d1113 1
a1113 1
                                      NULL, &type,
d1174 12
d1187 1
a1187 1
get_nt_ifconf (struct ifconf *ifc, struct sockaddr_in *sa, int what)
d1191 2
a1192 1
  DWORD type, size;
d1208 1
a1208 1
                           NULL, &type,
d1213 1
a1213 1
                               NULL, &type,
d1240 1
a1240 1
                               NULL, &type,
d1244 1
a1244 1
                                  NULL, &type,
d1274 1
a1274 1
                                          NULL, &type,
d1279 1
a1279 1
                                          NULL, &type,
d1338 17
d1356 1
a1356 1
get_9x_ifconf (struct ifconf *ifc, struct sockaddr_in *sa, int what)
d1358 1
a1358 1
  HKEY key, subkey;
d1360 1
d1363 1
a1363 2
  DWORD type, size;
  char ifname[256], ip[256], np[256];
d1365 3
a1367 4

  char eth[2];
  eth[0] = '/';
  eth[1] = '\0';
d1372 13
a1384 7
  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    "SYSTEM\\"
                    "CurrentControlSet\\"
                    "Services\\"
                    "Class\\"
                    "NetTrans",
                    0, KEY_READ, &key) == ERROR_SUCCESS)
d1386 21
a1406 5
      for (int i = 0;
           (res = RegEnumKeyEx (key, i, ifname,
                                (size = sizeof ifname, &size),
                                0, 0, 0, &update)) != ERROR_NO_MORE_ITEMS;
           ++i)
d1408 81
a1488 10
          if (res != ERROR_SUCCESS
              || RegOpenKeyEx (key, ifname, 0,
                               KEY_READ, &subkey) != ERROR_SUCCESS)
            continue;
          if (RegQueryValueEx (subkey, "IPAddress", 0,
                               &type, (unsigned char *) ip,
                               (size = sizeof ip, &size)) == ERROR_SUCCESS
              || RegQueryValueEx (subkey, "IPMask", 0,
                                  &type, (unsigned char *) np,
                                  (size = sizeof np, &size)) == ERROR_SUCCESS)
a1489 4
              if ((caddr_t)++ifr > ifc->ifc_buf
                  + ifc->ifc_len
                  - sizeof(struct ifreq))
                break;
a1492 21
              switch (what)
                {
                case SIOCGIFCONF:
                case SIOCGIFADDR:
                  sa = (struct sockaddr_in *) &ifr->ifr_addr;
                  sa->sin_addr.s_addr = cygwin_inet_addr (ip);
                  break;
                case SIOCGIFBRDADDR:
                  lip = cygwin_inet_addr (ip);
                  lnp = cygwin_inet_addr (np);
                  sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
                  sa->sin_addr.s_addr = lip & lnp | ~lnp;
                  break;
                case SIOCGIFNETMASK:
                  sa = (struct sockaddr_in *) &ifr->ifr_netmask;
                  sa->sin_addr.s_addr = cygwin_inet_addr (np);
                  break;
                }
              sa->sin_family = AF_INET;
              sa->sin_port = 0;
              ++cnt;
d1494 1
d1496 1
d1498 4
d1504 4
d1560 1
a1560 1
    get_9x_ifconf (ifc, sa, what);
d1562 1
a1562 1
    get_nt_ifconf (ifc, sa, what);
d1564 1
a1564 1
    get_2k_ifconf (ifc, sa, what);
@


1.18
log
@* dcrt0.cc (quoted): Fix problem where ' quoted strings were skipped.
* fhandler.h (fhandler_socket::~fhandler_socket): Delete declaration.
* net.cc: Remove unnecessary "number_of_sockets" usage.
(fhandler_socket::fhandler_socket): Ditto.
(fhandler_socket::~fhandler_socket): Delete definition.
* spawn.cc (spawn_guts): Force first argument passed to CreateProcess as a
command line to be windows style.
@
text
@d1022 5
d1047 2
a1048 2
static int
get_ifconf (struct ifconf *ifc, int what)
d1050 14
a1063 1
  if (os_being_run == winNT)
d1065 3
a1067 1
      HKEY key;
d1069 273
a1341 186
      unsigned long lip, lnp;
      int cnt = 1;
      char *binding = (char *) 0;
      struct sockaddr_in *sa;

      /* Union maps buffer to correct struct */
      struct ifreq *ifr = ifc->ifc_req;

      /* Ensure we have space for two struct ifreqs, fail if not. */
      if (ifc->ifc_len < (int) (2 * sizeof (struct ifreq)))
	{
	  set_errno (EFAULT);
	  return -1;
	}

      /* Set up interface lo0 first */
      strcpy (ifr->ifr_name, "lo0");
      memset (&ifr->ifr_addr, '\0', sizeof (ifr->ifr_addr));
      switch (what)
	{
	case SIOCGIFCONF:
	case SIOCGIFADDR:
	  sa = (struct sockaddr_in *) &ifr->ifr_addr;
	  sa->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  break;
	case SIOCGIFBRDADDR:
	  lip = htonl (INADDR_LOOPBACK);
	  lnp = cygwin_inet_addr ("255.0.0.0");
	  sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	  sa->sin_addr.s_addr = lip & lnp | ~lnp;
	  break;
	case SIOCGIFNETMASK:
	  sa = (struct sockaddr_in *) &ifr->ifr_netmask;
	  sa->sin_addr.s_addr = cygwin_inet_addr ("255.0.0.0");
	  break;
	default:
	  set_errno (EINVAL);
	  return -1;
	}
      sa->sin_family = AF_INET;
      sa->sin_port = 0;

      if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
			"SYSTEM\\"
			"CurrentControlSet\\"
			"Services\\"
			"Tcpip\\"
			"Linkage",
			0, KEY_READ, &key) == ERROR_SUCCESS)
	{
	  if (RegQueryValueEx (key, "Bind",
			       NULL, &type,
			       NULL, &size) == ERROR_SUCCESS)
	    {
	      binding = (char *) alloca (size);
	      if (RegQueryValueEx (key, "Bind",
				   NULL, &type,
				   (unsigned char *) binding,
				   &size) != ERROR_SUCCESS)
		{
		  binding = NULL;
		}
	    }
	  RegCloseKey (key);
	}

      if (binding)
	{
	  char *bp, eth[2];
	  char cardkey[256], ipaddress[256], netmask[256];

	  eth[0] = '/';
	  eth[1] = '\0';
	  for (bp = binding; *bp; bp += strlen(bp) + 1)
	    {
	      bp += strlen ("\\Device\\");
	      strcpy (cardkey, "SYSTEM\\CurrentControlSet\\Services\\");
	      strcat (cardkey, bp);
	      strcat (cardkey, "\\Parameters\\Tcpip");

	      if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, cardkey,
				0, KEY_READ, &key) != ERROR_SUCCESS)
		continue;

	      if (RegQueryValueEx (key, "IPAddress",
				   NULL, &type,
				   (unsigned char *) &ipaddress,
				   (size = 256, &size)) == ERROR_SUCCESS
		  && RegQueryValueEx (key, "SubnetMask",
				      NULL, &type,
				      (unsigned char *) &netmask,
				      (size = 256, &size)) == ERROR_SUCCESS)
		{
		  char *ip, *np;
		  char sub[2];
		  char dhcpaddress[256], dhcpnetmask[256];

		  sub[0] = '/';
		  sub[1] = '\0';
		  if (strncmp (bp, "NdisWan", 7))
		    ++*eth;
		  for (ip = ipaddress, np = netmask;
		       *ip && *np;
		       ip += strlen (ip) + 1, np += strlen (np) + 1)
		    {
		      if ((caddr_t) ++ifr > ifc->ifc_buf
			  + ifc->ifc_len
			  - sizeof (struct ifreq))
			break;

		      if (! strncmp (bp, "NdisWan", 7))
			{
			  strcpy (ifr->ifr_name, "ppp");
			  strcat (ifr->ifr_name, bp + 7);
			}
		      else
			{
			  strcpy (ifr->ifr_name, "eth");
			  strcat (ifr->ifr_name, eth);
			}
		      ++*sub;
		      if (*sub >= '1')
			strcat (ifr->ifr_name, sub);
		      memset (&ifr->ifr_addr, '\0', sizeof ifr->ifr_addr);
		      if (cygwin_inet_addr (ip) == 0L
			  && RegQueryValueEx (key, "DhcpIPAddress",
					      NULL, &type,
					      (unsigned char *) &dhcpaddress,
					      (size = 256, &size))
			  == ERROR_SUCCESS
			  && RegQueryValueEx (key, "DhcpSubnetMask",
					      NULL, &type,
					      (unsigned char *) &dhcpnetmask,
					      (size = 256, &size))
			  == ERROR_SUCCESS)
			{
			  switch (what)
			    {
			    case SIOCGIFCONF:
			    case SIOCGIFADDR:
			      sa = (struct sockaddr_in *) &ifr->ifr_addr;
			      sa->sin_addr.s_addr =
				cygwin_inet_addr (dhcpaddress);
			      break;
			    case SIOCGIFBRDADDR:
			      lip = cygwin_inet_addr (dhcpaddress);
			      lnp = cygwin_inet_addr (dhcpnetmask);
			      sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
			      sa->sin_addr.s_addr = lip & lnp | ~lnp;
			      break;
			    case SIOCGIFNETMASK:
			      sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			      sa->sin_addr.s_addr =
				cygwin_inet_addr (dhcpnetmask);
			      break;
			    }
			}
		      else
			{
			  switch (what)
			    {
			    case SIOCGIFCONF:
			    case SIOCGIFADDR:
			      sa = (struct sockaddr_in *) &ifr->ifr_addr;
			      sa->sin_addr.s_addr = cygwin_inet_addr (ip);
			      break;
			    case SIOCGIFBRDADDR:
			      lip = cygwin_inet_addr (ip);
			      lnp = cygwin_inet_addr (np);
			      sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
			      sa->sin_addr.s_addr = lip & lnp | ~lnp;
			      break;
			    case SIOCGIFNETMASK:
			      sa = (struct sockaddr_in *) &ifr->ifr_netmask;
			      sa->sin_addr.s_addr = cygwin_inet_addr (np);
			      break;
			    }
			}
		      sa->sin_family = AF_INET;
		      sa->sin_port = 0;
		      ++cnt;
		    }
		}
	      RegCloseKey (key);
	    }
	}
d1343 74
a1416 2
      /* Set the correct length */
      ifc->ifc_len = cnt * sizeof (struct ifreq);
d1418 16
a1433 1
  else /* Windows 9x */
d1435 3
a1437 107
      HKEY key, subkey;
      FILETIME update;
      LONG res;
      DWORD type, size;
      unsigned long lip, lnp;
      char ifname[256], ip[256], np[256];
      int cnt = 1;
      struct sockaddr_in *sa;

      /* Union maps buffer to correct struct */
      struct ifreq *ifr = ifc->ifc_req;
      char eth[2];

      eth[0] = '/';
      eth[1] = '\0';

      /* Ensure we have space for two struct ifreqs, fail if not. */
      if (ifc->ifc_len < (int) (2 * sizeof (struct ifreq)))
	{
	  set_errno (EFAULT);
	  return -1;
	}

      /* Set up interface lo0 first */
      strcpy (ifr->ifr_name, "lo0");
      memset (&ifr->ifr_addr, '\0', sizeof ifr->ifr_addr);
      switch (what)
	{
	case SIOCGIFCONF:
	case SIOCGIFADDR:
	  sa = (struct sockaddr_in *) &ifr->ifr_addr;
	  sa->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  break;
	case SIOCGIFBRDADDR:
	  lip = htonl(INADDR_LOOPBACK);
	  lnp = cygwin_inet_addr ("255.0.0.0");
	  sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
	  sa->sin_addr.s_addr = lip & lnp | ~lnp;
	  break;
	case SIOCGIFNETMASK:
	  sa = (struct sockaddr_in *) &ifr->ifr_netmask;
	  sa->sin_addr.s_addr = cygwin_inet_addr ("255.0.0.0");
	  break;
	default:
	  set_errno (EINVAL);
	  return -1;
	}
      sa->sin_family = AF_INET;
      sa->sin_port = 0;

      if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
			"SYSTEM\\"
			"CurrentControlSet\\"
			"Services\\"
			"Class\\"
			"NetTrans",
			0, KEY_READ, &key) == ERROR_SUCCESS)
	{
	  for (int i = 0;
	       (res = RegEnumKeyEx (key, i, ifname,
				    (size = sizeof ifname, &size),
				    0, 0, 0, &update)) != ERROR_NO_MORE_ITEMS;
	       ++i)
	    {
	      if (res != ERROR_SUCCESS
		  || RegOpenKeyEx (key, ifname, 0,
				   KEY_READ, &subkey) != ERROR_SUCCESS)
		continue;
	      if (RegQueryValueEx (subkey, "IPAddress", 0,
				   &type, (unsigned char *) ip,
				   (size = sizeof ip, &size)) == ERROR_SUCCESS
		  || RegQueryValueEx (subkey, "IPMask", 0,
				      &type, (unsigned char *) np,
				      (size = sizeof np, &size)) == ERROR_SUCCESS)
		{
		  if ((caddr_t)++ifr > ifc->ifc_buf
		      + ifc->ifc_len
		      - sizeof(struct ifreq))
		    break;
		  ++*eth;
		  strcpy (ifr->ifr_name, "eth");
		  strcat (ifr->ifr_name, eth);
		  switch (what)
		    {
		    case SIOCGIFCONF:
		    case SIOCGIFADDR:
		      sa = (struct sockaddr_in *) &ifr->ifr_addr;
		      sa->sin_addr.s_addr = cygwin_inet_addr (ip);
		      break;
		    case SIOCGIFBRDADDR:
		      lip = cygwin_inet_addr (ip);
		      lnp = cygwin_inet_addr (np);
		      sa = (struct sockaddr_in *) &ifr->ifr_broadaddr;
		      sa->sin_addr.s_addr = lip & lnp | ~lnp;
		      break;
		    case SIOCGIFNETMASK:
		      sa = (struct sockaddr_in *) &ifr->ifr_netmask;
		      sa->sin_addr.s_addr = cygwin_inet_addr (np);
		      break;
		    }
		  sa->sin_family = AF_INET;
		  sa->sin_port = 0;
		  ++cnt;
		}
	      RegCloseKey (subkey);
	    }
	}
d1439 23
a1461 2
      /* Set the correct length */
      ifc->ifc_len = cnt * sizeof (struct ifreq);
d1463 13
@


1.17
log
@* sigproc.h (sigframe::set): Eliminate second argument.  Default bp to current
frame pointer rather than using this within the function, which is unstable
when this method is not inlined.
* net.cc: Eliminate use of second argument to sigframe.set throughout.
* select.cc (cygwin_select): Ditto.
* sigproc.cc (sig_send): Ditto.
@
text
@a35 5
/* We only want to initialize WinSock in a child process if socket
   handles are inheritted. This global allows us to know whether this
   should be done or not */
int number_of_sockets = 0;

a1581 1
  number_of_sockets++;
a1595 9
}

fhandler_socket::~fhandler_socket ()
{
  if (--number_of_sockets < 0)
    {
      number_of_sockets = 0;
      system_printf("socket count < 0");
    }
@


1.16
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d431 1
a431 1
  sigframe thisframe (mainthread, 0);
d457 1
a457 1
  sigframe thisframe (mainthread, 0);
d614 1
a614 1
  sigframe thisframe (mainthread, 0);
d727 1
a727 1
  sigframe thisframe (mainthread, 0);
d913 1
a913 1
  sigframe thisframe (mainthread, 0);
d956 1
a956 1
  sigframe thisframe (mainthread, 0);
d982 1
a982 1
  sigframe thisframe (mainthread, 0);
d1369 1
a1369 1
  sigframe thisframe (mainthread, 0);
d1409 1
a1409 1
  sigframe thisframe (mainthread, 0);
d1438 1
a1438 1
  sigframe thisframe (mainthread, 0);
@


1.15
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d34 1
a79 1
  MARK ();
a98 1
  MARK ();
@


1.14
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d357 4
a360 4
        {
          set_winsock_errno ();
          goto done;
        }
d366 1
a366 1
        name = (type == SOCK_STREAM ? "/dev/tcp" : "/dev/udp");
d368 1
a368 1
        name = (type == SOCK_STREAM ? "/dev/streamsocket" : "/dev/dgsocket");
d784 5
a788 5
          if (strlen (un_addr->sun_path) >= UNIX_PATH_LEN)
            {
              set_errno (ENAMETOOLONG);
              goto out;
            }
d808 2
a809 2
          /* bind must fail if file system socket object already exists
             so _open() is called with O_EXCL flag. */
d811 2
a812 2
                      O_WRONLY | O_CREAT | O_EXCL | O_BINARY,
                      0);
d814 3
a816 3
            {
              if (get_errno () == EEXIST)
                set_errno (EADDRINUSE);
d818 1
a818 1
            }
d820 7
a826 7
          char buf[sizeof (SOCKET_COOKIE) + 10];
          __small_sprintf (buf, "%s%u", SOCKET_COOKIE, sin.sin_port);
          len = strlen (buf) + 1;

          /* Note that the terminating nul is written.  */
          if (_write (fd, buf, len) != len)
            {
d828 8
a835 8
              _close (fd);
              _unlink (un_addr->sun_path);
            }
          else
            {
              _close (fd);
              chmod (un_addr->sun_path,
                (S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO) & ~myself->umask);
d837 1
a837 1
            }
d1035 1
a1035 1
 *                                                  Parameters\Tcpip
d1712 13
a1724 13
        char buf[2048];
        struct ifconf ifc;
        ifc.ifc_len = sizeof(buf);
        ifc.ifc_buf = buf;
        struct ifreq *ifrp;

        struct ifreq *ifr = (struct ifreq *) p;
        if (ifr == 0)
          {
            debug_printf("ifr == NULL\n");
            set_errno (EINVAL);
            return -1;
          }
d1727 1
a1727 1
        if (res)
d1733 9
a1741 9
        debug_printf("    name: %s\n", ifr->ifr_name);
        for (ifrp = ifc.ifc_req;
             (caddr_t) ifrp < ifc.ifc_buf + ifc.ifc_len;
             ++ifrp)
          {
            debug_printf("testname: %s\n", ifrp->ifr_name);
            if (! strcmp (ifrp->ifr_name, ifr->ifr_name))
              {
                switch (cmd)
d1753 9
a1761 9
                break;
              }
          }
        if ((caddr_t) ifrp >= ifc.ifc_buf + ifc.ifc_len)
          {
            set_errno (EINVAL);
            return -1;
          }
        break;
@


1.13
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d26 3
d30 3
a33 1
#include "cygerrno.h"
@


1.12
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d28 1
@


1.11
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d26 2
@


1.10
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d321 1
a321 1
  fhandler_base *fh = dtable.build_fhandler(fd, FH_SOCKET, name);
d336 1
a336 1
  int fd = dtable.find_unused_handle ();
d364 1
a364 1
      fhandler_socket *h = (fhandler_socket *) dtable[fd];
d422 1
a422 1
  fhandler_socket *h = (fhandler_socket *) dtable[fd];
d449 1
a449 1
  fhandler_socket *h = (fhandler_socket *) dtable[fd];
d468 1
a468 1
  if (dtable.not_open (fd))
d474 1
a474 1
  return dtable[fd]->is_socket ();
d736 1
a736 1
      int res_fd = dtable.find_unused_handle ();
d932 1
a932 1
  fhandler_socket *h = (fhandler_socket *) dtable[fd];
d948 1
a948 1
  fhandler_socket *h = (fhandler_socket *) dtable[fd];
d974 1
a974 1
  fhandler_socket *h = (fhandler_socket *) dtable[fd];
d1364 1
a1364 1
  int res_fd = dtable.find_unused_handle ();
d1370 1
a1370 1
      *fd2p = dtable.find_unused_handle (res_fd + 1);
d1404 1
a1404 1
  int res_fd = dtable.find_unused_handle ();
d1433 1
a1433 1
  int res_fd = dtable.find_unused_handle ();
d1438 1
a1438 1
      *fd2p = dtable.find_unused_handle (res_fd + 1);
d1481 1
a1481 1
  sb[0] = dtable.find_unused_handle ();
d1487 1
a1487 1
  sb[1] = dtable.find_unused_handle (sb[0] + 1);
@


1.9
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d15 2
a21 3

#define Win32_Winsock
#include "winsup.h"
@


1.8
log
@* exceptions.cc: Remove unneeded include.
* dcrt0.cc: Wrap LoadDLLfunc stuff in dummy function.
* init.cc: Ditto.
* uinfo.cc: Ditto.
@
text
@d19 2
a24 1
#include <unistd.h>
@


1.8.2.1
log
@* select.cc (fhandler_console::select_read): Call set_cursor_maybe since select
may block and cursor may not be visible.
* select.cc (fhandler_console::select_write): Ditto.
* select.cc (fhandler_console::select_except): Ditto.
* environ.cc (cur_environ): Give "C" linkage.
* winsup.h: Ditto.
* winsup.cc: Change include ordering.
@
text
@d20 1
a23 1
#include "winsup.h"
@


1.7
log
@* Makefile.in: Remove libadvapi32.a.
* autoload.h: Add additional field to autoload block for handling unimplemented
functions.
(LoadDLLfuncEx): New function which accepts additional parameter for
controlling unimplemented function behavior.
(LoadDLLfunc): Use LoadDLLfuncEx.
* dcrt0.cc: Use new arguments for LoadDLLfunc.  Add advapi32 routines.
(noload): Rewrite in assembler.  Handle new unimplemented function type.
* exceptions.cc: Eliminate another vestige of StackWalk stuff.
* net.cc: Use new arguments for LoadDLLfunc.
* uinfo.cc: Ditto.

* config.h.in: Remove obsolete define.
* path.h (isdrive): New macro.
* dcrt0.cc (globify): Use new macro to determine if a string refers to an
MS-DOS drive.
* environ.cc (winenv): Ditto.
* spawn.cc (find_exec): Ditto.
* path.cc (get_raw_device_number): Ditto.
(mount_info::conv_to_posix_path): Ditto.
(chdir): Ditto.
(cygwin_posix_path_list_p): Ditto.
(cygwin_split_path): Ditto.
(path_conv::check): Move tmp_buf to beginning of function since it can be used
earlier in the loop.  Use tmp_buf rather than 'root' to hold root information.
(mount_info::conv_to_win32_path): Add trailing slash to end of mount path when
it translates to a drive.  Add defensive code to avoid writing beyond the end
of 'dst'.
@
text
@d1785 1
d1819 4
d1858 2
@


1.6
log
@* path.cc (mount_info::cygdrive_posix_path): Don't add trailing slash if
referring to something like c:\.
* dcrt0.cc (dll_crt0_1): Move uinfo initialization prior to sig_send
initialization to give signal thread a chance to finish.
* debug.cc (WFSO): Move to sigproc.cc
(WFMO): Ditto.
* exceptions.cc (interruptible): Allocate slightly more space for directory
just for paranoia's sake.
(call_handler): Eliminate nonmain argument.  Determine if main thread has set a
frame pointer and use it if so.
(sig_handle): Eliminate nonmain argument.
* net.cc: Record frame information in appropriate routines throughout.
* select.cc (select): Ditto.
* sigproc.cc: Use sigthread structure to record mainthread id throughout.
(sig_send): Record frame information for signal handler.
(wait_sig): Reflect argument change in sig_handle.
(WFSO): Move here and record frame information for signal handler.
(WFMO): Ditto.
* sigproc.h: Implement new "sigthread" class.  Implement "sigframe" class for
manipulating signal frame info.
* thread.cc (__pthread_kill): Use standard _kill() function rather than calling
sig_send directly.
* winsup.h: Eliminate ebp element from signal_dispatch class.
@
text
@d1818 35
a1852 35
LoadDLLfunc (WSAAsyncSelect, WSAAsyncSelect@@16, wsock32)
LoadDLLfunc (WSACleanup, WSACleanup@@0, wsock32)
LoadDLLfunc (WSAGetLastError, WSAGetLastError@@0, wsock32)
LoadDLLfunc (WSAStartup, WSAStartup@@8, wsock32)
LoadDLLfunc (__WSAFDIsSet, __WSAFDIsSet@@8, wsock32)
LoadDLLfunc (accept, accept@@12, wsock32)
LoadDLLfunc (bind, bind@@12, wsock32)
LoadDLLfunc (closesocket, closesocket@@4, wsock32)
LoadDLLfunc (connect, connect@@12, wsock32)
LoadDLLfunc (gethostbyaddr, gethostbyaddr@@12, wsock32)
LoadDLLfunc (gethostbyname, gethostbyname@@4, wsock32)
LoadDLLfunc (gethostname, gethostname@@8, wsock32)
LoadDLLfunc (getpeername, getpeername@@12, wsock32)
LoadDLLfunc (getprotobyname, getprotobyname@@4, wsock32)
LoadDLLfunc (getprotobynumber, getprotobynumber@@4, wsock32)
LoadDLLfunc (getservbyname, getservbyname@@8, wsock32)
LoadDLLfunc (getservbyport, getservbyport@@8, wsock32)
LoadDLLfunc (getsockname, getsockname@@12, wsock32)
LoadDLLfunc (getsockopt, getsockopt@@20, wsock32)
LoadDLLfunc (inet_addr, inet_addr@@4, wsock32)
LoadDLLfunc (inet_network, inet_network@@4, wsock32)
LoadDLLfunc (inet_ntoa, inet_ntoa@@4, wsock32)
LoadDLLfunc (ioctlsocket, ioctlsocket@@12, wsock32)
LoadDLLfunc (listen, listen@@8, wsock32)
LoadDLLfunc (rcmd, rcmd@@24, wsock32)
LoadDLLfunc (recv, recv@@16, wsock32)
LoadDLLfunc (recvfrom, recvfrom@@24, wsock32)
LoadDLLfunc (rexec, rexec@@24, wsock32)
LoadDLLfunc (rresvport, rresvport@@4, wsock32)
LoadDLLfunc (select, select@@20, wsock32)
LoadDLLfunc (send, send@@16, wsock32)
LoadDLLfunc (sendto, sendto@@24, wsock32)
LoadDLLfunc (setsockopt, setsockopt@@20, wsock32)
LoadDLLfunc (shutdown, shutdown@@8, wsock32)
LoadDLLfunc (socket, socket@@12, wsock32)
@


1.5
log
@* net.cc: Avoid a warning in declaration inet_network.
@
text
@d424 1
d450 1
d607 1
d720 1
d906 1
a906 1

d949 1
d975 1
d1362 1
d1402 1
d1431 1
d1609 1
d1621 1
d1637 1
d1676 1
@


1.4
log
@* net.cc (cygwin_inet_network): new function.
* cygwin.din (inet_network): new export
@
text
@d131 1
a131 1
extern "C" unsigned int	 inet_network (const char *);
@


1.3
log
@Respond to more g++ warnings relating to initializing structures.
@
text
@d130 11
d1825 1
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d228 1
a228 1
 {0}
d259 1
a259 1
  {0}
@


1.1
log
@Initial revision
@
text
@d907 1
a907 1
cygwin_herror (const char *p)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
