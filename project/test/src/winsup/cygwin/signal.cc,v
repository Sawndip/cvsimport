head	1.123;
access;
symbols
	cygwin-1_7_35-release:1.123
	cygwin-1_7_34-release:1.123
	cygwin-1_7_33-release:1.120.2.2
	cygwin-1_7_32-release:1.120.2.1
	cygwin-1_7_31-release:1.120.2.1
	cygwin-1_7_30-release:1.120.2.1
	cygwin-1_7_29-release:1.120
	cygwin-1_7_29-release-branchpoint:1.120.0.2
	cygwin-pre-user-db:1.120
	cygwin-1_7_28-release:1.120
	cygwin-1_7_27-release:1.120
	cygwin-1_7_26-release:1.120
	cygwin-1_7_25-release:1.120
	cygwin-1_7_24-release:1.120
	cygwin-1_7_23-release:1.120
	cygwin-1_7_22-release:1.120
	cygwin-1_7_21-release:1.120
	cygwin-1_7_20-release:1.120
	cygwin-1_7_19-release:1.120
	cygwin-64bit-postmerge:1.119
	cygwin-64bit-premerge-branch:1.118.0.2
	cygwin-64bit-premerge:1.118
	cygwin-1_7_18-release:1.118
	post-ptmalloc3:1.114.2.4
	pre-ptmalloc3:1.114.2.4
	cygwin-1_7_17-release:1.116
	cygwin-64bit-branch:1.114.0.2
	cygwin-1_7_16-release:1.110
	cygwin-1_7_15-release:1.106
	cygwin-1_7_14_2-release:1.106
	cygwin-1_7_14-release:1.106
	cygwin-1_7_12-release:1.106
	cygwin-1_7_11-release:1.106
	cygwin-1_7_10-release:1.106
	signal-rewrite:1.100.0.2
	pre-notty:1.97
	cygwin-1_7_9-release:1.91
	cv-post-1_7_9:1.91.0.2
	cygwin-1_7_8-release:1.91
	cygwin-1_7_7-release:1.90
	cygwin-1_7_5-release:1.90
	cygwin-1_7_4-release:1.90
	cygwin-1_7_3-release:1.90
	cygwin-1_7_2-release:1.90
	fifo_doover3:1.90.0.2
	cygwin-1_7_1-release:1.88
	prefifo:1.88
	cv-branch-2:1.88.0.2
	pre-ripout-set_console_state_for_spawn:1.88
	EOL_registry_mounts:1.86
	preoverlapped:1.84
	drop_9x_support_start:1.82
	cr-0x5f1:1.82.0.4
	cv-branch:1.82.0.2
	pre-ptymaster-archetype:1.81
	cr-0x3b58:1.76.0.4
	cr-0x5ef:1.76.0.2
	after-mmap-privanon-noreserve:1.75
	after-mmap-revamp:1.75
	before-mmap-revamp:1.75
	cgf-more-exit-sync:1.73
	post_wait_sig_exit:1.72
	pre_wait_sig_exit:1.72
	reparent-point:1.61
	noreparent:1.61.0.4
	cr-0x5e6:1.61.0.2
	cr-0x9e:1.55.0.6
	cr-0x9d:1.55.0.4
	cgf-deleteme:1.55.0.2
	pre-sigrewrite:1.53
	corinna-01:1.53
	cr-0x9c:1.48.0.4
	cr-0x9b:1.48.0.2
	cr-0x99:1.47
	Z-emcb-cygwin_daemon:1.46.0.2
	w32api-2_2:1.42
	mingw-runtime-2_4:1.42
	pre-cgf-merge:1.50
	cgf-dev-branch:1.41.0.2
	predaemon:1.33
	cygwin_daemon_merge_HEAD:1.33
	pregp02r1:1.33.0.8
	cygnus_cvs_20020108_pre:1.31
	Z-cygwin_daemon_merge-new_HEAD:1.34
	Z-cygwin_daemon_merge_HEAD:1.34
	cygwin_daemon:1.30.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.123
date	2014.08.22.09.21.32;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2014.08.19.19.25.54;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2014.05.09.14.28.48;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches
	1.120.2.1;
next	1.119;

1.119
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2013.01.31.05.26.46;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2013.01.21.04.34.52;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2012.08.15.19.07.42;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2012.08.15.16.35.00;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2012.08.07.04.25.05;	author cgf;	state Exp;
branches
	1.114.2.1;
next	1.113;

1.113
date	2012.07.30.03.44.40;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2012.07.25.22.21.17;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2012.07.02.02.24.25;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2011.12.13.20.06.30;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2011.12.03.23.55.21;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2011.11.21.19.13.30;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2011.11.14.01.29.49;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2011.08.03.19.17.02;	author yselkowitz;	state Exp;
branches;
next	1.99;

1.99
date	2011.08.03.16.40.47;	author yselkowitz;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.10.00.01.33;	author ericb;	state Exp;
branches;
next	1.97;

1.97
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2011.05.05.00.31.20;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2011.05.03.02.03.04;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2011.04.18.11.26.37;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2011.04.18.01.46.57;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2011.04.17.21.45.28;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.20.22.28.57;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2009.12.19.00.58.34;	author ericb;	state Exp;
branches;
next	1.89;

1.89
date	2009.12.17.14.04.04;	author ericb;	state Exp;
branches;
next	1.88;

1.88
date	2008.06.09.13.45.59;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2008.04.07.18.45.58;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.12.20.49.48;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2007.03.07.21.51.27;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2006.07.04.23.57.43;	author cgf;	state Exp;
branches
	1.82.4.1;
next	1.81;

1.81
date	2006.04.22.23.13.18;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2006.04.22.23.09.44;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.23.15.55.59;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.22.04.13.55;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2006.02.06.18.24.06;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.23.22.50.20;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2005.11.14.04.28.45;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2005.11.04.20.45.56;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2005.09.26.14.51.47;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2005.08.23.22.22.52;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.03.02.40.29;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2005.06.09.05.11.51;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2005.03.27.23.33.29;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2005.03.27.02.31.32;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2005.03.09.21.07.56;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2005.02.26.20.50.25;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2005.01.03.18.11.00;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.03.18.06.26;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.26.04.15.08;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.25.15.15.27;	author cgf;	state Exp;
branches
	1.61.4.1;
next	1.60;

1.60
date	2004.02.26.05.10.47;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.21.15.47.48;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2003.11.28.22.13.57;	author cgf;	state Exp;
branches
	1.55.2.1
	1.55.6.1;
next	1.54;

1.54
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.27.02.30.46;	author phumblet;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.25.03.51.51;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.17.01.15.55;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.13.17.14.15;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.07.05.18.01;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.01.02.05.32;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2003.08.19.05.47.44;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2003.08.19.04.10.41;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2003.05.06.19.39.10;	author tpfaff;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.22.10.43.38;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.15.10.21.23;	author corinna;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2003.01.14.20.05.49;	author tpfaff;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.22.20.51.13;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.22.04.43.47;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.15.19.04.36;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.20.04.15.50;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.13.20.03.03;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.11.02.24.06;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.08.17.49.52;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.16.17.09.19;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.03.03.13.14;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.22.16.22.36;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.01.00.06.17;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.16.18.49.20;	author duda;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.07.23.48.09;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.17.14.57.09;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.12.05.38.25;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.08.04.02.01;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.05.06.42.23;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.30.23.19.45;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.26.00.51.50;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.21.04.53.49;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.20.04.20.21;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.02.19.19.21;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.16.13.19.52;	author duda;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.11.00.25.57;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.29.02.06.49;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.29.16.24.39;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.05.23.46.44;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.120.2.1
date	2014.05.19.11.47.54;	author corinna;	state Exp;
branches;
next	1.120.2.2;

1.120.2.2
date	2014.11.13.12.53.06;	author corinna;	state Exp;
branches;
next	;

1.114.2.1
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.114.2.2;

1.114.2.2
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.114.2.3;

1.114.2.3
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.114.2.4;

1.114.2.4
date	2013.02.05.15.30.12;	author corinna;	state Exp;
branches;
next	;

1.82.4.1
date	2007.11.12.15.30.20;	author corinna;	state Exp;
branches;
next	1.82.4.2;

1.82.4.2
date	2008.02.18.14.08.37;	author corinna;	state Exp;
branches;
next	;

1.61.4.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	;

1.55.2.1
date	2004.01.15.18.29.37;	author cgf;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	1.55.2.3;

1.55.2.3
date	2004.01.17.05.51.36;	author cgf;	state Exp;
branches;
next	1.55.2.4;

1.55.2.4
date	2004.01.19.05.38.24;	author cgf;	state Exp;
branches;
next	;

1.55.6.1
date	2004.01.21.15.47.58;	author cgf;	state Exp;
branches;
next	;

1.41.2.1
date	2003.01.24.04.04.20;	author cgf;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2003.05.10.17.20.54;	author cgf;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2003.09.14.01.35.38;	author cgf;	state Exp;
branches;
next	;

1.30.4.1
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.30.4.2;

1.30.4.2
date	2002.01.15.12.52.51;	author rbcollins;	state Exp;
branches;
next	1.30.4.3;

1.30.4.3
date	2002.06.13.14.34.11;	author rbcollins;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.123
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@/* signal.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

   Written by Steve Chamberlain of Cygnus Support, sac@@cygnus.com
   Significant changes by Sergey Okhapkin <sos@@prospect.com.ru>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <sys/cygwin.h>
#include "pinfo.h"
#include "sigproc.h"
#include "cygtls.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "cygwait.h"

#define _SA_NORESTART	0x8000

static int __reg3 sigaction_worker (int, const struct sigaction *, struct sigaction *, bool);

#define sigtrapped(func) ((func) != SIG_IGN && (func) != SIG_DFL)

extern "C" _sig_func_ptr
signal (int sig, _sig_func_ptr func)
{
  sig_dispatch_pending ();
  _sig_func_ptr prev;

  /* check that sig is in right range */
  if (sig < 0 || sig >= NSIG || sig == SIGKILL || sig == SIGSTOP)
    {
      set_errno (EINVAL);
      syscall_printf ("SIG_ERR = signal (%d, %p)", sig, func);
      return (_sig_func_ptr) SIG_ERR;
    }

  prev = global_sigs[sig].sa_handler;
  struct sigaction& gs = global_sigs[sig];
  if (gs.sa_flags & _SA_NORESTART)
    gs.sa_flags &= ~SA_RESTART;
  else
    gs.sa_flags |= SA_RESTART;

  gs.sa_mask = SIGTOMASK (sig);
  gs.sa_handler = func;
  gs.sa_flags &= ~SA_SIGINFO;

  syscall_printf ("%p = signal (%d, %p)", prev, sig, func);
  return prev;
}

extern "C" int
clock_nanosleep (clockid_t clk_id, int flags, const struct timespec *rqtp,
		 struct timespec *rmtp)
{
  const bool abstime = (flags & TIMER_ABSTIME) ? true : false;
  int res = 0;
  sig_dispatch_pending ();
  pthread_testcancel ();

  if (rqtp->tv_sec < 0 || rqtp->tv_nsec < 0 || rqtp->tv_nsec > 999999999L)
    return EINVAL;

  /* Explicitly disallowed by POSIX. Needs to be checked first to avoid
     being caught by the following test. */
  if (clk_id == CLOCK_THREAD_CPUTIME_ID)
    return EINVAL;

  /* support for CPU-time clocks is optional */
  if (CLOCKID_IS_PROCESS (clk_id) || CLOCKID_IS_THREAD (clk_id))
    return ENOTSUP;

  switch (clk_id)
    {
    case CLOCK_REALTIME:
    case CLOCK_MONOTONIC:
      break;
    default:
      /* unknown or illegal clock ID */
      return EINVAL;
    }

  LARGE_INTEGER timeout;

  timeout.QuadPart = (LONGLONG) rqtp->tv_sec * NSPERSEC
		     + ((LONGLONG) rqtp->tv_nsec + 99LL) / 100LL;

  if (abstime)
    {
      struct timespec tp;

      clock_gettime (clk_id, &tp);
      /* Check for immediate timeout */
      if (tp.tv_sec > rqtp->tv_sec
	  || (tp.tv_sec == rqtp->tv_sec && tp.tv_nsec > rqtp->tv_nsec))
	return 0;

      if (clk_id == CLOCK_REALTIME)
	timeout.QuadPart += FACTOR;
      else
	{
	  /* other clocks need to be handled with a relative timeout */
	  timeout.QuadPart -= tp.tv_sec * NSPERSEC + tp.tv_nsec / 100LL;
	  timeout.QuadPart *= -1LL;
	}
    }
  else /* !abstime */
    timeout.QuadPart *= -1LL;

  syscall_printf ("clock_nanosleep (%ld.%09ld)", rqtp->tv_sec, rqtp->tv_nsec);

  int rc = cygwait (NULL, &timeout, cw_sig_eintr | cw_cancel | cw_cancel_self);
  if (rc == WAIT_SIGNALED)
    res = EINTR;

  /* according to POSIX, rmtp is used only if !abstime */
  if (rmtp && !abstime)
    {
      rmtp->tv_sec = (time_t) (timeout.QuadPart / NSPERSEC);
      rmtp->tv_nsec = (long) ((timeout.QuadPart % NSPERSEC) * 100LL);
    }

  syscall_printf ("%d = clock_nanosleep(%lu, %d, %ld.%09ld, %ld.%09.ld)",
		  res, clk_id, flags, rqtp->tv_sec, rqtp->tv_nsec,
		  rmtp ? rmtp->tv_sec : 0, rmtp ? rmtp->tv_nsec : 0);
  return res;
}

extern "C" int
nanosleep (const struct timespec *rqtp, struct timespec *rmtp)
{
  int res = clock_nanosleep (CLOCK_REALTIME, 0, rqtp, rmtp);
  if (res != 0)
    {
      set_errno (res);
      return -1;
    }
  return 0;
}

extern "C" unsigned int
sleep (unsigned int seconds)
{
  struct timespec req, rem;
  req.tv_sec = seconds;
  req.tv_nsec = 0;
  if (clock_nanosleep (CLOCK_REALTIME, 0, &req, &rem))
    return rem.tv_sec + (rem.tv_nsec > 0);
  return 0;
}

extern "C" unsigned int
usleep (useconds_t useconds)
{
  struct timespec req;
  req.tv_sec = useconds / 1000000;
  req.tv_nsec = (useconds % 1000000) * 1000;
  int res = clock_nanosleep (CLOCK_REALTIME, 0, &req, NULL);
  if (res != 0)
    {
      set_errno (res);
      return -1;
    }
  return 0;
}

extern "C" int
sigprocmask (int how, const sigset_t *set, sigset_t *oldset)
{
  int res = handle_sigprocmask (how, set, oldset, _my_tls.sigmask);
  if (res)
    {
      set_errno (res);
      res = -1;
    }
  syscall_printf ("%R = sigprocmask (%d, %p, %p)", res, how, set, oldset);
  return res;
}

int __reg3
handle_sigprocmask (int how, const sigset_t *set, sigset_t *oldset, sigset_t& opmask)
{
  /* check that how is in right range */
  if (how != SIG_BLOCK && how != SIG_UNBLOCK && how != SIG_SETMASK)
    {
      syscall_printf ("Invalid how value %d", how);
      return EINVAL;
    }

  __try
	{
      if (oldset)
	*oldset = opmask;

      if (set)
	{
	  sigset_t newmask = opmask;
	  switch (how)
	    {
	    case SIG_BLOCK:
	      /* add set to current mask */
	      newmask |= *set;
	      break;
	    case SIG_UNBLOCK:
	      /* remove set from current mask */
	      newmask &= ~*set;
	      break;
	    case SIG_SETMASK:
	      /* just set it */
	      newmask = *set;
	      break;
	    }
	  set_signal_mask (opmask, newmask);
	}
    }
  __except (EFAULT)
    {
      return EFAULT;
    }
  __endtry
  return 0;
}

int __reg2
_pinfo::kill (siginfo_t& si)
{
  int res;
  DWORD this_process_state;
  pid_t this_pid;

  sig_dispatch_pending ();

  if (exists ())
    {
      bool sendSIGCONT;
      this_process_state = process_state;
      if ((sendSIGCONT = (si.si_signo < 0)))
	si.si_signo = -si.si_signo;

      if (si.si_signo == 0)
	res = 0;
      else if ((res = sig_send (this, si)))
	{
	  sigproc_printf ("%d = sig_send, %E ", res);
	  res = -1;
	}
      else if (sendSIGCONT)
	{
	  siginfo_t si2 = {0};
	  si2.si_signo = SIGCONT;
	  si2.si_code = SI_KERNEL;
	  sig_send (this, si2);
	}
      this_pid = pid;
    }
  else if (si.si_signo == 0 && this && process_state == PID_EXITED)
    {
      this_process_state = process_state;
      this_pid = pid;
      res = 0;
    }
  else
    {
      set_errno (ESRCH);
      this_process_state = 0;
      this_pid = 0;
      res = -1;
    }

  syscall_printf ("%d = _pinfo::kill (%d), pid %d, process_state %y", res,
		  si.si_signo, this_pid, this_process_state);
  return res;
}

int
raise (int sig)
{
  return kill (myself->pid, sig);
}

static int
kill0 (pid_t pid, siginfo_t& si)
{
  syscall_printf ("kill (%d, %d)", pid, si.si_signo);
  /* check that sig is in right range */
  if (si.si_signo < 0 || si.si_signo >= NSIG)
    {
      set_errno (EINVAL);
      syscall_printf ("signal %d out of range", si.si_signo);
      return -1;
    }

  return (pid > 0) ? pinfo (pid)->kill (si) : kill_pgrp (-pid, si);
}

int
kill (pid_t pid, int sig)
{
  siginfo_t si = {0};
  si.si_signo = sig;
  si.si_code = SI_USER;
  return kill0 (pid, si);
}

int
kill_pgrp (pid_t pid, siginfo_t& si)
{
  int res = 0;
  int found = 0;
  int killself = 0;

  sigproc_printf ("pid %d, signal %d", pid, si.si_signo);

  winpids pids ((DWORD) PID_MAP_RW);
  for (unsigned i = 0; i < pids.npids; i++)
    {
      _pinfo *p = pids[i];

      if (!p->exists ())
	continue;

      /* Is it a process we want to kill?  */
      if ((pid == 0 && (p->pgid != myself->pgid || p->ctty != myself->ctty)) ||
	  (pid > 1 && p->pgid != pid) ||
	  (si.si_signo < 0 && NOTSTATE (p, PID_STOPPED)))
	continue;
      sigproc_printf ("killing pid %d, pgrp %d, p->%s, %s", p->pid, p->pgid,
		      p->__ctty (), myctty ());
      if (p == myself)
	killself++;
      else if (p->kill (si))
	res = -1;
      found++;
    }

  if (killself && !exit_state && myself->kill (si))
    res = -1;

  if (!found)
    {
      set_errno (ESRCH);
      res = -1;
    }
  syscall_printf ("%R = kill(%d, %d)", res, pid, si.si_signo);
  return res;
}

extern "C" int
killpg (pid_t pgrp, int sig)
{
  return kill (-pgrp, sig);
}

extern "C" void
abort (void)
{
  _my_tls.incyg++;
  sig_dispatch_pending ();
  /* Ensure that SIGABRT can be caught regardless of blockage. */
  sigset_t sig_mask;
  sigfillset (&sig_mask);
  sigdelset (&sig_mask, SIGABRT);
  set_signal_mask (_my_tls.sigmask, sig_mask);

  raise (SIGABRT);
  _my_tls.call_signal_handler (); /* Call any signal handler */

  /* Flush all streams as per SUSv2.  */
  if (_GLOBAL_REENT->__cleanup)
    _GLOBAL_REENT->__cleanup (_GLOBAL_REENT);
  do_exit (SIGABRT);	/* signal handler didn't exit.  Goodbye. */
}

static int __reg3
sigaction_worker (int sig, const struct sigaction *newact,
		  struct sigaction *oldact, bool isinternal)
{
  int res = -1;
  __try
    {
      sig_dispatch_pending ();
      /* check that sig is in right range */
      if (sig < 0 || sig >= NSIG)
	set_errno (EINVAL);
      else
	{
	  struct sigaction oa = global_sigs[sig];

	  if (!newact)
	    sigproc_printf ("signal %d, newact %p, oa %p",
			    sig, newact, oa, oa.sa_handler);
	  else
	    {
	      sigproc_printf ("signal %d, newact %p (handler %p), oa %p",
			      sig, newact, newact->sa_handler, oa,
			      oa.sa_handler);
	      if (sig == SIGKILL || sig == SIGSTOP)
		{
		  set_errno (EINVAL);
		  __leave;
		}
	      struct sigaction na = *newact;
	      struct sigaction& gs = global_sigs[sig];
	      if (!isinternal)
		na.sa_flags &= ~_SA_INTERNAL_MASK;
	      gs = na;
	      if (!(gs.sa_flags & SA_NODEFER))
		gs.sa_mask |= SIGTOMASK(sig);
	      if (gs.sa_handler == SIG_IGN)
		sig_clear (sig);
	      if (gs.sa_handler == SIG_DFL && sig == SIGCHLD)
		sig_clear (sig);
	      if (sig == SIGCHLD)
		{
		  myself->process_state &= ~PID_NOCLDSTOP;
		  if (gs.sa_flags & SA_NOCLDSTOP)
		    myself->process_state |= PID_NOCLDSTOP;
		}
	    }

	    if (oldact)
	      {
		*oldact = oa;
		oa.sa_flags &= ~_SA_INTERNAL_MASK;
	      }
	    res = 0;
	}
    }
  __except (EFAULT) {}
  __endtry
  return res;
}

extern "C" int
sigaction (int sig, const struct sigaction *newact, struct sigaction *oldact)
{
  int res = sigaction_worker (sig, newact, oldact, false);
  syscall_printf ("%R = sigaction(%d, %p, %p)", res, sig, newact, oldact);
  return res;
}

extern "C" int
sigaddset (sigset_t *set, const int sig)
{
  /* check that sig is in right range */
  if (sig <= 0 || sig >= NSIG)
    {
      set_errno (EINVAL);
      syscall_printf ("SIG_ERR = sigaddset signal %d out of range", sig);
      return -1;
    }

  *set |= SIGTOMASK (sig);
  return 0;
}

extern "C" int
sigdelset (sigset_t *set, const int sig)
{
  /* check that sig is in right range */
  if (sig <= 0 || sig >= NSIG)
    {
      set_errno (EINVAL);
      syscall_printf ("SIG_ERR = sigdelset signal %d out of range", sig);
      return -1;
    }

  *set &= ~SIGTOMASK (sig);
  return 0;
}

extern "C" int
sigismember (const sigset_t *set, int sig)
{
  /* check that sig is in right range */
  if (sig <= 0 || sig >= NSIG)
    {
      set_errno (EINVAL);
      syscall_printf ("SIG_ERR = sigdelset signal %d out of range", sig);
      return -1;
    }

  if (*set & SIGTOMASK (sig))
    return 1;
  else
    return 0;
}

extern "C" int
sigemptyset (sigset_t *set)
{
  *set = (sigset_t) 0;
  return 0;
}

extern "C" int
sigfillset (sigset_t *set)
{
  *set = ~((sigset_t) 0);
  return 0;
}

extern "C" int
sigsuspend (const sigset_t *set)
{
  int res = handle_sigsuspend (*set);
  syscall_printf ("%R = sigsuspend(%p)", res, set);
  return res;
}

extern "C" int
sigpause (int signal_mask)
{
  int res = handle_sigsuspend ((sigset_t) signal_mask);
  syscall_printf ("%R = sigpause(%y)", res, signal_mask);
  return res;
}

extern "C" int
pause (void)
{
  int res = handle_sigsuspend (_my_tls.sigmask);
  syscall_printf ("%R = pause()", res);
  return res;
}

extern "C" int
siginterrupt (int sig, int flag)
{
  struct sigaction act;
  sigaction (sig, NULL, &act);
  if (flag)
    {
      act.sa_flags &= ~SA_RESTART;
      act.sa_flags |= _SA_NORESTART;
    }
  else
    {
      act.sa_flags &= ~_SA_NORESTART;
      act.sa_flags |= SA_RESTART;
    }
  int res = sigaction_worker (sig, &act, NULL, true);
  syscall_printf ("%R = siginterrupt(%d, %y)", sig, flag);
  return res;
}

extern "C" int
sigwait (const sigset_t *set, int *sig_ptr)
{
  int sig = sigwaitinfo (set, NULL);
  if (sig > 0)
    *sig_ptr = sig;
  return sig > 0 ? 0 : -1;
}

extern "C" int
sigwaitinfo (const sigset_t *set, siginfo_t *info)
{
  int res = -1;

  pthread_testcancel ();

  __try
    {
      set_signal_mask (_my_tls.sigwait_mask, *set);
      sig_dispatch_pending (true);

      switch (cygwait (NULL, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
	{
	case WAIT_SIGNALED:
	  if (!sigismember (set, _my_tls.infodata.si_signo))
	    set_errno (EINTR);
	  else
	    {
	      _my_tls.lock ();
	      if (info)
		*info = _my_tls.infodata;
	      res = _my_tls.infodata.si_signo;
	      _my_tls.sig = 0;
	      if (_my_tls.retaddr () == (__stack_t) sigdelayed)
		_my_tls.pop ();
	      _my_tls.unlock ();
	    }
	  break;
	default:
	  __seterrno ();
	  break;
	}
    }
  __except (EFAULT) {
    res = -1;
  }
  __endtry
  sigproc_printf ("returning signal %d", res);
  return res;
}

/* FIXME: SUSv3 says that this function should block until the signal has
   actually been delivered.  Currently, this will only happen when sending
   signals to the current process.  It will not happen when sending signals
   to other processes.  */
extern "C" int
sigqueue (pid_t pid, int sig, const union sigval value)
{
  siginfo_t si = {0};
  pinfo dest (pid);
  if (!dest)
    {
      set_errno (ESRCH);
      return -1;
    }
  si.si_signo = sig;
  si.si_code = SI_QUEUE;
  si.si_value = value;
  return sig_send (dest, si);
}
@


1.122
log
@	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d200 4
a203 6
  myfault efault;
  if (efault.faulted (EFAULT))
    return EFAULT;

  if (oldset)
    *oldset = opmask;
d205 1
a205 4
  if (set)
    {
      sigset_t newmask = opmask;
      switch (how)
d207 17
a223 12
	case SIG_BLOCK:
	  /* add set to current mask */
	  newmask |= *set;
	  break;
	case SIG_UNBLOCK:
	  /* remove set from current mask */
	  newmask &= ~*set;
	  break;
	case SIG_SETMASK:
	  /* just set it */
	  newmask = *set;
	  break;
a224 1
      set_signal_mask (opmask, newmask);
d226 5
d389 1
a389 2
  myfault efault;
  if (!efault.faulted (EFAULT))
d400 2
a401 1
	    sigproc_printf ("signal %d, newact %p, oa %p", sig, newact, oa, oa.sa_handler);
d404 3
a406 1
	      sigproc_printf ("signal %d, newact %p (handler %p), oa %p", sig, newact, newact->sa_handler, oa, oa.sa_handler);
d410 1
a410 1
		  goto out;
d439 2
a440 2

out:
d569 2
d573 4
a576 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d578 1
a578 8
  set_signal_mask (_my_tls.sigwait_mask, *set);
  sig_dispatch_pending (true);

  int res;
  switch (cygwait (NULL, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
    {
    case WAIT_SIGNALED:
      if (!sigismember (set, _my_tls.infodata.si_signo))
d580 18
a597 2
	  set_errno (EINTR);
	  res = -1;
a598 15
      else
	{
	  _my_tls.lock ();
	  if (info)
	    *info = _my_tls.infodata;
	  res = _my_tls.infodata.si_signo;
	  _my_tls.sig = 0;
	  if (_my_tls.retaddr () == (__stack_t) sigdelayed)
	    _my_tls.pop ();
	  _my_tls.unlock ();
	}
      break;
    default:
      __seterrno ();
      res = -1;
d600 4
a603 1

@


1.121
log
@* signal.cc (sigprocmask): Fix strace output to include "how".
* fhandler_console.cc (dev_console::save_restore): Only current dwEnd line
rather than the one after that.
@
text
@d567 1
a567 1
    return EFAULT;
@


1.120
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d186 1
a186 1
  syscall_printf ("%R = sigprocmask (%d, %p, %p)", res, set, oldset);
@


1.120.2.1
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@d186 1
a186 1
  syscall_printf ("%R = sigprocmask (%d, %p, %p)", res, how, set, oldset);
@


1.120.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d200 6
a205 4
  __try
	{
      if (oldset)
	*oldset = opmask;
d207 4
a210 1
      if (set)
d212 12
a223 17
	  sigset_t newmask = opmask;
	  switch (how)
	    {
	    case SIG_BLOCK:
	      /* add set to current mask */
	      newmask |= *set;
	      break;
	    case SIG_UNBLOCK:
	      /* remove set from current mask */
	      newmask &= ~*set;
	      break;
	    case SIG_SETMASK:
	      /* just set it */
	      newmask = *set;
	      break;
	    }
	  set_signal_mask (opmask, newmask);
d225 1
a226 5
  __except (EFAULT)
    {
      return EFAULT;
    }
  __endtry
d385 2
a386 1
  __try
d397 1
a397 2
	    sigproc_printf ("signal %d, newact %p, oa %p",
			    sig, newact, oa, oa.sa_handler);
d400 1
a400 3
	      sigproc_printf ("signal %d, newact %p (handler %p), oa %p",
			      sig, newact, newact->sa_handler, oa,
			      oa.sa_handler);
d404 1
a404 1
		  __leave;
d433 2
a434 2
  __except (EFAULT) {}
  __endtry
d563 5
a567 1
  int res = -1;
d569 2
a570 1
  pthread_testcancel ();
d572 2
a573 1
  __try
d575 7
a581 4
      set_signal_mask (_my_tls.sigwait_mask, *set);
      sig_dispatch_pending (true);

      switch (cygwait (NULL, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
d583 8
a590 18
	case WAIT_SIGNALED:
	  if (!sigismember (set, _my_tls.infodata.si_signo))
	    set_errno (EINTR);
	  else
	    {
	      _my_tls.lock ();
	      if (info)
		*info = _my_tls.infodata;
	      res = _my_tls.infodata.si_signo;
	      _my_tls.sig = 0;
	      if (_my_tls.retaddr () == (__stack_t) sigdelayed)
		_my_tls.pop ();
	      _my_tls.unlock ();
	    }
	  break;
	default:
	  __seterrno ();
	  break;
d592 4
d597 1
a597 4
  __except (EFAULT) {
    res = -1;
  }
  __endtry
@


1.119
log
@	* Merge in cygwin-64bit-branch.
@
text
@d190 1
a190 1
int __stdcall
d230 1
a230 1
int __stdcall
@


1.118
log
@* DevNotes: Add entry cgf-000022.
* cygtls.h (_cygtls::func): Define as a sa_sigaction style function.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(_cygtls::interrupt_setup): Fix coercion to accommodate 'func' change.
(ctrl_c_handler): Use tty kill_pgrp to send a signal.
(sigpacket::process): Don't process sigflush here.
(_cygtls::call_signal_handler): Reorganize to avoid a race.  Always call
sa_sigaction style function.
* fhandler_termios.cc (is_flush_sig): Define new function.
(tty_min::kill_pgrp): Handle tty flush when signal detected.
(fhandler_termios::bg_check): Be slightly more paranoid about checking for
valid tty.
(fhandler_termios::sigflush): Don't flush unless tty owner.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Use tty kill_pgrp to send
signal.
(fhandler_pty_master::ioctl): Ditto.
* signal.cc (killsys): Delete definition.
* sigproc.h (killsys): Delete declaration.
* include/cygwin/signal.h (siginfo_t): Simplify union/struct nesting slightly.
Implement mechanism to allow cygwin data passing.
@
text
@d276 1
a276 1
  syscall_printf ("%d = _pinfo::kill (%d), pid %d, process_state %p", res,
d519 1
a519 1
  syscall_printf ("%R = sigpause(%p)", res, signal_mask);
d547 1
a547 1
  syscall_printf ("%R = siginterrupt(%d, %p)", sig, flag);
@


1.117
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@a302 9
killsys (pid_t pid, int sig)
{
  siginfo_t si = {0};
  si.si_signo = sig;
  si.si_code = SI_KERNEL;
  return kill0 (pid, si);
}

int
@


1.116
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d29 1
a29 2
static int sigaction_worker (int, const struct sigaction *, struct sigaction *, bool)
  __attribute__ ((regparm (3)));
d389 1
a389 1
static int  __attribute__ ((regparm (3)))
@


1.115
log
@* exceptions.cc (sigdelayed): Move declaration to sigproc.h.
* sigproc.h (sigdelayed): Make symbol globally available.
* gendef (sigdelayed): Specifically zero incyg and stacklock.
* signal.cc (sigwaitinfo): Lock _my_tls and try harder to clean up signal
information.
@
text
@d123 1
a123 1
  int rc = cancelable_wait (NULL, &timeout, cw_sig_eintr | cw_cancel | cw_cancel_self);
d583 1
a583 1
  switch (cancelable_wait (NULL, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
@


1.114
log
@* signal.cc (sigwaitinfo): Change cw_sig to the correct cw_sig_eintr.
@
text
@d593 1
d597 4
a600 1
	  InterlockedExchange ((LONG *) &_my_tls.sig, (LONG) 0);
@


1.114.2.1
log
@Pull in changes from HEAD
@
text
@d123 1
a123 1
  int rc = cygwait (NULL, &timeout, cw_sig_eintr | cw_cancel | cw_cancel_self);
d583 1
a583 1
  switch (cygwait (NULL, cw_infinite, cw_sig_eintr | cw_cancel | cw_cancel_self))
a592 1
	  _my_tls.lock ();
d596 1
a596 4
	  _my_tls.sig = 0;
	  if (_my_tls.retaddr () == (__stack_t) sigdelayed)
	    _my_tls.pop ();
	  _my_tls.unlock ();
@


1.114.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d277 1
a277 1
  syscall_printf ("%d = _pinfo::kill (%d), pid %d, process_state %y", res,
d529 1
a529 1
  syscall_printf ("%R = sigpause(%y)", res, signal_mask);
d557 1
a557 1
  syscall_printf ("%R = siginterrupt(%d, %y)", sig, flag);
@


1.114.2.3
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d29 2
a30 1
static int __reg3 sigaction_worker (int, const struct sigaction *, struct sigaction *, bool);
d390 1
a390 1
static int __reg3
@


1.114.2.4
log
@Pull in changes from HEAD
@
text
@d303 9
@


1.113
log
@* cygwait.cc (cancelable_wait): Add some debugging-only output.
* exceptions.cc (sig_handle_tty_stop): Make sure that incyg is cleared when
exiting if we have no parent process.  Only wait for signal_arrived.
(sigpacket::process): Make continue_now a bool.  Delay sending signal_arrived
until the end.  Make code more defensive to avoid calling signal handler when
stopped.  Only set signal_arrived when stopped.
* sigproc.cc (sig_hold): Rename from sigCONT.  Make static.
(sig_send): Accommodate sigCONT -> sig_hold rename.
(wait_sig): Ditto.
* sigproc.h (sigCONT): Delete declaration.
* fhandler_console.cc (fhandler_console::write): Use new '%0c' facility to
print characters.  Change to paranoid to avoid excessive strace output.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Make frequent strace
printf "paranoid" to help cut down on strace output size.
* signal.cc (sigsuspend): Add standard syscall strace output.
(sigpause): Ditto.
(pause): Ditto.
* cygtls.h (_cygtls::reset_signal_arrived): New function.
@
text
@d583 1
a583 1
  switch (cancelable_wait (NULL, cw_infinite, cw_sig | cw_cancel | cw_cancel_self))
a595 1
	  /* FIXME: Is this right? */
@


1.112
log
@* signal.cc (clock_nanosleep): Force return on signal rather than letting
cancelable_wait loop on signal.
@
text
@d520 3
a522 1
  return handle_sigsuspend (*set);
d528 3
a530 1
  return handle_sigsuspend ((sigset_t) signal_mask);
d536 3
a538 1
  return handle_sigsuspend (_my_tls.sigmask);
@


1.111
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d123 1
a123 1
  int rc = cancelable_wait (NULL, &timeout, cw_sig | cw_cancel | cw_cancel_self);
@


1.110
log
@* Makefile.in: Add some more optimization flags for cygwait, malloc and path.  Explain
why -fomit-frame-pointer doesn't work right for passwd.o and path.o.  Add
-static to link command line for cygwin0.dll.
* fhandler_disk_file.cc (fhandler_disk_file::facl): Reorganize slightly to
silence compiler warning when compiling with -fstack-check.
* net.cc (inet_ntop6): Initialize structure members to silence compiler warning
when compiling with -fstack-check.
* pseudo-reloc.cc (_pei386_runtime_relocator): Make this a C function.  Detect
NULL u.
* winsup.h (_pei386_runtime_relocator): Declare this as extern "C".
* lib/_cygwin_crt0_common.cc (_pei386_runtime_relocator): Call with NULL
argument.
* signal.cc (sigaction_worker): Eliminate last argument.  Let callers report
their own strace info.  Regparmize.
(sigaction): Reflect sigaction_worker changes.
(siginterrupt): Ditto.
* exceptions.cc: Update copyright.
@
text
@d123 3
a125 6
  int rc = cancelable_wait (signal_arrived, &timeout);
  if (rc == WAIT_OBJECT_0)
    {
      _my_tls.call_signal_handler ();
      res = EINTR;
    }
d226 1
a226 1
      set_signal_mask (newmask, opmask);
d379 1
a379 1
  set_signal_mask (sig_mask, _my_tls.sigmask);
a567 7
  HANDLE h;
  h = _my_tls.event = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
  if (!h)
    {
      __seterrno ();
      return -1;
    }
d569 5
a573 1
  _my_tls.sigwait_mask = *set;
d577 1
a577 1
  switch (WaitForSingleObject (h, INFINITE))
d579 1
a579 1
    case WAIT_OBJECT_0:
d590 1
a598 2
  _my_tls.event = NULL;
  CloseHandle (h);
@


1.109
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d29 1
a29 1
static int sigaction_worker (int, const struct sigaction *, struct sigaction *, bool, const char *)
d393 1
a393 1
static int
d395 1
a395 1
		  struct sigaction *oldact, bool isinternal, const char *fnname)
a447 1
  syscall_printf ("%R = %s(%d, %p, %p)", res, fnname, sig, newact, oldact);
d454 3
a456 1
  return sigaction_worker (sig, newact, oldact, false, "sigaction");
d553 3
a555 1
  return sigaction_worker (sig, &act, NULL, true, "siginterrupt");
@


1.108
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d123 6
a128 3
  int rc = cancelable_wait (NULL, &timeout, cw_sig | cw_cancel | cw_cancel_self);
  if (rc == WAIT_SIGNALED)
    res = EINTR;
d568 7
d580 1
a580 1
  switch (cancelable_wait (NULL, NULL, cw_sig | cw_cancel | cw_cancel_self))
d582 1
a582 1
    case WAIT_SIGNALED:
d601 2
@


1.107
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d123 3
a125 6
  int rc = cancelable_wait (signal_arrived, &timeout);
  if (rc == WAIT_OBJECT_0)
    {
      _my_tls.call_signal_handler ();
      res = EINTR;
    }
a564 7
  HANDLE h;
  h = _my_tls.event = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
  if (!h)
    {
      __seterrno ();
      return -1;
    }
d570 1
a570 1
  switch (WaitForSingleObject (h, INFINITE))
d572 1
a572 1
    case WAIT_OBJECT_0:
a590 2
  _my_tls.event = NULL;
  CloseHandle (h);
@


1.106
log
@Clean up whitespace.
@
text
@d25 1
@


1.105
log
@* dcrt0.cc (init_windows_system_directory): Record system_wow64_directory
information.
* exceptions.cc (_cygtls::inside_kernel): Modernize comment.  Consider
executing a DLL from the Wow64 directory as being "in the kernel".
(_cygtls::call_signal_handler): For now, only deal with main_tls signals if
main_tls is known to be executing in the cygwin DLL.  To more closely emulate
linux, consider the operation to be restartable if not executing in the main
thread.
* globals.cc (windows_system_directory): Remove NO_COPY.
(windows_system_directory_length): Ditto.
(system_wow64_directory): New variable.
(system_wow64_directory_length): Ditto.
* select.cc (cygwin_select): Don't issue a EINTR on non-main threads since that
seems to be what Linux does.  Add missing break to signal case/switch.
(select_stuff::wait): Don't issue a EINTR on non-main threads since that seems
to be what Linux does.  Remove now-unneeded accommodation for
WAIT_IO_COMPLETION.  Add a comment.
* sigproc.h (cygwait): Ditto.  Don't return if signal_received noticed and it's
not the main thread.
* signal.cc (sigprocmask): Add standard syscall debug stuff.
* thread.cc (pthread_sigmask): Ditto.
@
text
@d105 1
a105 1
          || (tp.tv_sec == rqtp->tv_sec && tp.tv_nsec > rqtp->tv_nsec))
@


1.104
log
@* mmap.cc (mlock): Add standard syscall return value debugging output.
(munlock): Ditto.
(posix_madvise): Ditto.
* signal.cc: Remove obsolete sigcatchers stuff throughout.
(sigaction_worker): Add function name parameter and use it to show standard
syscall return value debugging output.  Also add fault protection.
(sigaction): Accommodate extra argument to sigaction_worker.
(siginterrupt): Ditto.
* syscalls.cc (read): Remove obsolete sigcatchers stuff.
(readv): Ditto.
@
text
@d185 6
a190 2
    set_errno (res);
  return res ? -1 : 0;
@


1.103
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@a25 2
int sigcatchers;	/* FIXME: Not thread safe. */

d28 1
a28 1
static int sigaction_worker (int, const struct sigaction *, struct sigaction *, bool)
a32 17
static inline void
set_sigcatchers (void (*oldsig) (int), void (*cursig) (int))
{
#ifdef DEBUGGING
  int last_sigcatchers = sigcatchers;
#endif
  if (!sigtrapped (oldsig) && sigtrapped (cursig))
    sigcatchers++;
  else if (sigtrapped (oldsig) && !sigtrapped (cursig))
    sigcatchers--;
#ifdef DEBUGGING
  if (last_sigcatchers != sigcatchers)
    sigproc_printf ("last %d, old %d, cur %p, cur %p", last_sigcatchers,
		    sigcatchers, oldsig, cursig);
#endif
}

a57 2
  set_sigcatchers (prev, func);

d389 2
a390 1
sigaction_worker (int sig, const struct sigaction *newact, struct sigaction *oldact, bool isinternal)
d392 3
a394 3
  sig_dispatch_pending ();
  /* check that sig is in right range */
  if (sig < 0 || sig >= NSIG)
d396 7
a402 7
      set_errno (EINVAL);
      sigproc_printf ("signal %d, newact %p, oldact %p", sig, newact, oldact);
      syscall_printf ("SIG_ERR = sigaction signal %d out of range", sig);
      return -1;
    }

  struct sigaction oa = global_sigs[sig];
d404 35
a438 27
  if (!newact)
    sigproc_printf ("signal %d, newact %p, oa %p", sig, newact, oa, oa.sa_handler);
  else
    {
      sigproc_printf ("signal %d, newact %p (handler %p), oa %p", sig, newact, newact->sa_handler, oa, oa.sa_handler);
      if (sig == SIGKILL || sig == SIGSTOP)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      struct sigaction na = *newact;
      struct sigaction& gs = global_sigs[sig];
      if (!isinternal)
	na.sa_flags &= ~_SA_INTERNAL_MASK;
      gs = na;
      if (!(gs.sa_flags & SA_NODEFER))
	gs.sa_mask |= SIGTOMASK(sig);
      if (gs.sa_handler == SIG_IGN)
	sig_clear (sig);
      if (gs.sa_handler == SIG_DFL && sig == SIGCHLD)
	sig_clear (sig);
      set_sigcatchers (oa.sa_handler, gs.sa_handler);
      if (sig == SIGCHLD)
	{
	  myself->process_state &= ~PID_NOCLDSTOP;
	  if (gs.sa_flags & SA_NOCLDSTOP)
	    myself->process_state |= PID_NOCLDSTOP;
d442 3
a444 7
  if (oldact)
    {
      *oldact = oa;
      oa.sa_flags &= ~_SA_INTERNAL_MASK;
    }

  return 0;
d450 1
a450 1
  return sigaction_worker (sig, newact, oldact, false);
d547 1
a547 1
  return sigaction_worker (sig, &act, NULL, true);
@


1.102
log
@* sigproc.cc (remove_proc): Don't do busy loop when execing since thread could
have been terminated prior to setting flag.
* signal.cc (sigwaitinfo): Zero event before closing to signal other threads
that it is no longer available.
@
text
@d157 1
a157 1
  syscall_printf ("%d = clock_nanosleep (%lu, %d, %ld.%09ld, %ld.%09.ld)",
d379 1
a379 1
  syscall_printf ("%d = kill (%d, %d)", res, pid, si.si_signo);
@


1.101
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d611 2
@


1.100
log
@* cygwin.din (clock_nanosleep): Export.
* posix.sgml (std-notimpl): Move clock_nanosleep from here...
(std-susv4): ... to here.
(std-notes): Note limitations of clock_nanosleep.
* signal.cc (clock_nanosleep): Renamed from nanosleep, adding clock_id
and flags arguments and changing return values throughout.
Improve checks for illegal rqtp values.  Add support for
CLOCK_MONOTONIC and TIMER_ABSTIME.
(nanosleep): Rewrite in terms of clock_nanosleep.
(sleep): Ditto.
(usleep): Ditto.
* thread.cc: Mark clock_nanosleep in list of cancellation points.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d612 1
a612 1
  sigproc_printf ("returning sig %d", res);
@


1.99
log
@* cygtls.h (struct _local_storage): Add cw_timer member.
* cygtls.cc (_cygtls::init_thread): Initialize locals.cw_timer.
(_cygtls::fixup_after_fork): Ditto.
* tlsoffsets.h: Regenerate.
* ntdll.h (enum _TIMER_INFORMATION_CLASS): Define.
(struct _TIMER_BASIC_INFORMATION): Define.
(NtQueryTimer): Declare function.
* thread.h (cancelable_wait): Change timeout argument to
PLARGE_INTEGER and provide NULL default.
(fast_mutex::lock): Adjust accordingly.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER
and default to NULL.
* thread.cc (cancelable_wait): Change timeout argument to
PLARGE_INTEGER.  Initialize _cygtls.locals.cw_timer if needed.
Use NT waitable timers for handling timeout.  Return remaining time
to timeout argument if timeout was relative.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER.
Adjust to change in cancelable_wait.
(pthread_mutex::lock): Adjust to change in cancelable_wait.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(__pthread_cond_dowait): Change waitlength argument to PLARGE_INTEGER.
Adjust to changes in cancelable_wait and pthread_cond::wait.
(pthread_cond_timedwait): Adjust to change in __pthread_cond_dowait.
(pthread_cond_wait): Ditto.
(semaphore::_timedwait): Adjust to change in cancelable_wait.
(semaphore::_wait): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
* signal.cc (nanosleep): Ditto.
* wait.cc (wait4): Ditto. Fix copyright dates.
* times.cc (FACTOR, NSPERSEC): Move from here...
* hires.h (FACTOR, NSPERSEC): ...to here.
@
text
@d84 2
a85 1
nanosleep (const struct timespec *rqtp, struct timespec *rmtp)
d87 1
d92 13
a104 1
  if ((unsigned int) rqtp->tv_nsec > 999999999)
d106 6
a111 2
      set_errno (EINVAL);
      return -1;
d113 1
a117 1
  timeout.QuadPart *= -1LL;
d119 23
a141 1
  syscall_printf ("nanosleep (%ld.%09ld)", rqtp->tv_sec, rqtp->tv_nsec);
d147 1
a147 2
      set_errno (EINTR);
      res = -1;
d150 2
a151 1
  if (rmtp)
d157 3
a159 3
  syscall_printf ("%d = nanosleep (%ld.%09ld, %ld.%09.ld)", res, rqtp->tv_sec,
		  rqtp->tv_nsec, rmtp ? rmtp->tv_sec : 0,
		  rmtp ? rmtp->tv_nsec : 0);
d163 12
d181 1
a181 1
  if (nanosleep (&req, &rem))
d192 7
a198 2
  int res = nanosleep (&req, NULL);
  return res;
@


1.98
log
@pthread_sigmask: fix return value to match POSIX

* signal.cc (handle_sigprocmask): Return error rather than setting
errno, for pthread_sigmask.
(sigprocmask): Adjust caller.
@
text
@d95 5
a99 23
  unsigned int sec = rqtp->tv_sec;
  DWORD resolution = gtod.resolution ();
  bool done = false;
  DWORD req;
  DWORD rem;

  while (!done)
    {
      /* Divide user's input into transactions no larger than 49.7
	 days at a time.  */
      if (sec > HIRES_DELAY_MAX / 1000)
	{
	  req = ((HIRES_DELAY_MAX + resolution - 1)
		 / resolution * resolution);
	  sec -= HIRES_DELAY_MAX / 1000;
	}
      else
	{
	  req = ((sec * 1000 + (rqtp->tv_nsec + 999999) / 1000000
		  + resolution - 1) / resolution) * resolution;
	  sec = 0;
	  done = true;
	}
d101 1
a101 2
      DWORD end_time = gtod.dmsecs () + req;
      syscall_printf ("nanosleep (%ld)", req);
d103 6
a108 10
      int rc = cancelable_wait (signal_arrived, req);
      if ((rem = end_time - gtod.dmsecs ()) > HIRES_DELAY_MAX)
	rem = 0;
      if (rc == WAIT_OBJECT_0)
	{
	  _my_tls.call_signal_handler ();
	  set_errno (EINTR);
	  res = -1;
	  break;
	}
d113 2
a114 11
      rmtp->tv_sec = sec + rem / 1000;
      rmtp->tv_nsec = (rem % 1000) * 1000000;
      if (sec)
	{
	  rmtp->tv_nsec += rqtp->tv_nsec;
	  if (rmtp->tv_nsec >= 1000000000)
	    {
	      rmtp->tv_nsec -= 1000000000;
	      rmtp->tv_sec++;
	    }
	}
d117 3
a119 1
  syscall_printf ("%d = nanosleep (%ld, %ld)", res, req, rem);
@


1.97
log
@whitespace elimination
@
text
@d177 4
a180 1
  return handle_sigprocmask (how, set, oldset, _my_tls.sigmask);
d190 1
a190 2
      set_errno (EINVAL);
      return -1;
d195 1
a195 1
    return -1;
@


1.96
log
@* signal.cc (_pinfo::kill): Return success on kill(0) only if pid exists or is
in PID_EXITED state.  Report pid 0 when pid does not exist rather than pid -1.
Make debug output reflect actual function call.
* sigproc.cc (stopped_or_terminated): Set process state to reaped when we've
finished waiting for it.
* include/sys/cygwin.h (PID_REAPED): New enum.
@
text
@d104 1
a104 1
         days at a time.  */
d106 5
a110 5
        {
          req = ((HIRES_DELAY_MAX + resolution - 1)
                 / resolution * resolution);
          sec -= HIRES_DELAY_MAX / 1000;
        }
d112 6
a117 6
        {
          req = ((sec * 1000 + (rqtp->tv_nsec + 999999) / 1000000
                  + resolution - 1) / resolution) * resolution;
          sec = 0;
          done = true;
        }
d124 1
a124 1
        rem = 0;
d126 6
a131 6
        {
          _my_tls.call_signal_handler ();
          set_errno (EINTR);
          res = -1;
          break;
        }
d139 8
a146 8
        {
          rmtp->tv_nsec += rqtp->tv_nsec;
          if (rmtp->tv_nsec >= 1000000000)
            {
              rmtp->tv_nsec -= 1000000000;
              rmtp->tv_sec++;
            }
        }
@


1.95
log
@* signal.cc (_pinfo::kill): Avoid referencing 'pid' after ESRCH.
@
text
@d253 1
a253 1
  else if (si.si_signo == 0 && this)
d263 1
a263 1
      this_pid = -1;
d267 2
a268 2
  syscall_printf ("%d = _pinfo::kill (%d, %d), process_state %p", res, this_pid,
		  si.si_signo, this_process_state);
@


1.94
log
@	* Fix various copyrights.
@
text
@d226 1
d251 1
d256 1
d263 1
d267 1
a267 1
  syscall_printf ("%d = _pinfo::kill (%d, %d), process_state %p", res, pid,
@


1.93
log
@* * signal.cc (_pinfo::kill): Set this_process_state when process exists.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
@


1.92
log
@* signal.cc (_pinfo::kill): Return 0 when attempting to test for existence of
an existed process which has not yet been reaped.
@
text
@d232 1
@


1.91
log
@* include/sys/cygwin.h (PID_NOTCYGWIN): New enum.
* spawn.cc (spawn_guts): Set a flag when a process is not a cygwin process.
* fhandler_tty.cc (fhandler_tty_slave::init): Remove previous change.  Try a
different method to determine when we should become the process group owner.
* signal.cc (kill0): Remove archaic code which dealt with never-set flag.
@
text
@d224 3
d229 1
a229 4
  int res = 0;
  bool sendSIGCONT;

  if (!exists ())
d231 18
a248 2
      set_errno (ESRCH);
      return -1;
d250 1
a250 8

  if ((sendSIGCONT = (si.si_signo < 0)))
    si.si_signo = -si.si_signo;

  DWORD this_process_state = process_state;
  if (si.si_signo == 0)
    /* ok */;
  else if ((res = sig_send (this, si)))
d252 2
a253 2
      sigproc_printf ("%d = sig_send, %E ", res);
      res = -1;
d255 1
a255 1
  else if (sendSIGCONT)
d257 3
a259 4
      siginfo_t si2 = {0};
      si2.si_signo = SIGCONT;
      si2.si_code = SI_KERNEL;
      sig_send (this, si2);
@


1.90
log
@* signal.cc (nanosleep): Fix bug in previous patch.
@
text
@a276 6
  /* Silently ignore stop signals from a member of orphaned process group.
     FIXME: Why??? */
  if (ISSTATE (myself, PID_ORPHANED) &&
      (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN || si.si_signo == SIGTTOU))
    si.si_signo = 0;

@


1.89
log
@* signal.cc (nanosleep): Support 'infinite' sleep times.
(sleep): Avoid uninitialized memory.
@
text
@d105 1
a105 1
      if (sec > HIRES_DELAY_MAX)
d107 1
a107 1
          req = ((HIRES_DELAY_MAX * 1000 + resolution - 1)
d109 1
a109 1
          sec -= HIRES_DELAY_MAX;
@


1.88
log
@* signal.cc (abort): Only flush streams after signal handler.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
d90 1
a90 2
  if ((unsigned int) rqtp->tv_sec > (HIRES_DELAY_MAX / 1000 - 1)
      || (unsigned int) rqtp->tv_nsec > 999999999)
d95 1
d97 3
a99 4
  DWORD req = ((rqtp->tv_sec * 1000 + (rqtp->tv_nsec + 999999) / 1000000
		+ resolution - 1) / resolution) * resolution;
  DWORD end_time = gtod.dmsecs () + req;
  syscall_printf ("nanosleep (%ld)", req);
d101 1
a101 5
  int rc = cancelable_wait (signal_arrived, req);
  DWORD rem;
  if ((rem = end_time - gtod.dmsecs ()) > HIRES_DELAY_MAX)
    rem = 0;
  if (rc == WAIT_OBJECT_0)
d103 29
a131 3
      _my_tls.call_signal_handler ();
      set_errno (EINTR);
      res = -1;
d136 1
a136 1
      rmtp->tv_sec = rem / 1000;
d138 9
d159 3
a161 2
  nanosleep (&req, &rem);
  return rem.tv_sec + (rem.tv_nsec > 0);
d170 1
a170 1
  int res = nanosleep (&req, 0);
@


1.87
log
@Remove unneeded header files from source files throughout.
@
text
@a326 10
  /* Flush all streams as per SUSv2.
     From my reading of this document, this isn't strictly correct.
     The streams are supposed to be flushed prior to exit.  However,
     if there is I/O in any signal handler that will not necessarily
     be flushed.
     However this is the way FreeBSD does it, and it is much easier to
     do things this way, so... */
  if (_GLOBAL_REENT->__cleanup)
    _GLOBAL_REENT->__cleanup (_GLOBAL_REENT);

d335 4
@


1.86
log
@	* Fix copyright dates.
@
text
@a16 1
#include "cygerrno.h"
a19 2
#include "hires.h"
#include "security.h"
a24 1
#include "cygtls.h"
@


1.85
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
@


1.84
log
@* signal.cc (usleep): Use useconds_t for the type as per POSIX.
@
text
@d150 1
a150 1
  return handle_sigprocmask (how, set, oldset, myself->getsigmask ());
d345 1
a345 1
  set_signal_mask (sig_mask, myself->getsigmask ());
d488 1
a488 1
  return handle_sigsuspend (myself->getsigmask ());
@


1.83
log
@* signal.cc (handle_sigprocmask): Remove extraneous sig_dispatch_pending.
@
text
@d138 1
a138 1
usleep (unsigned int useconds)
@


1.82
log
@* signal.cc (signal): Set sa_mask to sig.
@
text
@a155 1
  sig_dispatch_pending ();
@


1.82.4.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d138 1
a138 1
usleep (useconds_t useconds)
d156 1
@


1.82.4.2
log
@	* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and
	use either main sigmask or current thread sigmask.
	(set_process_mask): Ditto.
	(sighold): Ditto.
	(sigrelse): Ditto.
	(sigset): Ditto.
	(set_process_mask_delta): Ditto.
	(_cygtls::call_signal_handler): Ditto.
	* fhandler_process.cc (format_process_status): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* pinfo.h (class pinfo): Ditto.
	* select.cc (pselect): Ditto.
	* signal.cc (sigprocmask): Ditto.
	(abort): Ditto.
	(sigpause): Ditto.
	(sigsend): Ditto.
	(wait_sig): Ditto.
	* sigproc.cc (sig_send): Ditto.
	(pending_signals::add): Ditto.
	(wait_sig): Ditto.
	* thread.h (pthread::parent_tls): New member.
	* thread.cc (pthread::pthread): Record parent_tls here.
	(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d150 1
a150 1
  return handle_sigprocmask (how, set, oldset, _my_tls.sigmask);
d345 1
a345 1
  set_signal_mask (sig_mask, _my_tls.sigmask);
d488 1
a488 1
  return handle_sigsuspend (_my_tls.sigmask);
@


1.81
log
@* signal.cc (abort): On second thought, just set incyg once.
@
text
@d77 1
a77 1
  gs.sa_mask = 0;
@


1.80
log
@* abort.cc (abort): Set incyg manually to help get a reliable gdb stack trace.
* cygwin.din (abort): Make NOSIGFE.
@
text
@d330 1
a347 1
  _my_tls.incyg++;
a348 1
  _my_tls.incyg--;
@


1.79
log
@* sigproc.cc (sigalloc): Don't set SA_RESTART here.
* signal.cc (_SA_NORESTART): New flag.
(sigaction_worker): New function, derived from sigaction.  Don't set internal
flags unless called internally.
(sigaction): Use sigaction_worker.
(signal): Honor new _SA_NORESTART flag.
(siginterrupt): Set _SA_NORESTART flag appropriately.  Use sigaction_worker to
set flags.
* include/cygwin/signal.h: Define _SA_INTERNAL_MASK here.
@
text
@d28 1
d347 1
d349 1
@


1.78
log
@* signal.cc (signal): Don't set SA_RESTART here.
(siginterrupt): White space.
* sigproc.cc (sigalloc): Set SA_RESTART here, on initialization.
@
text
@d31 5
d70 10
a79 3
  global_sigs[sig].sa_handler = func;
  global_sigs[sig].sa_mask = 0;
  global_sigs[sig].sa_flags &= ~SA_SIGINFO;
d351 2
a352 2
extern "C" int
sigaction (int sig, const struct sigaction *newact, struct sigaction *oldact)
d376 8
a383 5
      struct sigaction& na = global_sigs[sig];
      na = *newact;
      if (!(na.sa_flags & SA_NODEFER))
	na.sa_mask |= SIGTOMASK(sig);
      if (na.sa_handler == SIG_IGN)
d385 1
a385 1
      if (na.sa_handler == SIG_DFL && sig == SIGCHLD)
d387 1
a387 1
      set_sigcatchers (oa.sa_handler, na.sa_handler);
d391 1
a391 1
	  if (na.sa_flags & SA_NOCLDSTOP)
d397 4
a400 1
    *oldact = oa;
d406 6
d496 4
a499 1
    act.sa_flags &= ~SA_RESTART;
d501 5
a505 2
    act.sa_flags |= SA_RESTART;
  return sigaction (sig, &act, NULL);
@


1.77
log
@Always zero all elements of siginfo_t throughout.
* cygtls.h (_cygtls::thread_context): Declare new field.
(_cygtls::thread_id): Ditto.
(_cygtls::signal_exit): Move into this class.
(_cygtls::copy_context): Declare new function.
(_cygtls::signal_debugger): Ditto.
* cygtls.cc (_cygtls::init_thread): Fill out thread id field.
* exceptions.cc (exception): Change message when exception info is unknown.
Copy context to thread local storage.
(_cygtls::handle_exceptions): Avoid double test for fault_guarded.  Reflect
move of signal_exit to _cygtls class.
(sigpacket::process): Copy context to thread local storage.
(_cygtls::signal_exit): Move to _cygtls class.  Call signal_debugger to notify
debugger of exiting signal (WIP).  Call stackdump here (WIP).
(_cygtls::copy_context): Define new function.
(_cygtls::signal_debugger): Ditto.
* tlsoffsets.h: Regenerate.
* include/cygwin.h (_fpstate): New internal structure.
(ucontext): Declare new structure (WIP).
(__COPY_CONTEXT_SIZE): New define.
* exceptions.cc (_cygtls::interrupt_setup): Clear "threadkill" field when there
is no sigwaiting thread.
(setup_handler): Move event handling into interrupt_setup.
@
text
@d67 1
a67 4
  /* SA_RESTART is set to maintain BSD compatible signal behaviour by default.
     This is also compatible with the behaviour of signal(2) in Linux. */
  global_sigs[sig].sa_flags |= SA_RESTART;
  global_sigs[sig].sa_flags &= ~ SA_SIGINFO;
d470 1
a470 1
  sigaction(sig, NULL, &act);
@


1.76
log
@* cygtls.cc (_cygtls::handle_threadlist_exception): Make an error fatal.
* cygtls.h (sockaddr_in): Use header rather than defining our own structure.
* exceptions.cc (_cygtls::interrupt_setup): Use exact contents of sa_mask
rather than assuming tht current sig should be masked, too.
(_cygtls::call_signal_handler): Use more aggressive locking.
* gendef (_sigbe): Wait until later before releasing incyg.
(_sigreturn): Remove more arguments to accommodate quasi-sa_sigaction support.
(_sigdelayed): Push arguments for sa_sigaction.  More work needed here.
* signal.cc (sigaction): Implement SA_NODEFER.
* tlsoffsets.h: Regenerate.

* sigproc.cc (wait_sig): Use default buffer size of Windows 9x complains.
* pinfo.cc (_onreturn::dummy_handle): Remove.
(_onreturn::h): Make this a pointer.
(_onreturn::~_onreturn): Detect whether pointer is NULL rather than value is
NULL.
(_onreturn::_onreturn): Set h to NULL initially.
(_onreturn::no_close_p_handle): Set h to NULL.
(winpids::add): Initialize onreturn with value from p.hProcess immediately.
@
text
@d212 1
a212 1
      siginfo_t si2;
a214 1
      si2.si_pid = si2.si_uid = si2.si_errno = 0;
d253 1
a253 1
  siginfo_t si;
a255 1
  si.si_pid = si.si_uid = si.si_errno = 0;
d262 1
a262 1
  siginfo_t si;
a264 1
  si.si_pid = si.si_uid = si.si_errno = 0;
d538 1
a538 1
  siginfo_t si;
a546 1
  si.si_pid = si.si_uid = si.si_errno = 0;
@


1.75
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d260 1
d360 2
a361 2
  if (newact)
    sigproc_printf ("signal %d, newact %p (handler %p), oa %p", sig, newact, newact->sa_handler, oa, oa.sa_handler);
a362 3
    sigproc_printf ("signal %d, newact %p, oa %p", sig, newact, oa, oa.sa_handler);

  if (newact)
d364 1
d370 5
a374 2
      global_sigs[sig] = *newact;
      if (newact->sa_handler == SIG_IGN)
d376 1
a376 1
      if (newact->sa_handler == SIG_DFL && sig == SIGCHLD)
d378 1
a378 1
      set_sigcatchers (oa.sa_handler, newact->sa_handler);
d382 1
a382 1
	  if (newact->sa_flags & SA_NOCLDSTOP)
@


1.74
log
@* cygheap.h (init_cygheap::_gtod): New hires_ms element.
* hires.h (hires_ms::minperiod): Remove static designation.
(hires::began_period): New field.
* signal.cc: Include headers required for cygheap.h now that gtod lives in the
cygheap.
* timer.c: Ditto.
* times.cc (gtod): Delete variable.
(gtod::minperiod): Ditto.
(gtod::began_period): Define.
(hires_ms::prime): Add more debugging output.  Call timeBeginPeriod only when
!began_period.
@
text
@d292 2
a293 2
      sigproc_printf ("killing pid %d, pgrp %d, p->ctty %d, myself->ctty %d",
		      p->pid, p->pgid, p->ctty, myself->ctty);
@


1.73
log
@* exceptions.cc (handle_exceptions): Just si_code to SI_KERNEL first and let it
be overridden.
* exceptions.cc (_cygtls::call_signal_handler): Call signal handler with extra
siginfo_t * and void * parameters when SA_SIGINFO flag is set.
* signal.cc (signal): Clear SA_SIGINFO flag.
(sigqueue): Fix incorrect setting of si_code.
* sigproc.cc (signal_fixup_after_exec): Clear SA_SIGINFO flag when setting
handler to SIG_DFL.
@
text
@d24 4
@


1.72
log
@* sigproc.h (set_signal_mask): Remove default on second parameter and make pass
by reference.
* signal.cc (abort): Accommodate change to set_signal_mask.
* select.cc (pselect): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
(ctrl_c_handler): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Return ENMFILE if
__handle is not set.  Set __handle to NULL when out of files.
(fhandler_disk_file::rewinddir): Don't close handle if it's NULL.
(fhandler_disk_file::closedir): Ditto.
@
text
@d66 1
d528 4
d543 1
a543 1
  si.si_code = SI_USER;
@


1.71
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d332 1
a332 1
  set_signal_mask (sig_mask);
@


1.70
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d97 1
a97 1
      (void) _my_tls.call_signal_handler ();
d175 1
a175 1
      (void) set_signal_mask (newmask, opmask);
d211 1
a211 1
      (void) sig_send (this, si2);
d335 1
a335 1
  (void) _my_tls.call_signal_handler (); /* Call any signal handler */
d469 1
a469 1
  (void) sigaction(sig, NULL, &act);
@


1.69
log
@Change pthread::cancelable_wait to just cancelable_wait, throughout.
* thread.h (cw_sig_wait): New enum.
(fast_mutex::lock): Use cancelable_wait with resumable signal.
(cancelable_wait): Change fourth argument to cw_sig_wait enum.
* thread.cc (cancelable_wait): Ditto.  Loop on signal detection if fourth
argument == cw_sig_resume.
@
text
@d150 4
d155 1
a155 5
    {
      if (check_null_invalid_struct_errno (oldset))
	return -1;
      *oldset = opmask;
    }
a158 2
      if (check_invalid_read_struct_errno (set))
	return -1;
@


1.68
log
@* times.cc (hires_ms::usecs): Compare the difference.
* hires.h: Add parentheses to HIRES_DELAY_MAX.
@
text
@d91 1
a91 1
  int rc = pthread::cancelable_wait (signal_arrived, req);
@


1.67
log
@* timer.cc (nanosleep): Treat tv_sec < 0 as invalid.
* include/search.h: Make declarations consistent with newlib.
@
text
@a79 1
      || rqtp->tv_sec < 0
@


1.66
log
@	* signal.cc (sigprocmask): Rename first parameter to "how".
	(handle_sigprocmask): Ditto.  Check "how" for being a valid "how" value.
	Fix call order in case of wrong "how" value.
@
text
@d80 1
@


1.65
log
@* debug.cc (delete_handle): Report on handle value in debugging output.
* pinfo.h (_pinfo::exists): Declare "new" function.
(_pinfo::kill): Ditto.
* fhandler_termios.cc (tty_min::kill_pgrp): Use _pinfo::exists rather than
proc_exists.
* pinfo.cc (pinfo::init): Ditto.  Don't do a low_priority_sleep(0) when looping
to find exec'ed procinfo.
(pinfo::release): Be more careful about unmapping and closing.
* signal.cc (_pinfo::kill): Rename from kill_worker.  Accommodate entry into
_pinfo class.
(kill0): Use _pinfo::kill rather than kill_worker.
(kill_pgrp): Ditto.  Use _pinfo::exists rather than proc_exists.
* sigproc.cc (_pinfo::exists): Rename from proc_exists.
(pid_exists): Use _pinfo::exists rather than proc_exists.
(remove_proc): Ditto.
* sigproc.h (proc_exists): Delete declaration.
@
text
@d133 1
a133 1
sigprocmask (int sig, const sigset_t *set, sigset_t *oldset)
d135 1
a135 1
  return handle_sigprocmask (sig, set, oldset, myself->getsigmask ());
d139 1
a139 1
handle_sigprocmask (int sig, const sigset_t *set, sigset_t *oldset, sigset_t& opmask)
d142 2
a143 2
  /* check that sig is in right range */
  if (sig < 0 || sig >= NSIG)
d145 1
a146 1
      syscall_printf ("signal %d out of range", sig);
d162 1
a162 1
      switch (sig)
a175 3
	default:
	  set_errno (EINVAL);
	  return -1;
@


1.64
log
@	* signal.cc: Fix copyright date.
@
text
@d185 2
a186 2
static int
kill_worker (pid_t pid, siginfo_t& si)
a190 1
  pinfo dest (pid);
d193 1
a193 1
  if (!dest)
d202 1
a202 1
  DWORD process_state = dest->process_state;
d204 2
a205 6
    {
      res = proc_exists (dest) ? 0 : -1;
      if (res < 0)
	set_errno (ESRCH);
    }
  else if ((res = sig_send (dest, si)))
d216 1
a216 1
      (void) sig_send (dest, si2);
d219 2
a220 2
  syscall_printf ("%d = kill_worker (%d, %d), process_state %p", res, pid,
		  si.si_signo, process_state);
d248 1
a248 1
  return (pid > 0) ? kill_worker (pid, si) : kill_pgrp (-pid, si);
d284 1
a284 1
      if (!proc_exists (p))
d296 1
a296 1
      else if (kill_worker (p->pid, si))
d301 1
a301 1
  if (killself && !exit_state && kill_worker (myself->pid, si))
@


1.63
log
@	* signal.cc (abort): Call _GLOBAL_REENT's __cleanup.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.62
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d334 2
a335 2
  if (_REENT->__cleanup)
    _REENT->__cleanup (_REENT);
@


1.61
log
@* path.cc (normalize_posix_path): Reorganize to short circuit to DOS path
handling whenever a '\' is detected.
* signal.cc (sigaction): Make strace output more informative.
* sigproc.cc (pending_signals::add): Just index directly into signal array
rather than treating the array as a heap.
(pending_signals::del): Ditto.
(wait_sig): Don't send signal if we already have a similar signal queued.
* sigproc.h (call_signal_handler_now): Remove obsolete declaration.
@
text
@d345 1
a345 1
  do_exit (1);	/* signal handler didn't exit.  Goodbye. */
@


1.61.4.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@d345 1
a345 1
  do_exit (SIGABRT);	/* signal handler didn't exit.  Goodbye. */
@


1.60
log
@* exceptions.cc (setup_handler): Signal event for any sigwaitinfo if it exists
to force signal to be handled.  Zero event here to prevent races.
* signal.cc (sigwaitinfo): Use local handle value for everything since signal
thread could zero event element at any time.  Detect when awaking due to thread
not in mask and set return value and errno accordingly.  Don't set signal
number to zero unless we've recognized the signal.
* sigproc.cc (sigq): Rename from sigqueue throughout.
* thread.cc (pthread::join): Handle signals received while waiting for thread
to terminate.
* cygwin.din: Export sighold, sigqueue.
* exceptions.cc (sighold): Define new function.
* signal.cc (handle_sigprocmask): Set correct errno for invalid signal.
Simplify debugging output.
(sigqueue): Define new function.
* include/cygwin/signal.h (sighold): Declare new function.
(sigqueue): Ditto.
* include/cygwin/version.h: Bump API minor version number.
* include/limits.h (TIMER_MAX): Define.
(_POSIX_TIMER_MAX): Ditto.
@
text
@a351 1
  sigproc_printf ("signal %d, newact %p, oldact %p", sig, newact, oldact);
d356 1
d362 5
@


1.59
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d144 2
a145 2
      set_errno (ESRCH);
      syscall_printf ("SIG_ERR = sigprocmask signal %d out of range", sig);
d496 1
a496 1
  if (!_my_tls.event)
d503 1
d506 1
a506 1
  switch (WaitForSingleObject (_my_tls.event, INFINITE))
d509 12
a520 4
      res = _my_tls.infodata.si_signo;
      sigproc_printf ("returning sig %d", res);
      if (info)
	*info = _my_tls.infodata;
a525 2
  _my_tls.event = NULL;
  InterlockedExchange ((LONG *) &_my_tls.sig, (LONG) 0);
d527 1
a527 1
  sig_dispatch_pending ();
d529 17
@


1.58
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d96 1
a96 1
      (void) call_signal_handler_now ();
d305 1
a305 1
  if (killself && kill_worker (myself->pid, si))
d344 1
a344 1
  (void) call_signal_handler_now (); /* Call any signal handler */
@


1.57
log
@* signal.cc (sigaction): Fix if-statement typo.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.56
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d379 1
a379 1
	  if (newact->sa_flags & SA_NOCLDSTOP);
@


1.55
log
@* pinfo.h (_pinfo::getsig): Remove obsolete function, here and throughout.
* exceptions.cc: Ditto.
* fhandler_termios.cc: Ditto.
* signal.cc: Ditto.
* sigproc.cc: Ditto.
* Makefile.in: Revert previous change which made a cygwin.din newer than a
version.h a warning rather than an error.
@
text
@d185 1
a185 1
kill_worker (pid_t pid, int sig)
d191 1
a191 1
  BOOL sendSIGCONT;
d199 2
a200 2
  if ((sendSIGCONT = (sig < 0)))
    sig = -sig;
d203 1
a203 1
  if (sig == 0)
d209 1
a209 1
  else if ((res = sig_send (dest, sig)))
d215 7
a221 1
    (void) sig_send (dest, SIGCONT);
d223 2
a224 1
  syscall_printf ("%d = kill_worker (%d, %d), process_state %p", res, pid, sig, process_state);
d234 2
a235 2
int
kill (pid_t pid, int sig)
d237 1
a237 1
  syscall_printf ("kill (%d, %d)", pid, sig);
d239 1
a239 1
  if (sig < 0 || sig >= NSIG)
d242 1
a242 1
      syscall_printf ("signal %d out of range", sig);
d249 2
a250 2
      (sig == SIGTSTP || sig == SIGTTIN || sig == SIGTTOU))
    sig = 0;
d252 1
a252 1
  return (pid > 0) ? kill_worker (pid, sig) : kill_pgrp (-pid, sig);
d256 20
a275 1
kill_pgrp (pid_t pid, int sig)
d281 1
a281 1
  sigproc_printf ("pid %d, signal %d", pid, sig);
d294 1
a294 1
	  (sig < 0 && NOTSTATE (p, PID_STOPPED)))
d300 1
a300 1
      else if (kill_worker (p->pid, sig))
d305 1
a305 1
  if (killself && kill_worker (myself->pid, sig))
d313 1
a313 1
  syscall_printf ("%d = kill (%d, %d)", res, pid, sig);
d481 8
d491 1
a491 1
sigwait (const sigset_t *set, int *sig)
d494 2
a495 1
  _my_tls.event = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d504 1
d508 4
a511 3
      CloseHandle (_my_tls.event);
      _my_tls.event = NULL;
      *sig = InterlockedExchange ((LONG *) &_my_tls.sig, (LONG) 0);
d515 1
a515 1
      return -1;
d517 5
a521 1
  return 0;
@


1.55.6.1
log
@* signal.cc (sigaction): Fix if-statement typo.
@
text
@d353 1
a353 1
	  if (newact->sa_flags & SA_NOCLDSTOP)
@


1.55.2.1
log
@* gentls_offsets: Reinstate unlink of temp files.
@
text
@d185 1
a185 1
kill_worker (pid_t pid, siginfo_t& si)
d191 1
a191 1
  bool sendSIGCONT;
d199 2
a200 2
  if ((sendSIGCONT = (si.si_signo < 0)))
    si.si_signo = -si.si_signo;
d203 1
a203 1
  if (si.si_signo == 0)
d209 1
a209 1
  else if ((res = sig_send (dest, si)))
d215 1
a215 7
    {
      siginfo_t si2;
      si2.si_signo = SIGCONT;
      si2.si_code = SI_KERNEL;
      si2.si_pid = si2.si_uid = si2.si_errno = 0;
      (void) sig_send (dest, si2);
    }
d217 1
a217 2
  syscall_printf ("%d = kill_worker (%d, %d), process_state %p", res, pid,
		  si.si_signo, process_state);
d227 2
a228 2
static int
kill0 (pid_t pid, siginfo_t& si)
d230 1
a230 1
  syscall_printf ("kill (%d, %d)", pid, si.si_signo);
d232 1
a232 1
  if (si.si_signo < 0 || si.si_signo >= NSIG)
d235 1
a235 1
      syscall_printf ("signal %d out of range", si.si_signo);
d242 2
a243 5
      (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN || si.si_signo == SIGTTOU))
    si.si_signo = 0;

  return (pid > 0) ? kill_worker (pid, si) : kill_pgrp (-pid, si);
}
d245 1
a245 17
int
killsys (pid_t pid, int sig)
{
  siginfo_t si;
  si.si_signo = sig;
  si.si_code = SI_KERNEL;
  si.si_pid = si.si_uid = si.si_errno = 0;
  return kill0 (pid, si);
}
int
kill (pid_t pid, int sig)
{
  siginfo_t si;
  si.si_signo = sig;
  si.si_code = SI_USER;
  si.si_pid = si.si_uid = si.si_errno = 0;
  return kill0 (pid, si);
d249 1
a249 1
kill_pgrp (pid_t pid, siginfo_t& si)
d255 1
a255 1
  sigproc_printf ("pid %d, signal %d", pid, si.si_signo);
d268 1
a268 1
	  (si.si_signo < 0 && NOTSTATE (p, PID_STOPPED)))
d274 1
a274 1
      else if (kill_worker (p->pid, si))
d279 1
a279 1
  if (killself && kill_worker (myself->pid, si))
d287 1
a287 1
  syscall_printf ("%d = kill (%d, %d)", res, pid, si.si_signo);
@


1.55.2.2
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@d486 1
a486 2
  HANDLE h;
  h = _my_tls.event = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
a494 1
  int res;
d498 2
a500 1
      res = 0;
d504 1
a504 1
      res = -1;
d506 1
a506 5
  _my_tls.event = NULL;
  _my_tls.sig = 0;
  CloseHandle (h);
  sig_dispatch_pending ();
  return res;
@


1.55.2.3
log
@* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
@
text
@a480 9
extern "C" int
sigwait (const sigset_t *set, int *sig_ptr)
{
  siginfo_t si;
  int pid = sigwaitinfo (set, NULL);
  if (pid > 0)
    *sig_ptr = pid;
  return pid > 0 ? 0 : -1;
}
d483 1
a483 1
sigwaitinfo (const sigset_t *set, siginfo_t *info)
d500 2
a501 3
      res = _my_tls.infodata.si_pid;
      if (info)
	*info = _my_tls.infodata;
d508 1
a508 1
  InterlockedExchange ((LONG *) &_my_tls.sig, (LONG) 0);
@


1.55.2.4
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
@
text
@d484 5
a488 4
  int sig = sigwaitinfo (set, NULL);
  if (sig > 0)
    *sig_ptr = sig;
  return sig > 0 ? 0 : -1;
d509 1
a509 2
      res = _my_tls.infodata.si_signo;
      sigproc_printf ("returning sig %d", res);
@


1.54
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d59 3
a61 3
  prev = myself->getsig (sig).sa_handler;
  myself->getsig (sig).sa_handler = func;
  myself->getsig (sig).sa_mask = 0;
d64 1
a64 1
  myself->getsig (sig).sa_flags |= SA_RESTART;
d335 1
a335 1
  struct sigaction oa = myself->getsig (sig);
d344 1
a344 1
      myself->getsig (sig) = *newact;
@


1.53
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* pinfo.cc (pinfo::init): Do not give FILE_MAP_WRITE access to Everybody.
	* exceptions.cc (sig_handle_tty_stop): Do not create pinfo parent with
	PID_MAP_WRITE.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Ditto for pinfo p.
	* signal.cc (kill_worker): Ditto for pinfo dest.
@
text
@d18 1
a19 1
#include "pinfo.h"
d21 2
a75 1
  sigframe thisframe (mainthread);
d96 1
a96 1
      (void) thisframe.call_signal_handler ();
d134 6
d144 1
a144 1
      set_errno (EINVAL);
d150 6
a155 1
    *oldset = myself->getsigmask ();
d158 3
a160 1
      sigset_t newmask = myself->getsigmask ();
d179 1
a179 1
      (void) set_process_mask (newmask);
d202 1
a202 4
#if 0
  if (dest == myself && !sendSIGCONT)
    dest = myself_nowait_nonmain;
#endif
d217 1
a217 1
  syscall_printf ("%d = kill_worker (%d, %d)", res, pid, sig);
a229 1
  sigframe thisframe (mainthread);
a253 1
  sigframe thisframe (mainthread);
a300 1
  sigframe thisframe (mainthread);
d315 1
a315 1
  set_process_mask (sig_mask);
d318 1
a318 1
  (void) thisframe.call_signal_handler (); /* Call any signal handler */
d447 1
a447 1
  (void)sigaction(sig, NULL, &act);
d452 1
a452 1
  return sigaction(sig, &act, NULL);
d455 27
@


1.52
log
@* include/tzfile.h: Add some missing entries.
@
text
@d176 1
a176 1
  pinfo dest (pid, PID_MAP_RW);
@


1.51
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d85 1
a85 1
		+ resolution - 1) / resolution ) * resolution;
@


1.50
log
@* pinfo.h (winpids::pid_access): New element.
(winpids::winpids): Rejigger to set pinfo_access.
* pinfo.cc (winpids::add): Try to open shared memory region with supplied
pinfo_access first, then default to readonly.
* fhandler_termios.cc (tty_min::kill_pgrp): When getting list of pids to work
with, suggest opening with PID_MAP_RW.
* signal.cc (kill_pgrp): Ditto.
* sigproc.cc (sig_send): Perform a write check on todo prior to attempting to
increment it.  Return EACCES if we can't write to it.
@
text
@a184 2
  dest->setthread2signal (NULL);

@


1.49
log
@* include/sys/cygwin.h: Rename PID_UNUSED to PID_MAP_RW.
* pinfo.cc (pinfo_init): Initialize myself->gid.
(pinfo::init): Create the "access" variable, set it appropriately and use it to
specify the requested access.
* exceptions.cc (sig_handle_tty_stop): Add PID_MAP_RW in pinfo parent.
* signal.cc (kill_worker): Ditto for pinfo dest.
* syscalls.cc (setpgid): Ditto for pinfo p.
@
text
@d250 1
a250 1
  winpids pids;
@


1.48
log
@* signal.cc (nanosleep): Improve test for valid values.  Round delay up to
resolution.  Fix test for negative remainder.  Use timeGetTime through gtod.
(sleep): Round up return value.  Christopher Faylor <cgf@@redhat.com>
* hires.h (HIRES_DELAY_MAX): Define.
(hires_ms::minperiod): Declare static.
(hires_ms::resolution): New.
(hires_ms::dmsecs): New.
(hires_ms::prime): Return UINT.
(gtod): Declare.
* times.cc (hires_ms::prime): Always calculate minperiod and set it to 1 in
case of failure.  Return minperiod.
(hires_ms::resolution): Define.
(hires_ms::~hires_ms): Delete.
(hires_ms::usecs): Check minperiod to prime.
(gtod) Define as global.
@
text
@d176 1
a176 1
  pinfo dest (pid);
@


1.47
log
@* cygheap.cc (cygheap_init): Allocate space for sigaction array in cygheap.
* cygheap.h (cygheap_types): Add HEAP_SIGS.
* exceptions.cc (signal_fixup_after_exec): Remove from this file.
* pinfo.h (pinfo::getsig): Just return global_sigs array.
(pinfo::sigs): Delete.
* sigproc.cc (signal_fixup_after_exec): Move it here.
(global_sigs): New global array, moved from pinfo structure.
(sigalloc): New function.  Allocate global sigaction array here.
(proc_subproc): Remove copysigs call.  It's automatic now.
* include/sys/cygwin.h (PID_NOCLDSTOP): New value.
* signal.cc (sigaction): Set myself->PID_NODCLDSTOP when appropriate.
* sigproc.h (sigalloc): Declare.
* fnmatch.c (fnmatch): Use C90 parameters.
(rangematch): Ditto.
* fhandler.cc (fhandler_base::raw_read): Use right coercion to avoid a compiler
warning.
@
text
@d20 1
d77 2
a78 1
  if (rqtp->tv_sec < 0 || rqtp->tv_nsec < 0 || rqtp->tv_nsec > 999999999)
d83 4
a86 4

  DWORD req = rqtp->tv_sec * 1000 + (rqtp->tv_nsec + 500000) / 1000000;
  DWORD start_time = GetTickCount ();
  DWORD end_time = start_time + req;
d90 3
a92 2
  DWORD now = GetTickCount ();
  DWORD rem = (rc == WAIT_TIMEOUT || now >= end_time) ? 0 : end_time - now;
d117 1
a117 1
  return rem.tv_sec + (rem.tv_nsec + 500000000) / 1000000000;
@


1.46
log
@* signal.cc (sigpending): Move.
* sigproc.cc (sigpending): To here.
(getlocal_sigtodo): Return process-local signal array.
(sigpending): Accommodate new process-local signal array.
(sig_send): Ditto.
(sig_set_pending): Ditto.
(wait_sig): Ditto.
@
text
@d341 6
@


1.45
log
@Throughout, eliminate argument to sig_dispatch_pending.
* exceptions.cc (setup_handler): Move non-interruptible condition handling
(back) to wait_sig (as suggested by Pierre Humblet).
(set_process_mask): Don't worry about calling sig_dispatch_pending from
sigthread since it is detected in the function anyway.
(sig_handle): Eliminate thisproc arg.  Don't call sig_dispatch_pending on
SIGCONT since that should happen automatically.
* sigproc.cc (sig_dispatch_pending): Eliminate justwake argument.  Just return
when called from sigthread.
(wait_sig): Change some variables to bool.  Change inner while to an if.  Move
uninterruptible signal handling here.
(sigproc_terminate): Don't call sig_dispatch_pending.  Just increment semaphore
on exit.
* speclib: Use slightly different (but still flawed) method for determining
symbols to extract from libraries.
@
text
@a410 11
sigpending (sigset_t *set)
{
  unsigned bit;
  *set = 0;
  for (int sig = 1; sig < NSIG; sig++)
    if (*myself->getsigtodo (sig) && myself->getsigmask () & (bit = SIGTOMASK (sig)))
      *set |= bit;
  return 0;
}

extern "C" int
@


1.44
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d45 1
a45 1
  sig_dispatch_pending (0);
d72 1
a72 1
  sig_dispatch_pending (0);
d130 1
a130 1
  sig_dispatch_pending (0);
d170 1
a170 1
  sig_dispatch_pending (0);
d290 1
a290 1
  sig_dispatch_pending (0);
d316 1
a316 1
  sig_dispatch_pending (0);
@


1.43
log
@
* signal.cc (nanosleep): Do not wait twice for signal arrival.
@
text
@a14 1
#include <errno.h>
d299 2
a300 2
  if (_reent_clib ()->__cleanup)
    _reent_clib ()->__cleanup (_reent_clib ());
@


1.42
log
@	* cygwin.din: Export nanosleep().
	* signal.cc (nanosleep): New function.
	(sleep): Move old functionality to nanosleep().  Call nanosleep().
	(usleep): Remove old functionality.  Call nanosleep().
	* include/cygwin/version.h: Bump API minor number.
@
text
@d91 1
a91 1
  if (WaitForSingleObject (signal_arrived, 0) == WAIT_OBJECT_0)
@


1.41
log
@	* autoload.cc: Fix copyright date.
	* fhandler_dsp.cc: Ditto.
	* mmap.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* signal.cc: Ditto.
	* syscalls.cc: Ditto.
	* uname.cc: Ditto.
	* wait.cc: Ditto.
@
text
@d69 2
a70 2
extern "C" unsigned int
sleep (unsigned int seconds)
d72 1
a72 1
  int rc;
a74 2
  DWORD ms, start_time, end_time;

d77 10
a86 4
  ms = seconds * 1000;
  start_time = GetTickCount ();
  end_time = start_time + (seconds * 1000);
  syscall_printf ("sleep (%d)", seconds);
d88 1
a88 1
  rc = pthread::cancelable_wait (signal_arrived, ms);
d90 1
a90 4
  if (rc == WAIT_TIMEOUT || now >= end_time)
    ms = 0;
  else
    ms = end_time - now;
d92 11
a102 1
    (void) thisframe.call_signal_handler ();
d104 3
a106 2
  DWORD res = (ms + 500) / 1000;
  syscall_printf ("%d = sleep (%d)", res, seconds);
d108 8
a115 1
  return res;
d121 5
a125 7
  pthread_testcancel ();

  sig_dispatch_pending (0);
  syscall_printf ("usleep (%d)", useconds);
  pthread::cancelable_wait (signal_arrived, (useconds + 500) / 1000);
  syscall_printf ("0 = usleep (%d)", useconds);
  return 0;
@


1.41.2.1
log
@trunk merge
@
text
@d69 2
a70 2
extern "C" int
nanosleep (const struct timespec *rqtp, struct timespec *rmtp)
d72 1
a72 1
  int res = 0;
d75 2
d79 4
a82 10
  if (rqtp->tv_sec < 0 || rqtp->tv_nsec < 0 || rqtp->tv_nsec > 999999999)
    {
      set_errno (EINVAL);
      return -1;
    }

  DWORD req = rqtp->tv_sec * 1000 + (rqtp->tv_nsec + 500000) / 1000000;
  DWORD start_time = GetTickCount ();
  DWORD end_time = start_time + req;
  syscall_printf ("nanosleep (%ld)", req);
d84 1
a84 1
  int rc = pthread::cancelable_wait (signal_arrived, req);
d86 4
a89 1
  DWORD rem = (rc == WAIT_TIMEOUT || now >= end_time) ? 0 : end_time - now;
d91 4
a94 11
    {
      (void) thisframe.call_signal_handler ();
      set_errno (EINTR);
      res = -1;
    }

  if (rmtp)
    {
      rmtp->tv_sec = rem / 1000;
      rmtp->tv_nsec = (rem % 1000) * 1000000;
    }
a95 1
  syscall_printf ("%d = nanosleep (%ld, %ld)", res, req, rem);
d100 1
a100 1
sleep (unsigned int seconds)
d102 1
a102 6
  struct timespec req, rem;
  req.tv_sec = seconds;
  req.tv_nsec = 0;
  nanosleep (&req, &rem);
  return rem.tv_sec + (rem.tv_nsec + 500000000) / 1000000000;
}
d104 5
a108 8
extern "C" unsigned int
usleep (unsigned int useconds)
{
  struct timespec req;
  req.tv_sec = useconds / 1000000;
  req.tv_nsec = (useconds % 1000000) * 1000;
  int res = nanosleep (&req, 0);
  return res;
@


1.41.2.2
log
@merge from trunk
@
text
@d91 1
a91 1
  if (rc == WAIT_OBJECT_0)
@


1.41.2.3
log
@merge from trunk
@
text
@d15 1
d300 2
a301 2
  if (_REENT->__cleanup)
    _REENT->__cleanup (_REENT);
@


1.41.2.4
log
@merge from trunk
@
text
@d45 1
a45 1
  sig_dispatch_pending ();
d72 1
a72 1
  sig_dispatch_pending ();
d130 1
a130 1
  sig_dispatch_pending ();
d170 1
a170 1
  sig_dispatch_pending ();
d290 1
a290 1
  sig_dispatch_pending ();
d316 1
a316 1
  sig_dispatch_pending ();
d407 11
@


1.41.2.5
log
@merge from trunk
@
text
@a340 6
      if (sig == SIGCHLD)
	{
	  myself->process_state &= ~PID_NOCLDSTOP;
	  if (newact->sa_flags & SA_NOCLDSTOP);
	    myself->process_state |= PID_NOCLDSTOP;
	}
@


1.41.2.6
log
@merge from trunk
@
text
@a19 1
#include "hires.h"
d76 1
a76 2
  if ((unsigned int) rqtp->tv_sec > (HIRES_DELAY_MAX / 1000 - 1)
      || (unsigned int) rqtp->tv_nsec > 999999999)
d81 4
a84 4
  DWORD resolution = gtod.resolution ();
  DWORD req = ((rqtp->tv_sec * 1000 + (rqtp->tv_nsec + 999999) / 1000000
		+ resolution - 1) / resolution ) * resolution;
  DWORD end_time = gtod.dmsecs () + req;
d88 2
a89 3
  DWORD rem;
  if ((rem = end_time - gtod.dmsecs ()) > HIRES_DELAY_MAX)
    rem = 0;
d114 1
a114 1
  return rem.tv_sec + (rem.tv_nsec > 0);
d181 2
@


1.41.2.7
log
@merge from trunk
@
text
@d176 1
a176 1
  pinfo dest (pid, PID_MAP_RW);
@


1.40
log
@Apply sleep_cancel patch
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.39
log
@* exceptions.cc (handle_sigsuspend): Force pending signal delivery before
waiting for signals to happen.
* signal.cc (sleep): Force pending signal delivery before sleeping.
(usleep): Ditto.
(signal): Force pending signal delivery before manipulating signal stuff.
(sigprocmask): Ditto.
(kill_worker): Ditto.
(abort): Ditto.
(sigaction): Ditto.
* syscalls.cc (readv): Force pending signal delivery before I/O.
(writev): Ditto.
(open): Ditto.
* net.cc: Ditto, throughout.
* sigproc.cc (sig_dispatch_pending): Deliver any pending signals prior to
returning.
* tty.cc (tty::make_pipes): Increase pipe buffer size.
@
text
@d77 2
d84 1
a84 1
  rc = WaitForSingleObject (signal_arrived, ms);
d102 2
d106 1
a106 1
  WaitForSingleObject (signal_arrived, (useconds + 500) / 1000);
@


1.38
log
@* exceptions.cc (sigthread::get_winapi_lock): Just do standard 'give up
timeslice' wait.
(setup_handler): Revamp YA to attempt to deliver signal multiple times on
failure rather than punting to wait_sig.
* miscfuncs.cc (low_priority_sleep): Accept INFINITE sleep to mean "don't reset
the priority after setting it to idle".  Return previous priority.
* winsup.h (SLEEP_0_STAY_LOW): Define.
(low_priority_sleep): Return an int.
* sigproc.h: Define WAIT_SIG_PRIORITY here.
* sigproc.cc: Remove WAIT_SIG_PRIORITY definition.
@
text
@d46 1
d73 1
d100 1
d110 1
d150 2
d270 1
d296 1
@


1.37
log
@* include/cygwin/version.h: Bump API_MINOR to accommodate below changes.
* cygwin.din (siginterrupt): New export.
* signal.cc (siginterrupt): New.
@
text
@d60 1
a60 1
     This is also compatible to the behaviour of signal(2) in Linux. */
@


1.36
log
@Rename _kill() to kill() throughout.  Rename _raise() to raise() throughout.
Rename _pid() to pid() throughout.
* Makefile.in: Compile some objects with -fomit-frame-pointer.
* cygwin.din: Reverse aliasing for _kill.
* syscalls.cc (_getpid_r): New function, implemented for newlib compatibility.
* shared.cc (open_shared): Remove reserving of memory since previous change
eliminate the need for this hack.
@
text
@d410 13
@


1.35
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d184 1
a184 1
_raise (int sig)
d186 1
a186 1
  return _kill (myself->pid, sig);
a188 1
/* This is called _kill because the real kill is in newlib.  */
d190 1
a190 1
_kill (pid_t pid, int sig)
d258 1
a258 1
  return _kill (-pgrp, sig);
d281 1
a281 1
  _raise (SIGABRT);
@


1.34
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d205 1
a205 1
  if (ISSTATE(myself, PID_ORPHANED) &&
d233 1
a233 1
	  (sig < 0 && NOTSTATE(p, PID_STOPPED)))
@


1.33
log
@Add copyright stuff
@
text
@a18 1
#include "sync.h"
@


1.32
log
@* exceptions.cc (sig_handle): Accept a second argument indicating whether the
signal came from this process or not.
* sigproc.h: Reflect sig_handle arg change.
* signal.cc (kill_pgrp): Add sigframe info.
(abort): New function.  Eliminates newlib function of same name.
* sigproc.cc (wait_sig): Pass "signal from this process" value as arg 2.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.31
log
@	* select.cc: Set errno using set_sig_errno() throughout.
	* signal.cc (signal): Always set SA_RESTART flag.
	* syscalls.cc (_read): Revert previous patch.
@
text
@d16 1
d194 1
d219 1
d261 25
@


1.30
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d59 3
@


1.30.4.1
log
@Merged changes from HEAD
@
text
@a58 3
  /* SA_RESTART is set to maintain BSD compatible signal behaviour by default.
     This is also compatible to the behaviour of signal(2) in Linux. */
  myself->getsig (sig).sa_flags |= SA_RESTART;
@


1.30.4.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a15 1
#include <stdlib.h>
a192 1
  sigframe thisframe (mainthread);
a216 1
  sigframe thisframe (mainthread);
a257 25
}

extern "C" void
abort (void)
{
  sigframe thisframe (mainthread);
  /* Flush all streams as per SUSv2.
     From my reading of this document, this isn't strictly correct.
     The streams are supposed to be flushed prior to exit.  However,
     if there is I/O in any signal handler that will not necessarily
     be flushed.
     However this is the way FreeBSD does it, and it is much easier to
     do things this way, so... */
  if (_reent_clib ()->__cleanup)
    _reent_clib ()->__cleanup (_reent_clib ());

  /* Ensure that SIGABRT can be caught regardless of blockage. */
  sigset_t sig_mask;
  sigfillset (&sig_mask);
  sigdelset (&sig_mask, SIGABRT);
  set_process_mask (sig_mask);

  _raise (SIGABRT);
  (void) thisframe.call_signal_handler (); /* Call any signal handler */
  do_exit (1);	/* signal handler didn't exit.  Goodbye. */
@


1.30.4.3
log
@Merged changes from HEAD
@
text
@d19 1
@


1.29
log
@forced commit
@
text
@d227 2
a228 2
          (pid > 1 && p->pgid != pid) ||
          (sig < 0 && NOTSTATE(p, PID_STOPPED)))
@


1.28
log
@* exceptions.cc (sig_handle_tty_stop): Reset PID_STOPPED if not actually
stopping.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Don't set
controlling terminal if just inheriting a handle.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
* signal.cc (kill_worker): Set appropriate errno if proc_exists determines that
process does not really exist.
@
text
@@


1.27
log
@* syscalls.cc (sleep): Try to be a little more accomodating of signal arrival.
Ensure that the signal handler is called.
@
text
@d163 5
a167 1
    res = proc_exists (dest) ? 0 : -1;
@


1.26
log
@* signal.cc (sleep): Protect with sigframe.
@
text
@a68 2
  unsigned start_time;
  unsigned int res;
d70 1
d72 1
d74 2
d77 4
a80 4
  syscall_printf ("sleep (%d)", seconds);
  rc = WaitForSingleObject (signal_arrived, seconds * 1000);
  if (rc == WAIT_TIMEOUT)
    res = 0;
d82 3
a84 1
    res = seconds - (GetTickCount () - start_time)/1000;
d86 1
@


1.25
log
@* sigproc.h (class sigframe): Implement 'unregister()' method.
(sigframe::~sigframe): Use unregister method.
(sigframe::call_signal_handler): Declare new method.
* exceptions.cc (sigframe::call_signal_handler): New method.  Unregisters
current sigframe before calling signal handler.
(setup_handler): Clear waiting threads prior to arming signal_arrived.
* syscalls.cc (_read): Change goto to loop.  Recalculate sigframe inside of
loop so that constructor is called when appropriate.
* wait.cc (wait4): Ditto.
* signal.cc: Change "sig" to "signal" in debugging messages throughout.
* sigproc.cc: Ditto.
@
text
@d71 1
@


1.24
log
@* signal.cc (signal): Prohibit setting handlers for SIGKILL and SIGSTOP
* signal.cc (sigaction): Ditto
* syscalls.cc (_lseek): Return EINVAL on invalid input
@
text
@d102 1
a102 1
      syscall_printf ("SIG_ERR = sigprocmask sig %d out of range", sig);
d185 1
a185 1
      syscall_printf ("sig %d out of range", sig);
d205 1
a205 1
  sigproc_printf ("pid %d, sig %d", pid, sig);
d250 1
a250 1
  sigproc_printf ("sig %d, newact %p, oldact %p", sig, newact, oldact);
d255 1
a255 1
      syscall_printf ("SIG_ERR = sigaction sig %d out of range", sig);
d289 1
a289 1
      syscall_printf ("SIG_ERR = sigaddset sig %d out of range", sig);
d304 1
a304 1
      syscall_printf ("SIG_ERR = sigdelset sig %d out of range", sig);
d319 1
a319 1
      syscall_printf ("SIG_ERR = sigdelset sig %d out of range", sig);
@


1.23
log
@* signal.cc (killpg): Correct first argument.
@
text
@d49 1
a49 1
  if (sig < 0 || sig >= NSIG)
d263 1
a263 1
      if ((sig == SIGKILL || sig == SIGSTOP) && newact->sa_handler != SIG_DFL)
@


1.22
log
@* autoload.cc (LoadDLLinitfunc): Remove debugging statement.
* exceptions.cc (sig_handle_tty_stop): Move setting of PID_STOPPED to earlier
in interrupt.
((interrupt_setup): i.e., here.
(sig_handle): Don't queue multiple SIGSTOPS.
* fhandler.h (bg_check_types): Enumerate return value of bg_check for clarity.
* signal.cc (kill_pgrp): Minor cleanup.
* fhandler_termios.cc (fhandler_termios::bg_check): Use enumerated type for
function return.  Don't raise signal if a signal is already queued.
* fhandler_console.cc (fhandler_console::read): Use enumerated return type for
bg_check.
* select.cc: Ditto, throughout.
* read.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
(_read): YA interrupt detect simplification.
* wait.cc (wait4): Ditto.
@
text
@d242 1
a242 1
killpg (int pgrp, int sig)
@


1.21
log
@* debug.h: Add regparm attributes to some functions.
* signal.cc (sigaction): Don't treat SIGCONT specially.
* exceptions.cc (interrupt_setup): Save sa_flags of interrupted signal for
later use.
(sig_handler): Default any stopping signal to SIGSTOP.
(call_signal_handler): New function.
(sigdelayed0): New function.
* sigproc.cc (sigproc_init): Initialize SIGSTOP sigaction for special behavior.
* sigproc.h: Define call_signal_handler.
* syscalls.cc (_read): Allow restartable signal behavior.
@
text
@d216 3
a218 5
      if (pid == 0 && (p->pgid != myself->pgid || p->ctty != myself->ctty))
	continue;
      if (pid > 1 && p->pgid != pid)
	continue;
      if (sig < 0 && NOTSTATE(p, PID_STOPPED))
@


1.20
log
@* pinfo.cc (codepage_init): Move function.
* environ.cc (codepage_init): To here.
* exceptoins.cc (SIG_NONMASKABLE): Remove SIGCONT from consideration since it
is supposed to be maskable.
* signal.cc (sigaction): Ditto.
* sigproc.cc (wait_sig): Ditto.
* winsup.h: Eliminate global declaration of codepage_init.
@
text
@d265 1
a265 2
      if ((sig == SIGKILL || sig == SIGSTOP || sig == SIGCONT) &&
	  newact->sa_handler != SIG_DFL)
@


1.19
log
@* pinfo.cc (winpids:add): New method.
(winpids::enumNT): New method renamed from EnumProcessesNT.  Use add method to
add elements to the lists.
(winpids::enum9x): New method renamed from EnumProcesses9x.  Use add method to
add elements to the lists.
(winpids::enum_init): Accept 'winpid' parameter to control whether to add all
windows pids to the list.
(winpids::release): New method.
* pinfo.h (winpids): Reflect above changes.
* signal.cc (kill_pgrp): Ditto.
* external.cc (fillout_pinfo): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
d265 2
a266 1
      if ((sig == SIGKILL || sig == SIGSTOP) && newact->sa_handler != SIG_DFL)
@


1.18
log
@* signal.cc (kill_pgrp): Revert 25-Oct change.
(kill_worker): Ditto.
@
text
@d210 1
a210 1
      pinfo p (pids[i], PID_NOREDIR);
@


1.17
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d163 1
a163 1
  else if (sendSIGCONT && ISSTATE(dest, PID_STOPPED))
d219 2
@


1.16
log
@* signal.cc (kill_pgrp): Don't limit sending of signals to stopped processes
when sig < 0.
(kill_worker): Only send SIGCONT to stopped processes when sendSIGCONT.
@
text
@d60 1
a60 1
  
@


1.15
log
@* fhandler.h (fhandler_console): Remove tcsetpgrp.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Eliminate.
* fork.cc (fork_parent): Avoid returning same pid twice in a row regardless of
OS.
* pinfo.cc (pinfo::init): Rename create argument to flags and treat it as such.
* signal.cc (set_sigcatchers): New function.
(signal): Use set_sigcatchers to increment or decrement sigcatcher tracker.
(sigaction): Ditto.  Add debugging output.
* spawn.cc (spawn_guts): Always quote first argv[0] argument when it's a
COMSPEC shell.
@
text
@d163 1
a163 1
  else if (sendSIGCONT)
a218 2
	continue;
      if (sig < 0 && NOTSTATE(p, PID_STOPPED))
@


1.14
log
@* external.cc (fillout_pinfo): Pass PID_NOREDIR flag to pinfo init to avoid
finding execed processes twice.
* signal.cc (kill_pgrp): Ditto.
* spawn.cc (spawn_guts): Avoid passing first argument to CreateProcess when
running a windows shell so that CreateProcess will locate the shell.
Reorganize so that correct error is returned when CreateProcess fails.
@
text
@d26 17
d59 1
a59 4
  if (!sigtrapped (prev) && sigtrapped (func))
    sigcatchers++;
  else if (sigtrapped (prev) && !sigtrapped (func))
    sigcatchers--;
d252 1
d275 1
a275 4
      if (!sigtrapped (oa.sa_handler) && sigtrapped (newact->sa_handler))
	sigcatchers++;
      else if (sigtrapped (oa.sa_handler) && !sigtrapped (newact->sa_handler))
	sigcatchers--;
@


1.13
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@d196 1
a196 1
      pinfo p (pids[i]);
@


1.12
log
@* signal.cc (sigaction): Allow new action == oldaction.
@
text
@d22 4
d42 5
d236 1
a236 3
sigaction (int sig,
		const struct sigaction *newaction,
		struct sigaction *oldaction)
a237 2
  struct sigaction out_oldaction;

d246 1
a246 2
  if (oldaction)
    out_oldaction = myself->getsig (sig);
d248 1
a248 1
  if (newaction)
d250 1
a250 1
      if ((sig == SIGKILL || sig == SIGSTOP) && newaction->sa_handler != SIG_DFL)
d255 2
a256 2
      myself->getsig (sig) = *newaction;
      if (newaction->sa_handler == SIG_IGN)
d258 1
a258 1
      if (newaction->sa_handler == SIG_DFL && sig == SIGCHLD)
d260 4
d266 2
a267 2
  if (oldaction)
    *oldaction = out_oldaction;
@


1.11
log
@	* signal.cc (sleep): If interrupted by signal, return the
	requested time minus the time actually slept.
@
text
@d22 1
a22 2
extern "C"
_sig_func_ptr
d35 3
a37 3
  prev = myself->getsig(sig).sa_handler;
  myself->getsig(sig).sa_handler = func;
  myself->getsig(sig).sa_mask = 0;
d42 1
a42 2
extern "C"
unsigned int
d63 1
a63 2
extern "C"
unsigned int
d72 1
a72 2
extern "C"
int
d124 1
a124 1
  dest->setthread2signal(NULL);
d220 1
a220 2
extern "C"
int
d226 1
a226 2
extern "C"
int
d231 2
d242 1
a242 1
      *oldaction = myself->getsig(sig);
d251 1
a251 1
      myself->getsig(sig) = *newaction;
d258 3
d264 1
a264 2
extern "C"
int
d279 1
a279 2
extern "C"
int
d294 1
a294 2
extern "C"
int
d311 1
a311 2
extern "C"
int
d318 1
a318 2
extern "C"
int
d325 1
a325 2
extern "C"
int
d331 1
a331 1
    if (*myself->getsigtodo(sig) && myself->getsigmask () & (bit = SIGTOMASK (sig)))
d336 1
a336 2
extern "C"
int
d342 1
a342 2
extern "C"
int
d348 1
a348 2
extern "C"
int
@


1.10
log
@* cygheap.cc (init_cheap): Just use any old address for the cygwin heap.
* exceptions.cc (signal_exit): Don't terminate the main thread.  Just try to
exit in this thread really quickly.
* signal.cc (kill_pgrp): Fix typo which caused pinfo structure to be assigned
incorrectly.
@
text
@d47 1
a47 1
  int res;
d49 1
d54 9
a62 7
  res = WaitForSingleObject (signal_arrived, seconds * 1000);
  if (res == WAIT_TIMEOUT)
    {
      syscall_printf ("0 = sleep (%d)", seconds);
      return 0;
    }
  return (GetTickCount () - start_time)/1000;
@


1.9
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d188 1
a188 1
      pinfo p = pids[i];
@


1.8
log
@* signal.cc (_raise): New function.
* exceptions.cc (unused_sig_wrapper): Remove _raise.
* sigproc.h (class sigframe): Default frames to skip to zero or suffer from
exuberant optimization.
* fhandler_tty.cc (fhandler_tty::write): Set appropriate errno when WriteFile
to pipe fails.
@
text
@d17 1
@


1.7
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d147 6
@


1.6
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d16 3
a19 1
#include "cygerrno.h"
@


1.5
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d17 1
@


1.4
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d16 1
@


1.3
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d14 1
a15 1
#include "winsup.h"
@


1.2
log
@* dcrt0.cc (__cygwin_user_data): Initialize.
(dll_crt0_1): Eliminate user_data initialization.
(dll_crt0): Set up impure_ptr_ptr for older executables.
(cygwin_dll_init): Eliminate user_data initializations.
(__api_fatal): Don't check for user_data initialization.
* dll_init.cc (struct dll): Store entire contents of per_process rather than
just a pointer.
(add): Ditto.
(initOneDll): Don't check for user_data initialization.
(DllList::recordDll): Store contents of per_process argument.
(DllList::detachDll): Pass address of per_process field.
(DllList::initAll): Ditto.
(DllList::doGlobalDestructorsOfDlls): Ditto.
(DllListIterator::operator *): Ditto.
(dll_dllcrt0): Default to __cygwin_user_data if arg is NULL.
* include/sys/cygwin.h: Reorganize per_process to eliminate obsolete fields and
accomodate new way of initializing.
* lib/_cygwin_crt0_common: Initialize _impure_ptr from
__cygwin_user_data.impure_ptr.
@
text
@d111 1
a111 1
  pinfo  *dest = procinfo (pid);
d174 2
a175 1
  for (int i = 0; i < cygwin_shared->p.size (); i++)
d177 1
a177 1
      pinfo *p = &cygwin_shared->p.vec[i];
@


1.1
log
@Initial revision
@
text
@a78 5
  /* gcc can call sigprocmask when a builtin contructor is activated.
     This can happen prior to the setup of myself */
  if (!user_data)
    return 0;

a105 15

#if 0
/* This is called _raise because the real raise is in newlib.  */
int
_raise (int sig)
{
  if (!user_data)
    {
      set_errno (ESRCH);
      return -1;
    }

  return _kill (myself->pid, sig);
}
#endif
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
