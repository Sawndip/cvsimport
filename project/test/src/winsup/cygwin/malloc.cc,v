head	1.12;
access;
symbols
	cygwin-1_7_35-release:1.12
	cygwin-1_7_34-release:1.12
	cygwin-1_7_33-release:1.11.22.1
	cygwin-1_7_32-release:1.11
	cygwin-1_7_31-release:1.11
	cygwin-1_7_30-release:1.11
	cygwin-1_7_29-release:1.11
	cygwin-1_7_29-release-branchpoint:1.11.0.22
	cygwin-pre-user-db:1.11
	cygwin-1_7_28-release:1.11
	cygwin-1_7_27-release:1.11
	cygwin-1_7_26-release:1.11
	cygwin-1_7_25-release:1.11
	cygwin-1_7_24-release:1.11
	cygwin-1_7_23-release:1.11
	cygwin-1_7_22-release:1.11
	cygwin-1_7_21-release:1.11
	cygwin-1_7_20-release:1.11
	cygwin-1_7_19-release:1.11
	cygwin-64bit-postmerge:1.11
	cygwin-64bit-premerge-branch:1.11.0.20
	cygwin-64bit-premerge:1.11
	cygwin-1_7_18-release:1.11
	post-ptmalloc3:1.11.18.1
	pre-ptmalloc3:1.11
	cygwin-1_7_17-release:1.11
	cygwin-64bit-branch:1.11.0.18
	cygwin-1_7_16-release:1.11
	cygwin-1_7_15-release:1.11
	cygwin-1_7_14_2-release:1.11
	cygwin-1_7_14-release:1.11
	cygwin-1_7_12-release:1.11
	cygwin-1_7_11-release:1.11
	cygwin-1_7_10-release:1.11
	signal-rewrite:1.11.0.16
	pre-notty:1.11
	cygwin-1_7_9-release:1.11
	cv-post-1_7_9:1.11.0.14
	cygwin-1_7_8-release:1.11
	cygwin-1_7_7-release:1.11
	cygwin-1_7_5-release:1.11
	cygwin-1_7_4-release:1.11
	cygwin-1_7_3-release:1.11
	cygwin-1_7_2-release:1.11
	fifo_doover3:1.11.0.12
	cygwin-1_7_1-release:1.11
	prefifo:1.11
	cv-branch-2:1.11.0.10
	pre-ripout-set_console_state_for_spawn:1.11
	EOL_registry_mounts:1.11
	preoverlapped:1.11
	drop_9x_support_start:1.11
	cr-0x5f1:1.11.0.8
	cv-branch:1.11.0.6
	pre-ptymaster-archetype:1.11
	cr-0x3b58:1.11.0.4
	cr-0x5ef:1.11.0.2
	after-mmap-privanon-noreserve:1.10
	after-mmap-revamp:1.10
	before-mmap-revamp:1.10
	cgf-more-exit-sync:1.10
	post_wait_sig_exit:1.10
	pre_wait_sig_exit:1.10
	vendor:1.9.0.2
	reparent-point:1.7
	noreparent:1.7.0.14
	cr-0x5e6:1.7.0.12
	cr-0x9e:1.7.0.10
	cr-0x9d:1.7.0.8
	cgf-deleteme:1.7.0.6
	pre-sigrewrite:1.7
	corinna-01:1.7
	cr-0x9c:1.7.0.4
	cr-0x9b:1.7.0.2
	cr-0x99:1.7
	Z-emcb-cygwin_daemon:1.6.0.2
	w32api-2_2:1.6
	mingw-runtime-2_4:1.5
	pre-cgf-merge:1.7
	cgf-dev-branch:1.4.0.16
	Z-cygwin_daemon_merge_HEAD:1.4
	cygwin_daemon:1.1.0.2
	Z-cygwin_daemon_merge-new_HEAD:1.4;
locks; strict;
comment	@// @;


1.12
date	2014.08.14.17.36.21;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.10.17.09.58;	author cgf;	state Exp;
branches
	1.11.18.1
	1.11.22.1;
next	1.10;

1.10
date	2005.07.28.17.03.34;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.05.15.11.49;	author cgf;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.06.05.03.47.36;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.31.18.26.58;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.08.17.03.34;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.07.06.15.10;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.28.16.08.09;	author cgf;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	2002.08.18.05.49.25;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.18.03.28.52;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.16.19.41.39;	author cgf;	state Exp;
branches
	1.1.2.1;
next	;

1.11.18.1
date	2013.02.27.08.36.58;	author corinna;	state Exp;
branches;
next	1.11.18.2;

1.11.18.2
date	2013.03.13.16.51.25;	author corinna;	state Exp;
branches;
next	1.11.18.3;

1.11.18.3
date	2013.04.10.12.29.48;	author corinna;	state Exp;
branches;
next	1.11.18.4;

1.11.18.4
date	2013.04.23.09.06.12;	author corinna;	state Exp;
branches;
next	;

1.11.22.1
date	2014.11.13.12.53.02;	author corinna;	state Exp;
branches;
next	;

1.9.2.1
date	2005.07.05.15.21.26;	author cgf;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2005.12.10.17.07.49;	author cgf;	state Exp;
branches;
next	;

1.4.16.1
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2003.02.09.05.46.39;	author cgf;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	;

1.1.2.1
date	2002.08.16.21.46.49;	author scottc;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.08.18.12.09.27;	author scottc;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.08.28.16.09.14;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.12
log
@	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.
@
text
@/*
  This is a version (aka dlmalloc) of malloc/free/realloc written by
  Doug Lea and released to the public domain, as explained at
  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
  comments, complaints, performance data, etc to dl@@cs.oswego.edu

* Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
   Note: There may be an updated version of this malloc obtainable at
           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
         Check before installing!

* Quickstart

  This library is all in one file to simplify the most common usage:
  ftp it, compile it (-O3), and link it into another program. All of
  the compile-time options default to reasonable values for use on
  most platforms.  You might later want to step through various
  compile-time and dynamic tuning options.

  For convenience, an include file for code using this malloc is at:
     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.6.h
  You don't really need this .h file unless you call functions not
  defined in your system include files.  The .h file contains only the
  excerpts from this file needed for using this malloc on ANSI C/C++
  systems, so long as you haven't changed compile-time options about
  naming and tuning parameters.  If you do, then you can create your
  own malloc.h that does include all settings by cutting at the point
  indicated below. Note that you may already by default be using a C
  library containing a malloc that is based on some version of this
  malloc (for example in linux). You might still want to use the one
  in this file to customize settings or to avoid overheads associated
  with library versions.

* Vital statistics:

  Supported pointer/size_t representation:       4 or 8 bytes
       size_t MUST be an unsigned type of the same width as
       pointers. (If you are using an ancient system that declares
       size_t as a signed type, or need it to be a different width
       than pointers, you can use a previous release of this malloc
       (e.g. 2.7.2) supporting these.)

  Alignment:                                     8 bytes (minimum)
       This suffices for nearly all current machines and C compilers.
       However, you can define MALLOC_ALIGNMENT to be wider than this
       if necessary (up to 128bytes), at the expense of using more space.

  Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)
                                          8 or 16 bytes (if 8byte sizes)
       Each malloced chunk has a hidden word of overhead holding size
       and status information, and additional cross-check word
       if FOOTERS is defined.

  Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)
                          8-byte ptrs:  32 bytes    (including overhead)

       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.
       The maximum overhead wastage (i.e., number of extra bytes
       allocated than were requested in malloc) is less than or equal
       to the minimum size, except for requests >= mmap_threshold that
       are serviced via mmap(), where the worst case wastage is about
       32 bytes plus the remainder from a system page (the minimal
       mmap unit); typically 4096 or 8192 bytes.

  Security: static-safe; optionally more or less
       The "security" of malloc refers to the ability of malicious
       code to accentuate the effects of errors (for example, freeing
       space that is not currently malloc'ed or overwriting past the
       ends of chunks) in code that calls malloc.  This malloc
       guarantees not to modify any memory locations below the base of
       heap, i.e., static variables, even in the presence of usage
       errors.  The routines additionally detect most improper frees
       and reallocs.  All this holds as long as the static bookkeeping
       for malloc itself is not corrupted by some other means.  This
       is only one aspect of security -- these checks do not, and
       cannot, detect all possible programming errors.

       If FOOTERS is defined nonzero, then each allocated chunk
       carries an additional check word to verify that it was malloced
       from its space.  These check words are the same within each
       execution of a program using malloc, but differ across
       executions, so externally crafted fake chunks cannot be
       freed. This improves security by rejecting frees/reallocs that
       could corrupt heap memory, in addition to the checks preventing
       writes to statics that are always on.  This may further improve
       security at the expense of time and space overhead.  (Note that
       FOOTERS may also be worth using with MSPACES.)

       By default detected errors cause the program to abort (calling
       "abort()"). You can override this to instead proceed past
       errors by defining PROCEED_ON_ERROR.  In this case, a bad free
       has no effect, and a malloc that encounters a bad address
       caused by user overwrites will ignore the bad address by
       dropping pointers and indices to all known memory. This may
       be appropriate for programs that should continue if at all
       possible in the face of programming errors, although they may
       run out of memory because dropped memory is never reclaimed.

       If you don't like either of these options, you can define
       CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything
       else. And if if you are sure that your program using malloc has
       no errors or vulnerabilities, you can define INSECURE to 1,
       which might (or might not) provide a small performance improvement.

       It is also possible to limit the maximum total allocatable
       space, using malloc_set_footprint_limit. This is not
       designed as a security feature in itself (calls to set limits
       are not screened or privileged), but may be useful as one
       aspect of a secure implementation.

  Thread-safety: NOT thread-safe unless USE_LOCKS defined non-zero
       When USE_LOCKS is defined, each public call to malloc, free,
       etc is surrounded with a lock. By default, this uses a plain
       pthread mutex, win32 critical section, or a spin-lock if if
       available for the platform and not disabled by setting
       USE_SPIN_LOCKS=0.  However, if USE_RECURSIVE_LOCKS is defined,
       recursive versions are used instead (which are not required for
       base functionality but may be needed in layered extensions).
       Using a global lock is not especially fast, and can be a major
       bottleneck.  It is designed only to provide minimal protection
       in concurrent environments, and to provide a basis for
       extensions.  If you are using malloc in a concurrent program,
       consider instead using nedmalloc
       (http://www.nedprod.com/programs/portable/nedmalloc/) or
       ptmalloc (See http://www.malloc.de), which are derived from
       versions of this malloc.

  System requirements: Any combination of MORECORE and/or MMAP/MUNMAP
       This malloc can use unix sbrk or any emulation (invoked using
       the CALL_MORECORE macro) and/or mmap/munmap or any emulation
       (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system
       memory.  On most unix systems, it tends to work best if both
       MORECORE and MMAP are enabled.  On Win32, it uses emulations
       based on VirtualAlloc. It also uses common C library functions
       like memset.

  Compliance: I believe it is compliant with the Single Unix Specification
       (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably
       others as well.

* Overview of algorithms

  This is not the fastest, most space-conserving, most portable, or
  most tunable malloc ever written. However it is among the fastest
  while also being among the most space-conserving, portable and
  tunable.  Consistent balance across these factors results in a good
  general-purpose allocator for malloc-intensive programs.

  In most ways, this malloc is a best-fit allocator. Generally, it
  chooses the best-fitting existing chunk for a request, with ties
  broken in approximately least-recently-used order. (This strategy
  normally maintains low fragmentation.) However, for requests less
  than 256bytes, it deviates from best-fit when there is not an
  exactly fitting available chunk by preferring to use space adjacent
  to that used for the previous small request, as well as by breaking
  ties in approximately most-recently-used order. (These enhance
  locality of series of small allocations.)  And for very large requests
  (>= 256Kb by default), it relies on system memory mapping
  facilities, if supported.  (This helps avoid carrying around and
  possibly fragmenting memory used only for large chunks.)

  All operations (except malloc_stats and mallinfo) have execution
  times that are bounded by a constant factor of the number of bits in
  a size_t, not counting any clearing in calloc or copying in realloc,
  or actions surrounding MORECORE and MMAP that have times
  proportional to the number of non-contiguous regions returned by
  system allocation routines, which is often just 1. In real-time
  applications, you can optionally suppress segment traversals using
  NO_SEGMENT_TRAVERSAL, which assures bounded execution even when
  system allocators return non-contiguous spaces, at the typical
  expense of carrying around more memory and increased fragmentation.

  The implementation is not very modular and seriously overuses
  macros. Perhaps someday all C compilers will do as good a job
  inlining modular code as can now be done by brute-force expansion,
  but now, enough of them seem not to.

  Some compilers issue a lot of warnings about code that is
  dead/unreachable only on some platforms, and also about intentional
  uses of negation on unsigned types. All known cases of each can be
  ignored.

  For a longer but out of date high-level description, see
     http://gee.cs.oswego.edu/dl/html/malloc.html

* MSPACES
  If MSPACES is defined, then in addition to malloc, free, etc.,
  this file also defines mspace_malloc, mspace_free, etc. These
  are versions of malloc routines that take an "mspace" argument
  obtained using create_mspace, to control all internal bookkeeping.
  If ONLY_MSPACES is defined, only these versions are compiled.
  So if you would like to use this allocator for only some allocations,
  and your system malloc for others, you can compile with
  ONLY_MSPACES and then do something like...
    static mspace mymspace = create_mspace(0,0); // for example
    #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)

  (Note: If you only need one instance of an mspace, you can instead
  use "USE_DL_PREFIX" to relabel the global malloc.)

  You can similarly create thread-local allocators by storing
  mspaces as thread-locals. For example:
    static __thread mspace tlms = 0;
    void*  tlmalloc(size_t bytes) {
      if (tlms == 0) tlms = create_mspace(0, 0);
      return mspace_malloc(tlms, bytes);
    }
    void  tlfree(void* mem) { mspace_free(tlms, mem); }

  Unless FOOTERS is defined, each mspace is completely independent.
  You cannot allocate from one and free to another (although
  conformance is only weakly checked, so usage errors are not always
  caught). If FOOTERS is defined, then each chunk carries around a tag
  indicating its originating mspace, and frees are directed to their
  originating spaces. Normally, this requires use of locks.

 -------------------------  Compile-time options ---------------------------

Be careful in setting #define values for numerical constants of type
size_t. On some systems, literal values are not automatically extended
to size_t precision unless they are explicitly casted. You can also
use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.

WIN32                    default: defined if _WIN32 defined
  Defining WIN32 sets up defaults for MS environment and compilers.
  Otherwise defaults are for unix. Beware that there seem to be some
  cases where this malloc might not be a pure drop-in replacement for
  Win32 malloc: Random-looking failures from Win32 GDI API's (eg;
  SetDIBits()) may be due to bugs in some video driver implementations
  when pixel buffers are malloc()ed, and the region spans more than
  one VirtualAlloc()ed region. Because dlmalloc uses a small (64Kb)
  default granularity, pixel buffers may straddle virtual allocation
  regions more often than when using the Microsoft allocator.  You can
  avoid this by using VirtualAlloc() and VirtualFree() for all pixel
  buffers rather than using malloc().  If this is not possible,
  recompile this malloc with a larger DEFAULT_GRANULARITY. Note:
  in cases where MSC and gcc (cygwin) are known to differ on WIN32,
  conditions use _MSC_VER to distinguish them.

DLMALLOC_EXPORT       default: extern
  Defines how public APIs are declared. If you want to export via a
  Windows DLL, you might define this as
    #define DLMALLOC_EXPORT extern  __declspec(dllexport)
  If you want a POSIX ELF shared object, you might use
    #define DLMALLOC_EXPORT extern __attribute__((visibility("default")))

MALLOC_ALIGNMENT         default: (size_t)(2 * sizeof(void *))
  Controls the minimum alignment for malloc'ed chunks.  It must be a
  power of two and at least 8, even on machines for which smaller
  alignments would suffice. It may be defined as larger than this
  though. Note however that code and data structures are optimized for
  the case of 8-byte alignment.

MSPACES                  default: 0 (false)
  If true, compile in support for independent allocation spaces.
  This is only supported if HAVE_MMAP is true.

ONLY_MSPACES             default: 0 (false)
  If true, only compile in mspace versions, not regular versions.

USE_LOCKS                default: 0 (false)
  Causes each call to each public routine to be surrounded with
  pthread or WIN32 mutex lock/unlock. (If set true, this can be
  overridden on a per-mspace basis for mspace versions.) If set to a
  non-zero value other than 1, locks are used, but their
  implementation is left out, so lock functions must be supplied manually,
  as described below.

USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and spin locks available
  If true, uses custom spin locks for locking. This is currently
  supported only gcc >= 4.1, older gccs on x86 platforms, and recent
  MS compilers.  Otherwise, posix locks or win32 critical sections are
  used.

USE_RECURSIVE_LOCKS      default: not defined
  If defined nonzero, uses recursive (aka reentrant) locks, otherwise
  uses plain mutexes. This is not required for malloc proper, but may
  be needed for layered allocators such as nedmalloc.

LOCK_AT_FORK            default: not defined
  If defined nonzero, performs pthread_atfork upon initialization
  to initialize child lock while holding parent lock. The implementation
  assumes that pthread locks (not custom locks) are being used. In other
  cases, you may need to customize the implementation.

FOOTERS                  default: 0
  If true, provide extra checking and dispatching by placing
  information in the footers of allocated chunks. This adds
  space and time overhead.

INSECURE                 default: 0
  If true, omit checks for usage errors and heap space overwrites.

USE_DL_PREFIX            default: NOT defined
  Causes compiler to prefix all public routines with the string 'dl'.
  This can be useful when you only want to use this malloc in one part
  of a program, using your regular system malloc elsewhere.

MALLOC_INSPECT_ALL       default: NOT defined
  If defined, compiles malloc_inspect_all and mspace_inspect_all, that
  perform traversal of all heap space.  Unless access to these
  functions is otherwise restricted, you probably do not want to
  include them in secure implementations.

ABORT                    default: defined as abort()
  Defines how to abort on failed checks.  On most systems, a failed
  check cannot die with an "assert" or even print an informative
  message, because the underlying print routines in turn call malloc,
  which will fail again.  Generally, the best policy is to simply call
  abort(). It's not very useful to do more than this because many
  errors due to overwriting will show up as address faults (null, odd
  addresses etc) rather than malloc-triggered checks, so will also
  abort.  Also, most compilers know that abort() does not return, so
  can better optimize code conditionally calling it.

PROCEED_ON_ERROR           default: defined as 0 (false)
  Controls whether detected bad addresses cause them to bypassed
  rather than aborting. If set, detected bad arguments to free and
  realloc are ignored. And all bookkeeping information is zeroed out
  upon a detected overwrite of freed heap space, thus losing the
  ability to ever return it from malloc again, but enabling the
  application to proceed. If PROCEED_ON_ERROR is defined, the
  static variable malloc_corruption_error_count is compiled in
  and can be examined to see if errors have occurred. This option
  generates slower code than the default abort policy.

DEBUG                    default: NOT defined
  The DEBUG setting is mainly intended for people trying to modify
  this code or diagnose problems when porting to new platforms.
  However, it may also be able to better isolate user errors than just
  using runtime checks.  The assertions in the check routines spell
  out in more detail the assumptions and invariants underlying the
  algorithms.  The checking is fairly extensive, and will slow down
  execution noticeably. Calling malloc_stats or mallinfo with DEBUG
  set will attempt to check every non-mmapped allocated and free chunk
  in the course of computing the summaries.

ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)
  Debugging assertion failures can be nearly impossible if your
  version of the assert macro causes malloc to be called, which will
  lead to a cascade of further failures, blowing the runtime stack.
  ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),
  which will usually make debugging easier.

MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32
  The action to take before "return 0" when malloc fails to be able to
  return memory because there is none available.

HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES
  True if this system supports sbrk or an emulation of it.

MORECORE                  default: sbrk
  The name of the sbrk-style system routine to call to obtain more
  memory.  See below for guidance on writing custom MORECORE
  functions. The type of the argument to sbrk/MORECORE varies across
  systems.  It cannot be size_t, because it supports negative
  arguments, so it is normally the signed type of the same width as
  size_t (sometimes declared as "intptr_t").  It doesn't much matter
  though. Internally, we only call it with arguments less than half
  the max value of a size_t, which should work across all reasonable
  possibilities, although sometimes generating compiler warnings.

MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
  If true, take advantage of fact that consecutive calls to MORECORE
  with positive arguments always return contiguous increasing
  addresses.  This is true of unix sbrk. It does not hurt too much to
  set it true anyway, since malloc copes with non-contiguities.
  Setting it false when definitely non-contiguous saves time
  and possibly wasted space it would take to discover this though.

MORECORE_CANNOT_TRIM      default: NOT defined
  True if MORECORE cannot release space back to the system when given
  negative arguments. This is generally necessary only if you are
  using a hand-crafted MORECORE function that cannot handle negative
  arguments.

NO_SEGMENT_TRAVERSAL       default: 0
  If non-zero, suppresses traversals of memory segments
  returned by either MORECORE or CALL_MMAP. This disables
  merging of segments that are contiguous, and selectively
  releasing them to the OS if unused, but bounds execution times.

HAVE_MMAP                 default: 1 (true)
  True if this system supports mmap or an emulation of it.  If so, and
  HAVE_MORECORE is not true, MMAP is used for all system
  allocation. If set and HAVE_MORECORE is true as well, MMAP is
  primarily used to directly allocate very large blocks. It is also
  used as a backup strategy in cases where MORECORE fails to provide
  space from system. Note: A single call to MUNMAP is assumed to be
  able to unmap memory that may have be allocated using multiple calls
  to MMAP, so long as they are adjacent.

HAVE_MREMAP               default: 1 on linux, else 0
  If true realloc() uses mremap() to re-allocate large blocks and
  extend or shrink allocation spaces.

MMAP_CLEARS               default: 1 except on WINCE.
  True if mmap clears memory so calloc doesn't need to. This is true
  for standard unix mmap using /dev/zero and on WIN32 except for WINCE.

USE_BUILTIN_FFS            default: 0 (i.e., not used)
  Causes malloc to use the builtin ffs() function to compute indices.
  Some compilers may recognize and intrinsify ffs to be faster than the
  supplied C version. Also, the case of x86 using gcc is special-cased
  to an asm instruction, so is already as fast as it can be, and so
  this setting has no effect. Similarly for Win32 under recent MS compilers.
  (On most x86s, the asm version is only slightly faster than the C version.)

malloc_getpagesize         default: derive from system includes, or 4096.
  The system page size. To the extent possible, this malloc manages
  memory from the system in page-size units.  This may be (and
  usually is) a function rather than a constant. This is ignored
  if WIN32, where page size is determined using getSystemInfo during
  initialization.

USE_DEV_RANDOM             default: 0 (i.e., not used)
  Causes malloc to use /dev/random to initialize secure magic seed for
  stamping footers. Otherwise, the current time is used.

NO_MALLINFO                default: 0
  If defined, don't compile "mallinfo". This can be a simple way
  of dealing with mismatches between system declarations and
  those in this file.

MALLINFO_FIELD_TYPE        default: size_t
  The type of the fields in the mallinfo struct. This was originally
  defined as "int" in SVID etc, but is more usefully defined as
  size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set

NO_MALLOC_STATS            default: 0
  If defined, don't compile "malloc_stats". This avoids calls to
  fprintf and bringing in stdio dependencies you might not want.

REALLOC_ZERO_BYTES_FREES    default: not defined
  This should be set if a call to realloc with zero bytes should
  be the same as a call to free. Some people think it should. Otherwise,
  since this malloc returns a unique pointer for malloc(0), so does
  realloc(p, 0).

LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H
LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H
LACKS_STDLIB_H LACKS_SCHED_H LACKS_TIME_H  default: NOT defined unless on WIN32
  Define these if your system does not have these header files.
  You might need to manually insert some of the declarations they provide.

DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,
                                system_info.dwAllocationGranularity in WIN32,
                                otherwise 64K.
      Also settable using mallopt(M_GRANULARITY, x)
  The unit for allocating and deallocating memory from the system.  On
  most systems with contiguous MORECORE, there is no reason to
  make this more than a page. However, systems with MMAP tend to
  either require or encourage larger granularities.  You can increase
  this value to prevent system allocation functions to be called so
  often, especially if they are slow.  The value must be at least one
  page and must be a power of two.  Setting to 0 causes initialization
  to either page size or win32 region size.  (Note: In previous
  versions of malloc, the equivalent of this option was called
  "TOP_PAD")

DEFAULT_TRIM_THRESHOLD    default: 2MB
      Also settable using mallopt(M_TRIM_THRESHOLD, x)
  The maximum amount of unused top-most memory to keep before
  releasing via malloc_trim in free().  Automatic trimming is mainly
  useful in long-lived programs using contiguous MORECORE.  Because
  trimming via sbrk can be slow on some systems, and can sometimes be
  wasteful (in cases where programs immediately afterward allocate
  more large chunks) the value should be high enough so that your
  overall system performance would improve by releasing this much
  memory.  As a rough guide, you might set to a value close to the
  average size of a process (program) running on your system.
  Releasing this much memory would allow such a process to run in
  memory.  Generally, it is worth tuning trim thresholds when a
  program undergoes phases where several large chunks are allocated
  and released in ways that can reuse each other's storage, perhaps
  mixed with phases where there are no such chunks at all. The trim
  value must be greater than page size to have any useful effect.  To
  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick
  some people use of mallocing a huge space and then freeing it at
  program startup, in an attempt to reserve system memory, doesn't
  have the intended effect under automatic trimming, since that memory
  will immediately be returned to the system.

DEFAULT_MMAP_THRESHOLD       default: 256K
      Also settable using mallopt(M_MMAP_THRESHOLD, x)
  The request size threshold for using MMAP to directly service a
  request. Requests of at least this size that cannot be allocated
  using already-existing space will be serviced via mmap.  (If enough
  normal freed space already exists it is used instead.)  Using mmap
  segregates relatively large chunks of memory so that they can be
  individually obtained and released from the host system. A request
  serviced through mmap is never reused by any other request (at least
  not directly; the system may just so happen to remap successive
  requests to the same locations).  Segregating space in this way has
  the benefits that: Mmapped space can always be individually released
  back to the system, which helps keep the system level memory demands
  of a long-lived program low.  Also, mapped memory doesn't become
  `locked' between other chunks, as can happen with normally allocated
  chunks, which means that even trimming via malloc_trim would not
  release them.  However, it has the disadvantage that the space
  cannot be reclaimed, consolidated, and then used to service later
  requests, as happens with normal chunks.  The advantages of mmap
  nearly always outweigh disadvantages for "large" chunks, but the
  value of "large" may vary across systems.  The default is an
  empirically derived value that works well in most systems. You can
  disable mmap by setting to MAX_SIZE_T.

MAX_RELEASE_CHECK_RATE   default: 4095 unless not HAVE_MMAP
  The number of consolidated frees between checks to release
  unused segments when freeing. When using non-contiguous segments,
  especially with multiple mspaces, checking only for topmost space
  doesn't always suffice to trigger trimming. To compensate for this,
  free() will, with a period of MAX_RELEASE_CHECK_RATE (or the
  current number of segments, if greater) try to release unused
  segments to the OS when freeing chunks that result in
  consolidation. The best value for this parameter is a compromise
  between slowing down frees with relatively costly checks that
  rarely trigger versus holding on to unused memory. To effectively
  disable, set to MAX_SIZE_T. This may lead to a very slight speed
  improvement at the expense of carrying around more memory.
*/

/* Version identifier to allow people to support multiple versions */
#ifndef DLMALLOC_VERSION
#define DLMALLOC_VERSION 20806
#endif /* DLMALLOC_VERSION */

#ifndef DLMALLOC_EXPORT
#define DLMALLOC_EXPORT extern
#endif

#ifndef WIN32
#ifdef _WIN32
#define WIN32 1
#endif  /* _WIN32 */
#ifdef _WIN32_WCE
#define LACKS_FCNTL_H
#define WIN32 1
#endif /* _WIN32_WCE */
#endif  /* WIN32 */
#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <tchar.h>
#define HAVE_MMAP 1
#define HAVE_MORECORE 0
#define LACKS_UNISTD_H
#define LACKS_SYS_PARAM_H
#define LACKS_SYS_MMAN_H
#define LACKS_STRING_H
#define LACKS_STRINGS_H
#define LACKS_SYS_TYPES_H
#define LACKS_ERRNO_H
#define LACKS_SCHED_H
#ifndef MALLOC_FAILURE_ACTION
#define MALLOC_FAILURE_ACTION
#endif /* MALLOC_FAILURE_ACTION */
#ifndef MMAP_CLEARS
#ifdef _WIN32_WCE /* WINCE reportedly does not clear */
#define MMAP_CLEARS 0
#else
#define MMAP_CLEARS 1
#endif /* _WIN32_WCE */
#endif /*MMAP_CLEARS */
#endif  /* WIN32 */

#if defined(DARWIN) || defined(_DARWIN)
/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
#ifndef HAVE_MORECORE
#define HAVE_MORECORE 0
#define HAVE_MMAP 1
/* OSX allocators provide 16 byte alignment */
#ifndef MALLOC_ALIGNMENT
#define MALLOC_ALIGNMENT ((size_t)16U)
#endif
#endif  /* HAVE_MORECORE */
#endif  /* DARWIN */

#ifndef LACKS_SYS_TYPES_H
#include <sys/types.h>  /* For size_t */
#endif  /* LACKS_SYS_TYPES_H */
#ifdef __CYGWIN__
#include "cygmalloc.h"
#endif /* __CYGWIN__ */

/* The maximum possible size_t value has all bits set */
#define MAX_SIZE_T           (~(size_t)0)

#ifndef USE_LOCKS /* ensure true if spin or recursive locks set */
#define USE_LOCKS  ((defined(USE_SPIN_LOCKS) && USE_SPIN_LOCKS != 0) || \
                    (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0))
#endif /* USE_LOCKS */

#if USE_LOCKS /* Spin locks for gcc >= 4.1, older gcc on x86, MSC >= 1310 */
#if ((defined(__GNUC__) &&                                              \
      ((__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)) ||      \
       defined(__i386__) || defined(__x86_64__))) ||                    \
     (defined(_MSC_VER) && _MSC_VER>=1310))
#ifndef USE_SPIN_LOCKS
#define USE_SPIN_LOCKS 1
#endif /* USE_SPIN_LOCKS */
#elif USE_SPIN_LOCKS
#error "USE_SPIN_LOCKS defined without implementation"
#endif /* ... locks available... */
#elif !defined(USE_SPIN_LOCKS)
#define USE_SPIN_LOCKS 0
#endif /* USE_LOCKS */

#ifndef ONLY_MSPACES
#define ONLY_MSPACES 0
#endif  /* ONLY_MSPACES */
#ifndef MSPACES
#if ONLY_MSPACES
#define MSPACES 1
#else   /* ONLY_MSPACES */
#define MSPACES 0
#endif  /* ONLY_MSPACES */
#endif  /* MSPACES */
#ifndef MALLOC_ALIGNMENT
#define MALLOC_ALIGNMENT ((size_t)(2 * sizeof(void *)))
#endif  /* MALLOC_ALIGNMENT */
#ifndef FOOTERS
#define FOOTERS 0
#endif  /* FOOTERS */
#ifndef ABORT
#define ABORT  abort()
#endif  /* ABORT */
#ifndef ABORT_ON_ASSERT_FAILURE
#define ABORT_ON_ASSERT_FAILURE 1
#endif  /* ABORT_ON_ASSERT_FAILURE */
#ifndef PROCEED_ON_ERROR
#define PROCEED_ON_ERROR 0
#endif  /* PROCEED_ON_ERROR */

#ifndef INSECURE
#define INSECURE 0
#endif  /* INSECURE */
#ifndef MALLOC_INSPECT_ALL
#define MALLOC_INSPECT_ALL 0
#endif  /* MALLOC_INSPECT_ALL */
#ifndef HAVE_MMAP
#define HAVE_MMAP 1
#endif  /* HAVE_MMAP */
#ifndef MMAP_CLEARS
#define MMAP_CLEARS 1
#endif  /* MMAP_CLEARS */
#ifndef HAVE_MREMAP
#ifdef linux
#define HAVE_MREMAP 1
#define _GNU_SOURCE /* Turns on mremap() definition */
#else   /* linux */
#define HAVE_MREMAP 0
#endif  /* linux */
#endif  /* HAVE_MREMAP */
#ifndef MALLOC_FAILURE_ACTION
#define MALLOC_FAILURE_ACTION  errno = ENOMEM;
#endif  /* MALLOC_FAILURE_ACTION */
#ifndef HAVE_MORECORE
#if ONLY_MSPACES
#define HAVE_MORECORE 0
#else   /* ONLY_MSPACES */
#define HAVE_MORECORE 1
#endif  /* ONLY_MSPACES */
#endif  /* HAVE_MORECORE */
#if !HAVE_MORECORE
#define MORECORE_CONTIGUOUS 0
#else   /* !HAVE_MORECORE */
#define MORECORE_DEFAULT sbrk
#ifndef MORECORE_CONTIGUOUS
#define MORECORE_CONTIGUOUS 1
#endif  /* MORECORE_CONTIGUOUS */
#endif  /* HAVE_MORECORE */
#ifndef DEFAULT_GRANULARITY
#if (MORECORE_CONTIGUOUS || defined(WIN32))
#define DEFAULT_GRANULARITY (0)  /* 0 means to compute in init_mparams */
#else   /* MORECORE_CONTIGUOUS */
#define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)
#endif  /* MORECORE_CONTIGUOUS */
#endif  /* DEFAULT_GRANULARITY */
#ifndef DEFAULT_TRIM_THRESHOLD
#ifndef MORECORE_CANNOT_TRIM
#define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)
#else   /* MORECORE_CANNOT_TRIM */
#define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T
#endif  /* MORECORE_CANNOT_TRIM */
#endif  /* DEFAULT_TRIM_THRESHOLD */
#ifndef DEFAULT_MMAP_THRESHOLD
#if HAVE_MMAP
#define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)
#else   /* HAVE_MMAP */
#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
#endif  /* HAVE_MMAP */
#endif  /* DEFAULT_MMAP_THRESHOLD */
#ifndef MAX_RELEASE_CHECK_RATE
#if HAVE_MMAP
#define MAX_RELEASE_CHECK_RATE 4095
#else
#define MAX_RELEASE_CHECK_RATE MAX_SIZE_T
#endif /* HAVE_MMAP */
#endif /* MAX_RELEASE_CHECK_RATE */
#ifndef USE_BUILTIN_FFS
#define USE_BUILTIN_FFS 0
#endif  /* USE_BUILTIN_FFS */
#ifndef USE_DEV_RANDOM
#define USE_DEV_RANDOM 0
#endif  /* USE_DEV_RANDOM */
#ifndef NO_MALLINFO
#define NO_MALLINFO 0
#endif  /* NO_MALLINFO */
#ifndef MALLINFO_FIELD_TYPE
#define MALLINFO_FIELD_TYPE size_t
#endif  /* MALLINFO_FIELD_TYPE */
#ifndef NO_MALLOC_STATS
#define NO_MALLOC_STATS 0
#endif  /* NO_MALLOC_STATS */
#ifndef NO_SEGMENT_TRAVERSAL
#define NO_SEGMENT_TRAVERSAL 0
#endif /* NO_SEGMENT_TRAVERSAL */

/*
  mallopt tuning options.  SVID/XPG defines four standard parameter
  numbers for mallopt, normally defined in malloc.h.  None of these
  are used in this malloc, so setting them has no effect. But this
  malloc does support the following options.
*/

#define M_TRIM_THRESHOLD     (-1)
#define M_GRANULARITY        (-2)
#define M_MMAP_THRESHOLD     (-3)

/* ------------------------ Mallinfo declarations ------------------------ */

#if !NO_MALLINFO
/*
  This version of malloc supports the standard SVID/XPG mallinfo
  routine that returns a struct containing usage properties and
  statistics. It should work on any system that has a
  /usr/include/malloc.h defining struct mallinfo.  The main
  declaration needed is the mallinfo struct that is returned (by-copy)
  by mallinfo().  The malloinfo struct contains a bunch of fields that
  are not even meaningful in this version of malloc.  These fields are
  are instead filled by mallinfo() with other numbers that might be of
  interest.

  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
  /usr/include/malloc.h file that includes a declaration of struct
  mallinfo.  If so, it is included; else a compliant version is
  declared below.  These must be precisely the same for mallinfo() to
  work.  The original SVID version of this struct, defined on most
  systems with mallinfo, declares all fields as ints. But some others
  define as unsigned long. If your system defines the fields using a
  type of different width than listed here, you MUST #include your
  system version and #define HAVE_USR_INCLUDE_MALLOC_H.
*/

/* #define HAVE_USR_INCLUDE_MALLOC_H */

#ifdef HAVE_USR_INCLUDE_MALLOC_H
#include "/usr/include/malloc.h"
#else /* HAVE_USR_INCLUDE_MALLOC_H */
#ifndef STRUCT_MALLINFO_DECLARED
/* HP-UX (and others?) redefines mallinfo unless _STRUCT_MALLINFO is defined */
#define _STRUCT_MALLINFO
#define STRUCT_MALLINFO_DECLARED 1
struct mallinfo {
  MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */
  MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */
  MALLINFO_FIELD_TYPE smblks;   /* always 0 */
  MALLINFO_FIELD_TYPE hblks;    /* always 0 */
  MALLINFO_FIELD_TYPE hblkhd;   /* space in mmapped regions */
  MALLINFO_FIELD_TYPE usmblks;  /* maximum total allocated space */
  MALLINFO_FIELD_TYPE fsmblks;  /* always 0 */
  MALLINFO_FIELD_TYPE uordblks; /* total allocated space */
  MALLINFO_FIELD_TYPE fordblks; /* total free space */
  MALLINFO_FIELD_TYPE keepcost; /* releasable (via malloc_trim) space */
};
#endif /* STRUCT_MALLINFO_DECLARED */
#endif /* HAVE_USR_INCLUDE_MALLOC_H */
#endif /* NO_MALLINFO */

/*
  Try to persuade compilers to inline. The most critical functions for
  inlining are defined as macros, so these aren't used for them.
*/

#ifndef FORCEINLINE
  #if defined(__GNUC__)
#define FORCEINLINE __inline __attribute__ ((always_inline))
  #elif defined(_MSC_VER)
    #define FORCEINLINE __forceinline
  #endif
#endif
#ifndef NOINLINE
  #if defined(__GNUC__)
    #define NOINLINE __attribute__ ((noinline))
  #elif defined(_MSC_VER)
    #define NOINLINE __declspec(noinline)
  #else
    #define NOINLINE
  #endif
#endif

#ifdef __cplusplus
extern "C" {
#ifndef FORCEINLINE
 #define FORCEINLINE inline
#endif
#endif /* __cplusplus */
#ifndef FORCEINLINE
 #define FORCEINLINE
#endif

#if !ONLY_MSPACES

/* ------------------- Declarations of public routines ------------------- */

#ifndef USE_DL_PREFIX
#define dlcalloc               calloc
#define dlfree                 free
#define dlmalloc               malloc
#define dlmemalign             memalign
#define dlposix_memalign       posix_memalign
#define dlrealloc              realloc
#define dlrealloc_in_place     realloc_in_place
#define dlvalloc               valloc
#define dlpvalloc              pvalloc
#define dlmallinfo             mallinfo
#define dlmallopt              mallopt
#define dlmalloc_trim          malloc_trim
#define dlmalloc_stats         malloc_stats
#define dlmalloc_usable_size   malloc_usable_size
#define dlmalloc_footprint     malloc_footprint
#define dlmalloc_max_footprint malloc_max_footprint
#define dlmalloc_footprint_limit malloc_footprint_limit
#define dlmalloc_set_footprint_limit malloc_set_footprint_limit
#define dlmalloc_inspect_all   malloc_inspect_all
#define dlindependent_calloc   independent_calloc
#define dlindependent_comalloc independent_comalloc
#define dlbulk_free            bulk_free
#endif /* USE_DL_PREFIX */

/*
  malloc(size_t n)
  Returns a pointer to a newly allocated chunk of at least n bytes, or
  null if no space is available, in which case errno is set to ENOMEM
  on ANSI C systems.

  If n is zero, malloc returns a minimum-sized chunk. (The minimum
  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit
  systems.)  Note that size_t is an unsigned type, so calls with
  arguments that would be negative if signed are interpreted as
  requests for huge amounts of space, which will often fail. The
  maximum supported value of n differs across systems, but is in all
  cases less than the maximum representable value of a size_t.
*/
DLMALLOC_EXPORT void* dlmalloc(size_t);

/*
  free(void* p)
  Releases the chunk of memory pointed to by p, that had been previously
  allocated using malloc or a related routine such as realloc.
  It has no effect if p is null. If p was not malloced or already
  freed, free(p) will by default cause the current program to abort.
*/
DLMALLOC_EXPORT void  dlfree(void*);

/*
  calloc(size_t n_elements, size_t element_size);
  Returns a pointer to n_elements * element_size bytes, with all locations
  set to zero.
*/
DLMALLOC_EXPORT void* dlcalloc(size_t, size_t);

/*
  realloc(void* p, size_t n)
  Returns a pointer to a chunk of size n that contains the same data
  as does chunk p up to the minimum of (n, p's size) bytes, or null
  if no space is available.

  The returned pointer may or may not be the same as p. The algorithm
  prefers extending p in most cases when possible, otherwise it
  employs the equivalent of a malloc-copy-free sequence.

  If p is null, realloc is equivalent to malloc.

  If space is not available, realloc returns null, errno is set (if on
  ANSI) and p is NOT freed.

  if n is for fewer bytes than already held by p, the newly unused
  space is lopped off and freed if possible.  realloc with a size
  argument of zero (re)allocates a minimum-sized chunk.

  The old unix realloc convention of allowing the last-free'd chunk
  to be used as an argument to realloc is not supported.
*/
DLMALLOC_EXPORT void* dlrealloc(void*, size_t);

/*
  realloc_in_place(void* p, size_t n)
  Resizes the space allocated for p to size n, only if this can be
  done without moving p (i.e., only if there is adjacent space
  available if n is greater than p's current allocated size, or n is
  less than or equal to p's size). This may be used instead of plain
  realloc if an alternative allocation strategy is needed upon failure
  to expand space; for example, reallocation of a buffer that must be
  memory-aligned or cleared. You can use realloc_in_place to trigger
  these alternatives only when needed.

  Returns p if successful; otherwise null.
*/
DLMALLOC_EXPORT void* dlrealloc_in_place(void*, size_t);

/*
  memalign(size_t alignment, size_t n);
  Returns a pointer to a newly allocated chunk of n bytes, aligned
  in accord with the alignment argument.

  The alignment argument should be a power of two. If the argument is
  not a power of two, the nearest greater power is used.
  8-byte alignment is guaranteed by normal malloc calls, so don't
  bother calling memalign with an argument of 8 or less.

  Overreliance on memalign is a sure way to fragment space.
*/
DLMALLOC_EXPORT void* dlmemalign(size_t, size_t);

/*
  int posix_memalign(void** pp, size_t alignment, size_t n);
  Allocates a chunk of n bytes, aligned in accord with the alignment
  argument. Differs from memalign only in that it (1) assigns the
  allocated memory to *pp rather than returning it, (2) fails and
  returns EINVAL if the alignment is not a power of two (3) fails and
  returns ENOMEM if memory cannot be allocated.
*/
DLMALLOC_EXPORT int dlposix_memalign(void**, size_t, size_t);

/*
  valloc(size_t n);
  Equivalent to memalign(pagesize, n), where pagesize is the page
  size of the system. If the pagesize is unknown, 4096 is used.
*/
DLMALLOC_EXPORT void* dlvalloc(size_t);

/*
  mallopt(int parameter_number, int parameter_value)
  Sets tunable parameters The format is to provide a
  (parameter-number, parameter-value) pair.  mallopt then sets the
  corresponding parameter to the argument value if it can (i.e., so
  long as the value is meaningful), and returns 1 if successful else
  0.  To workaround the fact that mallopt is specified to use int,
  not size_t parameters, the value -1 is specially treated as the
  maximum unsigned size_t value.

  SVID/XPG/ANSI defines four standard param numbers for mallopt,
  normally defined in malloc.h.  None of these are use in this malloc,
  so setting them has no effect. But this malloc also supports other
  options in mallopt. See below for details.  Briefly, supported
  parameters are as follows (listed defaults are for "typical"
  configurations).

  Symbol            param #  default    allowed param values
  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1 disables)
  M_GRANULARITY        -2     page size   any power of 2 >= page size
  M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)
*/
DLMALLOC_EXPORT int dlmallopt(int, int);

/*
  malloc_footprint();
  Returns the number of bytes obtained from the system.  The total
  number of bytes allocated by malloc, realloc etc., is less than this
  value. Unlike mallinfo, this function returns only a precomputed
  result, so can be called frequently to monitor memory consumption.
  Even if locks are otherwise defined, this function does not use them,
  so results might not be up to date.
*/
DLMALLOC_EXPORT size_t dlmalloc_footprint(void);

/*
  malloc_max_footprint();
  Returns the maximum number of bytes obtained from the system. This
  value will be greater than current footprint if deallocated space
  has been reclaimed by the system. The peak number of bytes allocated
  by malloc, realloc etc., is less than this value. Unlike mallinfo,
  this function returns only a precomputed result, so can be called
  frequently to monitor memory consumption.  Even if locks are
  otherwise defined, this function does not use them, so results might
  not be up to date.
*/
DLMALLOC_EXPORT size_t dlmalloc_max_footprint(void);

/*
  malloc_footprint_limit();
  Returns the number of bytes that the heap is allowed to obtain from
  the system, returning the last value returned by
  malloc_set_footprint_limit, or the maximum size_t value if
  never set. The returned value reflects a permission. There is no
  guarantee that this number of bytes can actually be obtained from
  the system.
*/
DLMALLOC_EXPORT size_t dlmalloc_footprint_limit();

/*
  malloc_set_footprint_limit();
  Sets the maximum number of bytes to obtain from the system, causing
  failure returns from malloc and related functions upon attempts to
  exceed this value. The argument value may be subject to page
  rounding to an enforceable limit; this actual value is returned.
  Using an argument of the maximum possible size_t effectively
  disables checks. If the argument is less than or equal to the
  current malloc_footprint, then all future allocations that require
  additional system memory will fail. However, invocation cannot
  retroactively deallocate existing used memory.
*/
DLMALLOC_EXPORT size_t dlmalloc_set_footprint_limit(size_t bytes);

#if MALLOC_INSPECT_ALL
/*
  malloc_inspect_all(void(*handler)(void *start,
                                    void *end,
                                    size_t used_bytes,
                                    void* callback_arg),
                      void* arg);
  Traverses the heap and calls the given handler for each managed
  region, skipping all bytes that are (or may be) used for bookkeeping
  purposes.  Traversal does not include include chunks that have been
  directly memory mapped. Each reported region begins at the start
  address, and continues up to but not including the end address.  The
  first used_bytes of the region contain allocated data. If
  used_bytes is zero, the region is unallocated. The handler is
  invoked with the given callback argument. If locks are defined, they
  are held during the entire traversal. It is a bad idea to invoke
  other malloc functions from within the handler.

  For example, to count the number of in-use chunks with size greater
  than 1000, you could write:
  static int count = 0;
  void count_chunks(void* start, void* end, size_t used, void* arg) {
    if (used >= 1000) ++count;
  }
  then:
    malloc_inspect_all(count_chunks, NULL);

  malloc_inspect_all is compiled only if MALLOC_INSPECT_ALL is defined.
*/
DLMALLOC_EXPORT void dlmalloc_inspect_all(void(*handler)(void*, void *, size_t, void*),
                           void* arg);

#endif /* MALLOC_INSPECT_ALL */

#if !NO_MALLINFO
/*
  mallinfo()
  Returns (by copy) a struct containing various summary statistics:

  arena:     current total non-mmapped bytes allocated from system
  ordblks:   the number of free chunks
  smblks:    always zero.
  hblks:     current number of mmapped regions
  hblkhd:    total bytes held in mmapped regions
  usmblks:   the maximum total allocated space. This will be greater
                than current total if trimming has occurred.
  fsmblks:   always zero
  uordblks:  current total allocated space (normal or mmapped)
  fordblks:  total free space
  keepcost:  the maximum number of bytes that could ideally be released
               back to system via malloc_trim. ("ideally" means that
               it ignores page restrictions etc.)

  Because these fields are ints, but internal bookkeeping may
  be kept as longs, the reported values may wrap around zero and
  thus be inaccurate.
*/
DLMALLOC_EXPORT struct mallinfo dlmallinfo(void);
#endif /* NO_MALLINFO */

/*
  independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);

  independent_calloc is similar to calloc, but instead of returning a
  single cleared space, it returns an array of pointers to n_elements
  independent elements that can hold contents of size elem_size, each
  of which starts out cleared, and can be independently freed,
  realloc'ed etc. The elements are guaranteed to be adjacently
  allocated (this is not guaranteed to occur with multiple callocs or
  mallocs), which may also improve cache locality in some
  applications.

  The "chunks" argument is optional (i.e., may be null, which is
  probably the most typical usage). If it is null, the returned array
  is itself dynamically allocated and should also be freed when it is
  no longer needed. Otherwise, the chunks array must be of at least
  n_elements in length. It is filled in with the pointers to the
  chunks.

  In either case, independent_calloc returns this pointer array, or
  null if the allocation failed.  If n_elements is zero and "chunks"
  is null, it returns a chunk representing an array with zero elements
  (which should be freed if not wanted).

  Each element must be freed when it is no longer needed. This can be
  done all at once using bulk_free.

  independent_calloc simplifies and speeds up implementations of many
  kinds of pools.  It may also be useful when constructing large data
  structures that initially have a fixed number of fixed-sized nodes,
  but the number is not known at compile time, and some of the nodes
  may later need to be freed. For example:

  struct Node { int item; struct Node* next; };

  struct Node* build_list() {
    struct Node** pool;
    int n = read_number_of_nodes_needed();
    if (n <= 0) return 0;
    pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);
    if (pool == 0) die();
    // organize into a linked list...
    struct Node* first = pool[0];
    for (i = 0; i < n-1; ++i)
      pool[i]->next = pool[i+1];
    free(pool);     // Can now free the array (or not, if it is needed later)
    return first;
  }
*/
DLMALLOC_EXPORT void** dlindependent_calloc(size_t, size_t, void**);

/*
  independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);

  independent_comalloc allocates, all at once, a set of n_elements
  chunks with sizes indicated in the "sizes" array.    It returns
  an array of pointers to these elements, each of which can be
  independently freed, realloc'ed etc. The elements are guaranteed to
  be adjacently allocated (this is not guaranteed to occur with
  multiple callocs or mallocs), which may also improve cache locality
  in some applications.

  The "chunks" argument is optional (i.e., may be null). If it is null
  the returned array is itself dynamically allocated and should also
  be freed when it is no longer needed. Otherwise, the chunks array
  must be of at least n_elements in length. It is filled in with the
  pointers to the chunks.

  In either case, independent_comalloc returns this pointer array, or
  null if the allocation failed.  If n_elements is zero and chunks is
  null, it returns a chunk representing an array with zero elements
  (which should be freed if not wanted).

  Each element must be freed when it is no longer needed. This can be
  done all at once using bulk_free.

  independent_comallac differs from independent_calloc in that each
  element may have a different size, and also that it does not
  automatically clear elements.

  independent_comalloc can be used to speed up allocation in cases
  where several structs or objects must always be allocated at the
  same time.  For example:

  struct Head { ... }
  struct Foot { ... }

  void send_message(char* msg) {
    int msglen = strlen(msg);
    size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };
    void* chunks[3];
    if (independent_comalloc(3, sizes, chunks) == 0)
      die();
    struct Head* head = (struct Head*)(chunks[0]);
    char*        body = (char*)(chunks[1]);
    struct Foot* foot = (struct Foot*)(chunks[2]);
    // ...
  }

  In general though, independent_comalloc is worth using only for
  larger values of n_elements. For small values, you probably won't
  detect enough difference from series of malloc calls to bother.

  Overuse of independent_comalloc can increase overall memory usage,
  since it cannot reuse existing noncontiguous small chunks that
  might be available for some of the elements.
*/
DLMALLOC_EXPORT void** dlindependent_comalloc(size_t, size_t*, void**);

/*
  bulk_free(void* array[], size_t n_elements)
  Frees and clears (sets to null) each non-null pointer in the given
  array.  This is likely to be faster than freeing them one-by-one.
  If footers are used, pointers that have been allocated in different
  mspaces are not freed or cleared, and the count of all such pointers
  is returned.  For large arrays of pointers with poor locality, it
  may be worthwhile to sort this array before calling bulk_free.
*/
DLMALLOC_EXPORT size_t  dlbulk_free(void**, size_t n_elements);

/*
  pvalloc(size_t n);
  Equivalent to valloc(minimum-page-that-holds(n)), that is,
  round up n to nearest pagesize.
 */
DLMALLOC_EXPORT void*  dlpvalloc(size_t);

/*
  malloc_trim(size_t pad);

  If possible, gives memory back to the system (via negative arguments
  to sbrk) if there is unused memory at the `high' end of the malloc
  pool or in unused MMAP segments. You can call this after freeing
  large blocks of memory to potentially reduce the system-level memory
  requirements of a program. However, it cannot guarantee to reduce
  memory. Under some allocation patterns, some large free blocks of
  memory will be locked between two used chunks, so they cannot be
  given back to the system.

  The `pad' argument to malloc_trim represents the amount of free
  trailing space to leave untrimmed. If this argument is zero, only
  the minimum amount of memory to maintain internal data structures
  will be left. Non-zero arguments can be supplied to maintain enough
  trailing space to service future expected allocations without having
  to re-obtain memory from the system.

  Malloc_trim returns 1 if it actually released any memory, else 0.
*/
DLMALLOC_EXPORT int  dlmalloc_trim(size_t);

/*
  malloc_stats();
  Prints on stderr the amount of space obtained from the system (both
  via sbrk and mmap), the maximum amount (which may be more than
  current if malloc_trim and/or munmap got called), and the current
  number of bytes allocated via malloc (or realloc, etc) but not yet
  freed. Note that this is the number of bytes allocated, not the
  number requested. It will be larger than the number requested
  because of alignment and bookkeeping overhead. Because it includes
  alignment wastage as being in use, this figure may be greater than
  zero even when no user-level chunks are allocated.

  The reported current and maximum system memory can be inaccurate if
  a program makes other calls to system memory allocation functions
  (normally sbrk) outside of malloc.

  malloc_stats prints only the most commonly interesting statistics.
  More information can be obtained by calling mallinfo.
*/
DLMALLOC_EXPORT void  dlmalloc_stats(void);

/*
  malloc_usable_size(void* p);

  Returns the number of bytes you can actually use in
  an allocated chunk, which may be more than you requested (although
  often not) due to alignment and minimum size constraints.
  You can use this many bytes without worrying about
  overwriting other allocated objects. This is not a particularly great
  programming practice. malloc_usable_size can be more useful in
  debugging and assertions, for example:

  p = malloc(n);
  assert(malloc_usable_size(p) >= 256);
*/
size_t dlmalloc_usable_size(void*);

#endif /* ONLY_MSPACES */

#if MSPACES

/*
  mspace is an opaque type representing an independent
  region of space that supports mspace_malloc, etc.
*/
typedef void* mspace;

/*
  create_mspace creates and returns a new independent space with the
  given initial capacity, or, if 0, the default granularity size.  It
  returns null if there is no system memory available to create the
  space.  If argument locked is non-zero, the space uses a separate
  lock to control access. The capacity of the space will grow
  dynamically as needed to service mspace_malloc requests.  You can
  control the sizes of incremental increases of this space by
  compiling with a different DEFAULT_GRANULARITY or dynamically
  setting with mallopt(M_GRANULARITY, value).
*/
DLMALLOC_EXPORT mspace create_mspace(size_t capacity, int locked);

/*
  destroy_mspace destroys the given space, and attempts to return all
  of its memory back to the system, returning the total number of
  bytes freed. After destruction, the results of access to all memory
  used by the space become undefined.
*/
DLMALLOC_EXPORT size_t destroy_mspace(mspace msp);

/*
  create_mspace_with_base uses the memory supplied as the initial base
  of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this
  space is used for bookkeeping, so the capacity must be at least this
  large. (Otherwise 0 is returned.) When this initial space is
  exhausted, additional memory will be obtained from the system.
  Destroying this space will deallocate all additionally allocated
  space (if possible) but not the initial base.
*/
DLMALLOC_EXPORT mspace create_mspace_with_base(void* base, size_t capacity, int locked);

/*
  mspace_track_large_chunks controls whether requests for large chunks
  are allocated in their own untracked mmapped regions, separate from
  others in this mspace. By default large chunks are not tracked,
  which reduces fragmentation. However, such chunks are not
  necessarily released to the system upon destroy_mspace.  Enabling
  tracking by setting to true may increase fragmentation, but avoids
  leakage when relying on destroy_mspace to release all memory
  allocated using this space.  The function returns the previous
  setting.
*/
DLMALLOC_EXPORT int mspace_track_large_chunks(mspace msp, int enable);


/*
  mspace_malloc behaves as malloc, but operates within
  the given space.
*/
DLMALLOC_EXPORT void* mspace_malloc(mspace msp, size_t bytes);

/*
  mspace_free behaves as free, but operates within
  the given space.

  If compiled with FOOTERS==1, mspace_free is not actually needed.
  free may be called instead of mspace_free because freed chunks from
  any space are handled by their originating spaces.
*/
DLMALLOC_EXPORT void mspace_free(mspace msp, void* mem);

/*
  mspace_realloc behaves as realloc, but operates within
  the given space.

  If compiled with FOOTERS==1, mspace_realloc is not actually
  needed.  realloc may be called instead of mspace_realloc because
  realloced chunks from any space are handled by their originating
  spaces.
*/
DLMALLOC_EXPORT void* mspace_realloc(mspace msp, void* mem, size_t newsize);

/*
  mspace_calloc behaves as calloc, but operates within
  the given space.
*/
DLMALLOC_EXPORT void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);

/*
  mspace_memalign behaves as memalign, but operates within
  the given space.
*/
DLMALLOC_EXPORT void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);

/*
  mspace_independent_calloc behaves as independent_calloc, but
  operates within the given space.
*/
DLMALLOC_EXPORT void** mspace_independent_calloc(mspace msp, size_t n_elements,
                                 size_t elem_size, void* chunks[]);

/*
  mspace_independent_comalloc behaves as independent_comalloc, but
  operates within the given space.
*/
DLMALLOC_EXPORT void** mspace_independent_comalloc(mspace msp, size_t n_elements,
                                   size_t sizes[], void* chunks[]);

/*
  mspace_footprint() returns the number of bytes obtained from the
  system for this space.
*/
DLMALLOC_EXPORT size_t mspace_footprint(mspace msp);

/*
  mspace_max_footprint() returns the peak number of bytes obtained from the
  system for this space.
*/
DLMALLOC_EXPORT size_t mspace_max_footprint(mspace msp);


#if !NO_MALLINFO
/*
  mspace_mallinfo behaves as mallinfo, but reports properties of
  the given space.
*/
DLMALLOC_EXPORT struct mallinfo mspace_mallinfo(mspace msp);
#endif /* NO_MALLINFO */

/*
  malloc_usable_size(void* p) behaves the same as malloc_usable_size;
*/
DLMALLOC_EXPORT size_t mspace_usable_size(const void* mem);

/*
  mspace_malloc_stats behaves as malloc_stats, but reports
  properties of the given space.
*/
DLMALLOC_EXPORT void mspace_malloc_stats(mspace msp);

/*
  mspace_trim behaves as malloc_trim, but
  operates within the given space.
*/
DLMALLOC_EXPORT int mspace_trim(mspace msp, size_t pad);

/*
  An alias for mallopt.
*/
DLMALLOC_EXPORT int mspace_mallopt(int, int);

#endif /* MSPACES */

#ifdef __cplusplus
}  /* end of extern "C" */
#endif /* __cplusplus */

/*
  ========================================================================
  To make a fully customizable malloc.h header file, cut everything
  above this line, put into file malloc.h, edit to suit, and #include it
  on the next line, as well as in programs that use this malloc.
  ========================================================================
*/

/* #include "malloc.h" */

/*------------------------------ internal #includes ---------------------- */

#ifdef _MSC_VER
#pragma warning( disable : 4146 ) /* no "unsigned" warnings */
#endif /* _MSC_VER */
#if !NO_MALLOC_STATS
#include <stdio.h>       /* for printing in malloc_stats */
#endif /* NO_MALLOC_STATS */
#ifndef LACKS_ERRNO_H
#include <errno.h>       /* for MALLOC_FAILURE_ACTION */
#endif /* LACKS_ERRNO_H */
#ifdef DEBUG
#if ABORT_ON_ASSERT_FAILURE
#undef assert
#define assert(x) if(!(x)) ABORT
#else /* ABORT_ON_ASSERT_FAILURE */
#include <assert.h>
#endif /* ABORT_ON_ASSERT_FAILURE */
#else  /* DEBUG */
#ifndef assert
#define assert(x)
#endif
#define DEBUG 0
#endif /* DEBUG */
#if !defined(WIN32) && !defined(LACKS_TIME_H)
#include <time.h>        /* for magic initialization */
#endif /* WIN32 */
#ifndef LACKS_STDLIB_H
#include <stdlib.h>      /* for abort() */
#endif /* LACKS_STDLIB_H */
#ifndef LACKS_STRING_H
#include <string.h>      /* for memset etc */
#endif  /* LACKS_STRING_H */
#if USE_BUILTIN_FFS
#ifndef LACKS_STRINGS_H
#include <strings.h>     /* for ffs */
#endif /* LACKS_STRINGS_H */
#endif /* USE_BUILTIN_FFS */
#if HAVE_MMAP
#ifndef LACKS_SYS_MMAN_H
/* On some versions of linux, mremap decl in mman.h needs __USE_GNU set */
#if (defined(linux) && !defined(__USE_GNU))
#define __USE_GNU 1
#include <sys/mman.h>    /* for mmap */
#undef __USE_GNU
#else
#include <sys/mman.h>    /* for mmap */
#endif /* linux */
#endif /* LACKS_SYS_MMAN_H */
#ifndef LACKS_FCNTL_H
#include <fcntl.h>
#endif /* LACKS_FCNTL_H */
#endif /* HAVE_MMAP */
#ifndef LACKS_UNISTD_H
#include <unistd.h>     /* for sbrk, sysconf */
#else /* LACKS_UNISTD_H */
#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
extern void*     sbrk(ptrdiff_t);
#endif /* FreeBSD etc */
#endif /* LACKS_UNISTD_H */

/* Declarations for locking */
#if USE_LOCKS
#ifndef WIN32
#if defined (__SVR4) && defined (__sun)  /* solaris */
#include <thread.h>
#elif !defined(LACKS_SCHED_H)
#include <sched.h>
#endif /* solaris or LACKS_SCHED_H */
#if (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0) || !USE_SPIN_LOCKS
#include <pthread.h>
#endif /* USE_RECURSIVE_LOCKS ... */
#elif defined(_MSC_VER)
#ifndef _M_AMD64
/* These are already defined on AMD64 builds */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
LONG __cdecl _InterlockedCompareExchange(LONG volatile *Dest, LONG Exchange, LONG Comp);
LONG __cdecl _InterlockedExchange(LONG volatile *Target, LONG Value);
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* _M_AMD64 */
#pragma intrinsic (_InterlockedCompareExchange)
#pragma intrinsic (_InterlockedExchange)
#define interlockedcompareexchange _InterlockedCompareExchange
#define interlockedexchange _InterlockedExchange
#elif defined(WIN32) && defined(__GNUC__)
#define interlockedcompareexchange(a, b, c) __sync_val_compare_and_swap(a, c, b)
#define interlockedexchange __sync_lock_test_and_set
#endif /* Win32 */
#else /* USE_LOCKS */
#endif /* USE_LOCKS */

#ifndef LOCK_AT_FORK
#define LOCK_AT_FORK 0
#endif

/* Declarations for bit scanning on win32 */
#if defined(_MSC_VER) && _MSC_VER>=1300
#ifndef BitScanForward /* Try to avoid pulling in WinNT.h */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
unsigned char _BitScanForward(unsigned long *index, unsigned long mask);
unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#endif /* BitScanForward */
#endif /* defined(_MSC_VER) && _MSC_VER>=1300 */

#ifndef WIN32
#ifndef malloc_getpagesize
#  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
#    ifndef _SC_PAGE_SIZE
#      define _SC_PAGE_SIZE _SC_PAGESIZE
#    endif
#  endif
#  ifdef _SC_PAGE_SIZE
#    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
#  else
#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
       extern size_t getpagesize();
#      define malloc_getpagesize getpagesize()
#    else
#      ifdef WIN32 /* use supplied emulation of getpagesize */
#        define malloc_getpagesize getpagesize()
#      else
#        ifndef LACKS_SYS_PARAM_H
#          include <sys/param.h>
#        endif
#        ifdef EXEC_PAGESIZE
#          define malloc_getpagesize EXEC_PAGESIZE
#        else
#          ifdef NBPG
#            ifndef CLSIZE
#              define malloc_getpagesize NBPG
#            else
#              define malloc_getpagesize (NBPG * CLSIZE)
#            endif
#          else
#            ifdef NBPC
#              define malloc_getpagesize NBPC
#            else
#              ifdef PAGESIZE
#                define malloc_getpagesize PAGESIZE
#              else /* just guess */
#                define malloc_getpagesize ((size_t)4096U)
#              endif
#            endif
#          endif
#        endif
#      endif
#    endif
#  endif
#endif
#endif

/* ------------------- size_t and alignment properties -------------------- */

/* The byte and bit size of a size_t */
#define SIZE_T_SIZE         (sizeof(size_t))
#define SIZE_T_BITSIZE      (sizeof(size_t) << 3)

/* Some constants coerced to size_t */
/* Annoying but necessary to avoid errors on some platforms */
#define SIZE_T_ZERO         ((size_t)0)
#define SIZE_T_ONE          ((size_t)1)
#define SIZE_T_TWO          ((size_t)2)
#define SIZE_T_FOUR         ((size_t)4)
#define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)
#define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)
#define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
#define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)

/* The bit mask value corresponding to MALLOC_ALIGNMENT */
#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)

/* True if address a has acceptable alignment */
#define is_aligned(A)       (((size_t)((A)) & (CHUNK_ALIGN_MASK)) == 0)

/* the number of bytes to offset an address to align it */
#define align_offset(A)\
 ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 :\
  ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))

/* -------------------------- MMAP preliminaries ------------------------- */

/*
   If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and
   checks to fail so compiler optimizer can delete code rather than
   using so many "#if"s.
*/


/* MORECORE and MMAP must return MFAIL on failure */
#define MFAIL                ((void*)(MAX_SIZE_T))
#define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */

#if HAVE_MMAP

#ifndef WIN32
#define MUNMAP_DEFAULT(a, s)  munmap((a), (s))
#define MMAP_PROT            (PROT_READ|PROT_WRITE)
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS        MAP_ANON
#endif /* MAP_ANON */
#ifdef MAP_ANONYMOUS
#define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)
#define MMAP_DEFAULT(s)       mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
#else /* MAP_ANONYMOUS */
/*
   Nearly all versions of mmap support MAP_ANONYMOUS, so the following
   is unlikely to be needed, but is supplied just in case.
*/
#define MMAP_FLAGS           (MAP_PRIVATE)
static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */
#define MMAP_DEFAULT(s) ((dev_zero_fd < 0) ? \
           (dev_zero_fd = open("/dev/zero", O_RDWR), \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
#endif /* MAP_ANONYMOUS */

#define DIRECT_MMAP_DEFAULT(s) MMAP_DEFAULT(s)

#else /* WIN32 */

/* Win32 MMAP via VirtualAlloc */
static FORCEINLINE void* win32mmap(size_t size) {
  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
  return (ptr != 0)? ptr: MFAIL;
}

/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
static FORCEINLINE void* win32direct_mmap(size_t size) {
  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
                           PAGE_READWRITE);
  return (ptr != 0)? ptr: MFAIL;
}

/* This function supports releasing coalesed segments */
static FORCEINLINE int win32munmap(void* ptr, size_t size) {
  MEMORY_BASIC_INFORMATION minfo;
  char* cptr = (char*)ptr;
  while (size) {
    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)
      return -1;
    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||
        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
      return -1;
    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)
      return -1;
    cptr += minfo.RegionSize;
    size -= minfo.RegionSize;
  }
  return 0;
}

#define MMAP_DEFAULT(s)             win32mmap(s)
#define MUNMAP_DEFAULT(a, s)        win32munmap((a), (s))
#define DIRECT_MMAP_DEFAULT(s)      win32direct_mmap(s)
#endif /* WIN32 */
#endif /* HAVE_MMAP */

#if HAVE_MREMAP
#ifndef WIN32
#define MREMAP_DEFAULT(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
#endif /* WIN32 */
#endif /* HAVE_MREMAP */

/**
 * Define CALL_MORECORE
 */
#if HAVE_MORECORE
    #ifdef MORECORE
        #define CALL_MORECORE(S)    MORECORE(S)
    #else  /* MORECORE */
        #define CALL_MORECORE(S)    MORECORE_DEFAULT(S)
    #endif /* MORECORE */
#else  /* HAVE_MORECORE */
    #define CALL_MORECORE(S)        MFAIL
#endif /* HAVE_MORECORE */

/**
 * Define CALL_MMAP/CALL_MUNMAP/CALL_DIRECT_MMAP
 */
#if HAVE_MMAP
    #define USE_MMAP_BIT            (SIZE_T_ONE)

    #ifdef MMAP
        #define CALL_MMAP(s)        MMAP(s)
    #else /* MMAP */
        #define CALL_MMAP(s)        MMAP_DEFAULT(s)
    #endif /* MMAP */
    #ifdef MUNMAP
        #define CALL_MUNMAP(a, s)   MUNMAP((a), (s))
    #else /* MUNMAP */
        #define CALL_MUNMAP(a, s)   MUNMAP_DEFAULT((a), (s))
    #endif /* MUNMAP */
    #ifdef DIRECT_MMAP
        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP(s)
    #else /* DIRECT_MMAP */
        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP_DEFAULT(s)
    #endif /* DIRECT_MMAP */
#else  /* HAVE_MMAP */
    #define USE_MMAP_BIT            (SIZE_T_ZERO)

    #define MMAP(s)                 MFAIL
    #define MUNMAP(a, s)            (-1)
    #define DIRECT_MMAP(s)          MFAIL
    #define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)
    #define CALL_MMAP(s)            MMAP(s)
    #define CALL_MUNMAP(a, s)       MUNMAP((a), (s))
#endif /* HAVE_MMAP */

/**
 * Define CALL_MREMAP
 */
#if HAVE_MMAP && HAVE_MREMAP
    #ifdef MREMAP
        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP((addr), (osz), (nsz), (mv))
    #else /* MREMAP */
        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP_DEFAULT((addr), (osz), (nsz), (mv))
    #endif /* MREMAP */
#else  /* HAVE_MMAP && HAVE_MREMAP */
    #define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL
#endif /* HAVE_MMAP && HAVE_MREMAP */

/* mstate bit set if continguous morecore disabled or failed */
#define USE_NONCONTIGUOUS_BIT (4U)

/* segment bit set in create_mspace_with_base */
#define EXTERN_BIT            (8U)


/* --------------------------- Lock preliminaries ------------------------ */

/*
  When locks are defined, there is one global lock, plus
  one per-mspace lock.

  The global lock_ensures that mparams.magic and other unique
  mparams values are initialized only once. It also protects
  sequences of calls to MORECORE.  In many cases sys_alloc requires
  two calls, that should not be interleaved with calls by other
  threads.  This does not protect against direct calls to MORECORE
  by other threads not using this lock, so there is still code to
  cope the best we can on interference.

  Per-mspace locks surround calls to malloc, free, etc.
  By default, locks are simple non-reentrant mutexes.

  Because lock-protected regions generally have bounded times, it is
  OK to use the supplied simple spinlocks. Spinlocks are likely to
  improve performance for lightly contended applications, but worsen
  performance under heavy contention.

  If USE_LOCKS is > 1, the definitions of lock routines here are
  bypassed, in which case you will need to define the type MLOCK_T,
  and at least INITIAL_LOCK, DESTROY_LOCK, ACQUIRE_LOCK, RELEASE_LOCK
  and TRY_LOCK.  You must also declare a
    static MLOCK_T malloc_global_mutex = { initialization values };.

*/

#if !USE_LOCKS
#define USE_LOCK_BIT               (0U)
#define INITIAL_LOCK(l)            (0)
#define DESTROY_LOCK(l)            (0)
#define ACQUIRE_MALLOC_GLOBAL_LOCK()
#define RELEASE_MALLOC_GLOBAL_LOCK()

#else
#if USE_LOCKS > 1
/* -----------------------  User-defined locks ------------------------ */
/* Define your own lock implementation here */
/* #define INITIAL_LOCK(lk)  ... */
/* #define DESTROY_LOCK(lk)  ... */
/* #define ACQUIRE_LOCK(lk)  ... */
/* #define RELEASE_LOCK(lk)  ... */
/* #define TRY_LOCK(lk) ... */
/* static MLOCK_T malloc_global_mutex = ... */

#elif USE_SPIN_LOCKS

/* First, define CAS_LOCK and CLEAR_LOCK on ints */
/* Note CAS_LOCK defined to return 0 on success */

#if defined(__GNUC__)&& (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
#define CAS_LOCK(sl)     __sync_lock_test_and_set(sl, 1)
#define CLEAR_LOCK(sl)   __sync_lock_release(sl)

#elif (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)))
/* Custom spin locks for older gcc on x86 */
static FORCEINLINE int x86_cas_lock(int *sl) {
  int ret;
  int val = 1;
  int cmp = 0;
  __asm__ __volatile__  ("lock; cmpxchgl %1, %2"
                         : "=a" (ret)
                         : "r" (val), "m" (*(sl)), "0"(cmp)
                         : "memory", "cc");
  return ret;
}

static FORCEINLINE void x86_clear_lock(int* sl) {
  assert(*sl != 0);
  int prev = 0;
  int ret;
  __asm__ __volatile__ ("lock; xchgl %0, %1"
                        : "=r" (ret)
                        : "m" (*(sl)), "0"(prev)
                        : "memory");
}

#define CAS_LOCK(sl)     x86_cas_lock(sl)
#define CLEAR_LOCK(sl)   x86_clear_lock(sl)

#else /* Win32 MSC */
#define CAS_LOCK(sl)     interlockedexchange(sl, (LONG)1)
#define CLEAR_LOCK(sl)   interlockedexchange (sl, (LONG)0)

#endif /* ... gcc spins locks ... */

/* How to yield for a spin lock */
#define SPINS_PER_YIELD       63
#if defined(_MSC_VER)
#define SLEEP_EX_DURATION     50 /* delay for yield/sleep */
#define SPIN_LOCK_YIELD  SleepEx(SLEEP_EX_DURATION, FALSE)
#elif defined (__SVR4) && defined (__sun) /* solaris */
#define SPIN_LOCK_YIELD   thr_yield();
#elif !defined(LACKS_SCHED_H)
#define SPIN_LOCK_YIELD   sched_yield();
#else
#define SPIN_LOCK_YIELD
#endif /* ... yield ... */

#if !defined(USE_RECURSIVE_LOCKS) || USE_RECURSIVE_LOCKS == 0
/* Plain spin locks use single word (embedded in malloc_states) */
static int spin_acquire_lock(int *sl) {
  int spins = 0;
  while (*(volatile int *)sl != 0 || CAS_LOCK(sl)) {
    if ((++spins & SPINS_PER_YIELD) == 0) {
      SPIN_LOCK_YIELD;
    }
  }
  return 0;
}

#define MLOCK_T               int
#define TRY_LOCK(sl)          !CAS_LOCK(sl)
#define RELEASE_LOCK(sl)      CLEAR_LOCK(sl)
#define ACQUIRE_LOCK(sl)      (CAS_LOCK(sl)? spin_acquire_lock(sl) : 0)
#define INITIAL_LOCK(sl)      (*sl = 0)
#define DESTROY_LOCK(sl)      (0)
static MLOCK_T malloc_global_mutex = 0;

#else /* USE_RECURSIVE_LOCKS */
/* types for lock owners */
#ifdef WIN32
#define THREAD_ID_T           DWORD
#define CURRENT_THREAD        GetCurrentThreadId()
#define EQ_OWNER(X,Y)         ((X) == (Y))
#else
/*
  Note: the following assume that pthread_t is a type that can be
  initialized to (casted) zero. If this is not the case, you will need to
  somehow redefine these or not use spin locks.
*/
#define THREAD_ID_T           pthread_t
#define CURRENT_THREAD        pthread_self()
#define EQ_OWNER(X,Y)         pthread_equal(X, Y)
#endif

struct malloc_recursive_lock {
  int sl;
  unsigned int c;
  THREAD_ID_T threadid;
};

#define MLOCK_T  struct malloc_recursive_lock
static MLOCK_T malloc_global_mutex = { 0, 0, (THREAD_ID_T)0};

static FORCEINLINE void recursive_release_lock(MLOCK_T *lk) {
  assert(lk->sl != 0);
  if (--lk->c == 0) {
    CLEAR_LOCK(&lk->sl);
  }
}

static FORCEINLINE int recursive_acquire_lock(MLOCK_T *lk) {
  THREAD_ID_T mythreadid = CURRENT_THREAD;
  int spins = 0;
  for (;;) {
    if (*((volatile int *)(&lk->sl)) == 0) {
      if (!CAS_LOCK(&lk->sl)) {
        lk->threadid = mythreadid;
        lk->c = 1;
        return 0;
      }
    }
    else if (EQ_OWNER(lk->threadid, mythreadid)) {
      ++lk->c;
      return 0;
    }
    if ((++spins & SPINS_PER_YIELD) == 0) {
      SPIN_LOCK_YIELD;
    }
  }
}

static FORCEINLINE int recursive_try_lock(MLOCK_T *lk) {
  THREAD_ID_T mythreadid = CURRENT_THREAD;
  if (*((volatile int *)(&lk->sl)) == 0) {
    if (!CAS_LOCK(&lk->sl)) {
      lk->threadid = mythreadid;
      lk->c = 1;
      return 1;
    }
  }
  else if (EQ_OWNER(lk->threadid, mythreadid)) {
    ++lk->c;
    return 1;
  }
  return 0;
}

#define RELEASE_LOCK(lk)      recursive_release_lock(lk)
#define TRY_LOCK(lk)          recursive_try_lock(lk)
#define ACQUIRE_LOCK(lk)      recursive_acquire_lock(lk)
#define INITIAL_LOCK(lk)      ((lk)->threadid = (THREAD_ID_T)0, (lk)->sl = 0, (lk)->c = 0)
#define DESTROY_LOCK(lk)      (0)
#endif /* USE_RECURSIVE_LOCKS */

#elif defined(WIN32) /* Win32 critical sections */
#define MLOCK_T               CRITICAL_SECTION
#define ACQUIRE_LOCK(lk)      (EnterCriticalSection(lk), 0)
#define RELEASE_LOCK(lk)      LeaveCriticalSection(lk)
#define TRY_LOCK(lk)          TryEnterCriticalSection(lk)
#define INITIAL_LOCK(lk)      (!InitializeCriticalSectionAndSpinCount((lk), 0x80000000|4000))
#define DESTROY_LOCK(lk)      (DeleteCriticalSection(lk), 0)
#define NEED_GLOBAL_LOCK_INIT

static MLOCK_T malloc_global_mutex;
static volatile LONG malloc_global_mutex_status;

/* Use spin loop to initialize global lock */
static void init_malloc_global_mutex() {
  for (;;) {
    long stat = malloc_global_mutex_status;
    if (stat > 0)
      return;
    /* transition to < 0 while initializing, then to > 0) */
    if (stat == 0 &&
        interlockedcompareexchange(&malloc_global_mutex_status, (LONG)-1, (LONG)0) == 0) {
      InitializeCriticalSection(&malloc_global_mutex);
      interlockedexchange(&malloc_global_mutex_status, (LONG)1);
      return;
    }
    SleepEx(0, FALSE);
  }
}

#else /* pthreads-based locks */
#define MLOCK_T               pthread_mutex_t
#define ACQUIRE_LOCK(lk)      pthread_mutex_lock(lk)
#define RELEASE_LOCK(lk)      pthread_mutex_unlock(lk)
#define TRY_LOCK(lk)          (!pthread_mutex_trylock(lk))
#define INITIAL_LOCK(lk)      pthread_init_lock(lk)
#define DESTROY_LOCK(lk)      pthread_mutex_destroy(lk)

#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0 && defined(linux) && !defined(PTHREAD_MUTEX_RECURSIVE)
/* Cope with old-style linux recursive lock initialization by adding */
/* skipped internal declaration from pthread.h */
extern int pthread_mutexattr_setkind_np __P ((pthread_mutexattr_t *__attr,
                                              int __kind));
#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
#define pthread_mutexattr_settype(x,y) pthread_mutexattr_setkind_np(x,y)
#endif /* USE_RECURSIVE_LOCKS ... */

static MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;

static int pthread_init_lock (MLOCK_T *lk) {
  pthread_mutexattr_t attr;
  if (pthread_mutexattr_init(&attr)) return 1;
#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0
  if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;
#endif
  if (pthread_mutex_init(lk, &attr)) return 1;
  if (pthread_mutexattr_destroy(&attr)) return 1;
  return 0;
}

#endif /* ... lock types ... */

/* Common code for all lock types */
#define USE_LOCK_BIT               (2U)

#ifndef ACQUIRE_MALLOC_GLOBAL_LOCK
#define ACQUIRE_MALLOC_GLOBAL_LOCK()  ACQUIRE_LOCK(&malloc_global_mutex);
#endif

#ifndef RELEASE_MALLOC_GLOBAL_LOCK
#define RELEASE_MALLOC_GLOBAL_LOCK()  RELEASE_LOCK(&malloc_global_mutex);
#endif

#endif /* USE_LOCKS */

/* -----------------------  Chunk representations ------------------------ */

/*
  (The following includes lightly edited explanations by Colin Plumb.)

  The malloc_chunk declaration below is misleading (but accurate and
  necessary).  It declares a "view" into memory allowing access to
  necessary fields at known offsets from a given base.

  Chunks of memory are maintained using a `boundary tag' method as
  originally described by Knuth.  (See the paper by Paul Wilson
  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
  techniques.)  Sizes of free chunks are stored both in the front of
  each chunk and at the end.  This makes consolidating fragmented
  chunks into bigger chunks fast.  The head fields also hold bits
  representing whether chunks are free or in use.

  Here are some pictures to make it clearer.  They are "exploded" to
  show that the state of a chunk can be thought of as extending from
  the high 31 bits of the head field of its header through the
  prev_foot and PINUSE_BIT bit of the following chunk header.

  A chunk that's in use looks like:

   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           | Size of previous chunk (if P = 0)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
 chunk-> +-                                                             -+
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
       | Size of next chunk (may or may not be in use)               | +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    And if it's free, it looks like this:

   chunk-> +-                                                             -+
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
 chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
       | Size of next chunk (must be in use, or we would have merged)| +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               :
       +- User payload                                                -+
       :                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                                     |0|
                                                                     +-+
  Note that since we always merge adjacent free chunks, the chunks
  adjacent to a free chunk must be in use.

  Given a pointer to a chunk (which can be derived trivially from the
  payload pointer) we can, in O(1) time, find out whether the adjacent
  chunks are free, and if so, unlink them from the lists that they
  are on and merge them with the current chunk.

  Chunks always begin on even word boundaries, so the mem portion
  (which is returned to the user) is also on an even word boundary, and
  thus at least double-word aligned.

  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
  chunk size (which is always a multiple of two words), is an in-use
  bit for the *previous* chunk.  If that bit is *clear*, then the
  word before the current chunk size contains the previous chunk
  size, and can be used to find the front of the previous chunk.
  The very first chunk allocated always has this bit set, preventing
  access to non-existent (or non-owned) memory. If pinuse is set for
  any given chunk, then you CANNOT determine the size of the
  previous chunk, and might even get a memory addressing fault when
  trying to do so.

  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
  the chunk size redundantly records whether the current chunk is
  inuse (unless the chunk is mmapped). This redundancy enables usage
  checks within free and realloc, and reduces indirection when freeing
  and consolidating chunks.

  Each freshly allocated chunk must have both cinuse and pinuse set.
  That is, each allocated chunk borders either a previously allocated
  and still in-use chunk, or the base of its memory arena. This is
  ensured by making all allocations from the `lowest' part of any
  found chunk.  Further, no free chunk physically borders another one,
  so each free chunk is known to be preceded and followed by either
  inuse chunks or the ends of memory.

  Note that the `foot' of the current chunk is actually represented
  as the prev_foot of the NEXT chunk. This makes it easier to
  deal with alignments etc but can be very confusing when trying
  to extend or adapt this code.

  The exceptions to all this are

     1. The special chunk `top' is the top-most available chunk (i.e.,
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.

     3. Chunks allocated via mmap, have both cinuse and pinuse bits
        cleared in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.

*/

struct malloc_chunk {
  size_t               prev_foot;  /* Size of previous chunk (if free).  */
  size_t               head;       /* Size and inuse bits. */
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;
};

typedef struct malloc_chunk  mchunk;
typedef struct malloc_chunk* mchunkptr;
typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */
typedef unsigned int bindex_t;         /* Described below */
typedef unsigned int binmap_t;         /* Described below */
typedef unsigned int flag_t;           /* The type of various bit flag sets */

/* ------------------- Chunks sizes and alignments ----------------------- */

#define MCHUNK_SIZE         (sizeof(mchunk))

#if FOOTERS
#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
#else /* FOOTERS */
#define CHUNK_OVERHEAD      (SIZE_T_SIZE)
#endif /* FOOTERS */

/* MMapped chunks need a second word of overhead ... */
#define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)
/* ... and additional padding for fake next-chunk at foot */
#define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)

/* The smallest size we can malloc is an aligned minimal chunk */
#define MIN_CHUNK_SIZE\
  ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)

/* conversion from malloc headers to user pointers, and back */
#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
/* chunk associated with aligned address A */
#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))

/* Bounds on request (not chunk) sizes. */
#define MAX_REQUEST         ((-MIN_CHUNK_SIZE) << 2)
#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)

/* pad request bytes into a usable size */
#define pad_request(req) \
   (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)

/* pad request, checking for minimum (but not maximum) */
#define request2size(req) \
  (((req) < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))


/* ------------------ Operations on head and foot fields ----------------- */

/*
  The head field of a chunk is or'ed with PINUSE_BIT when previous
  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
  use, unless mmapped, in which case both bits are cleared.

  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
*/

#define PINUSE_BIT          (SIZE_T_ONE)
#define CINUSE_BIT          (SIZE_T_TWO)
#define FLAG4_BIT           (SIZE_T_FOUR)
#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)
#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)

/* Head value for fenceposts */
#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)

/* extraction of fields from head words */
#define cinuse(p)           ((p)->head & CINUSE_BIT)
#define pinuse(p)           ((p)->head & PINUSE_BIT)
#define flag4inuse(p)       ((p)->head & FLAG4_BIT)
#define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)
#define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)

#define chunksize(p)        ((p)->head & ~(FLAG_BITS))

#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)
#define set_flag4(p)        ((p)->head |= FLAG4_BIT)
#define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)

/* Treat space at ptr +/- offset as a chunk */
#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))

/* Ptr to next or previous physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))

/* extract next chunk's pinuse bit */
#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)

/* Get/set size at footer */
#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)
#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))

/* Set size, pinuse bit, and foot */
#define set_size_and_pinuse_of_free_chunk(p, s)\
  ((p)->head = (s|PINUSE_BIT), set_foot(p, s))

/* Set size, pinuse bit, foot, and clear next pinuse */
#define set_free_with_pinuse(p, s, n)\
  (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))

/* Get the internal overhead associated with chunk p */
#define overhead_for(p)\
 (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)

/* Return true if malloced space is not necessarily cleared */
#if MMAP_CLEARS
#define calloc_must_clear(p) (!is_mmapped(p))
#else /* MMAP_CLEARS */
#define calloc_must_clear(p) (1)
#endif /* MMAP_CLEARS */

/* ---------------------- Overlaid data structures ----------------------- */

/*
  When chunks are not in use, they are treated as nodes of either
  lists or trees.

  "Small"  chunks are stored in circular doubly-linked lists, and look
  like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Larger chunks are kept in a form of bitwise digital trees (aka
  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
  free chunks greater than 256 bytes, their size doesn't impose any
  constraints on user chunk sizes.  Each node looks like:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk of same size        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk of same size       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to left child (child[0])                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to right child (child[1])                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to parent                                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             bin index of this chunk                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space                                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
  of the same size are arranged in a circularly-linked list, with only
  the oldest chunk (the next to be used, in our FIFO ordering)
  actually in the tree.  (Tree members are distinguished by a non-null
  parent pointer.)  If a chunk with the same size an an existing node
  is inserted, it is linked off the existing node using pointers that
  work in the same way as fd/bk pointers of small chunks.

  Each tree contains a power of 2 sized range of chunk sizes (the
  smallest is 0x100 <= x < 0x180), which is is divided in half at each
  tree level, with the chunks in the smaller half of the range (0x100
  <= x < 0x140 for the top nose) in the left subtree and the larger
  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,
  done by inspecting individual bits.

  Using these rules, each node's left subtree contains all smaller
  sizes than its right subtree.  However, the node at the root of each
  subtree has no particular ordering relationship to either.  (The
  dividing line between the subtree sizes is based on trie relation.)
  If we remove the last chunk of a given size from the interior of the
  tree, we need to replace it with a leaf node.  The tree ordering
  rules permit a node to be replaced by any leaf below it.

  The smallest chunk in a tree (a common operation in a best-fit
  allocator) can be found by walking a path to the leftmost leaf in
  the tree.  Unlike a usual binary tree, where we follow left child
  pointers until we reach a null, here we follow the right child
  pointer any time the left one is null, until we reach a leaf with
  both child pointers null. The smallest chunk in the tree will be
  somewhere along that path.

  The worst case number of steps to add, find, or remove a node is
  bounded by the number of bits differentiating chunks within
  bins. Under current bin calculations, this ranges from 6 up to 21
  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
  is of course much better.
*/

struct malloc_tree_chunk {
  /* The first four fields must be compatible with malloc_chunk */
  size_t                    prev_foot;
  size_t                    head;
  struct malloc_tree_chunk* fd;
  struct malloc_tree_chunk* bk;

  struct malloc_tree_chunk* child[2];
  struct malloc_tree_chunk* parent;
  bindex_t                  index;
};

typedef struct malloc_tree_chunk  tchunk;
typedef struct malloc_tree_chunk* tchunkptr;
typedef struct malloc_tree_chunk* tbinptr; /* The type of bins of trees */

/* A little helper macro for trees */
#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])

/* ----------------------------- Segments -------------------------------- */

/*
  Each malloc space may include non-contiguous segments, held in a
  list headed by an embedded malloc_segment record representing the
  top-most space. Segments also include flags holding properties of
  the space. Large chunks that are directly allocated by mmap are not
  included in this list. They are instead independently created and
  destroyed without otherwise keeping track of them.

  Segment management mainly comes into play for spaces allocated by
  MMAP.  Any call to MMAP might or might not return memory that is
  adjacent to an existing segment.  MORECORE normally contiguously
  extends the current space, so this space is almost always adjacent,
  which is simpler and faster to deal with. (This is why MORECORE is
  used preferentially to MMAP when both are available -- see
  sys_alloc.)  When allocating using MMAP, we don't use any of the
  hinting mechanisms (inconsistently) supported in various
  implementations of unix mmap, or distinguish reserving from
  committing memory. Instead, we just ask for space, and exploit
  contiguity when we get it.  It is probably possible to do
  better than this on some systems, but no general scheme seems
  to be significantly better.

  Management entails a simpler variant of the consolidation scheme
  used for chunks to reduce fragmentation -- new adjacent memory is
  normally prepended or appended to an existing segment. However,
  there are limitations compared to chunk consolidation that mostly
  reflect the fact that segment processing is relatively infrequent
  (occurring only when getting memory from system) and that we
  don't expect to have huge numbers of segments:

  * Segments are not indexed, so traversal requires linear scans.  (It
    would be possible to index these, but is not worth the extra
    overhead and complexity for most programs on most platforms.)
  * New segments are only appended to old ones when holding top-most
    memory; if they cannot be prepended to others, they are held in
    different segments.

  Except for the top-most segment of an mstate, each segment record
  is kept at the tail of its segment. Segments are added by pushing
  segment records onto the list headed by &mstate.seg for the
  containing mstate.

  Segment flags control allocation/merge/deallocation policies:
  * If EXTERN_BIT set, then we did not allocate this segment,
    and so should not try to deallocate or merge with others.
    (This currently holds only for the initial segment passed
    into create_mspace_with_base.)
  * If USE_MMAP_BIT set, the segment may be merged with
    other surrounding mmapped segments and trimmed/de-allocated
    using munmap.
  * If neither bit is set, then the segment was obtained using
    MORECORE so can be merged with surrounding MORECORE'd segments
    and deallocated/trimmed using MORECORE with negative arguments.
*/

struct malloc_segment {
  char*        base;             /* base address */
  size_t       size;             /* allocated size */
  struct malloc_segment* next;   /* ptr to next segment */
  flag_t       sflags;           /* mmap and extern flag */
};

#define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT)
#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)

typedef struct malloc_segment  msegment;
typedef struct malloc_segment* msegmentptr;

/* ---------------------------- malloc_state ----------------------------- */

/*
   A malloc_state holds all of the bookkeeping for a space.
   The main fields are:

  Top
    The topmost chunk of the currently active segment. Its size is
    cached in topsize.  The actual size of topmost space is
    topsize+TOP_FOOT_SIZE, which includes space reserved for adding
    fenceposts and segment records if necessary when getting more
    space from the system.  The size at which to autotrim top is
    cached from mparams in trim_check, except that it is disabled if
    an autotrim fails.

  Designated victim (dv)
    This is the preferred chunk for servicing small requests that
    don't have exact fits.  It is normally the chunk split off most
    recently to service another small request.  Its size is cached in
    dvsize. The link fields of this chunk are not maintained since it
    is not kept in a bin.

  SmallBins
    An array of bin headers for free chunks.  These bins hold chunks
    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
    chunks of all the same size, spaced 8 bytes apart.  To simplify
    use in double-linked lists, each bin header acts as a malloc_chunk
    pointing to the real first node, if it exists (else pointing to
    itself).  This avoids special-casing for headers.  But to avoid
    waste, we allocate only the fd/bk pointers of bins, and then use
    repositioning tricks to treat these as the fields of a chunk.

  TreeBins
    Treebins are pointers to the roots of trees holding a range of
    sizes. There are 2 equally spaced treebins for each power of two
    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
    larger.

  Bin maps
    There is one bit map for small bins ("smallmap") and one for
    treebins ("treemap).  Each bin sets its bit when non-empty, and
    clears the bit when empty.  Bit operations are then used to avoid
    bin-by-bin searching -- nearly all "search" is done without ever
    looking at bins that won't be selected.  The bit maps
    conservatively use 32 bits per map word, even if on 64bit system.
    For a good description of some of the bit-based techniques used
    here, see Henry S. Warren Jr's book "Hacker's Delight" (and
    supplement at http://hackersdelight.org/). Many of these are
    intended to reduce the branchiness of paths through malloc etc, as
    well as to reduce the number of memory locations read or written.

  Segments
    A list of segments headed by an embedded malloc_segment record
    representing the initial space.

  Address check support
    The least_addr field is the least address ever obtained from
    MORECORE or MMAP. Attempted frees and reallocs of any address less
    than this are trapped (unless INSECURE is defined).

  Magic tag
    A cross-check field that should always hold same value as mparams.magic.

  Max allowed footprint
    The maximum allowed bytes to allocate from system (zero means no limit)

  Flags
    Bits recording whether to use MMAP, locks, or contiguous MORECORE

  Statistics
    Each space keeps track of current and maximum system memory
    obtained via MORECORE or MMAP.

  Trim support
    Fields holding the amount of unused topmost memory that should trigger
    trimming, and a counter to force periodic scanning to release unused
    non-topmost segments.

  Locking
    If USE_LOCKS is defined, the "mutex" lock is acquired and released
    around every public call using this mspace.

  Extension support
    A void* pointer and a size_t field that can be used to help implement
    extensions to this malloc.
*/

/* Bin types, widths and sizes */
#define NSMALLBINS        (32U)
#define NTREEBINS         (32U)
#define SMALLBIN_SHIFT    (3U)
#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)
#define TREEBIN_SHIFT     (8U)
#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)
#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)
#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)

struct malloc_state {
  binmap_t   smallmap;
  binmap_t   treemap;
  size_t     dvsize;
  size_t     topsize;
  char*      least_addr;
  mchunkptr  dv;
  mchunkptr  top;
  size_t     trim_check;
  size_t     release_checks;
  size_t     magic;
  mchunkptr  smallbins[(NSMALLBINS+1)*2];
  tbinptr    treebins[NTREEBINS];
  size_t     footprint;
  size_t     max_footprint;
  size_t     footprint_limit; /* zero means no limit */
  flag_t     mflags;
#if USE_LOCKS
  MLOCK_T    mutex;     /* locate lock among fields that rarely change */
#endif /* USE_LOCKS */
  msegment   seg;
  void*      extp;      /* Unused but available for extensions */
  size_t     exts;
};

typedef struct malloc_state*    mstate;

/* ------------- Global malloc_state and malloc_params ------------------- */

/*
  malloc_params holds global properties, including those that can be
  dynamically set using mallopt. There is a single instance, mparams,
  initialized in init_mparams. Note that the non-zeroness of "magic"
  also serves as an initialization flag.
*/

struct malloc_params {
  size_t magic;
  size_t page_size;
  size_t granularity;
  size_t mmap_threshold;
  size_t trim_threshold;
  flag_t default_mflags;
};

static struct malloc_params mparams;

/* Ensure mparams initialized */
#define ensure_initialization() (void)(mparams.magic != 0 || init_mparams())

#if !ONLY_MSPACES

/* The global malloc_state used for all non-"mspace" calls */
static struct malloc_state _gm_;
#define gm                 (&_gm_)
#define is_global(M)       ((M) == &_gm_)

#endif /* !ONLY_MSPACES */

#define is_initialized(M)  ((M)->top != 0)

/* -------------------------- system alloc setup ------------------------- */

/* Operations on mflags */

#define use_lock(M)           ((M)->mflags &   USE_LOCK_BIT)
#define enable_lock(M)        ((M)->mflags |=  USE_LOCK_BIT)
#if USE_LOCKS
#define disable_lock(M)       ((M)->mflags &= ~USE_LOCK_BIT)
#else
#define disable_lock(M)
#endif

#define use_mmap(M)           ((M)->mflags &   USE_MMAP_BIT)
#define enable_mmap(M)        ((M)->mflags |=  USE_MMAP_BIT)
#if HAVE_MMAP
#define disable_mmap(M)       ((M)->mflags &= ~USE_MMAP_BIT)
#else
#define disable_mmap(M)
#endif

#define use_noncontiguous(M)  ((M)->mflags &   USE_NONCONTIGUOUS_BIT)
#define disable_contiguous(M) ((M)->mflags |=  USE_NONCONTIGUOUS_BIT)

#define set_lock(M,L)\
 ((M)->mflags = (L)?\
  ((M)->mflags | USE_LOCK_BIT) :\
  ((M)->mflags & ~USE_LOCK_BIT))

/* page-align a size */
#define page_align(S)\
 (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))

/* granularity-align a size */
#define granularity_align(S)\
  (((S) + (mparams.granularity - SIZE_T_ONE))\
   & ~(mparams.granularity - SIZE_T_ONE))


/* For mmap, use granularity alignment on windows, else page-align */
#ifdef WIN32
#define mmap_align(S) granularity_align(S)
#else
#define mmap_align(S) page_align(S)
#endif

/* For sys_alloc, enough padding to ensure can malloc request on success */
#define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)

#define is_page_aligned(S)\
   (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
#define is_granularity_aligned(S)\
   (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)

/*  True if segment S holds address A */
#define segment_holds(S, A)\
  ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)

/* Return segment holding given address */
static msegmentptr segment_holding(mstate m, char* addr) {
  msegmentptr sp = &m->seg;
  for (;;) {
    if (addr >= sp->base && addr < sp->base + sp->size)
      return sp;
    if ((sp = sp->next) == 0)
      return 0;
  }
}

/* Return true if segment contains a segment link */
static int has_segment_link(mstate m, msegmentptr ss) {
  msegmentptr sp = &m->seg;
  for (;;) {
    if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)
      return 1;
    if ((sp = sp->next) == 0)
      return 0;
  }
}

#ifndef MORECORE_CANNOT_TRIM
#define should_trim(M,s)  ((s) > (M)->trim_check)
#else  /* MORECORE_CANNOT_TRIM */
#define should_trim(M,s)  (0)
#endif /* MORECORE_CANNOT_TRIM */

/*
  TOP_FOOT_SIZE is padding at the end of a segment, including space
  that may be needed to place segment records and fenceposts when new
  noncontiguous segments are added.
*/
#define TOP_FOOT_SIZE\
  (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)


/* -------------------------------  Hooks -------------------------------- */

/*
  PREACTION should be defined to return 0 on success, and nonzero on
  failure. If you are not using locking, you can redefine these to do
  anything you like.
*/

#if USE_LOCKS
#define PREACTION(M)  ((use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
#define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }
#else /* USE_LOCKS */

#ifndef PREACTION
#define PREACTION(M) (0)
#endif  /* PREACTION */

#ifndef POSTACTION
#define POSTACTION(M)
#endif  /* POSTACTION */

#endif /* USE_LOCKS */

/*
  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
  USAGE_ERROR_ACTION is triggered on detected bad frees and
  reallocs. The argument p is an address that might have triggered the
  fault. It is ignored by the two predefined actions, but might be
  useful in custom actions that try to help diagnose errors.
*/

#if PROCEED_ON_ERROR

/* A count of the number of corruption errors causing resets */
int malloc_corruption_error_count;

/* default corruption action */
static void reset_on_error(mstate m);

#define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)
#define USAGE_ERROR_ACTION(m, p)

#else /* PROCEED_ON_ERROR */

#ifndef CORRUPTION_ERROR_ACTION
#define CORRUPTION_ERROR_ACTION(m) ABORT
#endif /* CORRUPTION_ERROR_ACTION */

#ifndef USAGE_ERROR_ACTION
#define USAGE_ERROR_ACTION(m,p) ABORT
#endif /* USAGE_ERROR_ACTION */

#endif /* PROCEED_ON_ERROR */


/* -------------------------- Debugging setup ---------------------------- */

#if ! DEBUG

#define check_free_chunk(M,P)
#define check_inuse_chunk(M,P)
#define check_malloced_chunk(M,P,N)
#define check_mmapped_chunk(M,P)
#define check_malloc_state(M)
#define check_top_chunk(M,P)

#else /* DEBUG */
#define check_free_chunk(M,P)       do_check_free_chunk(M,P)
#define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)
#define check_top_chunk(M,P)        do_check_top_chunk(M,P)
#define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)
#define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)
#define check_malloc_state(M)       do_check_malloc_state(M)

static void   do_check_any_chunk(mstate m, mchunkptr p);
static void   do_check_top_chunk(mstate m, mchunkptr p);
static void   do_check_mmapped_chunk(mstate m, mchunkptr p);
static void   do_check_inuse_chunk(mstate m, mchunkptr p);
static void   do_check_free_chunk(mstate m, mchunkptr p);
static void   do_check_malloced_chunk(mstate m, void* mem, size_t s);
static void   do_check_tree(mstate m, tchunkptr t);
static void   do_check_treebin(mstate m, bindex_t i);
static void   do_check_smallbin(mstate m, bindex_t i);
static void   do_check_malloc_state(mstate m);
static int    bin_find(mstate m, mchunkptr x);
static size_t traverse_and_check(mstate m);
#endif /* DEBUG */

/* ---------------------------- Indexing Bins ---------------------------- */

#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)
#define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)
#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)
#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))

/* addressing by index. See above about smallbin repositioning */
#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
#define treebin_at(M,i)     (&((M)->treebins[i]))

/* assign tree index for size S to variable I. Use x86 asm if possible  */
#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define compute_tree_index(S, I)\
{\
  unsigned int X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int K = (unsigned) sizeof(X)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(X); \
    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
  }\
}

#elif defined (__INTEL_COMPILER)
#define compute_tree_index(S, I)\
{\
  size_t X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int K = _bit_scan_reverse (X); \
    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
  }\
}

#elif defined(_MSC_VER) && _MSC_VER>=1300
#define compute_tree_index(S, I)\
{\
  size_t X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int K;\
    _BitScanReverse((DWORD *) &K, (DWORD) X);\
    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
  }\
}

#else /* GNUC */
#define compute_tree_index(S, I)\
{\
  size_t X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int Y = (unsigned int)X;\
    unsigned int N = ((Y - 0x100) >> 16) & 8;\
    unsigned int K = (((Y <<= N) - 0x1000) >> 16) & 4;\
    N += K;\
    N += K = (((Y <<= K) - 0x4000) >> 16) & 2;\
    K = 14 - N + ((Y <<= K) >> 15);\
    I = (K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1));\
  }\
}
#endif /* GNUC */

/* Bit representing maximum resolved size in a treebin at i */
#define bit_for_tree_index(i) \
   (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)

/* Shift placing maximum resolved bit in a treebin at i as sign bit */
#define leftshift_for_tree_index(i) \
   ((i == NTREEBINS-1)? 0 : \
    ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))

/* The size of the smallest chunk held in bin with index i */
#define minsize_for_tree_index(i) \
   ((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \
   (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))


/* ------------------------ Operations on bin maps ----------------------- */

/* bit corresponding to given index */
#define idx2bit(i)              ((binmap_t)(1) << (i))

/* Mark/Clear bits with given index */
#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))
#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))
#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))

#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))
#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))
#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))

/* isolate the least set bit of a bitmap */
#define least_bit(x)         ((x) & -(x))

/* mask with all bits to left of least bit of x on */
#define left_bits(x)         ((x<<1) | -(x<<1))

/* mask with all bits to left of or equal to least bit of x on */
#define same_or_left_bits(x) ((x) | -(x))

/* index corresponding to given bit. Use x86 asm if possible */

#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  J = __builtin_ctz(X); \
  I = (bindex_t)J;\
}

#elif defined (__INTEL_COMPILER)
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  J = _bit_scan_forward (X); \
  I = (bindex_t)J;\
}

#elif defined(_MSC_VER) && _MSC_VER>=1300
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  _BitScanForward((DWORD *) &J, X);\
  I = (bindex_t)J;\
}

#elif USE_BUILTIN_FFS
#define compute_bit2idx(X, I) I = ffs(X)-1

#else
#define compute_bit2idx(X, I)\
{\
  unsigned int Y = X - 1;\
  unsigned int K = Y >> (16-4) & 16;\
  unsigned int N = K;        Y >>= K;\
  N += K = Y >> (8-3) &  8;  Y >>= K;\
  N += K = Y >> (4-2) &  4;  Y >>= K;\
  N += K = Y >> (2-1) &  2;  Y >>= K;\
  N += K = Y >> (1-0) &  1;  Y >>= K;\
  I = (bindex_t)(N + Y);\
}
#endif /* GNUC */


/* ----------------------- Runtime Check Support ------------------------- */

/*
  For security, the main invariant is that malloc/free/etc never
  writes to a static address other than malloc_state, unless static
  malloc_state itself has been corrupted, which cannot occur via
  malloc (because of these checks). In essence this means that we
  believe all pointers, sizes, maps etc held in malloc_state, but
  check all of those linked or offsetted from other embedded data
  structures.  These checks are interspersed with main code in a way
  that tends to minimize their run-time cost.

  When FOOTERS is defined, in addition to range checking, we also
  verify footer fields of inuse chunks, which can be used guarantee
  that the mstate controlling malloc/free is intact.  This is a
  streamlined version of the approach described by William Robertson
  et al in "Run-time Detection of Heap-based Overflows" LISA'03
  http://www.usenix.org/events/lisa03/tech/robertson.html The footer
  of an inuse chunk holds the xor of its mstate and a random seed,
  that is checked upon calls to free() and realloc().  This is
  (probabalistically) unguessable from outside the program, but can be
  computed by any code successfully malloc'ing any chunk, so does not
  itself provide protection against code that has already broken
  security through some other means.  Unlike Robertson et al, we
  always dynamically check addresses of all offset chunks (previous,
  next, etc). This turns out to be cheaper than relying on hashes.
*/

#if !INSECURE
/* Check if address a is at least as high as any from MORECORE or MMAP */
#define ok_address(M, a) ((char*)(a) >= (M)->least_addr)
/* Check if address of next chunk n is higher than base chunk p */
#define ok_next(p, n)    ((char*)(p) < (char*)(n))
/* Check if p has inuse status */
#define ok_inuse(p)     is_inuse(p)
/* Check if p has its pinuse bit on */
#define ok_pinuse(p)     pinuse(p)

#else /* !INSECURE */
#define ok_address(M, a) (1)
#define ok_next(b, n)    (1)
#define ok_inuse(p)      (1)
#define ok_pinuse(p)     (1)
#endif /* !INSECURE */

#if (FOOTERS && !INSECURE)
/* Check if (alleged) mstate m has expected magic field */
#define ok_magic(M)      ((M)->magic == mparams.magic)
#else  /* (FOOTERS && !INSECURE) */
#define ok_magic(M)      (1)
#endif /* (FOOTERS && !INSECURE) */

/* In gcc, use __builtin_expect to minimize impact of checks */
#if !INSECURE
#if defined(__GNUC__) && __GNUC__ >= 3
#define RTCHECK(e)  __builtin_expect(e, 1)
#else /* GNUC */
#define RTCHECK(e)  (e)
#endif /* GNUC */
#else /* !INSECURE */
#define RTCHECK(e)  (1)
#endif /* !INSECURE */

/* macros to set up inuse chunks with or without footers */

#if !FOOTERS

#define mark_inuse_foot(M,p,s)

/* Macros for setting head/foot of non-mmapped chunks */

/* Set cinuse bit and pinuse bit of next chunk */
#define set_inuse(M,p,s)\
  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)

/* Set cinuse and pinuse of this chunk and pinuse of next chunk */
#define set_inuse_and_pinuse(M,p,s)\
  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)

/* Set size, cinuse and pinuse bit of this chunk */
#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT))

#else /* FOOTERS */

/* Set foot of inuse chunk to be xor of mstate and seed */
#define mark_inuse_foot(M,p,s)\
  (((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))

#define get_mstate_for(p)\
  ((mstate)(((mchunkptr)((char*)(p) +\
    (chunksize(p))))->prev_foot ^ mparams.magic))

#define set_inuse(M,p,s)\
  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \
  mark_inuse_foot(M,p,s))

#define set_inuse_and_pinuse(M,p,s)\
  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\
 mark_inuse_foot(M,p,s))

#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
  mark_inuse_foot(M, p, s))

#endif /* !FOOTERS */

/* ---------------------------- setting mparams -------------------------- */

#if LOCK_AT_FORK
static void pre_fork(void)         { ACQUIRE_LOCK(&(gm)->mutex); }
static void post_fork_parent(void) { RELEASE_LOCK(&(gm)->mutex); }
static void post_fork_child(void)  { INITIAL_LOCK(&(gm)->mutex); }
#endif /* LOCK_AT_FORK */

/* Initialize mparams */
static int init_mparams(void) {
#ifdef NEED_GLOBAL_LOCK_INIT
  if (malloc_global_mutex_status <= 0)
    init_malloc_global_mutex();
#endif

  ACQUIRE_MALLOC_GLOBAL_LOCK();
  if (mparams.magic == 0) {
    size_t magic;
    size_t psize;
    size_t gsize;

#ifndef WIN32
    psize = malloc_getpagesize;
    gsize = ((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);
#else /* WIN32 */
    {
      SYSTEM_INFO system_info;
      GetSystemInfo(&system_info);
      psize = system_info.dwPageSize;
      gsize = ((DEFAULT_GRANULARITY != 0)?
               DEFAULT_GRANULARITY : system_info.dwAllocationGranularity);
    }
#endif /* WIN32 */

    /* Sanity-check configuration:
       size_t must be unsigned and as wide as pointer type.
       ints must be at least 4 bytes.
       alignment must be at least 8.
       Alignment, min chunk size, and page size must all be powers of 2.
    */
    if ((sizeof(size_t) != sizeof(char*)) ||
        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
        (sizeof(int) < 4)  ||
        (MALLOC_ALIGNMENT < (size_t)8U) ||
        ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||
        ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||
        ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
        ((psize            & (psize-SIZE_T_ONE))            != 0))
      ABORT;
    mparams.granularity = gsize;
    mparams.page_size = psize;
    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
#if MORECORE_CONTIGUOUS
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
#else  /* MORECORE_CONTIGUOUS */
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
#endif /* MORECORE_CONTIGUOUS */

#if !ONLY_MSPACES
    /* Set up lock for main malloc area */
    gm->mflags = mparams.default_mflags;
    (void)INITIAL_LOCK(&gm->mutex);
#endif
#if LOCK_AT_FORK
    pthread_atfork(&pre_fork, &post_fork_parent, &post_fork_child);
#endif

    {
#if USE_DEV_RANDOM
      int fd;
      unsigned char buf[sizeof(size_t)];
      /* Try to use /dev/urandom, else fall back on using time */
      if ((fd = open("/dev/urandom", O_RDONLY)) >= 0 &&
          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
        magic = *((size_t *) buf);
        close(fd);
      }
      else
#endif /* USE_DEV_RANDOM */
#ifdef WIN32
      magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);
#elif defined(LACKS_TIME_H)
      magic = (size_t)&magic ^ (size_t)0x55555555U;
#else
      magic = (size_t)(time(0) ^ (size_t)0x55555555U);
#endif
      magic |= (size_t)8U;    /* ensure nonzero */
      magic &= ~(size_t)7U;   /* improve chances of fault for bad values */
      /* Until memory modes commonly available, use volatile-write */
      (*(volatile size_t *)(&(mparams.magic))) = magic;
    }
  }

  RELEASE_MALLOC_GLOBAL_LOCK();
  return 1;
}

/* support for mallopt */
static int change_mparam(int param_number, int value) {
  size_t val;
  ensure_initialization();
  val = (value == -1)? MAX_SIZE_T : (size_t)value;
  switch(param_number) {
  case M_TRIM_THRESHOLD:
    mparams.trim_threshold = val;
    return 1;
  case M_GRANULARITY:
    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {
      mparams.granularity = val;
      return 1;
    }
    else
      return 0;
  case M_MMAP_THRESHOLD:
    mparams.mmap_threshold = val;
    return 1;
  default:
    return 0;
  }
}

#if DEBUG
/* ------------------------- Debugging Support --------------------------- */

/* Check properties of any chunk, whether free, inuse, mmapped etc  */
static void do_check_any_chunk(mstate m, mchunkptr p) {
  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
  assert(ok_address(m, p));
}

/* Check properties of top chunk */
static void do_check_top_chunk(mstate m, mchunkptr p) {
  msegmentptr sp = segment_holding(m, (char*)p);
  size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */
  assert(sp != 0);
  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
  assert(ok_address(m, p));
  assert(sz == m->topsize);
  assert(sz > 0);
  assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);
  assert(pinuse(p));
  assert(!pinuse(chunk_plus_offset(p, sz)));
}

/* Check properties of (inuse) mmapped chunks */
static void do_check_mmapped_chunk(mstate m, mchunkptr p) {
  size_t  sz = chunksize(p);
  size_t len = (sz + (p->prev_foot) + MMAP_FOOT_PAD);
  assert(is_mmapped(p));
  assert(use_mmap(m));
  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
  assert(ok_address(m, p));
  assert(!is_small(sz));
  assert((len & (mparams.page_size-SIZE_T_ONE)) == 0);
  assert(chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD);
  assert(chunk_plus_offset(p, sz+SIZE_T_SIZE)->head == 0);
}

/* Check properties of inuse chunks */
static void do_check_inuse_chunk(mstate m, mchunkptr p) {
  do_check_any_chunk(m, p);
  assert(is_inuse(p));
  assert(next_pinuse(p));
  /* If not pinuse and not mmapped, previous chunk has OK offset */
  assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);
  if (is_mmapped(p))
    do_check_mmapped_chunk(m, p);
}

/* Check properties of free chunks */
static void do_check_free_chunk(mstate m, mchunkptr p) {
  size_t sz = chunksize(p);
  mchunkptr next = chunk_plus_offset(p, sz);
  do_check_any_chunk(m, p);
  assert(!is_inuse(p));
  assert(!next_pinuse(p));
  assert (!is_mmapped(p));
  if (p != m->dv && p != m->top) {
    if (sz >= MIN_CHUNK_SIZE) {
      assert((sz & CHUNK_ALIGN_MASK) == 0);
      assert(is_aligned(chunk2mem(p)));
      assert(next->prev_foot == sz);
      assert(pinuse(p));
      assert (next == m->top || is_inuse(next));
      assert(p->fd->bk == p);
      assert(p->bk->fd == p);
    }
    else  /* markers are always of size SIZE_T_SIZE */
      assert(sz == SIZE_T_SIZE);
  }
}

/* Check properties of malloced chunks at the point they are malloced */
static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {
  if (mem != 0) {
    mchunkptr p = mem2chunk(mem);
    size_t sz = p->head & ~INUSE_BITS;
    do_check_inuse_chunk(m, p);
    assert((sz & CHUNK_ALIGN_MASK) == 0);
    assert(sz >= MIN_CHUNK_SIZE);
    assert(sz >= s);
    /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
    assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));
  }
}

/* Check a tree and its subtrees.  */
static void do_check_tree(mstate m, tchunkptr t) {
  tchunkptr head = 0;
  tchunkptr u = t;
  bindex_t tindex = t->index;
  size_t tsize = chunksize(t);
  bindex_t idx;
  compute_tree_index(tsize, idx);
  assert(tindex == idx);
  assert(tsize >= MIN_LARGE_SIZE);
  assert(tsize >= minsize_for_tree_index(idx));
  assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));

  do { /* traverse through chain of same-sized nodes */
    do_check_any_chunk(m, ((mchunkptr)u));
    assert(u->index == tindex);
    assert(chunksize(u) == tsize);
    assert(!is_inuse(u));
    assert(!next_pinuse(u));
    assert(u->fd->bk == u);
    assert(u->bk->fd == u);
    if (u->parent == 0) {
      assert(u->child[0] == 0);
      assert(u->child[1] == 0);
    }
    else {
      assert(head == 0); /* only one node on chain has parent */
      head = u;
      assert(u->parent != u);
      assert (u->parent->child[0] == u ||
              u->parent->child[1] == u ||
              *((tbinptr*)(u->parent)) == u);
      if (u->child[0] != 0) {
        assert(u->child[0]->parent == u);
        assert(u->child[0] != u);
        do_check_tree(m, u->child[0]);
      }
      if (u->child[1] != 0) {
        assert(u->child[1]->parent == u);
        assert(u->child[1] != u);
        do_check_tree(m, u->child[1]);
      }
      if (u->child[0] != 0 && u->child[1] != 0) {
        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
      }
    }
    u = u->fd;
  } while (u != t);
  assert(head != 0);
}

/*  Check all the chunks in a treebin.  */
static void do_check_treebin(mstate m, bindex_t i) {
  tbinptr* tb = treebin_at(m, i);
  tchunkptr t = *tb;
  int empty = (m->treemap & (1U << i)) == 0;
  if (t == 0)
    assert(empty);
  if (!empty)
    do_check_tree(m, t);
}

/*  Check all the chunks in a smallbin.  */
static void do_check_smallbin(mstate m, bindex_t i) {
  sbinptr b = smallbin_at(m, i);
  mchunkptr p = b->bk;
  unsigned int empty = (m->smallmap & (1U << i)) == 0;
  if (p == b)
    assert(empty);
  if (!empty) {
    for (; p != b; p = p->bk) {
      size_t size = chunksize(p);
      mchunkptr q;
      /* each chunk claims to be free */
      do_check_free_chunk(m, p);
      /* chunk belongs in bin */
      assert(small_index(size) == i);
      assert(p->bk == b || chunksize(p->bk) == chunksize(p));
      /* chunk is followed by an inuse chunk */
      q = next_chunk(p);
      if (q->head != FENCEPOST_HEAD)
        do_check_inuse_chunk(m, q);
    }
  }
}

/* Find x in a bin. Used in other check functions. */
static int bin_find(mstate m, mchunkptr x) {
  size_t size = chunksize(x);
  if (is_small(size)) {
    bindex_t sidx = small_index(size);
    sbinptr b = smallbin_at(m, sidx);
    if (smallmap_is_marked(m, sidx)) {
      mchunkptr p = b;
      do {
        if (p == x)
          return 1;
      } while ((p = p->fd) != b);
    }
  }
  else {
    bindex_t tidx;
    compute_tree_index(size, tidx);
    if (treemap_is_marked(m, tidx)) {
      tchunkptr t = *treebin_at(m, tidx);
      size_t sizebits = size << leftshift_for_tree_index(tidx);
      while (t != 0 && chunksize(t) != size) {
        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
        sizebits <<= 1;
      }
      if (t != 0) {
        tchunkptr u = t;
        do {
          if (u == (tchunkptr)x)
            return 1;
        } while ((u = u->fd) != t);
      }
    }
  }
  return 0;
}

/* Traverse each chunk and check it; return total */
static size_t traverse_and_check(mstate m) {
  size_t sum = 0;
  if (is_initialized(m)) {
    msegmentptr s = &m->seg;
    sum += m->topsize + TOP_FOOT_SIZE;
    while (s != 0) {
      mchunkptr q = align_as_chunk(s->base);
      mchunkptr lastq = 0;
      assert(pinuse(q));
      while (segment_holds(s, q) &&
             q != m->top && q->head != FENCEPOST_HEAD) {
        sum += chunksize(q);
        if (is_inuse(q)) {
          assert(!bin_find(m, q));
          do_check_inuse_chunk(m, q);
        }
        else {
          assert(q == m->dv || bin_find(m, q));
          assert(lastq == 0 || is_inuse(lastq)); /* Not 2 consecutive free */
          do_check_free_chunk(m, q);
        }
        lastq = q;
        q = next_chunk(q);
      }
      s = s->next;
    }
  }
  return sum;
}


/* Check all properties of malloc_state. */
static void do_check_malloc_state(mstate m) {
  bindex_t i;
  size_t total;
  /* check bins */
  for (i = 0; i < NSMALLBINS; ++i)
    do_check_smallbin(m, i);
  for (i = 0; i < NTREEBINS; ++i)
    do_check_treebin(m, i);

  if (m->dvsize != 0) { /* check dv chunk */
    do_check_any_chunk(m, m->dv);
    assert(m->dvsize == chunksize(m->dv));
    assert(m->dvsize >= MIN_CHUNK_SIZE);
    assert(bin_find(m, m->dv) == 0);
  }

  if (m->top != 0) {   /* check top chunk */
    do_check_top_chunk(m, m->top);
    /*assert(m->topsize == chunksize(m->top)); redundant */
    assert(m->topsize > 0);
    assert(bin_find(m, m->top) == 0);
  }

  total = traverse_and_check(m);
  assert(total <= m->footprint);
  assert(m->footprint <= m->max_footprint);
}
#endif /* DEBUG */

/* ----------------------------- statistics ------------------------------ */

#if !NO_MALLINFO
static struct mallinfo internal_mallinfo(mstate m) {
  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  ensure_initialization();
  if (!PREACTION(m)) {
    check_malloc_state(m);
    if (is_initialized(m)) {
      size_t nfree = SIZE_T_ONE; /* top always free */
      size_t mfree = m->topsize + TOP_FOOT_SIZE;
      size_t sum = mfree;
      msegmentptr s = &m->seg;
      while (s != 0) {
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          size_t sz = chunksize(q);
          sum += sz;
          if (!is_inuse(q)) {
            mfree += sz;
            ++nfree;
          }
          q = next_chunk(q);
        }
        s = s->next;
      }

      nm.arena    = sum;
      nm.ordblks  = nfree;
      nm.hblkhd   = m->footprint - sum;
      nm.usmblks  = m->max_footprint;
      nm.uordblks = m->footprint - mfree;
      nm.fordblks = mfree;
      nm.keepcost = m->topsize;
    }

    POSTACTION(m);
  }
  return nm;
}
#endif /* !NO_MALLINFO */

#if !NO_MALLOC_STATS
static void internal_malloc_stats(mstate m) {
  ensure_initialization();
  if (!PREACTION(m)) {
    size_t maxfp = 0;
    size_t fp = 0;
    size_t used = 0;
    check_malloc_state(m);
    if (is_initialized(m)) {
      msegmentptr s = &m->seg;
      maxfp = m->max_footprint;
      fp = m->footprint;
      used = fp - (m->topsize + TOP_FOOT_SIZE);

      while (s != 0) {
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          if (!is_inuse(q))
            used -= chunksize(q);
          q = next_chunk(q);
        }
        s = s->next;
      }
    }
    POSTACTION(m); /* drop lock */
    fprintf(stderr, "max system bytes = %10lu\n", (unsigned long)(maxfp));
    fprintf(stderr, "system bytes     = %10lu\n", (unsigned long)(fp));
    fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));
  }
}
#endif /* NO_MALLOC_STATS */

/* ----------------------- Operations on smallbins ----------------------- */

/*
  Various forms of linking and unlinking are defined as macros.  Even
  the ones for trees, which are very long but have very short typical
  paths.  This is ugly but reduces reliance on inlining support of
  compilers.
*/

/* Link a free chunk into a smallbin  */
#define insert_small_chunk(M, P, S) {\
  bindex_t I  = small_index(S);\
  mchunkptr B = smallbin_at(M, I);\
  mchunkptr F = B;\
  assert(S >= MIN_CHUNK_SIZE);\
  if (!smallmap_is_marked(M, I))\
    mark_smallmap(M, I);\
  else if (RTCHECK(ok_address(M, B->fd)))\
    F = B->fd;\
  else {\
    CORRUPTION_ERROR_ACTION(M);\
  }\
  B->fd = P;\
  F->bk = P;\
  P->fd = F;\
  P->bk = B;\
}

/* Unlink a chunk from a smallbin  */
#define unlink_small_chunk(M, P, S) {\
  mchunkptr F = P->fd;\
  mchunkptr B = P->bk;\
  bindex_t I = small_index(S);\
  assert(P != B);\
  assert(P != F);\
  assert(chunksize(P) == small_index2size(I));\
  if (RTCHECK(F == smallbin_at(M,I) || (ok_address(M, F) && F->bk == P))) { \
    if (B == F) {\
      clear_smallmap(M, I);\
    }\
    else if (RTCHECK(B == smallbin_at(M,I) ||\
                     (ok_address(M, B) && B->fd == P))) {\
      F->bk = B;\
      B->fd = F;\
    }\
    else {\
      CORRUPTION_ERROR_ACTION(M);\
    }\
  }\
  else {\
    CORRUPTION_ERROR_ACTION(M);\
  }\
}

/* Unlink the first chunk from a smallbin */
#define unlink_first_small_chunk(M, B, P, I) {\
  mchunkptr F = P->fd;\
  assert(P != B);\
  assert(P != F);\
  assert(chunksize(P) == small_index2size(I));\
  if (B == F) {\
    clear_smallmap(M, I);\
  }\
  else if (RTCHECK(ok_address(M, F) && F->bk == P)) {\
    F->bk = B;\
    B->fd = F;\
  }\
  else {\
    CORRUPTION_ERROR_ACTION(M);\
  }\
}

/* Replace dv node, binning the old one */
/* Used only when dvsize known to be small */
#define replace_dv(M, P, S) {\
  size_t DVS = M->dvsize;\
  assert(is_small(DVS));\
  if (DVS != 0) {\
    mchunkptr DV = M->dv;\
    insert_small_chunk(M, DV, DVS);\
  }\
  M->dvsize = S;\
  M->dv = P;\
}

/* ------------------------- Operations on trees ------------------------- */

/* Insert chunk into tree */
#define insert_large_chunk(M, X, S) {\
  tbinptr* H;\
  bindex_t I;\
  compute_tree_index(S, I);\
  H = treebin_at(M, I);\
  X->index = I;\
  X->child[0] = X->child[1] = 0;\
  if (!treemap_is_marked(M, I)) {\
    mark_treemap(M, I);\
    *H = X;\
    X->parent = (tchunkptr)H;\
    X->fd = X->bk = X;\
  }\
  else {\
    tchunkptr T = *H;\
    size_t K = S << leftshift_for_tree_index(I);\
    for (;;) {\
      if (chunksize(T) != S) {\
        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
        K <<= 1;\
        if (*C != 0)\
          T = *C;\
        else if (RTCHECK(ok_address(M, C))) {\
          *C = X;\
          X->parent = T;\
          X->fd = X->bk = X;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
      }\
      else {\
        tchunkptr F = T->fd;\
        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
          T->fd = F->bk = X;\
          X->fd = F;\
          X->bk = T;\
          X->parent = 0;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
      }\
    }\
  }\
}

/*
  Unlink steps:

  1. If x is a chained node, unlink it from its same-sized fd/bk links
     and choose its bk node as its replacement.
  2. If x was the last node of its size, but not a leaf node, it must
     be replaced with a leaf node (not merely one with an open left or
     right), to make sure that lefts and rights of descendents
     correspond properly to bit masks.  We use the rightmost descendent
     of x.  We could use any other leaf, but this is easy to locate and
     tends to counteract removal of leftmosts elsewhere, and so keeps
     paths shorter than minimally guaranteed.  This doesn't loop much
     because on average a node in a tree is near the bottom.
  3. If x is the base of a chain (i.e., has parent links) relink
     x's parent and children to x's replacement (or null if none).
*/

#define unlink_large_chunk(M, X) {\
  tchunkptr XP = X->parent;\
  tchunkptr R;\
  if (X->bk != X) {\
    tchunkptr F = X->fd;\
    R = X->bk;\
    if (RTCHECK(ok_address(M, F) && F->bk == X && R->fd == X)) {\
      F->bk = R;\
      R->fd = F;\
    }\
    else {\
      CORRUPTION_ERROR_ACTION(M);\
    }\
  }\
  else {\
    tchunkptr* RP;\
    if (((R = *(RP = &(X->child[1]))) != 0) ||\
        ((R = *(RP = &(X->child[0]))) != 0)) {\
      tchunkptr* CP;\
      while ((*(CP = &(R->child[1])) != 0) ||\
             (*(CP = &(R->child[0])) != 0)) {\
        R = *(RP = CP);\
      }\
      if (RTCHECK(ok_address(M, RP)))\
        *RP = 0;\
      else {\
        CORRUPTION_ERROR_ACTION(M);\
      }\
    }\
  }\
  if (XP != 0) {\
    tbinptr* H = treebin_at(M, X->index);\
    if (X == *H) {\
      if ((*H = R) == 0) \
        clear_treemap(M, X->index);\
    }\
    else if (RTCHECK(ok_address(M, XP))) {\
      if (XP->child[0] == X) \
        XP->child[0] = R;\
      else \
        XP->child[1] = R;\
    }\
    else\
      CORRUPTION_ERROR_ACTION(M);\
    if (R != 0) {\
      if (RTCHECK(ok_address(M, R))) {\
        tchunkptr C0, C1;\
        R->parent = XP;\
        if ((C0 = X->child[0]) != 0) {\
          if (RTCHECK(ok_address(M, C0))) {\
            R->child[0] = C0;\
            C0->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
        if ((C1 = X->child[1]) != 0) {\
          if (RTCHECK(ok_address(M, C1))) {\
            R->child[1] = C1;\
            C1->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
      }\
      else\
        CORRUPTION_ERROR_ACTION(M);\
    }\
  }\
}

/* Relays to large vs small bin operations */

#define insert_chunk(M, P, S)\
  if (is_small(S)) insert_small_chunk(M, P, S)\
  else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }

#define unlink_chunk(M, P, S)\
  if (is_small(S)) unlink_small_chunk(M, P, S)\
  else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }


/* Relays to internal calls to malloc/free from realloc, memalign etc */

#if ONLY_MSPACES
#define internal_malloc(m, b) mspace_malloc(m, b)
#define internal_free(m, mem) mspace_free(m,mem);
#else /* ONLY_MSPACES */
#if MSPACES
#define internal_malloc(m, b)\
  ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
#define internal_free(m, mem)\
   if (m == gm) dlfree(mem); else mspace_free(m,mem);
#else /* MSPACES */
#define internal_malloc(m, b) dlmalloc(b)
#define internal_free(m, mem) dlfree(mem)
#endif /* MSPACES */
#endif /* ONLY_MSPACES */

/* -----------------------  Direct-mmapping chunks ----------------------- */

/*
  Directly mmapped chunks are set up with an offset to the start of
  the mmapped region stored in the prev_foot field of the chunk. This
  allows reconstruction of the required argument to MUNMAP when freed,
  and also allows adjustment of the returned chunk to meet alignment
  requirements (especially in memalign).
*/

/* Malloc using mmap */
static void* mmap_alloc(mstate m, size_t nb) {
  size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
  if (m->footprint_limit != 0) {
    size_t fp = m->footprint + mmsize;
    if (fp <= m->footprint || fp > m->footprint_limit)
      return 0;
  }
  if (mmsize > nb) {     /* Check for wrap around 0 */
    char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));
    if (mm != CMFAIL) {
      size_t offset = align_offset(chunk2mem(mm));
      size_t psize = mmsize - offset - MMAP_FOOT_PAD;
      mchunkptr p = (mchunkptr)(mm + offset);
      p->prev_foot = offset;
      p->head = psize;
      mark_inuse_foot(m, p, psize);
      chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
      chunk_plus_offset(p, psize+SIZE_T_SIZE)->head = 0;

      if (m->least_addr == 0 || mm < m->least_addr)
        m->least_addr = mm;
      if ((m->footprint += mmsize) > m->max_footprint)
        m->max_footprint = m->footprint;
      assert(is_aligned(chunk2mem(p)));
      check_mmapped_chunk(m, p);
      return chunk2mem(p);
    }
  }
  return 0;
}

/* Realloc using mmap */
static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb, int flags) {
  size_t oldsize = chunksize(oldp);
  (void)flags; /* placate people compiling -Wunused */
  if (is_small(nb)) /* Can't shrink mmap regions below small size */
    return 0;
  /* Keep old chunk if big enough but not too big */
  if (oldsize >= nb + SIZE_T_SIZE &&
      (oldsize - nb) <= (mparams.granularity << 1))
    return oldp;
  else {
    size_t offset = oldp->prev_foot;
    size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;
    size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
    char* cp = (char*)CALL_MREMAP((char*)oldp - offset,
                                  oldmmsize, newmmsize, flags);
    if (cp != CMFAIL) {
      mchunkptr newp = (mchunkptr)(cp + offset);
      size_t psize = newmmsize - offset - MMAP_FOOT_PAD;
      newp->head = psize;
      mark_inuse_foot(m, newp, psize);
      chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;
      chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;

      if (cp < m->least_addr)
        m->least_addr = cp;
      if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)
        m->max_footprint = m->footprint;
      check_mmapped_chunk(m, newp);
      return newp;
    }
  }
  return 0;
}


/* -------------------------- mspace management -------------------------- */

/* Initialize top chunk and its size */
static void init_top(mstate m, mchunkptr p, size_t psize) {
  /* Ensure alignment */
  size_t offset = align_offset(chunk2mem(p));
  p = (mchunkptr)((char*)p + offset);
  psize -= offset;

  m->top = p;
  m->topsize = psize;
  p->head = psize | PINUSE_BIT;
  /* set size of fake trailing chunk holding overhead space only once */
  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
  m->trim_check = mparams.trim_threshold; /* reset on each update */
}

/* Initialize bins for a new mstate that is otherwise zeroed out */
static void init_bins(mstate m) {
  /* Establish circular links for smallbins */
  bindex_t i;
  for (i = 0; i < NSMALLBINS; ++i) {
    sbinptr bin = smallbin_at(m,i);
    bin->fd = bin->bk = bin;
  }
}

#if PROCEED_ON_ERROR

/* default corruption action */
static void reset_on_error(mstate m) {
  int i;
  ++malloc_corruption_error_count;
  /* Reinitialize fields to forget about all memory */
  m->smallmap = m->treemap = 0;
  m->dvsize = m->topsize = 0;
  m->seg.base = 0;
  m->seg.size = 0;
  m->seg.next = 0;
  m->top = m->dv = 0;
  for (i = 0; i < NTREEBINS; ++i)
    *treebin_at(m, i) = 0;
  init_bins(m);
}
#endif /* PROCEED_ON_ERROR */

/* Allocate chunk and prepend remainder with chunk in successor base. */
static void* prepend_alloc(mstate m, char* newbase, char* oldbase,
                           size_t nb) {
  mchunkptr p = align_as_chunk(newbase);
  mchunkptr oldfirst = align_as_chunk(oldbase);
  size_t psize = (char*)oldfirst - (char*)p;
  mchunkptr q = chunk_plus_offset(p, nb);
  size_t qsize = psize - nb;
  set_size_and_pinuse_of_inuse_chunk(m, p, nb);

  assert((char*)oldfirst > (char*)q);
  assert(pinuse(oldfirst));
  assert(qsize >= MIN_CHUNK_SIZE);

  /* consolidate remainder with first chunk of old base */
  if (oldfirst == m->top) {
    size_t tsize = m->topsize += qsize;
    m->top = q;
    q->head = tsize | PINUSE_BIT;
    check_top_chunk(m, q);
  }
  else if (oldfirst == m->dv) {
    size_t dsize = m->dvsize += qsize;
    m->dv = q;
    set_size_and_pinuse_of_free_chunk(q, dsize);
  }
  else {
    if (!is_inuse(oldfirst)) {
      size_t nsize = chunksize(oldfirst);
      unlink_chunk(m, oldfirst, nsize);
      oldfirst = chunk_plus_offset(oldfirst, nsize);
      qsize += nsize;
    }
    set_free_with_pinuse(q, qsize, oldfirst);
    insert_chunk(m, q, qsize);
    check_free_chunk(m, q);
  }

  check_malloced_chunk(m, chunk2mem(p), nb);
  return chunk2mem(p);
}

/* Add a segment to hold a new noncontiguous region */
static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {
  /* Determine locations and sizes of segment, fenceposts, old top */
  char* old_top = (char*)m->top;
  msegmentptr oldsp = segment_holding(m, old_top);
  char* old_end = oldsp->base + oldsp->size;
  size_t ssize = pad_request(sizeof(struct malloc_segment));
  char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
  size_t offset = align_offset(chunk2mem(rawsp));
  char* asp = rawsp + offset;
  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
  mchunkptr sp = (mchunkptr)csp;
  msegmentptr ss = (msegmentptr)(chunk2mem(sp));
  mchunkptr tnext = chunk_plus_offset(sp, ssize);
  mchunkptr p = tnext;
  int nfences = 0;

  /* reset top to new space */
  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);

  /* Set up segment record */
  assert(is_aligned(ss));
  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);
  *ss = m->seg; /* Push current record */
  m->seg.base = tbase;
  m->seg.size = tsize;
  m->seg.sflags = mmapped;
  m->seg.next = ss;

  /* Insert trailing fenceposts */
  for (;;) {
    mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);
    p->head = FENCEPOST_HEAD;
    ++nfences;
    if ((char*)(&(nextp->head)) < old_end)
      p = nextp;
    else
      break;
  }
  assert(nfences >= 2);

  /* Insert the rest of old top into a bin as an ordinary free chunk */
  if (csp != old_top) {
    mchunkptr q = (mchunkptr)old_top;
    size_t psize = csp - old_top;
    mchunkptr tn = chunk_plus_offset(q, psize);
    set_free_with_pinuse(q, psize, tn);
    insert_chunk(m, q, psize);
  }

  check_top_chunk(m, m->top);
}

/* -------------------------- System allocation -------------------------- */

/* Get memory from system using MORECORE or MMAP */
static void* sys_alloc(mstate m, size_t nb) {
  char* tbase = CMFAIL;
  size_t tsize = 0;
  flag_t mmap_flag = 0;
  size_t asize; /* allocation size */

  ensure_initialization();

  /* Directly map large chunks, but only if already initialized */
  if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
    void* mem = mmap_alloc(m, nb);
    if (mem != 0)
      return mem;
  }

  asize = granularity_align(nb + SYS_ALLOC_PADDING);
  if (asize <= nb)
    return 0; /* wraparound */
  if (m->footprint_limit != 0) {
    size_t fp = m->footprint + asize;
    if (fp <= m->footprint || fp > m->footprint_limit)
      return 0;
  }

  /*
    Try getting memory in any of three ways (in most-preferred to
    least-preferred order):
    1. A call to MORECORE that can normally contiguously extend memory.
       (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
       or main space is mmapped or a previous contiguous call failed)
    2. A call to MMAP new space (disabled if not HAVE_MMAP).
       Note that under the default settings, if MORECORE is unable to
       fulfill a request, and HAVE_MMAP is true, then mmap is
       used as a noncontiguous system allocator. This is a useful backup
       strategy for systems with holes in address spaces -- in this case
       sbrk cannot contiguously expand the heap, but mmap may be able to
       find space.
    3. A call to MORECORE that cannot usually contiguously extend memory.
       (disabled if not HAVE_MORECORE)

   In all cases, we need to request enough bytes from system to ensure
   we can malloc nb bytes upon success, so pad with enough space for
   top_foot, plus alignment-pad to make sure we don't lose bytes if
   not on boundary, and round this up to a granularity unit.
  */

  if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {
    char* br = CMFAIL;
    size_t ssize = asize; /* sbrk call size */
    msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);
    ACQUIRE_MALLOC_GLOBAL_LOCK();

    if (ss == 0) {  /* First time through or recovery */
      char* base = (char*)CALL_MORECORE(0);
      if (base != CMFAIL) {
        size_t fp;
        /* Adjust to end on a page boundary */
        if (!is_page_aligned(base))
          ssize += (page_align((size_t)base) - (size_t)base);
        fp = m->footprint + ssize; /* recheck limits */
        if (ssize > nb && ssize < HALF_MAX_SIZE_T &&
            (m->footprint_limit == 0 ||
             (fp > m->footprint && fp <= m->footprint_limit)) &&
            (br = (char*)(CALL_MORECORE(ssize))) == base) {
          tbase = base;
          tsize = ssize;
        }
      }
    }
    else {
      /* Subtract out existing available top space from MORECORE request. */
      ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);
      /* Use mem here only if it did continuously extend old space */
      if (ssize < HALF_MAX_SIZE_T &&
          (br = (char*)(CALL_MORECORE(ssize))) == ss->base+ss->size) {
        tbase = br;
        tsize = ssize;
      }
    }

    if (tbase == CMFAIL) {    /* Cope with partial failure */
      if (br != CMFAIL) {    /* Try to use/extend the space we did get */
        if (ssize < HALF_MAX_SIZE_T &&
            ssize < nb + SYS_ALLOC_PADDING) {
          size_t esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);
          if (esize < HALF_MAX_SIZE_T) {
            char* end = (char*)CALL_MORECORE(esize);
            if (end != CMFAIL)
              ssize += esize;
            else {            /* Can't use; try to release */
              (void) CALL_MORECORE(-ssize);
              br = CMFAIL;
            }
          }
        }
      }
      if (br != CMFAIL) {    /* Use the space we did get */
        tbase = br;
        tsize = ssize;
      }
      else
        disable_contiguous(m); /* Don't try contiguous path in the future */
    }

    RELEASE_MALLOC_GLOBAL_LOCK();
  }

  if (HAVE_MMAP && tbase == CMFAIL) {  /* Try MMAP */
    char* mp = (char*)(CALL_MMAP(asize));
    if (mp != CMFAIL) {
      tbase = mp;
      tsize = asize;
      mmap_flag = USE_MMAP_BIT;
    }
  }

  if (HAVE_MORECORE && tbase == CMFAIL) { /* Try noncontiguous MORECORE */
    if (asize < HALF_MAX_SIZE_T) {
      char* br = CMFAIL;
      char* end = CMFAIL;
      ACQUIRE_MALLOC_GLOBAL_LOCK();
      br = (char*)(CALL_MORECORE(asize));
      end = (char*)(CALL_MORECORE(0));
      RELEASE_MALLOC_GLOBAL_LOCK();
      if (br != CMFAIL && end != CMFAIL && br < end) {
        size_t ssize = end - br;
        if (ssize > nb + TOP_FOOT_SIZE) {
          tbase = br;
          tsize = ssize;
        }
      }
    }
  }

  if (tbase != CMFAIL) {

    if ((m->footprint += tsize) > m->max_footprint)
      m->max_footprint = m->footprint;

    if (!is_initialized(m)) { /* first-time initialization */
      if (m->least_addr == 0 || tbase < m->least_addr)
        m->least_addr = tbase;
      m->seg.base = tbase;
      m->seg.size = tsize;
      m->seg.sflags = mmap_flag;
      m->magic = mparams.magic;
      m->release_checks = MAX_RELEASE_CHECK_RATE;
      init_bins(m);
#if !ONLY_MSPACES
      if (is_global(m))
        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
      else
#endif
      {
        /* Offset top by embedded malloc_state */
        mchunkptr mn = next_chunk(mem2chunk(m));
        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
      }
    }

    else {
      /* Try to merge with an existing segment */
      msegmentptr sp = &m->seg;
      /* Only consider most recent segment if traversal suppressed */
      while (sp != 0 && tbase != sp->base + sp->size)
        sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
      if (sp != 0 &&
          !is_extern_segment(sp) &&
          (sp->sflags & USE_MMAP_BIT) == mmap_flag &&
          segment_holds(sp, m->top)) { /* append */
        sp->size += tsize;
        init_top(m, m->top, m->topsize + tsize);
      }
      else {
        if (tbase < m->least_addr)
          m->least_addr = tbase;
        sp = &m->seg;
        while (sp != 0 && sp->base != tbase + tsize)
          sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
        if (sp != 0 &&
            !is_extern_segment(sp) &&
            (sp->sflags & USE_MMAP_BIT) == mmap_flag) {
          char* oldbase = sp->base;
          sp->base = tbase;
          sp->size += tsize;
          return prepend_alloc(m, tbase, oldbase, nb);
        }
        else
          add_segment(m, tbase, tsize, mmap_flag);
      }
    }

    if (nb < m->topsize) { /* Allocate from new or extended top space */
      size_t rsize = m->topsize -= nb;
      mchunkptr p = m->top;
      mchunkptr r = m->top = chunk_plus_offset(p, nb);
      r->head = rsize | PINUSE_BIT;
      set_size_and_pinuse_of_inuse_chunk(m, p, nb);
      check_top_chunk(m, m->top);
      check_malloced_chunk(m, chunk2mem(p), nb);
      return chunk2mem(p);
    }
  }

  MALLOC_FAILURE_ACTION;
  return 0;
}

/* -----------------------  system deallocation -------------------------- */

/* Unmap and unlink any mmapped segments that don't contain used chunks */
static size_t release_unused_segments(mstate m) {
  size_t released = 0;
  int nsegs = 0;
  msegmentptr pred = &m->seg;
  msegmentptr sp = pred->next;
  while (sp != 0) {
    char* base = sp->base;
    size_t size = sp->size;
    msegmentptr next = sp->next;
    ++nsegs;
    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
      mchunkptr p = align_as_chunk(base);
      size_t psize = chunksize(p);
      /* Can unmap if first chunk holds entire segment and not pinned */
      if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
        tchunkptr tp = (tchunkptr)p;
        assert(segment_holds(sp, (char*)sp));
        if (p == m->dv) {
          m->dv = 0;
          m->dvsize = 0;
        }
        else {
          unlink_large_chunk(m, tp);
        }
        if (CALL_MUNMAP(base, size) == 0) {
          released += size;
          m->footprint -= size;
          /* unlink obsoleted record */
          sp = pred;
          sp->next = next;
        }
        else { /* back out if cannot unmap */
          insert_large_chunk(m, tp, psize);
        }
      }
    }
    if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */
      break;
    pred = sp;
    sp = next;
  }
  /* Reset check counter */
  m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
                       (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);
  return released;
}

static int sys_trim(mstate m, size_t pad) {
  size_t released = 0;
  ensure_initialization();
  if (pad < MAX_REQUEST && is_initialized(m)) {
    pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */

    if (m->topsize > pad) {
      /* Shrink top space in granularity-size units, keeping at least one */
      size_t unit = mparams.granularity;
      size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
                      SIZE_T_ONE) * unit;
      msegmentptr sp = segment_holding(m, (char*)m->top);

      if (!is_extern_segment(sp)) {
        if (is_mmapped_segment(sp)) {
          if (HAVE_MMAP &&
              sp->size >= extra &&
              !has_segment_link(m, sp)) { /* can't shrink if pinned */
            size_t newsize = sp->size - extra;
            (void)newsize; /* placate people compiling -Wunused-variable */
            /* Prefer mremap, fall back to munmap */
            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
              released = extra;
            }
          }
        }
        else if (HAVE_MORECORE) {
          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
          ACQUIRE_MALLOC_GLOBAL_LOCK();
          {
            /* Make sure end of memory is where we last set it. */
            char* old_br = (char*)(CALL_MORECORE(0));
            if (old_br == sp->base + sp->size) {
              char* rel_br = (char*)(CALL_MORECORE(-extra));
              char* new_br = (char*)(CALL_MORECORE(0));
              if (rel_br != CMFAIL && new_br < old_br)
                released = old_br - new_br;
            }
          }
          RELEASE_MALLOC_GLOBAL_LOCK();
        }
      }

      if (released != 0) {
        sp->size -= released;
        m->footprint -= released;
        init_top(m, m->top, m->topsize - released);
        check_top_chunk(m, m->top);
      }
    }

    /* Unmap any unused mmapped segments */
    if (HAVE_MMAP)
      released += release_unused_segments(m);

    /* On failure, disable autotrim to avoid repeated failed future calls */
    if (released == 0 && m->topsize > m->trim_check)
      m->trim_check = MAX_SIZE_T;
  }

  return (released != 0)? 1 : 0;
}

/* Consolidate and bin a chunk. Differs from exported versions
   of free mainly in that the chunk need not be marked as inuse.
*/
static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {
  mchunkptr next = chunk_plus_offset(p, psize);
  if (!pinuse(p)) {
    mchunkptr prev;
    size_t prevsize = p->prev_foot;
    if (is_mmapped(p)) {
      psize += prevsize + MMAP_FOOT_PAD;
      if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
        m->footprint -= psize;
      return;
    }
    prev = chunk_minus_offset(p, prevsize);
    psize += prevsize;
    p = prev;
    if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
      if (p != m->dv) {
        unlink_chunk(m, p, prevsize);
      }
      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
        m->dvsize = psize;
        set_free_with_pinuse(p, psize, next);
        return;
      }
    }
    else {
      CORRUPTION_ERROR_ACTION(m);
      return;
    }
  }
  if (RTCHECK(ok_address(m, next))) {
    if (!cinuse(next)) {  /* consolidate forward */
      if (next == m->top) {
        size_t tsize = m->topsize += psize;
        m->top = p;
        p->head = tsize | PINUSE_BIT;
        if (p == m->dv) {
          m->dv = 0;
          m->dvsize = 0;
        }
        return;
      }
      else if (next == m->dv) {
        size_t dsize = m->dvsize += psize;
        m->dv = p;
        set_size_and_pinuse_of_free_chunk(p, dsize);
        return;
      }
      else {
        size_t nsize = chunksize(next);
        psize += nsize;
        unlink_chunk(m, next, nsize);
        set_size_and_pinuse_of_free_chunk(p, psize);
        if (p == m->dv) {
          m->dvsize = psize;
          return;
        }
      }
    }
    else {
      set_free_with_pinuse(p, psize, next);
    }
    insert_chunk(m, p, psize);
  }
  else {
    CORRUPTION_ERROR_ACTION(m);
  }
}

/* ---------------------------- malloc --------------------------- */

/* allocate a large request from the best fitting chunk in a treebin */
static void* tmalloc_large(mstate m, size_t nb) {
  tchunkptr v = 0;
  size_t rsize = -nb; /* Unsigned negation */
  tchunkptr t;
  bindex_t idx;
  compute_tree_index(nb, idx);
  if ((t = *treebin_at(m, idx)) != 0) {
    /* Traverse tree for this bin looking for node with size == nb */
    size_t sizebits = nb << leftshift_for_tree_index(idx);
    tchunkptr rst = 0;  /* The deepest untaken right subtree */
    for (;;) {
      tchunkptr rt;
      size_t trem = chunksize(t) - nb;
      if (trem < rsize) {
        v = t;
        if ((rsize = trem) == 0)
          break;
      }
      rt = t->child[1];
      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
      if (rt != 0 && rt != t)
        rst = rt;
      if (t == 0) {
        t = rst; /* set t to least subtree holding sizes > nb */
        break;
      }
      sizebits <<= 1;
    }
  }
  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */
    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;
    if (leftbits != 0) {
      bindex_t i;
      binmap_t leastbit = least_bit(leftbits);
      compute_bit2idx(leastbit, i);
      t = *treebin_at(m, i);
    }
  }

  while (t != 0) { /* find smallest of tree or subtree */
    size_t trem = chunksize(t) - nb;
    if (trem < rsize) {
      rsize = trem;
      v = t;
    }
    t = leftmost_child(t);
  }

  /*  If dv is a better fit, return 0 so malloc will use it */
  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {
    if (RTCHECK(ok_address(m, v))) { /* split */
      mchunkptr r = chunk_plus_offset(v, nb);
      assert(chunksize(v) == rsize + nb);
      if (RTCHECK(ok_next(v, r))) {
        unlink_large_chunk(m, v);
        if (rsize < MIN_CHUNK_SIZE)
          set_inuse_and_pinuse(m, v, (rsize + nb));
        else {
          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
          set_size_and_pinuse_of_free_chunk(r, rsize);
          insert_chunk(m, r, rsize);
        }
        return chunk2mem(v);
      }
    }
    CORRUPTION_ERROR_ACTION(m);
  }
  return 0;
}

/* allocate a small request from the best fitting chunk in a treebin */
static void* tmalloc_small(mstate m, size_t nb) {
  tchunkptr t, v;
  size_t rsize;
  bindex_t i;
  binmap_t leastbit = least_bit(m->treemap);
  compute_bit2idx(leastbit, i);
  v = t = *treebin_at(m, i);
  rsize = chunksize(t) - nb;

  while ((t = leftmost_child(t)) != 0) {
    size_t trem = chunksize(t) - nb;
    if (trem < rsize) {
      rsize = trem;
      v = t;
    }
  }

  if (RTCHECK(ok_address(m, v))) {
    mchunkptr r = chunk_plus_offset(v, nb);
    assert(chunksize(v) == rsize + nb);
    if (RTCHECK(ok_next(v, r))) {
      unlink_large_chunk(m, v);
      if (rsize < MIN_CHUNK_SIZE)
        set_inuse_and_pinuse(m, v, (rsize + nb));
      else {
        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
        set_size_and_pinuse_of_free_chunk(r, rsize);
        replace_dv(m, r, rsize);
      }
      return chunk2mem(v);
    }
  }

  CORRUPTION_ERROR_ACTION(m);
  return 0;
}

#if !ONLY_MSPACES

void* dlmalloc(size_t bytes) {
  /*
     Basic algorithm:
     If a small request (< 256 bytes minus per-chunk overhead):
       1. If one exists, use a remainderless chunk in associated smallbin.
          (Remainderless means that there are too few excess bytes to
          represent as a chunk.)
       2. If it is big enough, use the dv chunk, which is normally the
          chunk adjacent to the one used for the most recent small request.
       3. If one exists, split the smallest available chunk in a bin,
          saving remainder in dv.
       4. If it is big enough, use the top chunk.
       5. If available, get memory from system and use it
     Otherwise, for a large request:
       1. Find the smallest available binned chunk that fits, and use it
          if it is better fitting than dv chunk, splitting if necessary.
       2. If better fitting than any binned chunk, use the dv chunk.
       3. If it is big enough, use the top chunk.
       4. If request size >= mmap threshold, try to directly mmap this chunk.
       5. If available, get memory from system and use it

     The ugly goto's here ensure that postaction occurs along all paths.
  */

#if USE_LOCKS
  ensure_initialization(); /* initialize in sys_alloc if not using locks */
#endif

  if (!PREACTION(gm)) {
    void* mem;
    size_t nb;
    if (bytes <= MAX_SMALL_REQUEST) {
      bindex_t idx;
      binmap_t smallbits;
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
      idx = small_index(nb);
      smallbits = gm->smallmap >> idx;

      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(gm, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(gm, b, p, idx);
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
      }

      else if (nb > gm->dvsize) {
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(gm, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(gm, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(gm, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(gm, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }

        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }
      }
    }
    else if (bytes >= MAX_REQUEST)
      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
    else {
      nb = pad_request(bytes);
      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
      }
    }

    if (nb <= gm->dvsize) {
      size_t rsize = gm->dvsize - nb;
      mchunkptr p = gm->dv;
      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
        gm->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
      }
      else { /* exhaust dv */
        size_t dvs = gm->dvsize;
        gm->dvsize = 0;
        gm->dv = 0;
        set_inuse_and_pinuse(gm, p, dvs);
      }
      mem = chunk2mem(p);
      check_malloced_chunk(gm, mem, nb);
      goto postaction;
    }

    else if (nb < gm->topsize) { /* Split top */
      size_t rsize = gm->topsize -= nb;
      mchunkptr p = gm->top;
      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
      r->head = rsize | PINUSE_BIT;
      set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
      mem = chunk2mem(p);
      check_top_chunk(gm, gm->top);
      check_malloced_chunk(gm, mem, nb);
      goto postaction;
    }

    mem = sys_alloc(gm, nb);

  postaction:
    POSTACTION(gm);
    return mem;
  }

  return 0;
}

/* ---------------------------- free --------------------------- */

void dlfree(void* mem) {
  /*
     Consolidate freed chunks with preceeding or succeeding bordering
     free chunks, if they exist, and then place in a bin.  Intermixed
     with special cases for top, dv, mmapped chunks, and usage errors.
  */

  if (mem != 0) {
    mchunkptr p  = mem2chunk(mem);
#if FOOTERS
    mstate fm = get_mstate_for(p);
    if (!ok_magic(fm)) {
      USAGE_ERROR_ACTION(fm, p);
      return;
    }
#else /* FOOTERS */
#define fm gm
#endif /* FOOTERS */
    if (!PREACTION(fm)) {
      check_inuse_chunk(fm, p);
      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if (is_mmapped(p)) {
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
      }
    erroraction:
      USAGE_ERROR_ACTION(fm, p);
    postaction:
      POSTACTION(fm);
    }
  }
#if !FOOTERS
#undef fm
#endif /* FOOTERS */
}

void* dlcalloc(size_t n_elements, size_t elem_size) {
  void* mem;
  size_t req = 0;
  if (n_elements != 0) {
    req = n_elements * elem_size;
    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
        (req / n_elements != elem_size))
      req = MAX_SIZE_T; /* force downstream failure on overflow */
  }
  mem = dlmalloc(req);
  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
    memset(mem, 0, req);
  return mem;
}

#endif /* !ONLY_MSPACES */

/* ------------ Internal support for realloc, memalign, etc -------------- */

/* Try to realloc; only in-place unless can_move true */
static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
                                   int can_move) {
  mchunkptr newp = 0;
  size_t oldsize = chunksize(p);
  mchunkptr next = chunk_plus_offset(p, oldsize);
  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
              ok_next(p, next) && ok_pinuse(next))) {
    if (is_mmapped(p)) {
      newp = mmap_resize(m, p, nb, can_move);
    }
    else if (oldsize >= nb) {             /* already big enough */
      size_t rsize = oldsize - nb;
      if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */
        mchunkptr r = chunk_plus_offset(p, nb);
        set_inuse(m, p, nb);
        set_inuse(m, r, rsize);
        dispose_chunk(m, r, rsize);
      }
      newp = p;
    }
    else if (next == m->top) {  /* extend into top */
      if (oldsize + m->topsize > nb) {
        size_t newsize = oldsize + m->topsize;
        size_t newtopsize = newsize - nb;
        mchunkptr newtop = chunk_plus_offset(p, nb);
        set_inuse(m, p, nb);
        newtop->head = newtopsize |PINUSE_BIT;
        m->top = newtop;
        m->topsize = newtopsize;
        newp = p;
      }
    }
    else if (next == m->dv) { /* extend into dv */
      size_t dvs = m->dvsize;
      if (oldsize + dvs >= nb) {
        size_t dsize = oldsize + dvs - nb;
        if (dsize >= MIN_CHUNK_SIZE) {
          mchunkptr r = chunk_plus_offset(p, nb);
          mchunkptr n = chunk_plus_offset(r, dsize);
          set_inuse(m, p, nb);
          set_size_and_pinuse_of_free_chunk(r, dsize);
          clear_pinuse(n);
          m->dvsize = dsize;
          m->dv = r;
        }
        else { /* exhaust dv */
          size_t newsize = oldsize + dvs;
          set_inuse(m, p, newsize);
          m->dvsize = 0;
          m->dv = 0;
        }
        newp = p;
      }
    }
    else if (!cinuse(next)) { /* extend into next free chunk */
      size_t nextsize = chunksize(next);
      if (oldsize + nextsize >= nb) {
        size_t rsize = oldsize + nextsize - nb;
        unlink_chunk(m, next, nextsize);
        if (rsize < MIN_CHUNK_SIZE) {
          size_t newsize = oldsize + nextsize;
          set_inuse(m, p, newsize);
        }
        else {
          mchunkptr r = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
          set_inuse(m, r, rsize);
          dispose_chunk(m, r, rsize);
        }
        newp = p;
      }
    }
  }
  else {
    USAGE_ERROR_ACTION(m, chunk2mem(p));
  }
  return newp;
}

static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
  void* mem = 0;
  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
    alignment = MIN_CHUNK_SIZE;
  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
    size_t a = MALLOC_ALIGNMENT << 1;
    while (a < alignment) a <<= 1;
    alignment = a;
  }
  if (bytes >= MAX_REQUEST - alignment) {
    if (m != 0)  { /* Test isn't needed but avoids compiler warning */
      MALLOC_FAILURE_ACTION;
    }
  }
  else {
    size_t nb = request2size(bytes);
    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
    mem = internal_malloc(m, req);
    if (mem != 0) {
      mchunkptr p = mem2chunk(mem);
      if (PREACTION(m))
        return 0;
      if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */
        /*
          Find an aligned spot inside chunk.  Since we need to give
          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
          the first calculation places us at a spot with less than
          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
          We've allocated enough total room so that this is always
          possible.
        */
        char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
                                                       SIZE_T_ONE)) &
                                             -alignment));
        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
          br : br+alignment;
        mchunkptr newp = (mchunkptr)pos;
        size_t leadsize = pos - (char*)(p);
        size_t newsize = chunksize(p) - leadsize;

        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
          newp->prev_foot = p->prev_foot + leadsize;
          newp->head = newsize;
        }
        else { /* Otherwise, give back leader, use the rest */
          set_inuse(m, newp, newsize);
          set_inuse(m, p, leadsize);
          dispose_chunk(m, p, leadsize);
        }
        p = newp;
      }

      /* Give back spare room at the end */
      if (!is_mmapped(p)) {
        size_t size = chunksize(p);
        if (size > nb + MIN_CHUNK_SIZE) {
          size_t remainder_size = size - nb;
          mchunkptr remainder = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
          set_inuse(m, remainder, remainder_size);
          dispose_chunk(m, remainder, remainder_size);
        }
      }

      mem = chunk2mem(p);
      assert (chunksize(p) >= nb);
      assert(((size_t)mem & (alignment - 1)) == 0);
      check_inuse_chunk(m, p);
      POSTACTION(m);
    }
  }
  return mem;
}

/*
  Common support for independent_X routines, handling
    all of the combinations that can result.
  The opts arg has:
    bit 0 set if all elements are same size (using sizes[0])
    bit 1 set if elements should be zeroed
*/
static void** ialloc(mstate m,
                     size_t n_elements,
                     size_t* sizes,
                     int opts,
                     void* chunks[]) {

  size_t    element_size;   /* chunksize of each element, if all same */
  size_t    contents_size;  /* total size of elements */
  size_t    array_size;     /* request size of pointer array */
  void*     mem;            /* malloced aggregate space */
  mchunkptr p;              /* corresponding chunk */
  size_t    remainder_size; /* remaining bytes while splitting */
  void**    marray;         /* either "chunks" or malloced ptr array */
  mchunkptr array_chunk;    /* chunk for malloced ptr array */
  flag_t    was_enabled;    /* to disable mmap */
  size_t    size;
  size_t    i;

  ensure_initialization();
  /* compute array length, if needed */
  if (chunks != 0) {
    if (n_elements == 0)
      return chunks; /* nothing to do */
    marray = chunks;
    array_size = 0;
  }
  else {
    /* if empty req, must still return chunk representing empty array */
    if (n_elements == 0)
      return (void**)internal_malloc(m, 0);
    marray = 0;
    array_size = request2size(n_elements * (sizeof(void*)));
  }

  /* compute total element size */
  if (opts & 0x1) { /* all-same-size */
    element_size = request2size(*sizes);
    contents_size = n_elements * element_size;
  }
  else { /* add up all the sizes */
    element_size = 0;
    contents_size = 0;
    for (i = 0; i != n_elements; ++i)
      contents_size += request2size(sizes[i]);
  }

  size = contents_size + array_size;

  /*
     Allocate the aggregate chunk.  First disable direct-mmapping so
     malloc won't use it, since we would not be able to later
     free/realloc space internal to a segregated mmap region.
  */
  was_enabled = use_mmap(m);
  disable_mmap(m);
  mem = internal_malloc(m, size - CHUNK_OVERHEAD);
  if (was_enabled)
    enable_mmap(m);
  if (mem == 0)
    return 0;

  if (PREACTION(m)) return 0;
  p = mem2chunk(mem);
  remainder_size = chunksize(p);

  assert(!is_mmapped(p));

  if (opts & 0x2) {       /* optionally clear the elements */
    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
  }

  /* If not provided, allocate the pointer array as final part of chunk */
  if (marray == 0) {
    size_t  array_chunk_size;
    array_chunk = chunk_plus_offset(p, contents_size);
    array_chunk_size = remainder_size - contents_size;
    marray = (void**) (chunk2mem(array_chunk));
    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);
    remainder_size = contents_size;
  }

  /* split out elements */
  for (i = 0; ; ++i) {
    marray[i] = chunk2mem(p);
    if (i != n_elements-1) {
      if (element_size != 0)
        size = element_size;
      else
        size = request2size(sizes[i]);
      remainder_size -= size;
      set_size_and_pinuse_of_inuse_chunk(m, p, size);
      p = chunk_plus_offset(p, size);
    }
    else { /* the final element absorbs any overallocation slop */
      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);
      break;
    }
  }

#if DEBUG
  if (marray != chunks) {
    /* final element must have exactly exhausted chunk */
    if (element_size != 0) {
      assert(remainder_size == element_size);
    }
    else {
      assert(remainder_size == request2size(sizes[i]));
    }
    check_inuse_chunk(m, mem2chunk(marray));
  }
  for (i = 0; i != n_elements; ++i)
    check_inuse_chunk(m, mem2chunk(marray[i]));

#endif /* DEBUG */

  POSTACTION(m);
  return marray;
}

/* Try to free all pointers in the given array.
   Note: this could be made faster, by delaying consolidation,
   at the price of disabling some user integrity checks, We
   still optimize some consolidations by combining adjacent
   chunks before freeing, which will occur often if allocated
   with ialloc or the array is sorted.
*/
static size_t internal_bulk_free(mstate m, void* array[], size_t nelem) {
  size_t unfreed = 0;
  if (!PREACTION(m)) {
    void** a;
    void** fence = &(array[nelem]);
    for (a = array; a != fence; ++a) {
      void* mem = *a;
      if (mem != 0) {
        mchunkptr p = mem2chunk(mem);
        size_t psize = chunksize(p);
#if FOOTERS
        if (get_mstate_for(p) != m) {
          ++unfreed;
          continue;
        }
#endif
        check_inuse_chunk(m, p);
        *a = 0;
        if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {
          void ** b = a + 1; /* try to merge with next chunk */
          mchunkptr next = next_chunk(p);
          if (b != fence && *b == chunk2mem(next)) {
            size_t newsize = chunksize(next) + psize;
            set_inuse(m, p, newsize);
            *b = chunk2mem(p);
          }
          else
            dispose_chunk(m, p, psize);
        }
        else {
          CORRUPTION_ERROR_ACTION(m);
          break;
        }
      }
    }
    if (should_trim(m, m->topsize))
      sys_trim(m, 0);
    POSTACTION(m);
  }
  return unfreed;
}

/* Traversal */
#if MALLOC_INSPECT_ALL
static void internal_inspect_all(mstate m,
                                 void(*handler)(void *start,
                                                void *end,
                                                size_t used_bytes,
                                                void* callback_arg),
                                 void* arg) {
  if (is_initialized(m)) {
    mchunkptr top = m->top;
    msegmentptr s;
    for (s = &m->seg; s != 0; s = s->next) {
      mchunkptr q = align_as_chunk(s->base);
      while (segment_holds(s, q) && q->head != FENCEPOST_HEAD) {
        mchunkptr next = next_chunk(q);
        size_t sz = chunksize(q);
        size_t used;
        void* start;
        if (is_inuse(q)) {
          used = sz - CHUNK_OVERHEAD; /* must not be mmapped */
          start = chunk2mem(q);
        }
        else {
          used = 0;
          if (is_small(sz)) {     /* offset by possible bookkeeping */
            start = (void*)((char*)q + sizeof(struct malloc_chunk));
          }
          else {
            start = (void*)((char*)q + sizeof(struct malloc_tree_chunk));
          }
        }
        if (start < (void*)next)  /* skip if all space is bookkeeping */
          handler(start, next, used, arg);
        if (q == top)
          break;
        q = next;
      }
    }
  }
}
#endif /* MALLOC_INSPECT_ALL */

/* ------------------ Exported realloc, memalign, etc -------------------- */

#if !ONLY_MSPACES

void* dlrealloc(void* oldmem, size_t bytes) {
  void* mem = 0;
  if (oldmem == 0) {
    mem = dlmalloc(bytes);
  }
  else if (bytes >= MAX_REQUEST) {
    MALLOC_FAILURE_ACTION;
  }
#ifdef REALLOC_ZERO_BYTES_FREES
  else if (bytes == 0) {
    dlfree(oldmem);
  }
#endif /* REALLOC_ZERO_BYTES_FREES */
  else {
    size_t nb = request2size(bytes);
    mchunkptr oldp = mem2chunk(oldmem);
#if ! FOOTERS
    mstate m = gm;
#else /* FOOTERS */
    mstate m = get_mstate_for(oldp);
    if (!ok_magic(m)) {
      USAGE_ERROR_ACTION(m, oldmem);
      return 0;
    }
#endif /* FOOTERS */
    if (!PREACTION(m)) {
      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
      POSTACTION(m);
      if (newp != 0) {
        check_inuse_chunk(m, newp);
        mem = chunk2mem(newp);
      }
      else {
        mem = internal_malloc(m, bytes);
        if (mem != 0) {
          size_t oc = chunksize(oldp) - overhead_for(oldp);
          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
          internal_free(m, oldmem);
        }
      }
    }
  }
  return mem;
}

void* dlrealloc_in_place(void* oldmem, size_t bytes) {
  void* mem = 0;
  if (oldmem != 0) {
    if (bytes >= MAX_REQUEST) {
      MALLOC_FAILURE_ACTION;
    }
    else {
      size_t nb = request2size(bytes);
      mchunkptr oldp = mem2chunk(oldmem);
#if ! FOOTERS
      mstate m = gm;
#else /* FOOTERS */
      mstate m = get_mstate_for(oldp);
      if (!ok_magic(m)) {
        USAGE_ERROR_ACTION(m, oldmem);
        return 0;
      }
#endif /* FOOTERS */
      if (!PREACTION(m)) {
        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
        POSTACTION(m);
        if (newp == oldp) {
          check_inuse_chunk(m, newp);
          mem = oldmem;
        }
      }
    }
  }
  return mem;
}

void* dlmemalign(size_t alignment, size_t bytes) {
  if (alignment <= MALLOC_ALIGNMENT) {
    return dlmalloc(bytes);
  }
  return internal_memalign(gm, alignment, bytes);
}

int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {
  void* mem = 0;
  if (alignment == MALLOC_ALIGNMENT)
    mem = dlmalloc(bytes);
  else {
    size_t d = alignment / sizeof(void*);
    size_t r = alignment % sizeof(void*);
    if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)
      return EINVAL;
    else if (bytes <= MAX_REQUEST - alignment) {
      if (alignment <  MIN_CHUNK_SIZE)
        alignment = MIN_CHUNK_SIZE;
      mem = internal_memalign(gm, alignment, bytes);
    }
  }
  if (mem == 0)
    return ENOMEM;
  else {
    *pp = mem;
    return 0;
  }
}

void* dlvalloc(size_t bytes) {
  size_t pagesz;
  ensure_initialization();
  pagesz = mparams.page_size;
  return dlmemalign(pagesz, bytes);
}

void* dlpvalloc(size_t bytes) {
  size_t pagesz;
  ensure_initialization();
  pagesz = mparams.page_size;
  return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
}

void** dlindependent_calloc(size_t n_elements, size_t elem_size,
                            void* chunks[]) {
  size_t sz = elem_size; /* serves as 1-element array */
  return ialloc(gm, n_elements, &sz, 3, chunks);
}

void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
                              void* chunks[]) {
  return ialloc(gm, n_elements, sizes, 0, chunks);
}

size_t dlbulk_free(void* array[], size_t nelem) {
  return internal_bulk_free(gm, array, nelem);
}

#if MALLOC_INSPECT_ALL
void dlmalloc_inspect_all(void(*handler)(void *start,
                                         void *end,
                                         size_t used_bytes,
                                         void* callback_arg),
                          void* arg) {
  ensure_initialization();
  if (!PREACTION(gm)) {
    internal_inspect_all(gm, handler, arg);
    POSTACTION(gm);
  }
}
#endif /* MALLOC_INSPECT_ALL */

int dlmalloc_trim(size_t pad) {
  int result = 0;
  ensure_initialization();
  if (!PREACTION(gm)) {
    result = sys_trim(gm, pad);
    POSTACTION(gm);
  }
  return result;
}

size_t dlmalloc_footprint(void) {
  return gm->footprint;
}

size_t dlmalloc_max_footprint(void) {
  return gm->max_footprint;
}

size_t dlmalloc_footprint_limit(void) {
  size_t maf = gm->footprint_limit;
  return maf == 0 ? MAX_SIZE_T : maf;
}

size_t dlmalloc_set_footprint_limit(size_t bytes) {
  size_t result;  /* invert sense of 0 */
  if (bytes == 0)
    result = granularity_align(1); /* Use minimal size */
  if (bytes == MAX_SIZE_T)
    result = 0;                    /* disable */
  else
    result = granularity_align(bytes);
  return gm->footprint_limit = result;
}

#if !NO_MALLINFO
struct mallinfo dlmallinfo(void) {
  return internal_mallinfo(gm);
}
#endif /* NO_MALLINFO */

#if !NO_MALLOC_STATS
void dlmalloc_stats() {
  internal_malloc_stats(gm);
}
#endif /* NO_MALLOC_STATS */

int dlmallopt(int param_number, int value) {
  return change_mparam(param_number, value);
}

size_t dlmalloc_usable_size(void* mem) {
  if (mem != 0) {
    mchunkptr p = mem2chunk(mem);
    if (is_inuse(p))
      return chunksize(p) - overhead_for(p);
  }
  return 0;
}

#endif /* !ONLY_MSPACES */

/* ----------------------------- user mspaces ---------------------------- */

#if MSPACES

static mstate init_user_mstate(char* tbase, size_t tsize) {
  size_t msize = pad_request(sizeof(struct malloc_state));
  mchunkptr mn;
  mchunkptr msp = align_as_chunk(tbase);
  mstate m = (mstate)(chunk2mem(msp));
  memset(m, 0, msize);
  (void)INITIAL_LOCK(&m->mutex);
  msp->head = (msize|INUSE_BITS);
  m->seg.base = m->least_addr = tbase;
  m->seg.size = m->footprint = m->max_footprint = tsize;
  m->magic = mparams.magic;
  m->release_checks = MAX_RELEASE_CHECK_RATE;
  m->mflags = mparams.default_mflags;
  m->extp = 0;
  m->exts = 0;
  disable_contiguous(m);
  init_bins(m);
  mn = next_chunk(mem2chunk(m));
  init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);
  check_top_chunk(m, m->top);
  return m;
}

mspace create_mspace(size_t capacity, int locked) {
  mstate m = 0;
  size_t msize;
  ensure_initialization();
  msize = pad_request(sizeof(struct malloc_state));
  if (capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
    size_t rs = ((capacity == 0)? mparams.granularity :
                 (capacity + TOP_FOOT_SIZE + msize));
    size_t tsize = granularity_align(rs);
    char* tbase = (char*)(CALL_MMAP(tsize));
    if (tbase != CMFAIL) {
      m = init_user_mstate(tbase, tsize);
      m->seg.sflags = USE_MMAP_BIT;
      set_lock(m, locked);
    }
  }
  return (mspace)m;
}

mspace create_mspace_with_base(void* base, size_t capacity, int locked) {
  mstate m = 0;
  size_t msize;
  ensure_initialization();
  msize = pad_request(sizeof(struct malloc_state));
  if (capacity > msize + TOP_FOOT_SIZE &&
      capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
    m = init_user_mstate((char*)base, capacity);
    m->seg.sflags = EXTERN_BIT;
    set_lock(m, locked);
  }
  return (mspace)m;
}

int mspace_track_large_chunks(mspace msp, int enable) {
  int ret = 0;
  mstate ms = (mstate)msp;
  if (!PREACTION(ms)) {
    if (!use_mmap(ms)) {
      ret = 1;
    }
    if (!enable) {
      enable_mmap(ms);
    } else {
      disable_mmap(ms);
    }
    POSTACTION(ms);
  }
  return ret;
}

size_t destroy_mspace(mspace msp) {
  size_t freed = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    msegmentptr sp = &ms->seg;
    (void)DESTROY_LOCK(&ms->mutex); /* destroy before unmapped */
    while (sp != 0) {
      char* base = sp->base;
      size_t size = sp->size;
      flag_t flag = sp->sflags;
      (void)base; /* placate people compiling -Wunused-variable */
      sp = sp->next;
      if ((flag & USE_MMAP_BIT) && !(flag & EXTERN_BIT) &&
          CALL_MUNMAP(base, size) == 0)
        freed += size;
    }
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return freed;
}

/*
  mspace versions of routines are near-clones of the global
  versions. This is not so nice but better than the alternatives.
*/

void* mspace_malloc(mspace msp, size_t bytes) {
  mstate ms = (mstate)msp;
  if (!ok_magic(ms)) {
    USAGE_ERROR_ACTION(ms,ms);
    return 0;
  }
  if (!PREACTION(ms)) {
    void* mem;
    size_t nb;
    if (bytes <= MAX_SMALL_REQUEST) {
      bindex_t idx;
      binmap_t smallbits;
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
      idx = small_index(nb);
      smallbits = ms->smallmap >> idx;

      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(ms, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(ms, b, p, idx);
        set_inuse_and_pinuse(ms, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
      }

      else if (nb > ms->dvsize) {
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(ms, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(ms, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(ms, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(ms, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }

        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }
      }
    }
    else if (bytes >= MAX_REQUEST)
      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
    else {
      nb = pad_request(bytes);
      if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
      }
    }

    if (nb <= ms->dvsize) {
      size_t rsize = ms->dvsize - nb;
      mchunkptr p = ms->dv;
      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
        ms->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
      }
      else { /* exhaust dv */
        size_t dvs = ms->dvsize;
        ms->dvsize = 0;
        ms->dv = 0;
        set_inuse_and_pinuse(ms, p, dvs);
      }
      mem = chunk2mem(p);
      check_malloced_chunk(ms, mem, nb);
      goto postaction;
    }

    else if (nb < ms->topsize) { /* Split top */
      size_t rsize = ms->topsize -= nb;
      mchunkptr p = ms->top;
      mchunkptr r = ms->top = chunk_plus_offset(p, nb);
      r->head = rsize | PINUSE_BIT;
      set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
      mem = chunk2mem(p);
      check_top_chunk(ms, ms->top);
      check_malloced_chunk(ms, mem, nb);
      goto postaction;
    }

    mem = sys_alloc(ms, nb);

  postaction:
    POSTACTION(ms);
    return mem;
  }

  return 0;
}

void mspace_free(mspace msp, void* mem) {
  if (mem != 0) {
    mchunkptr p  = mem2chunk(mem);
#if FOOTERS
    mstate fm = get_mstate_for(p);
    (void)msp; /* placate people compiling -Wunused */
#else /* FOOTERS */
    mstate fm = (mstate)msp;
#endif /* FOOTERS */
    if (!ok_magic(fm)) {
      USAGE_ERROR_ACTION(fm, p);
      return;
    }
    if (!PREACTION(fm)) {
      check_inuse_chunk(fm, p);
      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if (is_mmapped(p)) {
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
      }
    erroraction:
      USAGE_ERROR_ACTION(fm, p);
    postaction:
      POSTACTION(fm);
    }
  }
}

void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {
  void* mem;
  size_t req = 0;
  mstate ms = (mstate)msp;
  if (!ok_magic(ms)) {
    USAGE_ERROR_ACTION(ms,ms);
    return 0;
  }
  if (n_elements != 0) {
    req = n_elements * elem_size;
    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
        (req / n_elements != elem_size))
      req = MAX_SIZE_T; /* force downstream failure on overflow */
  }
  mem = internal_malloc(ms, req);
  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
    memset(mem, 0, req);
  return mem;
}

void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {
  void* mem = 0;
  if (oldmem == 0) {
    mem = mspace_malloc(msp, bytes);
  }
  else if (bytes >= MAX_REQUEST) {
    MALLOC_FAILURE_ACTION;
  }
#ifdef REALLOC_ZERO_BYTES_FREES
  else if (bytes == 0) {
    mspace_free(msp, oldmem);
  }
#endif /* REALLOC_ZERO_BYTES_FREES */
  else {
    size_t nb = request2size(bytes);
    mchunkptr oldp = mem2chunk(oldmem);
#if ! FOOTERS
    mstate m = (mstate)msp;
#else /* FOOTERS */
    mstate m = get_mstate_for(oldp);
    if (!ok_magic(m)) {
      USAGE_ERROR_ACTION(m, oldmem);
      return 0;
    }
#endif /* FOOTERS */
    if (!PREACTION(m)) {
      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
      POSTACTION(m);
      if (newp != 0) {
        check_inuse_chunk(m, newp);
        mem = chunk2mem(newp);
      }
      else {
        mem = mspace_malloc(m, bytes);
        if (mem != 0) {
          size_t oc = chunksize(oldp) - overhead_for(oldp);
          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
          mspace_free(m, oldmem);
        }
      }
    }
  }
  return mem;
}

void* mspace_realloc_in_place(mspace msp, void* oldmem, size_t bytes) {
  void* mem = 0;
  if (oldmem != 0) {
    if (bytes >= MAX_REQUEST) {
      MALLOC_FAILURE_ACTION;
    }
    else {
      size_t nb = request2size(bytes);
      mchunkptr oldp = mem2chunk(oldmem);
#if ! FOOTERS
      mstate m = (mstate)msp;
#else /* FOOTERS */
      mstate m = get_mstate_for(oldp);
      (void)msp; /* placate people compiling -Wunused */
      if (!ok_magic(m)) {
        USAGE_ERROR_ACTION(m, oldmem);
        return 0;
      }
#endif /* FOOTERS */
      if (!PREACTION(m)) {
        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
        POSTACTION(m);
        if (newp == oldp) {
          check_inuse_chunk(m, newp);
          mem = oldmem;
        }
      }
    }
  }
  return mem;
}

void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {
  mstate ms = (mstate)msp;
  if (!ok_magic(ms)) {
    USAGE_ERROR_ACTION(ms,ms);
    return 0;
  }
  if (alignment <= MALLOC_ALIGNMENT)
    return mspace_malloc(msp, bytes);
  return internal_memalign(ms, alignment, bytes);
}

void** mspace_independent_calloc(mspace msp, size_t n_elements,
                                 size_t elem_size, void* chunks[]) {
  size_t sz = elem_size; /* serves as 1-element array */
  mstate ms = (mstate)msp;
  if (!ok_magic(ms)) {
    USAGE_ERROR_ACTION(ms,ms);
    return 0;
  }
  return ialloc(ms, n_elements, &sz, 3, chunks);
}

void** mspace_independent_comalloc(mspace msp, size_t n_elements,
                                   size_t sizes[], void* chunks[]) {
  mstate ms = (mstate)msp;
  if (!ok_magic(ms)) {
    USAGE_ERROR_ACTION(ms,ms);
    return 0;
  }
  return ialloc(ms, n_elements, sizes, 0, chunks);
}

size_t mspace_bulk_free(mspace msp, void* array[], size_t nelem) {
  return internal_bulk_free((mstate)msp, array, nelem);
}

#if MALLOC_INSPECT_ALL
void mspace_inspect_all(mspace msp,
                        void(*handler)(void *start,
                                       void *end,
                                       size_t used_bytes,
                                       void* callback_arg),
                        void* arg) {
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    if (!PREACTION(ms)) {
      internal_inspect_all(ms, handler, arg);
      POSTACTION(ms);
    }
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
}
#endif /* MALLOC_INSPECT_ALL */

int mspace_trim(mspace msp, size_t pad) {
  int result = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    if (!PREACTION(ms)) {
      result = sys_trim(ms, pad);
      POSTACTION(ms);
    }
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return result;
}

#if !NO_MALLOC_STATS
void mspace_malloc_stats(mspace msp) {
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    internal_malloc_stats(ms);
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
}
#endif /* NO_MALLOC_STATS */

size_t mspace_footprint(mspace msp) {
  size_t result = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    result = ms->footprint;
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return result;
}

size_t mspace_max_footprint(mspace msp) {
  size_t result = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    result = ms->max_footprint;
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return result;
}

size_t mspace_footprint_limit(mspace msp) {
  size_t result = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    size_t maf = ms->footprint_limit;
    result = (maf == 0) ? MAX_SIZE_T : maf;
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return result;
}

size_t mspace_set_footprint_limit(mspace msp, size_t bytes) {
  size_t result = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    if (bytes == 0)
      result = granularity_align(1); /* Use minimal size */
    if (bytes == MAX_SIZE_T)
      result = 0;                    /* disable */
    else
      result = granularity_align(bytes);
    ms->footprint_limit = result;
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return result;
}

#if !NO_MALLINFO
struct mallinfo mspace_mallinfo(mspace msp) {
  mstate ms = (mstate)msp;
  if (!ok_magic(ms)) {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return internal_mallinfo(ms);
}
#endif /* NO_MALLINFO */

size_t mspace_usable_size(const void* mem) {
  if (mem != 0) {
    mchunkptr p = mem2chunk(mem);
    if (is_inuse(p))
      return chunksize(p) - overhead_for(p);
  }
  return 0;
}

int mspace_mallopt(int param_number, int value) {
  return change_mparam(param_number, value);
}

#endif /* MSPACES */


/* -------------------- Alternative MORECORE functions ------------------- */

/*
  Guidelines for creating a custom version of MORECORE:

  * For best performance, MORECORE should allocate in multiples of pagesize.
  * MORECORE may allocate more memory than requested. (Or even less,
      but this will usually result in a malloc failure.)
  * MORECORE must not allocate memory when given argument zero, but
      instead return one past the end address of memory from previous
      nonzero call.
  * For best performance, consecutive calls to MORECORE with positive
      arguments should return increasing addresses, indicating that
      space has been contiguously extended.
  * Even though consecutive calls to MORECORE need not return contiguous
      addresses, it must be OK for malloc'ed chunks to span multiple
      regions in those cases where they do happen to be contiguous.
  * MORECORE need not handle negative arguments -- it may instead
      just return MFAIL when given negative arguments.
      Negative arguments are always multiples of pagesize. MORECORE
      must not misinterpret negative args as large positive unsigned
      args. You can suppress all such calls from even occurring by defining
      MORECORE_CANNOT_TRIM,

  As an example alternative MORECORE, here is a custom allocator
  kindly contributed for pre-OSX macOS.  It uses virtually but not
  necessarily physically contiguous non-paged memory (locked in,
  present and won't get swapped out).  You can use it by uncommenting
  this section, adding some #includes, and setting up the appropriate
  defines above:

      #define MORECORE osMoreCore

  There is also a shutdown routine that should somehow be called for
  cleanup upon program exit.

  #define MAX_POOL_ENTRIES 100
  #define MINIMUM_MORECORE_SIZE  (64 * 1024U)
  static int next_os_pool;
  void *our_os_pools[MAX_POOL_ENTRIES];

  void *osMoreCore(int size)
  {
    void *ptr = 0;
    static void *sbrk_top = 0;

    if (size > 0)
    {
      if (size < MINIMUM_MORECORE_SIZE)
         size = MINIMUM_MORECORE_SIZE;
      if (CurrentExecutionLevel() == kTaskLevel)
         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
      if (ptr == 0)
      {
        return (void *) MFAIL;
      }
      // save ptrs so they can be freed during cleanup
      our_os_pools[next_os_pool] = ptr;
      next_os_pool++;
      ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);
      sbrk_top = (char *) ptr + size;
      return ptr;
    }
    else if (size < 0)
    {
      // we don't currently support shrink behavior
      return (void *) MFAIL;
    }
    else
    {
      return sbrk_top;
    }
  }

  // cleanup any allocated memory pools
  // called as last thing before shutting down driver

  void osCleanupMem(void)
  {
    void **ptr;

    for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)
      if (*ptr)
      {
         PoolDeallocate(*ptr);
         *ptr = 0;
      }
  }

*/


/* -----------------------------------------------------------------------
History:
    v2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
      * fix bad comparison in dlposix_memalign
      * don't reuse adjusted asize in sys_alloc
      * add LOCK_AT_FORK -- thanks to Kirill Artamonov for the suggestion
      * reduce compiler warnings -- thanks to all who reported/suggested these

    v2.8.5 Sun May 22 10:26:02 2011  Doug Lea  (dl at gee)
      * Always perform unlink checks unless INSECURE
      * Add posix_memalign.
      * Improve realloc to expand in more cases; expose realloc_in_place.
        Thanks to Peter Buhr for the suggestion.
      * Add footprint_limit, inspect_all, bulk_free. Thanks
        to Barry Hayes and others for the suggestions.
      * Internal refactorings to avoid calls while holding locks
      * Use non-reentrant locks by default. Thanks to Roland McGrath
        for the suggestion.
      * Small fixes to mspace_destroy, reset_on_error.
      * Various configuration extensions/changes. Thanks
         to all who contributed these.

    V2.8.4a Thu Apr 28 14:39:43 2011 (dl at gee.cs.oswego.edu)
      * Update Creative Commons URL

    V2.8.4 Wed May 27 09:56:23 2009  Doug Lea  (dl at gee)
      * Use zeros instead of prev foot for is_mmapped
      * Add mspace_track_large_chunks; thanks to Jean Brouwers
      * Fix set_inuse in internal_realloc; thanks to Jean Brouwers
      * Fix insufficient sys_alloc padding when using 16byte alignment
      * Fix bad error check in mspace_footprint
      * Adaptations for ptmalloc; thanks to Wolfram Gloger.
      * Reentrant spin locks; thanks to Earl Chew and others
      * Win32 improvements; thanks to Niall Douglas and Earl Chew
      * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options
      * Extension hook in malloc_state
      * Various small adjustments to reduce warnings on some compilers
      * Various configuration extensions/changes for more platforms. Thanks
         to all who contributed these.

    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)
      * Add max_footprint functions
      * Ensure all appropriate literals are size_t
      * Fix conditional compilation problem for some #define settings
      * Avoid concatenating segments with the one provided
        in create_mspace_with_base
      * Rename some variables to avoid compiler shadowing warnings
      * Use explicit lock initialization.
      * Better handling of sbrk interference.
      * Simplify and fix segment insertion, trimming and mspace_destroy
      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x
      * Thanks especially to Dennis Flanagan for help on these.

    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
      * Fix memalign brace error.

    V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)
      * Fix improper #endif nesting in C++
      * Add explicit casts needed for C++

    V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)
      * Use trees for large bins
      * Support mspaces
      * Use segments to unify sbrk-based and mmap-based system allocation,
        removing need for emulation on most platforms without sbrk.
      * Default safety checks
      * Optional footer checks. Thanks to William Robertson for the idea.
      * Internal code refactoring
      * Incorporate suggestions and platform-specific changes.
        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
        Aaron Bachmann,  Emery Berger, and others.
      * Speed up non-fastbin processing enough to remove fastbins.
      * Remove useless cfree() to avoid conflicts with other apps.
      * Remove internal memcpy, memset. Compilers handle builtins better.
      * Remove some options that no one ever used and rename others.

    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
      * Fix malloc_state bitmap array misdeclaration

    V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)
      * Allow tuning of FIRST_SORTED_BIN_SIZE
      * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.
      * Better detection and support for non-contiguousness of MORECORE.
        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
      * Bypass most of malloc if no frees. Thanks To Emery Berger.
      * Fix freeing of old top non-contiguous chunk im sysmalloc.
      * Raised default trim and map thresholds to 256K.
      * Fix mmap-related #defines. Thanks to Lubos Lunak.
      * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.
      * Branch-free bin calculation
      * Default trim and mmap thresholds now 256K.

    V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)
      * Introduce independent_comalloc and independent_calloc.
        Thanks to Michael Pachos for motivation and help.
      * Make optional .h file available
      * Allow > 2GB requests on 32bit systems.
      * new WIN32 sbrk, mmap, munmap, lock code from <Walter@@GeNeSys-e.de>.
        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
        and Anonymous.
      * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for
        helping test this.)
      * memalign: check alignment arg
      * realloc: don't try to shift chunks backwards, since this
        leads to  more fragmentation in some programs and doesn't
        seem to help in any others.
      * Collect all cases in malloc requiring system memory into sysmalloc
      * Use mmap as backup to sbrk
      * Place all internal state in malloc_state
      * Introduce fastbins (although similar to 2.5.1)
      * Many minor tunings and cosmetic improvements
      * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK
      * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS
        Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
      * Include errno.h to support default failure action.

    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)
      * return null for negative arguments
      * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com>
         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
          (e.g. WIN32 platforms)
         * Cleanup header file inclusion for WIN32 platforms
         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
           memory allocation routines
         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
           usage of 'assert' in non-WIN32 code
         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
           avoid infinite loop
      * Always call 'fREe()' rather than 'free()'

    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)
      * Fixed ordering problem with boundary-stamping

    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)
      * Added pvalloc, as recommended by H.J. Liu
      * Added 64bit pointer support mainly from Wolfram Gloger
      * Added anonymously donated WIN32 sbrk emulation
      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen
      * malloc_extend_top: fix mask error that caused wastage after
        foreign sbrks
      * Add linux mremap support code from HJ Liu

    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)
      * Integrated most documentation with the code.
      * Add support for mmap, with help from
        Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
      * Use last_remainder in more cases.
      * Pack bins using idea from  colin@@nyx10.cs.du.edu
      * Use ordered bins instead of best-fit threshhold
      * Eliminate block-local decls to simplify tracing and debugging.
      * Support another case of realloc via move into top
      * Fix error occuring when initial sbrk_base not word-aligned.
      * Rely on page size for units instead of SBRK_UNIT to
        avoid surprises about sbrk alignment conventions.
      * Add mallinfo, mallopt. Thanks to Raymond Nijssen
        (raymond@@es.ele.tue.nl) for the suggestion.
      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.
      * More precautions for cases where other routines call sbrk,
        courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
      * Added macros etc., allowing use in linux libc from
        H.J. Lu (hjl@@gnu.ai.mit.edu)
      * Inverted this history list

    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)
      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.
      * Removed all preallocation code since under current scheme
        the work required to undo bad preallocations exceeds
        the work saved in good cases for most test programs.
      * No longer use return list or unconsolidated bins since
        no scheme using them consistently outperforms those that don't
        given above changes.
      * Use best fit for very large chunks to prevent some worst-cases.
      * Added some support for debugging

    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)
      * Removed footers when chunks are in use. Thanks to
        Paul Wilson (wilson@@cs.texas.edu) for the suggestion.

    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)
      * Added malloc_trim, with help from Wolfram Gloger
        (wmglo@@Dent.MED.Uni-Muenchen.DE).

    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)

    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)
      * realloc: try to expand in both directions
      * malloc: swap order of clean-bin strategy;
      * realloc: only conditionally expand backwards
      * Try not to scavenge used bins
      * Use bin counts as a guide to preallocation
      * Occasionally bin return list chunks in first scan
      * Add a few optimizations from colin@@nyx10.cs.du.edu

    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)
      * faster bin computation & slightly different binning
      * merged all consolidations to one part of malloc proper
         (eliminating old malloc_find_space & malloc_clean_bin)
      * Scan 2 returns chunks (not just 1)
      * Propagate failure in realloc if malloc returns 0
      * Add stuff to allow compilation on non-ANSI compilers
          from kpv@@research.att.com

    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)
      * removed potential for odd address access in prev_chunk
      * removed dependency on getpagesize.h
      * misc cosmetics and a bit more internal documentation
      * anticosmetics: mangled names in macros to evade debugger strangeness
      * tested on sparc, hp-700, dec-mips, rs6000
          with gcc & native cc (hp, dec only) allowing
          Detlefs & Zorn comparison study (in SIGPLAN Notices.)

    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)
      * Based loosely on libg++-1.2X malloc. (It retains some of the overall
         structure of old version,  but most details differ.)

*/
@


1.11
log
@* malloc.cc: Update to version 2.8.3.
* cygmalloc.h (MSPACE): Remove unneeded definition.
@
text
@d4 1
a4 1
  http://creativecommons.org/licenses/publicdomain.  Send questions,
d7 1
a7 2
* Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)

d9 2
a10 2
	   ftp://gee.cs.oswego.edu/pub/misc/malloc.c
	 Check before installing!
d21 1
a21 1
     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.3.h
d43 1
a43 1
  Alignment:                                     8 bytes (default)
d49 1
a49 1
					  8 or 16 bytes (if 8byte sizes)
d55 1
a55 1
			  8-byte ptrs:  32 bytes    (including overhead)
d106 7
a112 1
  Thread-safety: NOT thread-safe unless USE_LOCKS defined
d114 14
a127 7
       etc is surrounded with either a pthread mutex or a win32
       spinlock (depending on WIN32). This is not especially fast, and
       can be a major bottleneck.  It is designed only to provide
       minimal protection in concurrent environments, and to provide a
       basis for extensions.  If you are using malloc in a concurrent
       program, consider instead using ptmalloc, which is derived from
       a version of this malloc. (See http://www.malloc.de).
d168 5
a172 1
  system allocation routines, which is often just 1.
d216 1
a216 1
  originating spaces.
d222 2
a223 1
to size_t precision unless they are explicitly casted.
d227 20
a246 1
  Otherwise defaults are for unix.
d248 1
a248 1
MALLOC_ALIGNMENT         default: (size_t)8
d265 21
a285 1
  overridden on a per-mspace basis for mspace versions.)
d300 6
d362 1
a362 3
  possibilities, although sometimes generating compiler warnings.  See
  near the end of this file for guidelines for creating a custom
  version of MORECORE.
d364 1
a364 1
MORECORE_CONTIGUOUS       default: 1 (true)
d378 6
d398 1
a398 1
MMAP_CLEARS               default: 1 on unix
d400 1
a400 1
  for standard unix mmap using /dev/zero.
d407 2
a408 2
  this setting has no effect. (On most x86s, the asm version is only
  slightly faster than the C version.)
d431 4
d443 1
a443 1
LACKS_STDLIB_H                default: NOT defined unless on WIN32
d448 2
a449 2
				system_info.dwAllocationGranularity in WIN32,
				otherwise 64K.
d509 23
a531 1
*/
d537 4
d545 1
d555 2
d558 8
a565 1
#define MMAP_CLEARS 0 /* WINCE and some others apparently don't clear */
d573 4
d590 20
d621 1
a621 1
#define MALLOC_ALIGNMENT ((size_t)8U)
d635 1
a635 3
#ifndef USE_LOCKS
#define USE_LOCKS 0
#endif  /* USE_LOCKS */
d639 3
d651 1
d669 1
a669 3
#ifndef MORECORE
#define MORECORE sbrk
#endif  /* MORECORE */
d675 1
a675 1
#if MORECORE_CONTIGUOUS
d695 7
d714 6
d762 4
a765 1

d778 1
a778 1

d782 22
d806 3
d810 3
d823 1
d825 1
d835 3
d840 1
a842 1

d857 1
a857 1
void* dlmalloc(size_t);
d866 1
a866 1
void  dlfree(void*);
d873 1
a873 1
void* dlcalloc(size_t, size_t);
d897 12
d910 3
a912 1
void* dlrealloc(void*, size_t);
d926 11
a936 1
void* dlmemalign(size_t, size_t);
d943 1
a943 1
void* dlvalloc(size_t);
d951 5
a955 1
  0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,
d963 1
a963 1
  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (MAX_SIZE_T disables)
d967 1
a967 1
int dlmallopt(int, int);
d978 1
a978 1
size_t dlmalloc_footprint(void);
d991 60
a1050 1
size_t dlmalloc_max_footprint(void);
d1063 1
a1063 1
		than current total if trimming has occurred.
d1068 2
a1069 2
	       back to system via malloc_trim. ("ideally" means that
	       it ignores page restrictions etc.)
d1075 1
a1075 1
struct mallinfo dlmallinfo(void);
d1102 2
a1103 5
  Each element must be individually freed when it is no longer
  needed. If you'd like to instead be able to free all at once, you
  should instead use regular calloc and assign pointers into this
  space to represent elements.  (In this case though, you cannot
  independently free elements.)
d1127 1
a1127 1
void** dlindependent_calloc(size_t, size_t, void**);
d1151 2
a1152 5
  Each element must be individually freed when it is no longer
  needed. If you'd like to instead be able to free all at once, you
  should instead use a single regular malloc, and assign pointers at
  particular offsets in the aggregate space. (In this case though, you
  cannot independently free elements.)
d1185 1
a1185 1
void** dlindependent_comalloc(size_t, size_t*, void**);
d1187 10
d1203 1
a1203 1
void*  dlpvalloc(size_t);
d1226 1
a1226 17
int  dlmalloc_trim(size_t);

/*
  malloc_usable_size(void* p);

  Returns the number of bytes you can actually use in
  an allocated chunk, which may be more than you requested (although
  often not) due to alignment and minimum size constraints.
  You can use this many bytes without worrying about
  overwriting other allocated objects. This is not a particularly great
  programming practice. malloc_usable_size can be more useful in
  debugging and assertions, for example:

  p = malloc(n);
  assert(malloc_usable_size(p) >= 256);
*/
size_t dlmalloc_usable_size(void*);
d1247 17
a1263 1
void  dlmalloc_stats(void);
d1286 1
a1286 1
mspace create_mspace(size_t capacity, int locked);
d1294 1
a1294 1
size_t destroy_mspace(mspace msp);
d1305 15
a1319 1
mspace create_mspace_with_base(void* base, size_t capacity, int locked);
d1325 1
a1325 1
void* mspace_malloc(mspace msp, size_t bytes);
d1335 1
a1335 1
void mspace_free(mspace msp, void* mem);
d1346 1
a1346 1
void* mspace_realloc(mspace msp, void* mem, size_t newsize);
d1352 1
a1352 1
void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
d1358 1
a1358 1
void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
d1364 2
a1365 2
void** mspace_independent_calloc(mspace msp, size_t n_elements,
				 size_t elem_size, void* chunks[]);
d1371 2
a1372 2
void** mspace_independent_comalloc(mspace msp, size_t n_elements,
				   size_t sizes[], void* chunks[]);
d1378 1
a1378 1
size_t mspace_footprint(mspace msp);
d1384 1
a1384 1
size_t mspace_max_footprint(mspace msp);
d1392 1
a1392 1
struct mallinfo mspace_mallinfo(mspace msp);
d1396 5
d1404 1
a1404 1
void mspace_malloc_stats(mspace msp);
d1410 1
a1410 1
int mspace_trim(mspace msp, size_t pad);
d1415 1
a1415 1
int mspace_mallopt(int, int);
d1420 1
a1420 1
};  /* end of extern "C" */
d1435 1
a1435 1
#ifdef WIN32
d1437 2
a1438 2
#endif /* WIN32 */

d1440 1
a1440 1

a1443 6
#if FOOTERS
#include <time.h>        /* for magic initialization */
#endif /* FOOTERS */
#ifndef LACKS_STDLIB_H
#include <stdlib.h>      /* for abort() */
#endif /* LACKS_STDLIB_H */
d1446 1
d1452 1
d1454 2
d1457 6
d1473 3
d1477 4
a1485 1
#if HAVE_MORECORE
d1487 1
a1487 1
#include <unistd.h>     /* for sbrk */
d1493 57
a1549 1
#endif /* HAVE_MMAP */
d1605 1
a1605 1
/* Annoying but necessary to avoid errors on some plaftorms */
d1609 1
d1639 1
a1639 10
#if !HAVE_MMAP
#define IS_MMAPPED_BIT       (SIZE_T_ZERO)
#define USE_MMAP_BIT         (SIZE_T_ZERO)
#define CALL_MMAP(s)         MFAIL
#define CALL_MUNMAP(a, s)    (-1)
#define DIRECT_MMAP(s)       MFAIL

#else /* HAVE_MMAP */
#define IS_MMAPPED_BIT       (SIZE_T_ONE)
#define USE_MMAP_BIT         (SIZE_T_ONE)
d1642 1
a1642 1
#define CALL_MUNMAP(a, s)    munmap((a), (s))
d1649 1
a1649 1
#define CALL_MMAP(s)         mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
d1657 4
a1660 4
#define CALL_MMAP(s) ((dev_zero_fd < 0) ? \
	   (dev_zero_fd = open("/dev/zero", O_RDWR), \
	    mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
	    mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
d1663 2
a1664 1
#define DIRECT_MMAP(s)       CALL_MMAP(s)
d1668 1
a1668 1
static void* win32mmap(size_t size) {
d1674 1
a1674 1
static void* win32direct_mmap(size_t size) {
d1676 1
a1676 1
			   PAGE_READWRITE);
d1681 1
a1681 1
static int win32munmap(void* ptr, size_t size) {
d1683 1
a1683 1
  char* cptr = ptr;
d1688 1
a1688 1
	minfo.State != MEM_COMMIT || minfo.RegionSize > size)
d1698 3
a1700 3
#define CALL_MMAP(s)         win32mmap(s)
#define CALL_MUNMAP(a, s)    win32munmap((a), (s))
#define DIRECT_MMAP(s)       win32direct_mmap(s)
d1704 5
a1708 5
#if HAVE_MMAP && HAVE_MREMAP
#define CALL_MREMAP(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
#else  /* HAVE_MMAP && HAVE_MREMAP */
#define CALL_MREMAP(addr, osz, nsz, mv) MFAIL
#endif /* HAVE_MMAP && HAVE_MREMAP */
d1710 3
d1714 5
a1718 1
#define CALL_MORECORE(S)     MORECORE(S)
d1720 1
a1720 1
#define CALL_MORECORE(S)     MFAIL
d1723 45
a1776 2
#if USE_LOCKS

d1778 2
a1779 1
  When locks are defined, there are up to two global locks:
d1781 21
a1801 6
  * If HAVE_MORECORE, morecore_mutex protects sequences of calls to
    MORECORE.  In many cases sys_alloc requires two calls, that should
    not be interleaved with calls by other threads.  This does not
    protect against direct calls to MORECORE by other threads not
    using this lock, so there is still code to cope the best we can on
    interference.
a1802 2
  * magic_init_mutex ensures that mparams.magic and other
    unique mparams values are initialized only once.
d1805 108
a1912 7
#ifndef WIN32
/* By default use posix locks */
#include <pthread.h>
#define MLOCK_T pthread_mutex_t
#define INITIAL_LOCK(l)      pthread_mutex_init(l, NULL)
#define ACQUIRE_LOCK(l)      pthread_mutex_lock(l)
#define RELEASE_LOCK(l)      pthread_mutex_unlock(l)
d1914 5
a1918 3
#if HAVE_MORECORE
static MLOCK_T morecore_mutex = PTHREAD_MUTEX_INITIALIZER;
#endif /* HAVE_MORECORE */
d1920 2
a1921 1
static MLOCK_T magic_init_mutex = PTHREAD_MUTEX_INITIALIZER;
d1923 6
a1928 5
#else /* WIN32 */
/*
   Because lock-protected regions have bounded times, and there
   are no recursive lock calls, we can use simple spinlocks.
*/
d1930 3
a1932 2
#define MLOCK_T long
static int win32_acquire_lock (MLOCK_T *sl) {
d1934 9
a1942 2
#ifdef InterlockedCompareExchangePointer
    if (!InterlockedCompareExchange(sl, 1, 0))
d1944 56
a1999 5
#else  /* Use older void* version */
    if (!InterlockedCompareExchange((void**)sl, (void*)1, (void*)0))
      return 0;
#endif /* InterlockedCompareExchangePointer */
    Sleep (0);
d2003 28
a2030 2
static void win32_release_lock (MLOCK_T *sl) {
  InterlockedExchange (sl, 0);
d2033 1
a2033 8
#define INITIAL_LOCK(l)      *(l)=0
#define ACQUIRE_LOCK(l)      win32_acquire_lock(l)
#define RELEASE_LOCK(l)      win32_release_lock(l)
#if HAVE_MORECORE
static MLOCK_T morecore_mutex;
#endif /* HAVE_MORECORE */
static MLOCK_T magic_init_mutex;
#endif /* WIN32 */
d2035 1
a2036 4
#else  /* USE_LOCKS */
#define USE_LOCK_BIT               (0U)
#define INITIAL_LOCK(l)
#endif /* USE_LOCKS */
d2038 7
a2044 7
#if USE_LOCKS && HAVE_MORECORE
#define ACQUIRE_MORECORE_LOCK()    ACQUIRE_LOCK(&morecore_mutex);
#define RELEASE_MORECORE_LOCK()    RELEASE_LOCK(&morecore_mutex);
#else /* USE_LOCKS && HAVE_MORECORE */
#define ACQUIRE_MORECORE_LOCK()
#define RELEASE_MORECORE_LOCK()
#endif /* USE_LOCKS && HAVE_MORECORE */
a2045 6
#if USE_LOCKS
#define ACQUIRE_MAGIC_INIT_LOCK()  ACQUIRE_LOCK(&magic_init_mutex);
#define RELEASE_MAGIC_INIT_LOCK()  RELEASE_LOCK(&magic_init_mutex);
#else  /* USE_LOCKS */
#define ACQUIRE_MAGIC_INIT_LOCK()
#define RELEASE_MAGIC_INIT_LOCK()
a2047 1

d2073 4
a2076 4
	   | Size of previous chunk (if P = 1)                             |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
	 | Size of this chunk                                         1| +-+
d2078 7
a2084 7
	 |                                                               |
	 +-                                                             -+
	 |                                                               |
	 +-                                                             -+
	 |                                                               :
	 +-      size - sizeof(size_t) available payload bytes          -+
	 :                                                               |
d2086 2
a2087 2
	 |                                                               |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2095 4
a2098 4
	   | User payload (must be in use, or we would have merged!)       |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
	 | Size of this chunk                                         0| +-+
d2100 7
a2106 7
	 | Next pointer                                                  |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 | Prev pointer                                                  |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 |                                                               :
	 +-      size - sizeof(struct chunk) unused bytes               -+
	 :                                                               |
d2108 2
a2109 2
	 | Size of this chunk                                            |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2117 2
a2118 2
								     |0|
								     +-+
d2144 3
a2146 2
  inuse. This redundancy enables usage checks within free and realloc,
  and reduces indirection when freeing and consolidating chunks.
d2151 1
a2151 1
  ensured by making all allocations from the the `lowest' part of any
d2164 18
a2181 19
	the one bordering the end of available memory). It is treated
	specially.  Top is never included in any bin, is used only if
	no other chunk is available, and is released back to the
	system if it is very large (see M_TRIM_THRESHOLD).  In effect,
	the top chunk is treated as larger (and thus less well
	fitting) than any other available chunk.  The top chunk
	doesn't update its trailing size field since there is no next
	contiguous chunk that would have to index off it. However,
	space is still allocated for it (TOP_FOOT_SIZE) to enable
	separation or merging when space is extended.

     3. Chunks allocated via mmap, which have the lowest-order bit
	(IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
	PINUSE_BIT in their head fields.  Because they are allocated
	one-by-one, each must carry its own prev_foot field, which is
	also used to hold the offset this chunk has within its mmapped
	region, which is needed to preserve alignment. Each mmapped
	chunk is trailed by the first two fields of a fake next-chunk
	for sake of usage checks.
d2242 3
a2244 3
  use. If the chunk was obtained with mmap, the prev_foot field has
  IS_MMAPPED_BIT set, otherwise holding the offset of the base of the
  mmapped region to the base of the chunk.
d2249 1
d2251 1
d2259 5
a2263 1
#define chunksize(p)        ((p)->head & ~(INUSE_BITS))
d2266 2
a2267 1
#define clear_cinuse(p)     ((p)->head &= ~CINUSE_BIT)
d2274 1
a2274 1
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~INUSE_BITS)))
a2291 3
#define is_mmapped(p)\
  (!((p)->head & PINUSE_BIT) && ((p)->prev_foot & IS_MMAPPED_BIT))

d2313 2
a2314 2
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2317 7
a2323 7
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
d2326 1
a2326 1
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2334 2
a2335 2
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2338 14
a2351 14
	    |             Forward pointer to next chunk of same size        |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk of same size       |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to left child (child[0])                  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to right child (child[1])                 |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to parent                                 |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             bin index of this chunk                           |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space                                      .
	    .                                                               |
d2354 1
a2354 1
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2462 1
a2462 1
  * If IS_MMAPPED_BIT set, the segment may be merged with
d2477 1
a2477 1
#define is_mmapped_segment(S)  ((S)->sflags & IS_MMAPPED_BIT)
d2546 3
d2556 5
d2564 4
d2589 1
d2595 1
d2601 2
d2612 2
a2613 1
  initialized in init_mparams.
d2627 5
d2636 3
d2647 1
d2649 3
d2655 1
d2657 3
d2671 1
a2671 1
 (((S) + (mparams.page_size)) & ~(mparams.page_size - SIZE_T_ONE))
d2675 13
a2687 1
  (((S) + (mparams.granularity)) & ~(mparams.granularity - SIZE_T_ONE))
d2744 1
a2744 5

/* Ensure locks are initialized */
#define GLOBALLY_INITIALIZE() (mparams.page_size == 0 && init_mparams())

#define PREACTION(M)  ((GLOBALLY_INITIALIZE() || use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
d2789 1
d2826 1
a2826 1
#define small_index(s)      ((s)  >> SMALLBIN_SHIFT)
d2834 30
a2863 2
/* assign tree index for size S to variable I */
#if defined(__GNUC__) && defined(i386)
d2873 1
a2873 1
    __asm__("bsrl %1,%0\n\t" : "=r" (K) : "rm"  (X));\
d2877 1
d2927 5
a2931 1
/* index corresponding to given bit */
d2933 22
a2954 1
#if defined(__GNUC__) && defined(i386)
d2958 1
a2958 1
  __asm__("bsfl %1,%0\n\t" : "=r" (J) : "rm" (X));\
d2962 1
a2962 2
#else /* GNUC */
#if  USE_BUILTIN_FFS
d2965 1
a2965 1
#else /* USE_BUILTIN_FFS */
a2976 1
#endif /* USE_BUILTIN_FFS */
a2978 9
/* isolate the least set bit of a bitmap */
#define least_bit(x)         ((x) & -(x))

/* mask with all bits to left of least bit of x on */
#define left_bits(x)         ((x<<1) | -(x<<1))

/* mask with all bits to left of or equal to least bit of x on */
#define same_or_left_bits(x) ((x) | -(x))

d3000 1
a3000 1
  (probablistically) unguessable from outside the program, but can be
d3013 2
a3014 2
/* Check if p has its cinuse bit on */
#define ok_cinuse(p)     cinuse(p)
d3021 1
a3021 1
#define ok_cinuse(p)     (1)
a3031 1

d3049 2
d3093 6
d3101 23
a3123 2
  if (mparams.page_size == 0) {
    size_t s;
d3125 17
d3150 9
a3158 1
#if (FOOTERS && !INSECURE)
d3165 3
a3167 3
	  read(fd, buf, sizeof(buf)) == sizeof(buf)) {
	s = *((size_t *) buf);
	close(fd);
d3171 11
a3181 5
	s = (size_t)(time(0) ^ (size_t)0x55555555U);

      s |= (size_t)8U;    /* ensure nonzero */
      s &= ~(size_t)7U;   /* improve chances of fault for bad values */

d3183 1
a3183 24
#else /* (FOOTERS && !INSECURE) */
    s = (size_t)0x58585858U;
#endif /* (FOOTERS && !INSECURE) */
    ACQUIRE_MAGIC_INIT_LOCK();
    if (mparams.magic == 0) {
      mparams.magic = s;
      /* Set up lock for main malloc area */
      INITIAL_LOCK(&gm->mutex);
      gm->mflags = mparams.default_mflags;
    }
    RELEASE_MAGIC_INIT_LOCK();

#ifndef WIN32
    mparams.page_size = malloc_getpagesize;
    mparams.granularity = ((DEFAULT_GRANULARITY != 0)?
			   DEFAULT_GRANULARITY : mparams.page_size);
#else /* WIN32 */
    {
      SYSTEM_INFO system_info;
      GetSystemInfo(&system_info);
      mparams.page_size = system_info.dwPageSize;
      mparams.granularity = system_info.dwAllocationGranularity;
    }
#endif /* WIN32 */
d3185 2
a3186 17
    /* Sanity-check configuration:
       size_t must be unsigned and as wide as pointer type.
       ints must be at least 4 bytes.
       alignment must be at least 8.
       Alignment, min chunk size, and page size must all be powers of 2.
    */
    if ((sizeof(size_t) != sizeof(char*)) ||
	(MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
	(sizeof(int) < 4)  ||
	(MALLOC_ALIGNMENT < (size_t)8U) ||
	((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
	((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
	((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||
	((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))
      ABORT;
  }
  return 0;
d3191 3
a3193 2
  size_t val = (size_t)value;
  init_mparams();
d3225 1
a3225 1
  size_t  sz = chunksize(p);
d3233 1
a3233 1
  assert(!next_pinuse(p));
d3239 1
a3239 1
  size_t len = (sz + (p->prev_foot & ~IS_MMAPPED_BIT) + MMAP_FOOT_PAD);
d3253 1
a3253 1
  assert(cinuse(p));
d3263 1
a3263 1
  size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);
d3266 1
a3266 1
  assert(!cinuse(p));
d3275 1
a3275 1
      assert (next == m->top || cinuse(next));
d3288 1
a3288 1
    size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);
d3315 1
a3315 1
    assert(!cinuse(u));
d3328 2
a3329 2
	      u->parent->child[1] == u ||
	      *((tbinptr*)(u->parent)) == u);
d3331 3
a3333 3
	assert(u->child[0]->parent == u);
	assert(u->child[0] != u);
	do_check_tree(m, u->child[0]);
d3336 3
a3338 3
	assert(u->child[1]->parent == u);
	assert(u->child[1] != u);
	do_check_tree(m, u->child[1]);
d3341 1
a3341 1
	assert(chunksize(u->child[0]) < chunksize(u->child[1]));
d3379 1
a3379 1
	do_check_inuse_chunk(m, q);
d3393 2
a3394 2
	if (p == x)
	  return 1;
d3405 2
a3406 2
	t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
	sizebits <<= 1;
d3409 5
a3413 5
	tchunkptr u = t;
	do {
	  if (u == (tchunkptr)x)
	    return 1;
	} while ((u = u->fd) != t);
d3431 13
a3443 13
	     q != m->top && q->head != FENCEPOST_HEAD) {
	sum += chunksize(q);
	if (cinuse(q)) {
	  assert(!bin_find(m, q));
	  do_check_inuse_chunk(m, q);
	}
	else {
	  assert(q == m->dv || bin_find(m, q));
	  assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */
	  do_check_free_chunk(m, q);
	}
	lastq = q;
	q = next_chunk(q);
d3451 1
d3471 1
a3471 1
    assert(m->topsize == chunksize(m->top));
d3487 1
d3496 12
a3507 12
	mchunkptr q = align_as_chunk(s->base);
	while (segment_holds(s, q) &&
	       q != m->top && q->head != FENCEPOST_HEAD) {
	  size_t sz = chunksize(q);
	  sum += sz;
	  if (!cinuse(q)) {
	    mfree += sz;
	    ++nfree;
	  }
	  q = next_chunk(q);
	}
	s = s->next;
d3525 1
d3527 1
d3540 8
a3547 8
	mchunkptr q = align_as_chunk(s->base);
	while (segment_holds(s, q) &&
	       q != m->top && q->head != FENCEPOST_HEAD) {
	  if (!cinuse(q))
	    used -= chunksize(q);
	  q = next_chunk(q);
	}
	s = s->next;
d3550 1
a3550 1

a3553 2

    POSTACTION(m);
d3556 1
d3594 12
a3605 6
  if (F == B)\
    clear_smallmap(M, I);\
  else if (RTCHECK((F == smallbin_at(M,I) || ok_address(M, F)) &&\
		   (B == smallbin_at(M,I) || ok_address(M, B)))) {\
    F->bk = B;\
    B->fd = F;\
d3618 1
a3618 1
  if (B == F)\
d3620 3
a3622 1
  else if (RTCHECK(ok_address(M, F))) {\
a3623 1
    F->bk = B;\
d3634 1
a3636 1
    assert(is_small(DVS));\
d3664 14
a3677 14
	tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
	K <<= 1;\
	if (*C != 0)\
	  T = *C;\
	else if (RTCHECK(ok_address(M, C))) {\
	  *C = X;\
	  X->parent = T;\
	  X->fd = X->bk = X;\
	  break;\
	}\
	else {\
	  CORRUPTION_ERROR_ACTION(M);\
	  break;\
	}\
d3680 12
a3691 12
	tchunkptr F = T->fd;\
	if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
	  T->fd = F->bk = X;\
	  X->fd = F;\
	  X->bk = T;\
	  X->parent = 0;\
	  break;\
	}\
	else {\
	  CORRUPTION_ERROR_ACTION(M);\
	  break;\
	}\
d3720 1
a3720 1
    if (RTCHECK(ok_address(M, F))) {\
d3731 1
a3731 1
	((R = *(RP = &(X->child[0]))) != 0)) {\
d3734 2
a3735 2
	     (*(CP = &(R->child[0])) != 0)) {\
	R = *(RP = CP);\
d3738 1
a3738 1
	*RP = 0;\
d3740 1
a3740 1
	CORRUPTION_ERROR_ACTION(M);\
d3748 1
a3748 1
	clear_treemap(M, X->index);\
d3752 1
a3752 1
	XP->child[0] = R;\
d3754 1
a3754 1
	XP->child[1] = R;\
d3760 18
a3777 18
	tchunkptr C0, C1;\
	R->parent = XP;\
	if ((C0 = X->child[0]) != 0) {\
	  if (RTCHECK(ok_address(M, C0))) {\
	    R->child[0] = C0;\
	    C0->parent = R;\
	  }\
	  else\
	    CORRUPTION_ERROR_ACTION(M);\
	}\
	if ((C1 = X->child[1]) != 0) {\
	  if (RTCHECK(ok_address(M, C1))) {\
	    R->child[1] = C1;\
	    C1->parent = R;\
	  }\
	  else\
	    CORRUPTION_ERROR_ACTION(M);\
	}\
d3780 1
a3780 1
	CORRUPTION_ERROR_ACTION(M);\
d3804 1
a3804 1
   (m == gm)? dlmalloc(b) : mspace_malloc(m, b)
d3820 1
a3820 3
  requirements (especially in memalign).  There is also enough space
  allocated to hold a fake next chunk of size SIZE_T_SIZE to maintain
  the PINUSE bit so frees can be checked.
d3825 6
a3830 1
  size_t mmsize = granularity_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3832 1
a3832 1
    char* mm = (char*)(DIRECT_MMAP(mmsize));
d3837 2
a3838 2
      p->prev_foot = offset | IS_MMAPPED_BIT;
      (p)->head = (psize|CINUSE_BIT);
d3843 2
a3844 2
      if (mm < m->least_addr)
	m->least_addr = mm;
d3846 1
a3846 1
	m->max_footprint = m->footprint;
d3856 1
a3856 1
static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb) {
d3858 1
d3866 1
a3866 1
    size_t offset = oldp->prev_foot & ~IS_MMAPPED_BIT;
d3868 1
a3868 2
    size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +
					 CHUNK_ALIGN_MASK);
d3870 1
a3870 1
				  oldmmsize, newmmsize, 1);
d3874 1
a3874 1
      newp->head = (psize|CINUSE_BIT);
d3880 1
a3880 1
	m->least_addr = cp;
d3882 1
a3882 1
	m->max_footprint = m->footprint;
d3890 1
d3925 1
a3925 1
  m->smallbins = m->treebins = 0;
d3939 1
a3939 1
			   size_t nb) {
d3964 1
a3964 1
    if (!cinuse(oldfirst)) {
a3978 1

d4039 1
d4041 1
a4041 1
  init_mparams();
d4043 2
a4044 2
  /* Directly map large chunks */
  if (use_mmap(m) && nb >= mparams.mmap_threshold) {
d4050 9
d4074 5
d4083 1
d4085 1
a4085 2
    size_t asize = 0;
    ACQUIRE_MORECORE_LOCK();
d4090 12
a4101 10
	asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
	/* Adjust to end on a page boundary */
	if (!is_page_aligned(base))
	  asize += (page_align((size_t)base) - (size_t)base);
	/* Can't call MORECORE if size is negative when treated as signed */
	if (asize < HALF_MAX_SIZE_T &&
	    (br = (char*)(CALL_MORECORE(asize))) == base) {
	  tbase = base;
	  tsize = asize;
	}
d4106 1
a4106 1
      asize = granularity_align(nb - m->topsize + TOP_FOOT_SIZE + SIZE_T_ONE);
d4108 4
a4111 4
      if (asize < HALF_MAX_SIZE_T &&
	  (br = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
	tbase = br;
	tsize = asize;
d4117 13
a4129 13
	if (asize < HALF_MAX_SIZE_T &&
	    asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
	  size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
	  if (esize < HALF_MAX_SIZE_T) {
	    char* end = (char*)CALL_MORECORE(esize);
	    if (end != CMFAIL)
	      asize += esize;
	    else {            /* Can't use; try to release */
	      CALL_MORECORE(-asize);
	      br = CMFAIL;
	    }
	  }
	}
d4132 2
a4133 2
	tbase = br;
	tsize = asize;
d4136 1
a4136 1
	disable_contiguous(m); /* Don't try contiguous path in the future */
d4139 1
a4139 1
    RELEASE_MORECORE_LOCK();
d4143 5
a4147 9
    size_t req = nb + TOP_FOOT_SIZE + SIZE_T_ONE;
    size_t rsize = granularity_align(req);
    if (rsize > nb) { /* Fail if wraps around zero */
      char* mp = (char*)(CALL_MMAP(rsize));
      if (mp != CMFAIL) {
	tbase = mp;
	tsize = rsize;
	mmap_flag = IS_MMAPPED_BIT;
      }
a4151 1
    size_t asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
d4155 1
a4155 1
      ACQUIRE_MORECORE_LOCK();
d4158 1
a4158 1
      RELEASE_MORECORE_LOCK();
d4160 5
a4164 5
	size_t ssize = end - br;
	if (ssize > nb + TOP_FOOT_SIZE) {
	  tbase = br;
	  tsize = ssize;
	}
d4175 3
a4177 1
      m->seg.base = m->least_addr = tbase;
d4181 1
d4183 1
d4185 7
a4191 5
	init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
      else {
	/* Offset top by embedded malloc_state */
	mchunkptr mn = next_chunk(mem2chunk(m));
	init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
d4198 1
d4200 1
a4200 1
	sp = sp->next;
d4202 5
a4206 5
	  !is_extern_segment(sp) &&
	  (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&
	  segment_holds(sp, m->top)) { /* append */
	sp->size += tsize;
	init_top(m, m->top, m->topsize + tsize);
d4209 15
a4223 15
	if (tbase < m->least_addr)
	  m->least_addr = tbase;
	sp = &m->seg;
	while (sp != 0 && sp->base != tbase + tsize)
	  sp = sp->next;
	if (sp != 0 &&
	    !is_extern_segment(sp) &&
	    (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
	  char* oldbase = sp->base;
	  sp->base = tbase;
	  sp->size += tsize;
	  return prepend_alloc(m, tbase, oldbase, nb);
	}
	else
	  add_segment(m, tbase, tsize, mmap_flag);
d4248 1
d4255 1
d4260 20
a4279 20
      if (!cinuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
	tchunkptr tp = (tchunkptr)p;
	assert(segment_holds(sp, (char*)sp));
	if (p == m->dv) {
	  m->dv = 0;
	  m->dvsize = 0;
	}
	else {
	  unlink_large_chunk(m, tp);
	}
	if (CALL_MUNMAP(base, size) == 0) {
	  released += size;
	  m->footprint -= size;
	  /* unlink obsoleted record */
	  sp = pred;
	  sp->next = next;
	}
	else { /* back out if cannot unmap */
	  insert_large_chunk(m, tp, psize);
	}
d4282 2
d4287 3
d4295 1
d4303 1
a4303 1
		      SIZE_T_ONE) * unit;
d4307 29
a4335 28
	if (is_mmapped_segment(sp)) {
	  if (HAVE_MMAP &&
	      sp->size >= extra &&
	      !has_segment_link(m, sp)) { /* can't shrink if pinned */
	    size_t newsize = sp->size - extra;
	    /* Prefer mremap, fall back to munmap */
	    if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
		(CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
	      released = extra;
	    }
	  }
	}
	else if (HAVE_MORECORE) {
	  if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
	    extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
	  ACQUIRE_MORECORE_LOCK();
	  {
	    /* Make sure end of memory is where we last set it. */
	    char* old_br = (char*)(CALL_MORECORE(0));
	    if (old_br == sp->base + sp->size) {
	      char* rel_br = (char*)(CALL_MORECORE(-extra));
	      char* new_br = (char*)(CALL_MORECORE(0));
	      if (rel_br != CMFAIL && new_br < old_br)
		released = old_br - new_br;
	    }
	  }
	  RELEASE_MORECORE_LOCK();
	}
d4339 4
a4342 4
	sp->size -= released;
	m->footprint -= released;
	init_top(m, m->top, m->topsize - released);
	check_top_chunk(m, m->top);
d4351 1
a4351 1
    if (released == 0)
d4358 72
a4429 1
/* ---------------------------- malloc support --------------------------- */
a4437 1

d4446 3
a4448 3
	v = t;
	if ((rsize = trem) == 0)
	  break;
d4453 1
a4453 1
	rst = rt;
d4455 2
a4456 2
	t = rst; /* set t to least subtree holding sizes > nb */
	break;
a4460 1

d4486 9
a4494 9
	unlink_large_chunk(m, v);
	if (rsize < MIN_CHUNK_SIZE)
	  set_inuse_and_pinuse(m, v, (rsize + nb));
	else {
	  set_size_and_pinuse_of_inuse_chunk(m, v, nb);
	  set_size_and_pinuse_of_free_chunk(r, rsize);
	  insert_chunk(m, r, rsize);
	}
	return chunk2mem(v);
a4508 1

d4526 1
a4526 1
	set_inuse_and_pinuse(m, v, (rsize + nb));
d4528 3
a4530 3
	set_size_and_pinuse_of_inuse_chunk(m, v, nb);
	set_size_and_pinuse_of_free_chunk(r, rsize);
	replace_dv(m, r, rsize);
d4540 29
a4568 1
/* --------------------------- realloc support --------------------------- */
d4570 9
a4578 11
static void* internal_realloc(mstate m, void* oldmem, size_t bytes) {
  if (bytes >= MAX_REQUEST) {
    MALLOC_FAILURE_ACTION;
    return 0;
  }
  if (!PREACTION(m)) {
    mchunkptr oldp = mem2chunk(oldmem);
    size_t oldsize = chunksize(oldp);
    mchunkptr next = chunk_plus_offset(oldp, oldsize);
    mchunkptr newp = 0;
    void* extra = 0;
d4580 12
a4591 1
    /* Try to either shrink or extend into top. Else malloc-copy-free */
d4593 31
a4623 25
    if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&
		ok_next(oldp, next) && ok_pinuse(next))) {
      size_t nb = request2size(bytes);
      if (is_mmapped(oldp))
	newp = mmap_resize(m, oldp, nb);
      else if (oldsize >= nb) { /* already big enough */
	size_t rsize = oldsize - nb;
	newp = oldp;
	if (rsize >= MIN_CHUNK_SIZE) {
	  mchunkptr remainder = chunk_plus_offset(newp, nb);
	  set_inuse(m, newp, nb);
	  set_inuse(m, remainder, rsize);
	  extra = chunk2mem(remainder);
	}
      }
      else if (next == m->top && oldsize + m->topsize > nb) {
	/* Expand into top */
	size_t newsize = oldsize + m->topsize;
	size_t newtopsize = newsize - nb;
	mchunkptr newtop = chunk_plus_offset(oldp, nb);
	set_inuse(m, oldp, nb);
	newtop->head = newtopsize |PINUSE_BIT;
	m->top = newtop;
	m->topsize = newtopsize;
	newp = oldp;
d4626 2
d4629 5
a4633 3
      USAGE_ERROR_ACTION(m, oldmem);
      POSTACTION(m);
      return 0;
d4636 8
a4643 5
    POSTACTION(m);

    if (newp != 0) {
      if (extra != 0) {
	internal_free(m, extra);
d4645 5
a4649 9
      check_inuse_chunk(m, newp);
      return chunk2mem(newp);
    }
    else {
      void* newmem = internal_malloc(m, bytes);
      if (newmem != 0) {
	size_t oc = oldsize - overhead_for(oldp);
	memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);
	internal_free(m, oldmem);
d4651 3
a4653 1
      return newmem;
a4654 3
  }
  return 0;
}
d4656 11
a4666 1
/* --------------------------- memalign support -------------------------- */
d4668 1
a4668 10
static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
  if (alignment <= MALLOC_ALIGNMENT)    /* Can just use malloc */
    return internal_malloc(m, bytes);
  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
    alignment = MIN_CHUNK_SIZE;
  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
    size_t a = MALLOC_ALIGNMENT << 1;
    while (a < alignment) a <<= 1;
    alignment = a;
  }
d4670 3
a4672 4
  if (bytes >= MAX_REQUEST - alignment) {
    if (m != 0)  { /* Test isn't needed but avoids compiler warning */
      MALLOC_FAILURE_ACTION;
    }
a4673 52
  else {
    size_t nb = request2size(bytes);
    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
    char* mem = (char*)internal_malloc(m, req);
    if (mem != 0) {
      void* leader = 0;
      void* trailer = 0;
      mchunkptr p = mem2chunk(mem);

      if (PREACTION(m)) return 0;
      if ((((size_t)(mem)) % alignment) != 0) { /* misaligned */
	/*
	  Find an aligned spot inside chunk.  Since we need to give
	  back leading space in a chunk of at least MIN_CHUNK_SIZE, if
	  the first calculation places us at a spot with less than
	  MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
	  We've allocated enough total room so that this is always
	  possible.
	*/
	char* br = (char*)mem2chunk((size_t)(((size_t)(mem +
						       alignment -
						       SIZE_T_ONE)) &
					     -alignment));
	char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
	  br : br+alignment;
	mchunkptr newp = (mchunkptr)pos;
	size_t leadsize = pos - (char*)(p);
	size_t newsize = chunksize(p) - leadsize;

	if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
	  newp->prev_foot = p->prev_foot + leadsize;
	  newp->head = (newsize|CINUSE_BIT);
	}
	else { /* Otherwise, give back leader, use the rest */
	  set_inuse(m, newp, newsize);
	  set_inuse(m, p, leadsize);
	  leader = chunk2mem(p);
	}
	p = newp;
      }

      /* Give back spare room at the end */
      if (!is_mmapped(p)) {
	size_t size = chunksize(p);
	if (size > nb + MIN_CHUNK_SIZE) {
	  size_t remainder_size = size - nb;
	  mchunkptr remainder = chunk_plus_offset(p, nb);
	  set_inuse(m, p, nb);
	  set_inuse(m, remainder, remainder_size);
	  trailer = chunk2mem(remainder);
	}
      }
a4674 13
      assert (chunksize(p) >= nb);
      assert((((size_t)(chunk2mem(p))) % alignment) == 0);
      check_inuse_chunk(m, p);
      POSTACTION(m);
      if (leader != 0) {
	internal_free(m, leader);
      }
      if (trailer != 0) {
	internal_free(m, trailer);
      }
      return chunk2mem(p);
    }
  }
d4678 1
a4678 1
/* ------------------------ comalloc/coalloc support --------------------- */
d4680 1
a4680 5
static void** ialloc(mstate m,
		     size_t n_elements,
		     size_t* sizes,
		     int opts,
		     void* chunks[]) {
d4682 3
a4684 6
    This provides common support for independent_X routines, handling
    all of the combinations that can result.

    The opts arg has:
    bit 0 set if all elements are same size (using sizes[0])
    bit 1 set if elements should be zeroed
d4687 288
d4987 1
d5055 1
a5055 1
	size = element_size;
d5057 1
a5057 1
	size = request2size(sizes[i]);
d5088 40
a5127 83

/* -------------------------- public routines ---------------------------- */

#if !ONLY_MSPACES

void* dlmalloc(size_t bytes) {
  /*
     Basic algorithm:
     If a small request (< 256 bytes minus per-chunk overhead):
       1. If one exists, use a remainderless chunk in associated smallbin.
	  (Remainderless means that there are too few excess bytes to
	  represent as a chunk.)
       2. If it is big enough, use the dv chunk, which is normally the
	  chunk adjacent to the one used for the most recent small request.
       3. If one exists, split the smallest available chunk in a bin,
	  saving remainder in dv.
       4. If it is big enough, use the top chunk.
       5. If available, get memory from system and use it
     Otherwise, for a large request:
       1. Find the smallest available binned chunk that fits, and use it
	  if it is better fitting than dv chunk, splitting if necessary.
       2. If better fitting than any binned chunk, use the dv chunk.
       3. If it is big enough, use the top chunk.
       4. If request size >= mmap threshold, try to directly mmap this chunk.
       5. If available, get memory from system and use it

     The ugly goto's here ensure that postaction occurs along all paths.
  */

  if (!PREACTION(gm)) {
    void* mem;
    size_t nb;
    if (bytes <= MAX_SMALL_REQUEST) {
      bindex_t idx;
      binmap_t smallbits;
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
      idx = small_index(nb);
      smallbits = gm->smallmap >> idx;

      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
	mchunkptr b, p;
	idx += ~smallbits & 1;       /* Uses next bin if idx empty */
	b = smallbin_at(gm, idx);
	p = b->fd;
	assert(chunksize(p) == small_index2size(idx));
	unlink_first_small_chunk(gm, b, p, idx);
	set_inuse_and_pinuse(gm, p, small_index2size(idx));
	mem = chunk2mem(p);
	check_malloced_chunk(gm, mem, nb);
	goto postaction;
      }

      else if (nb > gm->dvsize) {
	if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
	  mchunkptr b, p, r;
	  size_t rsize;
	  bindex_t i;
	  binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
	  binmap_t leastbit = least_bit(leftbits);
	  compute_bit2idx(leastbit, i);
	  b = smallbin_at(gm, i);
	  p = b->fd;
	  assert(chunksize(p) == small_index2size(i));
	  unlink_first_small_chunk(gm, b, p, i);
	  rsize = small_index2size(i) - nb;
	  /* Fit here cannot be remainderless if 4byte sizes */
	  if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
	    set_inuse_and_pinuse(gm, p, small_index2size(i));
	  else {
	    set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
	    r = chunk_plus_offset(p, nb);
	    set_size_and_pinuse_of_free_chunk(r, rsize);
	    replace_dv(gm, r, rsize);
	  }
	  mem = chunk2mem(p);
	  check_malloced_chunk(gm, mem, nb);
	  goto postaction;
	}

	else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
	  check_malloced_chunk(gm, mem, nb);
	  goto postaction;
	}
d5130 3
a5132 47
    else if (bytes >= MAX_REQUEST)
      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
    else {
      nb = pad_request(bytes);
      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
	check_malloced_chunk(gm, mem, nb);
	goto postaction;
      }
    }

    if (nb <= gm->dvsize) {
      size_t rsize = gm->dvsize - nb;
      mchunkptr p = gm->dv;
      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
	mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
	gm->dvsize = rsize;
	set_size_and_pinuse_of_free_chunk(r, rsize);
	set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
      }
      else { /* exhaust dv */
	size_t dvs = gm->dvsize;
	gm->dvsize = 0;
	gm->dv = 0;
	set_inuse_and_pinuse(gm, p, dvs);
      }
      mem = chunk2mem(p);
      check_malloced_chunk(gm, mem, nb);
      goto postaction;
    }

    else if (nb < gm->topsize) { /* Split top */
      size_t rsize = gm->topsize -= nb;
      mchunkptr p = gm->top;
      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
      r->head = rsize | PINUSE_BIT;
      set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
      mem = chunk2mem(p);
      check_top_chunk(gm, gm->top);
      check_malloced_chunk(gm, mem, nb);
      goto postaction;
    }

    mem = sys_alloc(gm, nb);

  postaction:
    POSTACTION(gm);
    return mem;
d5134 1
a5134 2

  return 0;
d5137 36
a5172 88
void dlfree(void* mem) {
  /*
     Consolidate freed chunks with preceeding or succeeding bordering
     free chunks, if they exist, and then place in a bin.  Intermixed
     with special cases for top, dv, mmapped chunks, and usage errors.
  */

  if (mem != 0) {
    mchunkptr p  = mem2chunk(mem);
#if FOOTERS
    mstate fm = get_mstate_for(p);
    if (!ok_magic(fm)) {
      USAGE_ERROR_ACTION(fm, p);
      return;
    }
#else /* FOOTERS */
#define fm gm
#endif /* FOOTERS */
    if (!PREACTION(fm)) {
      check_inuse_chunk(fm, p);
      if (RTCHECK(ok_address(fm, p) && ok_cinuse(p))) {
	size_t psize = chunksize(p);
	mchunkptr next = chunk_plus_offset(p, psize);
	if (!pinuse(p)) {
	  size_t prevsize = p->prev_foot;
	  if ((prevsize & IS_MMAPPED_BIT) != 0) {
	    prevsize &= ~IS_MMAPPED_BIT;
	    psize += prevsize + MMAP_FOOT_PAD;
	    if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
	      fm->footprint -= psize;
	    goto postaction;
	  }
	  else {
	    mchunkptr prev = chunk_minus_offset(p, prevsize);
	    psize += prevsize;
	    p = prev;
	    if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
	      if (p != fm->dv) {
		unlink_chunk(fm, p, prevsize);
	      }
	      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
		fm->dvsize = psize;
		set_free_with_pinuse(p, psize, next);
		goto postaction;
	      }
	    }
	    else
	      goto erroraction;
	  }
	}

	if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
	  if (!cinuse(next)) {  /* consolidate forward */
	    if (next == fm->top) {
	      size_t tsize = fm->topsize += psize;
	      fm->top = p;
	      p->head = tsize | PINUSE_BIT;
	      if (p == fm->dv) {
		fm->dv = 0;
		fm->dvsize = 0;
	      }
	      if (should_trim(fm, tsize))
		sys_trim(fm, 0);
	      goto postaction;
	    }
	    else if (next == fm->dv) {
	      size_t dsize = fm->dvsize += psize;
	      fm->dv = p;
	      set_size_and_pinuse_of_free_chunk(p, dsize);
	      goto postaction;
	    }
	    else {
	      size_t nsize = chunksize(next);
	      psize += nsize;
	      unlink_chunk(fm, next, nsize);
	      set_size_and_pinuse_of_free_chunk(p, psize);
	      if (p == fm->dv) {
		fm->dvsize = psize;
		goto postaction;
	      }
	    }
	  }
	  else
	    set_free_with_pinuse(p, psize, next);
	  insert_chunk(fm, p, psize);
	  check_free_chunk(fm, p);
	  goto postaction;
	}
a5173 4
    erroraction:
      USAGE_ERROR_ACTION(fm, p);
    postaction:
      POSTACTION(fm);
a5175 3
#if !FOOTERS
#undef fm
#endif /* FOOTERS */
d5177 3
d5181 1
a5181 14
void* dlcalloc(size_t n_elements, size_t elem_size) {
  void* mem;
  size_t req = 0;
  if (n_elements != 0) {
    req = n_elements * elem_size;
    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
	(req / n_elements != elem_size))
      req = MAX_SIZE_T; /* force downstream failure on overflow */
  }
  mem = dlmalloc(req);
  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
    memset(mem, 0, req);
  return mem;
}
d5184 7
a5190 2
  if (oldmem == 0)
    return dlmalloc(bytes);
d5192 1
a5192 1
  if (bytes == 0) {
a5193 1
    return 0;
d5197 2
d5202 1
a5202 1
    mstate m = get_mstate_for(mem2chunk(oldmem));
d5208 47
a5254 1
    return internal_realloc(m, oldmem, bytes);
d5256 1
d5260 3
d5266 21
a5286 9
void** dlindependent_calloc(size_t n_elements, size_t elem_size,
				 void* chunks[]) {
  size_t sz = elem_size; /* serves as 1-element array */
  return ialloc(gm, n_elements, &sz, 3, chunks);
}

void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
				   void* chunks[]) {
  return ialloc(gm, n_elements, sizes, 0, chunks);
d5291 1
a5291 1
  init_mparams();
d5298 1
a5298 1
  init_mparams();
d5303 29
d5334 1
d5350 16
d5372 1
d5376 5
d5385 1
a5385 1
    if (cinuse(p))
a5390 4
int dlmallopt(int param_number, int value) {
  return change_mparam(param_number, value);
}

d5403 2
a5404 2
  INITIAL_LOCK(&m->mutex);
  msp->head = (msize|PINUSE_BIT|CINUSE_BIT);
d5408 1
d5410 2
d5422 3
a5424 3
  size_t msize = pad_request(sizeof(struct malloc_state));
  init_mparams(); /* Ensure pagesize etc initialized */

d5427 1
a5427 1
		 (capacity + TOP_FOOT_SIZE + msize));
d5432 1
a5432 1
      m->seg.sflags = IS_MMAPPED_BIT;
d5441 3
a5443 3
  size_t msize = pad_request(sizeof(struct malloc_state));
  init_mparams(); /* Ensure pagesize etc initialized */

d5453 17
d5475 1
d5480 1
d5482 3
a5484 3
      if ((flag & IS_MMAPPED_BIT) && !(flag & EXTERN_BIT) &&
	  CALL_MUNMAP(base, size) == 0)
	freed += size;
a5497 1

d5515 10
a5524 10
	mchunkptr b, p;
	idx += ~smallbits & 1;       /* Uses next bin if idx empty */
	b = smallbin_at(ms, idx);
	p = b->fd;
	assert(chunksize(p) == small_index2size(idx));
	unlink_first_small_chunk(ms, b, p, idx);
	set_inuse_and_pinuse(ms, p, small_index2size(idx));
	mem = chunk2mem(p);
	check_malloced_chunk(ms, mem, nb);
	goto postaction;
d5528 30
a5557 30
	if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
	  mchunkptr b, p, r;
	  size_t rsize;
	  bindex_t i;
	  binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
	  binmap_t leastbit = least_bit(leftbits);
	  compute_bit2idx(leastbit, i);
	  b = smallbin_at(ms, i);
	  p = b->fd;
	  assert(chunksize(p) == small_index2size(i));
	  unlink_first_small_chunk(ms, b, p, i);
	  rsize = small_index2size(i) - nb;
	  /* Fit here cannot be remainderless if 4byte sizes */
	  if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
	    set_inuse_and_pinuse(ms, p, small_index2size(i));
	  else {
	    set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
	    r = chunk_plus_offset(p, nb);
	    set_size_and_pinuse_of_free_chunk(r, rsize);
	    replace_dv(ms, r, rsize);
	  }
	  mem = chunk2mem(p);
	  check_malloced_chunk(ms, mem, nb);
	  goto postaction;
	}

	else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
	  check_malloced_chunk(ms, mem, nb);
	  goto postaction;
	}
d5565 2
a5566 2
	check_malloced_chunk(ms, mem, nb);
	goto postaction;
d5574 4
a5577 4
	mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
	ms->dvsize = rsize;
	set_size_and_pinuse_of_free_chunk(r, rsize);
	set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
d5580 4
a5583 4
	size_t dvs = ms->dvsize;
	ms->dvsize = 0;
	ms->dv = 0;
	set_inuse_and_pinuse(ms, p, dvs);
d5617 1
d5627 77
a5703 68
      if (RTCHECK(ok_address(fm, p) && ok_cinuse(p))) {
	size_t psize = chunksize(p);
	mchunkptr next = chunk_plus_offset(p, psize);
	if (!pinuse(p)) {
	  size_t prevsize = p->prev_foot;
	  if ((prevsize & IS_MMAPPED_BIT) != 0) {
	    prevsize &= ~IS_MMAPPED_BIT;
	    psize += prevsize + MMAP_FOOT_PAD;
	    if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
	      fm->footprint -= psize;
	    goto postaction;
	  }
	  else {
	    mchunkptr prev = chunk_minus_offset(p, prevsize);
	    psize += prevsize;
	    p = prev;
	    if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
	      if (p != fm->dv) {
		unlink_chunk(fm, p, prevsize);
	      }
	      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
		fm->dvsize = psize;
		set_free_with_pinuse(p, psize, next);
		goto postaction;
	      }
	    }
	    else
	      goto erroraction;
	  }
	}

	if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
	  if (!cinuse(next)) {  /* consolidate forward */
	    if (next == fm->top) {
	      size_t tsize = fm->topsize += psize;
	      fm->top = p;
	      p->head = tsize | PINUSE_BIT;
	      if (p == fm->dv) {
		fm->dv = 0;
		fm->dvsize = 0;
	      }
	      if (should_trim(fm, tsize))
		sys_trim(fm, 0);
	      goto postaction;
	    }
	    else if (next == fm->dv) {
	      size_t dsize = fm->dvsize += psize;
	      fm->dv = p;
	      set_size_and_pinuse_of_free_chunk(p, dsize);
	      goto postaction;
	    }
	    else {
	      size_t nsize = chunksize(next);
	      psize += nsize;
	      unlink_chunk(fm, next, nsize);
	      set_size_and_pinuse_of_free_chunk(p, psize);
	      if (p == fm->dv) {
		fm->dvsize = psize;
		goto postaction;
	      }
	    }
	  }
	  else
	    set_free_with_pinuse(p, psize, next);
	  insert_chunk(fm, p, psize);
	  check_free_chunk(fm, p);
	  goto postaction;
	}
d5724 1
a5724 1
	(req / n_elements != elem_size))
d5734 7
a5740 2
  if (oldmem == 0)
    return mspace_malloc(msp, bytes);
d5742 1
a5742 1
  if (bytes == 0) {
a5743 1
    return 0;
d5747 42
a5788 3
#if FOOTERS
    mchunkptr p  = mem2chunk(oldmem);
    mstate ms = get_mstate_for(p);
d5790 6
a5795 1
    mstate ms = (mstate)msp;
d5797 8
a5804 3
    if (!ok_magic(ms)) {
      USAGE_ERROR_ACTION(ms,ms);
      return 0;
a5805 1
    return internal_realloc(ms, oldmem, bytes);
d5807 1
d5816 2
d5822 1
a5822 1
				 size_t elem_size, void* chunks[]) {
d5833 1
a5833 1
				   size_t sizes[], void* chunks[]) {
d5842 24
d5881 1
d5891 1
d5894 1
a5894 1
  size_t result;
d5899 3
a5901 1
  USAGE_ERROR_ACTION(ms,ms);
a5904 1

d5906 1
a5906 1
  size_t result;
d5911 16
a5926 1
  USAGE_ERROR_ACTION(ms,ms);
d5930 17
d5958 9
d5973 1
d6023 1
a6023 1
	 size = MINIMUM_MORECORE_SIZE;
d6025 1
a6025 1
	 ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
d6028 1
a6028 1
	return (void *) MFAIL;
d6058 2
a6059 2
	 PoolDeallocate(*ptr);
	 *ptr = 0;
d6068 38
d6111 1
a6111 1
	in create_mspace_with_base
d6130 1
a6130 1
	removing need for emulation on most platforms without sbrk.
d6135 2
a6136 2
	Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
	Aaron Bachmann,  Emery Berger, and others.
d6149 1
a6149 1
	Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
d6160 1
a6160 1
	Thanks to Michael Pachos for motivation and help.
d6164 2
a6165 2
	Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
	and Anonymous.
d6167 1
a6167 1
	helping test this.)
d6170 2
a6171 2
	leads to  more fragmentation in some programs and doesn't
	seem to help in any others.
d6179 1
a6179 1
	Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
d6185 11
a6195 11
	 * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
	  (e.g. WIN32 platforms)
	 * Cleanup header file inclusion for WIN32 platforms
	 * Cleanup code to avoid Microsoft Visual C++ compiler complaints
	 * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
	   memory allocation routines
	 * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
	 * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
	   usage of 'assert' in non-WIN32 code
	 * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
	   avoid infinite loop
d6207 1
a6207 1
	foreign sbrks
d6213 1
a6213 1
	Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d6221 1
a6221 1
	avoid surprises about sbrk alignment conventions.
d6223 1
a6223 1
	(raymond@@es.ele.tue.nl) for the suggestion.
d6226 1
a6226 1
	courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d6228 1
a6228 1
	H.J. Lu (hjl@@gnu.ai.mit.edu)
d6234 2
a6235 2
	the work required to undo bad preallocations exceeds
	the work saved in good cases for most test programs.
d6237 2
a6238 2
	no scheme using them consistently outperforms those that don't
	given above changes.
d6244 1
a6244 1
	Paul Wilson (wilson@@cs.texas.edu) for the suggestion.
d6248 1
a6248 1
	(wmglo@@Dent.MED.Uni-Muenchen.DE).
d6264 1
a6264 1
	 (eliminating old malloc_find_space & malloc_clean_bin)
d6268 1
a6268 1
	  from kpv@@research.att.com
d6276 2
a6277 2
	  with gcc & native cc (hp, dec only) allowing
	  Detlefs & Zorn comparison study (in SIGPLAN Notices.)
d6281 1
a6281 1
	 structure of old version,  but most details differ.)
@


1.11.22.1
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d4 1
a4 1
  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
d7 2
a8 1
* Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
d10 2
a11 2
           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
         Check before installing!
d22 1
a22 1
     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.6.h
d44 1
a44 1
  Alignment:                                     8 bytes (minimum)
d50 1
a50 1
                                          8 or 16 bytes (if 8byte sizes)
d56 1
a56 1
                          8-byte ptrs:  32 bytes    (including overhead)
d107 1
a107 7
       It is also possible to limit the maximum total allocatable
       space, using malloc_set_footprint_limit. This is not
       designed as a security feature in itself (calls to set limits
       are not screened or privileged), but may be useful as one
       aspect of a secure implementation.

  Thread-safety: NOT thread-safe unless USE_LOCKS defined non-zero
d109 7
a115 14
       etc is surrounded with a lock. By default, this uses a plain
       pthread mutex, win32 critical section, or a spin-lock if if
       available for the platform and not disabled by setting
       USE_SPIN_LOCKS=0.  However, if USE_RECURSIVE_LOCKS is defined,
       recursive versions are used instead (which are not required for
       base functionality but may be needed in layered extensions).
       Using a global lock is not especially fast, and can be a major
       bottleneck.  It is designed only to provide minimal protection
       in concurrent environments, and to provide a basis for
       extensions.  If you are using malloc in a concurrent program,
       consider instead using nedmalloc
       (http://www.nedprod.com/programs/portable/nedmalloc/) or
       ptmalloc (See http://www.malloc.de), which are derived from
       versions of this malloc.
d156 1
a156 5
  system allocation routines, which is often just 1. In real-time
  applications, you can optionally suppress segment traversals using
  NO_SEGMENT_TRAVERSAL, which assures bounded execution even when
  system allocators return non-contiguous spaces, at the typical
  expense of carrying around more memory and increased fragmentation.
d200 1
a200 1
  originating spaces. Normally, this requires use of locks.
d206 1
a206 2
to size_t precision unless they are explicitly casted. You can also
use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.
d210 1
a210 20
  Otherwise defaults are for unix. Beware that there seem to be some
  cases where this malloc might not be a pure drop-in replacement for
  Win32 malloc: Random-looking failures from Win32 GDI API's (eg;
  SetDIBits()) may be due to bugs in some video driver implementations
  when pixel buffers are malloc()ed, and the region spans more than
  one VirtualAlloc()ed region. Because dlmalloc uses a small (64Kb)
  default granularity, pixel buffers may straddle virtual allocation
  regions more often than when using the Microsoft allocator.  You can
  avoid this by using VirtualAlloc() and VirtualFree() for all pixel
  buffers rather than using malloc().  If this is not possible,
  recompile this malloc with a larger DEFAULT_GRANULARITY. Note:
  in cases where MSC and gcc (cygwin) are known to differ on WIN32,
  conditions use _MSC_VER to distinguish them.

DLMALLOC_EXPORT       default: extern
  Defines how public APIs are declared. If you want to export via a
  Windows DLL, you might define this as
    #define DLMALLOC_EXPORT extern  __declspec(dllexport)
  If you want a POSIX ELF shared object, you might use
    #define DLMALLOC_EXPORT extern __attribute__((visibility("default")))
d212 1
a212 1
MALLOC_ALIGNMENT         default: (size_t)(2 * sizeof(void *))
d229 1
a229 21
  overridden on a per-mspace basis for mspace versions.) If set to a
  non-zero value other than 1, locks are used, but their
  implementation is left out, so lock functions must be supplied manually,
  as described below.

USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and spin locks available
  If true, uses custom spin locks for locking. This is currently
  supported only gcc >= 4.1, older gccs on x86 platforms, and recent
  MS compilers.  Otherwise, posix locks or win32 critical sections are
  used.

USE_RECURSIVE_LOCKS      default: not defined
  If defined nonzero, uses recursive (aka reentrant) locks, otherwise
  uses plain mutexes. This is not required for malloc proper, but may
  be needed for layered allocators such as nedmalloc.

LOCK_AT_FORK            default: not defined
  If defined nonzero, performs pthread_atfork upon initialization
  to initialize child lock while holding parent lock. The implementation
  assumes that pthread locks (not custom locks) are being used. In other
  cases, you may need to customize the implementation.
a243 6
MALLOC_INSPECT_ALL       default: NOT defined
  If defined, compiles malloc_inspect_all and mspace_inspect_all, that
  perform traversal of all heap space.  Unless access to these
  functions is otherwise restricted, you probably do not want to
  include them in secure implementations.

d300 3
a302 1
  possibilities, although sometimes generating compiler warnings.
d304 1
a304 1
MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
a317 6
NO_SEGMENT_TRAVERSAL       default: 0
  If non-zero, suppresses traversals of memory segments
  returned by either MORECORE or CALL_MMAP. This disables
  merging of segments that are contiguous, and selectively
  releasing them to the OS if unused, but bounds execution times.

d332 1
a332 1
MMAP_CLEARS               default: 1 except on WINCE.
d334 1
a334 1
  for standard unix mmap using /dev/zero and on WIN32 except for WINCE.
d341 2
a342 2
  this setting has no effect. Similarly for Win32 under recent MS compilers.
  (On most x86s, the asm version is only slightly faster than the C version.)
a364 4
NO_MALLOC_STATS            default: 0
  If defined, don't compile "malloc_stats". This avoids calls to
  fprintf and bringing in stdio dependencies you might not want.

d373 1
a373 1
LACKS_STDLIB_H LACKS_SCHED_H LACKS_TIME_H  default: NOT defined unless on WIN32
d378 2
a379 2
                                system_info.dwAllocationGranularity in WIN32,
                                otherwise 64K.
d439 1
a439 23
MAX_RELEASE_CHECK_RATE   default: 4095 unless not HAVE_MMAP
  The number of consolidated frees between checks to release
  unused segments when freeing. When using non-contiguous segments,
  especially with multiple mspaces, checking only for topmost space
  doesn't always suffice to trigger trimming. To compensate for this,
  free() will, with a period of MAX_RELEASE_CHECK_RATE (or the
  current number of segments, if greater) try to release unused
  segments to the OS when freeing chunks that result in
  consolidation. The best value for this parameter is a compromise
  between slowing down frees with relatively costly checks that
  rarely trigger versus holding on to unused memory. To effectively
  disable, set to MAX_SIZE_T. This may lead to a very slight speed
  improvement at the expense of carrying around more memory.
*/

/* Version identifier to allow people to support multiple versions */
#ifndef DLMALLOC_VERSION
#define DLMALLOC_VERSION 20806
#endif /* DLMALLOC_VERSION */

#ifndef DLMALLOC_EXPORT
#define DLMALLOC_EXPORT extern
#endif
a444 4
#ifdef _WIN32_WCE
#define LACKS_FCNTL_H
#define WIN32 1
#endif /* _WIN32_WCE */
a448 1
#include <tchar.h>
a457 2
#define LACKS_SCHED_H
#ifndef MALLOC_FAILURE_ACTION
d459 1
a459 8
#endif /* MALLOC_FAILURE_ACTION */
#ifndef MMAP_CLEARS
#ifdef _WIN32_WCE /* WINCE reportedly does not clear */
#define MMAP_CLEARS 0
#else
#define MMAP_CLEARS 1
#endif /* _WIN32_WCE */
#endif /*MMAP_CLEARS */
a466 4
/* OSX allocators provide 16 byte alignment */
#ifndef MALLOC_ALIGNMENT
#define MALLOC_ALIGNMENT ((size_t)16U)
#endif
a479 20
#ifndef USE_LOCKS /* ensure true if spin or recursive locks set */
#define USE_LOCKS  ((defined(USE_SPIN_LOCKS) && USE_SPIN_LOCKS != 0) || \
                    (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0))
#endif /* USE_LOCKS */

#if USE_LOCKS /* Spin locks for gcc >= 4.1, older gcc on x86, MSC >= 1310 */
#if ((defined(__GNUC__) &&                                              \
      ((__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)) ||      \
       defined(__i386__) || defined(__x86_64__))) ||                    \
     (defined(_MSC_VER) && _MSC_VER>=1310))
#ifndef USE_SPIN_LOCKS
#define USE_SPIN_LOCKS 1
#endif /* USE_SPIN_LOCKS */
#elif USE_SPIN_LOCKS
#error "USE_SPIN_LOCKS defined without implementation"
#endif /* ... locks available... */
#elif !defined(USE_SPIN_LOCKS)
#define USE_SPIN_LOCKS 0
#endif /* USE_LOCKS */

d491 1
a491 1
#define MALLOC_ALIGNMENT ((size_t)(2 * sizeof(void *)))
d505 3
a507 1

a510 3
#ifndef MALLOC_INSPECT_ALL
#define MALLOC_INSPECT_ALL 0
#endif  /* MALLOC_INSPECT_ALL */
a519 1
#define _GNU_SOURCE /* Turns on mremap() definition */
d537 3
a539 1
#define MORECORE_DEFAULT sbrk
d545 1
a545 1
#if (MORECORE_CONTIGUOUS || defined(WIN32))
a564 7
#ifndef MAX_RELEASE_CHECK_RATE
#if HAVE_MMAP
#define MAX_RELEASE_CHECK_RATE 4095
#else
#define MAX_RELEASE_CHECK_RATE MAX_SIZE_T
#endif /* HAVE_MMAP */
#endif /* MAX_RELEASE_CHECK_RATE */
a576 6
#ifndef NO_MALLOC_STATS
#define NO_MALLOC_STATS 0
#endif  /* NO_MALLOC_STATS */
#ifndef NO_SEGMENT_TRAVERSAL
#define NO_SEGMENT_TRAVERSAL 0
#endif /* NO_SEGMENT_TRAVERSAL */
d619 1
a619 4
#ifndef STRUCT_MALLINFO_DECLARED
/* HP-UX (and others?) redefines mallinfo unless _STRUCT_MALLINFO is defined */
#define _STRUCT_MALLINFO
#define STRUCT_MALLINFO_DECLARED 1
d632 1
a632 1
#endif /* STRUCT_MALLINFO_DECLARED */
a635 22
/*
  Try to persuade compilers to inline. The most critical functions for
  inlining are defined as macros, so these aren't used for them.
*/

#ifndef FORCEINLINE
  #if defined(__GNUC__)
#define FORCEINLINE __inline __attribute__ ((always_inline))
  #elif defined(_MSC_VER)
    #define FORCEINLINE __forceinline
  #endif
#endif
#ifndef NOINLINE
  #if defined(__GNUC__)
    #define NOINLINE __attribute__ ((noinline))
  #elif defined(_MSC_VER)
    #define NOINLINE __declspec(noinline)
  #else
    #define NOINLINE
  #endif
#endif

a637 3
#ifndef FORCEINLINE
 #define FORCEINLINE inline
#endif
a638 3
#ifndef FORCEINLINE
 #define FORCEINLINE
#endif
a648 1
#define dlposix_memalign       posix_memalign
a649 1
#define dlrealloc_in_place     realloc_in_place
a658 3
#define dlmalloc_footprint_limit malloc_footprint_limit
#define dlmalloc_set_footprint_limit malloc_set_footprint_limit
#define dlmalloc_inspect_all   malloc_inspect_all
a660 1
#define dlbulk_free            bulk_free
d663 1
d678 1
a678 1
DLMALLOC_EXPORT void* dlmalloc(size_t);
d687 1
a687 1
DLMALLOC_EXPORT void  dlfree(void*);
d694 1
a694 1
DLMALLOC_EXPORT void* dlcalloc(size_t, size_t);
a717 12
DLMALLOC_EXPORT void* dlrealloc(void*, size_t);

/*
  realloc_in_place(void* p, size_t n)
  Resizes the space allocated for p to size n, only if this can be
  done without moving p (i.e., only if there is adjacent space
  available if n is greater than p's current allocated size, or n is
  less than or equal to p's size). This may be used instead of plain
  realloc if an alternative allocation strategy is needed upon failure
  to expand space; for example, reallocation of a buffer that must be
  memory-aligned or cleared. You can use realloc_in_place to trigger
  these alternatives only when needed.
d719 1
a719 3
  Returns p if successful; otherwise null.
*/
DLMALLOC_EXPORT void* dlrealloc_in_place(void*, size_t);
d733 1
a733 11
DLMALLOC_EXPORT void* dlmemalign(size_t, size_t);

/*
  int posix_memalign(void** pp, size_t alignment, size_t n);
  Allocates a chunk of n bytes, aligned in accord with the alignment
  argument. Differs from memalign only in that it (1) assigns the
  allocated memory to *pp rather than returning it, (2) fails and
  returns EINVAL if the alignment is not a power of two (3) fails and
  returns ENOMEM if memory cannot be allocated.
*/
DLMALLOC_EXPORT int dlposix_memalign(void**, size_t, size_t);
d740 1
a740 1
DLMALLOC_EXPORT void* dlvalloc(size_t);
d748 1
a748 5
  0.  To workaround the fact that mallopt is specified to use int,
  not size_t parameters, the value -1 is specially treated as the
  maximum unsigned size_t value.

  SVID/XPG/ANSI defines four standard param numbers for mallopt,
d756 1
a756 1
  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1 disables)
d760 1
a760 1
DLMALLOC_EXPORT int dlmallopt(int, int);
d771 1
a771 1
DLMALLOC_EXPORT size_t dlmalloc_footprint(void);
d784 1
a784 60
DLMALLOC_EXPORT size_t dlmalloc_max_footprint(void);

/*
  malloc_footprint_limit();
  Returns the number of bytes that the heap is allowed to obtain from
  the system, returning the last value returned by
  malloc_set_footprint_limit, or the maximum size_t value if
  never set. The returned value reflects a permission. There is no
  guarantee that this number of bytes can actually be obtained from
  the system.
*/
DLMALLOC_EXPORT size_t dlmalloc_footprint_limit();

/*
  malloc_set_footprint_limit();
  Sets the maximum number of bytes to obtain from the system, causing
  failure returns from malloc and related functions upon attempts to
  exceed this value. The argument value may be subject to page
  rounding to an enforceable limit; this actual value is returned.
  Using an argument of the maximum possible size_t effectively
  disables checks. If the argument is less than or equal to the
  current malloc_footprint, then all future allocations that require
  additional system memory will fail. However, invocation cannot
  retroactively deallocate existing used memory.
*/
DLMALLOC_EXPORT size_t dlmalloc_set_footprint_limit(size_t bytes);

#if MALLOC_INSPECT_ALL
/*
  malloc_inspect_all(void(*handler)(void *start,
                                    void *end,
                                    size_t used_bytes,
                                    void* callback_arg),
                      void* arg);
  Traverses the heap and calls the given handler for each managed
  region, skipping all bytes that are (or may be) used for bookkeeping
  purposes.  Traversal does not include include chunks that have been
  directly memory mapped. Each reported region begins at the start
  address, and continues up to but not including the end address.  The
  first used_bytes of the region contain allocated data. If
  used_bytes is zero, the region is unallocated. The handler is
  invoked with the given callback argument. If locks are defined, they
  are held during the entire traversal. It is a bad idea to invoke
  other malloc functions from within the handler.

  For example, to count the number of in-use chunks with size greater
  than 1000, you could write:
  static int count = 0;
  void count_chunks(void* start, void* end, size_t used, void* arg) {
    if (used >= 1000) ++count;
  }
  then:
    malloc_inspect_all(count_chunks, NULL);

  malloc_inspect_all is compiled only if MALLOC_INSPECT_ALL is defined.
*/
DLMALLOC_EXPORT void dlmalloc_inspect_all(void(*handler)(void*, void *, size_t, void*),
                           void* arg);

#endif /* MALLOC_INSPECT_ALL */
d797 1
a797 1
                than current total if trimming has occurred.
d802 2
a803 2
               back to system via malloc_trim. ("ideally" means that
               it ignores page restrictions etc.)
d809 1
a809 1
DLMALLOC_EXPORT struct mallinfo dlmallinfo(void);
d836 5
a840 2
  Each element must be freed when it is no longer needed. This can be
  done all at once using bulk_free.
d864 1
a864 1
DLMALLOC_EXPORT void** dlindependent_calloc(size_t, size_t, void**);
d888 5
a892 2
  Each element must be freed when it is no longer needed. This can be
  done all at once using bulk_free.
d925 1
a925 1
DLMALLOC_EXPORT void** dlindependent_comalloc(size_t, size_t*, void**);
a926 10
/*
  bulk_free(void* array[], size_t n_elements)
  Frees and clears (sets to null) each non-null pointer in the given
  array.  This is likely to be faster than freeing them one-by-one.
  If footers are used, pointers that have been allocated in different
  mspaces are not freed or cleared, and the count of all such pointers
  is returned.  For large arrays of pointers with poor locality, it
  may be worthwhile to sort this array before calling bulk_free.
*/
DLMALLOC_EXPORT size_t  dlbulk_free(void**, size_t n_elements);
d933 1
a933 1
DLMALLOC_EXPORT void*  dlpvalloc(size_t);
d956 17
a972 1
DLMALLOC_EXPORT int  dlmalloc_trim(size_t);
d993 1
a993 17
DLMALLOC_EXPORT void  dlmalloc_stats(void);

/*
  malloc_usable_size(void* p);

  Returns the number of bytes you can actually use in
  an allocated chunk, which may be more than you requested (although
  often not) due to alignment and minimum size constraints.
  You can use this many bytes without worrying about
  overwriting other allocated objects. This is not a particularly great
  programming practice. malloc_usable_size can be more useful in
  debugging and assertions, for example:

  p = malloc(n);
  assert(malloc_usable_size(p) >= 256);
*/
size_t dlmalloc_usable_size(void*);
d1016 1
a1016 1
DLMALLOC_EXPORT mspace create_mspace(size_t capacity, int locked);
d1024 1
a1024 1
DLMALLOC_EXPORT size_t destroy_mspace(mspace msp);
d1035 1
a1035 15
DLMALLOC_EXPORT mspace create_mspace_with_base(void* base, size_t capacity, int locked);

/*
  mspace_track_large_chunks controls whether requests for large chunks
  are allocated in their own untracked mmapped regions, separate from
  others in this mspace. By default large chunks are not tracked,
  which reduces fragmentation. However, such chunks are not
  necessarily released to the system upon destroy_mspace.  Enabling
  tracking by setting to true may increase fragmentation, but avoids
  leakage when relying on destroy_mspace to release all memory
  allocated using this space.  The function returns the previous
  setting.
*/
DLMALLOC_EXPORT int mspace_track_large_chunks(mspace msp, int enable);

d1041 1
a1041 1
DLMALLOC_EXPORT void* mspace_malloc(mspace msp, size_t bytes);
d1051 1
a1051 1
DLMALLOC_EXPORT void mspace_free(mspace msp, void* mem);
d1062 1
a1062 1
DLMALLOC_EXPORT void* mspace_realloc(mspace msp, void* mem, size_t newsize);
d1068 1
a1068 1
DLMALLOC_EXPORT void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
d1074 1
a1074 1
DLMALLOC_EXPORT void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
d1080 2
a1081 2
DLMALLOC_EXPORT void** mspace_independent_calloc(mspace msp, size_t n_elements,
                                 size_t elem_size, void* chunks[]);
d1087 2
a1088 2
DLMALLOC_EXPORT void** mspace_independent_comalloc(mspace msp, size_t n_elements,
                                   size_t sizes[], void* chunks[]);
d1094 1
a1094 1
DLMALLOC_EXPORT size_t mspace_footprint(mspace msp);
d1100 1
a1100 1
DLMALLOC_EXPORT size_t mspace_max_footprint(mspace msp);
d1108 1
a1108 1
DLMALLOC_EXPORT struct mallinfo mspace_mallinfo(mspace msp);
a1111 5
  malloc_usable_size(void* p) behaves the same as malloc_usable_size;
*/
DLMALLOC_EXPORT size_t mspace_usable_size(const void* mem);

/*
d1115 1
a1115 1
DLMALLOC_EXPORT void mspace_malloc_stats(mspace msp);
d1121 1
a1121 1
DLMALLOC_EXPORT int mspace_trim(mspace msp, size_t pad);
d1126 1
a1126 1
DLMALLOC_EXPORT int mspace_mallopt(int, int);
d1131 1
a1131 1
}  /* end of extern "C" */
d1146 1
a1146 1
#ifdef _MSC_VER
d1148 2
a1149 2
#endif /* _MSC_VER */
#if !NO_MALLOC_STATS
d1151 1
a1151 1
#endif /* NO_MALLOC_STATS */
d1155 6
a1162 1
#undef assert
a1167 1
#ifndef assert
a1168 2
#endif
#define DEBUG 0
a1169 6
#if !defined(WIN32) && !defined(LACKS_TIME_H)
#include <time.h>        /* for magic initialization */
#endif /* WIN32 */
#ifndef LACKS_STDLIB_H
#include <stdlib.h>      /* for abort() */
#endif /* LACKS_STDLIB_H */
a1179 3
/* On some versions of linux, mremap decl in mman.h needs __USE_GNU set */
#if (defined(linux) && !defined(__USE_GNU))
#define __USE_GNU 1
a1180 4
#undef __USE_GNU
#else
#include <sys/mman.h>    /* for mmap */
#endif /* linux */
d1186 1
d1188 1
a1188 1
#include <unistd.h>     /* for sbrk, sysconf */
d1194 1
a1194 57

/* Declarations for locking */
#if USE_LOCKS
#ifndef WIN32
#if defined (__SVR4) && defined (__sun)  /* solaris */
#include <thread.h>
#elif !defined(LACKS_SCHED_H)
#include <sched.h>
#endif /* solaris or LACKS_SCHED_H */
#if (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0) || !USE_SPIN_LOCKS
#include <pthread.h>
#endif /* USE_RECURSIVE_LOCKS ... */
#elif defined(_MSC_VER)
#ifndef _M_AMD64
/* These are already defined on AMD64 builds */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
LONG __cdecl _InterlockedCompareExchange(LONG volatile *Dest, LONG Exchange, LONG Comp);
LONG __cdecl _InterlockedExchange(LONG volatile *Target, LONG Value);
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* _M_AMD64 */
#pragma intrinsic (_InterlockedCompareExchange)
#pragma intrinsic (_InterlockedExchange)
#define interlockedcompareexchange _InterlockedCompareExchange
#define interlockedexchange _InterlockedExchange
#elif defined(WIN32) && defined(__GNUC__)
#define interlockedcompareexchange(a, b, c) __sync_val_compare_and_swap(a, c, b)
#define interlockedexchange __sync_lock_test_and_set
#endif /* Win32 */
#else /* USE_LOCKS */
#endif /* USE_LOCKS */

#ifndef LOCK_AT_FORK
#define LOCK_AT_FORK 0
#endif

/* Declarations for bit scanning on win32 */
#if defined(_MSC_VER) && _MSC_VER>=1300
#ifndef BitScanForward /* Try to avoid pulling in WinNT.h */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
unsigned char _BitScanForward(unsigned long *index, unsigned long mask);
unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#endif /* BitScanForward */
#endif /* defined(_MSC_VER) && _MSC_VER>=1300 */
d1250 1
a1250 1
/* Annoying but necessary to avoid errors on some platforms */
a1253 1
#define SIZE_T_FOUR         ((size_t)4)
d1283 10
a1292 1
#if HAVE_MMAP
d1295 1
a1295 1
#define MUNMAP_DEFAULT(a, s)  munmap((a), (s))
d1302 1
a1302 1
#define MMAP_DEFAULT(s)       mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
d1310 4
a1313 4
#define MMAP_DEFAULT(s) ((dev_zero_fd < 0) ? \
           (dev_zero_fd = open("/dev/zero", O_RDWR), \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
d1316 1
a1316 2
#define DIRECT_MMAP_DEFAULT(s) MMAP_DEFAULT(s)

d1320 1
a1320 1
static FORCEINLINE void* win32mmap(size_t size) {
d1326 1
a1326 1
static FORCEINLINE void* win32direct_mmap(size_t size) {
d1328 1
a1328 1
                           PAGE_READWRITE);
d1333 1
a1333 1
static FORCEINLINE int win32munmap(void* ptr, size_t size) {
d1335 1
a1335 1
  char* cptr = (char*)ptr;
d1340 1
a1340 1
        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
d1350 3
a1352 3
#define MMAP_DEFAULT(s)             win32mmap(s)
#define MUNMAP_DEFAULT(a, s)        win32munmap((a), (s))
#define DIRECT_MMAP_DEFAULT(s)      win32direct_mmap(s)
d1356 5
a1360 5
#if HAVE_MREMAP
#ifndef WIN32
#define MREMAP_DEFAULT(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
#endif /* WIN32 */
#endif /* HAVE_MREMAP */
a1361 3
/**
 * Define CALL_MORECORE
 */
d1363 1
a1363 5
    #ifdef MORECORE
        #define CALL_MORECORE(S)    MORECORE(S)
    #else  /* MORECORE */
        #define CALL_MORECORE(S)    MORECORE_DEFAULT(S)
    #endif /* MORECORE */
d1365 1
a1365 1
    #define CALL_MORECORE(S)        MFAIL
a1367 45
/**
 * Define CALL_MMAP/CALL_MUNMAP/CALL_DIRECT_MMAP
 */
#if HAVE_MMAP
    #define USE_MMAP_BIT            (SIZE_T_ONE)

    #ifdef MMAP
        #define CALL_MMAP(s)        MMAP(s)
    #else /* MMAP */
        #define CALL_MMAP(s)        MMAP_DEFAULT(s)
    #endif /* MMAP */
    #ifdef MUNMAP
        #define CALL_MUNMAP(a, s)   MUNMAP((a), (s))
    #else /* MUNMAP */
        #define CALL_MUNMAP(a, s)   MUNMAP_DEFAULT((a), (s))
    #endif /* MUNMAP */
    #ifdef DIRECT_MMAP
        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP(s)
    #else /* DIRECT_MMAP */
        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP_DEFAULT(s)
    #endif /* DIRECT_MMAP */
#else  /* HAVE_MMAP */
    #define USE_MMAP_BIT            (SIZE_T_ZERO)

    #define MMAP(s)                 MFAIL
    #define MUNMAP(a, s)            (-1)
    #define DIRECT_MMAP(s)          MFAIL
    #define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)
    #define CALL_MMAP(s)            MMAP(s)
    #define CALL_MUNMAP(a, s)       MUNMAP((a), (s))
#endif /* HAVE_MMAP */

/**
 * Define CALL_MREMAP
 */
#if HAVE_MMAP && HAVE_MREMAP
    #ifdef MREMAP
        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP((addr), (osz), (nsz), (mv))
    #else /* MREMAP */
        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP_DEFAULT((addr), (osz), (nsz), (mv))
    #endif /* MREMAP */
#else  /* HAVE_MMAP && HAVE_MREMAP */
    #define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL
#endif /* HAVE_MMAP && HAVE_MREMAP */

d1377 2
d1380 1
a1380 2
  When locks are defined, there is one global lock, plus
  one per-mspace lock.
d1382 6
a1387 21
  The global lock_ensures that mparams.magic and other unique
  mparams values are initialized only once. It also protects
  sequences of calls to MORECORE.  In many cases sys_alloc requires
  two calls, that should not be interleaved with calls by other
  threads.  This does not protect against direct calls to MORECORE
  by other threads not using this lock, so there is still code to
  cope the best we can on interference.

  Per-mspace locks surround calls to malloc, free, etc.
  By default, locks are simple non-reentrant mutexes.

  Because lock-protected regions generally have bounded times, it is
  OK to use the supplied simple spinlocks. Spinlocks are likely to
  improve performance for lightly contended applications, but worsen
  performance under heavy contention.

  If USE_LOCKS is > 1, the definitions of lock routines here are
  bypassed, in which case you will need to define the type MLOCK_T,
  and at least INITIAL_LOCK, DESTROY_LOCK, ACQUIRE_LOCK, RELEASE_LOCK
  and TRY_LOCK.  You must also declare a
    static MLOCK_T malloc_global_mutex = { initialization values };.
d1389 2
d1393 7
a1399 83
#if !USE_LOCKS
#define USE_LOCK_BIT               (0U)
#define INITIAL_LOCK(l)            (0)
#define DESTROY_LOCK(l)            (0)
#define ACQUIRE_MALLOC_GLOBAL_LOCK()
#define RELEASE_MALLOC_GLOBAL_LOCK()

#else
#if USE_LOCKS > 1
/* -----------------------  User-defined locks ------------------------ */
/* Define your own lock implementation here */
/* #define INITIAL_LOCK(lk)  ... */
/* #define DESTROY_LOCK(lk)  ... */
/* #define ACQUIRE_LOCK(lk)  ... */
/* #define RELEASE_LOCK(lk)  ... */
/* #define TRY_LOCK(lk) ... */
/* static MLOCK_T malloc_global_mutex = ... */

#elif USE_SPIN_LOCKS

/* First, define CAS_LOCK and CLEAR_LOCK on ints */
/* Note CAS_LOCK defined to return 0 on success */

#if defined(__GNUC__)&& (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
#define CAS_LOCK(sl)     __sync_lock_test_and_set(sl, 1)
#define CLEAR_LOCK(sl)   __sync_lock_release(sl)

#elif (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)))
/* Custom spin locks for older gcc on x86 */
static FORCEINLINE int x86_cas_lock(int *sl) {
  int ret;
  int val = 1;
  int cmp = 0;
  __asm__ __volatile__  ("lock; cmpxchgl %1, %2"
                         : "=a" (ret)
                         : "r" (val), "m" (*(sl)), "0"(cmp)
                         : "memory", "cc");
  return ret;
}

static FORCEINLINE void x86_clear_lock(int* sl) {
  assert(*sl != 0);
  int prev = 0;
  int ret;
  __asm__ __volatile__ ("lock; xchgl %0, %1"
                        : "=r" (ret)
                        : "m" (*(sl)), "0"(prev)
                        : "memory");
}

#define CAS_LOCK(sl)     x86_cas_lock(sl)
#define CLEAR_LOCK(sl)   x86_clear_lock(sl)

#else /* Win32 MSC */
#define CAS_LOCK(sl)     interlockedexchange(sl, (LONG)1)
#define CLEAR_LOCK(sl)   interlockedexchange (sl, (LONG)0)

#endif /* ... gcc spins locks ... */

/* How to yield for a spin lock */
#define SPINS_PER_YIELD       63
#if defined(_MSC_VER)
#define SLEEP_EX_DURATION     50 /* delay for yield/sleep */
#define SPIN_LOCK_YIELD  SleepEx(SLEEP_EX_DURATION, FALSE)
#elif defined (__SVR4) && defined (__sun) /* solaris */
#define SPIN_LOCK_YIELD   thr_yield();
#elif !defined(LACKS_SCHED_H)
#define SPIN_LOCK_YIELD   sched_yield();
#else
#define SPIN_LOCK_YIELD
#endif /* ... yield ... */

#if !defined(USE_RECURSIVE_LOCKS) || USE_RECURSIVE_LOCKS == 0
/* Plain spin locks use single word (embedded in malloc_states) */
static int spin_acquire_lock(int *sl) {
  int spins = 0;
  while (*(volatile int *)sl != 0 || CAS_LOCK(sl)) {
    if ((++spins & SPINS_PER_YIELD) == 0) {
      SPIN_LOCK_YIELD;
    }
  }
  return 0;
}
d1401 3
a1403 24
#define MLOCK_T               int
#define TRY_LOCK(sl)          !CAS_LOCK(sl)
#define RELEASE_LOCK(sl)      CLEAR_LOCK(sl)
#define ACQUIRE_LOCK(sl)      (CAS_LOCK(sl)? spin_acquire_lock(sl) : 0)
#define INITIAL_LOCK(sl)      (*sl = 0)
#define DESTROY_LOCK(sl)      (0)
static MLOCK_T malloc_global_mutex = 0;

#else /* USE_RECURSIVE_LOCKS */
/* types for lock owners */
#ifdef WIN32
#define THREAD_ID_T           DWORD
#define CURRENT_THREAD        GetCurrentThreadId()
#define EQ_OWNER(X,Y)         ((X) == (Y))
#else
/*
  Note: the following assume that pthread_t is a type that can be
  initialized to (casted) zero. If this is not the case, you will need to
  somehow redefine these or not use spin locks.
*/
#define THREAD_ID_T           pthread_t
#define CURRENT_THREAD        pthread_self()
#define EQ_OWNER(X,Y)         pthread_equal(X, Y)
#endif
d1405 1
a1405 5
struct malloc_recursive_lock {
  int sl;
  unsigned int c;
  THREAD_ID_T threadid;
};
d1407 5
a1411 9
#define MLOCK_T  struct malloc_recursive_lock
static MLOCK_T malloc_global_mutex = { 0, 0, (THREAD_ID_T)0};

static FORCEINLINE void recursive_release_lock(MLOCK_T *lk) {
  assert(lk->sl != 0);
  if (--lk->c == 0) {
    CLEAR_LOCK(&lk->sl);
  }
}
d1413 2
a1414 3
static FORCEINLINE int recursive_acquire_lock(MLOCK_T *lk) {
  THREAD_ID_T mythreadid = CURRENT_THREAD;
  int spins = 0;
d1416 5
a1420 9
    if (*((volatile int *)(&lk->sl)) == 0) {
      if (!CAS_LOCK(&lk->sl)) {
        lk->threadid = mythreadid;
        lk->c = 1;
        return 0;
      }
    }
    else if (EQ_OWNER(lk->threadid, mythreadid)) {
      ++lk->c;
d1422 2
a1423 19
    }
    if ((++spins & SPINS_PER_YIELD) == 0) {
      SPIN_LOCK_YIELD;
    }
  }
}

static FORCEINLINE int recursive_try_lock(MLOCK_T *lk) {
  THREAD_ID_T mythreadid = CURRENT_THREAD;
  if (*((volatile int *)(&lk->sl)) == 0) {
    if (!CAS_LOCK(&lk->sl)) {
      lk->threadid = mythreadid;
      lk->c = 1;
      return 1;
    }
  }
  else if (EQ_OWNER(lk->threadid, mythreadid)) {
    ++lk->c;
    return 1;
a1424 1
  return 0;
d1427 2
a1428 34
#define RELEASE_LOCK(lk)      recursive_release_lock(lk)
#define TRY_LOCK(lk)          recursive_try_lock(lk)
#define ACQUIRE_LOCK(lk)      recursive_acquire_lock(lk)
#define INITIAL_LOCK(lk)      ((lk)->threadid = (THREAD_ID_T)0, (lk)->sl = 0, (lk)->c = 0)
#define DESTROY_LOCK(lk)      (0)
#endif /* USE_RECURSIVE_LOCKS */

#elif defined(WIN32) /* Win32 critical sections */
#define MLOCK_T               CRITICAL_SECTION
#define ACQUIRE_LOCK(lk)      (EnterCriticalSection(lk), 0)
#define RELEASE_LOCK(lk)      LeaveCriticalSection(lk)
#define TRY_LOCK(lk)          TryEnterCriticalSection(lk)
#define INITIAL_LOCK(lk)      (!InitializeCriticalSectionAndSpinCount((lk), 0x80000000|4000))
#define DESTROY_LOCK(lk)      (DeleteCriticalSection(lk), 0)
#define NEED_GLOBAL_LOCK_INIT

static MLOCK_T malloc_global_mutex;
static volatile LONG malloc_global_mutex_status;

/* Use spin loop to initialize global lock */
static void init_malloc_global_mutex() {
  for (;;) {
    long stat = malloc_global_mutex_status;
    if (stat > 0)
      return;
    /* transition to < 0 while initializing, then to > 0) */
    if (stat == 0 &&
        interlockedcompareexchange(&malloc_global_mutex_status, (LONG)-1, (LONG)0) == 0) {
      InitializeCriticalSection(&malloc_global_mutex);
      interlockedexchange(&malloc_global_mutex_status, (LONG)1);
      return;
    }
    SleepEx(0, FALSE);
  }
d1431 8
a1438 29
#else /* pthreads-based locks */
#define MLOCK_T               pthread_mutex_t
#define ACQUIRE_LOCK(lk)      pthread_mutex_lock(lk)
#define RELEASE_LOCK(lk)      pthread_mutex_unlock(lk)
#define TRY_LOCK(lk)          (!pthread_mutex_trylock(lk))
#define INITIAL_LOCK(lk)      pthread_init_lock(lk)
#define DESTROY_LOCK(lk)      pthread_mutex_destroy(lk)

#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0 && defined(linux) && !defined(PTHREAD_MUTEX_RECURSIVE)
/* Cope with old-style linux recursive lock initialization by adding */
/* skipped internal declaration from pthread.h */
extern int pthread_mutexattr_setkind_np __P ((pthread_mutexattr_t *__attr,
                                              int __kind));
#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
#define pthread_mutexattr_settype(x,y) pthread_mutexattr_setkind_np(x,y)
#endif /* USE_RECURSIVE_LOCKS ... */

static MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;

static int pthread_init_lock (MLOCK_T *lk) {
  pthread_mutexattr_t attr;
  if (pthread_mutexattr_init(&attr)) return 1;
#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0
  if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;
#endif
  if (pthread_mutex_init(lk, &attr)) return 1;
  if (pthread_mutexattr_destroy(&attr)) return 1;
  return 0;
}
a1439 3
#endif /* ... lock types ... */

/* Common code for all lock types */
d1441 4
d1446 7
a1452 3
#ifndef ACQUIRE_MALLOC_GLOBAL_LOCK
#define ACQUIRE_MALLOC_GLOBAL_LOCK()  ACQUIRE_LOCK(&malloc_global_mutex);
#endif
d1454 7
a1460 3
#ifndef RELEASE_MALLOC_GLOBAL_LOCK
#define RELEASE_MALLOC_GLOBAL_LOCK()  RELEASE_LOCK(&malloc_global_mutex);
#endif
a1461 1
#endif /* USE_LOCKS */
d1488 4
a1491 4
           | Size of previous chunk (if P = 0)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
d1493 7
a1499 7
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
d1501 2
a1502 2
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1510 4
a1513 4
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
d1515 7
a1521 7
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
d1523 2
a1524 2
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1532 2
a1533 2
                                                                     |0|
                                                                     +-+
d1559 2
a1560 3
  inuse (unless the chunk is mmapped). This redundancy enables usage
  checks within free and realloc, and reduces indirection when freeing
  and consolidating chunks.
d1565 1
a1565 1
  ensured by making all allocations from the `lowest' part of any
d1578 19
a1596 18
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.

     3. Chunks allocated via mmap, have both cinuse and pinuse bits
        cleared in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.
d1657 3
a1659 3
  use, unless mmapped, in which case both bits are cleared.

  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
a1663 1
#define FLAG4_BIT           (SIZE_T_FOUR)
a1664 1
#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)
d1672 1
a1672 5
#define flag4inuse(p)       ((p)->head & FLAG4_BIT)
#define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)
#define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)

#define chunksize(p)        ((p)->head & ~(FLAG_BITS))
d1675 1
a1675 2
#define set_flag4(p)        ((p)->head |= FLAG4_BIT)
#define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)
d1682 1
a1682 1
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
d1700 3
d1724 2
a1725 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1728 7
a1734 7
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
d1737 1
a1737 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1745 2
a1746 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1749 14
a1762 14
            |             Forward pointer to next chunk of same size        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk of same size       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to left child (child[0])                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to right child (child[1])                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to parent                                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             bin index of this chunk                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space                                      .
            .                                                               |
d1765 1
a1765 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1873 1
a1873 1
  * If USE_MMAP_BIT set, the segment may be merged with
d1888 1
a1888 1
#define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT)
a1956 3
  Max allowed footprint
    The maximum allowed bytes to allocate from system (zero means no limit)

a1963 5
  Trim support
    Fields holding the amount of unused topmost memory that should trigger
    trimming, and a counter to force periodic scanning to release unused
    non-topmost segments.

a1966 4

  Extension support
    A void* pointer and a size_t field that can be used to help implement
    extensions to this malloc.
a1987 1
  size_t     release_checks;
a1992 1
  size_t     footprint_limit; /* zero means no limit */
a1997 2
  void*      extp;      /* Unused but available for extensions */
  size_t     exts;
d2007 1
a2007 2
  initialized in init_mparams. Note that the non-zeroness of "magic"
  also serves as an initialization flag.
a2020 5
/* Ensure mparams initialized */
#define ensure_initialization() (void)(mparams.magic != 0 || init_mparams())

#if !ONLY_MSPACES

a2024 3

#endif /* !ONLY_MSPACES */

a2032 1
#if USE_LOCKS
a2033 3
#else
#define disable_lock(M)
#endif
a2036 1
#if HAVE_MMAP
a2037 3
#else
#define disable_mmap(M)
#endif
d2049 1
a2049 1
 (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
d2053 1
a2053 13
  (((S) + (mparams.granularity - SIZE_T_ONE))\
   & ~(mparams.granularity - SIZE_T_ONE))


/* For mmap, use granularity alignment on windows, else page-align */
#ifdef WIN32
#define mmap_align(S) granularity_align(S)
#else
#define mmap_align(S) page_align(S)
#endif

/* For sys_alloc, enough padding to ensure can malloc request on success */
#define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)
d2110 5
a2114 1
#define PREACTION(M)  ((use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
a2158 1

d2195 1
a2195 1
#define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)
d2203 2
a2204 30
/* assign tree index for size S to variable I. Use x86 asm if possible  */
#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define compute_tree_index(S, I)\
{\
  unsigned int X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int K = (unsigned) sizeof(X)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(X); \
    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
  }\
}

#elif defined (__INTEL_COMPILER)
#define compute_tree_index(S, I)\
{\
  size_t X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int K = _bit_scan_reverse (X); \
    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
  }\
}

#elif defined(_MSC_VER) && _MSC_VER>=1300
d2214 1
a2214 1
    _BitScanReverse((DWORD *) &K, (DWORD) X);\
a2217 1

d2267 1
a2267 2
/* isolate the least set bit of a bitmap */
#define least_bit(x)         ((x) & -(x))
d2269 6
a2274 14
/* mask with all bits to left of least bit of x on */
#define left_bits(x)         ((x<<1) | -(x<<1))

/* mask with all bits to left of or equal to least bit of x on */
#define same_or_left_bits(x) ((x) | -(x))

/* index corresponding to given bit. Use x86 asm if possible */

#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  J = __builtin_ctz(X); \
  I = (bindex_t)J;\
d2277 2
a2278 17
#elif defined (__INTEL_COMPILER)
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  J = _bit_scan_forward (X); \
  I = (bindex_t)J;\
}

#elif defined(_MSC_VER) && _MSC_VER>=1300
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  _BitScanForward((DWORD *) &J, X);\
  I = (bindex_t)J;\
}

#elif USE_BUILTIN_FFS
d2281 1
a2281 1
#else
d2293 1
d2296 9
d2326 1
a2326 1
  (probabalistically) unguessable from outside the program, but can be
d2339 2
a2340 2
/* Check if p has inuse status */
#define ok_inuse(p)     is_inuse(p)
d2347 1
a2347 1
#define ok_inuse(p)      (1)
d2358 1
a2375 2
/* Macros for setting head/foot of non-mmapped chunks */

a2417 6
#if LOCK_AT_FORK
static void pre_fork(void)         { ACQUIRE_LOCK(&(gm)->mutex); }
static void post_fork_parent(void) { RELEASE_LOCK(&(gm)->mutex); }
static void post_fork_child(void)  { INITIAL_LOCK(&(gm)->mutex); }
#endif /* LOCK_AT_FORK */

d2420 2
a2421 23
#ifdef NEED_GLOBAL_LOCK_INIT
  if (malloc_global_mutex_status <= 0)
    init_malloc_global_mutex();
#endif

  ACQUIRE_MALLOC_GLOBAL_LOCK();
  if (mparams.magic == 0) {
    size_t magic;
    size_t psize;
    size_t gsize;

#ifndef WIN32
    psize = malloc_getpagesize;
    gsize = ((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);
#else /* WIN32 */
    {
      SYSTEM_INFO system_info;
      GetSystemInfo(&system_info);
      psize = system_info.dwPageSize;
      gsize = ((DEFAULT_GRANULARITY != 0)?
               DEFAULT_GRANULARITY : system_info.dwAllocationGranularity);
    }
#endif /* WIN32 */
a2422 17
    /* Sanity-check configuration:
       size_t must be unsigned and as wide as pointer type.
       ints must be at least 4 bytes.
       alignment must be at least 8.
       Alignment, min chunk size, and page size must all be powers of 2.
    */
    if ((sizeof(size_t) != sizeof(char*)) ||
        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
        (sizeof(int) < 4)  ||
        (MALLOC_ALIGNMENT < (size_t)8U) ||
        ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||
        ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||
        ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
        ((psize            & (psize-SIZE_T_ONE))            != 0))
      ABORT;
    mparams.granularity = gsize;
    mparams.page_size = psize;
d2431 1
a2431 9
#if !ONLY_MSPACES
    /* Set up lock for main malloc area */
    gm->mflags = mparams.default_mflags;
    (void)INITIAL_LOCK(&gm->mutex);
#endif
#if LOCK_AT_FORK
    pthread_atfork(&pre_fork, &post_fork_parent, &post_fork_child);
#endif

d2438 3
a2440 3
          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
        magic = *((size_t *) buf);
        close(fd);
d2444 28
a2471 11
#ifdef WIN32
      magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);
#elif defined(LACKS_TIME_H)
      magic = (size_t)&magic ^ (size_t)0x55555555U;
#else
      magic = (size_t)(time(0) ^ (size_t)0x55555555U);
#endif
      magic |= (size_t)8U;    /* ensure nonzero */
      magic &= ~(size_t)7U;   /* improve chances of fault for bad values */
      /* Until memory modes commonly available, use volatile-write */
      (*(volatile size_t *)(&(mparams.magic))) = magic;
d2473 17
d2491 1
a2491 3

  RELEASE_MALLOC_GLOBAL_LOCK();
  return 1;
d2496 2
a2497 3
  size_t val;
  ensure_initialization();
  val = (value == -1)? MAX_SIZE_T : (size_t)value;
d2529 1
a2529 1
  size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */
d2537 1
a2537 1
  assert(!pinuse(chunk_plus_offset(p, sz)));
d2543 1
a2543 1
  size_t len = (sz + (p->prev_foot) + MMAP_FOOT_PAD);
d2557 1
a2557 1
  assert(is_inuse(p));
d2567 1
a2567 1
  size_t sz = chunksize(p);
d2570 1
a2570 1
  assert(!is_inuse(p));
d2579 1
a2579 1
      assert (next == m->top || is_inuse(next));
d2592 1
a2592 1
    size_t sz = p->head & ~INUSE_BITS;
d2619 1
a2619 1
    assert(!is_inuse(u));
d2632 2
a2633 2
              u->parent->child[1] == u ||
              *((tbinptr*)(u->parent)) == u);
d2635 3
a2637 3
        assert(u->child[0]->parent == u);
        assert(u->child[0] != u);
        do_check_tree(m, u->child[0]);
d2640 3
a2642 3
        assert(u->child[1]->parent == u);
        assert(u->child[1] != u);
        do_check_tree(m, u->child[1]);
d2645 1
a2645 1
        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
d2683 1
a2683 1
        do_check_inuse_chunk(m, q);
d2697 2
a2698 2
        if (p == x)
          return 1;
d2709 2
a2710 2
        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
        sizebits <<= 1;
d2713 5
a2717 5
        tchunkptr u = t;
        do {
          if (u == (tchunkptr)x)
            return 1;
        } while ((u = u->fd) != t);
d2735 13
a2747 13
             q != m->top && q->head != FENCEPOST_HEAD) {
        sum += chunksize(q);
        if (is_inuse(q)) {
          assert(!bin_find(m, q));
          do_check_inuse_chunk(m, q);
        }
        else {
          assert(q == m->dv || bin_find(m, q));
          assert(lastq == 0 || is_inuse(lastq)); /* Not 2 consecutive free */
          do_check_free_chunk(m, q);
        }
        lastq = q;
        q = next_chunk(q);
a2754 1

d2774 1
a2774 1
    /*assert(m->topsize == chunksize(m->top)); redundant */
a2789 1
  ensure_initialization();
d2798 12
a2809 12
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          size_t sz = chunksize(q);
          sum += sz;
          if (!is_inuse(q)) {
            mfree += sz;
            ++nfree;
          }
          q = next_chunk(q);
        }
        s = s->next;
a2826 1
#if !NO_MALLOC_STATS
a2827 1
  ensure_initialization();
d2840 8
a2847 8
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          if (!is_inuse(q))
            used -= chunksize(q);
          q = next_chunk(q);
        }
        s = s->next;
d2850 1
a2850 1
    POSTACTION(m); /* drop lock */
d2854 2
a2857 1
#endif /* NO_MALLOC_STATS */
d2895 6
a2900 12
  if (RTCHECK(F == smallbin_at(M,I) || (ok_address(M, F) && F->bk == P))) { \
    if (B == F) {\
      clear_smallmap(M, I);\
    }\
    else if (RTCHECK(B == smallbin_at(M,I) ||\
                     (ok_address(M, B) && B->fd == P))) {\
      F->bk = B;\
      B->fd = F;\
    }\
    else {\
      CORRUPTION_ERROR_ACTION(M);\
    }\
d2913 1
a2913 1
  if (B == F) {\
d2915 2
a2916 2
  }\
  else if (RTCHECK(ok_address(M, F) && F->bk == P)) {\
a2917 1
    B->fd = F;\
a2927 1
  assert(is_small(DVS));\
d2930 1
d2958 14
a2971 14
        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
        K <<= 1;\
        if (*C != 0)\
          T = *C;\
        else if (RTCHECK(ok_address(M, C))) {\
          *C = X;\
          X->parent = T;\
          X->fd = X->bk = X;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d2974 12
a2985 12
        tchunkptr F = T->fd;\
        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
          T->fd = F->bk = X;\
          X->fd = F;\
          X->bk = T;\
          X->parent = 0;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d3014 1
a3014 1
    if (RTCHECK(ok_address(M, F) && F->bk == X && R->fd == X)) {\
d3025 1
a3025 1
        ((R = *(RP = &(X->child[0]))) != 0)) {\
d3028 2
a3029 2
             (*(CP = &(R->child[0])) != 0)) {\
        R = *(RP = CP);\
d3032 1
a3032 1
        *RP = 0;\
d3034 1
a3034 1
        CORRUPTION_ERROR_ACTION(M);\
d3042 1
a3042 1
        clear_treemap(M, X->index);\
d3046 1
a3046 1
        XP->child[0] = R;\
d3048 1
a3048 1
        XP->child[1] = R;\
d3054 18
a3071 18
        tchunkptr C0, C1;\
        R->parent = XP;\
        if ((C0 = X->child[0]) != 0) {\
          if (RTCHECK(ok_address(M, C0))) {\
            R->child[0] = C0;\
            C0->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
        if ((C1 = X->child[1]) != 0) {\
          if (RTCHECK(ok_address(M, C1))) {\
            R->child[1] = C1;\
            C1->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
d3074 1
a3074 1
        CORRUPTION_ERROR_ACTION(M);\
d3098 1
a3098 1
  ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
d3114 3
a3116 1
  requirements (especially in memalign).
d3121 1
a3121 6
  size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
  if (m->footprint_limit != 0) {
    size_t fp = m->footprint + mmsize;
    if (fp <= m->footprint || fp > m->footprint_limit)
      return 0;
  }
d3123 1
a3123 1
    char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));
d3128 2
a3129 2
      p->prev_foot = offset;
      p->head = psize;
d3134 2
a3135 2
      if (m->least_addr == 0 || mm < m->least_addr)
        m->least_addr = mm;
d3137 1
a3137 1
        m->max_footprint = m->footprint;
d3147 1
a3147 1
static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb, int flags) {
a3148 1
  (void)flags; /* placate people compiling -Wunused */
d3156 1
a3156 1
    size_t offset = oldp->prev_foot;
d3158 2
a3159 1
    size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3161 1
a3161 1
                                  oldmmsize, newmmsize, flags);
d3165 1
a3165 1
      newp->head = psize;
d3171 1
a3171 1
        m->least_addr = cp;
d3173 1
a3173 1
        m->max_footprint = m->footprint;
a3180 1

d3215 1
a3215 1
  m->smallmap = m->treemap = 0;
d3229 1
a3229 1
                           size_t nb) {
d3254 1
a3254 1
    if (!is_inuse(oldfirst)) {
d3269 1
a3329 1
  size_t asize; /* allocation size */
d3331 1
a3331 1
  ensure_initialization();
d3333 2
a3334 2
  /* Directly map large chunks, but only if already initialized */
  if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
a3339 9
  asize = granularity_align(nb + SYS_ALLOC_PADDING);
  if (asize <= nb)
    return 0; /* wraparound */
  if (m->footprint_limit != 0) {
    size_t fp = m->footprint + asize;
    if (fp <= m->footprint || fp > m->footprint_limit)
      return 0;
  }

a3354 5

   In all cases, we need to request enough bytes from system to ensure
   we can malloc nb bytes upon success, so pad with enough space for
   top_foot, plus alignment-pad to make sure we don't lose bytes if
   not on boundary, and round this up to a granularity unit.
a3358 1
    size_t ssize = asize; /* sbrk call size */
d3360 2
a3361 1
    ACQUIRE_MALLOC_GLOBAL_LOCK();
d3366 10
a3375 12
        size_t fp;
        /* Adjust to end on a page boundary */
        if (!is_page_aligned(base))
          ssize += (page_align((size_t)base) - (size_t)base);
        fp = m->footprint + ssize; /* recheck limits */
        if (ssize > nb && ssize < HALF_MAX_SIZE_T &&
            (m->footprint_limit == 0 ||
             (fp > m->footprint && fp <= m->footprint_limit)) &&
            (br = (char*)(CALL_MORECORE(ssize))) == base) {
          tbase = base;
          tsize = ssize;
        }
d3380 1
a3380 1
      ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);
d3382 4
a3385 4
      if (ssize < HALF_MAX_SIZE_T &&
          (br = (char*)(CALL_MORECORE(ssize))) == ss->base+ss->size) {
        tbase = br;
        tsize = ssize;
d3391 13
a3403 13
        if (ssize < HALF_MAX_SIZE_T &&
            ssize < nb + SYS_ALLOC_PADDING) {
          size_t esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);
          if (esize < HALF_MAX_SIZE_T) {
            char* end = (char*)CALL_MORECORE(esize);
            if (end != CMFAIL)
              ssize += esize;
            else {            /* Can't use; try to release */
              (void) CALL_MORECORE(-ssize);
              br = CMFAIL;
            }
          }
        }
d3406 2
a3407 2
        tbase = br;
        tsize = ssize;
d3410 1
a3410 1
        disable_contiguous(m); /* Don't try contiguous path in the future */
d3413 1
a3413 1
    RELEASE_MALLOC_GLOBAL_LOCK();
d3417 9
a3425 5
    char* mp = (char*)(CALL_MMAP(asize));
    if (mp != CMFAIL) {
      tbase = mp;
      tsize = asize;
      mmap_flag = USE_MMAP_BIT;
d3430 1
d3434 1
a3434 1
      ACQUIRE_MALLOC_GLOBAL_LOCK();
d3437 1
a3437 1
      RELEASE_MALLOC_GLOBAL_LOCK();
d3439 5
a3443 5
        size_t ssize = end - br;
        if (ssize > nb + TOP_FOOT_SIZE) {
          tbase = br;
          tsize = ssize;
        }
d3454 1
a3454 3
      if (m->least_addr == 0 || tbase < m->least_addr)
        m->least_addr = tbase;
      m->seg.base = tbase;
a3457 1
      m->release_checks = MAX_RELEASE_CHECK_RATE;
a3458 1
#if !ONLY_MSPACES
d3460 5
a3464 7
        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
      else
#endif
      {
        /* Offset top by embedded malloc_state */
        mchunkptr mn = next_chunk(mem2chunk(m));
        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
a3470 1
      /* Only consider most recent segment if traversal suppressed */
d3472 1
a3472 1
        sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
d3474 5
a3478 5
          !is_extern_segment(sp) &&
          (sp->sflags & USE_MMAP_BIT) == mmap_flag &&
          segment_holds(sp, m->top)) { /* append */
        sp->size += tsize;
        init_top(m, m->top, m->topsize + tsize);
d3481 15
a3495 15
        if (tbase < m->least_addr)
          m->least_addr = tbase;
        sp = &m->seg;
        while (sp != 0 && sp->base != tbase + tsize)
          sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
        if (sp != 0 &&
            !is_extern_segment(sp) &&
            (sp->sflags & USE_MMAP_BIT) == mmap_flag) {
          char* oldbase = sp->base;
          sp->base = tbase;
          sp->size += tsize;
          return prepend_alloc(m, tbase, oldbase, nb);
        }
        else
          add_segment(m, tbase, tsize, mmap_flag);
a3519 1
  int nsegs = 0;
a3525 1
    ++nsegs;
d3530 20
a3549 20
      if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
        tchunkptr tp = (tchunkptr)p;
        assert(segment_holds(sp, (char*)sp));
        if (p == m->dv) {
          m->dv = 0;
          m->dvsize = 0;
        }
        else {
          unlink_large_chunk(m, tp);
        }
        if (CALL_MUNMAP(base, size) == 0) {
          released += size;
          m->footprint -= size;
          /* unlink obsoleted record */
          sp = pred;
          sp->next = next;
        }
        else { /* back out if cannot unmap */
          insert_large_chunk(m, tp, psize);
        }
a3551 2
    if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */
      break;
a3554 3
  /* Reset check counter */
  m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
                       (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);
a3559 1
  ensure_initialization();
d3567 1
a3567 1
                      SIZE_T_ONE) * unit;
d3571 28
a3598 29
        if (is_mmapped_segment(sp)) {
          if (HAVE_MMAP &&
              sp->size >= extra &&
              !has_segment_link(m, sp)) { /* can't shrink if pinned */
            size_t newsize = sp->size - extra;
            (void)newsize; /* placate people compiling -Wunused-variable */
            /* Prefer mremap, fall back to munmap */
            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
              released = extra;
            }
          }
        }
        else if (HAVE_MORECORE) {
          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
          ACQUIRE_MALLOC_GLOBAL_LOCK();
          {
            /* Make sure end of memory is where we last set it. */
            char* old_br = (char*)(CALL_MORECORE(0));
            if (old_br == sp->base + sp->size) {
              char* rel_br = (char*)(CALL_MORECORE(-extra));
              char* new_br = (char*)(CALL_MORECORE(0));
              if (rel_br != CMFAIL && new_br < old_br)
                released = old_br - new_br;
            }
          }
          RELEASE_MALLOC_GLOBAL_LOCK();
        }
d3602 4
a3605 4
        sp->size -= released;
        m->footprint -= released;
        init_top(m, m->top, m->topsize - released);
        check_top_chunk(m, m->top);
d3614 1
a3614 1
    if (released == 0 && m->topsize > m->trim_check)
d3621 1
a3621 72
/* Consolidate and bin a chunk. Differs from exported versions
   of free mainly in that the chunk need not be marked as inuse.
*/
static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {
  mchunkptr next = chunk_plus_offset(p, psize);
  if (!pinuse(p)) {
    mchunkptr prev;
    size_t prevsize = p->prev_foot;
    if (is_mmapped(p)) {
      psize += prevsize + MMAP_FOOT_PAD;
      if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
        m->footprint -= psize;
      return;
    }
    prev = chunk_minus_offset(p, prevsize);
    psize += prevsize;
    p = prev;
    if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
      if (p != m->dv) {
        unlink_chunk(m, p, prevsize);
      }
      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
        m->dvsize = psize;
        set_free_with_pinuse(p, psize, next);
        return;
      }
    }
    else {
      CORRUPTION_ERROR_ACTION(m);
      return;
    }
  }
  if (RTCHECK(ok_address(m, next))) {
    if (!cinuse(next)) {  /* consolidate forward */
      if (next == m->top) {
        size_t tsize = m->topsize += psize;
        m->top = p;
        p->head = tsize | PINUSE_BIT;
        if (p == m->dv) {
          m->dv = 0;
          m->dvsize = 0;
        }
        return;
      }
      else if (next == m->dv) {
        size_t dsize = m->dvsize += psize;
        m->dv = p;
        set_size_and_pinuse_of_free_chunk(p, dsize);
        return;
      }
      else {
        size_t nsize = chunksize(next);
        psize += nsize;
        unlink_chunk(m, next, nsize);
        set_size_and_pinuse_of_free_chunk(p, psize);
        if (p == m->dv) {
          m->dvsize = psize;
          return;
        }
      }
    }
    else {
      set_free_with_pinuse(p, psize, next);
    }
    insert_chunk(m, p, psize);
  }
  else {
    CORRUPTION_ERROR_ACTION(m);
  }
}

/* ---------------------------- malloc --------------------------- */
d3630 1
d3639 3
a3641 3
        v = t;
        if ((rsize = trem) == 0)
          break;
d3646 1
a3646 1
        rst = rt;
d3648 2
a3649 2
        t = rst; /* set t to least subtree holding sizes > nb */
        break;
d3654 1
d3680 9
a3688 9
        unlink_large_chunk(m, v);
        if (rsize < MIN_CHUNK_SIZE)
          set_inuse_and_pinuse(m, v, (rsize + nb));
        else {
          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
          set_size_and_pinuse_of_free_chunk(r, rsize);
          insert_chunk(m, r, rsize);
        }
        return chunk2mem(v);
d3703 1
d3721 1
a3721 1
        set_inuse_and_pinuse(m, v, (rsize + nb));
d3723 3
a3725 3
        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
        set_size_and_pinuse_of_free_chunk(r, rsize);
        replace_dv(m, r, rsize);
d3735 1
a3735 1
#if !ONLY_MSPACES
d3737 11
a3747 20
void* dlmalloc(size_t bytes) {
  /*
     Basic algorithm:
     If a small request (< 256 bytes minus per-chunk overhead):
       1. If one exists, use a remainderless chunk in associated smallbin.
          (Remainderless means that there are too few excess bytes to
          represent as a chunk.)
       2. If it is big enough, use the dv chunk, which is normally the
          chunk adjacent to the one used for the most recent small request.
       3. If one exists, split the smallest available chunk in a bin,
          saving remainder in dv.
       4. If it is big enough, use the top chunk.
       5. If available, get memory from system and use it
     Otherwise, for a large request:
       1. Find the smallest available binned chunk that fits, and use it
          if it is better fitting than dv chunk, splitting if necessary.
       2. If better fitting than any binned chunk, use the dv chunk.
       3. If it is big enough, use the top chunk.
       4. If request size >= mmap threshold, try to directly mmap this chunk.
       5. If available, get memory from system and use it
d3749 1
a3749 2
     The ugly goto's here ensure that postaction occurs along all paths.
  */
d3751 32
a3782 3
#if USE_LOCKS
  ensure_initialization(); /* initialize in sys_alloc if not using locks */
#endif
d3784 1
a3784 9
  if (!PREACTION(gm)) {
    void* mem;
    size_t nb;
    if (bytes <= MAX_SMALL_REQUEST) {
      bindex_t idx;
      binmap_t smallbits;
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
      idx = small_index(nb);
      smallbits = gm->smallmap >> idx;
d3786 3
a3788 44
      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(gm, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(gm, b, p, idx);
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
      }

      else if (nb > gm->dvsize) {
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(gm, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(gm, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(gm, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(gm, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }

        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }
d3790 2
a3792 2
    else if (bytes >= MAX_REQUEST)
      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
d3794 5
a3798 4
      nb = pad_request(bytes);
      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
d3800 1
d3802 30
d3833 30
a3862 8
    if (nb <= gm->dvsize) {
      size_t rsize = gm->dvsize - nb;
      mchunkptr p = gm->dv;
      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
        gm->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
d3864 11
a3874 5
      else { /* exhaust dv */
        size_t dvs = gm->dvsize;
        gm->dvsize = 0;
        gm->dv = 0;
        set_inuse_and_pinuse(gm, p, dvs);
a3875 4
      mem = chunk2mem(p);
      check_malloced_chunk(gm, mem, nb);
      goto postaction;
    }
d3877 11
a3887 10
    else if (nb < gm->topsize) { /* Split top */
      size_t rsize = gm->topsize -= nb;
      mchunkptr p = gm->top;
      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
      r->head = rsize | PINUSE_BIT;
      set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
      mem = chunk2mem(p);
      check_top_chunk(gm, gm->top);
      check_malloced_chunk(gm, mem, nb);
      goto postaction;
a3888 6

    mem = sys_alloc(gm, nb);

  postaction:
    POSTACTION(gm);
    return mem;
a3889 1

d3893 1
a3893 1
/* ---------------------------- free --------------------------- */
d3895 5
a3899 1
void dlfree(void* mem) {
d3901 6
a3906 3
     Consolidate freed chunks with preceeding or succeeding bordering
     free chunks, if they exist, and then place in a bin.  Intermixed
     with special cases for top, dv, mmapped chunks, and usage errors.
a3908 288
  if (mem != 0) {
    mchunkptr p  = mem2chunk(mem);
#if FOOTERS
    mstate fm = get_mstate_for(p);
    if (!ok_magic(fm)) {
      USAGE_ERROR_ACTION(fm, p);
      return;
    }
#else /* FOOTERS */
#define fm gm
#endif /* FOOTERS */
    if (!PREACTION(fm)) {
      check_inuse_chunk(fm, p);
      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if (is_mmapped(p)) {
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
      }
    erroraction:
      USAGE_ERROR_ACTION(fm, p);
    postaction:
      POSTACTION(fm);
    }
  }
#if !FOOTERS
#undef fm
#endif /* FOOTERS */
}

void* dlcalloc(size_t n_elements, size_t elem_size) {
  void* mem;
  size_t req = 0;
  if (n_elements != 0) {
    req = n_elements * elem_size;
    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
        (req / n_elements != elem_size))
      req = MAX_SIZE_T; /* force downstream failure on overflow */
  }
  mem = dlmalloc(req);
  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
    memset(mem, 0, req);
  return mem;
}

#endif /* !ONLY_MSPACES */

/* ------------ Internal support for realloc, memalign, etc -------------- */

/* Try to realloc; only in-place unless can_move true */
static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
                                   int can_move) {
  mchunkptr newp = 0;
  size_t oldsize = chunksize(p);
  mchunkptr next = chunk_plus_offset(p, oldsize);
  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
              ok_next(p, next) && ok_pinuse(next))) {
    if (is_mmapped(p)) {
      newp = mmap_resize(m, p, nb, can_move);
    }
    else if (oldsize >= nb) {             /* already big enough */
      size_t rsize = oldsize - nb;
      if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */
        mchunkptr r = chunk_plus_offset(p, nb);
        set_inuse(m, p, nb);
        set_inuse(m, r, rsize);
        dispose_chunk(m, r, rsize);
      }
      newp = p;
    }
    else if (next == m->top) {  /* extend into top */
      if (oldsize + m->topsize > nb) {
        size_t newsize = oldsize + m->topsize;
        size_t newtopsize = newsize - nb;
        mchunkptr newtop = chunk_plus_offset(p, nb);
        set_inuse(m, p, nb);
        newtop->head = newtopsize |PINUSE_BIT;
        m->top = newtop;
        m->topsize = newtopsize;
        newp = p;
      }
    }
    else if (next == m->dv) { /* extend into dv */
      size_t dvs = m->dvsize;
      if (oldsize + dvs >= nb) {
        size_t dsize = oldsize + dvs - nb;
        if (dsize >= MIN_CHUNK_SIZE) {
          mchunkptr r = chunk_plus_offset(p, nb);
          mchunkptr n = chunk_plus_offset(r, dsize);
          set_inuse(m, p, nb);
          set_size_and_pinuse_of_free_chunk(r, dsize);
          clear_pinuse(n);
          m->dvsize = dsize;
          m->dv = r;
        }
        else { /* exhaust dv */
          size_t newsize = oldsize + dvs;
          set_inuse(m, p, newsize);
          m->dvsize = 0;
          m->dv = 0;
        }
        newp = p;
      }
    }
    else if (!cinuse(next)) { /* extend into next free chunk */
      size_t nextsize = chunksize(next);
      if (oldsize + nextsize >= nb) {
        size_t rsize = oldsize + nextsize - nb;
        unlink_chunk(m, next, nextsize);
        if (rsize < MIN_CHUNK_SIZE) {
          size_t newsize = oldsize + nextsize;
          set_inuse(m, p, newsize);
        }
        else {
          mchunkptr r = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
          set_inuse(m, r, rsize);
          dispose_chunk(m, r, rsize);
        }
        newp = p;
      }
    }
  }
  else {
    USAGE_ERROR_ACTION(m, chunk2mem(p));
  }
  return newp;
}

static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
  void* mem = 0;
  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
    alignment = MIN_CHUNK_SIZE;
  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
    size_t a = MALLOC_ALIGNMENT << 1;
    while (a < alignment) a <<= 1;
    alignment = a;
  }
  if (bytes >= MAX_REQUEST - alignment) {
    if (m != 0)  { /* Test isn't needed but avoids compiler warning */
      MALLOC_FAILURE_ACTION;
    }
  }
  else {
    size_t nb = request2size(bytes);
    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
    mem = internal_malloc(m, req);
    if (mem != 0) {
      mchunkptr p = mem2chunk(mem);
      if (PREACTION(m))
        return 0;
      if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */
        /*
          Find an aligned spot inside chunk.  Since we need to give
          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
          the first calculation places us at a spot with less than
          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
          We've allocated enough total room so that this is always
          possible.
        */
        char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
                                                       SIZE_T_ONE)) &
                                             -alignment));
        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
          br : br+alignment;
        mchunkptr newp = (mchunkptr)pos;
        size_t leadsize = pos - (char*)(p);
        size_t newsize = chunksize(p) - leadsize;

        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
          newp->prev_foot = p->prev_foot + leadsize;
          newp->head = newsize;
        }
        else { /* Otherwise, give back leader, use the rest */
          set_inuse(m, newp, newsize);
          set_inuse(m, p, leadsize);
          dispose_chunk(m, p, leadsize);
        }
        p = newp;
      }

      /* Give back spare room at the end */
      if (!is_mmapped(p)) {
        size_t size = chunksize(p);
        if (size > nb + MIN_CHUNK_SIZE) {
          size_t remainder_size = size - nb;
          mchunkptr remainder = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
          set_inuse(m, remainder, remainder_size);
          dispose_chunk(m, remainder, remainder_size);
        }
      }

      mem = chunk2mem(p);
      assert (chunksize(p) >= nb);
      assert(((size_t)mem & (alignment - 1)) == 0);
      check_inuse_chunk(m, p);
      POSTACTION(m);
    }
  }
  return mem;
}

/*
  Common support for independent_X routines, handling
    all of the combinations that can result.
  The opts arg has:
    bit 0 set if all elements are same size (using sizes[0])
    bit 1 set if elements should be zeroed
*/
static void** ialloc(mstate m,
                     size_t n_elements,
                     size_t* sizes,
                     int opts,
                     void* chunks[]) {

a3920 1
  ensure_initialization();
d3988 1
a3988 1
        size = element_size;
d3990 1
a3990 1
        size = request2size(sizes[i]);
d4021 109
a4129 40
/* Try to free all pointers in the given array.
   Note: this could be made faster, by delaying consolidation,
   at the price of disabling some user integrity checks, We
   still optimize some consolidations by combining adjacent
   chunks before freeing, which will occur often if allocated
   with ialloc or the array is sorted.
*/
static size_t internal_bulk_free(mstate m, void* array[], size_t nelem) {
  size_t unfreed = 0;
  if (!PREACTION(m)) {
    void** a;
    void** fence = &(array[nelem]);
    for (a = array; a != fence; ++a) {
      void* mem = *a;
      if (mem != 0) {
        mchunkptr p = mem2chunk(mem);
        size_t psize = chunksize(p);
#if FOOTERS
        if (get_mstate_for(p) != m) {
          ++unfreed;
          continue;
        }
#endif
        check_inuse_chunk(m, p);
        *a = 0;
        if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {
          void ** b = a + 1; /* try to merge with next chunk */
          mchunkptr next = next_chunk(p);
          if (b != fence && *b == chunk2mem(next)) {
            size_t newsize = chunksize(next) + psize;
            set_inuse(m, p, newsize);
            *b = chunk2mem(p);
          }
          else
            dispose_chunk(m, p, psize);
        }
        else {
          CORRUPTION_ERROR_ACTION(m);
          break;
        }
d4131 15
d4147 6
a4152 3
    if (should_trim(m, m->topsize))
      sys_trim(m, 0);
    POSTACTION(m);
d4154 2
a4155 1
  return unfreed;
d4158 88
a4245 36
/* Traversal */
#if MALLOC_INSPECT_ALL
static void internal_inspect_all(mstate m,
                                 void(*handler)(void *start,
                                                void *end,
                                                size_t used_bytes,
                                                void* callback_arg),
                                 void* arg) {
  if (is_initialized(m)) {
    mchunkptr top = m->top;
    msegmentptr s;
    for (s = &m->seg; s != 0; s = s->next) {
      mchunkptr q = align_as_chunk(s->base);
      while (segment_holds(s, q) && q->head != FENCEPOST_HEAD) {
        mchunkptr next = next_chunk(q);
        size_t sz = chunksize(q);
        size_t used;
        void* start;
        if (is_inuse(q)) {
          used = sz - CHUNK_OVERHEAD; /* must not be mmapped */
          start = chunk2mem(q);
        }
        else {
          used = 0;
          if (is_small(sz)) {     /* offset by possible bookkeeping */
            start = (void*)((char*)q + sizeof(struct malloc_chunk));
          }
          else {
            start = (void*)((char*)q + sizeof(struct malloc_tree_chunk));
          }
        }
        if (start < (void*)next)  /* skip if all space is bookkeeping */
          handler(start, next, used, arg);
        if (q == top)
          break;
        q = next;
d4247 4
d4253 3
a4256 1
#endif /* MALLOC_INSPECT_ALL */
d4258 14
a4271 3
/* ------------------ Exported realloc, memalign, etc -------------------- */

#if !ONLY_MSPACES
d4274 2
a4275 7
  void* mem = 0;
  if (oldmem == 0) {
    mem = dlmalloc(bytes);
  }
  else if (bytes >= MAX_REQUEST) {
    MALLOC_FAILURE_ACTION;
  }
d4277 1
a4277 1
  else if (bytes == 0) {
d4279 1
a4282 2
    size_t nb = request2size(bytes);
    mchunkptr oldp = mem2chunk(oldmem);
d4286 1
a4286 1
    mstate m = get_mstate_for(oldp);
d4292 1
a4292 16
    if (!PREACTION(m)) {
      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
      POSTACTION(m);
      if (newp != 0) {
        check_inuse_chunk(m, newp);
        mem = chunk2mem(newp);
      }
      else {
        mem = internal_malloc(m, bytes);
        if (mem != 0) {
          size_t oc = chunksize(oldp) - overhead_for(oldp);
          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
          internal_free(m, oldmem);
        }
      }
    }
a4293 1
  return mem;
d4296 2
a4297 29
void* dlrealloc_in_place(void* oldmem, size_t bytes) {
  void* mem = 0;
  if (oldmem != 0) {
    if (bytes >= MAX_REQUEST) {
      MALLOC_FAILURE_ACTION;
    }
    else {
      size_t nb = request2size(bytes);
      mchunkptr oldp = mem2chunk(oldmem);
#if ! FOOTERS
      mstate m = gm;
#else /* FOOTERS */
      mstate m = get_mstate_for(oldp);
      if (!ok_magic(m)) {
        USAGE_ERROR_ACTION(m, oldmem);
        return 0;
      }
#endif /* FOOTERS */
      if (!PREACTION(m)) {
        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
        POSTACTION(m);
        if (newp == oldp) {
          check_inuse_chunk(m, newp);
          mem = oldmem;
        }
      }
    }
  }
  return mem;
d4300 4
a4303 5
void* dlmemalign(size_t alignment, size_t bytes) {
  if (alignment <= MALLOC_ALIGNMENT) {
    return dlmalloc(bytes);
  }
  return internal_memalign(gm, alignment, bytes);
d4306 3
a4308 21
int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {
  void* mem = 0;
  if (alignment == MALLOC_ALIGNMENT)
    mem = dlmalloc(bytes);
  else {
    size_t d = alignment / sizeof(void*);
    size_t r = alignment % sizeof(void*);
    if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)
      return EINVAL;
    else if (bytes <= MAX_REQUEST - alignment) {
      if (alignment <  MIN_CHUNK_SIZE)
        alignment = MIN_CHUNK_SIZE;
      mem = internal_memalign(gm, alignment, bytes);
    }
  }
  if (mem == 0)
    return ENOMEM;
  else {
    *pp = mem;
    return 0;
  }
d4313 1
a4313 1
  ensure_initialization();
d4320 1
a4320 1
  ensure_initialization();
a4324 29
void** dlindependent_calloc(size_t n_elements, size_t elem_size,
                            void* chunks[]) {
  size_t sz = elem_size; /* serves as 1-element array */
  return ialloc(gm, n_elements, &sz, 3, chunks);
}

void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
                              void* chunks[]) {
  return ialloc(gm, n_elements, sizes, 0, chunks);
}

size_t dlbulk_free(void* array[], size_t nelem) {
  return internal_bulk_free(gm, array, nelem);
}

#if MALLOC_INSPECT_ALL
void dlmalloc_inspect_all(void(*handler)(void *start,
                                         void *end,
                                         size_t used_bytes,
                                         void* callback_arg),
                          void* arg) {
  ensure_initialization();
  if (!PREACTION(gm)) {
    internal_inspect_all(gm, handler, arg);
    POSTACTION(gm);
  }
}
#endif /* MALLOC_INSPECT_ALL */

a4326 1
  ensure_initialization();
a4341 16
size_t dlmalloc_footprint_limit(void) {
  size_t maf = gm->footprint_limit;
  return maf == 0 ? MAX_SIZE_T : maf;
}

size_t dlmalloc_set_footprint_limit(size_t bytes) {
  size_t result;  /* invert sense of 0 */
  if (bytes == 0)
    result = granularity_align(1); /* Use minimal size */
  if (bytes == MAX_SIZE_T)
    result = 0;                    /* disable */
  else
    result = granularity_align(bytes);
  return gm->footprint_limit = result;
}

a4347 1
#if !NO_MALLOC_STATS
a4350 5
#endif /* NO_MALLOC_STATS */

int dlmallopt(int param_number, int value) {
  return change_mparam(param_number, value);
}
d4355 1
a4355 1
    if (is_inuse(p))
d4361 4
d4377 2
a4378 2
  (void)INITIAL_LOCK(&m->mutex);
  msp->head = (msize|INUSE_BITS);
a4381 1
  m->release_checks = MAX_RELEASE_CHECK_RATE;
a4382 2
  m->extp = 0;
  m->exts = 0;
d4393 3
a4395 3
  size_t msize;
  ensure_initialization();
  msize = pad_request(sizeof(struct malloc_state));
d4398 1
a4398 1
                 (capacity + TOP_FOOT_SIZE + msize));
d4403 1
a4403 1
      m->seg.sflags = USE_MMAP_BIT;
d4412 3
a4414 3
  size_t msize;
  ensure_initialization();
  msize = pad_request(sizeof(struct malloc_state));
a4423 17
int mspace_track_large_chunks(mspace msp, int enable) {
  int ret = 0;
  mstate ms = (mstate)msp;
  if (!PREACTION(ms)) {
    if (!use_mmap(ms)) {
      ret = 1;
    }
    if (!enable) {
      enable_mmap(ms);
    } else {
      disable_mmap(ms);
    }
    POSTACTION(ms);
  }
  return ret;
}

a4428 1
    (void)DESTROY_LOCK(&ms->mutex); /* destroy before unmapped */
a4432 1
      (void)base; /* placate people compiling -Wunused-variable */
d4434 3
a4436 3
      if ((flag & USE_MMAP_BIT) && !(flag & EXTERN_BIT) &&
          CALL_MUNMAP(base, size) == 0)
        freed += size;
d4450 1
d4468 10
a4477 10
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(ms, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(ms, b, p, idx);
        set_inuse_and_pinuse(ms, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4481 30
a4510 30
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(ms, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(ms, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(ms, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(ms, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }

        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }
d4518 2
a4519 2
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4527 4
a4530 4
        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
        ms->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
d4533 4
a4536 4
        size_t dvs = ms->dvsize;
        ms->dvsize = 0;
        ms->dv = 0;
        set_inuse_and_pinuse(ms, p, dvs);
a4569 1
    (void)msp; /* placate people compiling -Wunused */
d4579 68
a4646 77
      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if (is_mmapped(p)) {
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
d4667 1
a4667 1
        (req / n_elements != elem_size))
d4677 2
a4678 7
  void* mem = 0;
  if (oldmem == 0) {
    mem = mspace_malloc(msp, bytes);
  }
  else if (bytes >= MAX_REQUEST) {
    MALLOC_FAILURE_ACTION;
  }
d4680 1
a4680 1
  else if (bytes == 0) {
d4682 1
d4686 3
a4688 4
    size_t nb = request2size(bytes);
    mchunkptr oldp = mem2chunk(oldmem);
#if ! FOOTERS
    mstate m = (mstate)msp;
d4690 4
a4693 3
    mstate m = get_mstate_for(oldp);
    if (!ok_magic(m)) {
      USAGE_ERROR_ACTION(m, oldmem);
d4696 1
a4696 49
#endif /* FOOTERS */
    if (!PREACTION(m)) {
      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
      POSTACTION(m);
      if (newp != 0) {
        check_inuse_chunk(m, newp);
        mem = chunk2mem(newp);
      }
      else {
        mem = mspace_malloc(m, bytes);
        if (mem != 0) {
          size_t oc = chunksize(oldp) - overhead_for(oldp);
          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
          mspace_free(m, oldmem);
        }
      }
    }
  }
  return mem;
}

void* mspace_realloc_in_place(mspace msp, void* oldmem, size_t bytes) {
  void* mem = 0;
  if (oldmem != 0) {
    if (bytes >= MAX_REQUEST) {
      MALLOC_FAILURE_ACTION;
    }
    else {
      size_t nb = request2size(bytes);
      mchunkptr oldp = mem2chunk(oldmem);
#if ! FOOTERS
      mstate m = (mstate)msp;
#else /* FOOTERS */
      mstate m = get_mstate_for(oldp);
      (void)msp; /* placate people compiling -Wunused */
      if (!ok_magic(m)) {
        USAGE_ERROR_ACTION(m, oldmem);
        return 0;
      }
#endif /* FOOTERS */
      if (!PREACTION(m)) {
        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
        POSTACTION(m);
        if (newp == oldp) {
          check_inuse_chunk(m, newp);
          mem = oldmem;
        }
      }
    }
a4697 1
  return mem;
a4705 2
  if (alignment <= MALLOC_ALIGNMENT)
    return mspace_malloc(msp, bytes);
d4710 1
a4710 1
                                 size_t elem_size, void* chunks[]) {
d4721 1
a4721 1
                                   size_t sizes[], void* chunks[]) {
a4729 24
size_t mspace_bulk_free(mspace msp, void* array[], size_t nelem) {
  return internal_bulk_free((mstate)msp, array, nelem);
}

#if MALLOC_INSPECT_ALL
void mspace_inspect_all(mspace msp,
                        void(*handler)(void *start,
                                       void *end,
                                       size_t used_bytes,
                                       void* callback_arg),
                        void* arg) {
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    if (!PREACTION(ms)) {
      internal_inspect_all(ms, handler, arg);
      POSTACTION(ms);
    }
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
}
#endif /* MALLOC_INSPECT_ALL */

a4744 1
#if !NO_MALLOC_STATS
a4753 1
#endif /* NO_MALLOC_STATS */
d4756 1
a4756 1
  size_t result = 0;
d4761 1
a4761 3
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
d4765 1
d4767 1
a4767 1
  size_t result = 0;
d4772 1
a4772 3
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
a4775 30
size_t mspace_footprint_limit(mspace msp) {
  size_t result = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    size_t maf = ms->footprint_limit;
    result = (maf == 0) ? MAX_SIZE_T : maf;
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return result;
}

size_t mspace_set_footprint_limit(mspace msp, size_t bytes) {
  size_t result = 0;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    if (bytes == 0)
      result = granularity_align(1); /* Use minimal size */
    if (bytes == MAX_SIZE_T)
      result = 0;                    /* disable */
    else
      result = granularity_align(bytes);
    ms->footprint_limit = result;
  }
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
  return result;
}
a4786 9
size_t mspace_usable_size(const void* mem) {
  if (mem != 0) {
    mchunkptr p = mem2chunk(mem);
    if (is_inuse(p))
      return chunksize(p) - overhead_for(p);
  }
  return 0;
}

a4792 1

d4842 1
a4842 1
         size = MINIMUM_MORECORE_SIZE;
d4844 1
a4844 1
         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
d4847 1
a4847 1
        return (void *) MFAIL;
d4877 2
a4878 2
         PoolDeallocate(*ptr);
         *ptr = 0;
a4886 38
    v2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
      * fix bad comparison in dlposix_memalign
      * don't reuse adjusted asize in sys_alloc
      * add LOCK_AT_FORK -- thanks to Kirill Artamonov for the suggestion
      * reduce compiler warnings -- thanks to all who reported/suggested these

    v2.8.5 Sun May 22 10:26:02 2011  Doug Lea  (dl at gee)
      * Always perform unlink checks unless INSECURE
      * Add posix_memalign.
      * Improve realloc to expand in more cases; expose realloc_in_place.
        Thanks to Peter Buhr for the suggestion.
      * Add footprint_limit, inspect_all, bulk_free. Thanks
        to Barry Hayes and others for the suggestions.
      * Internal refactorings to avoid calls while holding locks
      * Use non-reentrant locks by default. Thanks to Roland McGrath
        for the suggestion.
      * Small fixes to mspace_destroy, reset_on_error.
      * Various configuration extensions/changes. Thanks
         to all who contributed these.

    V2.8.4a Thu Apr 28 14:39:43 2011 (dl at gee.cs.oswego.edu)
      * Update Creative Commons URL

    V2.8.4 Wed May 27 09:56:23 2009  Doug Lea  (dl at gee)
      * Use zeros instead of prev foot for is_mmapped
      * Add mspace_track_large_chunks; thanks to Jean Brouwers
      * Fix set_inuse in internal_realloc; thanks to Jean Brouwers
      * Fix insufficient sys_alloc padding when using 16byte alignment
      * Fix bad error check in mspace_footprint
      * Adaptations for ptmalloc; thanks to Wolfram Gloger.
      * Reentrant spin locks; thanks to Earl Chew and others
      * Win32 improvements; thanks to Niall Douglas and Earl Chew
      * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options
      * Extension hook in malloc_state
      * Various small adjustments to reduce warnings on some compilers
      * Various configuration extensions/changes for more platforms. Thanks
         to all who contributed these.

d4892 1
a4892 1
        in create_mspace_with_base
d4911 1
a4911 1
        removing need for emulation on most platforms without sbrk.
d4916 2
a4917 2
        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
        Aaron Bachmann,  Emery Berger, and others.
d4930 1
a4930 1
        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
d4941 1
a4941 1
        Thanks to Michael Pachos for motivation and help.
d4945 2
a4946 2
        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
        and Anonymous.
d4948 1
a4948 1
        helping test this.)
d4951 2
a4952 2
        leads to  more fragmentation in some programs and doesn't
        seem to help in any others.
d4960 1
a4960 1
        Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
d4966 11
a4976 11
         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
          (e.g. WIN32 platforms)
         * Cleanup header file inclusion for WIN32 platforms
         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
           memory allocation routines
         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
           usage of 'assert' in non-WIN32 code
         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
           avoid infinite loop
d4988 1
a4988 1
        foreign sbrks
d4994 1
a4994 1
        Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5002 1
a5002 1
        avoid surprises about sbrk alignment conventions.
d5004 1
a5004 1
        (raymond@@es.ele.tue.nl) for the suggestion.
d5007 1
a5007 1
        courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5009 1
a5009 1
        H.J. Lu (hjl@@gnu.ai.mit.edu)
d5015 2
a5016 2
        the work required to undo bad preallocations exceeds
        the work saved in good cases for most test programs.
d5018 2
a5019 2
        no scheme using them consistently outperforms those that don't
        given above changes.
d5025 1
a5025 1
        Paul Wilson (wilson@@cs.texas.edu) for the suggestion.
d5029 1
a5029 1
        (wmglo@@Dent.MED.Uni-Muenchen.DE).
d5045 1
a5045 1
         (eliminating old malloc_find_space & malloc_clean_bin)
d5049 1
a5049 1
          from kpv@@research.att.com
d5057 2
a5058 2
          with gcc & native cc (hp, dec only) allowing
          Detlefs & Zorn comparison study (in SIGPLAN Notices.)
d5062 1
a5062 1
         structure of old version,  but most details differ.)
@


1.11.18.1
log
@	* configure.ac (MALLOC_OFILES): Add ptmalloc3.o.
	* configure: Regenerate.
	* cygmalloc.h: Declare pt* functions rather than dl* functions.
	(mmap64): Declare.
	(mmap): Define as mmap64.
	(__malloc_lock): Drop macro.
	(__malloc_unlock): Ditto.
	(MSPACES): Define.
	(ONLY_MSPACES): Define.
	* debug.h: Include malloc.h rather than otherwise unused dlmalloc.h.
	* fork.cc (frok::parent): Drop malloc locking since that's performed
	by malloc_atfork now.
	* heap.cc (heap_init): Accommodate the fact that there's a chance
	that no heap space has been allocated at fork time.
	* malloc-private.h: New file from ptmalloc3, having malloc-machine.h
	and malloc-2.8.3.h folded in.
	* malloc.cc: Replaced by new file from ptmalloc3.
	* malloc_wrapper.cc: Throughout, remove malloc locks and call pt*
	functions rather than dl* functions.
	* pinfo.cc (winpids::set): Drop malloc locking.
	* ptmalloc3.cc: New file from ptmalloc3.
@
text
@a1 10
  $Id: malloc.c,v 1.4 2006/03/30 16:47:29 wg Exp $

  This version of malloc.c was adapted for ptmalloc3 by Wolfram Gloger
  <wg@@malloc.de>.  Therefore, some of the comments below do not apply
  for this modified version.  However, it is the intention to keep
  differences to Doug Lea's original version minimal, hence the
  comments were mostly left unchanged.

 -----------------------------------------------------------------------

d7 1
a7 1
* Version pre-2.8.4 Wed Mar 29 19:46:29 2006    (dl at gee)
d10 2
a11 2
           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
         Check before installing!
d50 1
a50 1
                                          8 or 16 bytes (if 8byte sizes)
d56 1
a56 1
                          8-byte ptrs:  32 bytes    (including overhead)
d114 2
a115 4
       program, consider instead using nedmalloc
       (http://www.nedprod.com/programs/portable/nedmalloc/) or
       ptmalloc (See http://www.malloc.de), which are derived
       from versions of this malloc.
d156 1
a156 5
  system allocation routines, which is often just 1. In real-time
  applications, you can optionally suppress segment traversals using
  NO_SEGMENT_TRAVERSAL, which assures bounded execution even when
  system allocators return non-contiguous spaces, at the typical
  expense of carrying around more memory and increased fragmentation.
d206 1
a206 2
to size_t precision unless they are explicitly casted. You can also
use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.
d229 1
a229 8
  overridden on a per-mspace basis for mspace versions.) If set to a
  non-zero value other than 1, locks are used, but their
  implementation is left out, so lock functions must be supplied manually.

USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and on x86 using gcc or MSC
  If true, uses custom spin locks for locking. This is currently
  supported only for x86 platforms using gcc or recent MS compilers.
  Otherwise, posix locks or win32 critical sections are used.
d304 1
a304 1
MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
a317 6
NO_SEGMENT_TRAVERSAL       default: 0
  If non-zero, suppresses traversals of memory segments
  returned by either MORECORE or CALL_MMAP. This disables
  merging of segments that are contiguous, and selectively
  releasing them to the OS if unused, but bounds execution times.

d332 1
a332 1
MMAP_CLEARS               default: 1 except on WINCE.
d334 1
a334 1
  for standard unix mmap using /dev/zero and on WIN32 except for WINCE.
d341 2
a342 2
  this setting has no effect. Similarly for Win32 under recent MS compilers.
  (On most x86s, the asm version is only slightly faster than the C version.)
d378 2
a379 2
                                system_info.dwAllocationGranularity in WIN32,
                                otherwise 64K.
a438 13
MAX_RELEASE_CHECK_RATE   default: 255 unless not HAVE_MMAP
  The number of consolidated frees between checks to release
  unused segments when freeing. When using non-contiguous segments,
  especially with multiple mspaces, checking only for topmost space
  doesn't always suffice to trigger trimming. To compensate for this,
  free() will, with a period of MAX_RELEASE_CHECK_RATE (or the
  current number of segments, if greater) try to release unused
  segments to the OS when freeing chunks that result in
  consolidation. The best value for this parameter is a compromise
  between slowing down frees with relatively costly checks that
  rarely trigger versus holding on to unused memory. To effectively
  disable, set to MAX_SIZE_T. This may lead to a very slight speed
  improvement at the expense of carrying around more memory.
d459 1
a459 5
#ifdef _WIN32_WCE /* WINCE reportedly does not clear */
#define MMAP_CLEARS 0
#else
#define MMAP_CLEARS 1
#endif /* _WIN32_WCE */
a507 7
#ifndef USE_SPIN_LOCKS
#if USE_LOCKS && (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))) || (defined(_MSC_VER) && _MSC_VER>=1310)
#define USE_SPIN_LOCKS 1
#else
#define USE_SPIN_LOCKS 0
#endif /* USE_LOCKS && ... */
#endif /* USE_SPIN_LOCKS */
a564 7
#ifndef MAX_RELEASE_CHECK_RATE
#if HAVE_MMAP
#define MAX_RELEASE_CHECK_RATE 255
#else
#define MAX_RELEASE_CHECK_RATE MAX_SIZE_T
#endif /* HAVE_MMAP */
#endif /* MAX_RELEASE_CHECK_RATE */
a576 3
#ifndef NO_SEGMENT_TRAVERSAL
#define NO_SEGMENT_TRAVERSAL 0
#endif /* NO_SEGMENT_TRAVERSAL */
a635 22
/*
  Try to persuade compilers to inline. The most critical functions for
  inlining are defined as macros, so these aren't used for them.
*/

#ifndef FORCEINLINE
  #if defined(__GNUC__)
#define FORCEINLINE __inline __attribute__ ((always_inline))
  #elif defined(_MSC_VER)
    #define FORCEINLINE __forceinline
  #endif
#endif
#ifndef NOINLINE
  #if defined(__GNUC__)
    #define NOINLINE __attribute__ ((noinline))
  #elif defined(_MSC_VER)
    #define NOINLINE __declspec(noinline)
  #else
    #define NOINLINE
  #endif
#endif

a637 3
#ifndef FORCEINLINE
 #define FORCEINLINE inline
#endif
a638 3
#ifndef FORCEINLINE
 #define FORCEINLINE
#endif
d797 1
a797 1
                than current total if trimming has occurred.
d802 2
a803 2
               back to system via malloc_trim. ("ideally" means that
               it ignores page restrictions etc.)
d1081 1
a1081 1
                                 size_t elem_size, void* chunks[]);
d1088 1
a1088 1
                                   size_t sizes[], void* chunks[]);
a1195 45
/* Declarations for locking */
#if USE_LOCKS
#ifndef WIN32
#include <pthread.h>
#if defined (__SVR4) && defined (__sun)  /* solaris */
#include <thread.h>
#endif /* solaris */
#else
#ifndef _M_AMD64
/* These are already defined on AMD64 builds */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
LONG __cdecl _InterlockedCompareExchange(LPLONG volatile Dest, LONG Exchange, LONG Comp);
LONG __cdecl _InterlockedExchange(LPLONG volatile Target, LONG Value);
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* _M_AMD64 */
#pragma intrinsic (_InterlockedCompareExchange)
#pragma intrinsic (_InterlockedExchange)
#define interlockedcompareexchange _InterlockedCompareExchange
#define interlockedexchange _InterlockedExchange
#endif /* Win32 */
#endif /* USE_LOCKS */

/* Declarations for bit scanning on win32 */
#if defined(_MSC_VER) && _MSC_VER>=1300
#ifndef BitScanForward	/* Try to avoid pulling in WinNT.h */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
unsigned char _BitScanForward(unsigned long *index, unsigned long mask);
unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#endif /* BitScanForward */
#endif /* defined(_MSC_VER) && _MSC_VER>=1300 */

a1242 2


d1250 1
a1250 1
/* Annoying but necessary to avoid errors on some platforms */
a1253 1
#define SIZE_T_FOUR         ((size_t)4)
d1311 3
a1313 3
           (dev_zero_fd = open("/dev/zero", O_RDWR), \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
d1320 1
a1320 1
static FORCEINLINE void* win32mmap(size_t size) {
d1326 1
a1326 1
static FORCEINLINE void* win32direct_mmap(size_t size) {
d1328 1
a1328 1
                           PAGE_READWRITE);
d1333 1
a1333 1
static FORCEINLINE int win32munmap(void* ptr, size_t size) {
d1335 1
a1335 1
  char* cptr = (char*)ptr;
d1340 1
a1340 1
        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
d1359 1
a1359 2
#define CALL_MREMAP(addr, osz, nsz, mv) ((void)(addr),(void)(osz), \
                                         (void)(nsz), (void)(mv),MFAIL)
d1377 2
a1390 12

   To enable use in layered extensions, locks are reentrant.

   Because lock-protected regions generally have bounded times, we use
   the supplied simple spinlocks in the custom versions for x86.

   If USE_LOCKS is > 1, the definitions of lock routines here are
   bypassed, in which case you will need to define at least
   INITIAL_LOCK, ACQUIRE_LOCK, RELEASE_LOCK, and
   NULL_LOCK_INITIALIZER, and possibly TRY_LOCK and IS_LOCKED
   (The latter two are not used in this malloc, but are
   commonly needed in extensions.)
a1392 3
#if USE_LOCKS == 1

#if USE_SPIN_LOCKS
d1394 6
a1399 49
/* Custom pthread-style spin locks on x86 and x64 for gcc */
struct pthread_mlock_t
{
  volatile pthread_t threadid;
  volatile unsigned int c;
  volatile unsigned int l;
};
#define MLOCK_T struct pthread_mlock_t
#define CURRENT_THREAD        pthread_self()
#define SPINS_PER_YIELD       63
static FORCEINLINE int pthread_acquire_lock (MLOCK_T *sl) {
  if(CURRENT_THREAD==sl->threadid)
    ++sl->c;
  else {
    int spins = 0;
    for (;;) {
      int ret;
      __asm__ __volatile__ ("lock cmpxchgl %2,(%1)" : "=a" (ret) : "r" (&sl->l), "r" (1), "a" (0));
      if(!ret) {
        assert(!sl->threadid);
        sl->threadid=CURRENT_THREAD;
        sl->c=1;
        break;
      }
      if ((++spins & SPINS_PER_YIELD) == 0) {
#if defined (__SVR4) && defined (__sun) /* solaris */
        thr_yield();
#else
#ifdef linux
        sched_yield();
#else  /* no-op yield on unknown systems */
        ;
#endif /* linux */
#endif /* solaris */
      }
    }
  }

  return 0;
}

static FORCEINLINE void pthread_release_lock (MLOCK_T *sl) {
  int ret;
  assert(CURRENT_THREAD==sl->threadid);
  if (!--sl->c) {
    sl->threadid=0;
    __asm__ __volatile__ ("xchgl %2,(%1)" : "=r" (ret) : "r" (&sl->l), "0" (0));
  }
}
a1400 19
static FORCEINLINE int pthread_try_lock (MLOCK_T *sl) {
  int ret;
  __asm__ __volatile__ ("lock cmpxchgl %2,(%1)" : "=a" (ret) : "r" (&sl->l), "r" (1), "a" (0));
  if(!ret){
    assert(!sl->threadid);
    sl->threadid=CURRENT_THREAD;
    sl->c=1;
    return 1;
  }
  return 0;
}

#define INITIAL_LOCK(sl)      (memset((sl), 0, sizeof(MLOCK_T)), 0)
#define ACQUIRE_LOCK(sl)      pthread_acquire_lock(sl)
#define RELEASE_LOCK(sl)      pthread_release_lock(sl)
#define TRY_LOCK(sl)          pthread_try_lock(sl)
#define IS_LOCKED(sl)         ((sl)->l)

static MLOCK_T magic_init_mutex = {0, 0, 0 };
d1402 1
a1402 1
static MLOCK_T morecore_mutex = {0, 0, 0 };
d1405 2
d1408 4
a1411 29
/* Custom win32-style spin locks on x86 and x64 for MSC */
struct win32_mlock_t
{
  volatile long threadid;
  volatile unsigned int c;
  long l;
};
#define MLOCK_T struct win32_mlock_t
#define CURRENT_THREAD        GetCurrentThreadId()
#define SPINS_PER_YIELD    63
static FORCEINLINE int win32_acquire_lock (MLOCK_T *sl) {
  long mythreadid=CURRENT_THREAD;
  if(mythreadid==sl->threadid)
    ++sl->c;
  else {
    int spins = 0;
    for (;;) {
      if (!interlockedexchange(&sl->l, 1)) {
        assert(!sl->threadid);
        sl->threadid=mythreadid;
        sl->c=1;
        break;
      }
      if ((++spins & SPINS_PER_YIELD) == 0)
        SleepEx(0, FALSE);
    }
  }
  return 0;
}
d1413 11
a1423 5
static FORCEINLINE void win32_release_lock (MLOCK_T *sl) {
  assert(CURRENT_THREAD==sl->threadid);
  if (!--sl->c) {
    sl->threadid=0;
    interlockedexchange (&sl->l, 0);
d1427 2
a1428 8
static FORCEINLINE int win32_try_lock (MLOCK_T *sl) {
  if (!interlockedexchange(&sl->l, 1)){
    assert(!sl->threadid);
    sl->threadid=CURRENT_THREAD;
    sl->c=1;
    return 1;
  }
  return 0;
d1431 3
a1433 7
#define INITIAL_LOCK(sl)      (memset(sl, 0, sizeof(MLOCK_T)), 0)
#define ACQUIRE_LOCK(sl)      win32_acquire_lock(sl)
#define RELEASE_LOCK(sl)      win32_release_lock(sl)
#define TRY_LOCK(sl)          win32_try_lock(sl)
#define IS_LOCKED(sl)         ((sl)->l)

static MLOCK_T magic_init_mutex = {0, 0 };
d1435 1
a1435 1
static MLOCK_T morecore_mutex = {0, 0 };
a1436 74

#endif /* WIN32 */
#else /* USE_SPIN_LOCKS */

#ifndef WIN32
/* pthreads-based locks */
struct pthread_mlock_t
{
  volatile unsigned int c;
  pthread_mutex_t l;
};
#define MLOCK_T struct pthread_mlock_t
#define CURRENT_THREAD        pthread_self()
static FORCEINLINE int pthread_acquire_lock (MLOCK_T *sl) {
  if(!pthread_mutex_lock(&(sl)->l)){
    sl->c++;
    return 0;
  }
  return 1;
}

static FORCEINLINE void pthread_release_lock (MLOCK_T *sl) {
  --sl->c;
  pthread_mutex_unlock(&(sl)->l);
}

static FORCEINLINE int pthread_try_lock (MLOCK_T *sl) {
  if(!pthread_mutex_trylock(&(sl)->l)){
    sl->c++;
    return 1;
  }
  return 0;
}

static FORCEINLINE int pthread_init_lock (MLOCK_T *sl) {
  pthread_mutexattr_t attr;
  sl->c=0;
  if(pthread_mutexattr_init(&attr)) return 1;
  if(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;
  if(pthread_mutex_init(&sl->l, &attr)) return 1;
  pthread_mutexattr_destroy(&attr);
  return 0;
}

static FORCEINLINE int pthread_islocked (MLOCK_T *sl) {
  if(!pthread_try_lock(sl)){
    int ret = (sl->c != 0);
    pthread_mutex_unlock(sl);
    return ret;
  }
  return 0;
}

#define INITIAL_LOCK(sl)      pthread_init_lock(sl)
#define ACQUIRE_LOCK(sl)      pthread_acquire_lock(sl)
#define RELEASE_LOCK(sl)      pthread_release_lock(sl)
#define TRY_LOCK(sl)          pthread_try_lock(sl)
#define IS_LOCKED(sl)         pthread_islocked(sl)

static MLOCK_T magic_init_mutex = {0, PTHREAD_MUTEX_INITIALIZER };
#if HAVE_MORECORE
static MLOCK_T morecore_mutex = {0, PTHREAD_MUTEX_INITIALIZER };
#endif /* HAVE_MORECORE */

#else /* WIN32 */
/* Win32 critical sections */
#define MLOCK_T         CRITICAL_SECTION
#define CURRENT_THREAD  GetCurrentThreadId()
#define INITIAL_LOCK(s) (!InitializeCriticalSectionAndSpinCount((s), 4000)
#define ACQUIRE_LOCK(s) ( (!((s))->DebugInfo ? INITIAL_LOCK((s)) : 0), !EnterCriticalSection((s)), 0)
#define RELEASE_LOCK(s) ( LeaveCriticalSection((s)), 0 )
#define TRY_LOCK(s)     ( TryEnterCriticalSection((s)) )
#define IS_LOCKED(s)    ( (s)->LockCount >= 0 )
#define NULL_LOCK_INITIALIZER
a1437 3
#if HAVE_MORECORE
static MLOCK_T morecore_mutex;
#endif /* HAVE_MORECORE */
a1438 19
#endif /* USE_SPIN_LOCKS */
#endif /* USE_LOCKS == 1 */

/* -----------------------  User-defined locks ------------------------ */

#if USE_LOCKS > 1
/* Define your own lock implementation here */
/* #define INITIAL_LOCK(sl)  ... */
/* #define ACQUIRE_LOCK(sl)  ... */
/* #define RELEASE_LOCK(sl)  ... */
/* #define TRY_LOCK(sl) ... */
/* #define IS_LOCKED(sl) ... */
/* #define NULL_LOCK_INITIALIZER ... */

static MLOCK_T magic_init_mutex = NULL_LOCK_INITIALIZER;
#if HAVE_MORECORE
static MLOCK_T morecore_mutex = NULL_LOCK_INITIALIZER;
#endif /* HAVE_MORECORE */
#endif /* USE_LOCKS > 1 */
a1439 4
/* -----------------------  Lock-based state ------------------------ */


#if USE_LOCKS
d1488 4
a1491 4
           | Size of previous chunk (if P = 1)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
d1493 7
a1499 7
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
d1501 2
a1502 2
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1510 4
a1513 4
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
d1515 7
a1521 7
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
d1523 2
a1524 2
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1532 2
a1533 2
                                                                     |0|
                                                                     +-+
d1578 10
a1587 10
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.
d1590 7
a1596 7
        (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
        PINUSE_BIT in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.
a1659 2

  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
a1663 1
#define FLAG4_BIT           (SIZE_T_FOUR)
a1664 1
#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)
d1672 1
a1672 1
#define chunksize(p)        ((p)->head & ~(FLAG_BITS))
d1682 1
a1682 1
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
d1724 2
a1725 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1728 7
a1734 7
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
d1737 1
a1737 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1745 2
a1746 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1749 14
a1762 14
            |             Forward pointer to next chunk of same size        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk of same size       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to left child (child[0])                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to right child (child[1])                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to parent                                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             bin index of this chunk                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space                                      .
            .                                                               |
d1765 1
a1765 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
a1963 5
  Trim support
    Fields holding the amount of unused topmost memory that should trigger
    timming, and a counter to force periodic scanning to release unused
    non-topmost segments.

a1966 4

  Extension support
    A void* pointer and a size_t field that can be used to help implement
    extensions to this malloc.
a1987 1
  size_t     release_checks;
a1997 2
  void*      extp;      /* Unused but available for extensions */
  size_t     exts;
a2020 2
#if !ONLY_MSPACES

a2024 3

#endif /* !ONLY_MSPACES */

d2049 1
a2049 1
 (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
d2053 1
a2053 10
  (((S) + (mparams.granularity - SIZE_T_ONE))\
   & ~(mparams.granularity - SIZE_T_ONE))


/* For mmap, use granularity alignment on windows, else page-align */
#ifdef WIN32
#define mmap_align(S) granularity_align(S)
#else
#define mmap_align(S) page_align(S)
#endif
d2204 1
a2204 16
#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define compute_tree_index(S, I)\
{\
  unsigned int X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int K;\
    __asm__("bsrl\t%1, %0\n\t" : "=r" (K) : "g"  (X));\
    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
  }\
}

#elif defined(_MSC_VER) && _MSC_VER>=1300
d2214 1
a2214 1
    _BitScanReverse((DWORD *) &K, X);\
d2269 1
a2269 1
#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
d2273 1
a2273 8
  __asm__("bsfl\t%1, %0\n\t" : "=r" (J) : "g" (X));\
  I = (bindex_t)J;\
}
#elif defined(_MSC_VER) && _MSC_VER>=1300
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  _BitScanForward((DWORD *) &J, X);\
d2438 3
a2440 3
          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
        s = *((size_t *) buf);
        close(fd);
d2444 1
a2444 1
        s = (size_t)(time(0) ^ (size_t)0x55555555U);
a2455 1
#if !ONLY_MSPACES
a2458 1
#endif
d2465 1
a2465 1
                           DEFAULT_GRANULARITY : mparams.page_size);
d2482 7
a2488 7
        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
        (sizeof(int) < 4)  ||
        (MALLOC_ALIGNMENT < (size_t)8U) ||
        ((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
        ((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
        ((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||
        ((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))
d2529 1
a2529 1
  size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */
d2537 1
a2537 1
  assert(!pinuse(chunk_plus_offset(p, sz)));
d2567 1
a2567 1
  size_t sz = chunksize(p);
d2632 2
a2633 2
              u->parent->child[1] == u ||
              *((tbinptr*)(u->parent)) == u);
d2635 3
a2637 3
        assert(u->child[0]->parent == u);
        assert(u->child[0] != u);
        do_check_tree(m, u->child[0]);
d2640 3
a2642 3
        assert(u->child[1]->parent == u);
        assert(u->child[1] != u);
        do_check_tree(m, u->child[1]);
d2645 1
a2645 1
        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
d2683 1
a2683 1
        do_check_inuse_chunk(m, q);
d2697 2
a2698 2
        if (p == x)
          return 1;
d2709 2
a2710 2
        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
        sizebits <<= 1;
d2713 5
a2717 5
        tchunkptr u = t;
        do {
          if (u == (tchunkptr)x)
            return 1;
        } while ((u = u->fd) != t);
d2735 13
a2747 13
             q != m->top && q->head != FENCEPOST_HEAD) {
        sum += chunksize(q);
        if (cinuse(q)) {
          assert(!bin_find(m, q));
          do_check_inuse_chunk(m, q);
        }
        else {
          assert(q == m->dv || bin_find(m, q));
          assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */
          do_check_free_chunk(m, q);
        }
        lastq = q;
        q = next_chunk(q);
d2774 1
a2774 1
    /*assert(m->topsize == chunksize(m->top)); redundant */
d2798 12
a2809 12
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          size_t sz = chunksize(q);
          sum += sz;
          if (!cinuse(q)) {
            mfree += sz;
            ++nfree;
          }
          q = next_chunk(q);
        }
        s = s->next;
d2840 8
a2847 8
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          if (!cinuse(q))
            used -= chunksize(q);
          q = next_chunk(q);
        }
        s = s->next;
d2898 1
a2898 1
                   (B == smallbin_at(M,I) || ok_address(M, B)))) {\
d2958 14
a2971 14
        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
        K <<= 1;\
        if (*C != 0)\
          T = *C;\
        else if (RTCHECK(ok_address(M, C))) {\
          *C = X;\
          X->parent = T;\
          X->fd = X->bk = X;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d2974 12
a2985 12
        tchunkptr F = T->fd;\
        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
          T->fd = F->bk = X;\
          X->fd = F;\
          X->bk = T;\
          X->parent = 0;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d3025 1
a3025 1
        ((R = *(RP = &(X->child[0]))) != 0)) {\
d3028 2
a3029 2
             (*(CP = &(R->child[0])) != 0)) {\
        R = *(RP = CP);\
d3032 1
a3032 1
        *RP = 0;\
d3034 1
a3034 1
        CORRUPTION_ERROR_ACTION(M);\
d3042 1
a3042 1
        clear_treemap(M, X->index);\
d3046 1
a3046 1
        XP->child[0] = R;\
d3048 1
a3048 1
        XP->child[1] = R;\
d3054 18
a3071 18
        tchunkptr C0, C1;\
        R->parent = XP;\
        if ((C0 = X->child[0]) != 0) {\
          if (RTCHECK(ok_address(M, C0))) {\
            R->child[0] = C0;\
            C0->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
        if ((C1 = X->child[1]) != 0) {\
          if (RTCHECK(ok_address(M, C1))) {\
            R->child[1] = C1;\
            C1->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
d3074 1
a3074 1
        CORRUPTION_ERROR_ACTION(M);\
d3098 1
a3098 1
   ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
d3121 1
a3121 1
  size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3135 1
a3135 1
        m->least_addr = mm;
d3137 1
a3137 1
        m->max_footprint = m->footprint;
d3158 2
a3159 1
    size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3161 1
a3161 1
                                  oldmmsize, newmmsize, 1);
d3171 1
a3171 1
        m->least_addr = cp;
d3173 1
a3173 1
        m->max_footprint = m->footprint;
d3229 1
a3229 1
                           size_t nb) {
d3269 1
d3366 10
a3375 10
        asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
        /* Adjust to end on a page boundary */
        if (!is_page_aligned(base))
          asize += (page_align((size_t)base) - (size_t)base);
        /* Can't call MORECORE if size is negative when treated as signed */
        if (asize < HALF_MAX_SIZE_T &&
            (br = (char*)(CALL_MORECORE(asize))) == base) {
          tbase = base;
          tsize = asize;
        }
d3383 3
a3385 3
          (br = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
        tbase = br;
        tsize = asize;
d3391 13
a3403 13
        if (asize < HALF_MAX_SIZE_T &&
            asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
          size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
          if (esize < HALF_MAX_SIZE_T) {
            char* end = (char*)CALL_MORECORE(esize);
            if (end != CMFAIL)
              asize += esize;
            else {            /* Can't use; try to release */
              (void) CALL_MORECORE(-asize);
              br = CMFAIL;
            }
          }
        }
d3406 2
a3407 2
        tbase = br;
        tsize = asize;
d3410 1
a3410 1
        disable_contiguous(m); /* Don't try contiguous path in the future */
d3422 3
a3424 3
        tbase = mp;
        tsize = rsize;
        mmap_flag = IS_MMAPPED_BIT;
d3439 5
a3443 5
        size_t ssize = end - br;
        if (ssize > nb + TOP_FOOT_SIZE) {
          tbase = br;
          tsize = ssize;
        }
a3457 1
      m->release_checks = MAX_RELEASE_CHECK_RATE;
a3458 1
#if !ONLY_MSPACES
d3460 5
a3464 7
        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
      else
#endif
      {
        /* Offset top by embedded malloc_state */
        mchunkptr mn = next_chunk(mem2chunk(m));
        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
a3470 1
      /* Only consider most recent segment if traversal suppressed */
d3472 1
a3472 1
        sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
d3474 5
a3478 5
          !is_extern_segment(sp) &&
          (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&
          segment_holds(sp, m->top)) { /* append */
        sp->size += tsize;
        init_top(m, m->top, m->topsize + tsize);
d3481 15
a3495 15
        if (tbase < m->least_addr)
          m->least_addr = tbase;
        sp = &m->seg;
        while (sp != 0 && sp->base != tbase + tsize)
          sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
        if (sp != 0 &&
            !is_extern_segment(sp) &&
            (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
          char* oldbase = sp->base;
          sp->base = tbase;
          sp->size += tsize;
          return prepend_alloc(m, tbase, oldbase, nb);
        }
        else
          add_segment(m, tbase, tsize, mmap_flag);
a3519 1
  int nsegs = 0;
a3525 1
    ++nsegs;
d3531 19
a3549 19
        tchunkptr tp = (tchunkptr)p;
        assert(segment_holds(sp, (char*)sp));
        if (p == m->dv) {
          m->dv = 0;
          m->dvsize = 0;
        }
        else {
          unlink_large_chunk(m, tp);
        }
        if (CALL_MUNMAP(base, size) == 0) {
          released += size;
          m->footprint -= size;
          /* unlink obsoleted record */
          sp = pred;
          sp->next = next;
        }
        else { /* back out if cannot unmap */
          insert_large_chunk(m, tp, psize);
        }
a3551 2
    if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */
      break;
a3554 3
  /* Reset check counter */
  m->release_checks = ((nsegs > MAX_RELEASE_CHECK_RATE)?
                       nsegs : MAX_RELEASE_CHECK_RATE);
d3567 1
a3567 1
                      SIZE_T_ONE) * unit;
d3571 28
a3598 28
        if (is_mmapped_segment(sp)) {
          if (HAVE_MMAP &&
              sp->size >= extra &&
              !has_segment_link(m, sp)) { /* can't shrink if pinned */
            size_t newsize = sp->size - extra;
            /* Prefer mremap, fall back to munmap */
            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
              released = extra;
            }
          }
        }
        else if (HAVE_MORECORE) {
          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
          ACQUIRE_MORECORE_LOCK();
          {
            /* Make sure end of memory is where we last set it. */
            char* old_br = (char*)(CALL_MORECORE(0));
            if (old_br == sp->base + sp->size) {
              char* rel_br = (char*)(CALL_MORECORE(-extra));
              char* new_br = (char*)(CALL_MORECORE(0));
              if (rel_br != CMFAIL && new_br < old_br)
                released = old_br - new_br;
            }
          }
          RELEASE_MORECORE_LOCK();
        }
d3602 4
a3605 4
        sp->size -= released;
        m->footprint -= released;
        init_top(m, m->top, m->topsize - released);
        check_top_chunk(m, m->top);
d3614 1
a3614 1
    if (released == 0 && m->topsize > m->trim_check)
d3639 3
a3641 3
        v = t;
        if ((rsize = trem) == 0)
          break;
d3646 1
a3646 1
        rst = rt;
d3648 2
a3649 2
        t = rst; /* set t to least subtree holding sizes > nb */
        break;
d3680 9
a3688 9
        unlink_large_chunk(m, v);
        if (rsize < MIN_CHUNK_SIZE)
          set_inuse_and_pinuse(m, v, (rsize + nb));
        else {
          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
          set_size_and_pinuse_of_free_chunk(r, rsize);
          insert_chunk(m, r, rsize);
        }
        return chunk2mem(v);
d3721 1
a3721 1
        set_inuse_and_pinuse(m, v, (rsize + nb));
d3723 3
a3725 3
        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
        set_size_and_pinuse_of_free_chunk(r, rsize);
        replace_dv(m, r, rsize);
d3752 1
a3752 1
                ok_next(oldp, next) && ok_pinuse(next))) {
d3755 1
a3755 1
        newp = mmap_resize(m, oldp, nb);
d3757 8
a3764 8
        size_t rsize = oldsize - nb;
        newp = oldp;
        if (rsize >= MIN_CHUNK_SIZE) {
          mchunkptr remainder = chunk_plus_offset(newp, nb);
          set_inuse(m, newp, nb);
          set_inuse(m, remainder, rsize);
          extra = chunk2mem(remainder);
        }
d3767 9
a3775 9
        /* Expand into top */
        size_t newsize = oldsize + m->topsize;
        size_t newtopsize = newsize - nb;
        mchunkptr newtop = chunk_plus_offset(oldp, nb);
        set_inuse(m, oldp, nb);
        newtop->head = newtopsize |PINUSE_BIT;
        m->top = newtop;
        m->topsize = newtopsize;
        newp = oldp;
d3788 1
a3788 1
        internal_free(m, extra);
d3796 3
a3798 3
        size_t oc = oldsize - overhead_for(oldp);
        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);
        internal_free(m, oldmem);
d3835 28
a3862 28
        /*
          Find an aligned spot inside chunk.  Since we need to give
          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
          the first calculation places us at a spot with less than
          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
          We've allocated enough total room so that this is always
          possible.
        */
        char* br = (char*)mem2chunk((size_t)(((size_t)(mem +
                                                       alignment -
                                                       SIZE_T_ONE)) &
                                             -alignment));
        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
          br : br+alignment;
        mchunkptr newp = (mchunkptr)pos;
        size_t leadsize = pos - (char*)(p);
        size_t newsize = chunksize(p) - leadsize;

        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
          newp->prev_foot = p->prev_foot + leadsize;
          newp->head = (newsize|CINUSE_BIT);
        }
        else { /* Otherwise, give back leader, use the rest */
          set_inuse(m, newp, newsize);
          set_inuse(m, p, leadsize);
          leader = chunk2mem(p);
        }
        p = newp;
d3867 8
a3874 8
        size_t size = chunksize(p);
        if (size > nb + MIN_CHUNK_SIZE) {
          size_t remainder_size = size - nb;
          mchunkptr remainder = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
          set_inuse(m, remainder, remainder_size);
          trailer = chunk2mem(remainder);
        }
d3882 1
a3882 1
        internal_free(m, leader);
d3885 1
a3885 1
        internal_free(m, trailer);
d3896 4
a3899 4
                     size_t n_elements,
                     size_t* sizes,
                     int opts,
                     void* chunks[]) {
d3988 1
a3988 1
        size = element_size;
d3990 1
a3990 1
        size = request2size(sizes[i]);
d4031 2
a4032 2
          (Remainderless means that there are too few excess bytes to
          represent as a chunk.)
d4034 1
a4034 1
          chunk adjacent to the one used for the most recent small request.
d4036 1
a4036 1
          saving remainder in dv.
d4041 1
a4041 1
          if it is better fitting than dv chunk, splitting if necessary.
d4061 10
a4070 10
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(gm, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(gm, b, p, idx);
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
d4074 30
a4103 30
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(gm, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(gm, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(gm, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(gm, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }

        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }
d4111 2
a4112 2
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
d4120 4
a4123 4
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
        gm->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
d4126 4
a4129 4
        size_t dvs = gm->dvsize;
        gm->dvsize = 0;
        gm->dv = 0;
        set_inuse_and_pinuse(gm, p, dvs);
d4179 67
a4245 77
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if ((prevsize & IS_MMAPPED_BIT) != 0) {
            prevsize &= ~IS_MMAPPED_BIT;
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
d4264 1
a4264 1
        (req / n_elements != elem_size))
d4301 1
a4301 1
                                 void* chunks[]) {
d4307 1
a4307 1
                                   void* chunks[]) {
a4381 1
  m->release_checks = MAX_RELEASE_CHECK_RATE;
a4382 2
  m->extp = 0;
  m->exts = 0;
d4398 1
a4398 1
                 (capacity + TOP_FOOT_SIZE + msize));
d4435 2
a4436 2
          CALL_MUNMAP(base, size) == 0)
        freed += size;
d4468 10
a4477 10
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(ms, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(ms, b, p, idx);
        set_inuse_and_pinuse(ms, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4481 30
a4510 30
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(ms, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(ms, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(ms, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(ms, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }

        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }
d4518 2
a4519 2
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4527 4
a4530 4
        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
        ms->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
d4533 4
a4536 4
        size_t dvs = ms->dvsize;
        ms->dvsize = 0;
        ms->dv = 0;
        set_inuse_and_pinuse(ms, p, dvs);
d4580 67
a4646 77
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if ((prevsize & IS_MMAPPED_BIT) != 0) {
            prevsize &= ~IS_MMAPPED_BIT;
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
d4667 1
a4667 1
        (req / n_elements != elem_size))
d4710 1
a4710 1
                                 size_t elem_size, void* chunks[]) {
d4721 1
a4721 1
                                   size_t sizes[], void* chunks[]) {
d4756 1
a4756 1
  size_t result = 0;
d4761 1
a4761 3
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
d4767 1
a4767 1
  size_t result = 0;
d4772 1
a4772 3
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
a4786 9
size_t mspace_usable_size(void* mem) {
  if (mem != 0) {
    mchunkptr p = mem2chunk(mem);
    if (cinuse(p))
      return chunksize(p) - overhead_for(p);
  }
  return 0;
}

d4842 1
a4842 1
         size = MINIMUM_MORECORE_SIZE;
d4844 1
a4844 1
         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
d4847 1
a4847 1
        return (void *) MFAIL;
d4877 2
a4878 2
         PoolDeallocate(*ptr);
         *ptr = 0;
a4886 9
    V2.8.4 (not yet released)
      * Fix bad error check in mspace_footprint
      * Adaptations for ptmalloc, courtesy of Wolfram Gloger.
      * Reentrant spin locks, courtesy of Earl Chew and others
      * Win32 improvements, courtesy of Niall Douglas and Earl Chew
      * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options
      * Various small adjustments to reduce warnings on some compilers
      * Extension hook in malloc_state

d4892 1
a4892 1
        in create_mspace_with_base
d4911 1
a4911 1
        removing need for emulation on most platforms without sbrk.
d4916 2
a4917 2
        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
        Aaron Bachmann,  Emery Berger, and others.
d4930 1
a4930 1
        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
d4941 1
a4941 1
        Thanks to Michael Pachos for motivation and help.
d4945 2
a4946 2
        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
        and Anonymous.
d4948 1
a4948 1
        helping test this.)
d4951 2
a4952 2
        leads to  more fragmentation in some programs and doesn't
        seem to help in any others.
d4960 1
a4960 1
        Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
d4966 11
a4976 11
         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
          (e.g. WIN32 platforms)
         * Cleanup header file inclusion for WIN32 platforms
         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
           memory allocation routines
         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
           usage of 'assert' in non-WIN32 code
         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
           avoid infinite loop
d4988 1
a4988 1
        foreign sbrks
d4994 1
a4994 1
        Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5002 1
a5002 1
        avoid surprises about sbrk alignment conventions.
d5004 1
a5004 1
        (raymond@@es.ele.tue.nl) for the suggestion.
d5007 1
a5007 1
        courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5009 1
a5009 1
        H.J. Lu (hjl@@gnu.ai.mit.edu)
d5015 2
a5016 2
        the work required to undo bad preallocations exceeds
        the work saved in good cases for most test programs.
d5018 2
a5019 2
        no scheme using them consistently outperforms those that don't
        given above changes.
d5025 1
a5025 1
        Paul Wilson (wilson@@cs.texas.edu) for the suggestion.
d5029 1
a5029 1
        (wmglo@@Dent.MED.Uni-Muenchen.DE).
d5045 1
a5045 1
         (eliminating old malloc_find_space & malloc_clean_bin)
d5049 1
a5049 1
          from kpv@@research.att.com
d5057 2
a5058 2
          with gcc & native cc (hp, dec only) allowing
          Detlefs & Zorn comparison study (in SIGPLAN Notices.)
d5062 1
a5062 1
         structure of old version,  but most details differ.)
a5064 2


@


1.11.18.2
log
@	* Revert to old malloc.
	* mmap.cc (MMAP_STORAGE_LOW): Set higher.  Add comment.
	(MMAP_STORAGE_HIGH): Add comment.
	(class mmap_allocator): Change comment.  Add mmap_current_low member.
	(mmap_allocator::mmap_allocator): Define default constructor.
	(mmap_allocator::alloc): Change to a round-robin mechanism.  Add or
	change comments accordingly.
@
text
@d2 10
d17 1
a17 1
* Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)
d20 2
a21 2
	   ftp://gee.cs.oswego.edu/pub/misc/malloc.c
	 Check before installing!
d60 1
a60 1
					  8 or 16 bytes (if 8byte sizes)
d66 1
a66 1
			  8-byte ptrs:  32 bytes    (including overhead)
d124 4
a127 2
       program, consider instead using ptmalloc, which is derived from
       a version of this malloc. (See http://www.malloc.de).
d168 5
a172 1
  system allocation routines, which is often just 1.
d222 2
a223 1
to size_t precision unless they are explicitly casted.
d246 8
a253 1
  overridden on a per-mspace basis for mspace versions.)
d328 1
a328 1
MORECORE_CONTIGUOUS       default: 1 (true)
d342 6
d362 1
a362 1
MMAP_CLEARS               default: 1 on unix
d364 1
a364 1
  for standard unix mmap using /dev/zero.
d371 2
a372 2
  this setting has no effect. (On most x86s, the asm version is only
  slightly faster than the C version.)
d408 2
a409 2
				system_info.dwAllocationGranularity in WIN32,
				otherwise 64K.
d469 13
d502 5
a506 1
#define MMAP_CLEARS 0 /* WINCE and some others apparently don't clear */
d555 7
d619 7
d638 3
d700 22
d724 3
d728 3
d889 1
a889 1
		than current total if trimming has occurred.
d894 2
a895 2
	       back to system via malloc_trim. ("ideally" means that
	       it ignores page restrictions etc.)
d1173 1
a1173 1
				 size_t elem_size, void* chunks[]);
d1180 1
a1180 1
				   size_t sizes[], void* chunks[]);
d1288 45
d1380 2
d1389 1
a1389 1
/* Annoying but necessary to avoid errors on some plaftorms */
d1393 1
d1451 3
a1453 3
	   (dev_zero_fd = open("/dev/zero", O_RDWR), \
	    mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
	    mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
d1460 1
a1460 1
static void* win32mmap(size_t size) {
d1466 1
a1466 1
static void* win32direct_mmap(size_t size) {
d1468 1
a1468 1
			   PAGE_READWRITE);
d1473 1
a1473 1
static int win32munmap(void* ptr, size_t size) {
d1475 1
a1475 1
  char* cptr = ptr;
d1480 1
a1480 1
	minfo.State != MEM_COMMIT || minfo.RegionSize > size)
d1499 2
a1500 1
#define CALL_MREMAP(addr, osz, nsz, mv) MFAIL
a1517 2
#if USE_LOCKS

d1530 12
d1544 3
d1548 127
a1674 6
/* By default use posix locks */
#include <pthread.h>
#define MLOCK_T pthread_mutex_t
#define INITIAL_LOCK(l)      pthread_mutex_init(l, NULL)
#define ACQUIRE_LOCK(l)      pthread_mutex_lock(l)
#define RELEASE_LOCK(l)      pthread_mutex_unlock(l)
d1676 1
d1678 1
a1678 1
static MLOCK_T morecore_mutex = PTHREAD_MUTEX_INITIALIZER;
d1681 2
a1682 1
static MLOCK_T magic_init_mutex = PTHREAD_MUTEX_INITIALIZER;
d1684 21
a1704 5
#else /* WIN32 */
/*
   Because lock-protected regions have bounded times, and there
   are no recursive lock calls, we can use simple spinlocks.
*/
d1706 4
a1709 11
#define MLOCK_T long
static int win32_acquire_lock (MLOCK_T *sl) {
  for (;;) {
#ifdef InterlockedCompareExchangePointer
    if (!InterlockedCompareExchange(sl, 1, 0))
      return 0;
#else  /* Use older void* version */
    if (!InterlockedCompareExchange((void**)sl, (void*)1, (void*)0))
      return 0;
#endif /* InterlockedCompareExchangePointer */
    Sleep (0);
d1711 1
d1714 17
a1730 2
static void win32_release_lock (MLOCK_T *sl) {
  InterlockedExchange (sl, 0);
d1733 22
a1754 3
#define INITIAL_LOCK(l)      *(l)=0
#define ACQUIRE_LOCK(l)      win32_acquire_lock(l)
#define RELEASE_LOCK(l)      win32_release_lock(l)
a1757 1
static MLOCK_T magic_init_mutex;
d1759 19
d1779 4
d1831 4
a1834 4
	   | Size of previous chunk (if P = 1)                             |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
	 | Size of this chunk                                         1| +-+
d1836 7
a1842 7
	 |                                                               |
	 +-                                                             -+
	 |                                                               |
	 +-                                                             -+
	 |                                                               :
	 +-      size - sizeof(size_t) available payload bytes          -+
	 :                                                               |
d1844 2
a1845 2
	 |                                                               |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1853 4
a1856 4
	   | User payload (must be in use, or we would have merged!)       |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
	 | Size of this chunk                                         0| +-+
d1858 7
a1864 7
	 | Next pointer                                                  |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 | Prev pointer                                                  |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 |                                                               :
	 +-      size - sizeof(struct chunk) unused bytes               -+
	 :                                                               |
d1866 2
a1867 2
	 | Size of this chunk                                            |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1875 2
a1876 2
								     |0|
								     +-+
d1921 10
a1930 10
	the one bordering the end of available memory). It is treated
	specially.  Top is never included in any bin, is used only if
	no other chunk is available, and is released back to the
	system if it is very large (see M_TRIM_THRESHOLD).  In effect,
	the top chunk is treated as larger (and thus less well
	fitting) than any other available chunk.  The top chunk
	doesn't update its trailing size field since there is no next
	contiguous chunk that would have to index off it. However,
	space is still allocated for it (TOP_FOOT_SIZE) to enable
	separation or merging when space is extended.
d1933 7
a1939 7
	(IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
	PINUSE_BIT in their head fields.  Because they are allocated
	one-by-one, each must carry its own prev_foot field, which is
	also used to hold the offset this chunk has within its mmapped
	region, which is needed to preserve alignment. Each mmapped
	chunk is trailed by the first two fields of a fake next-chunk
	for sake of usage checks.
d2003 2
d2009 1
d2011 1
d2019 1
a2019 1
#define chunksize(p)        ((p)->head & ~(INUSE_BITS))
d2029 1
a2029 1
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~INUSE_BITS)))
d2071 2
a2072 2
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2075 7
a2081 7
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
d2084 1
a2084 1
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2092 2
a2093 2
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2096 14
a2109 14
	    |             Forward pointer to next chunk of same size        |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk of same size       |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to left child (child[0])                  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to right child (child[1])                 |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to parent                                 |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             bin index of this chunk                           |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space                                      .
	    .                                                               |
d2112 1
a2112 1
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2311 5
d2319 4
d2344 1
d2355 2
d2380 2
d2386 3
d2413 1
a2413 1
 (((S) + (mparams.page_size)) & ~(mparams.page_size - SIZE_T_ONE))
d2417 10
a2426 1
  (((S) + (mparams.granularity)) & ~(mparams.granularity - SIZE_T_ONE))
d2577 16
a2592 1
#if defined(__GNUC__) && defined(i386)
d2602 1
a2602 1
    __asm__("bsrl %1,%0\n\t" : "=r" (K) : "rm"  (X));\
d2657 1
a2657 1
#if defined(__GNUC__) && defined(i386)
d2661 8
a2668 1
  __asm__("bsfl %1,%0\n\t" : "=r" (J) : "rm" (X));\
d2833 3
a2835 3
	  read(fd, buf, sizeof(buf)) == sizeof(buf)) {
	s = *((size_t *) buf);
	close(fd);
d2839 1
a2839 1
	s = (size_t)(time(0) ^ (size_t)0x55555555U);
d2851 1
d2855 1
d2862 1
a2862 1
			   DEFAULT_GRANULARITY : mparams.page_size);
d2879 7
a2885 7
	(MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
	(sizeof(int) < 4)  ||
	(MALLOC_ALIGNMENT < (size_t)8U) ||
	((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
	((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
	((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||
	((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))
d2926 1
a2926 1
  size_t  sz = chunksize(p);
d2934 1
a2934 1
  assert(!next_pinuse(p));
d2964 1
a2964 1
  size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);
d3029 2
a3030 2
	      u->parent->child[1] == u ||
	      *((tbinptr*)(u->parent)) == u);
d3032 3
a3034 3
	assert(u->child[0]->parent == u);
	assert(u->child[0] != u);
	do_check_tree(m, u->child[0]);
d3037 3
a3039 3
	assert(u->child[1]->parent == u);
	assert(u->child[1] != u);
	do_check_tree(m, u->child[1]);
d3042 1
a3042 1
	assert(chunksize(u->child[0]) < chunksize(u->child[1]));
d3080 1
a3080 1
	do_check_inuse_chunk(m, q);
d3094 2
a3095 2
	if (p == x)
	  return 1;
d3106 2
a3107 2
	t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
	sizebits <<= 1;
d3110 5
a3114 5
	tchunkptr u = t;
	do {
	  if (u == (tchunkptr)x)
	    return 1;
	} while ((u = u->fd) != t);
d3132 13
a3144 13
	     q != m->top && q->head != FENCEPOST_HEAD) {
	sum += chunksize(q);
	if (cinuse(q)) {
	  assert(!bin_find(m, q));
	  do_check_inuse_chunk(m, q);
	}
	else {
	  assert(q == m->dv || bin_find(m, q));
	  assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */
	  do_check_free_chunk(m, q);
	}
	lastq = q;
	q = next_chunk(q);
d3171 1
a3171 1
    assert(m->topsize == chunksize(m->top));
d3195 12
a3206 12
	mchunkptr q = align_as_chunk(s->base);
	while (segment_holds(s, q) &&
	       q != m->top && q->head != FENCEPOST_HEAD) {
	  size_t sz = chunksize(q);
	  sum += sz;
	  if (!cinuse(q)) {
	    mfree += sz;
	    ++nfree;
	  }
	  q = next_chunk(q);
	}
	s = s->next;
d3237 8
a3244 8
	mchunkptr q = align_as_chunk(s->base);
	while (segment_holds(s, q) &&
	       q != m->top && q->head != FENCEPOST_HEAD) {
	  if (!cinuse(q))
	    used -= chunksize(q);
	  q = next_chunk(q);
	}
	s = s->next;
d3295 1
a3295 1
		   (B == smallbin_at(M,I) || ok_address(M, B)))) {\
d3355 14
a3368 14
	tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
	K <<= 1;\
	if (*C != 0)\
	  T = *C;\
	else if (RTCHECK(ok_address(M, C))) {\
	  *C = X;\
	  X->parent = T;\
	  X->fd = X->bk = X;\
	  break;\
	}\
	else {\
	  CORRUPTION_ERROR_ACTION(M);\
	  break;\
	}\
d3371 12
a3382 12
	tchunkptr F = T->fd;\
	if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
	  T->fd = F->bk = X;\
	  X->fd = F;\
	  X->bk = T;\
	  X->parent = 0;\
	  break;\
	}\
	else {\
	  CORRUPTION_ERROR_ACTION(M);\
	  break;\
	}\
d3422 1
a3422 1
	((R = *(RP = &(X->child[0]))) != 0)) {\
d3425 2
a3426 2
	     (*(CP = &(R->child[0])) != 0)) {\
	R = *(RP = CP);\
d3429 1
a3429 1
	*RP = 0;\
d3431 1
a3431 1
	CORRUPTION_ERROR_ACTION(M);\
d3439 1
a3439 1
	clear_treemap(M, X->index);\
d3443 1
a3443 1
	XP->child[0] = R;\
d3445 1
a3445 1
	XP->child[1] = R;\
d3451 18
a3468 18
	tchunkptr C0, C1;\
	R->parent = XP;\
	if ((C0 = X->child[0]) != 0) {\
	  if (RTCHECK(ok_address(M, C0))) {\
	    R->child[0] = C0;\
	    C0->parent = R;\
	  }\
	  else\
	    CORRUPTION_ERROR_ACTION(M);\
	}\
	if ((C1 = X->child[1]) != 0) {\
	  if (RTCHECK(ok_address(M, C1))) {\
	    R->child[1] = C1;\
	    C1->parent = R;\
	  }\
	  else\
	    CORRUPTION_ERROR_ACTION(M);\
	}\
d3471 1
a3471 1
	CORRUPTION_ERROR_ACTION(M);\
d3495 1
a3495 1
   (m == gm)? dlmalloc(b) : mspace_malloc(m, b)
d3518 1
a3518 1
  size_t mmsize = granularity_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3532 1
a3532 1
	m->least_addr = mm;
d3534 1
a3534 1
	m->max_footprint = m->footprint;
d3555 1
a3555 2
    size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +
					 CHUNK_ALIGN_MASK);
d3557 1
a3557 1
				  oldmmsize, newmmsize, 1);
d3567 1
a3567 1
	m->least_addr = cp;
d3569 1
a3569 1
	m->max_footprint = m->footprint;
d3625 1
a3625 1
			   size_t nb) {
a3664 1

d3761 10
a3770 10
	asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
	/* Adjust to end on a page boundary */
	if (!is_page_aligned(base))
	  asize += (page_align((size_t)base) - (size_t)base);
	/* Can't call MORECORE if size is negative when treated as signed */
	if (asize < HALF_MAX_SIZE_T &&
	    (br = (char*)(CALL_MORECORE(asize))) == base) {
	  tbase = base;
	  tsize = asize;
	}
d3778 3
a3780 3
	  (br = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
	tbase = br;
	tsize = asize;
d3786 13
a3798 13
	if (asize < HALF_MAX_SIZE_T &&
	    asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
	  size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
	  if (esize < HALF_MAX_SIZE_T) {
	    char* end = (char*)CALL_MORECORE(esize);
	    if (end != CMFAIL)
	      asize += esize;
	    else {            /* Can't use; try to release */
	      CALL_MORECORE(-asize);
	      br = CMFAIL;
	    }
	  }
	}
d3801 2
a3802 2
	tbase = br;
	tsize = asize;
d3805 1
a3805 1
	disable_contiguous(m); /* Don't try contiguous path in the future */
d3817 3
a3819 3
	tbase = mp;
	tsize = rsize;
	mmap_flag = IS_MMAPPED_BIT;
d3834 5
a3838 5
	size_t ssize = end - br;
	if (ssize > nb + TOP_FOOT_SIZE) {
	  tbase = br;
	  tsize = ssize;
	}
d3853 1
d3855 1
d3857 7
a3863 5
	init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
      else {
	/* Offset top by embedded malloc_state */
	mchunkptr mn = next_chunk(mem2chunk(m));
	init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
d3870 1
d3872 1
a3872 1
	sp = sp->next;
d3874 5
a3878 5
	  !is_extern_segment(sp) &&
	  (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&
	  segment_holds(sp, m->top)) { /* append */
	sp->size += tsize;
	init_top(m, m->top, m->topsize + tsize);
d3881 15
a3895 15
	if (tbase < m->least_addr)
	  m->least_addr = tbase;
	sp = &m->seg;
	while (sp != 0 && sp->base != tbase + tsize)
	  sp = sp->next;
	if (sp != 0 &&
	    !is_extern_segment(sp) &&
	    (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
	  char* oldbase = sp->base;
	  sp->base = tbase;
	  sp->size += tsize;
	  return prepend_alloc(m, tbase, oldbase, nb);
	}
	else
	  add_segment(m, tbase, tsize, mmap_flag);
d3920 1
d3927 1
d3933 19
a3951 19
	tchunkptr tp = (tchunkptr)p;
	assert(segment_holds(sp, (char*)sp));
	if (p == m->dv) {
	  m->dv = 0;
	  m->dvsize = 0;
	}
	else {
	  unlink_large_chunk(m, tp);
	}
	if (CALL_MUNMAP(base, size) == 0) {
	  released += size;
	  m->footprint -= size;
	  /* unlink obsoleted record */
	  sp = pred;
	  sp->next = next;
	}
	else { /* back out if cannot unmap */
	  insert_large_chunk(m, tp, psize);
	}
d3954 2
d3959 3
d3974 1
a3974 1
		      SIZE_T_ONE) * unit;
d3978 28
a4005 28
	if (is_mmapped_segment(sp)) {
	  if (HAVE_MMAP &&
	      sp->size >= extra &&
	      !has_segment_link(m, sp)) { /* can't shrink if pinned */
	    size_t newsize = sp->size - extra;
	    /* Prefer mremap, fall back to munmap */
	    if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
		(CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
	      released = extra;
	    }
	  }
	}
	else if (HAVE_MORECORE) {
	  if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
	    extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
	  ACQUIRE_MORECORE_LOCK();
	  {
	    /* Make sure end of memory is where we last set it. */
	    char* old_br = (char*)(CALL_MORECORE(0));
	    if (old_br == sp->base + sp->size) {
	      char* rel_br = (char*)(CALL_MORECORE(-extra));
	      char* new_br = (char*)(CALL_MORECORE(0));
	      if (rel_br != CMFAIL && new_br < old_br)
		released = old_br - new_br;
	    }
	  }
	  RELEASE_MORECORE_LOCK();
	}
d4009 4
a4012 4
	sp->size -= released;
	m->footprint -= released;
	init_top(m, m->top, m->topsize - released);
	check_top_chunk(m, m->top);
d4021 1
a4021 1
    if (released == 0)
d4046 3
a4048 3
	v = t;
	if ((rsize = trem) == 0)
	  break;
d4053 1
a4053 1
	rst = rt;
d4055 2
a4056 2
	t = rst; /* set t to least subtree holding sizes > nb */
	break;
d4087 9
a4095 9
	unlink_large_chunk(m, v);
	if (rsize < MIN_CHUNK_SIZE)
	  set_inuse_and_pinuse(m, v, (rsize + nb));
	else {
	  set_size_and_pinuse_of_inuse_chunk(m, v, nb);
	  set_size_and_pinuse_of_free_chunk(r, rsize);
	  insert_chunk(m, r, rsize);
	}
	return chunk2mem(v);
d4128 1
a4128 1
	set_inuse_and_pinuse(m, v, (rsize + nb));
d4130 3
a4132 3
	set_size_and_pinuse_of_inuse_chunk(m, v, nb);
	set_size_and_pinuse_of_free_chunk(r, rsize);
	replace_dv(m, r, rsize);
d4159 1
a4159 1
		ok_next(oldp, next) && ok_pinuse(next))) {
d4162 1
a4162 1
	newp = mmap_resize(m, oldp, nb);
d4164 8
a4171 8
	size_t rsize = oldsize - nb;
	newp = oldp;
	if (rsize >= MIN_CHUNK_SIZE) {
	  mchunkptr remainder = chunk_plus_offset(newp, nb);
	  set_inuse(m, newp, nb);
	  set_inuse(m, remainder, rsize);
	  extra = chunk2mem(remainder);
	}
d4174 9
a4182 9
	/* Expand into top */
	size_t newsize = oldsize + m->topsize;
	size_t newtopsize = newsize - nb;
	mchunkptr newtop = chunk_plus_offset(oldp, nb);
	set_inuse(m, oldp, nb);
	newtop->head = newtopsize |PINUSE_BIT;
	m->top = newtop;
	m->topsize = newtopsize;
	newp = oldp;
d4195 1
a4195 1
	internal_free(m, extra);
d4203 3
a4205 3
	size_t oc = oldsize - overhead_for(oldp);
	memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);
	internal_free(m, oldmem);
d4242 28
a4269 28
	/*
	  Find an aligned spot inside chunk.  Since we need to give
	  back leading space in a chunk of at least MIN_CHUNK_SIZE, if
	  the first calculation places us at a spot with less than
	  MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
	  We've allocated enough total room so that this is always
	  possible.
	*/
	char* br = (char*)mem2chunk((size_t)(((size_t)(mem +
						       alignment -
						       SIZE_T_ONE)) &
					     -alignment));
	char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
	  br : br+alignment;
	mchunkptr newp = (mchunkptr)pos;
	size_t leadsize = pos - (char*)(p);
	size_t newsize = chunksize(p) - leadsize;

	if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
	  newp->prev_foot = p->prev_foot + leadsize;
	  newp->head = (newsize|CINUSE_BIT);
	}
	else { /* Otherwise, give back leader, use the rest */
	  set_inuse(m, newp, newsize);
	  set_inuse(m, p, leadsize);
	  leader = chunk2mem(p);
	}
	p = newp;
d4274 8
a4281 8
	size_t size = chunksize(p);
	if (size > nb + MIN_CHUNK_SIZE) {
	  size_t remainder_size = size - nb;
	  mchunkptr remainder = chunk_plus_offset(p, nb);
	  set_inuse(m, p, nb);
	  set_inuse(m, remainder, remainder_size);
	  trailer = chunk2mem(remainder);
	}
d4289 1
a4289 1
	internal_free(m, leader);
d4292 1
a4292 1
	internal_free(m, trailer);
d4303 4
a4306 4
		     size_t n_elements,
		     size_t* sizes,
		     int opts,
		     void* chunks[]) {
d4395 1
a4395 1
	size = element_size;
d4397 1
a4397 1
	size = request2size(sizes[i]);
d4438 2
a4439 2
	  (Remainderless means that there are too few excess bytes to
	  represent as a chunk.)
d4441 1
a4441 1
	  chunk adjacent to the one used for the most recent small request.
d4443 1
a4443 1
	  saving remainder in dv.
d4448 1
a4448 1
	  if it is better fitting than dv chunk, splitting if necessary.
d4468 10
a4477 10
	mchunkptr b, p;
	idx += ~smallbits & 1;       /* Uses next bin if idx empty */
	b = smallbin_at(gm, idx);
	p = b->fd;
	assert(chunksize(p) == small_index2size(idx));
	unlink_first_small_chunk(gm, b, p, idx);
	set_inuse_and_pinuse(gm, p, small_index2size(idx));
	mem = chunk2mem(p);
	check_malloced_chunk(gm, mem, nb);
	goto postaction;
d4481 30
a4510 30
	if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
	  mchunkptr b, p, r;
	  size_t rsize;
	  bindex_t i;
	  binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
	  binmap_t leastbit = least_bit(leftbits);
	  compute_bit2idx(leastbit, i);
	  b = smallbin_at(gm, i);
	  p = b->fd;
	  assert(chunksize(p) == small_index2size(i));
	  unlink_first_small_chunk(gm, b, p, i);
	  rsize = small_index2size(i) - nb;
	  /* Fit here cannot be remainderless if 4byte sizes */
	  if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
	    set_inuse_and_pinuse(gm, p, small_index2size(i));
	  else {
	    set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
	    r = chunk_plus_offset(p, nb);
	    set_size_and_pinuse_of_free_chunk(r, rsize);
	    replace_dv(gm, r, rsize);
	  }
	  mem = chunk2mem(p);
	  check_malloced_chunk(gm, mem, nb);
	  goto postaction;
	}

	else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
	  check_malloced_chunk(gm, mem, nb);
	  goto postaction;
	}
d4518 2
a4519 2
	check_malloced_chunk(gm, mem, nb);
	goto postaction;
d4527 4
a4530 4
	mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
	gm->dvsize = rsize;
	set_size_and_pinuse_of_free_chunk(r, rsize);
	set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
d4533 4
a4536 4
	size_t dvs = gm->dvsize;
	gm->dvsize = 0;
	gm->dv = 0;
	set_inuse_and_pinuse(gm, p, dvs);
d4586 77
a4662 67
	size_t psize = chunksize(p);
	mchunkptr next = chunk_plus_offset(p, psize);
	if (!pinuse(p)) {
	  size_t prevsize = p->prev_foot;
	  if ((prevsize & IS_MMAPPED_BIT) != 0) {
	    prevsize &= ~IS_MMAPPED_BIT;
	    psize += prevsize + MMAP_FOOT_PAD;
	    if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
	      fm->footprint -= psize;
	    goto postaction;
	  }
	  else {
	    mchunkptr prev = chunk_minus_offset(p, prevsize);
	    psize += prevsize;
	    p = prev;
	    if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
	      if (p != fm->dv) {
		unlink_chunk(fm, p, prevsize);
	      }
	      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
		fm->dvsize = psize;
		set_free_with_pinuse(p, psize, next);
		goto postaction;
	      }
	    }
	    else
	      goto erroraction;
	  }
	}

	if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
	  if (!cinuse(next)) {  /* consolidate forward */
	    if (next == fm->top) {
	      size_t tsize = fm->topsize += psize;
	      fm->top = p;
	      p->head = tsize | PINUSE_BIT;
	      if (p == fm->dv) {
		fm->dv = 0;
		fm->dvsize = 0;
	      }
	      if (should_trim(fm, tsize))
		sys_trim(fm, 0);
	      goto postaction;
	    }
	    else if (next == fm->dv) {
	      size_t dsize = fm->dvsize += psize;
	      fm->dv = p;
	      set_size_and_pinuse_of_free_chunk(p, dsize);
	      goto postaction;
	    }
	    else {
	      size_t nsize = chunksize(next);
	      psize += nsize;
	      unlink_chunk(fm, next, nsize);
	      set_size_and_pinuse_of_free_chunk(p, psize);
	      if (p == fm->dv) {
		fm->dvsize = psize;
		goto postaction;
	      }
	    }
	  }
	  else
	    set_free_with_pinuse(p, psize, next);
	  insert_chunk(fm, p, psize);
	  check_free_chunk(fm, p);
	  goto postaction;
	}
d4681 1
a4681 1
	(req / n_elements != elem_size))
d4718 1
a4718 1
				 void* chunks[]) {
d4724 1
a4724 1
				   void* chunks[]) {
d4799 1
d4801 2
d4818 1
a4818 1
		 (capacity + TOP_FOOT_SIZE + msize));
d4855 2
a4856 2
	  CALL_MUNMAP(base, size) == 0)
	freed += size;
d4888 10
a4897 10
	mchunkptr b, p;
	idx += ~smallbits & 1;       /* Uses next bin if idx empty */
	b = smallbin_at(ms, idx);
	p = b->fd;
	assert(chunksize(p) == small_index2size(idx));
	unlink_first_small_chunk(ms, b, p, idx);
	set_inuse_and_pinuse(ms, p, small_index2size(idx));
	mem = chunk2mem(p);
	check_malloced_chunk(ms, mem, nb);
	goto postaction;
d4901 30
a4930 30
	if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
	  mchunkptr b, p, r;
	  size_t rsize;
	  bindex_t i;
	  binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
	  binmap_t leastbit = least_bit(leftbits);
	  compute_bit2idx(leastbit, i);
	  b = smallbin_at(ms, i);
	  p = b->fd;
	  assert(chunksize(p) == small_index2size(i));
	  unlink_first_small_chunk(ms, b, p, i);
	  rsize = small_index2size(i) - nb;
	  /* Fit here cannot be remainderless if 4byte sizes */
	  if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
	    set_inuse_and_pinuse(ms, p, small_index2size(i));
	  else {
	    set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
	    r = chunk_plus_offset(p, nb);
	    set_size_and_pinuse_of_free_chunk(r, rsize);
	    replace_dv(ms, r, rsize);
	  }
	  mem = chunk2mem(p);
	  check_malloced_chunk(ms, mem, nb);
	  goto postaction;
	}

	else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
	  check_malloced_chunk(ms, mem, nb);
	  goto postaction;
	}
d4938 2
a4939 2
	check_malloced_chunk(ms, mem, nb);
	goto postaction;
d4947 4
a4950 4
	mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
	ms->dvsize = rsize;
	set_size_and_pinuse_of_free_chunk(r, rsize);
	set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
d4953 4
a4956 4
	size_t dvs = ms->dvsize;
	ms->dvsize = 0;
	ms->dv = 0;
	set_inuse_and_pinuse(ms, p, dvs);
d5000 77
a5076 67
	size_t psize = chunksize(p);
	mchunkptr next = chunk_plus_offset(p, psize);
	if (!pinuse(p)) {
	  size_t prevsize = p->prev_foot;
	  if ((prevsize & IS_MMAPPED_BIT) != 0) {
	    prevsize &= ~IS_MMAPPED_BIT;
	    psize += prevsize + MMAP_FOOT_PAD;
	    if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
	      fm->footprint -= psize;
	    goto postaction;
	  }
	  else {
	    mchunkptr prev = chunk_minus_offset(p, prevsize);
	    psize += prevsize;
	    p = prev;
	    if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
	      if (p != fm->dv) {
		unlink_chunk(fm, p, prevsize);
	      }
	      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
		fm->dvsize = psize;
		set_free_with_pinuse(p, psize, next);
		goto postaction;
	      }
	    }
	    else
	      goto erroraction;
	  }
	}

	if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
	  if (!cinuse(next)) {  /* consolidate forward */
	    if (next == fm->top) {
	      size_t tsize = fm->topsize += psize;
	      fm->top = p;
	      p->head = tsize | PINUSE_BIT;
	      if (p == fm->dv) {
		fm->dv = 0;
		fm->dvsize = 0;
	      }
	      if (should_trim(fm, tsize))
		sys_trim(fm, 0);
	      goto postaction;
	    }
	    else if (next == fm->dv) {
	      size_t dsize = fm->dvsize += psize;
	      fm->dv = p;
	      set_size_and_pinuse_of_free_chunk(p, dsize);
	      goto postaction;
	    }
	    else {
	      size_t nsize = chunksize(next);
	      psize += nsize;
	      unlink_chunk(fm, next, nsize);
	      set_size_and_pinuse_of_free_chunk(p, psize);
	      if (p == fm->dv) {
		fm->dvsize = psize;
		goto postaction;
	      }
	    }
	  }
	  else
	    set_free_with_pinuse(p, psize, next);
	  insert_chunk(fm, p, psize);
	  check_free_chunk(fm, p);
	  goto postaction;
	}
d5097 1
a5097 1
	(req / n_elements != elem_size))
d5140 1
a5140 1
				 size_t elem_size, void* chunks[]) {
d5151 1
a5151 1
				   size_t sizes[], void* chunks[]) {
d5186 1
a5186 1
  size_t result;
d5191 3
a5193 1
  USAGE_ERROR_ACTION(ms,ms);
d5199 1
a5199 1
  size_t result;
d5204 3
a5206 1
  USAGE_ERROR_ACTION(ms,ms);
d5221 9
d5285 1
a5285 1
	 size = MINIMUM_MORECORE_SIZE;
d5287 1
a5287 1
	 ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
d5290 1
a5290 1
	return (void *) MFAIL;
d5320 2
a5321 2
	 PoolDeallocate(*ptr);
	 *ptr = 0;
d5330 9
d5344 1
a5344 1
	in create_mspace_with_base
d5363 1
a5363 1
	removing need for emulation on most platforms without sbrk.
d5368 2
a5369 2
	Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
	Aaron Bachmann,  Emery Berger, and others.
d5382 1
a5382 1
	Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
d5393 1
a5393 1
	Thanks to Michael Pachos for motivation and help.
d5397 2
a5398 2
	Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
	and Anonymous.
d5400 1
a5400 1
	helping test this.)
d5403 2
a5404 2
	leads to  more fragmentation in some programs and doesn't
	seem to help in any others.
d5412 1
a5412 1
	Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
d5418 11
a5428 11
	 * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
	  (e.g. WIN32 platforms)
	 * Cleanup header file inclusion for WIN32 platforms
	 * Cleanup code to avoid Microsoft Visual C++ compiler complaints
	 * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
	   memory allocation routines
	 * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
	 * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
	   usage of 'assert' in non-WIN32 code
	 * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
	   avoid infinite loop
d5440 1
a5440 1
	foreign sbrks
d5446 1
a5446 1
	Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5454 1
a5454 1
	avoid surprises about sbrk alignment conventions.
d5456 1
a5456 1
	(raymond@@es.ele.tue.nl) for the suggestion.
d5459 1
a5459 1
	courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5461 1
a5461 1
	H.J. Lu (hjl@@gnu.ai.mit.edu)
d5467 2
a5468 2
	the work required to undo bad preallocations exceeds
	the work saved in good cases for most test programs.
d5470 2
a5471 2
	no scheme using them consistently outperforms those that don't
	given above changes.
d5477 1
a5477 1
	Paul Wilson (wilson@@cs.texas.edu) for the suggestion.
d5481 1
a5481 1
	(wmglo@@Dent.MED.Uni-Muenchen.DE).
d5497 1
a5497 1
	 (eliminating old malloc_find_space & malloc_clean_bin)
d5501 1
a5501 1
	  from kpv@@research.att.com
d5509 2
a5510 2
	  with gcc & native cc (hp, dec only) allowing
	  Detlefs & Zorn comparison study (in SIGPLAN Notices.)
d5514 1
a5514 1
	 structure of old version,  but most details differ.)
d5517 2
@


1.11.18.3
log
@	* Reinstantiate ptmalloc3.
	* configure.ac (MALLOC_OFILES): Drop here.
	* configure: Regenerate.
	* Makefile.in (MALLOC_OFILES): Set to fixed value here.
	* cygmalloc.h (HAVE_MORECORE): Define.
	* malloc.cc (init_user_mstate): Don't disable MORECORE if building
	with ONLY_MSPACES.
@
text
@a1 10
  $Id: malloc.cc,v 1.11.18.1 2013/02/27 08:36:58 corinna Exp $

  This version of malloc.c was adapted for ptmalloc3 by Wolfram Gloger
  <wg@@malloc.de>.  Therefore, some of the comments below do not apply
  for this modified version.  However, it is the intention to keep
  differences to Doug Lea's original version minimal, hence the
  comments were mostly left unchanged.

 -----------------------------------------------------------------------

d7 1
a7 1
* Version pre-2.8.4 Wed Mar 29 19:46:29 2006    (dl at gee)
d10 2
a11 2
           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
         Check before installing!
d50 1
a50 1
                                          8 or 16 bytes (if 8byte sizes)
d56 1
a56 1
                          8-byte ptrs:  32 bytes    (including overhead)
d114 2
a115 4
       program, consider instead using nedmalloc
       (http://www.nedprod.com/programs/portable/nedmalloc/) or
       ptmalloc (See http://www.malloc.de), which are derived
       from versions of this malloc.
d156 1
a156 5
  system allocation routines, which is often just 1. In real-time
  applications, you can optionally suppress segment traversals using
  NO_SEGMENT_TRAVERSAL, which assures bounded execution even when
  system allocators return non-contiguous spaces, at the typical
  expense of carrying around more memory and increased fragmentation.
d206 1
a206 2
to size_t precision unless they are explicitly casted. You can also
use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.
d229 1
a229 8
  overridden on a per-mspace basis for mspace versions.) If set to a
  non-zero value other than 1, locks are used, but their
  implementation is left out, so lock functions must be supplied manually.

USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and on x86 using gcc or MSC
  If true, uses custom spin locks for locking. This is currently
  supported only for x86 platforms using gcc or recent MS compilers.
  Otherwise, posix locks or win32 critical sections are used.
d304 1
a304 1
MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
a317 6
NO_SEGMENT_TRAVERSAL       default: 0
  If non-zero, suppresses traversals of memory segments
  returned by either MORECORE or CALL_MMAP. This disables
  merging of segments that are contiguous, and selectively
  releasing them to the OS if unused, but bounds execution times.

d332 1
a332 1
MMAP_CLEARS               default: 1 except on WINCE.
d334 1
a334 1
  for standard unix mmap using /dev/zero and on WIN32 except for WINCE.
d341 2
a342 2
  this setting has no effect. Similarly for Win32 under recent MS compilers.
  (On most x86s, the asm version is only slightly faster than the C version.)
d378 2
a379 2
                                system_info.dwAllocationGranularity in WIN32,
                                otherwise 64K.
a438 13
MAX_RELEASE_CHECK_RATE   default: 255 unless not HAVE_MMAP
  The number of consolidated frees between checks to release
  unused segments when freeing. When using non-contiguous segments,
  especially with multiple mspaces, checking only for topmost space
  doesn't always suffice to trigger trimming. To compensate for this,
  free() will, with a period of MAX_RELEASE_CHECK_RATE (or the
  current number of segments, if greater) try to release unused
  segments to the OS when freeing chunks that result in
  consolidation. The best value for this parameter is a compromise
  between slowing down frees with relatively costly checks that
  rarely trigger versus holding on to unused memory. To effectively
  disable, set to MAX_SIZE_T. This may lead to a very slight speed
  improvement at the expense of carrying around more memory.
d459 1
a459 5
#ifdef _WIN32_WCE /* WINCE reportedly does not clear */
#define MMAP_CLEARS 0
#else
#define MMAP_CLEARS 1
#endif /* _WIN32_WCE */
a507 7
#ifndef USE_SPIN_LOCKS
#if USE_LOCKS && (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))) || (defined(_MSC_VER) && _MSC_VER>=1310)
#define USE_SPIN_LOCKS 1
#else
#define USE_SPIN_LOCKS 0
#endif /* USE_LOCKS && ... */
#endif /* USE_SPIN_LOCKS */
a564 7
#ifndef MAX_RELEASE_CHECK_RATE
#if HAVE_MMAP
#define MAX_RELEASE_CHECK_RATE 255
#else
#define MAX_RELEASE_CHECK_RATE MAX_SIZE_T
#endif /* HAVE_MMAP */
#endif /* MAX_RELEASE_CHECK_RATE */
a576 3
#ifndef NO_SEGMENT_TRAVERSAL
#define NO_SEGMENT_TRAVERSAL 0
#endif /* NO_SEGMENT_TRAVERSAL */
a635 22
/*
  Try to persuade compilers to inline. The most critical functions for
  inlining are defined as macros, so these aren't used for them.
*/

#ifndef FORCEINLINE
  #if defined(__GNUC__)
#define FORCEINLINE __inline __attribute__ ((always_inline))
  #elif defined(_MSC_VER)
    #define FORCEINLINE __forceinline
  #endif
#endif
#ifndef NOINLINE
  #if defined(__GNUC__)
    #define NOINLINE __attribute__ ((noinline))
  #elif defined(_MSC_VER)
    #define NOINLINE __declspec(noinline)
  #else
    #define NOINLINE
  #endif
#endif

a637 3
#ifndef FORCEINLINE
 #define FORCEINLINE inline
#endif
a638 3
#ifndef FORCEINLINE
 #define FORCEINLINE
#endif
d797 1
a797 1
                than current total if trimming has occurred.
d802 2
a803 2
               back to system via malloc_trim. ("ideally" means that
               it ignores page restrictions etc.)
d1081 1
a1081 1
                                 size_t elem_size, void* chunks[]);
d1088 1
a1088 1
                                   size_t sizes[], void* chunks[]);
a1195 45
/* Declarations for locking */
#if USE_LOCKS
#ifndef WIN32
#include <pthread.h>
#if defined (__SVR4) && defined (__sun)  /* solaris */
#include <thread.h>
#endif /* solaris */
#else
#ifndef _M_AMD64
/* These are already defined on AMD64 builds */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
LONG __cdecl _InterlockedCompareExchange(LPLONG volatile Dest, LONG Exchange, LONG Comp);
LONG __cdecl _InterlockedExchange(LPLONG volatile Target, LONG Value);
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* _M_AMD64 */
#pragma intrinsic (_InterlockedCompareExchange)
#pragma intrinsic (_InterlockedExchange)
#define interlockedcompareexchange _InterlockedCompareExchange
#define interlockedexchange _InterlockedExchange
#endif /* Win32 */
#endif /* USE_LOCKS */

/* Declarations for bit scanning on win32 */
#if defined(_MSC_VER) && _MSC_VER>=1300
#ifndef BitScanForward	/* Try to avoid pulling in WinNT.h */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
unsigned char _BitScanForward(unsigned long *index, unsigned long mask);
unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#endif /* BitScanForward */
#endif /* defined(_MSC_VER) && _MSC_VER>=1300 */

a1242 2


d1250 1
a1250 1
/* Annoying but necessary to avoid errors on some platforms */
a1253 1
#define SIZE_T_FOUR         ((size_t)4)
d1311 3
a1313 3
           (dev_zero_fd = open("/dev/zero", O_RDWR), \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
d1320 1
a1320 1
static FORCEINLINE void* win32mmap(size_t size) {
d1326 1
a1326 1
static FORCEINLINE void* win32direct_mmap(size_t size) {
d1328 1
a1328 1
                           PAGE_READWRITE);
d1333 1
a1333 1
static FORCEINLINE int win32munmap(void* ptr, size_t size) {
d1335 1
a1335 1
  char* cptr = (char*)ptr;
d1340 1
a1340 1
        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
d1359 1
a1359 2
#define CALL_MREMAP(addr, osz, nsz, mv) ((void)(addr),(void)(osz), \
                                         (void)(nsz), (void)(mv),MFAIL)
d1377 2
a1390 12

   To enable use in layered extensions, locks are reentrant.

   Because lock-protected regions generally have bounded times, we use
   the supplied simple spinlocks in the custom versions for x86.

   If USE_LOCKS is > 1, the definitions of lock routines here are
   bypassed, in which case you will need to define at least
   INITIAL_LOCK, ACQUIRE_LOCK, RELEASE_LOCK, and
   NULL_LOCK_INITIALIZER, and possibly TRY_LOCK and IS_LOCKED
   (The latter two are not used in this malloc, but are
   commonly needed in extensions.)
a1392 3
#if USE_LOCKS == 1

#if USE_SPIN_LOCKS
d1394 6
a1399 49
/* Custom pthread-style spin locks on x86 and x64 for gcc */
struct pthread_mlock_t
{
  volatile pthread_t threadid;
  volatile unsigned int c;
  volatile unsigned int l;
};
#define MLOCK_T struct pthread_mlock_t
#define CURRENT_THREAD        pthread_self()
#define SPINS_PER_YIELD       63
static FORCEINLINE int pthread_acquire_lock (MLOCK_T *sl) {
  if(CURRENT_THREAD==sl->threadid)
    ++sl->c;
  else {
    int spins = 0;
    for (;;) {
      int ret;
      __asm__ __volatile__ ("lock cmpxchgl %2,(%1)" : "=a" (ret) : "r" (&sl->l), "r" (1), "a" (0));
      if(!ret) {
        assert(!sl->threadid);
        sl->threadid=CURRENT_THREAD;
        sl->c=1;
        break;
      }
      if ((++spins & SPINS_PER_YIELD) == 0) {
#if defined (__SVR4) && defined (__sun) /* solaris */
        thr_yield();
#else
#ifdef linux
        sched_yield();
#else  /* no-op yield on unknown systems */
        ;
#endif /* linux */
#endif /* solaris */
      }
    }
  }

  return 0;
}

static FORCEINLINE void pthread_release_lock (MLOCK_T *sl) {
  int ret;
  assert(CURRENT_THREAD==sl->threadid);
  if (!--sl->c) {
    sl->threadid=0;
    __asm__ __volatile__ ("xchgl %2,(%1)" : "=r" (ret) : "r" (&sl->l), "0" (0));
  }
}
a1400 19
static FORCEINLINE int pthread_try_lock (MLOCK_T *sl) {
  int ret;
  __asm__ __volatile__ ("lock cmpxchgl %2,(%1)" : "=a" (ret) : "r" (&sl->l), "r" (1), "a" (0));
  if(!ret){
    assert(!sl->threadid);
    sl->threadid=CURRENT_THREAD;
    sl->c=1;
    return 1;
  }
  return 0;
}

#define INITIAL_LOCK(sl)      (memset((sl), 0, sizeof(MLOCK_T)), 0)
#define ACQUIRE_LOCK(sl)      pthread_acquire_lock(sl)
#define RELEASE_LOCK(sl)      pthread_release_lock(sl)
#define TRY_LOCK(sl)          pthread_try_lock(sl)
#define IS_LOCKED(sl)         ((sl)->l)

static MLOCK_T magic_init_mutex = {0, 0, 0 };
d1402 1
a1402 1
static MLOCK_T morecore_mutex = {0, 0, 0 };
d1405 2
d1408 4
a1411 29
/* Custom win32-style spin locks on x86 and x64 for MSC */
struct win32_mlock_t
{
  volatile long threadid;
  volatile unsigned int c;
  long l;
};
#define MLOCK_T struct win32_mlock_t
#define CURRENT_THREAD        GetCurrentThreadId()
#define SPINS_PER_YIELD    63
static FORCEINLINE int win32_acquire_lock (MLOCK_T *sl) {
  long mythreadid=CURRENT_THREAD;
  if(mythreadid==sl->threadid)
    ++sl->c;
  else {
    int spins = 0;
    for (;;) {
      if (!interlockedexchange(&sl->l, 1)) {
        assert(!sl->threadid);
        sl->threadid=mythreadid;
        sl->c=1;
        break;
      }
      if ((++spins & SPINS_PER_YIELD) == 0)
        SleepEx(0, FALSE);
    }
  }
  return 0;
}
d1413 11
a1423 5
static FORCEINLINE void win32_release_lock (MLOCK_T *sl) {
  assert(CURRENT_THREAD==sl->threadid);
  if (!--sl->c) {
    sl->threadid=0;
    interlockedexchange (&sl->l, 0);
d1427 2
a1428 8
static FORCEINLINE int win32_try_lock (MLOCK_T *sl) {
  if (!interlockedexchange(&sl->l, 1)){
    assert(!sl->threadid);
    sl->threadid=CURRENT_THREAD;
    sl->c=1;
    return 1;
  }
  return 0;
d1431 3
a1433 7
#define INITIAL_LOCK(sl)      (memset(sl, 0, sizeof(MLOCK_T)), 0)
#define ACQUIRE_LOCK(sl)      win32_acquire_lock(sl)
#define RELEASE_LOCK(sl)      win32_release_lock(sl)
#define TRY_LOCK(sl)          win32_try_lock(sl)
#define IS_LOCKED(sl)         ((sl)->l)

static MLOCK_T magic_init_mutex = {0, 0 };
d1435 1
a1435 1
static MLOCK_T morecore_mutex = {0, 0 };
a1436 74

#endif /* WIN32 */
#else /* USE_SPIN_LOCKS */

#ifndef WIN32
/* pthreads-based locks */
struct pthread_mlock_t
{
  volatile unsigned int c;
  pthread_mutex_t l;
};
#define MLOCK_T struct pthread_mlock_t
#define CURRENT_THREAD        pthread_self()
static FORCEINLINE int pthread_acquire_lock (MLOCK_T *sl) {
  if(!pthread_mutex_lock(&(sl)->l)){
    sl->c++;
    return 0;
  }
  return 1;
}

static FORCEINLINE void pthread_release_lock (MLOCK_T *sl) {
  --sl->c;
  pthread_mutex_unlock(&(sl)->l);
}

static FORCEINLINE int pthread_try_lock (MLOCK_T *sl) {
  if(!pthread_mutex_trylock(&(sl)->l)){
    sl->c++;
    return 1;
  }
  return 0;
}

static FORCEINLINE int pthread_init_lock (MLOCK_T *sl) {
  pthread_mutexattr_t attr;
  sl->c=0;
  if(pthread_mutexattr_init(&attr)) return 1;
  if(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;
  if(pthread_mutex_init(&sl->l, &attr)) return 1;
  pthread_mutexattr_destroy(&attr);
  return 0;
}

static FORCEINLINE int pthread_islocked (MLOCK_T *sl) {
  if(!pthread_try_lock(sl)){
    int ret = (sl->c != 0);
    pthread_mutex_unlock(sl);
    return ret;
  }
  return 0;
}

#define INITIAL_LOCK(sl)      pthread_init_lock(sl)
#define ACQUIRE_LOCK(sl)      pthread_acquire_lock(sl)
#define RELEASE_LOCK(sl)      pthread_release_lock(sl)
#define TRY_LOCK(sl)          pthread_try_lock(sl)
#define IS_LOCKED(sl)         pthread_islocked(sl)

static MLOCK_T magic_init_mutex = {0, PTHREAD_MUTEX_INITIALIZER };
#if HAVE_MORECORE
static MLOCK_T morecore_mutex = {0, PTHREAD_MUTEX_INITIALIZER };
#endif /* HAVE_MORECORE */

#else /* WIN32 */
/* Win32 critical sections */
#define MLOCK_T         CRITICAL_SECTION
#define CURRENT_THREAD  GetCurrentThreadId()
#define INITIAL_LOCK(s) (!InitializeCriticalSectionAndSpinCount((s), 4000)
#define ACQUIRE_LOCK(s) ( (!((s))->DebugInfo ? INITIAL_LOCK((s)) : 0), !EnterCriticalSection((s)), 0)
#define RELEASE_LOCK(s) ( LeaveCriticalSection((s)), 0 )
#define TRY_LOCK(s)     ( TryEnterCriticalSection((s)) )
#define IS_LOCKED(s)    ( (s)->LockCount >= 0 )
#define NULL_LOCK_INITIALIZER
a1437 3
#if HAVE_MORECORE
static MLOCK_T morecore_mutex;
#endif /* HAVE_MORECORE */
a1438 4
#endif /* USE_SPIN_LOCKS */
#endif /* USE_LOCKS == 1 */

/* -----------------------  User-defined locks ------------------------ */
a1439 19
#if USE_LOCKS > 1
/* Define your own lock implementation here */
/* #define INITIAL_LOCK(sl)  ... */
/* #define ACQUIRE_LOCK(sl)  ... */
/* #define RELEASE_LOCK(sl)  ... */
/* #define TRY_LOCK(sl) ... */
/* #define IS_LOCKED(sl) ... */
/* #define NULL_LOCK_INITIALIZER ... */

static MLOCK_T magic_init_mutex = NULL_LOCK_INITIALIZER;
#if HAVE_MORECORE
static MLOCK_T morecore_mutex = NULL_LOCK_INITIALIZER;
#endif /* HAVE_MORECORE */
#endif /* USE_LOCKS > 1 */

/* -----------------------  Lock-based state ------------------------ */


#if USE_LOCKS
d1488 4
a1491 4
           | Size of previous chunk (if P = 1)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
d1493 7
a1499 7
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
d1501 2
a1502 2
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1510 4
a1513 4
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
d1515 7
a1521 7
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
d1523 2
a1524 2
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1532 2
a1533 2
                                                                     |0|
                                                                     +-+
d1578 10
a1587 10
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.
d1590 7
a1596 7
        (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
        PINUSE_BIT in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.
a1659 2

  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
a1663 1
#define FLAG4_BIT           (SIZE_T_FOUR)
a1664 1
#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)
d1672 1
a1672 1
#define chunksize(p)        ((p)->head & ~(FLAG_BITS))
d1682 1
a1682 1
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
d1724 2
a1725 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1728 7
a1734 7
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
d1737 1
a1737 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1745 2
a1746 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1749 14
a1762 14
            |             Forward pointer to next chunk of same size        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk of same size       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to left child (child[0])                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to right child (child[1])                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to parent                                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             bin index of this chunk                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space                                      .
            .                                                               |
d1765 1
a1765 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
a1963 5
  Trim support
    Fields holding the amount of unused topmost memory that should trigger
    timming, and a counter to force periodic scanning to release unused
    non-topmost segments.

a1966 4

  Extension support
    A void* pointer and a size_t field that can be used to help implement
    extensions to this malloc.
a1987 1
  size_t     release_checks;
a1997 2
  void*      extp;      /* Unused but available for extensions */
  size_t     exts;
a2020 2
#if !ONLY_MSPACES

a2024 3

#endif /* !ONLY_MSPACES */

d2049 1
a2049 1
 (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
d2053 1
a2053 10
  (((S) + (mparams.granularity - SIZE_T_ONE))\
   & ~(mparams.granularity - SIZE_T_ONE))


/* For mmap, use granularity alignment on windows, else page-align */
#ifdef WIN32
#define mmap_align(S) granularity_align(S)
#else
#define mmap_align(S) page_align(S)
#endif
d2204 1
a2204 16
#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define compute_tree_index(S, I)\
{\
  unsigned int X = S >> TREEBIN_SHIFT;\
  if (X == 0)\
    I = 0;\
  else if (X > 0xFFFF)\
    I = NTREEBINS-1;\
  else {\
    unsigned int K;\
    __asm__("bsrl\t%1, %0\n\t" : "=r" (K) : "g"  (X));\
    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
  }\
}

#elif defined(_MSC_VER) && _MSC_VER>=1300
d2214 1
a2214 1
    _BitScanReverse((DWORD *) &K, X);\
d2269 1
a2269 8
#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define compute_bit2idx(X, I)\
{\
  unsigned int J;\
  __asm__("bsfl\t%1, %0\n\t" : "=r" (J) : "g" (X));\
  I = (bindex_t)J;\
}
#elif defined(_MSC_VER) && _MSC_VER>=1300
d2273 1
a2273 1
  _BitScanForward((DWORD *) &J, X);\
d2438 3
a2440 3
          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
        s = *((size_t *) buf);
        close(fd);
d2444 1
a2444 1
        s = (size_t)(time(0) ^ (size_t)0x55555555U);
a2455 1
#if !ONLY_MSPACES
a2458 1
#endif
d2465 1
a2465 1
                           DEFAULT_GRANULARITY : mparams.page_size);
d2482 7
a2488 7
        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
        (sizeof(int) < 4)  ||
        (MALLOC_ALIGNMENT < (size_t)8U) ||
        ((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
        ((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
        ((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||
        ((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))
d2529 1
a2529 1
  size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */
d2537 1
a2537 1
  assert(!pinuse(chunk_plus_offset(p, sz)));
d2567 1
a2567 1
  size_t sz = chunksize(p);
d2632 2
a2633 2
              u->parent->child[1] == u ||
              *((tbinptr*)(u->parent)) == u);
d2635 3
a2637 3
        assert(u->child[0]->parent == u);
        assert(u->child[0] != u);
        do_check_tree(m, u->child[0]);
d2640 3
a2642 3
        assert(u->child[1]->parent == u);
        assert(u->child[1] != u);
        do_check_tree(m, u->child[1]);
d2645 1
a2645 1
        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
d2683 1
a2683 1
        do_check_inuse_chunk(m, q);
d2697 2
a2698 2
        if (p == x)
          return 1;
d2709 2
a2710 2
        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
        sizebits <<= 1;
d2713 5
a2717 5
        tchunkptr u = t;
        do {
          if (u == (tchunkptr)x)
            return 1;
        } while ((u = u->fd) != t);
d2735 13
a2747 13
             q != m->top && q->head != FENCEPOST_HEAD) {
        sum += chunksize(q);
        if (cinuse(q)) {
          assert(!bin_find(m, q));
          do_check_inuse_chunk(m, q);
        }
        else {
          assert(q == m->dv || bin_find(m, q));
          assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */
          do_check_free_chunk(m, q);
        }
        lastq = q;
        q = next_chunk(q);
d2774 1
a2774 1
    /*assert(m->topsize == chunksize(m->top)); redundant */
d2798 12
a2809 12
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          size_t sz = chunksize(q);
          sum += sz;
          if (!cinuse(q)) {
            mfree += sz;
            ++nfree;
          }
          q = next_chunk(q);
        }
        s = s->next;
d2840 8
a2847 8
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          if (!cinuse(q))
            used -= chunksize(q);
          q = next_chunk(q);
        }
        s = s->next;
d2898 1
a2898 1
                   (B == smallbin_at(M,I) || ok_address(M, B)))) {\
d2958 14
a2971 14
        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
        K <<= 1;\
        if (*C != 0)\
          T = *C;\
        else if (RTCHECK(ok_address(M, C))) {\
          *C = X;\
          X->parent = T;\
          X->fd = X->bk = X;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d2974 12
a2985 12
        tchunkptr F = T->fd;\
        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
          T->fd = F->bk = X;\
          X->fd = F;\
          X->bk = T;\
          X->parent = 0;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d3025 1
a3025 1
        ((R = *(RP = &(X->child[0]))) != 0)) {\
d3028 2
a3029 2
             (*(CP = &(R->child[0])) != 0)) {\
        R = *(RP = CP);\
d3032 1
a3032 1
        *RP = 0;\
d3034 1
a3034 1
        CORRUPTION_ERROR_ACTION(M);\
d3042 1
a3042 1
        clear_treemap(M, X->index);\
d3046 1
a3046 1
        XP->child[0] = R;\
d3048 1
a3048 1
        XP->child[1] = R;\
d3054 18
a3071 18
        tchunkptr C0, C1;\
        R->parent = XP;\
        if ((C0 = X->child[0]) != 0) {\
          if (RTCHECK(ok_address(M, C0))) {\
            R->child[0] = C0;\
            C0->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
        if ((C1 = X->child[1]) != 0) {\
          if (RTCHECK(ok_address(M, C1))) {\
            R->child[1] = C1;\
            C1->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
d3074 1
a3074 1
        CORRUPTION_ERROR_ACTION(M);\
d3098 1
a3098 1
   ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
d3121 1
a3121 1
  size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3135 1
a3135 1
        m->least_addr = mm;
d3137 1
a3137 1
        m->max_footprint = m->footprint;
d3158 2
a3159 1
    size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3161 1
a3161 1
                                  oldmmsize, newmmsize, 1);
d3171 1
a3171 1
        m->least_addr = cp;
d3173 1
a3173 1
        m->max_footprint = m->footprint;
d3229 1
a3229 1
                           size_t nb) {
d3269 1
d3366 10
a3375 10
        asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
        /* Adjust to end on a page boundary */
        if (!is_page_aligned(base))
          asize += (page_align((size_t)base) - (size_t)base);
        /* Can't call MORECORE if size is negative when treated as signed */
        if (asize < HALF_MAX_SIZE_T &&
            (br = (char*)(CALL_MORECORE(asize))) == base) {
          tbase = base;
          tsize = asize;
        }
d3383 3
a3385 3
          (br = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
        tbase = br;
        tsize = asize;
d3391 13
a3403 13
        if (asize < HALF_MAX_SIZE_T &&
            asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
          size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
          if (esize < HALF_MAX_SIZE_T) {
            char* end = (char*)CALL_MORECORE(esize);
            if (end != CMFAIL)
              asize += esize;
            else {            /* Can't use; try to release */
              (void) CALL_MORECORE(-asize);
              br = CMFAIL;
            }
          }
        }
d3406 2
a3407 2
        tbase = br;
        tsize = asize;
d3410 1
a3410 1
        disable_contiguous(m); /* Don't try contiguous path in the future */
d3422 3
a3424 3
        tbase = mp;
        tsize = rsize;
        mmap_flag = IS_MMAPPED_BIT;
d3439 5
a3443 5
        size_t ssize = end - br;
        if (ssize > nb + TOP_FOOT_SIZE) {
          tbase = br;
          tsize = ssize;
        }
a3457 1
      m->release_checks = MAX_RELEASE_CHECK_RATE;
a3458 1
#if !ONLY_MSPACES
d3460 5
a3464 7
        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
      else
#endif
      {
        /* Offset top by embedded malloc_state */
        mchunkptr mn = next_chunk(mem2chunk(m));
        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
a3470 1
      /* Only consider most recent segment if traversal suppressed */
d3472 1
a3472 1
        sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
d3474 5
a3478 5
          !is_extern_segment(sp) &&
          (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&
          segment_holds(sp, m->top)) { /* append */
        sp->size += tsize;
        init_top(m, m->top, m->topsize + tsize);
d3481 15
a3495 15
        if (tbase < m->least_addr)
          m->least_addr = tbase;
        sp = &m->seg;
        while (sp != 0 && sp->base != tbase + tsize)
          sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
        if (sp != 0 &&
            !is_extern_segment(sp) &&
            (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
          char* oldbase = sp->base;
          sp->base = tbase;
          sp->size += tsize;
          return prepend_alloc(m, tbase, oldbase, nb);
        }
        else
          add_segment(m, tbase, tsize, mmap_flag);
a3519 1
  int nsegs = 0;
a3525 1
    ++nsegs;
d3531 19
a3549 19
        tchunkptr tp = (tchunkptr)p;
        assert(segment_holds(sp, (char*)sp));
        if (p == m->dv) {
          m->dv = 0;
          m->dvsize = 0;
        }
        else {
          unlink_large_chunk(m, tp);
        }
        if (CALL_MUNMAP(base, size) == 0) {
          released += size;
          m->footprint -= size;
          /* unlink obsoleted record */
          sp = pred;
          sp->next = next;
        }
        else { /* back out if cannot unmap */
          insert_large_chunk(m, tp, psize);
        }
a3551 2
    if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */
      break;
a3554 3
  /* Reset check counter */
  m->release_checks = ((nsegs > MAX_RELEASE_CHECK_RATE)?
                       nsegs : MAX_RELEASE_CHECK_RATE);
d3567 1
a3567 1
                      SIZE_T_ONE) * unit;
d3571 28
a3598 28
        if (is_mmapped_segment(sp)) {
          if (HAVE_MMAP &&
              sp->size >= extra &&
              !has_segment_link(m, sp)) { /* can't shrink if pinned */
            size_t newsize = sp->size - extra;
            /* Prefer mremap, fall back to munmap */
            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
              released = extra;
            }
          }
        }
        else if (HAVE_MORECORE) {
          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
          ACQUIRE_MORECORE_LOCK();
          {
            /* Make sure end of memory is where we last set it. */
            char* old_br = (char*)(CALL_MORECORE(0));
            if (old_br == sp->base + sp->size) {
              char* rel_br = (char*)(CALL_MORECORE(-extra));
              char* new_br = (char*)(CALL_MORECORE(0));
              if (rel_br != CMFAIL && new_br < old_br)
                released = old_br - new_br;
            }
          }
          RELEASE_MORECORE_LOCK();
        }
d3602 4
a3605 4
        sp->size -= released;
        m->footprint -= released;
        init_top(m, m->top, m->topsize - released);
        check_top_chunk(m, m->top);
d3614 1
a3614 1
    if (released == 0 && m->topsize > m->trim_check)
d3639 3
a3641 3
        v = t;
        if ((rsize = trem) == 0)
          break;
d3646 1
a3646 1
        rst = rt;
d3648 2
a3649 2
        t = rst; /* set t to least subtree holding sizes > nb */
        break;
d3680 9
a3688 9
        unlink_large_chunk(m, v);
        if (rsize < MIN_CHUNK_SIZE)
          set_inuse_and_pinuse(m, v, (rsize + nb));
        else {
          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
          set_size_and_pinuse_of_free_chunk(r, rsize);
          insert_chunk(m, r, rsize);
        }
        return chunk2mem(v);
d3721 1
a3721 1
        set_inuse_and_pinuse(m, v, (rsize + nb));
d3723 3
a3725 3
        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
        set_size_and_pinuse_of_free_chunk(r, rsize);
        replace_dv(m, r, rsize);
d3752 1
a3752 1
                ok_next(oldp, next) && ok_pinuse(next))) {
d3755 1
a3755 1
        newp = mmap_resize(m, oldp, nb);
d3757 8
a3764 8
        size_t rsize = oldsize - nb;
        newp = oldp;
        if (rsize >= MIN_CHUNK_SIZE) {
          mchunkptr remainder = chunk_plus_offset(newp, nb);
          set_inuse(m, newp, nb);
          set_inuse(m, remainder, rsize);
          extra = chunk2mem(remainder);
        }
d3767 9
a3775 9
        /* Expand into top */
        size_t newsize = oldsize + m->topsize;
        size_t newtopsize = newsize - nb;
        mchunkptr newtop = chunk_plus_offset(oldp, nb);
        set_inuse(m, oldp, nb);
        newtop->head = newtopsize |PINUSE_BIT;
        m->top = newtop;
        m->topsize = newtopsize;
        newp = oldp;
d3788 1
a3788 1
        internal_free(m, extra);
d3796 3
a3798 3
        size_t oc = oldsize - overhead_for(oldp);
        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);
        internal_free(m, oldmem);
d3835 28
a3862 28
        /*
          Find an aligned spot inside chunk.  Since we need to give
          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
          the first calculation places us at a spot with less than
          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
          We've allocated enough total room so that this is always
          possible.
        */
        char* br = (char*)mem2chunk((size_t)(((size_t)(mem +
                                                       alignment -
                                                       SIZE_T_ONE)) &
                                             -alignment));
        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
          br : br+alignment;
        mchunkptr newp = (mchunkptr)pos;
        size_t leadsize = pos - (char*)(p);
        size_t newsize = chunksize(p) - leadsize;

        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
          newp->prev_foot = p->prev_foot + leadsize;
          newp->head = (newsize|CINUSE_BIT);
        }
        else { /* Otherwise, give back leader, use the rest */
          set_inuse(m, newp, newsize);
          set_inuse(m, p, leadsize);
          leader = chunk2mem(p);
        }
        p = newp;
d3867 8
a3874 8
        size_t size = chunksize(p);
        if (size > nb + MIN_CHUNK_SIZE) {
          size_t remainder_size = size - nb;
          mchunkptr remainder = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
          set_inuse(m, remainder, remainder_size);
          trailer = chunk2mem(remainder);
        }
d3882 1
a3882 1
        internal_free(m, leader);
d3885 1
a3885 1
        internal_free(m, trailer);
d3896 4
a3899 4
                     size_t n_elements,
                     size_t* sizes,
                     int opts,
                     void* chunks[]) {
d3988 1
a3988 1
        size = element_size;
d3990 1
a3990 1
        size = request2size(sizes[i]);
d4031 2
a4032 2
          (Remainderless means that there are too few excess bytes to
          represent as a chunk.)
d4034 1
a4034 1
          chunk adjacent to the one used for the most recent small request.
d4036 1
a4036 1
          saving remainder in dv.
d4041 1
a4041 1
          if it is better fitting than dv chunk, splitting if necessary.
d4061 10
a4070 10
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(gm, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(gm, b, p, idx);
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
d4074 30
a4103 30
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(gm, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(gm, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(gm, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(gm, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }

        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }
d4111 2
a4112 2
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
d4120 4
a4123 4
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
        gm->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
d4126 4
a4129 4
        size_t dvs = gm->dvsize;
        gm->dvsize = 0;
        gm->dv = 0;
        set_inuse_and_pinuse(gm, p, dvs);
d4179 67
a4245 77
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if ((prevsize & IS_MMAPPED_BIT) != 0) {
            prevsize &= ~IS_MMAPPED_BIT;
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
d4264 1
a4264 1
        (req / n_elements != elem_size))
d4301 1
a4301 1
                                 void* chunks[]) {
d4307 1
a4307 1
                                   void* chunks[]) {
a4381 1
  m->release_checks = MAX_RELEASE_CHECK_RATE;
a4382 3
  m->extp = 0;
  m->exts = 0;
#if !ONLY_MSPACES
a4383 1
#endif
d4398 1
a4398 1
                 (capacity + TOP_FOOT_SIZE + msize));
d4435 2
a4436 2
          CALL_MUNMAP(base, size) == 0)
        freed += size;
d4468 10
a4477 10
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        b = smallbin_at(ms, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(ms, b, p, idx);
        set_inuse_and_pinuse(ms, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4481 30
a4510 30
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(ms, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(ms, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            set_inuse_and_pinuse(ms, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(ms, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }

        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }
d4518 2
a4519 2
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4527 4
a4530 4
        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
        ms->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
d4533 4
a4536 4
        size_t dvs = ms->dvsize;
        ms->dvsize = 0;
        ms->dv = 0;
        set_inuse_and_pinuse(ms, p, dvs);
d4580 67
a4646 77
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if ((prevsize & IS_MMAPPED_BIT) != 0) {
            prevsize &= ~IS_MMAPPED_BIT;
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);

          if (is_small(psize)) {
            insert_small_chunk(fm, p, psize);
            check_free_chunk(fm, p);
          }
          else {
            tchunkptr tp = (tchunkptr)p;
            insert_large_chunk(fm, tp, psize);
            check_free_chunk(fm, p);
            if (--fm->release_checks == 0)
              release_unused_segments(fm);
          }
          goto postaction;
        }
d4667 1
a4667 1
        (req / n_elements != elem_size))
d4710 1
a4710 1
                                 size_t elem_size, void* chunks[]) {
d4721 1
a4721 1
                                   size_t sizes[], void* chunks[]) {
d4756 1
a4756 1
  size_t result = 0;
d4761 1
a4761 3
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
d4767 1
a4767 1
  size_t result = 0;
d4772 1
a4772 3
  else {
    USAGE_ERROR_ACTION(ms,ms);
  }
a4786 9
size_t mspace_usable_size(void* mem) {
  if (mem != 0) {
    mchunkptr p = mem2chunk(mem);
    if (cinuse(p))
      return chunksize(p) - overhead_for(p);
  }
  return 0;
}

d4842 1
a4842 1
         size = MINIMUM_MORECORE_SIZE;
d4844 1
a4844 1
         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
d4847 1
a4847 1
        return (void *) MFAIL;
d4877 2
a4878 2
         PoolDeallocate(*ptr);
         *ptr = 0;
a4886 9
    V2.8.4 (not yet released)
      * Fix bad error check in mspace_footprint
      * Adaptations for ptmalloc, courtesy of Wolfram Gloger.
      * Reentrant spin locks, courtesy of Earl Chew and others
      * Win32 improvements, courtesy of Niall Douglas and Earl Chew
      * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options
      * Various small adjustments to reduce warnings on some compilers
      * Extension hook in malloc_state

d4892 1
a4892 1
        in create_mspace_with_base
d4911 1
a4911 1
        removing need for emulation on most platforms without sbrk.
d4916 2
a4917 2
        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
        Aaron Bachmann,  Emery Berger, and others.
d4930 1
a4930 1
        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
d4941 1
a4941 1
        Thanks to Michael Pachos for motivation and help.
d4945 2
a4946 2
        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
        and Anonymous.
d4948 1
a4948 1
        helping test this.)
d4951 2
a4952 2
        leads to  more fragmentation in some programs and doesn't
        seem to help in any others.
d4960 1
a4960 1
        Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
d4966 11
a4976 11
         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
          (e.g. WIN32 platforms)
         * Cleanup header file inclusion for WIN32 platforms
         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
           memory allocation routines
         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
           usage of 'assert' in non-WIN32 code
         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
           avoid infinite loop
d4988 1
a4988 1
        foreign sbrks
d4994 1
a4994 1
        Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5002 1
a5002 1
        avoid surprises about sbrk alignment conventions.
d5004 1
a5004 1
        (raymond@@es.ele.tue.nl) for the suggestion.
d5007 1
a5007 1
        courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5009 1
a5009 1
        H.J. Lu (hjl@@gnu.ai.mit.edu)
d5015 2
a5016 2
        the work required to undo bad preallocations exceeds
        the work saved in good cases for most test programs.
d5018 2
a5019 2
        no scheme using them consistently outperforms those that don't
        given above changes.
d5025 1
a5025 1
        Paul Wilson (wilson@@cs.texas.edu) for the suggestion.
d5029 1
a5029 1
        (wmglo@@Dent.MED.Uni-Muenchen.DE).
d5045 1
a5045 1
         (eliminating old malloc_find_space & malloc_clean_bin)
d5049 1
a5049 1
          from kpv@@research.att.com
d5057 2
a5058 2
          with gcc & native cc (hp, dec only) allowing
          Detlefs & Zorn comparison study (in SIGPLAN Notices.)
d5062 1
a5062 1
         structure of old version,  but most details differ.)
a5064 2


@


1.11.18.4
log
@	* Remove ptmalloc3 once and for all.
@
text
@d2 10
d17 1
a17 1
* Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)
d20 2
a21 2
	   ftp://gee.cs.oswego.edu/pub/misc/malloc.c
	 Check before installing!
d60 1
a60 1
					  8 or 16 bytes (if 8byte sizes)
d66 1
a66 1
			  8-byte ptrs:  32 bytes    (including overhead)
d124 4
a127 2
       program, consider instead using ptmalloc, which is derived from
       a version of this malloc. (See http://www.malloc.de).
d168 5
a172 1
  system allocation routines, which is often just 1.
d222 2
a223 1
to size_t precision unless they are explicitly casted.
d246 8
a253 1
  overridden on a per-mspace basis for mspace versions.)
d328 1
a328 1
MORECORE_CONTIGUOUS       default: 1 (true)
d342 6
d362 1
a362 1
MMAP_CLEARS               default: 1 on unix
d364 1
a364 1
  for standard unix mmap using /dev/zero.
d371 2
a372 2
  this setting has no effect. (On most x86s, the asm version is only
  slightly faster than the C version.)
d408 2
a409 2
				system_info.dwAllocationGranularity in WIN32,
				otherwise 64K.
d469 13
d502 5
a506 1
#define MMAP_CLEARS 0 /* WINCE and some others apparently don't clear */
d555 7
d619 7
d638 3
d700 22
d724 3
d728 3
d889 1
a889 1
		than current total if trimming has occurred.
d894 2
a895 2
	       back to system via malloc_trim. ("ideally" means that
	       it ignores page restrictions etc.)
d1173 1
a1173 1
				 size_t elem_size, void* chunks[]);
d1180 1
a1180 1
				   size_t sizes[], void* chunks[]);
d1288 45
d1380 2
d1389 1
a1389 1
/* Annoying but necessary to avoid errors on some plaftorms */
d1393 1
d1451 3
a1453 3
	   (dev_zero_fd = open("/dev/zero", O_RDWR), \
	    mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
	    mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
d1460 1
a1460 1
static void* win32mmap(size_t size) {
d1466 1
a1466 1
static void* win32direct_mmap(size_t size) {
d1468 1
a1468 1
			   PAGE_READWRITE);
d1473 1
a1473 1
static int win32munmap(void* ptr, size_t size) {
d1475 1
a1475 1
  char* cptr = ptr;
d1480 1
a1480 1
	minfo.State != MEM_COMMIT || minfo.RegionSize > size)
d1499 2
a1500 1
#define CALL_MREMAP(addr, osz, nsz, mv) MFAIL
a1517 2
#if USE_LOCKS

d1530 12
d1544 3
d1548 127
a1674 6
/* By default use posix locks */
#include <pthread.h>
#define MLOCK_T pthread_mutex_t
#define INITIAL_LOCK(l)      pthread_mutex_init(l, NULL)
#define ACQUIRE_LOCK(l)      pthread_mutex_lock(l)
#define RELEASE_LOCK(l)      pthread_mutex_unlock(l)
d1676 1
d1678 1
a1678 1
static MLOCK_T morecore_mutex = PTHREAD_MUTEX_INITIALIZER;
d1681 2
a1682 1
static MLOCK_T magic_init_mutex = PTHREAD_MUTEX_INITIALIZER;
d1684 21
a1704 5
#else /* WIN32 */
/*
   Because lock-protected regions have bounded times, and there
   are no recursive lock calls, we can use simple spinlocks.
*/
d1706 4
a1709 11
#define MLOCK_T long
static int win32_acquire_lock (MLOCK_T *sl) {
  for (;;) {
#ifdef InterlockedCompareExchangePointer
    if (!InterlockedCompareExchange(sl, 1, 0))
      return 0;
#else  /* Use older void* version */
    if (!InterlockedCompareExchange((void**)sl, (void*)1, (void*)0))
      return 0;
#endif /* InterlockedCompareExchangePointer */
    Sleep (0);
d1711 1
d1714 8
a1721 2
static void win32_release_lock (MLOCK_T *sl) {
  InterlockedExchange (sl, 0);
d1724 31
a1754 3
#define INITIAL_LOCK(l)      *(l)=0
#define ACQUIRE_LOCK(l)      win32_acquire_lock(l)
#define RELEASE_LOCK(l)      win32_release_lock(l)
a1757 1
static MLOCK_T magic_init_mutex;
d1759 4
d1764 19
d1831 4
a1834 4
	   | Size of previous chunk (if P = 1)                             |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
	 | Size of this chunk                                         1| +-+
d1836 7
a1842 7
	 |                                                               |
	 +-                                                             -+
	 |                                                               |
	 +-                                                             -+
	 |                                                               :
	 +-      size - sizeof(size_t) available payload bytes          -+
	 :                                                               |
d1844 2
a1845 2
	 |                                                               |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1853 4
a1856 4
	   | User payload (must be in use, or we would have merged!)       |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
	 | Size of this chunk                                         0| +-+
d1858 7
a1864 7
	 | Next pointer                                                  |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 | Prev pointer                                                  |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 |                                                               :
	 +-      size - sizeof(struct chunk) unused bytes               -+
	 :                                                               |
d1866 2
a1867 2
	 | Size of this chunk                                            |
	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1875 2
a1876 2
								     |0|
								     +-+
d1921 10
a1930 10
	the one bordering the end of available memory). It is treated
	specially.  Top is never included in any bin, is used only if
	no other chunk is available, and is released back to the
	system if it is very large (see M_TRIM_THRESHOLD).  In effect,
	the top chunk is treated as larger (and thus less well
	fitting) than any other available chunk.  The top chunk
	doesn't update its trailing size field since there is no next
	contiguous chunk that would have to index off it. However,
	space is still allocated for it (TOP_FOOT_SIZE) to enable
	separation or merging when space is extended.
d1933 7
a1939 7
	(IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
	PINUSE_BIT in their head fields.  Because they are allocated
	one-by-one, each must carry its own prev_foot field, which is
	also used to hold the offset this chunk has within its mmapped
	region, which is needed to preserve alignment. Each mmapped
	chunk is trailed by the first two fields of a fake next-chunk
	for sake of usage checks.
d2003 2
d2009 1
d2011 1
d2019 1
a2019 1
#define chunksize(p)        ((p)->head & ~(INUSE_BITS))
d2029 1
a2029 1
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~INUSE_BITS)))
d2071 2
a2072 2
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2075 7
a2081 7
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
d2084 1
a2084 1
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2092 2
a2093 2
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2096 14
a2109 14
	    |             Forward pointer to next chunk of same size        |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk of same size       |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to left child (child[0])                  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to right child (child[1])                 |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Pointer to parent                                 |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             bin index of this chunk                           |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space                                      .
	    .                                                               |
d2112 1
a2112 1
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2311 5
d2319 4
d2344 1
d2355 2
d2380 2
d2386 3
d2413 1
a2413 1
 (((S) + (mparams.page_size)) & ~(mparams.page_size - SIZE_T_ONE))
d2417 10
a2426 1
  (((S) + (mparams.granularity)) & ~(mparams.granularity - SIZE_T_ONE))
d2577 16
a2592 1
#if defined(__GNUC__) && defined(i386)
d2602 1
a2602 1
    __asm__("bsrl %1,%0\n\t" : "=r" (K) : "rm"  (X));\
d2657 8
a2664 1
#if defined(__GNUC__) && defined(i386)
d2668 1
a2668 1
  __asm__("bsfl %1,%0\n\t" : "=r" (J) : "rm" (X));\
d2833 3
a2835 3
	  read(fd, buf, sizeof(buf)) == sizeof(buf)) {
	s = *((size_t *) buf);
	close(fd);
d2839 1
a2839 1
	s = (size_t)(time(0) ^ (size_t)0x55555555U);
d2851 1
d2855 1
d2862 1
a2862 1
			   DEFAULT_GRANULARITY : mparams.page_size);
d2879 7
a2885 7
	(MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
	(sizeof(int) < 4)  ||
	(MALLOC_ALIGNMENT < (size_t)8U) ||
	((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
	((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
	((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||
	((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))
d2926 1
a2926 1
  size_t  sz = chunksize(p);
d2934 1
a2934 1
  assert(!next_pinuse(p));
d2964 1
a2964 1
  size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);
d3029 2
a3030 2
	      u->parent->child[1] == u ||
	      *((tbinptr*)(u->parent)) == u);
d3032 3
a3034 3
	assert(u->child[0]->parent == u);
	assert(u->child[0] != u);
	do_check_tree(m, u->child[0]);
d3037 3
a3039 3
	assert(u->child[1]->parent == u);
	assert(u->child[1] != u);
	do_check_tree(m, u->child[1]);
d3042 1
a3042 1
	assert(chunksize(u->child[0]) < chunksize(u->child[1]));
d3080 1
a3080 1
	do_check_inuse_chunk(m, q);
d3094 2
a3095 2
	if (p == x)
	  return 1;
d3106 2
a3107 2
	t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
	sizebits <<= 1;
d3110 5
a3114 5
	tchunkptr u = t;
	do {
	  if (u == (tchunkptr)x)
	    return 1;
	} while ((u = u->fd) != t);
d3132 13
a3144 13
	     q != m->top && q->head != FENCEPOST_HEAD) {
	sum += chunksize(q);
	if (cinuse(q)) {
	  assert(!bin_find(m, q));
	  do_check_inuse_chunk(m, q);
	}
	else {
	  assert(q == m->dv || bin_find(m, q));
	  assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */
	  do_check_free_chunk(m, q);
	}
	lastq = q;
	q = next_chunk(q);
d3171 1
a3171 1
    assert(m->topsize == chunksize(m->top));
d3195 12
a3206 12
	mchunkptr q = align_as_chunk(s->base);
	while (segment_holds(s, q) &&
	       q != m->top && q->head != FENCEPOST_HEAD) {
	  size_t sz = chunksize(q);
	  sum += sz;
	  if (!cinuse(q)) {
	    mfree += sz;
	    ++nfree;
	  }
	  q = next_chunk(q);
	}
	s = s->next;
d3237 8
a3244 8
	mchunkptr q = align_as_chunk(s->base);
	while (segment_holds(s, q) &&
	       q != m->top && q->head != FENCEPOST_HEAD) {
	  if (!cinuse(q))
	    used -= chunksize(q);
	  q = next_chunk(q);
	}
	s = s->next;
d3295 1
a3295 1
		   (B == smallbin_at(M,I) || ok_address(M, B)))) {\
d3355 14
a3368 14
	tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
	K <<= 1;\
	if (*C != 0)\
	  T = *C;\
	else if (RTCHECK(ok_address(M, C))) {\
	  *C = X;\
	  X->parent = T;\
	  X->fd = X->bk = X;\
	  break;\
	}\
	else {\
	  CORRUPTION_ERROR_ACTION(M);\
	  break;\
	}\
d3371 12
a3382 12
	tchunkptr F = T->fd;\
	if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
	  T->fd = F->bk = X;\
	  X->fd = F;\
	  X->bk = T;\
	  X->parent = 0;\
	  break;\
	}\
	else {\
	  CORRUPTION_ERROR_ACTION(M);\
	  break;\
	}\
d3422 1
a3422 1
	((R = *(RP = &(X->child[0]))) != 0)) {\
d3425 2
a3426 2
	     (*(CP = &(R->child[0])) != 0)) {\
	R = *(RP = CP);\
d3429 1
a3429 1
	*RP = 0;\
d3431 1
a3431 1
	CORRUPTION_ERROR_ACTION(M);\
d3439 1
a3439 1
	clear_treemap(M, X->index);\
d3443 1
a3443 1
	XP->child[0] = R;\
d3445 1
a3445 1
	XP->child[1] = R;\
d3451 18
a3468 18
	tchunkptr C0, C1;\
	R->parent = XP;\
	if ((C0 = X->child[0]) != 0) {\
	  if (RTCHECK(ok_address(M, C0))) {\
	    R->child[0] = C0;\
	    C0->parent = R;\
	  }\
	  else\
	    CORRUPTION_ERROR_ACTION(M);\
	}\
	if ((C1 = X->child[1]) != 0) {\
	  if (RTCHECK(ok_address(M, C1))) {\
	    R->child[1] = C1;\
	    C1->parent = R;\
	  }\
	  else\
	    CORRUPTION_ERROR_ACTION(M);\
	}\
d3471 1
a3471 1
	CORRUPTION_ERROR_ACTION(M);\
d3495 1
a3495 1
   (m == gm)? dlmalloc(b) : mspace_malloc(m, b)
d3518 1
a3518 1
  size_t mmsize = granularity_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3532 1
a3532 1
	m->least_addr = mm;
d3534 1
a3534 1
	m->max_footprint = m->footprint;
d3555 1
a3555 2
    size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +
					 CHUNK_ALIGN_MASK);
d3557 1
a3557 1
				  oldmmsize, newmmsize, 1);
d3567 1
a3567 1
	m->least_addr = cp;
d3569 1
a3569 1
	m->max_footprint = m->footprint;
d3625 1
a3625 1
			   size_t nb) {
a3664 1

d3761 10
a3770 10
	asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
	/* Adjust to end on a page boundary */
	if (!is_page_aligned(base))
	  asize += (page_align((size_t)base) - (size_t)base);
	/* Can't call MORECORE if size is negative when treated as signed */
	if (asize < HALF_MAX_SIZE_T &&
	    (br = (char*)(CALL_MORECORE(asize))) == base) {
	  tbase = base;
	  tsize = asize;
	}
d3778 3
a3780 3
	  (br = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
	tbase = br;
	tsize = asize;
d3786 13
a3798 13
	if (asize < HALF_MAX_SIZE_T &&
	    asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
	  size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
	  if (esize < HALF_MAX_SIZE_T) {
	    char* end = (char*)CALL_MORECORE(esize);
	    if (end != CMFAIL)
	      asize += esize;
	    else {            /* Can't use; try to release */
	      CALL_MORECORE(-asize);
	      br = CMFAIL;
	    }
	  }
	}
d3801 2
a3802 2
	tbase = br;
	tsize = asize;
d3805 1
a3805 1
	disable_contiguous(m); /* Don't try contiguous path in the future */
d3817 3
a3819 3
	tbase = mp;
	tsize = rsize;
	mmap_flag = IS_MMAPPED_BIT;
d3834 5
a3838 5
	size_t ssize = end - br;
	if (ssize > nb + TOP_FOOT_SIZE) {
	  tbase = br;
	  tsize = ssize;
	}
d3853 1
d3855 1
d3857 7
a3863 5
	init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
      else {
	/* Offset top by embedded malloc_state */
	mchunkptr mn = next_chunk(mem2chunk(m));
	init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
d3870 1
d3872 1
a3872 1
	sp = sp->next;
d3874 5
a3878 5
	  !is_extern_segment(sp) &&
	  (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&
	  segment_holds(sp, m->top)) { /* append */
	sp->size += tsize;
	init_top(m, m->top, m->topsize + tsize);
d3881 15
a3895 15
	if (tbase < m->least_addr)
	  m->least_addr = tbase;
	sp = &m->seg;
	while (sp != 0 && sp->base != tbase + tsize)
	  sp = sp->next;
	if (sp != 0 &&
	    !is_extern_segment(sp) &&
	    (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
	  char* oldbase = sp->base;
	  sp->base = tbase;
	  sp->size += tsize;
	  return prepend_alloc(m, tbase, oldbase, nb);
	}
	else
	  add_segment(m, tbase, tsize, mmap_flag);
d3920 1
d3927 1
d3933 19
a3951 19
	tchunkptr tp = (tchunkptr)p;
	assert(segment_holds(sp, (char*)sp));
	if (p == m->dv) {
	  m->dv = 0;
	  m->dvsize = 0;
	}
	else {
	  unlink_large_chunk(m, tp);
	}
	if (CALL_MUNMAP(base, size) == 0) {
	  released += size;
	  m->footprint -= size;
	  /* unlink obsoleted record */
	  sp = pred;
	  sp->next = next;
	}
	else { /* back out if cannot unmap */
	  insert_large_chunk(m, tp, psize);
	}
d3954 2
d3959 3
d3974 1
a3974 1
		      SIZE_T_ONE) * unit;
d3978 28
a4005 28
	if (is_mmapped_segment(sp)) {
	  if (HAVE_MMAP &&
	      sp->size >= extra &&
	      !has_segment_link(m, sp)) { /* can't shrink if pinned */
	    size_t newsize = sp->size - extra;
	    /* Prefer mremap, fall back to munmap */
	    if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
		(CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
	      released = extra;
	    }
	  }
	}
	else if (HAVE_MORECORE) {
	  if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
	    extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
	  ACQUIRE_MORECORE_LOCK();
	  {
	    /* Make sure end of memory is where we last set it. */
	    char* old_br = (char*)(CALL_MORECORE(0));
	    if (old_br == sp->base + sp->size) {
	      char* rel_br = (char*)(CALL_MORECORE(-extra));
	      char* new_br = (char*)(CALL_MORECORE(0));
	      if (rel_br != CMFAIL && new_br < old_br)
		released = old_br - new_br;
	    }
	  }
	  RELEASE_MORECORE_LOCK();
	}
d4009 4
a4012 4
	sp->size -= released;
	m->footprint -= released;
	init_top(m, m->top, m->topsize - released);
	check_top_chunk(m, m->top);
d4021 1
a4021 1
    if (released == 0)
d4046 3
a4048 3
	v = t;
	if ((rsize = trem) == 0)
	  break;
d4053 1
a4053 1
	rst = rt;
d4055 2
a4056 2
	t = rst; /* set t to least subtree holding sizes > nb */
	break;
d4087 9
a4095 9
	unlink_large_chunk(m, v);
	if (rsize < MIN_CHUNK_SIZE)
	  set_inuse_and_pinuse(m, v, (rsize + nb));
	else {
	  set_size_and_pinuse_of_inuse_chunk(m, v, nb);
	  set_size_and_pinuse_of_free_chunk(r, rsize);
	  insert_chunk(m, r, rsize);
	}
	return chunk2mem(v);
d4128 1
a4128 1
	set_inuse_and_pinuse(m, v, (rsize + nb));
d4130 3
a4132 3
	set_size_and_pinuse_of_inuse_chunk(m, v, nb);
	set_size_and_pinuse_of_free_chunk(r, rsize);
	replace_dv(m, r, rsize);
d4159 1
a4159 1
		ok_next(oldp, next) && ok_pinuse(next))) {
d4162 1
a4162 1
	newp = mmap_resize(m, oldp, nb);
d4164 8
a4171 8
	size_t rsize = oldsize - nb;
	newp = oldp;
	if (rsize >= MIN_CHUNK_SIZE) {
	  mchunkptr remainder = chunk_plus_offset(newp, nb);
	  set_inuse(m, newp, nb);
	  set_inuse(m, remainder, rsize);
	  extra = chunk2mem(remainder);
	}
d4174 9
a4182 9
	/* Expand into top */
	size_t newsize = oldsize + m->topsize;
	size_t newtopsize = newsize - nb;
	mchunkptr newtop = chunk_plus_offset(oldp, nb);
	set_inuse(m, oldp, nb);
	newtop->head = newtopsize |PINUSE_BIT;
	m->top = newtop;
	m->topsize = newtopsize;
	newp = oldp;
d4195 1
a4195 1
	internal_free(m, extra);
d4203 3
a4205 3
	size_t oc = oldsize - overhead_for(oldp);
	memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);
	internal_free(m, oldmem);
d4242 28
a4269 28
	/*
	  Find an aligned spot inside chunk.  Since we need to give
	  back leading space in a chunk of at least MIN_CHUNK_SIZE, if
	  the first calculation places us at a spot with less than
	  MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
	  We've allocated enough total room so that this is always
	  possible.
	*/
	char* br = (char*)mem2chunk((size_t)(((size_t)(mem +
						       alignment -
						       SIZE_T_ONE)) &
					     -alignment));
	char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
	  br : br+alignment;
	mchunkptr newp = (mchunkptr)pos;
	size_t leadsize = pos - (char*)(p);
	size_t newsize = chunksize(p) - leadsize;

	if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
	  newp->prev_foot = p->prev_foot + leadsize;
	  newp->head = (newsize|CINUSE_BIT);
	}
	else { /* Otherwise, give back leader, use the rest */
	  set_inuse(m, newp, newsize);
	  set_inuse(m, p, leadsize);
	  leader = chunk2mem(p);
	}
	p = newp;
d4274 8
a4281 8
	size_t size = chunksize(p);
	if (size > nb + MIN_CHUNK_SIZE) {
	  size_t remainder_size = size - nb;
	  mchunkptr remainder = chunk_plus_offset(p, nb);
	  set_inuse(m, p, nb);
	  set_inuse(m, remainder, remainder_size);
	  trailer = chunk2mem(remainder);
	}
d4289 1
a4289 1
	internal_free(m, leader);
d4292 1
a4292 1
	internal_free(m, trailer);
d4303 4
a4306 4
		     size_t n_elements,
		     size_t* sizes,
		     int opts,
		     void* chunks[]) {
d4395 1
a4395 1
	size = element_size;
d4397 1
a4397 1
	size = request2size(sizes[i]);
d4438 2
a4439 2
	  (Remainderless means that there are too few excess bytes to
	  represent as a chunk.)
d4441 1
a4441 1
	  chunk adjacent to the one used for the most recent small request.
d4443 1
a4443 1
	  saving remainder in dv.
d4448 1
a4448 1
	  if it is better fitting than dv chunk, splitting if necessary.
d4468 10
a4477 10
	mchunkptr b, p;
	idx += ~smallbits & 1;       /* Uses next bin if idx empty */
	b = smallbin_at(gm, idx);
	p = b->fd;
	assert(chunksize(p) == small_index2size(idx));
	unlink_first_small_chunk(gm, b, p, idx);
	set_inuse_and_pinuse(gm, p, small_index2size(idx));
	mem = chunk2mem(p);
	check_malloced_chunk(gm, mem, nb);
	goto postaction;
d4481 30
a4510 30
	if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
	  mchunkptr b, p, r;
	  size_t rsize;
	  bindex_t i;
	  binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
	  binmap_t leastbit = least_bit(leftbits);
	  compute_bit2idx(leastbit, i);
	  b = smallbin_at(gm, i);
	  p = b->fd;
	  assert(chunksize(p) == small_index2size(i));
	  unlink_first_small_chunk(gm, b, p, i);
	  rsize = small_index2size(i) - nb;
	  /* Fit here cannot be remainderless if 4byte sizes */
	  if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
	    set_inuse_and_pinuse(gm, p, small_index2size(i));
	  else {
	    set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
	    r = chunk_plus_offset(p, nb);
	    set_size_and_pinuse_of_free_chunk(r, rsize);
	    replace_dv(gm, r, rsize);
	  }
	  mem = chunk2mem(p);
	  check_malloced_chunk(gm, mem, nb);
	  goto postaction;
	}

	else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
	  check_malloced_chunk(gm, mem, nb);
	  goto postaction;
	}
d4518 2
a4519 2
	check_malloced_chunk(gm, mem, nb);
	goto postaction;
d4527 4
a4530 4
	mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
	gm->dvsize = rsize;
	set_size_and_pinuse_of_free_chunk(r, rsize);
	set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
d4533 4
a4536 4
	size_t dvs = gm->dvsize;
	gm->dvsize = 0;
	gm->dv = 0;
	set_inuse_and_pinuse(gm, p, dvs);
d4586 77
a4662 67
	size_t psize = chunksize(p);
	mchunkptr next = chunk_plus_offset(p, psize);
	if (!pinuse(p)) {
	  size_t prevsize = p->prev_foot;
	  if ((prevsize & IS_MMAPPED_BIT) != 0) {
	    prevsize &= ~IS_MMAPPED_BIT;
	    psize += prevsize + MMAP_FOOT_PAD;
	    if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
	      fm->footprint -= psize;
	    goto postaction;
	  }
	  else {
	    mchunkptr prev = chunk_minus_offset(p, prevsize);
	    psize += prevsize;
	    p = prev;
	    if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
	      if (p != fm->dv) {
		unlink_chunk(fm, p, prevsize);
	      }
	      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
		fm->dvsize = psize;
		set_free_with_pinuse(p, psize, next);
		goto postaction;
	      }
	    }
	    else
	      goto erroraction;
	  }
	}

	if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
	  if (!cinuse(next)) {  /* consolidate forward */
	    if (next == fm->top) {
	      size_t tsize = fm->topsize += psize;
	      fm->top = p;
	      p->head = tsize | PINUSE_BIT;
	      if (p == fm->dv) {
		fm->dv = 0;
		fm->dvsize = 0;
	      }
	      if (should_trim(fm, tsize))
		sys_trim(fm, 0);
	      goto postaction;
	    }
	    else if (next == fm->dv) {
	      size_t dsize = fm->dvsize += psize;
	      fm->dv = p;
	      set_size_and_pinuse_of_free_chunk(p, dsize);
	      goto postaction;
	    }
	    else {
	      size_t nsize = chunksize(next);
	      psize += nsize;
	      unlink_chunk(fm, next, nsize);
	      set_size_and_pinuse_of_free_chunk(p, psize);
	      if (p == fm->dv) {
		fm->dvsize = psize;
		goto postaction;
	      }
	    }
	  }
	  else
	    set_free_with_pinuse(p, psize, next);
	  insert_chunk(fm, p, psize);
	  check_free_chunk(fm, p);
	  goto postaction;
	}
d4681 1
a4681 1
	(req / n_elements != elem_size))
d4718 1
a4718 1
				 void* chunks[]) {
d4724 1
a4724 1
				   void* chunks[]) {
d4799 1
d4801 3
d4805 1
d4820 1
a4820 1
		 (capacity + TOP_FOOT_SIZE + msize));
d4857 2
a4858 2
	  CALL_MUNMAP(base, size) == 0)
	freed += size;
d4890 10
a4899 10
	mchunkptr b, p;
	idx += ~smallbits & 1;       /* Uses next bin if idx empty */
	b = smallbin_at(ms, idx);
	p = b->fd;
	assert(chunksize(p) == small_index2size(idx));
	unlink_first_small_chunk(ms, b, p, idx);
	set_inuse_and_pinuse(ms, p, small_index2size(idx));
	mem = chunk2mem(p);
	check_malloced_chunk(ms, mem, nb);
	goto postaction;
d4903 30
a4932 30
	if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
	  mchunkptr b, p, r;
	  size_t rsize;
	  bindex_t i;
	  binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
	  binmap_t leastbit = least_bit(leftbits);
	  compute_bit2idx(leastbit, i);
	  b = smallbin_at(ms, i);
	  p = b->fd;
	  assert(chunksize(p) == small_index2size(i));
	  unlink_first_small_chunk(ms, b, p, i);
	  rsize = small_index2size(i) - nb;
	  /* Fit here cannot be remainderless if 4byte sizes */
	  if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
	    set_inuse_and_pinuse(ms, p, small_index2size(i));
	  else {
	    set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
	    r = chunk_plus_offset(p, nb);
	    set_size_and_pinuse_of_free_chunk(r, rsize);
	    replace_dv(ms, r, rsize);
	  }
	  mem = chunk2mem(p);
	  check_malloced_chunk(ms, mem, nb);
	  goto postaction;
	}

	else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
	  check_malloced_chunk(ms, mem, nb);
	  goto postaction;
	}
d4940 2
a4941 2
	check_malloced_chunk(ms, mem, nb);
	goto postaction;
d4949 4
a4952 4
	mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
	ms->dvsize = rsize;
	set_size_and_pinuse_of_free_chunk(r, rsize);
	set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
d4955 4
a4958 4
	size_t dvs = ms->dvsize;
	ms->dvsize = 0;
	ms->dv = 0;
	set_inuse_and_pinuse(ms, p, dvs);
d5002 77
a5078 67
	size_t psize = chunksize(p);
	mchunkptr next = chunk_plus_offset(p, psize);
	if (!pinuse(p)) {
	  size_t prevsize = p->prev_foot;
	  if ((prevsize & IS_MMAPPED_BIT) != 0) {
	    prevsize &= ~IS_MMAPPED_BIT;
	    psize += prevsize + MMAP_FOOT_PAD;
	    if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
	      fm->footprint -= psize;
	    goto postaction;
	  }
	  else {
	    mchunkptr prev = chunk_minus_offset(p, prevsize);
	    psize += prevsize;
	    p = prev;
	    if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
	      if (p != fm->dv) {
		unlink_chunk(fm, p, prevsize);
	      }
	      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
		fm->dvsize = psize;
		set_free_with_pinuse(p, psize, next);
		goto postaction;
	      }
	    }
	    else
	      goto erroraction;
	  }
	}

	if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
	  if (!cinuse(next)) {  /* consolidate forward */
	    if (next == fm->top) {
	      size_t tsize = fm->topsize += psize;
	      fm->top = p;
	      p->head = tsize | PINUSE_BIT;
	      if (p == fm->dv) {
		fm->dv = 0;
		fm->dvsize = 0;
	      }
	      if (should_trim(fm, tsize))
		sys_trim(fm, 0);
	      goto postaction;
	    }
	    else if (next == fm->dv) {
	      size_t dsize = fm->dvsize += psize;
	      fm->dv = p;
	      set_size_and_pinuse_of_free_chunk(p, dsize);
	      goto postaction;
	    }
	    else {
	      size_t nsize = chunksize(next);
	      psize += nsize;
	      unlink_chunk(fm, next, nsize);
	      set_size_and_pinuse_of_free_chunk(p, psize);
	      if (p == fm->dv) {
		fm->dvsize = psize;
		goto postaction;
	      }
	    }
	  }
	  else
	    set_free_with_pinuse(p, psize, next);
	  insert_chunk(fm, p, psize);
	  check_free_chunk(fm, p);
	  goto postaction;
	}
d5099 1
a5099 1
	(req / n_elements != elem_size))
d5142 1
a5142 1
				 size_t elem_size, void* chunks[]) {
d5153 1
a5153 1
				   size_t sizes[], void* chunks[]) {
d5188 1
a5188 1
  size_t result;
d5193 3
a5195 1
  USAGE_ERROR_ACTION(ms,ms);
d5201 1
a5201 1
  size_t result;
d5206 3
a5208 1
  USAGE_ERROR_ACTION(ms,ms);
d5223 9
d5287 1
a5287 1
	 size = MINIMUM_MORECORE_SIZE;
d5289 1
a5289 1
	 ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
d5292 1
a5292 1
	return (void *) MFAIL;
d5322 2
a5323 2
	 PoolDeallocate(*ptr);
	 *ptr = 0;
d5332 9
d5346 1
a5346 1
	in create_mspace_with_base
d5365 1
a5365 1
	removing need for emulation on most platforms without sbrk.
d5370 2
a5371 2
	Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
	Aaron Bachmann,  Emery Berger, and others.
d5384 1
a5384 1
	Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
d5395 1
a5395 1
	Thanks to Michael Pachos for motivation and help.
d5399 2
a5400 2
	Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
	and Anonymous.
d5402 1
a5402 1
	helping test this.)
d5405 2
a5406 2
	leads to  more fragmentation in some programs and doesn't
	seem to help in any others.
d5414 1
a5414 1
	Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
d5420 11
a5430 11
	 * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
	  (e.g. WIN32 platforms)
	 * Cleanup header file inclusion for WIN32 platforms
	 * Cleanup code to avoid Microsoft Visual C++ compiler complaints
	 * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
	   memory allocation routines
	 * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
	 * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
	   usage of 'assert' in non-WIN32 code
	 * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
	   avoid infinite loop
d5442 1
a5442 1
	foreign sbrks
d5448 1
a5448 1
	Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5456 1
a5456 1
	avoid surprises about sbrk alignment conventions.
d5458 1
a5458 1
	(raymond@@es.ele.tue.nl) for the suggestion.
d5461 1
a5461 1
	courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d5463 1
a5463 1
	H.J. Lu (hjl@@gnu.ai.mit.edu)
d5469 2
a5470 2
	the work required to undo bad preallocations exceeds
	the work saved in good cases for most test programs.
d5472 2
a5473 2
	no scheme using them consistently outperforms those that don't
	given above changes.
d5479 1
a5479 1
	Paul Wilson (wilson@@cs.texas.edu) for the suggestion.
d5483 1
a5483 1
	(wmglo@@Dent.MED.Uni-Muenchen.DE).
d5499 1
a5499 1
	 (eliminating old malloc_find_space & malloc_clean_bin)
d5503 1
a5503 1
	  from kpv@@research.att.com
d5511 2
a5512 2
	  with gcc & native cc (hp, dec only) allowing
	  Detlefs & Zorn comparison study (in SIGPLAN Notices.)
d5516 1
a5516 1
	 structure of old version,  but most details differ.)
d5519 2
@


1.10
log
@* cygmalloc.h (MSPACES): Define.  This dropped through the cracks after the
last malloc update.
* dcrt0.cc: Fix a comment.
* malloc.cc (internal_malloc): Fix definition so that it can be safely coerced.
@
text
@d7 1
a7 1
* Version 2.8.2 Sun Jun 12 16:05:14 2005  Doug Lea  (dl at gee)
d22 1
a22 1
     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.0.h
d204 4
d212 1
a212 1
MALLOC_ALIGNMENT         default: 8
d298 1
a298 1
  though. Internally, we only call if with arguments less than half
d365 6
d409 1
a409 1
  disable trimming completely, you can set to -1U. Note that the trick
d437 1
a437 1
  disable mmap by setting to -1U.
a440 2
#define DEFAULT_MMAP_THRESHOLD (16 * 1024 * 1024)

d444 2
a445 2
#endif
#endif
d460 1
a460 1
#endif
d467 2
a468 2
#endif
#endif
d472 1
a472 1
#endif
d475 5
a479 1
#endif
d482 1
a482 1
#endif
d486 1
a486 1
#else
d488 2
a489 2
#endif
#endif
d491 2
a492 2
#define MALLOC_ALIGNMENT (8U)
#endif
d495 1
a495 1
#endif
d498 1
a498 1
#endif
d501 1
a501 1
#endif
d504 1
a504 1
#endif
d507 1
a507 1
#endif
d510 1
a510 1
#endif
d513 1
a513 1
#endif
d516 1
a516 1
#endif
d520 1
a520 1
#else
d522 2
a523 2
#endif
#endif
d526 1
a526 1
#endif
d530 1
a530 1
#else
d532 2
a533 2
#endif
#endif
d536 1
a536 1
#else
d539 1
a539 1
#endif
d542 2
a543 2
#endif
#endif
d547 4
a550 4
#else
#define DEFAULT_GRANULARITY (64U * 1024U)
#endif
#endif
d553 5
a557 5
#define DEFAULT_TRIM_THRESHOLD (2U * 1024U * 1024U)
#else
#define DEFAULT_TRIM_THRESHOLD (-1U)
#endif
#endif
d560 5
a564 5
#define DEFAULT_MMAP_THRESHOLD (256U * 1024U)
#else
#define DEFAULT_MMAP_THRESHOLD (-1U)
#endif
#endif
d567 1
a567 1
#endif
d570 1
a570 1
#endif
d573 1
a573 1
#endif
d576 1
a576 1
#endif
d618 1
a618 1
#else
d633 2
a634 2
#endif
#endif
d638 1
a638 1
#endif
d658 1
d661 1
a661 1
#endif
d685 1
a685 1
  freed, free(p) will by default cuase the current program to abort.
d756 1
a756 1
  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1U disables trimming)
d771 14
a784 1
size_t dlmalloc_footprint();
d810 1
a810 1
#endif
d993 1
a993 1
void  dlmalloc_stats();
d995 1
a995 1
#endif
d1096 6
d1109 1
a1109 1
#endif
d1128 1
a1128 1
#endif
d1132 1
a1132 1
#endif
d1148 1
a1148 1
#endif
d1154 1
a1154 1
#endif
d1157 1
a1157 1
#endif
d1160 1
a1160 1
#endif
d1164 1
a1164 1
#else
d1166 2
a1167 2
#endif
#else
d1169 1
a1169 1
#endif
d1172 1
a1172 1
#endif
d1176 2
a1177 2
#endif
#endif
d1181 1
a1181 1
#endif
d1184 2
a1185 2
#endif
#endif
d1189 1
a1189 1
#else
d1192 3
a1194 3
#endif
#endif
#endif
d1232 1
a1232 1
#                define malloc_getpagesize (4096U)
d1249 9
a1257 2
/* The size_t value with all bits set */
#define MAX_SIZE_T           (~(size_t)0)
d1260 1
a1260 1
#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - 1)
d1284 2
a1285 2
#define IS_MMAPPED_BIT       (0U)
#define USE_MMAP_BIT         (0U)
d1290 3
a1292 3
#else
#define IS_MMAPPED_BIT       (1U)
#define USE_MMAP_BIT         (1U)
d1299 1
a1299 1
#endif
d1303 1
a1303 1
#else
d1314 1
a1314 1
#endif
d1317 1
a1317 1
#else
d1353 2
a1354 2
#endif
#endif
d1358 1
a1358 1
#else
d1360 1
a1360 1
#endif
d1364 1
a1364 1
#else
d1366 1
a1366 1
#endif
d1371 4
d1389 2
a1390 2
  * If using secure footers, magic_init_mutex ensures that mparams.magic is
    initialized exactly once.
d1397 1
d1403 1
a1403 1
#endif
a1404 1
#if FOOTERS & !INSECURE
a1405 1
#endif
d1407 1
a1407 1
#else
d1422 1
a1422 1
#endif
d1431 1
d1436 1
a1436 2
#endif
#if FOOTERS & !INSECURE
d1438 1
a1438 2
#endif
#endif
d1441 1
a1441 1
#else
d1443 2
a1444 1
#endif
d1449 1
a1449 1
#else
d1452 1
a1452 1
#endif
d1454 1
a1454 1
#if USE_LOCKS && FOOTERS && !INSECURE
d1457 1
a1457 1
#else
d1460 1
a1460 1
#endif
d1619 2
a1620 2
#define CHUNK_OVERHEAD      (SIZE_T_SIZE*2U)
#else
d1622 1
a1622 1
#endif
d1625 1
a1625 1
#define MMAP_CHUNK_OVERHEAD (SIZE_T_SIZE*2U)
d1627 1
a1627 1
#define MMAP_FOOT_PAD       (SIZE_T_SIZE*4U)
d1631 1
a1631 1
  (size_t)(((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK))
d1634 2
a1635 2
#define chunk2mem(p)        ((void*)((char*)(p)       + (SIZE_T_SIZE*2U)))
#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - (SIZE_T_SIZE*2U)))
d1641 1
a1641 1
#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - 1U)
d1662 2
a1663 2
#define PINUSE_BIT          (1U)
#define CINUSE_BIT          (2U)
d1710 1
a1710 1
#else
d1712 1
a1712 1
#endif
d1829 1
a1829 1
  initial space. Segments also include flags holding properties of
d1863 16
a1878 4
  Except for the initial segment of an mstate (which holds its own
  embedded segment record), segment records for one segment are
  kept in a different segment (the one in effect when the new
  segment was created).  So unmapping segments is delicate.
d1885 1
a1885 1
  flag_t       sflags;           /* mmap flag */
d1888 3
d1973 1
a1973 1
#define SMALLBIN_WIDTH    (1U << SMALLBIN_SHIFT)
d1975 2
a1976 2
#define MIN_LARGE_SIZE    (1U << TREEBIN_SHIFT)
#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - 1)
d1996 1
a1996 1
#endif
d2049 1
a2049 1
 (((S) + (mparams.page_size)) & ~(mparams.page_size - 1))
d2053 1
a2053 1
  (((S) + (mparams.granularity)) & ~(mparams.granularity - 1))
d2056 1
a2056 1
   (((size_t)(S) & (mparams.page_size - 1)) == 0)
d2058 1
a2058 1
   (((size_t)(S) & (mparams.granularity - 1)) == 0)
d2088 1
a2088 1
#else
d2090 1
a2090 1
#endif
d2098 1
a2098 1
  (pad_request(MIN_CHUNK_SIZE + sizeof(struct malloc_segment)))
d2111 4
a2114 1
#define PREACTION(M)  ((use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
d2116 1
a2116 1
#else
d2120 1
a2120 1
#endif
d2124 1
a2124 1
#endif
d2126 1
a2126 1
#endif
d2147 1
a2147 1
#else
d2151 1
a2151 1
#endif
d2155 1
a2155 1
#endif
d2157 1
a2157 1
#endif
d2170 1
a2170 1
#else
d2190 1
a2190 1
#endif
d2218 1
a2218 1
#else
d2236 1
a2236 1
#endif
d2245 1
a2245 1
    ((SIZE_T_BITSIZE-1) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
d2249 2
a2250 2
   (((size_t)(1U) << (((i) >> 1) + TREEBIN_SHIFT)) |  \
   (((size_t)((i) & 1U)) << (((i) >> 1U) + TREEBIN_SHIFT - 1)))
d2277 1
a2277 1
#else
d2281 1
a2281 1
#else
d2293 2
a2294 2
#endif
#endif
d2344 1
a2344 1
#else
d2349 1
a2349 1
#endif
d2354 1
a2354 1
#else
d2356 1
a2356 1
#endif
d2363 1
a2363 1
#else
d2365 2
a2366 2
#endif
#else
d2368 1
a2368 1
#endif
d2390 1
a2390 1
#else
d2414 1
a2414 1
#endif
d2419 1
a2419 1
static void init_mparams() {
d2421 9
a2432 1
      size_t s;
d2443 1
a2443 1
#endif
d2446 2
a2447 2
      s |= 8U;    /* ensure nonzero */
      s &= ~7U;   /* improve chances of fault for bad values */
a2448 4
      ACQUIRE_MAGIC_INIT_LOCK();
      if (mparams.magic == 0)
	mparams.magic = s;
      RELEASE_MAGIC_INIT_LOCK();
d2450 11
a2460 12

#else
    mparams.magic = (size_t)0x58585858U;
#endif

    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
#if MORECORE_CONTIGUOUS
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
#else
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
#endif
d2466 1
a2466 1
#else
d2473 1
a2473 1
#endif
d2484 5
a2488 5
	(MALLOC_ALIGNMENT < 8U) ||
	((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-1))    != 0) ||
	((MCHUNK_SIZE         & (MCHUNK_SIZE-1))         != 0) ||
	((mparams.granularity & (mparams.granularity-1)) != 0) ||
	((mparams.page_size   & (mparams.page_size-1))   != 0))
d2491 1
d2549 1
a2549 1
  assert((len & (mparams.page_size-1)) == 0);
d2657 1
a2657 1
  int empty = (m->treemap & (1 << i)) == 0;
d2668 1
a2668 1
  unsigned int empty = (m->smallmap & (1 << i)) == 0;
d2709 1
a2709 1
	t = t->child[(sizebits >> (SIZE_T_BITSIZE-1)) & 1];
d2783 1
a2783 1
#endif
d2793 3
a2795 3
      size_t nfree = 1; /* top always free */
      size_t free = m->topsize + TOP_FOOT_SIZE;
      size_t sum = free;
d2804 1
a2804 1
	    free += sz;
d2814 1
a2814 1
      nm.hblkhd   = m->max_footprint - sum;
d2816 2
a2817 1
      nm.uordblks = m->footprint - free;
d2825 1
a2825 1
#endif
d2958 1
a2958 1
	tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-1)) & 1]);\
d3095 1
a3095 1
#else
d3098 1
a3098 1
   ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
d3101 1
a3101 1
#else
d3104 2
a3105 2
#endif
#endif
d3121 1
a3121 1
  size_t mmsize = granularity_align(nb + 6*SIZE_T_SIZE + CHUNK_ALIGN_MASK);
d3153 1
a3153 1
      (oldsize - nb) <= 2U * mparams.granularity)
d3158 1
a3158 1
    size_t newmmsize = granularity_align(nb + 6 * SIZE_T_SIZE +
d3225 1
a3225 1
#endif
d3277 1
a3277 1
  char* rawsp = old_end - (ssize + 4*SIZE_T_SIZE + CHUNK_ALIGN_MASK);
d3293 4
a3296 4
  ss->base = tbase;
  ss->size = tsize;
  ss->sflags = mmapped;
  ss->next = m->seg.next;
d3313 1
a3313 1
    mchunkptr p = (mchunkptr)old_top;
d3315 3
a3317 3
    mchunkptr tn = chunk_plus_offset(p, psize);
    set_free_with_pinuse(p, psize, tn);
    insert_chunk(m, p, psize);
d3321 1
a3321 1
    }
d3340 1
a3340 1
	/*
d3347 2
a3348 2
       Note that under the default settings, if MORECORE ever returns
       failure for a request, and HAVE_MMAP is true, then mmap is
d3358 1
a3358 1
    char* brk = CMFAIL;
d3360 1
d3364 1
a3364 1
      char* base = (char *) CALL_MORECORE(0);
d3366 1
a3366 1
	size_t asize = granularity_align(nb + TOP_FOOT_SIZE + 1);
d3371 2
a3372 2
	if (asize < MAX_SIZE_T / 2 &&
	    (brk = (char*)(CALL_MORECORE(asize))) == base) {
d3374 1
a3374 1
	  tsize = (size_t)asize;
d3377 2
a3378 2
	}
	else {
d3380 1
a3380 1
      size_t asize = granularity_align(nb - m->topsize + TOP_FOOT_SIZE + 1);
d3382 4
a3385 4
      if (asize < MAX_SIZE_T / 2 &&
	  (brk = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
	tbase = brk;
	tsize = (size_t)asize;
d3389 21
a3409 1
    if (tbase == CMFAIL) {
d3411 1
a3411 9
	if (brk != CMFAIL) {   /* Try to use the space we did get */
	  char* end = (char*)CALL_MORECORE(0);
	  size_t esize = end - brk;
	  if (end != CMFAIL && end > brk && esize > nb + TOP_FOOT_SIZE) {
	    tbase = brk;
	    tsize = esize;
		}
	      }
	    }
d3414 1
a3414 1
	  }
d3417 1
a3417 1
    size_t req = nb + TOP_FOOT_SIZE + 1;
a3424 1
	}
d3427 1
d3430 3
a3432 3
    size_t asize = granularity_align(nb + TOP_FOOT_SIZE + 1);
    if (asize < MAX_SIZE_T / 2) {
      char* brk = CMFAIL;
d3435 1
a3435 1
      brk = (char*)(CALL_MORECORE(asize));
d3438 2
a3439 2
      if (brk != CMFAIL && end != CMFAIL && brk < end) {
	size_t ssize = end - brk;
d3441 1
a3441 1
	  tbase = brk;
a3457 1
      m->mflags = mparams.default_mflags;
d3465 1
a3465 1
    }
d3473 3
a3475 1
      if (sp != 0 && (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&
d3479 2
a3480 2
  }
  else {
d3486 3
a3488 1
	if (sp != 0 && (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
a3507 1
      }
d3509 1
d3511 2
a3512 2
    MALLOC_FAILURE_ACTION;
    return 0;
d3517 41
d3566 2
a3567 1
      size_t extra = ((m->topsize - pad + (unit-1)) / unit - 1) * unit;
d3570 11
a3580 9
      if ((sp->sflags & IS_MMAPPED_BIT) != 0) {
	if (HAVE_MMAP &&
	    sp->size >= extra &&
	    !has_segment_link(m, sp)) { /* can't shrink if pinned */
	  size_t newsize = sp->size - extra;
	  /* Prefer mremap, fall back to munmap */
	  if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
	      (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
	    released = extra;
d3583 13
a3595 13
      }
      else if (HAVE_MORECORE) {
	if (extra >= MAX_SIZE_T / 2) /* Avoid wrapping negative */
	  extra = (MAX_SIZE_T / 2) + 1 - unit;
	ACQUIRE_MORECORE_LOCK();
{
	  /* Make sure end of memory is where we last set it. */
	  char* old_brk = (char*)(CALL_MORECORE(0));
	  if (old_brk == sp->base + sp->size) {
	    char* rel_brk = (char*)(CALL_MORECORE(-extra));
	    char* new_brk = (char*)(CALL_MORECORE(0));
	    if (rel_brk != CMFAIL && new_brk < old_brk)
	      released = old_brk - new_brk;
d3597 1
d3599 1
a3599 2
	RELEASE_MORECORE_LOCK();
  }
d3610 2
a3611 48
    if (HAVE_MMAP && use_noncontiguous(m)) {
      msegmentptr pred = 0;
      msegmentptr sp = m->seg.next;
      while (sp != 0) {
	char* base = sp->base;
	size_t size = sp->size;
	msegmentptr next = sp->next;
	if ((sp->sflags & IS_MMAPPED_BIT)) {
	  mchunkptr p = align_as_chunk(base);
	  size_t psize = chunksize(p);
	  /* Can unmap if first chunk holds entire segment and not pinned */
	  if (!cinuse(p) &&
	      p != m->top &&
	      segment_holds(sp, (char*)pred) &&
	      (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
	    tchunkptr tp = (tchunkptr)p;
	    msegment pseg = *pred;
	    pseg.next = next;
	    if (p == m->dv) {
	      m->dv = 0;
	      m->dvsize = 0;
	    }
	    else {
	      unlink_large_chunk(m, tp);
	    }
	    if (CALL_MUNMAP(base, size) == 0) {
	      /* relink next-pointer of list predecessor */
	      msegmentptr pp = &m->seg;
	      while (pp != 0) {
		if (pp->next == pred) {
		  pp->next = sp;
		  break;
		}
		pp = pp->next;
	      }
	      *sp = pseg;
	      released += size;
	      m->footprint -= size;
	    }
	    else { /* back out if cannot unmap */
	      insert_large_chunk(m, tp, psize);
	    }
	  }
	}
	pred = sp;
	sp = next;
      }
    }
d3642 1
a3642 1
    }
d3644 1
a3644 1
      t = t->child[(sizebits >> (SIZE_T_BITSIZE-1)) & 1];
d3650 1
a3650 1
  }
d3813 2
a3814 2
  if ((alignment & (alignment-1)) != 0) {/* Ensure a power of 2 */
    size_t a = MALLOC_ALIGNMENT * 2;
d3820 3
a3822 1
    MALLOC_FAILURE_ACTION;
d3843 6
a3848 4
	char* brk = (char*)mem2chunk((size_t)(((size_t)(mem + alignment-1)) &
					      -alignment));
	char* pos = ((size_t)(brk - (char*)(p)) >= MIN_CHUNK_SIZE)?
	  brk : brk+alignment;
d3862 1
a3862 1
        p = newp;
d3904 1
a3904 1
  The opts arg has:
d3907 1
a3907 1
*/
d3913 1
a3913 1
  mchunkptr       p;              /* corresponding chunk */
d3916 1
a3916 1
  mchunkptr       array_chunk;    /* chunk for malloced ptr array */
d3919 1
a3919 1
  size_t          i;
d3931 1
a3931 1
      return (void **) internal_malloc(m, 0);
d4009 1
a4009 1
  }
d4015 1
a4015 1
#endif
d4060 1
a4060 1
      if ((smallbits & 0x3) != 0) { /* Remainderless fit to a smallbin. */
d4062 1
a4062 1
	idx += ~smallbits & 1;      /* Uses next bin if idx empty */
d4173 1
a4173 1
#else
d4175 1
a4175 1
#endif
d4255 1
a4255 1
#endif
d4276 6
d4285 1
a4285 1
#else
d4291 1
a4291 1
#endif
d4322 1
a4322 1
  return dlmemalign(pagesz, (bytes + pagesz - 1) & ~(pagesz - 1));
d4334 1
a4334 1
size_t dlmalloc_footprint() {
d4338 4
d4343 1
a4343 1
struct mallinfo dlmallinfo() {
d4346 1
a4346 1
#endif
d4365 1
a4365 1
#endif
d4377 1
a4398 1
    flag_t mmap_flag = IS_MMAPPED_BIT;
d4403 1
a4403 1
      m->seg.sflags = mmap_flag;
d4418 1
d4428 9
a4436 26
    size_t msize = ms->seg.size;
    flag_t mflag = ms->seg.sflags;
    /* free each segment, getting each link before unmapping it */
    msegmentptr sp = ms->seg.next;
    if (sp != 0) {
      msegmentptr next = sp->next;
      char* nextbase = sp->base;
      size_t nextsize = sp->size;
      flag_t nextflag = sp->sflags;
      while (sp != 0) {
	char* base = nextbase;
	size_t size = nextsize;
	flag_t flag = nextflag;
	if (next != 0) {
	  next = next->next;
	  if (next != 0) {
	    nextbase = next->base;
	    nextsize = next->size;
	    nextflag = next->sflags;
	  }
	}
	if ((flag & IS_MMAPPED_BIT) &&
	    CALL_MUNMAP(base, size) == 0)
	  freed += size;
	sp = next;
      }
a4437 5

    /* free main space */
    if ((mflag & IS_MMAPPED_BIT) &&
	CALL_MUNMAP((char*)(mem2chunk(ms)), msize) == 0)
      freed += msize;
d4467 1
a4467 1
      if ((smallbits & 0x3) != 0) { /* Remainderless fit to a smallbin. */
d4469 1
a4469 1
	idx += ~smallbits & 1;      /* Uses next bin if idx empty */
d4570 1
a4570 1
#else
d4572 1
a4572 1
#endif
d4679 6
d4687 1
a4687 1
    mchunkptr p  = mem2chunk(mem);
d4689 1
a4689 1
#else
d4691 1
a4691 1
#endif
d4766 12
a4777 1
#if !NO_MALLIFO
d4785 1
a4785 1
#endif
d4791 1
a4791 1
#endif
d4810 1
a4810 1
    * MORECORE need not handle negative arguments -- it may instead
d4887 14
a4900 1
    C2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
@


1.9
log
@* malloc.cc: Update to version 2.8.2.
@
text
@d3033 1
a3033 1
   (m == gm)? dlmalloc(b) : mspace_malloc(m, b)
@


1.9.2.1
log
@Check in base 2.8.2.
@
text
@d10 2
a11 2
           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
         Check before installing!
d50 1
a50 1
                                          8 or 16 bytes (if 8byte sizes)
d56 1
a56 1
                          8-byte ptrs:  32 bytes    (including overhead)
d368 2
a369 2
                                system_info.dwAllocationGranularity in WIN32,
                                otherwise 64K.
d431 2
d465 3
d771 1
a771 1
                than current total if trimming has occurred.
d776 2
a777 2
               back to system via malloc_trim. ("ideally" means that
               it ignores page restrictions etc.)
d1055 1
a1055 1
                                 size_t elem_size, void* chunks[]);
d1062 1
a1062 1
                                   size_t sizes[], void* chunks[]);
d1272 3
a1274 3
           (dev_zero_fd = open("/dev/zero", O_RDWR), \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
d1289 1
a1289 1
                           PAGE_READWRITE);
d1301 1
a1301 1
        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
d1446 4
a1449 4
           | Size of previous chunk (if P = 1)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
d1451 7
a1457 7
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
d1459 2
a1460 2
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1468 4
a1471 4
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
d1473 7
a1479 7
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
d1481 2
a1482 2
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1490 2
a1491 2
                                                                     |0|
                                                                     +-+
d1536 10
a1545 10
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.
d1548 7
a1554 7
        (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
        PINUSE_BIT in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.
d1682 2
a1683 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1686 7
a1692 7
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
d1695 1
a1695 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1703 2
a1704 2
            |             Size of previous chunk                            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d1707 14
a1720 14
            |             Forward pointer to next chunk of same size        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk of same size       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to left child (child[0])                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to right child (child[1])                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Pointer to parent                                 |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             bin index of this chunk                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space                                      .
            .                                                               |
d1723 1
a1723 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
d2370 3
a2372 3
          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
        s = *((size_t *) buf);
        close(fd);
d2376 1
a2376 1
        s = (size_t)(time(0) ^ (size_t)0x55555555U);
d2383 1
a2383 1
        mparams.magic = s;
d2402 1
a2402 1
                           DEFAULT_GRANULARITY : mparams.page_size);
d2419 7
a2425 7
        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
        (sizeof(int) < 4)  ||
        (MALLOC_ALIGNMENT < 8U) ||
        ((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-1))    != 0) ||
        ((MCHUNK_SIZE         & (MCHUNK_SIZE-1))         != 0) ||
        ((mparams.granularity & (mparams.granularity-1)) != 0) ||
        ((mparams.page_size   & (mparams.page_size-1))   != 0))
d2568 2
a2569 2
              u->parent->child[1] == u ||
              *((tbinptr*)(u->parent)) == u);
d2571 3
a2573 3
        assert(u->child[0]->parent == u);
        assert(u->child[0] != u);
        do_check_tree(m, u->child[0]);
d2576 3
a2578 3
        assert(u->child[1]->parent == u);
        assert(u->child[1] != u);
        do_check_tree(m, u->child[1]);
d2581 1
a2581 1
        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
d2619 1
a2619 1
        do_check_inuse_chunk(m, q);
d2633 2
a2634 2
        if (p == x)
          return 1;
d2645 2
a2646 2
        t = t->child[(sizebits >> (SIZE_T_BITSIZE-1)) & 1];
        sizebits <<= 1;
d2649 5
a2653 5
        tchunkptr u = t;
        do {
          if (u == (tchunkptr)x)
            return 1;
        } while ((u = u->fd) != t);
d2671 13
a2683 13
             q != m->top && q->head != FENCEPOST_HEAD) {
        sum += chunksize(q);
        if (cinuse(q)) {
          assert(!bin_find(m, q));
          do_check_inuse_chunk(m, q);
        }
        else {
          assert(q == m->dv || bin_find(m, q));
          assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */
          do_check_free_chunk(m, q);
        }
        lastq = q;
        q = next_chunk(q);
d2734 12
a2745 12
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          size_t sz = chunksize(q);
          sum += sz;
          if (!cinuse(q)) {
            free += sz;
            ++nfree;
          }
          q = next_chunk(q);
        }
        s = s->next;
d2775 8
a2782 8
        mchunkptr q = align_as_chunk(s->base);
        while (segment_holds(s, q) &&
               q != m->top && q->head != FENCEPOST_HEAD) {
          if (!cinuse(q))
            used -= chunksize(q);
          q = next_chunk(q);
        }
        s = s->next;
d2833 1
a2833 1
                   (B == smallbin_at(M,I) || ok_address(M, B)))) {\
d2893 14
a2906 14
        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-1)) & 1]);\
        K <<= 1;\
        if (*C != 0)\
          T = *C;\
        else if (RTCHECK(ok_address(M, C))) {\
          *C = X;\
          X->parent = T;\
          X->fd = X->bk = X;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d2909 12
a2920 12
        tchunkptr F = T->fd;\
        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
          T->fd = F->bk = X;\
          X->fd = F;\
          X->bk = T;\
          X->parent = 0;\
          break;\
        }\
        else {\
          CORRUPTION_ERROR_ACTION(M);\
          break;\
        }\
d2960 1
a2960 1
        ((R = *(RP = &(X->child[0]))) != 0)) {\
d2963 2
a2964 2
             (*(CP = &(R->child[0])) != 0)) {\
        R = *(RP = CP);\
d2967 1
a2967 1
        *RP = 0;\
d2969 1
a2969 1
        CORRUPTION_ERROR_ACTION(M);\
d2977 1
a2977 1
        clear_treemap(M, X->index);\
d2981 1
a2981 1
        XP->child[0] = R;\
d2983 1
a2983 1
        XP->child[1] = R;\
d2989 18
a3006 18
        tchunkptr C0, C1;\
        R->parent = XP;\
        if ((C0 = X->child[0]) != 0) {\
          if (RTCHECK(ok_address(M, C0))) {\
            R->child[0] = C0;\
            C0->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
        if ((C1 = X->child[1]) != 0) {\
          if (RTCHECK(ok_address(M, C1))) {\
            R->child[1] = C1;\
            C1->parent = R;\
          }\
          else\
            CORRUPTION_ERROR_ACTION(M);\
        }\
d3009 1
a3009 1
        CORRUPTION_ERROR_ACTION(M);\
d3051 1
a3051 1
  the PINUSE bit so frees can be checked. 
d3070 1
a3070 1
        m->least_addr = mm;
d3072 1
a3072 1
        m->max_footprint = m->footprint;
d3087 1
a3087 1
  if (oldsize >= nb + SIZE_T_SIZE && 
d3093 2
a3094 2
    size_t newmmsize = granularity_align(nb + 6 * SIZE_T_SIZE + 
                                         CHUNK_ALIGN_MASK);
d3096 1
a3096 1
                                  oldmmsize, newmmsize, 1);
d3106 1
a3106 1
        m->least_addr = cp;
d3108 1
a3108 1
        m->max_footprint = m->footprint;
d3164 1
a3164 1
                           size_t nb) {
d3256 1
a3256 1
}
d3275 1
a3275 1
  /*
d3298 1
a3298 1
      char* base = (char*)CALL_MORECORE(0);
d3300 10
a3309 10
        size_t asize = granularity_align(nb + TOP_FOOT_SIZE + 1);
        /* Adjust to end on a page boundary */
        if (!is_page_aligned(base))
          asize += (page_align((size_t)base) - (size_t)base);
        /* Can't call MORECORE if size is negative when treated as signed */
        if (asize < MAX_SIZE_T / 2 && 
            (brk = (char*)(CALL_MORECORE(asize))) == base) {
          tbase = base;
          tsize = (size_t)asize;
        }
d3311 2
a3312 2
    }
    else {
d3317 3
a3319 3
          (brk = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
        tbase = brk;
        tsize = (size_t)asize;
d3324 10
a3333 10
        disable_contiguous(m); /* Don't try contiguous path in the future */
        if (brk != CMFAIL) {   /* Try to use the space we did get */
          char* end = (char*)CALL_MORECORE(0);
          size_t esize = end - brk;
          if (end != CMFAIL && end > brk && esize > nb + TOP_FOOT_SIZE) {
            tbase = brk;
            tsize = esize;
          }
        }
    }
d3336 1
a3336 1
  }
d3344 4
a3347 3
        tbase = mp;
        tsize = rsize;
        mmap_flag = IS_MMAPPED_BIT;
a3349 1
  }
d3361 5
a3365 5
        size_t ssize = end - brk;
        if (ssize > nb + TOP_FOOT_SIZE) {
          tbase = brk;
          tsize = ssize;
        }
d3383 1
a3383 1
        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
d3385 4
a3388 4
        /* Offset top by embedded malloc_state */
        mchunkptr mn = next_chunk(mem2chunk(m));
        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
      }
d3395 1
a3395 1
        sp = sp->next;
d3397 18
a3414 18
          segment_holds(sp, m->top)) { /* append */
        sp->size += tsize;
        init_top(m, m->top, m->topsize + tsize);
      }
      else {
        if (tbase < m->least_addr)
          m->least_addr = tbase;
        sp = &m->seg;
        while (sp != 0 && sp->base != tbase + tsize)
          sp = sp->next;
        if (sp != 0 && (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
          char* oldbase = sp->base;
          sp->base = tbase;
          sp->size += tsize;
          return prepend_alloc(m, tbase, oldbase, nb);
        }
        else
          add_segment(m, tbase, tsize, mmap_flag);
d3427 1
a3428 1
  }
d3430 2
a3431 2
  MALLOC_FAILURE_ACTION;
  return 0;
d3448 10
a3457 10
        if (HAVE_MMAP &&
            sp->size >= extra &&
            !has_segment_link(m, sp)) { /* can't shrink if pinned */
          size_t newsize = sp->size - extra;
          /* Prefer mremap, fall back to munmap */
          if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
              (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
            released = extra;
          }
        }
d3460 15
a3474 15
        if (extra >= MAX_SIZE_T / 2) /* Avoid wrapping negative */
          extra = (MAX_SIZE_T / 2) + 1 - unit;
        ACQUIRE_MORECORE_LOCK();
        {
          /* Make sure end of memory is where we last set it. */
          char* old_brk = (char*)(CALL_MORECORE(0));
          if (old_brk == sp->base + sp->size) {
            char* rel_brk = (char*)(CALL_MORECORE(-extra));
            char* new_brk = (char*)(CALL_MORECORE(0));
            if (rel_brk != CMFAIL && new_brk < old_brk)
              released = old_brk - new_brk;
          }
        }
        RELEASE_MORECORE_LOCK();
      }
d3477 4
a3480 4
        sp->size -= released;
        m->footprint -= released;
        init_top(m, m->top, m->topsize - released);
        check_top_chunk(m, m->top);
d3489 42
a3530 42
        char* base = sp->base;
        size_t size = sp->size;
        msegmentptr next = sp->next;
        if ((sp->sflags & IS_MMAPPED_BIT)) {
          mchunkptr p = align_as_chunk(base);
          size_t psize = chunksize(p);
          /* Can unmap if first chunk holds entire segment and not pinned */
          if (!cinuse(p) &&
              p != m->top &&
              segment_holds(sp, (char*)pred) &&
              (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
            tchunkptr tp = (tchunkptr)p;
            msegment pseg = *pred;
            pseg.next = next;
            if (p == m->dv) {
              m->dv = 0;
              m->dvsize = 0;
            }
            else {
              unlink_large_chunk(m, tp);
            }
            if (CALL_MUNMAP(base, size) == 0) {
              /* relink next-pointer of list predecessor */
              msegmentptr pp = &m->seg;
              while (pp != 0) {
                if (pp->next == pred) {
                  pp->next = sp;
                  break;
                }
                pp = pp->next;
              }
              *sp = pseg;
              released += size;
              m->footprint -= size;
            }
            else { /* back out if cannot unmap */
              insert_large_chunk(m, tp, psize);
            }
          }
        }
        pred = sp;
        sp = next;
d3560 4
a3563 4
        v = t;
        if ((rsize = trem) == 0)
          break;
      }
d3567 1
a3567 1
        rst = rt;
d3569 3
a3571 3
        t = rst; /* set t to least subtree holding sizes > nb */
        break;
      }
d3601 9
a3609 9
        unlink_large_chunk(m, v);
        if (rsize < MIN_CHUNK_SIZE)
          set_inuse_and_pinuse(m, v, (rsize + nb));
        else {
          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
          set_size_and_pinuse_of_free_chunk(r, rsize);
          insert_chunk(m, r, rsize);
        }
        return chunk2mem(v);
d3642 1
a3642 1
        set_inuse_and_pinuse(m, v, (rsize + nb));
d3644 3
a3646 3
        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
        set_size_and_pinuse_of_free_chunk(r, rsize);
        replace_dv(m, r, rsize);
d3673 1
a3673 1
                ok_next(oldp, next) && ok_pinuse(next))) {
d3676 1
a3676 1
        newp = mmap_resize(m, oldp, nb);
d3678 8
a3685 8
        size_t rsize = oldsize - nb;
        newp = oldp;
        if (rsize >= MIN_CHUNK_SIZE) {
          mchunkptr remainder = chunk_plus_offset(newp, nb);
          set_inuse(m, newp, nb);
          set_inuse(m, remainder, rsize);
          extra = chunk2mem(remainder);
        }
d3688 9
a3696 9
        /* Expand into top */
        size_t newsize = oldsize + m->topsize;
        size_t newtopsize = newsize - nb;
        mchunkptr newtop = chunk_plus_offset(oldp, nb);
        set_inuse(m, oldp, nb);
        newtop->head = newtopsize |PINUSE_BIT;
        m->top = newtop;
        m->topsize = newtopsize;
        newp = oldp;
d3709 1
a3709 1
        internal_free(m, extra);
d3717 3
a3719 3
        size_t oc = oldsize - overhead_for(oldp);
        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);
        internal_free(m, oldmem);
d3754 25
a3778 25
        /*
          Find an aligned spot inside chunk.  Since we need to give
          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
          the first calculation places us at a spot with less than
          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
          We've allocated enough total room so that this is always
          possible.
        */
        char* brk = (char*)mem2chunk((size_t)(((size_t)(mem + alignment-1)) &
                                              -alignment));
        char* pos = ((size_t)(brk - (char*)(p)) >= MIN_CHUNK_SIZE)?
          brk : brk+alignment;
        mchunkptr newp = (mchunkptr)pos;
        size_t leadsize = pos - (char*)(p);
        size_t newsize = chunksize(p) - leadsize;

        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
          newp->prev_foot = p->prev_foot + leadsize;
          newp->head = (newsize|CINUSE_BIT);
        }
        else { /* Otherwise, give back leader, use the rest */
          set_inuse(m, newp, newsize);
          set_inuse(m, p, leadsize);
          leader = chunk2mem(p);
        }
d3784 8
a3791 8
        size_t size = chunksize(p);
        if (size > nb + MIN_CHUNK_SIZE) {
          size_t remainder_size = size - nb;
          mchunkptr remainder = chunk_plus_offset(p, nb);
          set_inuse(m, p, nb);
          set_inuse(m, remainder, remainder_size);
          trailer = chunk2mem(remainder);
        }
d3799 1
a3799 1
        internal_free(m, leader);
d3802 1
a3802 1
        internal_free(m, trailer);
d3813 4
a3816 4
                     size_t n_elements,
                     size_t* sizes,
                     int opts,
                     void* chunks[]) {
d3821 1
a3821 1
    The opts arg has:
d3824 1
a3824 1
  */
d3830 1
a3830 1
  mchunkptr p;              /* corresponding chunk */
d3833 1
a3833 1
  mchunkptr array_chunk;    /* chunk for malloced ptr array */
d3836 1
a3836 1
  size_t    i;
d3848 1
a3848 1
      return (void**)internal_malloc(m, 0);
d3905 1
a3905 1
        size = element_size;
d3907 1
a3907 1
        size = request2size(sizes[i]);
d3926 1
a3926 1
    }
d3948 2
a3949 2
          (Remainderless means that there are too few excess bytes to
          represent as a chunk.)
d3951 1
a3951 1
          chunk adjacent to the one used for the most recent small request.
d3953 1
a3953 1
          saving remainder in dv.
d3958 1
a3958 1
          if it is better fitting than dv chunk, splitting if necessary.
d3978 10
a3987 10
        mchunkptr b, p;
        idx += ~smallbits & 1;      /* Uses next bin if idx empty */
        b = smallbin_at(gm, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(gm, b, p, idx);
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
d3991 30
a4020 30
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(gm, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(gm, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE) 
            set_inuse_and_pinuse(gm, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(gm, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }

        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }
d4028 2
a4029 2
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
d4037 4
a4040 4
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
        gm->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
d4043 4
a4046 4
        size_t dvs = gm->dvsize;
        gm->dvsize = 0;
        gm->dv = 0;
        set_inuse_and_pinuse(gm, p, dvs);
d4096 67
a4162 67
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if ((prevsize & IS_MMAPPED_BIT) != 0) {
            prevsize &= ~IS_MMAPPED_BIT;
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);
          insert_chunk(fm, p, psize);
          check_free_chunk(fm, p);
          goto postaction;
        }
d4181 1
a4181 1
        (req / n_elements != elem_size))
d4212 1
a4212 1
                                 void* chunks[]) {
d4218 1
a4218 1
                                   void* chunks[]) {
d4304 1
a4304 1
                 (capacity + TOP_FOOT_SIZE + msize));
d4344 15
a4358 15
        char* base = nextbase;
        size_t size = nextsize;
        flag_t flag = nextflag;
        if (next != 0) {
          next = next->next;
          if (next != 0) {
            nextbase = next->base;
            nextsize = next->size;
            nextflag = next->sflags;
          }
        }
        if ((flag & IS_MMAPPED_BIT) &&
            CALL_MUNMAP(base, size) == 0)
          freed += size;
        sp = next;
d4364 1
a4364 1
        CALL_MUNMAP((char*)(mem2chunk(ms)), msize) == 0)
d4396 10
a4405 10
        mchunkptr b, p;
        idx += ~smallbits & 1;      /* Uses next bin if idx empty */
        b = smallbin_at(ms, idx);
        p = b->fd;
        assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(ms, b, p, idx);
        set_inuse_and_pinuse(ms, p, small_index2size(idx));
        mem = chunk2mem(p);
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4409 30
a4438 30
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          b = smallbin_at(ms, i);
          p = b->fd;
          assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(ms, b, p, i);
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE) 
            set_inuse_and_pinuse(ms, p, small_index2size(i));
          else {
            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
            r = chunk_plus_offset(p, nb);
            set_size_and_pinuse_of_free_chunk(r, rsize);
            replace_dv(ms, r, rsize);
          }
          mem = chunk2mem(p);
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }

        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
          check_malloced_chunk(ms, mem, nb);
          goto postaction;
        }
d4446 2
a4447 2
        check_malloced_chunk(ms, mem, nb);
        goto postaction;
d4455 4
a4458 4
        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
        ms->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
d4461 4
a4464 4
        size_t dvs = ms->dvsize;
        ms->dvsize = 0;
        ms->dv = 0;
        set_inuse_and_pinuse(ms, p, dvs);
d4508 67
a4574 67
        size_t psize = chunksize(p);
        mchunkptr next = chunk_plus_offset(p, psize);
        if (!pinuse(p)) {
          size_t prevsize = p->prev_foot;
          if ((prevsize & IS_MMAPPED_BIT) != 0) {
            prevsize &= ~IS_MMAPPED_BIT;
            psize += prevsize + MMAP_FOOT_PAD;
            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
              fm->footprint -= psize;
            goto postaction;
          }
          else {
            mchunkptr prev = chunk_minus_offset(p, prevsize);
            psize += prevsize;
            p = prev;
            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
              if (p != fm->dv) {
                unlink_chunk(fm, p, prevsize);
              }
              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
                fm->dvsize = psize;
                set_free_with_pinuse(p, psize, next);
                goto postaction;
              }
            }
            else
              goto erroraction;
          }
        }

        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
          if (!cinuse(next)) {  /* consolidate forward */
            if (next == fm->top) {
              size_t tsize = fm->topsize += psize;
              fm->top = p;
              p->head = tsize | PINUSE_BIT;
              if (p == fm->dv) {
                fm->dv = 0;
                fm->dvsize = 0;
              }
              if (should_trim(fm, tsize))
                sys_trim(fm, 0);
              goto postaction;
            }
            else if (next == fm->dv) {
              size_t dsize = fm->dvsize += psize;
              fm->dv = p;
              set_size_and_pinuse_of_free_chunk(p, dsize);
              goto postaction;
            }
            else {
              size_t nsize = chunksize(next);
              psize += nsize;
              unlink_chunk(fm, next, nsize);
              set_size_and_pinuse_of_free_chunk(p, psize);
              if (p == fm->dv) {
                fm->dvsize = psize;
                goto postaction;
              }
            }
          }
          else
            set_free_with_pinuse(p, psize, next);
          insert_chunk(fm, p, psize);
          check_free_chunk(fm, p);
          goto postaction;
        }
d4595 1
a4595 1
        (req / n_elements != elem_size))
d4632 1
a4632 1
                                 size_t elem_size, void* chunks[]) {
d4643 1
a4643 1
                                   size_t sizes[], void* chunks[]) {
d4721 1
a4721 1
  * MORECORE need not handle negative arguments -- it may instead
d4753 1
a4753 1
         size = MINIMUM_MORECORE_SIZE;
d4755 1
a4755 1
         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
d4758 1
a4758 1
        return (void *) MFAIL;
d4788 2
a4789 2
         PoolDeallocate(*ptr);
         *ptr = 0;
d4808 2
a4809 2
      * Use segments to unify sbrk-based and mmap-based system allocation, 
        removing need for emulation on most platforms without sbrk.
d4813 3
a4815 3
      * Incorporate suggestions and platform-specific changes. 
        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas, 
        Aaron Bachmann,  Emery Berger, and others.
d4828 1
a4828 1
        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
d4839 1
a4839 1
        Thanks to Michael Pachos for motivation and help.
d4843 2
a4844 2
        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
        and Anonymous.
d4846 1
a4846 1
        helping test this.)
d4849 2
a4850 2
        leads to  more fragmentation in some programs and doesn't
        seem to help in any others.
d4858 1
a4858 1
        Thanks to Tony E. Bennett <tbennett@@nvidia.com> and others.
d4864 11
a4874 11
         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
          (e.g. WIN32 platforms)
         * Cleanup header file inclusion for WIN32 platforms
         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
           memory allocation routines
         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
           usage of 'assert' in non-WIN32 code
         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
           avoid infinite loop
d4886 1
a4886 1
        foreign sbrks
d4892 1
a4892 1
        Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d4900 1
a4900 1
        avoid surprises about sbrk alignment conventions.
d4902 1
a4902 1
        (raymond@@es.ele.tue.nl) for the suggestion.
d4905 1
a4905 1
        courtesy of Wolfram Gloger (Gloger@@lrz.uni-muenchen.de).
d4907 1
a4907 1
        H.J. Lu (hjl@@gnu.ai.mit.edu)
d4913 2
a4914 2
        the work required to undo bad preallocations exceeds
        the work saved in good cases for most test programs.
d4916 2
a4917 2
        no scheme using them consistently outperforms those that don't
        given above changes.
d4923 1
a4923 1
        Paul Wilson (wilson@@cs.texas.edu) for the suggestion.
d4927 1
a4927 1
        (wmglo@@Dent.MED.Uni-Muenchen.DE).
d4943 1
a4943 1
         (eliminating old malloc_find_space & malloc_clean_bin)
d4947 1
a4947 1
          from kpv@@research.att.com
d4955 2
a4956 2
          with gcc & native cc (hp, dec only) allowing
          Detlefs & Zorn comparison study (in SIGPLAN Notices.)
d4960 1
a4960 1
         structure of old version,  but most details differ.)
@


1.9.2.2
log
@2.8.3
@
text
@d7 1
a7 1
* Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)
d22 1
a22 1
     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.3.h
a203 4
Be careful in setting #define values for numerical constants of type
size_t. On some systems, literal values are not automatically extended
to size_t precision unless they are explicitly casted.

d208 1
a208 1
MALLOC_ALIGNMENT         default: (size_t)8
d294 1
a294 1
  though. Internally, we only call it with arguments less than half
a360 6
REALLOC_ZERO_BYTES_FREES    default: not defined
  This should be set if a call to realloc with zero bytes should 
  be the same as a call to free. Some people think it should. Otherwise, 
  since this malloc returns a unique pointer for malloc(0), so does 
  realloc(p, 0).

d399 1
a399 1
  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick
d427 1
a427 1
  disable mmap by setting to MAX_SIZE_T.
d434 2
a435 2
#endif  /* _WIN32 */
#endif  /* WIN32 */
d450 1
a450 1
#endif  /* WIN32 */
d457 2
a458 2
#endif  /* HAVE_MORECORE */
#endif  /* DARWIN */
d462 1
a462 5
#endif  /* LACKS_SYS_TYPES_H */

/* The maximum possible size_t value has all bits set */
#define MAX_SIZE_T           (~(size_t)0)

d465 1
a465 1
#endif  /* ONLY_MSPACES */
d469 1
a469 1
#else   /* ONLY_MSPACES */
d471 2
a472 2
#endif  /* ONLY_MSPACES */
#endif  /* MSPACES */
d474 2
a475 2
#define MALLOC_ALIGNMENT ((size_t)8U)
#endif  /* MALLOC_ALIGNMENT */
d478 1
a478 1
#endif  /* FOOTERS */
d481 1
a481 1
#endif  /* ABORT */
d484 1
a484 1
#endif  /* ABORT_ON_ASSERT_FAILURE */
d487 1
a487 1
#endif  /* PROCEED_ON_ERROR */
d490 1
a490 1
#endif  /* USE_LOCKS */
d493 1
a493 1
#endif  /* INSECURE */
d496 1
a496 1
#endif  /* HAVE_MMAP */
d499 1
a499 1
#endif  /* MMAP_CLEARS */
d503 1
a503 1
#else   /* linux */
d505 2
a506 2
#endif  /* linux */
#endif  /* HAVE_MREMAP */
d509 1
a509 1
#endif  /* MALLOC_FAILURE_ACTION */
d513 1
a513 1
#else   /* ONLY_MSPACES */
d515 2
a516 2
#endif  /* ONLY_MSPACES */
#endif  /* HAVE_MORECORE */
d519 1
a519 1
#else   /* !HAVE_MORECORE */
d522 1
a522 1
#endif  /* MORECORE */
d525 2
a526 2
#endif  /* MORECORE_CONTIGUOUS */
#endif  /* HAVE_MORECORE */
d530 4
a533 4
#else   /* MORECORE_CONTIGUOUS */
#define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)
#endif  /* MORECORE_CONTIGUOUS */
#endif  /* DEFAULT_GRANULARITY */
d536 5
a540 5
#define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)
#else   /* MORECORE_CANNOT_TRIM */
#define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T
#endif  /* MORECORE_CANNOT_TRIM */
#endif  /* DEFAULT_TRIM_THRESHOLD */
d543 5
a547 5
#define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)
#else   /* HAVE_MMAP */
#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
#endif  /* HAVE_MMAP */
#endif  /* DEFAULT_MMAP_THRESHOLD */
d550 1
a550 1
#endif  /* USE_BUILTIN_FFS */
d553 1
a553 1
#endif  /* USE_DEV_RANDOM */
d556 1
a556 1
#endif  /* NO_MALLINFO */
d559 1
a559 1
#endif  /* MALLINFO_FIELD_TYPE */
d601 1
a601 1
#else /* HAVE_USR_INCLUDE_MALLOC_H */
d616 2
a617 2
#endif /* HAVE_USR_INCLUDE_MALLOC_H */
#endif /* NO_MALLINFO */
d621 1
a621 1
#endif /* __cplusplus */
a640 1
#define dlmalloc_max_footprint malloc_max_footprint
d643 1
a643 1
#endif /* USE_DL_PREFIX */
d667 1
a667 1
  freed, free(p) will by default cause the current program to abort.
d738 1
a738 1
  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (MAX_SIZE_T disables)
d753 1
a753 14
size_t dlmalloc_footprint(void);

/*
  malloc_max_footprint();
  Returns the maximum number of bytes obtained from the system. This
  value will be greater than current footprint if deallocated space
  has been reclaimed by the system. The peak number of bytes allocated
  by malloc, realloc etc., is less than this value. Unlike mallinfo,
  this function returns only a precomputed result, so can be called
  frequently to monitor memory consumption.  Even if locks are
  otherwise defined, this function does not use them, so results might
  not be up to date.
*/
size_t dlmalloc_max_footprint(void);
d779 1
a779 1
#endif /* NO_MALLINFO */
d962 1
a962 1
void  dlmalloc_stats(void);
d964 1
a964 1
#endif /* ONLY_MSPACES */
a1064 6
/*
  mspace_max_footprint() returns the peak number of bytes obtained from the
  system for this space.
*/
size_t mspace_max_footprint(mspace msp);

d1072 1
a1072 1
#endif /* NO_MALLINFO */
d1091 1
a1091 1
#endif /* MSPACES */
d1095 1
a1095 1
#endif /* __cplusplus */
d1111 1
a1111 1
#endif /* WIN32 */
d1117 1
a1117 1
#endif /* LACKS_ERRNO_H */
d1120 1
a1120 1
#endif /* FOOTERS */
d1123 1
a1123 1
#endif /* LACKS_STDLIB_H */
d1127 1
a1127 1
#else /* ABORT_ON_ASSERT_FAILURE */
d1129 2
a1130 2
#endif /* ABORT_ON_ASSERT_FAILURE */
#else  /* DEBUG */
d1132 1
a1132 1
#endif /* DEBUG */
d1135 1
a1135 1
#endif  /* LACKS_STRING_H */
d1139 2
a1140 2
#endif /* LACKS_STRINGS_H */
#endif /* USE_BUILTIN_FFS */
d1144 1
a1144 1
#endif /* LACKS_SYS_MMAN_H */
d1147 2
a1148 2
#endif /* LACKS_FCNTL_H */
#endif /* HAVE_MMAP */
d1152 1
a1152 1
#else /* LACKS_UNISTD_H */
d1155 3
a1157 3
#endif /* FreeBSD etc */
#endif /* LACKS_UNISTD_H */
#endif /* HAVE_MMAP */
d1195 1
a1195 1
#                define malloc_getpagesize ((size_t)4096U)
d1212 2
a1213 9
/* Some constants coerced to size_t */
/* Annoying but necessary to avoid errors on some plaftorms */
#define SIZE_T_ZERO         ((size_t)0)
#define SIZE_T_ONE          ((size_t)1)
#define SIZE_T_TWO          ((size_t)2)
#define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)
#define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)
#define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
#define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)
d1216 1
a1216 1
#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)
d1240 2
a1241 2
#define IS_MMAPPED_BIT       (SIZE_T_ZERO)
#define USE_MMAP_BIT         (SIZE_T_ZERO)
d1246 3
a1248 3
#else /* HAVE_MMAP */
#define IS_MMAPPED_BIT       (SIZE_T_ONE)
#define USE_MMAP_BIT         (SIZE_T_ONE)
d1255 1
a1255 1
#endif /* MAP_ANON */
d1259 1
a1259 1
#else /* MAP_ANONYMOUS */
d1270 1
a1270 1
#endif /* MAP_ANONYMOUS */
d1273 1
a1273 1
#else /* WIN32 */
d1309 2
a1310 2
#endif /* WIN32 */
#endif /* HAVE_MMAP */
d1314 1
a1314 1
#else  /* HAVE_MMAP && HAVE_MREMAP */
d1316 1
a1316 1
#endif /* HAVE_MMAP && HAVE_MREMAP */
d1320 1
a1320 1
#else  /* HAVE_MORECORE */
d1322 1
a1322 1
#endif /* HAVE_MORECORE */
a1326 4
/* segment bit set in create_mspace_with_base */
#define EXTERN_BIT            (8U)


d1341 2
a1342 2
  * magic_init_mutex ensures that mparams.magic and other
    unique mparams values are initialized only once.
a1348 1
#define INITIAL_LOCK(l)      pthread_mutex_init(l, NULL)
d1354 1
a1354 1
#endif /* HAVE_MORECORE */
d1356 1
d1358 1
d1360 1
a1360 1
#else /* WIN32 */
d1375 1
a1375 1
#endif /* InterlockedCompareExchangePointer */
a1383 1
#define INITIAL_LOCK(l)      *(l)=0
d1388 2
a1389 1
#endif /* HAVE_MORECORE */
d1391 2
a1392 1
#endif /* WIN32 */
d1395 1
a1395 1
#else  /* USE_LOCKS */
d1397 1
a1397 2
#define INITIAL_LOCK(l)
#endif /* USE_LOCKS */
d1402 1
a1402 1
#else /* USE_LOCKS && HAVE_MORECORE */
d1405 1
a1405 1
#endif /* USE_LOCKS && HAVE_MORECORE */
d1407 1
a1407 1
#if USE_LOCKS
d1410 1
a1410 1
#else  /* USE_LOCKS */
d1413 1
a1413 1
#endif /* USE_LOCKS */
d1572 2
a1573 2
#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
#else /* FOOTERS */
d1575 1
a1575 1
#endif /* FOOTERS */
d1578 1
a1578 1
#define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)
d1580 1
a1580 1
#define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)
d1584 1
a1584 1
  ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
d1587 2
a1588 2
#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
d1594 1
a1594 1
#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
d1615 2
a1616 2
#define PINUSE_BIT          (SIZE_T_ONE)
#define CINUSE_BIT          (SIZE_T_TWO)
d1663 1
a1663 1
#else /* MMAP_CLEARS */
d1665 1
a1665 1
#endif /* MMAP_CLEARS */
d1782 1
a1782 1
  top-most space. Segments also include flags holding properties of
d1816 4
a1819 16
  Except for the top-most segment of an mstate, each segment record
  is kept at the tail of its segment. Segments are added by pushing
  segment records onto the list headed by &mstate.seg for the
  containing mstate.

  Segment flags control allocation/merge/deallocation policies:
  * If EXTERN_BIT set, then we did not allocate this segment,
    and so should not try to deallocate or merge with others.
    (This currently holds only for the initial segment passed
    into create_mspace_with_base.)
  * If IS_MMAPPED_BIT set, the segment may be merged with
    other surrounding mmapped segments and trimmed/de-allocated
    using munmap.
  * If neither bit is set, then the segment was obtained using
    MORECORE so can be merged with surrounding MORECORE'd segments
    and deallocated/trimmed using MORECORE with negative arguments.
d1826 1
a1826 1
  flag_t       sflags;           /* mmap and extern flag */
a1828 3
#define is_mmapped_segment(S)  ((S)->sflags & IS_MMAPPED_BIT)
#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)

d1911 1
a1911 1
#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)
d1913 2
a1914 2
#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)
#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)
d1934 1
a1934 1
#endif /* USE_LOCKS */
d1987 1
a1987 1
 (((S) + (mparams.page_size)) & ~(mparams.page_size - SIZE_T_ONE))
d1991 1
a1991 1
  (((S) + (mparams.granularity)) & ~(mparams.granularity - SIZE_T_ONE))
d1994 1
a1994 1
   (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
d1996 1
a1996 1
   (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)
d2026 1
a2026 1
#else  /* MORECORE_CANNOT_TRIM */
d2028 1
a2028 1
#endif /* MORECORE_CANNOT_TRIM */
d2036 1
a2036 1
  (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
d2049 1
a2049 4
/* Ensure locks are initialized */
#define GLOBALLY_INITIALIZE() (mparams.page_size == 0 && init_mparams())

#define PREACTION(M)  ((GLOBALLY_INITIALIZE() || use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
d2051 1
a2051 1
#else /* USE_LOCKS */
d2055 1
a2055 1
#endif  /* PREACTION */
d2059 1
a2059 1
#endif  /* POSTACTION */
d2061 1
a2061 1
#endif /* USE_LOCKS */
d2082 1
a2082 1
#else /* PROCEED_ON_ERROR */
d2086 1
a2086 1
#endif /* CORRUPTION_ERROR_ACTION */
d2090 1
a2090 1
#endif /* USAGE_ERROR_ACTION */
d2092 1
a2092 1
#endif /* PROCEED_ON_ERROR */
d2105 1
a2105 1
#else /* DEBUG */
d2125 1
a2125 1
#endif /* DEBUG */
d2153 1
a2153 1
#else /* GNUC */
d2171 1
a2171 1
#endif /* GNUC */
d2180 1
a2180 1
    ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
d2184 2
a2185 2
   ((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \
   (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))
d2212 1
a2212 1
#else /* GNUC */
d2216 1
a2216 1
#else /* USE_BUILTIN_FFS */
d2228 2
a2229 2
#endif /* USE_BUILTIN_FFS */
#endif /* GNUC */
d2279 1
a2279 1
#else /* !INSECURE */
d2284 1
a2284 1
#endif /* !INSECURE */
d2289 1
a2289 1
#else  /* (FOOTERS && !INSECURE) */
d2291 1
a2291 1
#endif /* (FOOTERS && !INSECURE) */
d2298 1
a2298 1
#else /* GNUC */
d2300 2
a2301 2
#endif /* GNUC */
#else /* !INSECURE */
d2303 1
a2303 1
#endif /* !INSECURE */
d2325 1
a2325 1
#else /* FOOTERS */
d2349 1
a2349 1
#endif /* !FOOTERS */
d2354 1
a2354 1
static int init_mparams(void) {
a2355 9
    size_t s;

    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
#if MORECORE_CONTIGUOUS
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
#else  /* MORECORE_CONTIGUOUS */
    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
#endif /* MORECORE_CONTIGUOUS */
d2359 1
d2370 1
a2370 1
#endif /* USE_DEV_RANDOM */
d2373 2
a2374 2
      s |= (size_t)8U;    /* ensure nonzero */
      s &= ~(size_t)7U;   /* improve chances of fault for bad values */
d2376 4
d2381 12
a2392 11
#else /* (FOOTERS && !INSECURE) */
    s = (size_t)0x58585858U;
#endif /* (FOOTERS && !INSECURE) */
    ACQUIRE_MAGIC_INIT_LOCK();
    if (mparams.magic == 0) {
      mparams.magic = s;
      /* Set up lock for main malloc area */
      INITIAL_LOCK(&gm->mutex);
      gm->mflags = mparams.default_mflags;
    }
    RELEASE_MAGIC_INIT_LOCK();
d2398 1
a2398 1
#else /* WIN32 */
d2405 1
a2405 1
#endif /* WIN32 */
d2416 5
a2420 5
        (MALLOC_ALIGNMENT < (size_t)8U) ||
        ((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
        ((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
        ((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||
        ((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))
a2422 1
  return 0;
d2480 1
a2480 1
  assert((len & (mparams.page_size-SIZE_T_ONE)) == 0);
d2588 1
a2588 1
  int empty = (m->treemap & (1U << i)) == 0;
d2599 1
a2599 1
  unsigned int empty = (m->smallmap & (1U << i)) == 0;
d2640 1
a2640 1
        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
d2714 1
a2714 1
#endif /* DEBUG */
d2724 3
a2726 3
      size_t nfree = SIZE_T_ONE; /* top always free */
      size_t mfree = m->topsize + TOP_FOOT_SIZE;
      size_t sum = mfree;
d2735 1
a2735 1
            mfree += sz;
d2745 1
a2745 1
      nm.hblkhd   = m->footprint - sum;
d2747 1
a2747 2
      nm.uordblks = m->footprint - mfree;
      nm.fordblks = mfree;
d2755 1
a2755 1
#endif /* !NO_MALLINFO */
d2888 1
a2888 1
        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
d3025 1
a3025 1
#else /* ONLY_MSPACES */
d3031 1
a3031 1
#else /* MSPACES */
d3034 2
a3035 2
#endif /* MSPACES */
#endif /* ONLY_MSPACES */
d3046 1
a3046 1
  the PINUSE bit so frees can be checked.
d3051 1
a3051 1
  size_t mmsize = granularity_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3082 2
a3083 2
  if (oldsize >= nb + SIZE_T_SIZE &&
      (oldsize - nb) <= (mparams.granularity << 1))
d3088 1
a3088 1
    size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +
d3155 1
a3155 1
#endif /* PROCEED_ON_ERROR */
d3207 1
a3207 1
  char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
d3223 4
a3226 4
  *ss = m->seg; /* Push current record */
  m->seg.base = tbase;
  m->seg.size = tsize;
  m->seg.sflags = mmapped;
d3243 1
a3243 1
    mchunkptr q = (mchunkptr)old_top;
d3245 3
a3247 3
    mchunkptr tn = chunk_plus_offset(q, psize);
    set_free_with_pinuse(q, psize, tn);
    insert_chunk(m, q, psize);
d3277 2
a3278 2
       Note that under the default settings, if MORECORE is unable to
       fulfill a request, and HAVE_MMAP is true, then mmap is
d3288 1
a3288 1
    char* br = CMFAIL;
a3289 1
    size_t asize = 0;
d3295 1
a3295 1
        asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
d3300 2
a3301 2
        if (asize < HALF_MAX_SIZE_T &&
            (br = (char*)(CALL_MORECORE(asize))) == base) {
d3303 1
a3303 1
          tsize = asize;
d3309 1
a3309 1
      asize = granularity_align(nb - m->topsize + TOP_FOOT_SIZE + SIZE_T_ONE);
d3311 4
a3314 4
      if (asize < HALF_MAX_SIZE_T &&
          (br = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
        tbase = br;
        tsize = asize;
d3318 8
a3325 13
    if (tbase == CMFAIL) {    /* Cope with partial failure */
      if (br != CMFAIL) {    /* Try to use/extend the space we did get */
        if (asize < HALF_MAX_SIZE_T &&
            asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
          size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
          if (esize < HALF_MAX_SIZE_T) {
            char* end = (char*)CALL_MORECORE(esize);
            if (end != CMFAIL)
              asize += esize;
            else {            /* Can't use; try to release */
              CALL_MORECORE(-asize);
              br = CMFAIL;
            }
a3327 7
      }
      if (br != CMFAIL) {    /* Use the space we did get */
        tbase = br;
        tsize = asize;
      }
      else
        disable_contiguous(m); /* Don't try contiguous path in the future */
d3334 1
a3334 1
    size_t req = nb + TOP_FOOT_SIZE + SIZE_T_ONE;
d3347 3
a3349 3
    size_t asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
    if (asize < HALF_MAX_SIZE_T) {
      char* br = CMFAIL;
d3352 1
a3352 1
      br = (char*)(CALL_MORECORE(asize));
d3355 2
a3356 2
      if (br != CMFAIL && end != CMFAIL && br < end) {
        size_t ssize = end - br;
d3358 1
a3358 1
          tbase = br;
d3375 1
d3377 1
a3377 1
      if (is_global(m)) 
d3391 1
a3391 3
      if (sp != 0 &&
          !is_extern_segment(sp) &&
          (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&
d3402 1
a3402 3
        if (sp != 0 &&
            !is_extern_segment(sp) &&
            (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {
a3430 41
/* Unmap and unlink any mmapped segments that don't contain used chunks */
static size_t release_unused_segments(mstate m) {
  size_t released = 0;
  msegmentptr pred = &m->seg;
  msegmentptr sp = pred->next;
  while (sp != 0) {
    char* base = sp->base;
    size_t size = sp->size;
    msegmentptr next = sp->next;
    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
      mchunkptr p = align_as_chunk(base);
      size_t psize = chunksize(p);
      /* Can unmap if first chunk holds entire segment and not pinned */
      if (!cinuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
        tchunkptr tp = (tchunkptr)p;
        assert(segment_holds(sp, (char*)sp));
        if (p == m->dv) {
          m->dv = 0;
          m->dvsize = 0;
        }
        else {
          unlink_large_chunk(m, tp);
        }
        if (CALL_MUNMAP(base, size) == 0) {
          released += size;
          m->footprint -= size;
          /* unlink obsoleted record */
          sp = pred;
          sp->next = next;
        }
        else { /* back out if cannot unmap */
          insert_large_chunk(m, tp, psize);
        }
      }
    }
    pred = sp;
    sp = next;
  }
  return released;
}

d3439 1
a3439 2
      size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
                      SIZE_T_ONE) * unit;
d3442 9
a3450 11
      if (!is_extern_segment(sp)) {
        if (is_mmapped_segment(sp)) {
          if (HAVE_MMAP &&
              sp->size >= extra &&
              !has_segment_link(m, sp)) { /* can't shrink if pinned */
            size_t newsize = sp->size - extra;
            /* Prefer mremap, fall back to munmap */
            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
              released = extra;
            }
d3453 13
a3465 13
        else if (HAVE_MORECORE) {
          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
          ACQUIRE_MORECORE_LOCK();
          {
            /* Make sure end of memory is where we last set it. */
            char* old_br = (char*)(CALL_MORECORE(0));
            if (old_br == sp->base + sp->size) {
              char* rel_br = (char*)(CALL_MORECORE(-extra));
              char* new_br = (char*)(CALL_MORECORE(0));
              if (rel_br != CMFAIL && new_br < old_br)
                released = old_br - new_br;
            }
a3466 1
          RELEASE_MORECORE_LOCK();
d3468 1
d3480 48
a3527 2
    if (HAVE_MMAP) 
      released += release_unused_segments(m);
d3560 1
a3560 1
      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
d3729 2
a3730 2
  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
    size_t a = MALLOC_ALIGNMENT << 1;
d3734 1
a3734 1
  
d3736 1
a3736 3
    if (m != 0)  { /* Test isn't needed but avoids compiler warning */
      MALLOC_FAILURE_ACTION;
    }
d3757 4
a3760 6
        char* br = (char*)mem2chunk((size_t)(((size_t)(mem +
                                                       alignment -
                                                       SIZE_T_ONE)) &
                                             -alignment));
        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
          br : br+alignment;
d3927 1
a3927 1
#endif /* DEBUG */
d3972 1
a3972 1
      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
d3974 1
a3974 1
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
d3999 1
a3999 1
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
d4085 1
a4085 1
#else /* FOOTERS */
d4087 1
a4087 1
#endif /* FOOTERS */
d4167 1
a4167 1
#endif /* FOOTERS */
a4187 6
#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) {
    dlfree(oldmem);
    return 0;
  }
#endif /* REALLOC_ZERO_BYTES_FREES */
d4191 1
a4191 1
#else /* FOOTERS */
d4197 1
a4197 1
#endif /* FOOTERS */
d4228 1
a4228 1
  return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
d4240 1
a4240 1
size_t dlmalloc_footprint(void) {
a4243 4
size_t dlmalloc_max_footprint(void) {
  return gm->max_footprint;
}

d4245 1
a4245 1
struct mallinfo dlmallinfo(void) {
d4248 1
a4248 1
#endif /* NO_MALLINFO */
d4267 1
a4267 1
#endif /* !ONLY_MSPACES */
a4278 1
  INITIAL_LOCK(&m->mutex);
d4300 1
d4305 1
a4305 1
      m->seg.sflags = IS_MMAPPED_BIT;
a4319 1
    m->seg.sflags = EXTERN_BIT;
d4329 26
a4354 9
    msegmentptr sp = &ms->seg;
    while (sp != 0) {
      char* base = sp->base;
      size_t size = sp->size;
      flag_t flag = sp->sflags;
      sp = sp->next;
      if ((flag & IS_MMAPPED_BIT) && !(flag & EXTERN_BIT) &&
          CALL_MUNMAP(base, size) == 0)
        freed += size;
d4356 5
d4390 1
a4390 1
      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
d4392 1
a4392 1
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
d4417 1
a4417 1
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
d4493 1
a4493 1
#else /* FOOTERS */
d4495 1
a4495 1
#endif /* FOOTERS */
a4601 6
#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) {
    mspace_free(msp, oldmem);
    return 0;
  }
#endif /* REALLOC_ZERO_BYTES_FREES */
d4604 1
a4604 1
    mchunkptr p  = mem2chunk(oldmem);
d4606 1
a4606 1
#else /* FOOTERS */
d4608 1
a4608 1
#endif /* FOOTERS */
d4683 1
a4683 12
size_t mspace_max_footprint(mspace msp) {
  size_t result;
  mstate ms = (mstate)msp;
  if (ok_magic(ms)) {
    result = ms->max_footprint;
  }
  USAGE_ERROR_ACTION(ms,ms);
  return result;
}


#if !NO_MALLINFO
d4691 1
a4691 1
#endif /* NO_MALLINFO */
d4697 1
a4697 1
#endif /* MSPACES */
d4793 1
a4793 14
    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)
      * Add max_footprint functions
      * Ensure all appropriate literals are size_t
      * Fix conditional compilation problem for some #define settings
      * Avoid concatenating segments with the one provided
        in create_mspace_with_base
      * Rename some variables to avoid compiler shadowing warnings
      * Use explicit lock initialization.
      * Better handling of sbrk interference.
      * Simplify and fix segment insertion, trimming and mspace_destroy
      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x
      * Thanks especially to Dennis Flanagan for help on these.

    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
d4803 1
a4803 1
      * Use segments to unify sbrk-based and mmap-based system allocation,
d4808 2
a4809 2
      * Incorporate suggestions and platform-specific changes.
        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
d4956 1
a4956 1
 
@


1.8
log
@* malloc.cc: Update to Doug Lea's malloc v2.8.0.
@
text
@d7 1
a7 1
* Version 2.8.0 Mon May 30 14:59:49 2005  Doug Lea  (dl at gee)
d624 4
a649 3
#ifdef __cplusplus
extern "C" {
#endif
a3777 1
	  p = newp;
d3779 1
d3938 1
d4798 7
@


1.7
log
@* Makefile.in (MALLOC_OFILES): Always fill in with correct malloc object.
* configure.in: Fill in MALLOC_OFILES with either debugging or regular malloc.
* configure: Regenerate.
* dlmalloc.c: Make various fruitless changes to attempt to get to work.
* dlmalloc.h: Ditto.
* malloc.cc (free): Check malloc pool when debugging.
* path.cc (win32_device_name): Eliminate compiler warning.
* sigproc.cc (sig_dispatch_pending): Remove use of was_pending.  Let
thisframe.call_signal_handler decide if handler should be called rather than
using bogus was_pending check.
* exceptions.cc (interrupt_setup): Remove accidentally checked in debugging
code.
* heap.cc (sbrk): Save rounded addess in user_heap_max.
@
text
@d3 3
a5 4
  Doug Lea and released to the public domain.  Use, modify, and
  redistribute this code without permission or acknowledgement in any
  way you wish.  Send questions, comments, complaints, performance
  data, etc to dl@@cs.oswego.edu
d7 1
a7 1
* VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
d16 4
a19 5
  ftp it, compile it (-O), and link it into another program. All
  of the compile-time options default to reasonable values for use on
  most unix platforms. Compile -DWIN32 for reasonable defaults on windows.
  You might later want to step through various compile-time and dynamic
  tuning options.
d22 1
a22 1
     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.7.1.h
d29 5
a33 49
  indicated below.

* Why use this malloc?

  This is not the fastest, most space-conserving, most portable, or
  most tunable malloc ever written. However it is among the fastest
  while also being among the most space-conserving, portable and tunable.
  Consistent balance across these factors results in a good general-purpose
  allocator for malloc-intensive programs.

  The main properties of the algorithms are:
  * For large (>= 512 bytes) requests, it is a pure best-fit allocator,
    with ties normally decided via FIFO (i.e. least recently used).
  * For small (<= 64 bytes by default) requests, it is a caching
    allocator, that maintains pools of quickly recycled chunks.
  * In between, and for combinations of large and small requests, it does
    the best it can trying to meet both goals at once.
  * For very large requests (>= 128KB by default), it relies on system
    memory mapping facilities, if supported.

  For a longer but slightly out of date high-level description, see
     http://gee.cs.oswego.edu/dl/html/malloc.html

  You may already by default be using a C library containing a malloc
  that is  based on some version of this malloc (for example in
  linux). You might still want to use the one in this file in order to
  customize settings or to avoid overheads associated with library
  versions.

* Contents, described in more detail in "description of public routines" below.

  Standard (ANSI/SVID/...)  functions:
    malloc(size_t n);
    calloc(size_t n_elements, size_t element_size);
    free(Void_t* p);
    realloc(Void_t* p, size_t n);
    memalign(size_t alignment, size_t n);
    valloc(size_t n);
    mallinfo()
    mallopt(int parameter_number, int parameter_value)

  Additional functions:
    independent_calloc(size_t n_elements, size_t size, Void_t* chunks[]);
    independent_comalloc(size_t n_elements, size_t sizes[], Void_t* chunks[]);
    pvalloc(size_t n);
    cfree(Void_t* p);
    malloc_trim(size_t pad);
    malloc_usable_size(Void_t* p);
    malloc_stats();
d37 11
a47 9
  Supported pointer representation:       4 or 8 bytes
  Supported size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.
       You can adjust this by defining INTERNAL_SIZE_T

  Alignment:                              2 * sizeof(size_t) (default)
       (i.e., 8 byte alignment with 4byte size_t). This suffices for
       nearly all current machines and C compilers. However, you can
       define MALLOC_ALIGNMENT to be wider than this if necessary.
d49 2
a50 1
  Minimum overhead per allocated chunk:   4 or 8 bytes
d52 2
a53 4
       and status information.

  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
			  8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
d55 2
a56 5
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are
       needed; 4 (8) for a trailing size field and 8 (16) bytes for
       free list pointers. Thus, the minimum allocatable size is
       16/24/32 bytes.
a59 1

d63 62
a124 39
       are serviced via mmap(), where the worst case wastage is 2 *
       sizeof(size_t) bytes plus the remainder from a system page (the
       minimal mmap unit); typically 4096 or 8192 bytes.

  Maximum allocated size:  4-byte size_t: 2^32 minus about two pages
			   8-byte size_t: 2^64 minus about two pages

       It is assumed that (possibly signed) size_t values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
       an unsigned type. The ISO C standard says that it must be
       unsigned, but a few systems are known not to adhere to this.
       Additionally, even when size_t is unsigned, sbrk (which is by
       default used to obtain memory from system) accepts signed
       arguments, and may not be able to handle size_t-wide arguments
       with negative sign bit.  Generally, values that would
       appear as negative after accounting for overhead and alignment
       are supported only via mmap(), which does not have this
       limitation.

       Requests for sizes outside the allowed range will perform an optional
       failure action and then return null. (Requests may also
       also fail because a system is out of memory.)

  Thread-safety: NOT thread-safe unless USE_MALLOC_LOCK defined

       When USE_MALLOC_LOCK is defined, wrappers are created to
       surround every public call with either a pthread mutex or
       a win32 spinlock (depending on WIN32). This is not
       especially fast, and can be a major bottleneck.
       It is designed only to provide minimal protection
       in concurrent environments, and to provide a basis for
       extensions.  If you are using malloc in a concurrent program,
       you would be far better off obtaining ptmalloc, which is
       derived from a version of this malloc, and is well-tuned for
       concurrent programs. (See http://www.malloc.de) Note that
       even when USE_MALLOC_LOCK is defined, you can can guarantee
       full thread-safety only if no threads acquire memory through
       direct calls to MORECORE or other system-level allocators.
d126 2
a127 2
  Compliance: I believe it is compliant with the 1997 Single Unix Specification
       (See http://www.opennc.org). Also SVID/XPG, ANSI C, and probably
d130 40
a169 1
* Synopsis of compile-time options:
d171 30
a200 64
    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People also report using it in stand-alone embedded systems.

    The implementation is in straight, hand-tuned ANSI C.  It is not
    at all modular. (Sorry!)  It uses a lot of macros.  To be at all
    usable, this code should be compiled using an optimizing compiler
    (for example gcc -O3) that can simplify expressions and control
    paths. (FAQ: some macros import variables as arguments rather than
    declare locals because people reported that some debuggers
    otherwise get confused.)

    OPTION                     DEFAULT VALUE

    Compilation Environment options:

    __STD_C                    derived from C compiler defines
    WIN32                      NOT defined
    HAVE_MEMCPY                defined
    USE_MEMCPY                 1 if HAVE_MEMCPY is defined
    HAVE_MMAP                  defined as 1
    MMAP_CLEARS                1
    HAVE_MREMAP                0 unless linux defined
    malloc_getpagesize         derived from system #includes, or 4096 if not
    HAVE_USR_INCLUDE_MALLOC_H  NOT defined
    LACKS_UNISTD_H             NOT defined unless WIN32
    LACKS_SYS_PARAM_H          NOT defined unless WIN32
    LACKS_SYS_MMAN_H           NOT defined unless WIN32
    LACKS_FCNTL_H              NOT defined

    Changing default word sizes:

    INTERNAL_SIZE_T            size_t
    MALLOC_ALIGNMENT           2 * sizeof(INTERNAL_SIZE_T)
    PTR_UINT                   unsigned long
    CHUNK_SIZE_T               unsigned long

    Configuration and functionality options:

    USE_DL_PREFIX              NOT defined
    USE_PUBLIC_MALLOC_WRAPPERS NOT defined
    USE_MALLOC_LOCK            NOT defined
    DEBUG                      NOT defined
    REALLOC_ZERO_BYTES_FREES   NOT defined
    MALLOC_FAILURE_ACTION      errno = ENOMEM, if __STD_C defined, else no-op
    TRIM_FASTBINS              0
    FIRST_SORTED_BIN_SIZE      512

    Options for customizing MORECORE:

    MORECORE                   sbrk
    MORECORE_CONTIGUOUS        1
    MORECORE_CANNOT_TRIM       NOT defined
    MMAP_AS_MORECORE_SIZE      (1024 * 1024)

    Tuning options that are also dynamically changeable via mallopt:

    DEFAULT_MXFAST             64
    DEFAULT_TRIM_THRESHOLD     256 * 1024
    DEFAULT_TOP_PAD            0
    DEFAULT_MMAP_THRESHOLD     256 * 1024
    DEFAULT_MMAP_MAX           65536
d202 1
a202 3
    There are several other #defined constants and macros that you
    probably don't want to touch unless you are extending or adapting malloc.
*/
d204 2
a205 2
/*
  WIN32 sets up defaults for MS environment and compilers.
d207 222
d431 1
a431 1
/* #define WIN32 */
d433 5
a438 1

d441 2
a442 2

/* Win32 doesn't supply or need the following headers */
d446 7
d454 7
a460 4
/* Use the supplied emulation of sbrk */
#define MORECORE sbrk
#define MORECORE_CONTIGUOUS 1
#define MORECORE_FAILURE    ((void*)(-1))
d462 38
a499 1
/* Use the supplied emulation of mmap and munmap */
d501 2
a502 1
#define MUNMAP_FAILURE  (-1)
a503 13

/* These values don't really matter in windows mmap emulation */
#define MAP_PRIVATE 1
#define MAP_ANONYMOUS 2
#define PROT_READ 1
#define PROT_WRITE 2

/* Emulation functions defined at the end of this file */

/* If USE_MALLOC_LOCK, use supplied critical-section-based lock functions */
#ifdef USE_MALLOC_LOCK
static int slwait(int *sl);
static int slrelease(int *sl);
d505 9
a513 10

static long getpagesize(void);
static long getregionsize(void);
static void *sbrk(long size);
static void *mmap(void *ptr, long size, long prot, long type, long handle, long arg);
static long munmap(void *ptr, long size);

static void vminfo (unsigned long*free, unsigned long*reserved, unsigned long*committed);
static int cpuinfo (int whole, unsigned long*kernel, unsigned long*user);

d515 3
a517 10

/*
  __STD_C should be nonzero if using ANSI-standard C compiler, a C++
  compiler, or a C compiler sufficiently close to ANSI to get away
  with it.
*/

#ifndef __STD_C
#if defined(__STDC__) || defined(_cplusplus)
#define __STD_C     1
d519 2
a520 1
#define __STD_C     0
d522 2
a523 10
#endif /*__STD_C*/


/*
  Void_t* is the pointer type that malloc should say it returns
*/

#ifndef Void_t
#if (__STD_C || defined(WIN32))
#define Void_t      void
d525 5
a529 1
#define Void_t      char
d531 4
a534 4
#endif /*Void_t*/

#if __STD_C
#include <stddef.h>   /* for size_t */
d536 2
a537 1
#include <sys/types.h>
d539 5
a543 5

#include "cygmalloc.h"

#ifdef __cplusplus
extern "C" {
a544 7

/* define LACKS_UNISTD_H if your system does not have a <unistd.h>. */

/* #define  LACKS_UNISTD_H */

#ifndef LACKS_UNISTD_H
#include <unistd.h>
d546 3
a548 40

/* define LACKS_SYS_PARAM_H if your system does not have a <sys/param.h>. */

/* #define  LACKS_SYS_PARAM_H */


#include <stdio.h>    /* needed for malloc_stats */
#include <errno.h>    /* needed for optional MALLOC_FAILURE_ACTION */


/*
  Debugging:

  Because freed chunks may be overwritten with bookkeeping fields, this
  malloc will often die when freed memory is overwritten by user
  programs.  This can be very effective (albeit in an annoying way)
  in helping track down dangling pointers.

  If you compile with -DDEBUG, a number of assertion checks are
  enabled that will catch more memory errors. You probably won't be
  able to make much sense of the actual assertion errors, but they
  should help you locate incorrectly overwritten memory.  The
  checking is fairly extensive, and will slow down execution
  noticeably. Calling malloc_stats or mallinfo with DEBUG set will
  attempt to check every non-mmapped allocated and free chunk in the
  course of computing the summmaries. (By nature, mmapped regions
  cannot be checked very much automatically.)

  Setting DEBUG may also be helpful if you are trying to modify
  this code. The assertions in the check routines spell out in more
  detail the assumptions and invariants underlying the algorithms.

  Setting DEBUG does NOT provide an automated mechanism for checking
  that all accesses to malloced memory stay within their
  bounds. However, there are several add-ons and adaptations of this
  or other mallocs available that do this.
*/

#if DEBUG
#include <assert.h>
d550 14
a563 1
#define assert(x) ((void)0)
d567 4
a570 2
  The unsigned integer type used for comparing any two chunk sizes.
  This should be at least as wide as size_t, but should not be signed.
d573 3
a575 12
#ifndef CHUNK_SIZE_T
#define CHUNK_SIZE_T unsigned long
#endif

/*
  The unsigned integer type used to hold addresses when they are are
  manipulated as integers. Except that it is not defined on all
  systems, intptr_t would suffice.
*/
#ifndef PTR_UINT
#define PTR_UINT unsigned long
#endif
d577 1
d579 1
d581 9
a589 2
  INTERNAL_SIZE_T is the word-size used for internal bookkeeping
  of chunk sizes.
d591 10
a600 1
  The default version is the same as size_t.
d602 1
a602 3
  While not strictly necessary, it is best to define this as an
  unsigned type, even if size_t is a signed type. This may avoid some
  artificial size limitations on some systems.
d604 3
a606 7
  On a 64-bit machine, you may be able to reduce malloc overhead by
  defining INTERNAL_SIZE_T to be a 32 bit `unsigned int' at the
  expense of not being able to handle more than 2^32 of malloced
  space. If this limitation is acceptable, you are encouraged to set
  this unless you are on a platform requiring 16byte alignments. In
  this case the alignment requirements turn out to negate any
  potential advantages of decreasing size_t word size.
d608 12
a619 12
  Implementors: Beware of the possible combinations of:
     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,
       and might be the same width as int or as long
     - size_t might have different width and signedness as INTERNAL_SIZE_T
     - int and long might be 32 or 64 bits, and might be the same width
  To deal with this, most comparisons and difference computations
  among INTERNAL_SIZE_Ts should cast them to CHUNK_SIZE_T, being
  aware of the fact that casting an unsigned int to a wider long does
  not sign-extend. (This also makes checking for negative numbers
  awkward.) Some of these casts result in harmless compiler warnings
  on some systems.
*/
d621 1
a621 2
#ifndef INTERNAL_SIZE_T
#define INTERNAL_SIZE_T size_t
d624 1
a624 2
/* The corresponding word size */
#define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))
d626 1
d628 17
d646 2
a647 11
/*
  MALLOC_ALIGNMENT is the minimum alignment for malloc'ed chunks.
  It must be a power of two at least 2 * SIZE_SZ, even on machines
  for which smaller alignments would suffice. It may be defined as
  larger than this though. Note however that code and data structures
  are optimized for the case of 8-byte alignment.
*/


#ifndef MALLOC_ALIGNMENT
#define MALLOC_ALIGNMENT       (2 * SIZE_SZ)
a649 5
/* The corresponding bit mask value */
#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)



d651 12
a662 4
  REALLOC_ZERO_BYTES_FREES should be set if a call to
  realloc with zero bytes should be the same as a call to free.
  Some people think it should. Otherwise, since this malloc
  returns a unique pointer for malloc(0), so does realloc(p, 0).
d664 1
a664 2

/*   #define REALLOC_ZERO_BYTES_FREES */
d667 5
a671 13
  TRIM_FASTBINS controls whether free() of a very small chunk can
  immediately lead to trimming. Setting to true (1) can reduce memory
  footprint, but will almost always slow down programs that use a lot
  of small chunks.

  Define this only if you are willing to give up some speed to more
  aggressively reduce system-level memory footprint when releasing
  memory in programs that use many small chunks.  You can get
  essentially the same effect by setting MXFAST to 0, but this can
  lead to even greater slowdowns in programs using many small chunks.
  TRIM_FASTBINS is an in-between compile-time option, that disables
  only those chunks bordering topmost memory from being placed in
  fastbins.
d673 1
a673 5

#ifndef TRIM_FASTBINS
#define TRIM_FASTBINS  0
#endif

d676 3
a678 3
  USE_DL_PREFIX will prefix all public routines with the string 'dl'.
  This is necessary when you only want to use this malloc in one part
  of a program, using your regular system malloc elsewhere.
d680 1
a680 3

/* #define USE_DL_PREFIX */

d683 4
a686 2
  USE_MALLOC_LOCK causes wrapper functions to surround each
  callable routine with pthread mutex lock/unlock.
d688 3
a690 2
  USE_MALLOC_LOCK forces USE_PUBLIC_MALLOC_WRAPPERS to be defined
*/
d692 1
d694 2
a695 1
/* #define USE_MALLOC_LOCK */
d697 3
d701 2
a702 8
/*
  If USE_PUBLIC_MALLOC_WRAPPERS is defined, every public routine is
  actually a wrapper function that first calls MALLOC_PREACTION, then
  calls the internal routine, and follows it with
  MALLOC_POSTACTION. This is needed for locking, but you can also use
  this, without USE_MALLOC_LOCK, for purposes of interception,
  instrumentation, etc. It is a sad fact that using wrappers often
  noticeably degrades performance of malloc-intensive programs.
d705 1
a705 6
#ifdef USE_MALLOC_LOCK
#define USE_PUBLIC_MALLOC_WRAPPERS
#else
/* #define USE_PUBLIC_MALLOC_WRAPPERS */
#endif

d708 3
a710 5
   Two-phase name translation.
   All of the actual routines are given mangled names.
   When wrappers are used, they become the public callable versions.
   When DL_PREFIX is used, the callable names are prefixed.
*/
d712 4
a715 51
#ifndef USE_PUBLIC_MALLOC_WRAPPERS
#define cALLOc      public_cALLOc
#define fREe        public_fREe
#define cFREe       public_cFREe
#define mALLOc      public_mALLOc
#define mEMALIGn    public_mEMALIGn
#define rEALLOc     public_rEALLOc
#define vALLOc      public_vALLOc
#define pVALLOc     public_pVALLOc
#define mALLINFo    public_mALLINFo
#define mALLOPt     public_mALLOPt
#define mTRIm       public_mTRIm
#define mSTATs      public_mSTATs
#define mUSABLe     public_mUSABLe
#define iCALLOc     public_iCALLOc
#define iCOMALLOc   public_iCOMALLOc
#endif

#ifdef USE_DL_PREFIX
#define public_cALLOc    dlcalloc
#define public_fREe      dlfree
#define public_cFREe     dlcfree
#define public_mALLOc    dlmalloc
#define public_mEMALIGn  dlmemalign
#define public_rEALLOc   dlrealloc
#define public_vALLOc    dlvalloc
#define public_pVALLOc   dlpvalloc
#define public_mALLINFo  dlmallinfo
#define public_mALLOPt   dlmallopt
#define public_mTRIm     dlmalloc_trim
#define public_mSTATs    dlmalloc_stats
#define public_mUSABLe   dlmalloc_usable_size
#define public_iCALLOc   dlindependent_calloc
#define public_iCOMALLOc dlindependent_comalloc
#else /* USE_DL_PREFIX */
#define public_cALLOc    calloc
#define public_fREe      free
#define public_cFREe     cfree
#define public_mALLOc    malloc
#define public_mEMALIGn  memalign
#define public_rEALLOc   realloc
#define public_vALLOc    valloc
#define public_pVALLOc   pvalloc
#define public_mALLINFo  mallinfo
#define public_mALLOPt   mallopt
#define public_mTRIm     malloc_trim
#define public_mSTATs    malloc_stats
#define public_mUSABLe   malloc_usable_size
#define public_iCALLOc   independent_calloc
#define public_iCOMALLOc independent_comalloc
#endif /* USE_DL_PREFIX */
d717 3
d722 3
a724 11
  HAVE_MEMCPY should be defined if you are not otherwise using
  ANSI STD C, but still have memcpy and memset in your C library
  and want to use them in calloc and realloc. Otherwise simple
  macro versions are defined below.

  USE_MEMCPY should be defined as 1 if you actually want to
  have memset and memcpy called. People report that the macro
  versions are faster than libc versions on some systems.

  Even if USE_MEMCPY is set to 1, loops to copy/clear small chunks
  (of <= 36 bytes) are manually unrolled in realloc and calloc.
d726 1
a726 26

#define HAVE_MEMCPY

#ifndef USE_MEMCPY
#ifdef HAVE_MEMCPY
#define USE_MEMCPY 1
#else
#define USE_MEMCPY 0
#endif
#endif


#if (__STD_C || defined(HAVE_MEMCPY))

#ifdef WIN32
/* On Win32 memset and memcpy are already declared in windows.h */
#else
#if __STD_C
void* memset(void*, int, size_t);
void* memcpy(void*, const void*, size_t);
#else
Void_t* memset();
Void_t* memcpy();
#endif
#endif
#endif
d729 11
a739 3
  MALLOC_FAILURE_ACTION is the action to take before "return 0" when
  malloc fails to be able to return memory, either because memory is
  exhausted or because of illegal arguments.
d741 4
a744 1
  By default, sets errno if running on STD_C platform, else does nothing.
d746 1
a746 10

#ifndef MALLOC_FAILURE_ACTION
#if __STD_C
#define MALLOC_FAILURE_ACTION \
   errno = ENOMEM;

#else
#define MALLOC_FAILURE_ACTION
#endif
#endif
d749 7
a755 1
  MORECORE-related declarations. By default, rely on sbrk
d757 1
d759 1
a759 11

#ifdef LACKS_UNISTD_H
#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
#if __STD_C
extern Void_t*     sbrk(ptrdiff_t);
#else
extern Void_t*     sbrk();
#endif
#endif
#endif

d761 2
a762 5
  MORECORE is the name of the routine to call to obtain more memory
  from the system.  See below for general guidance on writing
  alternative MORECORE functions, as well as a version for WIN32 and a
  sample version for pre-OSX macos.
*/
d764 13
a776 3
#ifndef MORECORE
#define MORECORE sbrk
#endif
d778 3
a780 5
/*
  MORECORE_FAILURE is the value returned upon failure of MORECORE
  as well as mmap. Since it cannot be an otherwise valid memory address,
  and must reflect values of standard sys calls, you probably ought not
  try to redefine it.
d782 1
a782 3

#ifndef MORECORE_FAILURE
#define MORECORE_FAILURE (-1)
d786 1
a786 8
  If MORECORE_CONTIGUOUS is true, take advantage of fact that
  consecutive calls to MORECORE with positive arguments always return
  contiguous increasing addresses.  This is true of unix sbrk.  Even
  if not defined, when regions happen to be contiguous, malloc will
  permit allocations spanning regions obtained from different
  calls. But defining this when applicable enables some stronger
  consistency checks and space efficiencies.
*/
d788 1
a788 378
#ifndef MORECORE_CONTIGUOUS
#define MORECORE_CONTIGUOUS 1
#endif

/*
  Define MORECORE_CANNOT_TRIM if your version of MORECORE
  cannot release space back to the system when given negative
  arguments. This is generally necessary only if you are using
  a hand-crafted MORECORE function that cannot handle negative arguments.
*/

/* #define MORECORE_CANNOT_TRIM */


/*
  Define HAVE_MMAP as true to optionally make malloc() use mmap() to
  allocate very large blocks.  These will be returned to the
  operating system immediately after a free(). Also, if mmap
  is available, it is used as a backup strategy in cases where
  MORECORE fails to provide space from system.

  This malloc is best tuned to work with mmap for large requests.
  If you do not have mmap, operations involving very large chunks (1MB
  or so) may be slower than you'd like.
*/

#ifndef HAVE_MMAP
#define HAVE_MMAP 1
#endif

#if HAVE_MMAP
/*
   Standard unix mmap using /dev/zero clears memory so calloc doesn't
   need to.
*/

#ifndef MMAP_CLEARS
#define MMAP_CLEARS 1
#endif

#else /* no mmap */
#ifndef MMAP_CLEARS
#define MMAP_CLEARS 0
#endif
#endif


/*
   MMAP_AS_MORECORE_SIZE is the minimum mmap size argument to use if
   sbrk fails, and mmap is used as a backup (which is done only if
   HAVE_MMAP).  The value must be a multiple of page size.  This
   backup strategy generally applies only when systems have "holes" in
   address space, so sbrk cannot perform contiguous expansion, but
   there is still space available on system.  On systems for which
   this is known to be useful (i.e. most linux kernels), this occurs
   only when programs allocate huge amounts of memory.  Between this,
   and the fact that mmap regions tend to be limited, the size should
   be large, to avoid too many mmap calls and thus avoid running out
   of kernel resources.
*/

#ifndef MMAP_AS_MORECORE_SIZE
#define MMAP_AS_MORECORE_SIZE (1024 * 1024)
#endif

/*
  Define HAVE_MREMAP to make realloc() use mremap() to re-allocate
  large blocks.  This is currently only possible on Linux with
  kernel versions newer than 1.3.77.
*/

#ifndef HAVE_MREMAP
#ifdef linux
#define HAVE_MREMAP 1
#else
#define HAVE_MREMAP 0
#endif

#endif /* HAVE_MMAP */


/*
  The system page size. To the extent possible, this malloc manages
  memory from the system in page-size units.  Note that this value is
  cached during initialization into a field of malloc_state. So even
  if malloc_getpagesize is a function, it is only called once.

  The following mechanics for getpagesize were adapted from bsd/gnu
  getpagesize.h. If none of the system-probes here apply, a value of
  4096 is used, which should be OK: If they don't apply, then using
  the actual value probably doesn't impact performance.
*/


#ifndef malloc_getpagesize

#ifndef LACKS_UNISTD_H
#  include <unistd.h>
#endif

#  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
#    ifndef _SC_PAGE_SIZE
#      define _SC_PAGE_SIZE _SC_PAGESIZE
#    endif
#  endif

#  ifdef _SC_PAGE_SIZE
#    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
#  else
#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
       extern size_t getpagesize();
#      define malloc_getpagesize getpagesize()
#    else
#      ifdef WIN32 /* use supplied emulation of getpagesize */
#        define malloc_getpagesize getpagesize()
#      else
#        ifndef LACKS_SYS_PARAM_H
#          include <sys/param.h>
#        endif
#        ifdef EXEC_PAGESIZE
#          define malloc_getpagesize EXEC_PAGESIZE
#        else
#          ifdef NBPG
#            ifndef CLSIZE
#              define malloc_getpagesize NBPG
#            else
#              define malloc_getpagesize (NBPG * CLSIZE)
#            endif
#          else
#            ifdef NBPC
#              define malloc_getpagesize NBPC
#            else
#              ifdef PAGESIZE
#                define malloc_getpagesize PAGESIZE
#              else /* just guess */
#                define malloc_getpagesize (4096)
#              endif
#            endif
#          endif
#        endif
#      endif
#    endif
#  endif
#endif

/*
  This version of malloc supports the standard SVID/XPG mallinfo
  routine that returns a struct containing usage properties and
  statistics. It should work on any SVID/XPG compliant system that has
  a /usr/include/malloc.h defining struct mallinfo. (If you'd like to
  install such a thing yourself, cut out the preliminary declarations
  as described above and below and save them in a malloc.h file. But
  there's no compelling reason to bother to do this.)

  The main declaration needed is the mallinfo struct that is returned
  (by-copy) by mallinfo().  The SVID/XPG malloinfo struct contains a
  bunch of fields that are not even meaningful in this version of
  malloc.  These fields are are instead filled by mallinfo() with
  other numbers that might be of interest.

  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
  /usr/include/malloc.h file that includes a declaration of struct
  mallinfo.  If so, it is included; else an SVID2/XPG2 compliant
  version is declared below.  These must be precisely the same for
  mallinfo() to work.  The original SVID version of this struct,
  defined on most systems with mallinfo, declares all fields as
  ints. But some others define as unsigned long. If your system
  defines the fields using a type of different width than listed here,
  you must #include your system version and #define
  HAVE_USR_INCLUDE_MALLOC_H.
*/

/* #define HAVE_USR_INCLUDE_MALLOC_H */

#ifdef HAVE_USR_INCLUDE_MALLOC_H
#include "/usr/include/malloc.h"
#else

/* SVID2/XPG mallinfo structure */

struct mallinfo {
  int arena;    /* non-mmapped space allocated from system */
  int ordblks;  /* number of free chunks */
  int smblks;   /* number of fastbin blocks */
  int hblks;    /* number of mmapped regions */
  int hblkhd;   /* space in mmapped regions */
  int usmblks;  /* maximum total allocated space */
  int fsmblks;  /* space available in freed fastbin blocks */
  int uordblks; /* total allocated space */
  int fordblks; /* total free space */
  int keepcost; /* top-most, releasable (via malloc_trim) space */
};

/*
  SVID/XPG defines four standard parameter numbers for mallopt,
  normally defined in malloc.h.  Only one of these (M_MXFAST) is used
  in this malloc. The others (M_NLBLKS, M_GRAIN, M_KEEP) don't apply,
  so setting them has no effect. But this malloc also supports other
  options in mallopt described below.
*/
#endif


/* ---------- description of public routines ------------ */

/*
  malloc(size_t n)
  Returns a pointer to a newly allocated chunk of at least n bytes, or null
  if no space is available. Additionally, on failure, errno is
  set to ENOMEM on ANSI C systems.

  If n is zero, malloc returns a minumum-sized chunk. (The minimum
  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit
  systems.)  On most systems, size_t is an unsigned type, so calls
  with negative arguments are interpreted as requests for huge amounts
  of space, which will often fail. The maximum supported value of n
  differs across systems, but is in all cases less than the maximum
  representable value of a size_t.
*/
#if __STD_C
Void_t*  public_mALLOc(size_t);
#else
Void_t*  public_mALLOc();
#endif

/*
  free(Void_t* p)
  Releases the chunk of memory pointed to by p, that had been previously
  allocated using malloc or a related routine such as realloc.
  It has no effect if p is null. It can have arbitrary (i.e., bad!)
  effects if p has already been freed.

  Unless disabled (using mallopt), freeing very large spaces will
  when possible, automatically trigger operations that give
  back unused memory to the system, thus reducing program footprint.
*/
#if __STD_C
void     public_fREe(Void_t*);
#else
void     public_fREe();
#endif

/*
  calloc(size_t n_elements, size_t element_size);
  Returns a pointer to n_elements * element_size bytes, with all locations
  set to zero.
*/
#if __STD_C
Void_t*  public_cALLOc(size_t, size_t);
#else
Void_t*  public_cALLOc();
#endif

/*
  realloc(Void_t* p, size_t n)
  Returns a pointer to a chunk of size n that contains the same data
  as does chunk p up to the minimum of (n, p's size) bytes, or null
  if no space is available.

  The returned pointer may or may not be the same as p. The algorithm
  prefers extending p when possible, otherwise it employs the
  equivalent of a malloc-copy-free sequence.

  If p is null, realloc is equivalent to malloc.

  If space is not available, realloc returns null, errno is set (if on
  ANSI) and p is NOT freed.

  if n is for fewer bytes than already held by p, the newly unused
  space is lopped off and freed if possible.  Unless the #define
  REALLOC_ZERO_BYTES_FREES is set, realloc with a size argument of
  zero (re)allocates a minimum-sized chunk.

  Large chunks that were internally obtained via mmap will always
  be reallocated using malloc-copy-free sequences unless
  the system supports MREMAP (currently only linux).

  The old unix realloc convention of allowing the last-free'd chunk
  to be used as an argument to realloc is not supported.
*/
#if __STD_C
Void_t*  public_rEALLOc(Void_t*, size_t);
#else
Void_t*  public_rEALLOc();
#endif

/*
  memalign(size_t alignment, size_t n);
  Returns a pointer to a newly allocated chunk of n bytes, aligned
  in accord with the alignment argument.

  The alignment argument should be a power of two. If the argument is
  not a power of two, the nearest greater power is used.
  8-byte alignment is guaranteed by normal malloc calls, so don't
  bother calling memalign with an argument of 8 or less.

  Overreliance on memalign is a sure way to fragment space.
*/
#if __STD_C
Void_t*  public_mEMALIGn(size_t, size_t);
#else
Void_t*  public_mEMALIGn();
#endif

/*
  valloc(size_t n);
  Equivalent to memalign(pagesize, n), where pagesize is the page
  size of the system. If the pagesize is unknown, 4096 is used.
*/
#if __STD_C
Void_t*  public_vALLOc(size_t);
#else
Void_t*  public_vALLOc();
#endif



/*
  mallopt(int parameter_number, int parameter_value)
  Sets tunable parameters The format is to provide a
  (parameter-number, parameter-value) pair.  mallopt then sets the
  corresponding parameter to the argument value if it can (i.e., so
  long as the value is meaningful), and returns 1 if successful else
  0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,
  normally defined in malloc.h.  Only one of these (M_MXFAST) is used
  in this malloc. The others (M_NLBLKS, M_GRAIN, M_KEEP) don't apply,
  so setting them has no effect. But this malloc also supports four
  other options in mallopt. See below for details.  Briefly, supported
  parameters are as follows (listed defaults are for "typical"
  configurations).

  Symbol            param #   default    allowed param values
  M_MXFAST          1         64         0-80  (0 disables fastbins)
  M_TRIM_THRESHOLD -1         256*1024   any   (-1U disables trimming)
  M_TOP_PAD        -2         0          any
  M_MMAP_THRESHOLD -3         256*1024   any   (or 0 if no MMAP support)
  M_MMAP_MAX       -4         65536      any   (0 disables use of mmap)
*/
#if __STD_C
int      public_mALLOPt(int, int);
#else
int      public_mALLOPt();
#endif


/*
  mallinfo()
  Returns (by copy) a struct containing various summary statistics:

  arena:     current total non-mmapped bytes allocated from system
  ordblks:   the number of free chunks
  smblks:    the number of fastbin blocks (i.e., small chunks that
	       have been freed but not use resused or consolidated)
  hblks:     current number of mmapped regions
  hblkhd:    total bytes held in mmapped regions
  usmblks:   the maximum total allocated space. This will be greater
		than current total if trimming has occurred.
  fsmblks:   total bytes held in fastbin blocks
  uordblks:  current total allocated space (normal or mmapped)
  fordblks:  total free space
  keepcost:  the maximum number of bytes that could ideally be released
	       back to system via malloc_trim. ("ideally" means that
	       it ignores page restrictions etc.)

  Because these fields are ints, but internal bookkeeping may
  be kept as longs, the reported values may wrap around zero and
  thus be inaccurate.
*/
#if __STD_C
struct mallinfo public_mALLINFo(void);
#else
struct mallinfo public_mALLINFo();
#endif

/*
  independent_calloc(size_t n_elements, size_t element_size, Void_t* chunks[]);

  independent_calloc is similar to calloc, but instead of returning a
d837 1
a837 5
#if __STD_C
Void_t** public_iCALLOc(size_t, size_t, Void_t**);
#else
Void_t** public_iCALLOc();
#endif
d840 1
a840 1
  independent_comalloc(size_t n_elements, size_t sizes[], Void_t* chunks[]);
d898 1
a898 5
#if __STD_C
Void_t** public_iCOMALLOc(size_t, size_t*, Void_t**);
#else
Void_t** public_iCOMALLOc();
#endif
d906 1
a906 19
#if __STD_C
Void_t*  public_pVALLOc(size_t);
#else
Void_t*  public_pVALLOc();
#endif

/*
  cfree(Void_t* p);
  Equivalent to free(p).

  cfree is needed/defined on some systems that pair it with calloc,
  for odd historical reasons (such as: cfree is used in example
  code in the first edition of K&R).
*/
#if __STD_C
void     public_cFREe(Void_t*);
#else
void     public_cFREe();
#endif
d911 8
a918 8
  If possible, gives memory back to the system (via negative
  arguments to sbrk) if there is unused memory at the `high' end of
  the malloc pool. You can call this after freeing large blocks of
  memory to potentially reduce the system-level memory requirements
  of a program. However, it cannot guarantee to reduce memory. Under
  some allocation patterns, some large free blocks of memory will be
  locked between two used chunks, so they cannot be given back to
  the system.
d921 5
a925 6
  trailing space to leave untrimmed. If this argument is zero,
  only the minimum amount of memory to maintain internal data
  structures will be left (one page or less). Non-zero arguments
  can be supplied to maintain enough trailing space to service
  future expected allocations without having to re-obtain memory
  from the system.
a927 2
  On systems that do not support "negative sbrks", it will always
  rreturn 0.
d929 1
a929 5
#if __STD_C
int      public_mTRIm(size_t);
#else
int      public_mTRIm();
#endif
d932 1
a932 1
  malloc_usable_size(Void_t* p);
a943 1

d945 1
a945 5
#if __STD_C
size_t   public_mUSABLe(Void_t*);
#else
size_t   public_mUSABLe();
#endif
d965 2
a967 5
*/
#if __STD_C
void     public_mSTATs();
#else
void     public_mSTATs();
d970 1
a970 1
/* mallopt tuning options */
d973 2
a974 93
  M_MXFAST is the maximum request size used for "fastbins", special bins
  that hold returned chunks without consolidating their spaces. This
  enables future requests for chunks of the same size to be handled
  very quickly, but can increase fragmentation, and thus increase the
  overall memory footprint of a program.

  This malloc manages fastbins very conservatively yet still
  efficiently, so fragmentation is rarely a problem for values less
  than or equal to the default.  The maximum supported value of MXFAST
  is 80. You wouldn't want it any higher than this anyway.  Fastbins
  are designed especially for use with many small structs, objects or
  strings -- the default handles structs/objects/arrays with sizes up
  to 16 4byte fields, or small strings representing words, tokens,
  etc. Using fastbins for larger objects normally worsens
  fragmentation without improving speed.

  M_MXFAST is set in REQUEST size units. It is internally used in
  chunksize units, which adds padding and alignment.  You can reduce
  M_MXFAST to 0 to disable all use of fastbins.  This causes the malloc
  algorithm to be a closer approximation of fifo-best-fit in all cases,
  not just for larger requests, but will generally cause it to be
  slower.
*/


/* M_MXFAST is a standard SVID/XPG tuning option, usually listed in malloc.h */
#ifndef M_MXFAST
#define M_MXFAST            1
#endif

#ifndef DEFAULT_MXFAST
#define DEFAULT_MXFAST     64
#endif


/*
  M_TRIM_THRESHOLD is the maximum amount of unused top-most memory
  to keep before releasing via malloc_trim in free().

  Automatic trimming is mainly useful in long-lived programs.
  Because trimming via sbrk can be slow on some systems, and can
  sometimes be wasteful (in cases where programs immediately
  afterward allocate more large chunks) the value should be high
  enough so that your overall system performance would improve by
  releasing this much memory.

  The trim threshold and the mmap control parameters (see below)
  can be traded off with one another. Trimming and mmapping are
  two different ways of releasing unused memory back to the
  system. Between these two, it is often possible to keep
  system-level demands of a long-lived program down to a bare
  minimum. For example, in one test suite of sessions measuring
  the XF86 X server on Linux, using a trim threshold of 128K and a
  mmap threshold of 192K led to near-minimal long term resource
  consumption.

  If you are using this malloc in a long-lived program, it should
  pay to experiment with these values.  As a rough guide, you
  might set to a value close to the average size of a process
  (program) running on your system.  Releasing this much memory
  would allow such a process to run in memory.  Generally, it's
  worth it to tune for trimming rather tham memory mapping when a
  program undergoes phases where several large chunks are
  allocated and released in ways that can reuse each other's
  storage, perhaps mixed with phases where there are no such
  chunks at all.  And in well-behaved long-lived programs,
  controlling release of large blocks via trimming versus mapping
  is usually faster.

  However, in most programs, these parameters serve mainly as
  protection against the system-level effects of carrying around
  massive amounts of unneeded memory. Since frequent calls to
  sbrk, mmap, and munmap otherwise degrade performance, the default
  parameters are set to relatively high values that serve only as
  safeguards.

  The trim value must be greater than page size to have any useful
  effect.  To disable trimming completely, you can set to
  (unsigned long)(-1)

  Trim settings interact with fastbin (MXFAST) settings: Unless
  TRIM_FASTBINS is defined, automatic trimming never takes place upon
  freeing a chunk with size less than or equal to MXFAST. Trimming is
  instead delayed until subsequent freeing of larger chunks. However,
  you can still force an attempted trim by calling malloc_trim.

  Also, trimming is not generally possible in cases where
  the main arena is obtained via mmap.

  Note that the trick some people use of mallocing a huge space and
  then freeing it at program startup, in an attempt to reserve system
  memory, doesn't have the intended effect under automatic trimming,
  since that memory will immediately be returned to the system.
d976 1
d978 12
a989 1
#define M_TRIM_THRESHOLD       -1
d991 7
a997 3
#ifndef DEFAULT_TRIM_THRESHOLD
#define DEFAULT_TRIM_THRESHOLD (256 * 1024)
#endif
d1000 9
a1008 2
  M_TOP_PAD is the amount of extra `padding' space to allocate or
  retain whenever sbrk is called. It is used in two ways internally:
d1010 5
a1014 3
  * When sbrk is called to extend the top of the arena to satisfy
  a new malloc request, this much padding is added to the sbrk
  request.
d1016 3
a1018 2
  * When malloc_trim is called automatically from free(),
  it is used as the `pad' argument.
d1020 5
a1024 2
  In both cases, the actual amount of padding is rounded
  so that the end of the arena is always a system page boundary.
d1026 3
a1028 5
  The main reason for using padding is to avoid calling sbrk so
  often. Having even a small pad greatly reduces the likelihood
  that nearly every malloc request during program start-up (or
  after trimming) will invoke sbrk, which needlessly wastes
  time.
d1030 4
a1033 5
  Automatic rounding-up to page-size units is normally sufficient
  to avoid measurable overhead, so the default is 0.  However, in
  systems where sbrk is relatively slow, it can pay to increase
  this value, at the expense of carrying around more memory than
  the program needs.
d1035 1
d1037 5
a1041 1
#define M_TOP_PAD              -2
d1043 5
a1047 3
#ifndef DEFAULT_TOP_PAD
#define DEFAULT_TOP_PAD        (0)
#endif
d1050 5
a1054 4
  M_MMAP_THRESHOLD is the request size threshold for using mmap()
  to service a request. Requests of at least this size that cannot
  be allocated using already-existing space will be serviced via mmap.
  (If enough normal freed space already exists it is used instead.)
d1056 6
a1061 5
  Using mmap segregates relatively large chunks of memory so that
  they can be individually obtained and released from the host
  system. A request serviced through mmap is never reused by any
  other request (at least not directly; the system may just so
  happen to remap successive requests to the same locations).
d1063 5
a1067 1
  Segregating space in this way has the benefits that:
a1068 8
   1. Mmapped space can ALWAYS be individually released back
      to the system, which helps keep the system level memory
      demands of a long-lived program low.
   2. Mapped memory can never become `locked' between
      other chunks, as can happen with normally allocated chunks, which
      means that even trimming via malloc_trim would not release them.
   3. On some systems with "holes" in address spaces, mmap can obtain
      memory that sbrk cannot.
d1070 4
a1073 16
  However, it has the disadvantages that:

   1. The space cannot be reclaimed, consolidated, and then
      used to service later requests, as happens with normal chunks.
   2. It can lead to more wastage because of mmap page alignment
      requirements
   3. It causes malloc performance to be more dependent on host
      system memory management support routines which may vary in
      implementation quality and may impose arbitrary
      limitations. Generally, servicing a request via normal
      malloc steps is faster than going through a system's mmap.

  The advantages of mmap nearly always outweigh disadvantages for
  "large" chunks, but the value of "large" varies across systems.  The
  default is an empirically derived value that works well in most
  systems.
d1075 1
a1075 7

#define M_MMAP_THRESHOLD      -3

#define DEFAULT_MMAP_THRESHOLD (16 * 1024 * 1024)

#ifndef DEFAULT_MMAP_THRESHOLD
#define DEFAULT_MMAP_THRESHOLD (256 * 1024)
d1079 4
a1082 5
  M_MMAP_MAX is the maximum number of requests to simultaneously
  service using mmap. This parameter exists because
. Some systems have a limited number of internal tables for
  use by mmap, and using more than a few of them may degrade
  performance.
d1084 3
a1086 4
  The default is set to a value that serves only as a safeguard.
  Setting to 0 disables use of mmap for servicing large requests.  If
  HAVE_MMAP is not set, the default value is 0, and attempts to set it
  to non-zero values in mallopt will fail.
d1088 1
d1090 4
a1093 1
#define M_MMAP_MAX             -4
a1094 6
#ifndef DEFAULT_MMAP_MAX
#if HAVE_MMAP
#define DEFAULT_MMAP_MAX       (65536)
#else
#define DEFAULT_MMAP_MAX       (0)
#endif
d1111 1
a1111 1
/* --------------------- public wrappers ---------------------- */
d1113 2
a1114 35
#ifdef USE_PUBLIC_MALLOC_WRAPPERS

/* Declare all routines as internal */
#if __STD_C
static Void_t*  mALLOc(size_t);
static void     fREe(Void_t*);
static Void_t*  rEALLOc(Void_t*, size_t);
static Void_t*  mEMALIGn(size_t, size_t);
static Void_t*  vALLOc(size_t);
static Void_t*  pVALLOc(size_t);
static Void_t*  cALLOc(size_t, size_t);
static Void_t** iCALLOc(size_t, size_t, Void_t**);
static Void_t** iCOMALLOc(size_t, size_t*, Void_t**);
static void     cFREe(Void_t*);
static int      mTRIm(size_t);
static size_t   mUSABLe(Void_t*);
static void     mSTATs();
static int      mALLOPt(int, int);
static struct mallinfo mALLINFo(void);
#else
static Void_t*  mALLOc();
static void     fREe();
static Void_t*  rEALLOc();
static Void_t*  mEMALIGn();
static Void_t*  vALLOc();
static Void_t*  pVALLOc();
static Void_t*  cALLOc();
static Void_t** iCALLOc();
static Void_t** iCOMALLOc();
static void     cFREe();
static int      mTRIm();
static size_t   mUSABLe();
static void     mSTATs();
static int      mALLOPt();
static struct mallinfo mALLINFo();
d1117 1
a1117 16
/*
  MALLOC_PREACTION and MALLOC_POSTACTION should be
  defined to return 0 on success, and nonzero on failure.
  The return value of MALLOC_POSTACTION is currently ignored
  in wrapper functions since there is no reasonable default
  action to take on failure.
*/


#ifdef USE_MALLOC_LOCK

#ifdef WIN32

static int mALLOC_MUTEx;
#define MALLOC_PREACTION   slwait(&mALLOC_MUTEx)
#define MALLOC_POSTACTION  slrelease(&mALLOC_MUTEx)
d1119 15
d1135 21
a1155 10

#include <pthread.h>

static pthread_mutex_t mALLOC_MUTEx = PTHREAD_MUTEX_INITIALIZER;

#define MALLOC_PREACTION   pthread_mutex_lock(&mALLOC_MUTEx)
#define MALLOC_POSTACTION  pthread_mutex_unlock(&mALLOC_MUTEx)

#endif /* USE_MALLOC_LOCK */

d1157 5
d1163 45
a1207 5
/* Substitute anything you like for these */

#define MALLOC_PREACTION   (0)
#define MALLOC_POSTACTION  (0)

d1210 1
a1210 29
Void_t* public_mALLOc(size_t bytes) {
  Void_t* m;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = mALLOc(bytes);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}

void public_fREe(Void_t* m) {
  if (MALLOC_PREACTION != 0) {
    return;
  }
  fREe(m);
  if (MALLOC_POSTACTION != 0) {
  }
}

Void_t* public_rEALLOc(Void_t* m, size_t bytes) {
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = rEALLOc(m, bytes);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
d1212 3
a1214 10
Void_t* public_mEMALIGn(size_t alignment, size_t bytes) {
  Void_t* m;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = mEMALIGn(alignment, bytes);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
d1216 2
a1217 10
Void_t* public_vALLOc(size_t bytes) {
  Void_t* m;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = vALLOc(bytes);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
d1219 2
a1220 12
#ifdef NEED_PVALLOC
Void_t* public_pVALLOc(size_t bytes) {
  Void_t* m;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = pVALLOc(bytes);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
#endif
d1222 2
a1223 10
Void_t* public_cALLOc(size_t n, size_t elem_size) {
  Void_t* m;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = cALLOc(n, elem_size);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
d1225 4
d1230 1
a1230 10
Void_t** public_iCALLOc(size_t n, size_t elem_size, Void_t** chunks) {
  Void_t** m;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = iCALLOc(n, elem_size, chunks);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
d1232 5
a1236 10
Void_t** public_iCOMALLOc(size_t n, size_t sizes[], Void_t** chunks) {
  Void_t** m;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  m = iCOMALLOc(n, sizes, chunks);
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
a1237 8
void public_cFREe(Void_t* m) {
  if (MALLOC_PREACTION != 0) {
    return;
  }
  cFREe(m);
  if (MALLOC_POSTACTION != 0) {
  }
}
d1239 3
a1241 10
int public_mTRIm(size_t s) {
  int result;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  result = mTRIm(s);
  if (MALLOC_POSTACTION != 0) {
  }
  return result;
}
d1243 6
a1248 10
size_t public_mUSABLe(Void_t* m) {
  size_t result;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  result = mUSABLe(m);
  if (MALLOC_POSTACTION != 0) {
  }
  return result;
}
d1250 56
a1305 6
void public_mSTATs() {
  if (MALLOC_PREACTION != 0) {
    return;
  }
  mSTATs();
  if (MALLOC_POSTACTION != 0) {
d1307 1
d1310 5
a1314 11
struct mallinfo public_mALLINFo() {
  struct mallinfo m;
  if (MALLOC_PREACTION != 0) {
    struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    return nm;
  }
  m = mALLINFo();
  if (MALLOC_POSTACTION != 0) {
  }
  return m;
}
d1316 5
a1320 10
int public_mALLOPt(int p, int v) {
  int result;
  if (MALLOC_PREACTION != 0) {
    return 0;
  }
  result = mALLOPt(p, v);
  if (MALLOC_POSTACTION != 0) {
  }
  return result;
}
d1322 4
d1328 2
d1331 1
d1333 1
a1333 1
/* ------------- Optional versions of memcopy ---------------- */
d1335 2
d1338 6
a1343 1
#if USE_MEMCPY
d1345 2
a1346 3
/*
  Note: memcpy is ONLY invoked with non-overlapping regions,
  so the (usually slower) memmove is not needed.
d1349 6
a1354 54
#define MALLOC_COPY(dest, src, nbytes)  memcpy(dest, src, nbytes)
#define MALLOC_ZERO(dest, nbytes)       memset(dest, 0,   nbytes)

#else /* !USE_MEMCPY */

/* Use Duff's device for good zeroing/copying performance. */

#define MALLOC_ZERO(charp, nbytes)                                            \
do {                                                                          \
  INTERNAL_SIZE_T* mzp = (INTERNAL_SIZE_T*)(charp);                           \
  CHUNK_SIZE_T  mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T);                     \
  long mcn;                                                                   \
  if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; }             \
  switch (mctmp) {                                                            \
    case 0: for(;;) { *mzp++ = 0;                                             \
    case 7:           *mzp++ = 0;                                             \
    case 6:           *mzp++ = 0;                                             \
    case 5:           *mzp++ = 0;                                             \
    case 4:           *mzp++ = 0;                                             \
    case 3:           *mzp++ = 0;                                             \
    case 2:           *mzp++ = 0;                                             \
    case 1:           *mzp++ = 0; if(mcn <= 0) break; mcn--; }                \
  }                                                                           \
} while(0)

#define MALLOC_COPY(dest,src,nbytes)                                          \
do {                                                                          \
  INTERNAL_SIZE_T* mcsrc = (INTERNAL_SIZE_T*) src;                            \
  INTERNAL_SIZE_T* mcdst = (INTERNAL_SIZE_T*) dest;                           \
  CHUNK_SIZE_T  mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T);                     \
  long mcn;                                                                   \
  if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; }             \
  switch (mctmp) {                                                            \
    case 0: for(;;) { *mcdst++ = *mcsrc++;                                    \
    case 7:           *mcdst++ = *mcsrc++;                                    \
    case 6:           *mcdst++ = *mcsrc++;                                    \
    case 5:           *mcdst++ = *mcsrc++;                                    \
    case 4:           *mcdst++ = *mcsrc++;                                    \
    case 3:           *mcdst++ = *mcsrc++;                                    \
    case 2:           *mcdst++ = *mcsrc++;                                    \
    case 1:           *mcdst++ = *mcsrc++; if(mcn <= 0) break; mcn--; }       \
  }                                                                           \
} while(0)

#endif

/* ------------------ MMAP support ------------------  */


#if HAVE_MMAP

#ifndef LACKS_FCNTL_H
#include <fcntl.h>
#endif
d1356 2
a1357 2
#ifndef LACKS_SYS_MMAN_H
#include <sys/mman.h>
d1360 2
a1361 2
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
d1364 1
d1366 2
a1367 3
   Nearly all versions of mmap support MAP_ANONYMOUS,
   so the following is unlikely to be needed, but is
   supplied just in case.
d1370 9
a1378 14
#ifndef MAP_ANONYMOUS

static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */

#define MMAP(addr, size, prot, flags) ((dev_zero_fd < 0) ? \
 (dev_zero_fd = open("/dev/zero", O_RDWR), \
  mmap((addr), (size), (prot), (flags), dev_zero_fd, 0)) : \
   mmap((addr), (size), (prot), (flags), dev_zero_fd, 0))

#else

#define MMAP(addr, size, prot, flags) \
 (mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS, -1, 0))

d1380 3
d1384 3
d1388 166
a1553 7
#endif /* HAVE_MMAP */


/*
  -----------------------  Chunk representations -----------------------
*/

a1554 4
/*
  This struct declaration is misleading (but accurate and necessary).
  It declares a "view" into memory allowing access to necessary
  fields at known offsets from a given base. See explanation below.
d1558 2
a1559 4

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

d1564 1
a1564 1

d1566 4
d1571 1
a1571 2
/*
   malloc_chunk details:
d1573 1
a1573 1
    (The following includes lightly edited explanations by Colin Plumb.)
d1575 5
a1579 8
    Chunks of memory are maintained using a `boundary tag' method as
    described in e.g., Knuth or Standish.  (See the paper by Paul
    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a
    survey of such techniques.)  Sizes of free chunks are stored both
    in the front of each chunk and at the end.  This makes
    consolidating fragmented chunks into bigger chunks very fast.  The
    size fields also hold bits representing whether chunks are free or
    in use.
d1581 4
a1584 1
    An allocated chunk looks like this:
d1586 3
d1590 5
a1594 1205
    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if allocated            | |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             User data starts here...                          .
	    .                                                               .
	    .             (malloc_usable_space() bytes)                     .
	    .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk                                     |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    Where "chunk" is the front of the chunk for the purpose of most of
    the malloc code, but "mem" is the pointer that is returned to the
    user.  "Nextchunk" is the beginning of the next contiguous chunk.

    Chunks always begin on even word boundries, so the mem portion
    (which is returned to the user) is also on an even word boundary, and
    thus at least double-word aligned.

    Free chunks are stored in circular doubly-linked lists, and look like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    The P (PREV_INUSE) bit, stored in the unused low-order bit of the
    chunk size (which is always a multiple of two words), is an in-use
    bit for the *previous* chunk.  If that bit is *clear*, then the
    word before the current chunk size contains the previous chunk
    size, and can be used to find the front of the previous chunk.
    The very first chunk allocated always has this bit set,
    preventing access to non-existent (or non-owned) memory. If
    prev_inuse is set for any given chunk, then you CANNOT determine
    the size of the previous chunk, and might even get a memory
    addressing fault when trying to do so.

    Note that the `foot' of the current chunk is actually represented
    as the prev_size of the NEXT chunk. This makes it easier to
    deal with alignments etc but can be very confusing when trying
    to extend or adapt this code.

    The two exceptions to all this are

     1. The special chunk `top' doesn't bother using the
	trailing size field since there is no next contiguous chunk
	that would have to index off it. After initialization, `top'
	is forced to always exist.  If it would become less than
	MINSIZE bytes long, it is replenished.

     2. Chunks allocated via mmap, which have the second-lowest-order
	bit (IS_MMAPPED) set in their size fields.  Because they are
	allocated one-by-one, each must contain its own trailing size field.

*/

/*
  ---------- Size and alignment checks and conversions ----------
*/

/* conversion from malloc headers to user pointers, and back */

#define chunk2mem(p)   ((Void_t*)((char*)(p) + 2*SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))

/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (sizeof(struct malloc_chunk))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
  (CHUNK_SIZE_T)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))

/* Check if m has acceptable alignment */

#define aligned_OK(m)  (((PTR_UINT)((m)) & (MALLOC_ALIGN_MASK)) == 0)


/*
   Check if a request is so large that it would wrap around zero when
   padded and aligned. To simplify some other code, the bound is made
   low enough so that adding MINSIZE will also not wrap around sero.
*/

#define REQUEST_OUT_OF_RANGE(req)                                 \
  ((CHUNK_SIZE_T)(req) >=                                        \
   (CHUNK_SIZE_T)(INTERNAL_SIZE_T)(-2 * MINSIZE))

/* pad request bytes into a usable size -- internal version */

#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/*  Same, except also perform argument check */

#define checked_request2size(req, sz)                             \
  if (REQUEST_OUT_OF_RANGE(req)) {                                \
    MALLOC_FAILURE_ACTION;                                        \
    return 0;                                                     \
  }                                                               \
  (sz) = request2size(req);

/*
  --------------- Physical chunk operations ---------------
*/


/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)

/*
  Bits to mask off when extracting size

  Note: IS_MMAPPED is intentionally not masked off from size field in
  macros for which mmapped chunks should never be seen. This should
  cause helpful core dumps to occur if it is tried by accident by
  people extending or adapting this malloc.
*/
#define SIZE_BITS (PREV_INUSE|IS_MMAPPED)

/* Get size, ignoring use bits */
#define chunksize(p)         ((p)->size & ~(SIZE_BITS))


/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->size & ~PREV_INUSE) ))

/* Ptr to previous physical malloc_chunk */
#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_size) ))

/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))

/* extract p's inuse bit */
#define inuse(p)\
((((mchunkptr)(((char*)(p))+((p)->size & ~PREV_INUSE)))->size) & PREV_INUSE)

/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)\
((mchunkptr)(((char*)(p)) + ((p)->size & ~PREV_INUSE)))->size |= PREV_INUSE

#define clear_inuse(p)\
((mchunkptr)(((char*)(p)) + ((p)->size & ~PREV_INUSE)))->size &= ~(PREV_INUSE)


/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)\
 (((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)

#define set_inuse_bit_at_offset(p, s)\
 (((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)

#define clear_inuse_bit_at_offset(p, s)\
 (((mchunkptr)(((char*)(p)) + (s)))->size &= ~(PREV_INUSE))


/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->size = (((p)->size & PREV_INUSE) | (s)))

/* Set size/use field */
#define set_head(p, s)       ((p)->size = (s))

/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr)((char*)(p) + (s)))->prev_size = (s))


/*
  -------------------- Internal data structures --------------------

   All internal state is held in an instance of malloc_state defined
   below. There are no other static variables, except in two optional
   cases:
   * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.
   * If HAVE_MMAP is true, but mmap doesn't support
     MAP_ANONYMOUS, a dummy file descriptor for mmap.

   Beware of lots of tricks that minimize the total bookkeeping space
   requirements. The result is a little over 1K bytes (for 4byte
   pointers and size_t.)
*/

/*
  Bins

    An array of bin headers for free chunks. Each bin is doubly
    linked.  The bins are approximately proportionally (log) spaced.
    There are a lot of these bins (128). This may look excessive, but
    works very well in practice.  Most bins hold sizes that are
    unusual as malloc request sizes, but are more usual for fragments
    and consolidated sets of chunks, which is what these bins hold, so
    they can be found quickly.  All procedures maintain the invariant
    that no consolidated chunk physically borders another one, so each
    chunk in a list is known to be preceeded and followed by either
    inuse chunks or the ends of memory.

    Chunks in bins are kept in size order, with ties going to the
    approximately least recently used chunk. Ordering isn't needed
    for the small bins, which all contain the same-sized chunks, but
    facilitates best-fit allocation for larger chunks. These lists
    are just sequential. Keeping them in order almost never requires
    enough traversal to warrant using fancier ordered data
    structures.

    Chunks of the same size are linked with the most
    recently freed at the front, and allocations are taken from the
    back.  This results in LRU (FIFO) allocation order, which tends
    to give each chunk an equal opportunity to be consolidated with
    adjacent freed chunks, resulting in larger free chunks and less
    fragmentation.

    To simplify use in double-linked lists, each bin header acts
    as a malloc_chunk. This avoids special-casing for headers.
    But to conserve space and improve locality, we allocate
    only the fd/bk pointers of bins, and then use repositioning tricks
    to treat these as the fields of a malloc_chunk*.
*/

typedef struct malloc_chunk* mbinptr;

/* addressing -- note that bin_at(0) does not exist */
#define bin_at(m, i) ((mbinptr)((char*)&((m)->bins[(i)<<1]) - (SIZE_SZ<<1)))

/* analog of ++bin */
#define next_bin(b)  ((mbinptr)((char*)(b) + (sizeof(mchunkptr)<<1)))

/* Reminders about list directionality within bins */
#define first(b)     ((b)->fd)
#define last(b)      ((b)->bk)

/* Take a chunk off a bin list */
#define unlink(P, BK, FD) {                                            \
  FD = P->fd;                                                          \
  BK = P->bk;                                                          \
  FD->bk = BK;                                                         \
  BK->fd = FD;                                                         \
}

/*
  Indexing

    Bins for sizes < 512 bytes contain chunks of all the same size, spaced
    8 bytes apart. Larger bins are approximately logarithmically spaced:

    64 bins of size       8
    32 bins of size      64
    16 bins of size     512
     8 bins of size    4096
     4 bins of size   32768
     2 bins of size  262144
     1 bin  of size what's left

    The bins top out around 1MB because we expect to service large
    requests via mmap.
*/

#define NBINS              96
#define NSMALLBINS         32
#define SMALLBIN_WIDTH      8
#define MIN_LARGE_SIZE    256

#define in_smallbin_range(sz)  \
  ((CHUNK_SIZE_T)(sz) < (CHUNK_SIZE_T)MIN_LARGE_SIZE)

#define smallbin_index(sz)     (((unsigned)(sz)) >> 3)

/*
  Compute index for size. We expect this to be inlined when
  compiled with optimization, else not, which works out well.
*/
static int largebin_index(unsigned int sz) {
  unsigned int  x = sz >> SMALLBIN_WIDTH;
  unsigned int m;            /* bit position of highest set bit of m */

  if (x >= 0x10000) return NBINS-1;

  /* On intel, use BSRL instruction to find highest bit */
#if defined(__GNUC__) && defined(i386)

  __asm__("bsrl %1,%0\n\t"
	  : "=r" (m)
	  : "g"  (x));

#else
  {
    /*
      Based on branch-free nlz algorithm in chapter 5 of Henry
      S. Warren Jr's book "Hacker's Delight".
    */

    unsigned int n = ((x - 0x100) >> 16) & 8;
    x <<= n;
    m = ((x - 0x1000) >> 16) & 4;
    n += m;
    x <<= m;
    m = ((x - 0x4000) >> 16) & 2;
    n += m;
    x = (x << m) >> 14;
    m = 13 - n + (x & ~(x>>1));
  }
#endif

  /* Use next 2 bits to create finer-granularity bins */
  return NSMALLBINS + (m << 2) + ((sz >> (m + 6)) & 3);
}

#define bin_index(sz) \
 ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))

/*
  FIRST_SORTED_BIN_SIZE is the chunk size corresponding to the
  first bin that is maintained in sorted order. This must
  be the smallest size corresponding to a given bin.

  Normally, this should be MIN_LARGE_SIZE. But you can weaken
  best fit guarantees to sometimes speed up malloc by increasing value.
  Doing this means that malloc may choose a chunk that is
  non-best-fitting by up to the width of the bin.

  Some useful cutoff values:
      512 - all bins sorted
     2560 - leaves bins <=     64 bytes wide unsorted
    12288 - leaves bins <=    512 bytes wide unsorted
    65536 - leaves bins <=   4096 bytes wide unsorted
   262144 - leaves bins <=  32768 bytes wide unsorted
       -1 - no bins sorted (not recommended!)
*/

#define FIRST_SORTED_BIN_SIZE MIN_LARGE_SIZE
/* #define FIRST_SORTED_BIN_SIZE 65536 */

/*
  Unsorted chunks

    All remainders from chunk splits, as well as all returned chunks,
    are first placed in the "unsorted" bin. They are then placed
    in regular bins after malloc gives them ONE chance to be used before
    binning. So, basically, the unsorted_chunks list acts as a queue,
    with chunks being placed on it in free (and malloc_consolidate),
    and taken off (to be either used or placed in bins) in malloc.
*/

/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */
#define unsorted_chunks(M)          (bin_at(M, 1))

/*
  Top

    The top-most available chunk (i.e., the one bordering the end of
    available memory) is treated specially. It is never included in
    any bin, is used only if no other chunk is available, and is
    released back to the system if it is very large (see
    M_TRIM_THRESHOLD).  Because top initially
    points to its own bin with initial zero size, thus forcing
    extension on the first malloc request, we avoid having any special
    code in malloc to check whether it even exists yet. But we still
    need to do so when getting memory from system, so we make
    initial_top treat the bin as a legal but unusable chunk during the
    interval between initialization and the first call to
    sYSMALLOc. (This is somewhat delicate, since it relies on
    the 2 preceding words to be zero during this interval as well.)
*/

/* Conveniently, the unsorted bin can be used as dummy top on first call */
#define initial_top(M)              (unsorted_chunks(M))

/*
  Binmap

    To help compensate for the large number of bins, a one-level index
    structure is used for bin-by-bin searching.  `binmap' is a
    bitvector recording whether bins are definitely empty so they can
    be skipped over during during traversals.  The bits are NOT always
    cleared as soon as bins are empty, but instead only
    when they are noticed to be empty during traversal in malloc.
*/

/* Conservatively use 32 bits per map word, even if on 64bit system */
#define BINMAPSHIFT      5
#define BITSPERMAP       (1U << BINMAPSHIFT)
#define BINMAPSIZE       (NBINS / BITSPERMAP)

#define idx2block(i)     ((i) >> BINMAPSHIFT)
#define idx2bit(i)       ((1U << ((i) & ((1U << BINMAPSHIFT)-1))))

#define mark_bin(m,i)    ((m)->binmap[idx2block(i)] |=  idx2bit(i))
#define unmark_bin(m,i)  ((m)->binmap[idx2block(i)] &= ~(idx2bit(i)))
#define get_binmap(m,i)  ((m)->binmap[idx2block(i)] &   idx2bit(i))

/*
  Fastbins

    An array of lists holding recently freed small chunks.  Fastbins
    are not doubly linked.  It is faster to single-link them, and
    since chunks are never removed from the middles of these lists,
    double linking is not necessary. Also, unlike regular bins, they
    are not even processed in FIFO order (they use faster LIFO) since
    ordering doesn't much matter in the transient contexts in which
    fastbins are normally used.

    Chunks in fastbins keep their inuse bit set, so they cannot
    be consolidated with other free chunks. malloc_consolidate
    releases all chunks in fastbins and consolidates them with
    other free chunks.
*/

typedef struct malloc_chunk* mfastbinptr;

/* offset 2 to use otherwise unindexable first 2 bins */
#define fastbin_index(sz)        ((((unsigned int)(sz)) >> 3) - 2)

/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE     80

#define NFASTBINS  (fastbin_index(request2size(MAX_FAST_SIZE))+1)

/*
  FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()
  that triggers automatic consolidation of possibly-surrounding
  fastbin chunks. This is a heuristic, so the exact value should not
  matter too much. It is defined at half the default trim threshold as a
  compromise heuristic to only attempt consolidation if it is likely
  to lead to trimming. However, it is not dynamically tunable, since
  consolidation reduces fragmentation surrounding loarge chunks even
  if trimming is not used.
*/

#define FASTBIN_CONSOLIDATION_THRESHOLD  \
  ((unsigned long)(DEFAULT_TRIM_THRESHOLD) >> 1)

/*
  Since the lowest 2 bits in max_fast don't matter in size comparisons,
  they are used as flags.
*/

/*
  ANYCHUNKS_BIT held in max_fast indicates that there may be any
  freed chunks at all. It is set true when entering a chunk into any
  bin.
*/

#define ANYCHUNKS_BIT        (1U)

#define have_anychunks(M)     (((M)->max_fast &  ANYCHUNKS_BIT))
#define set_anychunks(M)      ((M)->max_fast |=  ANYCHUNKS_BIT)
#define clear_anychunks(M)    ((M)->max_fast &= ~ANYCHUNKS_BIT)

/*
  FASTCHUNKS_BIT held in max_fast indicates that there are probably
  some fastbin chunks. It is set true on entering a chunk into any
  fastbin, and cleared only in malloc_consolidate.
*/

#define FASTCHUNKS_BIT        (2U)

#define have_fastchunks(M)   (((M)->max_fast &  FASTCHUNKS_BIT))
#define set_fastchunks(M)    ((M)->max_fast |=  (FASTCHUNKS_BIT|ANYCHUNKS_BIT))
#define clear_fastchunks(M)  ((M)->max_fast &= ~(FASTCHUNKS_BIT))

/*
   Set value of max_fast.
   Use impossibly small value if 0.
*/

#define set_max_fast(M, s) \
  (M)->max_fast = (((s) == 0)? SMALLBIN_WIDTH: request2size(s)) | \
  ((M)->max_fast &  (FASTCHUNKS_BIT|ANYCHUNKS_BIT))

#define get_max_fast(M) \
  ((M)->max_fast & ~(FASTCHUNKS_BIT | ANYCHUNKS_BIT))


/*
  morecore_properties is a status word holding dynamically discovered
  or controlled properties of the morecore function
*/

#define MORECORE_CONTIGUOUS_BIT  (1U)

#define contiguous(M) \
	(((M)->morecore_properties &  MORECORE_CONTIGUOUS_BIT))
#define noncontiguous(M) \
	(((M)->morecore_properties &  MORECORE_CONTIGUOUS_BIT) == 0)
#define set_contiguous(M) \
	((M)->morecore_properties |=  MORECORE_CONTIGUOUS_BIT)
#define set_noncontiguous(M) \
	((M)->morecore_properties &= ~MORECORE_CONTIGUOUS_BIT)


/*
   ----------- Internal state representation and initialization -----------
*/

struct malloc_state {

  /* The maximum chunk size to be eligible for fastbin */
  INTERNAL_SIZE_T  max_fast;   /* low 2 bits used as flags */

  /* Fastbins */
  mfastbinptr      fastbins[NFASTBINS];

  /* Base of the topmost chunk -- not otherwise kept in a bin */
  mchunkptr        top;

  /* The remainder from the most recent split of a small request */
  mchunkptr        last_remainder;

  /* Normal bins packed as described above */
  mchunkptr        bins[NBINS * 2];

  /* Bitmap of bins. Trailing zero map handles cases of largest binned size */
  unsigned int     binmap[BINMAPSIZE+1];

  /* Tunable parameters */
  CHUNK_SIZE_T     trim_threshold;
  INTERNAL_SIZE_T  top_pad;
  INTERNAL_SIZE_T  mmap_threshold;

  /* Memory map support */
  int              n_mmaps;
  int              n_mmaps_max;
  int              max_n_mmaps;

  /* Cache malloc_getpagesize */
  unsigned int     pagesize;

  /* Track properties of MORECORE */
  unsigned int     morecore_properties;

  /* Statistics */
  INTERNAL_SIZE_T  mmapped_mem;
  INTERNAL_SIZE_T  sbrked_mem;
  INTERNAL_SIZE_T  max_sbrked_mem;
  INTERNAL_SIZE_T  max_mmapped_mem;
  INTERNAL_SIZE_T  max_total_mem;
};

typedef struct malloc_state *mstate;

/*
   There is exactly one instance of this struct in this malloc.
   If you are adapting this malloc in a way that does NOT use a static
   malloc_state, you MUST explicitly zero-fill it before using. This
   malloc relies on the property that malloc_state is initialized to
   all zeroes (as is true of C statics).
*/

static struct malloc_state av_;  /* never directly referenced */

/*
   All uses of av_ are via get_malloc_state().
   At most one "call" to get_malloc_state is made per invocation of
   the public versions of malloc and free, but other routines
   that in turn invoke malloc and/or free may call more then once.
   Also, it is called in check* routines if DEBUG is set.
*/

#define get_malloc_state() (&(av_))

/*
  Initialize a malloc_state struct.

  This is called only from within malloc_consolidate, which needs
  be called in the same contexts anyway.  It is never called directly
  outside of malloc_consolidate because some optimizing compilers try
  to inline it at all call points, which turns out not to be an
  optimization at all. (Inlining it in malloc_consolidate is fine though.)
*/

#if __STD_C
static void malloc_init_state(mstate av)
#else
static void malloc_init_state(av) mstate av;
#endif
{
  int     i;
  mbinptr bin;

  /* Establish circular links for normal bins */
  for (i = 1; i < NBINS; ++i) {
    bin = bin_at(av,i);
    bin->fd = bin->bk = bin;
  }

  av->top_pad        = DEFAULT_TOP_PAD;
  av->n_mmaps_max    = DEFAULT_MMAP_MAX;
  av->mmap_threshold = DEFAULT_MMAP_THRESHOLD;
  av->trim_threshold = DEFAULT_TRIM_THRESHOLD;

#if MORECORE_CONTIGUOUS
  set_contiguous(av);
#else
  set_noncontiguous(av);
#endif


  set_max_fast(av, DEFAULT_MXFAST);

  av->top            = initial_top(av);
  av->pagesize       = malloc_getpagesize;
}

/*
   Other internal utilities operating on mstates
*/

#if __STD_C
static Void_t*  sYSMALLOc(INTERNAL_SIZE_T, mstate);
#ifndef MORECORE_CANNOT_TRIM
static int      sYSTRIm(size_t, mstate);
#endif
static void     malloc_consolidate(mstate);
#ifdef NEED_INDEPENDENT
static Void_t** iALLOc(size_t, size_t*, int, Void_t**);
#endif
#else
static Void_t*  sYSMALLOc();
#ifndef MORECORE_CANNOT_TRIM
static int      sYSTRIm();
#endif
static void     malloc_consolidate();
#ifdef NEED_INDEPENDENT
static Void_t** iALLOc();
#endif
#endif

/*
  Debugging support

  These routines make a number of assertions about the states
  of data structures that should be true at all times. If any
  are not true, it's very likely that a user program has somehow
  trashed memory. (It's also possible that there is a coding error
  in malloc. In which case, please report it!)
*/

#if ! DEBUG

#define check_chunk(P)
#define check_free_chunk(P)
#define check_inuse_chunk(P)
#define check_remalloced_chunk(P,N)
#define check_malloced_chunk(P,N)
#define check_malloc_state()

#else
#define check_chunk(P)              do_check_chunk(P)
#define check_free_chunk(P)         do_check_free_chunk(P)
#define check_inuse_chunk(P)        do_check_inuse_chunk(P)
#define check_remalloced_chunk(P,N) do_check_remalloced_chunk(P,N)
#define check_malloced_chunk(P,N)   do_check_malloced_chunk(P,N)
#define check_malloc_state()        do_check_malloc_state()

/*
  Properties of all chunks
*/

#if __STD_C
static void do_check_chunk(mchunkptr p)
#else
static void do_check_chunk(p) mchunkptr p;
#endif
{
  mstate av = get_malloc_state();
  CHUNK_SIZE_T  sz = chunksize(p);
  /* min and max possible addresses assuming contiguous allocation */
  char* max_address = (char*)(av->top) + chunksize(av->top);
  char* min_address = max_address - av->sbrked_mem;

  if (!chunk_is_mmapped(p)) {

    /* Has legal address ... */
    if (p != av->top) {
      if (contiguous(av)) {
	assert(((char*)p) >= min_address);
	assert(((char*)p + sz) <= ((char*)(av->top)));
      }
    }
    else {
      /* top size is always at least MINSIZE */
      assert((CHUNK_SIZE_T)(sz) >= MINSIZE);
      /* top predecessor always marked inuse */
      assert(prev_inuse(p));
    }

  }
  else {
#if HAVE_MMAP
    /* address is outside main heap  */
    if (contiguous(av) && av->top != initial_top(av)) {
      assert(((char*)p) < min_address || ((char*)p) > max_address);
    }
    /* chunk is page-aligned */
    assert(((p->prev_size + sz) & (av->pagesize-1)) == 0);
    /* mem is aligned */
    assert(aligned_OK(chunk2mem(p)));
#else
    /* force an appropriate assert violation if debug set */
    assert(!chunk_is_mmapped(p));
#endif
  }
}

/*
  Properties of free chunks
*/

#if __STD_C
static void do_check_free_chunk(mchunkptr p)
#else
static void do_check_free_chunk(p) mchunkptr p;
#endif
{
  mstate av = get_malloc_state();

  INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;
  mchunkptr next = chunk_at_offset(p, sz);

  do_check_chunk(p);

  /* Chunk must claim to be free ... */
  assert(!inuse(p));
  assert (!chunk_is_mmapped(p));

  /* Unless a special marker, must have OK fields */
  if ((CHUNK_SIZE_T)(sz) >= MINSIZE)
  {
    assert((sz & MALLOC_ALIGN_MASK) == 0);
    assert(aligned_OK(chunk2mem(p)));
    /* ... matching footer field */
    assert(next->prev_size == sz);
    /* ... and is fully consolidated */
    assert(prev_inuse(p));
    assert (next == av->top || inuse(next));

    /* ... and has minimally sane links */
    assert(p->fd->bk == p);
    assert(p->bk->fd == p);
  }
  else /* markers are always of size SIZE_SZ */
    assert(sz == SIZE_SZ);
}

/*
  Properties of inuse chunks
*/

#if __STD_C
static void do_check_inuse_chunk(mchunkptr p)
#else
static void do_check_inuse_chunk(p) mchunkptr p;
#endif
{
  mstate av = get_malloc_state();
  mchunkptr next;
  do_check_chunk(p);

  if (chunk_is_mmapped(p))
    return; /* mmapped chunks have no next/prev */

  /* Check whether it claims to be in use ... */
  assert(inuse(p));

  next = next_chunk(p);

  /* ... and is surrounded by OK chunks.
    Since more things can be checked with free chunks than inuse ones,
    if an inuse chunk borders them and debug is on, it's worth doing them.
  */
  if (!prev_inuse(p))  {
    /* Note that we cannot even look at prev unless it is not inuse */
    mchunkptr prv = prev_chunk(p);
    assert(next_chunk(prv) == p);
    do_check_free_chunk(prv);
  }

  if (next == av->top) {
    assert(prev_inuse(next));
    assert(chunksize(next) >= MINSIZE);
  }
  else if (!inuse(next))
    do_check_free_chunk(next);
}

/*
  Properties of chunks recycled from fastbins
*/

#if __STD_C
static void do_check_remalloced_chunk(mchunkptr p, INTERNAL_SIZE_T s)
#else
static void do_check_remalloced_chunk(p, s) mchunkptr p; INTERNAL_SIZE_T s;
#endif
{
  INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;

  do_check_inuse_chunk(p);

  /* Legal size ... */
  assert((sz & MALLOC_ALIGN_MASK) == 0);
  assert((CHUNK_SIZE_T)(sz) >= MINSIZE);
  /* ... and alignment */
  assert(aligned_OK(chunk2mem(p)));
  /* chunk is less than MINSIZE more than request */
  assert((long)(sz) - (long)(s) >= 0);
  assert((long)(sz) - (long)(s + MINSIZE) < 0);
}

/*
  Properties of nonrecycled chunks at the point they are malloced
*/

#if __STD_C
static void do_check_malloced_chunk(mchunkptr p, INTERNAL_SIZE_T s)
#else
static void do_check_malloced_chunk(p, s) mchunkptr p; INTERNAL_SIZE_T s;
#endif
{
  /* same as recycled case ... */
  do_check_remalloced_chunk(p, s);

  /*
    ... plus,  must obey implementation invariant that prev_inuse is
    always true of any allocated chunk; i.e., that each allocated
    chunk borders either a previously allocated and still in-use
    chunk, or the base of its memory arena. This is ensured
    by making all allocations from the the `lowest' part of any found
    chunk.  This does not necessarily hold however for chunks
    recycled via fastbins.
  */

  assert(prev_inuse(p));
}


/*
  Properties of malloc_state.

  This may be useful for debugging malloc, as well as detecting user
  programmer errors that somehow write into malloc_state.

  If you are extending or experimenting with this malloc, you can
  probably figure out how to hack this routine to print out or
  display chunk addresses, sizes, bins, and other instrumentation.
*/

static void do_check_malloc_state()
{
  mstate av = get_malloc_state();
  int i;
  mchunkptr p;
  mchunkptr q;
  mbinptr b;
  unsigned int binbit;
  int empty;
  unsigned int idx;
  INTERNAL_SIZE_T size;
  CHUNK_SIZE_T  total = 0;
  int max_fast_bin;

  /* internal size_t must be no wider than pointer type */
  assert(sizeof(INTERNAL_SIZE_T) <= sizeof(char*));

  /* alignment is a power of 2 */
  assert((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-1)) == 0);

  /* cannot run remaining checks until fully initialized */
  if (av->top == 0 || av->top == initial_top(av))
    return;

  /* pagesize is a power of 2 */
  assert((av->pagesize & (av->pagesize-1)) == 0);

  /* properties of fastbins */

  /* max_fast is in allowed range */
  assert(get_max_fast(av) <= request2size(MAX_FAST_SIZE));

  max_fast_bin = fastbin_index(av->max_fast);

  for (i = 0; i < NFASTBINS; ++i) {
    p = av->fastbins[i];

    /* all bins past max_fast are empty */
    if (i > max_fast_bin)
      assert(p == 0);

    while (p != 0) {
      /* each chunk claims to be inuse */
      do_check_inuse_chunk(p);
      total += chunksize(p);
      /* chunk belongs in this bin */
      assert(fastbin_index(chunksize(p)) == i);
      p = p->fd;
    }
  }

  if (total != 0)
    assert(have_fastchunks(av));
  else if (!have_fastchunks(av))
    assert(total == 0);

  /* check normal bins */
  for (i = 1; i < NBINS; ++i) {
    b = bin_at(av,i);

    /* binmap is accurate (except for bin 1 == unsorted_chunks) */
    if (i >= 2) {
      binbit = get_binmap(av,i);
      empty = last(b) == b;
      if (!binbit)
	assert(empty);
      else if (!empty)
	assert(binbit);
    }

    for (p = last(b); p != b; p = p->bk) {
      /* each chunk claims to be free */
      do_check_free_chunk(p);
      size = chunksize(p);
      total += size;
      if (i >= 2) {
	/* chunk belongs in bin */
	idx = bin_index(size);
	assert(idx == i);
	/* lists are sorted */
	if ((CHUNK_SIZE_T) size >= (CHUNK_SIZE_T)(FIRST_SORTED_BIN_SIZE)) {
	  assert(p->bk == b ||
		 (CHUNK_SIZE_T)chunksize(p->bk) >=
		 (CHUNK_SIZE_T)chunksize(p));
	}
      }
      /* chunk is followed by a legal chain of inuse chunks */
      for (q = next_chunk(p);
	   (q != av->top && inuse(q) &&
	     (CHUNK_SIZE_T)(chunksize(q)) >= MINSIZE);
	   q = next_chunk(q))
	do_check_inuse_chunk(q);
    }
  }

  /* top chunk is OK */
  check_chunk(av->top);

  /* sanity checks for statistics */

  assert(total <= (CHUNK_SIZE_T)(av->max_total_mem));
  assert(av->n_mmaps >= 0);
  assert(av->n_mmaps <= av->max_n_mmaps);

  assert((CHUNK_SIZE_T)(av->sbrked_mem) <=
	 (CHUNK_SIZE_T)(av->max_sbrked_mem));

  assert((CHUNK_SIZE_T)(av->mmapped_mem) <=
	 (CHUNK_SIZE_T)(av->max_mmapped_mem));

  assert((CHUNK_SIZE_T)(av->max_total_mem) >=
	 (CHUNK_SIZE_T)(av->mmapped_mem) + (CHUNK_SIZE_T)(av->sbrked_mem));
}
#endif


/* ----------- Routines dealing with system allocation -------------- */

/*
  sysmalloc handles malloc cases requiring more memory from the system.
  On entry, it is assumed that av->top does not have enough
  space to service request for nb bytes, thus requiring that av->top
  be extended or replaced.
*/

#if __STD_C
static Void_t* sYSMALLOc(INTERNAL_SIZE_T nb, mstate av)
#else
static Void_t* sYSMALLOc(nb, av) INTERNAL_SIZE_T nb; mstate av;
#endif
{
  mchunkptr       old_top;        /* incoming value of av->top */
  INTERNAL_SIZE_T old_size;       /* its size */
  char*           old_end;        /* its end address */

  long            size;           /* arg to first MORECORE or mmap call */
  char*           brk;            /* return value from MORECORE */

  long            correction;     /* arg to 2nd MORECORE call */
  char*           snd_brk;        /* 2nd return val */

  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */
  INTERNAL_SIZE_T end_misalign;   /* partial page left at end of new space */
  char*           aligned_brk;    /* aligned offset into brk */

  mchunkptr       p;              /* the allocated/returned chunk */
  mchunkptr       remainder;      /* remainder from allocation */
  CHUNK_SIZE_T    remainder_size; /* its size */

  CHUNK_SIZE_T    sum;            /* for updating stats */

  size_t          pagemask  = av->pagesize - 1;

  /*
    If there is space available in fastbins, consolidate and retry
    malloc from scratch rather than getting memory from system.  This
    can occur only if nb is in smallbin range so we didn't consolidate
    upon entry to malloc. It is much easier to handle this case here
    than in malloc proper.
  */

  if (have_fastchunks(av)) {
    assert(in_smallbin_range(nb));
    malloc_consolidate(av);
    return mALLOc(nb - MALLOC_ALIGN_MASK);
  }


#if HAVE_MMAP

  /*
    If have mmap, and the request size meets the mmap threshold, and
    the system supports mmap, and there are few enough currently
    allocated mmapped regions, try to directly map this request
    rather than expanding top.
  */

  if ((CHUNK_SIZE_T)(nb) >= (CHUNK_SIZE_T)(av->mmap_threshold) &&
      (av->n_mmaps < av->n_mmaps_max)) {

    char* mm;             /* return value from mmap call*/

    /*
      Round up size to nearest page.  For mmapped chunks, the overhead
      is one SIZE_SZ unit larger than for normal chunks, because there
      is no following chunk whose prev_size field could be used.
    */
    size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) & ~pagemask;

    /* Don't try if size wraps around 0 */
    if ((CHUNK_SIZE_T)(size) > (CHUNK_SIZE_T)(nb)) {

      mm = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));

      if (mm != (char*)(MORECORE_FAILURE)) {

	/*
	  The offset to the start of the mmapped region is stored
	  in the prev_size field of the chunk. This allows us to adjust
	  returned start address to meet alignment requirements here
	  and in memalign(), and still be able to compute proper
	  address argument for later munmap in free() and realloc().
	*/

	front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK;
	if (front_misalign > 0) {
	  correction = MALLOC_ALIGNMENT - front_misalign;
	  p = (mchunkptr)(mm + correction);
	  p->prev_size = correction;
	  set_head(p, (size - correction) |IS_MMAPPED);
	}
	else {
	  p = (mchunkptr)mm;
	  p->prev_size = 0;
	  set_head(p, size|IS_MMAPPED);
	}

	/* update statistics */

	if (++av->n_mmaps > av->max_n_mmaps)
	  av->max_n_mmaps = av->n_mmaps;

	sum = av->mmapped_mem += size;
	if (sum > (CHUNK_SIZE_T)(av->max_mmapped_mem))
	  av->max_mmapped_mem = sum;
	sum += av->sbrked_mem;
	if (sum > (CHUNK_SIZE_T)(av->max_total_mem))
	  av->max_total_mem = sum;

	check_chunk(p);

	return chunk2mem(p);
      }
    }
  }
#endif

  /* Record incoming configuration of top */

  old_top  = av->top;
  old_size = chunksize(old_top);
  old_end  = (char*)(chunk_at_offset(old_top, old_size));

  brk = snd_brk = (char*)(MORECORE_FAILURE);

  /*
     If not the first time through, we require old_size to be
     at least MINSIZE and to have prev_inuse set.
  */

  assert((old_top == initial_top(av) && old_size == 0) ||
	 ((CHUNK_SIZE_T) (old_size) >= MINSIZE &&
	  prev_inuse(old_top)));

  /* Precondition: not enough current space to satisfy nb request */
  assert((CHUNK_SIZE_T)(old_size) < (CHUNK_SIZE_T)(nb + MINSIZE));

  /* Precondition: all fastbins are consolidated */
  assert(!have_fastchunks(av));


  /* Request enough space for nb + pad + overhead */

  size = nb + av->top_pad + MINSIZE;

  /*
    If contiguous, we can subtract out existing space that we hope to
    combine with new space. We add it back later only if
    we don't actually get contiguous space.
  */

  if (contiguous(av))
    size -= old_size;

  /*
    Round to a multiple of page size.
    If MORECORE is not contiguous, this ensures that we only call it
    with whole-page arguments.  And if MORECORE is contiguous and
    this is not first time through, this preserves page-alignment of
    previous calls. Otherwise, we correct to page-align below.
  */

  size = (size + pagemask) & ~pagemask;

  /*
    Don't try to call MORECORE if argument is so big as to appear
    negative. Note that since mmap takes size_t arg, it may succeed
    below even if we cannot call MORECORE.
  */

  if (size > 0)
    brk = (char*)(MORECORE(size));

  /*
    If have mmap, try using it as a backup when MORECORE fails or
    cannot be used. This is worth doing on systems that have "holes" in
    address space, so sbrk cannot extend to give contiguous space, but
    space is available elsewhere.  Note that we ignore mmap max count
    and threshold limits, since the space will not be used as a
    segregated mmap region.
  */

#if HAVE_MMAP
  if (brk == (char*)(MORECORE_FAILURE)) {

    /* Cannot merge with old top, so add its size back in */
    if (contiguous(av))
      size = (size + old_size + pagemask) & ~pagemask;

    /* If we are relying on mmap as backup, then use larger units */
    if ((CHUNK_SIZE_T)(size) < (CHUNK_SIZE_T)(MMAP_AS_MORECORE_SIZE))
      size = MMAP_AS_MORECORE_SIZE;

    /* Don't try if size wraps around 0 */
    if ((CHUNK_SIZE_T)(size) > (CHUNK_SIZE_T)(nb)) {

      brk = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));

      if (brk != (char*)(MORECORE_FAILURE)) {

	/* We do not need, and cannot use, another sbrk call to find end */
	snd_brk = brk + size;

	/*
	   Record that we no longer have a contiguous sbrk region.
	   After the first time mmap is used as backup, we do not
	   ever rely on contiguous space since this could incorrectly
	   bridge regions.
	*/
	set_noncontiguous(av);
      }
    }
  }
#endif
d1596 3
a1598 2
  if (brk != (char*)(MORECORE_FAILURE)) {
    av->sbrked_mem += size;
d1600 3
a1602 3
    /*
      If MORECORE extends previous space, we can likewise extend top size.
    */
d1604 3
a1606 3
    if (brk == old_end && snd_brk == (char*)(MORECORE_FAILURE)) {
      set_head(old_top, (size + old_size) | PREV_INUSE);
    }
a1607 2
    /*
      Otherwise, make adjustments:
d1609 1
a1609 2
      * If the first time through or noncontiguous, we need to call sbrk
	just to find out where the end of memory lies.
d1611 7
a1617 2
      * We need to ensure that all returned chunks from malloc will meet
	MALLOC_ALIGNMENT
d1619 3
a1621 3
      * If there was an intervening foreign sbrk, we need to adjust sbrk
	request size to account for fact that we will not be able to
	combine new space with existing space in old_top.
d1623 2
a1624 5
      * Almost all systems internally allocate whole pages at a time, in
	which case we might as well use the whole last page of request.
	So we allocate enough more memory to hit a page boundary now,
	which in turn causes future contiguous calls to page-align.
    */
d1626 4
a1629 17
    else {
      front_misalign = 0;
      end_misalign = 0;
      correction = 0;
      aligned_brk = brk;

      /*
	If MORECORE returns an address lower than we have seen before,
	we know it isn't really contiguous.  This and some subsequent
	checks help cope with non-conforming MORECORE functions and
	the presence of "foreign" calls to MORECORE from outside of
	malloc or by other threads.  We cannot guarantee to detect
	these in all cases, but cope with the ones we do detect.
      */
      if (contiguous(av) && old_size != 0 && brk < old_end) {
	set_noncontiguous(av);
      }
d1631 2
a1632 2
      /* handle contiguous cases */
      if (contiguous(av)) {
d1634 3
a1636 7
	/*
	   We can tolerate forward non-contiguities here (usually due
	   to foreign calls) but treat them as part of our space for
	   stats reporting.
	*/
	if (old_size != 0)
	  av->sbrked_mem += brk - old_end;
d1638 3
a1640 1
	/* Guarantee alignment of first new chunk made from this space */
d1642 2
a1643 2
	front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) & MALLOC_ALIGN_MASK;
	if (front_misalign > 0) {
d1645 3
a1647 7
	  /*
	    Skip over some bytes to arrive at an aligned position.
	    We don't need to specially mark these wasted front bytes.
	    They will never be accessed anyway because
	    prev_inuse of av->top (and any chunk created from its start)
	    is always true after initialization.
	  */
d1649 3
a1651 3
	  correction = MALLOC_ALIGNMENT - front_misalign;
	  aligned_brk += correction;
	}
d1653 3
a1655 4
	/*
	  If this isn't adjacent to existing space, then we will not
	  be able to merge with old_top space, so must add to 2nd request.
	*/
d1657 2
a1658 1
	correction += old_size;
d1660 3
a1662 32
	/* Extend the end address to hit a page boundary */
	end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);
	correction += ((end_misalign + pagemask) & ~pagemask) - end_misalign;

	assert(correction >= 0);
	snd_brk = (char*)(MORECORE(correction));

	if (snd_brk == (char*)(MORECORE_FAILURE)) {
	  /*
	    If can't allocate correction, try to at least find out current
	    brk.  It might be enough to proceed without failing.
	  */
	  correction = 0;
	  snd_brk = (char*)(MORECORE(0));
	}
	else if (snd_brk < brk) {
	  /*
	    If the second call gives noncontiguous space even though
	    it says it won't, the only course of action is to ignore
	    results of second call, and conservatively estimate where
	    the first call left us. Also set noncontiguous, so this
	    won't happen again, leaving at most one hole.

	    Note that this check is intrinsically incomplete.  Because
	    MORECORE is allowed to give more space than we ask for,
	    there is no reliable way to detect a noncontiguity
	    producing a forward gap for the second call.
	  */
	  snd_brk = brk + size;
	  correction = 0;
	  set_noncontiguous(av);
	}
d1664 6
a1669 1
      }
d1671 1
a1671 4
      /* handle non-contiguous cases */
      else {
	/* MORECORE/mmap must correctly align */
	assert(aligned_OK(chunk2mem(brk)));
d1673 3
a1675 6
	/* Find out current end of memory */
	if (snd_brk == (char*)(MORECORE_FAILURE)) {
	  snd_brk = (char*)(MORECORE(0));
	  av->sbrked_mem += snd_brk - brk - size;
	}
      }
d1677 2
a1678 5
      /* Adjust top based on results of second sbrk */
      if (snd_brk != (char*)(MORECORE_FAILURE)) {
	av->top = (mchunkptr)aligned_brk;
	set_head(av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
	av->sbrked_mem += correction;
d1680 15
a1694 8
	/*
	  If not the first time through, we either have a
	  gap due to foreign sbrk or a non-contiguous region.  Insert a
	  double fencepost at old_top to prevent consolidation with space
	  we don't own. These fenceposts are artificial chunks that are
	  marked as inuse and are in any case too small to use.  We need
	  two to make sizes and alignments work out.
	*/
d1696 4
a1699 33
	if (old_size != 0) {
	  /*
	     Shrink old_top to insert fenceposts, keeping size a
	     multiple of MALLOC_ALIGNMENT. We know there is at least
	     enough space in old_top to do this.
	  */
	  old_size = (old_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
	  set_head(old_top, old_size | PREV_INUSE);

	  /*
	    Note that the following assignments completely overwrite
	    old_top when old_size was previously MINSIZE.  This is
	    intentional. We need the fencepost, even if old_top otherwise gets
	    lost.
	  */
	  chunk_at_offset(old_top, old_size          )->size =
	    SIZE_SZ|PREV_INUSE;

	  chunk_at_offset(old_top, old_size + SIZE_SZ)->size =
	    SIZE_SZ|PREV_INUSE;

	  /*
	     If possible, release the rest, suppressing trimming.
	  */
	  if (old_size >= MINSIZE) {
	    INTERNAL_SIZE_T tt = av->trim_threshold;
	    av->trim_threshold = (INTERNAL_SIZE_T)(-1);
	    fREe(chunk2mem(old_top));
	    av->trim_threshold = tt;
	  }
	}
      }
    }
d1701 22
a1722 26
    /* Update statistics */
    sum = av->sbrked_mem;
    if (sum > (CHUNK_SIZE_T)(av->max_sbrked_mem))
      av->max_sbrked_mem = sum;

    sum += av->mmapped_mem;
    if (sum > (CHUNK_SIZE_T)(av->max_total_mem))
      av->max_total_mem = sum;

    check_malloc_state();

    /* finally, do the allocation */

    p = av->top;
    size = chunksize(p);

    /* check that one of the above allocation paths succeeded */
    if ((CHUNK_SIZE_T)(size) >= (CHUNK_SIZE_T)(nb + MINSIZE)) {
      remainder_size = size - nb;
      remainder = chunk_at_offset(p, nb);
      av->top = remainder;
      set_head(p, nb | PREV_INUSE);
      set_head(remainder, remainder_size | PREV_INUSE);
      check_malloced_chunk(p, nb);
      return chunk2mem(p);
    }
d1724 49
a1772 1
  }
d1774 58
a1831 4
  /* catch all failure paths */
  MALLOC_FAILURE_ACTION;
  return 0;
}
d1833 2
d1836 1
a1837 1
#ifndef MORECORE_CANNOT_TRIM
d1839 81
a1919 7
  sYSTRIm is an inverse of sorts to sYSMALLOc.  It gives memory back
  to the system (via negative arguments to sbrk) if there is unused
  memory at the `high' end of the malloc pool. It is called
  automatically by free() when top space exceeds the trim
  threshold. It is also called by the public malloc_trim routine.  It
  returns 1 if it actually released any memory, else 0.
*/
d1921 17
a1937 4
#if __STD_C
static int sYSTRIm(size_t pad, mstate av)
#else
static int sYSTRIm(pad, av) size_t pad; mstate av;
d1939 4
a1942 7
{
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  long  released;        /* Amount actually released */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by post-check sbrk call */
  size_t pagesz;
d1944 1
a1944 2
  pagesz = av->pagesize;
  top_size = chunksize(av->top);
d1946 5
a1950 2
  /* Release in pagesize units, keeping at least one page */
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
d1952 8
a1959 1
  if (extra > 0) {
d1961 1
a1961 6
    /*
      Only proceed if end of memory is where we last set it.
      This avoids problems if there were foreign sbrk calls.
    */
    current_brk = (char*)(MORECORE(0));
    if (current_brk == (char*)(av->top) + top_size) {
d1963 51
a2013 25
      /*
	Attempt to release memory. We ignore MORECORE return value,
	and instead call again to find out where new end of memory is.
	This avoids problems if first call releases less than we asked,
	of if failure somehow altered brk value. (We could still
	encounter problems if it altered brk in some very bad way,
	but the only thing we can do is adjust anyway, which will cause
	some downstream failure.)
      */

      MORECORE(-extra);
      new_brk = (char*)(MORECORE(0));

      if (new_brk != (char*)MORECORE_FAILURE) {
	released = (long)(current_brk - new_brk);

	if (released != 0) {
	  /* Success. Adjust top. */
	  av->sbrked_mem -= released;
	  set_head(av->top, (top_size - released) | PREV_INUSE);
	  check_malloc_state();
	  return 1;
	}
      }
    }
a2014 1
  return 0;
a2015 1
#endif /*MORECORE_CANNOT_TRIM*/
d2017 10
a2026 3
/*
  ------------------------------ malloc ------------------------------
*/
d2028 2
a2029 3

#if __STD_C
Void_t* mALLOc(size_t bytes)
d2031 1
a2031 1
  Void_t* mALLOc(bytes) size_t bytes;
a2032 2
{
  mstate av = get_malloc_state();
d2034 7
a2040 15
  INTERNAL_SIZE_T nb;               /* normalized request size */
  unsigned int    idx;              /* associated bin index */
  mbinptr         bin;              /* associated bin */
  mfastbinptr*    fb;               /* associated fastbin */

  mchunkptr       victim;           /* inspected/selected chunk */
  INTERNAL_SIZE_T size;             /* its size */
  int             victim_index;     /* its bin index */

  mchunkptr       remainder;        /* remainder from a split */
  CHUNK_SIZE_T    remainder_size;   /* its size */

  unsigned int    block;            /* bit map traverser */
  unsigned int    bit;              /* bit map traverser */
  unsigned int    map;              /* current word of binmap */
a2041 2
  mchunkptr       fwd;              /* misc temp for linking */
  mchunkptr       bck;              /* misc temp for linking */
d2043 1
a2043 8
  /*
    Convert request size to internal form by adding SIZE_SZ bytes
    overhead plus possibly more to obtain necessary alignment and/or
    to obtain a size of at least MINSIZE, the smallest allocatable
    size. Also, checked_request2size traps (returning 0) request sizes
    that are so large that they wrap around zero when padded and
    aligned.
  */
d2045 5
a2049 1
  checked_request2size(bytes, nb);
d2051 1
a2051 8
  /*
    Bypass search if no frees yet
   */
  if (!have_anychunks(av)) {
    if (av->max_fast == 0) /* initialization check */
      malloc_consolidate(av);
    goto use_top;
  }
d2053 3
a2055 3
  /*
    If the size qualifies as a fastbin, first check corresponding bin.
  */
d2057 3
a2059 8
  if ((CHUNK_SIZE_T)(nb) <= (CHUNK_SIZE_T)(av->max_fast)) {
    fb = &(av->fastbins[(fastbin_index(nb))]);
    if ( (victim = *fb) != 0) {
      *fb = victim->fd;
      check_remalloced_chunk(victim, nb);
      return chunk2mem(victim);
    }
  }
d2061 3
a2063 7
  /*
    If a small request, check regular bin.  Since these "smallbins"
    hold one size each, no searching within bins is necessary.
    (For a large request, we need to wait until unsorted chunks are
    processed to find best fit. But for small ones, fits are exact
    anyway, so we can check now, which is faster.)
  */
d2065 1
a2065 9
  if (in_smallbin_range(nb)) {
    idx = smallbin_index(nb);
    bin = bin_at(av,idx);

    if ( (victim = last(bin)) != bin) {
      bck = victim->bk;
      set_inuse_bit_at_offset(victim, nb);
      bin->bk = bck;
      bck->fd = bin;
d2067 7
a2073 4
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }
  }
d2075 1
a2075 10
  /*
     If this is a large request, consolidate fastbins before continuing.
     While it might look excessive to kill all fastbins before
     even seeing if there is space available, this avoids
     fragmentation problems normally associated with fastbins.
     Also, in practice, programs tend to have runs of either small or
     large requests, but less often mixtures, so consolidation is not
     invoked all that often in most programs. And the programs that
     it is called frequently in otherwise tend to fragment.
  */
d2077 2
a2078 5
  else {
    idx = largebin_index(nb);
    if (have_fastchunks(av))
      malloc_consolidate(av);
  }
d2080 2
a2081 7
  /*
    Process recently freed or remaindered chunks, taking one only if
    it is exact fit, or, if this a small request, the chunk is remainder from
    the most recent non-exact fit.  Place other traversed chunks in
    bins.  Note that this step is the only place in any routine where
    chunks are placed in bins.
  */
d2083 2
a2084 11
  while ( (victim = unsorted_chunks(av)->bk) != unsorted_chunks(av)) {
    bck = victim->bk;
    size = chunksize(victim);

    /*
       If a small request, try to use last remainder if it is the
       only chunk in unsorted bin.  This helps promote locality for
       runs of consecutive small requests. This is the only
       exception to best-fit, and applies only when there is
       no exact fit for a small chunk.
    */
d2086 1
a2086 4
    if (in_smallbin_range(nb) &&
	bck == unsorted_chunks(av) &&
	victim == av->last_remainder &&
	(CHUNK_SIZE_T)(size) > (CHUNK_SIZE_T)(nb + MINSIZE)) {
d2088 3
a2090 6
      /* split and reattach remainder */
      remainder_size = size - nb;
      remainder = chunk_at_offset(victim, nb);
      unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
      av->last_remainder = remainder;
      remainder->bk = remainder->fd = unsorted_chunks(av);
d2092 3
a2094 3
      set_head(victim, nb | PREV_INUSE);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
d2096 1
a2096 3
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }
d2098 1
a2098 3
    /* remove from unsorted list */
    unsorted_chunks(av)->bk = bck;
    bck->fd = unsorted_chunks(av);
d2100 1
a2100 1
    /* Take now instead of binning if exact fit */
d2102 39
a2140 5
    if (size == nb) {
      set_inuse_bit_at_offset(victim, size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }
d2142 34
a2175 1
    /* place chunk in bin */
d2177 28
a2204 18
    if (in_smallbin_range(size)) {
      victim_index = smallbin_index(size);
      bck = bin_at(av, victim_index);
      fwd = bck->fd;
    }
    else {
      victim_index = largebin_index(size);
      bck = bin_at(av, victim_index);
      fwd = bck->fd;

      if (fwd != bck) {
	/* if smaller than smallest, place first */
	if ((CHUNK_SIZE_T)(size) < (CHUNK_SIZE_T)(bck->bk->size)) {
	  fwd = bck;
	  bck = bck->bk;
	}
	else if ((CHUNK_SIZE_T)(size) >=
		 (CHUNK_SIZE_T)(FIRST_SORTED_BIN_SIZE)) {
d2206 1
a2206 8
	  /* maintain large bins in sorted order */
	  size |= PREV_INUSE; /* Or with inuse bit to speed comparisons */
	  while ((CHUNK_SIZE_T)(size) < (CHUNK_SIZE_T)(fwd->size))
	    fwd = fwd->fd;
	  bck = fwd->bk;
	}
      }
    }
d2208 7
a2214 6
    mark_bin(av, victim_index);
    victim->bk = bck;
    victim->fd = fwd;
    fwd->bk = victim;
    bck->fd = victim;
  }
d2216 3
a2218 8
  /*
    If a large request, scan through the chunks of current bin to
    find one that fits.  (This will be the smallest that fits unless
    FIRST_SORTED_BIN_SIZE has been changed from default.)  This is
    the only step where an unbounded number of chunks might be
    scanned without doing anything useful with them. However the
    lists tend to be short.
  */
d2220 14
a2233 2
  if (!in_smallbin_range(nb)) {
    bin = bin_at(av, idx);
d2235 2
a2236 2
    for (victim = last(bin); victim != bin; victim = victim->bk) {
      size = chunksize(victim);
d2238 2
a2239 24
      if ((CHUNK_SIZE_T)(size) >= (CHUNK_SIZE_T)(nb)) {
	remainder_size = size - nb;
	unlink(victim, bck, fwd);

	/* Exhaust */
	if (remainder_size < MINSIZE)  {
	  set_inuse_bit_at_offset(victim, size);
	  check_malloced_chunk(victim, nb);
	  return chunk2mem(victim);
	}
	/* Split */
	else {
	  remainder = chunk_at_offset(victim, nb);
	  unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
	  remainder->bk = remainder->fd = unsorted_chunks(av);
	  set_head(victim, nb | PREV_INUSE);
	  set_head(remainder, remainder_size | PREV_INUSE);
	  set_foot(remainder, remainder_size);
	  check_malloced_chunk(victim, nb);
	  return chunk2mem(victim);
	}
      }
    }
  }
d2241 2
a2242 5
  /*
    Search for a chunk by scanning bins, starting with next largest
    bin. This search is strictly by best-fit; i.e., the smallest
    (with ties going to approximately the least recently used) chunk
    that fits is selected.
a2243 2
    The bitmap avoids needing to check that most blocks are nonempty.
  */
d2245 1
a2245 5
  ++idx;
  bin = bin_at(av,idx);
  block = idx2block(idx);
  map = av->binmap[block];
  bit = idx2bit(idx);
d2247 9
a2255 1
  for (;;) {
d2257 15
a2271 6
    /* Skip rest of block if there are no more set bits in this block.  */
    if (bit > map || bit == 0) {
      do {
	if (++block >= BINMAPSIZE)  /* out of bins */
	  goto use_top;
      } while ( (map = av->binmap[block]) == 0);
d2273 9
a2281 3
      bin = bin_at(av, (block << BINMAPSHIFT));
      bit = 1;
    }
d2283 6
a2288 6
    /* Advance to bin with set bit. There must be one. */
    while ((bit & map) == 0) {
      bin = next_bin(bin);
      bit <<= 1;
      assert(bit != 0);
    }
d2290 6
a2295 2
    /* Inspect the bin. It is likely to be non-empty */
    victim = last(bin);
a2296 6
    /*  If a false alarm (empty bin), clear the bit. */
    if (victim == bin) {
      av->binmap[block] = map &= ~bit; /* Write through */
      bin = next_bin(bin);
      bit <<= 1;
    }
d2298 10
a2307 2
    else {
      size = chunksize(victim);
d2309 1
a2309 2
      /*  We know the first chunk in this bin is big enough to use. */
      assert((CHUNK_SIZE_T)(size) >= (CHUNK_SIZE_T)(nb));
d2311 1
a2311 1
      remainder_size = size - nb;
d2313 1
a2313 4
      /* unlink */
      bck = victim->bk;
      bin->bk = bck;
      bck->fd = bin;
d2315 4
a2318 6
      /* Exhaust */
      if (remainder_size < MINSIZE) {
	set_inuse_bit_at_offset(victim, size);
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
d2320 4
a2323 3
      /* Split */
      else {
	remainder = chunk_at_offset(victim, nb);
d2325 3
a2327 5
	unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
	remainder->bk = remainder->fd = unsorted_chunks(av);
	/* advertise as last remainder */
	if (in_smallbin_range(nb))
	  av->last_remainder = remainder;
d2329 1
a2329 8
	set_head(victim, nb | PREV_INUSE);
	set_head(remainder, remainder_size | PREV_INUSE);
	set_foot(remainder, remainder_size);
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
    }
  }
d2331 3
a2333 15
  use_top:
  /*
    If large enough, split off the chunk bordering the end of memory
    (held in av->top). Note that this is in accord with the best-fit
    search rule.  In effect, av->top is treated as larger (and thus
    less well fitting) than any other available chunk since it can
    be extended to be as large as necessary (up to system
    limitations).

    We require that av->top always exists (i.e., has size >=
    MINSIZE) after initialization, so if it would otherwise be
    exhuasted by current request, it is replenished. (The main
    reason for ensuring it exists is that we may need MINSIZE space
    to put in fenceposts in sysmalloc.)
  */
d2335 3
a2337 2
  victim = av->top;
  size = chunksize(victim);
d2339 4
a2342 6
  if ((CHUNK_SIZE_T)(size) >= (CHUNK_SIZE_T)(nb + MINSIZE)) {
    remainder_size = size - nb;
    remainder = chunk_at_offset(victim, nb);
    av->top = remainder;
    set_head(victim, nb | PREV_INUSE);
    set_head(remainder, remainder_size | PREV_INUSE);
d2344 4
a2347 3
    check_malloced_chunk(victim, nb);
    return chunk2mem(victim);
  }
d2349 3
a2351 5
  /*
     If no space in top, relay to handle system-dependent cases
  */
  return sYSMALLOc(nb, av);
}
d2353 1
a2353 3
/*
  ------------------------------ free ------------------------------
*/
d2355 1
a2355 7
#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
  mstate av = get_malloc_state();
d2357 3
a2359 9
  mchunkptr       p;           /* chunk corresponding to mem */
  INTERNAL_SIZE_T size;        /* its size */
  mfastbinptr*    fb;          /* associated fastbin */
  mchunkptr       nextchunk;   /* next contiguous chunk */
  INTERNAL_SIZE_T nextsize;    /* its size */
  int             nextinuse;   /* true if nextchunk is used */
  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */
  mchunkptr       bck;         /* misc temp for linking */
  mchunkptr       fwd;         /* misc temp for linking */
d2361 15
a2375 5
  check_malloc_state();
  /* free(0) has no effect */
  if (mem != 0) {
    p = mem2chunk(mem);
    size = chunksize(p);
d2377 2
a2378 1
    check_inuse_chunk(p);
d2380 5
a2384 4
    /*
      If eligible, place chunk on a fastbin so it can be found
      and used quickly in malloc.
    */
d2386 3
a2388 1
    if ((CHUNK_SIZE_T)(size) <= (CHUNK_SIZE_T)(av->max_fast)
d2390 6
a2395 6
#if TRIM_FASTBINS
	/*
	   If TRIM_FASTBINS set, don't place chunks
	   bordering top into fastbins
	*/
	&& (chunk_at_offset(p, size) != av->top)
a2396 1
	) {
d2398 10
a2407 4
      set_fastchunks(av);
      fb = &(av->fastbins[fastbin_index(size)]);
      p->fd = *fb;
      *fb = p;
d2409 1
d2411 5
a2415 2
    /*
       Consolidate other non-mmapped chunks as they arrive.
d2417 11
d2429 22
a2450 2
    else if (!chunk_is_mmapped(p)) {
      set_anychunks(av);
d2452 2
a2453 2
      nextchunk = chunk_at_offset(p, size);
      nextsize = chunksize(nextchunk);
d2455 67
a2521 18
      /* consolidate backward */
      if (!prev_inuse(p)) {
	prevsize = p->prev_size;
	size += prevsize;
	p = chunk_at_offset(p, -((long) prevsize));
	unlink(p, bck, fwd);
      }

      if (nextchunk != av->top) {
	/* get and clear inuse bit */
	nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
	set_head(nextchunk, nextsize);

	/* consolidate forward */
	if (!nextinuse) {
	  unlink(nextchunk, bck, fwd);
	  size += nextsize;
	}
d2523 13
a2535 5
	/*
	  Place the chunk in unsorted chunk list. Chunks are
	  not placed into regular bins until after they have
	  been given one chance to be used in malloc.
	*/
d2537 85
a2621 17
	bck = unsorted_chunks(av);
	fwd = bck->fd;
	p->bk = bck;
	p->fd = fwd;
	bck->fd = p;
	fwd->bk = p;

	set_head(p, size | PREV_INUSE);
	set_foot(p, size);

	check_free_chunk(p);
      }

      /*
	 If the chunk borders the current high end of memory,
	 consolidate into top
      */
d2623 30
a2652 29
      else {
	size += nextsize;
	set_head(p, size | PREV_INUSE);
	av->top = p;
	check_chunk(p);
      }

      /*
	If freeing a large space, consolidate possibly-surrounding
	chunks. Then, if the total unused topmost memory exceeds trim
	threshold, ask malloc_trim to reduce top.

	Unless max_fast is 0, we don't know if there are fastbins
	bordering top, so we cannot tell for sure whether threshold
	has been reached unless fastbins are consolidated.  But we
	don't want to consolidate on each free.  As a compromise,
	consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
	is reached.
      */

      if ((CHUNK_SIZE_T)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
	if (have_fastchunks(av))
	  malloc_consolidate(av);

#ifndef MORECORE_CANNOT_TRIM
	if ((CHUNK_SIZE_T)(chunksize(av->top)) >=
	    (CHUNK_SIZE_T)(av->trim_threshold))
	  sYSTRIm(av->top_pad, av);
#endif
a2653 1

d2655 3
a2657 7
    /*
      If the chunk was allocated via mmap, release via munmap()
      Note that if HAVE_MMAP is false but chunk_is_mmapped is
      true, then user must have overwritten memory. There's nothing
      we can do to catch this error unless DEBUG is set, in which case
      check_inuse_chunk (above) will have triggered error.
    */
d2659 26
a2684 10
    else {
#if HAVE_MMAP
      int ret;
      INTERNAL_SIZE_T offset = p->prev_size;
      av->n_mmaps--;
      av->mmapped_mem -= (size + offset);
      ret = munmap((char*)p - offset, size + offset);
      /* munmap returns non-zero on failure */
      assert(ret == 0);
#endif
d2687 1
a2687 1
    check_malloc_state();
d2690 28
a2717 18
/*
  ------------------------- malloc_consolidate -------------------------

  malloc_consolidate is a specialized version of free() that tears
  down chunks held in fastbins.  Free itself cannot be used for this
  purpose since, among other things, it might place chunks back onto
  fastbins.  So, instead, we need to use a minor variant of the same
  code.

  Also, because this routine needs to be called the first time through
  malloc anyway, it turns out to be the perfect place to trigger
  initialization code.
*/

#if __STD_C
static void malloc_consolidate(mstate av)
#else
static void malloc_consolidate(av) mstate av;
a2718 24
{
  mfastbinptr*    fb;                 /* current fastbin being consolidated */
  mfastbinptr*    maxfb;              /* last fastbin (for loop control) */
  mchunkptr       p;                  /* current chunk being consolidated */
  mchunkptr       nextp;              /* next chunk to consolidate */
  mchunkptr       unsorted_bin;       /* bin header */
  mchunkptr       first_unsorted;     /* chunk to link to */

  /* These have same use as in free() */
  mchunkptr       nextchunk;
  INTERNAL_SIZE_T size;
  INTERNAL_SIZE_T nextsize;
  INTERNAL_SIZE_T prevsize;
  int             nextinuse;
  mchunkptr       bck;
  mchunkptr       fwd;

  /*
    If max_fast is 0, we know that av hasn't
    yet been initialized, in which case do so below
  */

  if (av->max_fast != 0) {
    clear_fastchunks(av);
d2720 21
a2740 30
    unsorted_bin = unsorted_chunks(av);

    /*
      Remove each chunk from fast bin and consolidate it, placing it
      then in unsorted bin. Among other reasons for doing this,
      placing in unsorted bin avoids needing to calculate actual bins
      until malloc is sure that chunks aren't immediately going to be
      reused anyway.
    */

    maxfb = &(av->fastbins[fastbin_index(av->max_fast)]);
    fb = &(av->fastbins[0]);
    do {
      if ( (p = *fb) != 0) {
	*fb = 0;

	do {
	  check_inuse_chunk(p);
	  nextp = p->fd;

	  /* Slightly streamlined version of consolidation code in free() */
	  size = p->size & ~PREV_INUSE;
	  nextchunk = chunk_at_offset(p, size);
	  nextsize = chunksize(nextchunk);

	  if (!prev_inuse(p)) {
	    prevsize = p->prev_size;
	    size += prevsize;
	    p = chunk_at_offset(p, -((long) prevsize));
	    unlink(p, bck, fwd);
d2742 4
d2747 13
a2759 8
	  if (nextchunk != av->top) {
	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
	    set_head(nextchunk, nextsize);

	    if (!nextinuse) {
	      size += nextsize;
	      unlink(nextchunk, bck, fwd);
	    }
d2761 23
a2783 9
	    first_unsorted = unsorted_bin->fd;
	    unsorted_bin->fd = p;
	    first_unsorted->bk = p;

	    set_head(p, size | PREV_INUSE);
	    p->bk = unsorted_bin;
	    p->fd = first_unsorted;
	    set_foot(p, size);
	  }
d2785 294
a3078 5
	  else {
	    size += nextsize;
	    set_head(p, size | PREV_INUSE);
	    av->top = p;
	  }
d3080 9
a3088 5
	} while ( (p = nextp) != 0);

      }
    } while (fb++ != maxfb);
  }
d3090 21
a3110 2
    malloc_init_state(av);
    check_malloc_state();
d3112 1
d3115 26
a3140 3
/*
  ------------------------------ realloc ------------------------------
*/
d3142 1
d3144 15
a3158 4
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
a3159 2
{
  mstate av = get_malloc_state();
d3161 37
a3197 1
  INTERNAL_SIZE_T  nb;              /* padded request size */
d3199 3
a3201 2
  mchunkptr        oldp;            /* chunk corresponding to oldmem */
  INTERNAL_SIZE_T  oldsize;         /* its size */
a3202 3
  mchunkptr        newp;            /* chunk to return */
  INTERNAL_SIZE_T  newsize;         /* its size */
  Void_t*          newmem;          /* corresponding user mem */
d3204 28
a3231 1
  mchunkptr        next;            /* next contiguous chunk after oldp */
d3233 11
a3243 5
  mchunkptr        remainder;       /* extra space at end of newp */
  CHUNK_SIZE_T     remainder_size;  /* its size */

  mchunkptr        bck;             /* misc temp for linking */
  mchunkptr        fwd;             /* misc temp for linking */
d3245 7
a3251 10
  CHUNK_SIZE_T     copysize;        /* bytes to copy */
  unsigned int     ncopies;         /* INTERNAL_SIZE_T words to copy */
  INTERNAL_SIZE_T* s;               /* copy source */
  INTERNAL_SIZE_T* d;               /* copy destination */


#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) {
    fREe(oldmem);
    return 0;
a3252 1
#endif
d3254 2
a3255 2
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
d3257 1
a3257 1
  checked_request2size(bytes, nb);
d3259 5
a3263 2
  oldp    = mem2chunk(oldmem);
  oldsize = chunksize(oldp);
d3265 1
a3265 1
  check_inuse_chunk(oldp);
d3267 6
a3272 1
  if (!chunk_is_mmapped(oldp)) {
d3274 16
a3289 5
    if ((CHUNK_SIZE_T)(oldsize) >= (CHUNK_SIZE_T)(nb)) {
      /* already big enough; split below */
      newp = oldp;
      newsize = oldsize;
    }
d3291 18
a3308 20
    else {
      next = chunk_at_offset(oldp, oldsize);

      /* Try to expand forward into top */
      if (next == av->top &&
	  (CHUNK_SIZE_T)(newsize = oldsize + chunksize(next)) >=
	  (CHUNK_SIZE_T)(nb + MINSIZE)) {
	set_head_size(oldp, nb);
	av->top = chunk_at_offset(oldp, nb);
	set_head(av->top, (newsize - nb) | PREV_INUSE);
	return chunk2mem(oldp);
      }

      /* Try to expand forward into next chunk;  split off remainder below */
      else if (next != av->top &&
	       !inuse(next) &&
	       (CHUNK_SIZE_T)(newsize = oldsize + chunksize(next)) >=
	       (CHUNK_SIZE_T)(nb)) {
	newp = oldp;
	unlink(next, bck, fwd);
a3309 16

      /* allocate, copy, free */
      else {
	newmem = mALLOc(nb - MALLOC_ALIGN_MASK);
	if (newmem == 0)
	  return 0; /* propagate failure */

	newp = mem2chunk(newmem);
	newsize = chunksize(newp);

	/*
	  Avoid copy if newp is next chunk after oldp.
	*/
	if (newp == next) {
	  newsize += oldsize;
	  newp = oldp;
d3312 9
a3320 14
	  /*
	    Unroll copy of <= 36 bytes (72 if 8byte sizes)
	    We know that contents have an odd number of
	    INTERNAL_SIZE_T-sized words; minimally 3.
	  */

	  copysize = oldsize - SIZE_SZ;
	  s = (INTERNAL_SIZE_T*)(oldmem);
	  d = (INTERNAL_SIZE_T*)(newmem);
	  ncopies = copysize / sizeof(INTERNAL_SIZE_T);
	  assert(ncopies >= 3);

	  if (ncopies > 9)
	    MALLOC_COPY(d, s, copysize);
d3322 8
a3329 13
	  else {
	    *(d+0) = *(s+0);
	    *(d+1) = *(s+1);
	    *(d+2) = *(s+2);
	    if (ncopies > 4) {
	      *(d+3) = *(s+3);
	      *(d+4) = *(s+4);
	      if (ncopies > 6) {
		*(d+5) = *(s+5);
		*(d+6) = *(s+6);
		if (ncopies > 8) {
		  *(d+7) = *(s+7);
		  *(d+8) = *(s+8);
d3333 2
d3337 9
a3345 3
	  fREe(oldmem);
	  check_inuse_chunk(newp);
	  return chunk2mem(newp);
d3350 18
a3367 1
    /* If possible, free extra space in old or extended chunk */
d3369 1
a3369 1
    assert((CHUNK_SIZE_T)(newsize) >= (CHUNK_SIZE_T)(nb));
d3371 2
a3372 1
    remainder_size = newsize - nb;
d3374 13
a3386 3
    if (remainder_size < MINSIZE) { /* not enough extra to split off */
      set_head_size(newp, newsize);
      set_inuse_bit_at_offset(newp, newsize);
a3387 7
    else { /* split remainder */
      remainder = chunk_at_offset(newp, nb);
      set_head_size(newp, nb);
      set_head(remainder, remainder_size | PREV_INUSE);
      /* Mark remainder as inuse so free() won't complain */
      set_inuse_bit_at_offset(remainder, remainder_size);
      fREe(chunk2mem(remainder));
d3390 9
a3398 2
    check_inuse_chunk(newp);
    return chunk2mem(newp);
a3399 5

  /*
    Handle mmap cases
  */

d3401 14
a3414 34
#if HAVE_MMAP

#if HAVE_MREMAP
    INTERNAL_SIZE_T offset = oldp->prev_size;
    size_t pagemask = av->pagesize - 1;
    char *cp;
    CHUNK_SIZE_T  sum;

    /* Note the extra SIZE_SZ overhead */
    newsize = (nb + offset + SIZE_SZ + pagemask) & ~pagemask;

    /* don't need to remap if still within same page */
    if (oldsize == newsize - offset)
      return oldmem;

    cp = (char*)mremap((char*)oldp - offset, oldsize + offset, newsize, 1);

    if (cp != (char*)MORECORE_FAILURE) {

      newp = (mchunkptr)(cp + offset);
      set_head(newp, (newsize - offset)|IS_MMAPPED);

      assert(aligned_OK(chunk2mem(newp)));
      assert((newp->prev_size == offset));

      /* update statistics */
      sum = av->mmapped_mem += newsize - oldsize;
      if (sum > (CHUNK_SIZE_T)(av->max_mmapped_mem))
	av->max_mmapped_mem = sum;
      sum += av->sbrked_mem;
      if (sum > (CHUNK_SIZE_T)(av->max_total_mem))
	av->max_total_mem = sum;

      return chunk2mem(newp);
a3415 1
#endif
d3417 9
a3425 9
    /* Note the extra SIZE_SZ overhead. */
    if ((CHUNK_SIZE_T)(oldsize) >= (CHUNK_SIZE_T)(nb + SIZE_SZ))
      newmem = oldmem; /* do nothing */
    else {
      /* Must alloc, copy, free. */
      newmem = mALLOc(nb - MALLOC_ALIGN_MASK);
      if (newmem != 0) {
	MALLOC_COPY(newmem, oldmem, oldsize - 2*SIZE_SZ);
	fREe(oldmem);
a3427 1
    return newmem;
a3428 3
#else
    /* If !HAVE_MMAP, but chunk_is_mmapped, user must have overwritten mem */
    check_malloc_state();
a3430 2
#endif
  }
d3433 1
a3433 3
/*
  ------------------------------ memalign ------------------------------
*/
d3435 27
a3461 5
#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
d3463 11
a3473 10
  INTERNAL_SIZE_T nb;             /* padded  request size */
  char*           m;              /* memory returned by malloc call */
  mchunkptr       p;              /* corresponding chunk */
  char*           brk;            /* alignment point within p */
  mchunkptr       newp;           /* chunk to return */
  INTERNAL_SIZE_T newsize;        /* its size */
  INTERNAL_SIZE_T leadsize;       /* leading space before alignment point */
  mchunkptr       remainder;      /* spare room at end to split off */
  CHUNK_SIZE_T    remainder_size; /* its size */
  INTERNAL_SIZE_T size;
d3475 7
a3481 1
  /* If need less alignment than we give anyway, just relay to malloc */
d3483 49
a3531 1
  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
d3533 82
a3614 1
  /* Otherwise, ensure that it is at least a minimum chunk size */
d3616 18
a3633 1
  if (alignment <  MINSIZE) alignment = MINSIZE;
d3635 14
a3648 5
  /* Make sure alignment is power of 2 (in case MINSIZE is not).  */
  if ((alignment & (alignment - 1)) != 0) {
    size_t a = MALLOC_ALIGNMENT * 2;
    while ((CHUNK_SIZE_T)a < (CHUNK_SIZE_T)alignment) a <<= 1;
    alignment = a;
d3651 3
a3653 6
  checked_request2size(bytes, nb);

  /*
    Strategy: find a spot within that chunk that meets the alignment
    request, and then possibly free the leading and trailing space.
  */
d3655 1
d3657 46
a3702 1
  /* Call malloc with worst case padding to hit alignment. */
d3704 1
a3704 1
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
d3706 5
a3710 27
  if (m == 0) return 0; /* propagate failure */

  p = mem2chunk(m);

  if ((((PTR_UINT)(m)) % alignment) != 0) { /* misaligned */

    /*
      Find an aligned spot inside chunk.  Since we need to give back
      leading space in a chunk of at least MINSIZE, if the first
      calculation places us at a spot with less than MINSIZE leader,
      we can move to the next aligned spot -- we've allocated enough
      total room so that this is always possible.
    */

    brk = (char*)mem2chunk((PTR_UINT)(((PTR_UINT)(m + alignment - 1)) &
			   -((signed long) alignment)));
    if ((CHUNK_SIZE_T)(brk - (char*)(p)) < MINSIZE)
      brk += alignment;

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
    newsize = chunksize(p) - leadsize;

    /* For mmapped chunks, just adjust offset */
    if (chunk_is_mmapped(p)) {
      newp->prev_size = p->prev_size + leadsize;
      set_head(newp, newsize|IS_MMAPPED);
d3713 8
a3720 21

    /* Otherwise, give back leader, use the rest */
    set_head(newp, newsize | PREV_INUSE);
    set_inuse_bit_at_offset(newp, newsize);
    set_head_size(p, leadsize);
    fREe(chunk2mem(p));
    p = newp;

    assert (newsize >= nb &&
	    (((PTR_UINT)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */
  if (!chunk_is_mmapped(p)) {
    size = chunksize(p);
    if ((CHUNK_SIZE_T)(size) > (CHUNK_SIZE_T)(nb + MINSIZE)) {
      remainder_size = size - nb;
      remainder = chunk_at_offset(p, nb);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_head_size(p, nb);
      fREe(chunk2mem(remainder));
d3723 1
a3723 3

  check_inuse_chunk(p);
  return chunk2mem(p);
d3726 1
a3726 3
/*
  ------------------------------ calloc ------------------------------
*/
d3728 10
a3737 10
#if __STD_C
Void_t* cALLOc(size_t n_elements, size_t elem_size)
#else
Void_t* cALLOc(n_elements, elem_size) size_t n_elements; size_t elem_size;
#endif
{
  mchunkptr p;
  CHUNK_SIZE_T  clearsize;
  CHUNK_SIZE_T  nclears;
  INTERNAL_SIZE_T* d;
d3739 11
a3749 1
  Void_t* mem = mALLOc(n_elements * elem_size);
d3751 29
a3779 2
  if (mem != 0) {
    p = mem2chunk(mem);
d3781 11
a3791 12
    if (!chunk_is_mmapped(p))
    {
      /*
	Unroll clear of <= 36 bytes (72 if 8byte sizes)
	We know that contents have an odd number of
	INTERNAL_SIZE_T-sized words; minimally 3.
      */

      d = (INTERNAL_SIZE_T*)mem;
      clearsize = chunksize(p) - SIZE_SZ;
      nclears = clearsize / sizeof(INTERNAL_SIZE_T);
      assert(nclears >= 3);
d3793 9
a3801 19
      if (nclears > 9)
	MALLOC_ZERO(d, clearsize);

      else {
	*(d+0) = 0;
	*(d+1) = 0;
	*(d+2) = 0;
	if (nclears > 4) {
	  *(d+3) = 0;
	  *(d+4) = 0;
	  if (nclears > 6) {
	    *(d+5) = 0;
	    *(d+6) = 0;
	    if (nclears > 8) {
	      *(d+7) = 0;
	      *(d+8) = 0;
	    }
	  }
	}
d3803 1
a3804 11
#if ! MMAP_CLEARS
    else
    {
      d = (INTERNAL_SIZE_T*)mem;
      /*
	Note the additional SIZE_SZ
      */
      clearsize = chunksize(p) - 2*SIZE_SZ;
      MALLOC_ZERO(d, clearsize);
    }
#endif
d3806 1
a3806 1
  return mem;
d3809 1
a3809 3
/*
  ------------------------------ cfree ------------------------------
*/
d3811 8
a3818 42
#if __STD_C
void cFREe(Void_t *mem)
#else
void cFREe(mem) Void_t *mem;
#endif
{
  fREe(mem);
}

#ifdef NEED_INDEPENDENT
/*
  ------------------------- independent_calloc -------------------------
*/

#if __STD_C
Void_t** iCALLOc(size_t n_elements, size_t elem_size, Void_t* chunks[])
#else
Void_t** iCALLOc(n_elements, elem_size, chunks) size_t n_elements; size_t elem_size; Void_t* chunks[];
#endif
{
  size_t sz = elem_size; /* serves as 1-element array */
  /* opts arg of 3 means all elements are same size, and should be cleared */
  return iALLOc(n_elements, &sz, 3, chunks);
}

/*
  ------------------------- independent_comalloc -------------------------
*/

#if __STD_C
Void_t** iCOMALLOc(size_t n_elements, size_t sizes[], Void_t* chunks[])
#else
Void_t** iCOMALLOc(n_elements, sizes, chunks) size_t n_elements; size_t sizes[]; Void_t* chunks[];
#endif
{
  return iALLOc(n_elements, sizes, 0, chunks);
}

/*
  ------------------------------ ialloc ------------------------------
  ialloc provides common support for independent_X routines, handling all of
  the combinations that can result.
d3825 4
a3828 15

#if __STD_C
static Void_t** iALLOc(size_t n_elements,
		       size_t* sizes,
		       int opts,
		       Void_t* chunks[])
#else
static Void_t** iALLOc(n_elements, sizes, opts, chunks) size_t n_elements; size_t* sizes; int opts; Void_t* chunks[];
#endif
{
  mstate av = get_malloc_state();
  INTERNAL_SIZE_T element_size;   /* chunksize of each element, if all same */
  INTERNAL_SIZE_T contents_size;  /* total size of elements */
  INTERNAL_SIZE_T array_size;     /* request size of pointer array */
  Void_t*         mem;            /* malloced aggregate space */
d3830 2
a3831 2
  INTERNAL_SIZE_T remainder_size; /* remaining bytes while splitting */
  Void_t**        marray;         /* either "chunks" or malloced ptr array */
d3833 2
a3834 2
  int             mmx;            /* to disable mmap */
  INTERNAL_SIZE_T size;
a3836 3
  /* Ensure initialization */
  if (av->max_fast == 0) malloc_consolidate(av);

d3847 1
a3847 1
      return (Void_t**) mALLOc(0);
d3849 1
a3849 1
    array_size = request2size(n_elements * (sizeof(Void_t*)));
d3864 1
a3864 2
  /* subtract out alignment bytes from total to minimize overallocation */
  size = contents_size + array_size - MALLOC_ALIGN_MASK;
d3867 9
a3875 9
     Allocate the aggregate chunk.
     But first disable mmap so malloc won't use it, since
     we would not be able to later free/realloc space internal
     to a segregated mmap region.
 */
  mmx = av->n_mmaps_max;   /* disable mmap */
  av->n_mmaps_max = 0;
  mem = mALLOc(size);
  av->n_mmaps_max = mmx;   /* reset mmap */
d3879 1
a3880 1
  assert(!chunk_is_mmapped(p));
d3883 2
d3886 1
a3886 1
    MALLOC_ZERO(mem, remainder_size - SIZE_SZ - array_size);
d3891 5
a3895 3
    array_chunk = chunk_at_offset(p, contents_size);
    marray = (Void_t**) (chunk2mem(array_chunk));
    set_head(array_chunk, (remainder_size - contents_size) | PREV_INUSE);
d3908 2
a3909 2
      set_head(p, size | PREV_INUSE);
      p = chunk_at_offset(p, size);
d3912 1
a3912 1
      set_head(p, remainder_size | PREV_INUSE);
d3920 4
a3923 3
    if (element_size != 0)
      assert(remainder_size == element_size);
    else
a3924 1
    check_inuse_chunk(mem2chunk(marray));
d3926 4
a3930 2
  for (i = 0; i != n_elements; ++i)
    check_inuse_chunk(mem2chunk(marray[i]));
d3933 1
a3935 1
#endif /* NEED_INDEPENDENT */
d3937 24
d3962 2
a3963 3
/*
  ------------------------------ valloc ------------------------------
*/
d3965 22
a3986 11
#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
  /* Ensure initialization */
  mstate av = get_malloc_state();
  if (av->max_fast == 0) malloc_consolidate(av);
  return mEMALIGn(av->pagesize, bytes);
}
d3988 26
a4013 4
#ifdef NEED_PVALLOC
/*
  ------------------------------ pvalloc ------------------------------
*/
d4015 15
d4031 38
a4068 8
#if __STD_C
Void_t* pVALLOc(size_t bytes)
#else
Void_t* pVALLOc(bytes) size_t bytes;
#endif
{
  mstate av = get_malloc_state();
  size_t pagesz;
d4070 1
a4070 4
  /* Ensure initialization */
  if (av->max_fast == 0) malloc_consolidate(av);
  pagesz = av->pagesize;
  return mEMALIGn(pagesz, (bytes + pagesz - 1) & ~(pagesz - 1));
a4071 1
#endif /*NEED_PVALLOC*/
d4073 6
d4080 43
a4122 3
/*
  ------------------------------ malloc_trim ------------------------------
*/
d4124 46
a4169 4
#if __STD_C
int mTRIm(size_t pad)
#else
int mTRIm(pad) size_t pad;
d4171 1
a4171 4
{
  mstate av = get_malloc_state();
  /* Ensure initialization/consolidation */
  malloc_consolidate(av);
d4173 13
a4185 5
#ifndef MORECORE_CANNOT_TRIM
  return sYSTRIm(pad, av);
#else
  return 0;
#endif
d4188 6
a4193 7

/*
  ------------------------- malloc_usable_size -------------------------
*/

#if __STD_C
size_t mUSABLe(Void_t* mem)
d4195 5
a4199 1
size_t mUSABLe(mem) Void_t* mem;
d4201 1
a4201 8
{
  mchunkptr p;
  if (mem != 0) {
    p = mem2chunk(mem);
    if (chunk_is_mmapped(p))
      return chunksize(p) - 2*SIZE_SZ;
    else if (inuse(p))
      return chunksize(p) - SIZE_SZ;
a4202 1
  return 0;
d4205 3
a4207 3
/*
  ------------------------------ mallinfo ------------------------------
*/
d4209 5
a4213 11
struct mallinfo mALLINFo()
{
  mstate av = get_malloc_state();
  struct mallinfo mi;
  unsigned i;
  mbinptr b;
  mchunkptr p;
  INTERNAL_SIZE_T avail;
  INTERNAL_SIZE_T fastavail;
  int nblocks;
  int nfastblocks;
d4215 4
a4218 2
  /* Ensure initialization */
  if (av->top == 0)  malloc_consolidate(av);
d4220 6
a4225 1
  check_malloc_state();
d4227 6
a4232 7
  /* Account for top */
  avail = chunksize(av->top);
  nblocks = 1;  /* top always exists */

  /* traverse fastbins */
  nfastblocks = 0;
  fastavail = 0;
d4234 5
a4238 5
  for (i = 0; i < NFASTBINS; ++i) {
    for (p = av->fastbins[i]; p != 0; p = p->fd) {
      ++nfastblocks;
      fastavail += chunksize(p);
    }
d4240 2
d4243 3
a4245 1
  avail += fastavail;
d4247 5
a4251 8
  /* traverse regular bins */
  for (i = 1; i < NBINS; ++i) {
    b = bin_at(av, i);
    for (p = last(b); p != b; p = p->bk) {
      ++nblocks;
      avail += chunksize(p);
    }
  }
d4253 2
a4254 11
  mi.smblks = nfastblocks;
  mi.ordblks = nblocks;
  mi.fordblks = avail;
  mi.uordblks = av->sbrked_mem - avail;
  mi.arena = av->sbrked_mem;
  mi.hblks = av->n_mmaps;
  mi.hblkhd = av->mmapped_mem;
  mi.fsmblks = fastavail;
  mi.keepcost = chunksize(av->top);
  mi.usmblks = av->max_total_mem;
  return mi;
d4257 8
a4264 3
/*
  ------------------------------ malloc_stats ------------------------------
*/
d4266 3
a4268 3
void mSTATs()
{
  struct mallinfo mi = mALLINFo();
a4269 11
#ifdef WIN32
  {
    CHUNK_SIZE_T  free, reserved, committed;
    vminfo (&free, &reserved, &committed);
    fprintf(stderr, "free bytes       = %10lu\n",
	    free);
    fprintf(stderr, "reserved bytes   = %10lu\n",
	    reserved);
    fprintf(stderr, "committed bytes  = %10lu\n",
	    committed);
  }
d4272 1
d4274 20
a4293 6
  fprintf(stderr, "max system bytes = %10lu\n",
	  (CHUNK_SIZE_T)(mi.usmblks));
  fprintf(stderr, "system bytes     = %10lu\n",
	  (CHUNK_SIZE_T)(mi.arena + mi.hblkhd));
  fprintf(stderr, "in use bytes     = %10lu\n",
	  (CHUNK_SIZE_T)(mi.uordblks + mi.hblkhd));
d4295 63
a4357 8
#ifdef WIN32
  {
    CHUNK_SIZE_T  kernel, user;
    if (cpuinfo (TRUE, &kernel, &user)) {
      fprintf(stderr, "kernel ms        = %10lu\n",
	      kernel);
      fprintf(stderr, "user ms          = %10lu\n",
	      user);
d4359 8
d4368 1
a4368 1
#endif
a4370 1

d4372 2
a4373 1
  ------------------------------ mallopt ------------------------------
a4375 9
#if __STD_C
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  mstate av = get_malloc_state();
  /* Ensure initialization/consolidation */
  malloc_consolidate(av);
d4377 70
a4446 5
  switch(param_number) {
  case M_MXFAST:
    if (value >= 0 && value <= MAX_FAST_SIZE) {
      set_max_fast(av, value);
      return 1;
a4447 2
    else
      return 0;
d4449 38
a4486 3
  case M_TRIM_THRESHOLD:
    av->trim_threshold = value;
    return 1;
d4488 2
a4489 3
  case M_TOP_PAD:
    av->top_pad = value;
    return 1;
d4491 44
a4534 3
  case M_MMAP_THRESHOLD:
    av->mmap_threshold = value;
    return 1;
d4536 45
a4580 7
  case M_MMAP_MAX:
#if !HAVE_MMAP
    if (value != 0)
      return 0;
#endif
    av->n_mmaps_max = value;
    return 1;
d4582 6
a4587 1
  default:
d4590 10
d4602 17
a4618 3
/*
  -------------------- Alternative MORECORE functions --------------------
*/
d4620 8
d4629 10
a4638 2
/*
  General Requirements for MORECORE.
d4640 9
a4648 1
  The MORECORE function must have the following properties:
d4650 14
a4663 1
  If MORECORE_CONTIGUOUS is false:
d4665 9
a4673 2
    * MORECORE must allocate in multiples of pagesize. It will
      only be called with arguments that are multiples of pagesize.
d4675 9
a4683 2
    * MORECORE(0) must return an address that is at least
      MALLOC_ALIGNMENT aligned. (Page-aligning always suffices.)
a4684 1
  else (i.e. If MORECORE_CONTIGUOUS is true):
d4686 9
a4694 3
    * Consecutive calls to MORECORE with positive arguments
      return increasing addresses, indicating that space has been
      contiguously extended.
d4696 3
a4698 2
    * MORECORE need not allocate in multiples of pagesize.
      Calls to MORECORE need not have args of multiples of pagesize.
d4700 1
a4700 1
    * MORECORE need not page-align.
d4702 1
a4702 1
  In either case:
d4704 2
a4705 2
    * MORECORE may allocate more memory than requested. (Or even less,
      but this will generally result in a malloc failure.)
d4707 4
a4710 1
    * MORECORE must not allocate memory when given argument zero, but
d4712 5
a4716 5
      nonzero call. This malloc does NOT call MORECORE(0)
      until at least one call with positive arguments is made, so
      the initial value returned is not important.

    * Even though consecutive calls to MORECORE need not return contiguous
a4718 1

d4720 1
a4720 1
      just return MORECORE_FAILURE when given negative arguments.
d4726 6
a4731 31
  There is some variation across systems about the type of the
  argument to sbrk/MORECORE. If size_t is unsigned, then it cannot
  actually be size_t, because sbrk supports negative args, so it is
  normally the signed type of the same width as size_t (sometimes
  declared as "intptr_t", and sometimes "ptrdiff_t").  It doesn't much
  matter though. Internally, we use "long" as arguments, which should
  work across all reasonable possibilities.

  Additionally, if MORECORE ever returns failure for a positive
  request, and HAVE_MMAP is true, then mmap is used as a noncontiguous
  system allocator. This is a useful backup strategy for systems with
  holes in address spaces -- in this case sbrk cannot contiguously
  expand the heap, but mmap may be able to map noncontiguous space.

  If you'd like mmap to ALWAYS be used, you can define MORECORE to be
  a function that always returns MORECORE_FAILURE.

  Malloc only has limited ability to detect failures of MORECORE
  to supply contiguous space when it says it can. In particular,
  multithreaded programs that do not use locks may result in
  rece conditions across calls to MORECORE that result in gaps
  that cannot be detected as such, and subsequent corruption.

  If you are using this malloc with something other than sbrk (or its
  emulation) to supply memory regions, you probably want to set
  MORECORE_CONTIGUOUS as false.  As an example, here is a custom
  allocator kindly contributed for pre-OSX macOS.  It uses virtually
  but not necessarily physically contiguous non-paged memory (locked
  in, present and won't get swapped out).  You can use it by
  uncommenting this section, adding some #includes, and setting up the
  appropriate defines above:
a4733 1
      #define MORECORE_CONTIGUOUS 0
d4739 1
a4739 1
  #define MINIMUM_MORECORE_SIZE  (64 * 1024)
d4756 1
a4756 1
	return (void *) MORECORE_FAILURE;
d4761 1
a4761 1
      ptr = (void *) ((((CHUNK_SIZE_T) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);
d4768 1
a4768 1
      return (void *) MORECORE_FAILURE;
d4794 17
a4810 490
/*
  --------------------------------------------------------------

  Emulation of sbrk for win32.
  Donated by J. Walter <Walter@@GeNeSys-e.de>.
  For additional information about this code, and malloc on Win32, see
     http://www.genesys-e.de/jwalter/
*/


#ifdef WIN32

#ifdef _DEBUG
/* #define TRACE */
#endif

/* Support for USE_MALLOC_LOCK */
#ifdef USE_MALLOC_LOCK

/* Wait for spin lock */
static int slwait (int *sl) {
    while (InterlockedCompareExchange ((void **) sl, (void *) 1, (void *) 0) != 0)
	    Sleep (0);
    return 0;
}

/* Release spin lock */
static int slrelease (int *sl) {
    InterlockedExchange (sl, 0);
    return 0;
}

#ifdef NEEDED
/* Spin lock for emulation code */
static int g_sl;
#endif

#endif /* USE_MALLOC_LOCK */

/* getpagesize for windows */
static long getpagesize (void) {
    static long g_pagesize = 0;
    if (! g_pagesize) {
	SYSTEM_INFO system_info;
	GetSystemInfo (&system_info);
	g_pagesize = system_info.dwPageSize;
    }
    return g_pagesize;
}
static long getregionsize (void) {
    static long g_regionsize = 0;
    if (! g_regionsize) {
	SYSTEM_INFO system_info;
	GetSystemInfo (&system_info);
	g_regionsize = system_info.dwAllocationGranularity;
    }
    return g_regionsize;
}

/* A region list entry */
typedef struct _region_list_entry {
    void *top_allocated;
    void *top_committed;
    void *top_reserved;
    long reserve_size;
    struct _region_list_entry *previous;
} region_list_entry;

/* Allocate and link a region entry in the region list */
static int region_list_append (region_list_entry **last, void *base_reserved, long reserve_size) {
    region_list_entry *next = HeapAlloc (GetProcessHeap (), 0, sizeof (region_list_entry));
    if (! next)
	return FALSE;
    next->top_allocated = (char *) base_reserved;
    next->top_committed = (char *) base_reserved;
    next->top_reserved = (char *) base_reserved + reserve_size;
    next->reserve_size = reserve_size;
    next->previous = *last;
    *last = next;
    return TRUE;
}
/* Free and unlink the last region entry from the region list */
static int region_list_remove (region_list_entry **last) {
    region_list_entry *previous = (*last)->previous;
    if (! HeapFree (GetProcessHeap (), sizeof (region_list_entry), *last))
	return FALSE;
    *last = previous;
    return TRUE;
}

#define CEIL(size,to)	(((size)+(to)-1)&~((to)-1))
#define FLOOR(size,to)	((size)&~((to)-1))

#define SBRK_SCALE  0
/* #define SBRK_SCALE  1 */
/* #define SBRK_SCALE  2 */
/* #define SBRK_SCALE  4  */

/* sbrk for windows */
static void *sbrk (long size) {
    static long g_pagesize, g_my_pagesize;
    static long g_regionsize, g_my_regionsize;
    static region_list_entry *g_last;
    void *result = (void *) MORECORE_FAILURE;
#ifdef TRACE
    printf ("sbrk %d\n", size);
#endif
#if defined (USE_MALLOC_LOCK) && defined (NEEDED)
    /* Wait for spin lock */
    slwait (&g_sl);
#endif
    /* First time initialization */
    if (! g_pagesize) {
	g_pagesize = getpagesize ();
	g_my_pagesize = g_pagesize << SBRK_SCALE;
    }
    if (! g_regionsize) {
	g_regionsize = getregionsize ();
	g_my_regionsize = g_regionsize << SBRK_SCALE;
    }
    if (! g_last) {
	if (! region_list_append (&g_last, 0, 0))
	   goto sbrk_exit;
    }
    /* Assert invariants */
    assert (g_last);
    assert ((char *) g_last->top_reserved - g_last->reserve_size <= (char *) g_last->top_allocated &&
	    g_last->top_allocated <= g_last->top_committed);
    assert ((char *) g_last->top_reserved - g_last->reserve_size <= (char *) g_last->top_committed &&
	    g_last->top_committed <= g_last->top_reserved &&
	    (unsigned) g_last->top_committed % g_pagesize == 0);
    assert ((unsigned) g_last->top_reserved % g_regionsize == 0);
    assert ((unsigned) g_last->reserve_size % g_regionsize == 0);
    /* Allocation requested? */
    if (size >= 0) {
	/* Allocation size is the requested size */
	long allocate_size = size;
	/* Compute the size to commit */
	long to_commit = (char *) g_last->top_allocated + allocate_size - (char *) g_last->top_committed;
	/* Do we reach the commit limit? */
	if (to_commit > 0) {
	    /* Round size to commit */
	    long commit_size = CEIL (to_commit, g_my_pagesize);
	    /* Compute the size to reserve */
	    long to_reserve = (char *) g_last->top_committed + commit_size - (char *) g_last->top_reserved;
	    /* Do we reach the reserve limit? */
	    if (to_reserve > 0) {
		/* Compute the remaining size to commit in the current region */
		long remaining_commit_size = (char *) g_last->top_reserved - (char *) g_last->top_committed;
		if (remaining_commit_size > 0) {
		    /* Assert preconditions */
		    assert ((unsigned) g_last->top_committed % g_pagesize == 0);
		    assert (0 < remaining_commit_size && remaining_commit_size % g_pagesize == 0); {
			/* Commit this */
			void *base_committed = VirtualAlloc (g_last->top_committed, remaining_commit_size,
											 MEM_COMMIT, PAGE_READWRITE);
			/* Check returned pointer for consistency */
			if (base_committed != g_last->top_committed)
			    goto sbrk_exit;
			/* Assert postconditions */
			assert ((unsigned) base_committed % g_pagesize == 0);
#ifdef TRACE
			printf ("Commit %p %d\n", base_committed, remaining_commit_size);
#endif
			/* Adjust the regions commit top */
			g_last->top_committed = (char *) base_committed + remaining_commit_size;
		    }
		} {
		    /* Now we are going to search and reserve. */
		    int contiguous = -1;
		    int found = FALSE;
		    MEMORY_BASIC_INFORMATION memory_info;
		    void *base_reserved;
		    long reserve_size;
		    do {
			/* Assume contiguous memory */
			contiguous = TRUE;
			/* Round size to reserve */
			reserve_size = CEIL (to_reserve, g_my_regionsize);
			/* Start with the current region's top */
			memory_info.BaseAddress = g_last->top_reserved;
			/* Assert preconditions */
			assert ((unsigned) memory_info.BaseAddress % g_pagesize == 0);
			assert (0 < reserve_size && reserve_size % g_regionsize == 0);
			while (VirtualQuery (memory_info.BaseAddress, &memory_info, sizeof (memory_info))) {
			    /* Assert postconditions */
			    assert ((unsigned) memory_info.BaseAddress % g_pagesize == 0);
#ifdef TRACE
			    printf ("Query %p %d %s\n", memory_info.BaseAddress, memory_info.RegionSize,
				    memory_info.State == MEM_FREE ? "FREE":
				    (memory_info.State == MEM_RESERVE ? "RESERVED":
				     (memory_info.State == MEM_COMMIT ? "COMMITTED": "?")));
#endif
			    /* Region is free, well aligned and big enough: we are done */
			    if (memory_info.State == MEM_FREE &&
				(unsigned) memory_info.BaseAddress % g_regionsize == 0 &&
				memory_info.RegionSize >= (unsigned) reserve_size) {
				found = TRUE;
				break;
			    }
			    /* From now on we can't get contiguous memory! */
			    contiguous = FALSE;
			    /* Recompute size to reserve */
			    reserve_size = CEIL (allocate_size, g_my_regionsize);
			    memory_info.BaseAddress = (char *) memory_info.BaseAddress + memory_info.RegionSize;
			    /* Assert preconditions */
			    assert ((unsigned) memory_info.BaseAddress % g_pagesize == 0);
			    assert (0 < reserve_size && reserve_size % g_regionsize == 0);
			}
			/* Search failed? */
			if (! found)
			    goto sbrk_exit;
			/* Assert preconditions */
			assert ((unsigned) memory_info.BaseAddress % g_regionsize == 0);
			assert (0 < reserve_size && reserve_size % g_regionsize == 0);
			/* Try to reserve this */
			base_reserved = VirtualAlloc (memory_info.BaseAddress, reserve_size,
									  MEM_RESERVE, PAGE_NOACCESS);
			if (! base_reserved) {
			    int rc = GetLastError ();
			    if (rc != ERROR_INVALID_ADDRESS)
				goto sbrk_exit;
			}
			/* A null pointer signals (hopefully) a race condition with another thread. */
			/* In this case, we try again. */
		    } while (! base_reserved);
		    /* Check returned pointer for consistency */
		    if (memory_info.BaseAddress && base_reserved != memory_info.BaseAddress)
			goto sbrk_exit;
		    /* Assert postconditions */
		    assert ((unsigned) base_reserved % g_regionsize == 0);
#ifdef TRACE
		    printf ("Reserve %p %d\n", base_reserved, reserve_size);
#endif
		    /* Did we get contiguous memory? */
		    if (contiguous) {
			long start_size = (char *) g_last->top_committed - (char *) g_last->top_allocated;
			/* Adjust allocation size */
			allocate_size -= start_size;
			/* Adjust the regions allocation top */
			g_last->top_allocated = g_last->top_committed;
			/* Recompute the size to commit */
			to_commit = (char *) g_last->top_allocated + allocate_size - (char *) g_last->top_committed;
			/* Round size to commit */
			commit_size = CEIL (to_commit, g_my_pagesize);
		    }
		    /* Append the new region to the list */
		    if (! region_list_append (&g_last, base_reserved, reserve_size))
			goto sbrk_exit;
		    /* Didn't we get contiguous memory? */
		    if (! contiguous) {
			/* Recompute the size to commit */
			to_commit = (char *) g_last->top_allocated + allocate_size - (char *) g_last->top_committed;
			/* Round size to commit */
			commit_size = CEIL (to_commit, g_my_pagesize);
		    }
		}
	    }
	    /* Assert preconditions */
	    assert ((unsigned) g_last->top_committed % g_pagesize == 0);
	    assert (0 < commit_size && commit_size % g_pagesize == 0); {
		/* Commit this */
		void *base_committed = VirtualAlloc (g_last->top_committed, commit_size,
									     MEM_COMMIT, PAGE_READWRITE);
		/* Check returned pointer for consistency */
		if (base_committed != g_last->top_committed)
		    goto sbrk_exit;
		/* Assert postconditions */
		assert ((unsigned) base_committed % g_pagesize == 0);
#ifdef TRACE
		printf ("Commit %p %d\n", base_committed, commit_size);
#endif
		/* Adjust the regions commit top */
		g_last->top_committed = (char *) base_committed + commit_size;
	    }
	}
	/* Adjust the regions allocation top */
	g_last->top_allocated = (char *) g_last->top_allocated + allocate_size;
	result = (char *) g_last->top_allocated - size;
    /* Deallocation requested? */
    } else if (size < 0) {
	long deallocate_size = - size;
	/* As long as we have a region to release */
	while ((char *) g_last->top_allocated - deallocate_size < (char *) g_last->top_reserved - g_last->reserve_size) {
	    /* Get the size to release */
	    long release_size = g_last->reserve_size;
	    /* Get the base address */
	    void *base_reserved = (char *) g_last->top_reserved - release_size;
	    /* Assert preconditions */
	    assert ((unsigned) base_reserved % g_regionsize == 0);
	    assert (0 < release_size && release_size % g_regionsize == 0); {
		/* Release this */
		int rc = VirtualFree (base_reserved, 0,
				      MEM_RELEASE);
		/* Check returned code for consistency */
		if (! rc)
		    goto sbrk_exit;
#ifdef TRACE
		printf ("Release %p %d\n", base_reserved, release_size);
#endif
	    }
	    /* Adjust deallocation size */
	    deallocate_size -= (char *) g_last->top_allocated - (char *) base_reserved;
	    /* Remove the old region from the list */
	    if (! region_list_remove (&g_last))
		goto sbrk_exit;
	} {
	    /* Compute the size to decommit */
	    long to_decommit = (char *) g_last->top_committed - ((char *) g_last->top_allocated - deallocate_size);
	    if (to_decommit >= g_my_pagesize) {
		/* Compute the size to decommit */
		long decommit_size = FLOOR (to_decommit, g_my_pagesize);
		/*  Compute the base address */
		void *base_committed = (char *) g_last->top_committed - decommit_size;
		/* Assert preconditions */
		assert ((unsigned) base_committed % g_pagesize == 0);
		assert (0 < decommit_size && decommit_size % g_pagesize == 0); {
		    /* Decommit this */
		    int rc = VirtualFree ((char *) base_committed, decommit_size,
					  MEM_DECOMMIT);
		    /* Check returned code for consistency */
		    if (! rc)
			goto sbrk_exit;
#ifdef TRACE
		    printf ("Decommit %p %d\n", base_committed, decommit_size);
#endif
		}
		/* Adjust deallocation size and regions commit and allocate top */
		deallocate_size -= (char *) g_last->top_allocated - (char *) base_committed;
		g_last->top_committed = base_committed;
		g_last->top_allocated = base_committed;
	    }
	}
	/* Adjust regions allocate top */
	g_last->top_allocated = (char *) g_last->top_allocated - deallocate_size;
	/* Check for underflow */
	if ((char *) g_last->top_reserved - g_last->reserve_size > (char *) g_last->top_allocated ||
	    g_last->top_allocated > g_last->top_committed) {
	    /* Adjust regions allocate top */
	    g_last->top_allocated = (char *) g_last->top_reserved - g_last->reserve_size;
	    goto sbrk_exit;
	}
	result = g_last->top_allocated;
    }
    /* Assert invariants */
    assert (g_last);
    assert ((char *) g_last->top_reserved - g_last->reserve_size <= (char *) g_last->top_allocated &&
	    g_last->top_allocated <= g_last->top_committed);
    assert ((char *) g_last->top_reserved - g_last->reserve_size <= (char *) g_last->top_committed &&
	    g_last->top_committed <= g_last->top_reserved &&
	    (unsigned) g_last->top_committed % g_pagesize == 0);
    assert ((unsigned) g_last->top_reserved % g_regionsize == 0);
    assert ((unsigned) g_last->reserve_size % g_regionsize == 0);

sbrk_exit:
#if defined (USE_MALLOC_LOCK) && defined (NEEDED)
    /* Release spin lock */
    slrelease (&g_sl);
#endif
    return result;
}

/* mmap for windows */
static void *mmap (void *ptr, long size, long prot, long type, long handle, long arg) {
    static long g_pagesize;
    static long g_regionsize;
#ifdef TRACE
    printf ("mmap %d\n", size);
#endif
#if defined (USE_MALLOC_LOCK) && defined (NEEDED)
    /* Wait for spin lock */
    slwait (&g_sl);
#endif
    /* First time initialization */
    if (! g_pagesize)
	g_pagesize = getpagesize ();
    if (! g_regionsize)
	g_regionsize = getregionsize ();
    /* Assert preconditions */
    assert ((unsigned) ptr % g_regionsize == 0);
    assert (size % g_pagesize == 0);
    /* Allocate this */
    ptr = VirtualAlloc (ptr, size,
					    MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, PAGE_READWRITE);
    if (! ptr) {
	ptr = (void *) MORECORE_FAILURE;
	goto mmap_exit;
    }
    /* Assert postconditions */
    assert ((unsigned) ptr % g_regionsize == 0);
#ifdef TRACE
    printf ("Commit %p %d\n", ptr, size);
#endif
mmap_exit:
#if defined (USE_MALLOC_LOCK) && defined (NEEDED)
    /* Release spin lock */
    slrelease (&g_sl);
#endif
    return ptr;
}

/* munmap for windows */
static long munmap (void *ptr, long size) {
    static long g_pagesize;
    static long g_regionsize;
    int rc = MUNMAP_FAILURE;
#ifdef TRACE
    printf ("munmap %p %d\n", ptr, size);
#endif
#if defined (USE_MALLOC_LOCK) && defined (NEEDED)
    /* Wait for spin lock */
    slwait (&g_sl);
#endif
    /* First time initialization */
    if (! g_pagesize)
	g_pagesize = getpagesize ();
    if (! g_regionsize)
	g_regionsize = getregionsize ();
    /* Assert preconditions */
    assert ((unsigned) ptr % g_regionsize == 0);
    assert (size % g_pagesize == 0);
    /* Free this */
    if (! VirtualFree (ptr, 0,
		       MEM_RELEASE))
	goto munmap_exit;
    rc = 0;
#ifdef TRACE
    printf ("Release %p %d\n", ptr, size);
#endif
munmap_exit:
#if defined (USE_MALLOC_LOCK) && defined (NEEDED)
    /* Release spin lock */
    slrelease (&g_sl);
#endif
    return rc;
}

static void vminfo (CHUNK_SIZE_T  *free, CHUNK_SIZE_T  *reserved, CHUNK_SIZE_T  *committed) {
    MEMORY_BASIC_INFORMATION memory_info;
    memory_info.BaseAddress = 0;
    *free = *reserved = *committed = 0;
    while (VirtualQuery (memory_info.BaseAddress, &memory_info, sizeof (memory_info))) {
	switch (memory_info.State) {
	case MEM_FREE:
	    *free += memory_info.RegionSize;
	    break;
	case MEM_RESERVE:
	    *reserved += memory_info.RegionSize;
	    break;
	case MEM_COMMIT:
	    *committed += memory_info.RegionSize;
	    break;
	}
	memory_info.BaseAddress = (char *) memory_info.BaseAddress + memory_info.RegionSize;
    }
}

static int cpuinfo (int whole, CHUNK_SIZE_T  *kernel, CHUNK_SIZE_T  *user) {
    if (whole) {
	__int64 creation64, exit64, kernel64, user64;
	int rc = GetProcessTimes (GetCurrentProcess (),
				  (FILETIME *) &creation64,
				  (FILETIME *) &exit64,
				  (FILETIME *) &kernel64,
				  (FILETIME *) &user64);
	if (! rc) {
	    *kernel = 0;
	    *user = 0;
	    return FALSE;
	}
	*kernel = (CHUNK_SIZE_T) (kernel64 / 10000);
	*user = (CHUNK_SIZE_T) (user64 / 10000);
	return TRUE;
    } else {
	__int64 creation64, exit64, kernel64, user64;
	int rc = GetThreadTimes (GetCurrentThread (),
				 (FILETIME *) &creation64,
				 (FILETIME *) &exit64,
				 (FILETIME *) &kernel64,
				 (FILETIME *) &user64);
	if (! rc) {
	    *kernel = 0;
	    *user = 0;
	    return FALSE;
	}
	*kernel = (CHUNK_SIZE_T) (kernel64 / 10000);
	*user = (CHUNK_SIZE_T) (user64 / 10000);
	return TRUE;
    }
}
a4811 4
#endif /* WIN32 */

/* ------------------------------------------------------------
History:
d4842 1
a4842 1
      * Collect all cases in malloc requiring system memory into sYSMALLOc
@


1.6
log
@* include/cygwin/version.h: Bump DLL minor number.
* malloc.cc (DEFAULT_MMAP_THRESHOLD): Bump down to 16MB thanks to below
changes.
@
text
@d3747 1
d3882 1
@


1.5
log
@* malloc.cc (DEFAULT_MMAP_THRESHOLD): Set high to avoid mmaps.
* pipe.cc (fhandler_pipe::close): Avoid extraneous this->.
@
text
@d1458 1
a1458 1
#define DEFAULT_MMAP_THRESHOLD (128 * 1024 * 1024)
@


1.4
log
@* malloc.cc: Protect some definitions to avoid a compile time warning.
@
text
@d1458 2
@


1.4.16.1
log
@merge from trunk
@
text
@a1457 2
#define DEFAULT_MMAP_THRESHOLD (128 * 1024 * 1024)

@


1.4.16.2
log
@merge from trunk
@
text
@d1458 1
a1458 1
#define DEFAULT_MMAP_THRESHOLD (16 * 1024 * 1024)
@


1.4.16.3
log
@merge from trunk
@
text
@a3746 1
  check_malloc_state();
a3880 1
    check_malloc_state();
@


1.3
log
@* perthread.h (vfork_save): Add ctty, sid, pgid, exitval fields.
(vfork_save::restore_pid): New method.
(vfork_save::restore_exit): New method.
* fork.cc (vfork): Save ctty, sid, pgid and restore them when returning to
"parent".  Use exitval field if exiting but never created a new process.
* syscalls.cc (setsid): Detect when in "vfork" and force an actual fork so that
pid will be allocated (UGLY!).
(getsid): New function.
* dcrt0.cc (do_exit): Use vfork_save::restore_exit method for returning from a
vfork.
* spawn.cc (spawnve): Use vfork_save::{restore_pid,restore_exit} methods for
returning from vfork.
* cygwin.din: Export getsid.
* include/cygwin/version.h: Bump api minor number.
* malloc.cc: #ifdef sYSTRIm for when MORECORE_CANNOT_TRIM is true.
@
text
@d2513 1
d2515 1
d2522 1
d2524 1
@


1.2
log
@* malloc.cc: Update to 2.7.2.
* malloc_wrapper.cc (malloc_init): Call user level mallocs to determine if the
malloc has been wrapped.
@
text
@d3297 1
a3297 1

d3363 1
@


1.1
log
@* Makefile.in: Add support for new malloc.o and renamed malloc_wrapper.o.  Use
-fomit-frame-pointer for malloc.o compilation.
* malloc_wrapper.cc: New file.  Rename from malloc.cc.  Add support for more
malloc functions.  Eliminate export_* calls.  Just use straight malloc names.
Remove unused argument from malloc lock functions.
* cygwin.din: Just export straight malloc names.  Add malloc_stats,
malloc_trim, malloc_usable_size, mallopt, memalign, valloc.
* dcrt0.cc (__cygwin_user): Eliminate export_* malloc entries.
* fork.cc (fork_parent): Remove unused argument from malloc_lock argument.
* malloc.cc: New file.  Doug Lea's malloc v2.7.1.
* cygmalloc.h: New file.
* include/cygwin/version.h: Bump API_MINOR.
* sync.h (muto::acquire): Use appropriate number for regparm attribute.
(muto::reset): Ditto.
(muto::release): Ditto.
@
text
@d8 1
a8 1
* VERSION 2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)
d1570 2
a1571 2
#define MALLOC_PREACTION   __malloc_lock ()
#define MALLOC_POSTACTION  __malloc_unlock ()
d2415 2
a2416 2
  /* Bitmap of bins */
  unsigned int     binmap[BINMAPSIZE];
d5436 3
@


1.1.2.1
log
@Merged changes from HEAD
@
text
@@


1.1.2.2
log
@Merged changes from HEAD
@
text
@d8 1
a8 1
* VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
d1570 2
a1571 2
#define MALLOC_PREACTION   (0)
#define MALLOC_POSTACTION  (0)
d2415 2
a2416 2
  /* Bitmap of bins. Trailing zero map handles cases of largest binned size */
  unsigned int     binmap[BINMAPSIZE+1];
d3297 1
a3297 1
#ifndef MORECORE_CANNOT_TRIM
a3362 1
#endif /*MORECORE_CANNOT_TRIM*/
a5435 3
    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
      * Fix malloc_state bitmap array misdeclaration

@


1.1.2.3
log
@Merged changes from HEAD
@
text
@a2512 1
#ifndef MORECORE_CANNOT_TRIM
a2513 1
#endif
a2519 1
#ifndef MORECORE_CANNOT_TRIM
a2520 1
#endif
@


