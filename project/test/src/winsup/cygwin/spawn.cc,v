head	1.363;
access;
symbols
	cygwin-1_7_35-release:1.363
	cygwin-1_7_34-release:1.360
	cygwin-1_7_33-release:1.353.2.3
	cygwin-1_7_32-release:1.353.2.2
	cygwin-1_7_31-release:1.353.2.2
	cygwin-1_7_30-release:1.353.2.1
	cygwin-1_7_29-release:1.353
	cygwin-1_7_29-release-branchpoint:1.353.0.2
	cygwin-pre-user-db:1.353
	cygwin-1_7_28-release:1.353
	cygwin-1_7_27-release:1.353
	cygwin-1_7_26-release:1.353
	cygwin-1_7_25-release:1.352
	cygwin-1_7_24-release:1.350
	cygwin-1_7_23-release:1.350
	cygwin-1_7_22-release:1.349
	cygwin-1_7_21-release:1.347
	cygwin-1_7_20-release:1.345
	cygwin-1_7_19-release:1.345
	cygwin-64bit-postmerge:1.342
	cygwin-64bit-premerge-branch:1.341.0.2
	cygwin-64bit-premerge:1.341
	cygwin-1_7_18-release:1.341
	post-ptmalloc3:1.334.2.7
	pre-ptmalloc3:1.334.2.7
	cygwin-1_7_17-release:1.336
	cygwin-64bit-branch:1.334.0.2
	cygwin-1_7_16-release:1.333
	cygwin-1_7_15-release:1.332
	cygwin-1_7_14_2-release:1.330
	cygwin-1_7_14-release:1.330
	cygwin-1_7_12-release:1.329
	cygwin-1_7_11-release:1.324
	cygwin-1_7_10-release:1.322
	signal-rewrite:1.305.0.2
	pre-notty:1.303
	cygwin-1_7_9-release:1.301
	cv-post-1_7_9:1.301.0.2
	cygwin-1_7_8-release:1.301
	cygwin-1_7_7-release:1.294
	cygwin-1_7_5-release:1.289
	cygwin-1_7_4-release:1.289
	cygwin-1_7_3-release:1.289
	cygwin-1_7_2-release:1.288
	fifo_doover3:1.287.0.2
	cygwin-1_7_1-release:1.285
	prefifo:1.274
	cv-branch-2:1.272.0.2
	pre-ripout-set_console_state_for_spawn:1.260
	EOL_registry_mounts:1.257
	preoverlapped:1.244
	drop_9x_support_start:1.240
	cr-0x5f1:1.233.0.2
	cv-branch:1.232.0.2
	pre-ptymaster-archetype:1.232
	cr-0x3b58:1.209.0.4
	cr-0x5ef:1.209.0.2
	after-mmap-privanon-noreserve:1.198
	after-mmap-revamp:1.198
	before-mmap-revamp:1.198
	cgf-more-exit-sync:1.193
	post_wait_sig_exit:1.193
	pre_wait_sig_exit:1.186
	reparent-point:1.153
	noreparent:1.153.0.2
	cr-0x5e6:1.148.0.2
	cr-0x9e:1.141.0.6
	cr-0x9d:1.141.0.4
	cgf-deleteme:1.141.0.2
	pre-sigrewrite:1.138
	corinna-01:1.137
	cr-0x9c:1.126.2.3.0.2
	cr-0x9b:1.126.0.2
	cr-0x99:1.125
	Z-emcb-cygwin_daemon:1.125.0.2
	w32api-2_2:1.119
	mingw-runtime-2_4:1.119
	pre-cgf-merge:1.130
	cgf-dev-branch:1.118.0.12
	predaemon:1.98
	cygwin_daemon_merge_HEAD:1.98
	pregp02r1:1.98.0.2
	cygnus_cvs_20020108_pre:1.94
	Z-cygwin_daemon_merge-new_HEAD:1.114
	Z-cygwin_daemon_merge_HEAD:1.114
	cygwin_daemon:1.89.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.363
date	2015.02.16.11.49.33;	author corinna;	state Exp;
branches;
next	1.362;

1.362
date	2015.02.15.08.59.55;	author corinna;	state Exp;
branches;
next	1.361;

1.361
date	2015.02.11.13.15.58;	author corinna;	state Exp;
branches;
next	1.360;

1.360
date	2014.12.02.15.41.13;	author corinna;	state Exp;
branches;
next	1.359;

1.359
date	2014.12.02.15.39.57;	author corinna;	state Exp;
branches;
next	1.358;

1.358
date	2014.12.02.10.16.03;	author corinna;	state Exp;
branches;
next	1.357;

1.357
date	2014.12.02.10.09.13;	author corinna;	state Exp;
branches;
next	1.356;

1.356
date	2014.08.22.09.21.32;	author corinna;	state Exp;
branches;
next	1.355;

1.355
date	2014.06.23.19.05.14;	author corinna;	state Exp;
branches;
next	1.354;

1.354
date	2014.05.03.19.58.20;	author cgf;	state Exp;
branches;
next	1.353;

1.353
date	2013.11.24.12.13.35;	author corinna;	state Exp;
branches
	1.353.2.1;
next	1.352;

1.352
date	2013.08.23.18.19.46;	author cgf;	state Exp;
branches;
next	1.351;

1.351
date	2013.08.23.09.29.25;	author corinna;	state Exp;
branches;
next	1.350;

1.350
date	2013.07.26.17.27.59;	author cgf;	state Exp;
branches;
next	1.349;

1.349
date	2013.07.19.22.44.01;	author cgf;	state Exp;
branches;
next	1.348;

1.348
date	2013.07.19.17.28.34;	author cgf;	state Exp;
branches;
next	1.347;

1.347
date	2013.06.19.16.00.43;	author cgf;	state Exp;
branches;
next	1.346;

1.346
date	2013.06.19.14.39.00;	author cgf;	state Exp;
branches;
next	1.345;

1.345
date	2013.05.03.19.39.01;	author cgf;	state Exp;
branches;
next	1.344;

1.344
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.343;

1.343
date	2013.04.30.23.51.08;	author cgf;	state Exp;
branches;
next	1.342;

1.342
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.341;

1.341
date	2013.03.31.12.35.44;	author cgf;	state Exp;
branches;
next	1.340;

1.340
date	2013.03.31.11.05.35;	author cgf;	state Exp;
branches;
next	1.339;

1.339
date	2013.03.09.00.11.31;	author cgf;	state Exp;
branches;
next	1.338;

1.338
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.337;

1.337
date	2012.11.30.07.11.19;	author cgf;	state Exp;
branches;
next	1.336;

1.336
date	2012.09.14.03.32.51;	author cgf;	state Exp;
branches;
next	1.335;

1.335
date	2012.08.16.23.34.45;	author cgf;	state Exp;
branches;
next	1.334;

1.334
date	2012.08.03.14.48.59;	author cgf;	state Exp;
branches
	1.334.2.1;
next	1.333;

1.333
date	2012.05.14.22.42.56;	author cgf;	state Exp;
branches;
next	1.332;

1.332
date	2012.05.08.15.06.43;	author cgf;	state Exp;
branches;
next	1.331;

1.331
date	2012.05.07.15.05.56;	author cgf;	state Exp;
branches;
next	1.330;

1.330
date	2012.04.15.17.51.22;	author cgf;	state Exp;
branches;
next	1.329;

1.329
date	2012.03.21.15.54.50;	author cgf;	state Exp;
branches;
next	1.328;

1.328
date	2012.03.21.05.23.13;	author cgf;	state Exp;
branches;
next	1.327;

1.327
date	2012.03.20.15.07.30;	author cgf;	state Exp;
branches;
next	1.326;

1.326
date	2012.03.16.20.20.29;	author cgf;	state Exp;
branches;
next	1.325;

1.325
date	2012.03.07.17.09.37;	author cgf;	state Exp;
branches;
next	1.324;

1.324
date	2012.02.17.14.26.17;	author corinna;	state Exp;
branches;
next	1.323;

1.323
date	2012.02.07.17.15.06;	author corinna;	state Exp;
branches;
next	1.322;

1.322
date	2012.01.11.22.38.52;	author cgf;	state Exp;
branches;
next	1.321;

1.321
date	2012.01.11.19.07.10;	author cgf;	state Exp;
branches;
next	1.320;

1.320
date	2012.01.09.17.03.38;	author corinna;	state Exp;
branches;
next	1.319;

1.319
date	2012.01.08.06.24.17;	author cgf;	state Exp;
branches;
next	1.318;

1.318
date	2011.12.22.14.33.08;	author corinna;	state Exp;
branches;
next	1.317;

1.317
date	2011.12.07.10.48.17;	author corinna;	state Exp;
branches;
next	1.316;

1.316
date	2011.12.03.21.43.27;	author cgf;	state Exp;
branches;
next	1.315;

1.315
date	2011.11.24.21.36.52;	author cgf;	state Exp;
branches;
next	1.314;

1.314
date	2011.11.24.02.17.54;	author cgf;	state Exp;
branches;
next	1.313;

1.313
date	2011.11.23.21.58.43;	author cgf;	state Exp;
branches;
next	1.312;

1.312
date	2011.11.16.04.09.33;	author cgf;	state Exp;
branches;
next	1.311;

1.311
date	2011.11.14.01.45.42;	author cgf;	state Exp;
branches;
next	1.310;

1.310
date	2011.11.14.01.29.49;	author cgf;	state Exp;
branches;
next	1.309;

1.309
date	2011.10.26.19.42.39;	author cgf;	state Exp;
branches;
next	1.308;

1.308
date	2011.10.25.16.35.58;	author corinna;	state Exp;
branches;
next	1.307;

1.307
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.306;

1.306
date	2011.10.07.13.52.20;	author cgf;	state Exp;
branches;
next	1.305;

1.305
date	2011.07.04.15.25.36;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2011.06.09.21.20.27;	author cgf;	state Exp;
branches;
next	1.303;

1.303
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.302;

1.302
date	2011.05.30.06.52.12;	author cgf;	state Exp;
branches;
next	1.301;

1.301
date	2011.02.15.18.11.50;	author corinna;	state Exp;
branches;
next	1.300;

1.300
date	2011.02.15.15.25.59;	author corinna;	state Exp;
branches;
next	1.299;

1.299
date	2011.01.20.11.09.21;	author corinna;	state Exp;
branches;
next	1.298;

1.298
date	2011.01.19.14.59.10;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2011.01.19.10.28.39;	author corinna;	state Exp;
branches;
next	1.296;

1.296
date	2011.01.19.09.15.17;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2010.09.20.22.28.57;	author cgf;	state Exp;
branches;
next	1.294;

1.294
date	2010.08.13.11.51.54;	author corinna;	state Exp;
branches;
next	1.293;

1.293
date	2010.06.29.10.37.23;	author corinna;	state Exp;
branches;
next	1.292;

1.292
date	2010.06.29.10.28.40;	author corinna;	state Exp;
branches;
next	1.291;

1.291
date	2010.05.18.14.30.51;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2010.04.27.23.06.48;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2010.03.29.17.15.51;	author corinna;	state Exp;
branches;
next	1.288;

1.288
date	2010.01.25.11.21.56;	author corinna;	state Exp;
branches;
next	1.287;

1.287
date	2009.12.21.15.16.28;	author corinna;	state Exp;
branches;
next	1.286;

1.286
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.285;

1.285
date	2009.11.17.10.43.01;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2009.11.05.09.59.18;	author corinna;	state Exp;
branches;
next	1.283;

1.283
date	2009.10.19.08.33.00;	author corinna;	state Exp;
branches;
next	1.282;

1.282
date	2009.10.13.10.23.31;	author corinna;	state Exp;
branches;
next	1.281;

1.281
date	2009.09.25.13.44.45;	author ericb;	state Exp;
branches;
next	1.280;

1.280
date	2009.08.10.18.36.28;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2009.08.01.19.52.46;	author cgf;	state Exp;
branches;
next	1.278;

1.278
date	2009.08.01.17.55.58;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2009.08.01.03.36.44;	author cgf;	state Exp;
branches;
next	1.276;

1.276
date	2009.08.01.03.27.51;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2009.07.30.08.56.57;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2009.07.04.23.51.10;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2009.06.22.15.40.59;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2009.04.05.04.23.50;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2009.02.24.02.11.14;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2009.01.09.05.18.01;	author cgf;	state Exp;
branches;
next	1.269;

1.269
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.268;

1.268
date	2008.11.26.17.21.04;	author cgf;	state Exp;
branches;
next	1.267;

1.267
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2008.07.31.14.41.19;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2008.07.23.10.17.04;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2008.07.22.16.59.59;	author corinna;	state Exp;
branches;
next	1.263;

1.263
date	2008.07.14.20.22.03;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2008.06.17.15.38.17;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2008.06.12.15.57.23;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2008.04.30.09.51.38;	author corinna;	state Exp;
branches;
next	1.259;

1.259
date	2008.04.26.18.01.42;	author corinna;	state Exp;
branches;
next	1.258;

1.258
date	2008.04.07.18.45.58;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2008.03.27.01.50.40;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2008.03.12.12.41.49;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2008.03.11.13.26.40;	author corinna;	state Exp;
branches;
next	1.254;

1.254
date	2008.03.11.12.34.08;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2008.03.05.18.31.09;	author corinna;	state Exp;
branches;
next	1.251;

1.251
date	2008.02.01.12.37.51;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2007.12.14.11.32.40;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2007.08.17.20.22.24;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2007.08.17.19.58.57;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2007.08.16.15.07.41;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2007.07.19.08.36.32;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2007.03.28.14.34.24;	author cgf;	state Exp;
branches;
next	1.243;

1.243
date	2007.02.23.12.01.52;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2007.02.23.10.51.59;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2007.01.18.21.28.36;	author corinna;	state Exp;
branches;
next	1.239;

1.239
date	2007.01.03.11.14.53;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2007.01.01.19.37.19;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.236;

1.236
date	2006.12.05.10.59.21;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2006.11.30.10.17.24;	author corinna;	state Exp;
branches;
next	1.234;

1.234
date	2006.08.09.15.04.32;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches
	1.233.2.1;
next	1.232;

1.232
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches
	1.232.2.1;
next	1.231;

1.231
date	2006.05.22.04.50.54;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2006.05.21.05.25.49;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2006.04.13.16.11.06;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2006.04.13.01.37.00;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2006.04.12.15.53.22;	author cgf;	state Exp;
branches;
next	1.226;

1.226
date	2006.04.03.17.21.42;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2006.03.27.03.52.24;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2006.03.22.03.20.28;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2006.03.21.01.37.25;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2006.03.20.18.01.17;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2006.03.18.19.17.21;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2006.03.13.21.10.14;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2006.02.20.16.26.16;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2006.02.20.16.15.51;	author cgf;	state Exp;
branches;
next	1.217;

1.217
date	2006.02.15.22.11.13;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2006.02.03.21.33.09;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2006.02.01.08.44.15;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2006.01.31.21.49.39;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2006.01.31.21.23.57;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2006.01.31.21.09.43;	author corinna;	state Exp;
branches;
next	1.211;

1.211
date	2006.01.27.06.08.05;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2006.01.27.06.06.06;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2006.01.12.15.53.51;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2006.01.12.05.03.15;	author cgf;	state Exp;
branches;
next	1.207;

1.207
date	2006.01.10.02.39.22;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2006.01.07.17.57.26;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2006.01.05.16.23.19;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2006.01.04.03.43.55;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2005.12.29.20.46.34;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2005.12.21.17.20.43;	author cgf;	state Exp;
branches;
next	1.201;

1.201
date	2005.12.21.17.14.34;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2005.12.19.19.04.14;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2005.12.19.04.34.13;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2005.10.29.20.33.59;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2005.10.24.15.17.54;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2005.10.19.22.25.46;	author cgf;	state Exp;
branches;
next	1.195;

1.195
date	2005.10.18.15.13.13;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.193;

1.193
date	2005.09.20.18.32.23;	author cgf;	state Exp;
branches;
next	1.192;

1.192
date	2005.09.16.20.12.12;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2005.09.16.19.58.12;	author cgf;	state Exp;
branches;
next	1.190;

1.190
date	2005.09.16.01.47.09;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2005.09.15.00.31.42;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2005.09.15.00.02.57;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2005.09.14.23.03.44;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2005.09.10.01.37.20;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2005.09.08.00.57.12;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2005.09.07.03.10.17;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2005.09.05.17.30.04;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2005.08.24.18.26.14;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2005.08.11.16.13.30;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2005.07.17.00.51.03;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2005.07.16.22.01.50;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2005.07.05.02.05.07;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2005.06.18.01.36.17;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2005.06.18.01.27.06;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2005.06.02.02.36.50;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2005.06.01.03.46.56;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2005.05.22.03.54.28;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2005.05.13.15.46.07;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2005.04.03.13.06.43;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2005.04.03.08.45.20;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2005.03.02.15.32.34;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2005.02.11.15.24.15;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2005.01.25.22.45.09;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2005.01.22.21.47.04;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2005.01.16.17.00.27;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2005.01.11.15.31.04;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2004.12.28.01.27.26;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2004.12.24.18.31.23;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2004.12.23.14.57.08;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2004.12.21.18.45.01;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2004.12.06.00.29.41;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2004.12.05.19.41.24;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2004.12.03.04.46.00;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2004.11.26.04.15.08;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2004.10.07.16.49.30;	author cgf;	state Exp;
branches
	1.153.2.1;
next	1.152;

1.152
date	2004.09.12.03.47.57;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2004.09.03.01.53.12;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2004.07.08.09.18.29;	author corinna;	state Exp;
branches;
next	1.149;

1.149
date	2004.06.02.21.20.54;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2004.04.10.13.45.10;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2004.03.14.06.34.05;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2004.02.13.19.34.32;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2004.02.09.04.04.24;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2004.02.06.10.37.37;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2004.01.23.23.05.33;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2003.12.08.00.21.17;	author cgf;	state Exp;
branches
	1.141.6.1;
next	1.140;

1.140
date	2003.12.07.22.37.12;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.137;

1.137
date	2003.09.27.01.58.23;	author phumblet;	state Exp;
branches;
next	1.136;

1.136
date	2003.09.26.08.45.24;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2003.09.26.03.20.30;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2003.09.26.03.09.42;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2003.09.26.02.23.34;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2003.09.25.13.49.21;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2003.09.20.19.51.48;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2003.09.20.00.43.33;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2003.09.20.00.31.13;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2003.09.16.09.24.52;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2003.09.10.02.12.26;	author phumblet;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2003.06.09.13.29.12;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2003.06.03.02.32.49;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2003.05.19.01.43.31;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2003.02.13.02.52.41;	author cgf;	state Exp;
branches
	1.120.2.1;
next	1.119;

1.119
date	2003.01.25.10.36.46;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2002.10.17.17.45.09;	author cgf;	state Exp;
branches
	1.118.12.1;
next	1.117;

1.117
date	2002.10.14.03.51.44;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2002.10.13.18.16.33;	author cgf;	state Exp;
branches
	1.116.4.1;
next	1.115;

1.115
date	2002.10.09.04.08.05;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2002.09.19.15.12.48;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2002.08.18.05.49.25;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2002.08.06.05.48.33;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2002.07.13.20.00.26;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2002.06.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2002.06.16.04.25.54;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2002.06.14.21.46.18;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2002.06.14.18.01.20;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2002.06.12.05.13.54;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2002.06.11.16.06.15;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2002.06.11.02.22.02;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2002.06.11.02.08.00;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2002.05.29.15.04.27;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2002.05.06.10.05.46;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2002.03.22.03.24.30;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2002.02.19.05.58.44;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2002.01.13.20.03.03;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2002.01.10.03.21.27;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2001.11.05.06.09.08;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2001.10.31.00.55.32;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2001.10.05.01.39.08;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2001.10.04.02.34.20;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2001.10.01.04.10.07;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2001.09.14.00.49.00;	author cgf;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2001.09.11.20.01.01;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2001.08.22.17.50.22;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2001.08.14.14.57.44;	author duda;	state Exp;
branches;
next	1.84;

1.84
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2001.07.18.17.05.34;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2001.07.17.03.41.52;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.26.21.03.08;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2001.06.24.21.57.50;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2001.05.20.08.10.47;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2001.04.30.21.19.42;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2001.04.18.21.10.13;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2001.04.17.03.52.08;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.03.18.20.58.18;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.03.12.14.49.29;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.02.22.14.51.16;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2001.02.21.22.59.11;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2001.02.21.21.49.37;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2000.11.20.22.10.13;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2000.11.20.19.35.44;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2000.11.15.21.04.02;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2000.11.15.09.01.33;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2000.11.15.06.27.48;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2000.11.15.00.13.09;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2000.11.08.20.36.36;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2000.11.06.06.36.32;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2000.11.04.05.54.57;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2000.10.26.10.13.41;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2000.10.25.03.54.50;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2000.10.24.02.25.27;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2000.10.21.05.53.43;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2000.10.21.04.53.49;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2000.10.20.04.20.21;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2000.10.14.05.52.38;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.12.04.38.29;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2000.10.09.02.53.44;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.30.01.56.40;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.27.05.12.09;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2000.09.26.00.52.21;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2000.09.25.16.36.12;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.19.13.48.52;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2000.09.13.19.57.00;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.06.21.03.10;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.05.03.16.28;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.01.20.54.22;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.26.01.36.20;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.24.04.07.50;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.23.14.56.28;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.23.14.53.24;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.09.02.33.47;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.03.03.02.41;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.29.16.24.40;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.27.17.30.48;	author dj;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.21.19.34.35;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.19.20.27.27;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.19.20.14.24;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.17.19.18.21;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.16.20.06.11;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.16.06.31.06;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.15.02.48.11;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.09.21.02.43;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.02.10.17.44;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.01.17.30.35;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.24.17.37.52;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.19.17.36.30;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.16.19.36.07;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.30.00.38.51;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.05.13.32;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.19.29.15;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.23.04.07.13;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.353.2.1
date	2014.05.19.11.47.54;	author corinna;	state Exp;
branches;
next	1.353.2.2;

1.353.2.2
date	2014.07.15.14.34.38;	author corinna;	state Exp;
branches;
next	1.353.2.3;

1.353.2.3
date	2014.11.13.12.53.06;	author corinna;	state Exp;
branches;
next	;

1.334.2.1
date	2012.10.16.15.18.39;	author corinna;	state Exp;
branches;
next	1.334.2.2;

1.334.2.2
date	2012.12.06.10.59.04;	author corinna;	state Exp;
branches;
next	1.334.2.3;

1.334.2.3
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.334.2.4;

1.334.2.4
date	2012.12.13.12.55.12;	author corinna;	state Exp;
branches;
next	1.334.2.5;

1.334.2.5
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.334.2.6;

1.334.2.6
date	2013.02.09.20.38.01;	author corinna;	state Exp;
branches;
next	1.334.2.7;

1.334.2.7
date	2013.02.12.11.24.35;	author corinna;	state Exp;
branches;
next	1.334.2.8;

1.334.2.8
date	2013.03.09.13.07.58;	author corinna;	state Exp;
branches;
next	1.334.2.9;

1.334.2.9
date	2013.03.14.12.09.52;	author corinna;	state Exp;
branches;
next	1.334.2.10;

1.334.2.10
date	2013.04.08.09.32.31;	author corinna;	state Exp;
branches;
next	;

1.233.2.1
date	2006.12.05.11.34.01;	author corinna;	state Exp;
branches;
next	1.233.2.2;

1.233.2.2
date	2007.01.12.19.44.19;	author corinna;	state Exp;
branches;
next	1.233.2.3;

1.233.2.3
date	2007.01.15.11.56.07;	author corinna;	state Exp;
branches;
next	1.233.2.4;

1.233.2.4
date	2007.11.12.15.30.20;	author corinna;	state Exp;
branches;
next	1.233.2.5;

1.233.2.5
date	2007.12.14.11.32.50;	author corinna;	state Exp;
branches;
next	1.233.2.6;

1.233.2.6
date	2008.03.05.18.17.39;	author corinna;	state Exp;
branches;
next	;

1.232.2.1
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	;

1.153.2.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	1.153.2.2;

1.153.2.2
date	2004.11.18.00.48.41;	author cgf;	state Exp;
branches;
next	1.153.2.3;

1.153.2.3
date	2004.11.20.05.28.31;	author cgf;	state Exp;
branches;
next	1.153.2.4;

1.153.2.4
date	2004.11.20.18.35.11;	author cgf;	state Exp;
branches;
next	1.153.2.5;

1.153.2.5
date	2004.11.21.04.39.13;	author cgf;	state Exp;
branches;
next	1.153.2.6;

1.153.2.6
date	2004.11.24.05.48.31;	author cgf;	state Exp;
branches;
next	;

1.141.6.1
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	;

1.126.2.1
date	2003.09.20.02.48.13;	author cgf;	state Exp;
branches;
next	1.126.2.2;

1.126.2.2
date	2003.09.20.03.08.09;	author cgf;	state Exp;
branches;
next	1.126.2.3;

1.126.2.3
date	2003.09.20.19.53.38;	author cgf;	state Exp;
branches;
next	;

1.120.2.1
date	2003.03.16.23.38.19;	author cgf;	state Exp;
branches;
next	;

1.118.12.1
date	2003.01.25.16.37.00;	author cgf;	state Exp;
branches;
next	1.118.12.2;

1.118.12.2
date	2003.02.13.03.14.06;	author cgf;	state Exp;
branches;
next	1.118.12.3;

1.118.12.3
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.118.12.4;

1.118.12.4
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.118.12.5;

1.118.12.5
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.118.12.6;

1.118.12.6
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.118.12.7;

1.118.12.7
date	2003.09.11.04.47.22;	author cgf;	state Exp;
branches;
next	;

1.116.4.1
date	2002.10.14.03.31.59;	author cgf;	state Exp;
branches;
next	;

1.89.2.1
date	2001.10.02.12.09.56;	author rbcollins;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.89.2.3;

1.89.2.3
date	2002.01.15.12.52.52;	author rbcollins;	state Exp;
branches;
next	1.89.2.4;

1.89.2.4
date	2002.02.28.12.53.27;	author rbcollins;	state Exp;
branches;
next	1.89.2.5;

1.89.2.5
date	2002.06.13.14.34.12;	author rbcollins;	state Exp;
branches;
next	1.89.2.6;

1.89.2.6
date	2002.06.15.10.26.31;	author rbcollins;	state Exp;
branches;
next	1.89.2.7;

1.89.2.7
date	2002.06.18.00.17.07;	author scottc;	state Exp;
branches;
next	1.89.2.8;

1.89.2.8
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.89.2.9;

1.89.2.9
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	1.89.2.10;

1.89.2.10
date	2002.08.18.12.09.27;	author scottc;	state Exp;
branches;
next	1.89.2.11;

1.89.2.11
date	2002.09.19.21.51.22;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.363
log
@	* spawn.cc (find_exec): Extend preceeding comment to explain more
	detailed what's going on in this function.  Overwrite potential symlink
	target with original path.
@
text
@/* spawn.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <unistd.h>
#include <process.h>
#include <sys/wait.h>
#include <wchar.h>
#include <ctype.h>
#include <sys/cygwin.h>
#include "cygerrno.h"
#include "security.h"
#include "sigproc.h"
#include "pinfo.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "child_info.h"
#include "environ.h"
#include "cygtls.h"
#include "tls_pbuf.h"
#include "winf.h"
#include "ntdll.h"

static const suffix_info exe_suffixes[] =
{
  suffix_info ("", 1),
  suffix_info (".exe", 1),
  suffix_info (".com"),
  suffix_info (NULL)
};

/* Add .exe to PROG if not already present and see if that exists.
   If not, return PROG (converted from posix to win32 rules if necessary).
   The result is always BUF.

   Returns (possibly NULL) suffix */

static const char *
perhaps_suffix (const char *prog, path_conv& buf, int& err, unsigned opt)
{
  const char *ext;

  err = 0;
  debug_printf ("prog '%s'", prog);
  buf.check (prog, PC_SYM_FOLLOW | PC_NULLEMPTY | PC_POSIX,
	     (opt & FE_DLL) ? stat_suffixes : exe_suffixes);

  if (buf.isdir ())
    {
      err = EACCES;
      ext = NULL;
    }
  else if (!buf.exists ())
    {
      err = ENOENT;
      ext = NULL;
    }
  else if (buf.known_suffix ())
    ext = buf.get_win32 () + (buf.known_suffix () - buf.get_win32 ());
  else
    ext = strchr (buf.get_win32 (), '\0');

  debug_printf ("buf %s, suffix found '%s'", (char *) buf.get_win32 (), ext);
  return ext;
}

/* Find an executable name, possibly by appending known executable suffixes
   to it.  The path_conv struct 'buf' is filled and contains both, win32 and
   posix path of the target file.  Any found suffix is returned in known_suffix.
   Eventually the posix path in buf is overwritten with the exact path as it
   gets constructed for the path search.  The reason is that the path is used
   to create argv[0] in av::setup, and this requires that the filename stays
   intact, instead of being resolved if the file is a symlink.

   If the file is not found and !FE_NNF then the POSIX version of name is
   placed in buf and returned.  Otherwise the contents of buf is undefined
   and NULL is returned.  */
const char * __reg3
find_exec (const char *name, path_conv& buf, const char *search,
	   unsigned opt, const char **known_suffix)
{
  const char *suffix = "";
  const char *retval = NULL;
  tmp_pathbuf tp;
  char *tmp_path;
  char *tmp = tp.c_get ();
  bool has_slash = !!strpbrk (name, "/\\");
  int err = 0;

  debug_printf ("find_exec (%s)", name);

  /* Check to see if file can be opened as is first. */
  if ((has_slash || opt & FE_CWD)
      && (suffix = perhaps_suffix (name, buf, err, opt)) != NULL)
    {
      if (!has_slash)
	{
	  /* Overwrite potential symlink target with original path.
	     See comment preceeding this method. */
	  stpcpy (stpcpy (tmp, "./"), name);
	  buf.set_posix (tmp);
	}
      retval = buf.get_posix ();
      goto out;
    }

  const char *path;
  /* If it starts with a slash, it's a PATH-like pathlist.  Otherwise it's
     the name of an environment variable. */
  if (strchr (search, '/'))
    *stpncpy (tmp, search, NT_MAX_PATH - 1) = '\0';
  else if (has_slash || isdrive (name) || !(path = getenv (search)) || !*path)
    goto errout;
  else
    *stpncpy (tmp, path, NT_MAX_PATH - 1) = '\0';

  path = tmp;
  debug_printf ("searchpath %s", path);

  tmp_path = tp.c_get ();
  do
    {
      char *eotmp = strccpy (tmp_path, &path, ':');
      /* An empty path or '.' means the current directory, but we've
	 already tried that.  */
      if ((opt & FE_CWD) && (tmp_path[0] == '\0'
			     || (tmp_path[0] == '.' && tmp_path[1] == '\0')))
	continue;

      *eotmp++ = '/';
      stpcpy (eotmp, name);

      debug_printf ("trying %s", tmp_path);

      int err1;

      if ((suffix = perhaps_suffix (tmp_path, buf, err1, opt)) != NULL)
	{
	  if (buf.has_acls () && check_file_access (buf, X_OK, true))
	    continue;
	  /* Overwrite potential symlink target with original path.
	     See comment preceeding this method. */
	  buf.set_posix (tmp_path);
	  retval = buf.get_posix ();
	  goto out;
	}

    }
  while (*path && *++path);

 errout:
  /* Couldn't find anything in the given path.
     Take the appropriate action based on FE_NNF. */
  if (!(opt & FE_NNF))
    {
      buf.check (name, PC_SYM_FOLLOW | PC_POSIX);
      retval = buf.get_posix ();
    }

 out:
  debug_printf ("%s = find_exec (%s)", (char *) buf.get_posix (), name);
  if (known_suffix)
    *known_suffix = suffix ?: strchr (buf.get_win32 (), '\0');
  if (!retval && err)
    set_errno (err);
  return retval;
}

/* Utility for child_info_spawn::worker.  */

static HANDLE
handle (int fd, bool writing)
{
  HANDLE h;
  cygheap_fdget cfd (fd);

  if (cfd < 0)
    h = INVALID_HANDLE_VALUE;
  else if (cfd->close_on_exec ())
    h = INVALID_HANDLE_VALUE;
  else if (!writing)
    h = cfd->get_handle ();
  else
    h = cfd->get_output_handle ();

  return h;
}

int
iscmd (const char *argv0, const char *what)
{
  int n;
  n = strlen (argv0) - strlen (what);
  if (n >= 2 && argv0[1] != ':')
    return 0;
  return n >= 0 && strcasematch (argv0 + n, what) &&
	 (n == 0 || isdirsep (argv0[n - 1]));
}

#define ILLEGAL_SIG_FUNC_PTR ((_sig_func_ptr) (-2))
struct system_call_handle
{
  _sig_func_ptr oldint;
  _sig_func_ptr oldquit;
  sigset_t oldmask;
  bool is_system_call ()
  {
    return oldint != ILLEGAL_SIG_FUNC_PTR;
  }
  system_call_handle (bool issystem)
  {
    if (!issystem)
      oldint = ILLEGAL_SIG_FUNC_PTR;
    else
      {
	sig_send (NULL, __SIGHOLD);
	oldint = NULL;
      }
  }
  void arm()
  {
    if (is_system_call ())
      {
	sigset_t child_block;
	oldint = signal (SIGINT,  SIG_IGN);
	oldquit = signal (SIGQUIT, SIG_IGN);
	sigemptyset (&child_block);
	sigaddset (&child_block, SIGCHLD);
	sigprocmask (SIG_BLOCK, &child_block, &oldmask);
	sig_send (NULL, __SIGNOHOLD);
      }
  }
  ~system_call_handle ()
  {
    if (is_system_call ())
      {
	signal (SIGINT, oldint);
	signal (SIGQUIT, oldquit);
	sigprocmask (SIG_SETMASK, &oldmask, NULL);
      }
  }
# undef cleanup
};

child_info_spawn NO_COPY ch_spawn;

int
child_info_spawn::worker (const char *prog_arg, const char *const *argv,
			  const char *const envp[], int mode,
			  int in__stdin, int in__stdout)
{
  bool rc;
  pid_t cygpid;
  int res = -1;

  /* Check if we have been called from exec{lv}p or spawn{lv}p and mask
     mode to keep only the spawn mode. */
  bool p_type_exec = !!(mode & _P_PATH_TYPE_EXEC);
  mode = _P_MODE (mode);

  if (prog_arg == NULL)
    {
      syscall_printf ("prog_arg is NULL");
      set_errno (EFAULT);	/* As on Linux. */
      return -1;
    }
  if (!prog_arg[0])
    {
      syscall_printf ("prog_arg is empty");
      set_errno (ENOENT);	/* Per POSIX */
      return -1;
    }

  syscall_printf ("mode = %d, prog_arg = %.9500s", mode, prog_arg);

  /* FIXME: This is no error condition on Linux. */
  if (argv == NULL)
    {
      syscall_printf ("argv is NULL");
      set_errno (EINVAL);
      return -1;
    }

  av newargv;
  linebuf cmd;
  PWCHAR envblock = NULL;
  path_conv real_path;
  bool reset_sendsig = false;

  tmp_pathbuf tp;
  PWCHAR runpath = tp.w_get ();
  int c_flags;

  bool null_app_name = false;
  STARTUPINFOW si = {};
  int looped = 0;

  system_call_handle system_call (mode == _P_SYSTEM);

  __try
    {
      child_info_types chtype;
      if (mode == _P_OVERLAY)
	chtype = _CH_EXEC;
      else
	chtype = _CH_SPAWN;

      moreinfo = cygheap_exec_info::alloc ();

      /* CreateProcess takes one long string that is the command line (sigh).
	 We need to quote any argument that has whitespace or embedded "'s.  */

      int ac;
      for (ac = 0; argv[ac]; ac++)
	/* nothing */;

      int err;
      const char *ext;
      if ((ext = perhaps_suffix (prog_arg, real_path, err, FE_NADA)) == NULL)
	{
	  set_errno (err);
	  res = -1;
	  __leave;
	}

      res = newargv.setup (prog_arg, real_path, ext, ac, argv, p_type_exec);

      if (res)
	__leave;

      if (!real_path.iscygexec () && ::cygheap->cwd.get_error ())
	{
	  small_printf ("Error: Current working directory %s.\n"
			"Can't start native Windows application from here.\n\n",
			::cygheap->cwd.get_error_desc ());
	  set_errno (::cygheap->cwd.get_error ());
	  res = -1;
	  __leave;
	}

      if (ac == 3 && argv[1][0] == '/' && tolower (argv[1][1]) == 'c' &&
	  (iscmd (argv[0], "command.com") || iscmd (argv[0], "cmd.exe")))
	{
	  real_path.check (prog_arg);
	  cmd.add ("\"");
	  if (!real_path.error)
	    cmd.add (real_path.get_win32 ());
	  else
	    cmd.add (argv[0]);
	  cmd.add ("\"");
	  cmd.add (" ");
	  cmd.add (argv[1]);
	  cmd.add (" ");
	  cmd.add (argv[2]);
	  real_path.set_path (argv[0]);
	  null_app_name = true;
	}
      else
	{
	  if (real_path.iscygexec ())
	    {
	      moreinfo->argc = newargv.argc;
	      moreinfo->argv = newargv;
	    }
	  if ((wincmdln || !real_path.iscygexec ())
	       && !cmd.fromargv (newargv, real_path.get_win32 (),
				 real_path.iscygexec ()))
	    {
	      res = -1;
	      __leave;
	    }


	  if (mode != _P_OVERLAY || !real_path.iscygexec ()
	      || !DuplicateHandle (GetCurrentProcess (), myself.shared_handle (),
				   GetCurrentProcess (), &moreinfo->myself_pinfo,
				   0, TRUE, DUPLICATE_SAME_ACCESS))
	    moreinfo->myself_pinfo = NULL;
	  else
	    VerifyHandle (moreinfo->myself_pinfo);
	}

      PROCESS_INFORMATION pi;
      pi.hProcess = pi.hThread = NULL;
      pi.dwProcessId = pi.dwThreadId = 0;

      /* Set up needed handles for stdio */
      si.dwFlags = STARTF_USESTDHANDLES;
      si.hStdInput = handle ((in__stdin < 0 ? 0 : in__stdin), false);
      si.hStdOutput = handle ((in__stdout < 0 ? 1 : in__stdout), true);
      si.hStdError = handle (2, true);

      si.cb = sizeof (si);

      c_flags = GetPriorityClass (GetCurrentProcess ());
      sigproc_printf ("priority class %d", c_flags);

      c_flags |= CREATE_SEPARATE_WOW_VDM | CREATE_UNICODE_ENVIRONMENT;

      if (wincap.has_program_compatibility_assistant ())
	{
	  /* We're adding the CREATE_BREAKAWAY_FROM_JOB flag here to workaround
	     issues with the "Program Compatibility Assistant (PCA) Service"
	     starting with Windows Vista.  For some reason, when starting long
	     running sessions from mintty(*), the affected svchost.exe process
	     takes more and more memory and at one point takes over the CPU.  At
	     this point the machine becomes unresponsive.  The only way to get
	     back to normal is to stop the entire mintty session, or to stop the
	     PCA service.  However, a process which is controlled by PCA is part
	     of a compatibility job, which allows child processes to break away
	     from the job.  This helps to avoid this issue.

	     First we call IsProcessInJob.  It fetches the information whether or
	     not we're part of a job 20 times faster than QueryInformationJobObject.

	     (*) Note that this is not mintty's fault.  It has just been observed
	     with mintty in the first place.  See the archives for more info:
	     http://cygwin.com/ml/cygwin-developers/2012-02/msg00018.html */

	  JOBOBJECT_BASIC_LIMIT_INFORMATION jobinfo;
	  BOOL is_in_job;

	  if (IsProcessInJob (GetCurrentProcess (), NULL, &is_in_job)
	      && is_in_job
	      && QueryInformationJobObject (NULL, JobObjectBasicLimitInformation,
					 &jobinfo, sizeof jobinfo, NULL)
	      && (jobinfo.LimitFlags & (JOB_OBJECT_LIMIT_BREAKAWAY_OK
					| JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)))
	    {
	      debug_printf ("Add CREATE_BREAKAWAY_FROM_JOB");
	      c_flags |= CREATE_BREAKAWAY_FROM_JOB;
	    }
	}

      if (mode == _P_DETACH)
	c_flags |= DETACHED_PROCESS;
      else
	fhandler_console::need_invisible ();

      if (mode != _P_OVERLAY)
	myself->exec_sendsig = NULL;
      else
	{
	  /* Reset sendsig so that any process which wants to send a signal
	     to this pid will wait for the new process to become active.
	     Save the old value in case the exec fails.  */
	  if (!myself->exec_sendsig)
	    {
	      myself->exec_sendsig = myself->sendsig;
	      myself->exec_dwProcessId = myself->dwProcessId;
	      myself->sendsig = NULL;
	      reset_sendsig = true;
	    }
	}

      if (null_app_name)
	runpath = NULL;
      else
	{
	  USHORT len = real_path.get_nt_native_path ()->Length / sizeof (WCHAR);
	  if (RtlEqualUnicodePathPrefix (real_path.get_nt_native_path (),
					 &ro_u_natp, FALSE))
	    {
	      runpath = real_path.get_wide_win32_path (runpath);
	      /* If the executable path length is < MAX_PATH, make sure the long
		 path win32 prefix is removed from the path to make subsequent
		 not long path aware native Win32 child processes happy. */
	      if (len < MAX_PATH + 4)
		{
		  if (runpath[5] == ':')
		    runpath += 4;
		  else if (len < MAX_PATH + 6)
		    *(runpath += 6) = L'\\';
		}
	    }
	  else if (len < NT_MAX_PATH - ro_u_globalroot.Length / sizeof (WCHAR))
	    {
	      UNICODE_STRING rpath;

	      RtlInitEmptyUnicodeString (&rpath, runpath,
					 (NT_MAX_PATH - 1) * sizeof (WCHAR));
	      RtlCopyUnicodeString (&rpath, &ro_u_globalroot);
	      RtlAppendUnicodeStringToString (&rpath,
					      real_path.get_nt_native_path ());
	    }
	  else
	    {
	      set_errno (ENAMETOOLONG);
	      res = -1;
	      __leave;
	    }
	}

      cygbench ("spawn-worker");

      if (!real_path.iscygexec())
	::cygheap->fdtab.set_file_pointers_for_exec ();

      /* If we switch the user, merge the user's Windows environment. */
      bool switch_user = ::cygheap->user.issetuid ()
			 && (::cygheap->user.saved_uid
			     != ::cygheap->user.real_uid);
      moreinfo->envp = build_env (envp, envblock, moreinfo->envc,
				  real_path.iscygexec (),
				  switch_user ? ::cygheap->user.primary_token ()
					      : NULL);
      if (!moreinfo->envp || !envblock)
	{
	  set_errno (E2BIG);
	  res = -1;
	  __leave;
	}
      set (chtype, real_path.iscygexec ());
      __stdin = in__stdin;
      __stdout = in__stdout;
      record_children ();

      si.lpReserved2 = (LPBYTE) this;
      si.cbReserved2 = sizeof (*this);

      /* Depends on set call above.
	 Some file types might need extra effort in the parent after CreateProcess
	 and before copying the datastructures to the child.  So we have to start
	 the child in suspend state, unfortunately, to avoid a race condition. */
      if (!newargv.win16_exe
	  && (!iscygwin () || mode != _P_OVERLAY
	      || ::cygheap->fdtab.need_fixup_before ()))
	c_flags |= CREATE_SUSPENDED;
      /* If a native application should be spawned, we test here if the spawning
	 process is running in a console and, if so, if it's a foreground or
	 background process.  If it's a background process, we start the native
	 process with the CREATE_NEW_PROCESS_GROUP flag set.  This lets the native
	 process ignore Ctrl-C by default.  If we don't do that, pressing Ctrl-C
	 in a console will break native processes running in the background,
	 because the Ctrl-C event is sent to all processes in the console, unless
	 they ignore it explicitely.  CREATE_NEW_PROCESS_GROUP does that for us. */
      if (!iscygwin () && fhandler_console::exists ()
	  && fhandler_console::tc_getpgid () != myself->pgid)
	c_flags |= CREATE_NEW_PROCESS_GROUP;
      refresh_cygheap ();

      if (mode == _P_DETACH)
	/* all set */;
      else if (mode != _P_OVERLAY || !my_wr_proc_pipe)
	prefork ();
      else
	wr_proc_pipe = my_wr_proc_pipe;

      /* Don't allow child to inherit these handles if it's not a Cygwin program.
	 wr_proc_pipe will be injected later.  parent won't be used by the child
	 so there is no reason for the child to have it open as it can confuse
	 ps into thinking that children of windows processes are all part of
	 the same "execed" process.
	 FIXME: Someday, make it so that parent is never created when starting
	 non-Cygwin processes. */
      if (!iscygwin ())
	{
	  SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT, 0);
	  SetHandleInformation (parent, HANDLE_FLAG_INHERIT, 0);
	}
      /* FIXME: racy */
      if (mode != _P_OVERLAY)
	SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT, 0);
      parent_winpid = GetCurrentProcessId ();

    loop:
      /* When ruid != euid we create the new process under the current original
	 account and impersonate in child, this way maintaining the different
	 effective vs. real ids.
	 FIXME: If ruid != euid and ruid != saved_uid we currently give
	 up on ruid. The new process will have ruid == euid. */
      ::cygheap->user.deimpersonate ();

      if (!real_path.iscygexec () && mode == _P_OVERLAY)
	myself->process_state |= PID_NOTCYGWIN;

      wchar_t wcmd[(size_t) cmd];
      if (!::cygheap->user.issetuid ()
	  || (::cygheap->user.saved_uid == ::cygheap->user.real_uid
	      && ::cygheap->user.saved_gid == ::cygheap->user.real_gid
	      && !::cygheap->user.groups.issetgroups ()
	      && !::cygheap->user.setuid_to_restricted))
	{
	  rc = CreateProcessW (runpath,	  /* image name - with full path */
			       cmd.wcs (wcmd),/* what was passed to exec */
			       &sec_none_nih, /* process security attrs */
			       &sec_none_nih, /* thread security attrs */
			       TRUE,	  /* inherit handles from parent */
			       c_flags,
			       envblock,	  /* environment */
			       NULL,
			       &si,
			       &pi);
	}
      else
	{
	  /* Give access to myself */
	  if (mode == _P_OVERLAY)
	    myself.set_acl();

	  WCHAR wstname[1024] = { L'\0' };
	  HWINSTA hwst_orig = NULL, hwst = NULL;
	  HDESK hdsk_orig = NULL, hdsk = NULL;
	  PSECURITY_ATTRIBUTES sa;
	  DWORD n;

	  hwst_orig = GetProcessWindowStation ();
	  hdsk_orig = GetThreadDesktop (GetCurrentThreadId ());
	  GetUserObjectInformationW (hwst_orig, UOI_NAME, wstname, 1024, &n);
	  /* Prior to Vista it was possible to start a service with the
	     "Interact with desktop" flag.  This started the service in the
	     interactive window station of the console.  A big security
	     risk, but we don't want to disable this behaviour for older
	     OSes because it's still heavily used by some users.  They have
	     been warned. */
	  if (!::cygheap->user.setuid_to_restricted
	      && wcscasecmp (wstname, L"WinSta0") != 0)
	    {
	      WCHAR sid[128];

	      sa = sec_user ((PSECURITY_ATTRIBUTES) alloca (1024),
			     ::cygheap->user.sid ());
	      /* We're creating a window station per user, not per logon session.
		 First of all we might not have a valid logon session for
		 the user (logon by create_token), and second, it doesn't
		 make sense in terms of security to create a new window
		 station for every logon of the same user.  It just fills up
		 the system with window stations for no good reason. */
	      hwst = CreateWindowStationW (::cygheap->user.get_windows_id (sid),
					   0, GENERIC_READ | GENERIC_WRITE, sa);
	      if (!hwst)
		system_printf ("CreateWindowStation failed, %E");
	      else if (!SetProcessWindowStation (hwst))
		system_printf ("SetProcessWindowStation failed, %E");
	      else if (!(hdsk = CreateDesktopW (L"Default", NULL, NULL, 0,
						GENERIC_ALL, sa)))
		system_printf ("CreateDesktop failed, %E");
	      else
		{
		  wcpcpy (wcpcpy (wstname, sid), L"\\Default");
		  si.lpDesktop = wstname;
		  debug_printf ("Desktop: %W", si.lpDesktop);
		}
	    }

	  rc = CreateProcessAsUserW (::cygheap->user.primary_token (),
			       runpath,	  /* image name - with full path */
			       cmd.wcs (wcmd),/* what was passed to exec */
			       &sec_none_nih, /* process security attrs */
			       &sec_none_nih, /* thread security attrs */
			       TRUE,	  /* inherit handles from parent */
			       c_flags,
			       envblock,	  /* environment */
			       NULL,
			       &si,
			       &pi);
	  if (hwst)
	    {
	      SetProcessWindowStation (hwst_orig);
	      CloseWindowStation (hwst);
	    }
	  if (hdsk)
	    {
	      SetThreadDesktop (hdsk_orig);
	      CloseDesktop (hdsk);
	    }
	}

      if (mode != _P_OVERLAY)
	SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT,
			      HANDLE_FLAG_INHERIT);

      /* Set errno now so that debugging messages from it appear before our
	 final debugging message [this is a general rule for debugging
	 messages].  */
      if (!rc)
	{
	  __seterrno ();
	  syscall_printf ("CreateProcess failed, %E");
	  /* If this was a failed exec, restore the saved sendsig. */
	  if (reset_sendsig)
	    {
	      myself->sendsig = myself->exec_sendsig;
	      myself->exec_sendsig = NULL;
	    }
	  myself->process_state &= ~PID_NOTCYGWIN;
	  /* Reset handle inheritance to default when the execution of a non-Cygwin
	     process fails.  Only need to do this for _P_OVERLAY since the handle will
	     be closed otherwise.  Don't need to do this for 'parent' since it will
	     be closed in every case.  See FIXME above. */
	  if (!iscygwin () && mode == _P_OVERLAY)
	    SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT,
				  HANDLE_FLAG_INHERIT);
	  if (wr_proc_pipe == my_wr_proc_pipe)
	    wr_proc_pipe = NULL;	/* We still own it: don't nuke in destructor */

	  /* Restore impersonation. In case of _P_OVERLAY this isn't
	     allowed since it would overwrite child data. */
	  if (mode != _P_OVERLAY)
	    ::cygheap->user.reimpersonate ();

	  res = -1;
	  __leave;
	}

      /* The CREATE_SUSPENDED case is handled below */
      if (iscygwin () && !(c_flags & CREATE_SUSPENDED))
	strace.write_childpid (pi.dwProcessId);

      /* Fixup the parent data structures if needed and resume the child's
	 main thread. */
      if (::cygheap->fdtab.need_fixup_before ())
	::cygheap->fdtab.fixup_before_exec (pi.dwProcessId);

      if (mode != _P_OVERLAY)
	cygpid = cygwin_pid (pi.dwProcessId);
      else
	cygpid = myself->pid;

      /* We print the original program name here so the user can see that too.  */
      syscall_printf ("pid %d, prog_arg %s, cmd line %.9500s)",
		      rc ? cygpid : (unsigned int) -1, prog_arg, (const char *) cmd);

      /* Name the handle similarly to proc_subproc. */
      ProtectHandle1 (pi.hProcess, childhProc);

      if (mode == _P_OVERLAY)
	{
	  myself->dwProcessId = pi.dwProcessId;
	  strace.execing = 1;
	  myself.hProcess = hExeced = pi.hProcess;
	  real_path.get_wide_win32_path (myself->progname); // FIXME: race?
	  sigproc_printf ("new process name %W", myself->progname);
	  if (!iscygwin ())
	    close_all_files ();
	}
      else
	{
	  myself->set_has_pgid_children ();
	  ProtectHandle (pi.hThread);
	  pinfo child (cygpid,
		       PID_IN_USE | (real_path.iscygexec () ? 0 : PID_NOTCYGWIN));
	  if (!child)
	    {
	      syscall_printf ("pinfo failed");
	      if (get_errno () != ENOMEM)
		set_errno (EAGAIN);
	      res = -1;
	      __leave;
	    }
	  child->dwProcessId = pi.dwProcessId;
	  child.hProcess = pi.hProcess;

	  real_path.get_wide_win32_path (child->progname);
	  /* FIXME: This introduces an unreferenced, open handle into the child.
	     The purpose is to keep the pid shared memory open so that all of
	     the fields filled out by child.remember do not disappear and so there
	     is not a brief period during which the pid is not available.
	     However, we should try to find another way to do this eventually. */
	  DuplicateHandle (GetCurrentProcess (), child.shared_handle (),
			   pi.hProcess, NULL, 0, 0, DUPLICATE_SAME_ACCESS);
	  child->start_time = time (NULL); /* Register child's starting time. */
	  child->nice = myself->nice;
	  postfork (child);
	  if (!child.remember (mode == _P_DETACH))
	    {
	      /* FIXME: Child in strange state now */
	      CloseHandle (pi.hProcess);
	      ForceCloseHandle (pi.hThread);
	      res = -1;
	      __leave;
	    }
	}

      /* Start the child running */
      if (c_flags & CREATE_SUSPENDED)
	{
	  /* Inject a non-inheritable wr_proc_pipe handle into child so that we
	     can accurately track when the child exits without keeping this
	     process waiting around for it to exit.  */
	  if (!iscygwin ())
	    DuplicateHandle (GetCurrentProcess (), wr_proc_pipe, pi.hProcess, NULL,
			     0, false, DUPLICATE_SAME_ACCESS);
	  ResumeThread (pi.hThread);
	  if (iscygwin ())
	    strace.write_childpid (pi.dwProcessId);
	}
      ForceCloseHandle (pi.hThread);

      sigproc_printf ("spawned windows pid %d", pi.dwProcessId);

      bool synced;
      if ((mode == _P_DETACH || mode == _P_NOWAIT) && !iscygwin ())
	synced = false;
      else
	/* Just mark a non-cygwin process as 'synced'.  We will still eventually
	   wait for it to exit in maybe_set_exit_code_from_windows(). */
	synced = iscygwin () ? sync (pi.dwProcessId, pi.hProcess, INFINITE) : true;

      switch (mode)
	{
	case _P_OVERLAY:
	  myself.hProcess = pi.hProcess;
	  if (!synced)
	    {
	      if (!proc_retry (pi.hProcess))
		{
		  looped++;
		  goto loop;
		}
	      close_all_files (true);
	    }
	  else
	    {
	      if (iscygwin ())
		close_all_files (true);
	      if (!my_wr_proc_pipe
		  && WaitForSingleObject (pi.hProcess, 0) == WAIT_TIMEOUT)
		wait_for_myself ();
	    }
	  myself.exit (EXITCODE_NOSET);
	  break;
	case _P_WAIT:
	case _P_SYSTEM:
	  system_call.arm ();
	  if (waitpid (cygpid, &res, 0) != cygpid)
	    res = -1;
	  break;
	case _P_DETACH:
	  res = 0;	/* Lost all memory of this child. */
	  break;
	case _P_NOWAIT:
	case _P_NOWAITO:
	case _P_VFORK:
	  res = cygpid;
	  break;
	default:
	  break;
	}
    }
  __except (NO_ERROR)
    {
      if (get_errno () == ENOMEM)
	set_errno (E2BIG);
      else
	set_errno (EFAULT);
      res = -1;
    }
  __endtry
  this->cleanup ();
  if (envblock)
    free (envblock);
  return (int) res;
}

extern "C" int
cwait (int *result, int pid, int)
{
  return waitpid (pid, result, 0);
}

/*
* Helper function for spawn runtime calls.
* Doesn't search the path.
*/

extern "C" int
spawnve (int mode, const char *path, const char *const *argv,
       const char *const *envp)
{
  static char *const empty_env[] = { NULL };

  int ret;
#ifdef NEWVFORK
  vfork_save *vf = vfork_storage.val ();

  if (vf != NULL && (vf->pid < 0) && mode == _P_OVERLAY)
    mode = _P_NOWAIT;
  else
    vf = NULL;
#endif

  syscall_printf ("spawnve (%s, %s, %p)", path, argv[0], envp);

  if (!envp)
    envp = empty_env;

  switch (_P_MODE (mode))
    {
    case _P_OVERLAY:
      ch_spawn.worker (path, argv, envp, mode);
      /* Errno should be set by worker.  */
      ret = -1;
      break;
    case _P_VFORK:
    case _P_NOWAIT:
    case _P_NOWAITO:
    case _P_WAIT:
    case _P_DETACH:
    case _P_SYSTEM:
      ret = ch_spawn.worker (path, argv, envp, mode);
#ifdef NEWVFORK
      if (vf)
	{
	  if (ret > 0)
	    {
	      debug_printf ("longjmping due to vfork");
	      vf->restore_pid (ret);
	    }
	}
#endif
      break;
    default:
      set_errno (EINVAL);
      ret = -1;
      break;
    }
  return ret;
}

/*
* spawn functions as implemented in the MS runtime library.
* Most of these based on (and copied from) newlib/libc/posix/execXX.c
*/

extern "C" int
spawnl (int mode, const char *path, const char *arg0, ...)
{
  int i;
  va_list args;
  const char *argv[256];

  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
      argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);

  va_end (args);

  return spawnve (mode, path, (char * const  *) argv, cur_environ ());
}

extern "C" int
spawnle (int mode, const char *path, const char *arg0, ...)
{
  int i;
  va_list args;
  const char * const *envp;
  const char *argv[256];

  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
    argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);

  envp = va_arg (args, const char * const *);
  va_end (args);

  return spawnve (mode, path, (char * const *) argv, (char * const *) envp);
}

extern "C" int
spawnlp (int mode, const char *file, const char *arg0, ...)
{
  int i;
  va_list args;
  const char *argv[256];
  path_conv buf;

  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
      argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);

  va_end (args);

  return spawnve (mode | _P_PATH_TYPE_EXEC, find_exec (file, buf),
		  (char * const *) argv, cur_environ ());
}

extern "C" int
spawnlpe (int mode, const char *file, const char *arg0, ...)
{
  int i;
  va_list args;
  const char * const *envp;
  const char *argv[256];
  path_conv buf;

  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
    argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);

  envp = va_arg (args, const char * const *);
  va_end (args);

  return spawnve (mode | _P_PATH_TYPE_EXEC, find_exec (file, buf),
		  (char * const *) argv, envp);
}

extern "C" int
spawnv (int mode, const char *path, const char * const *argv)
{
  return spawnve (mode, path, argv, cur_environ ());
}

extern "C" int
spawnvp (int mode, const char *file, const char * const *argv)
{
  path_conv buf;
  return spawnve (mode | _P_PATH_TYPE_EXEC, find_exec (file, buf), argv,
		  cur_environ ());
}

extern "C" int
spawnvpe (int mode, const char *file, const char * const *argv,
	  const char * const *envp)
{
  path_conv buf;
  return spawnve (mode | _P_PATH_TYPE_EXEC, find_exec (file, buf), argv, envp);
}

int
av::setup (const char *prog_arg, path_conv& real_path, const char *ext,
	   int argc, const char *const *argv, bool p_type_exec)
{
  const char *p;
  bool exeext = ascii_strcasematch (ext, ".exe");
  new (this) av (argc, argv);
  if ((exeext && real_path.iscygexec ()) || ascii_strcasematch (ext, ".bat")
      || (!*ext && ((p = ext - 4) > real_path.get_win32 ())
	  && (ascii_strcasematch (p, ".bat") || ascii_strcasematch (p, ".cmd")
	      || ascii_strcasematch (p, ".btm"))))
    /* no extra checks needed */;
  else
    while (1)
      {
	char *pgm = NULL;
	char *arg1 = NULL;
	char *ptr, *buf;
	OBJECT_ATTRIBUTES attr;
	IO_STATUS_BLOCK io;
	HANDLE h;
	NTSTATUS status;
	LARGE_INTEGER size;

	status = NtOpenFile (&h, SYNCHRONIZE | GENERIC_READ,
			     real_path.get_object_attr (attr, sec_none_nih),
			     &io, FILE_SHARE_VALID_FLAGS,
			     FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_OPEN_FOR_BACKUP_INTENT
			     | FILE_NON_DIRECTORY_FILE);
	if (!NT_SUCCESS (status))
	  {
	    /* File is not readable?  Doesn't mean it's not executable.
	       Test for executability and if so, just assume the file is
	       a cygwin executable and go ahead. */
	    if (status == STATUS_ACCESS_DENIED && real_path.has_acls ()
		&& check_file_access (real_path, X_OK, true) == 0)
	      {
		real_path.set_cygexec (true);
		break;
	      }
	    goto err;
	  }
	if (!GetFileSizeEx (h, &size))
	  {
	    NtClose (h);
	    goto err;
	  }
	if (size.QuadPart > (LONGLONG) wincap.allocation_granularity ())
	  size.LowPart = wincap.allocation_granularity ();

	HANDLE hm = CreateFileMapping (h, &sec_none_nih, PAGE_READONLY,
				       0, 0, NULL);
	NtClose (h);
	if (!hm)
	  {
	    /* ERROR_FILE_INVALID indicates very likely an empty file. */
	    if (GetLastError () == ERROR_FILE_INVALID)
	      {
		debug_printf ("zero length file, treat as script.");
		goto just_shell;
	      }
	    goto err;
	  }
	/* Try to map the first 64K of the image.  That's enough for the local
	   tests, and it's enough for hook_or_detect_cygwin to compute the IAT
	   address. */
	buf = (char *) MapViewOfFile (hm, FILE_MAP_READ, 0, 0, size.LowPart);
	if (!buf)
	  {
	    CloseHandle (hm);
	    goto err;
	  }

	{
	  __try
	    {
	      if (buf[0] == 'M' && buf[1] == 'Z')
		{
		  WORD subsys;
		  unsigned off = (unsigned char) buf[0x18] | (((unsigned char) buf[0x19]) << 8);
		  win16_exe = off < sizeof (IMAGE_DOS_HEADER);
		  if (!win16_exe)
		    real_path.set_cygexec (hook_or_detect_cygwin (buf, NULL,
								  subsys, hm));
		  else
		    real_path.set_cygexec (false);
		  UnmapViewOfFile (buf);
		  CloseHandle (hm);
		  break;
		}
	    }
	  __except (NO_ERROR)
	    {
	      UnmapViewOfFile (buf);
	      CloseHandle (hm);
	      real_path.set_cygexec (false);
	      break;
	    }
	  __endtry
	}
	CloseHandle (hm);

	debug_printf ("%s is possibly a script", real_path.get_win32 ());

	ptr = buf;
	if (*ptr++ == '#' && *ptr++ == '!')
	  {
	    ptr += strspn (ptr, " \t");
	    size_t len = strcspn (ptr, "\r\n");
	    while (ptr[len - 1] == ' ' || ptr[len - 1] == '\t')
	      len--;
	    if (len)
	      {
		char *namebuf = (char *) alloca (len + 1);
		memcpy (namebuf, ptr, len);
		namebuf[len] = '\0';
		for (ptr = pgm = namebuf; *ptr; ptr++)
		  if (!arg1 && (*ptr == ' ' || *ptr == '\t'))
		    {
		      /* Null terminate the initial command and step over any
			 additional white space.  If we've hit the end of the
			 line, exit the loop.  Otherwise, we've found the first
			 argument. Position the current pointer on the last known
			 white space. */
		      *ptr = '\0';
		      char *newptr = ptr + 1;
		      newptr += strspn (newptr, " \t");
		      if (!*newptr)
			break;
		      arg1 = newptr;
		      ptr = newptr - 1;
		    }
	      }
	  }
	UnmapViewOfFile (buf);
  just_shell:
	if (!pgm)
	  {
	    if (!p_type_exec)
	      {
		/* Not called from exec[lv]p.  Don't try to treat as script. */
		debug_printf ("%s is not a valid executable",
			      real_path.get_win32 ());
		set_errno (ENOEXEC);
		return -1;
	      }
	    if (ascii_strcasematch (ext, ".com"))
	      break;
	    pgm = (char *) "/bin/sh";
	    arg1 = NULL;
	  }

	/* Check if script is executable.  Otherwise we start non-executable
	   scripts successfully, which is incorrect behaviour. */
	if (real_path.has_acls ()
	    && check_file_access (real_path, X_OK, true) < 0)
	  return -1;	/* errno is already set. */

	/* Replace argv[0] with the full path to the script if this is the
	   first time through the loop. */
	replace0_maybe (prog_arg);

	/* pointers:
	 * pgm	interpreter name
	 * arg1	optional string
	 */
	if (arg1)
	  unshift (arg1);

	find_exec (pgm, real_path, "PATH", FE_NADA, &ext);
	unshift (real_path.get_posix ());
      }
  if (real_path.iscygexec ())
    dup_all ();
  return 0;

err:
  __seterrno ();
  return -1;
}
@


1.362
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@d80 5
a84 1
   posix path of the file.  Any found suffix is returned in known_suffix.
d107 7
d142 1
a142 1
      strcpy (eotmp, name);
d152 3
@


1.361
log
@	* dlfcn.cc (check_path_access): Drop FE_NATIVE from find_exec call.
	(gfpod_helper): Drop equality sign from environment variable name
	in call to check_path_access.
	* exec.cc (execlp): Drop equality sign from environment variable name
	in call to find_exec.
	(execvp): Ditto.
	(execvpe): Ditto.
	* path.h (enum fe_types): Drop FE_NATIVE.
	(find_exec): Rename third paramter in declaration from search.  Drop
	equality sign from default value.
	* spawn.cc (perhaps_suffix): Add PC_POSIX to path_conv::check call.
	(find_exec): Simplify function.  Iterate over POSIX pathlist rather
	than Windows pathlist.  Drop handling of FE_NATIVE flag.  Always fill
	posix path of incoming path_conv buf, unless FE_NNF flag is given.
	(av::setup): Drop equality sign from environment variable name
	in call to find_exec.  Call unshift with normalized_path.
	* winf.cc (av::unshift): Drop conv parameter and code converting
	Windows to POSIX path.
	* winf.h (av::unshift): Accommodate prototype.
@
text
@d69 2
a70 2
  else if (buf.known_suffix)
    ext = buf.get_win32 () + (buf.known_suffix - buf.get_win32 ());
d80 1
a80 1
   posix path of the file..  Any found suffix is returned in known_suffix.
d82 1
a82 1
   If the file is not found and !FE_NNF then the win32 version of name is
d103 1
a103 1
      retval = buf.get_win32 ();
d141 1
a141 1
	  retval = buf.get_win32 ();
d154 1
a154 1
      retval = buf.get_win32 ();
d158 1
a158 1
  debug_printf ("%s = find_exec (%s)", (char *) buf.get_win32 (), name);
d1204 1
a1204 1
	unshift (real_path.normalized_path);
@


1.360
log
@Revert accidental checkin
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d56 1
a56 1
  buf.check (prog, PC_SYM_FOLLOW | PC_NULLEMPTY,
d78 7
a84 8
/* Find an executable name, possibly by appending known executable
   suffixes to it.  The win32-translated name is placed in 'buf'.
   Any found suffix is returned in known_suffix.

   If the file is not found and !null_if_not_found then the win32 version
   of name is placed in buf and returned.  Otherwise the contents of buf
   is undefined and NULL is returned.  */

d86 1
a86 1
find_exec (const char *name, path_conv& buf, const char *mywinenv,
d90 1
a90 2
  debug_printf ("find_exec (%s)", name);
  const char *retval;
d92 1
a93 1
  const char *posix = (opt & FE_NATIVE) ? NULL : name;
d97 3
a99 3
  /* Check to see if file can be opened as is first.
     Win32 systems always check . first, but PATH may not be set up to
     do this. */
a102 7
      if (posix && !has_slash)
	{
	  tmp[0] = '.';
	  tmp[1] = '/';
	  strcpy (tmp + 2, name);
	  posix = tmp;
	}
a106 1
  win_env *winpath;
d108 5
a112 19
  const char *posix_path;

  posix = (opt & FE_NATIVE) ? NULL : tmp;

  if (strchr (mywinenv, '/'))
    {
      /* it's not really an environment variable at all */
      int n = cygwin_conv_path_list (CCP_POSIX_TO_WIN_A, mywinenv, NULL, 0);
      char *s = (char *) alloca (n);
      if (cygwin_conv_path_list (CCP_POSIX_TO_WIN_A, mywinenv, s, n))
	goto errout;
      path = s;
      posix_path = mywinenv - 1;
    }
  else if (has_slash || strchr (name, '\\') || isdrive (name)
      || !(winpath = getwinenv (mywinenv))
      || !(path = winpath->get_native ()) || *path == '\0')
    /* Return the error condition if this is an absolute path or if there
       is no PATH to search. */
d115 1
a115 1
    posix_path = winpath->get_posix () - 1;
d117 4
a120 3
  debug_printf ("%s%s", mywinenv, path);
  /* Iterate over the specified path, looking for the file with and without
     executable extensions. */
d123 1
a123 2
      posix_path++;
      char *eotmp = strccpy (tmp, &path, ';');
d126 2
a127 1
      if (opt & FE_CWD && (tmp[0] == '\0' || (tmp[0] == '.' && tmp[1] == '\0')))
d130 1
a130 1
      *eotmp++ = '\\';
d133 1
a133 1
      debug_printf ("trying %s", tmp);
d137 1
a137 1
      if ((suffix = perhaps_suffix (tmp, buf, err1, opt)) != NULL)
a140 9

	  if (posix == tmp)
	    {
	      eotmp = strccpy (tmp, &posix_path, ':');
	      if (eotmp == tmp)
		*eotmp++ = '.';
	      *eotmp++ = '/';
	      strcpy (eotmp, name);
	    }
d144 1
d146 1
a146 1
  while (*path && *++path && (posix_path = strchr (posix_path, ':')));
a148 1
  posix = NULL;
d150 2
a151 6
     Take the appropriate action based on null_if_not_found. */
  if (opt & FE_NNF)
    retval = NULL;
  else if (!(opt & FE_NATIVE))
    retval = name;
  else
d153 1
a153 1
      buf.check (name);
a157 2
  if (posix)
    retval = buf.set_path (posix);
d1203 2
a1204 4
	/* FIXME: This should not be using FE_NATIVE.  It should be putting
	   the posix path on the argv list. */
	find_exec (pgm, real_path, "PATH=", FE_NATIVE, &ext);
	unshift (real_path.get_win32 (), 1);
@


1.359
log
@	* flock.cc (create_lock_in_parent): Make lf_obj handle inheritable.
	Explain why.
	(lockf_t::create_lock_obj): Use FALSE, rather than 0 for BOOL argument.
	(lockf_t::del_lock_obj): Check if NtSetEvent succeeded and print system
	message if not.
@
text
@a469 1
debug_printf ("ping 1");
@


1.358
log
@	* autoload.cc (CreateEnvironmentBlock): Import.
	(DestroyEnvironmentBlock): Import.
	* environ.cc (env_compare): New static bsearch comparison function.
	(build_env): Add parameter taking a user token.  If token is non-NULL,
	fetch user's default Windows environment and merge it into the resulting
	environment.  Explain what we do in preceeding comment.
	* environ,h (build_env): Align prototype to above change.
	* external.cc (create_winenv): Call build_env with NULL token.
	* spawn.cc (child_info_spawn::worker): When spawning new process under
	another user account, call build_env with new token to allow merging
	user's default Windows environment.
	* winlean.h (_USERENV_): Define to override dllimport.
@
text
@d470 1
@


1.357
log
@	* spawn.cc (child_info_spawn::worker): Fix formatting.
@
text
@d534 4
d539 3
a541 1
				  real_path.iscygexec ());
@


1.356
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d658 2
a659 2
	      hwst = CreateWindowStationW (::cygheap->user.get_windows_id (sid), 0,
					   GENERIC_READ | GENERIC_WRITE, sa);
@


1.355
log
@	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a332 1
  myfault efault;
d334 2
a335 1
  if (efault.faulted ())
d337 3
a339 2
      if (get_errno () == ENOMEM)
	set_errno (E2BIG);
d341 1
a341 4
	set_errno (EFAULT);
      res = -1;
      goto out;
    }
d343 1
a343 5
  child_info_types chtype;
  if (mode == _P_OVERLAY)
    chtype = _CH_EXEC;
  else
    chtype = _CH_SPAWN;
d345 2
a346 1
  moreinfo = cygheap_exec_info::alloc ();
d348 3
a350 2
  /* CreateProcess takes one long string that is the command line (sigh).
     We need to quote any argument that has whitespace or embedded "'s.  */
d352 8
a359 3
  int ac;
  for (ac = 0; argv[ac]; ac++)
    /* nothing */;
d361 1
a361 8
  int err;
  const char *ext;
  if ((ext = perhaps_suffix (prog_arg, real_path, err, FE_NADA)) == NULL)
    {
      set_errno (err);
      res = -1;
      goto out;
    }
d363 2
a364 1
  res = newargv.setup (prog_arg, real_path, ext, ac, argv, p_type_exec);
d366 9
a374 12
  if (res)
    goto out;

  if (!real_path.iscygexec () && ::cygheap->cwd.get_error ())
    {
      small_printf ("Error: Current working directory %s.\n"
		    "Can't start native Windows application from here.\n\n",
		    ::cygheap->cwd.get_error_desc ());
      set_errno (::cygheap->cwd.get_error ());
      res = -1;
      goto out;
    }
d376 2
a377 20
  if (ac == 3 && argv[1][0] == '/' && tolower (argv[1][1]) == 'c' &&
      (iscmd (argv[0], "command.com") || iscmd (argv[0], "cmd.exe")))
    {
      real_path.check (prog_arg);
      cmd.add ("\"");
      if (!real_path.error)
	cmd.add (real_path.get_win32 ());
      else
	cmd.add (argv[0]);
      cmd.add ("\"");
      cmd.add (" ");
      cmd.add (argv[1]);
      cmd.add (" ");
      cmd.add (argv[2]);
      real_path.set_path (argv[0]);
      null_app_name = true;
    }
  else
    {
      if (real_path.iscygexec ())
d379 13
a391 2
	  moreinfo->argc = newargv.argc;
	  moreinfo->argv = newargv;
d393 1
a393 3
      if ((wincmdln || !real_path.iscygexec ())
	   && !cmd.fromargv (newargv, real_path.get_win32 (),
			     real_path.iscygexec ()))
d395 12
a406 3
	  res = -1;
	  goto out;
	}
d409 8
a416 8
      if (mode != _P_OVERLAY || !real_path.iscygexec ()
	  || !DuplicateHandle (GetCurrentProcess (), myself.shared_handle (),
			       GetCurrentProcess (), &moreinfo->myself_pinfo,
			       0, TRUE, DUPLICATE_SAME_ACCESS))
	moreinfo->myself_pinfo = NULL;
      else
	VerifyHandle (moreinfo->myself_pinfo);
    }
d418 3
a420 3
  PROCESS_INFORMATION pi;
  pi.hProcess = pi.hThread = NULL;
  pi.dwProcessId = pi.dwThreadId = 0;
d422 5
a426 5
  /* Set up needed handles for stdio */
  si.dwFlags = STARTF_USESTDHANDLES;
  si.hStdInput = handle ((in__stdin < 0 ? 0 : in__stdin), false);
  si.hStdOutput = handle ((in__stdout < 0 ? 1 : in__stdout), true);
  si.hStdError = handle (2, true);
d428 1
a428 1
  si.cb = sizeof (si);
d430 2
a431 2
  c_flags = GetPriorityClass (GetCurrentProcess ());
  sigproc_printf ("priority class %d", c_flags);
d433 1
a433 1
  c_flags |= CREATE_SEPARATE_WOW_VDM | CREATE_UNICODE_ENVIRONMENT;
d435 1
a435 29
  if (wincap.has_program_compatibility_assistant ())
    {
      /* We're adding the CREATE_BREAKAWAY_FROM_JOB flag here to workaround
	 issues with the "Program Compatibility Assistant (PCA) Service"
	 starting with Windows Vista.  For some reason, when starting long
	 running sessions from mintty(*), the affected svchost.exe process
	 takes more and more memory and at one point takes over the CPU.  At
	 this point the machine becomes unresponsive.  The only way to get
	 back to normal is to stop the entire mintty session, or to stop the
	 PCA service.  However, a process which is controlled by PCA is part
	 of a compatibility job, which allows child processes to break away
	 from the job.  This helps to avoid this issue.

	 First we call IsProcessInJob.  It fetches the information whether or
	 not we're part of a job 20 times faster than QueryInformationJobObject.

	 (*) Note that this is not mintty's fault.  It has just been observed
	 with mintty in the first place.  See the archives for more info:
	 http://cygwin.com/ml/cygwin-developers/2012-02/msg00018.html */

      JOBOBJECT_BASIC_LIMIT_INFORMATION jobinfo;
      BOOL is_in_job;

      if (IsProcessInJob (GetCurrentProcess (), NULL, &is_in_job)
	  && is_in_job
	  && QueryInformationJobObject (NULL, JobObjectBasicLimitInformation,
				     &jobinfo, sizeof jobinfo, NULL)
	  && (jobinfo.LimitFlags & (JOB_OBJECT_LIMIT_BREAKAWAY_OK
				    | JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)))
d437 31
a467 2
	  debug_printf ("Add CREATE_BREAKAWAY_FROM_JOB");
	  c_flags |= CREATE_BREAKAWAY_FROM_JOB;
a468 1
    }
d470 4
a473 4
  if (mode == _P_DETACH)
    c_flags |= DETACHED_PROCESS;
  else
    fhandler_console::need_invisible ();
d475 3
a477 8
  if (mode != _P_OVERLAY)
    myself->exec_sendsig = NULL;
  else
    {
      /* Reset sendsig so that any process which wants to send a signal
	 to this pid will wait for the new process to become active.
	 Save the old value in case the exec fails.  */
      if (!myself->exec_sendsig)
d479 10
a488 4
	  myself->exec_sendsig = myself->sendsig;
	  myself->exec_dwProcessId = myself->dwProcessId;
	  myself->sendsig = NULL;
	  reset_sendsig = true;
a489 1
    }
d491 3
a493 7
  if (null_app_name)
    runpath = NULL;
  else
    {
      USHORT len = real_path.get_nt_native_path ()->Length / sizeof (WCHAR);
      if (RtlEqualUnicodePathPrefix (real_path.get_nt_native_path (),
				     &ro_u_natp, FALSE))
d495 17
a511 5
	  runpath = real_path.get_wide_win32_path (runpath);
	  /* If the executable path length is < MAX_PATH, make sure the long
	     path win32 prefix is removed from the path to make subsequent
	     not long path aware native Win32 child processes happy. */
	  if (len < MAX_PATH + 4)
d513 13
a525 4
	      if (runpath[5] == ':')
		runpath += 4;
	      else if (len < MAX_PATH + 6)
		*(runpath += 6) = L'\\';
d528 9
a536 1
      else if (len < NT_MAX_PATH - ro_u_globalroot.Length / sizeof (WCHAR))
d538 3
a540 7
	  UNICODE_STRING rpath;

	  RtlInitEmptyUnicodeString (&rpath, runpath,
				     (NT_MAX_PATH - 1) * sizeof (WCHAR));
	  RtlCopyUnicodeString (&rpath, &ro_u_globalroot);
	  RtlAppendUnicodeStringToString (&rpath,
					  real_path.get_nt_native_path ());
d542 33
d576 10
d587 2
a588 3
	  set_errno (ENAMETOOLONG);
	  res = -1;
	  goto out;
d590 4
a593 1
    }
d595 54
a648 1
  cygbench ("spawn-worker");
d650 24
a673 2
  if (!real_path.iscygexec())
    ::cygheap->fdtab.set_file_pointers_for_exec ();
d675 22
a696 43
  moreinfo->envp = build_env (envp, envblock, moreinfo->envc,
			      real_path.iscygexec ());
  if (!moreinfo->envp || !envblock)
    {
      set_errno (E2BIG);
      res = -1;
      goto out;
    }
  set (chtype, real_path.iscygexec ());
  __stdin = in__stdin;
  __stdout = in__stdout;
  record_children ();

  si.lpReserved2 = (LPBYTE) this;
  si.cbReserved2 = sizeof (*this);

  /* Depends on set call above.
     Some file types might need extra effort in the parent after CreateProcess
     and before copying the datastructures to the child.  So we have to start
     the child in suspend state, unfortunately, to avoid a race condition. */
  if (!newargv.win16_exe
      && (!iscygwin () || mode != _P_OVERLAY
	  || ::cygheap->fdtab.need_fixup_before ()))
    c_flags |= CREATE_SUSPENDED;
  /* If a native application should be spawned, we test here if the spawning
     process is running in a console and, if so, if it's a foreground or
     background process.  If it's a background process, we start the native
     process with the CREATE_NEW_PROCESS_GROUP flag set.  This lets the native
     process ignore Ctrl-C by default.  If we don't do that, pressing Ctrl-C
     in a console will break native processes running in the background,
     because the Ctrl-C event is sent to all processes in the console, unless
     they ignore it explicitely.  CREATE_NEW_PROCESS_GROUP does that for us. */
  if (!iscygwin () && fhandler_console::exists ()
      && fhandler_console::tc_getpgid () != myself->pgid)
    c_flags |= CREATE_NEW_PROCESS_GROUP;
  refresh_cygheap ();

  if (mode == _P_DETACH)
    /* all set */;
  else if (mode != _P_OVERLAY || !my_wr_proc_pipe)
    prefork ();
  else
    wr_proc_pipe = my_wr_proc_pipe;
d698 3
a700 51
  /* Don't allow child to inherit these handles if it's not a Cygwin program.
     wr_proc_pipe will be injected later.  parent won't be used by the child
     so there is no reason for the child to have it open as it can confuse
     ps into thinking that children of windows processes are all part of
     the same "execed" process.
     FIXME: Someday, make it so that parent is never created when starting
     non-Cygwin processes. */
  if (!iscygwin ())
    {
      SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT, 0);
      SetHandleInformation (parent, HANDLE_FLAG_INHERIT, 0);
    }
  /* FIXME: racy */
  if (mode != _P_OVERLAY)
    SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT, 0);
  parent_winpid = GetCurrentProcessId ();

loop:
  /* When ruid != euid we create the new process under the current original
     account and impersonate in child, this way maintaining the different
     effective vs. real ids.
     FIXME: If ruid != euid and ruid != saved_uid we currently give
     up on ruid. The new process will have ruid == euid. */
  ::cygheap->user.deimpersonate ();

  if (!real_path.iscygexec () && mode == _P_OVERLAY)
    myself->process_state |= PID_NOTCYGWIN;

  wchar_t wcmd[(size_t) cmd];
  if (!::cygheap->user.issetuid ()
      || (::cygheap->user.saved_uid == ::cygheap->user.real_uid
	  && ::cygheap->user.saved_gid == ::cygheap->user.real_gid
	  && !::cygheap->user.groups.issetgroups ()
	  && !::cygheap->user.setuid_to_restricted))
    {
      rc = CreateProcessW (runpath,	  /* image name - with full path */
			   cmd.wcs (wcmd),/* what was passed to exec */
			   &sec_none_nih, /* process security attrs */
			   &sec_none_nih, /* thread security attrs */
			   TRUE,	  /* inherit handles from parent */
			   c_flags,
			   envblock,	  /* environment */
			   NULL,
			   &si,
			   &pi);
    }
  else
    {
      /* Give access to myself */
      if (mode == _P_OVERLAY)
	myself.set_acl();
d702 4
a705 17
      WCHAR wstname[1024] = { L'\0' };
      HWINSTA hwst_orig = NULL, hwst = NULL;
      HDESK hdsk_orig = NULL, hdsk = NULL;
      PSECURITY_ATTRIBUTES sa;
      DWORD n;

      hwst_orig = GetProcessWindowStation ();
      hdsk_orig = GetThreadDesktop (GetCurrentThreadId ());
      GetUserObjectInformationW (hwst_orig, UOI_NAME, wstname, 1024, &n);
      /* Prior to Vista it was possible to start a service with the
	 "Interact with desktop" flag.  This started the service in the
	 interactive window station of the console.  A big security
	 risk, but we don't want to disable this behaviour for older
	 OSes because it's still heavily used by some users.  They have
	 been warned. */
      if (!::cygheap->user.setuid_to_restricted
	  && wcscasecmp (wstname, L"WinSta0") != 0)
d707 4
a710 20
	  WCHAR sid[128];

	  sa = sec_user ((PSECURITY_ATTRIBUTES) alloca (1024),
			 ::cygheap->user.sid ());
	  /* We're creating a window station per user, not per logon session.
	     First of all we might not have a valid logon session for
	     the user (logon by create_token), and second, it doesn't
	     make sense in terms of security to create a new window
	     station for every logon of the same user.  It just fills up
	     the system with window stations for no good reason. */
	  hwst = CreateWindowStationW (::cygheap->user.get_windows_id (sid), 0,
				       GENERIC_READ | GENERIC_WRITE, sa);
	  if (!hwst)
	    system_printf ("CreateWindowStation failed, %E");
	  else if (!SetProcessWindowStation (hwst))
	    system_printf ("SetProcessWindowStation failed, %E");
	  else if (!(hdsk = CreateDesktopW (L"Default", NULL, NULL, 0,
					    GENERIC_ALL, sa)))
	    system_printf ("CreateDesktop failed, %E");
	  else
d712 2
a713 3
	      wcpcpy (wcpcpy (wstname, sid), L"\\Default");
	      si.lpDesktop = wstname;
	      debug_printf ("Desktop: %W", si.lpDesktop);
d715 18
d735 3
a737 22
      rc = CreateProcessAsUserW (::cygheap->user.primary_token (),
			   runpath,	  /* image name - with full path */
			   cmd.wcs (wcmd),/* what was passed to exec */
			   &sec_none_nih, /* process security attrs */
			   &sec_none_nih, /* thread security attrs */
			   TRUE,	  /* inherit handles from parent */
			   c_flags,
			   envblock,	  /* environment */
			   NULL,
			   &si,
			   &pi);
      if (hwst)
	{
	  SetProcessWindowStation (hwst_orig);
	  CloseWindowStation (hwst);
	}
      if (hdsk)
	{
	  SetThreadDesktop (hdsk_orig);
	  CloseDesktop (hdsk);
	}
    }
d739 4
a742 27
  if (mode != _P_OVERLAY)
    SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT,
			  HANDLE_FLAG_INHERIT);

  /* Set errno now so that debugging messages from it appear before our
     final debugging message [this is a general rule for debugging
     messages].  */
  if (!rc)
    {
      __seterrno ();
      syscall_printf ("CreateProcess failed, %E");
      /* If this was a failed exec, restore the saved sendsig. */
      if (reset_sendsig)
	{
	  myself->sendsig = myself->exec_sendsig;
	  myself->exec_sendsig = NULL;
	}
      myself->process_state &= ~PID_NOTCYGWIN;
      /* Reset handle inheritance to default when the execution of a non-Cygwin
	 process fails.  Only need to do this for _P_OVERLAY since the handle will
	 be closed otherwise.  Don't need to do this for 'parent' since it will
	 be closed in every case.  See FIXME above. */
      if (!iscygwin () && mode == _P_OVERLAY)
	SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT,
			      HANDLE_FLAG_INHERIT);
      if (wr_proc_pipe == my_wr_proc_pipe)
	wr_proc_pipe = NULL;	/* We still own it: don't nuke in destructor */
a743 2
      /* Restore impersonation. In case of _P_OVERLAY this isn't
	 allowed since it would overwrite child data. */
d745 3
a747 1
	::cygheap->user.reimpersonate ();
d749 3
a751 3
      res = -1;
      goto out;
    }
d753 2
a754 8
  /* The CREATE_SUSPENDED case is handled below */
  if (iscygwin () && !(c_flags & CREATE_SUSPENDED))
    strace.write_childpid (pi.dwProcessId);

  /* Fixup the parent data structures if needed and resume the child's
     main thread. */
  if (::cygheap->fdtab.need_fixup_before ())
    ::cygheap->fdtab.fixup_before_exec (pi.dwProcessId);
d756 26
a781 4
  if (mode != _P_OVERLAY)
    cygpid = cygwin_pid (pi.dwProcessId);
  else
    cygpid = myself->pid;
d783 19
a801 30
  /* We print the original program name here so the user can see that too.  */
  syscall_printf ("pid %d, prog_arg %s, cmd line %.9500s)",
		  rc ? cygpid : (unsigned int) -1, prog_arg, (const char *) cmd);

  /* Name the handle similarly to proc_subproc. */
  ProtectHandle1 (pi.hProcess, childhProc);

  if (mode == _P_OVERLAY)
    {
      myself->dwProcessId = pi.dwProcessId;
      strace.execing = 1;
      myself.hProcess = hExeced = pi.hProcess;
      real_path.get_wide_win32_path (myself->progname); // FIXME: race?
      sigproc_printf ("new process name %W", myself->progname);
      if (!iscygwin ())
	close_all_files ();
    }
  else
    {
      myself->set_has_pgid_children ();
      ProtectHandle (pi.hThread);
      pinfo child (cygpid,
		   PID_IN_USE | (real_path.iscygexec () ? 0 : PID_NOTCYGWIN));
      if (!child)
	{
	  syscall_printf ("pinfo failed");
	  if (get_errno () != ENOMEM)
	    set_errno (EAGAIN);
	  res = -1;
	  goto out;
a802 2
      child->dwProcessId = pi.dwProcessId;
      child.hProcess = pi.hProcess;
d804 2
a805 12
      real_path.get_wide_win32_path (child->progname);
      /* FIXME: This introduces an unreferenced, open handle into the child.
	 The purpose is to keep the pid shared memory open so that all of
	 the fields filled out by child.remember do not disappear and so there
	 is not a brief period during which the pid is not available.
	 However, we should try to find another way to do this eventually. */
      DuplicateHandle (GetCurrentProcess (), child.shared_handle (),
		       pi.hProcess, NULL, 0, 0, DUPLICATE_SAME_ACCESS);
      child->start_time = time (NULL); /* Register child's starting time. */
      child->nice = myself->nice;
      postfork (child);
      if (!child.remember (mode == _P_DETACH))
d807 9
a815 5
	  /* FIXME: Child in strange state now */
	  CloseHandle (pi.hProcess);
	  ForceCloseHandle (pi.hThread);
	  res = -1;
	  goto out;
d817 1
a817 1
    }
d819 1
a819 14
  /* Start the child running */
  if (c_flags & CREATE_SUSPENDED)
    {
      /* Inject a non-inheritable wr_proc_pipe handle into child so that we
	 can accurately track when the child exits without keeping this
	 process waiting around for it to exit.  */
      if (!iscygwin ())
	DuplicateHandle (GetCurrentProcess (), wr_proc_pipe, pi.hProcess, NULL,
			 0, false, DUPLICATE_SAME_ACCESS);
      ResumeThread (pi.hThread);
      if (iscygwin ())
	strace.write_childpid (pi.dwProcessId);
    }
  ForceCloseHandle (pi.hThread);
d821 7
a827 1
  sigproc_printf ("spawned windows pid %d", pi.dwProcessId);
d829 1
a829 13
  bool synced;
  if ((mode == _P_DETACH || mode == _P_NOWAIT) && !iscygwin ())
    synced = false;
  else
    /* Just mark a non-cygwin process as 'synced'.  We will still eventually
       wait for it to exit in maybe_set_exit_code_from_windows(). */
    synced = iscygwin () ? sync (pi.dwProcessId, pi.hProcess, INFINITE) : true;

  switch (mode)
    {
    case _P_OVERLAY:
      myself.hProcess = pi.hProcess;
      if (!synced)
d831 12
a842 1
	  if (!proc_retry (pi.hProcess))
d844 5
a848 2
	      looped++;
	      goto loop;
d850 18
a867 1
	  close_all_files (true);
d869 5
d875 2
a876 25
	{
	  if (iscygwin ())
	    close_all_files (true);
	  if (!my_wr_proc_pipe
	      && WaitForSingleObject (pi.hProcess, 0) == WAIT_TIMEOUT)
	    wait_for_myself ();
	}
      myself.exit (EXITCODE_NOSET);
      break;
    case _P_WAIT:
    case _P_SYSTEM:
      system_call.arm ();
      if (waitpid (cygpid, &res, 0) != cygpid)
	res = -1;
      break;
    case _P_DETACH:
      res = 0;	/* Lost all memory of this child. */
      break;
    case _P_NOWAIT:
    case _P_NOWAITO:
    case _P_VFORK:
      res = cygpid;
      break;
    default:
      break;
d878 1
a878 2

out:
d1140 1
a1140 2
	  myfault efault;
	  if (efault.faulted ())
d1142 14
a1155 4
	      UnmapViewOfFile (buf);
	      CloseHandle (hm);
	      real_path.set_cygexec (false);
	      break;
d1157 1
a1157 1
	  if (buf[0] == 'M' && buf[1] == 'Z')
a1158 8
	      WORD subsys;
	      unsigned off = (unsigned char) buf[0x18] | (((unsigned char) buf[0x19]) << 8);
	      win16_exe = off < sizeof (IMAGE_DOS_HEADER);
	      if (!win16_exe)
		real_path.set_cygexec (hook_or_detect_cygwin (buf, NULL,
							      subsys, hm));
	      else
		real_path.set_cygexec (false);
d1161 1
d1164 1
@


1.354
log
@* spawn.cc (av::setup): Eat trailing whitespace on #! script.
@
text
@d97 1
a97 1
  int err;
@


1.353
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d1172 2
@


1.353.2.1
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@a1171 2
	    while (ptr[len - 1] == ' ' || ptr[len - 1] == '\t')
	      len--;
@


1.353.2.2
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d97 1
a97 1
  int err = 0;
@


1.353.2.3
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d333 1
d335 1
a335 2

  __try
d337 2
a338 3
      child_info_types chtype;
      if (mode == _P_OVERLAY)
	chtype = _CH_EXEC;
d340 10
a349 1
	chtype = _CH_SPAWN;
d351 1
a351 1
      moreinfo = cygheap_exec_info::alloc ();
d353 2
a354 2
      /* CreateProcess takes one long string that is the command line (sigh).
	 We need to quote any argument that has whitespace or embedded "'s.  */
d356 3
a358 3
      int ac;
      for (ac = 0; argv[ac]; ac++)
	/* nothing */;
d360 10
a369 8
      int err;
      const char *ext;
      if ((ext = perhaps_suffix (prog_arg, real_path, err, FE_NADA)) == NULL)
	{
	  set_errno (err);
	  res = -1;
	  __leave;
	}
d371 2
a372 1
      res = newargv.setup (prog_arg, real_path, ext, ac, argv, p_type_exec);
d374 9
a382 2
      if (res)
	__leave;
d384 27
a410 1
      if (!real_path.iscygexec () && ::cygheap->cwd.get_error ())
a411 4
	  small_printf ("Error: Current working directory %s.\n"
			"Can't start native Windows application from here.\n\n",
			::cygheap->cwd.get_error_desc ());
	  set_errno (::cygheap->cwd.get_error ());
d413 1
a413 1
	  __leave;
d416 6
a421 17
      if (ac == 3 && argv[1][0] == '/' && tolower (argv[1][1]) == 'c' &&
	  (iscmd (argv[0], "command.com") || iscmd (argv[0], "cmd.exe")))
	{
	  real_path.check (prog_arg);
	  cmd.add ("\"");
	  if (!real_path.error)
	    cmd.add (real_path.get_win32 ());
	  else
	    cmd.add (argv[0]);
	  cmd.add ("\"");
	  cmd.add (" ");
	  cmd.add (argv[1]);
	  cmd.add (" ");
	  cmd.add (argv[2]);
	  real_path.set_path (argv[0]);
	  null_app_name = true;
	}
d423 6
a428 13
	{
	  if (real_path.iscygexec ())
	    {
	      moreinfo->argc = newargv.argc;
	      moreinfo->argv = newargv;
	    }
	  if ((wincmdln || !real_path.iscygexec ())
	       && !cmd.fromargv (newargv, real_path.get_win32 (),
				 real_path.iscygexec ()))
	    {
	      res = -1;
	      __leave;
	    }
d430 5
d436 1
a436 8
	  if (mode != _P_OVERLAY || !real_path.iscygexec ()
	      || !DuplicateHandle (GetCurrentProcess (), myself.shared_handle (),
				   GetCurrentProcess (), &moreinfo->myself_pinfo,
				   0, TRUE, DUPLICATE_SAME_ACCESS))
	    moreinfo->myself_pinfo = NULL;
	  else
	    VerifyHandle (moreinfo->myself_pinfo);
	}
d438 2
a439 3
      PROCESS_INFORMATION pi;
      pi.hProcess = pi.hThread = NULL;
      pi.dwProcessId = pi.dwThreadId = 0;
d441 1
a441 5
      /* Set up needed handles for stdio */
      si.dwFlags = STARTF_USESTDHANDLES;
      si.hStdInput = handle ((in__stdin < 0 ? 0 : in__stdin), false);
      si.hStdOutput = handle ((in__stdout < 0 ? 1 : in__stdout), true);
      si.hStdError = handle (2, true);
d443 34
a476 1
      si.cb = sizeof (si);
d478 4
a481 2
      c_flags = GetPriorityClass (GetCurrentProcess ());
      sigproc_printf ("priority class %d", c_flags);
d483 15
a497 1
      c_flags |= CREATE_SEPARATE_WOW_VDM | CREATE_UNICODE_ENVIRONMENT;
d499 7
a505 1
      if (wincap.has_program_compatibility_assistant ())
d507 5
a511 27
	  /* We're adding the CREATE_BREAKAWAY_FROM_JOB flag here to workaround
	     issues with the "Program Compatibility Assistant (PCA) Service"
	     starting with Windows Vista.  For some reason, when starting long
	     running sessions from mintty(*), the affected svchost.exe process
	     takes more and more memory and at one point takes over the CPU.  At
	     this point the machine becomes unresponsive.  The only way to get
	     back to normal is to stop the entire mintty session, or to stop the
	     PCA service.  However, a process which is controlled by PCA is part
	     of a compatibility job, which allows child processes to break away
	     from the job.  This helps to avoid this issue.

	     First we call IsProcessInJob.  It fetches the information whether or
	     not we're part of a job 20 times faster than QueryInformationJobObject.

	     (*) Note that this is not mintty's fault.  It has just been observed
	     with mintty in the first place.  See the archives for more info:
	     http://cygwin.com/ml/cygwin-developers/2012-02/msg00018.html */

	  JOBOBJECT_BASIC_LIMIT_INFORMATION jobinfo;
	  BOOL is_in_job;

	  if (IsProcessInJob (GetCurrentProcess (), NULL, &is_in_job)
	      && is_in_job
	      && QueryInformationJobObject (NULL, JobObjectBasicLimitInformation,
					 &jobinfo, sizeof jobinfo, NULL)
	      && (jobinfo.LimitFlags & (JOB_OBJECT_LIMIT_BREAKAWAY_OK
					| JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)))
d513 4
a516 2
	      debug_printf ("Add CREATE_BREAKAWAY_FROM_JOB");
	      c_flags |= CREATE_BREAKAWAY_FROM_JOB;
d519 3
d523 6
a528 7
      if (mode == _P_DETACH)
	c_flags |= DETACHED_PROCESS;
      else
	fhandler_console::need_invisible ();

      if (mode != _P_OVERLAY)
	myself->exec_sendsig = NULL;
d531 3
a533 10
	  /* Reset sendsig so that any process which wants to send a signal
	     to this pid will wait for the new process to become active.
	     Save the old value in case the exec fails.  */
	  if (!myself->exec_sendsig)
	    {
	      myself->exec_sendsig = myself->sendsig;
	      myself->exec_dwProcessId = myself->dwProcessId;
	      myself->sendsig = NULL;
	      reset_sendsig = true;
	    }
d535 50
d586 69
a654 3
      if (null_app_name)
	runpath = NULL;
      else
d656 1
a656 19
	  USHORT len = real_path.get_nt_native_path ()->Length / sizeof (WCHAR);
	  if (RtlEqualUnicodePathPrefix (real_path.get_nt_native_path (),
					 &ro_u_natp, FALSE))
	    {
	      runpath = real_path.get_wide_win32_path (runpath);
	      /* If the executable path length is < MAX_PATH, make sure the long
		 path win32 prefix is removed from the path to make subsequent
		 not long path aware native Win32 child processes happy. */
	      if (len < MAX_PATH + 4)
		{
		  if (runpath[5] == ':')
		    runpath += 4;
		  else if (len < MAX_PATH + 6)
		    *(runpath += 6) = L'\\';
		}
	    }
	  else if (len < NT_MAX_PATH - ro_u_globalroot.Length / sizeof (WCHAR))
	    {
	      UNICODE_STRING rpath;
d658 17
a674 6
	      RtlInitEmptyUnicodeString (&rpath, runpath,
					 (NT_MAX_PATH - 1) * sizeof (WCHAR));
	      RtlCopyUnicodeString (&rpath, &ro_u_globalroot);
	      RtlAppendUnicodeStringToString (&rpath,
					      real_path.get_nt_native_path ());
	    }
d677 3
a679 3
	      set_errno (ENAMETOOLONG);
	      res = -1;
	      __leave;
d683 12
a694 8
      cygbench ("spawn-worker");

      if (!real_path.iscygexec())
	::cygheap->fdtab.set_file_pointers_for_exec ();

      moreinfo->envp = build_env (envp, envblock, moreinfo->envc,
				  real_path.iscygexec ());
      if (!moreinfo->envp || !envblock)
d696 2
a697 3
	  set_errno (E2BIG);
	  res = -1;
	  __leave;
d699 1
a699 44
      set (chtype, real_path.iscygexec ());
      __stdin = in__stdin;
      __stdout = in__stdout;
      record_children ();

      si.lpReserved2 = (LPBYTE) this;
      si.cbReserved2 = sizeof (*this);

      /* Depends on set call above.
	 Some file types might need extra effort in the parent after CreateProcess
	 and before copying the datastructures to the child.  So we have to start
	 the child in suspend state, unfortunately, to avoid a race condition. */
      if (!newargv.win16_exe
	  && (!iscygwin () || mode != _P_OVERLAY
	      || ::cygheap->fdtab.need_fixup_before ()))
	c_flags |= CREATE_SUSPENDED;
      /* If a native application should be spawned, we test here if the spawning
	 process is running in a console and, if so, if it's a foreground or
	 background process.  If it's a background process, we start the native
	 process with the CREATE_NEW_PROCESS_GROUP flag set.  This lets the native
	 process ignore Ctrl-C by default.  If we don't do that, pressing Ctrl-C
	 in a console will break native processes running in the background,
	 because the Ctrl-C event is sent to all processes in the console, unless
	 they ignore it explicitely.  CREATE_NEW_PROCESS_GROUP does that for us. */
      if (!iscygwin () && fhandler_console::exists ()
	  && fhandler_console::tc_getpgid () != myself->pgid)
	c_flags |= CREATE_NEW_PROCESS_GROUP;
      refresh_cygheap ();

      if (mode == _P_DETACH)
	/* all set */;
      else if (mode != _P_OVERLAY || !my_wr_proc_pipe)
	prefork ();
      else
	wr_proc_pipe = my_wr_proc_pipe;

      /* Don't allow child to inherit these handles if it's not a Cygwin program.
	 wr_proc_pipe will be injected later.  parent won't be used by the child
	 so there is no reason for the child to have it open as it can confuse
	 ps into thinking that children of windows processes are all part of
	 the same "execed" process.
	 FIXME: Someday, make it so that parent is never created when starting
	 non-Cygwin processes. */
      if (!iscygwin ())
d701 2
a702 2
	  SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT, 0);
	  SetHandleInformation (parent, HANDLE_FLAG_INHERIT, 0);
d704 1
a704 4
      /* FIXME: racy */
      if (mode != _P_OVERLAY)
	SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT, 0);
      parent_winpid = GetCurrentProcessId ();
d706 13
a718 17
    loop:
      /* When ruid != euid we create the new process under the current original
	 account and impersonate in child, this way maintaining the different
	 effective vs. real ids.
	 FIXME: If ruid != euid and ruid != saved_uid we currently give
	 up on ruid. The new process will have ruid == euid. */
      ::cygheap->user.deimpersonate ();

      if (!real_path.iscygexec () && mode == _P_OVERLAY)
	myself->process_state |= PID_NOTCYGWIN;

      wchar_t wcmd[(size_t) cmd];
      if (!::cygheap->user.issetuid ()
	  || (::cygheap->user.saved_uid == ::cygheap->user.real_uid
	      && ::cygheap->user.saved_gid == ::cygheap->user.real_gid
	      && !::cygheap->user.groups.issetgroups ()
	      && !::cygheap->user.setuid_to_restricted))
d720 2
a721 83
	  rc = CreateProcessW (runpath,	  /* image name - with full path */
			       cmd.wcs (wcmd),/* what was passed to exec */
			       &sec_none_nih, /* process security attrs */
			       &sec_none_nih, /* thread security attrs */
			       TRUE,	  /* inherit handles from parent */
			       c_flags,
			       envblock,	  /* environment */
			       NULL,
			       &si,
			       &pi);
	}
      else
	{
	  /* Give access to myself */
	  if (mode == _P_OVERLAY)
	    myself.set_acl();

	  WCHAR wstname[1024] = { L'\0' };
	  HWINSTA hwst_orig = NULL, hwst = NULL;
	  HDESK hdsk_orig = NULL, hdsk = NULL;
	  PSECURITY_ATTRIBUTES sa;
	  DWORD n;

	  hwst_orig = GetProcessWindowStation ();
	  hdsk_orig = GetThreadDesktop (GetCurrentThreadId ());
	  GetUserObjectInformationW (hwst_orig, UOI_NAME, wstname, 1024, &n);
	  /* Prior to Vista it was possible to start a service with the
	     "Interact with desktop" flag.  This started the service in the
	     interactive window station of the console.  A big security
	     risk, but we don't want to disable this behaviour for older
	     OSes because it's still heavily used by some users.  They have
	     been warned. */
	  if (!::cygheap->user.setuid_to_restricted
	      && wcscasecmp (wstname, L"WinSta0") != 0)
	    {
	      WCHAR sid[128];

	      sa = sec_user ((PSECURITY_ATTRIBUTES) alloca (1024),
			     ::cygheap->user.sid ());
	      /* We're creating a window station per user, not per logon session.
		 First of all we might not have a valid logon session for
		 the user (logon by create_token), and second, it doesn't
		 make sense in terms of security to create a new window
		 station for every logon of the same user.  It just fills up
		 the system with window stations for no good reason. */
	      hwst = CreateWindowStationW (::cygheap->user.get_windows_id (sid), 0,
					   GENERIC_READ | GENERIC_WRITE, sa);
	      if (!hwst)
		system_printf ("CreateWindowStation failed, %E");
	      else if (!SetProcessWindowStation (hwst))
		system_printf ("SetProcessWindowStation failed, %E");
	      else if (!(hdsk = CreateDesktopW (L"Default", NULL, NULL, 0,
						GENERIC_ALL, sa)))
		system_printf ("CreateDesktop failed, %E");
	      else
		{
		  wcpcpy (wcpcpy (wstname, sid), L"\\Default");
		  si.lpDesktop = wstname;
		  debug_printf ("Desktop: %W", si.lpDesktop);
		}
	    }

	  rc = CreateProcessAsUserW (::cygheap->user.primary_token (),
			       runpath,	  /* image name - with full path */
			       cmd.wcs (wcmd),/* what was passed to exec */
			       &sec_none_nih, /* process security attrs */
			       &sec_none_nih, /* thread security attrs */
			       TRUE,	  /* inherit handles from parent */
			       c_flags,
			       envblock,	  /* environment */
			       NULL,
			       &si,
			       &pi);
	  if (hwst)
	    {
	      SetProcessWindowStation (hwst_orig);
	      CloseWindowStation (hwst);
	    }
	  if (hdsk)
	    {
	      SetThreadDesktop (hdsk_orig);
	      CloseDesktop (hdsk);
	    }
d723 10
d734 2
d737 1
a737 2
	SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT,
			      HANDLE_FLAG_INHERIT);
d739 3
a741 28
      /* Set errno now so that debugging messages from it appear before our
	 final debugging message [this is a general rule for debugging
	 messages].  */
      if (!rc)
	{
	  __seterrno ();
	  syscall_printf ("CreateProcess failed, %E");
	  /* If this was a failed exec, restore the saved sendsig. */
	  if (reset_sendsig)
	    {
	      myself->sendsig = myself->exec_sendsig;
	      myself->exec_sendsig = NULL;
	    }
	  myself->process_state &= ~PID_NOTCYGWIN;
	  /* Reset handle inheritance to default when the execution of a non-Cygwin
	     process fails.  Only need to do this for _P_OVERLAY since the handle will
	     be closed otherwise.  Don't need to do this for 'parent' since it will
	     be closed in every case.  See FIXME above. */
	  if (!iscygwin () && mode == _P_OVERLAY)
	    SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT,
				  HANDLE_FLAG_INHERIT);
	  if (wr_proc_pipe == my_wr_proc_pipe)
	    wr_proc_pipe = NULL;	/* We still own it: don't nuke in destructor */

	  /* Restore impersonation. In case of _P_OVERLAY this isn't
	     allowed since it would overwrite child data. */
	  if (mode != _P_OVERLAY)
	    ::cygheap->user.reimpersonate ();
d743 8
a750 3
	  res = -1;
	  __leave;
	}
d752 4
a755 3
      /* The CREATE_SUSPENDED case is handled below */
      if (iscygwin () && !(c_flags & CREATE_SUSPENDED))
	strace.write_childpid (pi.dwProcessId);
d757 3
a759 4
      /* Fixup the parent data structures if needed and resume the child's
	 main thread. */
      if (::cygheap->fdtab.need_fixup_before ())
	::cygheap->fdtab.fixup_before_exec (pi.dwProcessId);
d761 2
a762 4
      if (mode != _P_OVERLAY)
	cygpid = cygwin_pid (pi.dwProcessId);
      else
	cygpid = myself->pid;
d764 17
a780 8
      /* We print the original program name here so the user can see that too.  */
      syscall_printf ("pid %d, prog_arg %s, cmd line %.9500s)",
		      rc ? cygpid : (unsigned int) -1, prog_arg, (const char *) cmd);

      /* Name the handle similarly to proc_subproc. */
      ProtectHandle1 (pi.hProcess, childhProc);

      if (mode == _P_OVERLAY)
d782 5
a786 7
	  myself->dwProcessId = pi.dwProcessId;
	  strace.execing = 1;
	  myself.hProcess = hExeced = pi.hProcess;
	  real_path.get_wide_win32_path (myself->progname); // FIXME: race?
	  sigproc_printf ("new process name %W", myself->progname);
	  if (!iscygwin ())
	    close_all_files ();
d788 15
a802 1
      else
d804 5
a808 34
	  myself->set_has_pgid_children ();
	  ProtectHandle (pi.hThread);
	  pinfo child (cygpid,
		       PID_IN_USE | (real_path.iscygexec () ? 0 : PID_NOTCYGWIN));
	  if (!child)
	    {
	      syscall_printf ("pinfo failed");
	      if (get_errno () != ENOMEM)
		set_errno (EAGAIN);
	      res = -1;
	      __leave;
	    }
	  child->dwProcessId = pi.dwProcessId;
	  child.hProcess = pi.hProcess;

	  real_path.get_wide_win32_path (child->progname);
	  /* FIXME: This introduces an unreferenced, open handle into the child.
	     The purpose is to keep the pid shared memory open so that all of
	     the fields filled out by child.remember do not disappear and so there
	     is not a brief period during which the pid is not available.
	     However, we should try to find another way to do this eventually. */
	  DuplicateHandle (GetCurrentProcess (), child.shared_handle (),
			   pi.hProcess, NULL, 0, 0, DUPLICATE_SAME_ACCESS);
	  child->start_time = time (NULL); /* Register child's starting time. */
	  child->nice = myself->nice;
	  postfork (child);
	  if (!child.remember (mode == _P_DETACH))
	    {
	      /* FIXME: Child in strange state now */
	      CloseHandle (pi.hProcess);
	      ForceCloseHandle (pi.hThread);
	      res = -1;
	      __leave;
	    }
d810 1
d812 14
a825 14
      /* Start the child running */
      if (c_flags & CREATE_SUSPENDED)
	{
	  /* Inject a non-inheritable wr_proc_pipe handle into child so that we
	     can accurately track when the child exits without keeping this
	     process waiting around for it to exit.  */
	  if (!iscygwin ())
	    DuplicateHandle (GetCurrentProcess (), wr_proc_pipe, pi.hProcess, NULL,
			     0, false, DUPLICATE_SAME_ACCESS);
	  ResumeThread (pi.hThread);
	  if (iscygwin ())
	    strace.write_childpid (pi.dwProcessId);
	}
      ForceCloseHandle (pi.hThread);
d827 1
a827 1
      sigproc_printf ("spawned windows pid %d", pi.dwProcessId);
d829 7
a835 7
      bool synced;
      if ((mode == _P_DETACH || mode == _P_NOWAIT) && !iscygwin ())
	synced = false;
      else
	/* Just mark a non-cygwin process as 'synced'.  We will still eventually
	   wait for it to exit in maybe_set_exit_code_from_windows(). */
	synced = iscygwin () ? sync (pi.dwProcessId, pi.hProcess, INFINITE) : true;
d837 5
a841 1
      switch (mode)
d843 1
a843 12
	case _P_OVERLAY:
	  myself.hProcess = pi.hProcess;
	  if (!synced)
	    {
	      if (!proc_retry (pi.hProcess))
		{
		  looped++;
		  goto loop;
		}
	      close_all_files (true);
	    }
	  else
d845 2
a846 5
	      if (iscygwin ())
		close_all_files (true);
	      if (!my_wr_proc_pipe
		  && WaitForSingleObject (pi.hProcess, 0) == WAIT_TIMEOUT)
		wait_for_myself ();
d848 1
a848 18
	  myself.exit (EXITCODE_NOSET);
	  break;
	case _P_WAIT:
	case _P_SYSTEM:
	  system_call.arm ();
	  if (waitpid (cygpid, &res, 0) != cygpid)
	    res = -1;
	  break;
	case _P_DETACH:
	  res = 0;	/* Lost all memory of this child. */
	  break;
	case _P_NOWAIT:
	case _P_NOWAITO:
	case _P_VFORK:
	  res = cygpid;
	  break;
	default:
	  break;
a849 5
    }
  __except (NO_ERROR)
    {
      if (get_errno () == ENOMEM)
	set_errno (E2BIG);
d851 25
a875 2
	set_errno (EFAULT);
      res = -1;
d877 2
a878 1
  __endtry
d1140 2
a1141 1
	  __try
d1143 4
a1146 14
	      if (buf[0] == 'M' && buf[1] == 'Z')
		{
		  WORD subsys;
		  unsigned off = (unsigned char) buf[0x18] | (((unsigned char) buf[0x19]) << 8);
		  win16_exe = off < sizeof (IMAGE_DOS_HEADER);
		  if (!win16_exe)
		    real_path.set_cygexec (hook_or_detect_cygwin (buf, NULL,
								  subsys, hm));
		  else
		    real_path.set_cygexec (false);
		  UnmapViewOfFile (buf);
		  CloseHandle (hm);
		  break;
		}
d1148 1
a1148 1
	  __except (NO_ERROR)
d1150 8
a1159 1
	      real_path.set_cygexec (false);
a1161 1
	  __endtry
@


1.352
log
@cygwin changes:
	* spawn.cc (child_info_spawn): Revert previous change.  Always set
	lpReserved2.
	* release/1.7.25: Change wording.
doc changes:
	* new-features.xml (ov-new1.7.25): Change wording.
@
text
@a16 2
#include <wingdi.h>
#include <winuser.h>
@


1.351
log
@	* path.h (enum path_types): Drop definition of PATH_64BITEXEC.
	(path_conv::iscygexec32): Drop unused inline function.
	(path_conv::iscygexec64): Ditto.
	(path_conv::set_cygexec): Remove unnecessary setting of PATH_64BITEXEC.
	* spawn.cc (child_info_spawn::worker): Disable setting of
	STARTUPINFOW::lpReserved2 and STARTUPINFOW::cbReserved2 for non-Cygwin
	child processes.  Explain why.
@
text
@d557 2
a558 11
  /* Don't propagate the child_info_spawn structure to the process if it
     hasn't been recognized as a Cygwin executable.  This also covers Cygwin
     executables of a different target (32 vs. 64 bit).  Native processes
     usually still work, even if lpReserved2 contains garbage from their
     point of view, but Cygwin processes of different bitsize will recognize
     it as Cygwin info and get all excited about the differences. */
  if (real_path.iscygexec ())
    {
      si.lpReserved2 = (LPBYTE) this;
      si.cbReserved2 = sizeof (*this);
    }
@


1.350
log
@cygwin directory changes:
	* environ.cc (tty_is_gone): Delete.
	(known): Delete tty, add wincmdln.
	* globals.cc: Reorganize list of environment bools, remove explicit =
	false for slight load time optimization.
	(wincmdln): New global.
	* spawn.cc (child_info_spawn::worker): Honor wincmdln.

doc directory changes:
	* new-features.sgml (ov-new1.7.23): Add new section.  Mention wincmdln.
	* cygwinenv.xml: Mention wincmdln.
@
text
@d557 11
a567 2
  si.lpReserved2 = (LPBYTE) this;
  si.cbReserved2 = sizeof (*this);
@


1.349
log
@* spawn.cc (child_info_spawn::worker): Reinstate using temp buffer for wide
character command-line storage.  Use wcs method to convert command line.
* winf.h (lb_wcs): Delete.
(linebuf::wcs): Implement new single-argument method.
@
text
@d410 3
a412 2
      else if (!cmd.fromargv (newargv, real_path.get_win32 (),
				   real_path.iscygexec ()))
@


1.348
log
@* common.din: Export GetCommandLine{A,W}.
* kernel32.cc: Add includes needed for GetCommandLine functions.
(ucmd): New function.
(cygwin_GetCommandLineW): Ditto.
(cygwin_GetCommandLineA): Ditto.
* spawn.cc (child_info_spawn::worker): Rename one_line -> cmd.  Use lb_wcs
macro to generate a wide character version of the line buffer.  Remove
duplicate printing of command line.  Don't access members of linebuf directly.
* winf.h: Use pragma once.
(linebuf): Make storage private.
(linebuf::operator size_t): New operator.  Return size of buf.
(linebuf::operator wchar_t): New operator.
(linebuf::wcs): New function.
(lb_wcs): New macro.
* include/cygwin/version.h: Bump API minor number to 268.
* strfuncs.cc: Clarify descriptive file comment.
@
text
@d615 1
d623 1
a623 1
			   lb_wcs (cmd),  /* what was passed to exec */
d686 1
a686 1
			   lb_wcs (cmd),  /* what was passed to exec */
@


1.347
log
@* spawn.cc (child_info_spawn::worker): Eliminate call to newargv.set() in favor
of conglomerated newargv.setup().  Let newargv.setup() decide when to call
dup_all().  Only set argc and argv for cygwin processes.
(av::setup): Rename from av::fixup.  Accept argc and argv parameters.  Fill out
argv and argc here.  Duplicate whole argv structure when this is a Cygwin
executable.
* winf.cc (linebuf::fromargv): Don't bother duplicating argv elements since
they will never be used.
* winf.h (av::set): Delete.
(av::setup): Rename from av::fixup.  Add two parameters.
(av::replace0_maybe): Assign calloced to 1 rather than 'true' for clarity.
(av::dup_maybe): Delete.
(av::dup_all): Set calloced to show that we have duplicated all of the
arguments in the list.
@
text
@d322 1
a322 1
  linebuf one_line;
d390 1
a390 1
      one_line.add ("\"");
d392 1
a392 1
	one_line.add (real_path.get_win32 ());
d394 6
a399 6
	one_line.add (argv[0]);
      one_line.add ("\"");
      one_line.add (" ");
      one_line.add (argv[1]);
      one_line.add (" ");
      one_line.add (argv[2]);
d410 1
a410 1
      else if (!one_line.fromargv (newargv, real_path.get_win32 (),
a425 5
  WCHAR wone_line[one_line.ix + 1];
  if (one_line.ix)
    sys_mbstowcs (wone_line, one_line.ix + 1, one_line.buf);
  else
    wone_line[0] = L'\0';
a536 2
  syscall_printf ("null_app_name %d (%W, %.9500W)", null_app_name,
		  runpath, wone_line);
d622 1
a622 1
			   wone_line,	  /* what was passed to exec */
d685 1
a685 1
			   wone_line,	  /* what was passed to exec */
d759 1
a759 1
		  rc ? cygpid : (unsigned int) -1, prog_arg, one_line.buf);
@


1.346
log
@* spawn.cc (child_info_spawn::worker): Eliminate wascygexec.
@
text
@a361 2
  newargv.set (ac, argv);

d371 1
a371 1
  res = newargv.fixup (prog_arg, real_path, ext, p_type_exec);
d406 4
a409 1
	newargv.dup_all ();
a417 4
      newargv.all_calloced ();
      moreinfo->argc = newargv.argc;
      moreinfo->argv = newargv;

d1073 2
a1074 2
av::fixup (const char *prog_arg, path_conv& real_path, const char *ext,
	   bool p_type_exec)
d1078 71
a1148 30
  if ((exeext && real_path.iscygexec ()) || ascii_strcasematch (ext, ".bat"))
    return 0;
  if (!*ext && ((p = ext - 4) > real_path.get_win32 ())
      && (ascii_strcasematch (p, ".bat") || ascii_strcasematch (p, ".cmd")
	  || ascii_strcasematch (p, ".btm")))
    return 0;
  while (1)
    {
      char *pgm = NULL;
      char *arg1 = NULL;
      char *ptr, *buf;
      OBJECT_ATTRIBUTES attr;
      IO_STATUS_BLOCK io;
      HANDLE h;
      NTSTATUS status;
      LARGE_INTEGER size;

      status = NtOpenFile (&h, SYNCHRONIZE | GENERIC_READ,
			   real_path.get_object_attr (attr, sec_none_nih),
			   &io, FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT
			   | FILE_NON_DIRECTORY_FILE);
      if (!NT_SUCCESS (status))
	{
	  /* File is not readable?  Doesn't mean it's not executable.
	     Test for executability and if so, just assume the file is
	     a cygwin executable and go ahead. */
	  if (status == STATUS_ACCESS_DENIED && real_path.has_acls ()
	      && check_file_access (real_path, X_OK, true) == 0)
d1150 3
a1152 1
	      real_path.set_cygexec (true);
d1155 1
a1155 17
	  goto err;
	}
      if (!GetFileSizeEx (h, &size))
	{
	  NtClose (h);
	  goto err;
	}
      if (size.QuadPart > (LONGLONG) wincap.allocation_granularity ())
	size.LowPart = wincap.allocation_granularity ();

      HANDLE hm = CreateFileMapping (h, &sec_none_nih, PAGE_READONLY,
				     0, 0, NULL);
      NtClose (h);
      if (!hm)
	{
	  /* ERROR_FILE_INVALID indicates very likely an empty file. */
	  if (GetLastError () == ERROR_FILE_INVALID)
d1157 11
a1167 2
	      debug_printf ("zero length file, treat as script.");
	      goto just_shell;
a1168 10
	  goto err;
	}
      /* Try to map the first 64K of the image.  That's enough for the local
	 tests, and it's enough for hook_or_detect_cygwin to compute the IAT
	 address. */
      buf = (char *) MapViewOfFile (hm, FILE_MAP_READ, 0, 0, size.LowPart);
      if (!buf)
	{
	  CloseHandle (hm);
	  goto err;
d1170 3
d1174 2
a1175 3
      {
	myfault efault;
	if (efault.faulted ())
d1177 24
a1200 4
	    UnmapViewOfFile (buf);
	    CloseHandle (hm);
	    real_path.set_cygexec (false);
	    break;
d1202 3
a1204 1
	if (buf[0] == 'M' && buf[1] == 'Z')
d1206 12
a1217 11
	    WORD subsys;
	    unsigned off = (unsigned char) buf[0x18] | (((unsigned char) buf[0x19]) << 8);
	    win16_exe = off < sizeof (IMAGE_DOS_HEADER);
	    if (!win16_exe)
	      real_path.set_cygexec (hook_or_detect_cygwin (buf, NULL,
							    subsys, hm));
	    else
	      real_path.set_cygexec (false);
	    UnmapViewOfFile (buf);
	    CloseHandle (hm);
	    break;
d1219 22
d1242 2
a1243 72
      CloseHandle (hm);

      debug_printf ("%s is possibly a script", real_path.get_win32 ());

      ptr = buf;
      if (*ptr++ == '#' && *ptr++ == '!')
	{
	  ptr += strspn (ptr, " \t");
	  size_t len = strcspn (ptr, "\r\n");
	  if (len)
	    {
	      char *namebuf = (char *) alloca (len + 1);
	      memcpy (namebuf, ptr, len);
	      namebuf[len] = '\0';
	      for (ptr = pgm = namebuf; *ptr; ptr++)
		if (!arg1 && (*ptr == ' ' || *ptr == '\t'))
		  {
		    /* Null terminate the initial command and step over any
		       additional white space.  If we've hit the end of the
		       line, exit the loop.  Otherwise, we've found the first
		       argument. Position the current pointer on the last known
		       white space. */
		    *ptr = '\0';
		    char *newptr = ptr + 1;
		    newptr += strspn (newptr, " \t");
		    if (!*newptr)
		      break;
		    arg1 = newptr;
		    ptr = newptr - 1;
		  }
	    }
	}
      UnmapViewOfFile (buf);
just_shell:
      if (!pgm)
	{
	  if (!p_type_exec)
	    {
	      /* Not called from exec[lv]p.  Don't try to treat as script. */
	      debug_printf ("%s is not a valid executable",
			    real_path.get_win32 ());
	      set_errno (ENOEXEC);
	      return -1;
	    }
	  if (ascii_strcasematch (ext, ".com"))
	    break;
	  pgm = (char *) "/bin/sh";
	  arg1 = NULL;
	}

      /* Check if script is executable.  Otherwise we start non-executable
	 scripts successfully, which is incorrect behaviour. */
      if (real_path.has_acls ()
	  && check_file_access (real_path, X_OK, true) < 0)
	return -1;	/* errno is already set. */

      /* Replace argv[0] with the full path to the script if this is the
	 first time through the loop. */
      replace0_maybe (prog_arg);

      /* pointers:
       * pgm	interpreter name
       * arg1	optional string
       */
      if (arg1)
	unshift (arg1);

      /* FIXME: This should not be using FE_NATIVE.  It should be putting
	 the posix path on the argv list. */
      find_exec (pgm, real_path, "PATH=", FE_NATIVE, &ext);
      unshift (real_path.get_win32 (), 1);
    }
@


1.345
log
@* spawn.cc (ILLEGAL_SIG_FUNC_PTR): New define.
(system_call_handle): Rename from system_call_cleanup.
(is_system_call): New convenience method.
(system_call_handle::system_call_handle): Use ILLEGAL_SIG_FUNC_PTR rather than
cast.  Call sig_send here rather than in caller.  Initialize oldint.
(system_call_handle::arm): New function pulled from constructor.
(~system_call_handle::system_call_handle): Use is_system_call().
(child_info_spawn::worker): Use system_call_handle to set up for system call
early.  Use arm call prior to waiting for child to properly set up signal
handling.  Move comment closer to code it is commenting on.
@
text
@a329 1
  bool wascygexec;
a372 1
  wascygexec = real_path.iscygexec ();
d407 1
a407 1
      if (wascygexec)
@


1.344
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d237 2
a238 1
struct system_call_cleanup
d243 5
a247 1
  system_call_cleanup (bool issystem)
d250 1
a250 1
      oldint = (_sig_func_ptr) -1;
d253 8
d270 1
a270 1
  ~system_call_cleanup ()
d272 1
a272 1
    if (oldmask != (sigset_t) -1)
a320 3
  /* FIXME: There is a small race here and FIXME: not thread safe! */
  if (mode == _P_SYSTEM)
    sig_send (NULL, __SIGHOLD);
d337 1
d616 1
a621 1
loop:
a754 2
  system_call_cleanup (mode == _P_SYSTEM);

d874 1
@


1.343
log
@* spawn.cc (system_call_cleanup): Rename from pthread_cleanup.  Extend
functionality.
(system_call_cleanup::system_call_cleanup): Set up signals like system()
requires.  Unblock previously-blocked signal handling.
(system_call_cleanup::~system_call_cleanup): Restore signal handling after
system().
(child_info_spawn::worker): Put signals on hold and use system_call_cleanup
class to set and restore signals rather than doing it prior to to running the
program.  Remove the ill-conceived pthread_cleanup stuff.
@
text
@d88 1
a88 1
const char * __stdcall
a766 1
  pid_t pid;
a773 1
      pid = myself->pid;
a812 1
      pid = child->pid;
@


1.342
log
@	* Merge in cygwin-64bit-branch.
@
text
@d237 1
a237 1
struct pthread_cleanup
d242 25
a266 1
  pthread_cleanup (): oldint (NULL), oldquit (NULL), oldmask ((sigset_t) -1) {}
a268 13
static void
do_cleanup (void *args)
{
# define cleanup ((pthread_cleanup *) args)
  if (cleanup->oldmask != (sigset_t) -1)
    {
      signal (SIGINT, cleanup->oldint);
      signal (SIGQUIT, cleanup->oldquit);
      sigprocmask (SIG_SETMASK, &(cleanup->oldmask), NULL);
    }
# undef cleanup
}

a308 1
  pthread_cleanup cleanup;
d310 1
a310 9
    {
      sigset_t child_block;
      cleanup.oldint = signal (SIGINT, SIG_IGN);
      cleanup.oldquit = signal (SIGQUIT, SIG_IGN);
      sigemptyset (&child_block);
      sigaddset (&child_block, SIGCHLD);
      sigprocmask (SIG_BLOCK, &child_block, &cleanup.oldmask);
    }
  pthread_cleanup_push (do_cleanup, (void *) &cleanup);
d744 2
a886 1
  pthread_cleanup_pop (1);
@


1.341
log
@* child_info.h (cygheap_exec_info::sigmask): Declare new field.
* cygheap.cc (init_cygheap::find_tls): Rename threadlist_ix -> ix.  Only take
one pass through thread list, looking for eligible threads to signal.  Set a
new param indicating that function has found a sigwait* mask.
* cygheap.h (init_cygheap::find_tls): Reflect new parameter.
* dcrt0.cc (parent_sigmask): New variable.
(child_info_spawn::handle_spawn): Save parent's signal mask here.
(dll_crt0_1): Restore parent's signal mask to tls sigmask as appropriate.  Call
sig_dispatch_pending to flush signal queue when we can finally do something
with signals.
* exceptions.cc (sigpacket::process): Avoid attempting to handle signals if we
haven't finished initializing.  Rely on the fact that find_tls will do mask
checking and don't do it again.  Delete ill-named 'dummy' variable.
* sigproc.cc (cygheap_exec_info::alloc): Save calling thread's signal mask in
new sigmask field.
(wait_sig): Try to debug when WFSO fails and DEBUGGING is defined.
* thread.cc (pthread::set_tls_self_pointer): Make this a true automatic method
rather than inexplicably relying on a thread parameter.
(pthread::thread_init_wrapper): Accommodate set_tls_self_pointer change to
non-static.  Initialize sigmask before setting tid or suffer signal races.
* ehread.h (pthread::set_tls_self_pointer): Make non-static, delete parameter.
@
text
@d37 1
a37 1
static suffix_info NO_COPY exe_suffixes[] =
a44 14
#if 0
/* CV, 2009-11-05: Used to be used when searching for DLLs in calls to
   dlopen().  However, dlopen() on other platforms never adds a suffix by
   its own.  Therefore we use stat_suffixes now, which only adds a .exe
   suffix for symmetry. */
static suffix_info dll_suffixes[] =
{
  suffix_info (".dll"),
  suffix_info ("", 1),
  suffix_info (".exe", 1),
  suffix_info (NULL)
};
#endif

d454 3
d462 1
d464 2
a465 16
      /* Calling QueryInformationJobObject costs time.  Starting with
	 Windows XP there's a function IsProcessInJob, which fetches the
	 information whether or not we're part of a job 20 times faster than
	 the call to QueryInformationJobObject.  But we're still
	 supporting Windows 2000, so we can't just link to that function.
	 On the other hand, loading the function pointer at runtime is a
	 time comsuming operation, too.  So, what we do here is to emulate
	 the IsProcessInJob function when called for the own process and with
	 a NULL job handle.  In this case it just returns the value of the
	 lowest bit from PEB->EnvironmentUpdateCount (observed with WinDbg).
	 The name of this PEB member is the same in all (inofficial)
	 documentations of the PEB.  Apparently it's a bit misleading.
	 As a result, we only call QueryInformationJobObject if we're on
	 Vista or later *and* if the PEB indicates we're running in a job.
	 Tested on Vista/32, Vista/64, W7/32, W7/64, W8/64. */
      if ((NtCurrentTeb ()->Peb->EnvironmentUpdateCount & 1) != 0
d914 1
a914 1
  syscall_printf ("spawnve (%s, %s, %x)", path, argv[0], envp);
d1114 1
a1114 1
      if (size.QuadPart > wincap.allocation_granularity ())
d1155 2
a1156 2
	      real_path.set_cygexec (!!hook_or_detect_cygwin (buf, NULL,
							      subsys, hm));
@


1.340
log
@whitespace
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.339
log
@* spawn.cc (child_info_spawn::worker): Save and restore my_wr_proc_pipe around
non-execing operations to avoid handle leak seen in
http://cygwin.com/ml/cygwin/2013-03/msg00152.html .
@
text
@a374 1

@


1.338
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d623 3
d730 3
a732 4
  /* Restore impersonation. In case of _P_OVERLAY this isn't
     allowed since it would overwrite child data. */
  if (mode != _P_OVERLAY || !rc)
    ::cygheap->user.reimpersonate ();
d753 2
a754 1
	SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
d757 6
@


1.337
log
@* spawn.cc (child_info_spawn::worker): Make detection of '/c' case insensitive
when looking for cmd.exe command line.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.336
log
@* cygthread.cc (cygthread::stub): Remove old, unnecessary, FIXMEd code.
* spawn.cc (child_info_spawn::worker): Avoid calling close_all_files() twice.
@
text
@d392 1
a392 1
  if (ac == 3 && argv[1][0] == '/' && argv[1][1] == 'c' &&
@


1.335
log
@whitespace cleanup
@
text
@d870 2
a871 1
	  close_all_files (true);
@


1.334
log
@* spawn.cc (child_info_spawn::worker): Put back a minor variation of Corinna's
test for detecting a background process when starting a non-cygwin process.
@
text
@d468 1
a468 1
	 
d749 1
a749 1
         be closed in every case.  See FIXME above. */
@


1.334.2.1
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d468 1
a468 1

d749 1
a749 1
	 be closed in every case.  See FIXME above. */
d870 1
a870 2
	  if (iscygwin ())
	    close_all_files (true);
@


1.334.2.2
log
@Pull in changes from HEAD, missing ones, too.
Move 64bit-only entry from ChangeLog to ChangeLog.64bit.
@
text
@d392 1
a392 1
  if (ac == 3 && argv[1][0] == '/' && tolower (argv[1][1]) == 'c' &&
@


1.334.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d930 1
a930 1
  syscall_printf ("spawnve (%s, %s, %p)", path, argv[0], envp);
@


1.334.2.4
log
@	* cygwin.sc.in (OUTPUT_FORMAT): Fix typo in 64 bit code.
	* spawn.cc (av::fixup): Drop '!!' to keep argument to set_cygexec a
	void *.
@
text
@d1171 2
a1172 2
	      real_path.set_cygexec (hook_or_detect_cygwin (buf, NULL,
							    subsys, hm));
@


1.334.2.5
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.334.2.6
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d37 1
a37 1
static const suffix_info exe_suffixes[] =
d45 14
@


1.334.2.7
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::open): Cast second parameter
	in roundup2 to same size as first parameter to make sure mask size is
	correct.
	* fhandler_process.cc (format_process_maps): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* hookapi.cc (find_first_notloaded_dll): Add cast.
	* spawn.cc (av::fixup): Ditto.
	* wincap.h: Add comment to explain the folowing change.
	(wincapc::page_size): Return size_t.
	(wincapc::allocation_granularity): Ditto.

	* mmap.cc: Throughout, accommodate the fact that AT_ROUND_TO_PAGE isn't
	support on 64 bit at all.
	(class mmap_allocator): New class to allocate mmap slots on x86_64.
	(mmap_alloc): Define global instant of mmap_allocator.
	(mmap64): Call mmap_alloc.alloc on x86_64.
@
text
@d1116 1
a1116 1
      if (size.QuadPart > (LONGLONG) wincap.allocation_granularity ())
@


1.334.2.8
log
@Pull in changes from HEAD
@
text
@a608 3
  /* FIXME: racy */
  if (mode != _P_OVERLAY)
    SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT, 0);
d713 4
a716 3
  if (mode != _P_OVERLAY)
    SetHandleInformation (my_wr_proc_pipe, HANDLE_FLAG_INHERIT,
			  HANDLE_FLAG_INHERIT);
d737 1
a737 2
	SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT,
			      HANDLE_FLAG_INHERIT);
a739 6

      /* Restore impersonation. In case of _P_OVERLAY this isn't
	 allowed since it would overwrite child data. */
      if (mode != _P_OVERLAY)
	::cygheap->user.reimpersonate ();

@


1.334.2.9
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@a454 3
	 First we call IsProcessInJob.  It fetches the information whether or
	 not we're part of a job 20 times faster than QueryInformationJobObject.

a459 1
      BOOL is_in_job;
d461 16
a476 2
      if (IsProcessInJob (GetCurrentProcess (), NULL, &is_in_job)
	  && is_in_job
@


1.334.2.10
log
@	* pipe.cc (fhandler_pipe::open): Fix format specifier and type when
	reading handle value.
	(fhandler_pipe::get_proc_fd_name): Use same format specifier as in
	fhandler_pipe::open.
@
text
@d361 1
@


1.333
log
@* DevNotes: Add entry cgf-000007.
* child_info.h (child_info_spawn::parent_winpid): Declare new field.
(child_info_spawn::get_parent_handle): Declare new function.
* dcrt0.cc (child_info_spawn::get_parent_handle): Define new function.
(child_info_spawn::handle_spawn): Recreate parent handle if possible when
dynamically loaded.  Don't mess with parent handle if it's NULL.
* spawn.cc (child_info_spawn::worker): Set parent_winpid appropriately.
@
text
@d591 10
a600 4
  /* Give non-Cygwin processes their own process group since they will be
     dealing with CTRL-C themselves.  Not sure if this is correct for spawn*()
     or not though.  */
  if (!iscygwin () && fhandler_console::exists ())
@


1.332
log
@* DevNotes: Add entry cgf-000004.
* pinfo.cc (pinfo::init): Reuse shared memory if the state is marked with
PID_REAPED.
* spawn.cc (child_info_spawn::worker): Don't duplicate myself_pinfo into
non-cygwin child.
* fork.cc (frok::parent): Improve error output.
@
text
@d617 1
@


1.331
log
@* DevNotes: Add entry cgf-000003.
* cygheap.h (init_cygheap::pid_handle): Delete.
* dcrt0.cc (child_info_spawn::handle_spawn): Keep parent open if we have
execed.
* pinfo.cc (pinfo::thisproc): Remove pid_handle manipulations.
(pinfo::init): Don't consider a reaped process to be available.
* spawn.cc (child_info_spawn::worker): Remove pid_handle manipulations.  Make
wr_proc_pipe and parent noninheritable when starting a program which doesn't
use the Cygwin DLL.  Conditionally reset wr_proc_pipe to inheritable if
CreateProcess fails.  Inject wr_proc_pipe handle into non-Cygwin process.
Consider a non-cygwin process to be 'synced'.
@
text
@d425 4
a428 4
      if (mode != _P_OVERLAY ||
	  !DuplicateHandle (GetCurrentProcess (), myself.shared_handle (),
			    GetCurrentProcess (), &moreinfo->myself_pinfo,
			    0, TRUE, DUPLICATE_SAME_ACCESS))
d743 1
a743 1
      if (!real_path.iscygexec () && mode == _P_OVERLAY)
@


1.330
log
@wincap.h: Rename assitant to assistant throughout.  wincap.cc: Ditto.
* devices.in (exists_console): Use fhandler_console::exists () rather than raw
test.
* devices.cc: Regenerate.
* fhandler.h (fhandler_console::exists): Define new function.
* fhandler_console.cc (fhandler_console::need_invisible): Use
fhandler_console::exists () rather than raw test.
* spawn.cc: Rename assitant to assistant throughout.
(child_info_spawn::worker): Simplify test for when to start a non-Cygwin
process in its own process group.  Just do it whenever we start a non-Cygwin
process.
@
text
@a519 11
      /* Save a copy of a handle to the current process around the first time we
	 exec so that the pid will not be reused.  Why did I stop cygwin from
	 generating its own pids again? */
      if (::cygheap->pid_handle)
	/* already done previously */;
      else if (DuplicateHandle (GetCurrentProcess (), GetCurrentProcess (),
				GetCurrentProcess (), &::cygheap->pid_handle,
				PROCESS_QUERY_INFORMATION, TRUE, 0))
	ProtectHandleINH (::cygheap->pid_handle);
      else
	system_printf ("duplicate to pid_handle failed, %E");
d605 13
d739 6
d766 1
a766 1
  syscall_printf ("%d = child_info_spawn::worker(%s, %.9500s)",
d826 6
d844 3
a846 1
    synced = sync (pi.dwProcessId, pi.hProcess, INFINITE);
@


1.329
log
@* child_info.h (child_info::postfork): Define new function.
* fork.cc (frok::parent): Call postfork to do all of the manipulation required
prior to calling pinfo::remember.
* pinfo.h (pinfo::set_rd_proc_pipe): Just set pinfo's rd_proc_pipe.  Don't
bother setting it to NULL.
* sigproc.cc (child_info_spawn::wait_for_myself): Call postfork to set up
myself for waiting.
* spawn.cc (child_info_spawn::worker): Avoid now-unnecessary global lock.
Consistently test mode rather than chtype when making wr_proc_pipe decisions.
Call postfork() to set up stuff prior to pinfo::remember.
@
text
@d456 1
a456 1
  if (wincap.has_program_compatibility_assitant ())
d602 4
a605 10
  /* If a native application should be spawned, we test here if the spawning
     process is running in a console and, if so, if it's a foreground or
     background process.  If it's a background process, we start the native
     process with the CREATE_NEW_PROCESS_GROUP flag set.  This lets the native
     process ignore Ctrl-C by default.  If we don't do that, pressing Ctrl-C
     in a console will break native processes running in the background,
     because the Ctrl-C event is sent to all processes in the console, unless
     they ignore it explicitely.  CREATE_NEW_PROCESS_GROUP does that for us. */
  if (!iscygwin () && myself->ctty >= 0 && iscons_dev (myself->ctty)
      && fhandler_console::tc_getpgid () != myself->pgid)
@


1.328
log
@* child_info.h: Reset magic number.
(child_info_spawn::wait_for_myself): Move function to sigproc.cc.
* pinfo.cc (is_toplevel_proc): Delete unneeded variable.
* sigproc.cc (child_info_spawn::wait_for_myself): Move function from header to
here.  Do all setup required to properly wait for top-level execed process to
exit.
* spawn.cc (child_info_spawn::worker): Attempt to properly handle _P_DETACH.
Set wr_proc_pipe if top-level process even when execing.  Just call
wait_for_myself() to...  wait for myself.  Don't call cleanup twice.
@
text
@a310 1
  hold_everything for_now;
a311 1

d617 1
a617 1
  else if (chtype != _CH_EXEC || !my_wr_proc_pipe)
a769 1
  bool synced;
a795 1
      child.set_rd_proc_pipe (rd_proc_pipe);
d809 1
d832 1
@


1.327
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::rd_proc_pipe): Declare new field.
(child_info::wr_proc_pipe): Ditto.
(child_info::prefork): Declare new function, derived from previous pinfo
version.
* dcrt0.cc (child_info_fork::handle_fork): Close previous wr_proc_pipe when
appropriate and assign new one from passed-in child_info block.
(child_info_spawn::handle_spawn): Assign our wr_proc_pipe handle from passed-in
child_info block.
* fork.cc (child_info::prefork): Define new function.
(frok::child): Clear rd_proc_pipe and wr_proc_pipe so they will not be closed
by the child_info destructor.
(frok::parent): Use child_info prefork handling, outside of retry loop.  Set
rd_proc_pipe in child's pinfo after successful CreateProcess.  Eliminate
postfork call.
* globals.cc (my_wr_proc_pipe): Define/declare new variable.
* pinfo.cc (pinfo::pending_rd_proc_pipe): Delete.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wait): Assume that rd_proc_pipe is set up correctly prior to call.
(_pinfo::alert_parent): Replace "wr_proc_pipe" with "my_wr_proc_pipe".
* pinfo.h (_pinfo::_wr_proc_pipe): Delete declaration.
(_pinfo::set_rd_proc_pipe): Define new function.
(pinfo::pending_rd_proc_pipe): Delete declaration.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wr_proc_pipe): Ditto.
* sigproc.cc (child_info::child_info): Clear rd_proc_pipe and wr_proc_pipe.
(child_info::cleanup): Close rd_proc_pipe and wr_proc_pipe if necessary.
(child_info_fork::child_info_fork): Set forker_finished to NULL by default.
(child_info_spawn::child_info_spawn): Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.
(child_info::sync): Ditto.
(child_info_spawn::cleanup): Call child_info::cleanup.
* spawn.cc (child_info_spawn::worker): Remove call to myself.prefork().  Set
wr_proc_pipe when execing or set up new rd_proc_pipe/wr_proc_pipe via
child_info::prefork when spawning.  Remove call to pinfo::postexec.  Set
rd_proc_pipe in child pinfo when spawning.  Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.  Remove call to postfork.
@
text
@d617 5
a621 1
  if (chtype == _CH_EXEC)
a622 2
  else
    prefork ();
d858 1
a858 6
	    {
	      extern bool is_toplevel_proc;
	      is_toplevel_proc = true;
	      myself.remember (false);
	      wait_for_myself ();
	    }
a859 1
      this->cleanup ();
@


1.326
log
@* fork.cc (lock_signals): Move to sigproc.h.
(lock_pthread): Ditto.
(hold_everything): Ditto.
(frok::parent): Call myself.prefork() just before calling CreateProcess.  Call
myself.postfork () on function exit.
* pinfo.cc (pinfo::pending_rd_proc_pipe): Define.
(pinfo::pending_wr_proc_pipe): Ditto.
(_pinfo::dup_proc_pipe): Delete.
(pinfo::wait): Move pipe creation into pinfo::prefork.  Set pipe variables from
pending_*.
(_pinfo::sync_proc_pipe): Delete.
(_pinfo::proc_pipe_owner): Ditto.
(pinfo::prefork): Define new function.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(_pinfo::alert_parent): Remove obsolete call to sync_proc_pipe.
(_pinfo::dup_proc_pipe): Delete declaration.
(_pinfo::sync_proc_pipe): Ditto.
(pinfo::pending_rd_proc_pipe): Declare.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Declare new function.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wr_proc_pipe): Define new wrapper function.
* sigproc.h: Include "sync.h".  Move locking functions from fork to here.
* spawn.cc (child_info_spawn::worker): Delete now-unneeded requirement to
record orig_wr_proc_pipe.  Call hold_everything prior to doing anything.  Call
myself.prefork() if spawning.  Replace wr_proc_pipe synchronization with call
to myself.postexec().  Call myself.postfork() if not execing.
* sync.h: Replace #ifdef wrapper with "#pragma once".
@
text
@d355 1
a355 4
    {
      chtype = _CH_SPAWN;
      myself.prefork ();
    }
d616 6
d743 2
a778 12
      /* If wr_proc_pipe doesn't exist then this process was not started by a cygwin
	 process.  So, we need to wait around until the process we've just "execed"
	 dies.  Use our own wait facility below to wait for our own pid to exit
	 (there is some minor special case code in proc_waiter and friends to
	 accommodate this).

	 If wr_proc_pipe exists, then it will be inherited by the child.
	 If the child has exited already, that's ok.  The parent will pick up
	 on this fact when we exit.  myself.postexec () will close our end of
	 the pipe.  */
      if (!newargv.win16_exe && myself->wr_proc_pipe)
	myself.postexec ();
d797 1
d854 1
a854 1
	  if (!myself->wr_proc_pipe
a883 2
  if (mode != _P_OVERLAY)
    myself.postfork ();
@


1.325
log
@* pinfo.cc (_pinfo::dup_proc_pipe): Reorganize to provide more information for
failing condition.
(pinfo::wait): Pass name of function to dup_proc_pipe.  Eliminate error check
for dup_proc_pipe since it never actually returned an error.
* pinfo.h (_pinfo::dup_proc_pipe): Add an argument.
* spawn.cc (child_info_spawn::worker): Pass name of function to dup_proc_pipe.
@
text
@d311 1
a338 1
  HANDLE orig_wr_proc_pipe = NULL;
d352 2
a353 2
  if (mode != _P_OVERLAY)
    chtype = _CH_SPAWN;
d355 4
a358 1
    chtype = _CH_EXEC;
d776 3
a778 3
	 dies.  Use our own wait facility to wait for our own pid to exit (there
	 is some minor special case code in proc_waiter and friends to accommodate
	 this).
d780 1
a780 1
	 If wr_proc_pipe exists, then it should be duplicated to the child.
d782 2
a783 3
	 on this fact when we exit.  dup_proc_pipe will close our end of the pipe.
	 Note that wr_proc_pipe may also be == INVALID_HANDLE_VALUE.  That will make
	 dup_proc_pipe essentially a no-op.  */
d785 1
a785 7
	{
	  if (!looped)
	    myself->sync_proc_pipe ();	/* Make sure that we own wr_proc_pipe
					   just in case we've been previously
					   execed. */
	  orig_wr_proc_pipe = myself->dup_proc_pipe (pi.hProcess, "child_info_spawn::worker");
	}
a849 5
	  if (orig_wr_proc_pipe)
	    {
	      myself->wr_proc_pipe_owner = GetCurrentProcessId ();
	      myself->wr_proc_pipe = orig_wr_proc_pipe;
	    }
d890 2
@


1.324
log
@	* ntdll.h (struct _PEB): Add EnvironmentUpdateCount member.
	* spawn.cc (child_info_spawn::worker): Speed up job recognition.  Expand
	comment to explain every little detail and so we never forget.
	* wincap.h (wincaps::has_program_compatibility_assitant): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d788 1
a788 1
	  orig_wr_proc_pipe = myself->dup_proc_pipe (pi.hProcess);
@


1.323
log
@	* include/process.h: Move here from include/cygwin subdir.
	* exec.cc: Change include of process.h to reflect the fact that it's
	now back in include.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
@
text
@d458 1
a458 14
  /* We're adding the CREATE_BREAKAWAY_FROM_JOB flag here to workaround issues
     with the "Program Compatibility Assistant (PCA) Service" observed on
     Windows 7.  For some reason, when starting long running sessions from
     mintty, the affected svchost.exe process takes more and more memory and
     at one point takes over the CPU.  At this point the machine becomes
     unresponsive.  The only way to get back to normal is to stop the entire
     mintty session, or to stop the PCA service.  However, a process which
     is controlled by PCA is part of a compatibility job, which allows child
     processes to break away from the job.  This helps to avoid this issue. */
  JOBOBJECT_BASIC_LIMIT_INFORMATION jobinfo;
  if (QueryInformationJobObject (NULL, JobObjectBasicLimitInformation,
				 &jobinfo, sizeof jobinfo, NULL)
      && (jobinfo.LimitFlags & (JOB_OBJECT_LIMIT_BREAKAWAY_OK
				| JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)))
d460 41
a500 2
      debug_printf ("Add CREATE_BREAKAWAY_FROM_JOB");
      c_flags |= CREATE_BREAKAWAY_FROM_JOB;
@


1.322
log
@* spawn.cc (child_info_spawn::worker): Delete debugging.
@
text
@d15 1
a15 1
#include <cygwin/process.h>
@


1.321
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@a339 1
#if 0
a349 1
#endif
@


1.320
log
@	* include/cygwin/process.h: Move here from newlib.
	* exec.cc: Change include of process.h to reflect the fact that it's
	now in the include/cygwin subfolder.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
@
text
@d21 1
a22 1
#include <sys/cygwin.h>
d24 2
a28 1
#include "sigproc.h"
a30 1
#include "pinfo.h"
d340 1
d351 1
d589 1
a589 1
      && fhandler_console::tc_getpgid () != getpgrp ())
@


1.319
log
@* dtable.cc (dtable::stdio_init): Always initialize console when we have one.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use a better method to
print tty name for debugging.
(fhandler_termios::bg_check): Ditto.
* pinfo.cc (_pinfo::set_ctty): Remove leftover debugging stuff.  Simplify
behavior when setting tty's sid and pgid to avoid overwriting previously set
values.
* spawn.cc (ch_spawn): Cosmetic change.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d15 1
a15 1
#include <process.h>
@


1.318
log
@	* spawn.cc (child_info_spawn::worker): Add CREATE_BREAKAWAY_FROM_JOB
	to c_flags only if current process is member of a job and breakaway
	is allowed.
@
text
@d272 1
a272 1
NO_COPY child_info_spawn ch_spawn;
@


1.317
log
@	* spawn.cc (child_info_spawn::worker): Add CREATE_BREAKAWAY_FROM_JOB
	to all spawned processes.  Explain why.
@
text
@d455 3
d467 9
a475 2
  c_flags |= CREATE_SEPARATE_WOW_VDM | CREATE_UNICODE_ENVIRONMENT
	     | CREATE_BREAKAWAY_FROM_JOB;
@


1.316
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d455 11
a465 1
  c_flags |= CREATE_SEPARATE_WOW_VDM | CREATE_UNICODE_ENVIRONMENT;
@


1.315
log
@* cygthread.h (cygthread::name): Default name to "main" if we are early in the
process of setting up the DLL and no name is known.
* dcrt0.cc (initial_env): Remove CYGWIN_SLEEP stuff.
(get_cygwin_startup_info): Activate strace here as appropriate.
(dll_crt0_0): Move get_cygwin_startup_info as early as possible to avoid
missing strace output.
* fork.cc (frok::child): Move debugging statement to point where ppid will be
set.
* pinfo.cc (pinfo::thisproc): Remove obsolete call to strace.hello.  Tweak
debug output slightly.
* select.cc (select_stuff::wait): Allow APCS to be triggered while waiting
since we use them now.  Report when that happens.
* sigproc.cc (child_info::child_info): Use strace.active() rather than
strace.attached().
* spawn.cc (child_info_spawn::worker): Only write strace child pid when we know
it's a cygwin process.  Accommodate change to write_child argument list.
* strace.cc (strace::hello): Delete.  Move functionality...
(strace::activate): ...to here.
(mypid): Just use raw GetCurrentProcessId () if myself isn't set.
(strace::write_childpid): Don't wait for subproc_ready.  Remove arg which was
required for it.
* include/sys/strace.h (strace::hello): Delete.
(strace::write_childpid): Delete first argument.
@
text
@d710 1
a710 1
  syscall_printf ("%d = child_info_spawn::worker (%s, %.9500s)",
@


1.314
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset for previous changes.
* dcrt0.cc (get_cygwin_startup_info): Signal readiness when stracing since
strace::write_child relies on it.  Use strace.activate to notify strace
process, passing in arg indicating whether we're forked.
* sigproc.cc (wait_sig): Accommodate new strace::activate argument.
* spawn.cc (child_info_spawn::worker): Oops.  Previous suspended test was
actually correct.  Revert and document.
* strace.cc (strace::activate): Send additional flag indicating whether this is
an attempt to activate a forked process.
(strace::hello): Report on windows pid.
* include/sys/strace.h (strace::strace): Make a dummy.
(strace::activate): Modify declaration to accept an argument.
(strace::write_childpid): Set regparm.
@
text
@d696 2
a697 2
  if (!(c_flags & CREATE_SUSPENDED))
    strace.write_childpid (*this, pi.dwProcessId);
d790 2
a791 1
      strace.write_childpid (*this, pi.dwProcessId);
@


1.313
log
@* pipe.cc (fhandler_pipe::create): Avoid derefencing a NULL pointer.
* child_info.h (child_info): Reorganize some elements so that the ones which
are initialized in a constructor are all together.
* sigproc.cc (child_info::child_info): Initialize values via the constructor
rather than as C statements and make sure that flags is set to zero initially.
* spawn.cc (child_info_spawn::worker): Use iscygwin() test for determining when
to send strace info since it is more foolproof than checking the suspend state.
@
text
@d695 2
a696 1
  if (iscygwin ())
@


1.312
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(cygheap_exec_info::nchildren): Move from child_info_spawn.
(cygheap_exec_info::cchildren): Ditto.
(cygheap_exec_info::record_children): Declare new function.
(cygheap_exec_info::reattach_children): Ditto.
(cygheap_exec_info::alloc): Ditto.
(child_info_spawn::nchildren): Move to cygheap_exec_info.
(child_info_spawn::cchildren): Ditto.
* sigproc.cc (cygheap_exec_info::alloc): Define new function.
(child_info_spawn::cleanup): Accommodate move of children info to
cygheap_exec_info.
(cygheap_exec_info::record_children): Define new function.
(cygheap_exec_info::reattach_children): Ditto.
(child_info_spawn::record_children): Use cygheap_exec_info function to
accomplish this task.
(child_info_spawn::reattach_children): Ditto.
* spawn.cc (child_info_spawn::worker): Allocate moreinfo using
cygheap_exec_info::alloc.
* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Use abort for the error to
avoid a retry.
@
text
@d695 1
a695 1
  if (!(c_flags & CREATE_SUSPENDED))
@


1.311
log
@Remove erroneously checked-in debugging statements.
* cygheap.cc (cygheap_fixup_in_child): Here.
* debug.cc (delete_handle): Here.
* sigproc.cc (child_info_spawn::cleanup): Here.
* spawn.cc (child_info_spawn::worker): Here.
@
text
@d357 1
a357 2
  moreinfo = (cygheap_exec_info *) ccalloc_abort (HEAP_1_EXEC, 1,
						  sizeof (cygheap_exec_info));
@


1.310
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@a851 1
debug_printf ("about to call cleanup");
@


1.309
log
@* child_info.h (cchildren): New struct.
(child_info_spawn::nchildren): Rename from nprocs.
(child_info_spawn::children): Change type to cchildren for more bookkeeping
possibilities.
(child_info_spawn::child_info_spawn): Clear nchildren.
(child_info_spawn::record_children): Declare new function.
(child_info_spawn::reattach_children): Ditto.
* dcrt0.cc (child_info_spawn::handle_spawn): Call reattach_children to gather
list of processes we are potentially waiting for.
* pinfo.h (pinfo::pinfo): Make sure that rd_proc_pipe is always cleared.
(pinfo::reattach): New function.
* sigproc.cc: Move pinfo.h earlier so that it can be used in sigproc.h.
(get_proc_lock): Don't bother with a lock during DLL initialization.
(proc_subproc): Handle PROC_REATTACH_CHILD.
(proc_terminate): Orphan children only when we are not an execed process or
when the pid is about to be occupied by a non-cygwin process.
(child_info_spawn::record_children): Define new function.
(child_info_spawn::reattach_children): Ditto.
* sigproc.h (procstuff): Define PROC_REATTACH_CHILD and renumber other
elements.
* spawn.cc (spawn_guts): Record any to-be-waited-for subprocesses if about to
exec a cygwin process.
* sigproc.cc (sig_send): Fix harmless transposition of fifth and six arguments
to DuplicateHandle().
(child_info::child_info): Ditto.
* globals.cc (hExeced): Make NO_COPY.
@
text
@a58 2
child_info_spawn NO_COPY *chExeced;

d220 1
a220 1
/* Utility for spawn_guts.  */
d272 1
d275 3
a277 2
spawn_guts (const char *prog_arg, const char *const *argv,
	    const char *const envp[], int mode, int __stdin, int __stdout)
d301 1
a301 1
  syscall_printf ("spawn_guts (%d, %.9500s)", mode, prog_arg);
a325 1
  child_info_spawn ch;
a333 1
  cygheap_exec_info *moreinfo;
d353 1
a353 1
    chtype = PROC_SPAWN;
d355 1
a355 1
    chtype = PROC_EXEC;
d385 1
a385 1
  if (!real_path.iscygexec () && cygheap->cwd.get_error ())
d389 2
a390 2
		    cygheap->cwd.get_error_desc ());
      set_errno (cygheap->cwd.get_error ());
d448 2
a449 2
  si.hStdInput = handle ((__stdin < 0 ? 0 : __stdin), false);
  si.hStdOutput = handle ((__stdout < 0 ? 1 : __stdout), true);
d480 1
a480 1
      if (cygheap->pid_handle)
d483 1
a483 1
				GetCurrentProcess (), &cygheap->pid_handle,
d485 1
a485 1
	ProtectHandleINH (cygheap->pid_handle);
d530 1
a530 1
  cygbench ("spawn-guts");
d533 1
a533 1
    cygheap->fdtab.set_file_pointers_for_exec ();
d543 4
a546 6
  ch.set (chtype, real_path.iscygexec ());
  ch.moreinfo = moreinfo;
  ch.__stdin = __stdin;
  ch.__stdout = __stdout;
  if (mode == _P_OVERLAY && ch.iscygwin ())
    ch.record_children ();
d548 2
a549 2
  si.lpReserved2 = (LPBYTE) &ch;
  si.cbReserved2 = sizeof (ch);
d551 1
a551 1
  /* Depends on ch.set call above.
d556 2
a557 2
      && (!ch.iscygwin () || mode != _P_OVERLAY
	  || cygheap->fdtab.need_fixup_before ()))
d567 1
a567 1
  if (!ch.iscygwin () && myself->ctty >= 0 && iscons_dev (myself->ctty)
d570 1
a570 1
  ch.refresh_cygheap ();
d577 1
a577 1
  cygheap->user.deimpersonate ();
d582 5
a586 5
  if (!cygheap->user.issetuid ()
      || (cygheap->user.saved_uid == cygheap->user.real_uid
	  && cygheap->user.saved_gid == cygheap->user.real_gid
	  && !cygheap->user.groups.issetgroups ()
	  && !cygheap->user.setuid_to_restricted))
d620 1
a620 1
      if (!cygheap->user.setuid_to_restricted
d626 1
a626 1
			 cygheap->user.sid ());
d633 1
a633 1
	  hwst = CreateWindowStationW (cygheap->user.get_windows_id (sid), 0,
d650 1
a650 1
      rc = CreateProcessAsUserW (cygheap->user.primary_token (),
d676 1
a676 1
    cygheap->user.reimpersonate ();
d697 1
a697 1
    strace.write_childpid (ch, pi.dwProcessId);
d701 2
a702 2
  if (cygheap->fdtab.need_fixup_before ())
    cygheap->fdtab.fixup_before_exec (pi.dwProcessId);
d710 1
a710 1
  syscall_printf ("%d = spawn_guts (%s, %.9500s)",
a719 1
      chExeced = &ch;	/* FIXME: there's a race here if a user sneaks in CTRL-C */
d745 1
a745 1
      if (!ch.iscygwin ())
d790 1
a790 1
      strace.write_childpid (ch, pi.dwProcessId);
d796 1
a796 1
  if ((mode == _P_DETACH || mode == _P_NOWAIT) && !ch.iscygwin ())
d799 1
a799 1
    synced = ch.sync (pi.dwProcessId, pi.hProcess, INFINITE);
d812 1
a812 1
	  if (!ch.proc_retry (pi.hProcess))
d828 1
a828 1
	      waitpid (myself->pid, &res, 0);
d831 1
d852 2
a857 1
#undef ch
d895 2
a896 2
      spawn_guts (path, argv, envp, mode);
      /* Errno should be set by spawn_guts.  */
d905 1
a905 1
      ret = spawn_guts (path, argv, envp, mode);
@


1.308
log
@	* hookapi.cc (hook_or_detect_cygwin): Take additional handle
	to a file mapping as parameter.  If this handle is not NULL,
	create another file mapping for the IAT.
	* spawn.cc (av::fixup): Only map the first 64K of an image and
	keep the mapping handle to use as argument to hook_or_detect_cygwin.
	* winsup.h (hook_or_detect_cygwin): Add mapping handle as default
	parameter in declaration.
@
text
@d549 2
@


1.307
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@d1062 1
d1073 1
a1073 1
	     Test for executablility and if so, just assume the file is
d1083 7
d1091 2
a1092 1
      HANDLE hm = CreateFileMapping (h, &sec_none_nih, PAGE_READONLY, 0, 0, NULL);
d1104 4
a1107 2
      buf = (char *) MapViewOfFile(hm, FILE_MAP_READ, 0, 0, 0);
      CloseHandle (hm);
d1109 4
a1112 1
	goto err;
d1119 1
d1129 2
a1130 1
	      real_path.set_cygexec (!!hook_or_detect_cygwin (buf, NULL, subsys));
d1134 1
d1138 1
@


1.306
log
@* fhandler.h (fhandler_console::tc_getpgid): New function.
* spawn.cc (spawn_guts): Add logic to put pure-windows processes "in the
background" when they are started that way.
@
text
@d37 1
a37 1
static suffix_info exe_suffixes[] =
d59 1
a59 1
child_info_spawn *chExeced;
@


1.305
log
@	Throughout, open console handles with sharing for reading and writing.
	* dcrt0.cc (insert_file): Open file with full sharing allowed.
	* hookapi.cc (find_first_notloaded_dll): Ditto.
	* spawn.cc (av::fixup): Ditto.
@
text
@d561 11
a571 1

@


1.304
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::old_title): Delete.
(child_info::~child_info_spawn): Remove recording of old_title.
* dcrt0.cc (title_buf): Delete.
(child_info_spawn::handle_spawn): Remove recording of old_title.
(dll_crt0_1): Get rid of all title handling.
(do_exit): Ditto.
* environ.cc (known): Delete strip_title and title.
* fhandler_console.cc (fhandler_console::write): Remove recording of old_title.
* globals.cc (exit_states): Remove ES_TITLE.
(display_title): Delete.
(strip_title_path): Delete.
(old_title): Delete.
* spawn.cc (spawn_guts): Remove old_title accommodation.
@
text
@d1055 1
a1055 1
			   &io, FILE_SHARE_READ | FILE_SHARE_WRITE,
@


1.303
log
@whitespace elimination
@
text
@a360 1
  moreinfo->old_title = NULL;
@


1.302
log
@* dll_init.cc (dll_list::find_by_modname): New function to search the dll list
for a module name only (no path).
(dll_list::alloc): Initialize newly-added members of struct dll.
(dll_list::append): New function to factor out the append operation
(used by dll_list::topsort).
(dll_list::populate_deps): New function to identify dll dependencies.
(dll_list::topsort): New function to sort the dll list topologically by
dependencies.
(dll_list::topsort_visit): New helper function for the above.
* dll_init.h (dll::ndeps): New class member.
(dll::deps): Ditto.
(dll::modname): Ditto.
(dll_list::find_by_modname): New function related to topsort.
(dll_list::populate_all_deps): Ditto.
(dll_list::populate_deps): Ditto.
(dll_list::topsort): Ditto.
(dll_list::topsort_visit): Ditto.
(dll_list::append): Ditto.
(pefile): New struct allowing simple introspection of dll images.
* fork.cc (fork): Topologically sort the dll list before forking
* child_info.h (CURR_CHILD_INFO_MAGIC): Refresh.
(child_info::refresh_cygheap): New function.
* spawn.cc (spawn_guts): Call refresh_cygheap before creating a new process to
ensure that cygheap_max is up-to-date.
* fork.cc (frok::parent): Ditto.
@
text
@d524 1
a524 1
      	{
@


1.301
log
@	* spawn.cc (spawn_guts): Only set PID_NOTCYGWIN in _P_OVERLAY mode.
	Drop flag if creating new process failed.
@
text
@d563 1
@


1.300
log
@	* devices.in: Throughout use slashes instead of backslashes in the
	native path of devices not backed by native NT devices.
	* devices.cc: Regenerate.
	* globals.cc (ro_u_pmem): Use correct case.
	(ro_u_globalroot): New R/O unicode string.
	* path.cc (path_conv::check): Fix incorrect handling of /proc/sys
	block devices if they are just visited due to a component check.
	(symlink_info::posixify): Fix typo in comment.
	(cygwin_conv_path): Use ro_u_globalroot instead of string constant.
	(fast_cwd_version): New shared variable to store FAST_CWD version
	used on the system.
	(find_fast_cwd_pointer): Rename from find_fast_cwd_pointers.  Don't
	set global fast_cwd_ptr pointer here.  Return pointer value instead.
	(find_fast_cwd): New function to set fast_cwd_ptr and fast_cwd_version.
	(cwdstuff::override_win32_cwd): Call find_fast_cwd from here.
	Check for fast_cwd_version to differ between old and new FAST_CWD
	structure.  Check old_cwd for NULL to avoid SEGV.  Don't set CWD if
	we have neitehr a valid fast_cwd_ptr, nor a valid CWD handle in the
	process parameter block.
	(cwdstuff::set): Create Win32 path taking /proc/sys paths into account.
	* spawn.cc (spawn_guts): Recode creating runpath.  Also take /proc/sys
	paths into account.  Drop special CWD handling when starting non-Cygwin
	processes.
@
text
@d571 1
a571 1
  if (!real_path.iscygexec ())
d683 1
@


1.299
log
@	* exec.cc: Include pinfo.h.
	* winf.h: Move definitions of _P_PATH_TYPE_EXEC and _P_MODE from here...
	* pinfo.h: ...to here.
	(_P_PATH_TYPE_EXEC): Redefine to be bigger than _P_SYSTEM.
	(_P_MODE): Redefine so as not to mask out _P_SYSTEM.
	* spawn.cc (spawnlp): Add _P_PATH_TYPE_EXEC flag in call to spawnve.
	(spawnlpe): Ditto.
	(spawnvp): Ditto.
@
text
@d493 35
a527 17
  runpath = null_app_name ? NULL : real_path.get_wide_win32_path (runpath);
  if (runpath)
    { /* If the executable path length is < MAX_PATH, make sure the long path
	 win32 prefix is removed from the path to make subsequent native Win32
	 child processes happy which are not long path aware. */
      USHORT len = real_path.get_nt_native_path ()->Length;
      if (len < (MAX_PATH + 4) * sizeof (WCHAR)
	  || (runpath[5] != L':'				/* UNC path */
	      && len < (MAX_PATH + 6) * sizeof (WCHAR)))
	{
	  PWCHAR r = runpath + 4;
	  if (r[1] != L':') /* UNC path */
	    *(r += 2) = L'\\';
	  if (!RtlIsDosDeviceName_U (r))
	    runpath = r;
	  else if (*r == L'\\')
	    *r = L'C';
a529 1

a570 2
  PWCHAR cwd;
  cwd = NULL;
d572 1
a572 5
    {
      myself->process_state |= PID_NOTCYGWIN;
      cygheap->cwd.cwd_lock.acquire ();
      cwd = cygheap->cwd.win32.Buffer;
    }
d587 1
a587 1
			   cwd,
d650 1
a650 1
			   cwd,
a664 3
  if (!real_path.iscygexec())
    cygheap->cwd.cwd_lock.release ();
    
@


1.298
log
@	* spawn.cc (av::fixup): Reenable #! handling for all exec functions.
	Return ENOEXEC in !p_type_exec case only for unrecognized files.
	Fix comment formatting.
@
text
@d972 2
a973 2
  return spawnve (mode, find_exec (file, buf), (char * const *) argv,
		  cur_environ ());
d996 2
a997 1
  return spawnve (mode, find_exec (file, buf), (char * const *) argv, envp);
d1010 2
a1011 1
  return spawnve (mode, find_exec (file, buf), argv, cur_environ ());
@


1.297
log
@	* exec.cc: Rearrange functions in alphabetical order.
	(_execve): Drop temporary define and drop export alias.
	(execl): Call spawnve.
	(execle): New function.
	(execlp): New function.
	(execv): Call spawnve.
	(execve): Drop converting NULL envp to emtpy envp.
	(execvp): Call spawnve.
	(execvpe): Drop converting NULL envp to emtpy envp.  Call spawnve.
	(fexecve): Call spawnve.
	* spawn.cc (spawnve): Convert NULL envp to emtpy envp.  Remove outdated
	comment.
	(spawnlp): Call spawnve.
	(spawnlpe): Ditto.
	(spawnvp): Ditto.
	(spawnvpe): Fix formatting.
@
text
@a1068 7
	      if (!p_type_exec)
		{
		  /* Not called from exec[lv]p.  Just leave. */
		  debug_printf ("zero length file.");
		  set_errno (ENOEXEC);
		  return -1;
		}
a1100 8
      if (!p_type_exec)
	{
	  /* Not called from exec[lv]p.  Don't try to treat as script. */
	  debug_printf ("%s is not a valid executable", real_path.get_win32 ());
	  set_errno (ENOEXEC);
	  return -1;
	}

d1116 5
a1120 4
		    /* Null terminate the initial command and step over any additional white
		       space.  If we've hit the end of the line, exit the loop.  Otherwise,
		       we've found the first argument. Position the current pointer on the
		       last known white space. */
d1135 8
@


1.296
log
@	* errno.cc (errmap): Add error codes for invalid binaries.
	* exec.cc (execvp): Call spawnve with _P_PATH_TYPE_EXEC flag
	from here.
	(execvpe): Ditto.
	* spawn.cc (spawn_guts): Filter _P_PATH_TYPE_EXEC from mode and
	store in p_type_exec.  Call av::fixup with addtional p_type_exec
	argument.
	(spawnve): Check for filtered mode.
	(spawnvpe): Add _P_PATH_TYPE_EXEC flag when calling spawnve.
	(av::fixup): Accept additional bool parameter p_type_exec.  Only check
	for script if p_type_exec is true.
	* winf.h (_P_PATH_TYPE_EXEC): Define.
	(_P_MODE): Define.
	(av::fixup): Declare with additional bool parameter.
@
text
@d857 2
d871 3
a876 2
      /* We do not pass _P_SEARCH_PATH here. execve doesn't search PATH.*/
      /* Just act as an exec if _P_OVERLAY set. */
d955 1
a955 1
spawnlp (int mode, const char *path, const char *arg0, ...)
d960 1
d972 2
a973 1
  return spawnvpe (mode, path, (char * const *) argv, cur_environ ());
d977 1
a977 1
spawnlpe (int mode, const char *path, const char *arg0, ...)
d983 1
d996 1
a996 1
  return spawnvpe (mode, path, (char * const *) argv, envp);
d1006 1
a1006 1
spawnvp (int mode, const char *path, const char * const *argv)
d1008 2
a1009 1
  return spawnvpe (mode, path, argv, cur_environ ());
d1014 1
a1014 1
					   const char * const *envp)
@


1.295
log
@* include/sys/cygwin.h (PID_NOTCYGWIN): New enum.
* spawn.cc (spawn_guts): Set a flag when a process is not a cygwin process.
* fhandler_tty.cc (fhandler_tty_slave::init): Remove previous change.  Try a
different method to determine when we should become the process group owner.
* signal.cc (kill0): Remove archaic code which dealt with never-set flag.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d283 5
d383 1
a383 1
  res = newargv.fixup (prog_arg, real_path, ext);
d869 1
a869 1
  switch (mode)
d1010 1
a1010 1
  return spawnve (mode, find_exec (file, buf), argv, envp);
d1014 2
a1015 1
av::fixup (const char *prog_arg, path_conv& real_path, const char *ext)
d1062 7
d1101 8
@


1.294
log
@	* cygheap.h (class cwdstuff): Make drive_length private.
	Add "error" member.
	(cwdstuff::get_error): New inline method.
	(cwdstuff::get_error_desc): Declare.
	(cwdstuff::set): Change first parameter to pointer to path_conv.
	* path.cc (chdir): Drop doit.  Align call to cwdstuff::set to
	new arguments.
	(cwdstuff::init): Only call cwdstuff::set if it's not already
	initialized.  Add comment.  Drop third parameter in call to
	cwdstuff::set.
	(cwdstuff::set): Partially rewrite.  Add lots of comments to explain
	everything.  Drop "doit" since it's not used anymore.  Always create
	new handle to CWD if not in a virtual path.  Drop PEB locking when
	reading PEB values in init phase.  Check for accessibility to set
	correct error code.  Drop Vista workaround.  Never write back into PEB.
	Set Win32 CWD to \\?\PIPE\ on init.  Simplify creation of win32 path.
	Set new error member to a meaningful value.
	(cwdstuff::get_error_desc): New method to generate error message
	from cwd error code.
	* spawn.cc (spawn_guts): Call cwdstuff::get_error_desc to create
	more meaningful error message when not being able to start native
	Win32 app due to CWD restrictions.  When starting native Win32 app,
	lock cwd and use in calls to CreateProcessW/CreateProcessAsUserW.
@
text
@d551 1
a551 1
  if (!real_path.iscygexec())
d553 1
d731 2
a732 1
      pinfo child (cygpid, PID_IN_USE);
@


1.293
log
@	* spawn.cc (spawn_guts): Reinstantiate a FIXME comment.
@
text
@d383 1
a383 3
  if (!real_path.iscygexec ()
      && (cygheap->cwd.drive_length == 0
	  || cygheap->cwd.win32.Length >= MAX_PATH * sizeof (WCHAR)))
d385 1
a385 1
      small_printf ("Error: Current working directory is a %s.\n"
d387 2
a388 5
		    cygheap->cwd.drive_length == 0
		    ? "virtual Cygwin directory"
		    : "path longer than allowed for a\n"
		      "Win32 working directory");
      set_errno (ENAMETOOLONG);
d549 8
d570 1
a570 1
			   NULL,
d633 1
a633 1
			   NULL,
d648 3
@


1.292
log
@	* exceptions.cc (dump_exception): Use %W instead of %s for printing
	progname.
	* fork.cc (frok::parent): Fix typos in debug output.
	* spawn.cc (spawn_guts): Copy wide Win32 filename into _pinfo::progname,
	rather than native NT name.
@
text
@d695 1
a695 1
      real_path.get_wide_win32_path (myself->progname);
@


1.291
log
@* environ.cc (regopt): Change the first argument to wide char string.
(environ_init): Accommodate change to the first argument of regopt.
* exception.cc (open_stackdumpfile): Accommodate change to the type of progname
in _pinfo.
* external.cc (fillout_pinfo): Ditto.
* fhandler_process.cc (format_process_winexename): Ditto.
(format_process_stat): Ditto.
* fork.cc (fork::parent): Ditto.
* pinfo.cc (pinfo_basic::pinfo_basic): Call GetModuleFileNameW instead of
GetModuleFileName.
(pinfo::thisproc): Accommodate change to the type of progname in _pinfo.
(pinfo_init): Ditto.
* pinfo.h (_pinfo): Change the type of progname to a wide char array.
* registry.h (reg_key::get_int): Change the first argument from constant point
to pointer to constant.
(reg_key::get_string): Ditto.  Change the last argument likewise.
* registry.cc (reg_key::get_int): Accommodate change to the declaration.
(reg_key::get_string): Ditto.
* strace.cc (strace::hello): Accommodate change to the type of progname in
_pinfo.
(strace::vsprntf): Ditto.
@
text
@d695 2
a696 2
      wcscpy (myself->progname, real_path.get_nt_native_path ()->Buffer); // FIXME: race?
      sigproc_printf ("new process name %S", myself->progname);
d736 1
a736 1
      wcscpy (child->progname, real_path.get_nt_native_path ()->Buffer);
@


1.290
log
@* spawn.cc (find_exec): Use the first detected errno when lookup fails.
@
text
@d695 2
a696 2
      strcpy (myself->progname, real_path.get_win32 ()); // FIXME: race?
      sigproc_printf ("new process name %s", myself->progname);
d736 1
a736 1
      strcpy (child->progname, real_path.get_win32 ());
@


1.289
log
@	* spawn.cc (find_exec): Enable finding paths in backslash notation,
	especially for the exec[vl]p functions.

	* path.cc (symlink_info::check): Disable returning directories with
	suffix appended here.
@
text
@d176 3
a178 1
      if ((suffix = perhaps_suffix (tmp, buf, err, opt)) != NULL)
@


1.288
log
@	* spawn.cc (spawn_guts): Only try to remove long path prefix from
	runpath if runpath is not NULL.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d114 1
a114 1
  bool has_slash = strchr (name, '/');
@


1.287
log
@	* exec.cc (execvp): Call find_exec with FE_NNF flag to enforce
	a NULL return when executable isn't found in $PATH.  Convert NULL
	to "".
	(execvpe): Ditto.
	* spawn.cc (spawn_guts): Return with EFAULT if prog_arg is NULL.
	Return with ENOENT if prog_arg is empty string.  Add a comment.
@
text
@d492 18
a509 17
  { /* If the executable path length is < MAX_PATH, make sure the long path
       win32 prefix is removed from the path to make subsequent native Win32
       child processes happy which are not long path aware. */
    USHORT len = real_path.get_nt_native_path ()->Length;
    if (len < (MAX_PATH + 4) * sizeof (WCHAR)
    	|| (runpath[5] != L':'				/* UNC path */
	    && len < (MAX_PATH + 6) * sizeof (WCHAR)))
      {
	PWCHAR r = runpath + 4;
	if (r[1] != L':') /* UNC path */
	  *(r += 2) = L'\\';
	if (!RtlIsDosDeviceName_U (r))
	  runpath = r;
	else if (*r == L'\\')
	  *r = L'C';
      }
  }
@


1.286
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d284 7
a290 1
      set_errno (EINVAL);
d296 1
@


1.285
log
@	Reintegrate socket duplication via WSADuplicateSocket/WSASocket.
	* autoload.cc (WSADuplicateSocketW): Define.
	(WSASocketW): Define.
	* dtable.cc (dtable::release): Call dec_need_fixup_before if necessary.
	(dtable::fixup_before_fork): New function.
	(dtable::fixup_before_exec): New function.
	* dtable.h (class dtable): Add member cnt_need_fixup_before.  Add
	declarations for above new functions.
	(dtable::dec_need_fixup_before): New inline method.
	(dtable::inc_need_fixup_before): New inline method.
	(dtable::need_fixup_before): New inline method.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): New virtual
	method.
	(fhandler_base::need_fixup_before): New virtual method.
	(class fhandler_socket): Add member prot_info_ptr.
	(fhandler_socket::init_fixup_before): Declare.
	(fhandler_socket::need_fixup_before): New inline method.
	(fhandler_socket::fixup_before_fork_exec): Declare.
	(fhandler_socket::fixup_after_exec): Declare.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	prot_info_ptr to NULL.
	(fhandler_socket::~fhandler_socket): Free prot_info_ptr conditionally.
	(fhandler_socket::init_fixup_before): New method.
	(fhandler_socket::fixup_before_fork_exec): Ditto.
	(fhandler_socket::fixup_after_fork): Use WSASocketW to duplicate
	socket if necessary.
	(fhandler_socket::fixup_after_exec): New method.
	(fhandler_socket::dup): Use fixup_before_fork_exec/fixup_after_fork
	to duplicate socket if necessary.
	* fork.cc (frok::parent): Start child suspended if some fhandler
	needs fixup before fork.  If so, call dtable::fixup_before_fork after
	CreateProcess and resume child.
	* net.cc (fdsock): Try to find out if socket needs fixup before and
	initialize socket accordingly.  Add HUGE comment to explain what happens
	and why.
	* spawn.cc (spawn_guts): Start child suspended if some fhandler needs
	fixup before exec.  If so, call dtable::fixup_before_exec after
	CreateProcess.
@
text
@d423 3
a425 3
	  !DuplicateHandle (hMainProc, myself.shared_handle (), hMainProc,
			    &moreinfo->myself_pinfo, 0, TRUE,
			    DUPLICATE_SAME_ACCESS))
d448 1
a448 1
  c_flags = GetPriorityClass (hMainProc);
d476 3
a478 3
      else if (DuplicateHandle (hMainProc, hMainProc, hMainProc,
      				&cygheap->pid_handle, PROCESS_QUERY_INFORMATION,
				TRUE, 0))
d732 2
a733 2
      DuplicateHandle (hMainProc, child.shared_handle (), pi.hProcess,
			      NULL, 0, 0, DUPLICATE_SAME_ACCESS);
@


1.284
log
@	* spawn.cc (dll_suffixes): Disable.  Explain why.
	(perhaps_suffix): Use stat_suffixes instead of dll_suffixes.
@
text
@d532 2
a533 1
      && (!ch.iscygwin () || mode != _P_OVERLAY))
d660 5
@


1.283
log
@	* spawn.cc (av::fixup): Treat non-readable, but executable files as
	Cygwin executables.
@
text
@d45 5
d57 1
d75 1
a75 1
	     (opt & FE_DLL) ? dll_suffixes : exe_suffixes);
@


1.282
log
@	* include/sys/cygwin.h: Add new cygwin_getinfo_type
	CW_SET_EXTERNAL_TOKEN.
	Add new enum CW_TOKEN_IMPERSONATION, CW_TOKEN_RESTRICTED.
	* cygheap.h (cyguser): New flags ext_token_is_restricted,
	curr_token_is_restricted and setuid_to_restricted.
	* external.cc (cygwin_internal): Add CW_SET_EXTERNAL_TOKEN.
	* sec_auth.cc (set_imp_token): New function.
	(cygwin_set_impersonation_token): Call set_imp_token ().
	* security.h (set_imp_token): New prototype.
	* spawn.cc (spawn_guts): Use CreateProcessAsUserW if restricted token
	was enabled by setuid().  Do not create new window station in this case.
	* syscalls.cc (seteuid32): Add handling of restricted external tokens.
	Set HANDLE_FLAG_INHERIT for primary token.
	(setuid32): Set setuid_to_restricted flag.
	* uinfo.cc (uinfo_init): Do not reimpersonate if restricted token was
	enabled by setuid ().  Initialize user.*_restricted flags.
@
text
@d1006 12
a1017 1
	goto err;
@


1.281
log
@Fix faccessat(,0) and access() semantics.

* fhandler.h (fhandler_base::fhaccess): Add parameter.
* security.h (check_file_access, check_registry_access): Likewise.
* security.cc (check_file_access, check_registry_access)
(check_access): Implement new parameter.
* fhandler.cc (fhandler_base::fhaccess): Likewise.
(device_access_denied): Update caller.
* syscalls.cc (access, faccessat): Update callers.
* spawn.cc (find_exec, fixup): Likewise.
@
text
@d540 2
a541 1
	  && !cygheap->user.groups.issetgroups ()))
d575 2
a576 1
      if (wcscasecmp (wstname, L"WinSta0") != 0)
@


1.280
log
@	* spawn.cc (av::fixup): Check shell scripts for executability only on
	filesystems/mounts supporting real permissions.
@
text
@d172 1
a172 1
	  if (buf.has_acls () && check_file_access (buf, X_OK))
d1086 2
a1087 1
      if (real_path.has_acls () && check_file_access (real_path, X_OK) < 0)
@


1.279
log
@* cygheap_malloc.h: New file.
* cygheap.h: Remove stuff now included in cygheap_malloc.h and include that
file.  Make cygheap_init a standard c++ function.  Remove unneeded child_info
declaration.
* path.h: Include cygheap_malloc.h.  Remove extra cstrdup declaration.
(path_conv): Reorganize to group variables together.
(path_conv::path): Make const char *.
(path_conv::known_suffix): Ditto.
(path_conv::normalized_path): Ditto.
(path_conv::path_conv): Reorganize initializers to reflect new element
ordering.
(path_conv::get_win32): Change return value to const char *.
(path_conv::set_path): Move back here from spawn.cc.
(parh_conv::modifiable_path): New function.
* path.cc (path_conv::add_ext_from_sym): Accommodate const'ness of
known_suffixes.
(path_conv::set_normalized_path): Ditto for normalized_path.
(path_conv::check): Use modifiable_path whereever we need to modify the path
element.  Use set_path to set the path.
(path_conv::~path_conv): Accommodate new const'ness.
* spawn.cc (perhaps_suffix): Declare ext as const since that's what is being
returned.
(path_conv::set_path): Move back to path.h.
* winf.f (linebuf): Perform minor cleanup.
(linebuf::fromargv): Change second parameter to const.
* winf.cc (linebuf::fromargv): Ditto.
@
text
@d1086 1
a1086 1
      if (check_file_access (real_path, X_OK) < 0)
@


1.278
log
@* path.h (path_conv::set_path): Change return value.
* spawn.cc (path_conv::set_path): Return newly set value.
(find_exec): Set retval to newly set value when calling set_path.
@
text
@d64 1
a64 1
  char *ext;
a89 8
inline char *
path_conv::set_path (const char *p)
{
  if (path)
    cfree (path);
  return path = cstrdup (p);
}

@


1.277
log
@* spawn.cc (find_exec): Fix one more path where retval was not set.
@
text
@d90 1
a90 1
inline void
d95 1
a95 1
  path = cstrdup (p);
d213 1
a213 1
    buf.set_path (posix);
d405 1
a405 1
      strcpy (real_path.get_win32 (), argv[0]);
@


1.276
log
@* spawn.cc (find_exec): Stop relying on the ability to set retval to a fixed
path_conv buffer and set it on the fly instead.
@
text
@d191 1
@


1.275
log
@	* path.h (class path_conv): Convert path from char array to char *.
	Initialize to NULL in constructors.  Drop normalized_path_size member.
	(path_conv::size): Remove.
	(path_conv::operator =): Always copy with sizeof path_conv.  Always
	duplicate path on cygheap.
	(path_conv::set_path): Move implementation to spawn.cc.
	* path.cc (path_conv::set_normalized_path): Always allocate
	normalized_path on cygheap.
	(path_conv::check): Don't work on path, rather allocate THIS_path in
	TLS and use it throughout.  When finished, allocate path on cygheap
	and copy over.  Defer tacking on extension after having copied path.
	* spawn.cc (path_conv::set_path): Implement here.
@
text
@d112 1
a112 1
  const char *retval = buf.get_win32 ();
d132 1
d202 2
a203 2
  else if (opt & FE_NATIVE)
    buf.check (name);
d205 4
a208 1
    retval = name;
@


1.274
log
@* autoload.cc (SetParent): Add new import.
* fhandler.h (fhandler_console::create_invisible_console): Declare new
function.
(create_invisible_console_workaround): Ditto.
* fhandler_console.cc (fhandler_console::create_invisible_console): Define new
function.
(create_invisible_console_workaround): Ditto.  Add too much code to deal with
broken Windows 7.  Use a helper app to start an invisible console window.
(fhandler_console::need_invisible): Reorganize to use helper functions to
create invisible console.
* spawn.cc (spawn_guts): Avoid zeroing already zeroed fields in si.
@
text
@d90 8
@


1.273
log
@	* spawn.cc (spawn_guts): Don't run additional check for Win32
	incompatible CWD if newargv.fixup bailed out already.
	(av::fixup): Check shell scripts for executability.
@
text
@a427 2
  si.lpReserved = NULL;
  si.lpDesktop = NULL;
@


1.272
log
@* net.cc: Undefine NOERROR and DELETE to avoid compiler warnings.
* shared_info.h (CURR_SHARED_MAGIC): Update.
* spawn.cc (spawn_guts): Avoid copying one line command line argument if it
hasn't been filled out.
@
text
@d360 3
a377 3
  if (res)
    goto out;

d1081 5
@


1.271
log
@Add DESTDIR functionality to Makefile.in's.
@
text
@d420 4
a423 1
  sys_mbstowcs (wone_line, one_line.ix + 1, one_line.buf);
@


1.270
log
@* include/sys/cygwin.h (CW_SETERRNO): Define.
* external.cc (CW_SETERRNO): Implement.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 192 to reflect the
above change.
* path.cc (path_prefix_p): Treat X: as equivalent to x:.
* mkglobals_h: Remove unneeded #define.
* spawn.cc (spawn_guts): Avoid overly wordy initialization to zero.
@
text
@d515 1
a515 1
  /* Depends on ch.set call above!
@


1.269
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d313 1
a313 2
  STARTUPINFOW si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
		     NULL, NULL, NULL};
@


1.268
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
a52 1
HANDLE hExeced;
d262 1
a262 1
int __stdcall
@


1.267
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d361 1
a361 1
  
d483 1
a483 1
        PWCHAR r = runpath + 4;
@


1.266
log
@	* spawn.cc (spawn_guts): Check constructed short pathname for being
	a DOS device name and fall back to long path name, if so.
@
text
@d977 1
a977 1
  if (exeext && real_path.iscygexec () || ascii_strcasematch (ext, ".bat"))
@


1.265
log
@	* spawn.cc (spawn_guts): Fix previous patch for UNC paths.
@
text
@d486 4
a489 1
	runpath = r;
@


1.264
log
@	* spawn.cc (spawn_guts): Remove long path prefix from win32 path
	before calling CreateProcess if path length is < MAX_PATH.
@
text
@d485 1
a485 1
	  r += 2;
@


1.263
log
@	Throughout drop allow_ntsec and allow_smbntsec handling.
	* environ.cc (set_ntsec): Remove.
	(set_smbntsec): Remove.
	(known): Remove ntsec and smbntsec options.
	* external.cc (check_ntsec): Return true if no filename is given.
	* mount.cc (oopts): Add "acl" and "noacl" options.  Set MOUNT_NOACL
	flag accordingly.
	(fillout_mntent): Handle MOUNT_NOACL flag.
	* path.h (enum path_types): Add PATH_NOACL.
	* security.cc (allow_ntsec): Remove.
	(allow_smbntsec): Remove.
	* security.h (allow_ntsec): Drop declaration.
	(allow_smbntsec): Drop declaration.
	* include/sys/mount.h (MOUNT_NOACL): Define.
@
text
@d475 14
@


1.262
log
@* spawn.cc (spawn_guts): Reinstate call to fhandler_console::need_invisible
since it is required to prevent console flashing.
@
text
@d172 1
a172 1
	  if (buf.has_acls () && allow_ntsec && check_file_access (buf, X_OK))
@


1.261
log
@	* fhandler.h (set_console_state_for_spawn): Drop declaration.
	* fhandler_console.cc (set_console_state_for_spawn): Remove.
	(fhandler_console::open): Set console state last.  Don't set
	ENABLE_PROCESSED_INPUT flag.
	* spawn.cc (spawn_guts): Drop call to set_console_state_for_spawn.
@
text
@d444 2
@


1.260
log
@	* dtable.cc (dtable::release): Drop fixup_before handling.
	(dtable::fixup_before_fork): Remove.
	(dtable::fixup_before_exec): Remove.
	* dtable.h (class dtable): Remove cnt_need_fixup_before member.
	(dtable::dtable): Accommodate above change.
	(dtable::dec_need_fixup_before): Remove.
	(dtable::inc_need_fixup_before): Remove.
	(dtable::need_fixup_before): Remove.
	(dtable::fixup_before_exec): Remove declaration.
	(dtable::fixup_before_fork): Ditto.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): Remove.
	(fhandler_base::need_fixup_before): Remove.
	* fork.cc (frok::parent): Drop fixup_before handling.
	* spawn.cc (spawn_guts): Ditto.
@
text
@a443 2
  else
    set_console_state_for_spawn (real_path.iscygexec ());
@


1.259
log
@	* dcrt0.cc (dll_crt0_0): Set SEM_NOGPFAULTERRORBOX error mode, too,
	to accommodate Vista/Longhorn.
	* spawn.cc (spawn_guts): Move check for CREATE_SUSPENDED condition
	after the call to ch.set() since it depends on it.
@
text
@d505 1
a505 2
      && (!ch.iscygwin () || mode != _P_OVERLAY
	  || cygheap->fdtab.need_fixup_before ()))
a629 5
  /* Fixup the parent data structures if needed and resume the child's
     main thread. */
  if (cygheap->fdtab.need_fixup_before ())
    cygheap->fdtab.fixup_before_exec (pi.dwProcessId);

@


1.258
log
@Remove unneeded header files from source files throughout.
@
text
@a473 9
  /* Some file types (currently only sockets) need extra effort in the parent
     after CreateProcess and before copying the datastructures to the child.
     So we have to start the child in suspend state, unfortunately, to avoid
     a race condition. */
  if (!newargv.win16_exe
      && (!ch.iscygwin () || mode != _P_OVERLAY
	  || cygheap->fdtab.need_fixup_before ()))
    c_flags |= CREATE_SUSPENDED;

d500 9
@


1.257
log
@* hookapi.cc (find_first_notloaded_dll): New function.
* pinfo.cc (status_exit): New function.  Issue message when dll not found.  Use
find_first_notloaded_dll to find a nonexistent dll.
(pinfo::maybe_set_exit_code_from_windows): Call status_exit when exit code >=
0xc0000000UL.
* sigproc.cc (child_info::proc_retry): Return exit code when
STATUS_DLL_NOT_FOUND.
* spawn.cc (spawn_guts): Minor cleanup.
* syscalls.cc (close_all_files): Don't actually close stderr filehandle.  Just
make it noninheritable.
* winsup.h (find_first_notloaded_dll): Declare new function.
* ntdll.h: Add several missing NTSTATUS defines.
@
text
@a13 1
#include <stdarg.h>
a16 1
#include <limits.h>
a29 1
#include "shared_info.h"
a30 1
#include "registry.h"
@


1.256
log
@	* winsup.h (NT_MAX_PATH): Revert ill-advised change to 32767.
	Accommodate change throughout.

	* cygwin.din (cygwin_conv_path): Export.
	(cygwin_conv_path_list): Export.
	(cygwin_create_path): Export.
	* dcrt0.cc (dll_crt0_1): Use cygwin_conv_path.
	* dtable.cc (handle_to_fn): Ditto.  Don't expect UNICODE_STRING being
	0-terminated.
	* environ.cc (env_plist_to_posix): New helper function.
	(env_plist_to_win32): Ditto.
	(env_path_to_posix): Ditto.
	(env_path_to_win32): Ditto.
	(return_MAX_PATH): Remove.
	(conv_envvars): Use new helper functions.  Drop removed members.
	(win_env::operator =): Accommodate removal of path length functions.
	(win_env::add_cache): Accommodate new env helper function API.
	(posify): Ditto.
	* environ.h (struct win_env): Ditto. Remove path length function
	pointers since they are unused.
	* path.cc (warn_msdos): Use cygwin_conv_path.
	(getfileattr): Use new tmp_pathbuf::u_get method.
	(fillout_mntent): Ditto.
	(symlink_info::check): Ditto.
	(path_conv::check): Use sizeof (WCHAR) instead of constant 2.
	(symlink_info::check_reparse_point): Ditto.
	(conv_path_list): Get max size of target string as argument.  Call
	cygwin_conv_path as helper function.
	(cygwin_conv_path): New function.
	(cygwin_create_path): New function.
	(cygwin_conv_to_win32_path): Just call cygwin_conv_path with size set
	to MAX_PATH.
	(cygwin_conv_to_full_win32_path): Ditto.
	(cygwin_conv_to_posix_path): Ditto.
	(cygwin_conv_to_full_posix_path): Ditto.
	(conv_path_list_buf_size): Add FIXME comment.
	(env_PATH_to_posix): Rename from env_win32_to_posix_path_list.
	Add size argument as required for env helper functions.
	(cygwin_win32_to_posix_path_list): Call conv_path_list with size set to
	MAX_PATH.
	(cygwin_posix_to_win32_path_list): Ditto.
	(cygwin_conv_path_list): New function.
	(cwdstuff::get): Fix length argument in call to sys_wcstombs.
	* spawn.cc (find_exec): Use cygwin_conv_path_list.
	* tls_pbuf.h (tmp_pathbuf::u_get: New method.
	* uinfo.cc (cygheap_user::ontherange): Allocate temporary path buffers
	using tmp_pathbuf.  Use cygwin_conv_path.
	* winf.cc (av::unshift): Use cygwin_conv_path.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h: Comment out old cygwin32_XXX API.
	Mark old path handling API as deprecated.
	(cygwin_conv_path_t): Typedef.  Define values.
	(cygwin_conv_path): Declare.
	(cygwin_create_path): Declare.
	(cygwin_conv_path_list): Declare.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d268 1
a268 1
spawn_guts (const char * prog_arg, const char *const *argv,
d748 1
a748 2
	  DWORD res = ch.proc_retry (pi.hProcess);
	  if (!res)
@


1.255
log
@	* spawn.cc (find_exec): Use tmp_pathbuf to allocate path buffer.
@
text
@d141 3
a143 3
      int n = cygwin_posix_to_win32_path_list_buf_size (mywinenv);
      char *s = (char *) alloca (n + 1);
      if (cygwin_posix_to_win32_path_list (mywinenv, s))
@


1.254
log
@	* path.cc (cwdstuff::set): Make sure drive_length is 0 for virtual
	paths.  Add comments.
	* spawn.cc (spawn_guts): Don't allow to start a native Win32 application
	from a long path or a virtual path.  Print an error message to stderr.
@
text
@d110 2
a111 1
  char tmp[CYG_MAX_PATH];
@


1.253
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d364 15
@


1.252
log
@	* child_info.h (~child_info_spawn): Check moreinfo->myself_pinfo for
	NULL before closing.
	* spawn.cc (spawn_guts): Don't close moreinfo->myself_pinfo explicitely
	in case of failing CloseProcess.

	* fhandler.cc (fhandler_base::open_): Return EISDIR when trying to
	create a directory.
	* path.cc (path_conv::check): If input path had a trailing dir
	separator, tack it on to the native path if directory doesn't exist.
@
text
@d21 1
d37 1
d306 1
a306 1
  char *envblock = NULL;
d310 2
a311 1
  const char *runpath;
d317 2
a318 2
  STARTUPINFO si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
		    NULL, NULL, NULL};
d339 2
a340 1
  moreinfo = (cygheap_exec_info *) ccalloc_abort (HEAP_1_EXEC, 1, sizeof (cygheap_exec_info));
d389 2
a390 1
      else if (!one_line.fromargv (newargv, real_path.get_win32 (), real_path.iscygexec ()))
d403 2
a404 2
			    &moreinfo->myself_pinfo, 0,
			    TRUE, DUPLICATE_SAME_ACCESS))
d409 2
d428 1
a428 1
  c_flags |= CREATE_SEPARATE_WOW_VDM;
d454 3
a456 2
      else if (DuplicateHandle (hMainProc, hMainProc, hMainProc, &cygheap->pid_handle,
				PROCESS_QUERY_INFORMATION, TRUE, 0))
d467 2
a468 1
      && (!ch.iscygwin () || mode != _P_OVERLAY || cygheap->fdtab.need_fixup_before ()))
d471 1
a471 1
  runpath = null_app_name ? NULL : real_path.get_win32 ();
d473 2
a474 1
  syscall_printf ("null_app_name %d (%s, %.9500s)", null_app_name, runpath, one_line.buf);
d481 2
a482 1
  moreinfo->envp = build_env (envp, envblock, moreinfo->envc, real_path.iscygexec ());
d510 10
a519 10
      rc = CreateProcess (runpath,	/* image name - with full path */
			  one_line.buf,	/* what was passed to exec */
			  &sec_none_nih,/* process security attrs */
			  &sec_none_nih,/* thread security attrs */
			  TRUE,		/* inherit handles from parent */
			  c_flags,
			  envblock,	/* environment */
			  NULL,
			  &si,
			  &pi);
d527 1
a527 1
      char wstname[1024] = { '\0' };
d535 1
a535 1
      GetUserObjectInformation (hwst_orig, UOI_NAME, wstname, 1024, &n);
d542 1
a542 1
      if (!ascii_strcasematch (wstname, "WinSta0"))
d544 1
a544 1
	  char sid[128];
d554 1
a554 1
	  hwst = CreateWindowStationA (cygheap->user.get_windows_id (sid), 0,
d560 1
a560 1
	  else if (!(hdsk = CreateDesktopA ("Default", NULL, NULL, 0,
d565 1
a565 1
	      stpcpy (stpcpy (wstname, sid), "\\Default");
d567 1
a567 1
	      debug_printf ("Desktop: %s", si.lpDesktop);
d571 11
a581 11
      rc = CreateProcessAsUser (cygheap->user.primary_token (),
		       runpath,		/* image name - with full path */
		       one_line.buf,	/* what was passed to exec */
		       &sec_none_nih,   /* process security attrs */
		       &sec_none_nih,   /* thread security attrs */
		       TRUE,		/* inherit handles from parent */
		       c_flags,
		       envblock,	/* environment */
		       NULL,
		       &si,
		       &pi);
d966 12
a977 6

      HANDLE h = CreateFile (real_path.get_win32 (), GENERIC_READ,
			       FILE_SHARE_READ | FILE_SHARE_WRITE,
			       &sec_none_nih, OPEN_EXISTING,
			       FILE_ATTRIBUTE_NORMAL, 0);
      if (h == INVALID_HANDLE_VALUE)
d981 1
a981 1
      CloseHandle (h);
@


1.251
log
@	* string.h: Re-enable inline strcasematch and strncasematch
	implementations and rename to ascii_strcasematch/ascii_strncasematch.
	* dcrt0.cc: Replace str[n]casematch with ascii_str[n]casematch where
	applicable.
	* environ.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
	* winf.cc: Ditto.
@
text
@a601 2
      if (moreinfo->myself_pinfo)
	CloseHandle (moreinfo->myself_pinfo);
@


1.250
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Reenable.  Fix
	comment.
	* spawn.cc (spawn_guts): Call cygheap->fdtab.set_file_pointers_for_exec
	only for non-Cygwin processes.
@
text
@d531 1
a531 1
      if (!strcasematch (wstname, "WinSta0"))
d945 2
a946 2
  bool exeext = strcasematch (ext, ".exe");
  if (exeext && real_path.iscygexec () || strcasematch (ext, ".bat"))
d949 2
a950 2
      && (strcasematch (p, ".bat") || strcasematch (p, ".cmd")
	  || strcasematch (p, ".btm")))
d1037 1
a1037 1
	  if (strcasematch (ext, ".com"))
@


1.249
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d468 2
a469 1
  cygheap->fdtab.set_file_pointers_for_exec ();
@


1.248
log
@	* spawn.cc (spawn_guts): Fix typo in comment.
@
text
@d336 1
a336 1
  moreinfo = (cygheap_exec_info *) ccalloc (HEAP_1_EXEC, 1, sizeof (cygheap_exec_info));
@


1.247
log
@	* autoload.cc (CloseDesktop): Define.
	(CreateDesktopA): Define.
	(SetThreadDesktop): Define.
	* spawn.cc (spawn_guts): When starting a process under another user
	account, don't open up permissions on current window station and
	desktop.  Instead, if not in interactive session, create a new per-user
	window station plus default desktop and use that for the child process.
@
text
@d536 1
a536 1
	  /* We're create a window station per user, not per logon session.
@


1.246
log
@	* path.h (path_conv::operator char *): Delete.
	(path_conv::operator const char *): Delete.
	* dlfcn.cc: Throughout, replace path_conv::operator char * and
	path_conv::operator const char * by call to path_conv::get_win32
	for easier transition to UNICODE_PATHs.
	* fhandler_socket.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d515 4
a518 4
      /* allow the child to interact with our window station/desktop */
      HANDLE hwst, hdsk;
      SECURITY_INFORMATION dsi = DACL_SECURITY_INFORMATION;
      NTSTATUS status;
a519 2
      char wstname[1024];
      char dskname[1024];
d521 37
a557 11
      hwst = GetProcessWindowStation ();
      if ((status = NtSetSecurityObject (hwst, dsi, get_null_sd ())))
	system_printf ("NtSetSecurityObject, %lx", status);
      GetUserObjectInformation (hwst, UOI_NAME, wstname, 1024, &n);
      hdsk = GetThreadDesktop (GetCurrentThreadId ());
      if ((status = NtSetSecurityObject (hdsk, dsi, get_null_sd ())))
	system_printf ("NtSetSecurityObject, %lx", status);
      GetUserObjectInformation (hdsk, UOI_NAME, dskname, 1024, &n);
      strcat (wstname, "\\");
      strcat (wstname, dskname);
      si.lpDesktop = wstname;
d570 10
@


1.245
log
@	* autoload.cc (SetUserObjectSecurity): Drop.
	* pinfo.cc (pinfo::set_acl): Use NtSetSecurityObject instead of
	SetKernelObjectSecurity.
	* spawn.cc (spawn_guts): Use NtSetSecurityObject instead of
	SetUserObjectSecurity.
	* uinfo.cc (cygheap_user::init): Ditto.
@
text
@d85 1
a85 1
    ext = (char *) buf + (buf.known_suffix - buf.get_win32 ());
d87 1
a87 1
    ext = strchr (buf, '\0');
d89 1
a89 1
  debug_printf ("buf %s, suffix found '%s'", (char *) buf, ext);
d107 1
a107 1
  const char *retval = buf;
d203 1
a203 1
  debug_printf ("%s = find_exec (%s)", (char *) buf, name);
d205 1
a205 1
    *known_suffix = suffix ?: strchr (buf, '\0');
d370 1
a370 1
	one_line.add (real_path);
d378 1
a378 1
      strcpy (real_path, argv[0]);
d385 1
a385 1
      else if (!one_line.fromargv (newargv, real_path, real_path.iscygexec ()))
d462 1
a462 1
  runpath = null_app_name ? NULL : (const char *) real_path;
d600 1
a600 1
      strcpy (myself->progname, real_path); // FIXME: race?
d641 1
a641 1
      strcpy (child->progname, real_path);
d913 1
a913 1
  if (!*ext && ((p = ext - 4) > (char *) real_path)
d923 1
a923 1
      HANDLE h = CreateFile (real_path, GENERIC_READ,
d969 1
a969 1
      debug_printf ("%s is possibly a script", (char *) real_path);
d1022 1
a1022 1
      unshift (real_path, 1);
@


1.244
log
@* spawn.cc (spawn_guts): Start pure-windows processes in a suspended state to
avoid potential DuplicateHandle problems.
@
text
@d37 1
d518 1
d524 2
a525 1
      SetUserObjectSecurity (hwst, &dsi, get_null_sd ());
d528 2
a529 1
      SetUserObjectSecurity (hdsk, &dsi, get_null_sd ());
@


1.243
log
@	* fhandler_console.cc (fhandler_console::need_invisible): Drop
	pty_needs_alloc_console check.
	* spawn.cc (spawn_guts): Ditto.
	(av::fixup): Remove setting iscui.
	* syscalls.cc (rename): Drop has_move_file_ex checks.  Remove 9x
	specific code.
	* wincap.cc: Remove has_move_file_ex and pty_needs_alloc_console
	throughout.
	* wincap.h: Ditto.
@
text
@d458 1
a458 1
      && (mode != _P_OVERLAY || cygheap->fdtab.need_fixup_before ()))
d612 3
a614 5
	    {
	      myself->sync_proc_pipe ();	/* Make sure that we own wr_proc_pipe
						   just in case we've been previously
						   execed. */
	    }
@


1.242
log
@	* exceptions.cc (dummy_ctrl_c_handler): Remove.
	(init_console_handler): Drop has_null_console_handler_routine checks.
	* fhandler_raw.cc (fhandler_dev_raw::open): Drop has_raw_devices check.
	* fhandler_serial.cc (fhandler_serial::open): Drop
	.supports_reading_modem_output_lines check.
	* miscfuncs.cc (low_priority_sleep): Drop has_switch_to_thread check.
	* shared.cc (open_shared): Drop needs_memory_protection checks.
	* spawn.cc (spawn_guts): Drop start_proc_suspended check.
	* uname.cc (uname): Drop has_valid_processorlevel check.
	* wincap.cc: Remove has_raw_devices, has_valid_processorlevel,
	supports_reading_modem_output_lines, needs_memory_protection,
	has_switch_to_thread, start_proc_suspended and
	has_null_console_handler_routine throughout.
	* wincap.h: Ditto.
@
text
@a416 5
  if (!wincap.pty_needs_alloc_console () && newargv.iscui && myself->ctty == -1)
    {
      si.dwFlags |= STARTF_USESHOWWINDOW;
      si.wShowWindow = SW_HIDE;
    }
a962 1
	    iscui = subsys == IMAGE_SUBSYSTEM_WINDOWS_CUI;
@


1.241
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d463 1
a463 2
      && (wincap.start_proc_suspended () || mode != _P_OVERLAY
	  || cygheap->fdtab.need_fixup_before ()))
@


1.240
log
@	* spawn.cc (spawn_guts): Don't set cwd for non-Cygwin child processes
	on NT to allow starting them in virtual directories.
@
text
@d510 1
a510 2
			  wincap.is_winnt () || real_path.iscygexec () ?
			  NULL : cygheap->cwd.win32,
d545 1
a545 2
		       wincap.is_winnt () || real_path.iscygexec () ?
		       NULL : cygheap->cwd.win32,
@


1.239
log
@	* ChangeLog: Happy New Year.
	* ChangeLog-2006: Move 2006 changelogs here.
	* spawn.cc: Bump copyright.
@
text
@d510 2
a511 1
			  real_path.iscygexec () ? NULL : cygheap->cwd.win32,
d546 2
a547 1
		       real_path.iscygexec () ? NULL : cygheap->cwd.win32,
@


1.238
log
@* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
_P_NOWAIT process.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
@


1.237
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d676 4
a679 1
  synced = ch.sync (pi.dwProcessId, pi.hProcess, INFINITE);
@


1.236
log
@	* dcrt0.cc (get_cygwin_startup_info): Change zeros to DWORD array.
	Expect first DWORD in child_info struct being set to non-zero if
	wincap.needs_count_in_si_lpres2 is set.  Add comment to explain why.
	* fork.cc (frok::parent): Set ch.zero[0] to a sensible count value
	if wincap.needs_count_in_si_lpres2 is set.
	* spawn.cc (spawn_guts): Ditto.  Add filler bytes after ch on stack
	to accomodate needs_count_in_si_lpres2.
	* wincap.h: Define needs_count_in_si_lpres2 throughout.
	* wincap.cc: Ditto.
@
text
@d213 1
a213 1
handle (int fd, int direction)
d222 1
a222 1
  else if (direction == 0)
d226 1
d263 1
a263 1
static int __stdcall
d265 1
a265 1
	    const char *const envp[], int mode)
d302 1
a302 8
  /* Allocate slightly bigger for call to CreateProcess to accomodate
     needs_count_in_si_lpres2. */
  struct {
    child_info_spawn ch;
    char filler[4];
  } _ch;
#define ch	_ch.ch

d313 2
a314 1
  STARTUPINFO si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL};
d409 2
d412 4
a415 3
  si.hStdInput = handle (0, 0); /* Get input handle */
  si.hStdOutput = handle (1, 1); /* Get output handle */
  si.hStdError = handle (2, 1); /* Get output handle */
d484 2
a489 4
  /* See comment in dcrt0.cc, function get_cygwin_startup_info. */
  if (wincap.needs_count_in_si_lpres2 ())
    ch.zero[0] = sizeof (ch) / 5;

@


1.235
log
@	* dir.cc (mkdir): Check last path component for "..".
	(rmdir): Don't check last path component for "..".
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop kludge
	which tries to allow deleting the current working directory.
	* path.cc (has_dot_last_component): Add parameter to indicate testing
	for "..".  Take trailing slash into account.
	(symlink_info::posixify): Rely on cygheap->cwd.win32 having a
	useful value.
	(cwdstuff::init): Initialize cygheap->cwd with current working
	directory.  Change to windows_system_directory afterwards.
	(cwdstuff::set): Never call SetCurrentDirectory here.  Just check
	if changing into target directory would be allowed.  Add comment to
	explain why.
	* path.h (has_dot_last_component): Declare with second parameter.
	* pinfo.cc (pinfo::zap_cwd): Remove.
	(pinfo::exit): Drop call to zap_cwd.
	* pinfo.h (class pinfo): Remove declaration of zap_cwd.
	* spawn.cc (spawn_guts): Set current working directory for non-Cygwin
	child applications.  Drop call to zap_cwd.
@
text
@d301 7
a307 1
  child_info_spawn ch;
d490 4
d737 1
@


1.234
log
@* autoload.cc (GetHandleInformation): Declare new function.
(SetHandleInformation): Ditto.
* debug.cc (add_handle): Use SetHandleInformation to protect handle.
(close_handle): Use SetHandleInformation to unprotect handle.
* spawn.cc (spawn_guts): Move detached test outside of P_OVERLAY block.
@
text
@d504 1
a504 1
			  0,		/* use current drive/directory */
d539 1
a539 1
		       0,		/* use current drive/directory */
a615 1
	      myself.zap_cwd ();
@


1.233
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d425 2
a451 2
      if (mode != _P_DETACH)
	set_console_state_for_spawn (real_path.iscygexec ());
@


1.233.2.1
log
@	* dcrt0.cc (get_cygwin_startup_info): Change zeros to DWORD array.
	Expect first DWORD in child_info struct being set to non-zero if
	wincap.needs_count_in_si_lpres2 is set.  Add comment to explain why.
	* fork.cc (frok::parent): Set ch.zero[0] to a sensible count value
	if wincap.needs_count_in_si_lpres2 is set.
	* spawn.cc (spawn_guts): Ditto.  Add filler bytes after ch on stack
	to accomodate needs_count_in_si_lpres2.
	* wincap.h: Define needs_count_in_si_lpres2 throughout.
	* wincap.cc: Ditto.
@
text
@d301 1
a301 7
  /* Allocate slightly bigger for call to CreateProcess to accomodate
     needs_count_in_si_lpres2. */
  struct {
    child_info_spawn ch;
    char filler[4];
  } _ch;
#define ch	_ch.ch
a483 4
  /* See comment in dcrt0.cc, function get_cygwin_startup_info. */
  if (wincap.needs_count_in_si_lpres2 ())
    ch.zero[0] = sizeof (ch) / 5;

a727 1
#undef ch
@


1.233.2.2
log
@2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d681 1
a681 4
  if ((mode == _P_DETACH || mode == _P_NOWAIT) && !ch.iscygwin ())
    synced = false;
  else
    synced = ch.sync (pi.dwProcessId, pi.hProcess, INFINITE);
@


1.233.2.3
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d213 1
a213 1
handle (int fd, bool writing)
d222 1
a222 1
  else if (!writing)
a225 1

d262 1
a262 1
int __stdcall
d264 1
a264 1
	    const char *const envp[], int mode, int __stdin, int __stdout)
d301 8
a308 1
  child_info_spawn ch;
d319 1
a319 2
  STARTUPINFO si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
		    NULL, NULL, NULL};
a413 2

  /* Set up needed handles for stdio */
d415 3
a417 4
  si.hStdInput = handle ((__stdin < 0 ? 0 : __stdin), false);
  si.hStdOutput = handle ((__stdout < 0 ? 1 : __stdout), true);
  si.hStdError = handle (2, true);

a485 2
  ch.__stdin = __stdin;
  ch.__stdout = __stdout;
d490 4
@


1.233.2.4
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d463 2
a464 2
      && (wincap.start_proc_suspended () || !ch.iscygwin ()
	  || mode != _P_OVERLAY || cygheap->fdtab.need_fixup_before ()))
@


1.233.2.5
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Reenable.  Fix
	comment.
	* spawn.cc (spawn_guts): Call cygheap->fdtab.set_file_pointers_for_exec
	only for non-Cygwin processes.
@
text
@d473 1
a473 2
  if (!real_path.iscygexec())
    cygheap->fdtab.set_file_pointers_for_exec ();
@


1.233.2.6
log
@2008-03-05  Corinna Vinschen  <corinna@@vinschen.de>

	* child_info.h (~child_info_spawn): Check moreinfo->myself_pinfo for
	NULL before closing.
	* spawn.cc (spawn_guts): Don't close moreinfo->myself_pinfo explicitely
	in case of failing CloseProcess.

	* exceptions.cc (_cygtls::handle_exceptions): Replace top level SEH
	installed by Windows with our own handler.

	* fhandler.cc (fhandler_base::open_): Return EISDIR when trying to
	create a directory.
	(fhandler_base::open_9x): Ditto.
	* ntdll.h (STATUS_OBJECT_NAME_INVALID): Define.
	* path.cc (path_conv::check): If input path had a trailing dir
	separator, tack it on to the native path if directory doesn't exist.

2008-03-05  Christopher Faylor  <me+cygwin@@cgf.cx>

	* exceptions.cc (_cygtls::handle_exceptions): Detect when signal is
	masked and treat as if it was not caught.  Revert to a 'return 0'
	rather than using a goto.
@
text
@d570 2
@


1.232
log
@white space
@
text
@d307 5
d334 1
a334 1
  cygheap_exec_info *moreinfo = (cygheap_exec_info *) ccalloc (HEAP_1_EXEC, 1, sizeof (cygheap_exec_info));
d355 2
a356 1
  bool wascygexec = real_path.iscygexec ();
d419 1
a419 1
  int c_flags = GetPriorityClass (hMainProc);
d463 1
a463 1
  const char *runpath = null_app_name ? NULL : (const char *) real_path;
d916 1
d937 1
a937 1
      char *buf = (char *) MapViewOfFile(hm, FILE_MAP_READ, 0, 0, 0);
d967 1
a967 1
      char *ptr = buf;
@


1.232.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@a306 5
  const char *runpath;
  int c_flags;
  bool wascygexec;
  cygheap_exec_info *moreinfo;

d329 1
a329 1
  moreinfo = (cygheap_exec_info *) ccalloc (HEAP_1_EXEC, 1, sizeof (cygheap_exec_info));
d350 1
a350 2

  wascygexec = real_path.iscygexec ();
d413 1
a413 1
  c_flags = GetPriorityClass (hMainProc);
d457 1
a457 1
  runpath = null_app_name ? NULL : (const char *) real_path;
a909 1
      char *ptr, *buf;
d930 1
a930 1
      buf = (char *) MapViewOfFile(hm, FILE_MAP_READ, 0, 0, 0);
d960 1
a960 1
      ptr = buf;
@


1.231
log
@* child_info.h (_CI_SAW_CTRL_C): New enum.
(CURR_CHILD_INFO_MAGIC): Reset.
(saw_ctrl_c): New function.
(set_saw_ctrl_c): Ditto.
* sigproc.cc (child_info::proc_retry): Return EXITCODE_OK if we get
STATUS_CONTROL_C_EXIT and we actually saw a CTRL-C.
* spawn.cc (dwExeced): Delete.
(chExeced): New variable.
(spawn_guts): Set chExeced;
* exceptions.cc (dwExeced): Delete declaration.
(chExeced): Declare.
(ctrl_c_handler): Detect if we're an exec stub process and set a flag, if so.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Add extra
DEBUGGING test.
* pinfo.cc: Fix comment.
@
text
@d921 1
a921 1
        {
@


1.230
log
@* debug.cc (add_handle): Print handle value when collision detected.
* dtable.cc (dtable::stdio_init): Cosmetic change.
* fhandler.h (fhandler_base::create_read_state): Protect handle.
(fhandler_pipe::create_guard): Ditto.  Always mark the handle as inheritable.
(fhandler_pipe::is_slow): Return boolean value rather than numeric 1.
* pipe.cc (fhandler_pipe::fhandler_pipe): Always flag that we need fork fixup.
(fhandler_pipe::open): Don't pass security attributes to create_guard.
(fhandler_pipe::set_close_on_exec): Don't handle guard here.
(fhandler_pipe::close): Accommodate now-protected guard handle.
(fhandler_pipe::fixup_in_child): Don't proected read_state here.
(fhandler_pipe::fixup_after_exec): Close guard handle if close_on_exec.
(fhandler_pipe::fixup_after_fork): Don't bother with guard here.
(fhandler_pipe::dup): Don't set res to non-error prematurely.  Use boolean
values where appropriate.  Protect guard and read_state.
(fhandler_pipe::create): Don't call need_fork_fixup since it is now the
default.  Don't protect read_state or guard.
* pipe.cc (fhandler_base::ready_for_read): Use bool values for "avail".
* spawn.cc (spawn_guts): Set cygheap->pid_handle as inheritable when
protecting.
* select.cc (fhandler_pipe::ready_for_read): Actually get the guard mutex for
blocking reads.
@
text
@d55 1
a55 1
DWORD dwExeced;
d586 2
a587 1
      myself->dwProcessId = dwExeced = pi.dwProcessId;
@


1.229
log
@* spawn.cc (spawn_guts): Move ch.set() call back to where it was supposed to
be.
@
text
@d441 1
a441 1
	ProtectHandle (cygheap->pid_handle);
@


1.228
log
@* spawn.cc (spawn_guts): Revert patch which treated derived cygwin programs
differently from those which are mounted with -X.  Pass extra argument to
linebuf::fromargv.
* winf.h (MAXCYGWINCMDLEN): New define.
(linebuf::finish): Add a new argument denoting when command line overflow is
ok.
(linebuf::fromargv): Ditto.
* winf.cc (linebuf::finish): Implement above change.
(linebuf::fromargv): Ditto.
@
text
@a464 1
  ch.set (chtype, real_path.iscygexec ());
d472 1
@


1.227
log
@* Makefile.in (DLL_OFILES): Add winf.o.
* spawn.cc: Move command line handling stuff into winf.cc.
* winf.h: New file.
* winf.cc: New file.
@
text
@d350 1
d375 1
a375 1
      if (real_path.iscygexec ())
d377 1
a377 1
      else if (!one_line.fromargv (newargv, real_path))
d465 1
a472 1
  ch.set (chtype, real_path.iscygexec ());
@


1.226
log
@	* spawn.cc (linebuf::finish): Drop argument.  Don't check command line
	length.
	(spawn_guts): Remove wascygexec.  Check real_path.iscygexec instead.
	Accommodate change to linebuf::finish.
@
text
@d36 1
a36 3

#define LINE_BUF_CHUNK (CYG_MAX_PATH * 2)
#define MAXWINCMDLEN 32767
a239 132
class linebuf
{
 public:
  size_t ix;
  char *buf;
  size_t alloced;
  linebuf () : ix (0), buf (NULL), alloced (0) {}
  ~linebuf () {if (buf) free (buf);}
  void add (const char *what, int len) __attribute__ ((regparm (3)));
  void add (const char *what) {add (what, strlen (what));}
  void prepend (const char *what, int len);
  void finish () __attribute__ ((regparm (1)));
};

void
linebuf::finish ()
{
  if (!ix)
    add ("", 1);
  else
    buf[--ix] = '\0';
}

void
linebuf::add (const char *what, int len)
{
  size_t newix = ix + len;
  if (newix >= alloced || !buf)
    {
      alloced += LINE_BUF_CHUNK + newix;
      buf = (char *) realloc (buf, alloced + 1);
    }
  memcpy (buf + ix, what, len);
  ix = newix;
  buf[ix] = '\0';
}

void
linebuf::prepend (const char *what, int len)
{
  int buflen;
  size_t newix;
  if ((newix = ix + len) >= alloced)
    {
      alloced += LINE_BUF_CHUNK + newix;
      buf = (char *) realloc (buf, alloced + 1);
      buf[ix] = '\0';
    }
  if ((buflen = strlen (buf)))
      memmove (buf + len, buf, buflen + 1);
  else
      buf[newix] = '\0';
  memcpy (buf, what, len);
  ix = newix;
}

class av
{
  char **argv;
  int calloced;
 public:
  int argc;
  bool win16_exe;
  bool iscui;
  av (): argv (NULL), iscui (false) {}
  av (int ac_in, const char * const *av_in) : calloced (0), argc (ac_in), win16_exe (false), iscui (false)
  {
    argv = (char **) cmalloc (HEAP_1_ARGV, (argc + 5) * sizeof (char *));
    memcpy (argv, av_in, (argc + 1) * sizeof (char *));
  }
  void *operator new (size_t, void *p) __attribute__ ((nothrow)) {return p;}
  void set (int ac_in, const char * const *av_in) {new (this) av (ac_in, av_in);}
  ~av ()
  {
    if (argv)
      {
	for (int i = 0; i < calloced; i++)
	  if (argv[i])
	    cfree (argv[i]);
	cfree (argv);
      }
  }
  int unshift (const char *what, int conv = 0);
  operator char **() {return argv;}
  void all_calloced () {calloced = argc;}
  void replace0_maybe (const char *arg0)
  {
    /* Note: Assumes that argv array has not yet been "unshifted" */
    if (!calloced)
      {
	argv[0] = cstrdup1 (arg0);
	calloced = true;
      }
  }
  void dup_maybe (int i)
  {
    if (i >= calloced)
      argv[i] = cstrdup1 (argv[i]);
  }
  void dup_all ()
  {
    for (int i = calloced; i < argc; i++)
      argv[i] = cstrdup1 (argv[i]);
  }
  int fixup (const char *, path_conv&, const char *);
};

int
av::unshift (const char *what, int conv)
{
  char **av;
  av = (char **) crealloc (argv, (argc + 2) * sizeof (char *));
  if (!av)
    return 0;

  argv = av;
  memmove (argv + 1, argv, (argc + 1) * sizeof (char *));
  char buf[CYG_MAX_PATH];
  if (conv)
    {
      cygwin_conv_to_posix_path (what, buf);
      char *p = strchr (buf, '\0') - 4;
      if (p > buf && strcasematch (p, ".exe"))
	*p = '\0';
      what = buf;
    }
  *argv = cstrdup1 (what);
  calloced++;
  argc++;
  return 1;
}

d376 1
a376 1
      else
d378 3
a380 47
	  for (int i = 0; i < newargv.argc; i++)
	    {
	      char *p = NULL;
	      const char *a;

	      newargv.dup_maybe (i);
	      a = i ? newargv[i] : (char *) real_path;
	      int len = strlen (a);
	      if (len != 0 && !strpbrk (a, " \t\n\r\""))
		one_line.add (a, len);
	      else
		{
		  one_line.add ("\"", 1);
		  /* Handle embedded special characters " and \.
		     A " is always preceded by a \.
		     A \ is not special unless it precedes a ".  If it does,
		     then all preceding \'s must be doubled to avoid having
		     the Windows command line parser interpret the \ as quoting
		     the ".  This rule applies to a string of \'s before the end
		     of the string, since cygwin/windows uses a " to delimit the
		     argument. */
		  for (; (p = strpbrk (a, "\"\\")); a = ++p)
		    {
		      one_line.add (a, p - a);
		      /* Find length of string of backslashes */
		      int n = strspn (p, "\\");
		      if (!n)
			one_line.add ("\\\"", 2);	/* No backslashes, so it must be a ".
						       The " has to be protected with a backslash. */
		      else
			{
			  one_line.add (p, n);	/* Add the run of backslashes */
			  /* Need to double up all of the preceding
			     backslashes if they precede a quote or EOS. */
			  if (!p[n] || p[n] == '"')
			    one_line.add (p, n);
			  p += n - 1;		/* Point to last backslash */
			}
		    }
		  if (*a)
		    one_line.add (a);
		  one_line.add ("\"", 1);
		}
	      one_line.add (" ", 1);
	    }

	  one_line.finish ();
a381 8
	  if (one_line.ix >= MAXWINCMDLEN)
	    {
	      debug_printf ("command line too long (>32K), return E2BIG");
	      set_errno (E2BIG);
	      res = -1;
	      goto out;
	    }
	}
@


1.225
log
@* spawn.cc (spawn_guts): Close handles if we know that we will not be seeing a
sync event from the child.
@
text
@d253 1
a253 1
  void finish (bool) __attribute__ ((regparm (2)));
d257 1
a257 1
linebuf::finish (bool cmdlenoverflow_ok)
d262 1
a262 5
    {
      if (ix-- > MAXWINCMDLEN && cmdlenoverflow_ok)
	ix = MAXWINCMDLEN - 1;
      buf[ix] = '\0';
    }
a483 1
  bool wascygexec = real_path.iscygexec ();
d508 1
a508 1
      if (wascygexec)
d558 1
a558 1
	  one_line.finish (real_path.iscygexec ());
@


1.224
log
@* child_info.h (child_status): Fix typo which made it impossible to set
iscygwin.
(child_info::isstraced): Booleanize.
(child_info::iscygwin): Ditto.
* sigproc.cc (child_info::child_info): Minor cleanup of flag setting.
* spawn.cc (spawn_guts): Only close_all_files when we know the process has
started successfully.
* exceptions.cc (init_console_handler): Fix indentation.
@
text
@d603 3
a605 3
  int flags = GetPriorityClass (hMainProc);
  sigproc_printf ("priority class %d", flags);
  flags |= CREATE_SEPARATE_WOW_VDM;
d608 1
a608 1
    flags |= DETACHED_PROCESS;
d645 1
a645 1
    flags |= CREATE_SUSPENDED;
d686 1
a686 1
			  flags,
d721 1
a721 1
		       flags,
d752 1
a752 1
  if (!(flags & CREATE_SUSPENDED))
d804 2
d845 1
a845 1
  if (flags & CREATE_SUSPENDED)
@


1.223
log
@* dcrt0.cc (dll_crt0_0): Call SetErrorMode earlier.
* pinfo.cc (_pinfo::dup_proc_pipe): Reset wr_proc_pipe on failure.  Return
previous pipe handle.
* pinfo.h (_pinfo::dup_proc_pipe): Reflect change to return value.
* spawn.cc (spawn_guts): Restore previous proc pipe on retry or if process
exits before synchronization.
@
text
@a779 2
      if (!looped)
	close_all_files (true);
d865 2
a866 1
	  if (ch.proc_retry (pi.hProcess) == 0)
d871 1
d873 1
a873 2
      else if (!myself->wr_proc_pipe
	       && WaitForSingleObject (pi.hProcess, 0) == WAIT_TIMEOUT)
d875 9
a883 4
	  extern bool is_toplevel_proc;
	  is_toplevel_proc = true;
	  myself.remember (false);
	  waitpid (myself->pid, &res, 0);
@


1.222
log
@* child_info.h (child_status): New enum.
(child_info::flag): Rename from 'straced'.
(child_info::isstraced): New function.
(child_info::iscygwin): Ditto.
(child_info_fork::handle_fork): Reparmize.
(child_info_fork::handle_failure): Ditto.
(child_info_spawn::handle_spawn): New function.
* dcrt0.cc (get_cygwin_startup_info): Use isstraced method.
(child_info_spawn::handle_spawn): Define new function from code previously in
dll_crt0_0.
(dll_crt0_0): Move spawn stuff into handle_spawn.  Only call
init_console_handler for fork case.
* sigproc.cc (child_info::child_info): Set flag appropriately.
(child_info::proc_retry): Treat exit code as "funny" if it's a cygwin process.
* spawn.cc (spawn_guts): Remove commented out flag setting.
@
text
@d448 1
d799 2
a800 2
					       just in case we've been previously
					       execed. */
d803 1
a803 1
	  myself->dup_proc_pipe (pi.hProcess);
d862 5
@


1.221
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Regenerate.
(child_info::retry): Move here from fork subclass.
(child_info::exit_code): New field.
(child_info::retry_count): Max retry count for process start.
(child_info::proc_retry): Declare new function.
(child_info_fork::retry): Move to parent.
(child_info_fork::fork_retry): Ditto.
* dcrt0.cc (child_info::fork_retry): Rename and move.
(child_info_fork::handle_failure): Move.
(dll_crt0_0): Initialize console handler based on whether we have a controlling
tty or not.  Avoid nonsensical check for fork where it can never occur.
* environ.cc (set_proc_retry): Rename from set_fork_retry.  Set retry_count in
child_info.
(parse_thing): Reflect above change.
* exceptions.cc (dummy_ctrl_c_handler): Remove unused variable name.
(ctrl_c_handler): Always return TRUE for the annoying CTRL_LOGOFF_EVENT.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Remove call to
init_console_handler.
* fhandler_tty.cc (fhandler_tty_slave::open): Just call mange_console_count
here and let it decide what to do with initializing console control handling.
* fork.cc (fork_retry): Remove definition.
(frok::parent): Define static errbuf and use in error messages (not thread safe
yet).  Close pi.hThread as soon as possible.  Protect pi.hProcess as soon as
possible.  Don't set retry_count.  That happens automatically in the
constructor now.  Accommodate name change from fork_retry to proc_retry.
* init.cc (dll_entry): Turn off ctrl-c handling early until we know how it is
supposed to be handled.
* pinfo.cc (_pinfo::dup_proc_pipe): Remember original proc pipe value for
failure error message.  Tweak debug message slightly.
* sigproc.cc (child_info::retry_count): Define.
(child_info::child_info): Initialize retry count.
(child_info::sync): Set exit code if process dies before synchronization.
(child_info::proc_retry): Rename from child_info_fork::fork_retry.  Use
previously derived exit code.  Be more defensive about what is classified as an
error exit.
(child_info_fork::handle_failure): Move here from dcrt0.cc.
* spawn.cc (spawn_guts): Maintain error mode when starting new process to avoid
annoying pop ups.  Move deimpersonate call within new loop.  Move envblock
freeing to end.  Loop if process dies prematurely with bad exit code.
* syscalls.cc (init_console_handler): Remove hopefully unneeded call to
init_console_handler.
@
text
@d604 1
a604 1
  flags |= /* CREATE_DEFAULT_ERROR_MODE | */CREATE_SEPARATE_WOW_VDM;
@


1.220
log
@* child_info.h (child_info_fork::handle_failure): Declare new function.
(child_info_fork::retry): New field.
* dcrt0.cc (__api_fatal_exit_val): Define.
(child_info_fork::handle_failure): Define new function.
(__api_fatal): Exit using __api_fatal_exit_val value.
* environ.cc (set_fork_retry): Set fork_retry based on CYGWIN environment
variable.
(parse_thing): Add "fork_retry" setting.
* fork.cc (fork_retry): Define.
(frok::parent): Reorganize to allow retry of failed child creation if child
signalled that it was ok to do so.
* heap.cc (heap_init): Signal parent via handle_failure when VirtualAlloc
fails.
* pinfo.h (EXITCODE_RETRY): Declare.
* sigproc.cc (child_info::sync): Properly exit with failure condition if called
for fork and didn't see subproc_ready.
* spawn.cc (spawn_guts): Use windows pid as first argument.
* winsup.h: Remove obsolete NEW_MACRO_VARARGS define.
(__api_fatal_exit_val): Declare.
(set_api_fatal_return): Define.
(in_dllentry): Declare.
* exceptions.cc (inside_kernel): Remove unneeded in_dllentry declaration.
@
text
@d441 1
a441 1
  char *envblock;
d447 1
d604 1
a604 1
  flags |= CREATE_DEFAULT_ERROR_MODE | CREATE_SEPARATE_WOW_VDM;
a652 1
  cygheap->user.deimpersonate ();
d672 3
a731 3
  if (envblock)
    free (envblock);

d779 2
a780 1
      close_all_files (true);
d795 7
a801 4
	  myself->sync_proc_pipe ();	/* Make sure that we own wr_proc_pipe
					   just in case we've been previously
					   execed. */
	  myself.zap_cwd ();
d859 10
a868 2
      if (synced && WaitForSingleObject (pi.hProcess, 0) == WAIT_TIMEOUT
	  && !myself->wr_proc_pipe)
d895 2
@


1.219
log
@fix typo
@
text
@d849 1
a849 1
  synced = ch.sync (pid, pi.hProcess, INFINITE);
@


1.218
log
@* spawn.cc (av::fixup): Check for .bat and friends specifically now since these
extensions are no longer automatically detected.
@
text
@d1067 1
a1067 1
	  || strcasematch (p, ".btm"))
@


1.217
log
@minor comment restructuring
@
text
@d1061 1
d1063 5
a1067 2
  if (exeext && real_path.iscygexec () || strcasematch (ext, ".bat")
      || strcasematch (ext, ".cmd"))
@


1.216
log
@	* path.cc (suffix_scan::lnk_match): Return true beginning with
	SCAN_APPENDLNK.
	(suffix_scan::next): Rearrange code to make .lnk append order slightly
	more deterministic.
	* spawn.cc (exe_suffixes): Try no suffix before .exe suffix to align
	evaluation with stat_suffixes.
	(dll_suffixes): Ditto.
@
text
@d156 2
a157 2
  /* Iterate over the specified path, looking for the file with and
     without executable extensions. */
@


1.215
log
@	* spawn.cc (dll_suffixes): Add .exe and "no suffix" to the list.
@
text
@d42 2
a43 1
  suffix_info (".exe", 1), suffix_info ("", 1),
d51 2
a52 1
  suffix_info (".exe", 1), suffix_info ("", 1),
@


1.214
log
@	* dlfcn.cc (check_path_access): Call find_exec with FE_DLL option.
	* path.h (enum fe_types): Add FE_DLL value.
	* spawn.cc (std_suffixes): Remove.
	(exe_suffixes): New suffix_info for executing files.
	(dll_suffixes): New suffix_info for searching shared libraries.
	(perhaps_suffix): Add opt argument.  Use dll_suffixes if FE_DLL
	option is given, exe_suffixes otherwise.
	(find_exec): Propagate opt argument to perhaps_suffix.  Drop suffix
	check when testing execute permission.
	(spawn_guts): Call perhaps_suffix with FE_NADA opt argument.
@
text
@d50 1
@


1.213
log
@* spawn.cc (av::fixup): Remove unused argument.
(spawn_guts): Remove capitalization in debugging.
@
text
@d40 1
a40 1
static suffix_info std_suffixes[] =
d43 7
a49 2
  suffix_info (".com"), suffix_info (".cmd"),
  suffix_info (".bat"), suffix_info (".dll"),
d63 1
a63 1
perhaps_suffix (const char *prog, path_conv& buf, int& err)
d69 2
a70 1
  buf.check (prog, PC_SYM_FOLLOW | PC_NULLEMPTY, std_suffixes);
d115 1
a115 1
      && (suffix = perhaps_suffix (name, buf, err)) != NULL)
d169 1
a169 1
      if ((suffix = perhaps_suffix (tmp, buf, err)) != NULL)
d171 1
a171 3
	  if (buf.has_acls () && allow_ntsec
	      && (*suffix == '\0' || strcmp (suffix, ".exe"))
	      && check_file_access (buf, X_OK))
d476 1
a476 1
  if ((ext = perhaps_suffix (prog_arg, real_path, err)) == NULL)
@


1.212
log
@	* spawn.cc (find_exec): Only return files with execute permission set
	if ntsec is on.  Don't check execute permission of Windows batch files.
	(av::fixup): Handle empty files gracefully.  Drop execute permission
	test here.
	* path.cc (suffix_scan::next): Don't skip any suffix on first run.
@
text
@d343 1
a343 1
  int fixup (child_info_types, const char *, path_conv&, const char *);
d480 1
a480 1
  res = newargv.fixup (chtype, prog_arg, real_path, ext);
d558 1
a558 1
	      debug_printf ("Command line too long (>32K), return E2BIG");
d1052 1
a1052 1
av::fixup (child_info_types chtype, const char *prog_arg, path_conv& real_path, const char *ext)
@


1.211
log
@* spawn.cc (spawn_guts): Fix potential handle leak when failing exec.
@
text
@d165 5
d1060 3
d1073 9
a1081 1
	goto err;
a1111 10
      if (real_path.has_acls () && allow_ntsec
	  && check_file_access (real_path, X_OK))
	{
	  UnmapViewOfFile (buf);
	  debug_printf ("... but not executable");
	  break;
	}

      char *pgm = NULL;
      char *arg1 = NULL;
d1140 1
@


1.210
log
@* exceptions.cc (inside_kernel): Fix to return true if we can't get the name of
the DLL for the given memory block since we are not in kernel code.
@
text
@d734 2
a735 1
      CloseHandle (moreinfo->myself_pinfo);
@


1.209
log
@	* Update copyrights.
@
text
@d734 1
@


1.208
log
@* fhandler.h (set_console_state_for_spawn): Whackamole the argument back to a
bool.
* spawn.cc (spawn_guts): Ditto, i.e., once again call
set_console_state_for_spawn with an indication of whether we're about to start
a cygwin process.
* fhandler_console.cc (set_console_state_for_spawn): Don't set the console
state if we know we're starting a cygwin process or if we're using a "real"
tty.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
@


1.207
log
@* spawn.cc (spawn_guts): Reorganize slightly so that 16 bit check is done prior
to check for command.com/cmd.com.  Don't bother setting CREATE_SUSPENDED flag
for a MS-DOS process since it doesn't work anyway.  Avoid calling remember()
when the child process has already exited.
(av::fixup): Explicitly set cygexec flag to falseon a 16 bit process.
@
text
@d621 1
a621 1
	set_console_state_for_spawn ();
@


1.206
log
@* fhandler.h (set_console_state_for_spawn): Eliminate argument from
declaration.
* fhandler.cc (set_console_state_for_spawn): Eliminate argument from
definition.  Always check for invisible console.
(fhandler_console::need_invisible): Don't do anything if the windows station is
already not visible.
* spawn.cc (spawn_guts): Accommodate change of argument to
set_console_state_for_spawn.
@
text
@d429 1
d465 15
a495 1
      goto skip_arg_parsing;
a496 17

  int err;
  const char *ext;
  if ((ext = perhaps_suffix (prog_arg, real_path, err)) == NULL)
    {
      set_errno (err);
      res = -1;
      goto out;
    }

  bool wascygexec = real_path.iscygexec ();
  res = newargv.fixup (chtype, prog_arg, real_path, ext);
  if (res)
    goto out;

  if (wascygexec)
    newargv.dup_all ();
d499 3
a501 1
      for (int i = 0; i < newargv.argc; i++)
d503 4
a506 2
	  char *p = NULL;
	  const char *a;
d508 6
a513 17
	  newargv.dup_maybe (i);
	  a = i ? newargv[i] : (char *) real_path;
	  int len = strlen (a);
	  if (len != 0 && !strpbrk (a, " \t\n\r\""))
	    one_line.add (a, len);
	  else
	    {
	      one_line.add ("\"", 1);
	      /* Handle embedded special characters " and \.
		 A " is always preceded by a \.
		 A \ is not special unless it precedes a ".  If it does,
		 then all preceding \'s must be doubled to avoid having
		 the Windows command line parser interpret the \ as quoting
		 the ".  This rule applies to a string of \'s before the end
		 of the string, since cygwin/windows uses a " to delimit the
		 argument. */
	      for (; (p = strpbrk (a, "\"\\")); a = ++p)
d515 10
a524 7
		  one_line.add (a, p - a);
		  /* Find length of string of backslashes */
		  int n = strspn (p, "\\");
		  if (!n)
		    one_line.add ("\\\"", 2);	/* No backslashes, so it must be a ".
						   The " has to be protected with a backslash. */
		  else
d526 15
a540 6
		      one_line.add (p, n);	/* Add the run of backslashes */
		      /* Need to double up all of the preceding
			 backslashes if they precede a quote or EOS. */
		      if (!p[n] || p[n] == '"')
			one_line.add (p, n);
		      p += n - 1;		/* Point to last backslash */
d542 3
d546 1
a546 3
	      if (*a)
		one_line.add (a);
	      one_line.add ("\"", 1);
a547 2
	  one_line.add (" ", 1);
	}
d549 1
a549 1
      one_line.finish (real_path.iscygexec ());
d551 7
a557 6
      if (one_line.ix >= MAXWINCMDLEN)
	{
	  debug_printf ("Command line too long (>32K), return E2BIG");
	  set_errno (E2BIG);
	  res = -1;
	  goto out;
d559 12
a572 14
  char *envblock;
  newargv.all_calloced ();
  moreinfo->argc = newargv.argc;
  moreinfo->argv = newargv;

  if (mode != _P_OVERLAY ||
      !DuplicateHandle (hMainProc, myself.shared_handle (), hMainProc,
			&moreinfo->myself_pinfo, 0,
			TRUE, DUPLICATE_SAME_ACCESS))
    moreinfo->myself_pinfo = NULL;
  else
    VerifyHandle (moreinfo->myself_pinfo);

 skip_arg_parsing:
d628 3
a630 2
  if (wincap.start_proc_suspended () || mode != _P_OVERLAY
      || cygheap->fdtab.need_fixup_before ())
d841 2
a842 1
      if (synced && !myself->wr_proc_pipe)
d1084 2
@


1.205
log
@* cygtls.cc (_cygtls::remove): Don't output debugging info if this isn't a
cygwin thread.
@
text
@d620 1
a620 1
	set_console_state_for_spawn (!real_path.iscygexec ());
@


1.204
log
@* fhandler_process.cc (fhandler_process::readdir): Add missing argument to
syscall_printf.
* fhandler_console.cc (fhandler_console::need_invisible): Use made-up name for
windows station rather than asking Windows to create one for us.
* spawn.cc (spawn_guts): Don't mess with console if we're detaching.
@
text
@d620 1
a620 1
	set_console_state_for_spawn (real_path.iscygexec ());
@


1.203
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@d619 2
a620 1
      set_console_state_for_spawn (real_path.iscygexec ());
@


1.202
log
@* spawn.cc (spawn_guts): Hide the window whenever ctty == -1, not just when we
have no console.
@
text
@d427 1
a427 1
  child_info_spawn ciresrv;
d646 2
a647 2
  ciresrv.set (chtype, real_path.iscygexec ());
  ciresrv.moreinfo = moreinfo;
d649 2
a650 2
  si.lpReserved2 = (LPBYTE) &ciresrv;
  si.cbReserved2 = sizeof (ciresrv);
d734 3
d824 4
a827 1
    ResumeThread (pi.hThread);
d832 1
a832 1
  synced = ciresrv.sync (pid, pi.hProcess, INFINITE);
@


1.201
log
@* cygheap.cc (init_cygheap::manage_console_count): Revert previous change.
Handle this a different way.
* external.cc (cygwin_internal): Accommodate extra hook_or_detect_cygwin
argument.
* hookapi.cc (cygwin_internal): Fill in subsys variable with the subsystem of
the executable.
* spawn.cc (av::iscui): New variable.
(spawn_guts): Hide window when we don't have a console and this isn't
NT/XP/2003.
(av::fixup): Set iscui flag.
* winsup.h (hook_or_detect_cygwin): Accommodate extra argument.
@
text
@d582 1
a582 1
  if (!wincap.pty_needs_alloc_console () && newargv.iscui && !GetConsoleCP ())
@


1.200
log
@* fhandler.h (set_console_state_for_spawn): Add an argument to the declaration.
* fhandler_console.cc (set_console_state_for_spawn): Ditto for the definition.
Only set invisible console for non-cygwin process.  Remove debugging leftover.
* spawn.cc (spawn_guts): Pass argument denoting whether this is a cygwin
process to set_console_state_for_spawn and only call this function when
exec'ing.
@
text
@d297 3
a299 2
  av (): argv (NULL) {}
  av (int ac_in, const char * const *av_in) : calloced (0), argc (ac_in), win16_exe (false)
d582 5
d1069 1
d1073 1
a1073 1
	      real_path.set_cygexec (!!hook_or_detect_cygwin (buf, NULL));
d1075 1
@


1.199
log
@* fhandler.h (fhandler_pipe::fixup_in_child): Declare new function.
(fhandler_console::invisible_console): Declare new variable.
(fhandler_console::need_invisible): Ditto.
(fhandler_console::has_a): Ditto.
* fhandler_console.cc (set_console_state_for_spawn): Eliminate return value.
Set up an invisible console if necessary prior to spawning.
(fhandler_console::invisible_console): Define.
* fhandler_tty.cc (fhandler_tty_slave::open): Use
fhandler_console::invisible_console to setup an invisible console.
* pipe.cc (fhandler_pipe::fixup_in_child): Define new function from
fixup_after_exec.
(fhandler_pipe::fixup_after_exec): Use fixup_in_child when appropriate.
(fhandler_pipe::fixup_after_fork): Ditto.
* spawn.cc (handle): Reorganize and modernize a little.
(spawn_guts): Rely on set_console_state_for_spawn to set the console into the
right state but don't create the process with "detached" flag if we have no
controlling tty since that confuses 'cmd'.
* dtable.cc (dtable::stdio_init): Don't set console as controlling terminal if
we have an invisible console.
* sigproc.cc (child_info::sync): Use correct name in ForceCloseHandle1.
@
text
@a585 2
  set_console_state_for_spawn ();

d613 1
@


1.198
log
@* exceptions.cc (signal_exit): Eliminate setting of main thread priority since
process lock should make that unnecessary.
* fork.cc (stack_base): Eliminate.
(frok::parent): Subsume stack_base and just set stack stuff here.  Report on
priority class in debugging output.
* spawn.cc (spawn_guts): Report on priority class in debugging output.
@
text
@d203 1
a203 1
handle (int n, int direction)
d205 2
a206 1
  fhandler_base *fh = cygheap->fdtab[n];
d208 9
a216 7
  if (!fh)
    return INVALID_HANDLE_VALUE;
  if (fh->close_on_exec ())
    return INVALID_HANDLE_VALUE;
  if (direction == 0)
    return fh->get_handle ();
  return fh->get_output_handle ();
d586 3
a588 1
  if (mode == _P_DETACH || !set_console_state_for_spawn ())
@


1.197
log
@	* spawn.cc (spawn_guts): Don't leave the function with return inside
	pthread cleanup brackets.
@
text
@d579 3
a581 1
  int flags = CREATE_DEFAULT_ERROR_MODE | GetPriorityClass (hMainProc) | CREATE_SEPARATE_WOW_VDM;
@


1.196
log
@* sigproc.cc (child_info::sync): Move check for !wr_proc_pipe lower.
* spawn.cc (spawn_guts): Correct check for top-level process.
@
text
@d549 2
a550 1
	  return -1;
d718 2
a719 1
      return -1;
@


1.195
log
@* sigproc.cc (child_info::sync): Use correct name when closing to prevent
warnings when DEBUGGING.
* spawn.cc (spawn_guts): Set myself.hProcess to pi.hProcess since this may have
been zeroed by the previous sync.
@
text
@d818 1
a818 1
      if (!synced && !myself->wr_proc_pipe)
@


1.194
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d817 1
@


1.193
log
@* spawn.cc (av::fixup): Just blindly run any file if it has a .bat or .cmd
extension.
@
text
@d817 1
a817 5
      if (!synced)
	/* let myself.exit handle this */;
      else if (myself->wr_proc_pipe)
	myself.hProcess = NULL;
      else
@


1.192
log
@* environ.cc (build_env): Use "kilo"bytes not "mega"bytes.  Return immediately
on error.
* spawn.cc (spawn_guts): Set return value to -1 on error from build_env.
@
text
@d1027 2
a1028 1
  if (exeext && real_path.iscygexec ())
@


1.191
log
@* environ.cc (build_env): Clear envblock and return NULL on attempt to use env
var > 32K.
* spawn.cc (spawn_guts): Set E2BIG if build_env detects an error.
@
text
@d630 1
@


1.190
log
@* sigproc.cc (no_signals_available): Return true if sending to self from the
signal thread.
(wait_sig): Correct so that WaitForSingleObject is called when hMainThread is
!= 0, rather than the reverse.
* cygheap.cc (cygheap_fixup_in_child): Clarify potential error message.
* fork.cc (fork_copy): Cosmetic change.
@
text
@d627 5
@


1.189
log
@* spawn.cc (av::fixup): Avoid breaking out of the wrong "loop".
@
text
@a1022 9
  char *buf = NULL;
  myfault efault;
  if (efault.faulted ())
    {
      if (buf)
	UnmapViewOfFile (buf);
      real_path.set_cygexec (false);
      return 0;
    }
d1036 1
a1036 1
      buf = (char *) MapViewOfFile(hm, FILE_MAP_READ, 0, 0, 0);
@


1.188
log
@* hookapi.cc (hook_or_detect_cygwin): Simplify very slightly.
* spawn.cc (av::fixup): Guard against problems reading an executable which does
not match Microsoft's documentation about PE format.
@
text
@d1050 18
a1067 19
      do
	{
	  myfault efault;
	  if (efault.faulted ())
	    {
	      UnmapViewOfFile (buf);
	      real_path.set_cygexec (false);
	      break;
	    }
	  if (buf[0] == 'M' && buf[1] == 'Z')
	    {
	      unsigned off = (unsigned char) buf[0x18] | (((unsigned char) buf[0x19]) << 8);
	      win16_exe = off < sizeof (IMAGE_DOS_HEADER);
	      if (!win16_exe)
		real_path.set_cygexec (!!hook_or_detect_cygwin (buf, NULL));
	      UnmapViewOfFile (buf);
	      break;
	    }
	} while (0);
@


1.187
log
@* spawn.cc (av::error): Eliminate.
(av::av): Remove reference to error.
(av::replace0_maybe): Ditto.
(av::dup_maybe): Ditto.
(av::dup_all): Ditto.
(av::unshift): Ditto.
(spawn_guts): On a fault, return E2BIG only if ENOMEM has been set.  Otherwise
return EFAULT.
@
text
@d1023 9
d1045 1
a1045 1
      char *buf = (char *) MapViewOfFile(hm, FILE_MAP_READ, 0, 0, 0);
d1050 1
a1050 1
      if (buf[0] == 'M' && buf[1] == 'Z')
d1052 17
a1068 7
	  unsigned off = (unsigned char) buf[0x18] | (((unsigned char) buf[0x19]) << 8);
	  win16_exe = off < sizeof (IMAGE_DOS_HEADER);
	  if (!win16_exe)
	    real_path.set_cygexec (!!hook_or_detect_cygwin (buf, NULL));
	  UnmapViewOfFile (buf);
	  break;
	}
d1070 1
a1070 1
      debug_printf ("%s is a script", (char *) real_path);
@


1.186
log
@* heap.cc (heap_init): Be slightly more aggressive when trying to allocate
heap.  Change fatal error to avoid confusion with cygheap.
* spawn.cc (linebuf::finish): New function.
(linebuf::add): Cosmetic change.
(spawn_guts): Only avoid building windows command line if the program being
executed was actually mounted with -X.  Don't return E2BIG if we hit the 32K
size and we're executing a detected cygwin program.  Just silently truncate the
windows command line, instead.
@
text
@a291 1
  int error;
d295 1
a295 1
  av (int ac_in, const char * const *av_in) : calloced (0), error (false), argc (ac_in), win16_exe (false)
d318 5
a322 5
    if (!calloced
	&& (argv[0] = cstrdup1 (arg0)))
      calloced = true;
    else
      error = errno;
d326 2
a327 3
    if (i >= calloced
	&& !(argv[i] = cstrdup1 (argv[i])))
      error = errno;
d332 1
a332 2
      if (!(argv[i] = cstrdup1 (argv[i])))
	error = errno;
d356 2
a357 2
  if (!(*argv = cstrdup1 (what)))
    error = errno;
a358 1
  calloced++;
d432 1
a432 1
  if (efault.faulted (E2BIG))
d434 4
a554 6
  if (newargv.error)
    {
      set_errno (newargv.error);
      return -1;
    }

@


1.185
log
@* hookapi.cc (rvadelta): Change argument to DWORD to eliminate a compiler
warning.
* path.h (path_conv::set_cygexec): New function.
* spawn.cc (av::iscygwin): Eliminate.
(av::av): Don't initialize iscygwin.
(spawn_guts): Just use real_path.iscygexec for all tests.
(av::fixup): Short circuit test if .exe extension and known cygexec.  Set
cygexec flag appropriately if we find that program uses cygwin1.dll.
@
text
@d38 1
d235 1
a235 1
  void add (const char *what, int len);
d238 1
d242 13
d257 2
a258 2
  size_t newix;
  if ((newix = ix + len) >= alloced || !buf)
d488 1
a488 1
  MALLOC_CHECK;
d493 1
a493 1
  if (real_path.iscygexec ())
a539 1
	  MALLOC_CHECK;
a540 1
	  MALLOC_CHECK;
d543 1
a543 6
      MALLOC_CHECK;
      if (one_line.ix)
	one_line.buf[one_line.ix - 1] = '\0';
      else
	one_line.add ("", 1);
      MALLOC_CHECK;
d545 1
a545 1
      if (one_line.ix > 32767)
a700 1
  MALLOC_CHECK;
a702 1
  MALLOC_CHECK;
@


1.184
log
@* dcrt0.cc (initial_env): Don't attempt stracing if dynamically loaded.
(dll_crt0_0): Move console initialization earlier.
* init.cc (dll_entry): Move console initialization here.
* exceptions.cc (init_console_handler): Fully remove any old console handler.
* spawn.cc (spawn_guts): Don't fill out windows argv if we've deduced that this
is a cygwin-using program.
(av::fixup): Always check executables to see if they are using cygwin1.dll.
Don't consider .com files to be scripts.
* hookapi.cc (rvadelta): New function.
(PEHeaderFromHModule): Simplify slightly.
(hook_or_detect_cygwin): Use passed in name argument for "HMODULE" rather than
incorrectly reading current program.  Calculate delta needed to read image data
and file names if this isn't a real "HMODULE".
@
text
@a279 1
  bool iscygwin;
d281 1
a281 1
  av (int ac_in, const char * const *av_in) : calloced (0), error (false), argc (ac_in), win16_exe (false), iscygwin (false)
a460 1
      newargv.iscygwin = false;
d478 1
a478 1
  if (real_path.iscygexec () || newargv.iscygwin)
d625 1
a625 1
  ciresrv.set (chtype, newargv.iscygwin);
d1020 3
a1022 2
  /* If the file name ends in either .exe, .com, .bat, or .cmd we assume
     that it is NOT a script file */
d1046 1
a1046 1
	    iscygwin = hook_or_detect_cygwin (buf, NULL);
d1094 1
a1094 4
	    {
	      iscygwin = false;
	      break;
	    }
@


1.183
log
@* cygheap.cc (cygheap_init): Eliminate debugging #if.
* fork.cc (fork_parent): Don't issue errors if "somebody" has set the
PID_EXITED flag on a child.  Don't close process handle if it has potentially
already been closed.
* pinfo.cc (winpids::add): Eliminate PID_ALLPIDS handling which was obsoleted
by previous changes.
* spawn.cc (av::fixup): Do win16 detection for .com files.  Make sure that
buffer has been unmapped in all cases.
@
text
@d282 1
a282 1
  av (int ac_in, const char * const *av_in) : calloced (0), error (false), argc (ac_in), win16_exe (false), iscygwin (true)
d462 1
d480 1
a480 1
  if (real_path.iscygexec ())
d1024 1
a1024 3
  while (*ext == '\0' || chtype == PROC_SPAWN
	 || (wincap.detect_win16_exe () && (strcasematch (ext, ".exe")
					    || strcasematch (ext, ".com"))))
d1094 5
@


1.182
log
@* spawn.cc (perhaps_suffix): Record errno-type error value in third argument.
(find_exec): On error, set errno returned from perhaps_suffix.
(spawn_guts): Ditto.
@
text
@d1023 3
a1025 1
  while (*ext == '\0' || chtype == PROC_SPAWN || (wincap.detect_win16_exe () && strcasematch (ext, ".exe")))
d1058 1
@


1.181
log
@* child_info.  (CURR_CHILD_INFO_MAGIC): Refresh.
(child_info::child_info()): New constructor.
(child_info_spawn::child_info_spawn()): Ditto.
(child_info_spawn::operator new): New operator.
(child_info_spawn::set): New function.
* spawn.cc (av()): New constructor.
(av::operator new): New operator.
(av::set): New function.
(spawn_guts): Reorganize so that classes which allocates are defined early in
the function so that it can be properly cleaned up after an efault.  Set errno
to E2BIG in the event of a SEGV situation.
@
text
@d57 1
a57 1
perhaps_suffix (const char *prog, path_conv& buf)
d61 1
d63 1
a63 1
  buf.check (prog, PC_SYM_FOLLOW, std_suffixes);
d65 10
a74 2
  if (!buf.exists () || buf.isdir ())
    ext = NULL;
d102 1
d108 1
a108 1
      && (suffix = perhaps_suffix (name, buf)) != NULL)
d162 1
a162 1
      if ((suffix = perhaps_suffix (tmp, buf)) != NULL)
d194 2
d465 1
d467 1
a467 1
  if ((ext = perhaps_suffix (prog_arg, real_path)) == NULL)
d469 1
a469 1
      set_errno (ENOENT);
@


1.180
log
@* child_info.h (child_info::sync): Pass pid and HANDLE rather than using pinfo.
(child_info::child_info): Accept an argument controlling whether to create
proc_subproc.
(child_info_spawn::child_info_spawn): Ditto.
* sigproc.cc (child_info::child_info): Ditto.
(child_info_spawn::child_info_spawn): Ditto.
(child_info::sync): Use passed in pid and HANDLE.
* fork.cc (fork_parent): Reflect additional arguments required for
child_info::sync.
* hookapi.cc (hook_or_detect_cygwin): Rename.  Change so that NULL 'fn'
argument just returns "true", indicating that program uses cygwin1.dll.
* spawn.cc (av::win16_exe): New element.
* spawn.cc (av::iscygwin): New element.
(av::fixup): New function.
(spawn_guts): Protect against SEGV.  Use fixup function to detect when it is
safe to wait for a spawned (as opposed to an execed) program.  Reflect changes
in child_info::sync arguments.
* external.cc (cygwin_internal): Reflect function renaming to
hook_or_detect_cygwin.
* cygheap.cc (cygheap_fixup_in_child): Close handle after debug fixup has been
done to prevent false positives in handle collision.
* exceptions.cc (try_to_debug): Notify debugger if already being debugged.
@
text
@d269 2
a270 1
  av (int ac, const char * const *av) : calloced (0), error (false), argc (ac), win16_exe (false), iscygwin (true)
d273 1
a273 1
    memcpy (argv, av, (argc + 1) * sizeof (char *));
d275 2
d368 1
d386 1
a386 1
  path_conv real_path;
d388 12
d401 1
d403 4
d409 7
d432 1
a432 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;		// FIXME: Could be very leaky

  av newargv (ac, argv);
a433 1
  int null_app_name = 0;
d449 1
a449 1
      null_app_name = 1;
d457 2
a458 1
      return -1;
a461 1
  int res;
d464 1
a464 1
    return res;
d553 3
a555 1
  PROCESS_INFORMATION pi = {NULL, 0, 0, 0};
a568 1
  bool reset_sendsig = false;
d613 1
a613 1
  child_info_spawn ciresrv (chtype, newargv.iscygwin);
a701 14
  /* FIXME: There is a small race here */

  pthread_cleanup cleanup;
  if (mode == _P_SYSTEM)
    {
      sigset_t child_block;
      cleanup.oldint = signal (SIGINT, SIG_IGN);
      cleanup.oldquit = signal (SIGQUIT, SIG_IGN);
      sigemptyset (&child_block);
      sigaddset (&child_block, SIGCHLD);
      sigprocmask (SIG_BLOCK, &child_block, &cleanup.oldmask);
    }
  pthread_cleanup_push (do_cleanup, (void *) &cleanup);

@


1.179
log
@fix whitespace
@
text
@d35 1
a35 1
#include "cygthread.h"
d267 3
a269 1
  av (int ac, const char * const *av) : calloced (0), error (false), argc (ac)
d308 1
a365 2
  MALLOC_CHECK;

d404 4
a409 1
  bool win16_exe = false;
d438 4
a441 94

  /* If the file name ends in either .exe, .com, .bat, or .cmd we assume
     that it is NOT a script file */
  while (*ext == '\0' || (wincap.detect_win16_exe () && strcasematch (ext, ".exe")))
    {
      HANDLE hnd = CreateFile (real_path, GENERIC_READ,
			       FILE_SHARE_READ | FILE_SHARE_WRITE,
			       &sec_none_nih, OPEN_EXISTING,
			       FILE_ATTRIBUTE_NORMAL, 0);
      if (hnd == INVALID_HANDLE_VALUE)
	{
	  __seterrno ();
	  return -1;
	}

      DWORD done;

      char buf[2 * CYG_MAX_PATH];
      buf[0] = buf[1] = buf[2] = buf[sizeof (buf) - 1] = '\0';
      if (!ReadFile (hnd, buf, sizeof (buf) - 1, &done, 0))
	{
	  CloseHandle (hnd);
	  __seterrno ();
	  return -1;
	}

      CloseHandle (hnd);

      if (buf[0] == 'M' && buf[1] == 'Z')
	{
	  unsigned off = (unsigned char) buf[0x18] | (((unsigned char) buf[0x19]) << 8);
	  win16_exe = off < sizeof (IMAGE_DOS_HEADER);
	  break;
	}

      debug_printf ("%s is a script", (char *) real_path);

      if (real_path.has_acls () && allow_ntsec
	  && check_file_access (real_path, X_OK))
	{
	  debug_printf ("... but not executable");
	  break;
	}

      char *pgm, *arg1;

      if (buf[0] != '#' || buf[1] != '!')
	{
	  pgm = (char *) "/bin/sh";
	  arg1 = NULL;
	}
      else
	{
	  char *ptr;
	  pgm = buf + 2;
	  pgm += strspn (pgm, " \t");
	  for (ptr = pgm, arg1 = NULL;
	       *ptr && *ptr != '\r' && *ptr != '\n';
	       ptr++)
	    if (!arg1 && (*ptr == ' ' || *ptr == '\t'))
	      {
		/* Null terminate the initial command and step over
		   any additional white space.  If we've hit the
		   end of the line, exit the loop.  Otherwise, we've
		   found the first argument. Position the current
		   pointer on the last known white space. */
		*ptr = '\0';
		char *newptr = ptr + 1;
		newptr += strspn (newptr, " \t");
		if (!*newptr || *newptr == '\r' || *newptr == '\n')
		  break;
		arg1 = newptr;
		ptr = newptr - 1;
	      }

	  *ptr = '\0';
	}

      /* Replace argv[0] with the full path to the script if this is the
	 first time through the loop. */
      newargv.replace0_maybe (prog_arg);

      /* pointers:
       * pgm	interpreter name
       * arg1	optional string
       */
      if (arg1)
	newargv.unshift (arg1);

      /* FIXME: This should not be using FE_NATIVE.  It should be putting
	 the posix path on the argv list. */
      find_exec (pgm, real_path, "PATH=", FE_NATIVE, &ext);
      newargv.unshift (real_path, 1);
    }
d589 1
a589 1
  child_info_spawn ciresrv (chtype);
a679 1
  int res;
d710 1
d730 1
a730 1
      if (!win16_exe && myself->wr_proc_pipe)
d738 1
d774 1
d784 1
a784 1
  synced = ciresrv.sync (myself, INFINITE);
d994 101
@


1.178
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d911 1
a911 1
return waitpid (pid, result, 0);
d923 1
a923 1
int ret;
d925 1
a925 1
vfork_save *vf = vfork_storage.val ();
d927 4
a930 4
if (vf != NULL && (vf->pid < 0) && mode == _P_OVERLAY)
  mode = _P_NOWAIT;
else
  vf = NULL;
d933 1
a933 1
syscall_printf ("spawnve (%s, %s, %x)", path, argv[0], envp);
d935 16
a950 16
switch (mode)
  {
  case _P_OVERLAY:
    /* We do not pass _P_SEARCH_PATH here. execve doesn't search PATH.*/
    /* Just act as an exec if _P_OVERLAY set. */
    spawn_guts (path, argv, envp, mode);
    /* Errno should be set by spawn_guts.  */
    ret = -1;
    break;
  case _P_VFORK:
  case _P_NOWAIT:
  case _P_NOWAITO:
  case _P_WAIT:
  case _P_DETACH:
  case _P_SYSTEM:
    ret = spawn_guts (path, argv, envp, mode);
d952 8
a959 8
    if (vf)
      {
	if (ret > 0)
	  {
	    debug_printf ("longjmping due to vfork");
	    vf->restore_pid (ret);
	  }
      }
d961 7
a967 7
    break;
  default:
    set_errno (EINVAL);
    ret = -1;
    break;
  }
return ret;
d978 3
a980 7
int i;
va_list args;
const char *argv[256];

va_start (args, arg0);
argv[0] = arg0;
i = 1;
d982 7
a988 3
do
    argv[i] = va_arg (args, const char *);
while (argv[i++] != NULL);
d990 1
a990 1
va_end (args);
d992 1
a992 1
return spawnve (mode, path, (char * const  *) argv, cur_environ ());
d998 12
a1009 12
int i;
va_list args;
const char * const *envp;
const char *argv[256];

va_start (args, arg0);
argv[0] = arg0;
i = 1;

do
  argv[i] = va_arg (args, const char *);
while (argv[i++] != NULL);
d1011 2
a1012 2
envp = va_arg (args, const char * const *);
va_end (args);
d1014 1
a1014 1
return spawnve (mode, path, (char * const *) argv, (char * const *) envp);
d1020 3
a1022 7
int i;
va_list args;
const char *argv[256];

va_start (args, arg0);
argv[0] = arg0;
i = 1;
d1024 7
a1030 3
do
    argv[i] = va_arg (args, const char *);
while (argv[i++] != NULL);
d1032 1
a1032 1
va_end (args);
d1034 1
a1034 1
return spawnvpe (mode, path, (char * const *) argv, cur_environ ());
d1040 12
a1051 12
int i;
va_list args;
const char * const *envp;
const char *argv[256];

va_start (args, arg0);
argv[0] = arg0;
i = 1;

do
  argv[i] = va_arg (args, const char *);
while (argv[i++] != NULL);
d1053 2
a1054 2
envp = va_arg (args, const char * const *);
va_end (args);
d1056 1
a1056 1
return spawnvpe (mode, path, (char * const *) argv, envp);
d1062 1
a1062 1
return spawnve (mode, path, argv, cur_environ ());
d1068 1
a1068 1
return spawnvpe (mode, path, argv, cur_environ ());
d1075 2
a1076 2
path_conv buf;
return spawnve (mode, find_exec (file, buf), argv, envp);
@


1.177
log
@* cygtls.h (_cygtls): Perform minor reformatting.
* winsup.h (close_all_files): Reflect argument change.
* dtable.cc (close_all_files): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* spawn.cc (spawn_guts): Move close_all_files back to its original location in
first P_OVERLAY test but use argument denoting that handles are only supposed
to be closed, not released (more work to be done here).
* syscalls.cc (close_all_files): Take an argument denoting whether to release
closed files or not.
* path.cc (symlink): Change argument names to reflect linux man page.
(symlink_worker): Ditto.  Also appropriately set ENOENT for empty strings.
@
text
@d775 1
a775 1
      (void) sigprocmask (SIG_BLOCK, &child_block, &cleanup.oldmask);
d822 1
a822 1
	  (void) myself->dup_proc_pipe (pi.hProcess);
d847 1
a847 1
      (void) DuplicateHandle (hMainProc, child.shared_handle (), pi.hProcess,
@


1.176
log
@* wincap.h (wincaps::detect_win16_exe): Declare.
(wincapc::detect_win16_exe): Implement.
* wincap.cc: Populate detect_win16_exe where appropriate.
* spawn.cc (spawn_guts): Only go out of the way to detect 16-bit apps on
systems which are flummoxed by them.
@
text
@d803 1
a872 1
      close_all_files ();
@


1.175
log
@* spawn.cc (spawn_guts): Detect when executing a 16-bit application and avoid
setting the process pipe since this causes conniptions in Windows 9x.
@
text
@d405 1
a405 1
  bool msdos_exe = false;
d437 1
a437 1
  while (*ext == '\0' || strcasematch (ext, ".exe"))
d465 1
a465 1
	  msdos_exe = off < sizeof (IMAGE_DOS_HEADER);
d815 1
a815 1
      if (!msdos_exe && myself->wr_proc_pipe)
@


1.174
log
@Revert 2005-05-30 close_all_files changes.
* spawn.cc (spawn_guts): When execing, close all files after the child has
synced with us.
@
text
@d405 1
d437 1
a437 1
  while (*ext == '\0')
d463 5
a467 1
	break;
d625 1
a625 1
  int flags = CREATE_DEFAULT_ERROR_MODE | GetPriorityClass (hMainProc);
d815 1
a815 1
      if (myself->wr_proc_pipe)
@


1.173
log
@* child_info.h (child_info::cygheap_h): Delete.
(child_info::dwProcessId): New field.
* cygheap.cc (init_cheap): Delete.
(dup_now): Ditto.
(cygheap_setup_for_child): Ditto.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_fixup_in_child): Simplify.  Use new "child_copy" function to copy heap
from parent.
(_csbrk): Don't attempt allocation if within cygheap section.  Fix so that more
than one allocation will succeed.
(cygheap_init): Reset possibly-nonzero region to zero.
* cygheap.h (cygheap_setup_for_child): Delete declaration.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_start): Define as an array.
* cygwin.sc: Modernize.  Remove unneeded sections.  Define cygheap here.
* dcrt0.cc (do_exit): Reflect argument change to close_all_files.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* fork.cc (fork_copy): Call ReadProcessMemory if there is no thread
(indicating that we're execing).
(fork_child): Don't mess with hParent.
(fork_parent): Remove hParent stuff.  It happens earlier now.  Remove call to
cygheap_setup_for_child* stuff.
(fork): Put child_info_stuff in grouped structure.  Issue error if parent
handle is not set.
(child_copy): New function.
* sigproc.cc (child_info::child_info): Put cygheap settings here.  Set parent
handle.
(child_info::~child_info): Close parent handle if it exists.
* spawn.cc (spawn_guts): Reorganize so that ciresrv is allocated at only the
last minute so that cygheap changes are reflected.  Delete cygheap_setup*
calls.
* syscalls.cc (close_all_files): Add an argument to flag when the fd entry
should be released.
* winsup.h (close_all_files): Add an argument to close_all_files declaration.
Declare child_copy.
@
text
@a798 1
      close_all_files (true);
d867 1
@


1.172
log
@* spawn.cc (find_exec): Accept a PATH-like string in place of an environment
variable.
* dlfcn.cc (get_full_path_of_dll): Search /usr/bin (for windows compatibility)
and /usr/lib (for UNIX compatibility) when looking for shared libraries.
* environ.cc (conv_envvars): Put back LD_LIBRARY_PATH since it is used by
get_full_path_of_dll().
* errno.cc (errmap): Map MOD_NOT_FOUND to ENOENT.
* cygmagic: Remove debugging cruft.
@
text
@d393 2
a394 6
  child_info_spawn ciresrv (chtype);
  si.lpReserved2 = (LPBYTE) &ciresrv;
  si.cbReserved2 = sizeof (ciresrv);

  ciresrv.moreinfo = (cygheap_exec_info *) ccalloc (HEAP_1_EXEC, 1, sizeof (cygheap_exec_info));
  ciresrv.moreinfo->old_title = NULL;
d599 2
a600 2
  ciresrv.moreinfo->argc = newargv.argc;
  ciresrv.moreinfo->argv = newargv;
d604 1
a604 1
			&ciresrv.moreinfo->myself_pinfo, 0,
d606 1
a606 1
    ciresrv.moreinfo->myself_pinfo = NULL;
d608 1
a608 1
    VerifyHandle (ciresrv.moreinfo->myself_pinfo);
a663 2
  void *newheap;

d669 7
a685 3
      ciresrv.moreinfo->envp = build_env (envp, envblock, ciresrv.moreinfo->envc,
					  real_path.iscygexec ());
      newheap = cygheap_setup_for_child (&ciresrv, cygheap->fdtab.need_fixup_before ());
a719 3
      ciresrv.moreinfo->envp = build_env (envp, envblock, ciresrv.moreinfo->envc,
					  real_path.iscygexec ());
      newheap = cygheap_setup_for_child (&ciresrv, cygheap->fdtab.need_fixup_before ());
a755 1
      cygheap_setup_for_child_cleanup (newheap, &ciresrv, 0);
d776 2
a777 7
  if (!cygheap->fdtab.need_fixup_before ())
    cygheap_setup_for_child_cleanup (newheap, &ciresrv, 0);
  else
    {
      cygheap->fdtab.fixup_before_exec (pi.dwProcessId);
      cygheap_setup_for_child_cleanup (newheap, &ciresrv, 1);
    }
d799 1
a799 1
      close_all_files ();
@


1.171
log
@Remove PC_FULL from path_conv usage throughout.
* path.h (enum pathconv_arg): Change PC_FULL to PC_NOUILL.
* path.cc (path_conv::check): Test for PC_NOFULL rather than !PC_FULL.
(cygwin_conv_to_win32_path): Use PC_NOFULL to force non-absolute path.
@
text
@d114 13
a126 3
  /* Return the error condition if this is an absolute path or if there
     is no PATH to search. */
  if (has_slash || strchr (name, '\\') || isdrive (name)
d129 2
d132 2
a135 3

  posix = (opt & FE_NATIVE) ? NULL : tmp;
  posix_path = winpath->get_posix () - 1;
@


1.170
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d62 1
a62 1
  buf.check (prog, PC_SYM_FOLLOW | PC_FULL, std_suffixes);
@


1.169
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@d714 1
a714 1
      rc = CreateProcessAsUser (cygheap->user.token (),
@


1.168
log
@* spawn.cc (do_cleanup): Properly restore SIGINT/SIGQUIT even if they had
previously been SIG_DFL.
@
text
@d307 1
a307 1
  char buf[CYG_MAX_PATH + 1];
d443 1
a443 1
      char buf[2 * CYG_MAX_PATH + 1];
@


1.167
log
@copyright
@
text
@a334 4
  if (cleanup->oldint)
    signal (SIGINT, cleanup->oldint);
  if (cleanup->oldquit)
    signal (SIGQUIT, cleanup->oldquit);
d336 5
a340 1
    sigprocmask (SIG_SETMASK, &(cleanup->oldmask), NULL);
a757 1
  pthread_cleanup_push (do_cleanup, (void *) &cleanup);
d767 1
@


1.166
log
@* cygthread.cc (cygthread::release): Reset ev here if it exists.
(cygthread::terminate_thread): Eliminat racy code which reset ev and
thread_sync.  Remove a few nonsensical inuse checks.  Exit at the bottom.
(cygthread::detach): Rewrite to again try to ensure that we don't say we're
signalled when we are not signalled.
* fhandler.cc (fhandler_base::raw_read): Revert to signalling read success
quickly.
* pipe.cc (fhandler_pipe::close): Use base method to close handle.
* sigproc.h (WAIT_SIG_PRIORITY): Just trundle along at normal priority to allow
the pipe thread to do its thing if possible.
* pinfo.h (pinfo::zap_cwd): Declare new function.
(pinfo::zap_cwd): Move 'cd out of the way code' here.
(pinfo::exit): Use it here.
* spawn.cc (spawn_guts): And here.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.165
log
@	* cygwin.din: Export getpriority and setpriority.
	* fork.cc (fork_parent): Copy parent's nice value into child.
	* spawn.cc (spawn_guts): Ditto.
	* miscfuncs.cc (winprio_to_nice): New function.
	(nice_to_winprio): Ditto.
	* pinfo.cc (pinfo_init): If parent is not a Cygwin process, set
	default nice value according to current Win32 priority class.
	* pinfo.h (class _pinfo): Add nice member.
	* syscalls.cc (setpriority): New function, only implementing
	PRIO_PROCESS for now.
	(getpriority): Ditto.
	(nice): Just call setpriority.
	* wincap.h (wincaps::has_extended_priority_class): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h: Add prototypes for winprio_to_nice and nice_to_winprio.
	* include/limits.h (NZERO): New define.
	* include/cygwin/types.h (id_t): New datatype.
	* include/cygwin/version.h: Bump API minor version.
	* include/sys/resource.h: Add PRIO_XXX defines and prototypes for
	getpriority and setpriority.
@
text
@d807 1
a807 1
	 on this fact when we exit.  dup_proc_pipe also closes our end of the pipe.
d815 1
a815 5
	  SetCurrentDirectory ("c:\\");	/* Move to an innocuous location to
					   avoid races with other processes
					   that may want to manipulate the
					   current directory before this process
					   has completely exited.  */
@


1.164
log
@* spawn.cc (spawn_guts): Perform same "cd" as in pinfo::exit below to make sure
that a stub process does not keep the current working directory busy after the
"execed" process has exited.
@
text
@d848 1
@


1.163
log
@* init.cc (dll_entry): Remove unused extern.
* include/sys/cygwin.h: Remove PID_ZOMBIE.
* pinfo.h: Rename EXITCODE_* defines.
(pinfo::set_exit_state): Remove parameter.
* pinfo.cc (set_exit_state): Remove parameter.  Reverse sense of test so that
exitcode is checked for having been set rather than not having been set.  Set
flag when exitcode has been established.  Don't set PID_STATE here.
(pinfo::init): Remove exitcode initialization.
(pinfo::exit): Reflect change in EXITCODE_* naming.  Set flag when exitcode has
been established.  Reflect change in arguments to set_process_state.
(proc_waiter): Reflect change in arguments to set_process_state.  Set
process_state here and only here.
* fhandler_process.cc (fhandler_process::fill_filebuf): Reflect removal of
PID_ZOMBIE define.
(format_process_stat): Ditto.
(format_process_status): Ditto.
* sigproc.cc (pid_exists): Ditto.
(stopped_or_terminated): Ditto.  Make sure that only low-order 16 bits of
exitcode are used.
* spawn.cc (spawn_guts): Reflect change in EXITCODE_* naming.
@
text
@d812 8
a819 3
	  /* Make sure that we own wr_proc_pipe just in case we've been
	     previously execed. */
	  myself->sync_proc_pipe ();
@


1.162
log
@* pinfo.h (_pinfo::set_exit_state): Declare new function.
(pinfo::exit): Move here from _pinfo::exit.
* sigproc.cc (child_info::sync): Use new function to set exitcode and
process_state.
* pinfo.cc (_pinfo::exit): Ditto.
(proc_waiter): Ditto.
(_pinfo::set_exit_state): Define new function.
(_pinfo::dup_proc_pipe): Close handle when there is no parent process around to
care about the exit value.
* dcrt0.cc (dll_crt0_0): Move subproc_ready synchronization later to make sure
that myself is still mapped in parent.
(do_exit): Reflect movement to pinfo::exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* errno.cc (errmap): Map PROC_NOT_FOUND.
* init.cc (dll_entry): Release myself before exiting.
* sigproc.cc (proc_can_be_signalled): Set errno appropriately.
(sig_send): Ditto.  Also remove ill-advised test for !myself->sendsig since
this is an indication of a process which is still initializating -- it is not
an error.
(child_info::sync): Don't set exitcode here.  Assume that will happen in
proc_waiter, if necessary.
* spawn.cc (spawn_guts): Delay "wait_for_myself" logic until later.  Don't wait
at all if the process has already exited.  Reflect movement to pinfo::exit.
@
text
@d876 1
a876 1
      myself.exit (EXITCODE_EXEC);
@


1.161
log
@* cygthread.cc (cygthread::stub): Add better debug output.
(cygthread::cygthread): Ditto.
(cygthread::terminate_thread): Ditto.  Move inuse test earlier or suffer
infinite loop.
* pinfo.cc (_pinfo::dup_proc_pipe): Close handle if DuplicateHandle fails and
process no longer exists.
* spawn.cc (spawn_guts): Create process in suspended state if OS demands it.
* wincap.cc: Add "start_proc_suspended" throughout.
* wincap.h (wincaps): Ditto.
(wincapc): Ditto.
@
text
@d648 1
a648 1
  if (wincap.start_proc_suspended() || mode != _P_OVERLAY
d790 1
a790 1
  bool wait_for_myself = false;
d810 1
a810 6
      if (!myself->wr_proc_pipe)
	{
	  myself.remember (false);
	  wait_for_myself = true;
	}
      else
d853 4
a856 4
/* Start the child running */
if (flags & CREATE_SUSPENDED)
  ResumeThread (pi.hThread);
ForceCloseHandle (pi.hThread);
d858 1
a858 1
sigproc_printf ("spawned windows pid %d", pi.dwProcessId);
d860 1
a860 1
ciresrv.sync (myself, INFINITE);
d862 32
a893 23
switch (mode)
  {
  case _P_OVERLAY:
    if (wait_for_myself)
      waitpid (myself->pid, &res, 0);
    myself->exit (res, 1);
    break;
  case _P_WAIT:
  case _P_SYSTEM:
    if (waitpid (cygpid, (int *) &res, 0) != cygpid)
      res = -1;
    break;
  case _P_DETACH:
    res = 0;	/* Lost all memory of this child. */
    break;
  case _P_NOWAIT:
  case _P_NOWAITO:
  case _P_VFORK:
    res = cygpid;
    break;
  default:
    break;
  }
d896 2
a897 2
pthread_cleanup_pop (1);
return (int) res;
@


1.160
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
(child_info::parent_wr_proc_pipe): Eliminate.
* pinfo.h (_pinfo::alert_parent): Move here from pinfo class.
(_pinfo::dup_proc_pipe): New method.
(_pinfo::sync_proc_pipe): Ditto.
* exceptions.cc (sig_handle_tty_stop): Reflect move of alert_parent.
* init.cc (dll_entry): Exit with status one if main process called ExitProcess.
* pinfo.cc (set_myself): Remove handling of parent_wr_proc_pipe.
(_pinfo::exit): Reflect move of alert_parent.  Set procinfo to NULL to flag
that we are exiting normally.  Always use exitcode when exiting
(although this could be a little racy).
(pinfo::init): Set default exit to SIGTERM.  This will be the exit code
reported if process is terminated.
(_pinfo::dup_proc_pipe): New function.
(pinfo::wait): Duplicate wr_proc_pipe to the right place.  Use dup_proc_pipe to
move the pipe to the child.
(_pinfo::sync_proc_pipe): New function.
(_pinfo::alert_parent): Move to _pinfo.  Make sure that wr_proc_pipe is ours
before using it.
* sigproc.cc (child_info::child_info): Remove handling of parent_wr_proc_pipe.
* spawn.cc (spawn_guts): Pass our wr_proc_pipe to the child when execing.
Ensure that exit code of cygwin process started from windows is correctly set.
@
text
@d648 2
a649 1
  if (mode != _P_OVERLAY || cygheap->fdtab.need_fixup_before ())
@


1.159
log
@* cygthread.cc (cygthread::stub): Detect if thread function wants to release
itself here, to avoid a race.
(cygthread::release): Clear more stuff.  Add a diagnostic for an internal
error.
* cygthread.h (auto_release): New function.
* pinfo.h (pinfo::remember): Add an argument to denote whether child is
detached.
* fork.cc (fork_parent): Reflect change in arguments to pinfo::remember.
* pinfo.cc (_pinfo::exit): Signal exit more forcibly.
(proc_waiter): Use cygthread::auto_release to signify that cygthread::stub
should release the thread.  This should avoid a race.
(pinfo::alert_parent): Don't signify an error when wr_proc_pipe == NULL.
* sigproc.cc (proc_subproc): Add support for PROC_DETACHED_CHILD.
* sigproc.h: Ditto.
* spawn.cc (spawn_guts): Specify whether child is detached or not when calling
pinfo::remember.
@
text
@d799 10
a808 4
	process.  So, we need to wait around until the process we've just "execed"
	dies.  Use our own wait facility to wait for our own pid to exit (there
	is some minor special case code in proc_waiter and friends to accommodeate
	this). */
d810 11
a820 5
       {
	 myself.remember (true);
	 wait_for_myself = true;
	 myself->wr_proc_pipe = INVALID_HANDLE_VALUE;
       }
d864 1
a864 4
if (wait_for_myself)
  waitpid (myself->pid, &res, 0);
else
  ciresrv.sync (myself, INFINITE);
d869 2
@


1.158
log
@* spawn.cc (spawn_guts): Force parent to forget about P_DETACH'ed process.
@
text
@d805 1
a805 1
	 myself.remember ();
a824 8
      if (!child.remember ())
	{
	  /* FIXME: Child in strange state now. */
	  CloseHandle (pi.hProcess);
	  CloseHandle (pi.hThread);
	  res = -1;
	  goto out;
	}
a833 2
      if (mode == _P_DETACH)
	myself.alert_parent (0);
d835 8
d868 1
a868 1
    res = 0;	/* Lose all memory of this child. */
@


1.157
log
@* fork.cc (fork_parent): Reinstate "childhProc" protection.  Don't close
hProcess handle here since it is used to ensure that a new process isn't
created with the old pid after the old pid exits.
* spawn.cc (spawn_guts): Ditto.
* pinfo.cc (proc_waiter): Don't send any signals if we've execed since this
process doesn't officially exist.
* pinfo.h (pinfo::pid_handle): Eliminate.  Just use hProc.
* sigproc.cc (sig_send): Don't send any signals if our sendsig doesn't exist.
That's a sign that we are execing.
(remove_proc): Eliminate pid_handle close.
@
text
@d842 2
@


1.156
log
@* sigproc.cc (mychild): Reimplement as list scan.
(proc_subproc): Don't mess with pinfo if it's myself.
* child_info.h (child_info_types): Label enum for _PROC constants.
(child_info::child_info): New constructor.
(child_info::~child_info): New destructor.
(child_info::sync): Declare new function.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): Remove old constructor.
(child_info_spawn::child_info_spawn): New constructor.
* dcrt0.cc (dll_crt0_0): Use correct sizeof when doing sanity check on passed
in child_info.  Signal readiness to parent when not forking (and not spawning).
* fork.cc (sync_with_child): Delete.
(resume_child): Remove extra argument.
(sync_with_parent): Use child_info method to sync with parent.
(fork_child): Don't close fork_info->subproc_ready since that is now handled by
the destructor.
(fork_parent): Remove subproc_ready stuff.  Use child_info sync method for
waiting..  Set start time here for child.  Rename "forked" to "child".
(fork): Check ch.subproc_ready for validity here.
* pinfo.h (_pinfo::exec_sendsig): Temp storage for exec stub which may be
staying around to handle non-cygwin captive process.
(_pinfo::exec_dwProcessId): Ditto.
(_pinfo::_lock): Renamed from lock.
(_pinfo::lock): New method.
(_pinfo::unlock): Ditto.
(_pinfo::initialize_lock): Ditto.
* pinfo.cc (set_myself): Use initialize_lock method to initialize myself lock.
Set "exec" fields in _pinfo to zero to indicate that we've started
successfully.  Set start time here when appropriate.
(_pinfo::commune_send): Use pinfo lock/unlock methods.
(proc_waiter): Remove special case for non-cywin processes.  Reinstitute
handling for PID_NOCLDSTOP.
* sigproc.cc (proc_subproc): Set proper EAGAIN errno when process table is
filled.
(sig_send): Use exec_* fields from _pinfo for sending signals if the the _pinfo
sendsig never materializes.
(child_info::child_info): New constructor, renamed from init_child_info.
Zeroes child_info structure and sets appropriate fields in structure based on
chtype.
(child_info::~child_info): New destructor.  Closes subproc_ready if it exists.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): New constructor.
(child_info::ready): New function.  Signals parent when child is ready.
(child_info::sync): New function.  Wait for child to signal us or process to
die.
(remove_proc): Remove closing of hProcess since this should now be handled
shortly after process creation.
* spawn.cc (spawn_guts): Use child_info_spawn constructor rather than
init_child_info.  Save exec_sendsig and exec_dwProcessId in execing _pinfo.
Rely on child_info constructor to properly set parent_wr_proc_pipe in ciresrv.
Revert to previous determination on whether to start a process in suspended
mode.  Remove reparenting stuff.  Just keep a stub around if starting a
non-cygwin process.
@
text
@d787 1
a787 1
  ProtectHandle (pi.hProcess);
a804 1
	 myself.hProcess = pi.hProcess;
a856 2
ForceCloseHandle (pi.hProcess);

@


1.155
log
@* child_info.h (child_info_fork::parent_wr_proc_pipe): New element.
* fork.cc (fork_parent): Set parent_wr_proc.
* pinfo.cc (set_myself): Close child_proc_info->parent_wr_proc if it exists
rather than trying to get value from parent _pinfo.
* pinfo.h (enum parent_aleter): New enum.
(pinfo::alert_parent): Declare as returning a value.
(pinfo::parent_alive): New function.
* pinfo.cc (pinfo::alert_parent): Set wr_proc_pipe to invalid non-NULL value
when parent disappears.  Return success of operation.
(proc_waiter): Use __ALERT_* enum for control since these are not really
signals.  Implement __ALERT_ALIVE.
* sigproc.cc (my_parent_is_alive): Eliminate.
* sigproc.h (my_parent_is_alive): Ditto for declaration.
(__SIGREPARENT): Eliminate.
@
text
@d375 1
a375 5
  child_info_spawn ciresrv;
  si.lpReserved2 = (LPBYTE) &ciresrv;
  si.cbReserved2 = sizeof (ciresrv);

  DWORD chtype;
d381 3
a383 1
  init_child_info (chtype, &ciresrv, NULL);
d617 1
a617 1
  HANDLE saved_sendsig;
d619 1
a619 1
    saved_sendsig = NULL;
d625 7
a631 2
      saved_sendsig = myself->sendsig;
      myself->sendsig = INVALID_HANDLE_VALUE;
a641 1
      ciresrv.parent_wr_proc_pipe = myself->wr_proc_pipe;
d644 5
a648 6
  /* Start the process in a suspended state.  Needed so that any potential parent will
     be able to take notice of the new "execed" process.  This is only really needed
     to handle exec'ed windows processes since cygwin processes are smart enough that
     the parent doesn't have to bother but what are you gonna do?  Cygwin lives in
     a windows world. */
  if (mode != _P_OVERLAY || !real_path.iscygexec ())
d743 5
a747 2
      if (saved_sendsig)
	myself->sendsig = saved_sendsig;
d787 1
a787 1
  ProtectHandle1 (pi.hProcess, childhProc);
d789 1
a789 2
  int wait_for_myself = false;
  DWORD exec_cygstarted;
d792 1
a792 10
      if (!real_path.iscygexec ())
	{
	  /* Store the old exec_cygstarted since this is used as a crude semaphore for
	     detecting when the parent has noticed the change in windows pid for this
	     cygwin pid. */
	  exec_cygstarted = myself->cygstarted;
	  myself->dwProcessId = dwExeced = pi.dwProcessId;  /* Reparenting needs this */
	  myself.alert_parent (__ALERT_REPARENT);
	}
      CloseHandle (saved_sendsig);
d794 1
a794 1
      hExeced = pi.hProcess;
d796 1
d798 5
a802 5
      /* If wr_proc_pipe is NULL then this process was not started by a cygwin
	 process.  So, we need to wait around until the process we've just "execed"
	 dies.  Use our own wait facility to wait for our own pid to exit (there
	 is some minor special case code in proc_waiter and friends to accommodate
	 this). */
d804 6
a809 5
	{
	  myself.hProcess = pi.hProcess;
	  myself.remember ();
	  wait_for_myself = true;
	}
a812 1
      exec_cygstarted = 0;
d828 3
a830 2
	  syscall_printf ("process table full");
	  set_errno (EAGAIN);
d843 1
d846 35
a880 41
  /* Start the child running */
  if (flags & CREATE_SUSPENDED)
    ResumeThread (pi.hThread);
  ForceCloseHandle (pi.hThread);
  // ForceCloseHandle (pi.hProcess);  // handled by proc_subproc and friends

  sigproc_printf ("spawned windows pid %d", pi.dwProcessId);

  if (wait_for_myself)
    waitpid (myself->pid, &res, 0);
  else
    {
      /* Loop, waiting for parent to notice pid change, if exec_cygstarted.
         In theory this wait should usually be a no-op.  */
      if (exec_cygstarted)
	while (myself->cygstarted == exec_cygstarted && myself.parent_alive ())
	  low_priority_sleep (0);
      res = 42;
    }

  switch (mode)
    {
    case _P_OVERLAY:
      myself->exit (res, 1);
      break;
    case _P_WAIT:
    case _P_SYSTEM:
      if (waitpid (cygpid, (int *) &res, 0) != cygpid)
	res = -1;
      break;
    case _P_DETACH:
      res = 0;	/* Lose all memory of this child. */
      break;
    case _P_NOWAIT:
    case _P_NOWAITO:
    case _P_VFORK:
      res = cygpid;
      break;
    default:
      break;
    }
d883 2
a884 2
  pthread_cleanup_pop (1);
  return (int) res;
d890 1
a890 1
  return waitpid (pid, result, 0);
d894 3
a896 3
 * Helper function for spawn runtime calls.
 * Doesn't search the path.
 */
d900 1
a900 1
	 const char *const *envp)
d902 1
a902 1
  int ret;
d904 1
a904 1
  vfork_save *vf = vfork_storage.val ();
d906 4
a909 4
  if (vf != NULL && (vf->pid < 0) && mode == _P_OVERLAY)
    mode = _P_NOWAIT;
  else
    vf = NULL;
d912 1
a912 1
  syscall_printf ("spawnve (%s, %s, %x)", path, argv[0], envp);
d914 16
a929 16
  switch (mode)
    {
    case _P_OVERLAY:
      /* We do not pass _P_SEARCH_PATH here. execve doesn't search PATH.*/
      /* Just act as an exec if _P_OVERLAY set. */
      spawn_guts (path, argv, envp, mode);
      /* Errno should be set by spawn_guts.  */
      ret = -1;
      break;
    case _P_VFORK:
    case _P_NOWAIT:
    case _P_NOWAITO:
    case _P_WAIT:
    case _P_DETACH:
    case _P_SYSTEM:
      ret = spawn_guts (path, argv, envp, mode);
d931 8
a938 8
      if (vf)
	{
	  if (ret > 0)
	    {
	      debug_printf ("longjmping due to vfork");
	      vf->restore_pid (ret);
	    }
	}
d940 7
a946 7
      break;
    default:
      set_errno (EINVAL);
      ret = -1;
      break;
    }
  return ret;
d950 3
a952 3
 * spawn functions as implemented in the MS runtime library.
 * Most of these based on (and copied from) newlib/libc/posix/execXX.c
 */
d957 7
a963 3
  int i;
  va_list args;
  const char *argv[256];
d965 3
a967 7
  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
      argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);
d969 1
a969 1
  va_end (args);
d971 1
a971 1
  return spawnve (mode, path, (char * const  *) argv, cur_environ ());
d977 12
a988 12
  int i;
  va_list args;
  const char * const *envp;
  const char *argv[256];

  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
    argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);
d990 2
a991 2
  envp = va_arg (args, const char * const *);
  va_end (args);
d993 1
a993 1
  return spawnve (mode, path, (char * const *) argv, (char * const *) envp);
d999 7
a1005 3
  int i;
  va_list args;
  const char *argv[256];
d1007 3
a1009 7
  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
      argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);
d1011 1
a1011 1
  va_end (args);
d1013 1
a1013 1
  return spawnvpe (mode, path, (char * const *) argv, cur_environ ());
d1019 12
a1030 12
  int i;
  va_list args;
  const char * const *envp;
  const char *argv[256];

  va_start (args, arg0);
  argv[0] = arg0;
  i = 1;

  do
    argv[i] = va_arg (args, const char *);
  while (argv[i++] != NULL);
d1032 2
a1033 2
  envp = va_arg (args, const char * const *);
  va_end (args);
d1035 1
a1035 1
  return spawnvpe (mode, path, (char * const *) argv, envp);
d1041 1
a1041 1
  return spawnve (mode, path, argv, cur_environ ());
d1047 1
a1047 1
  return spawnvpe (mode, path, argv, cur_environ ());
d1052 1
a1052 1
					     const char * const *envp)
d1054 2
a1055 2
  path_conv buf;
  return spawnve (mode, find_exec (file, buf), argv, envp);
@


1.154
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d639 1
d647 2
a648 1
  flags |= CREATE_SUSPENDED;
d789 9
a797 6
      /* Store the old exec_cygstarted since this is used as a crude semaphore for
	 detecting when the parent has noticed the change in windows pid for this
	 cygwin pid. */
      exec_cygstarted = myself->cygstarted;
      myself->dwProcessId = dwExeced = pi.dwProcessId;  /* Reparenting needs this */
      myself.alert_parent (__SIGREPARENT);
d801 1
a801 1
      strcpy (myself->progname, real_path);
d803 1
a803 1
      /* If wr_proc_pipe doesn't exist then this process was not started by a cygwin
d806 1
a806 1
	 is some minor special case code in proc_waiter and friends to accommodeate
d862 1
a862 1
         In theory this wait should be a no-op.  */
d864 1
a864 1
	while (myself->cygstarted == exec_cygstarted)
@


1.153
log
@* spawn.cc (pthread_cleanup::oldmask): Default to invalid signal mask.
(do_cleanup): Test for invalid signal mask to decide whether to restore the
mask rather than assuming zero mask indicates that there is nothing to do.
@
text
@a31 2
#define NEED_VFORK
#include "perthread.h"
d385 1
a385 10
  HANDLE subproc_ready;
  if (chtype != PROC_EXEC)
    subproc_ready = NULL;
  else
    {
      subproc_ready = CreateEvent (&sec_all, TRUE, FALSE, NULL);
      ProtectHandleINH (subproc_ready);
    }

  init_child_info (chtype, &ciresrv, subproc_ready);
a594 1
  ciresrv.hexec_proc = hexec_proc;
d618 2
d621 1
a621 2
    flags |= CREATE_SUSPENDED;
#if 0 //someday
d623 17
a639 2
    myself->dwProcessId = 0;
#endif
d641 6
a646 6
  /* Some file types (currently only sockets) need extra effort in the
     parent after CreateProcess and before copying the datastructures
     to the child. So we have to start the child in suspend state,
     unfortunately, to avoid a race condition. */
  if (cygheap->fdtab.need_fixup_before ())
    flags |= CREATE_SUSPENDED;
d725 1
a725 1
      cygheap->user.reimpersonate ();
d739 3
a741 6
#if 0 // someday
      if (mode == _P_OVERLAY)
	myself->dwProcessId = GetCurrentProcessId ();
#endif
      if (subproc_ready)
	ForceCloseHandle (subproc_ready);
a768 5
      if (mode == _P_OVERLAY)
	{
	  ResumeThread (pi.hThread);
	  cygthread::terminate ();
	}
d783 2
d787 7
a793 2
      /* These are both duplicated in the child code.  We do this here,
	 primarily for strace. */
a795 1
      dwExeced = pi.dwProcessId;
d798 11
d812 1
d825 1
a825 1
      child->hProcess = pi.hProcess;
a841 2
      /* Start the child running */
      ResumeThread (pi.hThread);
d844 3
d848 1
d852 3
a854 6
  bool exited;

  res = 0;
  exited = false;
  MALLOC_CHECK;
  if (mode == _P_OVERLAY)
d856 6
a861 72
      int nwait = 3;
      HANDLE waitbuf[3] = {pi.hProcess, signal_arrived, subproc_ready};
      for (int i = 0; i < 100; i++)
	{
	  switch (WaitForMultipleObjects (nwait, waitbuf, FALSE, INFINITE))
	    {
	    case WAIT_OBJECT_0:
	      sigproc_printf ("subprocess exited");
	      DWORD exitcode;
	      if (!GetExitCodeProcess (pi.hProcess, &exitcode))
		exitcode = 1;
	      res |= exitcode;
	      exited = true;
	      break;
	    case WAIT_OBJECT_0 + 1:
	      sigproc_printf ("signal arrived");
	      reset_signal_arrived ();
	      continue;
	    case WAIT_OBJECT_0 + 2:
	      if (my_parent_is_alive ())
		res |= EXIT_REPARENTING;
	      else if (!myself->ppid_handle)
		{
		  nwait = 2;
		  sigproc_terminate ();
		  continue;
		}
	      break;
	    case WAIT_FAILED:
	      system_printf ("wait failed: nwait %d, pid %d, winpid %d, %E",
			     nwait, myself->pid, myself->dwProcessId);
	      system_printf ("waitbuf[0] %p %d", waitbuf[0],
			     WaitForSingleObject (waitbuf[0], 0));
	      system_printf ("waitbuf[1] %p %d", waitbuf[1],
			     WaitForSingleObject (waitbuf[1], 0));
	      system_printf ("waitbuf[w] %p %d", waitbuf[2],
			     WaitForSingleObject (waitbuf[2], 0));
	      set_errno (ECHILD);
	      try_to_debug ();
	      return -1;
	    }
	  break;
	}

      ForceCloseHandle (subproc_ready);

      sigproc_printf ("res %p", res);

      if (res & EXIT_REPARENTING)
	{
	  /* Try to reparent child process.
	   * Make handles to child available to parent process and exit with
	   * EXIT_REPARENTING status. Wait() syscall in parent will then wait
	   * for newly created child.
	   */
	  HANDLE oldh = myself->hProcess;
	  HANDLE h = myself->ppid_handle;
	  sigproc_printf ("parent handle %p", h);
	  int rc = DuplicateHandle (hMainProc, pi.hProcess, h, &myself->hProcess,
				    0, FALSE, DUPLICATE_SAME_ACCESS);
	  sigproc_printf ("%d = DuplicateHandle, oldh %p, newh %p",
			  rc, oldh, myself->hProcess);
	  VerifyHandle (myself->hProcess);
	  if (!rc && my_parent_is_alive ())
	    {
	      system_printf ("Reparent failed, parent handle %p, %E", h);
	      system_printf ("my dwProcessId %d, myself->dwProcessId %d",
			     GetCurrentProcessId (), myself->dwProcessId);
	      system_printf ("old hProcess %p, hProcess %p", oldh, myself->hProcess);
	    }
	}

a863 2
  MALLOC_CHECK;

a866 1
      ForceCloseHandle1 (pi.hProcess, childhProc);
a932 1
      subproc_init ();
@


1.153.2.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@d388 1
a388 1
  if (1 || chtype != PROC_EXEC)
d811 1
a811 1
      child.hProcess = pi.hProcess;
d840 1
a840 1
#if 0
d862 3
a864 1
	      if (!myself->cygstarted)
d888 27
a914 1
      sigproc_printf ("P_OVERLAY res %p", res);
a915 1
#endif
d917 1
a917 1
  ForceCloseHandle1 (pi.hProcess, childhProc);
d922 1
d989 1
@


1.153.2.2
log
@checkpoint
@
text
@d32 2
d387 10
a396 1
  init_child_info (chtype, &ciresrv, NULL);
d630 3
a632 7

  HANDLE saved_sendsig;
  if (mode == _P_OVERLAY)
    {
      saved_sendsig = myself->sendsig;
      myself->sendsig = INVALID_HANDLE_VALUE;
    }
d634 2
a635 4
    {
      flags |= CREATE_SUSPENDED;
      saved_sendsig = NULL;
    }
d721 1
a721 1
    cygheap->user.reimpersonate ();
d735 6
a740 2
      if (saved_sendsig)
	myself->sendsig = saved_sendsig;
d840 50
@


1.153.2.3
log
@fix wait when invoked from non-cygwin process.
@
text
@d636 1
a636 1
  if (!myself->wr_proc_pipe || cygheap->fdtab.need_fixup_before ())
d759 5
a777 1
  int wait_for_myself = false;
a779 1
      CloseHandle (saved_sendsig);
a786 6
      if (!myself->wr_proc_pipe)
	{
	  myself.hProcess = pi.hProcess;
	  myself.remember ();
	  wait_for_myself = true;
	}
d819 2
a822 3
  /* Start the child running */
  if (flags & CREATE_SUSPENDED)
    ResumeThread (pi.hThread);
a823 1
  ForceCloseHandle1 (pi.hProcess, childhProc);
d827 5
a831 4
  if (!wait_for_myself)
    res = 0;
  else
    waitpid (myself->pid, &res, 0);
@


1.153.2.4
log
@* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.
@
text
@d621 1
a621 3
  if (mode != _P_OVERLAY)
    saved_sendsig = NULL;
  else
d626 5
d636 2
a637 1
  flags |= CREATE_SUSPENDED;
a773 1
  DWORD exec_cygstarted;
a775 3
      exec_cygstarted = myself->cygstarted;
      myself->dwProcessId = dwExeced = pi.dwProcessId;
      myself.alert_parent (__SIGREPARENT);
d781 1
a792 1
      exec_cygstarted = 0;
d828 1
d832 3
a834 1
  if (wait_for_myself)
a835 7
  else
    {
      if (exec_cygstarted)
	while (myself->cygstarted == exec_cygstarted)
	  low_priority_sleep (0);
      res = 42;
    }
@


1.153.2.5
log
@* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
@
text
@a626 4
      if (!cygheap->pid_handle
	  && !DuplicateHandle (hMainProc, hMainProc, hMainProc, &cygheap->pid_handle,
			   0, TRUE, DUPLICATE_SAME_ACCESS))
	system_printf ("duplicate to pid_handle failed, %E");
@


1.153.2.6
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
@
text
@d595 1
d627 3
a629 6
      if (cygheap->pid_handle)
	/* ok */;
      else if (DuplicateHandle (hMainProc, hMainProc, hMainProc, &cygheap->pid_handle,
				PROCESS_QUERY_INFORMATION, TRUE, 0))
	ProtectHandle (cygheap->pid_handle);
      else
@


1.152
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d329 1
a329 1
  pthread_cleanup (): oldint (NULL), oldquit (NULL), oldmask (0) {}
d340 1
a340 1
  if (cleanup->oldmask)
@


1.151
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d396 1
a396 2
  init_child_info (chtype, &ciresrv, (mode == _P_OVERLAY) ? myself->pid : 1,
		   subproc_ready);
d632 4
a643 1

d654 1
d735 4
@


1.150
log
@	* spawn.cc (spawn_guts): Check if script is executable.
@
text
@d869 1
a869 1
	      system_printf ("waitbuf[1] %p = %d", waitbuf[1],
d871 1
a871 1
	      system_printf ("waitbuf[w] %p = %d", waitbuf[2],
d882 1
a882 1
      sigproc_printf ("res = %x", res);
@


1.149
log
@* spawn.cc (find_exec): Use has_slash to determine if path has a slash rather
than calculating this twice.
@
text
@d472 7
@


1.148
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d117 3
a119 5
  if (strchr (name, '/') || strchr (name, '\\') ||
      isdrive (name) ||
      !(winpath = getwinenv (mywinenv)) ||
      !(path = winpath->get_native ()) ||
      *path == '\0')
@


1.147
log
@* cygtls.cc (_cygtls::remove): Call remove_wq to ensure that wait stuff is
removed from proc_subproc linked list.
* cygtls.h (_cygtls::remove_wq): Declare.
* sigproc.cc (_cygtls::remove_wq): Define.
(proc_subproc): Label event handle appropriately.
* spawn.cc (spawn_guts): Return -1 when wait() fails for spawn types that
require waiting.
@
text
@d188 1
a188 1
  if (fh->get_close_on_exec ())
@


1.146
log
@* Makefile.in (clean): Remove sigfe.s.
(sigfe.s): Ensure that sigfe.s will be regenerated if it does not exist.
* dll_init.cc (dll_dllcrt0): Simplify initializing tests.
* exceptions.cc (setup_handler): Detect when stub caller is either spinning or
has acquired the lock after being suspended to avoid windows problems with
suspending a win32 API call.
* cygtls.h (_cygtls::spinning): Declare new element.
* gendef: Remove unused _siglist_index and _siglist declaration.
(_sigfe): Set spinning element when potentially looping, waiting for lock.
(_sigbe): Ditto.
(_cygtls::lock): Ditto.
(_longjmp): Ditto.
* tlsoffsets.h: Regenerate.
* pinfo.cc (_pinfo::exit): Set final exit state here.  Call sigproc_terminate
if invoked with 'norecord'.  Clear any residual _cygtls stuff.
* winsup.h (exit_states): Define ES_FINAL.
* spawn.cc (spawn_guts): Don't call proc_terminate specifically when execing.
Let _pinfo::exit handle that case.
* sigproc.cc (wait_subproc): Always exit loop early when proc_loop_wait.
* init.cc (munge_threadfunc): Eliminate unused argument.
(dll_entry): Reflect above change in call to munge_threadfunc.
@
text
@d915 2
a916 1
      waitpid (cygpid, (int *) &res, 0);
@


1.145
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d748 1
a748 1
  /* Fixup the parent datastructure if needed and resume the child's
a910 1
      proc_terminate ();
@


1.144
log
@	* uinfo.cc (cygheap_user::init): Use sec_user_nih to build a
	security descriptor. Set both the process and the default DACLs.
	* fork.cc (fork_parent): Use sec_none_nih security attributes.
	* spawn.cc (spawn_guts): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.143
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@a641 2
  /* Preallocated buffer for `sec_user' call */
  char sa_buf[1024];
a656 1
      PSECURITY_ATTRIBUTES sec_attribs = sec_user_nih (sa_buf);
d662 2
a663 2
			  sec_attribs,	/* process security attrs */
			  sec_attribs,	/* thread security attrs */
a672 1
      PSID sid = cygheap->user.sid ();
a676 3
      /* Set security attributes with sid */
      PSECURITY_ATTRIBUTES sec_attribs = sec_user_nih (sa_buf, sid);

d700 2
a701 2
		       sec_attribs,     /* process security attrs */
		       sec_attribs,     /* thread security attrs */
@


1.142
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a399 6
  if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &ciresrv.parent, 0, 1,
			DUPLICATE_SAME_ACCESS))
     {
       system_printf ("couldn't create handle to myself for child, %E");
       return -1;
     }
a400 1
  VerifyHandle (ciresrv.parent);
@


1.141
log
@* spawn.cc (spawn_guts): Change type back to 'int' after erroneous change
below.
@
text
@d407 1
d616 2
d907 1
d965 1
d972 1
d993 1
d1002 1
@


1.141.6.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a406 1
  VerifyHandle (ciresrv.parent);
a614 2
  else
    VerifyHandle (ciresrv.moreinfo->myself_pinfo);
a903 1
	  VerifyHandle (myself->hProcess);
a960 1
#ifdef NEWVFORK
a966 1
#endif
a986 1
#ifdef NEWVFORK
a994 1
#endif
@


1.140
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d348 1
a348 1
static bool __stdcall
@


1.139
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d348 1
a348 1
static int __stdcall
d352 1
a352 1
  BOOL rc;
d835 1
a835 1
  BOOL exited;
d838 1
a838 1
  exited = FALSE;
d854 1
a854 1
	      exited = TRUE;
@


1.138
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@a353 1
  sigframe thisframe (mainthread);
a988 1
	  debug_printf ("longjmping due to vfork");
d990 4
a993 1
	    vf->restore_pid (ret);
@


1.137
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* pinfo.h (pinfo::set_acl): Declare.
	* pinfo.cc (pinfo_fixup_after_fork): Duplicate with no rights.
	(pinfo::set_acl): New.
	* spawn.cc (spawn_guts): Call myself.set_acl.
@
text
@d38 1
a38 1
#define LINE_BUF_CHUNK (MAX_PATH * 2)
d91 1
a91 1
  char tmp[MAX_PATH];
d310 1
a310 1
  char buf[MAX_PATH + 1];
d465 1
a465 1
      char buf[2 * MAX_PATH + 1];
@


1.136
log
@	* spawn.cc (spawn_guts): Set errno to E2BIG if command line is
	longer than CreateProcess allows (32K).
@
text
@d682 3
@


1.135
log
@* fork.cc (fork_parent): Detect failed pinfo constructor.
* spawn.cc (spawn_guts): Don't overwrite ENOMEM errno on failed pinfo
constructor.
@
text
@d590 7
@


1.134
log
@* spawn.cc (spawnve): Remove vfork short circuit and let caller deal with error
return.
@
text
@d795 2
a796 1
	  set_errno (EAGAIN);
@


1.133
log
@* spawn.cc (spawn_guts): Catch potential error from pinfo.remember.  Change
debug messages to make sense.  Pass correct value to pinfo constructor.  Ensure
cleanup after errors.  Always reimpersonate after errors.
@
text
@d980 1
a980 3
	  if (ret < 0)
	    vf->restore_exit (ret);
	  else
@


1.132
log
@* spawn.cc (spawn_guts): Move system signal handling stuff after CreateProcess
error check.
@
text
@d714 1
a714 1
  if (mode != _P_OVERLAY)
d737 1
a737 1
  DWORD res;
d791 1
a791 1
      pinfo child (cygpid, 1);
d794 1
d796 2
a797 2
	  syscall_printf ("-1 = spawnve (), process table full");
	  return -1;
d801 8
a808 1
      child.remember ();
d930 1
@


1.131
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@a711 15
  /* FIXME: There is a small race here */

  DWORD res;
  pthread_cleanup cleanup;
  pthread_cleanup_push (do_cleanup, (void *) &cleanup);
  if (mode == _P_SYSTEM)
    {
      sigset_t child_block;
      cleanup.oldint = signal (SIGINT, SIG_IGN);
      cleanup.oldquit = signal (SIGQUIT, SIG_IGN);
      sigemptyset (&child_block);
      sigaddset (&child_block, SIGCHLD);
      (void) sigprocmask (SIG_BLOCK, &child_block, &cleanup.oldmask);
    }

d733 15
@


1.130
log
@* spawn.cc (pthread_cleanup): New struct.
(do_cleanup): New function.
(spawn_guts): Initialize struct for pthread_cleanup handling to ensure proper
restoration of signals if/when thread is cancelled.  Restore settings using
pthread_cancel_pop.
@
text
@d24 1
a25 1
#include "path.h"
@


1.129
log
@fix accidental checkin
@
text
@d326 22
d714 3
a716 3
  sigset_t old_mask;
  _sig_func_ptr oldint = (_sig_func_ptr) NULL;
  _sig_func_ptr oldquit = (_sig_func_ptr) NULL;
d720 2
a721 2
      oldint = signal (SIGINT, SIG_IGN);
      oldquit = signal (SIGQUIT, SIG_IGN);
d724 1
a724 1
      (void) sigprocmask (SIG_BLOCK, &child_block, &old_mask);
a816 1
  DWORD res;
a908 6
      if (mode == _P_SYSTEM)
	{
	  signal (SIGINT, oldint);
	  signal (SIGQUIT, oldquit);
	  sigprocmask (SIG_SETMASK, &old_mask, NULL);
	}
d922 1
@


1.128
log
@* syscalls.cc (system): Strip signal considerations from here so that they are
not inherited by a child process.
* spawn.cc (spawn_guts): Handle system() signal stuff here.
* winsup.h (_P_SYSTEM): Define.
@
text
@d24 1
a25 1
#include "fhandler.h"
@


1.127
log
@	* cygheap.cc (cygheap_user::set_saved_sid): Rename from set_orig_sid.
	* cygheap.h (class cygheap_user): Rename orig_psid, orig_uid and
	orig_gid to saved_psid, saved_uid and saved_gid respectively.
	Rename methods orig_sid and set_orig_sid to saved_sid and set_saved_sid
	respectively.
	* sec_helper.cc (sec_acl): Accomodate above changes.
	* spawn.cc (spawn_guts): Ditto.
	* uinfo.cc (uinfo_init): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d24 1
a25 1
#include "path.h"
d689 16
d886 1
d888 6
d949 1
@


1.126
log
@2003-09-09  Pierre Humblet <pierre.humblet@@ieee.org>

	* shared_info.h: Include security.h.
	(open_shared): Add psa argument.
	(user_shared_initialize): New declaration.
	* security.h: Add _SECURITY_H guard.
	(sec_user): Use sec_none in the no ntsec case.
	* spawn.cc (spawn_guts): Remove call to load_registry_hive.
	* syscalls (seteuid32): If warranted, call load_registry_hive,
	user_shared_initialize and RegCloseKey(HKEY_CURRENT_USER).
	* shared.cc (user_shared_initialize): New.
	(open_shared): Add and use psa argument.
	(memory_init): Move mount table initialization to
	user_shared_initialize. Call it.
@
text
@d628 1
a628 1
     FIXME: If ruid != euid and ruid != orig_uid we currently give
d631 2
a632 2
      || (cygheap->user.orig_uid == cygheap->user.real_uid
	  && cygheap->user.orig_gid == cygheap->user.real_gid
@


1.126.2.1
log
@* thread.h (__reent_t::init_clib): Declare new function.
* thread.cc (__reent_t::init_clib): Define new function.
(pthread::thread_init_wrapper): Use __reent_t::init_clib to init local clib
storage and set std{in,out,err} appropriately.
* syscalls.cc (system): Strip signal considerations from here so that they are
not inherited by a child process.
* spawn.cc (spawn_guts): Handle system() signal stuff here.
* winsup.h (_P_SYSTEM): Define.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
d24 1
a25 1
#include "fhandler.h"
a688 16

  /* FIXME: There is a small race here */

  sigset_t old_mask;
  _sig_func_ptr oldint = (_sig_func_ptr) NULL;
  _sig_func_ptr oldquit = (_sig_func_ptr) NULL;
  if (mode == _P_SYSTEM)
    {
      sigset_t child_block;
      oldint = signal (SIGINT, SIG_IGN);
      oldquit = signal (SIGQUIT, SIG_IGN);
      sigemptyset (&child_block);
      sigaddset (&child_block, SIGCHLD);
      (void) sigprocmask (SIG_BLOCK, &child_block, &old_mask);
    }

a869 1
    case _P_SYSTEM:
a870 6
      if (mode == _P_SYSTEM)
	{
	  signal (SIGINT, oldint);
	  signal (SIGQUIT, oldquit);
	  sigprocmask (SIG_SETMASK, &old_mask, NULL);
	}
a925 1
    case _P_SYSTEM:
@


1.126.2.2
log
@fix accidental checkin
@
text
@d24 1
a25 1
#include "path.h"
@


1.126.2.3
log
@* spawn.cc (pthread_cleanup): New struct.
(do_cleanup): New function.
(spawn_guts): Initialize struct for pthread_cleanup handling to ensure proper
restoration of signals if/when thread is cancelled.  Restore settings using
pthread_cancel_pop.
@
text
@a325 22
struct pthread_cleanup
{
  _sig_func_ptr oldint;
  _sig_func_ptr oldquit;
  sigset_t oldmask;
  pthread_cleanup (): oldint (NULL), oldquit (NULL), oldmask (0) {}
};

static void
do_cleanup (void *args)
{
# define cleanup ((pthread_cleanup *) args)
  if (cleanup->oldint)
    signal (SIGINT, cleanup->oldint);
  if (cleanup->oldquit)
    signal (SIGQUIT, cleanup->oldquit);
  if (cleanup->oldmask)
    sigprocmask (SIG_SETMASK, &(cleanup->oldmask), NULL);
# undef cleanup
}


d692 3
a694 3
  DWORD res;
  pthread_cleanup cleanup;
  pthread_cleanup_push (do_cleanup, (void *) &cleanup);
d698 2
a699 2
      cleanup.oldint = signal (SIGINT, SIG_IGN);
      cleanup.oldquit = signal (SIGQUIT, SIG_IGN);
d702 1
a702 1
      (void) sigprocmask (SIG_BLOCK, &child_block, &cleanup.oldmask);
d795 1
d888 6
a906 1
  pthread_cleanup_pop (1);
@


1.125
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@a656 3
      /* Load users registry hive. */
      load_registry_hive (sid);

@


1.124
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d624 1
a624 2
  if (cygheap->user.issetuid ())
    RevertToSelf ();
d680 1
a680 1
      rc = CreateProcessAsUser (cygheap->user.token,
d694 2
a695 2
  if (mode != _P_OVERLAY && cygheap->user.issetuid ())
    ImpersonateLoggedOnUser (cygheap->user.token);
@


1.123
log
@	* spawn.cc (spawn_guts): Call CreateProcess while impersonated,
	when the real {u,g}ids and the groups are original.
	Move RevertToSelf and ImpersonateLoggedOnUser to the main line.
	* uinfo.cc (uinfo_init): Reorganize. If CreateProcess was called
	while impersonated, preserve the uids and gids and call
	ImpersonateLoggedOnUser. Preserve the uids and gids on Win9X.

	* exceptions.cc (error_start_init): Quote the pgm in the command.
@
text
@a16 1
#include <errno.h>
@


1.122
log
@* spawn.cc (spawn_guts): Don't hang around if the parent doesn't exist.
@
text
@d625 11
a635 1
  if (!cygheap->user.issetuid ())
a658 2
      RevertToSelf ();

a692 4
      /* Restore impersonation. In case of _P_OVERLAY this isn't
	 allowed since it would overwrite child data. */
      if (mode != _P_OVERLAY)
	ImpersonateLoggedOnUser (cygheap->user.token);
d694 4
@


1.121
log
@* spawn.cc (spawn_guts): Show more of command line in strace output.
@
text
@d803 1
a803 1
	      if (myself->ppid_handle)
d805 1
a805 1
	      if (!my_parent_is_alive ())
@


1.120
log
@* spawn.cc (linebuf::~linebuf): Resurrect commented out (for debugging?) code.
@
text
@d344 1
a344 1
  syscall_printf ("spawn_guts (%d, %.132s)", mode, prog_arg);
d616 1
a616 1
  syscall_printf ("null_app_name %d (%s, %.132s)", null_app_name, runpath, one_line.buf);
d730 1
a730 1
  syscall_printf ("%d = spawn_guts (%s, %.132s)",
@


1.120.2.1
log
@* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
@
text
@d183 1
a183 1
handle (int n)
d191 3
a193 1
  return n ? fh->get_output_handle () : fh->get_handle ();
d594 3
a596 3
  si.hStdInput = handle (0);	/* Get input handle */
  si.hStdOutput = handle (1);	/* Get output handle */
  si.hStdError = handle (2);	/* Get output handle */
d602 1
a602 4
    {
      debug_printf ("mode %c= _P_DETACH", mode == _P_DETACH ? '=' : '!');
      flags |= DETACHED_PROCESS;
    }
@


1.119
log
@	* syscalls.cc (seteuid32): On Win95 get the pw entry. If it exists
	update the euid and call cygheap->user.set_name. Remove special
	handling of ILLEGAL_UID.
	(setgid32): Add a debug_printf. On Win95, always set the egid.
	Remove special handling of ILLEGAL_GID. Do not compare gid and gr_gid.
	* child_info.h (class cygheap_exec_info): Remove uid.
	* spawn.cc (spawn_guts): Do not set ciresrv.moreinfo->uid.
	* dcrto.cc (dll_crt0_1): Always call uinfo_init.
	* uinfo.cc (uinfo_init): Reorganize and close handle if needed.
	(cygheap_user::ontherange): Do not call internal_getpwnam if pw is NULL.
@
text
@d214 1
a214 1
  ~linebuf () {/* if (buf) free (buf);*/}
@


1.118
log
@* dtable.cc (dtable::set_file_pointers_for_exec): New function.
* dtable.h (dtable::set_file_pointers_for_exec): Declare new function.
* spawn.cc (spawn_guts): Call dtable::set_file_pointers_for_exec to set
pointers to EOF when execing non-cygwin applications.
@
text
@a660 1
      ciresrv.moreinfo->uid = ILLEGAL_UID;
@


1.118.12.1
log
@merge from trunk
@
text
@d661 1
@


1.118.12.2
log
@merge from trunk
@
text
@d214 1
a214 1
  ~linebuf () {if (buf) free (buf);}
@


1.118.12.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d25 1
a26 1
#include "fhandler.h"
@


1.118.12.4
log
@merge from trunk
@
text
@d344 1
a344 1
  syscall_printf ("spawn_guts (%d, %.9500s)", mode, prog_arg);
d616 1
a616 1
  syscall_printf ("null_app_name %d (%s, %.9500s)", null_app_name, runpath, one_line.buf);
d730 1
a730 1
  syscall_printf ("%d = spawn_guts (%s, %.9500s)",
@


1.118.12.5
log
@merge from trunk
@
text
@d803 1
a803 1
	      if (my_parent_is_alive ())
d805 1
a805 1
	      else if (!myself->ppid_handle)
@


1.118.12.6
log
@merge from trunk
@
text
@d17 1
d625 1
a625 10
  cygheap->user.deimpersonate ();
  /* When ruid != euid we create the new process under the current original
     account and impersonate in child, this way maintaining the different
     effective vs. real ids.
     FIXME: If ruid != euid and ruid != orig_uid we currently give
     up on ruid. The new process will have ruid == euid. */
  if (!cygheap->user.issetuid ()
      || (cygheap->user.orig_uid == cygheap->user.real_uid
	  && cygheap->user.orig_gid == cygheap->user.real_gid
	  && !cygheap->user.groups.issetgroups ()))
d649 2
d674 1
a674 1
      rc = CreateProcessAsUser (cygheap->user.token (),
d685 4
a689 4
  /* Restore impersonation. In case of _P_OVERLAY this isn't
     allowed since it would overwrite child data. */
  if (mode != _P_OVERLAY)
      cygheap->user.reimpersonate ();
@


1.118.12.7
log
@merge from trunk
@
text
@d657 3
@


1.117
log
@* cygthread.cc (cygthread::stub): Reintroduce clearing of __name but do it
before SetEvent to eliminate a race.
(cygthread::terminate): Accumulate list of threads to check for termination and
call WaitForMultipleObjects on list rather than waiting for each thread
individually.
* sigproc.cc (subproc_init): Zap hwait_subproc thread handle since it is no
longer used.
* spawn.cc (spawn_guts): Fix so that cygthread::terminate is *really* called
only for exec.
@
text
@d624 1
@


1.116
log
@* cygthread.cc (cygthread::stub): Don't create event for long-running threads.
Initialize thread_sync event here which is used to Suspend using an event
rather than relying on SuspendThread/ResumeThread.
(cygthread::init): Save handle to runner thread for future termination.
(cygthread::cygthread): Only resume thread when it is actually suspended.
Otherwise signal thread completion event.
(cygthread::terminate): Forcibly terminate runner thread and any helper
threads.  Call DisableThreadLibrary calls if execing.
* cygthread.h (cygthread::thread_sync): Declare.
* dcrt0.cc (do_exit): Eliminate calls to obsolete window_terminate and
shared_terminate.
* exceptions.cc (events_terminate): Don't bother closing title_mutex since it
is going away anyway.
* pinfo.cc (_pinfo::exit): Call cygthread::terminate to ensure that threads are
shut down before process exit or otherwise strange races seem to occur.
* shared.cc (shared_terminate): Eliminate.
* shared.h (shared_terminate): Eliminate declaration.
* winsup.h (window_terminate): Eliminate declaration.
* spawn.cc (spawn_guts): Call cygthread::terminate early in process if execing.
Call DisableThreadLibrary calls if execing.
* window.cc (Winmain): Call ExitThread to force exit.
(window_terminate): Eliminate.
* dcrt0.cc (do_exit): Track exit state more closely.
@
text
@d718 4
a721 2
	ResumeThread (pi.hThread);
      cygthread::terminate ();
@


1.116.4.1
log
@* spawn.cc (spawn_guts): Fix so that cygthread::terminate is *really* called
only for exec.
* cygthread.cc (cygthread::stub): Don't zero __name here.  That introduces a
race.
@
text
@d718 2
a719 4
	{
	  ResumeThread (pi.hThread);
	  cygthread::terminate ();
	}
@


1.115
log
@* cygheap.cc (dup_now): Make fatal error a little more informative.
(cygheap_setup_for_child): Detect when default size of shared region is less
than the current size and allocate that much.
(_cbrk): Just return NULL on inability to allocate.
(_cmalloc): Ditto.
* cygheap.h (CYGHEAPSIZE): Change size to reflect newer, tinier fhandler sizes.
* spawn.cc (av::error): New element, reflects potential errno from cmalloc.
(av::~av): Don't free NULL pointers.
(av::replace0_maybe): Detect out-of-memory conditions.
(av::dup_maybe): Ditto.
(av::dup_all): Ditto.
(av::unshift): Ditto.
(spawn_guts): Set errno and return if argv creation ran into problems.
* fhandler.h (fhandler_union): Change member names to something safer.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Always set
fhandler_console::dev_state regardless of whether shared region is initialized.
* cygthread.cc (cygthread::runner): Use ExitThread rather than return
(planning for future).
@
text
@d37 1
d719 1
d722 3
a724 1
  if (mode == _P_OVERLAY)
a725 2
  else
    cygpid = cygwin_pid (pi.dwProcessId);
@


1.114
log
@Cleanup calls to CreateFile throughout.
* dcrt0.cc (__api_fatal): Correctly check for failing return from CreateFile.
* assert.cc (__assert): Don't check return value from CreateFile for NULL.
* fhandler_console.cc (set_console_state_for_spawn): Ditto.
* fork.cc (fork_parent): Ditto.
@
text
@d257 1
d259 1
a259 1
  av (int ac, const char * const *av) : calloced (0), argc (ac)
d266 7
a272 3
    for (int i = 0; i < calloced; i++)
      cfree (argv[i]);
    cfree (argv);
d280 5
a284 5
    if (!calloced)
      {
	argv[0] = cstrdup1 (arg0);
	calloced = 1;
      }
d288 3
a290 2
    if (i >= calloced)
      argv[i] = cstrdup1 (argv[i]);
d295 2
a296 1
      argv[i] = cstrdup1 (argv[i]);
d319 2
a320 1
  *argv = cstrdup1 (what);
d349 1
a349 1
      return (-1);
d572 6
@


1.113
log
@* perthread.h (vfork_save): Add ctty, sid, pgid, exitval fields.
(vfork_save::restore_pid): New method.
(vfork_save::restore_exit): New method.
* fork.cc (vfork): Save ctty, sid, pgid and restore them when returning to
"parent".  Use exitval field if exiting but never created a new process.
* syscalls.cc (setsid): Detect when in "vfork" and force an actual fork so that
pid will be allocated (UGLY!).
(getsid): New function.
* dcrt0.cc (do_exit): Use vfork_save::restore_exit method for returning from a
vfork.
* spawn.cc (spawnve): Use vfork_save::{restore_pid,restore_exit} methods for
returning from vfork.
* cygwin.din: Export getsid.
* include/cygwin/version.h: Bump api minor number.
* malloc.cc: #ifdef sYSTRIm for when MORECORE_CANNOT_TRIM is true.
@
text
@d423 4
a426 7
      HANDLE hnd = CreateFileA (real_path,
				GENERIC_READ,
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				&sec_none_nih,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				0);
@


1.112
log
@* spawn.cc (spawn_guts): Don't set mount_h here.
* sigproc.cc (init_child_info): Set it here instead.
* shared.cc (cygwin_mount_h): Make NO_COPY.
@
text
@d910 1
a910 1
      if (vf && ret > 0)
d913 4
a916 2
	  vf->pid = ret;
	  longjmp (vf->j, 1);
@


1.111
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@a610 1
  ciresrv.mount_h = cygwin_mount_h;
@


1.110
log
@* cygheap.h (cygheap_user::issetuid): New method.
* dtable.cc (dtable::vfork_child_dup): Use new method to determine if we are in
"setuid mode."
* fork.cc (fork_parent): Ditto.
* spawn.cc (spawn_guts): Ditto.
* syscalls.cc (seteuid32): Ditto.
(setegid32): Ditto.
* environ.cc (spenv::retrieve): (Suggested by Pierre Humblet) Do potential
recalculation of cygheap_user stuff when in setuid mode.  Return special value
when environment variable exists but should not be added.
(build_env): Don't add retrieved value to dstp if it is 'dont_add'.
@
text
@d360 1
a360 1
  HANDLE spr;
d362 1
a362 1
    spr = NULL;
d365 2
a366 2
      spr = CreateEvent (&sec_all, TRUE, FALSE, NULL);
      ProtectHandle (spr);
d370 1
a370 1
		   spr);
d692 2
a693 2
      if (spr)
	ForceCloseHandle (spr);
d771 1
a771 1
      HANDLE waitbuf[3] = {pi.hProcess, signal_arrived, spr};
d814 1
a814 1
      ForceCloseHandle (spr);
@


1.109
log
@* spawn.cc (spawn_guts): Revert removal of ciresrv.moreinfo->uid = ILLEGAL_UID.
@
text
@d613 1
a613 1
  if (!cygheap->user.impersonated || cygheap->user.token == INVALID_HANDLE_VALUE)
@


1.108
log
@* cygheap.h (cygheap_user::userprofile_env_buf): New static member.
* environ.cc (build_env): Add debugging statement.
(spenvs): Switch functions for USERDOMAIN and USERNAME.
* spawn.cc (spawn_guts): Move environment initialization prior to
cygheap_setup_for_child or environment info will never be copied to child.
@
text
@d649 1
@


1.107
log
@* cygheap.cc (cygheap_user::set_logsrv): Remove.
(cygheap_user::set_domain): Ditto.
* cygheap.h (cygheap_user::set_logsrv): Remove declaration.
(cygheap_user::set_domain): Ditto.
(cygheap_user::env_domain): Declare new method.
(cygheap_user::env_name): Ditto.
* environ.cc (spenvs): Add two environment variables.
* spawn.cc (spawn_guts): Call build_env after RevertToSelf.  Always set
ciresrv.mount_h.
(cygheap_user::ontherange): Recalculate homedrive/homepath if they are empty.
Use env_logsrv to get logon server.
(cygheap_user::env_logsrv): Calculate server name here rather than relying on
it having been previously calculated.
(cygheap_user::env_domain): Ditto for domain name.
(cygheap-user::env_name): New method.
* syscalls.cc (seteuid32): Do not get or set the environment.  Do not call
LookupAccountSid nor internal_getlogin.  Set cygheap->user name and sid from
the passwd entry.
* uinfo.cc (uinfo_init): Only call internal_getlogin when starting from a non
Cygwin process and use the values returned in user.
(internal_getlogin): Simplify to case where starting from a non Cygwin process.
Store return values in user and return void.  Do not set the Windows default
environment.
* dcrt0.cc (dll_crt0_1): Call uinfo_init only when needed.  Do not set
myself->uid nor reset user.sid.
* spawn.cc (spawn_guts): Get the sid from cygheap->user.  Always
RevertToSelf().  Don't set uid in impersonated case.
* cygheap.cc (cygheap_user::set_sid): Do not set orig_sig.
(cygheap_user::set_orig_sid): New.
* cygheap.h: Declare cygheap_user::set_sid.
* winsup.h: Add argument to uinfo_init().
@
text
@a615 1
      newheap = cygheap_setup_for_child (&ciresrv, cygheap->fdtab.need_fixup_before ());
d618 1
a658 1
      newheap = cygheap_setup_for_child (&ciresrv, cygheap->fdtab.need_fixup_before ());
d661 1
@


1.106
log
@* cygheap.cc (cygheap_user::set_name): Set homedrive and homepath to NULL on
user name change.
(cygheap_user::set_logsrv): Allocate enough space for leading \\ so that we can
put this in the environment, if needed.
* cygheap.h (homebodies): New enum.
(cygheap_user::homedrive): New field.
(cygheap_user::homepath): Ditto.
(cygheap_user::env_logsrv): New method.
(cygheap_user::env_homepath): New method.
(cygheap_user::env_homedrive): New method.
(cygheap_user::env_userprofile): New method.
(cygheap_user::ontherange): New method.
* environ.cc (envsize): Eliminate debugging argument.
(environ_init): Assume that envc counts number of elments not total size.
(spenv): New class.
(spenvs): New array, renamed from forced_winenv_vars, using spenv.
(spenv::retrieve): New method.
(build_env): Rename from 'winenv' -- one stop shopping for building new
environment blocks for both windows and "unix".
* environ.h (build_env: Declare.
(winenv): Delete declaration.
(envsize): Ditto.
* spawn.cc (spawn_guts): Use build_env to build windows and cygwin environment
blocks.
* uinfo.cc (internal_getlogin): Eliminate environment manipulation.  Default to
info from GetUserName if it exists.  Move HOMEPATH and HOMEDRIVE stuff
elsewhere.  Move HOME setting elsewhere.  Only set HOME environment variable in
processes that are not parented by a cygwin process.
(cygheap_user::ontherange): Define new method.
(cygheap_user::env_logsrv): Ditto.
(cygheap_user::env_homepath): Ditto.
(cygheap_user::env_homedrive): Ditto.
(cygheap_user::env_userprofile): Ditto.
@
text
@a569 2
  ciresrv.moreinfo->envp = build_env (envp, envblock, ciresrv.moreinfo->envc,
				      real_path.iscygexec ());
d611 2
a615 4
      ciresrv.moreinfo->uid = getuid32 ();
      /* FIXME: This leaks a handle in the CreateProcessAsUser case since the
	 child process doesn't know about cygwin_mount_h. */
      ciresrv.mount_h = cygwin_mount_h;
d617 2
d632 3
a634 10
      cygsid sid;
      DWORD ret_len;
      if (!GetTokenInformation (cygheap->user.token, TokenUser, &sid,
				sizeof sid, &ret_len))
	{
	  sid = NO_SID;
	  system_printf ("GetTokenInformation: %E");
	}
      /* Retrieve security attributes before setting psid to NULL
	 since it's value is needed by `sec_user'. */
a648 1
      ciresrv.moreinfo->uid = ILLEGAL_UID;
d660 2
@


1.105
log
@* spawn.cc (spawn_guts): More hToken removal cleanup.
@
text
@d565 1
d569 3
a572 8
  ciresrv.moreinfo->envc = envsize (envp, 1);
  ciresrv.moreinfo->envp = (char **) cmalloc (HEAP_1_ARGV, ciresrv.moreinfo->envc);
  ciresrv.hexec_proc = hexec_proc;
  char **c;
  const char * const *e;
  for (c = ciresrv.moreinfo->envp, e = envp; *e;)
    *c++ = cstrdup1 (*e++);
  *c = NULL;
a602 7

  /* Build windows style environment list */
  char *envblock;
  if (real_path.iscygexec ())
    envblock = NULL;
  else
    envblock = winenv (envp, 0);
@


1.104
log
@* spawn.cc (spawn_guts): Define sec_attribs and call sec_user_nih() only once.
@
text
@d657 1
a657 4
      /* Remove impersonation */
      if (cygheap->user.impersonated
	  && cygheap->user.token != INVALID_HANDLE_VALUE)
	RevertToSelf ();
d694 1
a694 3
      if (mode != _P_OVERLAY
	  && cygheap->user.impersonated
	  && cygheap->user.token != INVALID_HANDLE_VALUE)
@


1.103
log
@* Makefile.in: Ensure that -MD gets added to CFLAGS regardless of CFLAGS
command-line setting.
* cygwin.din: Export sexec* functions as function which returns ENOSYS
(i.e., sexec* is deprecated).
* dtable.cc (dtable::vfork_child_dup): Ensure that impersonation is restored
even on failure.
* exec.cc: Throughout, remove references to sexec* and _spawnve.
* pinfo.h: Remove _spawnve declaration.
* spawn.cc: Rename _spawnve to spawnve and use throughout.
(spawn_guts): Eliminate hToken argument and processing of same.  Just perform
special actions if impersonating.
(spawnve): Rename from _spawnve.
@
text
@d626 1
a626 1

d634 3
a636 5
					  /* process security attrs */
			  sec_user_nih (sa_buf),
					  /* thread security attrs */
			  sec_user_nih (sa_buf),
			  TRUE,	/* inherit handles from parent */
d638 2
a639 2
			  envblock,/* environment */
			  0,	/* use current drive/directory */
d689 1
a689 1
		       TRUE,	/* inherit handles from parent */
d691 2
a692 2
		       envblock,/* environment */
		       0,	/* use current drive/directory */
@


1.102
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@d319 1
a319 1
spawn_guts (HANDLE hToken, const char * prog_arg, const char *const *argv,
a614 7
  /* Preallocated buffer for `sec_user' call */
  char sa_buf[1024];

  if (!hToken && cygheap->user.impersonated
      && cygheap->user.token != INVALID_HANDLE_VALUE)
    hToken = cygheap->user.token;

d617 1
a617 1
  syscall_printf ("spawn_guts null_app_name %d (%s, %.132s)", null_app_name, runpath, one_line.buf);
d620 3
d624 1
a624 1
  if (!hToken)
d626 1
d649 2
a650 1
      if (!GetTokenInformation (hToken, TokenUser, &sid, sizeof sid, &ret_len))
d686 1
a686 1
      rc = CreateProcessAsUser (hToken,
a786 3
  if (hToken && hToken != cygheap->user.token)
    CloseHandle (hToken);

d907 2
a908 2
_spawnve (HANDLE hToken, int mode, const char *path, const char *const *argv,
	  const char *const *envp)
d918 1
a918 1
  syscall_printf ("_spawnve (%s, %s, %x)", path, argv[0], envp);
d925 1
a925 1
      spawn_guts (hToken, path, argv, envp, mode);
d935 1
a935 1
      ret = spawn_guts (hToken, path, argv, envp, mode);
d973 1
a973 1
  return _spawnve (NULL, mode, path, (char * const  *) argv, cur_environ ());
d995 1
a995 2
  return _spawnve (NULL, mode, path, (char * const *) argv,
		   (char * const *) envp);
d1043 1
a1043 8
  return _spawnve (NULL, mode, path, argv, cur_environ ());
}

extern "C" int
spawnve (int mode, const char *path, char * const *argv,
					     const char * const *envp)
{
  return _spawnve (NULL, mode, path, argv, envp);
d1057 1
a1057 1
  return _spawnve (NULL, mode, find_exec (file, buf), argv, envp);
@


1.101
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d630 1
a630 1
      ciresrv.moreinfo->uid = getuid ();
@


1.100
log
@	* spawn.cc (spawn_guts): Move call to set_process_privilege()
	to load_registry_hive().
	* registry.cc (load_registry_hive): ditto.
	* fork.cc (fork_parent): Call sec_user_nih() only once.
@
text
@a23 1
#include "perprocess.h"
a27 1
#include "sync.h"
@


1.99
log
@* spawn.cc (find_exec): Return input if file not found.
@
text
@a667 7
      static BOOL first_time = TRUE;
      if (first_time)
	{
	  set_process_privilege (SE_RESTORE_NAME);
	  first_time = FALSE;
	}

@


1.98
log
@* fork.cc (fork_parent): Use sec_user_nih to control process/thread
inheritance/permission.
* spawn.cc (spawn_guts): Ditto.
* security.cc (create_token): Initialize token so that it is not tested for
bogus value later.  Use sec_user to control process/thread creation.
* security.h (__sec_user): Rename declaration from sec_user.
(sec_user_nih): Declare here as inline function wrapper for __sec_user.
(sec_user): Ditto.
* sigproc.cc (czombies): Allocate a character array for zombies to avoid
constructor overhead
(extremely hackish, I know).
(cpchildren): Ditto.
(pchildren): New define.
(zombies): Ditto.
(getsem): Use sec_user_nih to control semaphore inheritance/permission.
@
text
@d92 1
a92 1
  char *retval = buf;
d169 2
@


1.97
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d638 1
a638 1
			  allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
d640 1
a640 1
			  allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
d659 1
a659 3
      PSECURITY_ATTRIBUTES sec_attribs = allow_ntsec && sid
					 ? sec_user (sa_buf, sid)
					 : &sec_all_nih;
@


1.96
log
@Add copyright stuff
@
text
@d685 1
a685 1
      ciresrv.moreinfo->uid = USHRT_MAX;
@


1.95
log
@* exceptions.cc (early_stuff_init): Rename from misnamed set_console_handler.
(ctrl_c_handler): Attempt to work around potential signal duplication during
process startup.
(sig_handle): Ignore SIGINT when we're just an "exec stub".
* spawn.cc (spawn_guts): Store pid of spawned process in global for use by
ctrl_c_handler.
* dcrt0.cc (dll_crt0_1): Call renamed initialization function.
* winsup.h: Reflect function name change.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.94
log
@Eliminate excess whitespace.
@
text
@d51 1
d60 1
a60 1
perhaps_suffix (const char *prog, path_conv &buf)
d764 1
@


1.93
log
@* cygheap.h (cygheap_fdmanip::cygheap_fdmanip): Clear fh.
(cygheap_fdmanip::isopen): New method.
* syscalls.cc (_read): Avoid accessing closed fd.
* path.h (fe_types): New enum.
(path_conv::set_path): New method.
(find_exec): Change null_if_not_found argument to something more generic.
* spawn.cc (find_exec): Default to returning the POSIX path rather than the
windows path, unless instructed otherwise.
(spawn_guts): Force call to find_exec to use native paths.
* dlfcn.cc (check_path_access): Accommodate new find_exec arguments.
* environ.h (win_env::get_posix): New method.
@
text
@d369 1
a369 1
      		   spr);
d499 1
a499 1
         the posix path on the argv list. */
d782 1
a782 1
         The purpose is to keep the pid shared memory open so that all of
@


1.92
log
@* spawn.cc (perhaps_suffix): Return NULL on non-existence of file as well as
"directoryness".  Previous code modified on 2001/09/30 actually had an arguable
bug which was unmasked by the change on that day.
@
text
@d87 1
a87 1
	   int null_if_notfound, const char **known_suffix)
d92 3
d99 12
a110 2
  if ((suffix = perhaps_suffix (name, buf)) != NULL)
    goto out;
d114 1
a114 1
  char tmp[MAX_PATH];
d127 2
d133 1
d137 1
a137 1
      if (tmp[0] == '\0' || (tmp[0] == '.' && tmp[1] == '\0'))
d146 11
a156 1
	goto out;
d158 1
a158 1
  while (*path && *++path);
d161 1
d164 1
a164 1
  if (null_if_notfound)
d166 1
a166 1
  else
d170 2
d498 3
a500 1
      find_exec (pgm, real_path, "PATH=", 0, &ext);
@


1.91
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d66 1
a66 1
  if (buf.isdir ())
@


1.90
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d325 1
a325 1
  if (mode != _P_OVERLAY && mode != _P_VFORK)
d331 1
a331 1
  if (mode != _P_OVERLAY)
d339 2
a340 1
  init_child_info (chtype, &ciresrv, (mode == _P_OVERLAY) ? myself->pid : 1, spr);
d678 1
a678 1
      if (mode != _P_OVERLAY && mode != _P_VFORK
d750 7
@


1.89
log
@* cygheap.cc (dup_now): New function.
(cygheap_setup_for_child): Accept new argument controlling whether to delay
copying of cygheap to shared memory region.
(cygheap_setup_for_child_cleanup): Accept new arguments controlling whether to
copy cygheap at this point.
* cygheap.h: Reflect above changes.
* fork.cc (fork_parent): Break copying of cygheap into two parts when
fork_fixup is required so that the child can see the parent's changes.
(vfork): Do stack cleanup prior to forcing a fork error.
* spawn.cc (spawn_guts): Ditto.
@
text
@d66 1
a66 1
  if (buf.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
d69 1
a69 1
    ext = buf + (buf.known_suffix - buf.get_win32 ());
@


1.89.2.1
log
@Merged changes from HEAD
@
text
@d66 1
a66 1
  if (buf.isdir ())
d69 1
a69 1
    ext = (char *) buf + (buf.known_suffix - buf.get_win32 ());
@


1.89.2.2
log
@Merged changes from HEAD
@
text
@d66 1
a66 1
  if (!buf.exists () || buf.isdir ())
d87 1
a87 1
	   unsigned opt, const char **known_suffix)
a91 3
  char tmp[MAX_PATH];
  const char *posix = (opt & FE_NATIVE) ? NULL : name;
  bool has_slash = strchr (name, '/');
d96 2
a97 12
  if ((has_slash || opt & FE_CWD)
      && (suffix = perhaps_suffix (name, buf)) != NULL)
    {
      if (posix && !has_slash)
	{
	  tmp[0] = '.';
	  tmp[1] = '/';
	  strcpy (tmp + 2, name);
	  posix = tmp;
	}
      goto out;
    }
d101 1
a101 1
  const char *posix_path;
a113 2
  posix = (opt & FE_NATIVE) ? NULL : tmp;
  posix_path = winpath->get_posix () - 1;
a117 1
      posix_path++;
d121 1
a121 1
      if (opt & FE_CWD && (tmp[0] == '\0' || (tmp[0] == '.' && tmp[1] == '\0')))
d130 1
a130 11
	{
	  if (posix == tmp)
	    {
	      eotmp = strccpy (tmp, &posix_path, ':');
	      if (eotmp == tmp)
		*eotmp++ = '.';
	      *eotmp++ = '/';
	      strcpy (eotmp, name);
	    }
	  goto out;
	}
d132 1
a132 1
  while (*path && *++path && (posix_path = strchr (posix_path, ':')));
a134 1
  posix = NULL;
d137 1
a137 1
  if (opt & FE_NNF)
d139 1
a139 1
  else if (opt & FE_NATIVE)
a142 2
  if (posix)
    buf.set_path (posix);
d325 1
a325 1
  if (mode != _P_OVERLAY)
d331 1
a331 1
  if (chtype != PROC_EXEC)
d339 1
a339 2
  init_child_info (chtype, &ciresrv, (mode == _P_OVERLAY) ? myself->pid : 1,
		   spr);
d468 1
a468 3
      /* FIXME: This should not be using FE_NATIVE.  It should be putting
	 the posix path on the argv list. */
      find_exec (pgm, real_path, "PATH=", FE_NATIVE, &ext);
d677 1
a677 1
      if (mode != _P_OVERLAY
a748 7
      /* FIXME: This introduces an unreferenced, open handle into the child.
	 The purpose is to keep the pid shared memory open so that all of
	 the fields filled out by child.remember do not disappear and so there
	 is not a brief period during which the pid is not available.
	 However, we should try to find another way to do this eventually. */
      (void) DuplicateHandle (hMainProc, child.shared_handle (), pi.hProcess,
			      NULL, 0, 0, DUPLICATE_SAME_ACCESS);
@


1.89.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a50 1
DWORD dwExeced;
d59 1
a59 1
perhaps_suffix (const char *prog, path_conv& buf)
a762 1
      dwExeced = pi.dwProcessId;
@


1.89.2.4
log
@Merged changes from HEAD
@
text
@d638 1
a638 1
			  sec_user_nih (sa_buf),
d640 1
a640 1
			  sec_user_nih (sa_buf),
d659 3
a661 1
      PSECURITY_ATTRIBUTES sec_attribs = sec_user_nih (sa_buf, sid);
d685 1
a685 1
      ciresrv.moreinfo->uid = ILLEGAL_UID;
@


1.89.2.5
log
@Merged changes from HEAD
@
text
@d24 1
d29 1
d92 1
a92 1
  const char *retval = buf;
a168 2
  else
    retval = name;
d319 1
a319 1
spawn_guts (const char * prog_arg, const char *const *argv,
a564 1
  char *envblock;
d568 3
d572 5
a576 3
  ciresrv.moreinfo->envp = build_env (envp, envblock, ciresrv.moreinfo->envc,
				      real_path.iscygexec ());

d608 14
d624 1
a624 1
  syscall_printf ("null_app_name %d (%s, %.132s)", null_app_name, runpath, one_line.buf);
a626 3
  /* Preallocated buffer for `sec_user' call */
  char sa_buf[1024];

d628 1
a628 1
  if (!cygheap->user.impersonated || cygheap->user.token == INVALID_HANDLE_VALUE)
d630 1
a630 2
      PSECURITY_ATTRIBUTES sec_attribs = sec_user_nih (sa_buf);
      ciresrv.moreinfo->uid = getuid32 ();
d637 5
a641 3
			  sec_attribs,	/* process security attrs */
			  sec_attribs,	/* thread security attrs */
			  TRUE,		/* inherit handles from parent */
d643 2
a644 2
			  envblock,	/* environment */
			  0,		/* use current drive/directory */
d652 1
a652 2
      if (!GetTokenInformation (cygheap->user.token, TokenUser, &sid,
				sizeof sid, &ret_len))
d661 11
a671 1
      RevertToSelf ();
d695 1
a695 1
      rc = CreateProcessAsUser (cygheap->user.token,
d700 1
a700 1
		       TRUE,		/* inherit handles from parent */
d702 2
a703 2
		       envblock,	/* environment */
		       0,		/* use current drive/directory */
d708 3
a710 1
      if (mode != _P_OVERLAY)
d796 3
d919 2
a920 2
spawnve (int mode, const char *path, const char *const *argv,
	 const char *const *envp)
d930 1
a930 1
  syscall_printf ("spawnve (%s, %s, %x)", path, argv[0], envp);
d937 1
a937 1
      spawn_guts (path, argv, envp, mode);
d947 1
a947 1
      ret = spawn_guts (path, argv, envp, mode);
d985 1
a985 1
  return spawnve (mode, path, (char * const  *) argv, cur_environ ());
d1007 2
a1008 1
  return spawnve (mode, path, (char * const *) argv, (char * const *) envp);
d1056 8
a1063 1
  return spawnve (mode, path, argv, cur_environ ());
d1077 1
a1077 1
  return spawnve (mode, find_exec (file, buf), argv, envp);
@


1.89.2.6
log
@Merged changes from HEAD
@
text
@d570 2
a612 2
  ciresrv.mount_h = cygwin_mount_h;

d616 4
a619 2
      ciresrv.moreinfo->envp = build_env (envp, envblock, ciresrv.moreinfo->envc,
					  real_path.iscygexec ());
d634 10
a643 3
      PSID sid = cygheap->user.sid ();

      /* Set security attributes with sid */
d658 1
a668 2
      ciresrv.moreinfo->envp = build_env (envp, envblock, ciresrv.moreinfo->envc,
					  real_path.iscygexec ());
@


1.89.2.7
log
@Merged changes from HEAD
@
text
@d613 1
a613 1
  if (!cygheap->user.issetuid ())
a648 1
      ciresrv.moreinfo->uid = ILLEGAL_UID;
@


1.89.2.8
log
@Merged changes from HEAD
@
text
@d360 1
a360 1
  HANDLE subproc_ready;
d362 1
a362 1
    subproc_ready = NULL;
d365 2
a366 2
      subproc_ready = CreateEvent (&sec_all, TRUE, FALSE, NULL);
      ProtectHandleINH (subproc_ready);
d370 1
a370 1
		   subproc_ready);
d692 2
a693 2
      if (subproc_ready)
	ForceCloseHandle (subproc_ready);
d771 1
a771 1
      HANDLE waitbuf[3] = {pi.hProcess, signal_arrived, subproc_ready};
d814 1
a814 1
      ForceCloseHandle (subproc_ready);
@


1.89.2.9
log
@Merged changes from HEAD
@
text
@d611 1
@


1.89.2.10
log
@Merged changes from HEAD
@
text
@d910 1
a910 1
      if (vf)
d913 2
a914 4
	  if (ret < 0)
	    vf->restore_exit (ret);
	  else
	    vf->restore_pid (ret);
@


1.89.2.11
log
@Merged changes from HEAD
@
text
@d423 7
a429 4
      HANDLE hnd = CreateFile (real_path, GENERIC_READ,
			       FILE_SHARE_READ | FILE_SHARE_WRITE,
			       &sec_none_nih, OPEN_EXISTING,
			       FILE_ATTRIBUTE_NORMAL, 0);
@


1.88
log
@Update copyrights.
@
text
@d593 1
d601 1
a601 1
      cygheap_setup_for_child (&ciresrv);
d663 1
a663 1
      cygheap_setup_for_child (&ciresrv);
a685 1
  cygheap_setup_for_child_cleanup (&ciresrv);
d697 1
d703 3
a705 1
  if (cygheap->fdtab.need_fixup_before ())
d708 1
@


1.87
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Cygnus Solutions.
@


1.86
log
@* smallprint.c (console_printf): New function.
* dcrt0.cc (dll_crt0_1): Use console_printf for debugging output.
* debug.cc (debug_mark_closed): New function.
(close_handle): Use debug_mark_closed.
* debug.h: Declare new functions.
* dtable.cc (dtable::build_fhandler): Remove unneeded extern.
* spawn.cc: Cosmetic changes.
* winsup.h: Define NO_COPY for C files, too.  Declare a global.
@
text
@d619 1
a619 1
        {
d631 1
a631 1
          && cygheap->user.token != INVALID_HANDLE_VALUE)
d636 4
a639 4
        {
          set_process_privilege (SE_RESTORE_NAME);
          first_time = FALSE;
        }
d706 1
a706 1
        ResumeThread (pi.hThread);
@


1.85
log
@* spawn.cc (spawn_guts): Enable appropriate privilege before
loading user's registry hive.
@
text
@d134 1
a134 1
errout:
d142 1
a142 1
out:
d178 1
a178 1
public:
d226 1
a226 1
public:
d550 1
a550 1
skip_arg_parsing:
d864 1
a864 2
extern "C"
int
d925 1
a925 2
extern "C"
int
d945 1
a945 2
extern "C"
int
d968 1
a968 2
extern "C"
int
d988 1
a988 2
extern "C"
int
d1010 1
a1010 2
extern "C"
int
d1016 1
a1016 2
extern "C"
int
d1023 1
a1023 2
extern "C"
int
d1029 1
a1029 2
extern "C"
int
@


1.84
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d634 7
@


1.83
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d678 1
a678 1
  ForceCloseHandle1 (ciresrv.cygheap_h, passed_cygheap_h);
d721 1
@


1.82
log
@* cygheap.cc (_cmalloc): Use correct constants for size calculation.
* dcrt0.cc (dll_crt0_1): Move uid initialization earlier.
* fork.cc (fork_parent): Move cygheap_setup_in_child to just prior to
CreateProcess so that all contents of cygheap are copied.
* spawn.cc (spawn_guts): Ditto.
@
text
@d25 1
a38 1
#include "security.h"
@


1.81
log
@* child_info.h: Bump magic number.
(class child_info): Add an element.
* cygheap.cc (init_cheap): Allocate cygwin heap in shared memory area.
(cygheap_fixup_in_child): Map cygwin heap, passed from parent via shared memory
into correct address.
(cygheap_setup_for_child): New function.
* cygheap.h: Declare new functions.
* dcrt0.cc (dll_crt0_1): Accomodate new cygheap_fixup_in_child arguments.
Avoid protecting subproc_ready unless it is spawn/nowait.
* fork.cc (fork_parent): Use new cygheap_setup_for_child function to setup
cygwin heap info.  Close passed cygheap shared memory handle.
* spawn.cc (spawn_guts): Ditto.  Also, reorganize to avoid synchronization
between parent and child in non-P_OVERLAY case.
* sigproc.cc (wait_sig): Only signal subproc_ready when execing.
@
text
@d545 2
a546 1
      !DuplicateHandle (hMainProc, myself.shared_handle (), hMainProc, &ciresrv.moreinfo->myself_pinfo, 0,
a581 2
  cygheap_setup_for_child (&ciresrv);

d600 1
d655 1
@


1.80
log
@* fhandler.cc (fhandler_disk_file::fstat): Don't rely on exactly 3 characters
being read for executable test since we could be checking for less than that.
* syscalls.cc (stat_worker): Try opening the file the "correct" way first so
that #! processing can potentially happen.  If that fails, then use "query
open" method.
* spawn.cc (spawn_guts): Delay processing of signal until after we've notified
parent about reparenting.
@
text
@d330 8
a337 2
  HANDLE spr = CreateEvent (&sec_all, TRUE, FALSE, NULL);
  ProtectHandle (spr);
d581 1
a581 2
  ciresrv.cygheap = cygheap;
  ciresrv.cygheap_max = cygheap_max;
d677 1
a749 4
  HANDLE waitbuf[3] = {pi.hProcess, signal_arrived, spr};
  int nwait = 3;
  bool saw_signal = 0;

d753 1
a753 1
  for (int i = 0; i < 100; i++)
d755 3
a757 1
      switch (WaitForMultipleObjects (nwait, waitbuf, FALSE, INFINITE))
d759 1
a759 15
	case WAIT_OBJECT_0:
	  sigproc_printf ("subprocess exited");
	  DWORD exitcode;
	  if (!GetExitCodeProcess (pi.hProcess, &exitcode))
	    exitcode = 1;
	  res |= exitcode;
	  exited = TRUE;
	  break;
	case WAIT_OBJECT_0 + 1:
	  sigproc_printf ("signal arrived");
	  reset_signal_arrived ();
	  saw_signal = 1;
	  continue;
	case WAIT_OBJECT_0 + 2:
	  if (mode == _P_OVERLAY)
d761 13
d778 1
a778 1
		  nwait = 1;
d782 13
a796 12
	case WAIT_FAILED:
	  system_printf ("wait failed: nwait %d, pid %d, winpid %d, %E",
			 nwait, myself->pid, myself->dwProcessId);
	  system_printf ("waitbuf[0] %p %d", waitbuf[0],
			 WaitForSingleObject (waitbuf[0], 0));
	  system_printf ("waitbuf[1] %p = %d", waitbuf[1],
			 WaitForSingleObject (waitbuf[1], 0));
	  system_printf ("waitbuf[w] %p = %d", waitbuf[2],
			 WaitForSingleObject (waitbuf[2], 0));
	  set_errno (ECHILD);
	  try_to_debug ();
	  return -1;
a797 2
      break;
    }
d799 1
a799 1
  ForceCloseHandle (spr);
d801 1
a801 1
  sigproc_printf ("res = %x", res);
d803 1
a803 15
  if (mode == _P_OVERLAY && (res & EXIT_REPARENTING))
    {
      /* Try to reparent child process.
       * Make handles to child available to parent process and exit with
       * EXIT_REPARENTING status. Wait() syscall in parent will then wait
       * for newly created child.
       */
      HANDLE oldh = myself->hProcess;
      HANDLE h = myself->ppid_handle;
      sigproc_printf ("parent handle %p", h);
      int rc = DuplicateHandle (hMainProc, pi.hProcess, h, &myself->hProcess,
				0, FALSE, DUPLICATE_SAME_ACCESS);
      sigproc_printf ("%d = DuplicateHandle, oldh %p, newh %p",
		      rc, oldh, myself->hProcess);
      if (!rc && my_parent_is_alive ())
d805 19
a823 4
	  system_printf ("Reparent failed, parent handle %p, %E", h);
	  system_printf ("my dwProcessId %d, myself->dwProcessId %d",
			 GetCurrentProcessId (), myself->dwProcessId);
	  system_printf ("old hProcess %p, hProcess %p", oldh, myself->hProcess);
d825 1
a826 3

  if (saw_signal && mode != _P_OVERLAY)
    thisframe.call_signal_handler ();
@


1.79
log
@forced commit
@
text
@d746 1
d765 2
a766 2
	  // reset_signal_arrived ();
	  thisframe.call_signal_handler ();
d823 3
@


1.78
log
@* exceptions.cc (interrupt_setup): Move actions from setup_handler to here.
(setup_handler): Move actions after a successful interrupt to interrupt_setup.
* fork.cc (vfork): Augment debugging output.
* sigproc.cc (proc_subproc): Ditto.
* spawn.cc (spawn_guts): Ditto.  Correctly fill out progname when spawn
NO_WAIT.  Call signal handler when a signal arrives.
* sigproc.h: Declare a function.
@
text
@@


1.77
log
@        * autoload.cc: Add load statements for `LookupAccountNameW',
        `LsaClose', `LsaEnumerateAccountRights', `LsaFreeMemory',
        `LsaOpenPolicy', `LsaQueryInformationPolicy', `NetLocalGroupEnum',
        `NetLocalGroupGetMembers', `NetServerEnum', `NetUserGetGroups' and
        `NtCreateToken'.
        * ntdll.h: Add declaration for `NtCreateToken'.
        * sec_helper.cc: Add `well_known_local_sid', `well_known_dialup_sid',
        `well_known_network_sid', `well_known_batch_sid',
        `well_known_interactive_sid', `well_known_service_sid' and
        `well_known_authenticated_users_sid'.
        (cygsid::string): Define as const method.
        (cygsid::get_sid): Set psid to NO_SID on error.
        (cygsid::getfromstr): Ditto.
        (cygsid::getfrompw): Simplify.
        (cygsid::getfromgr): Check for gr == NULL.
        (legal_sid_type): Move to security.h.
        (set_process_privilege): Return -1 on error, otherwise 0 or 1 related
        to previous privilege setting.
        * security.cc (extract_nt_dom_user): Remove `static'.
        (lsa2wchar): New function.
        (open_local_policy): Ditto.
        (close_local_policy): Ditto.
        (get_lsa_srv_inf): Ditto.
        (get_logon_server): Ditto.
        (get_logon_server_and_user_domain): Ditto.
        (get_user_groups): Ditto.
        (is_group_member): Ditto.
        (get_user_local_groups): Ditto.
        (sid_in_token_groups): Ditto.
        (get_user_primary_group): Ditto.
        (get_group_sidlist): Ditto.
        (get_system_priv_list): Ditto.
        (get_priv_list): Ditto.
        (get_dacl): Ditto.
        (create_token): Ditto.
        (subauth): Return immediately if SE_TCB_NAME can't be assigned.
        Change all return statements in case of error to jumps to `out'
        label. Add `out' label to support cleanup.
        * security.h: Add extern declarations for `well_known_local_sid',
        `well_known_dialup_sid', `well_known_network_sid',
        `well_known_batch_sid', `well_known_interactive_sid',
        `well_known_service_sid' and `well_known_authenticated_users_sid'.
        Add extern declarations for functions `create_token',
        `extract_nt_dom_user' and `get_logon_server_and_user_domain'.
        (class cygsid): Add method `assign'. Change operator= to call new
        `assign' method. Add `debug_print' method.
        (class cygsidlist): New class.
        (legal_sid_type): Moved from sec_helper.cc to here.
        * spawn.cc (spawn_guts) Revert reversion of previous patch.
        Call `RevertToSelf' and `ImpersonateLoggedOnUser' instead of `seteuid'
        again.
        * syscalls.cc (seteuid): Rearranged. Call `create_token' now when
        needed. Call `subauth' if `create_token' fails. Try setting token
        owner and primary group only if token was not explicitely created
        by `create_token'.
        * uinfo.cc (internal_getlogin): Try harder to generate correct user
        information. Especially don't trust return value of `GetUserName'.
@
text
@d305 1
a305 1
  syscall_printf ("spawn_guts (%.132s)", prog_arg);
a710 1
      strcpy (myself->progname, real_path);
d713 1
a725 1
      child->progname[0] = '\0';
d729 1
d764 2
a765 1
	  ResetEvent (signal_arrived);
d894 1
@


1.76
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@a624 1
      uid_t uid = geteuid ();
d627 1
a627 1
	seteuid (cygheap->user.orig_uid);
d666 1
a666 1
	seteuid (uid);
@


1.75
log
@        * autoload.cc: Add LoadDLLinitfunc for secur32.dll.
        Add LoadDLLfuncEx statements for AllocateLocallyUniqueId@@4,
        DuplicateTokenEx@@24, LsaNtStatusToWinError@@4,
        LsaDeregisterLogonProcess@@4, LsaFreeReturnBuffer@@4,
        LsaLogonUser@@56, LsaLookupAuthenticationPackage@@12,
        LsaRegisterLogonProcess@@12,
        * environ.cc: Add extern declaration for `subauth_id'.
        (subauth_id_init): New function for setting `subauth_id'.
        (struct parse_thing): Add entry for `subauth_id'.
        * fork.cc (fork_parent): Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * security.cc: Define global variable `subauth_id'.
        (extract_nt_dom_user): New function.
        (cygwin_logon_user): Call `extract_nt_dom_user' now.
        (str2lsa): New static function.
        (str2buf2lsa): Ditto.
        (str2buf2uni): Ditto.
        (subauth): Ditto.
        * security.h: Add prototype for `subauth'.
        * spawn.cc (spawn_guts): Use cygheap->user.token only if impersonated.
        Use `cygsid' type. Remove impersonation before allowing access to
        workstation/desktop to everyone. Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * syscalls.cc (seteuid): Rearranged to allow using subauthentication
        to retrieve user tokens when needed.
@
text
@d615 1
a615 1
	  sid = NULL;
a617 1

d625 1
d628 1
a628 1
	RevertToSelf ();
d667 1
a667 1
	ImpersonateLoggedOnUser (cygheap->user.token);
@


1.74
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d581 2
a582 1
  if (!hToken && cygheap->user.token != INVALID_HANDLE_VALUE)
d611 22
a650 25
      char tu[1024];
      PSID sid = NULL;
      DWORD ret_len;
      if (GetTokenInformation (hToken, TokenUser,
			       (LPVOID) &tu, sizeof tu,
			       &ret_len))
	sid = ((TOKEN_USER *) &tu)->User.Sid;
      else
	system_printf ("GetTokenInformation: %E");

      /* Retrieve security attributes before setting psid to NULL
	 since it's value is needed by `sec_user'. */
      PSECURITY_ATTRIBUTES sec_attribs = allow_ntsec && sid
					 ? sec_user (sa_buf, sid)
					 : &sec_all_nih;

      /* Remove impersonation */
      uid_t uid = geteuid ();
      if (cygheap->user.impersonated
          && cygheap->user.token != INVALID_HANDLE_VALUE)
	seteuid (cygheap->user.orig_uid);

      /* Load users registry hive. */
      load_registry_hive (sid);

d667 1
a667 1
	seteuid (uid);
@


1.73
log
@* path.h (cwdstuff): Move class.
* cygheap.h (cwdstuff): To here.
(init_cygheap): Add cwd field.
* child_info.h (cygheap_exec_info): Eliminate cwd stuff.
(child_info_spawn): Ditto.
* dcrt0.cc (dll_crt0_1): Remove cygcwd.fixup_after_exec call.  Convert cygcwd
reference to cygheap->cwd.
* path.cc: Ditto, throughout.
(cwdstuff::copy): Eliminate.
(cwdstuff::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Eliminate call to cygcwd.copy.
* fhandler.h (FH_OSS_DSP): Move into "fast" device category.
@
text
@d154 1
a154 1
  fhandler_base *fh = fdtab[n];
a342 2
  ciresrv.moreinfo->fds = fdtab;
  ciresrv.moreinfo->nfds = fdtab.size;
d564 1
a564 1
  if (fdtab.need_fixup_before ())
d691 1
a691 1
  if (fdtab.need_fixup_before ())
d693 1
a693 1
      fdtab.fixup_before_exec (pi.dwProcessId);
@


1.72
log
@fix spacing.
@
text
@a531 3
  cygcwd.copy (ciresrv.moreinfo->cwd_posix, ciresrv.moreinfo->cwd_win32,
	       ciresrv.moreinfo->cwd_hash);

@


1.71
log
@* spawn.cc (spawn_guts): Don't set EXIT_REPARENTING if parent process is not a
cygwin process (suggested by Jason Gouger <cygwin@@jason-gouger.com>).
@
text
@d301 1
a301 1
      set_errno(EINVAL);
d310 1
a310 1
      set_errno(EINVAL);
d330 1
a330 1
  HANDLE spr = CreateEvent(&sec_all, TRUE, FALSE, NULL);
d404 1
a404 1
      buf[0] = buf[1] = buf[2] = buf[sizeof(buf) - 1] = '\0';
d623 6
a628 6
      hwst = GetProcessWindowStation();
      SetUserObjectSecurity(hwst, &dsi, get_null_sd ());
      GetUserObjectInformation(hwst, UOI_NAME, wstname, 1024, &n);
      hdsk = GetThreadDesktop(GetCurrentThreadId());
      SetUserObjectSecurity(hdsk, &dsi, get_null_sd ());
      GetUserObjectInformation(hdsk, UOI_NAME, dskname, 1024, &n);
d650 1
a650 1
      uid_t uid = geteuid();
d825 1
a825 1
			 GetCurrentProcessId(), myself->dwProcessId);
@


1.70
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d777 2
a778 1
	      res |= EXIT_REPARENTING;
@


1.69
log
@        * cygerrno.h: Revert previous patch.
        * errno.cc: Ditto.
        * dir.cc: Eliminate `dir_suffixes'.
        (opendir): Remove usage of `dir_suffixes'.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::open): Remove usage of
        `inner_suffixes'.
        * path.cc: Rename `inner_suffixes' to `lnk_suffixes'.
        (path_conv::check): Remove usage of `inner_suffixes'.
        (symlink): Ditto.
        (symlink_info::check): Handle checking for `.lnk' in path_conv
        exclusively here.
        (chdir): Remove usage of `dir_suffixes'.
        * shortcut.c: Eliminate debug_printf lines.
        (check_shortcut): Don't set error except on failing ReadFile.
        * spawn.cc: Remove ".lnk" from `std_suffixes'.
        * syscalls.cc (_unlink): Remove usage of `inner_suffixes'.
        Remove ".lnk" from `stat_suffixes'.
        (_rename): Add check for renaming a symlink to keep the ".lnk"
        suffix after renaming.
@
text
@d24 1
@


1.68
log
@Add copyright year 2001
@
text
@a43 1
  suffix_info (".lnk", 1),
@


1.67
log
@        * Makefile.in: Add `-lshell32 -luuid' to link pass for new-cygwin1.dll.
        * autoload.cc: Add LoadDLLinitfunc for ole32.dll.
        Add LoadDLLfuncEx statements for CoInitialize@@4, CoUninitialize@@0
        and CoCreateInstance@@20.
        * dir.cc (dir_suffixes): New datastructure.
        (readdir): Check for R/O *.lnk files to hide the suffix.
        (opendir): Use `dir_suffixes' in path conversion.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::fstat): Add S_IFLNK flag
        before calling `get_file_attribute'. Take FILE_ATTRIBUTE_READONLY
        into account only if the file is no symlink.
        * path.cc (inner_suffixes): New datastructure.
        (SYMLINKATTR): Eliminated.
        (path_conv::check): Use `inner_suffixes' on inner path components.
        (shortcut_header): New global static variable.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): New function.
        (cmp_shortcut_header): Ditto.
        (symlink): Create symlinks by creating windows shortcuts. Preserve
        the old code.
        (symlink_info::check_shortcut): New method.
        (symlink_info::check_sysfile): Ditto.
        (symlink_info::check): Check for shortcuts. Move code reading
        old system attribute symlinks into symlink_info::check_sysfile().
        (chdir): Use `dir_suffixes' in path conversion.
        * security.cc (get_file_attribute): Check for S_IFLNK flag.
        Force 0777 permissions then.
        * spawn.cc (std_suffixes): Add ".lnk" suffix.
        * syscalls.cc (_unlink): Use `inner_suffixes' in path conversion.
        Check for shortcut symlinks to eliminate R/O attribute before
        calling DeleteFile().
        (stat_suffixes): Add ".lnk" suffix.
        (stat_worker): Force 0777 permissions if file is a symlink.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.66
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d44 1
@


1.65
log
@* spawn.cc (spawn_guts): Quoting was still wrong.  Keep trying to fix it.
@
text
@d31 1
d596 3
@


1.64
log
@* spawn.cc (spawn_guts): YA tweak for dealing with arcane rules of quoting in
"normal" Microsoft programs.
* child_info.h: Bump fork magic number.
* include/sys/mount.h: Add an entry for mixed mode.
@
text
@d483 8
d494 6
a499 1
		  if (*p == '\\' && p[1] == '\\')
d501 6
a506 2
		      one_line.add ("\\\\\\", 3);
		      p++;
a507 3
		  else if ((*p == '\\' && p[1] == '"') || *p == '"')
		    one_line.add ("\\", 1);
		  one_line.add (p, 1);
@


1.63
log
@        * cygheap.h: Move `token' and `impersonated' from class _pinfo
        to class cygheap_user.
        * pinfo.h: Ditto.
        * fork.cc (fork_child): Change usage of `token' and `impersonated'
        accordingly.
        (fork_parent): Ditto.
        * security.cc (cygwin_set_impersonation_token): Ditto.
        * sigproc.cc (proc_subproc): Ditto.
        * spawn.cc (spawn_guts): Ditto.
        * syscalls.cc (seteuid): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
@
text
@d486 6
a491 1
		  if ((*p == '\\' && p[1] == '"') || *p == '"')
@


1.62
log
@        * spawn.cc (spawn_guts): Revert patch to ignore chroot settings
        on creating native Win32 environment.
@
text
@d565 2
a566 2
  if (!hToken && myself->token != INVALID_HANDLE_VALUE)
    hToken = myself->token;
d627 2
a628 1
      if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
d648 2
a649 1
	  && myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
d722 1
a722 1
  if (hToken && hToken != myself->token)
@


1.61
log
@Throughout use myself->ppid_handle rather than parent_alive.
* child_info.h (child_info): Eliminate parent_alive.
* dcrt0.cc (dll_crt0_1): Call fork_init for debugging pid creation.
* fork.cc (fork_child): Reflect change to fixup_mmaps_after_fork arguments.
(slow_pid_reuse): New function to grab last 'n' pids to prevent pid reuse.
(fork_parent): Move last_fork_proc into slow_pid_reuse.  Handle fork_pids
debugging.  Eliminate unnecessary call to set_child_mmap_ptr.
(fork_init): New debugging function.
* mmap.cc (fixup_mmaps_after_fork): Renamed from recreate_mmaps_after_fork.
Rely on copied data after a fork.
(set_child_mmap_ptr): Eliminate.
* pinfo.h (_pinfo): Eliminate parent_alive, mmap_ptr and reflect above changes.
* spawn.cc (spawn_guts): Eliminate vestiges of "old way" of sending new hProc
to parent process.
@
text
@d557 1
a557 6
    {
      cygheap_root sav_root (cygheap->root);
      cygheap->root = NULL;
      envblock = winenv (envp, 0);
      cygheap->root = sav_root;
    }
@


1.60
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d757 1
a757 1
	      if (!parent_alive)
d792 8
a799 4
      pinfo parent (myself->ppid);
      if (!parent)
	/* nothing */;
      else
d801 4
a804 21
	  int rc = 0;
	  HANDLE oldh = myself->hProcess;
	  HANDLE h = myself->ppid_handle;
	  sigproc_printf ("parent handle %p, pid %d", h, parent->dwProcessId);
	  if (h == NULL && GetLastError () == ERROR_INVALID_PARAMETER)
	    rc = 0;
	  else if (h)
	    {
	      rc = DuplicateHandle (hMainProc, pi.hProcess,
				    h, &myself->hProcess, 0, FALSE,
				    DUPLICATE_SAME_ACCESS);
	      sigproc_printf ("%d = DuplicateHandle, oldh %p, newh %p",
			      rc, oldh, myself->hProcess);
	    }
	  if (!rc)
	    {
	      system_printf ("Reparent failed, parent handle %p, %E", h);
	      system_printf ("my dwProcessId %d, myself->dwProcessId %d",
			     GetCurrentProcessId(), myself->dwProcessId);
	      system_printf ("old hProcess %p, hProcess %p", oldh, myself->hProcess);
	    }
@


1.59
log
@* environ.cc (_addenv): malloc space for setenv if cygwin1.dll is used in
conjunction with older binaries.
(environ_init): Ditto.
* external.cc (get_cygdrive_info): New function.
* external.cc (get_cygdrive_prefixes): Change to use get_cygdrive_info but toss
the user and system flags.
* external.cc (cygwin_internal): Add new CW_GET_CYGDRIVE_INFO case.
* path.cc (mount_info::get_cygdrive_prefixes): Remove method.
* path.cc (mount_info::get_cygdrive_info): New method.  Actually,
get_cygdrive_info is really an enhanced version of get_cygdrive_prefixes
renamed to get_cygdrive_info that also gets the user and system flags.
* shared_info.h (get_cygdrive_prefixes): Remove method.
* shared_info.h (get_cygdrive_info): New method.
* include/cygwin/version.h: Bump minor API version due to adding
CW_GET_CYGDRIVE_INFO to cygwin_internal.
* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_CYGDRIVE_INFO.
@
text
@d557 6
a562 1
    envblock = winenv (envp, 0);
d633 1
a633 1
	seteuid (myself->orig_uid);
a712 1
      child->username[0] = '\0';
@


1.58
log
@* child_info.h (child_info): Add pppid_handle for closing the parent's of the
parent handle.
* dcrt0.cc (_dll_crt0): Close parent's parent handle when spawned or forked.
* debug.cc (add_handle): Correct erroneous reference to handle structure when
printing warning.
* exceptions.cc (interrupt_now): Always return 1.
(interrupt_on_return): Accept a sigthread argument.  Check to see if this
argument has been trashed prior to setting up the stack return.
(call_handler): Add a loop around attempts to dispatch signals to detect case
where interrupt_on_return fails.
(_sigdelayed): Set up a temporary frame pointer prior to calling stuff that
could trigger an interrupt or the stack walking code will be very confused.
* fork.cc (fork_parent): Move a lot of the setup of the child process into
proc_subproc.
* spawn.cc (spawn_guts): Ditto.  Use ppid_handle to contact logical parent when
reparenting.
* pinfo.h (_pinfo): Remember the logical handle of the parent process.
* sigproc.cc (proc_subproc): Record most stuff necessary for the _pinfo
structure that is inferrable from myself when adding children.
(wait_sig): Always set 'pending_signals' flag when about to kick off the signal
scanning loop.  Reset it only if there are no pending signals.
@
text
@d514 1
a514 1
  ciresrv.moreinfo->envc = envsize (envp, 0);
@


1.57
log
@* pinfo.cc (EnumProcessesNT): Avoid 0 pids.
(EnumProcesses9x): Ditto.
* sigproc.cc (remove_childe): Eliminate.
(proc_subproc): Move remove_child stuff here.
(wait_subproc): Synchronize with proc_subproc when error occurs.  Add more
debugging info.
* sigproc.h (procstuff): Add an entry.
* spawn.cc (spawn_guts): Add sigframe here.
@
text
@a709 16
      child->ppid = myself->pid;
      child->gid = myself->gid;
      child->pgid = myself->pgid;
      child->sid = myself->sid;
      child->ctty = myself->ctty;
      child->umask = myself->umask;
      child->process_state |= PID_INITIALIZING;
      if (myself->use_psid)
	{
	  child->use_psid = 1;
	  memcpy (child->psid, myself->psid, MAX_SID_LEN);
	}
      memcpy (child->logsrv, myself->logsrv, MAX_HOST_NAME);
      memcpy (child->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
      memcpy (child->root, myself->root, MAX_PATH+1);
      child->rootlen = myself->rootlen;
d795 1
a795 2
	  HANDLE h = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
				  parent->dwProcessId);
d798 1
a798 1
	    rc = 1;
a800 1
	      ProtectHandle (h);
a805 1
	      ForceCloseHandle (h);
@


1.56
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d292 1
@


1.55
log
@        * dtable.cc (dtable::release): Check for socket. Change
        cnt_need_fixup_before accordingly.
        (dtable::dup2): Ditto.
        (dtable::fixup_before_fork): New method.
        (dtable::fixup_before_exec): Ditto.
        * dtable.h (class dtable): Add member `cnt_need_fixup_before'. Add
        definition for methods `dec_need_fixup_before', `inc_need_fixup_before',
        `need_fixup_before', `fixup_before_exec' and `fixup_before_fork'.
        * fhandler.h (class fhandler_base): Slight rearrangements. Add
        definitions for methods `fixup_before_fork_exec'.
        (class fhandler_socket): Eliminate superfluous constructor.
        Add member `prot_info_ptr'. Add destructor. Add definitions for
        methods `dup', `fixup_before_fork_exec', `fixup_after_fork' and
        `fixup_after_exec'.
        * fork.cc (fork_parent): Care for file types which need a fixup
        before fork. Start child in suspended state then.
        * net.cc: New global variable `ws2_32_handle' and `wsadata'.
        (fdsock): Check for Winsock version. Call `set_socket_inheritance'
        only if Winsock version < 2.0. Care for `need_fixup' count in fdtab.
        (cygwin_socket): Eliminate call to `set_socket_inheritance'.
        (cygwin_accept): Ditto.
        (cygwin_rcmd): Ditto.
        (cygwin_rresvport): Ditto.
        (cygwin_rexec): Ditto.
        (socketpair): Ditto.
        (fhandler_socket::fhandler_socket): Set `need_fork_fixup'. Allocate
        space for the WSAPROTOCOL_INFOA struct used in fixup.
        (fhandler_socket::~fhandler_socket): New destructor.
        (fhandler_socket::fixup_before_fork_exec): New method.
        (fhandler_socket::fixup_after_fork): Ditto.
        (fhandler_socket::dup): Ditto.
        (wsock_init): New static function.
        (LoadDLLinitfunc (wsock32)): Rearranged.
        (LoadDLLinitfunc (ws2_32)): New function.
        (dummy_autoload): Add autoload statemants for `WSADuplicateSocketA'
        and `WSASocketA'.
        * spawn.cc (spawn_guts): Care for file types which need a fixup
        before exec. Start child in suspended state then.
@
text
@d453 1
a453 1
	  
@


1.54
log
@* dcrt0.cc (do_exit): Don't bother looking for pgrp children to send SIGHUP if
process has never created any children.
* fork.cc (fork): Set flag indicating that there is another process with our
process group.
* spawn.cc (spawn_guts): Ditto.
* pinfo.h (set_has_pgid_children): New methods for setting when process has
children in its process group.
* syscalls.cc (setpgid): Clear has_gid_children if pgid changes.
@
text
@d543 8
d665 9
@


1.53
log
@* exceptions.cc (signal_exit): Kill any executing child process if we're dying.
* path.h: Remove unneeded extern.
* spawn.cc (std_suffixes): Make static.  Don't set dwProcessId here since it
makes the process unsignalable.  Set strace flag that this is an execed process
stub.
* strace.cc (strace::vsprntf): Use strace flag to indicate when to visually
flag that this is an exec stub.
* include/sys/strace.h (strace): Add 'execing' flag.
@
text
@d681 1
@


1.52
log
@* spawn.cc (spawn_guts): Don't do the reparenting step if we notice that the
child has exited prior to sending the subprocess_ready signal
(?).
@
text
@d40 1
a40 1
suffix_info std_suffixes[] =
d48 2
d676 2
a677 1
      myself->dwProcessId = pi.dwProcessId;
@


1.51
log
@* fhandler.h (fhandler_console): Remove tcsetpgrp.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Eliminate.
* fork.cc (fork_parent): Avoid returning same pid twice in a row regardless of
OS.
* pinfo.cc (pinfo::init): Rename create argument to flags and treat it as such.
* signal.cc (set_sigcatchers): New function.
(signal): Use set_sigcatchers to increment or decrement sigcatcher tracker.
(sigaction): Ditto.  Add debugging output.
* spawn.cc (spawn_guts): Always quote first argv[0] argument when it's a
COMSPEC shell.
@
text
@a737 4

	  if (nwait > 2 && !(res & EXIT_REPARENTING) &&
	      (mode == _P_OVERLAY || mode == _P_VFORK))
	    res |= EXIT_REPARENTING;
d821 1
a821 1
      myself->exit (0, 1);
@


1.50
log
@* external.cc (fillout_pinfo): Pass PID_NOREDIR flag to pinfo init to avoid
finding execed processes twice.
* signal.cc (kill_pgrp): Ditto.
* spawn.cc (spawn_guts): Avoid passing first argument to CreateProcess when
running a windows shell so that CreateProcess will locate the shell.
Reorganize so that correct error is returned when CreateProcess fails.
@
text
@d355 1
d360 1
@


1.49
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d178 1
a178 3
  linebuf () : ix (0), buf (NULL), alloced (0)
  {
  }
d350 1
d354 5
a358 1
      one_line.add (argv[0]);
d364 1
a531 2
  syscall_printf ("spawn_guts (%s, %.132s)", (char *) real_path, one_line.buf);

d555 5
a559 1
cygbench ("spawn-guts");
d563 1
a563 1
      rc = CreateProcess (real_path,	/* image name - with full path */
d621 1
a621 1
		       real_path,	/* image name - with full path */
d648 2
a651 2
      __seterrno ();
      syscall_printf ("CreateProcess failed, %E");
@


1.48
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@a160 2
HANDLE NO_COPY hExeced = NULL;

a289 1
  int i;
a292 2
  hExeced = NULL;

d505 3
a507 1
  ciresrv.moreinfo->environ = (char **) cmalloc (HEAP_1_ARGV, envsize (envp, 1));
d510 1
a510 1
  for (c = ciresrv.moreinfo->environ, e = envp; *e;)
d530 1
a530 2
  int flags = CREATE_DEFAULT_ERROR_MODE | CREATE_SUSPENDED |
	      GetPriorityClass (hMainProc);
d534 2
d553 18
a570 1
  if (hToken)
d579 1
a630 13
  else
    rc = CreateProcess (real_path,	/* image name - with full path */
		        one_line.buf,	/* what was passed to exec */
					/* process security attrs */
		        allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
					/* thread security attrs */
		        allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
		        TRUE,	/* inherit handles from parent */
		        flags,
		        envblock,/* environment */
		        0,	/* use current drive/directory */
		        &si,
		        &pi);
a659 1
  ProtectHandle (pi.hThread);
d663 2
a665 1
      hExeced = pi.hProcess;
a666 9

      /* Set up child's signal handlers */
      /* CGF FIXME - consolidate with signal stuff below */
      for (i = 0; i < NSIG; i++)
	{
	  myself->getsig(i).sa_mask = 0;
	  if (myself->getsig(i).sa_handler != SIG_IGN || (mode != _P_OVERLAY))
	    myself->getsig(i).sa_handler = SIG_DFL;
	}
d670 1
a670 1
      pinfo_fixup_in_spawned_child (pi.hProcess);
a680 1
      child->uid = myself->uid;
a697 13
      for (i = 0; i < NSIG; i++)
	{
	  child->getsig(i).sa_mask = 0;
	  if (child->getsig(i).sa_handler != SIG_IGN || (mode != _P_OVERLAY))
	    child->getsig(i).sa_handler = SIG_DFL;
	}
      if (hToken)
	{
	  /* Set child->uid to USHRT_MAX to force calling internal_getlogin()
	     from child process. Clear username and psid to play it safe. */
	  child->uid = USHRT_MAX;
	  child->use_psid = 0;
	}
d699 2
d703 2
a705 3
  /* Start the child running */
  ResumeThread (pi.hThread);
  ForceCloseHandle (pi.hThread);
a807 10
      if (hExeced)
	{
	  ForceCloseHandle1 (hExeced, childhProc);
	  hExeced = INVALID_HANDLE_VALUE;
	}
    }
  else if (exited)
    {
      ForceCloseHandle1 (hExeced, childhProc);
      hExeced = INVALID_HANDLE_VALUE; // stop do_exit from attempting to terminate child
d815 1
d817 1
a817 4
      struct rusage r;
      fill_rusage (&r, hMainProc);
      add_rusage (&myself->rusage_self, &r);
      ExitProcess (0);
@


1.47
log
@* cygheap.cc (cygheap_fixup_in_child): Don't page round cygheap copied from
parent.
* dcrt0.cc (do_exit): Don't cleanup pinfo on exit.  That happens automatically
now.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_parent): Use stack_here value passed in from fork().
(fork): Figure out top of stack here and pass it to fork_parent.
* pinfo.cc (_pinfo::record_death): Eliminate.
* pinfo.h (_pinfo): Ditto.
* sigproc.cc (proc_exists): Simplify.
(proc_terminate): Ditto.
(remove_zombie): Don't cleanup pinfo stuff.
(wait_sig): Send subproc_ready signal whether execed or spawned.
* spawn.cc (spawn_guts): Always create subproc_ready event.  Use it for both
exec and spawn.
(_spawnve): Send proper mode to spawn_guts when mode != _P_OVERLAY.
@
text
@a221 10
static HANDLE hexec_proc = NULL;

void __stdcall
exec_fixup_after_fork ()
{
  if (hexec_proc)
    CloseHandle (hexec_proc);
  hexec_proc = NULL;
}

d344 1
a344 1
  ciresrv.moreinfo->old_title = old_title ? cstrdup (old_title) : NULL;
a554 8
  /* FIXME:  This leaves a handle to the process open so that the pid is not
     duplicated.  However, if a process execs another process two handles are
     left open, which is unnecessary. */
  if (mode == _P_OVERLAY && !hexec_proc &&
      !DuplicateHandle (hMainProc, hMainProc, hMainProc, &hexec_proc, 0,
			TRUE, DUPLICATE_SAME_ACCESS))
    system_printf ("couldn't save current process handle %p, %E", hMainProc);

d616 2
a617 2
    rc = CreateProcessA (real_path,	/* image name - with full path */
		       one_line.buf,	/* what was passed to exec */
d619 1
a619 1
		       allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
d621 7
a627 7
		       allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
		       TRUE,	/* inherit handles from parent */
		       flags,
		       envblock,/* environment */
		       0,	/* use current drive/directory */
		       &si,
		       &pi);
d676 1
d845 3
@


1.46
log
@* errno.cc (seterrno_from_win_error): Fix debugging output.
* fhandler.cc (fhandler_base::fstat): Move to inline method in fhandler.h.
(fhandler_base::set_io_handle): Ditto.
* fhandler.h (fhandler_base): Make some methods inline.
* fhandler_console.cc (fhandler_console::write_normal): Make buffer larger.
* sigproc.h (sigframe::sigframe): Actually use set ebp parameter correctly.
* spawn.cc (spawn_guts): Set dwProcessId when exec'ing.  Just exit immediately
after reparenting.
* syscalls.cc: Sprinkle sigframe stuff throughout.
* wait.cc (wait4): Set signal frame here.
* dcrt0.cc (__api_fatal): Don't rely on small_printf to display errors.  Always
display problems to the console, if possible.
@
text
@a160 15
/* Cover function for CreateProcess.

   This function is used by both the routines that search $PATH and those
   that do not.  This should work out ok as according to the documentation,
   CreateProcess only searches $PATH if PROG has no directory elements.

   Spawning doesn't fit well with Posix's fork/exec (one can argue the merits
   of either but that's beside the point).  If we're exec'ing we want to
   record the child pid for fork.  If we're spawn'ing we don't want to do
   this.  It is up to the caller to handle both cases.

   The result is the process id.  The handle of the created process is
   stored in H.
*/

d240 1
a240 1
    argv = (char **) cmalloc (HEAP_1_ARGV, (argc + 1) * sizeof (char *));
a335 1
  HANDLE spr = NULL;
d340 4
a343 5
    {
      spr = CreateEvent(&sec_all, TRUE, FALSE, NULL);
      ProtectHandle (spr);
      chtype = PROC_EXEC;
    }
a540 2
  /* Pass fd table to a child */

a679 2
      // close_all_files ();
      proc_terminate ();
d747 1
d749 7
a755 1
  if (mode == _P_OVERLAY || mode == _P_VFORK)
d757 1
a757 10
      BOOL exited;

      HANDLE waitbuf[3] = {pi.hProcess, signal_arrived, spr};
      int nwait = 3;

      SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST);
      res = 0;
      exited = FALSE;
      MALLOC_CHECK;
      for (int i = 0; i < 100; i++)
d759 18
a776 1
	  switch (WaitForMultipleObjects (nwait, waitbuf, FALSE, INFINITE))
d778 2
a779 19
	    case WAIT_OBJECT_0:
	      sigproc_printf ("subprocess exited");
	      DWORD exitcode;
	      if (!GetExitCodeProcess (pi.hProcess, &exitcode))
		exitcode = 1;
	      res |= exitcode;
	      exited = TRUE;

	      if (nwait <= 2 || (res & EXIT_REPARENTING) || (mode != _P_OVERLAY && mode != _P_VFORK))
		/* nothing to do */;
	      else if (WaitForSingleObject (spr, 1) == WAIT_OBJECT_0)
		goto reparent;
	      break;
	    case WAIT_OBJECT_0 + 1:
	      sigproc_printf ("signal arrived");
	      ResetEvent (signal_arrived);
	      continue;
	    case WAIT_OBJECT_0 + 2:
	      if (mode == _P_OVERLAY)
d781 3
a783 8
	      reparent:
		  res |= EXIT_REPARENTING;
		  if (!parent_alive)
		    {
		      nwait = 1;
		      sigproc_terminate ();
		      continue;
		    }
a784 11
	      break;
	    case WAIT_FAILED:
	      DWORD r;
	      system_printf ("wait failed: nwait %d, pid %d, winpid %d, %E",
			     nwait, myself->pid, myself->dwProcessId);
	      system_printf ("waitbuf[0] %p %d", waitbuf[0],
			     GetHandleInformation (waitbuf[0], &r));
	      system_printf ("waitbuf[1] %p = %d", waitbuf[1],
			     GetHandleInformation (waitbuf[1], &r));
	      set_errno (ECHILD);
	      return -1;
d787 12
d800 2
d803 1
a803 1
      ForceCloseHandle (spr);
d805 1
a805 1
      sigproc_printf ("res = %x", res);
d807 11
a817 1
      if (res & EXIT_REPARENTING)
d819 8
a826 9
	  /* Try to reparent child process.
	   * Make handles to child available to parent process and exit with
	   * EXIT_REPARENTING status. Wait() syscall in parent will then wait
	   * for newly created child.
	   */
	  pinfo parent (myself->ppid);
	  if (!parent)
	    /* nothing */;
	  else
d828 7
a834 24
	      int rc = 0;
	      HANDLE oldh = myself->hProcess;
	      HANDLE h = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
				      parent->dwProcessId);
	      sigproc_printf ("parent handle %p, pid %d", h, parent->dwProcessId);
	      if (h == NULL && GetLastError () == ERROR_INVALID_PARAMETER)
		rc = 1;
	      else if (h)
		{
		  ProtectHandle (h);
		  rc = DuplicateHandle (hMainProc, pi.hProcess,
					h, &myself->hProcess, 0, FALSE,
					DUPLICATE_SAME_ACCESS);
		  sigproc_printf ("%d = DuplicateHandle, oldh %p, newh %p",
				  rc, oldh, myself->hProcess);
		  ForceCloseHandle (h);
		}
	      if (!rc)
		{
		  system_printf ("Reparent failed, parent handle %p, %E", h);
		  system_printf ("my dwProcessId %d, myself->dwProcessId %d",
				 GetCurrentProcessId(), myself->dwProcessId);
		  system_printf ("old hProcess %p, hProcess %p", oldh, myself->hProcess);
		}
d836 1
a836 1
	  if (hExeced)
d838 4
a841 3
	      ForceCloseHandle1 (hExeced, childhProc);
	      hExeced = INVALID_HANDLE_VALUE;
	      close_all_files ();
d844 1
a844 1
      else if (exited)
d847 1
a847 1
	  hExeced = INVALID_HANDLE_VALUE; // stop do_exit from attempting to terminate child
d849 6
d856 1
a856 4
      MALLOC_CHECK;
      if (mode == _P_OVERLAY)
	ExitProcess (res);
    }
d860 4
d923 1
a923 1
      ret = spawn_guts (hToken, path, argv, envp, 0);
@


1.45
log
@* dtable.cc (set_std_handle): Use std_consts array to control SetStdHandle
settings.
(dtable::fixup_after_fork): Ditto.
* exceptions.cc (set_sig_errno): Remove some debugging output.
* path.cc (path_conv::check): Don't OR need_directory with flags sent to
symlink_info::check.
(symlink_info::check): Use PATH_ALL_EXEC to determine when a file is
executable.
* path.h (path_types): Add PATH_ALL_EXEC.
(isexec): Use PATH_ALL_EXEC so that cygexec types will be considered
executable.
* pinfo.h (_pinfo): Add a process handle that is kept open throughout the life
of a cygwin pid.
* sigproc.cc (proc_exists): Remove hopefully obsolete stuff.
(proc_subproc): Set up process handle that is kept open throughout the life of
a cygwin pid.  Reorganize PROC_WAIT stuff to use common code.
(proc_terminate): Close pid lifetime process handle.
(checkstate): Cleanup.
(stopped_or_terminated): Move zombie cleanup.
(remove_zombie): To here.
* spawn.cc (spawn_guts): Reorganize reparenting code for 1247th time.
@
text
@d702 1
d884 1
a884 1
	do_exit (res | EXIT_NOCLOSEALL);
@


1.44
log
@* path.cc (symlink_info::check): Set executable bit for a file if the first two
characters are 'MZ' to mirror spawn_guts check.
@
text
@d690 1
a690 2
		  rc ? cygpid : (unsigned int) -1,
		  prog_arg, one_line.buf);
a691 1
  MALLOC_CHECK;
a694 1
  MALLOC_CHECK;
d785 4
a788 2
	      if (!GetExitCodeProcess (pi.hProcess, &res))
		res = 1;
d791 1
a791 1
	      if (nwait <= 2 || mode != _P_OVERLAY)
a794 6
	      else if (!(res & EXIT_REPARENTING))
		{
		  MALLOC_CHECK;
		  close_all_files ();
		  MALLOC_CHECK;
		}
a804 1
		  close_all_files ();
d843 6
a848 5
	      int rc;
	      HANDLE hP = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
				       parent->dwProcessId);
	      sigproc_printf ("parent handle %p, pid %d", hP, parent->dwProcessId);
	      if (hP == NULL && GetLastError () == ERROR_INVALID_PARAMETER)
d850 1
a850 1
	      else if (hP)
d852 3
a854 3
		  ProtectHandle (hP);
		  rc = DuplicateHandle (hMainProc, pi.hProcess, hP,
					&myself->hProcess, 0, FALSE,
d856 3
a858 2
		  sigproc_printf ("Dup hP %d", rc);
		  ForceCloseHandle (hP);
d860 1
a860 1
	      if (!res)
d862 1
a862 1
		  system_printf ("Reparent failed, parent handle %p, %E", hP);
d865 1
a865 3
		  system_printf ("myself->process_state %x",
				 myself->process_state);
		  system_printf ("myself->hProcess %x", myself->hProcess);
d868 6
a873 2
	  ForceCloseHandle1 (hExeced, childhProc);
	  hExeced = INVALID_HANDLE_VALUE;
@


1.43
log
@* spawn.cc (spawn_guts): Attempt to accomodate archaic windows quoting
mechanism when dealing with '\' and '"'.
@
text
@d426 1
a426 1
      if (! ReadFile (hnd, buf, sizeof (buf) - 1, &done, 0))
d459 2
a460 2
		   end of the line, exit the loop.  Otherwise, position
		   we've found the first argument. Position the current
@


1.42
log
@* dcrt0.cc (quoted): Fix problem where ' quoted strings were skipped.
* fhandler.h (fhandler_socket::~fhandler_socket): Delete declaration.
* net.cc: Remove unnecessary "number_of_sockets" usage.
(fhandler_socket::fhandler_socket): Ditto.
(fhandler_socket::~fhandler_socket): Delete definition.
* spawn.cc (spawn_guts): Force first argument passed to CreateProcess as a
command line to be windows style.
@
text
@d255 1
a255 1
    argv = (char **) cmalloc (HEAP_ARGV, (argc + 1) * sizeof (char *));
d272 1
a272 1
	argv[0] = cstrdup (arg0);
d279 1
a279 1
      argv[i] = cstrdup (argv[i]);
d284 1
a284 1
      argv[i] = cstrdup (argv[i]);
d307 1
a307 1
  *argv = cstrdup (what);
d370 1
a370 1
  ciresrv.moreinfo = (cygheap_exec_info *) ccalloc (HEAP_EXEC, 1, sizeof (cygheap_exec_info));
d509 1
a509 1
		  if (*p == '\\' || *p == '"')
d537 1
a537 1
  ciresrv.moreinfo->environ = (char **) cmalloc (HEAP_ARGV, envsize (envp, 1));
d541 1
a541 1
    *c++ = cstrdup (*e++);
@


1.41
log
@* spawn.cc (av::dup_maybe): Make function void rather than void *.
* environ.cc (environ_init): Remember to reparse CYGWIN if envp is
supplied.
* heap.cc (_sbrk): Remember frame for signal handling.
* syscalls.cc (read_handler): Eliminate.
(_read): Move read_handler code here.  Reorganize for one path through
'ready_for_read'.
@
text
@d499 1
a499 1
	  a = newargv[i];
@


1.40
log
@* spawn.cc (spawn_guts): Use actual program argument passed in for argv[0] as
originally suggested by Kazuhiro Fujieda <fujieda@@jaist.ac.jp>.
@
text
@d276 1
a276 1
  void *dup_maybe (int i)
@


1.39
log
@* spawn.cc (av): Hide 'calloced' field and limit cstrduping to class methods
only.
(spawn_guts): Use methods for manipulating most newargv stuff.
* child_info.h (child_info_spawn::~child_info_spawn): Avoid memory leaks in
cygheap.
* spawn.cc (spawn_guts): Ditto.
* dcrt0.cc (quoted): Return next character after a quoted string when not doing
special quote processing.  Also ensure that non-NULL is returned in all circumstances.
* spawn.cc (spawn_guts): Ensure that argv[0] is correctly set to the full path
when a script is detected.  Suggested by Kazuhiro Fujieda
<fujieda@@jaist.ac.jp>.
@
text
@d476 1
a476 1
      newargv.replace0_maybe (real_path);
@


1.38
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d247 1
a247 1
struct av
d249 1
a249 1
  int argc;
a250 2
private:
  char **argv;
d252 2
a253 1
  av (int ac, const char * const *av) : argc (ac), calloced (0)
d266 20
a324 1
// if (strstr (prog_arg, "dopath")) try_to_debug ();
d438 1
a438 1
      debug_printf ("%s is a script", prog_arg);
d440 1
a440 1
      char *ptr, *pgm, *arg1;
a444 1
	  ptr = buf + 2;
d449 1
d474 4
a480 1
       * ptr	end of string
d490 1
a490 2
    for (int i = newargv.calloced; i < newargv.argc; i++)
      newargv[i] = cstrdup (newargv[i]);
d498 1
a498 2
	  if (i >= newargv.calloced)
	    newargv[i] = cstrdup (newargv[i]);
d529 2
@


1.37
log
@* sigproc.cc: Add include file for proper definitions.
* spawn.cc: Ditto.
* winsup.h: Define cfree to avoid newlib pollution.
@
text
@d23 1
d32 1
d34 3
@


1.36
log
@* path.cc (cwd_win32): Eliminate.
(cwd_posix): Eliminate.
(cwd_hash): Eliminate.
(cwdstuff::init): Rename from cwd_init.
(cwdstuff::fixup_after_exec): Rename from cwd_fixup_after_exec.
(cwdstuff::get): Rename from get_cwd_inner.
(normalize_posix_path): Eliminate cwd argument.  Just calculate when necessary.
(normalize_win32_path): Ditto.
(mount_info::conv_to_win32_path): Eliminate cwd retrieval here.
(mount_info::conv_to_posix_path): Ditto.
(hash_path_name): Accomodate additional methods in cwdstuff.
(get_cwd_win32): Eliminate.
(getcwd): Use cwdstuff methods.  Properly handle case where buf == NULL and len
< 0.
(cwdstuff::get_hash): New method.
(cwdstuff::get_initial): New method.
(cwdstuff::set): New method.
(cwdstuff::get): New method.
(cwdstuff::copy): New method.
* path.h: Move cwdstuff struct here.  Add a bunch of stuff to cwdstuff.  Make
cygcwd an extern.
* spawn.cc (spawn_guts): Use copy method to get copies of cwd info to pass to
execed process.
* dcrt0.cc (dll_crt0_1): Use cygcwd methods for cwd initialization.
@
text
@d28 1
a30 1
#include "cygheap.h"
@


1.35
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d508 2
a509 4
  /* FIXME: Should lock cwd access here. */
  ciresrv.moreinfo->cwd_posix = cwd_posix (NULL);
  ciresrv.moreinfo->cwd_win32 = cwd_win32 (NULL);
  ciresrv.moreinfo->cwd_hash = cwd_hash ();
@


1.34
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d516 1
a516 1
  for (c = ciresrv.moreinfo->environ, e = envp; *e; )
@


1.33
log
@* sigproc.cc (proc_info): Rename proc_exists which takes a pid to "pid_exists".
* shared.h: Split out "child_info" stuff into a new header file and use where
necessary.  Declare pid_exists.
* child_info.h: New file.
@
text
@a21 1
#include <paths.h>
d30 1
a32 2
extern BOOL allow_ntsec;

a171 1
DWORD NO_COPY exec_exit = 0;
d242 47
a294 1
  int argc;
d301 1
d318 34
d355 2
a356 1
  for (argc = 0; argv[argc]; argc++)
d359 1
a359 4
  char *real_path;
  path_conv real_path_buf;

  linebuf one_line;
d361 1
a361 1
  if (argc == 3 && argv[1][0] == '/' && argv[1][1] == 'c' &&
a367 1
      real_path = NULL;
d369 1
a369 1
      strcpy (real_path_buf, argv[0]);
a372 4
  real_path = real_path_buf;

  const char *saved_prog_arg;
  const char *newargv0, **firstarg;
d374 1
a374 2

  if ((ext = perhaps_suffix (prog_arg, real_path_buf)) == NULL)
a380 3
  saved_prog_arg = prog_arg;
  newargv0 = argv[0];
  firstarg = &newargv0;
d421 1
a421 2
	  strcpy (buf, "sh");         /* shell script without magic */
	  pgm = buf;
a447 1

a450 2
      char buf2[MAX_PATH + 1];

d456 2
d459 2
a460 27
      if (!arg1)
	one_line.prepend (" ", 1);
      else
	{
	  one_line.prepend ("\" ", 2);
	  one_line.prepend (arg1, strlen (arg1));
	  one_line.prepend (" \"", 2);
	}

      find_exec (pgm, real_path_buf, "PATH=", 0, &ext);
      cygwin_conv_to_posix_path (real_path, buf2);
      one_line.prepend (buf2, strlen (buf2));

      /* If script had absolute path, add it to script name now!
       * This is necessary if script has been found via PATH.
       * For example, /usr/local/bin/tkman started as "tkman":
       * #!/usr/local/bin/wish -f
       * ...
       * We should run /usr/local/bin/wish -f /usr/local/bin/tkman,
       * but not /usr/local/bin/wish -f tkman!
       * We don't modify anything, if script has qulified path.
       */
      if (firstarg)
	*firstarg = saved_prog_arg;

      debug_printf ("prog_arg '%s', copy '%s'", prog_arg, one_line.buf);
      firstarg = NULL;
d463 4
a466 1
  for (; *argv; argv++)
d468 4
a471 2
      char *p = NULL;
      const char *a = newargv0 ?: *argv;
d473 7
a479 10
      MALLOC_CHECK;

      newargv0 = NULL;
      int len = strlen (a);
      if (len != 0 && !strpbrk (a, " \t\n\r\""))
	one_line.add (a, len);
      else
	{
	  one_line.add ("\"", 1);
	  for (; (p = strpbrk (a, "\"\\")); a = ++p)
d481 11
a491 4
	      one_line.add (a, p - a);
	      if (*p == '\\' || *p == '"')
		one_line.add ("\\", 1);
	      one_line.add (p, 1);
d493 3
a495 3
	  if (*a)
	    one_line.add (a);
	  one_line.add ("\"", 1);
d497 1
d499 4
a502 1
      one_line.add (" ", 1);
d505 2
d508 15
a522 6
  MALLOC_CHECK;
  if (one_line.ix)
    one_line.buf[one_line.ix - 1] = '\0';
  else
    one_line.add ("", 1);
  MALLOC_CHECK;
a525 1
  STARTUPINFO si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL};
d536 1
a536 47
  MALLOC_CHECK;
  int len = fdtab.linearize_fd_array (0, 0);
  MALLOC_CHECK;
  if (len == -1)
    {
      system_printf ("FATAL error in linearize_fd_array");
      return -1;
    }
  int titlelen = 1 + (old_title && mode == _P_OVERLAY ? strlen (old_title) : 0);
  si.cbReserved2 = len + titlelen + sizeof(child_info);
  si.lpReserved2 = (LPBYTE) alloca (si.cbReserved2);

# define ciresrv ((child_info *)si.lpReserved2)
  HANDLE spr = NULL;
  DWORD chtype;
  if (mode != _P_OVERLAY)
    chtype = PROC_SPAWN;
  else
    {
      spr = CreateEvent(&sec_all, TRUE, FALSE, NULL);
      ProtectHandle (spr);
      chtype = PROC_EXEC;
    }

  init_child_info (chtype, ciresrv, (mode == _P_OVERLAY) ? myself->pid : 1, spr);
  if (mode != _P_OVERLAY ||
      !DuplicateHandle (hMainProc, myself.shared_handle (), hMainProc,
			&ciresrv->myself_pinfo, 0,
			TRUE, DUPLICATE_SAME_ACCESS))
   ciresrv->myself_pinfo = NULL;

  LPBYTE resrv = si.lpReserved2 + sizeof *ciresrv;

  if (fdtab.linearize_fd_array (resrv, len) < 0)
    {
      system_printf ("FATAL error in second linearize_fd_array");
      return -1;
    }

  if (titlelen > 1)
    strcpy ((char *) resrv + len, old_title);
  else
    resrv[len] = '\0';

  /* We print the translated program and arguments here so the user can see
     what was done to it.  */
  syscall_printf ("spawn_guts (%s, %.132s)", real_path, one_line.buf);
d545 8
a552 1
  char *envblock = winenv (envp, 0);
d560 3
d565 1
a565 1
		        TRUE, DUPLICATE_SAME_ACCESS))
d591 3
a593 3
                               (LPVOID) &tu, sizeof tu,
                               &ret_len))
        sid = ((TOKEN_USER *) &tu)->User.Sid;
d595 1
a595 1
        system_printf ("GetTokenInformation: %E");
d598 1
a598 1
         since it's value is needed by `sec_user'. */
d600 2
a601 2
                                         ? sec_user (sa_buf, sid)
                                         : &sec_all_nih;
d606 1
a606 1
        seteuid (myself->orig_uid);
d614 2
a615 2
                       sec_attribs,     /* process security attrs */
                       sec_attribs,     /* thread security attrs */
d623 4
a626 4
         allowed since it would overwrite child data. */
      if (mode != _P_OVERLAY
          && myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
        seteuid (uid);
d631 4
a634 4
                                        /* process security attrs */
                       allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
                                        /* thread security attrs */
                       allow_ntsec ? sec_user (sa_buf) : &sec_all_nih,
d643 2
a644 1
  free (envblock);
a646 3
  if (ciresrv->myself_pinfo)
    CloseHandle (ciresrv->myself_pinfo);

a650 2

  if (!rc)
d677 2
a678 2
      close_all_files ();
      strcpy (myself->progname, real_path_buf);
a701 2
      // CGF FIXME -- need to do this? strcpy (child->progname, path);
      // CGF FIXME -- need to do this? memcpy (child->username, myself->username, MAX_USER_NAME);
d747 1
a747 1
  if (mode == _P_OVERLAY)
a755 2
      DWORD timeout = INFINITE;
      exec_exit = 1;
d760 1
a760 1
	  switch (WaitForMultipleObjects (nwait, waitbuf, FALSE, timeout))
d762 11
a772 3
	    case WAIT_TIMEOUT:
	      syscall_printf ("WFMO timed out after signal");
	      if (WaitForSingleObject (pi.hProcess, 0) != WAIT_OBJECT_0)
d774 3
a776 2
		  sigproc_printf ("subprocess still alive after signal");
		  res = exec_exit;
a777 18
	      else
		{
		  sigproc_printf ("subprocess exited after signal");
	    case WAIT_OBJECT_0:
		  sigproc_printf ("subprocess exited");
		  if (!GetExitCodeProcess (pi.hProcess, &res))
		    res = exec_exit;
		  exited = TRUE;
		 }
	      if (nwait > 2)
		if (WaitForSingleObject (spr, 1) == WAIT_OBJECT_0)
		  res |= EXIT_REPARENTING;
		else if (!(res & EXIT_REPARENTING))
		  {
		    MALLOC_CHECK;
		    close_all_files ();
		    MALLOC_CHECK;
		  }
d784 1
a784 5
	      res = EXIT_REPARENTING;
	      MALLOC_CHECK;
	      ForceCloseHandle (spr);
	      MALLOC_CHECK;
	      if (!parent_alive)
d786 9
a794 3
		  nwait = 1;
		  sigproc_terminate ();
		  continue;
d811 1
a811 2
      if (nwait > 2)
	ForceCloseHandle (spr);
d827 1
d832 1
a832 1
		res = 1;
d836 4
a839 4
		  res = DuplicateHandle (hMainProc, pi.hProcess, hP,
					 &myself->hProcess, 0, FALSE,
					 DUPLICATE_SAME_ACCESS);
		  sigproc_printf ("Dup hP %d", res);
a851 1
	  res = EXIT_REPARENTING;
d862 2
a863 1
      do_exit (res | EXIT_NOCLOSEALL);
d866 16
a881 6
  if (mode == _P_WAIT)
    waitpid (cygpid, (int *) &res, 0);
  else if (mode == _P_DETACH)
    res = 0;	/* Lose all memory of this child. */
  else if ((mode == _P_NOWAIT) || (mode == _P_NOWAITO))
    res = cygpid;
d914 24
a937 23
      case _P_OVERLAY:
	/* We do not pass _P_SEARCH_PATH here. execve doesn't search PATH.*/
	/* Just act as an exec if _P_OVERLAY set. */
	spawn_guts (hToken, path, argv, envp, mode);
	/* Errno should be set by spawn_guts.  */
	ret = -1;
	break;
      case _P_NOWAIT:
      case _P_NOWAITO:
      case _P_WAIT:
      case _P_DETACH:
	subproc_init ();
	ret = spawn_guts (hToken, path, argv, envp, mode);
	if (vf && ret > 0)
	  {
	    vf->pid = ret;
	    longjmp (vf->j, 1);
	  }
	break;
      default:
	set_errno (EINVAL);
	ret = -1;
	break;
@


1.32
log
@* dcrt0.cc (dll_crt0_1): Move set_os_type.
(_dll_crt0): To here.
(cygwin_dll_init): And here.
* external.cc (fillout_pinfo): Use more foolproof method for scanning for pids.
* pinfo.cc (set_myself): Eliminate myself_identity.init.
* sigproc.cc (wait_sig): Do it here instead to reduce the amount of time where
there could potentially be two processes with the same pid.
* spawn.cc (spawn_guts): Eliminate duplicate initialization.
* include/sys/cygwin.h: Mark unused PID_* elements.
@
text
@d29 1
@


1.31
log
@* dcrt0.cc (dll_crt0_1): Move exception list and constructor stuff earlier in
the process.  Use new second argument to set_myself.
(cygwin_dll_init): Initialize exception list and constructor stuff here.
(_dll_crt0): And here.  Also, deal with inherited pinfo shared memory region
from parent.
* pinfo.cc (set_myself): Accept a second argument signifying the a shared
memory region, passed from an execing parent.
(pinfo_init): Ditto.
* pinfo.h: Ditto.
* shared.h (child_info): Add a handle field to pass to child.
* spawn.cc (spawn_guts): Create a shared handle to pass to an execed child.
* winsup.h: Remove extraneous declaration.
@
text
@d658 8
a665 8
    /* Set up child's signal handlers */
    /* CGF FIXME - consolidate with signal stuff below */
    for (i = 0; i < NSIG; i++)
      {
	myself->getsig(i).sa_mask = 0;
	if (myself->getsig(i).sa_handler != SIG_IGN || (mode != _P_OVERLAY))
	  myself->getsig(i).sa_handler = SIG_DFL;
      }
a698 1
      child->process_state |= PID_INITIALIZING;
@


1.30
log
@Revert previous erroneous checkin.
@
text
@d497 5
a503 1
# undef ciresrv
d617 3
@


1.29
log
@* include/sys/cygwin.h: Protect class definitions.
@
text
@a496 4
  if (mode != _P_OVERLAY ||
      !DuplicateHandle (hMainProc, myself.shared_handle (), hMainProc, &ciresrv->myself_pinfo, 0,
		       TRUE, DUPLICATE_SAME_ACCESS))
   ciresrv->myself_pinfo = NULL;
@


1.28
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d497 4
@


1.27
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d23 3
d27 2
d30 1
a30 1
#include "cygerrno.h"
@


1.26
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d25 1
@


1.25
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d22 3
a24 1
#include "paths.h"
@


1.24
log
@* select.cc (allocfd_set): Zero allocated fd_set.
(cygwin_select): Move fd_set copying logic from ::wait to here.  Use common
return through sell.poll.
(select_stuff::wait): Just return success or failure and let caller fill in
fd_set.
* pinfo.h (pinfo): Eliminate self-referential pointer to sidbuf since pinfo
structure exists at random locations now.
* fork.cc (fork): Use 'use_psid' element to control when the psid is relevant.
* shared.cc (sec_user): Ditto.
* spawn.cc (spawn_guts): Ditto.
* uinfo.cc (internal_getlogin): Ditto.
* syscall.cc (seteuid): Ditto.  Set use_psid element.
@
text
@d138 1
a138 1
  fhandler_base *fh = dtable[n];
d465 1
a465 1
  int len = dtable.linearize_fd_array (0, 0);
d493 1
a493 1
  if (dtable.linearize_fd_array (resrv, len) < 0)
@


1.23
log
@* fork.cc (vfork): Store complete stack frame in vfork_save structure for later
recovery.
* spawn.cc (spawn_guts): Reorganize slightly to consolidate handling when there
is a CreateProcess error.
(_spawnve): Only longjmp back to vfork handling when a process has been
successfuly started.
* winsup.h (vfork_save): Extend to include frame info.  Remove obsolete cpplus
conditionals.
@
text
@d673 5
a677 3
      memcpy (child->sidbuf, myself->sidbuf, MAX_SID_LEN);
      if (myself->psid)
	child->psid = child->sidbuf;
d696 1
a696 1
	  child->psid = NULL;
@


1.22
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d610 9
a618 1
    __seterrno ();
a629 7
  if (!rc)
    {
      if (spr)
	ForceCloseHandle (spr);
      return -1;
    }

d888 1
a888 1
	if (vf)
@


1.21
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d11 1
a18 1
#include "winsup.h"
d924 1
a924 1
  return _spawnve (NULL, mode, path, (char * const  *) argv, environ);
d969 1
a969 1
  return spawnvpe (mode, path, (char * const *) argv, environ);
d999 1
a999 1
  return _spawnve (NULL, mode, path, argv, environ);
d1014 1
a1014 1
  return spawnvpe (mode, path, argv, environ);
@


1.20
log
@* testsuite/winsup.api/winsup.exp: ignore stdout by default
* testsuite/winsup.api/crlf.c: non-verbose by default

* winsup.h: prune out windows headers we don't normally need
* assert.cc: add wingdi.h and winuser.h
* fhandler_console.cc: ditto
* fhandler_windows.cc: ditto
* select.cc: ditto
* spawn.cc: ditto
* strace.cc: ditto
* tty.cc: ditto
* window.cc: ditto
* hinfo.cc: add winsock.h
* syscalls.cc: add winnls.h
* uinfo.cc: ditto

* include/windows.h: optimize non-inclusion of repeat headers
@
text
@d226 11
a236 1
int __stdcall
d238 1
a238 1
	    const char *const envp[], pinfo *child, int mode)
d243 1
d488 1
a488 1
  init_child_info (chtype, ciresrv, child->pid, spr);
d523 5
a567 6
      /* Set child->uid to USHRT_MAX to force calling internal_getlogin()
         from child process. Clear username and psid to play it safe. */
      child->uid = USHRT_MAX;
      child->username[0] = '\0';
      child->psid = NULL;

d612 4
a615 5
  MALLOC_CHECK;
  /* Name the handle similarly to proc_subproc. */
  ProtectHandle1 (pi.hProcess, childhProc);
  ProtectHandle (pi.hThread);
  MALLOC_CHECK;
d619 1
a619 1
		  rc ? pi.dwProcessId : (unsigned int) -1,
d629 5
a633 7
  /* Set up child's signal handlers */
  for (i = 0; i < NSIG; i++)
    {
      child->getsig(i).sa_mask = 0;
      if (myself->getsig(i).sa_handler != SIG_IGN || (mode != _P_OVERLAY))
	child->getsig(i).sa_handler = SIG_DFL;
    }
d638 1
a638 1
      strcpy (child->progname, real_path_buf);
d641 9
d653 26
d682 14
a695 1
      proc_register (child);
d793 4
a796 1
	  if (my_parent_is_alive ())
a797 2
	      pinfo  *parent = procinfo (myself->ppid);
	      sigproc_printf ("parent = %p", parent);
d800 1
a800 1
	      sigproc_printf ("parent's handle = %d", hP);
d837 1
a837 3
    {
      waitpid (child->pid, (int *) &res, 0);
    }
d839 1
a839 4
    {
      /* Lose all memory of this child. */
      res = 0;
    }
d841 1
a841 3
    {
      res = child->pid;
    }
a861 1
  pinfo *child;
d877 1
a877 1
	spawn_guts (hToken, path, argv, envp, myself, mode);
a884 24
	child = cygwin_shared->p.allocate_pid ();
	if (!child)
	  {
	    set_errno (EAGAIN);
	    syscall_printf ("-1 = spawnve (), process table full");
	    return -1;
	  }
	strcpy (child->progname, path);
	child->ppid = myself->pid;
	child->uid = myself->uid;
	child->gid = myself->gid;
	child->pgid = myself->pgid;
	child->sid = myself->sid;
	child->ctty = myself->ctty;
	child->umask = myself->umask;
	child->process_state |= PID_INITIALIZING;
        memcpy (child->username, myself->username, MAX_USER_NAME);
        memcpy (child->sidbuf, myself->sidbuf, MAX_SID_LEN);
        if (myself->psid)
          child->psid = child->sidbuf;
        memcpy (child->logsrv, myself->logsrv, MAX_HOST_NAME);
        memcpy (child->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
        memcpy (child->root, myself->root, MAX_PATH+1);
        child->rootlen = myself->rootlen;
d886 1
a886 4
	ret = spawn_guts (hToken, path, argv, envp, child, mode);
	if (ret == -1)
	  child->process_state = PID_NOT_IN_USE;

d889 1
a889 1
	    vf->pid = child->pid;
@


1.19
log
@        * spawn.cc (span_guts): Retrieve security attributes before setting
        psid to NULL.
@
text
@d19 2
@


1.18
log
@        * spawn.cc (spawn_guts): Don't restore impersonation in case
        of _P_OVERLAY. Clean up slightly. Accomodate comments.
@
text
@d539 6
d562 2
a563 6
                                        /* process security attrs */
                       allow_ntsec && sid ? sec_user (sa_buf, sid)
                                          : &sec_all_nih,
                                        /* thread security attrs */
                       allow_ntsec && sid ? sec_user (sa_buf, sid)
                                          : &sec_all_nih,
@


1.17
log
@        * shared.h (class pinfo): New members `root' and `rootlen'.
        * syscalls.cc (chroot): Set new root for process.
        * path.cc (getcwd_inner): Add parameter to force use of
        new root from chroot() call.
        (ischrootpath): New macro.
        (normalize_posix_path): Care for changed root dir.
        (normalize_win32_path): Ditto.
        (getcwd_inner): Ditto.
        (chdir): Eliminate trailing path component consisting
        entirely of dots.
        * fork.cc (fork): Copy pinfo members regarding chroot().
        * spawn.cc (_spawnve): Ditto.
        * dir.cc (opendir): Don't use computed win32 path if
        chroot() took place.
@
text
@a527 3
      /* force the new process to reread /etc/passwd and /etc/group */
      child->uid = USHRT_MAX;
      child->username[0] = '\0';
d545 1
a545 1
         from child process. Set psid to NULL to play it safe. */
d547 1
d568 4
a571 2
      /* Restore impersonation */
      if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
@


1.16
log
@Throughout, eliminate third argument to path_conv and use new PC_* constants
for second argument.
* path.h: Generalize SYMLINK_* constants to PC_*.
(path_conv): Create a new method.  Fold third argument into second.
* dll_init.cc (dll_list::alloc): Try harder to find space to allocate dll
struct.
(dll_dllcrt0): Don't check sanity if we've already called dll_crt0.
* path.cc (path_conv::check): Don't check for a null or empty path unless
specifically told with a flag setting.
(check_null_empty_path): New function, adapted from macro.
* syscalls.cc (_rename): Use already-determined file attributes rather than
checking again.
* lib/cygwin/cygwin_attach.dll.c (cygwin_attach_dll): Use a static per_process
structure since this is apparently supposed to be zeroed.
* lib/cygwin_crt0.c (cygwin_crt0): Zero per_process structure sent to older
DLLs.
@
text
@d855 2
@


1.15
log
@* environ.cc: Use new definition of "environ" throughout.
(environ_init): Explicitly initialize __cygwin_environ.
(cur_environ): New function.  Detects when user has updated their environment.
* exec.cc: Use 'environ' define throughout rather than __cygwin_environ.
* spawn.cc: Ditto.
* winsup.h: Declare cur_environ, main_environ, environ.
@
text
@d46 1
a46 1
  buf.check (prog, SYMLINK_FOLLOW, 1, std_suffixes);
@


1.14
log
@* spawn.cc (spawn_guts): Use \ for quoting '"'.
* dcrt0.cc (quoted): Understand \ quoting for '"'.
@
text
@d415 1
a415 1
	  for (0; p = strpbrk (a, "\"\\"); a = ++p)
d897 1
a897 2
  return _spawnve (NULL, mode, path, (char * const  *) argv,
		   __cygwin_environ);
d942 1
a942 1
  return spawnvpe (mode, path, (char * const *) argv, __cygwin_environ);
d972 1
a972 1
  return _spawnve (NULL, mode, path, argv, __cygwin_environ);
d987 1
a987 1
  return spawnvpe (mode, path, argv, __cygwin_environ);
@


1.13
log
@* hinfo.cc (hinfo::linearize_fd_array): Make max_used_fd an int so that we can
detect when there are no fds to pass.
* dcrt0.cc (host_dependent_constants::init): Revert Sat Mar 18 01:32:04 2000
change.
(dll_crt0_1): Set "cygwin_finished_initializing" flag.
(dll_crt0): Don't perform memcpy if uptr is already set to internal structure.
(_dll_crt0): Remember location of programs envptr.
* dll_init.h (per_module, dll, dll_list): Revamp.
* dll_init.cc: Revamp.  Use new classes.
* fork.cc (fork): Use new revamped dll, dll_list, and per_module stuff.
* environ.cc: Use __cygwin_environ throughout rather than the
user_data->envptr.
* exec.cc: Ditto.
* spawn.cc: Ditto.
* winsup.h: Declare update_envptrs, cygwin_finished_initializing.
* lib/_cygwin_crt0_common.cc (_cygwin_crt0_common): Revert previous change.
* lib/cygwin_attach_dll.cc (cygwin_attach_dll): Always pass in own per_process
structure or we end up overwriting information from the main program.
@
text
@d410 1
a410 1
      if (len != 0 && !(p = strpbrk (a, " \t\n\r\"")))
d415 1
a415 1
	  for (; p; a = p, p = strchr (p, '"'))
d417 4
a420 3
	      one_line.add (a, ++p - a);
	      if (p[-1] == '"')
		one_line.add ("\"", 1);
@


1.12
log
@        * spawn.cc (spawn_guts): Close handle `hToken' only if it's not
        copied from myself->token.
        * syscalls.cc (seteuid): Replace CopySid by memcpy which is foolproof
        here.
@
text
@d897 1
a897 1
		   *user_data->envptr);
d942 1
a942 1
  return spawnvpe (mode, path, (char * const *) argv, *user_data->envptr);
d972 1
a972 1
  return _spawnve (NULL, mode, path, argv, *user_data->envptr);
d987 1
a987 1
  return spawnvpe (mode, path, argv, *user_data->envptr);
@


1.11
log
@        * winsup.h: Define MAX_SID_LEN and new MAX_HOST_NAME.
        * fork.cc (fork): Use above defines instead of numerical constants.
        * shared.cc (sec_user): Ditto.
        * shared.h (class pinfo): Ditto.
        * syscall.cc (seteuid): Ditto.
        * spawn.cc (_spawnve): Ditto. Eliminate conditional.
        (spawn_guts): Set child->uid = USHRT_MAX when user context will be
        changed in child process.
        * uinfo.cc (uinfo_init): Check for myself->uid instead of myself->psid
        to avoid reloading of /etc/passwd on process startup if ntsec is off.
        Use above defines instead of numerical constants.
        * security.cc: Move define for MAX_SID_LEN to winsup.h.
@
text
@d643 1
a643 1
  if (hToken)
@


1.10
log
@Changes by  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>
        * assert.cc (__assert): Reduce dependency on newlib.
        * exec.cc: Eliminate unnecessary inclusion of ctype.h.
        * glob.c: Ditto.
        * hinfo.cc: Ditto.
        * init.cc: Ditto.
        * strace.cc: Ditto.
        * tty.cc: Ditto.
        * grp.cc (parse_grp): Eliminate atoi.
        * passwd.cc (grab_int): Ditto.
        * grp.cc (getgroups): Eliminate str{n,}casecmp.
        * path.cc (get_raw_device_number): Ditto.
        * path.cc (sort_by_native_name): Ditto.
        * spawn.cc (iscmd): Ditto.
        * uinfo.cc (internal_getlogin): Ditto.
@
text
@d546 3
a548 2
      /* Set child->psid to NULL to force calling internal_getlogin()
         from child process. */
d848 6
a853 9
        if (!hToken && !myself->token)
          {
            memcpy (child->username, myself->username, MAX_USER_NAME);
            memcpy (child->sidbuf, myself->sidbuf, 40);
            if (myself->psid)
              child->psid = child->sidbuf;
            memcpy (child->logsrv, myself->logsrv, 256);
            memcpy (child->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
          }
@


1.9
log
@        * fork.cc (fork): Fix error in copying SID pointer.
        * spawn.cc (_spawnve): Ditto.
        * passwd.cc: Remove static from `passwd_in_memory_p'.
        (read_etc_passwd): Remove static.
        * uinfo.cc: Move global declaration of `read_etc_group' and
        `group_in_memory_p' into `uinfo_init'.
        (internal_getlogin): Try to get SID from current process first.
        (uinfo_init): Don't set uid and gid if `myself' has a valid SID.
        Only load /etc/passwd and /etc/group in that case.
@
text
@d172 1
a172 1
  return n >= 0 && strcasecmp (argv0 + n, what) == 0 &&
@


1.8
log
@        * dcrt0.cc: Add load statements for `GetSidIdentifierAuthority'
        and `RegLoadKeyA'.
        * registry.cc (get_registry_hive_path): New function.
        (load_registry_hive): Ditto.
        * security.cc (convert_sid_to_string_sid): New function.
        (get_ssid): Renamed to `convert_string_sid_to_sid'.
        (get_pw_sid): Call `convert_string_sid_to_sid' instead of `get_ssid'.
        (get_gr_sid): Ditto.
        (get_admin_sid): Ditto.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * shared.h: New prototypes for `get_registry_hive_path' and
        `load_registry_hive'.
        * spawn.cc (spawn_guts): Set child->psid to NULL to force calling
        `internal_getlogin' from child process in case of changing user context.
        Call `load_registry_hive' in case of changing user context.
        (_spawnve): Copy user infos only if user context remains the same.
        * uinfo.cc: Add load statement for `NetUserGetInfo'.
        Remove load statement for `NetGetDCName'.
        (internal_getlogin): Rewrite to speed up process startup
        and to correct user environment in case user context changes.
        (uinfo_init): Call internal_getlogin only if myself->psid is NULL,
        that is user context changes.
        * winsup.h: Add prototypes for `convert_sid_to_string_sid',
        `convert_string_sid_to_sid' and `get_pw_sid'.
@
text
@a849 1
            child->psid = myself->psid;
d851 2
@


1.7
log
@        * cygwin.din: Define symbols for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        * dcrt0.cc (dll_crt0_1): Eliminate superfluous conditional
        statements.
        Add load statements for `ImpersonateLoggedOnUser', `LogonUserA'
        and `RevertToSelf'.
        * fork.cc (fork): Care for correct impersonation of parent
        and child process.
        * security.cc (cygwin_set_impersonation_token): New function.
        (cygwin_logon_user): Ditto.
        shared.h (class pinfo): New members `orig_uid', `orig_gid',
        `real_uid' nad `real_gid'.
        spawn.cc (spawn_guts): Care for impersonation when starting
        child process in a different user context.
        * syscalls.cc (setgid): Call `setegid' now. Set real_gid.
        (setuid): Call `seteuid' now. Set real_uid.
        (seteuid): Functionality moved from setuid to here. Care for
        correct impersonation.
        (setegid): Functionality moved from setgid to here.
        * uinfo.cc (uinfo_init): Initialization of additional pinfo
        members.
        (getuid): Return real uid.
        (getgid): Return real gid.
        (geteuid): Return effective uid.
        (getegid): Return effective gid.
        include/sys/cygwin.h: Add prototypes for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        include/cygwin/version.h: Bumb API minor version to 22.
@
text
@d546 7
d847 8
a854 5
        memcpy (child->username, myself->username, MAX_USER_NAME);
        child->psid = myself->psid;
        memcpy (child->sidbuf, myself->sidbuf, 40);
        memcpy (child->logsrv, myself->logsrv, 256);
        memcpy (child->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
@


1.6
log
@* Makefile.in: Remove libadvapi32.a.
* autoload.h: Add additional field to autoload block for handling unimplemented
functions.
(LoadDLLfuncEx): New function which accepts additional parameter for
controlling unimplemented function behavior.
(LoadDLLfunc): Use LoadDLLfuncEx.
* dcrt0.cc: Use new arguments for LoadDLLfunc.  Add advapi32 routines.
(noload): Rewrite in assembler.  Handle new unimplemented function type.
* exceptions.cc: Eliminate another vestige of StackWalk stuff.
* net.cc: Use new arguments for LoadDLLfunc.
* uinfo.cc: Ditto.

* config.h.in: Remove obsolete define.
* path.h (isdrive): New macro.
* dcrt0.cc (globify): Use new macro to determine if a string refers to an
MS-DOS drive.
* environ.cc (winenv): Ditto.
* spawn.cc (find_exec): Ditto.
* path.cc (get_raw_device_number): Ditto.
(mount_info::conv_to_posix_path): Ditto.
(chdir): Ditto.
(cygwin_posix_path_list_p): Ditto.
(cygwin_split_path): Ditto.
(path_conv::check): Move tmp_buf to beginning of function since it can be used
earlier in the loop.  Use tmp_buf rather than 'root' to hold root information.
(mount_info::conv_to_win32_path): Add trailing slash to end of mount path when
it translates to a drive.  Add defensive code to avoid writing beyond the end
of 'dst'.
@
text
@d506 3
d541 5
d561 3
@


1.5
log
@* exceptions.cc (interruptible): Allocate slightly more space for directory
name check.  Windows 95 seems to null-terminate the directory otherwise.
(interrupt_on_return): Issue a fatal error if we can't find the caller's stack.
* spawn.cc (find_exec): Accept a path_conv argument rather than a buffer so
that the caller can find things out about a translated path.
(perhaps_suffix): Ditto.
(spawn_guts): Allocate path_conv stuff here so that we can find out stuff about
the translated path (this is work in progress).
* environ.cc (environ_init): Accept an as-yet unused argument indicating
whether we were invoked from a cygwin parent or not.
(winenv): Ditto.
(posify): Accept an argument indicating whether the path has already been
translated.
* dlfcn.cc (check_access): Provide a path_conv buffer to find_exec.
* exec.cc (sexecvpe): Ditto.
* path.cc (path_conv::check): Rename from path_conv::path_conv.
(mount_item::getmntent): Recognize "Cygwin executable" bit.
(symlink_info::check): Remove debugging statements.
* path.h (class path_conv): Add iscygexec method.  Rewrite constructor to call
"check" method to allow multiple operations on a path_conv variable.
* pinfo.cc (pinfo_init): Pass argument to environ_init.
* shared.h: Bump PROC_MAGIC.
* winsup.h: Reflect above changes to function arguments.
* include/sys/mount.h: Add MOUNT_CYGWIN_EXEC type.
@
text
@d88 1
a88 1
      isalpha (name[0]) && name[1] == ':' ||
@


1.4
log
@* spawn.cc (spawn_guts): Restore dependency on signal_arrived.  It's needed to
wake up the WaitForSingleObject.
@
text
@d41 1
a41 1
perhaps_suffix (const char *prog, char *buf)
d46 1
a46 2
  path_conv temp (prog, SYMLINK_FOLLOW, 1, std_suffixes);
  strcpy (buf, temp.get_win32 ());
d48 1
a48 1
  if (temp.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
d50 2
a51 2
  else if (temp.known_suffix)
    ext = buf + (temp.known_suffix - temp.get_win32 ());
d55 1
a55 1
  debug_printf ("buf %s, suffix found '%s'", buf, ext);
d68 1
a68 1
find_exec (const char *name, char *buf, const char *mywinenv,
d122 1
a122 1
    strcpy (buf, path_conv (name).get_win32 ());
d125 1
a125 1
  debug_printf ("%s = find_exec (%s)", buf, name);
d259 1
a259 1
  char real_path_buf[MAX_PATH];
a275 2
  MALLOC_CHECK;

d282 1
a282 1
  if ((ext = perhaps_suffix (prog_arg, real_path)) == NULL)
d381 1
a381 1
      find_exec (pgm, real_path, "PATH=", 0, &ext);
a499 1
  MALLOC_CHECK;
d501 1
a501 2
  char *envblock = winenv (envp);
  MALLOC_CHECK;
d975 1
a975 1
  char buf[MAXNAMLEN];
@


1.3
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@d638 2
a639 2
      HANDLE waitbuf[2] = {pi.hProcess, spr};
      int nwait = 2;
d678 4
@


1.2
log
@Respond to more g++ warnings relating to initializing structures.
@
text
@d638 2
a639 2
      HANDLE waitbuf[3] = {pi.hProcess, signal_arrived, spr};
      int nwait = 3;
d647 1
a647 2
  waitfor:
      switch (WaitForMultipleObjects (nwait, waitbuf, FALSE, timeout))
d649 1
a649 3
	case WAIT_TIMEOUT:
	  syscall_printf ("WFMO timed out after signal");
	  if (WaitForSingleObject (pi.hProcess, 0) != WAIT_OBJECT_0)
d651 48
a698 36
	      sigproc_printf ("subprocess still alive after signal");
	      res = exec_exit;
	    }
	  else
	    {
	      sigproc_printf ("subprocess exited after signal");
	case WAIT_OBJECT_0:
	      sigproc_printf ("subprocess exited");
	      if (!GetExitCodeProcess (pi.hProcess, &res))
		res = exec_exit;
	      exited = TRUE;
	     }
	  if (nwait > 2)
	    if (WaitForSingleObject (spr, 1) == WAIT_OBJECT_0)
	      res |= EXIT_REPARENTING;
	    else if (!(res & EXIT_REPARENTING))
	      {
		MALLOC_CHECK;
		close_all_files ();
		MALLOC_CHECK;
	      }
	  break;
	case WAIT_OBJECT_0 + 1:
	  sigproc_printf ("signal arrived");
	  timeout = 10;
	  goto waitfor;
	case WAIT_OBJECT_0 + 2:
	  res = EXIT_REPARENTING;
	  MALLOC_CHECK;
	  ForceCloseHandle (spr);
	  MALLOC_CHECK;
	  if (!parent_alive)
	    {
	      nwait = 1;
	      sigproc_terminate ();
	      goto waitfor;
a700 10
	case WAIT_FAILED:
	  DWORD r;
	  system_printf ("wait failed: nwait %d, pid %d, winpid %d, %E",
			 nwait, myself->pid, myself->dwProcessId);
	  system_printf ("waitbuf[0] %p %d", waitbuf[0],
			 GetHandleInformation (waitbuf[0], &r));
	  system_printf ("waitbuf[1] %p = %d", waitbuf[1],
			 GetHandleInformation (waitbuf[1], &r));
	  set_errno (ECHILD);
	  return -1;
@


1.1
log
@Initial revision
@
text
@d441 2
a442 3
  PROCESS_INFORMATION pi = {0};

  STARTUPINFO si = {0};
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
