head	1.149;
access;
symbols
	cygwin-1_7_35-release:1.149
	cygwin-1_7_34-release:1.148
	cygwin-1_7_33-release:1.148
	cygwin-1_7_32-release:1.148
	cygwin-1_7_31-release:1.148
	cygwin-1_7_30-release:1.148
	cygwin-1_7_29-release:1.148
	cygwin-1_7_29-release-branchpoint:1.148.0.2
	cygwin-pre-user-db:1.148
	cygwin-1_7_28-release:1.148
	cygwin-1_7_27-release:1.148
	cygwin-1_7_26-release:1.148
	cygwin-1_7_25-release:1.148
	cygwin-1_7_24-release:1.148
	cygwin-1_7_23-release:1.148
	cygwin-1_7_22-release:1.148
	cygwin-1_7_21-release:1.148
	cygwin-1_7_20-release:1.148
	cygwin-1_7_19-release:1.148
	cygwin-64bit-postmerge:1.147
	cygwin-64bit-premerge-branch:1.146.0.2
	cygwin-64bit-premerge:1.146
	cygwin-1_7_18-release:1.146
	post-ptmalloc3:1.145.2.3
	pre-ptmalloc3:1.145.2.3
	cygwin-1_7_17-release:1.145
	cygwin-64bit-branch:1.145.0.2
	cygwin-1_7_16-release:1.145
	cygwin-1_7_15-release:1.144
	cygwin-1_7_14_2-release:1.142
	cygwin-1_7_14-release:1.142
	cygwin-1_7_12-release:1.142
	cygwin-1_7_11-release:1.142
	cygwin-1_7_10-release:1.141
	signal-rewrite:1.132.0.2
	pre-notty:1.129
	cygwin-1_7_9-release:1.126
	cv-post-1_7_9:1.126.0.2
	cygwin-1_7_8-release:1.125
	cygwin-1_7_7-release:1.125
	cygwin-1_7_5-release:1.124
	cygwin-1_7_4-release:1.124
	cygwin-1_7_3-release:1.124
	cygwin-1_7_2-release:1.122
	fifo_doover3:1.120.0.2
	cygwin-1_7_1-release:1.118
	prefifo:1.115
	cv-branch-2:1.114.0.2
	pre-ripout-set_console_state_for_spawn:1.105
	EOL_registry_mounts:1.104
	preoverlapped:1.94
	drop_9x_support_start:1.92
	cr-0x5f1:1.90.0.2
	cv-branch:1.89.0.2
	pre-ptymaster-archetype:1.89
	cr-0x3b58:1.85.0.4
	cr-0x5ef:1.85.0.2
	after-mmap-privanon-noreserve:1.84
	after-mmap-revamp:1.84
	before-mmap-revamp:1.84
	cgf-more-exit-sync:1.82
	post_wait_sig_exit:1.80
	pre_wait_sig_exit:1.78
	reparent-point:1.64
	noreparent:1.64.0.2
	cr-0x5e6:1.61.0.2
	cr-0x9e:1.55.0.4
	cr-0x9d:1.55.0.2
	cgf-deleteme:1.54.0.2
	pre-sigrewrite:1.54
	corinna-01:1.54
	cr-0x9c:1.53.0.4
	cr-0x9b:1.53.0.2
	cr-0x99:1.52
	Z-emcb-cygwin_daemon:1.52.0.2
	w32api-2_2:1.49
	mingw-runtime-2_4:1.49
	pre-cgf-merge:1.53
	cgf-dev-branch:1.46.0.2
	predaemon:1.35
	cygwin_daemon_merge_HEAD:1.35
	pregp02r1:1.34.0.2
	cygnus_cvs_20020108_pre:1.32
	Z-cygwin_daemon_merge-new_HEAD:1.39
	Z-cygwin_daemon_merge_HEAD:1.39
	cygwin_daemon:1.19.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.149
date	2015.02.15.08.59.55;	author corinna;	state Exp;
branches;
next	1.148;

1.148
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.147;

1.147
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2013.01.21.04.34.52;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2012.05.12.19.17.16;	author cgf;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2012.04.30.15.38.45;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2012.04.28.19.49.58;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2012.02.14.11.27.43;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2012.01.22.21.43.25;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2011.12.12.01.22.29;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2011.11.23.21.58.43;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2011.11.23.18.56.57;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2011.10.30.04.50.35;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2011.10.23.19.01.47;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2011.10.15.22.37.30;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2011.08.15.16.05.13;	author corinna;	state Exp;
branches;
next	1.131;

1.131
date	2011.08.12.16.55.35;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2011.06.30.09.37.36;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2011.05.31.00.26.37;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2011.05.05.17.44.42;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2011.05.04.13.06.10;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2011.03.09.16.47.44;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2010.08.14.11.16.09;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2010.04.02.18.55.02;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2010.03.31.04.26.11;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.29.17.37.54;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.09.16.52.43;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2009.10.31.13.24.06;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2009.08.17.12.45.51;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2009.08.04.04.20.36;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2009.07.03.18.05.51;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2009.01.27.05.21.08;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2008.12.23.18.22.33;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2008.12.22.19.18.00;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2008.12.21.01.54.32;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2008.09.11.04.41.24;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2008.08.26.15.39.17;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2008.08.20.02.25.06;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2008.07.18.08.16.40;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2008.03.22.21.04.16;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2008.03.12.16.55.42;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.01.19.07.36;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.01.18.51.23;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2007.12.16.21.21.23;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2007.11.08.15.18.06;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.08.14.36.49;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2007.07.10.01.21.03;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2007.07.07.17.00.33;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2007.02.27.12.58.56;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2007.02.23.14.47.45;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2006.08.07.19.29.14;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2006.05.25.05.40.51;	author cgf;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2006.05.21.21.02.52;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2006.05.21.05.25.49;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2006.04.27.16.38.21;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2005.12.19.04.34.13;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2005.10.24.15.09.07;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2005.09.28.19.22.24;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.28.19.02.51;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.17.20.36.34;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.14.14.27.55;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.22.13.58.09;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2005.04.16.05.20.00;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2005.04.08.19.57.36;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.11.15.24.15;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.08.16.19.58;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.06.11.15.29;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.06.05.04.34;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2005.02.02.10.09.51;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2005.02.01.16.49.13;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2005.02.01.16.43.29;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2005.02.01.15.11.47;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.31.10.28.55;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2004.11.20.23.42.36;	author phumblet;	state Exp;
branches;
next	1.64;

1.64
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2004.09.09.08.58.44;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2004.09.03.01.32.02;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.10.13.45.10;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.17.16.38.47;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.02.20.33.09;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.17.03.47.27;	author cgf;	state Exp;
branches
	1.55.4.1;
next	1.54;

1.54
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2003.09.07.02.22.58;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.22.18.30.58;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.07.06.15.10;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.07.05.48.58;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.10.12.32.47;	author corinna;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2003.01.03.06.20.23;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.14.05.44.06;	author cgf;	state Exp;
branches
	1.44.4.1;
next	1.43;

1.43
date	2002.12.14.05.10.18;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.11.04.00.04;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.09.03.17.40;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.30.01.31.51;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.03.03.20.50;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.02.06.07.01;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.25.17.47.47;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.05.06.09.08;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.05.01.52.20;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.05.01.44.02;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.03.05.42.21;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.03.03.32.27;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.15.23.39.33;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.01.04.10.07;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.29.01.23.06;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.28.06.06.45;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.24.21.50.44;	author cgf;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.07.00.01.42;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.18.21.10.13;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.07.18.12.11;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.24.17.54.43;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.145.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.145.2.2;

1.145.2.2
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.145.2.3;

1.145.2.3
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.145.2.4;

1.145.2.4
date	2013.03.14.16.11.42;	author corinna;	state Exp;
branches;
next	1.145.2.5;

1.145.2.5
date	2013.04.08.09.32.31;	author corinna;	state Exp;
branches;
next	1.145.2.6;

1.145.2.6
date	2013.04.08.10.33.55;	author corinna;	state Exp;
branches;
next	;

1.90.2.1
date	2007.01.15.11.56.07;	author corinna;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2008.02.21.17.37.32;	author cgf;	state Exp;
branches;
next	;

1.89.2.1
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	;

1.55.4.1
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	;

1.54.2.1
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	;

1.46.2.1
date	2003.01.16.01.27.31;	author cgf;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2003.02.05.14.25.09;	author cgf;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2003.02.09.05.46.40;	author cgf;	state Exp;
branches;
next	1.46.2.5;

1.46.2.5
date	2003.02.11.03.13.08;	author cgf;	state Exp;
branches;
next	1.46.2.6;

1.46.2.6
date	2003.02.13.03.14.06;	author cgf;	state Exp;
branches;
next	1.46.2.7;

1.46.2.7
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.46.2.8;

1.46.2.8
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.46.2.9;

1.46.2.9
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.46.2.10;

1.46.2.10
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.44.4.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.44.4.2;

1.44.4.2
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.44.4.3;

1.44.4.3
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.44.4.4;

1.44.4.4
date	2003.01.03.06.17.23;	author cgf;	state Exp;
branches;
next	1.44.4.5;

1.44.4.5
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	;

1.19.2.1
date	2001.09.29.09.35.31;	author rbcollins;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.10.02.12.09.55;	author rbcollins;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2002.02.28.12.53.26;	author rbcollins;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2002.06.13.14.34.09;	author rbcollins;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2002.07.03.16.01.46;	author scottc;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2002.07.30.13.31.46;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.149
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@/* pipe.cc: pipe for Cygwin.

   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013, 2015 Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* FIXME: Should this really be fhandler_pipe.cc? */

#include "winsup.h"
#include <stdlib.h>
#include <sys/socket.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "pinfo.h"
#include "shared_info.h"

fhandler_pipe::fhandler_pipe ()
  : fhandler_base_overlapped (), popen_pid (0)
{
  max_atomic_write = DEFAULT_PIPEBUFSIZE;
  need_fork_fixup (true);
}

int
fhandler_pipe::init (HANDLE f, DWORD a, mode_t mode)
{
  /* FIXME: Have to clean this up someday
     FIXME: Do we have to check for both !get_win32_name() and
     !*get_win32_name()? */
  if ((!get_win32_name () || !*get_win32_name ()) && get_name ())
    {
      char *d;
      const char *s;
      char *hold_normalized_name = (char *) alloca (strlen (get_name ()) + 1);
      for (s = get_name (), d = hold_normalized_name; *s; s++, d++)
	if (*s == '/')
	  *d = '\\';
	else
	  *d = *s;
      *d = '\0';
      set_name (hold_normalized_name);
    }

  bool opened_properly = a & FILE_CREATE_PIPE_INSTANCE;
  a &= ~FILE_CREATE_PIPE_INSTANCE;
  fhandler_base::init (f, a, mode);
  close_on_exec (mode & O_CLOEXEC);
  if (opened_properly)
    setup_overlapped ();
  else
    destroy_overlapped ();
  return 1;
}

extern "C" int sscanf (const char *, const char *, ...);

int
fhandler_pipe::open (int flags, mode_t mode)
{
  HANDLE proc, pipe_hdl, nio_hdl = NULL;
  fhandler_pipe *fh = NULL;
  size_t size;
  int pid, rwflags = (flags & O_ACCMODE);
  bool inh;

  sscanf (get_name (), "/proc/%d/fd/pipe:[%lu]",
		       &pid, (unsigned long *) &pipe_hdl);
  if (pid == myself->pid)
    {
      cygheap_fdenum cfd (true);
      while (cfd.next () >= 0)
	{
	  if (cfd->get_handle () != pipe_hdl)
	    continue;
	  if ((rwflags == O_RDONLY && !(cfd->get_access () & GENERIC_READ))
	      || (rwflags == O_WRONLY && !(cfd->get_access () & GENERIC_WRITE)))
	    {
	      set_errno (EACCES);
	      return 0;
	    }
	  cfd->copyto (this);
	  set_io_handle (NULL);
	  pc.reset_conv_handle ();
	  if (!cfd->dup (this, flags))
	    return 1;
	  return 0;
	}
      set_errno (ENOENT);
      return 0;
    }

  pinfo p (pid);
  if (!p)
    {
      set_errno (ESRCH);
      return 0;
    }
  if (!(proc = OpenProcess (PROCESS_DUP_HANDLE, false, p->dwProcessId)))
    {
      __seterrno ();
      return 0;
    }
  if (!(fh = p->pipe_fhandler (pipe_hdl, size)) || !size)
    {
      set_errno (ENOENT);
      goto out;
    }
  /* Too bad, but Windows only allows the same access mode when dup'ing
     the pipe. */
  if ((rwflags == O_RDONLY && !(fh->get_access () & GENERIC_READ))
      || (rwflags == O_WRONLY && !(fh->get_access () & GENERIC_WRITE)))
    {
      set_errno (EACCES);
      goto out;
    }
  inh = !(flags & O_CLOEXEC);
  if (!DuplicateHandle (proc, pipe_hdl, GetCurrentProcess (), &nio_hdl,
			0, inh, DUPLICATE_SAME_ACCESS))
    {
      __seterrno ();
      goto out;
    }
  init (nio_hdl, fh->get_access (), mode & O_TEXT ?: O_BINARY);
  cfree (fh);
  CloseHandle (proc);
  return 1;
out:
  if (nio_hdl)
    CloseHandle (nio_hdl);
  if (fh)
    free (fh);
  if (proc)
    CloseHandle (proc);
  return 0;
}

off_t
fhandler_pipe::lseek (off_t offset, int whence)
{
  debug_printf ("(%D, %d)", offset, whence);
  set_errno (ESPIPE);
  return -1;
}

int
fhandler_pipe::fadvise (off_t offset, off_t length, int advice)
{
  set_errno (ESPIPE);
  return -1;
}

int
fhandler_pipe::ftruncate (off_t length, bool allow_truncate)
{
  set_errno (allow_truncate ? EINVAL : ESPIPE);
  return -1;
}

char *
fhandler_pipe::get_proc_fd_name (char *buf)
{
  __small_sprintf (buf, "pipe:[%lu]", get_handle ());
  return buf;
}

int
fhandler_pipe::dup (fhandler_base *child, int flags)
{
  fhandler_pipe *ftp = (fhandler_pipe *) child;
  ftp->set_popen_pid (0);

  int res;
  if (get_handle () && fhandler_base_overlapped::dup (child, flags))
    res = -1;
  else
    res = 0;

  debug_printf ("res %d", res);
  return res;
}

#define PIPE_INTRO "\\\\.\\pipe\\cygwin-"

/* Create a pipe, and return handles to the read and write ends,
   just like CreatePipe, but ensure that the write end permits
   FILE_READ_ATTRIBUTES access, on later versions of win32 where
   this is supported.  This access is needed by NtQueryInformationFile,
   which is used to implement select and nonblocking writes.
   Note that the return value is either 0 or GetLastError,
   unlike CreatePipe, which returns a bool for success or failure.  */
DWORD
fhandler_pipe::create (LPSECURITY_ATTRIBUTES sa_ptr, PHANDLE r, PHANDLE w,
		       DWORD psize, const char *name, DWORD open_mode)
{
  /* Default to error. */
  if (r)
    *r = NULL;
  if (w)
    *w = NULL;

  /* Ensure that there is enough pipe buffer space for atomic writes.  */
  if (!psize)
    psize = DEFAULT_PIPEBUFSIZE;

  char pipename[MAX_PATH];
  size_t len = __small_sprintf (pipename, PIPE_INTRO "%S-",
				      &cygheap->installation_key);
  DWORD pipe_mode = PIPE_READMODE_BYTE
		    | (wincap.has_pipe_reject_remote_clients ()
		       ? PIPE_REJECT_REMOTE_CLIENTS : 0);
  if (!name)
    pipe_mode |= pipe_byte ? PIPE_TYPE_BYTE : PIPE_TYPE_MESSAGE;
  else
    pipe_mode |= PIPE_TYPE_MESSAGE;

  if (!name || (open_mode & PIPE_ADD_PID))
    {
      len += __small_sprintf (pipename + len, "%u-", GetCurrentProcessId ());
      open_mode &= ~PIPE_ADD_PID;
    }

  if (name)
    len += __small_sprintf (pipename + len, "%s", name);

  open_mode |= PIPE_ACCESS_INBOUND | FILE_FLAG_FIRST_PIPE_INSTANCE;

  /* Retry CreateNamedPipe as long as the pipe name is in use.
     Retrying will probably never be necessary, but we want
     to be as robust as possible.  */
  DWORD err = 0;
  while (r && !*r)
    {
      static volatile ULONG pipe_unique_id;
      if (!name)
	__small_sprintf (pipename + len, "pipe-%p",
			 InterlockedIncrement ((LONG *) &pipe_unique_id));

      debug_printf ("name %s, size %u, mode %s", pipename, psize,
		    (pipe_mode & PIPE_TYPE_MESSAGE)
		    ? "PIPE_TYPE_MESSAGE" : "PIPE_TYPE_BYTE");

      /* Use CreateNamedPipe instead of CreatePipe, because the latter
	 returns a write handle that does not permit FILE_READ_ATTRIBUTES
	 access, on versions of win32 earlier than WinXP SP2.
	 CreatePipe also stupidly creates a full duplex pipe, which is
	 a waste, since only a single direction is actually used.
	 It's important to only allow a single instance, to ensure that
	 the pipe was not created earlier by some other process, even if
	 the pid has been reused.

	 Note that the write side of the pipe is opened as PIPE_TYPE_MESSAGE.
	 This *seems* to more closely mimic Linux pipe behavior and is
	 definitely required for pty handling since fhandler_pty_master
	 writes to the pipe in chunks, terminated by newline when CANON mode
	 is specified.  */
      *r = CreateNamedPipe (pipename, open_mode, pipe_mode, 1, psize,
			   psize, NMPWAIT_USE_DEFAULT_WAIT, sa_ptr);

      if (*r != INVALID_HANDLE_VALUE)
	{
	  debug_printf ("pipe read handle %p", *r);
	  err = 0;
	  break;
	}

      err = GetLastError ();
      switch (err)
	{
	case ERROR_PIPE_BUSY:
	  /* The pipe is already open with compatible parameters.
	     Pick a new name and retry.  */
	  debug_printf ("pipe busy", !name ? ", retrying" : "");
	  if (!name)
	    *r = NULL;
	  break;
	case ERROR_ACCESS_DENIED:
	  /* The pipe is already open with incompatible parameters.
	     Pick a new name and retry.  */
	  debug_printf ("pipe access denied%s", !name ? ", retrying" : "");
	  if (!name)
	    *r = NULL;
	  break;
	default:
	  {
	    err = GetLastError ();
	    debug_printf ("failed, %E");
	  }
	}
    }

  if (err)
    {
      *r = NULL;
      return err;
    }

  if (!w)
    debug_printf ("pipe write handle NULL");
  else
    {
      debug_printf ("CreateFile: name %s", pipename);

      /* Open the named pipe for writing.
	 Be sure to permit FILE_READ_ATTRIBUTES access.  */
      DWORD access = GENERIC_WRITE | FILE_READ_ATTRIBUTES;
      if ((open_mode & PIPE_ACCESS_DUPLEX) == PIPE_ACCESS_DUPLEX)
	access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;
      *w = CreateFile (pipename, access, 0, sa_ptr, OPEN_EXISTING,
		      open_mode & FILE_FLAG_OVERLAPPED, 0);

      if (!*w || *w == INVALID_HANDLE_VALUE)
	{
	  /* Failure. */
	  DWORD err = GetLastError ();
	  debug_printf ("CreateFile failed, r %p, %E", r);
	  if (r)
	    CloseHandle (*r);
	  *w = NULL;
	  return err;
	}

      debug_printf ("pipe write handle %p", *w);
    }

  /* Success. */
  return 0;
}

int
fhandler_pipe::create (fhandler_pipe *fhs[2], unsigned psize, int mode)
{
  HANDLE r, w;
  SECURITY_ATTRIBUTES *sa = sec_none_cloexec (mode);
  int res = -1;

  int ret = create (sa, &r, &w, psize, NULL, FILE_FLAG_OVERLAPPED);
  if (ret)
    __seterrno_from_win_error (ret);
  else if ((fhs[0] = (fhandler_pipe *) build_fh_dev (*piper_dev)) == NULL)
    {
      CloseHandle (r);
      CloseHandle (w);
    }
  else if ((fhs[1] = (fhandler_pipe *) build_fh_dev (*pipew_dev)) == NULL)
    {
      delete fhs[0];
      CloseHandle (w);
    }
  else
    {
      mode |= mode & O_TEXT ?: O_BINARY;
      fhs[0]->init (r, FILE_CREATE_PIPE_INSTANCE | GENERIC_READ, mode);
      fhs[1]->init (w, FILE_CREATE_PIPE_INSTANCE | GENERIC_WRITE, mode);
      res = 0;
    }

  debug_printf ("%R = pipe([%p, %p], %d, %y)", res, fhs[0], fhs[1], psize, mode);
  return res;
}

int
fhandler_pipe::ioctl (unsigned int cmd, void *p)
{
  int n;

  switch (cmd)
    {
    case FIONREAD:
      if (get_device () == FH_PIPEW)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      if (!PeekNamedPipe (get_handle (), NULL, 0, NULL, (DWORD *) &n, NULL))
	{
	  __seterrno ();
	  return -1;
	}
      break;
    default:
      return fhandler_base::ioctl (cmd, p);
      break;
    }
  *(int *) p = n;
  return 0;
}

int __reg2
fhandler_pipe::fstatvfs (struct statvfs *sfs)
{
  set_errno (EBADF);
  return -1;
}

static int __reg3
pipe_worker (int filedes[2], unsigned int psize, int mode)
{
  fhandler_pipe *fhs[2];
  int res = fhandler_pipe::create (fhs, psize, mode);
  if (!res)
    {
      cygheap_fdnew fdin;
      cygheap_fdnew fdout (fdin, false);
      char buf[sizeof ("/dev/fd/pipe:[2147483647]")];
      __small_sprintf (buf, "/dev/fd/pipe:[%d]", (int) fdin);
      fhs[0]->pc.set_posix (buf);
      __small_sprintf (buf, "pipe:[%d]", (int) fdout);
      fhs[1]->pc.set_posix (buf);
      fdin = fhs[0];
      fdout = fhs[1];
      filedes[0] = fdin;
      filedes[1] = fdout;
    }
  return res;
}

extern "C" int
_pipe (int filedes[2], unsigned int psize, int mode)
{
  int res = pipe_worker (filedes, psize, mode);
  int read, write;
  if (res != 0)
    read = write = -1;
  else
    {
      read = filedes[0];
      write = filedes[1];
    }
  syscall_printf ("%R = _pipe([%d, %d], %u, %y)", res, read, write, psize, mode);
  return res;
}

extern "C" int
pipe (int filedes[2])
{
  int res = pipe_worker (filedes, DEFAULT_PIPEBUFSIZE, O_BINARY);
  int read, write;
  if (res != 0)
    read = write = -1;
  else
    {
      read = filedes[0];
      write = filedes[1];
    }
  syscall_printf ("%R = pipe([%d, %d])", res, read, write);
  return res;
}

extern "C" int
pipe2 (int filedes[2], int mode)
{
  int res = pipe_worker (filedes, DEFAULT_PIPEBUFSIZE, mode);
  int read, write;
  if (res != 0)
    read = write = -1;
  else
    {
      read = filedes[0];
      write = filedes[1];
    }
  syscall_printf ("%R = pipe2([%d, %d], %y)", res, read, write, mode);
  return res;
}
@


1.148
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Hat, Inc.
d415 1
a415 1
      fhs[0]->pc.set_normalized_path (buf);
d417 1
a417 1
      fhs[1]->pc.set_normalized_path (buf);
@


1.147
log
@	* Merge in cygwin-64bit-branch.
@
text
@d397 1
a397 1
int __stdcall
@


1.146
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012 Hat, Inc.
d75 2
a76 1
  sscanf (get_name (), "/proc/%d/fd/pipe:[%d]", &pid, (int *) &pipe_hdl);
d146 2
a147 2
_off64_t
fhandler_pipe::lseek (_off64_t offset, int whence)
d149 1
a149 1
  debug_printf ("(%d, %d)", offset, whence);
d155 1
a155 1
fhandler_pipe::fadvise (_off64_t offset, _off64_t length, int advice)
d162 1
a162 1
fhandler_pipe::ftruncate (_off64_t length, bool allow_truncate)
d171 1
a171 1
  __small_sprintf (buf, "pipe:[%d]", get_handle ());
d217 3
a219 1
  DWORD pipe_mode = PIPE_READMODE_BYTE;
d234 1
a234 1
  open_mode |= PIPE_ACCESS_INBOUND;
d247 1
a247 1
      debug_printf ("name %s, size %lu, mode %s", pipename, psize,
d258 1
a258 2
	 the pid has been reused.  We avoid FILE_FLAG_FIRST_PIPE_INSTANCE
	 because that is only available for Win2k SP2 and WinXP.
d366 1
a366 1
  debug_printf ("%R = pipe([%p, %p], %d, %p)", res, fhs[0], fhs[1], psize, mode);
d438 1
a438 1
  syscall_printf ("%R = _pipe([%d, %d], %u, %p)", res, read, write, psize, mode);
d470 1
a470 1
  syscall_printf ("%R = pipe2([%d, %d], %p)", res, read, write, mode);
@


1.145
log
@* DevNotes: Add entry cgf-000005.
* fhandler.h (PIPE_ADD_PID): Redefine to something we actually DON'T use.
* pipe.cc (fhandler_pipe::create): Avoid clearing all open_mode bits when
checking for PIPE_ADD_PID.  Properly keep track of len so that passed in name
is not overwritten.
@
text
@d402 1
a402 1
static int __attribute__ ((regparm (3)))
@


1.145.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d145 2
a146 2
off_t
fhandler_pipe::lseek (off_t offset, int whence)
d154 1
a154 1
fhandler_pipe::fadvise (off_t offset, off_t length, int advice)
d161 1
a161 1
fhandler_pipe::ftruncate (off_t length, bool allow_truncate)
@


1.145.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d148 1
a148 1
  debug_printf ("(%D, %d)", offset, whence);
d244 1
a244 1
      debug_printf ("name %s, size %u, mode %s", pipename, psize,
d364 1
a364 1
  debug_printf ("%R = pipe([%p, %p], %d, %y)", res, fhs[0], fhs[1], psize, mode);
d436 1
a436 1
  syscall_printf ("%R = _pipe([%d, %d], %u, %y)", res, read, write, psize, mode);
d468 1
a468 1
  syscall_printf ("%R = pipe2([%d, %d], %y)", res, read, write, mode);
@


1.145.2.3
log
@Pull in changes from HEAD
@
text
@d402 1
a402 1
static int __reg3
@


1.145.2.4
log
@	* fhandler_tty.cc (fhandler_pty_master::setup): Add
	PIPE_REJECT_REMOTE_CLIENTS to pipe mode on systems supporting it.  Add
	FILE_FLAG_FIRST_PIPE_INSTANCE to pipe open mode.
	* pipe.cc (fhandler_pipe::create): Ditto.  Fix subsequent comment
	accordingly.
	* wincap.h (wincaps::has_pipe_reject_remote_clients): New element.
	* wincap.cc: Implement above element throughout.
	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Temporarily define until
	Mingw64 headers define it.
@
text
@d216 1
a216 3
  DWORD pipe_mode = PIPE_READMODE_BYTE
		    | (wincap.has_pipe_reject_remote_clients ()
		       ? PIPE_REJECT_REMOTE_CLIENTS : 0);
d231 1
a231 1
  open_mode |= PIPE_ACCESS_INBOUND | FILE_FLAG_FIRST_PIPE_INSTANCE;
d255 2
a256 1
	 the pid has been reused.
@


1.145.2.5
log
@	* pipe.cc (fhandler_pipe::open): Fix format specifier and type when
	reading handle value.
	(fhandler_pipe::get_proc_fd_name): Use same format specifier as in
	fhandler_pipe::open.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Hat, Inc.
d75 1
a75 1
  sscanf (get_name (), "/proc/%d/fd/pipe:[%lu]", &pid, (uintptr_t *) &pipe_hdl);
d170 1
a170 1
  __small_sprintf (buf, "pipe:[%lu]", get_handle ());
@


1.145.2.6
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Change type of
	local variable res to ssize_t.
	* net.cc (cygwin_sendto): Fix local variable res, containing return
	value, to be ssize_t as well.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* syscalls.cc (write): Ditto.
	(writev): Ditto.
	* pipe.cc (fhandler_pipe::open): Fix type when reading handle value to
	accommodate 32 bit compiler.
@
text
@d75 1
a75 2
  sscanf (get_name (), "/proc/%d/fd/pipe:[%lu]",
		       &pid, (unsigned long *) &pipe_hdl);
@


1.144
log
@* fhandler.h (PIPE_ADD_PID): Define new flag.
* pipe.cc (fhandler_pipe::create): Don't indiscriminately add process id to
every pipe since some pipe names (fifo, tty) don't need it.
* sigproc.cc (sigproc_init): Pass PIPE_ADD_PID to fhandler_pipe::create to
ensure that pid is always part of sigwait pipe name.
@
text
@d220 1
a220 4
    {
      strcpy (pipename + len, name);
      pipe_mode |= PIPE_TYPE_MESSAGE;
    }
d222 1
a222 1
  if (!name || (open_mode &= PIPE_ADD_PID))
d228 3
@


1.143
log
@* environ.cc (struct parse_thing): Add temporary (?) "pipe_byte" option.
* globals.cc (pipe_byte): Declare.
* pipe.cc (fhandler_pipe::create): Use current process id in pipe name rather
than pid for simple name collision avoidance.  Do this only once to avoid extra
overhead when a busy pipe is found.  Honor pipe_byte to create non-message
pipes if set.
* sigproc.cc (sigproc_init): Use a specific name for the signal pipe.
@
text
@d214 2
a215 3
  const size_t len = __small_sprintf (pipename, PIPE_INTRO "%S-%u-",
				      &cygheap->installation_key,
				      GetCurrentProcessId ());
d225 6
@


1.142
log
@	* cygheap.cc (init_cygheap::init_installation_root): Convert function
	init_installation_root into a cygheap method.
	* cygheap.h (struct init_cygheap): Move installation_root,
	installation_key, and installation_key_buf from shared
	.cygwin_dll_common DLL section to cygheap.  Declare new method
	init_installation_root.
	* dtable.cc (handle_to_fn): Accommodate the move of installation strings
	to the cygheap.
	* external.cc (cygwin_internal): Ditto.
	* fhandler_console.cc (fhandler_console::open_shared_console): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Ditto.
	* fhandler_tty.cc: Ditto, throughout.
	* mount.cc (mount_info::init): Ditto.
	* pipe.cc (fhandler_pipe::create): Ditto.
	* shared.cc: Ditto, throughout.
	(installation_root): Remove.
	(installation_key): Move to cygheap.
	(installation_key_buf): Ditto.
	(installation_root_inited): Remove.
	(SPIN_WAIT): Remove.
	(init_installation_root): Move to cygheap.
	(memory_init): Call cygheap->init_installation_root right after
	cygheap->user.init.  Drop call of init_installation_root function.
	* shared_info.h (init_installation_root): Drop declaration.
	(installation_root): Ditto.
	(installation_key): Ditto.
	* uinfo.cc (pwdgrp::load): Accommodate the move of installation strings
	to the cygheap.
@
text
@d214 11
a224 4
  const size_t len = __small_sprintf (pipename, PIPE_INTRO "%S-",
				      &cygheap->installation_key);
  if (name)
    strcpy (pipename + len, name);
d236 2
a237 2
	__small_sprintf (pipename + len, "pipe-%p-%p", myself->pid,
			InterlockedIncrement ((LONG *) &pipe_unique_id));
d239 3
a241 1
      debug_printf ("CreateNamedPipe: name %s, size %lu", pipename, psize);
d258 1
a258 2
      *r = CreateNamedPipe (pipename, open_mode,
			   PIPE_TYPE_MESSAGE | PIPE_READMODE_BYTE, 1, psize,
@


1.141
log
@* fhandler.h (fhandler_fifo::arm): Declare new function.
* fhandler_fifo.cc (fhandler_fifo::arm): Define new function.
(fhandler_fifo::open): Fix handling of RDWR pipes to avoid opening a second
handle.  Use arm() function to set events.
(fhandler_fifo::raw_read): Correctly go into "connect again logic" when we
detect another writer is available.  Use arm() function to set event.
* pipe.cc (fhandler_pipe::create): Add more detail to debugging output.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2011 Hat, Inc.
d215 1
a215 1
				      &installation_key);
@


1.140
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011 Hat, Inc.
d309 1
a309 1
	  debug_printf ("CreateFile failed, %E");
@


1.139
log
@* pipe.cc (fhandler_pipe::create): Use debug_printf to print debugging info
since this isn't a "syscall".
(pipe_worker): New function created from _pipe().
(_pipe): Use pipe_worker to create a pipe.  Use standard syscall strace
reporting on exit.
(pipe): Ditto.
(pipe2): Ditto.
@
text
@d407 1
a407 1
    } 
@


1.138
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d351 1
a351 1
  syscall_printf ("%R = pipe([%p, %p], %d, %p)", res, fhs[0], fhs[1], psize, mode);
d389 2
a390 2
extern "C" int
_pipe (int filedes[2], unsigned int psize, int mode)
d407 15
a421 1
      debug_printf ("%d, %d", (int) fdin, (int) fdout);
d423 1
d430 11
a440 1
  return _pipe (filedes, DEFAULT_PIPEBUFSIZE, O_BINARY);
d446 11
a456 1
  return _pipe (filedes, DEFAULT_PIPEBUFSIZE, mode);
@


1.137
log
@* pipe.cc (fhandler_pipe::create): Avoid derefencing a NULL pointer.
* child_info.h (child_info): Reorganize some elements so that the ones which
are initialized in a constructor are all together.
* sigproc.cc (child_info::child_info): Initialize values via the constructor
rather than as C statements and make sure that flags is set to zero initially.
* spawn.cc (child_info_spawn::worker): Use iscygwin() test for determining when
to send strace info since it is more foolproof than checking the suspend state.
@
text
@d351 1
a351 1
  syscall_printf ("%d = pipe ([%p, %p], %d, %p)", res, fhs[0], fhs[1], psize, mode);
@


1.136
log
@* fhandler.h (fhandler_pipe::create): Rename from the misnamed
"create_selectable".  Change return to DWORD.
(fhandler_pty_common::pipesize): New constant.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Reflect create_selectable
name change.
* miscfuncs.cc (CreatePipeOverlapped): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Rename from the misnamed "create_selectable".  Return
DWORD.  Only set pipe size to default when it is passed in as zero.
* fhandler_tty.cc (fhandler_pty_master::setup): Ditto.  Use
fhandler_pty_common::pipesize rather than a raw constant.
* tty.cc (tty::not_allocated): Ditto.
* sigproc.cc (sigproc_init): Use create_selectable to create the signal pipe to
get a more appropriate message based pipe.
@
text
@d267 1
a267 1
	  if (!*name)
d274 1
a274 1
	  if (!*name)
@


1.135
log
@* fhandler.h (fhandler_pipe::create_selectable): Remove optional argument, take
an options argument for CreateNamedPipe/CreateFile.  Change handle arguments to
expect pointers.
(fhandler_fifo::fifo_state): Delete.
(fhandler_fifo::dummy_client): Ditto.
(fhandler_fifo::open_nonserver): Ditto.
(fhandler_fifo::wait_state): Ditto.
(fhandler_fifo::raw_write): Ditto.
(fhandler_fifo::read_ready): New field.
(fhandler_fifo::write_ready): Ditto.
(fhandler_fifo::wait): Modify argument.
(fhandler_fifo::fifo_name): Add a new argument.
(fhandler_fifo::fixup_after_fork): New function.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove initialization of
expunged elements.  Initialize new handles to NULL.
(fhandler_fifo::open_nonserver): Delete.
(fnevent): New macro for creating a named event.
(fnpipe): New macro for creating a unique named pipe name.
(create_pipe): New macro for simplification of named pipe creation.
(fhandler_fifo::fifo_name): Use new argument when creating a shared name.
(fhandler_fifo::open): Rewrite.  Use events to synchronize.
(pure_debug_printf): New macro, active only when DEBUGGING.
(fhandler_fifo::wait): Rewrite to wait for new fifo events which are supplied
as a parameter.
(fhandler_fifo::raw_read): Rewrite to use handle mechanism to detect
client-side disconnect.
(fhandler_fifo::raw_write): Delete.
(fhandler_fifo::close): Remove accommodations for expunged fields.  Close event
handles.
(fhandler_fifo::dup): Remove accommodations for expunged fields.  Duplicate
event handles.
(fhandler_fifo::fixup_after_fork): New function.  Perform fixups on event
handles.
(fhandler_fifo::set_close_on_exec): Remove accommodations for expunged fields.
Set inheritance for new handle fields.
* miscfuncs.cc (CreatePipeOverlapped): Accommodate changes in
fhandler_pipe::create_selectable.
* tty.cc (tty::not_allocated): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create_selectable): Accept an extra open_mode argument.  Pass
arguments by reference and allow opening one end of the pipe at a time.
* sys/strace.h (debug_only_printf): Define new macro which calls debug_printf
only when DEBUGGING is defined.
@
text
@d199 3
a201 3
int
fhandler_pipe::create_selectable (LPSECURITY_ATTRIBUTES sa_ptr, HANDLE *r,
				  HANDLE *w, DWORD psize, const char *name, DWORD open_mode)
d210 1
a210 1
  if (psize < DEFAULT_PIPEBUFSIZE)
d330 1
a330 1
  int ret = create_selectable (sa, &r, &w, psize, NULL, FILE_FLAG_OVERLAPPED);
@


1.134
log
@* fhandler_tty.cc (fhandler_pty_slave::read): Use consistent way for testing
ReadFile return.
* pipe.cc (fhandler_pipe::create_selectable): Open the write side of the pipe
in message-mode to force writing as "chunks".  Explain why.
@
text
@d200 2
a201 2
fhandler_pipe::create_selectable (LPSECURITY_ATTRIBUTES sa_ptr, HANDLE& r,
				  HANDLE& w, DWORD psize, const char *name)
d204 4
a207 1
  r = w = INVALID_HANDLE_VALUE;
d216 2
d219 1
a219 2
  /* FIXME: Eventually make ttys work with overlapped I/O. */
  DWORD overlapped = name ? 0 : FILE_FLAG_OVERLAPPED;
d224 2
a225 2
  DWORD err;
  do
a230 2
      else
	strcpy (pipename + len, name);
a233 1
      err = 0;
d249 1
a249 1
      r = CreateNamedPipe (pipename, PIPE_ACCESS_INBOUND | overlapped,
d253 1
a253 1
      if (r != INVALID_HANDLE_VALUE)
d255 2
a256 1
	  debug_printf ("pipe read handle %p", r);
d266 3
a268 1
	  debug_printf ("pipe busy", name ? ", retrying" : "");
d273 3
a275 1
	  debug_printf ("pipe access denied%s", name ? ", retrying" : "");
d280 1
a280 2
	    debug_printf ("CreatePipe failed, %E");
	    return err;
a283 1
  while (!name);
d286 10
a295 1
    return err;
d297 7
a303 1
  debug_printf ("CreateFile: name %s", pipename);
d305 10
a314 4
  /* Open the named pipe for writing.
     Be sure to permit FILE_READ_ATTRIBUTES access.  */
  w = CreateFile (pipename, GENERIC_WRITE | FILE_READ_ATTRIBUTES, 0, sa_ptr,
		  OPEN_EXISTING, overlapped, 0);
d316 1
a316 7
  if (!w || w == INVALID_HANDLE_VALUE)
    {
      /* Failure. */
      DWORD err = GetLastError ();
      debug_printf ("CreateFile failed, %E");
      CloseHandle (r);
      return err;
a318 2
  debug_printf ("pipe write handle %p", w);

d330 1
a330 1
  int ret = create_selectable (sa, r, w, psize);
@


1.133
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d241 7
a247 1
	 because that is only available for Win2k SP2 and WinXP.  */
d249 1
a249 1
			   PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, 1, psize,
@


1.132
log
@	* pipe.cc (pipe): Just call _pipe with O_BINARY mode.  Move code to
	generate normalized pathnames from here...
	(_pipe): ...to here.
@
text
@d89 1
a89 1
	  *this = *(fhandler_pipe *) cfd;
d92 1
a92 1
	  if (!cfd->dup (this))
d175 1
a175 1
fhandler_pipe::dup (fhandler_base *child)
d181 1
a181 1
  if (get_handle () && fhandler_base_overlapped::dup (child))
@


1.131
log
@* miscfuncs.cc (create_pipe): Delete obsolete function.
* miscfuncs.h (create_pipe): Delete define.
* pipe.c (fhandler_pipe::create_selectable): Delete obsolete comment.
@
text
@d367 1
a367 1
pipe (int filedes[2])
d370 2
a371 2
  int res = fhandler_pipe::create (fhs, DEFAULT_PIPEBUFSIZE, O_BINARY);
  if (res == 0)
a385 1

d390 1
a390 1
_pipe (int filedes[2], unsigned int psize, int mode)
d392 1
a392 14
  fhandler_pipe *fhs[2];
  int res = fhandler_pipe::create (fhs, psize, mode);
  /* This type of pipe is not interruptible so set the appropriate flag. */
  if (!res)
    {
      cygheap_fdnew fdin;
      cygheap_fdnew fdout (fdin, false);
      fdin = fhs[0];
      fdout = fhs[1];
      filedes[0] = fdin;
      filedes[1] = fdout;
    }

  return res;
@


1.130
log
@	* dtable.cc (fh_oom): New static fhandler storage.
	(fh_calloc): New static function.  Add a comment to explain why this
	is needed.
	(cnew): Call fh_calloc as placement argument.
	(build_fh_name): Check return code from cnew against address of
	fh_oom to test for out of memory condition.
	(fh_alloc): Ditto.
	(build_fh_pc): Avoid a crash due to useing a NULL fhandler.
	* pipe.cc (fhandler_pipe::create): Check if build_fh_dev returned a
	valid pointer before using it.
@
text
@a245 1
      /* Win 95 seems to return NULL instead of INVALID_HANDLE_VALUE */
@


1.129
log
@* dtable.cc (dtable::select_write): Add missing argument to debug_printf.
* fhandler.cc (fhandler_base_overlapped::setup_overlapped): Explicitly set
io_pending to false.
(fhandler_base_overlapped::has_ongoing_io): Call GetOverlappedResult to force
completion of I/O.
(fhandler_base_overlapped::wait_overlapped): Rewrite to correctly deal with
nonblocking reads and to make more race proof.
(fhandler_base_overlapped::raw_write): Deal with new enum values.
(fhandler_base_overlapped::raw_read): Ditto.  Don't deal with ongoing I/O here
since it makes no sense in the read context.
* fhandler.h (enum wait_return): Add overlapped_unknown,
overlapped_nonblocking_no_data.
* pipe.cc (pipe): Add debugging output.
@
text
@d306 1
a306 1
  int res;
d310 2
d313 7
a319 2
      __seterrno_from_win_error (ret);
      res = -1;
a322 3
      fhs[0] = (fhandler_pipe *) build_fh_dev (*piper_dev);
      fhs[1] = (fhandler_pipe *) build_fh_dev (*pipew_dev);

@


1.128
log
@* fhandler.cc (fhandler_base_overlapped::raw_read): Rename from
read_overlapped.
(fhandler_base_overlapped::raw_e): Rename from write_overlapped.
* fhandler.h (fhandler_*::raw_read): Add reparm decoration.
(fhandler_*::raw_write): Ditto.
(fhandler_base_overlapped::raw_read): Rename from read_overlapped.
(fhandler_base_overlapped::raw_write): Rename from write_overlapped.
(fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
(fhandler_mailslot::raw_read): Ditto.
* fhandler_fifo.cc (fhandler_fifo::raw_read): Reflect read_overlapped ->
raw_read rename.
(fhandler_fifo::raw_write): Ditto.
* fhandler_mailslot.cc (fhandler_mailslot::raw_read): Delete.
(fhandler_mailslot::raw_write): Reflect read_overlapped -> raw_read rename.
* pipe.cc (fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
@
text
@d381 1
@


1.127
log
@	* fhandler.h (class fhandler_base): Remove uninterruptible_io status
	flag.
	(fhandler_base::ready_for_read): Remove declaration.
	(fhandler_socket::ready_for_read): Ditto.
	(fhandler_pipe::ready_for_read): Ditto.
	(fhandler_tty_master::is_slow): Remove.
	* fhandler_console.cc (fhandler_console::open): Drop setting
	uninterruptible_io.
	* fhandler_serial.cc (fhandler_serial::open): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Ditto.
	(fhandler_tty_master::init_console): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
	(fhandler_pipe::open): Ditto.
	(_pipe): Ditto.
	* select.cc (fhandler_pipe::ready_for_read): Remove.
	(fhandler_base::ready_for_read): Remove.
	* syscalls.cc (readv): Drop unneeded wait variable.  Remove entire test
	which might lead to calling ready_for_read.  Remove now unused label
	out.
@
text
@a173 12
void
fhandler_pipe::raw_read (void *in_ptr, size_t& in_len)
{
  return read_overlapped (in_ptr, in_len);
}

int
fhandler_pipe::raw_write (const void *ptr, size_t len)
{
  return write_overlapped (ptr, len);
}

@


1.126
log
@* errno.cc (errmap): Change mapping of NO_SYSTEM_RESOURCES to EFBIG.
* fhandler.cc (MAX_OVERLAPPED_WRITE_LEN): New constant.
(MIN_OVERLAPPED_WRITE_LEN): Ditto.
(fhandler_base_overlapped::close): Accommodate change in arguments to
wait_overlapped.
(fhandler_base_overlapped::setup_overlapped): Add __stdcall and regparm
modifiers.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::wait_overlapped): Modify to return an enum returning
various states.  Accept nonblocking parameter.
(fhandler_base_overlapped::read_overlapped): Add __stdcall and regparm
modifiers.  Rework to attempt to be smarter about reacting to states returned
by wait_overlapped.
(fhandler_base_overlapped::write_overlapped): Ditto.  Add fallback option for
when wait_overlapped detects that smaller chunks must be written.
(fhandler_base_overlapped::write_overlapped_fallback): Ditto.
* fhandler.h (DEFAULT_PIPEBUFSIZE): Move definition here from pipe.cc.
(fhandler_base::has_ongoing_io): Define with __stdcall and regparm modifiers.
(fhandler_base_overlapped::wait_return): New enum.
(fhandler_base_overlapped::max_atomic_write): New variable.
(fhandler_base_overlapped:: wait_overlapped): Accommodate changes mentioned
above to arguments and modifiers.
(fhandler_base_overlapped::setup_overlapped): Ditto for modifiers.
(fhandler_base_overlapped::read_overlapped): Ditto.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::fhandler_base_overlapped): Zero max_atomic_write.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Set max_atomic_write to the
size of the DEFAULT_PIPEBUFSIZE.
(fhandler_fifo::wait): Accommodate change in arguments to wait_overlapped.
* pipe.cc (fhandler_pipe::fhandler_pipe): Set max_atomic_write to the size of
the DEFAULT_PIPEBUFSIZE.
(fhandler_pipe::create_selectable): Allow minimum size of DEFAULT_PIPEBUFSIZE.
(DEFAULT_PIPEBUFSIZE): Delete here, move to fhandler.h.
@
text
@a30 1
  uninterruptible_io (true);
a131 1
  uninterruptible_io (fh->uninterruptible_io ());
a407 1
      fhs[0]->uninterruptible_io (true);
@


1.125
log
@	* pipe.cc (fhandler_pipe::open): Duplicate content of opened pipe
	fhandler before calling dup method.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Hat, Inc.
d29 1
d221 2
a222 2
  if (psize < PIPE_BUF)
    psize = PIPE_BUF;
a376 2
#define DEFAULT_PIPEBUFSIZE 65536

@


1.124
log
@* fhandler.h (fhandler_base::setup_overlapped): Delete virtual declaration.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base_overlapped): Remove now-unneeded friend.
(fhandler_base_overlapped::setup_overlapped): Return int, remove parameter.
(fhandler_base_overlapped::get_overlapped): Return reference.
(fhandler_base_overlapped::fhandler_base_overlapped): Be more assertive about
zeroing everything.
(fhandler_base_overlapped::fixup_after_fork): Declare new function.
(fhandler_base_overlapped::fixup_after_exec): Ditto.
(fhandler_base_overlapped::dup): Ditto.
(fhandler_base_overlapped::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo::dup): Call fhandler_base_overlapped::dup
rather than fhandler_base::dup.
* pipe.cc (fhandler_pipe::dup): Ditto.
(fhandler_pipe::init): Accommodate change in setup_overlapped arguments for
"opened_properly" case.
@
text
@d89 3
@


1.123
log
@* fhandler.cc (fhandler_base::dup): Call setup_overlapped unconditionally.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::fixup_after_fork): Ditto.
(fhandler_base::fixup_after_exec): Ditto.
(fhandler_base_overlapped::setup_overlapped): Move to this class from
fhandler_base.
(handler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::wait_overlapped): Ditto.  Track when we expect
pending I/O.
(fhandler_base_overlapped::read_overlapped): Move to this class from
fhandler_base.  Return error if ongoing I/O.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Semi-reinstate previous function.
* fhandler.h (fhandler_base::wait_overlapped): Move to fhandler_base_overlapped
class.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_overlapped): Ditto.
(fhandler_base::get_overlapped_buffer): Ditto.
(fhandler_base_overlapped): New class.
(fhandler_pipe): Inherit from fhandler_base_overlapped.  Remove overlapped
stuff as a result.
(fhandler_fifo): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Initialize fhandler_base_overlapped.
(pipe): Put a descriptive name in the fhandler.
@
text
@d57 4
a60 1
  setup_overlapped (opened_properly);
d191 1
a191 1
  if (get_handle () && fhandler_base::dup (child))
@


1.122
log
@* libc/strfmon.c (__setup_vars): Fix compiler warning about assigning const
strings.  Compare a pointer to NULL rather than '\0'.
* dll_init.cc (dll_dllcrt0_1): Minor comment fix.
* pipe.cc (fhandler_pipe::create_selectable): Remove Win9x accommodation.
@
text
@d27 1
a27 1
  : fhandler_base (), popen_pid (0), overlapped (NULL)
d381 5
@


1.121
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d254 1
a254 1
      if (r && r != INVALID_HANDLE_VALUE)
@


1.120
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d4 1
a4 1
   2008, 2009 Hat, Inc.
d56 1
a56 2
  if (mode & O_NOINHERIT)
    close_on_exec (true);
d118 1
a118 1
  inh = !(flags & O_NOINHERIT);
a125 2
  if (flags & O_NOINHERIT)
    close_on_exec (true);
d312 1
a312 1
  SECURITY_ATTRIBUTES *sa = (mode & O_NOINHERIT) ?  &sec_none_nih : &sec_none;
d409 6
@


1.119
log
@* fhandler_fifo.cc (fhandler_fifo::open): Avoid resetting errno after it has
been explicitly set.
* include/cygwin/version.h: Bump DLL minor version number to 2.
@
text
@d120 1
a120 1
  if (!DuplicateHandle (proc, pipe_hdl, hMainProc, &nio_hdl,
@


1.118
log
@	* cygprops.h: New file.
	* dtable.cc (handle_to_fn): Add check for correct installation_key
	string in object name for pipes and ttys.
	* external.cc (cygwin_internal): Add CW_GET_INSTKEY to allow fetching
	the installation_key from cygserver.
	* fhandler_fifo.cc (fhandler_fifo::fifo_name): Add installation_key
	to fifo name.
	* globals.cc: Include cygprops.h.
	(_RDATA): Move slightly and add comment.
	(cygwin_props): Define.
	* mount.cc (mount_info::init): Accommodate the fact that
	installation_root is now a global variable in DLL common shared memory,
	rather than a member of cygwin_shared.
	* pipe.cc (fhandler_pipe::create_selectable): Add installation_key to
	pipe name.
	* shared.cc (installation_root): Define here for storage in DLL
	common shared memory.
	(installation_key): Ditto.
	(installation_key_buf): Ditto.
	(init_installation_root): Convert from shared_info method to ordinary
	function.  Add initializing installation_key.  Invalidate
	installation_key depending of value of disable_key property.  Add
	comment to explain.
	(get_shared_parent_dir): Add installation_key to directory name.
	(get_session_parent_dir): Ditto.
	(shared_info::initialize): Move call to init_installation_root from
	here...
	(memory_init): ...to here.  Add debug output to print installation root
	and installation key.  Add comment to explain why.
	* shared_info.h (SHARED_INFO_CB): Recalculate.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Remove definition of installation_root and
	declaration of init_installation_root.
	(init_installation_root): Declare.
	(installation_root): Declare.
	(installation_key): Declare.
	* uinfo.cc (pwdgrp::load): Accommodate the fact that installation_root
	is now a global variable in DLL common shared memory.
	* include/cygwin/version.h: Bump API minor number.
	(CYGWIN_INFO_INSTALLATIONS_NAME): Add.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_INSTKEY.
@
text
@d4 1
a4 1
   2008 Hat, Inc.
@


1.117
log
@* pipe.cc (fhandler_pipe::create_selectable): Add -pipe to default pipe names.
* lib/_cygwin_crt0_common.cc (_cygwin_crt0_common): Use bool/true/false for
what is actually a boolean variable.
@
text
@d24 1
d220 4
a223 1
  char pipename[MAX_PATH] = PIPE_INTRO;
d235 1
a235 1
	__small_sprintf (pipename + strlen(PIPE_INTRO), "pipe-%p-%p", myself->pid,
d238 1
a238 1
	strcpy (pipename + strlen(PIPE_INTRO), name);
@


1.116
log
@* fhandler.h (fhandler_cygdrive:DRVSZ): New enum.
(pdrive_buf): New place to hold information about cygdrive.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Store drive info in
pdrive_buf since get_win32_name() could now be too small to hold everything.
(fhandler_cygdrive::rewinddir): Reset pdrive to pdrive_buf.
(fhandler_cygdrive::closedir): Ditto.
* pipe.cc (fhandler_pipe::init): Be more defensive when referencing
get_win32_name().  Rework logic which made a copy of the POSIX path and then
never used it.
@
text
@d231 1
a231 1
	__small_sprintf (pipename + strlen(PIPE_INTRO), "%p-%p", myself->pid,
@


1.115
log
@* dcrt0.cc (jit_debug): New global.
(initial_env): Set jit_debug when we are automatically starting a gdb process.
* dtable.cc (dtable::get_debugger_info): Don't tty tricks when we are being
debugged by our own captive gdb, as determined by jit_debug == true.
(dtable::init_std_file_from_handle): Detect errors when initializing a tty
early rather than at random points later.
* fhandler.h (fhandler_*::init): Return int to indicate success/failure.
* fhandler.cc (fhandler_base::init): Reflect change in return value.
* pipe.cc (fhandler_pipe::init): Ditto.
(fhandler_pipe::create_selectable): Don't say we're retrying when we aren't.
* fhandler_console.cc (fhandler_console::init): Ditto.  Return success/failure.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
(fhandler_tty_slave::open): Make debugging output more detailed.
* tty.cc (tty_list::terminate): Don't close I/O handles before all slaves have
checked in.
(tty::slave_alive): Make a non-inlined function.  Check if tty pipe handles can
be created as an additional exists check.
* tty.h (tty::slave_alive): Just define here.
@
text
@d35 4
a38 2
  // FIXME: Have to clean this up someday
  if (!*get_win32_name () && get_name ())
d40 2
d43 1
a43 3
      strcpy (hold_normalized_name, get_name ());
      char *s, *d;
      for (s = hold_normalized_name, d = (char *) get_win32_name (); *s; s++, d++)
@


1.114
log
@* fhandler.cc (fhandler_base::wait_overlapped): Set bytes to -1 on EINTR or
real error.
(fhandler_base::write_overlapped): Assume that bytes_written will contain
proper error value.
* pipe.cc (fhandler_pipe::fhandler_pipe): Set uninterruptible_io since signals
are handled by pipe functions now.
@
text
@d32 1
a32 1
void
d56 1
d263 1
a263 1
	  debug_printf ("pipe busy, retrying");
d268 1
a268 1
	  debug_printf ("pipe access denied, retrying");
@


1.113
log
@* fhandler.h (fhandler_base_setup_overlapped): Add new argument.
(fhandler_base::get_overlapped_buffer): Declare new function.
(fhandler_base::set_overlapped): Ditto.
(fhandler_pipe::overlapped): New variable.
(fhandler_pipe::get_overlapped): Rework to return contents of overlapped
variable.
(fhandler_pipe::set_overlapped): Set overlapped variable based on argument.
(fhandler_fifo::get_overlapped_buffer): Return pointer to io_status.
* fhandler.cc (handler_base::setup_overlapped): Set to overlapped pointer to
NULL if new doit parameter is false.  Otherwise set up overlapped event as
usual.
(fhandler_base::wait_overlapped): Return inres if this isn't an overlapped
operation.
(fhandler_base::read_overlapped): Remove inappropriate asserts.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero overlapped element.
(struct pipesync): Delete.
(getov_result): Ditto.
(pipe_handler): Ditto.
(pipesync::pipesync): Ditto.
(fhandler_pipe::init): Don't set up pipesync thread.  Just pass opened_properly
flag along to overlapped setup.
@
text
@d29 1
@


1.112
log
@* pipe.cc (getov_result): Minor cleanup.
@
text
@d26 1
a26 1
  : fhandler_base (), popen_pid (0)
a27 1
  get_overlapped ()->hEvent = NULL;
a30 124
struct pipesync
{
  bool reader;
  HANDLE ev, non_cygwin_h, ret_handle;
  pipesync(HANDLE, DWORD);
  int operator == (int x) const {return !!ev;}
  static DWORD WINAPI handler (LPVOID *);
};

inline bool
getov_result (BOOL res, bool reading, HANDLE h, DWORD& nbytes, LPOVERLAPPED ov)
{
  DWORD err = GetLastError ();
  if (res || (reading && ov && err == ERROR_HANDLE_EOF))
    /* not an error */;
  else if (!ov || (err != ERROR_IO_PENDING)
	   || (!GetOverlappedResult (h, ov, &nbytes, true)
	       && (!reading || (GetLastError () != ERROR_HANDLE_EOF))))
    {
      __seterrno ();
      return false;
    }
  return true;
}

static DWORD WINAPI
pipe_handler (LPVOID in_ps)
{
  pipesync ps = *(pipesync *) in_ps;
  HANDLE h, in, out;
  DWORD err = fhandler_pipe::create_selectable (&sec_none_nih, in, out, 0);
  if (err)
    {
      SetLastError (err);
      system_printf ("couldn't create a shadow pipe for non-cygwin pipe I/O, %E");
      return 0;
    }
  h = ((pipesync *) in_ps)->ret_handle = ps.reader ? in : out;
  SetHandleInformation (h, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
  SetEvent (ps.ev);

  DWORD read_bytes, write_bytes;
  HANDLE hread, hwrite, hclose;
  OVERLAPPED ov, *rov, *wov;
  memset (&ov, 0, sizeof (ov));
  ov.hEvent = CreateEvent (&sec_none_nih, true, false, NULL);
  if (ps.reader)
    {
      hread = ps.non_cygwin_h;
      hclose = hwrite = out;
      wov = &ov;
      rov = NULL;
    }
  else
    {
      hclose = hread = in;
      hwrite = ps.non_cygwin_h;
      rov = &ov;
      wov = NULL;
    }

  char buf[4096];
  while (1)
    {
      ResetEvent (ov.hEvent);
      BOOL res = ReadFile (hread, buf, 4096, &read_bytes, rov);
      if (!getov_result (res, true, hread, read_bytes, rov))
	break;
      if (!read_bytes)
	break;

      res = WriteFile (hwrite, buf, read_bytes, &write_bytes, wov);
      if (!getov_result (res, false, hwrite, write_bytes, wov))
	break;
      if (write_bytes != read_bytes)
	break;
    }

  err = GetLastError ();
  CloseHandle (ov.hEvent);
  CloseHandle (hclose);
  CloseHandle (ps.non_cygwin_h);
  SetLastError (err);
  return 0;
}

pipesync::pipesync (HANDLE f, DWORD is_reader):
  reader (false), ret_handle (NULL)
{
  ev = CreateEvent (&sec_none_nih, true, false, NULL);
  if (!ev)
    system_printf ("couldn't create synchronization event for non-cygwin pipe, %E");
  else
    {
      debug_printf ("created thread synchronization event %p", ev);
      non_cygwin_h = f;
      reader = !!is_reader;
      ret_handle = NULL;

      DWORD tid;
      HANDLE ht = CreateThread (&sec_none_nih, 0, pipe_handler, this, 0, &tid);

      if (!ht)
	goto out;
      CloseHandle (ht);

      switch (WaitForSingleObject (ev, INFINITE))
	{
	case WAIT_OBJECT_0:
	  break;
	default:
	  system_printf ("WFSO failed waiting for synchronization event for non-cygwin pipe, %E");
	  break;
	}
    }

out:
  if (ev)
    {
      CloseHandle (ev);
      ev = NULL;
    }
}

a50 6
  if (!opened_properly)
    {
      pipesync ps (f, a & GENERIC_READ);
      f = ps.ret_handle;
    }

d54 1
a54 1
  setup_overlapped ();
@


1.111
log
@* pipe.cc (getov_result): Add parameters to facilitate better EOF checking.
(pipe_handler): Pass extra arguments to getov_result.
@
text
@d45 1
a45 1
  if (res || (reading && ov && !res && err == ERROR_HANDLE_EOF))
a72 1
  char buf[4096];
d93 1
a153 1
  return;
@


1.110
log
@* fhandler.h (fhandler_pipe::raw_read): Remove __stdcall decoration.
* pipe.cc (fhandler_pipe::raw_read): Ditto.
@
text
@d42 1
a42 1
getov_result (HANDLE h, DWORD& nbytes, LPOVERLAPPED ov)
d44 6
a49 2
  if (ov && (GetLastError () != ERROR_IO_PENDING
	     || !GetOverlappedResult (h, ov, &nbytes, true)))
d98 1
a98 1
      if (!res && !getov_result (hread, read_bytes, rov))
d104 1
a104 1
      if (!res && !getov_result (hwrite, write_bytes, wov))
@


1.109
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d295 1
a295 1
void __stdcall
@


1.108
log
@	* fhandler.h (class fhandler_pipe): Rename read and write
	declarations to raw_read and raw_write.
	* pipe.cc (fhandler_pipe::raw_read): Rename from read.
	(fhandler_pipe::raw_write): Rename from write.
@
text
@d119 2
d122 11
a132 7
      system_printf ("couldn't create synchronization event for non-cygwin pipe, %E");
      goto out;
    }
  debug_printf ("created thread synchronization event %p", ev);
  non_cygwin_h = f;
  reader = !!is_reader;
  ret_handle = NULL;
d134 8
a141 14
  DWORD tid;
  HANDLE ht = CreateThread (&sec_none_nih, 0, pipe_handler, this, 0, &tid);

  if (!ht)
    goto out;
  CloseHandle (ht);

  switch (WaitForSingleObject (ev, INFINITE))
    {
    case WAIT_OBJECT_0:
      break;
    default:
      system_printf ("WFSO failed waiting for synchronization event for non-cygwin pipe, %E");
      break;
@


1.107
log
@* fhandler.cc (fhandler_base::wait_overlapped): Always assume that bytes will
be non-NULL.  Distinguish input result from result derived from WFMO and
GetOverlappedResult or res can never be -1.  Only raise SIGPIPE when writing.
* fhandler.h (fhandler_base::wait_overlapped): Pass first argument by value.
* fhandler_fifo.cc (fhandler_fifo::wait): Pass in dummy byte count to
wait_overlapped.
* pipe.cc (DEFAULT_PIPEBUFSIZE): Define to 65536 explicitly.
@
text
@d296 1
a296 1
fhandler_pipe::read (void *in_ptr, size_t& in_len)
d302 1
a302 1
fhandler_pipe::write (const void *ptr, size_t len)
@


1.106
log
@	* environ.cc (known): Remove "binmode" option.
	* fhandler.cc (binmode): Remove.
	(fhandler_base::set_flags): Accommodate binmode removal.
	* path.h (path_conv::set_binary): Remove.
	* pipe.cc (pipe): Create pipes always as binary pipes.
	* winsup.h (binmode): Remove declaration.
@
text
@d493 1
a493 1
#define DEFAULT_PIPEBUFSIZE (16 * PIPE_BUF)
@


1.105
log
@Remove unneeded header files from source files throughout.
@
text
@a497 1
  extern DWORD binmode;
d499 1
a499 3
  int res = fhandler_pipe::create (fhs, DEFAULT_PIPEBUFSIZE,
				   (!binmode || binmode == O_BINARY)
				   ? O_BINARY : O_TEXT);
@


1.104
log
@* dtable.cc: Define various device-related string constants as wide character
constants.
(dtable::init_std_file_from_handle): Reorganize pipe handling to try to catch
special tty case.
(build_fh_name_worker): Declare for common use.
(build_fh_name): Define char version.
(build_fh_name): Define (currently unused) UNICODE_STRING version.
(decode_tty): Detect if pipe is actually a cygwin tty, returning the tty name
in the buffer.
(handle_to_fn): Reorganize to use wide characters.
* dtable.h (build_fh_name): Declare (currently unused) UNICODE_STRING version.
* fhandler_tty.cc (fhandler_pty_master::setup): Use
fhandler_pipe::create_selectable to create a pipe with a given name.
* pipe.cc (pipe_handler): Make returned handle inheritable.
(fhandler_pipe::create_selectable): Take an optional name.  Use a standard
cygwin introducer for the name.
* path.cc (path_conv::check): Make first argument const.
* path.h (path_conv::check): Ditto for declaration.
(path_conv::path_conv): Ditto for UNICODE_STRING version.
@
text
@a14 1
#include <unistd.h>
a16 1
#include <limits.h>
a22 1
#include "thread.h"
a23 2
#include "cygthread.h"
#include "ntdll.h"
@


1.103
log
@	* pipe.cc (fhandler_pipe::create_selectable): Use MAX_PATH instead of
	CYG_MAX_PATH.
	* tty.cc (tty_list::init_session): Ditto.
	(tty::alive): Ditto.
	(tty::open_mutex): Ditto.
	(tty::create_inuse): Ditto.
	(tty::get_event): Ditto.
@
text
@d62 1
a62 1
  HANDLE in, out;
d70 2
a71 1
  ((pipesync *) in_ps)->ret_handle = ps.reader ? in : out;
d128 1
a157 1
#define WINPIPE "\\\\.\\pipe\\"
d328 2
d339 1
a339 1
				  HANDLE& w, DWORD psize)
d348 3
a350 1
  char pipename[MAX_PATH];
d355 2
a356 1
  while (1)
d359 5
a363 3

      __small_sprintf (pipename, "\\\\.\\pipe\\cygwin-%p-%p", myself->pid,
		       InterlockedIncrement ((LONG *) &pipe_unique_id));
d367 1
d377 1
a377 1
      r = CreateNamedPipe (pipename, PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
d388 1
a388 1
      DWORD err = GetLastError ();
d409 4
d419 1
a419 1
		  OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
@


1.102
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d345 1
a345 1
  char pipename[CYG_MAX_PATH];
@


1.101
log
@* tty.cc: Update copyright.
* pipe.cc: Ditto.
@
text
@a116 1
      
@


1.100
log
@* newsym: First stab at understanding data as well as functions.

* pipe.cc (fhandler_pipe::init): Move more intelligence here.
(fhandler_pipe::create): Simplify based on above change.

* tty.cc (tty_list::allocate): Remove non-NT code.
@
text
@d3 2
a4 2
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007 Hat, Inc.
@


1.99
log
@* dtable.cc (POSIX_NAMED_PIPE): New define.
(POSIX_NAMED_PIPE_LEN): Ditto.
(dtable::add_archetype): Use crealloc_abort.
(dtable::init_std_file_from_handle): Specifically detect pipe stdin/stdout.
Pass name to build_fh_dev so that proper name is recorded.  Use binmode of fh
if it is set before using get_default_mode.  Set proper read/write access when
calling init().
(handle_to_fn): Handle pipes.
* fhandler.cc (fhandler_base::wait_overlapped): Add some debugging.
* fhandler.h (fhandler_base::set_name): Default to just setting the path_conv
name.
(fhandler_pipe::init): Declare.
* pipe.cc (struct pipesync): New struct.
(getov_result): New function.  Blocks and retrieves the result of an overlay
I/O operation.
(pipe_handler): New function.
(pipesync::pipesync): New function.  Initializer for pipesync struct.
(handler_pipe::init): Define.  Detects attempts to set up a "native" pipe
fhandler and creates a thread which accepts input from or output to the
non-cygwin pipe, creating a cygwin pipe wrapper around the non-cygwin pipe.
(fhandler_pipe::create): Add pipe-specific flags to call to init().
* exceptions.cc (ctrl_c_handler): Lock process while we determine what to do.
@
text
@d159 1
a159 1
fhandler_pipe::init (HANDLE f, DWORD a, mode_t bin)
d184 3
a186 1
  fhandler_base::init (f, a, bin);
d429 1
a429 1
  int res = -1;
d433 4
a436 1
    __seterrno_from_win_error (ret);
d442 3
a444 9
      int binmode = mode & O_TEXT ?: O_BINARY;
      fhs[0]->init (r, FILE_CREATE_PIPE_INSTANCE | GENERIC_READ, binmode);
      fhs[1]->init (w, FILE_CREATE_PIPE_INSTANCE | GENERIC_WRITE, binmode);
      if (mode & O_NOINHERIT)
       {
	 fhs[0]->close_on_exec (true);
	 fhs[1]->close_on_exec (true);
       }

@


1.98
log
@revert premature checkin
@
text
@d37 151
d438 2
a439 2
      fhs[0]->init (r, GENERIC_READ, binmode);
      fhs[1]->init (w, GENERIC_WRITE, binmode);
a445 2
      fhs[0]->setup_overlapped ();
      fhs[1]->setup_overlapped ();
@


1.97
log
@* dllfixdbg: Eliminate extra objcopy step.
@
text
@a36 47
void
fhandler_pipe::init (HANDLE f, DWORD a, mode_t bin)
{
  // FIXME: Have to clean this up someday
  if (!*get_win32_name () && get_name ())
    {
      char *hold_normalized_name = (char *) alloca (strlen (get_name ()) + 1);
      strcpy (hold_normalized_name, get_name ());
      char *s, *d;
      for (s = hold_normalized_name, d = (char *) get_win32_name (); *s; s++, d++)
	if (*s == '/')
	  *d = '\\';
	else
	  *d = *s;
      set_name (hold_normalized_name);
    }

  bool opened_properly = a & FILE_CREATE_PIPE_INSTANCE;
  a &= ~FILE_CREATE_PIPE_INSTANCE;
  if (!opened_properly)
    {
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      HANDLE h = NULL;
      DWORD access = SYNCHRONIZE;
      if (a & GENERIC_READ)
	access |= FILE_READ_DATA | FILE_READ_ATTRIBUTES;
      if (a & GENERIC_WRITE)
	access |= FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES;
      OBJECT_ATTRIBUTES attr;
      static UNICODE_STRING fname;
      InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE, f, NULL);
small_printf ("f %p, h %p\n", f, h);
      status = NtOpenFile (&h, a | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ | FILE_SHARE_WRITE,
			   FILE_SEQUENTIAL_ONLY | FILE_SYNCHRONOUS_IO_ALERT);
      if (!NT_SUCCESS (status))
	system_printf ("Unable to reopen pipe %s, attributes %p, NT error: %p win32: %lu",
		       get_win32_name (), access, status, RtlNtStatusToDosError (status));
small_printf ("f %p, h %p\n", f, h);
      CloseHandle (f);
      f = h;
    }

  fhandler_base::init (f, a, bin);
  setup_overlapped ();
}

d287 2
a288 2
      fhs[0]->init (r, FILE_CREATE_PIPE_INSTANCE | GENERIC_READ, binmode);
      fhs[1]->init (w, FILE_CREATE_PIPE_INSTANCE | GENERIC_WRITE, binmode);
d295 2
@


1.96
log
@* debug.cc (close_handle): Change debug output format slightly.
* dlfcn.cc (dlclose): Don't close handle returned from GetModuleHandle(NULL).
* fhandler.h (fhandler_pipe::create): Remove obsolete argument.
(fhandler_pipe::create): Ditto.
* fhandler.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Ditto.
@
text
@d37 47
d334 2
a335 2
      fhs[0]->init (r, GENERIC_READ, binmode);
      fhs[1]->init (w, GENERIC_WRITE, binmode);
a341 2
      fhs[0]->setup_overlapped ();
      fhs[1]->setup_overlapped ();
@


1.95
log
@Preliminary change to make fifos/pipes interruptible and fifos reliable.
* dtable.cc (dtable::find_fifo): Eliminate definition.
* dtable.h (dtable::find_fifo): Ditto for declaration.
* fhandler.cc (fhandler_base::raw_read): Remove pipe-specific stuff.
(fhandler_base::fhandler_base): Ditto.
(fhandler_base::close): Handle overlapped I/O structure if appropriate.
(fhandler_base::dup): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::setup_overlapped): Define new function.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::get_overlapped): Declare new function.
(fhandler_base::setup_overlapped): Ditto.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_guard): Eliminate.
(fhandler_pipe::*): Rework to eliminate most Win9x related cruft, removing many
variables and defining a new overlapped capability.
(fhandler_fifo::*): Ditto.
(fifo_state): Declare new enum.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove old Win9x stuff.
Initialize overlapped handle to NULL.
(fhandler_fifo::set_use): Eliminate.
(fhandler_fifo::open_nonserver): Define.
(fhandler_fifo::open): Rework to use named pipes and overlapped I/O.
(fhandler_fifo::wait): Define new function to wait for named pipe connection.
(fhandler_fifo::read): Rework to use wait() and new overlapped I/O
functionality.
(fhandler_fifo::write): Ditto.
(fhandler_fifo::dup): Eliminate.
* pinfo.cc (commune_process): Remove fifo handling.
(_pinfo::commune_request): Ditto.
* pinfo.h (picom): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Remove Win9x stuff.  Initialize
overlapped handle to NULL.
(fhandler_pipe::open): Eliminate Win9x stuff.
(fhandler_pipe::set_close_on_exec): Eliminate.
(read_pipe): Eliminate.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::fixup_after_exec): Ditto.
(fhandler_pipe::fixup_in_child): Ditto.
(fhandler_pipe::read): Rework to use overlapped I/O.
(fhandler_pipe::write): New function using overlapped I/O.
(fhandler_pipe::dup): Rework to eliminate Win9x stuff.
(fhandler_pipe::create_selectable): Rework to eliminate Win9x and use
overlapped I/O.
* select.cc (peek_pipe): Rework to eliminate Win9x stuff and use overlapped
I/O.
(fhandler_base::ready_for_read): Ditto.
@
text
@d184 1
a184 1
				  HANDLE& w, DWORD psize, bool fifo)
d190 1
a190 1
  if (!fifo && psize < PIPE_BUF)
d272 1
a272 1
fhandler_pipe::create (fhandler_pipe *fhs[2], unsigned psize, int mode, bool fifo)
d278 1
a278 1
  int ret = create_selectable (sa, r, w, psize, fifo);
@


1.94
log
@	* fhandler.cc(fhandler_base::open): Open with READ_CONTROL only in
	case of query_open flag set to query_read_control.  Add case for
	new query_read_attributes flag.
	(fhandler_base::fstatvfs): New method.
	* fhandler.h (enum query_state): Add query_read_attributes flag.
	(class fhandler_base): Declare new virtual fstatvfs method.
	(class fhandler_socket): Ditto.
	(class fhandler_pipe): Ditto.
	(class fhandler_fifo): Ditto.
	(class fhandler_disk_file): Ditto.
	(class fhandler_virtual): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Open with
	query_read_attributes instead of query_read_control.
	(fhandler_disk_file::fstatvfs): New method.
	(fhandler_disk_file::facl): Open with query_read_attributes instead of
	query_read_control.
	* fhandler_fifo.cc (fhandler_fifo::fstatvfs): New method.
	* fhandler_socket.cc (fhandler_socket::fstatvfs): New method.
	(fhandler_socket::fchmod): Return with EBADF in the default case.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::fstatvfs): Ditto.
	* ntdll.h (struct _FILE_FS_ATTRIBUTE_INFORMATION): Define.
	(struct _FILE_FS_FULL_SIZE_INFORMATION): Define.
	* pipe.cc (fhandler_pipe::fstatvfs): New method.
	* syscalls.cc (fstatvfs): Just call the fhandler's fstatvfs.
	(statvfs): Ditto.
	(fstatfs): Call fstatvfs.
	(statfs): Drop EFAULT handling.
@
text
@d31 1
a31 1
  : fhandler_base (), guard (NULL), broken_pipe (false), popen_pid (0)
d33 1
a100 12
  if (!fh->guard)
    /* nothing to do */;
  else if (DuplicateHandle (proc, fh->guard, hMainProc, &guard,
			    0, inh, DUPLICATE_SAME_ACCESS))
    ProtectHandle (guard);
  else
    {
      __seterrno ();
      goto out;
    }
  if (fh->read_state)
    create_read_state (2);
a108 2
  if (guard)
    CloseHandle (guard);
a139 11
void
fhandler_pipe::set_close_on_exec (bool val)
{
  fhandler_base::set_close_on_exec (val);
  if (guard)
    {
      set_no_inheritance (guard, val);
      ModifyHandle (guard, !val);
    }
}

a146 15
struct pipeargs
{
  fhandler_base *fh;
  void *ptr;
  size_t *len;
};

static DWORD WINAPI
read_pipe (void *arg)
{
  pipeargs *pi = (pipeargs *) arg;
  pi->fh->fhandler_base::read (pi->ptr, *pi->len);
  return 0;
}

d150 1
a150 10
  if (broken_pipe)
    in_len = 0;
  else
    {
      pipeargs pi = {dynamic_cast<fhandler_base *>(this), in_ptr, &in_len};
      cygthread *th = new cygthread (read_pipe, 0, &pi, "read_pipe");
      if (th->detach (read_state) && !in_len)
	in_len = (size_t) -1;	/* received a signal */
    }
  ReleaseMutex (guard);
d154 1
a154 18
fhandler_pipe::close ()
{
  if (guard)
    ForceCloseHandle (guard);
#ifndef NEWVFORK
  if (read_state)
#else
  // FIXME is this vfork_cleanup test right?  Is it responsible for some of
  // the strange pipe behavior that has been reported in the cygwin mailing
  // list?
  if (read_state && !cygheap->fdtab.in_vfork_cleanup ())
#endif
    ForceCloseHandle (read_state);
  return fhandler_base::close ();
}

void
fhandler_pipe::fixup_in_child ()
d156 1
a156 18
  if (read_state)
    create_read_state (2);
}

void
fhandler_pipe::fixup_after_exec ()
{
  if (!close_on_exec ())
    fixup_in_child ();
}

void
fhandler_pipe::fixup_after_fork (HANDLE parent)
{
  fhandler_base::fixup_after_fork (parent);
  if (guard && fork_fixup (parent, guard, "guard"))
    ProtectHandle (guard);
  fixup_in_child ();
a161 1
  int res = -1;
a163 1
  ftp->guard = ftp->read_state = NULL;
d165 1
d167 1
a167 7
    goto err;

  if (!guard)
    /* nothing to do */;
  else if (DuplicateHandle (hMainProc, guard, hMainProc, &ftp->guard, 0, true,
			    DUPLICATE_SAME_ACCESS))
    ProtectHandle1 (ftp->guard, guard);
d169 1
a169 4
    {
      debug_printf ("couldn't duplicate guard %p, %E", guard);
      goto err;
    }
a170 22
  if (!read_state)
    /* nothing to do */;
  else if (DuplicateHandle (hMainProc, read_state, hMainProc,
			    &ftp->read_state, 0, false,
			    DUPLICATE_SAME_ACCESS))
    ProtectHandle1 (ftp->read_state, read_state);
  else
    {
      debug_printf ("couldn't duplicate read_state %p, %E", read_state);
      goto err;
    }

  res = 0;
  goto out;

err:
  if (ftp->guard)
    ForceCloseHandle1 (ftp->guard, guard);
  if (ftp->read_state)
    ForceCloseHandle1 (ftp->read_state, read_state);

out:
d216 1
a216 1
      r = CreateNamedPipe (pipename, PIPE_ACCESS_INBOUND,
d241 5
a245 13
	  /* CreateNamePipe failed.  Maybe we are on an older Win9x platform without
	     named pipes.  Return an anonymous pipe as the best approximation.  */
	  debug_printf ("CreateNamedPipe failed, resorting to CreatePipe size %lu",
			psize);
	  if (CreatePipe (&r, &w, sa_ptr, psize))
	    {
	      debug_printf ("pipe read handle %p", r);
	      debug_printf ("pipe write handle %p", w);
	      return 0;
	    }
	  err = GetLastError ();
	  debug_printf ("CreatePipe failed, %E");
	  return err;
d254 1
a254 1
		  OPEN_EXISTING, 0, 0);
d295 2
a296 2
      fhs[0]->create_read_state (2);

a297 1
      fhs[0]->create_guard (sa);
@


1.93
log
@	* fhandler.h (class fhandler_pipe): Remove members writepipe_exists,
	orig_pid and id.  Make hit_eof inline.
	* fhandler_fifo.cc (fhandler_fifo::open): Drop handling of
	writepipe_exists, orig_pid and id.
	* pipe.cc: Ditto throughout.
	(pipecount): Remove.
	(pipeid_fmt): Remove.
	(fhandler_pipe::hit_eof): Simplify.  Move to fhandler.h.
	(fhandler_pipe::dup): Drop leave label.
	(fhandler_pipe::create): Drop has_unreliable_pipes case.
	* wincap.cc: Remove has_unreliable_pipes throughout.
	* wincap.h: Ditto.
@
text
@d454 7
@


1.92
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d3 2
a4 2
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
   Hat, Inc.
a29 3
static unsigned pipecount;
static const NO_COPY char pipeid_fmt[] = "stupid_pipe.%u.%u";

d31 1
a31 2
  : fhandler_base (), guard (NULL), broken_pipe (false), writepipe_exists (NULL),
    orig_pid (0), id (0), popen_pid (0)
a109 9
  if (!fh->writepipe_exists)
    /* nothing to do */;
  else if (!DuplicateHandle (proc, fh->writepipe_exists,
			     hMainProc, &writepipe_exists,
			     0, inh, DUPLICATE_SAME_ACCESS))
    {
      __seterrno ();
      goto out;
    }
a119 2
  if (writepipe_exists)
    CloseHandle (writepipe_exists);
a161 2
  if (writepipe_exists)
    set_no_inheritance (writepipe_exists, val);
a205 2
  if (writepipe_exists)
    CloseHandle (writepipe_exists);
a217 16
bool
fhandler_pipe::hit_eof ()
{
  char buf[80];
  HANDLE ev;
  if (broken_pipe)
    return 1;
  if (!orig_pid)
    return false;
  __small_sprintf (buf, pipeid_fmt, orig_pid, id);
  if ((ev = OpenEvent (EVENT_ALL_ACCESS, FALSE, buf)))
    CloseHandle (ev);
  debug_printf ("%s %p", buf, ev);
  return ev == NULL;
}

a237 2
  if (writepipe_exists)
    fork_fixup (parent, writepipe_exists, "writepipe_exists");
d247 1
a247 1
  ftp->guard = ftp->writepipe_exists = ftp->read_state = NULL;
a262 10
  if (!writepipe_exists)
    /* nothing to do */;
  else if (!DuplicateHandle (hMainProc, writepipe_exists, hMainProc,
			     &ftp->writepipe_exists, 0, true,
			     DUPLICATE_SAME_ACCESS))
    {
      debug_printf ("couldn't duplicate writepipe_exists %p, %E", writepipe_exists);
      goto err;
    }

a280 2
  if (ftp->writepipe_exists)
    CloseHandle (ftp->writepipe_exists);
a282 1
  goto leave;
a284 5
  ftp->id = id;
  ftp->orig_pid = orig_pid;
  VerifyHandle (ftp->writepipe_exists);

leave:
a420 9
      if (wincap.has_unreliable_pipes ())
	{
	  char buf[80];
	  int count = pipecount++;	/* FIXME: Should this be InterlockedIncrement? */
	  __small_sprintf (buf, pipeid_fmt, myself->pid, count);
	  fhs[1]->writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
	  fhs[0]->orig_pid = myself->pid;
	  fhs[0]->id = count;
	}
@


1.91
log
@	* autoload.cc (NtSetInformationFile): Define.
	* cygwin.din: Export posix_fadvise and posix_fallocate.
	* fhandler.cc (fhandler_base::fadvise): New method.
	(fhandler_base::ftruncate): Add allow_truncate parameter.
	* fhandler.h (class fhandler_base): Add fadvise method.  Accomodate
	new parameter to ftruncate.
	(class fhandler_pipe): Add fadvise and ftruncate methods.
	(class fhandler_disk_file): Add fadvise method.  Accomodate new
	parameter to ftruncate.
	* fhandler_disk_file.cc (fhandler_disk_file::fadvise): New method.
	(fhandler_disk_file::ftruncate): Accomodate new allow_truncate
	parameter.  Set EOF using NtSetInformationFile on NT.
	* ntdll.h (struct _FILE_END_OF_FILE_INFORMATION): Define.
	(NtSetInformationFile): Declare.
	* pipe.cc (fhandler_pipe::fadvise): New method.
	(fhandler_pipe::ftruncate): Ditto.
	* syscalls.cc (posix_fadvise): New function.
	(posix_fallocate): Ditto.
	(ftruncate64): Accomodate second parameter to fhandler's ftruncate
	method.
	* include/fcntl.h: Add POSIX_FADV_* flags.  Add declarations of
	posix_fadvise and posix_fallocate.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d35 1
a35 1
    orig_pid (0), id (0)
d283 1
@


1.90
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d154 14
@


1.90.2.1
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d35 1
a35 1
    orig_pid (0), id (0), popen_pid (0)
a268 1
  ftp->set_popen_pid (0);
@


1.90.2.2
log
@* dtable.cc (dtable::init_std_file_from_handle): Try harder to make a pipe into
a full-cygwin device.
(handle_to_fn): Change \ to / when necessary.
* fhandler.cc (fhandler_base::init): Change bin to mode.
* fhandler.h (fhandler_pipe::init): Declare.
* pipe.cc (fhandler_pipe::init): Define.
(handler_pipe::open): Move initialization code into init.
@
text
@d3 2
a4 2
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2008
   Red Hat, Inc.
a41 33
void
fhandler_pipe::init (HANDLE f, DWORD a, mode_t mode)
{
  bool isread = !!(a & GENERIC_READ);
  SECURITY_ATTRIBUTES *sa = (mode & O_NOINHERIT) ?  &sec_none_nih : &sec_none;
  if (mode & O_NOINHERIT)
     close_on_exec (true);

  if (isread)
    {
      create_read_state (2);
      create_guard (sa);
    }

  if (!wincap.has_unreliable_pipes ())
    /* nothing to do */;
  else if (isread)
    {
      orig_pid = myself->pid;
      id = ++pipecount;
    }
  else /* NOTE: This assumes that pipecount has been incremented by a previous
	  init of the read end of the pipe.  That isn't really true of native
	  pipes but, ask me if I care.  */
    {
      char buf[80];
      __small_sprintf (buf, pipeid_fmt, myself->pid, pipecount);
     writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
    }

  fhandler_base::init (f, a, mode);
}

d449 1
a449 1
      mode |= mode & O_TEXT ?: O_BINARY;
d452 8
d461 10
@


1.89
log
@* debug.h (ModifyHandle): Define new macro.
(modify_handle): Declare new function.
* debug.cc (modify_handle): Define new function.
* fhandler.h (fhandler_base::fork_fixup): Change return value from void to
bool.
* fhandler.cc (fhandler_base::fork_fixup): Return true if fork fixup has been
done.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance of protected
handle via ModifyHandle if DEBUGGING.
(fhandler_pipe::fixup_after_fork): Protect guard handle if fork fixup has been
done.
@
text
@d49 1
d97 1
a97 1
  bool inh = !(flags & O_NOINHERIT);
@


1.89.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@a48 1
  bool inh;
d96 1
a96 1
  inh = !(flags & O_NOINHERIT);
@


1.88
log
@* fhandle.h (fhandler_pipe::create_guard): Revert change which eliminated
SECURITY_ATTRIBUTES argument.
* pipe.cc (fhandler_pipe::open): Duplicate guard from other process and protect
it appropriately.  Eliminate unneeded writepipe_exists temporary variable.  Set
inheritance appropriately.
(fhandler_pipe::set_close_on_exec): Revert change which eliminated handling
guard inheritance.
(fhandler_pipe::fixup_after_fork): Ditto.  Use correct name of entity being
checked by fork_fixup.
(fhandler_pipe::fixup_after_exec): Don't bother with guard here.
(fhandler_pipe::dup): Cosmetic changes and revert creation of writepipe_exists
as noninheritable.
(fhandler_pipe::create): Revert change which eliminated SECURITY_ATTRIBUTES
argument.  Revert change which always made writepipe_exists noninheritable.
@
text
@d158 4
a161 1
    set_no_inheritance (guard, val);
d256 2
a257 2
  if (guard)
    fork_fixup (parent, guard, "guard");
@


1.87
log
@* debug.cc (add_handle): Print handle value when collision detected.
* dtable.cc (dtable::stdio_init): Cosmetic change.
* fhandler.h (fhandler_base::create_read_state): Protect handle.
(fhandler_pipe::create_guard): Ditto.  Always mark the handle as inheritable.
(fhandler_pipe::is_slow): Return boolean value rather than numeric 1.
* pipe.cc (fhandler_pipe::fhandler_pipe): Always flag that we need fork fixup.
(fhandler_pipe::open): Don't pass security attributes to create_guard.
(fhandler_pipe::set_close_on_exec): Don't handle guard here.
(fhandler_pipe::close): Accommodate now-protected guard handle.
(fhandler_pipe::fixup_in_child): Don't proected read_state here.
(fhandler_pipe::fixup_after_exec): Close guard handle if close_on_exec.
(fhandler_pipe::fixup_after_fork): Don't bother with guard here.
(fhandler_pipe::dup): Don't set res to non-error prematurely.  Use boolean
values where appropriate.  Protect guard and read_state.
(fhandler_pipe::create): Don't call need_fork_fixup since it is now the
default.  Don't protect read_state or guard.
* pipe.cc (fhandler_base::ready_for_read): Use bool values for "avail".
* spawn.cc (spawn_guts): Set cygheap->pid_handle as inheritable when
protecting.
* select.cc (fhandler_pipe::ready_for_read): Actually get the guard mutex for
blocking reads.
@
text
@d3 2
a4 2
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006 Red Hat, Inc.
d45 1
a45 1
  HANDLE proc, pipe_hdl, nio_hdl = NULL, nwrp_hdl = NULL;
d96 1
d98 1
a98 1
			0, false, DUPLICATE_SAME_ACCESS))
d103 15
a117 3
  if (fh->writepipe_exists
      && !DuplicateHandle (proc, fh->writepipe_exists, hMainProc, &nwrp_hdl,
			   0, false, DUPLICATE_SAME_ACCESS))
a123 2
  if (fh->guard)
    create_guard ();
a124 1
  writepipe_exists = nwrp_hdl;
d132 4
a135 2
  if (nwrp_hdl)
    CloseHandle (nwrp_hdl);
d157 2
a246 2
  else if (guard)
    ForceCloseHandle (guard);
d253 2
d256 1
a256 1
    fork_fixup (parent, writepipe_exists, "guard");
d270 2
a271 2
  if (guard == NULL)
    ftp->guard = NULL;
d273 1
a273 1
			     DUPLICATE_SAME_ACCESS))
d281 2
a282 2
  if (writepipe_exists == NULL)
    ftp->writepipe_exists = NULL;
d284 1
a284 1
			     &ftp->writepipe_exists, 0, false,
d291 2
a292 2
  if (read_state == NULL)
    ftp->read_state = NULL;
d294 2
a295 2
			     &ftp->read_state, 0, 0,
			     DUPLICATE_SAME_ACCESS))
d456 1
a456 1
      fhs[0]->create_guard ();
d462 1
a462 1
	  fhs[1]->writepipe_exists = CreateEvent (&sec_none_nih, TRUE, FALSE, buf);
@


1.86
log
@	* pipe.cc (DEFAULT_PIPEBUFSIZE): Raise to 64K.
@
text
@d3 2
a4 2
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005 Red Hat, Inc.
d34 1
a34 1
  : fhandler_base (), guard (NULL), broken_pipe (false), writepipe_exists(0),
d37 1
d103 1
a103 2
      && !DuplicateHandle (proc, fh->writepipe_exists,
			   hMainProc, &nwrp_hdl,
d110 3
a112 7
    {
      create_read_state (2);
      need_fork_fixup (true);
      ProtectHandle1 (read_state, read_state);
    }
  if (fh->get_guard ())
    create_guard ((flags & O_NOINHERIT) ?  &sec_none_nih : &sec_none);
a144 2
  if (guard)
    set_no_inheritance (guard, val);
d149 2
a150 1
char *fhandler_pipe::get_proc_fd_name (char *buf)
d190 1
a190 1
    CloseHandle (guard);
d225 1
a225 4
    {
      create_read_state (2);
      ProtectHandle (read_state);
    }
d232 3
a234 1
      fixup_in_child ();
a240 2
  if (guard)
    fork_fixup (parent, guard, "guard");
d253 2
a254 6
  if (get_handle ())
    {
      res = fhandler_base::dup (child);
      if (res)
	goto err;
    }
d258 1
a258 1
  else if (!DuplicateHandle (hMainProc, guard, hMainProc, &ftp->guard, 0, 1,
d260 2
d270 1
a270 1
			     &ftp->writepipe_exists, 0, 1,
d279 1
a279 1
  else if (!DuplicateHandle (hMainProc, read_state, hMainProc,
d282 2
d294 1
a294 1
    CloseHandle (ftp->guard);
d298 1
a298 1
    CloseHandle (ftp->read_state);
a303 1
  VerifyHandle (ftp->guard);
a304 1
  VerifyHandle (ftp->read_state);
a439 2
      fhs[0]->need_fork_fixup (true);
      ProtectHandle1 (fhs[0]->read_state, read_state);
d442 1
a442 1
      fhs[0]->create_guard (sa);
d448 1
a448 1
	  fhs[1]->writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
@


1.85
log
@* fhandler.h (fhandler_pipe::fixup_in_child): Declare new function.
(fhandler_console::invisible_console): Declare new variable.
(fhandler_console::need_invisible): Ditto.
(fhandler_console::has_a): Ditto.
* fhandler_console.cc (set_console_state_for_spawn): Eliminate return value.
Set up an invisible console if necessary prior to spawning.
(fhandler_console::invisible_console): Define.
* fhandler_tty.cc (fhandler_tty_slave::open): Use
fhandler_console::invisible_console to setup an invisible console.
* pipe.cc (fhandler_pipe::fixup_in_child): Define new function from
fixup_after_exec.
(fhandler_pipe::fixup_after_exec): Use fixup_in_child when appropriate.
(fhandler_pipe::fixup_after_fork): Ditto.
* spawn.cc (handle): Reorganize and modernize a little.
(spawn_guts): Rely on set_console_state_for_spawn to set the console into the
right state but don't create the process with "detached" flag if we have no
controlling tty since that confuses 'cmd'.
* dtable.cc (dtable::stdio_init): Don't set console as controlling terminal if
we have an invisible console.
* sigproc.cc (child_info::sync): Use correct name in ForceCloseHandle1.
@
text
@d497 1
a497 1
#define DEFAULT_PIPEBUFSIZE (4 * PIPE_BUF)
@


1.84
log
@* cygheap.h (cygheap_fdenum): Remove start_fd stuff.
(cygheap_fdenum::rewind): Ditto.
* pipe.cc (fhandler_pipe::open): Lock fdtab while enumerating.
* times.cc (utimes_worker): Ditto.
@
text
@d227 1
a227 1
fhandler_pipe::fixup_after_exec ()
d237 7
d251 1
a251 1
  fixup_after_exec ();
@


1.83
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d52 1
a52 1
      cygheap_fdenum cfd;
@


1.82
log
@	Revert erroneous checkin.
@
text
@d184 1
a184 1
      cygthread *th = new cygthread (read_pipe, &pi, "read_pipe");
a238 1
debug_printf ("here");
@


1.81
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d63 1
a63 1
	  if (!cfd->dup (this, hMainProc))
d249 1
a249 1
fhandler_pipe::dup (fhandler_base *child, HANDLE from_proc)
d257 1
a257 1
      res = fhandler_base::dup (child, from_proc);
d264 1
a264 1
  else if (!DuplicateHandle (from_proc, guard, hMainProc, &ftp->guard, 0, 1,
d273 1
a273 1
  else if (!DuplicateHandle (from_proc, writepipe_exists, hMainProc,
d283 1
a283 1
  else if (!DuplicateHandle (from_proc, read_state, hMainProc,
@


1.80
log
@* pipe.cc (fhandler_pipe::open): Use 'cfree' to free buffer since it is now
allocated by cmalloc.
@
text
@d63 1
a63 1
	  if (!cfd->dup (this))
d249 1
a249 1
fhandler_pipe::dup (fhandler_base *child)
d257 1
a257 1
      res = fhandler_base::dup (child);
d264 1
a264 1
  else if (!DuplicateHandle (hMainProc, guard, hMainProc, &ftp->guard, 0, 1,
d273 1
a273 1
  else if (!DuplicateHandle (hMainProc, writepipe_exists, hMainProc,
d283 1
a283 1
  else if (!DuplicateHandle (hMainProc, read_state, hMainProc,
@


1.79
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d122 1
a122 1
  free (fh);
@


1.78
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@a188 1
  return;
@


1.77
log
@* fhandler.cc (fhandler_base::read): Remove unused signal state tweaks.
* fhandler.h (fhandler_pipe::create_selectable): Declare.
(fhandler_fifo::close_one_end): Declare.
* fhandler_fifo.cc (fhandler_fifo::close_one_end): Define.
(fhandler_fifo::open_not_mine): Use close_one_end to close appropriate end of
pipe.
* pinfo.cc (_pinfo::commune_recv): Ditto.
* pipe.cc (fhandler_pipe::create_selectable): Rename from
create_selectable_pipe.  Reorganize.
(fhandler_pipe::create): Use create_selectable.
@
text
@d188 1
a188 1
  (void) ReleaseMutex (guard);
@


1.76
log
@* fhandler.cc (fhandler::dup): Duplicate flags, too.
* fhandler.h (fhandler_fifo::owner): Eliminate.
* fhandler_disk_file.cc (fhandler_base::fstat_fs): Handle on-disk devices
better.
(fhandler_base::fstat_helper): Ditto.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Don't initialize obsolete
"owner".
(fhandler_fifo::open_not_mine): Add some debugging.  Duplicate correct handle
when we own it.
(fhandler_fifo::open): Set flags from input, not from first pipe.  Flag that
fork fixup is needed.
(fhandler_fifo::dup): Set errno correctly when DuplicateHandle fails.
* pinfo.cc (commune_send): Add debugging for fifo.
* cygwin/version.h: Bump API minor version to 127 to reflect exporting of
sigrelese.
@
text
@d321 1
a321 1
   Note that the return value is either NO_ERROR or GetLastError,
d323 3
a325 5
static int
create_selectable_pipe (PHANDLE read_pipe_ptr,
			PHANDLE write_pipe_ptr,
			LPSECURITY_ATTRIBUTES sa_ptr,
			DWORD psize)
d328 1
a328 3
  *read_pipe_ptr = *write_pipe_ptr = INVALID_HANDLE_VALUE;

  HANDLE read_pipe = INVALID_HANDLE_VALUE, write_pipe = INVALID_HANDLE_VALUE;
d331 1
a331 1
  if (psize < PIPE_BUF)
d341 1
a341 1
      static volatile LONG pipe_unique_id;
d343 1
a343 1
      __small_sprintf (pipename, "\\\\.\\pipe\\cygwin-%d-%ld", myself->pid,
d357 3
a359 9
      SetLastError (0);
      read_pipe = CreateNamedPipe (pipename,
				   PIPE_ACCESS_INBOUND,
				   PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
				   1,       /* max instances */
				   psize,   /* output buffer size */
				   psize,   /* input buffer size */
				   NMPWAIT_USE_DEFAULT_WAIT,
				   sa_ptr);
a360 1
      DWORD err = GetLastError ();
d362 1
a362 1
      if ((read_pipe || !err) && read_pipe != INVALID_HANDLE_VALUE)
d364 1
a364 1
	  debug_printf ("pipe read handle %p", read_pipe);
d368 1
d375 1
a375 1
	  continue;
d380 7
a386 7
	  continue;
	case ERROR_CALL_NOT_IMPLEMENTED:
	  /* We are on an older Win9x platform without named pipes.
	     Return an anonymous pipe as the best approximation.  */
	  debug_printf ("CreateNamedPipe not implemented, resorting to "
			"CreatePipe size %lu", psize);
	  if (CreatePipe (read_pipe_ptr, write_pipe_ptr, sa_ptr, psize))
d388 3
a390 3
	      debug_printf ("pipe read handle %p", *read_pipe_ptr);
	      debug_printf ("pipe write handle %p", *write_pipe_ptr);
	      return NO_ERROR;
a394 3
	default:
	  debug_printf ("CreateNamedPipe failed, %E");
	  return err;
a395 1
      /* NOTREACHED */
d402 2
a403 7
  write_pipe = CreateFile (pipename,
			   GENERIC_WRITE | FILE_READ_ATTRIBUTES,
			   0,       /* share mode */
			   sa_ptr,
			   OPEN_EXISTING,
			   0,       /* flags and attributes */
			   0);      /* handle to template file */
d405 1
a405 1
  if (write_pipe == INVALID_HANDLE_VALUE)
d410 1
a410 1
      CloseHandle (read_pipe);
d414 1
a414 1
  debug_printf ("pipe write handle %p", write_pipe);
d417 1
a417 3
  *read_pipe_ptr = read_pipe;
  *write_pipe_ptr = write_pipe;
  return NO_ERROR;
a425 1
  int ret;
d427 2
a428 1
  if ((ret = create_selectable_pipe (&r, &w, sa, psize)) != NO_ERROR)
@


1.75
log
@* pipe.cc (fhandler_pipe::open): Remove O_CREAT limitation.
@
text
@d240 1
a262 1
  /* FIXME: This leaks handles in the failing condition */
@


1.74
log
@* cygthread.cc (cygthread::release): Reset ev here if it exists.
(cygthread::terminate_thread): Eliminat racy code which reset ev and
thread_sync.  Remove a few nonsensical inuse checks.  Exit at the bottom.
(cygthread::detach): Rewrite to again try to ensure that we don't say we're
signalled when we are not signalled.
* fhandler.cc (fhandler_base::raw_read): Revert to signalling read success
quickly.
* pipe.cc (fhandler_pipe::close): Use base method to close handle.
* sigproc.h (WAIT_SIG_PRIORITY): Just trundle along at normal priority to allow
the pipe thread to do its thing if possible.
* pinfo.h (pinfo::zap_cwd): Declare new function.
(pinfo::zap_cwd): Move 'cd out of the way code' here.
(pinfo::exit): Use it here.
* spawn.cc (spawn_guts): And here.
@
text
@a48 5
  if (flags & O_CREAT)
    {
      set_errno (EACCES);
      return 0;
    }
@


1.73
log
@* pipe.cc (fhandler_pipe::read): Remove hold over from old read_state
implementation.
@
text
@d213 1
a213 6
  if (get_handle ())
    {
      CloseHandle (get_handle ());
      set_io_handle (NULL);
    }
  return 0;
@


1.72
log
@	* path.cc (path_conv::check): Leave symlink expansion loop in case
	a not-ENOENT error happens.

	* cygheap.h (cygheap_fdmanip::fhandler_pipe *): New cast operator.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_PIPE_FHANDLER handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::pipe_fhandler): New method.
	* pinfo.h (enum picom): Add PICOM_PIPE_FHANDLER.
	(_pinfo::pipe_fhandler): Declare.
	* pipe.cc (fhandler_pipe::open): Rewrite.  Allow to open foreign
	pipe handles.
@
text
@a188 1
      ResetEvent (read_state);
@


1.71
log
@* cygthread.h (cygthread::terminate_thread): Reflect return value.
* cygthread.cc (cygthread::detach): Be more careful about ensuring that sigwait
is properly waited for to avoid later missynchronization.
(cygthread::terminate_thread): Return true if thread was actually terminated
and all handles were closed.
* fhandler_base.cc (fhandler_base::raw_read): Use signal_read_state rather than
raw calls to win32 api.
(fhandler_base::read): Ditto.
* fhandler.h (fhandler_pipe::fixup_after_exec): Use method to create read_state
signalling.
(fhandler_pipe::create): Ditto.
* Makefile.in: Make some more files -fomit-frame-pointer.
@
text
@d39 2
d44 20
a63 18
  const char *path = get_name ();
  debug_printf ("path: %s", path);
  if (!strncmp (get_name (), "/proc/", 6))
    {
      char *c;
      HANDLE hdl;
      int pid = strtol (path += 6, &c, 10);
      if (!pid || !c || *c != '/')
        goto out;
      path = c;
      if (strncmp (path, "/fd/pipe:[", 10))
        goto out;
      path += 10;
      hdl = (HANDLE) atoi (path);
      if (pid == myself->pid)
        {
	  cygheap_fdenum cfd;
	  while (cfd.next () >= 0)
d65 2
a66 6
	      if (cfd->get_handle () == hdl)
	        {
		  if (!cfd->dup (this))
		    return 1;
		  return 0;
		}
d68 3
d72 47
a118 4
      else
        {
	  /* TODO: Open pipes of different process.  Is that possible? */
	}
d120 10
d131 8
a138 1
  set_errno (ENXIO);
@


1.70
log
@	* pipe.cc (fhandler_pipe::dup): Fix conditionals in case of error.
@
text
@d180 1
a180 1
      read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d413 1
a413 1
      fhs[0]->read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
@


1.69
log
@* cygthread.cc (cygthread::terminate_thread): Wait briefly for notification
event in the event that the thread was actually in the process of exiting.
* pipe.cc (fhandler_pipe::dup): read_state is not supposed to be inheritable.
Fix that.
* path.cc (path_conv::check): Set symlen = 0 to avoid a compiler warning.
* devices.h (devices::parsedisk): Declare new function.
* devices.in (devices::parsedisk): Define new function.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
name.
* fhandler_proc.cc (format_proc_partitions): Use parsedisk to generate disk
names from numeric codes.  (This was broken on two of my systems previously and
is still broken now)
@
text
@d3 2
a4 1
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d244 1
a244 1
  if (!ftp->guard)
d246 1
a246 1
  if (!ftp->writepipe_exists)
d248 1
a248 1
  if (!ftp->read_state)
@


1.68
log
@	* pipe.cc (fhandler_pipe::open):  Allow re-opening of /proc/<pid>/fd
	pipes of the current process.
@
text
@d232 1
a232 1
			     &ftp->read_state, 0, 1,
@


1.67
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d41 33
@


1.66
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d38 7
@


1.65
log
@2004-11-20  Pierre Humblet <pierre.humblet@@ieee.org>

	* fhandler.cc (fhandler::write): Remove debug_printf.
	* pipe.cc (fhandler_pipe::create): Edit syscall_printf format.
@
text
@d56 6
@


1.64
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d383 1
a383 1
  syscall_printf ("%d = ([%p, %p], %d, %p)", res, fhs[0], fhs[1], psize, mode);
@


1.63
log
@	* pipe.cc (create_selectable_pipe): Work around bug in Windows 95
	where CreateNamedPipe returns NULL.
@
text
@d226 3
a228 3
                        PHANDLE write_pipe_ptr,
                        LPSECURITY_ATTRIBUTES sa_ptr,
                        DWORD psize)
d254 8
a261 8
         returns a write handle that does not permit FILE_READ_ATTRIBUTES
         access, on versions of win32 earlier than WinXP SP2.
         CreatePipe also stupidly creates a full duplex pipe, which is
         a waste, since only a single direction is actually used.
         It's important to only allow a single instance, to ensure that
         the pipe was not created earlier by some other process, even if
         the pid has been reused.  We avoid FILE_FLAG_FIRST_PIPE_INSTANCE
         because that is only available for Win2k SP2 and WinXP.  */
d264 7
a270 7
                                   PIPE_ACCESS_INBOUND,
                                   PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                                   1,       /* max instances */
                                   psize,   /* output buffer size */
                                   psize,   /* input buffer size */
                                   NMPWAIT_USE_DEFAULT_WAIT,
                                   sa_ptr);
d275 4
a278 4
        {
          debug_printf ("pipe read handle %p", read_pipe);
          break;
        }
d281 29
a309 29
        {
        case ERROR_PIPE_BUSY:
          /* The pipe is already open with compatible parameters.
             Pick a new name and retry.  */
          debug_printf ("pipe busy, retrying");
          continue;
        case ERROR_ACCESS_DENIED:
          /* The pipe is already open with incompatible parameters.
             Pick a new name and retry.  */
          debug_printf ("pipe access denied, retrying");
          continue;
        case ERROR_CALL_NOT_IMPLEMENTED:
          /* We are on an older Win9x platform without named pipes.
             Return an anonymous pipe as the best approximation.  */
          debug_printf ("CreateNamedPipe not implemented, resorting to "
                        "CreatePipe size %lu", psize);
          if (CreatePipe (read_pipe_ptr, write_pipe_ptr, sa_ptr, psize))
            {
              debug_printf ("pipe read handle %p", *read_pipe_ptr);
              debug_printf ("pipe write handle %p", *write_pipe_ptr);
              return NO_ERROR;
            }
          err = GetLastError ();
          debug_printf ("CreatePipe failed, %E");
          return err;
        default:
          debug_printf ("CreateNamedPipe failed, %E");
          return err;
        }
d318 6
a323 6
                           GENERIC_WRITE | FILE_READ_ATTRIBUTES,
                           0,       /* share mode */
                           sa_ptr,
                           OPEN_EXISTING,
                           0,       /* flags and attributes */
                           0);      /* handle to template file */
@


1.62
log
@Christopher Faylor <cgf@@timesys.com>
* autoload.cc (NtQueryInformationFile): Return nonzero on error.
* ntdll.h (FILE_PIPE_LOCAL_INFORMATION): Add.
(NtQueryInformationFile): Fix types for last two arguments.
* pipe.cc: Include stdlib.h, limits.h, and ntdll.h.
(create_selectable_pipe): New function to create a pipe that can be used with
NtQueryInformationFile for select.
(fhandler_pipe::create): Call create_selectable_pipe instead of CreatePipe.
(pipe): Use DEFAULT_PIPEBUFSIZE as argument to create_pipe.
* select.cc: Include limits.h and ntdll.h.
(peek_pipe): Add select_printf output.  Call NtQueryInformationFile to
implement select for write on pipes.
(fhandler_pipe::select_read): Reorder field assignments to be consistent with
fhandler_pipe::select_write.
(fhandler_pipe::select_write): Initialize startup, verify, cleanup, and
write_ready fields for select_record.
(fhandler_pipe::select_except): Tweak indentation to be consistent with
fhandler_pipe::select_write.
@
text
@d262 1
d272 3
a274 1
      if (read_pipe != INVALID_HANDLE_VALUE)
a279 1
      DWORD err = GetLastError ();
@


1.61
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d15 1
d17 1
d27 1
d217 123
d346 1
d348 2
a349 2
  if (!CreatePipe (&r, &w, sa, psize))
    __seterrno ();
d412 2
d419 3
a421 2
  int res = fhandler_pipe::create (fhs, 16384, (!binmode || binmode == O_BINARY)
					       ? O_BINARY : O_TEXT);
@


1.60
log
@* include/cygwin/version.h: Bump DLL minor number to 9.
@
text
@d44 1
a44 1
fhandler_pipe::set_close_on_exec (int val)
d233 2
a234 2
	 fhs[0]->set_close_on_exec_flag (1);
	 fhs[1]->set_close_on_exec_flag (1);
d238 1
a238 1
      fhs[0]->set_need_fork_fixup ();
d315 1
a315 1
      fhs[0]->set_r_no_interrupt (1);
@


1.59
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d186 1
a186 1
      debug_printf ("couldn't duplicate read_state %p, %E", writepipe_exists);
@


1.58
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.57
log
@Throughout, change name from set_inheritance to set_no_inheritance to better
reflect input arguments of this function.
* cygheap.h (CYGHEAPSIZE): Increase size of cygheap to something closer to the
21st century.
@
text
@d126 1
a126 1
fhandler_pipe::fixup_after_exec (HANDLE parent)
d143 1
a143 1
  fixup_after_exec (parent);
@


1.56
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d48 1
a48 1
    set_inheritance (guard, val);
d50 1
a50 1
    set_inheritance (writepipe_exists, val);
@


1.55
log
@* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
@
text
@d92 3
d99 2
a100 1
    CloseHandle (read_state);
d129 4
a132 1
    read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d149 4
d155 1
a155 1
      int res = fhandler_base::dup (child);
d157 1
a157 1
	return res;
a159 2
  fhandler_pipe *ftp = (fhandler_pipe *) child;

d167 1
a167 1
      return -1;
d177 1
a177 1
      return -1;
d187 1
a187 1
      return -1;
d190 13
d205 7
a211 1
  return 0;
d239 1
@


1.55.4.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a91 3
#ifndef NEWVFORK
  if (read_state)
#else
d96 1
a96 2
#endif
    ForceCloseHandle (read_state);
d125 1
a125 4
    {
      read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
      ProtectHandle (read_state);
    }
a141 4
  int res = -1;
  fhandler_pipe *ftp = (fhandler_pipe *) child;
  ftp->guard = ftp->writepipe_exists = ftp->read_state = NULL;

d144 1
a144 1
      res = fhandler_base::dup (child);
d146 1
a146 1
	goto err;
d149 2
d158 1
a158 1
      goto err;
d168 1
a168 1
      goto err;
d178 1
a178 1
      goto err;
a180 13
  res = 0;
  goto out;

err:
  if (!ftp->guard)
    CloseHandle (ftp->guard);
  if (!ftp->writepipe_exists)
    CloseHandle (ftp->writepipe_exists);
  if (!ftp->read_state)
    CloseHandle (ftp->read_state);
  goto leave;

out:
d183 1
a183 7
  VerifyHandle (ftp->guard);
  VerifyHandle (ftp->writepipe_exists);
  VerifyHandle (ftp->read_state);

leave:
  debug_printf ("res %d", res);
  return res;
a210 1
      ProtectHandle1 (fhs[0]->read_state, read_state);
@


1.54
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d92 3
@


1.54.2.1
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@a91 3
  // FIXME is this vfork_cleanup test right?  Is it responsible for some of
  // the strange pipe behavior that has been reported in the cygwin mailing
  // list?
@


1.53
log
@Remove left coercion throughout.
@
text
@d18 1
a19 1
#include "path.h"
d29 2
a30 2
fhandler_pipe::fhandler_pipe (DWORD devtype)
  : fhandler_base (devtype), guard (NULL), broken_pipe (false), writepipe_exists(0),
d75 1
a75 1
      pipeargs pi = {this, in_ptr, &in_len};
d85 2
a86 1
int fhandler_pipe::close ()
a87 2
  int res = fhandler_base::close ();
#undef guard
d94 6
a99 1
  return res;
d184 1
a184 1
make_pipe (int fildes[2], unsigned int psize, int mode)
d190 3
a192 2
  cygheap_fdnew fdr;
  if (fdr >= 0)
d194 18
a211 6
      cygheap_fdnew fdw (fdr, false);
      if (fdw < 0)
	/* out of fds? */;
      else if (!CreatePipe (&r, &w, sa, psize))
	__seterrno ();
      else
d213 6
a218 28
	  fhandler_pipe *fhr = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdr, FH_PIPER, "/dev/piper");
	  fhandler_pipe *fhw = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdw, FH_PIPEW, "/dev/pipew");

	  int binmode = mode & O_TEXT ?: O_BINARY;
	  fhr->init (r, GENERIC_READ, binmode);
	  fhw->init (w, GENERIC_WRITE, binmode);
	  if (mode & O_NOINHERIT)
	   {
	     fhr->set_close_on_exec_flag (1);
	     fhw->set_close_on_exec_flag (1);
	   }

	  fildes[0] = fdr;
	  fildes[1] = fdw;
	  fhr->read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
	  fhr->set_need_fork_fixup ();

	  res = 0;
	  fhr->create_guard (sa);
	  if (wincap.has_unreliable_pipes ())
	    {
	      char buf[80];
	      int count = pipecount++;	/* FIXME: Should this be InterlockedIncrement? */
	      __small_sprintf (buf, pipeid_fmt, myself->pid, count);
	      fhw->writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
	      fhr->orig_pid = myself->pid;
	      fhr->id = count;
	    }
d222 1
a222 2
  syscall_printf ("%d = make_pipe ([%d, %d], %d, %p)", res, fildes[0],
		  fildes[1], psize, mode);
d257 14
a270 1
  return make_pipe (filedes, 16384, (!binmode || binmode == O_BINARY) ? O_BINARY : O_TEXT);
d276 2
a277 1
  int res = make_pipe (filedes, psize, mode);
d280 10
a289 1
    cygheap->fdtab[filedes[0]]->set_r_no_interrupt (1);
@


1.52
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d79 1
a79 1
	(ssize_t) in_len = -1;	/* received a signal */
@


1.51
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@a14 1
#include <errno.h>
@


1.50
log
@* pipe.cc (fhandler_pipe::dup): Don't dup input_handle if it doesn't exist.
@
text
@d36 2
a37 2
__off64_t
fhandler_pipe::lseek (__off64_t offset, int whence)
@


1.49
log
@* malloc.cc (DEFAULT_MMAP_THRESHOLD): Set high to avoid mmaps.
* pipe.cc (fhandler_pipe::close): Avoid extraneous this->.
@
text
@d136 6
a141 3
  int res = fhandler_base::dup (child);
  if (res)
    return res;
@


1.48
log
@* pipe.cc (fhandler_pipe::close): Avoid extraneous this->.
@
text
@d89 1
@


1.47
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d88 1
a88 1
  int res = this->fhandler_base::close ();
@


1.46
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d47 1
a47 1
  this->fhandler_base::set_close_on_exec (val);
d124 1
a124 1
  this->fhandler_base::fixup_after_fork (parent);
d135 1
a135 1
  int res = this->fhandler_base::dup (child);
@


1.46.2.1
log
@merge from trunk
@
text
@d30 2
a31 2
fhandler_pipe::fhandler_pipe ()
  : fhandler_base (), guard (NULL), broken_pipe (false), writepipe_exists(0),
d86 1
a86 2
int
fhandler_pipe::close ()
d88 1
d95 1
a95 6
  if (get_handle ())
    {
      CloseHandle (get_handle ());
      set_io_handle (NULL);
    }
  return 0;
d177 1
a177 1
fhandler_pipe::create (fhandler_pipe *fhs[2], unsigned psize, int mode, bool fifo)
d183 2
a184 3
  if (!CreatePipe (&r, &w, sa, psize))
    __seterrno ();
  else
d186 9
a194 2
      fhs[0] = (fhandler_pipe *) cygheap->fdtab.build_fhandler (-1, *piper_dev, "/dev/piper");
      fhs[1] = (fhandler_pipe *) cygheap->fdtab.build_fhandler (-1, *pipew_dev, "/dev/pipew");
d196 25
a220 22
      int binmode = mode & O_TEXT ?: O_BINARY;
      fhs[0]->init (r, GENERIC_READ, binmode);
      fhs[1]->init (w, GENERIC_WRITE, binmode);
      if (mode & O_NOINHERIT)
       {
	 fhs[0]->set_close_on_exec_flag (1);
	 fhs[1]->set_close_on_exec_flag (1);
       }

      fhs[0]->read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
      fhs[0]->set_need_fork_fixup ();

      res = 0;
      fhs[0]->create_guard (sa);
      if (wincap.has_unreliable_pipes ())
	{
	  char buf[80];
	  int count = pipecount++;	/* FIXME: Should this be InterlockedIncrement? */
	  __small_sprintf (buf, pipeid_fmt, myself->pid, count);
	  fhs[1]->writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
	  fhs[0]->orig_pid = myself->pid;
	  fhs[0]->id = count;
d224 2
a225 1
  syscall_printf ("%d = ([%p, %p], %d, %p)", res, fhs[0], fhs[1], psize, mode);
d260 1
a260 14
  fhandler_pipe *fhs[2];
  int res = fhandler_pipe::create (fhs, 16384, (!binmode || binmode == O_BINARY)
					       ? O_BINARY : O_TEXT);
  if (res == 0)
    {
      cygheap_fdnew fdin;
      cygheap_fdnew fdout (fdin, false);
      fdin = fhs[0];
      fdout = fhs[1];
      filedes[0] = fdin;
      filedes[1] = fdout;
    }

  return res;
d266 1
a266 2
  fhandler_pipe *fhs[2];
  int res = fhandler_pipe::create (fhs, psize, mode);
d269 1
a269 10
    {
      cygheap_fdnew fdin;
      cygheap_fdnew fdout (fdin, false);
      fhs[0]->set_r_no_interrupt (1);
      fdin = fhs[0];
      fdout = fhs[1];
      filedes[0] = fdin;
      filedes[1] = fdout;
    }

@


1.46.2.2
log
@merge from trunk
@
text
@d47 1
a47 1
  fhandler_base::set_close_on_exec (val);
d129 1
a129 1
  fhandler_base::fixup_after_fork (parent);
d140 1
a140 1
  int res = fhandler_base::dup (child);
@


1.46.2.3
log
@merge from trunk
@
text
@a88 1
  int res = fhandler_base::close ();
@


1.46.2.4
log
@merge from trunk
@
text
@d89 1
@


1.46.2.5
log
@merge from trunk
@
text
@d65 1
a65 2
  fhandler_base *fh = dynamic_cast<fhandler_base *> (pi->fh);
  fh->fhandler_base::read (pi->ptr, *pi->len);
@


1.46.2.6
log
@merge from trunk
@
text
@d65 2
a66 1
  pi->fh->fhandler_base::read (pi->ptr, *pi->len);
d77 1
a77 1
      pipeargs pi = {dynamic_cast<fhandler_base *>(this), in_ptr, &in_len};
@


1.46.2.7
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d19 1
a20 1
#include "fhandler.h"
d192 2
a193 2
      fhs[0] = (fhandler_pipe *) build_fh_dev (*piper_dev);
      fhs[1] = (fhandler_pipe *) build_fh_dev (*pipew_dev);
@


1.46.2.8
log
@merge from trunk
@
text
@d36 2
a37 2
_off64_t
fhandler_pipe::lseek (_off64_t offset, int whence)
d140 3
a142 6
  if (get_handle ())
    {
      int res = fhandler_base::dup (child);
      if (res)
	return res;
    }
@


1.46.2.9
log
@merge from trunk
@
text
@d15 1
@


1.46.2.10
log
@merge from trunk
@
text
@d79 1
a79 1
	in_len = (size_t) -1;	/* received a signal */
@


1.45
log
@* dtable.h (dtable::in_vfork_cleanup): New function.  True if vfork cleanup
needed.
* dtable.cc (dtable::vfork_parent_restore): Remove assertion.
* pipe.cc (fhandler_pipe::close): Don't close read_state during fork_fixup
since it wasn't inherited.
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.44
log
@* pipe.cc (make_pipe): Set fork fixup flag for read pipe.
@
text
@d93 1
a93 1
  if (read_state)
@


1.44.4.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d193 2
a194 2
	  fhandler_pipe *fhr = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdr, *piper_dev, "/dev/piper");
	  fhandler_pipe *fhw = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdw, *pipew_dev, "/dev/pipew");
@


1.44.4.2
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d30 2
a31 2
fhandler_pipe::fhandler_pipe ()
  : fhandler_base (0), guard (NULL), broken_pipe (false), writepipe_exists(0),
@


1.44.4.3
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d31 1
a31 1
  : fhandler_base (), guard (NULL), broken_pipe (false), writepipe_exists(0),
@


1.44.4.4
log
@* dtable.h (dtable::in_vfork_cleanup): New function.  True if vfork cleanup
needed.
* dtable.cc (dtable::vfork_parent_restore): Remove assertion.
* pipe.cc (fhandler_pipe::close): Don't close read_state during fork_fixup
since it wasn't inherited.
@
text
@d93 1
a93 1
  if (read_state && !cygheap->fdtab.in_vfork_cleanup ())
@


1.44.4.5
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@d86 1
a86 2
int
fhandler_pipe::close ()
d88 1
d95 1
a95 6
  if (get_handle ())
    {
      CloseHandle (get_handle ());
      set_io_handle (NULL);
    }
  return 0;
d177 1
a177 1
fhandler_pipe::create (fhandler_pipe *fhs[2], unsigned psize, int mode, bool fifo)
d183 2
a184 3
  if (!CreatePipe (&r, &w, sa, psize))
    __seterrno ();
  else
d186 9
a194 2
      fhs[0] = (fhandler_pipe *) cygheap->fdtab.build_fhandler (-1, *piper_dev, "/dev/piper");
      fhs[1] = (fhandler_pipe *) cygheap->fdtab.build_fhandler (-1, *pipew_dev, "/dev/pipew");
d196 25
a220 22
      int binmode = mode & O_TEXT ?: O_BINARY;
      fhs[0]->init (r, GENERIC_READ, binmode);
      fhs[1]->init (w, GENERIC_WRITE, binmode);
      if (mode & O_NOINHERIT)
       {
	 fhs[0]->set_close_on_exec_flag (1);
	 fhs[1]->set_close_on_exec_flag (1);
       }

      fhs[0]->read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
      fhs[0]->set_need_fork_fixup ();

      res = 0;
      fhs[0]->create_guard (sa);
      if (wincap.has_unreliable_pipes ())
	{
	  char buf[80];
	  int count = pipecount++;	/* FIXME: Should this be InterlockedIncrement? */
	  __small_sprintf (buf, pipeid_fmt, myself->pid, count);
	  fhs[1]->writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
	  fhs[0]->orig_pid = myself->pid;
	  fhs[0]->id = count;
d224 2
a225 1
  syscall_printf ("%d = ([%p, %p], %d, %p)", res, fhs[0], fhs[1], psize, mode);
d260 1
a260 14
  fhandler_pipe *fhs[2];
  int res = fhandler_pipe::create (fhs, 16384, (!binmode || binmode == O_BINARY)
					       ? O_BINARY : O_TEXT);
  if (res == 0)
    {
      cygheap_fdnew fdin;
      cygheap_fdnew fdout (fdin, false);
      fdin = fhs[0];
      fdout = fhs[1];
      filedes[0] = fdin;
      filedes[1] = fdout;
    }

  return res;
d266 1
a266 2
  fhandler_pipe *fhs[2];
  int res = fhandler_pipe::create (fhs, psize, mode);
d269 1
a269 10
    {
      cygheap_fdnew fdin;
      cygheap_fdnew fdout (fdin, false);
      fhs[0]->set_r_no_interrupt (1);
      fdin = fhs[0];
      fdout = fhs[1];
      filedes[0] = fdin;
      filedes[1] = fdout;
    }

@


1.43
log
@add FIXME
@
text
@d208 1
@


1.42
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d141 1
@


1.41
log
@* cygthread.h (cygthread::stack_ptr): New element.
(cygthread::detach): Accept a "wait_for_signal" argument.
(cygthread::terminate_thread): New function.
* cygthread.cc (cygthread::stub): Set stack pointer argument.
(cygthread::terminate_thread): New function.  Forcibly terminate thread.
(cygthread::detach): Optionally wait for signals and kill thread when signal
arrives.
* exceptions.cc (signal_exit): Set signal_arrived prior to exiting to wake up
anything blocking on signals.
* fhandler.h (fhandler_base::set_r_no_interrupt): Change to accept bool
argument.
(fhandler_pipe::ready_for_read): Declare.
* pipe.cc (pipeargs): New structure.
(read_pipe): New thread stub wrapper for normal pipe read.
(fhandler_pipe::read): Modify to call reader in a cygthread, terminating on
signal, as appropriate.
* select.cc (fhandler_pipe::ready_for_read): Define new function.
@
text
@d58 1
a58 2
  size_t len;
  int res;
d65 1
a65 1
  pi->res = pi->fh->fhandler_base::read (pi->ptr, pi->len);
d69 2
a70 2
int __stdcall
fhandler_pipe::read (void *in_ptr, size_t in_len)
d73 9
a81 8
    return 0;
  pipeargs pi;
  pi.fh = this;
  pi.ptr = in_ptr;
  pi.len = in_len;
  pi.res = -1;
  cygthread *th = new cygthread (read_pipe, &pi, "read_pipe");
  th->detach (1);
d83 1
a83 1
  return pi.res;
d93 2
d115 7
d129 1
d160 10
d206 1
@


1.40
log
@* fhandler.h (class fhandler_pipe): New ioctl() method.
* pipe.cc (fhandler_pipe::ioctl): New.
@
text
@d25 1
d54 16
d75 7
a81 1
  int res = this->fhandler_base::read (in_ptr, in_len);
d83 1
a83 1
  return res;
@


1.39
log
@* dcrt0.cc (dll_crt0_1): Move debug_fixup_after_fork_exec.
* cygheap.cc (cygheap_fixup_in_child): Call debug_fixup_after_fork_exec
immediately after cygheap has ben set up.
@
text
@d16 1
d181 27
@


1.38
log
@* cygheap.cc (init_cheap): Rearrange error message.
(cygheap_fixup_in_child): Ditto.
* dtable.cc: Remove if 0'ed code.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode.
* sec_helper.cc (cygsid::get_id): Use system_printf for error message.
* tty.cc (tty::common_init): Ditto.
@
text
@a130 1

@


1.37
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d11 2
@


1.36
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@a12 1
#include <sys/fcntl.h>
d150 1
a150 1
	  int binmode = mode & O_TEXT ? 0 : 1;
@


1.35
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@a21 1
#include "sigproc.h"
@


1.34
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d34 2
a35 2
__off32_t
fhandler_pipe::lseek (__off32_t offset, int whence)
@


1.33
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.32
log
@Eliminate excess whitespace.
@
text
@d34 2
a35 2
off_t
fhandler_pipe::lseek (off_t offset, int whence)
@


1.31
log
@* fhandler.h (fhandler_pipe::broken_pipe): Renamed from saweof.
(fhandler_pipe::set_eof): Reflect above change.
* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::hiteof): Ditto.
@
text
@d179 1
a179 1
      		  fildes[1], psize, mode);
@


1.30
log
@* pipe.cc (fhandler_pipe::read): Narrow eof return to just the "broken pipe"
test.
@
text
@d29 1
a29 1
  : fhandler_base (devtype), guard (NULL), saweof (false), writepipe_exists(0),
d55 1
a55 1
  if (saweof)
d77 1
a77 1
  if (saweof)
@


1.29
log
@* fhandler.cc (fhandler_base::read): Return just read ahead characters if slow
device.
* fhandler.h (fhandler_base::set_eof): New virtual method.
(fhandler_pipe::set_eof): New method.
* pipe.cc (fhandler_pipe::fhandler_pipe): Clear saweof flag.
(fhandler_pipe::read): Return immediately if hit eof.
(fhandler_pipe::hit_eof): Return true if saweof flag is set.
* select.cc (peek_pipe): Don't call PeekNamedPipe if we couldn't grab the guard
mutex.
@
text
@d55 1
a55 1
  if (hit_eof ())
@


1.28
log
@* dll_init.h (class dll_list): Reorder functions to avoid compiler "can't
inline" warnings.
* security.h (class cygsid): Ditto.
* sigproc.cc (get_proc_lock): Ditto.
* sigproc.h (class sigframe): Ditto.
* sync.h (class muto): Ditto.
* fhandler.h (fhandler_base::get_guard): Actually MAKE virtual as previously
indicated.
* pipe.cc (make_pipe): Remove extraneous set_errno.
* syscalls.cc (_open): Ditto.
* select.cc (peek_pipe): Need to check that there is still something to read
from the pipe after acquiring the mutex since another process/thread could have
eaten the input before we got to acquiring the lock.  (Thanks to Nick Duffek
for this inspiration.)
@
text
@d29 1
a29 1
  : fhandler_base (devtype), guard (NULL), writepipe_exists(0),
d55 2
d58 1
a58 1
  ReleaseMutex (guard);
d77 2
@


1.27
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d136 1
a136 3
  if (fdr < 0)
    /* saw an error */;
  else
d140 1
a140 1
	set_errno (ENMFILE);
@


1.26
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d29 2
a30 1
  : fhandler_base (devtype), guard (0), writepipe_exists(0), orig_pid (0), id (0)
@


1.25
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d51 1
a51 1
int
@


1.24
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@a30 1
  set_cb (sizeof *this);
@


1.23
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@a130 2
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "make_pipe");

a131 1
  int  fdr = -1, fdw = -1;
d135 3
a137 6
  if ((fdr = cygheap->fdtab.find_unused_handle ()) < 0)
    set_errno (ENMFILE);
  else if ((fdw = cygheap->fdtab.find_unused_handle (fdr + 1)) < 0)
    set_errno (ENMFILE);
  else if (!CreatePipe (&r, &w, sa, psize))
    __seterrno ();
d140 9
a148 11
      fhandler_pipe *fhr = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdr, FH_PIPER, "/dev/piper");
      fhandler_pipe *fhw = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdw, FH_PIPEW, "/dev/pipew");

      int binmode = mode & O_TEXT ? 0 : 1;
      fhr->init (r, GENERIC_READ, binmode);
      fhw->init (w, GENERIC_WRITE, binmode);
      if (mode & O_NOINHERIT)
       {
	 fhr->set_close_on_exec_flag (1);
	 fhw->set_close_on_exec_flag (1);
       }
d150 23
a172 13
      fildes[0] = fdr;
      fildes[1] = fdw;

      res = 0;
      fhr->create_guard (sa);
      if (wincap.has_unreliable_pipes ())
	{
	  char buf[80];
	  int count = pipecount++;	/* FIXME: Should this be InterlockedIncrement? */
	  __small_sprintf (buf, pipeid_fmt, myself->pid, count);
	  fhw->writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
	  fhr->orig_pid = myself->pid;
	  fhr->id = count;
d176 2
a177 2
  syscall_printf ("%d = make_pipe ([%d, %d], %d, %p)", res, fdr, fdw, psize, mode);
  ReleaseResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "make_pipe");
@


1.22
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d28 2
a29 3
fhandler_pipe::fhandler_pipe (const char *name, DWORD devtype) :
	fhandler_base (devtype, name),
	guard (0), writepipe_exists(0), orig_pid (0), id (0)
@


1.21
log
@* pipe.cc (fhandler_pipe::fixup_after_fork): New method.
* fhandler.h (fhandler_pipe::fixup_after_fork): Declare new method.
@
text
@d18 1
@


1.20
log
@* pipe.cc (fhandler_pipe::hit_eof): Return correct value when there is no EOF
event available.
@
text
@a65 1
{debug_printf ("writepipe_exists closed");
a66 1
}
d84 10
d107 4
a110 1
    return -1;
d117 4
a120 1
    return -1;
@


1.19
log
@* fhandler.h (fhandler_pipe::hit_eof): New method.
(writepipe_exists): New class element.
(orig_pid): Ditto.
(id): Ditto.
(is_slow): Eliminate.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance on
writepipe_exists, if it exists.
(fhandler_pipe::hit_eof): New method, modelled after tty.
(fhandler_pipe::dup): Duplicate writepipe_exists, if it exists.
(make_pipe): Set up a dummy event for pipes on windows 9x.  The nonexistence
of this event means that the write side of the pipe has closed.
(_dup): Move to syscalls.cc
(_dup2): Ditto.

* dtable.cc (dtable::build_fhandler): Fill out set_names here, if appropriate.
* syscalls.cc (_open): Call set_names in build_fhandler.
@
text
@d78 1
a78 1
    return bg_ok;
@


1.19.2.1
log
@Merged changes from HEAD
@
text
@d66 1
d68 1
d78 1
a78 1
    return false;
a85 10
void
fhandler_pipe::fixup_after_fork (HANDLE parent)
{
  this->fhandler_base::fixup_after_fork (parent);
  if (guard)
    fork_fixup (parent, guard, "guard");
  if (writepipe_exists)
    fork_fixup (parent, writepipe_exists, "guard");
}

d99 1
a99 4
    {
      debug_printf ("couldn't duplicate guard %p, %E", guard);
      return -1;
    }
d106 1
a106 4
    {
      debug_printf ("couldn't duplicate writepipe_exists %p, %E", writepipe_exists);
      return -1;
    }
@


1.19.2.2
log
@Merged changes from HEAD
@
text
@a17 1
#include "path.h"
@


1.19.2.3
log
@Merged changes from HEAD
@
text
@d28 3
a30 3
fhandler_pipe::fhandler_pipe (DWORD devtype)
  : fhandler_base (devtype), guard (NULL), broken_pipe (false), writepipe_exists(0),
    orig_pid (0), id (0)
d32 1
d53 1
a53 1
int __stdcall
a55 2
  if (broken_pipe)
    return 0;
d57 1
a57 1
  (void) ReleaseMutex (guard);
a75 2
  if (broken_pipe)
    return 1;
d132 2
d135 1
d139 7
a145 2
  cygheap_fdnew fdr;
  if (fdr >= 0)
d147 18
a164 6
      cygheap_fdnew fdw (fdr, false);
      if (fdw < 0)
	/* out of fds? */;
      else if (!CreatePipe (&r, &w, sa, psize))
	__seterrno ();
      else
d166 6
a171 26
	  fhandler_pipe *fhr = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdr, FH_PIPER, "/dev/piper");
	  fhandler_pipe *fhw = (fhandler_pipe *) cygheap->fdtab.build_fhandler (fdw, FH_PIPEW, "/dev/pipew");

	  int binmode = mode & O_TEXT ? 0 : 1;
	  fhr->init (r, GENERIC_READ, binmode);
	  fhw->init (w, GENERIC_WRITE, binmode);
	  if (mode & O_NOINHERIT)
	   {
	     fhr->set_close_on_exec_flag (1);
	     fhw->set_close_on_exec_flag (1);
	   }

	  fildes[0] = fdr;
	  fildes[1] = fdw;

	  res = 0;
	  fhr->create_guard (sa);
	  if (wincap.has_unreliable_pipes ())
	    {
	      char buf[80];
	      int count = pipecount++;	/* FIXME: Should this be InterlockedIncrement? */
	      __small_sprintf (buf, pipeid_fmt, myself->pid, count);
	      fhw->writepipe_exists = CreateEvent (sa, TRUE, FALSE, buf);
	      fhr->orig_pid = myself->pid;
	      fhr->id = count;
	    }
d175 2
a176 2
  syscall_printf ("%d = make_pipe ([%d, %d], %d, %p)", res, fildes[0],
		  fildes[1], psize, mode);
@


1.19.2.4
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d34 2
a35 2
__off64_t
fhandler_pipe::lseek (__off64_t offset, int whence)
@


1.19.2.5
log
@Merged changes from HEAD
@
text
@d13 1
d22 1
d152 1
a152 1
	  int binmode = mode & O_TEXT ?: O_BINARY;
@


1.19.2.6
log
@Merged changes from HEAD
@
text
@a10 2
/* FIXME: Should this really be fhandler_pipe.cc? */

@


1.19.2.7
log
@Merged changes from HEAD
@
text
@d131 1
@


1.18
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@d21 5
d28 2
a29 1
	fhandler_base (devtype, name), guard (0)
d46 4
a49 1
  set_inheritance (guard, val);
d65 4
d72 14
d100 10
d113 2
a114 1
static int
d149 9
a179 19
}

int
dup (int fd)
{
  int res;
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");

  res = dup2 (fd, cygheap->fdtab.find_unused_handle ());

  ReleaseResourceLock(LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "dup");

  return res;
}

int
dup2 (int oldfd, int newfd)
{
  return cygheap->fdtab.dup2 (oldfd, newfd);
@


1.17
log
@Update copyrights.
@
text
@d22 54
d110 1
@


1.16
log
@* cygheap.cc (cygheap_root::set): Avoid treating '/' specially.
* fhandler.cc (fhandler_base::fcntl): Only set specific O_NDELAY style flag
passed in from application.
* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
* fhandler.h: Set constant for future use.
* winsup.h: Define OLD_O_NDELAY only for old programs.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_OLD_O_NONBLOCK.
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000, 2001 Cygnus Solutions.
@


1.15
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 1999, 2000 Cygnus Solutions.
d25 1
a25 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," make_pipe");
d40 2
a41 2
      fhandler_base *fhr = cygheap->fdtab.build_fhandler (fdr, FH_PIPER, "/dev/piper");
      fhandler_base *fhw = cygheap->fdtab.build_fhandler (fdw, FH_PIPEW, "/dev/pipew");
d59 1
a59 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," make_pipe");
d84 1
a84 1
  SetResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," dup");
d88 1
a88 1
  ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," dup");
@


1.14
log
@forced commit
@
text
@d16 1
a20 1
#include "security.h"
@


1.13
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@@


1.12
log
@* fhandler.h (fhandler_base): Remove obsolete _rpos and _rsize elements.
* fhandler.cc (fhandler_base::open): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Ditto.
(fhandler_base::read): Ditto.  Add more debugging output.  Don't issue a \r
when \r\n detected.
* pipe.cc (make_pipe): Streamline slightly.  Make debug output more
interesting.
* strace.cc (strace::vsprintf): Use __progname where appropriate to distinguish
strace output when exec'ing.
@
text
@d18 1
d32 1
a32 1
  if ((fdr = fdtab.find_unused_handle ()) < 0)
d34 1
a34 1
  else if ((fdw = fdtab.find_unused_handle (fdr + 1)) < 0)
d40 2
a41 2
      fhandler_base *fhr = fdtab.build_fhandler (fdr, FH_PIPER, "/dev/piper");
      fhandler_base *fhw = fdtab.build_fhandler (fdw, FH_PIPEW, "/dev/pipew");
d76 1
a76 1
    fdtab[filedes[0]]->set_r_no_interrupt (1);
d86 1
a86 1
  res = dup2 (fd, fdtab.find_unused_handle ());
d96 1
a96 1
  return fdtab.dup2 (oldfd, newfd);
@


1.11
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d27 1
a27 1
  int  fdr, fdw;
d29 1
d54 1
a54 5
      debug_printf ("0 = pipe (%p) (%d:%p, %d:%p)", fildes,
		    fdr, fhr->get_handle (), fdw, fhw->get_handle ());

      ReleaseResourceLock(LOCK_FD_LIST,WRITE_LOCK|READ_LOCK," make_pipe");
      return 0;
d57 1
a57 1
  syscall_printf ("-1 = pipe (%p)", fildes);
d59 1
a59 1
  return -1;
@


1.10
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d19 1
@


1.9
log
@* environ.cc (parse_thing): nobinmode should force O_TEXT.
(regopt): Use correct path to find LOCAL_MACHINE registry options.
* fhandler.cc (fhandler_base::open): Set binary mode only when binmode ==
O_BINARY.
* pipe.cc (pipe): Pipe handling should rely on binmode not _fmode now that the
two are different.
@
text
@d32 1
a32 1
    set_errno ( ENMFILE);
@


1.8
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d67 2
a68 1
  return make_pipe (filedes, 16384, (!__fmode || __fmode == O_BINARY) ? O_BINARY : O_TEXT);
@


1.7
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d15 2
d18 1
a18 1
#include "cygerrno.h"
@


1.6
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d16 1
@


1.5
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d15 1
@


1.4
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d25 1
a25 1
  if ((fdr = dtable.find_unused_handle ()) < 0)
d27 1
a27 1
  else if ((fdw = dtable.find_unused_handle (fdr + 1)) < 0)
d33 2
a34 2
      fhandler_base *fhr = dtable.build_fhandler (fdr, FH_PIPER, "/dev/piper");
      fhandler_base *fhw = dtable.build_fhandler (fdw, FH_PIPEW, "/dev/pipew");
d72 1
a72 1
    dtable[filedes[0]]->set_r_no_interrupt (1);
d82 1
a82 1
  res = dup2 (fd, dtable.find_unused_handle ());
d92 1
a92 1
  return dtable.dup2 (oldfd, newfd);
@


1.3
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@d11 1
a14 1
#include "winsup.h"
@


1.2
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d33 2
a34 2
      fhandler_base *fhr = dtable.build_fhandler (fdr, FH_PIPE, "/dev/piper");
      fhandler_base *fhw = dtable.build_fhandler (fdw, FH_PIPE, "/dev/pipew");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* pipe.cc: pipe for WIN32.
d3 1
a3 1
   Copyright 1996, 1998, 1999 Cygnus Solutions.
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
