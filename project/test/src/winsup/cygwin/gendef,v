head	1.59;
access;
symbols
	cygwin-1_7_35-release:1.59
	cygwin-1_7_34-release:1.59
	cygwin-1_7_33-release:1.53.2.2
	cygwin-1_7_32-release:1.53.2.1
	cygwin-1_7_31-release:1.53.2.1
	cygwin-1_7_30-release:1.53.2.1
	cygwin-1_7_29-release:1.53.2.1
	cygwin-1_7_29-release-branchpoint:1.53.0.2
	cygwin-pre-user-db:1.53
	cygwin-1_7_28-release:1.53
	cygwin-1_7_27-release:1.51
	cygwin-1_7_26-release:1.51
	cygwin-1_7_25-release:1.51
	cygwin-1_7_24-release:1.51
	cygwin-1_7_23-release:1.51
	cygwin-1_7_22-release:1.51
	cygwin-1_7_21-release:1.51
	cygwin-1_7_20-release:1.51
	cygwin-1_7_19-release:1.51
	cygwin-64bit-postmerge:1.47
	cygwin-64bit-premerge-branch:1.46.0.2
	cygwin-64bit-premerge:1.46
	cygwin-1_7_18-release:1.46
	post-ptmalloc3:1.41.2.14
	pre-ptmalloc3:1.41.2.14
	cygwin-1_7_17-release:1.44
	cygwin-64bit-branch:1.41.0.2
	cygwin-1_7_16-release:1.39
	cygwin-1_7_15-release:1.39
	cygwin-1_7_14_2-release:1.39
	cygwin-1_7_14-release:1.39
	cygwin-1_7_12-release:1.39
	cygwin-1_7_11-release:1.39
	cygwin-1_7_10-release:1.39
	signal-rewrite:1.36.0.4
	pre-notty:1.36
	cygwin-1_7_9-release:1.36
	cv-post-1_7_9:1.36.0.2
	cygwin-1_7_8-release:1.36
	cygwin-1_7_7-release:1.36
	cygwin-1_7_5-release:1.34
	cygwin-1_7_4-release:1.34
	cygwin-1_7_3-release:1.34
	cygwin-1_7_2-release:1.34
	fifo_doover3:1.33.0.2
	cygwin-1_7_1-release:1.33
	prefifo:1.33
	cv-branch-2:1.32.0.2
	pre-ripout-set_console_state_for_spawn:1.30
	EOL_registry_mounts:1.30
	preoverlapped:1.27
	drop_9x_support_start:1.27
	cr-0x5f1:1.27.0.4
	cv-branch:1.27.0.2
	pre-ptymaster-archetype:1.27
	cr-0x3b58:1.23.0.4
	cr-0x5ef:1.23.0.2
	after-mmap-privanon-noreserve:1.21
	after-mmap-revamp:1.21
	before-mmap-revamp:1.21
	cgf-more-exit-sync:1.20
	post_wait_sig_exit:1.20
	pre_wait_sig_exit:1.20
	reparent-point:1.17
	noreparent:1.17.0.4
	cr-0x5e6:1.17.0.2
	cr-0x9e:1.1.0.6
	cr-0x9d:1.1.0.4
	cgf-deleteme:1.1.0.2;
locks; strict;
comment	@# @;


1.59
date	2015.01.16.16.19.36;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2014.10.24.15.04.10;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2014.10.24.13.40.02;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2014.08.25.14.53.49;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.27.19.35.55;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.27.20.53.02;	author cgf;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2014.01.27.20.08.36;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.27.19.31.04;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2013.05.21.18.26.48;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.01.01.15.07;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.30.23.43.08;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2012.12.07.17.23.22;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2012.08.15.17.29.58;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2012.08.15.17.07.47;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2012.08.15.16.35.00;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2012.07.29.21.43.29;	author cgf;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2011.12.16.16.32.25;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2011.12.16.05.27.14;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.04.17.58.24;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2010.08.01.19.10.52;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.18.20.10.22;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.28.18.23.35;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.09.21.02.53;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.14.09.14.47;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2008.03.01.13.18.22;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.09.17.20.09;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.02.00.09.50;	author cgf;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2006.03.13.04.26.57;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.12.23.57.05;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.01.20.20.22;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.23.22.50.20;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.05.20.20.17;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.29.15.19.34;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.28.23.26.23;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.27.16.16.51;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.12.03.09.28;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.12.02.07.39;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.09.01.24.08;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.07.04.57.47;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.05.19.09.04;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.04.05.31.14;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.25.04.08.00;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.18.20.48.38;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.14.04.38.37;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.13.19.34.32;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.12.04.55.29;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.08.19.59.27;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.26.22.25.57;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.53.2.1
date	2014.03.28.20.58.58;	author corinna;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2014.11.13.12.53.02;	author corinna;	state Exp;
branches;
next	;

1.41.2.1
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2012.12.10.12.19.45;	author corinna;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2013.01.21.13.52.06;	author corinna;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2013.01.22.17.40.52;	author corinna;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2013.01.23.17.31.35;	author corinna;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2013.01.25.17.07.42;	author corinna;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2013.01.28.18.31.44;	author corinna;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2013.01.29.12.32.16;	author corinna;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2013.01.30.19.42.17;	author corinna;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	2013.02.04.15.43.12;	author corinna;	state Exp;
branches;
next	1.41.2.11;

1.41.2.11
date	2013.02.04.17.03.36;	author corinna;	state Exp;
branches;
next	1.41.2.12;

1.41.2.12
date	2013.02.08.14.17.48;	author corinna;	state Exp;
branches;
next	1.41.2.13;

1.41.2.13
date	2013.02.11.11.40.18;	author corinna;	state Exp;
branches;
next	1.41.2.14;

1.41.2.14
date	2013.02.21.12.02.52;	author corinna;	state Exp;
branches;
next	1.41.2.15;

1.41.2.15
date	2013.03.11.11.37.50;	author corinna;	state Exp;
branches;
next	1.41.2.16;

1.41.2.16
date	2013.03.13.10.07.38;	author corinna;	state Exp;
branches;
next	1.41.2.17;

1.41.2.17
date	2013.03.15.08.40.49;	author corinna;	state Exp;
branches;
next	1.41.2.18;

1.41.2.18
date	2013.03.15.13.33.54;	author corinna;	state Exp;
branches;
next	1.41.2.19;

1.41.2.19
date	2013.03.19.09.27.36;	author corinna;	state Exp;
branches;
next	1.41.2.20;

1.41.2.20
date	2013.03.22.15.59.24;	author corinna;	state Exp;
branches;
next	;

1.27.4.1
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2008.03.02.10.40.39;	author corinna;	state Exp;
branches;
next	;

1.1.2.1
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	;

1.1.6.1
date	2004.01.26.22.28.58;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.59
log
@	* gendef: Export _sigbe on 64 bit as well.
	* malloc_wrapper.cc (free): In malloc_printf, call caller_return_address
	instead of __builtin_return_address.
	(malloc): Ditto.
	(realloc): Ditto.
	(calloc): Ditto.
	* miscfuncs.cc (__caller_return_address): New function.
	* miscfuncs.h (caller_return_address): New macro calling
	__caller_return_address.
	(__caller_return_address): Add prototype.
@
text
@#!/usr/bin/perl
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2013, 2014,
# 2015 Red Hat, Inc.
#
# This file is part of Cygwin.
#
# This software is a copyrighted work licensed under the terms of the
# Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
# details.
#
use strict;
use integer;
use Getopt::Long;

sub cleanup(@@);

my $cpu;
my $output_def;
my $tls_offsets;
GetOptions('cpu=s'=>\$cpu, 'output-def=s'=>\$output_def, 'tlsoffsets=s'=>\$tls_offsets);

$main::first = 0;
if (!defined($cpu) || !defined($output_def) || !defined($tls_offsets)) {
    die "$0: missing required option\n";
}

require $tls_offsets;

my $is64bit = $cpu eq 'x86_64';
my $sym_prefix = $is64bit ? '' : '_';

my @@top = ();
while (<>) {
    push(@@top, cleanup $_);
    last if /^\s*exports$/oi;
}
my @@in = cleanup <>;

my %sigfe = ();
my @@data = ();
my @@nosigfuncs = ();
my @@text = ();
for (@@in) {
    chomp;
    s/\s+DATA$//o and do {
	push @@data, $_;
	next;
    };
    if (/=/o) {
	if (s/\s+NOSIGFE\s*$//) {
	    # nothing
	} elsif (s/\s+SIGFE(_MAYBE)?$//) {
	    my $func = (split(' '))[2];
	    my $maybe = (defined($1) ? lc $1 : '') . '_';
	    $sigfe{$func} = '_sigfe' . $maybe . $func;
	}
    } else {
	my ($func, $sigfe) = m%^\s*(\S+)(?:\s+((?:NO)?SIGFE(?:_MAYBE)?))?$%o;
	if (defined($sigfe) && $sigfe =~ /^NO/o) {
	    $_ = $func;
	} else {
	    $sigfe ||= 'sigfe';
	    $_ = '_' . lc($sigfe) . '_' . $func;
	    $sigfe{$func} = $_;
	    $_ = $func . ' = ' . $_;
	}
    }
    s/(\S)\s+(\S)/$1 $2/go;
    s/(\S)\s+$/$1/o;
    s/^\s+(\S)/$1/o;
    push @@text, $_;
}

for (@@text) {
    my ($alias, $func) = /^(\S+)\s+=\s+(\S+)\s*$/o;
    $_ = $alias . ' = ' . $sigfe{$func}
      if defined($func) && $sigfe{$func};
}

open OUT, '>', $output_def or die "$0: couldn't open \"$output_def\" - $!\n";
push @@top, (map {$_ . " DATA\n"} @@data), (map {$_ . "\n"} @@text);
print OUT @@top;
close OUT;

open SIGFE, '>', 'sigfe.s' or die "$0: couldn't open 'sigfe.s' file for writing - $!\n";

for my $k (sort keys %sigfe) {
    print SIGFE fefunc($k, $sigfe{$k});
}
close SIGFE;

sub fefunc {
    my $func = $sym_prefix . shift;
    my $fe = $sym_prefix . shift;
    my $sigfe_func;
    if ($is64bit) {
	$sigfe_func = ($fe =~ /^(.*)_${func}$/)[0];
    } else {
	$sigfe_func = ($fe =~ /^(.*)${func}$/)[0];
    }
    my $extra;
    my $res;
    if ($is64bit) {
	$res = <<EOF;
	.extern	$func
	.global	$fe
	.seh_proc $fe
$fe:
	leaq	$func(%rip),%r10
	pushq	%r10
	.seh_pushreg %r10
	.seh_endprologue
	jmp	$sigfe_func
	.seh_endproc

EOF
    } else {
	$res = <<EOF;
        .extern $func
        .global $fe
$fe:
        pushl   \$$func
        jmp     $sigfe_func

EOF
    }
    if (!$main::first++) {
	if ($is64bit) {
	  $res = <<EOF . longjmp () . $res;
	.text

	.seh_proc _sigfe_maybe
_sigfe_maybe:					# stack is aligned on entry!
	.seh_endprologue
	movq	%gs:8,%r10			# location of bottom of stack
	leaq	$tls::initialized(%r10),%r11	# where we will be looking
	cmpq	%r11,%rsp			# stack loc > than tls
	jge	0f				# yep.  we don't have a tls.
	movl	$tls::initialized(%r10),%r11d
	cmpl	\$0xc763173f,%r11d		# initialized?
	je	1f
0:	ret
	.seh_endproc

	.seh_proc _sigfe
_sigfe:						# stack is aligned on entry!
	.seh_endprologue
	movq	%gs:8,%r10			# location of bottom of stack
1:	movl	\$1,%r11d			# potential lock value
	xchgl	%r11d,$tls::stacklock(%r10)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r10)	# flag if we are waiting for lock
	testl	%r11d,%r11d			# it will be zero
	jz	2f				#  if so
	pause
	jmp	1b				# loop
2:	movq	\$8,%rax			# have the lock, now increment the
	xaddq	%rax,$tls::stackptr(%r10)	#  stack pointer and get pointer
	leaq	_sigbe(%rip),%r11		# new place to return to
	xchgq	%r11,8(%rsp)			# exchange with real return value
	movq	%r11,(%rax)			# store real return value on alt stack
	incl	$tls::incyg(%r10)
	decl	$tls::stacklock(%r10)		# remove lock
	popq	%rax				# pop real function address from stack
	jmp	*%rax				# and jmp to it
	.seh_endproc

	.global _sigbe
	.seh_proc _sigbe
_sigbe:						# return here after cygwin syscall
						# stack is aligned on entry!
	.seh_endprologue
	movq	%gs:8,%r10			# address of bottom of tls
1:	movl	\$1,%r11d			# potential lock value
	xchgl	%r11d,$tls::stacklock(%r10)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r10)	# flag if we are waiting for lock
	testl	%r11d,%r11d			# it will be zero
	jz	2f				#  if so
	pause
	jmp	1b				#  and loop
2:	movq	\$-8,%r11			# now decrement aux stack
	xaddq	%r11,$tls::stackptr(%r10)	#  and get pointer
	movq	-8(%r11),%r11			# get return address from signal stack
	decl	$tls::incyg(%r10)
	decl	$tls::stacklock(%r10)		# release lock
	jmp	*%r11				# "return" to caller
	.seh_endproc

	.global	sigdelayed
	.seh_proc sigdelayed
sigdelayed:
	pushq	%r10				# used for return address injection
	.seh_pushreg %r10
	pushq	%rbp
	.seh_pushreg %rbp
	movq	%rsp,%rbp
	pushf
	.seh_pushreg %rax			# fake, there's no .seh_pushreg for the flags
	# stack is aligned or unaligned on entry!
	# make sure it is aligned from here on
	# We could be called from an interrupted thread which doesn't know
	# about his fate, so save and restore everything and the kitchen sink.
	andq	\$0xfffffffffffffff0,%rsp
	.seh_setframe %rbp,0
	pushq	%r15
	.seh_pushreg %r15
	pushq	%r14
	.seh_pushreg %r14
	pushq	%r13
	.seh_pushreg %r13
	pushq	%r12
	.seh_pushreg %r12
	pushq	%r11
	.seh_pushreg %r11
	pushq	%r9
	.seh_pushreg %r9
	pushq	%r8
	.seh_pushreg %r8
	pushq	%rsi
	.seh_pushreg %rsi
	pushq	%rdi
	.seh_pushreg %rdi
	pushq	%rdx
	.seh_pushreg %rdx
	pushq	%rcx
	.seh_pushreg %rcx
	pushq	%rbx
	.seh_pushreg %rbx
	pushq	%rax
	.seh_pushreg %rax
	subq	\$0x128,%rsp
	.seh_stackalloc 0x128
	fnstcw	0x120(%rsp)
	movdqa	%xmm15,0x110(%rsp)
	movdqa	%xmm14,0x100(%rsp)
	movdqa	%xmm13,0xf0(%rsp)
	movdqa	%xmm12,0xe0(%rsp)
	movdqa	%xmm11,0xd0(%rsp)
	movdqa	%xmm10,0xc0(%rsp)
	movdqa	%xmm9,0xb0(%rsp)
	movdqa	%xmm8,0xa0(%rsp)
	movdqa	%xmm7,0x90(%rsp)
	movdqa	%xmm6,0x80(%rsp)
	movdqa	%xmm5,0x70(%rsp)
	movdqa	%xmm4,0x60(%rsp)
	movdqa	%xmm3,0x50(%rsp)
	movdqa	%xmm2,0x40(%rsp)
	movdqa	%xmm1,0x30(%rsp)
	movdqa	%xmm0,0x20(%rsp)
	.seh_endprologue

	movq	%gs:8,%r12			# get tls
	movl	$tls::saved_errno(%r12),%r15d	# temporarily save saved_errno
	movq	\$$tls::start_offset,%rcx	# point to beginning of tls block
	addq	%r12,%rcx			#  and store as first arg to method
	call	_ZN7_cygtls19call_signal_handlerEv	# call handler

1:	movl	\$1,%r11d			# potential lock value
	xchgl	%r11d,$tls::stacklock(%r12)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r12)	# flag if we are waiting for lock
	testl	%r11d,%r11d			# it will be zero
	jz	2f				#  if so
	pause
	jmp	1b				#  and loop
2:	testl	%r15d,%r15d			# was saved_errno < 0
	jl	3f				# yup.  ignore it
	movq	$tls::errno_addr(%r12),%r11
	movl	%r15d,(%r11)
3:	movq	\$-8,%r11			# now decrement aux stack
	xaddq	%r11,$tls::stackptr(%r12)	#  and get pointer
	xorq	%r10,%r10
	xchgq	%r10,-8(%r11)			# get return address from signal stack
	xorl	%r11d,%r11d
	movl	%r11d,$tls::incyg(%r12)
	movl	%r11d,$tls::stacklock(%r12)	# unlock
	movdqa	0x20(%rsp),%xmm0
	movdqa	0x30(%rsp),%xmm1
	movdqa	0x40(%rsp),%xmm2
	movdqa	0x50(%rsp),%xmm3
	movdqa	0x60(%rsp),%xmm4
	movdqa	0x70(%rsp),%xmm5
	movdqa	0x80(%rsp),%xmm6
	movdqa	0x90(%rsp),%xmm7
	movdqa	0xa0(%rsp),%xmm8
	movdqa	0xb0(%rsp),%xmm9
	movdqa	0xc0(%rsp),%xmm10
	movdqa	0xd0(%rsp),%xmm11
	movdqa	0xe0(%rsp),%xmm12
	movdqa	0xf0(%rsp),%xmm13
	movdqa	0x100(%rsp),%xmm14
	movdqa	0x110(%rsp),%xmm15
	fninit
	fldcw	0x120(%rsp)
	addq	\$0x128,%rsp
	popq	%rax
	popq	%rbx
	popq	%rcx
	popq	%rdx
	popq	%rdi
	popq	%rsi
	popq	%r8
	popq	%r9
	popq	%r11
	popq	%r12
	popq	%r13
	popq	%r14
	popq	%r15
	movq	%rbp,%rsp
	subq	\$8, %rsp
	popf
	popq	%rbp
	xchgq	%r10,(%rsp)
	ret
	.seh_endproc

# _cygtls::pop
	.global _ZN7_cygtls3popEv
	.seh_proc _ZN7_cygtls3popEv
_ZN7_cygtls3popEv:
	.seh_endprologue
	movq	\$-8,%r11
	xaddq	%r11,$tls::pstackptr(%rcx)
	movq	-8(%r11),%rax
	ret
	.seh_endproc

# _cygtls::lock
	.global _ZN7_cygtls4lockEv
	.seh_proc _ZN7_cygtls4lockEv
_ZN7_cygtls4lockEv:
	pushq	%r12
	.seh_pushreg %r12
	.seh_endprologue
	movq	%rcx,%r12
1:	movl	\$1,%r11d
	xchgl	%r11d,$tls::pstacklock(%r12)
	testl   %r11d,%r11d
	jz	2f
	pause
	jmp	1b
2:	popq	%r12
	ret
	.seh_endproc

# _cygtls::unlock
	.global _ZN7_cygtls6unlockEv
	.seh_proc _ZN7_cygtls6unlockEv
_ZN7_cygtls6unlockEv:
	.seh_endprologue
	decl	$tls::pstacklock(%rcx)
	ret
	.seh_endproc

# _cygtls::locked
	.global _ZN7_cygtls6lockedEv
	.seh_proc _ZN7_cygtls6lockedEv
_ZN7_cygtls6lockedEv:
	.seh_endprologue
	movl	$tls::pstacklock(%rcx),%eax
	ret
	.seh_endproc

	.seh_proc stabilize_sig_stack
stabilize_sig_stack:
	pushq	%r12
	.seh_pushreg %r12
	subq	\$0x20,%rsp
	.seh_stackalloc 32
	.seh_endprologue
	movq	%gs:8,%r12
1:	movl	\$1,%r10d
	xchgl	%r10d,$tls::stacklock(%r12)
	movl	%r10d,$tls::spinning(%r12)	# flag if we are waiting for lock
	testl	%r10d,%r10d
	jz	2f
	pause
	jmp	1b
2:	incl	$tls::incyg(%r12)
	cmpl	\$0,$tls::sig(%r12)
	jz	3f
	decl	$tls::stacklock(%r12)		# unlock
	movq	\$$tls::start_offset,%rcx	# point to beginning
	addq	%r12,%rcx			#  of tls block
	call	_ZN7_cygtls19call_signal_handlerEv
	jmp	1b
3:	decl	$tls::incyg(%r12)
	addq	\$0x20,%rsp
	movq	%r12,%r11			# return tls addr in r11
	popq	%r12
	ret
	.seh_endproc
EOF
	} else {
	  $res = <<EOF . longjmp () . $res;
	.text

__sigfe_maybe:
	pushl	%ebx
	pushl	%edx
	movl	%fs:4,%ebx			# location of bottom of stack
	addl	\$$tls::initialized,%ebx	# where we will be looking
	cmpl	%ebx,%esp			# stack loc > than tls
	jge	0f				# yep.  we don't have a tls.
	subl	\$$tls::initialized,%ebx	# where we will be looking
	movl	$tls::initialized(%ebx),%eax
	cmpl	\$0xc763173f,%eax		# initialized?
	je	1f
0:	popl	%edx
	popl	%ebx
	ret

__sigfe:
	pushl	%ebx
	pushl	%edx
	movl	%fs:4,%ebx			# location of bottom of stack
1:	movl	\$1,%eax			# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)	# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)	# flag if we are waiting for lock
	testl	%eax,%eax			# it will be zero
	jz	2f				#  if so
	call	_yield				# should be a short-time thing, so
	jmp	1b				# sleep and loop
2:	movl	\$4,%eax			# have the lock, now increment the
	xadd	%eax,$tls::stackptr(%ebx)	#  stack pointer and get pointer
	leal	__sigbe,%edx			# new place to return to
	xchgl	%edx,12(%esp)			# exchange with real return value
	movl	%edx,(%eax)			# store real return value on alt stack
	incl	$tls::incyg(%ebx)
	decl	$tls::stacklock(%ebx)		# remove lock
	popl	%edx				# restore saved value
	popl	%ebx
	ret

	.global	__sigbe
__sigbe:					# return here after cygwin syscall
	pushl	%eax				# don't clobber
	pushl	%ebx				# tls pointer
1:	movl	%fs:4,%ebx			# address of bottom of tls
	movl	\$1,%eax			# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)	# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)	# flag if we are waiting for lock
	testl	%eax,%eax			# it will be zero
	jz	2f				#  if so
	call	_yield				# sleep
	jmp	1b				#  and loop
2:	movl	\$-4,%eax			# now decrement aux stack
	xadd	%eax,$tls::stackptr(%ebx)	#  and get pointer
	movl	-4(%eax),%eax			# get return address from signal stack
	xchgl	%eax,4(%esp)			# swap return address with saved eax
	decl	$tls::incyg(%ebx)
	decl	$tls::stacklock(%ebx)		# release lock
	popl	%ebx
	ret

	.global	_sigdelayed
_sigdelayed:
	pushl   %ebp
	movl    %esp,%ebp
	# We could be called from an interrupted thread which doesn't know
	# about his fate, so save and restore everything and the kitchen sink.
	pushf
	pushl   %esi
	pushl   %edi
	pushl   %edx
	pushl   %ecx
	pushl   %ebx
	pushl   %eax
	subl	\$0x84,%esp
	fnstcw  0x80(%esp)
	movdqu	%xmm7,0x70(%esp)
	movdqu	%xmm6,0x60(%esp)
	movdqu	%xmm5,0x50(%esp)
	movdqu	%xmm4,0x40(%esp)
	movdqu	%xmm3,0x30(%esp)
	movdqu	%xmm2,0x20(%esp)
	movdqu	%xmm1,0x10(%esp)
	movdqu	%xmm0,(%esp)
	movl	%fs:4,%ebx				# get tls
	pushl   $tls::saved_errno(%ebx) # saved errno

	movl	\$$tls::start_offset,%eax		# point to beginning
	addl	%ebx,%eax				#  of tls block
	call	__ZN7_cygtls19call_signal_handlerEv\@@4	# call handler

	movl	%fs:4,%ebx				# reget tls
1:	movl	\$1,%eax				# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)		# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)		# flag if we are waiting for lock
	testl	%eax,%eax				# it will be zero
	jz	2f					#  if so
	call	_yield					# sleep
	jmp	1b					#  and loop
2:	popl	%edx					# saved errno
	testl	%edx,%edx				# Is it < 0
	jl	3f					# yup.  ignore it
	movl	$tls::errno_addr(%ebx),%eax
	movl	%edx,(%eax)
3:	movl	\$-4,%eax				# now decrement aux stack
	xadd	%eax,$tls::stackptr(%ebx)		#  and get pointer
	xorl	%ebp,%ebp
	xchgl	%ebp,-4(%eax)				# get return address from signal stack
	xchgl	%ebp,0xa0(%esp)				# store real return address
leave:	xorl	%eax,%eax
	movl	%eax,$tls::incyg(%ebx)
	movl	%eax,$tls::stacklock(%ebx)		# unlock

	movdqu	(%esp),%xmm0
	movdqu	0x10(%esp),%xmm1
	movdqu	0x20(%esp),%xmm2
	movdqu	0x30(%esp),%xmm3
	movdqu	0x40(%esp),%xmm4
	movdqu	0x50(%esp),%xmm5
	movdqu	0x60(%esp),%xmm6
	movdqu	0x70(%esp),%xmm7
	fninit
	fldcw   0x80(%esp)
	addl	\$0x84,%esp
	popl	%eax
	popl	%ebx
	popl	%ecx
	popl	%edx
	popl	%edi
	popl	%esi
	popf
	ret

	.global __ZN7_cygtls3popEv\@@4
__ZN7_cygtls3popEv\@@4:
1:	pushl	%ebx
	movl	%eax,%ebx			# this
	movl	\$-4,%eax
	xadd	%eax,$tls::pstackptr(%ebx)
	movl	-4(%eax),%eax
	popl	%ebx
	ret

# _cygtls::lock
	.global	__ZN7_cygtls4lockEv\@@4
__ZN7_cygtls4lockEv\@@4:
	pushl	%ebx
	movl	%eax,%ebx
1:	movl	\$1,%eax
	xchgl	%eax,$tls::pstacklock(%ebx)
	testl	%eax,%eax
	jz	2f
	call	_yield
	jmp	1b
2:	popl	%ebx
	ret

# _cygtls::unlock
	.global	__ZN7_cygtls6unlockEv\@@4
__ZN7_cygtls6unlockEv\@@4:
	decl	$tls::pstacklock(%eax)
	ret

	.global	__ZN7_cygtls6lockedEv
__ZN7_cygtls6lockedEv:
	movl	$tls::pstacklock(%eax),%eax
	ret

	.extern	__ZN7_cygtls19call_signal_handlerEv\@@4
stabilize_sig_stack:
	movl	%fs:4,%ebx
1:	movl	\$1,%eax
	xchgl	%eax,$tls::stacklock(%ebx)
	movl	%eax,$tls::spinning(%ebx)		# flag if we are waiting for lock
	testl	%eax,%eax
	jz	2f
	call	_yield
	jmp	1b
2:	incl	$tls::incyg(%ebx)
	cmpl	\$0,$tls::sig(%ebx)
	jz	3f
	decl	$tls::stacklock(%ebx)			# unlock
	movl	\$$tls::start_offset,%eax		# point to beginning
	addl	%ebx,%eax				#  of tls block
	call	__ZN7_cygtls19call_signal_handlerEv\@@4
	jmp	1b
3:	decl	$tls::incyg(%ebx)
	ret
EOF
	}
    }
    return $res;
}

sub longjmp {
    if ($is64bit) {
	return <<EOF;

	.globl  setjmp
	.seh_proc setjmp
setjmp:
	.seh_endprologue
	leaq	8(%rsp),%rdx
	jmp	__setjmpex
	.seh_endproc

	.globl	__setjmpex
	.seh_proc __setjmpex
__setjmpex:
	.seh_endprologue
	# We use the Windows jmp_buf layout.
	# Store alternative stackptr in Spare.
	movq	%rdx,(%rcx)
	movq	%rbx,0x8(%rcx)
	movq	%rsp,0x10(%rcx)
	movq	%rbp,0x18(%rcx)
	movq	%rsi,0x20(%rcx)
	movq	%rdi,0x28(%rcx)
	movq	%r12,0x30(%rcx)
	movq	%r13,0x38(%rcx)
	movq	%r14,0x40(%rcx)
	movq	%r15,0x48(%rcx)
	movq	(%rsp),%r10
	movq	%r10,0x50(%rcx)
	# jmp_buf is potentially unaligned!
	movdqu	%xmm6,0x60(%rcx)
	movdqu	%xmm7,0x70(%rcx)
	movdqu	%xmm8,0x80(%rcx)
	movdqu	%xmm9,0x90(%rcx)
	movdqu	%xmm10,0xa0(%rcx)
	movdqu	%xmm11,0xb0(%rcx)
	movdqu	%xmm12,0xc0(%rcx)
	movdqu	%xmm13,0xd0(%rcx)
	movdqu	%xmm14,0xe0(%rcx)
	movdqu	%xmm15,0xf0(%rcx)
	pushq	%rcx
	.seh_pushreg %rcx
	call	stabilize_sig_stack		# returns tls in r11
	popq	%rcx
	movq	$tls::stackptr(%r11),%r10
	movq	%r10,0x58(%rcx)
	decl	$tls::stacklock(%r11)
	movl	\$0,%eax
	ret
	.seh_endproc

	.globl  __sjfault
	.seh_proc __sjfault
__sjfault:
	.seh_endprologue
	# Like setjmp, just w/o storing the alternate stackptr.
	movq	%rdx,(%rcx)
	movq	%rbx,0x8(%rcx)
	movq	%rsp,0x10(%rcx)
	movq	%rbp,0x18(%rcx)
	movq	%rsi,0x20(%rcx)
	movq	%rdi,0x28(%rcx)
	movq	%r12,0x30(%rcx)
	movq	%r13,0x38(%rcx)
	movq	%r14,0x40(%rcx)
	movq	%r15,0x48(%rcx)
	movq	(%rsp),%r10
	movq	%r10,0x50(%rcx)
	# jmp_buf is potentially unaligned!
	movdqu	%xmm6,0x60(%rcx)
	movdqu	%xmm7,0x70(%rcx)
	movdqu	%xmm8,0x80(%rcx)
	movdqu	%xmm9,0x90(%rcx)
	movdqu	%xmm10,0xa0(%rcx)
	movdqu	%xmm11,0xb0(%rcx)
	movdqu	%xmm12,0xc0(%rcx)
	movdqu	%xmm13,0xd0(%rcx)
	movdqu	%xmm14,0xe0(%rcx)
	movdqu	%xmm15,0xf0(%rcx)
	movl	\$0,%eax
	ret
	.seh_endproc

	.globl  __ljfault
	.seh_proc __ljfault
__ljfault:
	movq	0x8(%rcx),%rbx
	movq	0x10(%rcx),%rsp
	movq	0x18(%rcx),%rbp
	movq	0x20(%rcx),%rsi
	movq	0x28(%rcx),%rdi
	movq	0x30(%rcx),%r12
	movq	0x38(%rcx),%r13
	movq	0x40(%rcx),%r14
	movq	0x48(%rcx),%r15
	movq	0x50(%rcx),%r10
	movq	%r10,(%rsp)
	# jmp_buf is potentially unaligned!
	movdqu	0x60(%rcx),%xmm6
	movdqu	0x70(%rcx),%xmm7
	movdqu	0x80(%rcx),%xmm8
	movdqu	0x90(%rcx),%xmm9
	movdqu	0xa0(%rcx),%xmm10
	movdqu	0xb0(%rcx),%xmm11
	movdqu	0xc0(%rcx),%xmm12
	movdqu	0xd0(%rcx),%xmm13
	movdqu	0xe0(%rcx),%xmm14
	movdqu	0xf0(%rcx),%xmm15
	movl	%edx,%eax
	testl	%eax,%eax
	jne	0f
	incl	%eax
0:	ret
	.seh_endproc

	.globl  longjmp
	.seh_proc longjmp
longjmp:
	pushq	%rcx
	.seh_pushreg %rcx
	.seh_endprologue
	movl	%edx,%r12d			# save return value (r12 is overwritten anyway)
	call	stabilize_sig_stack		# returns tls in r11
	popq	%rcx
	movl	%r12d,%eax			# restore return value
	movq	0x58(%rcx),%r10			# get old signal stack
	movq	%r10,$tls::stackptr(%r11)	# restore
	decl	$tls::stacklock(%r11)		# relinquish lock
	xorl	%r10d,%r10d
	movl	%r10d,$tls::incyg(%r11)		# we're definitely not in cygwin anymore
	movq	0x8(%rcx),%rbx
	movq	0x10(%rcx),%rsp
	movq	0x18(%rcx),%rbp
	movq	0x20(%rcx),%rsi
	movq	0x28(%rcx),%rdi
	movq	0x30(%rcx),%r12
	movq	0x38(%rcx),%r13
	movq	0x40(%rcx),%r14
	movq	0x48(%rcx),%r15
	movq	0x50(%rcx),%r10
	movq	%r10,(%rsp)
	# jmp_buf is potentially unaligned!
	movdqu	0x60(%rcx),%xmm6
	movdqu	0x70(%rcx),%xmm7
	movdqu	0x80(%rcx),%xmm8
	movdqu	0x90(%rcx),%xmm9
	movdqu	0xa0(%rcx),%xmm10
	movdqu	0xb0(%rcx),%xmm11
	movdqu	0xc0(%rcx),%xmm12
	movdqu	0xd0(%rcx),%xmm13
	movdqu	0xe0(%rcx),%xmm14
	movdqu	0xf0(%rcx),%xmm15
	testl	%eax,%eax
	jne	0f
	incl	%eax
0:	ret
	.seh_endproc
EOF
    } else {
	return <<EOF;

	.globl	_setjmp
_setjmp:
	pushl	%ebp
	movl	%esp,%ebp
	pushl	%edi
	movl	8(%ebp),%edi
	movl	%eax,0(%edi)
	movl	%ebx,4(%edi)
	movl	%ecx,8(%edi)
	movl	%edx,12(%edi)
	movl	%esi,16(%edi)
	movl	-4(%ebp),%eax
	movl	%eax,20(%edi)
	movl	0(%ebp),%eax
	movl	%eax,24(%edi)
	movl	%esp,%eax
	addl	\$12,%eax
	movl	%eax,28(%edi)
	movl	4(%ebp),%eax
	movl	%eax,32(%edi)
	movw	%es,%ax
	movw	%ax,36(%edi)
	movw	%fs,%ax
	movw	%ax,38(%edi)
	movw	%gs,%ax
	movw	%ax,40(%edi)
	movw	%ss,%ax
	movw	%ax,42(%edi)
	movl	%fs:0,%eax
	movl	%eax,44(%edi)
	fnstcw  48(%edi)
	pushl	%ebx
	call	stabilize_sig_stack
	movl	$tls::stackptr(%ebx),%eax		# save stack pointer contents
	decl	$tls::stacklock(%ebx)
	popl	%ebx
	movl	%eax,52(%edi)
	popl	%edi
	movl	\$0,%eax
	leave
	ret

	.globl	___sjfault
___sjfault:
	pushl	%ebp
	movl	%esp,%ebp
	pushl	%edi
	movl	8(%ebp),%edi
	movl	%eax,0(%edi)
	movl	%ebx,4(%edi)
	movl	%ecx,8(%edi)
	movl	%edx,12(%edi)
	movl	%esi,16(%edi)
	movl	-4(%ebp),%eax
	movl	%eax,20(%edi)
	movl	0(%ebp),%eax
	movl	%eax,24(%edi)
	movl	%esp,%eax
	addl	\$12,%eax
	movl	%eax,28(%edi)
	movl	4(%ebp),%eax
	movl	%eax,32(%edi)
	movw	%es,%ax
	movw	%ax,36(%edi)
	movw	%fs,%ax
	movw	%ax,38(%edi)
	movw	%gs,%ax
	movw	%ax,40(%edi)
	movw	%ss,%ax
	movw	%ax,42(%edi)
	movl	%fs:0,%eax
	movl	%eax,44(%edi)
	popl	%edi
	movl	\$0,%eax
	leave
	ret

	.global	___ljfault
___ljfault:
	pushl	%ebp
	movl	%esp,%ebp
	movl	8(%ebp),%edi

	movl	12(%ebp),%eax
	testl	%eax,%eax
	jne	0f
	incl	%eax

0:	movl	%eax,0(%edi)
	movl	24(%edi),%ebp
	pushfl
	popl	%ebx
	movl	44(%edi),%eax
	movl	%eax,%fs:0
	movw	42(%edi),%ax
	movw	%ax,%ss
	movl	28(%edi),%esp
	pushl	32(%edi)
	pushl	%ebx
	movw	36(%edi),%ax
	movw	%ax,%es
	movw	40(%edi),%ax
	movw	%ax,%gs
	movl	0(%edi),%eax
	movl	4(%edi),%ebx
	movl	8(%edi),%ecx
	movl	16(%edi),%esi
	movl	12(%edi),%edx
	movl	20(%edi),%edi
	popfl
	ret

	.globl	_longjmp
_longjmp:
	pushl	%ebp
	movl	%esp,%ebp
	movl	8(%ebp),%edi				# address of buffer
	call	stabilize_sig_stack
	movl	52(%edi),%eax				# get old signal stack
	movl	%eax,$tls::stackptr(%ebx)		# restore
	decl	$tls::stacklock(%ebx)			# relinquish lock
	xorl	%eax,%eax
	movl	%eax,$tls::incyg(%ebx)			# we're definitely not in cygwin anymore

	movl	12(%ebp),%eax
	testl	%eax,%eax
	jne	3f
	incl	%eax

3:	movl	%eax,0(%edi)
	movl	24(%edi),%ebp
	pushfl
	popl	%ebx
	fninit
	fldcw   48(%edi)
	movl	44(%edi),%eax
	movl	%eax,%fs:0
	movw	42(%edi),%ax
	movw	%ax,%ss
	movl	28(%edi),%esp
	pushl	32(%edi)
	pushl	%ebx
	movw	36(%edi),%ax
	movw	%ax,%es
	movw	40(%edi),%ax
	movw	%ax,%gs
	movl	0(%edi),%eax
	movl	4(%edi),%ebx
	movl	8(%edi),%ecx
	movl	16(%edi),%esi
	movl	12(%edi),%edx
	movl	20(%edi),%edi
	popfl
	ret
EOF
    }
}

sub cleanup(@@) {
    grep {s/\r//og; s/#.*//og; s/\s+\n//sog; !/^$/o && $_} @@_;
}
@


1.58
log
@	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.
@
text
@d2 2
a3 2
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2013, 2014
# Red Hat, Inc.
d167 1
@


1.57
log
@	* gendef (sigdelayed): 64 bit only: Push CPU flags before aligning
	stack to avoid changing flag values.
@
text
@a189 1
	.seh_pushreg %rbp
d191 1
a191 1
	.seh_pushreg %rbp
d195 1
a196 1
	pushf
@


1.56
log
@	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d190 1
d196 2
d230 2
a231 3
	pushf
	subq	\$0x130,%rsp
	.seh_stackalloc 0x130
d293 1
a293 2
	addq	\$0x130,%rsp
	popf
d308 2
@


1.55
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@a183 2
	leaq	$tls::pathbufs(%r10),%r10	# Address of tls_pathbufs
	movq	\$0,(%r10)			# Set c_cnt and w_cnt to 0
a447 3
	leal	$tls::pathbufs(%ebx),%ebx	# Address of tls_pathbufs
	movl	\$0,(%ebx)			# Set c_cnt to 0
	movl	\$0,4(%ebx)			# Set w_cnt to 0
@


1.54
log
@	* gendef (_sigbe/x86_64): Fix typo in .seh_proc pseudo-op.
	(setjmp/x86_64): Drop storing ExceptionList pointer in jmp_buf->Frame.
	Drop comment.  Store likely frame in rdx.  Jump to __setjmpex.
	(__setjmpex): New function providing setjmp functionality.  Fetch
	jmp_buf->Frame from rdx, like MSVCRT setjmpex.
	(__sjfault/x86_64): Store rdx content in jmp_buf->Frame.
	(__ljfault/x86_64): Don't restore ExceptionList pointer.
	(longjmp/x86_64): Ditto.
@
text
@d2 1
a2 1
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2013
d184 2
d371 1
a371 1
	movl	%r10d,$tls::spinning(%r12)		# flag if we are waiting for lock
d379 3
a381 3
	decl	$tls::stacklock(%r12)			# unlock
	movq	\$$tls::start_offset,%rcx		# point to beginning
	addq	%r12,%rcx				#  of tls block
d386 1
a386 1
	movq	%r12,%r11				# return tls addr in r11
d398 5
a402 5
	movl	%fs:4,%ebx				# location of bottom of stack
	addl	\$$tls::initialized,%ebx		# where we will be looking
	cmpl	%ebx,%esp				# stack loc > than tls
	jge	0f					# yep.  we don't have a tls.
	subl	\$$tls::initialized,%ebx		# where we will be looking
d404 1
a404 1
	cmpl	\$0xc763173f,%eax			# initialized?
d413 13
a425 13
	movl	%fs:4,%ebx				# location of bottom of stack
1:	movl	\$1,%eax				# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)		# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)		# flag if we are waiting for lock
	testl	%eax,%eax				# it will be zero
	jz	2f					#  if so
	call	_yield					# should be a short-time thing, so
	jmp	1b					# sleep and loop
2:	movl	\$4,%eax				# have the lock, now increment the
	xadd	%eax,$tls::stackptr(%ebx)		#  stack pointer and get pointer
	leal	__sigbe,%edx				# new place to return to
	xchgl	%edx,12(%esp)				# exchange with real return value
	movl	%edx,(%eax)				# store real return value on alt stack
d427 2
a428 2
	decl	$tls::stacklock(%ebx)			# remove lock
	popl	%edx					# restore saved value
d433 15
a447 15
__sigbe:						# return here after cygwin syscall
	pushl	%eax					# don't clobber
	pushl	%ebx					# tls pointer
1:	movl	%fs:4,%ebx				# address of bottom of tls
	movl	\$1,%eax				# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)		# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)		# flag if we are waiting for lock
	testl	%eax,%eax				# it will be zero
	jz	2f					#  if so
	call	_yield					# sleep
	jmp	1b					#  and loop
2:	movl	\$-4,%eax				# now decrement aux stack
	xadd	%eax,$tls::stackptr(%ebx)		#  and get pointer
	movl	-4(%eax),%eax				# get return address from signal stack
	xchgl	%eax,4(%esp)				# swap return address with saved eax
d449 4
a452 1
	decl	$tls::stacklock(%ebx)			# release lock
@


1.53
log
@* gendef (_setjmp (x86)): Save FPU control word location in sequential
location.  Adjust sigstack save accordingly.
(_longjmp (x86)): Ditto for restore.
@
text
@d167 1
a167 1
	.seh_proc _sigfe
d592 9
a600 1
	# We use the Windows jmp_buf layout.  Store ExceptionList in Frame.
d602 1
a602 2
	movq	%gs:0,%r10
	movq	%r10,(%rcx)
d641 1
a641 2
	movq	%gs:0,%r10
	movq	%r10,(%rcx)
a670 2
	movq	(%rcx),%r10
	movq	%r10,%gs:0
a714 2
	movq	(%rcx),%r10
	movq	%r10,%gs:0
@


1.53.2.1
log
@2014-03-28  Corinna Vinschen  <corinna@@vinschen.de>

	* sec_auth.cc (create_token): Initialize lsa handle to NULL, rather than
	to INVALID_HANDLE_VALUE.
	(lsaauth): Ditto.
	(lsaprivkeyauth): Ditto.
	* setlsapwd.cc (setlsapwd): Don't initialize lsa handle.

2014-03-28  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (_cygtls::signal_debugger): Move memcpy to copy context
	from incoming siginfo_t to thread_context, too.

2014-03-27  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (_sigbe/x86_64): Fix typo in .seh_proc pseudo-op.
	(setjmp/x86_64): Drop storing ExceptionList pointer in jmp_buf->Frame.
	Drop comment.  Store likely frame in rdx.  Jump to __setjmpex.
	(__setjmpex): New function providing setjmp functionality.  Fetch
	jmp_buf->Frame from rdx, like MSVCRT setjmpex.
	(__sjfault/x86_64): Store rdx content in jmp_buf->Frame.
	(__ljfault/x86_64): Don't restore ExceptionList pointer.
	(longjmp/x86_64): Ditto.
@
text
@d167 1
a167 1
	.seh_proc _sigbe
d592 1
a592 9
	leaq	8(%rsp),%rdx
	jmp	__setjmpex
	.seh_endproc

	.globl	__setjmpex
	.seh_proc __setjmpex
__setjmpex:
	.seh_endprologue
	# We use the Windows jmp_buf layout.
d594 2
a595 1
	movq	%rdx,(%rcx)
d634 2
a635 1
	movq	%rdx,(%rcx)
d665 2
d711 2
@


1.53.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d2 1
a2 1
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2013, 2014
d191 1
a191 1
	.seh_pushreg %r10
a194 2
	pushf
	.seh_pushreg %rax			# fake, there's no .seh_pushreg for the flags
d227 3
a229 2
	subq	\$0x128,%rsp
	.seh_stackalloc 0x128
d291 2
a292 1
	addq	\$0x128,%rsp
a306 2
	subq	\$8, %rsp
	popf
d369 1
a369 1
	movl	%r10d,$tls::spinning(%r12)	# flag if we are waiting for lock
d377 3
a379 3
	decl	$tls::stacklock(%r12)		# unlock
	movq	\$$tls::start_offset,%rcx	# point to beginning
	addq	%r12,%rcx			#  of tls block
d384 1
a384 1
	movq	%r12,%r11			# return tls addr in r11
d396 5
a400 5
	movl	%fs:4,%ebx			# location of bottom of stack
	addl	\$$tls::initialized,%ebx	# where we will be looking
	cmpl	%ebx,%esp			# stack loc > than tls
	jge	0f				# yep.  we don't have a tls.
	subl	\$$tls::initialized,%ebx	# where we will be looking
d402 1
a402 1
	cmpl	\$0xc763173f,%eax		# initialized?
d411 13
a423 13
	movl	%fs:4,%ebx			# location of bottom of stack
1:	movl	\$1,%eax			# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)	# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)	# flag if we are waiting for lock
	testl	%eax,%eax			# it will be zero
	jz	2f				#  if so
	call	_yield				# should be a short-time thing, so
	jmp	1b				# sleep and loop
2:	movl	\$4,%eax			# have the lock, now increment the
	xadd	%eax,$tls::stackptr(%ebx)	#  stack pointer and get pointer
	leal	__sigbe,%edx			# new place to return to
	xchgl	%edx,12(%esp)			# exchange with real return value
	movl	%edx,(%eax)			# store real return value on alt stack
d425 2
a426 2
	decl	$tls::stacklock(%ebx)		# remove lock
	popl	%edx				# restore saved value
d431 15
a445 15
__sigbe:					# return here after cygwin syscall
	pushl	%eax				# don't clobber
	pushl	%ebx				# tls pointer
1:	movl	%fs:4,%ebx			# address of bottom of tls
	movl	\$1,%eax			# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)	# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)	# flag if we are waiting for lock
	testl	%eax,%eax			# it will be zero
	jz	2f				#  if so
	call	_yield				# sleep
	jmp	1b				#  and loop
2:	movl	\$-4,%eax			# now decrement aux stack
	xadd	%eax,$tls::stackptr(%ebx)	#  and get pointer
	movl	-4(%eax),%eax			# get return address from signal stack
	xchgl	%eax,4(%esp)			# swap return address with saved eax
d447 1
a447 1
	decl	$tls::stacklock(%ebx)		# release lock
@


1.52
log
@	* gendef (sigdelayed (x86_64)): Save and restore FPU control word.
	(_sigdelayed (x86)): Ditto.  Save and restore XMM registers.  Add
	comment.
	(_setjmp (x86)): Save FPU control word, following FreeBSD here.
	(_longjmp (x86)): Restore FPU control word.
@
text
@d774 1
a774 1
	fnstcw	56(%edi)
d780 1
a780 1
	movl	%eax,48(%edi)
d862 1
a862 1
	movl	48(%edi),%eax				# get old signal stack
d878 1
a878 1
	fldcw	56(%edi)
@


1.51
log
@	* dll_init.cc (dll_list::topsort): Fix early-return condition to
	accommodate process with all runtime loaded DLLs already dlclosed
	at fork time.
	* gendef (_sigfe_maybe): Fix code handling early return if we don't
	have a tls, broken on 2013-05-21.
@
text
@d228 3
a230 2
	subq	\$0x120,%rsp
	.seh_stackalloc 0x120
d289 3
a291 1
	addq	\$0x120,%rsp
d455 2
d464 10
d498 1
a498 1
	xchgl	%ebp,28(%esp)				# store real return address
d503 11
d774 1
d877 2
@


1.50
log
@	x86_64 only:
	* gendef (_sigfe_maybe): Drop pushing %r12, use %r10 instead since we
	don't call yield anymore.
	(_sigfe): Ditto.
	(_sigbe): Ditto.
@
text
@d136 3
a138 4
	addq	\$$tls::initialized,%r10	# where we will be looking
	cmpq	%r10,%rsp			# stack loc > than tls
	ret					#  yep.  we don't have a tls.
	subq	\$$tls::initialized,%r10	# where we will be looking
d142 1
@


1.49
log
@* gendef: Fix sigfe.s typo.
@
text
@d133 1
a133 3
_sigfe_maybe:
	pushq	%r12
	.seh_pushreg %r12
d135 6
a140 6
	movq	%gs:8,%r12			# location of bottom of stack
	addq	\$$tls::initialized,%r12	# where we will be looking
	cmpq	%r12,%rsp			# stack loc > than tls
	jge	0f				#  yep.  we don't have a tls.
	subq	\$$tls::initialized,%r12	# where we will be looking
	movl	$tls::initialized(%r12),%r11d
a142 3
0:
	popq	%r12
	ret
a146 2
	pushq	%r12
	.seh_pushreg %r12
d148 1
a148 1
	movq	%gs:8,%r12			# location of bottom of stack
d150 2
a151 2
	xchgl	%r11d,$tls::stacklock(%r12)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r12)	# flag if we are waiting for lock
d157 1
a157 1
	xaddq	%rax,$tls::stackptr(%r12)	#  stack pointer and get pointer
d159 1
a159 1
	xchgq	%r11,16(%rsp)			# exchange with real return value
d161 2
a162 3
	incl	$tls::incyg(%r12)
	decl	$tls::stacklock(%r12)		# remove lock
	popq	%r12				# restore saved value
a169 2
	pushq	%r12
	.seh_pushreg %r12
d171 1
a171 1
	movq	%gs:8,%r12			# address of bottom of tls
d173 2
a174 2
	xchgl	%r11d,$tls::stacklock(%r12)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r12)	# flag if we are waiting for lock
d180 1
a180 1
	xaddq	%r11,$tls::stackptr(%r12)	#  and get pointer
d182 2
a183 3
	decl	$tls::incyg(%r12)
	decl	$tls::stacklock(%r12)		# release lock
	popq	%r12
@


1.48
log
@* i686.din: New file.
* x86_64.din: New file.
* common.din: New file.
* cygwin.din: Delete.
* cygwin64.din: Delete.
* gendef: Rework to take options rather than using positional parameters.
Accept multiple files as input.
@
text
@d85 1
a85 1
open SIGFE, '>', 'sigfe.h' or die "$0: couldn't open 'sigfe.h' file for writing - $!\n";
@


1.47
log
@	* Merge in cygwin-64bit-branch.
@
text
@d12 3
d17 4
a20 5
my $in = shift;
my $tls_offsets = shift;
my $cpu = shift;
my $out = shift;
my $sigfe = shift;
d23 2
a24 2
if (!defined($in) || !defined($cpu) || !defined($out) || !defined($sigfe)) {
    die "usage: $0 deffile.in cygtls.h target-cpu deffile.def sigfe.s\n";
d29 2
a30 2
my $is64bit = ($cpu eq 'x86_64' ? 1 : 0);
my $sym_prefix = ($is64bit ? '' : '_');
a31 1
open(IN, $in) or die "$0: couldn't open \"$in\" - $!\n";
d33 1
a33 1
while (<IN>) {
d35 1
a35 1
    last if /^\s*exports$/i;
d37 1
a37 2
my @@in = cleanup <IN>;
close(IN);
d80 1
a80 1
open(OUT, '>', $out) or die "$0: couldn't open \"$out\" - $!\n";
d85 1
a85 1
open(SIGFE, '>', $sigfe) or die "$0: couldn't open sigfe file \"$sigfe\" - $!\n";
d885 1
a885 3
    map {s/\r//g; $_} @@_;
    map {s/#.*//g; $_} @@_;
    map {s/[ \t]+$//g; $_} @@_;
@


1.46
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d16 1
d21 2
a22 2
if (!defined($in) || !defined($out) || !defined($sigfe)) {
    die "usage: $0 deffile.in cygtls.h deffile.def sigfe.s\n";
d27 3
d54 1
a54 1
	    my $maybe = lc $1 . '_';
d93 8
a100 3
    my $func = '_' . shift;
    my $fe = '_' . shift;
    my $sigfe_func = ($fe =~ /^(.*)$func/)[0];
d102 3
a104 1
    my $res = <<EOF;
d107 1
d109 4
a112 1
	pushl	\$$func
d114 10
d126 1
d128 271
a398 1
	$res = <<EOF . longjmp () . $res;
d564 1
d570 158
a727 1
    return <<EOF;
d881 1
@


1.45
log
@* cygtls.h (_cygtls::get_signal_arrived): Add parameter to make lock/unlock
conditional.
* exceptions.cc (_cygtls::interrupt_setup): Don't get a lock when setting
signal_arrived since we already have one.
* gendef: Add some comments to make it easier to find functions.
@
text
@d2 2
a3 1
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d179 1
a179 1
	call	__ZN7_cygtls19call_signal_handlerEv	# call handler
d212 2
a213 2
	.global __ZN7_cygtls3popEv
__ZN7_cygtls3popEv:
d223 2
a224 2
	.global	__ZN7_cygtls4lockEv
__ZN7_cygtls4lockEv:
d237 2
a238 2
	.global	__ZN7_cygtls6unlockEv
__ZN7_cygtls6unlockEv:
d247 1
a247 1
	.extern	__ZN7_cygtls19call_signal_handlerEv
d263 1
a263 1
	call	__ZN7_cygtls19call_signal_handlerEv
@


1.44
log
@* gendef: Tighten up whitespace detection.
@
text
@d221 1
d235 1
@


1.43
log
@* gendef: Delete unneeded read from <IN> which ate an arbitrary line from
cygwin.din.
@
text
@d29 1
a29 1
    last if /^\s*exports\s*$/i;
d40 1
a40 1
    s/\sDATA$//o and do {
d47 1
a47 1
	} elsif (s/ SIGFE(_MAYBE)?$//) {
d70 1
a70 1
    my ($alias, $func) = /^(\S+) = (\S+)\s*$/o;
@


1.42
log
@* exceptions.cc (sigdelayed): Move declaration to sigproc.h.
* sigproc.h (sigdelayed): Make symbol globally available.
* gendef (sigdelayed): Specifically zero incyg and stacklock.
* signal.cc (sigwaitinfo): Lock _my_tls and try harder to clean up signal
information.
@
text
@d2 1
a2 1
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010 Red Hat, Inc.
a30 1
my $libline = cleanup scalar(<IN>);
@


1.41
log
@* cygtls.cc (_cygtls::reset_signal_arrived): New function.
(set_signal_arrived::~set_signal_arrived): Use reset_signal_arrived to reset
state.
* exceptions.cc (sig_handle_tty_stop): Use WAIT_SIGNALED rather than assume we
know the return from cancelable_wait.
(_cygtls::interrupt_setup): Modify to allow calling when executing in
non-cygwin code via sigdelayed.  Always reset signal_arrived.
* gendef: Throughout use start_offset rather than the completely wrong
sizeof__cygtls.
(_sigdelayed): Rewrite to avoid duplication when calling the signal handler.
(sigreturn): Delete.
* gentls_offsets: Define start_offset rather than sizeof__cygtls.
* tlsoffsets.h: Regenerate.
@
text
@d199 3
a201 2
leave:	decl	$tls::incyg(%ebx)
	decl	$tls::stacklock(%ebx)			# unlock
@


1.41.2.1
log
@Pull in changes from HEAD
@
text
@d2 1
a2 1
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d29 1
a29 1
    last if /^\s*exports$/i;
d31 1
d41 1
a41 1
    s/\s+DATA$//o and do {
d48 1
a48 1
	} elsif (s/\s+SIGFE(_MAYBE)?$//) {
d71 1
a71 1
    my ($alias, $func) = /^(\S+)\s+=\s+(\S+)\s*$/o;
d199 2
a200 3
leave:	xorl	%eax,%eax
	movl	%eax,$tls::incyg(%ebx)
	movl	%eax,$tls::stacklock(%ebx)		# unlock
@


1.41.2.2
log
@Pull in changes from HEAD
@
text
@a220 1
# _cygtls::lock
a233 1
# _cygtls::unlock
@


1.41.2.3
log
@Pull in changes from HEAD
@
text
@d2 1
a2 2
# Copyright 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2013
# Red Hat, Inc.
d178 1
a178 1
	call	__ZN7_cygtls19call_signal_handlerEv\@@4	# call handler
d211 2
a212 2
	.global __ZN7_cygtls3popEv\@@4
__ZN7_cygtls3popEv\@@4:
d222 2
a223 2
	.global	__ZN7_cygtls4lockEv\@@4
__ZN7_cygtls4lockEv\@@4:
d236 2
a237 2
	.global	__ZN7_cygtls6unlockEv\@@4
__ZN7_cygtls6unlockEv\@@4:
d246 1
a246 1
	.extern	__ZN7_cygtls19call_signal_handlerEv\@@4
d262 1
a262 1
	call	__ZN7_cygtls19call_signal_handlerEv\@@4
@


1.41.2.4
log
@	* Makefile.in (speclib): Exclude main symbol.
	(NEW_FUNCTIONS): Set to empty for x86_64.
	($(DEF_FILE)): Call gendef with target_alias as additional parameter.
	* configure.ac (DLL_ENTRY): Drop leading underscore for x86_64.
	* configure: Regenerate.
	* cygwin.sc.in: Drop _SYM usage for __data_start__, __data_end__,
	__bss_start__, and __bss_end__.
	* cygwin64.din: Remove all fast-call math function entry points.
	(_alloca): Define as __alloca.
	(_dll_crt0): Drop 32 bit stdcall specifier.
	(dll_entry): Ditto.
	(dll_noncygwin_dllcrt0): Remove.
	(getpwduid): Remove.
	(lacl): Remove.
	* dcrt0.cc (dll_data_start): Define for x86_64.
	(dll_data_end): Ditto.
	(dll_bss_start): Ditto.
	(dll_bss_end): Ditto.
	* gendef: Handle new target argument.  Handle 64 bit target.
	Add preliminiary empty function definitions for 64 bit to allow linking.
	* winsup.h: Define linker data and bss section symbols with
	additional underscore for x86_64.
	* lib/_cygwin_crt0_common.cc (__image_base__): Define for 64 bit and
	map to _image_base__ via macro.
	(_cygwin_crt0_common): Fix setting data and bss section borders on
	x86_64.
@
text
@d1 1
a1 1
#!/usr/bin/perl -w
a15 1
my $target = shift;
d20 2
a21 2
if (!defined($in) || !defined($target) || !defined($out) || !defined($sigfe)) {
    die "usage: $0 deffile.in cygtls.h target-triplet deffile.def sigfe.s\n";
a25 3
my $is64bit = ($target =~ /^x86_64\-/ ? 1 : 0);
my $sym_prefix = ($is64bit ? '' : '_');

d89 3
a91 8
    my $func = $sym_prefix . shift;
    my $fe = $sym_prefix . shift;
    my $sigfe_func;
    if ($is64bit) {
	$sigfe_func = ($fe =~ /^(.*)_${func}$/)[0];
    } else {
	$sigfe_func = ($fe =~ /^(.*)${func}$/)[0];
    }
d97 1
a97 1
	push	\$$func
d102 1
a102 42
	if ($is64bit) {
	  $res = <<EOF . longjmp () . $res;
	.text

_sigfe_maybe:
	ret

_sigfe:
	ret

_sigbe:
	ret

	.global	sigdelayed
sigdelayed:
	ret

# _cygtls::pop
	.global _ZN7_cygtls3popEv
_ZN7_cygtls3popEv:
	ret

# _cygtls::lock
	.global _ZN7_cygtls4lockEv
_ZN7_cygtls4lockEv:
	ret

# _cygtls::unlock
	.global _ZN7_cygtls6unlockEv
_ZN7_cygtls6unlockEv:
	ret

# _cygtls::locked
	.global _ZN7_cygtls6lockedEv
_ZN7_cygtls6lockedEv:
	ret

stabilize_sig_stack:
	ret
EOF
	} else {
	  $res = <<EOF . longjmp () . $res;
a267 1
	}
d273 1
a273 21
    if ($is64bit) {
	return <<EOF;

	.globl  setjmp
setjmp:
	ret

	.globl  __sjfault
__sjfault:
	ret

	.globl  __ljfault
__ljfault:
	ret

	.globl  longjmp
longjmp:
	ret
EOF
    } else {
	return <<EOF;
a426 1
    }
@


1.41.2.5
log
@	* gendef: First cut 64 bit assembler functionality, untested.
@
text
@a115 10
	pushq	%r12
	movq	%gs:8,%r12			# location of bottom of stack
	addq	\$$tls::initialized,%r12	# where we will be looking
	cmpq	%r12,%rsp			# stack loc > than tls
	jge	0f				# yep.  we don't have a tls.
	subq	\$$tls::initialized,%r12	# where we will be looking
	movl	$tls::initialized(%r12),%r11d
	cmpl	\$0xc763173f,%r11d		# initialized?
	je	1f
0:
d119 4
a122 45
	pushq	%r12
	movq	%gs:8,%r12			# location of bottom of stack
1:	movl	\$1,%r11d			# potential lock value
	xchgl	%r11d,$tls::stacklock(%r12)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r12)	# flag if we are waiting for lock
	testl	%r11d,%r11d			# it will be zero
	jz	2f				#  if so
	subq	\$40,%rsp			# Align stack
	call	yield				# should be a short-time thing, so
	nop
	addq	\$40,%rsp			# Revert stack
	jmp	1b				# sleep and loop
2:	movq	\$8,%rax			# have the lock, now increment the
	xaddq	%rax,$tls::stackptr(%r12)	#  stack pointer and get pointer
	leaq	_sigbe,%r11			# new place to return to
	xchgq	%r11,8(%rsp)			# exchange with real return value
	movq	%r11,(%rax)			# store real return value on alt stack
	incl	$tls::incyg(%r12)
	decl	$tls::stacklock(%r12)		# remove lock
	popq	%r12				# restore saved value
	popq	%rax				# pop real function address from stack
	jmp	*%rax				# and jmp to it

_sigbe:						# return here after cygwin syscall
	pushq	%rax				# don't clobber
	pushq	%r12				# tls pointer
	movq	%gs:8,%r12			# address of bottom of tls
1:	movl	\$1,%r11d			# potential lock value
	xchgl	%r11d,$tls::stacklock(%r12)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r12)	# flag if we are waiting for lock
	testl	%r11d,%r11d			# it will be zero
	jz	2f				#  if so
	subq	\$40,%rsp			# Align stack
	call	yield				# sleep
	nop
	addq	\$40,%rsp			# Revert stack
	jmp	1b				#  and loop
2:	movq	\$-8,%r11			# now decrement aux stack
	xaddq	%r11,$tls::stackptr(%r12)	#  and get pointer
	movq	-8(%r11),%r11			# get return address from signal stack
	decl	$tls::incyg(%r12)
	decl	$tls::stacklock(%r12)		# release lock
	popq	%r12
	popq	%rax				# restore return value
	jmp	*%r11				# "return" to caller
d126 1
a126 57
	pushq	%rbp
	movq	%rsp,%rbp
	pushf
	pushq	%r15
	pushq	%r14
	pushq	%r13
	pushq	%r12
	pushq	%r9
	pushq	%r8
	pushq	%rsi
	pushq	%rdi
	pushq	%rdx
	pushq	%rcx
	pushq	%rbx
	pushq	%rax
	subq	\$40,%rsp

	movq	%gs:8,%r12			# get tls
	movl	$tls::saved_errno(%r12),%r15d	# temorarily save saved_errno
	movq	\$$tls::start_offset,%rcx	# point to beginning of tls block
	addq	%r12,%rcx			#  and store as first arg to method
	call	_ZN7_cygtls19call_signal_handlerEv	# call handler

1:	movl	\$1,%r11d			# potential lock value
	xchgl	%r11d,$tls::stacklock(%r12)	# see if we can grab it
	movl	%r11d,$tls::spinning(%r12)	# flag if we are waiting for lock
	testl	%r11d,%r11d			# it will be zero
	jz	2f				#  if so
	call	yield				# sleep
	jmp	1b				#  and loop
2:	testl	%r15d,%r15d			# was saved_errno < 0
	jl	3f				# yup.  ignore it
	movq	$tls::errno_addr(%r12),%r11
	movl	%r15d,(%r11)
3:	movq	\$-8,%r11			# now decrement aux stack
	xaddq	%r11,$tls::stackptr(%r12)	#  and get pointer
	xorq	%r10,%r10
	xchgq	%r10,-8(%r11)			# get return address from signal stack
	xorl	%r11d,%r11d
	movl	%r11d,$tls::incyg(%r12)
	movl	%r11d,$tls::stacklock(%r12)	# unlock
	addq	\$40,%rsp
	popq	%rax
	popq	%rbx
	popq	%rcx
	popq	%rdx
	popq	%rdi
	popq	%rsi
	popq	%r8
	popq	%r9
	popq	%r12
	popq	%r13
	popq	%r14
	popq	%r15
	popf
	popq	%rbp
	jmp	*%r10
a130 3
	movq	\$-8,%r11
	xaddq	%r11,$tls::pstackptr(%rcx)
	movq	-8(%r11),%rax
a135 11
	pushq	%r12
	subq	\$32,%rsp
	movq	%rcx,%r12
1:	movl	\$1,%r11d
	xchgl	%r11d,$tls::pstacklock(%r12)
	testl   %r11d,%r11d
	jz	2f
	call	yield
	jmp	1b
2:	subq	\$32,%rsp
	popq	%r12
@


1.41.2.6
log
@	* cygwin.sc.in: Accommodate extra .text, .pdata, and .xdata section on 64 bit.
	* cygwin64.din: Set BASE to 0x200040000 to start shared sections at 0x200000000.
	* gendef: Second cut 64 bit assembler functionality, still untested.
@
text
@d106 1
a106 2
	leaq	$func(%rip),%r10
	pushq	%r10
d120 1
a120 1
	jge	0f				#  yep.  we don't have a tls.
a125 1
	popq	%r12
d143 1
a143 1
	leaq	_sigbe(%rip),%r11		# new place to return to
d179 1
d184 2
d188 2
d192 1
a192 1
	subq	\$32,%rsp
d218 1
a218 1
	addq	\$32,%rsp
d221 2
d225 2
d231 2
a232 1
	leave
a261 1
	decl	$tls::pstacklock(%rcx)
a266 1
	movl	$tls::pstacklock(%rcx),%eax
a269 21
	pushq	%r12
	subq	\$32,%rsp
	movq	%gs:8,%r12
1:	movl	\$1,%r10d
	xchgl	%r10d,$tls::stacklock(%r12)
	movl	%r10d,$tls::spinning(%r12)		# flag if we are waiting for lock
	testl	%r10d,%r10d
	jz	2f
	call	yield
	jmp	1b
2:	incl	$tls::incyg(%r12)
	cmpl	\$0,$tls::sig(%r12)
	jz	3f
	decl	$tls::stacklock(%r12)			# unlock
	movq	\$$tls::start_offset,%rcx		# point to beginning
	addq	%r12,%rcx				#  of tls block
	call	_ZN7_cygtls19call_signal_handlerEv
	jmp	1b
3:	decl	$tls::incyg(%r12)
	addq	\$32,%rsp
	popq	%r12
@


1.41.2.7
log
@	* gendef: Add missing setjmp/longjmp functionality, still untested.
@
text
@d140 1
d165 1
a177 1
	.seh_proc sigdelayed
a179 1
	.seh_pushreg %rbp
a180 1
	.seh_setframe %rbp,0
a181 1
	.seh_pushreg %r15
a182 1
	.seh_pushreg %r14
a183 1
	.seh_pushreg %r13
a184 1
	.seh_pushreg %r12
a185 1
	.seh_pushreg %rsi
a186 1
	.seh_pushreg %rdi
a187 1
	.seh_pushreg %rbx
a188 1
	.seh_pushreg %rax
a189 2
	.seh_stackalloc 32
	.seh_endprologue
d224 1
a224 1
	popq	%rbp
a225 1
	.seh_endproc
a228 1
	.seh_proc _ZN7_cygtls3popEv
a229 1
	.seh_endprologue
a233 1
	.seh_endproc
a236 1
	.seh_proc _ZN7_cygtls4lockEv
a238 1
	.seh_pushreg %r12
a239 2
	.seh_stackalloc 32
	.seh_endprologue
a249 1
	.seh_endproc
a252 1
	.seh_proc _ZN7_cygtls6unlockEv
a253 1
	.seh_endprologue
a255 1
	.seh_endproc
a258 1
	.seh_proc _ZN7_cygtls6lockedEv
a259 1
	.seh_endprologue
a261 1
	.seh_endproc
a262 1
	.seh_proc stabilize_sig_stack
a264 1
	.seh_pushreg %r12
a265 2
	.seh_stackalloc 32
	.seh_endprologue
a283 1
	movq	%r12,%r11				# return tls addr in r11
a285 1
	.seh_endproc
a463 1
	.seh_proc setjmp
a464 34
	.seh_endprologue
	# We use the Windows jmp_buf layout.  Store ExceptionList in Frame.
	# Store alternative stackptr in Spare.
	movq	%gs:0,%r10
	movq	%r10,(%rcx)
	movq	%rbx,8(%rcx)
	movq	%rsp,16(%rcx)
	movq	%rbp,24(%rcx)
	movq	%rsi,32(%rcx)
	movq	%rdi,40(%rcx)
	movq	%r12,48(%rcx)
	movq	%r13,56(%rcx)
	movq	%r14,64(%rcx)
	movq	%r15,72(%rcx)
	movq	(%rsp),%r10
	movq	%r10,80(%rcx)
	movaps	%xmm6,96(%rcx)
	movaps	%xmm7,112(%rcx)
	movaps	%xmm8,128(%rcx)
	movaps	%xmm9,144(%rcx)
	movaps	%xmm10,160(%rcx)
	movaps	%xmm11,176(%rcx)
	movaps	%xmm12,192(%rcx)
	movaps	%xmm13,208(%rcx)
	movaps	%xmm14,224(%rcx)
	movaps	%xmm15,240(%rcx)
	pushq	%rcx
	.seh_pushreg %rcx
	call	stabilize_sig_stack		# returns tls in r11
	popq	%rcx
	movq	$tls::stackptr(%r11),%r10
	movq	%r10,88(%ecx)
	decl	$tls::stacklock(%r11)
	movl	\$0,%eax
a465 1
	.seh_endproc
a467 1
	.seh_proc __sjfault
a468 26
	.seh_endprologue
	# Like setjmp, just w/o storing the alternate stackptr.
	movq	%gs:0,%r10
	movq	%r10,(%rcx)
	movq	%rbx,8(%rcx)
	movq	%rsp,16(%rcx)
	movq	%rbp,24(%rcx)
	movq	%rsi,32(%rcx)
	movq	%rdi,40(%rcx)
	movq	%r12,48(%rcx)
	movq	%r13,56(%rcx)
	movq	%r14,64(%rcx)
	movq	%r15,72(%rcx)
	movq	(%rsp),%r10
	movq	%r10,80(%rcx)
	movaps	%xmm6,96(%rcx)
	movaps	%xmm7,112(%rcx)
	movaps	%xmm8,128(%rcx)
	movaps	%xmm9,144(%rcx)
	movaps	%xmm10,160(%rcx)
	movaps	%xmm11,176(%rcx)
	movaps	%xmm12,192(%rcx)
	movaps	%xmm13,208(%rcx)
	movaps	%xmm14,224(%rcx)
	movaps	%xmm15,240(%rcx)
	movl	\$0,%eax
a469 1
	.seh_endproc
a471 1
	.seh_proc __ljfault
d473 1
a473 29
	movq	(%rcx),%r10
	movq	%r10,%gs:0
	movq	8(%rcx),%rbx
	movq	16(%rcx),%rsp
	movq	24(%rcx),%rbp
	movq	32(%rcx),%rsi
	movq	40(%rcx),%rdi
	movq	48(%rcx),%r12
	movq	56(%rcx),%r13
	movq	64(%rcx),%r14
	movq	72(%rcx),%r15
	movq	80(%rcx),%r10
	movq	%r10,(%rsp)
	movaps	96(%rcx),%xmm6
	movaps	112(%rcx),%xmm7
	movaps	128(%rcx),%xmm8
	movaps	144(%rcx),%xmm9
	movaps	160(%rcx),%xmm10
	movaps	176(%rcx),%xmm11
	movaps	192(%rcx),%xmm12
	movaps	208(%rcx),%xmm13
	movaps	224(%rcx),%xmm14
	movaps	240(%rcx),%xmm15
	movl	%edx,%eax
	testl	%eax,%eax
	jne	0f
	incl	%eax
0:	ret
	.seh_endproc
a475 1
	.seh_proc longjmp
d477 1
a477 40
	pushq	%rcx
	.seh_pushreg %rcx
	.seh_endprologue
	movq	%rdx,%r12			# save return value (r12 is overwritten anyway)
	call	stabilize_sig_stack		# returns tls in r11
	popq	%rcx
	movq	%r12,%rax			# restore return value
	movq	88(%rcx),%r10			# get old signal stack
	movq	%r10,$tls::stackptr(%r11)	# restore
	decl	$tls::stacklock(%r11)		# relinquish lock
	xorl	%r10d,%r10d
	movl	%r10d,$tls::incyg(%r11)		# we're definitely not in cygwin anymore
	movq	(%rcx),%r10
	movq	%r10,%gs:0
	movq	8(%rcx),%rbx
	movq	16(%rcx),%rsp
	movq	24(%rcx),%rbp
	movq	32(%rcx),%rsi
	movq	40(%rcx),%rdi
	movq	48(%rcx),%r12
	movq	56(%rcx),%r13
	movq	64(%rcx),%r14
	movq	72(%rcx),%r15
	movq	80(%rcx),%r10
	movq	%r10,(%rsp)
	movaps	96(%rcx),%xmm6
	movaps	112(%rcx),%xmm7
	movaps	128(%rcx),%xmm8
	movaps	144(%rcx),%xmm9
	movaps	160(%rcx),%xmm10
	movaps	176(%rcx),%xmm11
	movaps	192(%rcx),%xmm12
	movaps	208(%rcx),%xmm13
	movaps	224(%rcx),%xmm14
	movaps	240(%rcx),%xmm15
	testl	%eax,%eax
	jne	0f
	incl	%eax
0:	ret
	.seh_endproc
@


1.41.2.8
log
@	* Makefile.in (TEST_DLL_NAME): Fix to use correct name per target.
	* gendef (fefunc): Resurrect accidentally dropped 32 bit code.
@
text
@d102 1
a102 3
    my $res;
    if ($is64bit) {
	$res = <<EOF;
a110 10
    } else {
	$res = <<EOF;
        .extern $func
        .global $fe
$fe:
        pushl   \$$func
        jmp     $sigfe_func

EOF
    }
@


1.41.2.9
log
@	* Makefile.in ($(LIB_NAME)): Add --target option to mkimport call.
	* gendef: Drop -w option.  Make callto sigfe function pc-relative
	on x86_64.
	* miscfuncs.cc (__import_address): Drop comment and misguide attempt
	to handle absolute addressing in x86_64 mode.
	* mkimport: Add --target option.  Handle x86_64 target, especially
	create pc-relative jmp calls.
@
text
@d1 1
a1 1
#!/usr/bin/perl
d54 1
a54 1
	    my $maybe = (defined($1) ? lc $1 : '') . '_';
d110 1
a110 1
	jmp	*$sigfe_func(%rip)
@


1.41.2.10
log
@	* autoload.cc (LoadDLLfuncEx3): Adjust address computation required
	by latest change to the 64 bit code.
	* cygmalloc.h (MALLOC_ALIGNMENT): Set to 16 on x86_64.
	* cygtls.h: Set struct alignment to 8 on x86_64.  Move inclusion of
	other header files outside of alignment-enforced code area.  Drop
	inclusion of security.h entirely.
	(_cygtls::get_signal_arrived): Use NULL SECURITY_ATTRIBUTES rather than
	&sec_none_nih.
	* gendef (_cygtls::lock): Fix stack alignment.
	* heap.cc (page_const): Change type to ptrdiff_t, otherwise negation
	operator in pround creates broken bitmask.
	* shared.cc (page_const): Add cast to ptrdiff_t.
	* tlsoffsets64.h: Regenerate.
@
text
@d278 1
a278 1
2:	addq	\$32,%rsp
@


1.41.2.11
log
@	* gendef (fefunc): Fix incorrect pc-relative jmp instruction.
	(_sigfe): Fix offset to return address on stack.  Add and fix comments.
	(_sigbe): Fix stack alignment when creating spill area for call to
	yield.  Add and fix comments.
	(sigdelayed): Add fake push to make sure stack is aligned correctly.
	Use fake stack alignment on exit to store return address and call ret,
	rather than jmp.  Fix comments.
	(_cygtls::lock): Only create and destroy spill area when really calling
	yield.
@
text
@d110 1
a110 1
	jmp	$sigfe_func
d142 1
a142 1
_sigfe:						# stack is aligned on entry!
d150 1
a150 1
	subq	\$40,%rsp			# add spill and align stack
d152 1
a152 1
	addq	\$40,%rsp			# revert stack and
d157 1
a157 1
	xchgq	%r11,16(%rsp)			# exchange with real return value
a165 1
						# stack is aligned on entry!
d174 1
a174 1
	subq	\$32,%rsp			# add spill
d176 1
a176 1
	addq	\$32,%rsp			# revert stack
d189 1
a189 3
sigdelayed:					# stack is aligned on entry!
	pushq	%rbp				# fake to make unaligned
	.seh_pushreg %rbp
d215 1
a215 1
	movl	$tls::saved_errno(%r12),%r15d	# temporarily save saved_errno
d248 1
a248 2
	movq	%r10,(%rsp)
	ret
d268 2
a275 1
	subq	\$32,%rsp
a276 1
	addq	\$32,%rsp
d278 2
a279 1
2:	popq	%r12
@


1.41.2.12
log
@	* cygwin64.din (BASE): Set to 0x180040000.
	(_fe_dfl_env): Remove useless symbol.
	(_fe_nomask_env): Remove useless symbol.
	(exit): Add missing symbol.
	(setmode): Ditto.
	* gendef (longjmp): Convert all displacements to hex for readability.
	Change all movaps instructions to movdqu to accommodate unaligned
	access to 128 bit values.
@
text
@d518 9
a526 9
	movq	%rbx,0x8(%rcx)
	movq	%rsp,0x10(%rcx)
	movq	%rbp,0x18(%rcx)
	movq	%rsi,0x20(%rcx)
	movq	%rdi,0x28(%rcx)
	movq	%r12,0x30(%rcx)
	movq	%r13,0x38(%rcx)
	movq	%r14,0x40(%rcx)
	movq	%r15,0x48(%rcx)
d528 11
a538 11
	movq	%r10,0x50(%rcx)
	movdqu	%xmm6,0x60(%rcx)
	movdqu	%xmm7,0x70(%rcx)
	movdqu	%xmm8,0x80(%rcx)
	movdqu	%xmm9,0x90(%rcx)
	movdqu	%xmm10,0xa0(%rcx)
	movdqu	%xmm11,0xb0(%rcx)
	movdqu	%xmm12,0xc0(%rcx)
	movdqu	%xmm13,0xd0(%rcx)
	movdqu	%xmm14,0xe0(%rcx)
	movdqu	%xmm15,0xf0(%rcx)
d544 1
a544 1
	movq	%r10,0x58(%ecx)
d557 9
a565 9
	movq	%rbx,0x8(%rcx)
	movq	%rsp,0x10(%rcx)
	movq	%rbp,0x18(%rcx)
	movq	%rsi,0x20(%rcx)
	movq	%rdi,0x28(%rcx)
	movq	%r12,0x30(%rcx)
	movq	%r13,0x38(%rcx)
	movq	%r14,0x40(%rcx)
	movq	%r15,0x48(%rcx)
d567 11
a577 11
	movq	%r10,0x50(%rcx)
	movdqu	%xmm6,0x60(%rcx)
	movdqu	%xmm7,0x70(%rcx)
	movdqu	%xmm8,0x80(%rcx)
	movdqu	%xmm9,0x90(%rcx)
	movdqu	%xmm10,0xa0(%rcx)
	movdqu	%xmm11,0xb0(%rcx)
	movdqu	%xmm12,0xc0(%rcx)
	movdqu	%xmm13,0xd0(%rcx)
	movdqu	%xmm14,0xe0(%rcx)
	movdqu	%xmm15,0xf0(%rcx)
d587 10
a596 10
	movq	0x8(%rcx),%rbx
	movq	0x10(%rcx),%rsp
	movq	0x18(%rcx),%rbp
	movq	0x20(%rcx),%rsi
	movq	0x28(%rcx),%rdi
	movq	0x30(%rcx),%r12
	movq	0x38(%rcx),%r13
	movq	0x40(%rcx),%r14
	movq	0x48(%rcx),%r15
	movq	0x50(%rcx),%r10
d598 10
a607 10
	movdqu	0x60(%rcx),%xmm6
	movdqu	0x70(%rcx),%xmm7
	movdqu	0x80(%rcx),%xmm8
	movdqu	0x90(%rcx),%xmm9
	movdqu	0xa0(%rcx),%xmm10
	movdqu	0xb0(%rcx),%xmm11
	movdqu	0xc0(%rcx),%xmm12
	movdqu	0xd0(%rcx),%xmm13
	movdqu	0xe0(%rcx),%xmm14
	movdqu	0xf0(%rcx),%xmm15
d625 1
a625 1
	movq	0x58(%rcx),%r10			# get old signal stack
d632 10
a641 10
	movq	0x8(%rcx),%rbx
	movq	0x10(%rcx),%rsp
	movq	0x18(%rcx),%rbp
	movq	0x20(%rcx),%rsi
	movq	0x28(%rcx),%rdi
	movq	0x30(%rcx),%r12
	movq	0x38(%rcx),%r13
	movq	0x40(%rcx),%r14
	movq	0x48(%rcx),%r15
	movq	0x50(%rcx),%r10
d643 10
a652 10
	movdqu	0x60(%rcx),%xmm6
	movdqu	0x70(%rcx),%xmm7
	movdqu	0x80(%rcx),%xmm8
	movdqu	0x90(%rcx),%xmm9
	movdqu	0xa0(%rcx),%xmm10
	movdqu	0xb0(%rcx),%xmm11
	movdqu	0xc0(%rcx),%xmm12
	movdqu	0xd0(%rcx),%xmm13
	movdqu	0xe0(%rcx),%xmm14
	movdqu	0xf0(%rcx),%xmm15
@


1.41.2.13
log
@	* gendef (longjmp): Fix indirect addressing in x86_64 setjmp.
@
text
@d544 1
a544 1
	movq	%r10,0x58(%rcx)
@


1.41.2.14
log
@	* Makefile.in (target_cpu): Define.  Check for target_cpu rather than
	target_alias for conditional compilation issues.
	(toolopts): Change --target into --cpu option and use $target_cpu as
	argument.
	($(DEF_FILE)): Call gendef with $(target_cpu) as argument, rather than
	with $(target_alias).
	* gendef: Accommodate change from --target to --cpu option.
	* mkimport: Ditto.
	* speclib: Ditto.
@
text
@d16 1
a16 1
my $cpu = shift;
d21 2
a22 2
if (!defined($in) || !defined($cpu) || !defined($out) || !defined($sigfe)) {
    die "usage: $0 deffile.in cygtls.h target-cpu deffile.def sigfe.s\n";
d27 1
a27 1
my $is64bit = ($cpu eq 'x86_64' ? 1 : 0);
@


1.41.2.15
log
@	* gendef: Add SEH information to sigfe entry points, as well as to
	_sigfe and _sigbe.
@
text
@a106 1
	.seh_proc $fe
a109 2
	.seh_pushreg %r10
	.seh_endprologue
a110 1
	.seh_endproc
a127 1
	.seh_proc _sigfe_maybe
a129 2
	.seh_pushreg %r12
	.seh_endprologue
a140 1
	.seh_endproc
a141 1
	.seh_proc _sigfe
a143 2
	.seh_pushreg %r12
	.seh_endprologue
a163 1
	.seh_endproc
a164 1
	.seh_proc _sigfe
a167 1
	.seh_pushreg %rax
a168 2
	.seh_pushreg %r12
	.seh_endprologue
a186 1
	.seh_endproc
@


1.41.2.16
log
@	* gendef (_sigfe): Save arguments before calling yield so they don't
	get clobbered.  Explain why.
@
text
@d161 4
a164 12
	subq	\$0x48,%rsp			#   call yield but save
	movq	%rcx,0x40(%rsp)			#   arguments first, otherwise
	movq	%rdx,0x38(%rsp)			#   we end up with scrambled
	movq	%r8,0x30(%rsp)			#   arguments when eventually
	movq	%r9,0x28(%rsp)			#   calling the real function
	call	yield				# should be a short-time thing
	movq	0x28(%rsp),%r9			#  revert arguments,
	movq	0x30(%rsp),%r8
	movq	0x38(%rsp),%rdx
	movq	0x40(%rsp),%rcx
	addq	\$0x48,%rsp			# revert stack and
	jmp	1b				# loop
@


1.41.2.17
log
@	* gendef (_sigfe): Save float arguments as well before calling yield.
	(_sigbe): Move saving %rax from prologue to just before the yield call.
	Save %xmm0 register, too.
	(sigdelayed): Add comment.  Save %xmm0 register, too, before calling
	yield.
@
text
@d161 5
a165 9
	subq	\$0x88,%rsp			#   call yield but save
	movq	%rcx,0x80(%rsp)			#   arguments first, otherwise
	movq	%rdx,0x78(%rsp)			#   we end up with scrambled
	movq	%r8,0x70(%rsp)			#   arguments when eventually
	movq	%r9,0x68(%rsp)			#   calling the real function
	movdqu	%xmm0,0x58(%rsp)
	movdqu	%xmm1,0x48(%rsp)
	movdqu	%xmm2,0x38(%rsp)
	movdqu	%xmm3,0x28(%rsp)
d167 5
a171 9
	movdqu	0x28(%rsp),%xmm3		#  revert arguments,
	movdqu	0x38(%rsp),%xmm2
	movdqu	0x48(%rsp),%xmm1
	movdqu	0x58(%rsp),%xmm0
	movq	0x68(%rsp),%r9
	movq	0x70(%rsp),%r8
	movq	0x78(%rsp),%rdx
	movq	0x80(%rsp),%rcx
	addq	\$0x88,%rsp			# revert stack and
d188 3
a190 1
	pushq	%r12
d199 1
a199 3
	subq	\$0x40,%rsp			# add spill and save return regs
	movq	%rax,0x38(%rsp)
	movdqu	%xmm0,0x28(%rsp)
d201 1
a201 3
	movdqu	0x28(%rsp),%xmm0
	movq	0x38(%rsp),%rax
	addq	\$0x40,%rsp			# revert stack and return regs
d209 1
d217 1
a217 1
	.seh_pushreg %rbp			# used for return address injection
d238 2
a239 3
	subq	\$0x30,%rsp
	.seh_stackalloc 48
	movdqu	%xmm0,0x20(%rsp)
d266 1
a266 2
	movdqu	0x20(%rsp),%xmm0
	addq	\$0x30,%rsp
@


1.41.2.18
log
@	* gendef (_sigfe): 16-byte align xmm0 storage and use movdqa.
	(_sigbe): Fix alignment before calling yield.  Use movdqa to save and
	restore xmm0.
	(sigdelayed): Use movdqa to save and restore xmm0.
	(_ZN7_cygtls4lockEv): Change absolute values to hex.
	(stabilize_sig_stack): Ditto.
	(setjmp): Add comment to explain usage of movdqu.
	(__sjfault): Ditto.
	(__ljfault): Ditto.
	(longjmp): Ditto. Access return value using 32 bit opcodes only.
	* miscfuncs.cc (thread_wrapper): Don't attempt to copy exception
	handler list on x86_64.
@
text
@d162 8
a169 8
	movq	%rcx,0x78(%rsp)			#   arguments first, otherwise
	movq	%rdx,0x70(%rsp)			#   we end up with scrambled
	movq	%r8,0x68(%rsp)			#   arguments when eventually
	movq	%r9,0x60(%rsp)			#   calling the real function
	movdqa	%xmm0,0x50(%rsp)
	movdqa	%xmm1,0x40(%rsp)
	movdqa	%xmm2,0x30(%rsp)
	movdqa	%xmm3,0x20(%rsp)
d171 8
a178 8
	movdqa	0x20(%rsp),%xmm3		#  revert arguments,
	movdqa	0x30(%rsp),%xmm2
	movdqa	0x40(%rsp),%xmm1
	movdqa	0x50(%rsp),%xmm0
	movq	0x60(%rsp),%r9
	movq	0x68(%rsp),%r8
	movq	0x70(%rsp),%rdx
	movq	0x78(%rsp),%rcx
d205 3
a207 3
	subq	\$0x38,%rsp			# add spill and save return regs
	movq	%rax,0x30(%rsp)
	movdqa	%xmm0,0x20(%rsp)
d209 3
a211 3
	movdqa	0x20(%rsp),%xmm0
	movq	0x30(%rsp),%rax
	addq	\$0x38,%rsp			# revert stack and return regs
d249 1
a249 1
	movdqa	%xmm0,0x20(%rsp)
d276 1
a276 1
	movdqa	0x20(%rsp),%xmm0
d314 1
a314 1
	subq	\$0x20,%rsp
d316 1
a316 1
	addq	\$0x20,%rsp
d344 1
a344 1
	subq	\$0x20,%rsp
d364 1
a364 1
	addq	\$0x20,%rsp
a564 1
	# jmp_buf is potentially unaligned!
a603 1
	# jmp_buf is potentially unaligned!
a633 1
	# jmp_buf is potentially unaligned!
d657 1
a657 1
	movl	%edx,%r12d			# save return value (r12 is overwritten anyway)
d660 1
a660 1
	movl	%r12d,%eax			# restore return value
a678 1
	# jmp_buf is potentially unaligned!
@


1.41.2.19
log
@	* gendef (sigdelayed): Make sure to align the stack since sigdelayed
	can be called with or without aligned stack.  Save and restore all
	CPU registers.
@
text
@d224 3
a226 3
sigdelayed:
	pushq	%r10				# used for return address injection
	.seh_pushreg %rbp
a229 5
	# stack is aligned or unaligned on entry!
	# make sure it is aligned from here on
	# We could be called from an interrupted thread which doesn't know
	# about his fate, so save and restore everything and the kitchen sink.
	andq	\$0xfffffffffffffff0,%rsp
a238 6
	pushq	%r11
	.seh_pushreg %r11
	pushq	%r9
	.seh_pushreg %r9
	pushq	%r8
	.seh_pushreg %r8
a242 4
	pushq	%rdx
	.seh_pushreg %rdx
	pushq	%rcx
	.seh_pushreg %rcx
d247 2
a248 18
	pushf
	subq	\$0x120,%rsp
	.seh_stackalloc 0x120
	movdqa	%xmm15,0x110(%rsp)
	movdqa	%xmm14,0x100(%rsp)
	movdqa	%xmm13,0xf0(%rsp)
	movdqa	%xmm12,0xe0(%rsp)
	movdqa	%xmm11,0xd0(%rsp)
	movdqa	%xmm10,0xc0(%rsp)
	movdqa	%xmm9,0xb0(%rsp)
	movdqa	%xmm8,0xa0(%rsp)
	movdqa	%xmm7,0x90(%rsp)
	movdqa	%xmm6,0x80(%rsp)
	movdqa	%xmm5,0x70(%rsp)
	movdqa	%xmm4,0x60(%rsp)
	movdqa	%xmm3,0x50(%rsp)
	movdqa	%xmm2,0x40(%rsp)
	movdqa	%xmm1,0x30(%rsp)
d277 1
a277 17
	movdqa	0x30(%rsp),%xmm1
	movdqa	0x40(%rsp),%xmm2
	movdqa	0x50(%rsp),%xmm3
	movdqa	0x60(%rsp),%xmm4
	movdqa	0x70(%rsp),%xmm5
	movdqa	0x80(%rsp),%xmm6
	movdqa	0x90(%rsp),%xmm7
	movdqa	0xa0(%rsp),%xmm8
	movdqa	0xb0(%rsp),%xmm9
	movdqa	0xc0(%rsp),%xmm10
	movdqa	0xd0(%rsp),%xmm11
	movdqa	0xe0(%rsp),%xmm12
	movdqa	0xf0(%rsp),%xmm13
	movdqa	0x100(%rsp),%xmm14
	movdqa	0x110(%rsp),%xmm15
	addq	\$0x120,%rsp
	popf
a279 2
	popq	%rcx
	popq	%rdx
a281 3
	popq	%r8
	popq	%r9
	popq	%r11
a285 1
	movq	%rbp,%rsp
d287 1
a287 1
	xchgq	%r10,(%rsp)
@


1.41.2.20
log
@	* gendef: Use pause instead of calling yield throughout in x86_64 code.
@
text
@d161 19
a179 1
	pause
d205 7
a211 1
	pause
d294 1
a294 1
	pause
d367 3
a369 1
	pause
d406 1
a406 1
	pause
@


1.40
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d165 2
a166 2
	pushl	%ebp
	movl	%esp,%ebp
d168 8
a175 43
	pushl	%esi
	pushl	%edi
	pushl	%edx
	pushl	%ecx
	pushl	%ebx
	pushl	%eax
	movl	%fs:4,%ebx
1:	movl	\$1,%eax
	xchgl	%eax,$tls::stacklock(%ebx)
	movl	%eax,$tls::spinning(%ebx) # flag if we are waiting for lock
					  # If %eax is 1 then someone else has
					  # the lock but we want to flag that
					  # we're waiting for it.  If %eax is 0
					  # then we're not spinning and 0 will
					  # reflect that.
	testl	%eax,%eax
	jz	2f
	call	_yield
	jmp	1b
2:	incl	$tls::incyg(%ebx)
	movl	$tls::sig(%ebx),%eax
	testl	%eax,%eax
	jz	leave			# call_signal_handler may have beat us
					# to it
	pushl	$tls::saved_errno(%ebx)	# saved errno
	call	_set_process_mask_delta
	pushl	%eax

	# fill out handler arguments
	xorl	%eax,%eax		# ucontext_t (currently not set)
	pushl	%eax
	leal	$tls::infodata(%ebx),%eax
	pushl	%eax			# siginfo
	pushl	$tls::sig(%ebx)		# signal number

	pushl	\$_sigreturn		# where to return
	pushl	$tls::func(%ebx)	# user-supplied signal func
	movl	\$0,$tls::sig(%ebx)	# zero the signal number as a
					# flag to the signal handler thread
					# that it is ok to set up sigsave
4:	decl	$tls::incyg(%ebx)
	decl	$tls::stacklock(%ebx)
	ret				# return via signal handler
d177 3
a179 6
	.global	_sigreturn
_sigreturn:
	movl	%fs:4,%ebx
	incl	$tls::incyg(%ebx)
	addl	\$12,%esp				# remove arguments
	call	_set_process_mask\@@4
d181 1
d258 1
a258 1
	movl	\$-$tls::sizeof__cygtls,%eax		# point to beginning
@


1.39
log
@* gendef (sigdelayed): Remember to pop all of the saved registers.
(sigreturn): Add "leave" label.
@
text
@a204 2
	cmpl	\$0,$tls::threadkill(%ebx)#pthread_kill signal?
	jnz	4f			# yes.  callee clears signal number
@


1.38
log
@* exceptions.cc (_cygtls::call_signal_handler): Fix debugging to not go to
console.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Add temporary kludge
to work around problem of make closing a handler while it is being read.
* gendef (sigdelayed): Don't call a function if sig has been cleared.
* sigproc.h (cygwait): Simplify slightly.
@
text
@a162 36
	.global	_sigreturn
_sigreturn:
	movl	%fs:4,%ebx
	incl	$tls::incyg(%ebx)
	addl	\$12,%esp				# remove arguments
	call	_set_process_mask\@@4

1:	movl	\$1,%eax				# potential lock value
	xchgl	%eax,$tls::stacklock(%ebx)		# see if we can grab it
	movl	%eax,$tls::spinning(%ebx)		# flag if we are waiting for lock
	testl	%eax,%eax				# it will be zero
	jz	2f					#  if so
	call	_yield					# sleep
	jmp	1b					#  and loop
2:	popl	%edx					# saved errno
	testl	%edx,%edx				# Is it < 0
	jl	3f					# yup.  ignore it
	movl	$tls::errno_addr(%ebx),%eax
	movl	%edx,(%eax)
3:	movl	\$-4,%eax				# now decrement aux stack
	xadd	%eax,$tls::stackptr(%ebx)		#  and get pointer
	xorl	%ebp,%ebp
	xchgl	%ebp,-4(%eax)				# get return address from signal stack
	xchgl	%ebp,28(%esp)				# store real return address
	decl	$tls::incyg(%ebx)
	decl	$tls::stacklock(%ebx)			# unlock

	popl	%eax
	popl	%ebx
	popl	%ecx
	popl	%edx
	popl	%edi
	popl	%esi
	popf
	ret

d190 1
a190 1
	jz	4f			# call_signal_handler may have beat us
d214 36
@


1.37
log
@* exceptions.cc (exception::handle): Drop abbreviation for "exception" since I
never remember what it stands for.
(sig_handle_tty_stop): Remove obsolete call to sig_handle_tty_stop.
(_cygtls::call_signal_handler): Rework to grab signal information from
_main_tls if none is set for _my_tls.  Try harder to keep thread locked.
(reset_signal_arrived): Delete.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use new cygWFMO call
to wait for an event + standard cygwin stuff.  Modify debug output to
acccomodate new function.
* fhandler_console.cc (fhandler_console::read): Replace WaitForMultipleObjects
with cygWFMO.
* fhandler_socket.cc (get_inet_addr): Add comment.
* gendef (_sigdelayed): Remove call to reset_signal_arrived.
* sigproc.cc (_cygtls::signal_exit): Don't close my_readsig here unless we're
in the signal thread.
(create_signal_arrived): Create signal_arrived as auto-reset so that only one
thread is woken when a signal arrives.
* sigproc.h (cygWFMO): New function.
(reset_signal_arrived): Delete declaration.
@
text
@d224 4
@


1.36
log
@* exceptions.cc (_cygtls::interrupt_now): Revert to checking for "spinning"
when choosing to defer signal.
(_cygtls::call_signal_handler): Grab func when we have the lock.
* gendef: Update copyright.
(__sigbe): Simplify slightly.
(_sigdelayed): Grab a lock before manipulating stuff.
(_cygtls::pop): Properly return popped value.
(stabilize_sig_stack): Set incyg when we have the lock.
* sigproc.cc: Update copyright.
@
text
@a234 1
	call	_reset_signal_arrived\@@0
@


1.35
log
@* gendef: Throughout, remove lock from xchgl since it is implied.
(__ZN7_cygtls3popEv): Avoid potential (but probably nonexistent) race when
clearing element after pop.
@
text
@d2 1
a2 1
# Copyright 2003, 2004, 2005, 2006, 2008 Red Hat, Inc.
a143 2
	pushl	%edx
	pushl	%ebx
d145 1
d156 2
a157 3
	xorl	%edx,%edx
	xchgl	%edx,-4(%eax)				# get return address from signal stack
	xchgl	%edx,8(%esp)				# restore edx/real return address
a159 1
	popl	%eax
d175 1
a175 1
	call	_yield			# sleep
d211 13
a223 1
	incl	$tls::incyg(%ebx)
d237 1
a237 1
	pushl	$tls::func(%ebx)	# signal func
d244 2
a245 1
	ret
d247 1
a247 1
	.global	__ZN7_cygtls3popEv
d253 1
a282 1
	incl	$tls::incyg(%ebx)
d290 2
a291 1
2:	cmpl	\$0,$tls::sig(%ebx)
@


1.34
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d125 1
a125 1
	lock	xchgl %eax,$tls::stacklock(%ebx)	# see if we can grab it
d129 1
a129 1
	call	_yield			# should be a short-time thing, so
d149 1
a149 1
	lock	xchgl %eax,$tls::stacklock(%ebx)	# see if we can grab it
d153 1
a153 1
	call	_yield			# sleep
d174 1
a174 1
	lock	xchgl %eax,$tls::stacklock(%ebx)	# see if we can grab it
d240 3
a242 7
	pushl	%edx				# FIXME: needed?
	movl	%eax,%ebx
	movl	\$-4,%edx
	xadd	%edx,$tls::pstackptr(%ebx)
	xorl	%eax,%eax
	xchgl	%eax,-4(%edx)
	popl	%edx				# FIXME: needed?
d251 1
a251 1
	lock	xchgl %eax,$tls::pstacklock(%ebx)
d274 1
a274 1
	lock	xchgl %eax,$tls::stacklock(%ebx)
@


1.33
log
@* gendef (cleanup): Rename from 'nocr'.  Remove comments and trailing spaces.
* cygwin.din: Add long-needed comment describing what dll_crt0__FP11per_process
demangles to.
@
text
@d129 1
a129 2
	xorl	%eax,%eax				# nope.  It was not zero
	call	_low_priority_sleep			# should be a short-time thing, so
d153 1
a153 2
	xorl	%eax,%eax				# nope.  not zero
	call	_low_priority_sleep			# sleep
d178 1
a178 2
	xorl	%eax,%eax				# nope.  not zero
	call	_low_priority_sleep			# sleep
d258 1
a258 2
	xorl	%eax,%eax
	call	_low_priority_sleep
d282 1
a282 2
	xorl	%eax,%eax
	call	_low_priority_sleep
@


1.32
log
@* speclib: Semi-revert to previous version but don't try to generate
well-formed import library.  Instead, just extract appropriate symbols and let
later libcygwin.a on link line fill in the rest of the import stuff.
* gendef: Hopefully no-op modification to allow easier post-processing on
symbol values.
@
text
@d11 2
a12 1
sub nocr(@@);
d28 1
a28 1
    push(@@top, nocr $_);
d31 2
a32 2
my $libline = nocr scalar(<IN>);
my @@in = nocr <IN>;
d460 1
a460 1
sub nocr(@@) {
d462 2
@


1.31
log
@	* gendef: Remove STABS directives.
@
text
@d37 1
a37 1
my @@out = ();
d39 3
a41 2
    /\sDATA$/o and do {
	push(@@data, $_);
a43 1
    chomp;
d66 1
a66 1
    push(@@out, $_ . "\n");
d69 1
a69 1
for (@@out) {
d71 1
a71 1
    $_ = $alias . ' = ' . $sigfe{$func} . "\n"
d74 1
d76 2
a77 1
print OUT @@top, @@data, @@out;
@


1.30
log
@	* Fix copyright dates.
@
text
@a101 1
	.stabs	"_sigfe:F(0,1)",36,0,0,__sigfe
a140 1
	.stabs	"_sigbe:F(0,1)",36,0,0,__sigbe
a165 1
	.stabs	"sigreturn:F(0,1)",36,0,0,_sigreturn
a202 1
	.stabs	"sigdelayed:F(0,1)",36,0,0,_sigdelayed
@


1.29
log
@* exceptions.cc (_cygtls::handle_exceptions): Only call rtl_unwind when
exiting.  Just return, don't set thread context.
* gendef (_setjmp): Store %fs:0 in jmp_buf.
(_sjfault): Ditto.
(_ljfault): Restore %fs:0 from jmp_buf.
(_longjmp): Ditto.
@
text
@d2 1
a2 1
# Copyright 2003, 2004, 2005, 2006 Red Hat, Inc.
@


1.28
log
@* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid a
potential race.
@
text
@d335 2
d342 1
a342 1
	movl	%eax,44(%edi)
d376 2
d398 2
d424 1
a424 1
	movl	44(%edi),%eax				# get old signal stack
d439 2
@


1.27
log
@* cygheap.cc (cygheap_fixup_in_child): Don't close parent handle here.  Let the
caller do that.
* dcrt0.cc (child_info_spawn::handle_spawn): Close parent handle here to allow
fixup_after_exec functions to use it.
* cygtls.cc (_cygtls::call2): Avoid calling exit thread if called with
*crt0_1 functions.
* cygtls.h (_cygtls::isinitialized): Check that we actually have a tls before
seeing if it is initialized.
* gendef (_sigfe_maybe): Ditto.
* dcrt0.cc (dll_crt0_1): Remove static, use just one argument.
* dll_init.cc (dllcrt0_info): New structure.
(dll_dllcrt0): Change into a front-end to renamed dll_dllcrt0_1 so that we'll
always be assured of having something like a tls.
(dll_dllcrt0_1): New function, basically renamed from from dll_dllcrt0.
Unconditionally call _my_tls.init_exception_handler now that we are assured of
having a tls.  Change variable name from "linking" to "linked".
* winsup.h (dll_crt0_1): Declare.
(dll_dllcrt0_1): Ditto.
@
text
@d161 1
a163 1
	decl	$tls::incyg(%ebx)
@


1.27.4.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@a160 1
	decl	$tls::incyg(%ebx)
d163 1
@


1.27.4.2
log
@2008-03-01  Christopher Faylor  <me+cygwin@@cgf.cx>

	* cygtls.h (_cygtls::handle_threadlist_exception): Eliminate.
	(_cygtls::init_threadlist_exceptions): Ditto.
	* cygtls.cc (_cygtls::handle_threadlist_exception): Eliminate.
	(_cygtls::init_threadlist_exceptions): Ditto.
	(_cygtls::find_tls): Use myfault handling to deal with errors caused by
	nonexistent threads.
	* sigproc.cc (wait_sig): Eliminate call to init_threadlist_exceptions.

2008-03-01  Christopher Faylor  <me+cygwin@@cgf.cx>

	* cygtls.cc (_cygtls::init_exception_handler): Just return.

2008-03-01  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (_cygtls::handle_exceptions): Only call rtl_unwind when
	exiting.  Just return, don't set thread context.
	* gendef (_setjmp): Store %fs:0 in jmp_buf.
	(_sjfault): Ditto.
	(_ljfault): Restore %fs:0 from jmp_buf.
	(_longjmp): Ditto.
@
text
@a334 2
	movl	%fs:0,%eax
	movl	%eax,44(%edi)
d340 1
a340 1
	movl	%eax,48(%edi)
a373 2
	movl	%fs:0,%eax
	movl	%eax,44(%edi)
a393 2
	movl	44(%edi),%eax
	movl	%eax,%fs:0
d418 1
a418 1
	movl	48(%edi),%eax				# get old signal stack
a432 2
	movl	44(%edi),%eax
	movl	%eax,%fs:0
@


1.26
log
@* cygtls.cc (_cygtls::remove): Reset initialized flag right away if we were
previously initialized.
* cygtls.h (_cygtls::initialized): Move nearer the end to catch situation when
Windows 98 mysteriously changes pieces of cygtls when thread is detaching.
* gendef (__sigfe_maybe): Simplify slightly.
* tlsoffsets.h: Regenerate.
@
text
@d107 4
d114 1
a114 1
	popl	%edx
@


1.25
log
@* cygtls.h (CYGTLS_INITIALIZED): Change to a little more unlikely value.
(CYGTLSMAGIC): Delete.
* dcrt0.cc (dll_crt0_0): Call sigproc_init during init startup.
(_dll_crt0): Don't worry about sync_startup.  Just wait for sigthread here.
* dll_init.cc (cygwin_detach_dll): Only pick up tls version of retaddr if we
have a valid tls.
* fork.cc (frok::child): Remove sigproc_init initialization since it happens
much earlier now.
* gendef: Recognize SIGFE_MAYBE.
(fefunc): Generate calls to _sigfe_maybe, if appropriate.
(_sigfe_maybe): New function.
* init.cc (search_for): Always initialize search_for, even on fork.
(calibration_thread): Delete.
(calibration_id): Delete.
(prime_threads): Delete.
(munge_threadfunc): Remove calibration_thread special case.  Avoid calling
thread function if we haven't yet hit the "search_for" thread.
(dll_entry): Remove prime_threads call.  Only call munge_threadfunc when
hwait_sig is active.  Ditto.  for _my_tls.remove ();
* sigproc.cc (hwait_sig): Make global.
(sigproc_init): Don't bother with sync_startup.
(sig_send): Treat flush as a no-op when signals are held.
(wait_sig): Cause signals to be held after fork.
@
text
@d112 1
a112 2
	popl	%eax
	jmp	*%eax
@


1.24
log
@* analyze_sigfe: New script.
* dllfixdbg: Add copyright.
* gendef: Ditto.
* gendevices: Ditto.
* gentls_offsets: Ditto.
@
text
@d2 1
a2 1
# Copyright 2003, 2004, 2005 Red Hat, Inc.
d46 5
a50 3
	} elsif (s/ SIGFE$//) {
	  my $func = (split(' '))[2];
	  $sigfe{$func} = '_sigfe_' . $func;
d53 1
a53 1
	my ($func, $sigfe) = m%^\s*(\S+)(?:\s+((?:NO)?SIGR?FE))?$%o;
d88 1
d95 1
a95 1
	jmp	__sigfe
d103 12
@


1.23
log
@* cygtls.cc (_cygtls::handle_threadlist_exception): Make an error fatal.
* cygtls.h (sockaddr_in): Use header rather than defining our own structure.
* exceptions.cc (_cygtls::interrupt_setup): Use exact contents of sa_mask
rather than assuming tht current sig should be masked, too.
(_cygtls::call_signal_handler): Use more aggressive locking.
* gendef (_sigbe): Wait until later before releasing incyg.
(_sigreturn): Remove more arguments to accommodate quasi-sa_sigaction support.
(_sigdelayed): Push arguments for sa_sigaction.  More work needed here.
* signal.cc (sigaction): Implement SA_NODEFER.
* tlsoffsets.h: Regenerate.

* sigproc.cc (wait_sig): Use default buffer size of Windows 9x complains.
* pinfo.cc (_onreturn::dummy_handle): Remove.
(_onreturn::h): Make this a pointer.
(_onreturn::~_onreturn): Detect whether pointer is NULL rather than value is
NULL.
(_onreturn::_onreturn): Set h to NULL initially.
(_onreturn::no_close_p_handle): Set h to NULL.
(winpids::add): Initialize onreturn with value from p.hProcess immediately.
@
text
@d2 8
@


1.22
log
@Remove unneeded whitespace.
* cygtls.cc (_cygtls::set_state): Delete.
(_cygtls::reset_exception): Ditto.
(_cygtls::init_thread): Set initialized state directly here.
(_cygtls::push): Remove exception argument.  Don't treat exceptions specially.
* cygtls.h (_cygtls::push): Ditto.
(_cygtls::isinitialized): Don't treat exceptions specially.
(_cygtls::reset_exception): Delete.
(_cygtls::set_state): Ditto.
(_cygtls::handle_exceptions): Don't push ebp on the stack prior to calling
sig_send.  Just set incyg instead.
(_cygtls::interrupt_setup): Accommodate _cygtls::push argument change.
(_cygtls::interrupt_now): Ditto.
(setup_handler): Don't treat exceptions specially.
* gendef (longjmp): Always zero incyg flag.
@
text
@a134 1
	decl	$tls::incyg(%ebx)
d137 1
d146 1
a146 1
	addl	\$4,%esp				# Remove argument
d196 7
a202 2
	pushl	$tls::sig(%ebx)		# signal argument
	pushl	\$_sigreturn
d205 1
d208 1
a208 1
	jnz	4f			#yes.  Callee clears signal number
@


1.21
log
@* fork.cc (frok::child): Change order of cleanup prior to return.
(fork): Save more of the stack.
* gendef: Fix some comments.
* sigproc.cc (wait_sig): Clarify debug output.
@
text
@d389 2
@


1.20
log
@* cygtls.h (__ljfault): Declare.
(_cygtls::return_from_fault): Use __ljfault.
* exceptions.cc (set_signal_mask): Revert previous checkin.
* gendef (__sjfault): Split out into a separate function which doesn't bother
with any special signal locking.  routines.
(_ljfault): Return from a __sjfault without bothering with signals.
@
text
@d117 1
a117 1
__sigbe: # return here after cygwin syscall
d134 1
a134 1
	xchgl	%edx,8(%esp)				# restore ebx/real return address
@


1.19
log
@* gendef: Use nocr to remove \r's from input.  gendef (nocr): New function.
@
text
@d275 1
a275 1
	.globl	_setjmp, ___sjfault
a276 1
___sjfault:
d314 66
@


1.18
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d3 1
d19 1
a19 1
    push(@@top, $_);
d22 2
a23 2
my $libline = <IN>;
my @@in = <IN>;
d353 4
@


1.17
log
@* cygtls.h (waitq): Declare structure here.
(_cygtls::wq): Declare.
* cygtls.cc (_cygtls::fixup_after_fork): Clear wq.thread_ev to avoid using an
invalid event handle in forked process.
* dcrt0.cc (waitq_storage): Delete.
(threadstuff): Remove waitq_storage.
* perthread.h (per_thread_waitq): Delete.
(waitq_storage): Delete declaration.
* sigproc.cc (sigproc_init): Remove perthread waitq consideration.
* sigproc.h (waitq): Delete declaration.
* wait.cc (wait4): Use _my_tls waitq structure rather than per_thread.
* cygtls.h (_cygtls::newmask): Delete member.
(_cygtls::deltamask): New member.
* gendef (_sigdelayed): Replace the call to set_process_mask by a call to
set_process_mask_delta.
* exceptions.cc (handle_sigsuspend): Do not filter tempmask.  Or
SIG_NONMASKABLE in deltamask as a flag.
(_cygtls::interrupt_setup): Set deltamask only.
(set_process_mask_delta): New function.
(_cygtls::call_signal_handler): Replace the first call to set_process_mask by a
call to set_process_mask_delta.
* tlsoffsets.h: Regenerate.
@
text
@d274 1
a274 1
	.globl	_setjmp
d276 1
@


1.16
log
@* cygtls.cc (_cygtls::fixup_after_fork): Remove unneeded setting of oldmask.
* exceptions.cc: Remove some __I386__ conditionals.
(handle_exceptions): Move ppid test to outside of a loop for efficiency.
(setup_handler): Make debugging output more wordy.
(_cygtls::call_signal_handler): To avoid a race, use lock/unlock to synchronize
with signal thread and ensure that signal_arrived event has actually been set.
* gendef (_sigfe): Use ebx for all sigstack manipulations to ensure that the
register is saved.  Move setting of incyg to within stack lock to avoid
setup_handler confusion.
(_sigbe): Use ebx for all sigstack manipulations to ensure that the register is
saved.
(_cygtls::pop): Ditto.
(_cygtls::lock): Ditto.
(stabilize_sig_stack): Ditto.
(setjmp): Ditto.
(longjmp): Ditto.
@
text
@d193 2
a194 1
	pushl	$tls::oldmask(%ebx)	# oldmask
a199 3
	pushl	$tls::newmask(%ebx)	# newmask - eaten by set_process_mask

	call	_set_process_mask\@@4
@


1.15
log
@* exceptions.cc (setup_handler): Avoid suspending a thread if it in a cygwin
function, in an exception, spinning, or locked.
* gendef (_sigfe): Move incyg setting earlier.
(sigreturn): Set incyg flag to avoid interrupting called cygwin functions.
(sigdelayed): Ditto.
(stabilize_sig_stack): Ditto.
* sigproc.cc (proc_subproc): Don't restore process lock early in exec case.
* cygtls.h: Reorganize fields in _cygtls slightly.
* tlsoffsets.h: Regenerate.
@
text
@d94 4
a97 5
1:	movl	%fs:4,%edx				# location of bottom of stack
	incl	$tls::incyg(%edx)
	movl	\$1,%eax				# potential lock value
	lock	xchgl %eax,$tls::stacklock(%edx)	# see if we can grab it
	movl	%eax,$tls::spinning(%edx)		# flag if we are waiting for lock
d104 6
a109 5
	xadd	%eax,$tls::stackptr(%edx)		#  stack pointer and get pointer
	leal	__sigbe,%ebx				# new place to return to
	xchgl	%ebx,12(%esp)				# exchange with real return value
	movl	%ebx,(%eax)				# store real return value on alt stack
	decl	$tls::stacklock(%edx)			# remove lock
d116 2
a117 1
__sigbe:
a118 1
	pushl	%edx					# return here after cygwin syscall
d120 1
a120 1
1:	movl	%fs:4,%edx				# address of bottom of tls
d122 2
a123 2
	lock	xchgl %eax,$tls::stacklock(%edx)	# see if we can grab it
	movl	%eax,$tls::spinning(%edx)		# flag if we are waiting for lock
d130 6
a135 6
	xadd	%eax,$tls::stackptr(%edx)		#  and get pointer
	xorl	%ebx,%ebx
	xchgl	%ebx,-4(%eax)				# get return address from signal stack
	xchgl	%ebx,8(%esp)				# restore ebx/real return address
	decl	$tls::incyg(%edx)
	decl	$tls::stacklock(%edx)			# release lock
d137 1
a137 1
	popl	%edx
d193 1
a193 1
3:	pushl	$tls::oldmask(%ebx)	# oldmask
d214 3
a216 3
	movl	%eax,%edx
	movl	\$-4,%ebx
	xadd	%ebx,$tls::pstackptr(%edx)
d218 1
a218 1
	xchgl	%eax,-4(%ebx)
d225 2
a226 2
	pushl	%edi
	movl	%eax,%edi
d228 1
a228 1
	lock	xchgl %eax,$tls::pstacklock(%edi)
d234 1
a234 1
2:	popl	%edi
d249 5
a253 5
1:	movl	%fs:4,%edx
	incl	$tls::incyg(%edx)
	movl	\$1,%eax
	lock	xchgl %eax,$tls::stacklock(%edx)
	movl	%eax,$tls::spinning(%edx)		# flag if we are waiting for lock
d259 1
a259 1
2:	cmpl	\$0,$tls::sig(%edx)
d261 1
a261 1
	decl	$tls::stacklock(%edx)			# unlock
d263 1
a263 1
	addl	%edx,%eax				#  of tls block
d266 1
a266 1
3:	decl	$tls::incyg(%edx)
d304 1
a304 1
	pushl	%edx
d306 3
a308 3
	movl	$tls::stackptr(%edx),%eax		# save stack pointer contents
	decl	$tls::stacklock(%edx)
	popl	%edx
d322 2
a323 2
	movl	%eax,$tls::stackptr(%edx)		# restore
	decl	$tls::stacklock(%edx)			# relinquish lock
@


1.14
log
@* fork.cc (fork_parent): Save parent pid in a temporary variable since child
could conceivably exit before function returns, rendering the child's shared
memory area invalid.
* cygtls.h (_cygtls::incyg): Declare new field.
(_cygtls::in_exception): Define new function.
* exceptions.cc (setup_handler): Remove locked flag.  Use 'incyg' flag and
in_exception function to determine when we're in a cygwin function.
(_cygtls::call_signal_handler): Decrement incyg flag prior to calling a
handler.  Increment it on return.
* gendef (_sigfe): Increment incyg flag.  Use testl for zero testing rather
than orl, for consistency.
(_sigbe): Decrement incyg flag.  Use testl for zero testing rather than orl,
for consistency.
(_cygtls::pop): Use testl for zero testing rather than orl, for consistency.
(stabilize_sig_stack): Ditto.
@
text
@d95 1
d104 1
a104 2
2:	incl	$tls::incyg(%edx)
	movl	\$4,%eax				# have the lock, now increment the
d143 2
d148 3
a150 4
1:	movl	%fs:4,%edx
	movl	\$1,%eax				# potential lock value
	lock	xchgl %eax,$tls::stacklock(%edx)	# see if we can grab it
	movl	%eax,$tls::spinning(%edx)		# flag if we are waiting for lock
d156 2
a157 2
2:	popl	%ebx					# saved errno
	testl	%ebx,%ebx				# Is it < 0
d159 2
a160 2
	movl	$tls::errno_addr(%edx),%eax
	movl	%ebx,(%eax)
d162 1
a162 1
	xadd	%eax,$tls::stackptr(%edx)		#  and get pointer
d166 2
a167 1
	decl	$tls::stacklock(%edx)			# unlock
d191 1
d207 2
a208 1
4:	ret
d250 1
d266 2
a267 1
3:	ret
@


1.13
log
@* gendef (sigdelayed): Handle return here rather than going through sigbe to
ensure that flags are properly restored.
@
text
@d98 1
a98 1
	orl	%eax,%eax				# it will be zero
d103 2
a104 1
2:	movl	\$4,%eax				# have the lock, now increment the
d124 1
a124 1
	orl	%eax,%eax				# it will be zero
d134 1
d150 1
a150 1
	orl	%eax,%eax				# it will be zero
d225 1
a225 1
	orl	%eax,%eax
d249 1
a249 1
	orl	%eax,%eax
@


1.12
log
@* gendef (sigreturn): Call stabilize_sig_stack to ensure that there are no
pending signals.  Restore edx later.
(sigdelayed): Save edx earlier.
* malloc_wrapper.cc (malloc_init): Add some more debugging output.
@
text
@d90 1
a90 1
	.stabs	"_sigfe:F(0,1)",36,0,0,__sigbe
d138 66
a259 55

	.global	_sigreturn
	.stabs	"sigreturn:F(0,1)",36,0,0,_sigreturn
_sigreturn:
	addl	\$4,%esp				# Remove argument
	call	_set_process_mask\@@4

	call	stabilize_sig_stack

1:	popl	%ebx					# saved errno
	testl	%ebx,%ebx				# Is it < 0
	jl	2f					# yup.  ignore it
	movl	$tls::errno_addr(%edx),%eax
	movl	%ebx,(%eax)
2:	popl	%eax
	popl	%ebx
	popl	%ecx
	popl	%edi
	popl	%esi
	popf
	decl	$tls::stacklock(%edx)			# relinquish lock
	popl	%edx
	popl	%ebp
	jmp	__sigbe

	.global	_sigdelayed
	.stabs	"sigdelayed:F(0,1)",36,0,0,_sigdelayed
_sigdelayed:
	pushl	%ebp
	movl	%esp,%ebp
	pushl	%edx
	pushf
	pushl	%esi
	pushl	%edi
	pushl	%ecx
	pushl	%ebx
	pushl	%eax
	movl	%fs:4,%ebx
	pushl	$tls::saved_errno(%ebx)	# saved errno
3:	pushl	$tls::oldmask(%ebx)	# oldmask
	pushl	$tls::sig(%ebx)		# signal argument
	pushl	\$_sigreturn

	call	_reset_signal_arrived\@@0
	pushl	$tls::func(%ebx)	# signal func
	pushl	$tls::newmask(%ebx)	# newmask - eaten by set_process_mask

	call	_set_process_mask\@@4
	cmpl	\$0,$tls::threadkill(%ebx)#pthread_kill signal?
	jnz	4f			#yes.  Callee clears signal number
	movl	\$0,$tls::sig(%ebx)	# zero the signal number as a
					# flag to the signal handler thread
					# that it is ok to set up sigsave
4:	ret

@


1.11
log
@* gendef (stabilize_sig_stack): Correctly align this pointer for call to
_cygtls::call_signal_handler.
* gentls_offsets: Output sizeof field.
* tlsoffsets.h: Regenerate.
@
text
@d131 2
a132 2
	xchgl	%ebx,-4(%eax)				# 
	xchgl	%ebx,8(%esp)
d175 20
d198 1
a198 1
	addl	\$4,%esp		# Remove argument
d201 1
a201 1
	movl	%fs:4,%ebx
d203 5
a207 8
#	cmpl	\$0,$tls::sig(%ebx)	# Did a signal come in?
#	jnz	3f			# Yes, if non-zero

1:	popl	%edx			# saved errno
	testl	%edx,%edx		# Is it < 0
	jl	2f			# yup.  ignore it
	movl	$tls::errno_addr(%ebx),%eax
	movl	%edx,(%eax)
a210 1
	popl	%edx
d214 2
d224 1
a227 1
	pushl	%edx
a255 20

	.extern	__ZN7_cygtls19call_signal_handlerEv
stabilize_sig_stack:
1:	movl	%fs:4,%edx
	movl	\$1,%eax
	lock	xchgl %eax,$tls::stacklock(%edx)
	movl	%eax,$tls::spinning(%edx)		# flag if we are waiting for lock
	orl	%eax,%eax
	jz	2f
	xorl	%eax,%eax
	call	_low_priority_sleep
	jmp	1b
2:	cmpl	\$0,$tls::sig(%edx)
	jz	3f
	decl	$tls::stacklock(%edx)			# unlock
	movl	\$-$tls::sizeof__cygtls,%eax		# point to beginning
	addl	%edx,%eax				#  of tls block
	call	__ZN7_cygtls19call_signal_handlerEv
	jmp	1b
3:	ret
@


1.10
log
@* gendef (stabilize_sig_stack): New function.
(setjmp): Import, add sig stack handling.  Store sig stack info.
(longjmp): Call stabilize_sig_stack.  Restore sig stack info.
* config/i386/setjmp.c: Remove.
@
text
@d252 3
a254 2
	decl	$tls::stacklock(%edx)
	movl	%edx,%eax
@


1.9
log
@* dcrt0.cc (alloc_stack_hard_way): Revert to previous implementation.
(alloc_stack): Ditto.
* exceptions.cc (ctrl_c_handler): Add debugging output.
@
text
@d239 2
a240 3
	.globl	_longjmp

_longjmp:
d250 7
a256 2
2:	leal	($tls::stack)(%edx),%eax
	movl	%eax,($tls::stackptr)(%edx)
d258 2
d262 1
d264 43
a328 1
	decl	$tls::stacklock(%edx)
@


1.8
log
@* Makefile.in (clean): Remove sigfe.s.
(sigfe.s): Ensure that sigfe.s will be regenerated if it does not exist.
* dll_init.cc (dll_dllcrt0): Simplify initializing tests.
* exceptions.cc (setup_handler): Detect when stub caller is either spinning or
has acquired the lock after being suspended to avoid windows problems with
suspending a win32 API call.
* cygtls.h (_cygtls::spinning): Declare new element.
* gendef: Remove unused _siglist_index and _siglist declaration.
(_sigfe): Set spinning element when potentially looping, waiting for lock.
(_sigbe): Ditto.
(_cygtls::lock): Ditto.
(_longjmp): Ditto.
* tlsoffsets.h: Regenerate.
* pinfo.cc (_pinfo::exit): Set final exit state here.  Call sigproc_terminate
if invoked with 'norecord'.  Clear any residual _cygtls stuff.
* winsup.h (exit_states): Define ES_FINAL.
* spawn.cc (spawn_guts): Don't call proc_terminate specifically when execing.
Let _pinfo::exit handle that case.
* sigproc.cc (wait_subproc): Always exit loop early when proc_loop_wait.
* init.cc (munge_threadfunc): Eliminate unused argument.
(dll_entry): Reflect above change in call to munge_threadfunc.
@
text
@a283 1

@


1.7
log
@* gendef (_sigbe): Zero location on pop.
(_cygtls::pop): Ditto.
@
text
@a78 2
	.extern	_siglist_index
	.extern	_siglist
d97 1
d122 1
d245 1
@


1.6
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d130 1
a130 2
#	xorl	%ebx,%ebx
	movl	\$0x41774177,%ebx
d145 1
a145 2
#	xorl	%eax,%eax
	movl	8(%esp),%eax
@


1.5
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d94 1
d96 16
a111 15
	movl	%fs:4,%edx
1:	movl	\$1,%eax
	lock	xchgl %eax,$tls::stacklock(%edx)
	cmpl	%eax,%eax
	jz	2f
	xorl	%eax,%eax
	call	_low_priority_sleep
	jmp	1b
2:	movl	\$4,%eax
	xadd	%eax,$tls::stackptr(%edx)
	decl	$tls::stacklock(%edx)
	leal	__sigbe,%edx
	xchgl	%edx,8(%esp)
	movl	%edx,(%eax)
	popl	%edx
d117 18
a134 15
	pushl	%edx
	pushl	%eax
	movl	%fs:4,%edx
1:	movl	\$1,%eax
	lock	xchgl %eax,$tls::stacklock(%edx)
	cmpl	%eax,%eax
	jz	2f
	xorl	%eax,%eax
	call	_low_priority_sleep
	jmp	1b
2:	movl	\$-4,%eax
	xadd	%eax,$tls::stackptr(%edx)
	decl	$tls::stacklock(%edx)
	xchgl	%edx,-4(%eax)
	xchgl	%edx,4(%esp)
d136 1
d139 2
a140 2
	.global	__ZN11_threadinfo3popEv
__ZN11_threadinfo3popEv:
d142 1
d146 2
a147 1
	xorl	%eax,%eax
d149 1
d153 4
a156 4
	.global	__ZN11_threadinfo4lockEv
__ZN11_threadinfo4lockEv:
	pushl	%ebx
	movl	%eax,%ebx
d158 2
a159 2
	lock	xchgl %eax,$tls::pstacklock(%ebx)
	cmpl	%eax,%eax
d164 1
a164 2
2:	xorl	\$1,%eax
	popl	%ebx
d167 2
a168 2
	.global	__ZN11_threadinfo6unlockEv
__ZN11_threadinfo6unlockEv:
d172 5
d180 1
a180 1
	addl	\$4,%esp			# Remove argument
d185 2
a186 2
	cmpl	\$0,$tls::sig(%ebx)	# Did a signal come in?
	jnz	3f			# Yes, if non-zero
d231 1
a231 2
4:	popl	%ebx
	jmp	*%ebx
d244 11
d260 1
a260 1
	jne	0f
d262 2
a263 2
0:
	movl	%eax,0(%edi)
a275 3
	movl	%fs:4,%eax
	leal	($tls::stack)(%eax),%edx
	movl	%edx,($tls::stackptr)(%eax)
d279 2
a281 1
	movl	16(%edi),%esi
@


1.4
log
@* localtime.cc (localtime_r): Call tzset.
* Makefile.in: Make version.h/cygwin.din version check a warning since it is
not foolproof.
* cygheap.h (CYGHEAPSIZE): Bump size down.
* cygtls.h (_threadinfo::stacklock): New element.
(_threadinfo::pop): Make regparm.
(_threadinfo::lock): New function.
(_threadinfo::unlock): New function.
* cygtls.cc (_threadinfo::push): Wait for a lock on the stack before performing
the operation.
(_threadinfo::pop): Move to another file.
* cygwin.din: More SIGFE changes.
* exceptions.cc (try_to_debug): Always display messages on console.
(handle_exceptions): Unwind stack only when actually about to call sig_send.
(setup_handler): Lock stack prior to performing any operations.
* gendef (_sigfe): Ditto.
(_sigbe): Ditto.
(_threadinfo::pop): Ditto.  Move here.
* gen_tlsoffsets: Generate positive offsets.
* tlsoffsets.h: Regenerate.
@
text
@d97 3
a99 2
	lock	cmpxchg %eax,$tls::stacklock(%edx)
	jne	2f
d107 1
a107 1
	xchg	%edx,8(%esp)
d119 3
a121 2
	lock	cmpxchg %eax,$tls::stacklock(%edx)
	jne	2f
d127 3
a129 2
	xchg	%edx,-4(%eax)
	xchg	%edx,4(%esp)
d140 1
a140 2
	xchg	%eax,-4(%ebx)
	decl	$tls::pstacklock(%edx)
d144 2
a145 2
	.global	__ZN11_threadinfo4lockEi
__ZN11_threadinfo4lockEi:
d149 2
a150 3
	lock	cmpxchg %eax,$tls::pstacklock(%ebx)
	jne	2f
	cmpl	%edx,%edx
@


1.3
log
@* exceptions.cc (sig_handle_tty_stop): Avoid races by waiting for both
signal_arrived and for sigCONT.
(sigpacket::process): Enforce sending of both signal_arrived and sigCONT, where
appropriate.
* gendef (sigreturn): Save tls pointer in ebx so that it can jump into
sigdelayed and use the same register.
@
text
@a90 3
	.global	__sigbe
	.global	_sigreturn
	.global	_sigdelayed
d95 13
a107 6
	movl	%fs:4,%eax
	movl	\$4,%edx
	xadd	%edx,$tls::stackptr(%eax)
	leal	__sigbe,%eax
	xchg	%eax,8(%esp)
	movl	%eax,(%edx)
d111 1
d114 1
d116 35
a150 4
	pushl	%edx
	movl	\$-4,%edx
1:	movl	%fs:4,%eax
	xadd	%edx,$tls::stackptr(%eax)
a151 3
	lock    xchg %eax,-4(%edx)
	testl	%eax,%eax
	jnz	2f
a152 1
	xorl	%edx,%edx
d154 7
a160 2
2:	xchg	%eax,4(%esp)
	popl	%edx
d163 1
d189 1
@


1.2
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d130 1
a130 1
	movl	%fs:4,%eax
d132 1
a132 1
	cmpl	\$0,$tls::sig(%eax)	# Did a signal come in?
d138 1
a138 1
	movl	$tls::errno_addr(%eax),%eax
@


1.1
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d172 2
d177 1
a177 1
	popl	%ebx
@


1.1.6.1
log
@* exceptions.cc (sig_handle_tty_stop): Avoid races by waiting for both
signal_arrived and for sigCONT.
(sigpacket::process): Enforce sending of both signal_arrived and sigCONT, where
appropriate.
* gendef (sigreturn): Save tls pointer in ebx so that it can jump into
sigdelayed and use the same register.
@
text
@d130 1
a130 1
	movl	%fs:4,%ebx
d132 1
a132 1
	cmpl	\$0,$tls::sig(%ebx)	# Did a signal come in?
d138 1
a138 1
	movl	$tls::errno_addr(%ebx),%eax
@


1.1.2.1
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@a171 2
	cmpl	\$0,$tls::threadkill(%ebx)#pthread_kill signal?
	jnz	4f			#yes.  Callee clears signal number
d175 1
a175 1
4:	popl	%ebx
@

