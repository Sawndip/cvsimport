head	1.35;
access;
symbols
	cygwin-1_7_35-release:1.35
	cygwin-1_7_34-release:1.35
	cygwin-1_7_33-release:1.33.2.2
	cygwin-1_7_32-release:1.33.2.1
	cygwin-1_7_31-release:1.33.2.1
	cygwin-1_7_30-release:1.33
	cygwin-1_7_29-release:1.33
	cygwin-1_7_29-release-branchpoint:1.33.0.2
	cygwin-pre-user-db:1.33
	cygwin-1_7_28-release:1.33
	cygwin-1_7_27-release:1.33
	cygwin-1_7_26-release:1.33
	cygwin-1_7_25-release:1.32
	cygwin-1_7_24-release:1.32
	cygwin-1_7_23-release:1.32
	cygwin-1_7_22-release:1.32
	cygwin-1_7_21-release:1.32
	cygwin-1_7_20-release:1.32
	cygwin-1_7_19-release:1.32
	cygwin-64bit-postmerge:1.32
	cygwin-64bit-premerge-branch:1.31.0.4
	cygwin-64bit-premerge:1.31
	cygwin-1_7_18-release:1.31
	post-ptmalloc3:1.31.2.1
	pre-ptmalloc3:1.31.2.1
	cygwin-1_7_17-release:1.31
	cygwin-64bit-branch:1.31.0.2
	cygwin-1_7_16-release:1.31
	cygwin-1_7_15-release:1.31
	cygwin-1_7_14_2-release:1.31
	cygwin-1_7_14-release:1.31
	cygwin-1_7_12-release:1.31
	cygwin-1_7_11-release:1.31
	cygwin-1_7_10-release:1.30
	signal-rewrite:1.27.0.2
	pre-notty:1.27
	cygwin-1_7_9-release:1.26
	cv-post-1_7_9:1.26.0.2
	cygwin-1_7_8-release:1.26
	cygwin-1_7_7-release:1.25
	cygwin-1_7_5-release:1.25
	cygwin-1_7_4-release:1.25
	cygwin-1_7_3-release:1.25
	cygwin-1_7_2-release:1.25
	fifo_doover3:1.25.0.4
	cygwin-1_7_1-release:1.25
	prefifo:1.25
	cv-branch-2:1.25.0.2
	pre-ripout-set_console_state_for_spawn:1.24
	EOL_registry_mounts:1.23
	preoverlapped:1.23
	drop_9x_support_start:1.23
	cr-0x5f1:1.23.0.4
	cv-branch:1.23.0.2
	pre-ptymaster-archetype:1.23
	cr-0x3b58:1.20.0.4
	cr-0x5ef:1.20.0.2
	after-mmap-privanon-noreserve:1.19
	after-mmap-revamp:1.19
	before-mmap-revamp:1.19
	cgf-more-exit-sync:1.16
	post_wait_sig_exit:1.16
	pre_wait_sig_exit:1.16
	reparent-point:1.2
	noreparent:1.2.0.4
	cr-0x5e6:1.2.0.2
	cgf-deleteme:1.1.0.2;
locks; strict;
comment	@// @;


1.35
date	2014.08.22.09.21.32;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2014.06.05.19.50.24;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.25.11.38.08;	author corinna;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2013.04.23.09.44.34;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2012.02.17.17.34.01;	author corinna;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2011.12.03.21.43.27;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.14.01.37.02;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.14.01.29.49;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.17.17.08.09;	author yselkowitz;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.01.18.24.11;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2008.10.07.23.28.30;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.07.18.45.59;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.20.02.06.15;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.20.02.04.31;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.06.18.24.06;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.03.04.23.35;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.11.16.42.15;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.04.20.45.56;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.06.20.05.03;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.03.02.40.30;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.02.03.50.09;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.05.04.31.00;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.28.21.51.55;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.28.19.55.59;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.28.19.31.22;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.28.18.06.49;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.27.01.57.38;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.08.14.32.07;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.08.14.31.21;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.06.16.33.59;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.06.14.09.14;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.26.04.15.09;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2004.01.19.05.38.24;	author cgf;	state dead;
branches
	1.1.2.1;
next	;

1.33.2.1
date	2014.07.16.09.54.56;	author corinna;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2014.11.13.12.53.07;	author corinna;	state Exp;
branches;
next	;

1.31.2.1
date	2012.12.10.11.45.51;	author corinna;	state Exp;
branches;
next	;

1.2.4.1
date	2004.11.16.15.16.57;	author cgf;	state Exp;
branches;
next	;

1.1.2.1
date	2004.01.19.05.38.24;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.35
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@/* timer.cc

   Copyright 2004, 2005, 2006, 2008, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "thread.h"
#include "cygtls.h"
#include "sigproc.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"

#define TT_MAGIC 0x513e4a1c
struct timer_tracker
{
  unsigned magic;
  clockid_t clock_id;
  sigevent evp;
  timespec it_interval;
  HANDLE hcancel;
  HANDLE syncthread;
  long long interval_us;
  long long sleepto_us;
  bool cancel ();
  struct timer_tracker *next;
  int settime (int, const itimerspec *, itimerspec *);
  void gettime (itimerspec *);
  timer_tracker (clockid_t, const sigevent *);
  ~timer_tracker ();
  friend void fixup_timers_after_fork ();
};

timer_tracker NO_COPY ttstart (CLOCK_REALTIME, NULL);

class lock_timer_tracker
{
  static muto protect;
public:
  lock_timer_tracker ();
  ~lock_timer_tracker ();
};

muto NO_COPY lock_timer_tracker::protect;

lock_timer_tracker::lock_timer_tracker ()
{
  protect.init ("timer_protect")->acquire ();
}

lock_timer_tracker::~lock_timer_tracker ()
{
  protect.release ();
}

bool
timer_tracker::cancel ()
{
  if (!hcancel)
    return false;

  SetEvent (hcancel);
  DWORD res = WaitForSingleObject (syncthread, INFINITE);
  if (res != WAIT_OBJECT_0)
    system_printf ("WFSO returned unexpected value %u, %E", res);
  return true;
}

timer_tracker::~timer_tracker ()
{
  if (cancel ())
    {
      CloseHandle (hcancel);
#ifdef DEBUGGING
      hcancel = NULL;
#endif
    }
  if (syncthread)
    CloseHandle (syncthread);
  magic = 0;
}

timer_tracker::timer_tracker (clockid_t c, const sigevent *e)
{
  if (e != NULL)
    evp = *e;
  else
    {
      evp.sigev_notify = SIGEV_SIGNAL;
      evp.sigev_signo = SIGALRM;
      evp.sigev_value.sival_ptr = this;
    }
  clock_id = c;
  magic = TT_MAGIC;
  hcancel = NULL;
  if (this != &ttstart)
    {
      lock_timer_tracker here;
      next = ttstart.next;
      ttstart.next = this;
    }
}

static long long
to_us (const timespec& ts)
{
  long long res = ts.tv_sec;
  res *= 1000000;
  res += ts.tv_nsec / 1000 + ((ts.tv_nsec % 1000) ? 1 : 0);
  return res;
}

static DWORD WINAPI
timer_thread (VOID *x)
{
  timer_tracker *tt = ((timer_tracker *) x);
  long long now;
  long long sleepto_us =  tt->sleepto_us;
  while (1)
    {
      long long sleep_us;
      LONG sleep_ms;
      /* Account for delays in starting thread
	and sending the signal */
      now = gtod.usecs ();
      sleep_us = sleepto_us - now;
      if (sleep_us > 0)
	{
	  tt->sleepto_us = sleepto_us;
	  sleep_ms = (sleep_us + 999) / 1000;
	}
      else
	{
	  tt->sleepto_us = now;
	  sleep_ms = 0;
	}

      debug_printf ("%p waiting for %u ms", x, sleep_ms);
      switch (WaitForSingleObject (tt->hcancel, sleep_ms))
	{
	case WAIT_TIMEOUT:
	  debug_printf ("timed out");
	  break;
	case WAIT_OBJECT_0:
	  debug_printf ("%p cancelled", x);
	  goto out;
	default:
	  debug_printf ("%p wait failed, %E", x);
	  goto out;
	}

      switch (tt->evp.sigev_notify)
	{
	case SIGEV_SIGNAL:
	  {
	    siginfo_t si = {0};
	    si.si_signo = tt->evp.sigev_signo;
	    si.si_sigval.sival_ptr = tt->evp.sigev_value.sival_ptr;
	    si.si_code = SI_TIMER;
	    debug_printf ("%p sending signal %d", x, tt->evp.sigev_signo);
	    sig_send (myself_nowait, si);
	    break;
	  }
	case SIGEV_THREAD:
	  {
	    pthread_t notify_thread;
	    debug_printf ("%p starting thread", x);
	    pthread_attr_t *attr;
	    pthread_attr_t default_attr;
	    if (tt->evp.sigev_notify_attributes)
	      attr = tt->evp.sigev_notify_attributes;
	    else
	      {
		pthread_attr_init(attr = &default_attr);
		pthread_attr_setdetachstate (attr, PTHREAD_CREATE_DETACHED);
	      }

	    int rc = pthread_create (&notify_thread, attr,
				     (void * (*) (void *)) tt->evp.sigev_notify_function,
				     tt->evp.sigev_value.sival_ptr);
	    if (rc)
	      {
		debug_printf ("thread creation failed, %E");
		return 0;
	      }
	    // FIXME: pthread_join?
	    break;
	  }
	}
      if (!tt->interval_us)
	break;

      sleepto_us = tt->sleepto_us + tt->interval_us;
      debug_printf ("looping");
    }

out:
  _my_tls._ctinfo->auto_release ();     /* automatically return the cygthread to the cygthread pool */
  return 0;
}

static bool
it_bad (const timespec& t)
{
  if (t.tv_nsec < 0 || t.tv_nsec >= 1000000000 || t.tv_sec < 0)
    {
      set_errno (EINVAL);
      return true;
    }
  return false;
}

int
timer_tracker::settime (int in_flags, const itimerspec *value, itimerspec *ovalue)
{
  int ret = -1;

  __try
    {
      if (!value)
	{
	  set_errno (EINVAL);
	  __leave;
	}

      if (it_bad (value->it_value) || it_bad (value->it_interval))
	__leave;

      long long now = in_flags & TIMER_ABSTIME ? 0 : gtod.usecs ();

      lock_timer_tracker here;
      cancel ();

      if (ovalue)
	gettime (ovalue);

      if (!value->it_value.tv_sec && !value->it_value.tv_nsec)
	interval_us = sleepto_us = 0;
      else
	{
	  sleepto_us = now + to_us (value->it_value);
	  interval_us = to_us (value->it_interval);
	  it_interval = value->it_interval;
	  if (!hcancel)
	    hcancel = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
	  else
	    ResetEvent (hcancel);
	  if (!syncthread)
	    syncthread = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
	  else
	    ResetEvent (syncthread);
	  new cygthread (timer_thread, this, "itimer", syncthread);
	}
      ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  return ret;
}

void
timer_tracker::gettime (itimerspec *ovalue)
{
  if (!hcancel)
    memset (ovalue, 0, sizeof (*ovalue));
  else
    {
      ovalue->it_interval = it_interval;
      long long now = gtod.usecs ();
      long long left_us = sleepto_us - now;
      if (left_us < 0)
       left_us = 0;
      ovalue->it_value.tv_sec = left_us / 1000000;
      ovalue->it_value.tv_nsec = (left_us % 1000000) * 1000;
    }
}

extern "C" int
timer_gettime (timer_t timerid, struct itimerspec *ovalue)
{
  int ret = -1;

  __try
    {
      timer_tracker *tt = (timer_tracker *) timerid;
      if (tt->magic != TT_MAGIC)
	{
	  set_errno (EINVAL);
	  return -1;
	}

      tt->gettime (ovalue);
      ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  return ret;
}

extern "C" int
timer_create (clockid_t clock_id, struct sigevent *__restrict evp,
	      timer_t *__restrict timerid)
{
  int ret = -1;

  __try
    {
      if (CLOCKID_IS_PROCESS (clock_id) || CLOCKID_IS_THREAD (clock_id))
	{
	  set_errno (ENOTSUP);
	  return -1;
	}

      if (clock_id != CLOCK_REALTIME)
	{
	  set_errno (EINVAL);
	  return -1;
	}

      *timerid = (timer_t) new timer_tracker (clock_id, evp);
      ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  return ret;
}

extern "C" int
timer_settime (timer_t timerid, int flags,
	       const struct itimerspec *__restrict value,
	       struct itimerspec *__restrict ovalue)
{
  int ret = -1;

  __try
    {
      timer_tracker *tt = (timer_tracker *) timerid;
      if (tt->magic != TT_MAGIC)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      ret = tt->settime (flags, value, ovalue);
    }
  __except (EFAULT) {}
  __endtry
  return ret;
}

extern "C" int
timer_delete (timer_t timerid)
{
  int ret = -1;

  __try
    {
      timer_tracker *in_tt = (timer_tracker *) timerid;
      if (in_tt->magic != TT_MAGIC)
	{
	  set_errno (EINVAL);
	  __leave;
	}

      lock_timer_tracker here;
      for (timer_tracker *tt = &ttstart; tt->next != NULL; tt = tt->next)
	if (tt->next == in_tt)
	  {
	    tt->next = in_tt->next;
	    delete in_tt;
	    ret = 0;
	    __leave;
	  }
      set_errno (EINVAL);
      ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  return ret;
}

void
fixup_timers_after_fork ()
{
  ttstart.hcancel = ttstart.syncthread = NULL;
  for (timer_tracker *tt = &ttstart; tt->next != NULL; /* nothing */)
    {
      timer_tracker *deleteme = tt->next;
      tt->next = deleteme->next;
      deleteme->hcancel = deleteme->syncthread = NULL;
      delete deleteme;
    }
}


extern "C" int
setitimer (int which, const struct itimerval *__restrict value,
	   struct itimerval *__restrict ovalue)
{
  int ret;
  if (which != ITIMER_REAL)
    {
      set_errno (EINVAL);
      ret = -1;
    }
  else
    {
      struct itimerspec spec_value, spec_ovalue;
      spec_value.it_interval.tv_sec = value->it_interval.tv_sec;
      spec_value.it_interval.tv_nsec = value->it_interval.tv_usec * 1000;
      spec_value.it_value.tv_sec = value->it_value.tv_sec;
      spec_value.it_value.tv_nsec = value->it_value.tv_usec * 1000;
      ret = timer_settime ((timer_t) &ttstart, 0, &spec_value, &spec_ovalue);
      if (ret)
	ret = -1;
      else if (ovalue)
	{
	  ovalue->it_interval.tv_sec = spec_ovalue.it_interval.tv_sec;
	  ovalue->it_interval.tv_usec = spec_ovalue.it_interval.tv_nsec / 1000;
	  ovalue->it_value.tv_sec = spec_ovalue.it_value.tv_sec;
	  ovalue->it_value.tv_usec = spec_ovalue.it_value.tv_nsec / 1000;
	}
    }
  syscall_printf ("%R = setitimer()", ret);
  return ret;
}


extern "C" int
getitimer (int which, struct itimerval *ovalue)
{
  int ret = -1;

  if (which != ITIMER_REAL)
    set_errno (EINVAL);
  else
    {
      __try
	{
	  struct itimerspec spec_ovalue;
	  ret = timer_gettime ((timer_t) &ttstart, &spec_ovalue);
	  if (!ret)
	    {
	      ovalue->it_interval.tv_sec = spec_ovalue.it_interval.tv_sec;
	      ovalue->it_interval.tv_usec = spec_ovalue.it_interval.tv_nsec / 1000;
	      ovalue->it_value.tv_sec = spec_ovalue.it_value.tv_sec;
	      ovalue->it_value.tv_usec = spec_ovalue.it_value.tv_nsec / 1000;
	    }
	}
      __except (EFAULT) {}
      __endtry
    }
  syscall_printf ("%R = getitimer()", ret);
  return ret;
}

/* FIXME: POSIX - alarm survives exec */
extern "C" unsigned int
alarm (unsigned int seconds)
{
 struct itimerspec newt = {}, oldt;
 /* alarm cannot fail, but only needs not be
    correct for arguments < 64k. Truncate */
 if (seconds > (HIRES_DELAY_MAX / 1000 - 1))
   seconds = (HIRES_DELAY_MAX / 1000 - 1);
 newt.it_value.tv_sec = seconds;
 timer_settime ((timer_t) &ttstart, 0, &newt, &oldt);
 int ret = oldt.it_value.tv_sec + (oldt.it_value.tv_nsec > 0);
 syscall_printf ("%d = alarm(%u)", ret, seconds);
 return ret;
}

extern "C" useconds_t
ualarm (useconds_t value, useconds_t interval)
{
 struct itimerspec timer = {}, otimer;
 /* ualarm cannot fail.
    Interpret negative arguments as zero */
 if (value > 0)
   {
     timer.it_value.tv_sec = value / 1000000;
     timer.it_value.tv_nsec = (value % 1000000) * 1000;
   }
 if (interval > 0)
   {
     timer.it_interval.tv_sec = interval / 1000000;
     timer.it_interval.tv_nsec = (interval % 1000000) * 1000;
   }
 timer_settime ((timer_t) &ttstart, 0, &timer, &otimer);
 useconds_t ret = otimer.it_value.tv_sec * 1000000 + (otimer.it_value.tv_nsec + 999) / 1000;
 syscall_printf ("%d = ualarm(%ld , %ld)", ret, value, interval);
 return ret;
}
@


1.34
log
@* timer.cc (timer_tracker::cancel): Demote api_fatal to system_printf, printing
more details about odd failure condition.
@
text
@d3 1
a3 1
   Copyright 2004, 2005, 2006, 2008, 2010, 2011, 2012, 2013 Red Hat, Inc.
d222 3
a224 1
  if (!value)
d226 5
a230 3
      set_errno (EINVAL);
      return -1;
    }
d232 2
a233 5
  myfault efault;
  if (efault.faulted (EFAULT)
      || it_bad (value->it_value)
      || it_bad (value->it_interval))
    return -1;
d235 1
a235 1
  long long now = in_flags & TIMER_ABSTIME ? 0 : gtod.usecs ();
d237 2
a238 2
  lock_timer_tracker here;
  cancel ();
d240 2
a241 2
  if (ovalue)
    gettime (ovalue);
d243 2
a244 9
  if (!value->it_value.tv_sec && !value->it_value.tv_nsec)
    interval_us = sleepto_us = 0;
  else
    {
      sleepto_us = now + to_us (value->it_value);
      interval_us = to_us (value->it_interval);
      it_interval = value->it_interval;
      if (!hcancel)
	hcancel = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
d246 15
a260 6
	ResetEvent (hcancel);
      if (!syncthread)
	syncthread = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
      else
	ResetEvent (syncthread);
      new cygthread (timer_thread, this, "itimer", syncthread);
d262 3
a264 2

  return 0;
d287 1
a287 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d289 1
a289 2
  timer_tracker *tt = (timer_tracker *) timerid;
  if (tt->magic != TT_MAGIC)
d291 9
a299 2
      set_errno (EINVAL);
      return -1;
d301 3
a303 3

  tt->gettime (ovalue);
  return 0;
d310 1
a310 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d312 1
a312 1
  if (CLOCKID_IS_PROCESS (clock_id) || CLOCKID_IS_THREAD (clock_id))
d314 11
a324 3
      set_errno (ENOTSUP);
      return -1;
    }
d326 2
a327 4
  if (clock_id != CLOCK_REALTIME)
    {
      set_errno (EINVAL);
      return -1;
d329 3
a331 3

  *timerid = (timer_t) new timer_tracker (clock_id, evp);
  return 0;
d339 3
a341 5
  timer_tracker *tt = (timer_tracker *) timerid;
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (tt->magic != TT_MAGIC)
d343 7
a349 2
      set_errno (EINVAL);
      return -1;
d351 3
a353 2

  return tt->settime (flags, value, ovalue);
d359 3
a361 5
  timer_tracker *in_tt = (timer_tracker *) timerid;
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (in_tt->magic != TT_MAGIC)
d363 16
d380 1
a380 1
      return -1;
d382 3
a384 11

  lock_timer_tracker here;
  for (timer_tracker *tt = &ttstart; tt->next != NULL; tt = tt->next)
    if (tt->next == in_tt)
      {
	tt->next = in_tt->next;
	delete in_tt;
	return 0;
      }
  set_errno (EINVAL);
  return 0;
d437 2
a438 1
  int ret;
d440 1
a440 4
    {
      set_errno (EINVAL);
      ret = -1;
    }
d443 1
a443 4
      myfault efault;
      if (efault.faulted (EFAULT))
	ret = -1;
      else
d455 2
@


1.33
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@d69 3
a71 2
  if (WaitForSingleObject (syncthread, INFINITE) != WAIT_OBJECT_0)
    api_fatal ("WFSO failed waiting for timer thread, %E");
@


1.33.2.1
log
@Add more missing patches
@
text
@d69 2
a70 3
  DWORD res = WaitForSingleObject (syncthread, INFINITE);
  if (res != WAIT_OBJECT_0)
    system_printf ("WFSO returned unexpected value %u, %E", res);
@


1.33.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d3 1
a3 1
   Copyright 2004, 2005, 2006, 2008, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d222 1
a222 3
  int ret = -1;

  __try
d224 3
a226 5
      if (!value)
	{
	  set_errno (EINVAL);
	  __leave;
	}
d228 5
a232 2
      if (it_bad (value->it_value) || it_bad (value->it_interval))
	__leave;
d234 1
a234 1
      long long now = in_flags & TIMER_ABSTIME ? 0 : gtod.usecs ();
d236 2
a237 2
      lock_timer_tracker here;
      cancel ();
d239 2
a240 2
      if (ovalue)
	gettime (ovalue);
d242 13
a254 2
      if (!value->it_value.tv_sec && !value->it_value.tv_nsec)
	interval_us = sleepto_us = 0;
d256 2
a257 15
	{
	  sleepto_us = now + to_us (value->it_value);
	  interval_us = to_us (value->it_interval);
	  it_interval = value->it_interval;
	  if (!hcancel)
	    hcancel = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
	  else
	    ResetEvent (hcancel);
	  if (!syncthread)
	    syncthread = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
	  else
	    ResetEvent (syncthread);
	  new cygthread (timer_thread, this, "itimer", syncthread);
	}
      ret = 0;
d259 2
a260 3
  __except (EFAULT) {}
  __endtry
  return ret;
d283 3
a285 1
  int ret = -1;
d287 2
a288 1
  __try
d290 3
a292 6
      timer_tracker *tt = (timer_tracker *) timerid;
      if (tt->magic != TT_MAGIC)
	{
	  set_errno (EINVAL);
	  return -1;
	}
d294 2
a295 6
      tt->gettime (ovalue);
      ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  return ret;
d302 3
a304 1
  int ret = -1;
d306 1
a306 1
  __try
d308 3
a310 5
      if (CLOCKID_IS_PROCESS (clock_id) || CLOCKID_IS_THREAD (clock_id))
	{
	  set_errno (ENOTSUP);
	  return -1;
	}
d312 5
a316 5
      if (clock_id != CLOCK_REALTIME)
	{
	  set_errno (EINVAL);
	  return -1;
	}
d318 2
a319 6
      *timerid = (timer_t) new timer_tracker (clock_id, evp);
      ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  return ret;
d327 5
a331 3
  int ret = -1;

  __try
d333 2
a334 7
      timer_tracker *tt = (timer_tracker *) timerid;
      if (tt->magic != TT_MAGIC)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      ret = tt->settime (flags, value, ovalue);
d336 2
a337 3
  __except (EFAULT) {}
  __endtry
  return ret;
d343 5
a347 3
  int ret = -1;

  __try
a348 16
      timer_tracker *in_tt = (timer_tracker *) timerid;
      if (in_tt->magic != TT_MAGIC)
	{
	  set_errno (EINVAL);
	  __leave;
	}

      lock_timer_tracker here;
      for (timer_tracker *tt = &ttstart; tt->next != NULL; tt = tt->next)
	if (tt->next == in_tt)
	  {
	    tt->next = in_tt->next;
	    delete in_tt;
	    ret = 0;
	    __leave;
	  }
d350 1
a350 1
      ret = 0;
d352 11
a362 3
  __except (EFAULT) {}
  __endtry
  return ret;
d415 1
a415 2
  int ret = -1;

d417 4
a420 1
    set_errno (EINVAL);
d423 4
a426 1
      __try
a437 2
      __except (EFAULT) {}
      __endtry
@


1.32
log
@	* Merge in cygwin-64bit-branch.
@
text
@d3 1
a3 1
   Copyright 2004, 2005, 2006, 2008, 2010, 2011, 2012 Red Hat, Inc.
d298 2
a299 1
timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
d322 3
a324 2
timer_settime (timer_t timerid, int flags, const struct itimerspec *value,
	       struct itimerspec *ovalue)
d379 2
a380 1
setitimer (int which, const struct itimerval *value, struct itimerval *ovalue)
@


1.31
log
@	* timer.cc (getitimer): Don't create another local ret variable in
	timer_gettime calling branch.  Simplify conditional since timer_gettime
	always returns 0 or -1 anyway.
@
text
@d3 1
a3 2
   Copyright 2004, 2005, 2006, 2008, 2010, 2011
   Red Hat, Inc.
d127 1
a127 1
      long sleep_ms;
d451 1
a451 1
 syscall_printf ("%d = alarm(%d)", ret, seconds);
d463 2
a464 2
     timer.it_value.tv_sec = (unsigned int) value / 1000000;
     timer.it_value.tv_nsec = ((unsigned int) value % 1000000) * 1000;
d468 2
a469 2
     timer.it_interval.tv_sec = (unsigned int) interval / 1000000;
     timer.it_interval.tv_nsec = ((unsigned int) interval % 1000000) * 1000;
d473 1
a473 1
 syscall_printf ("%d = ualarm(%d , %d)", ret, value, interval);
@


1.31.2.1
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d3 2
a4 1
   Copyright 2004, 2005, 2006, 2008, 2010, 2011, 2012 Red Hat, Inc.
d128 1
a128 1
      LONG sleep_ms;
d452 1
a452 1
 syscall_printf ("%d = alarm(%u)", ret, seconds);
d464 2
a465 2
     timer.it_value.tv_sec = value / 1000000;
     timer.it_value.tv_nsec = (value % 1000000) * 1000;
d469 2
a470 2
     timer.it_interval.tv_sec = interval / 1000000;
     timer.it_interval.tv_nsec = (interval % 1000000) * 1000;
d474 1
a474 1
 syscall_printf ("%d = ualarm(%ld , %ld)", ret, value, interval);
@


1.30
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d426 2
a427 4
	  int ret = timer_gettime ((timer_t) &ttstart, &spec_ovalue);
	  if (ret)
	    ret = -1;
	  else
@


1.29
log
@update copyrights
@
text
@d380 1
d384 1
a384 1
      return -1;
d386 1
a386 8
  struct itimerspec spec_value, spec_ovalue;
  int ret;
  spec_value.it_interval.tv_sec = value->it_interval.tv_sec;
  spec_value.it_interval.tv_nsec = value->it_interval.tv_usec * 1000;
  spec_value.it_value.tv_sec = value->it_value.tv_sec;
  spec_value.it_value.tv_nsec = value->it_value.tv_usec * 1000;
  ret = timer_settime ((timer_t) &ttstart, 0, &spec_value, &spec_ovalue);
  if (!ret && ovalue)
d388 15
a402 4
      ovalue->it_interval.tv_sec = spec_ovalue.it_interval.tv_sec;
      ovalue->it_interval.tv_usec = spec_ovalue.it_interval.tv_nsec / 1000;
      ovalue->it_value.tv_sec = spec_ovalue.it_value.tv_sec;
      ovalue->it_value.tv_usec = spec_ovalue.it_value.tv_nsec / 1000;
d404 1
a404 1
  syscall_printf ("%d = setitimer ()", ret);
d412 1
d416 1
a416 1
      return -1;
d418 1
a418 6
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  struct itimerspec spec_ovalue;
  int ret = timer_gettime ((timer_t) &ttstart, &spec_ovalue);
  if (!ret)
d420 17
a436 4
      ovalue->it_interval.tv_sec = spec_ovalue.it_interval.tv_sec;
      ovalue->it_interval.tv_usec = spec_ovalue.it_interval.tv_nsec / 1000;
      ovalue->it_value.tv_sec = spec_ovalue.it_value.tv_sec;
      ovalue->it_value.tv_usec = spec_ovalue.it_value.tv_nsec / 1000;
d438 1
a438 1
  syscall_printf ("%d = getitimer ()", ret);
d454 1
a454 1
 syscall_printf ("%d = alarm (%d)", ret, seconds);
d476 1
a476 1
 syscall_printf ("%d = ualarm (%d , %d)", ret, value, interval);
@


1.28
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d3 2
a4 1
   Copyright 2004, 2005 Red Hat, Inc.
@


1.27
log
@* cygwin.din (clock_getcpuclockid): Export.
(pthread_getcpuclockid): Export.
* hires.h (PID_TO_CLOCKID): New macro.
(CLOCKID_TO_PID): New macro.
(CLOCKID_IS_PROCESS): New macro.
(THREADID_TO_CLOCKID): New macro.
(CLOCKID_TO_THREADID): New macro.
(CLOCKID_IS_THREAD): New macro.
* ntdll.h (enum _THREAD_INFORMATION_CLASS): Add ThreadTimes.
* posix.sgml (std-notimpl): Add clock_getcpuclockid and
pthread_getcpuclockid from here...
(std-susv4): ... to here.
(std-notes): Remove limitations of clock_getres and clock_gettime.
Note limitation of timer_create to CLOCK_REALTIME.
* sysconf.cc (sca): Set _SC_CPUTIME to _POSIX_CPUTIME, and
_SC_THREAD_CPUTIME to _POSIX_THREAD_CPUTIME.
* thread.cc (pthread_getcpuclockid): New function.
* timer.cc (timer_create): Set errno to ENOTSUP for CPU-time clocks.
* times.cc (clock_gettime): Handle CLOCK_PROCESS_CPUTIME_ID and
CLOCK_THREAD_CPUTIME_ID.
(clock_getres): Ditto.
(clock_settime): Set errno to EPERM for CPU-time clocks.
(clock_getcpuclockid): New function.
* include/pthread.h (pthread_getcpuclockid): Declare.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d165 1
a165 1
	    debug_printf ("%p sending sig %d", x, tt->evp.sigev_signo);
@


1.26
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d303 7
@


1.25
log
@* pthread.cc (pthread_create): Very minor formatting change.
* timer.cc (timer_thread): Ensure that any created thread defaults to detached
state.
@
text
@d256 1
a256 1
      new cygthread (timer_thread, 0, this, "itimer", syncthread);
@


1.24
log
@Remove unneeded header files from source files throughout.
@
text
@d173 11
a183 1
	    int rc = pthread_create (&notify_thread, tt->evp.sigev_notify_attributes,
@


1.23
log
@revert erroneous checkin
@
text
@a11 5
#include <time.h>
#include <stdlib.h>
#include "cygerrno.h"
#include "security.h"
#include "hires.h"
a14 1
#include "sync.h"
@


1.22
log
@* exceptions.cc (stackdump): Avoid dumping more than once.
@
text
@a76 1
  debug_printf ("cancelled");
@


1.21
log
@Always zero all elements of siginfo_t throughout.
* cygtls.h (_cygtls::thread_context): Declare new field.
(_cygtls::thread_id): Ditto.
(_cygtls::signal_exit): Move into this class.
(_cygtls::copy_context): Declare new function.
(_cygtls::signal_debugger): Ditto.
* cygtls.cc (_cygtls::init_thread): Fill out thread id field.
* exceptions.cc (exception): Change message when exception info is unknown.
Copy context to thread local storage.
(_cygtls::handle_exceptions): Avoid double test for fault_guarded.  Reflect
move of signal_exit to _cygtls class.
(sigpacket::process): Copy context to thread local storage.
(_cygtls::signal_exit): Move to _cygtls class.  Call signal_debugger to notify
debugger of exiting signal (WIP).  Call stackdump here (WIP).
(_cygtls::copy_context): Define new function.
(_cygtls::signal_debugger): Ditto.
* tlsoffsets.h: Regenerate.
* include/cygwin.h (_fpstate): New internal structure.
(ucontext): Declare new structure (WIP).
(__COPY_CONTEXT_SIZE): New define.
* exceptions.cc (_cygtls::interrupt_setup): Clear "threadkill" field when there
is no sigwaiting thread.
(setup_handler): Move event handling into interrupt_setup.
@
text
@d77 1
@


1.20
log
@* cygtls.h (_cygtls::el): New field.
(_cygtls::handle_exceptions): New function declaration.
(_cygtls::handle_threadlist_exception): Ditto.
(_cygtls::init_exception_handler): Ditto.
(_cygtls::init_threadlist_exceptions): Remove arg from declaration.
* cygtls.cc (_cygtls::call2): Don't initialize exceptions here.
(_cygtls::init_thread): Do it here instead and use member function.
(_cygtls::handle_threadlist_exception): Move into _cygtls class.
(_cygtls::init_exception_handler): Ditto.  Rely on existence of 'el' memmber in
_cygtls.
(_cygtls::init_threadlist_exceptions): Ditto.
* dcrt0.cc (dll_crt0_1): Remove exception_list definition and setting since it
now commonly resides in the tls.
* exceptions.cc (init_exception_handler): Move to cygtls.cc.
(init_exceptions): Ditto.
(rtl_unwind): New, safe wrapper function for RtlUnwind.
(_cygtls::handle_exceptions): Move to _cygtls.  Call rtl_unwind to unwind
frames and eliminate copying of structures.  Put address of failing instruction
in si_addr, not the address on the stack.  Return 0 to indicate that we've
handled this exception.
* external.cc (cygwin_internal): Make CW_INIT_EXCEPTIONS a no-op.
* sigproc.cc (wait_sig): Accommodate argument change to
_cygtls::init_threadlist_exceptions.
* tlsoffsets.h: Regenerate.
* include/exceptions.h (exception_list): Add more stuff to the exception list.
Apparently windows needs this?
(init_exceptions): Remove bogus declaration.
* include/cygwin/signal.h (SI_USER): Redefine as zero as per SUSv3.
* thread.cc (pthread_kill): Set si_pid and si_uid.
* timer.cc (timer_thread): Set si_code to SI_TIMER.
@
text
@d167 1
a167 2
	    siginfo_t si;
	    memset (&si, 0, sizeof (si));
@


1.19
log
@* cygheap.h (init_cygheap::_gtod): Remove.
* cygwin.din: Export clock_getres and clock_setres.
* hires.h (hires_ms::minperiod): Delete declaration.
(hires_ms::began_period): Ditto.
(hires_ms::prime): Make void.
(hires_ms::resolution): Just define here.
(hires_ms::usecs): Remove unneeded argument.
(gtod): Redeclare as a variable.
* timer.cc (timer_thread): Eliminate argument to gtod.usecs().
(timer_tracker::gettime): Ditto.
(timer_tracker::settime): Ditto.
* times.cc (gettimeofday): Ditto.
(hires_ms::began_period): Delete declaration.
(hires_us::prime): Remove debugging.
(hires_ms::prime): Make void.  Eliminate period stuff.
(hires_ms::usecs): Eliminate argument to gtod.usecs().
(hires_ms::resolution): New function.
(clock_getres): Ditto.
(clock_setres): Ditto.
* version.h: Bump API version to 143.
* include/cygwin/time.h: New file.
@
text
@d171 1
@


1.18
log
@* cygheap.h (init_cygheap::_gtod): New hires_ms element.
* hires.h (hires_ms::minperiod): Remove static designation.
(hires::began_period): New field.
* signal.cc: Include headers required for cygheap.h now that gtod lives in the
cygheap.
* timer.c: Ditto.
* times.cc (gtod): Delete variable.
(gtod::minperiod): Ditto.
(gtod::began_period): Define.
(hires_ms::prime): Add more debugging output.  Call timeBeginPeriod only when
!began_period.
@
text
@d136 1
a136 1
      now = gtod.usecs (false);
d229 1
a229 1
  long long now = in_flags & TIMER_ABSTIME ? 0 : gtod.usecs (false);
d266 1
a266 1
      long long now = gtod.usecs (false);
@


1.17
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d21 4
@


1.16
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d248 1
a248 1
      new cygthread (timer_thread, this, "itimer", syncthread);
@


1.15
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d248 1
a248 1
      (void) new cygthread (timer_thread, this, "itimer", syncthread);
@


1.14
log
@white space and minor comment cleanup.
@
text
@d219 2
a220 1
  if (__check_invalid_read_ptr_errno (value, sizeof (*value))
d222 1
a222 2
      || it_bad (value->it_interval)
      || (ovalue && check_null_invalid_struct_errno (ovalue)))
d274 2
a275 1
  if (check_null_invalid_struct_errno (ovalue))
d279 1
a279 1
  if (check_null_invalid_struct (tt) || tt->magic != TT_MAGIC)
d292 2
a293 2
  if (evp && check_null_invalid_struct_errno (evp)
      || check_null_invalid_struct_errno (timerid))
d310 4
a313 1
  if (check_null_invalid_struct (tt) || tt->magic != TT_MAGIC)
d326 4
a329 1
  if (check_null_invalid_struct (in_tt) || in_tt->magic != TT_MAGIC)
d396 2
a397 1
  if (check_null_invalid_struct_errno (ovalue))
@


1.13
log
@* sync.h (muto::operator int): New operator.
(locker): Remove unused class.
(new_muto): Delete.
(new_muto1): Ditto.
(new_muto_name): Ditto.
* cygheap.cc (cygheap_setup_for_child): Reflect use of static storage for muto
rather than pointer.
(_csbrk): Ditto.
(_cmalloc): Ditto.
(_cmalloc): Ditto.
(_cfree): Ditto.
* cygheap.h (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_drive): Ditto.
* cygmalloc.h (__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* cygtls.cc (sentry::lock): Ditto.
(sentry::sentry): Ditto.
(~sentry): Ditto.
(_cygtls::init): Ditto.
* dcrt0.cc: Ditto.
(cygwin_atexit): Ditto.
(cygwin_exit): Ditto.
* debug.cc (lock_debug::locker): Ditto.
(lock_debug::lock_debug): Ditto.
(lock_debug::unlock): Ditto.
(debug_init): Ditto.
* dtable.cc (dtable::init_lock): Ditto.
* dtable.h (dtable::lock_cs): Ditto.
(dtable::lock): Ditto.
(dtable::unlock): Ditto.
* exceptions.cc (mask_sync): Ditto.
(sighold): Ditto.
(set_process_mask_delta): Ditto.
(set_signal_mask): Ditto.
(events_init): Ditto.
* grp.cc (pwdgrp::pwdgrp): Ditto.
* malloc_wrapper.cc (mallock): Ditto.
(malloc_init): Ditto.
* path.cc (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::init): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* pwdgrp.h (pwdgrp::pglock): Ditto.
(pwdgrp::refresh): Ditto.
* sigproc.cc (sync_proc_subproc): Ditto.
(get_proc_lock): Ditto.
(proc_subproc): Ditto.
(_cygtls::remove_wq): Ditto.
(proc_terminate): Ditto.
(sigproc_init): Ditto.
* timer.cc (lock_timer_tracker::protect): Ditto.
(lock_timer_tracker::lock_timer_tracker): Ditto.
(lock_timer_tracker::~lock_timer_tracker): Ditto.
* wininfo.cc (wininfo::_lock;): Ditto.
(wininfo::winthread): Ditto.
(operator HWND): Ditto.
(wininfo::lock): Ditto.
(wininfo::release): Ditto.
* wininfo.h (wininfo::_lock;): Ditto.
@
text
@d69 1
a69 1
    
d131 1
a131 1
        and sending the signal */
@


1.12
log
@* timer.cc (getitimer): Check that ovalue is a valid pointer, not just NULL.
@
text
@d46 1
a46 1
  static muto *protect;
d52 1
a52 1
muto NO_COPY *lock_timer_tracker::protect;
d56 1
a56 1
  new_muto (protect)->acquire ();
d61 1
a61 1
  protect->release ();
@


1.11
log
@* timer.cc (timer_tracker::settime): Set times to zero when just cancelling a
timer.
@
text
@d389 2
a390 5
  if (ovalue == NULL)
    {
      set_errno (EFAULT);
      return -1;
    }
@


1.10
log
@* cygthread.cc (cygthread::detach): Revert to just waiting for thred event
since waiting for anything else is racy.
* timer.cc (timer_tracker::hcancel): Rename from cancel.
(timer_tracker::cancel): New method.
(timer_tracker::th): Remove.
(timer_tracker::~timer_tracker): Call cancel method.
(timer_tracker::timer_tracker): Ditto.
(timer_tracker::timer_tracker): Always, clear cancel, even though it is
probably not strictly necessary for ttstart.
(timer_thread): Accommodate cancel -> hcancel rename.
(timer_tracker::settime): Ditto.
(timer_tracker::gettime): Ditto.
(timer_delete): Ditto.
* cygwin.din: Export _ctype_.
* include/ctype.h: Mark that _ctype_ is imported.
@
text
@d233 3
a235 1
  if (value->it_value.tv_sec || value->it_value.tv_nsec)
@


1.9
log
@* timer.cc (timer_tracker::timer_tracker): Eliminate simple constructor.
(ttstart): Fully initialize.
* errno.cc: Fix typo introduced in previous change.
@
text
@d29 1
a29 1
  HANDLE cancel;
d33 1
a33 1
  cygthread *th;
d64 12
d78 1
a78 1
  if (cancel)
d80 1
a80 3
      SetEvent (cancel);
      th->detach ();
      CloseHandle (cancel);
d82 1
a82 2
      th = NULL;
      cancel = NULL;
d102 1
a104 1
      cancel = NULL;
d146 1
a146 1
      switch (WaitForSingleObject (tt->cancel, sleep_ms))
d228 1
a228 5
  if (cancel)
    {
      SetEvent (cancel);	// should be closed when the thread exits
      th->detach ();
    }
d238 2
a239 2
      if (!cancel)
	cancel = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
d241 1
a241 1
	ResetEvent (cancel);
d246 1
a246 1
      th = new cygthread (timer_thread, this, "itimer", syncthread);
d255 1
a255 1
  if (!cancel)
d341 1
a341 1
  ttstart.cancel = ttstart.syncthread = NULL;
d346 1
a346 1
      deleteme->cancel = deleteme->syncthread = NULL;
@


1.8
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@a37 1
  timer_tracker () {};
d42 1
a42 1
timer_tracker NO_COPY ttstart;
@


1.7
log
@revert errnoneous checkin
@
text
@a24 1
  static muto *protect;
d28 1
a28 1
  itimerspec it;
d30 3
a32 1
  int flags;
d36 1
d38 3
a40 1
  timer_tracker ();
d43 1
a43 1
timer_tracker ttstart;
d45 7
a51 1
muto *timer_tracker::protect;
d53 3
a55 1
timer_tracker::timer_tracker ()
d57 23
a79 1
  new_muto (protect);
a92 7
  cancel = NULL;
  flags = 0;
  memset (&it, 0, sizeof (it));
  protect->acquire ();
  next = ttstart.next;
  ttstart.next = this;
  protect->release ();
d94 7
d104 1
a104 1
to_us (timespec& ts)
d108 1
a108 1
  res += ts.tv_nsec / 1000 + ((ts.tv_nsec % 1000) >= 500 ? 1 : 0);
a111 3
static NO_COPY itimerspec itzero;
static NO_COPY timespec tzero;

d115 4
a118 3
  timer_tracker *tp = ((timer_tracker *) x);
  timer_tracker tt = *tp;
  for (bool first = true; ; first = false)
d120 11
a130 5
      long long sleep_us = to_us (first ? tt.it.it_value : tt.it.it_interval);
      long long sleep_to = sleep_us;
      long long now = gtod.usecs (false);
      if (tt.flags & TIMER_ABSTIME)
	sleep_us -= now;
d132 4
a135 1
	sleep_to += now;
d137 2
a138 4
      DWORD sleep_ms = (sleep_us < 0) ? 0 : (sleep_us / 1000);
      debug_printf ("%p waiting for %u ms, first %d", x, sleep_ms, first);
      tp->it.it_value = tzero;
      switch (WaitForSingleObject (tt.cancel, sleep_ms))
d144 1
a144 7
	  now = gtod.usecs (false);
	  sleep_us = sleep_to - now;
	  if (sleep_us < 0)
	    sleep_us = 0;
	  tp->it.it_value.tv_sec = sleep_us / 1000000;
	  tp->it.it_value.tv_nsec = (sleep_us % 1000000) * 1000;
	  debug_printf ("%p cancelled, elapsed %D", x, sleep_us);
d147 1
a147 1
	  debug_printf ("%p timer wait failed, %E", x);
d151 1
a151 1
      switch (tt.evp.sigev_notify)
d157 4
a160 4
	    si.si_signo = tt.evp.sigev_signo;
	    si.si_sigval.sival_ptr = tt.evp.sigev_value.sival_ptr;
	    debug_printf ("%p sending sig %d", x, tt.evp.sigev_signo);
	    sig_send (NULL, si);
d167 3
a169 3
	    int rc = pthread_create (&notify_thread, tt.evp.sigev_notify_attributes,
				     (void * (*) (void *)) tt.evp.sigev_notify_function,
				     tt.evp.sigev_value.sival_ptr);
d179 1
a179 1
      if (!tt.it.it_interval.tv_sec && !tt.it.it_interval.tv_nsec)
d181 2
a182 1
      tt.flags = 0;
d187 1
a187 4
  CloseHandle (tt.cancel);
  // FIXME: race here but is it inevitable?
  if (tt.cancel == tp->cancel)
    tp->cancel = NULL;
d211 4
a214 1
  if (__check_invalid_read_ptr_errno (value, sizeof (*value)))
d217 1
a217 2
  if (ovalue && check_null_invalid_struct_errno (ovalue))
    return -1;
d219 2
a220 4
  itimerspec *elapsed;
  if (!cancel)
    elapsed = &itzero;
  else
a223 1
      elapsed = &it;
d227 1
a227 1
    *ovalue = *elapsed;
d231 12
a242 8
      if (it_bad (value->it_value))
	return -1;
      if (it_bad (value->it_interval))
	return -1;
      flags = in_flags;
      cancel = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
      it = *value;
      th = new cygthread (timer_thread, this, "itimer");
d248 34
d285 2
a286 1
  if (evp && check_null_invalid_struct_errno (evp))
a287 3
  if (check_null_invalid_struct_errno (timerid))
    return -1;

d303 6
a308 2
  if (check_null_invalid_struct_errno (tt) || tt->magic != TT_MAGIC)
    return -1;
d316 5
a320 2
  if (check_null_invalid_struct_errno (in_tt) || in_tt->magic != TT_MAGIC)
    return -1;
d322 1
a322 1
  timer_tracker::protect->acquire ();
d326 2
a327 4
	timer_tracker *deleteme = tt->next;
	tt->next = deleteme->next;
	delete deleteme;
	timer_tracker::protect->release ();
a329 2
  timer_tracker::protect->release ();

d337 1
d342 1
d346 92
@


1.6
log
@* pinfo.cc (pinfo::exit): Right shift exit value by eight when not started in a
cygwin environment.
@
text
@d25 1
d36 1
a36 4
  timer_tracker () {};
  static void lock ();
  static void unlock ();
  ~timer_tracker ();
d39 1
a39 9
timer_tracker NO_COPY ttstart;

class lock_timer_tracker
{
  static muto *protect;
public:
  lock_timer_tracker ();
  ~lock_timer_tracker ();
};
d41 1
a41 1
muto NO_COPY *lock_timer_tracker::protect;
d43 1
a43 1
lock_timer_tracker::lock_timer_tracker ()
d45 1
a45 21
  new_muto (protect)->acquire ();
}

lock_timer_tracker::~lock_timer_tracker ()
{
  protect->release ();
}

timer_tracker::~timer_tracker ()
{
  if (cancel)
    {
      SetEvent (cancel);
      th->detach ();
      CloseHandle (cancel);
#ifdef DEBUGGING
      th = NULL;
      cancel = NULL;
#endif
    }
  magic = 0;
a49 1
  lock_timer_tracker now;
d62 1
d65 1
d70 1
a70 1
to_us (const timespec& ts)
d74 1
a74 1
  res += ts.tv_nsec / 1000 + (ts.tv_nsec % 1000) ? 1 : 0;
d153 4
a185 1
  lock_timer_tracker now;
d191 1
a191 1
      SetEvent (cancel);
a192 2
      CloseHandle (cancel);
      th = NULL;
d249 1
a249 1
  lock_timer_tracker now;
d253 4
a256 2
	tt->next = in_tt->next;
	delete in_tt;
d259 2
@


1.5
log
@update copyright
@
text
@a24 1
  static muto *protect;
d35 4
a38 1
  timer_tracker ();
d41 9
a49 1
timer_tracker ttstart;
d51 1
a51 1
muto *timer_tracker::protect;
d53 1
a53 1
timer_tracker::timer_tracker ()
d55 21
a75 1
  new_muto (protect);
d80 1
a92 1
  protect->acquire ();
a94 1
  protect->release ();
d99 1
a99 1
to_us (timespec& ts)
d103 1
a103 1
  res += ts.tv_nsec / 1000 + ((ts.tv_nsec % 1000) >= 500 ? 1 : 0);
a181 4
  CloseHandle (tt.cancel);
  // FIXME: race here but is it inevitable?
  if (tt.cancel == tp->cancel)
    tp->cancel = NULL;
d211 1
d217 1
a217 1
      SetEvent (cancel);	// should be closed when the thread exits
d219 2
d277 1
a277 1
  timer_tracker::protect->acquire ();
d281 2
a282 4
	timer_tracker *deleteme = tt->next;
	tt->next = deleteme->next;
	delete deleteme;
	timer_tracker::protect->release ();
a284 2
  timer_tracker::protect->release ();

@


1.4
log
@* timer.cc (timer_thread): Pass sigev pointer value as per SuSv3 rather than
pointer to sigev.
@
text
@d3 1
a3 1
   Copyright 2004 Red Hat, Inc.
@


1.3
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d136 1
a136 1
				     &tt.evp.sigev_value);
@


1.2
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@a18 1
#include "cygthread.h"
@


1.2.4.1
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d19 1
@


1.1
log
@file timer.cc was initially added on branch cgf-deleteme.
@
text
@d1 275
@


1.1.2.1
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
@
text
@a0 275
/* timer.cc

   Copyright 2004 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <time.h>
#include <stdlib.h>
#include "cygerrno.h"
#include "security.h"
#include "hires.h"
#include "thread.h"
#include "cygtls.h"
#include "cygthread.h"
#include "sigproc.h"
#include "sync.h"

#define TT_MAGIC 0x513e4a1c
struct timer_tracker
{
  static muto *protect;
  unsigned magic;
  clockid_t clock_id;
  sigevent evp;
  itimerspec it;
  HANDLE cancel;
  int flags;
  cygthread *th;
  struct timer_tracker *next;
  int settime (int, const itimerspec *, itimerspec *);
  timer_tracker (clockid_t, const sigevent *);
  timer_tracker ();
};

timer_tracker ttstart;

muto *timer_tracker::protect;

timer_tracker::timer_tracker ()
{
  new_muto (protect);
}

timer_tracker::timer_tracker (clockid_t c, const sigevent *e)
{
  if (e != NULL)
    evp = *e;
  else
    {
      evp.sigev_notify = SIGEV_SIGNAL;
      evp.sigev_signo = SIGALRM;
      evp.sigev_value.sival_ptr = this;
    }
  clock_id = c;
  cancel = NULL;
  flags = 0;
  memset (&it, 0, sizeof (it));
  protect->acquire ();
  next = ttstart.next;
  ttstart.next = this;
  protect->release ();
  magic = TT_MAGIC;
}

static long long
to_us (timespec& ts)
{
  long long res = ts.tv_sec;
  res *= 1000000;
  res += ts.tv_nsec / 1000 + ((ts.tv_nsec % 1000) >= 500 ? 1 : 0);
  return res;
}

static NO_COPY itimerspec itzero;
static NO_COPY timespec tzero;

static DWORD WINAPI
timer_thread (VOID *x)
{
  timer_tracker *tp = ((timer_tracker *) x);
  timer_tracker tt = *tp;
  for (bool first = true; ; first = false)
    {
      long long sleep_us = to_us (first ? tt.it.it_value : tt.it.it_interval);
      long long sleep_to = sleep_us;
      long long now = gtod.usecs (false);
      if (tt.flags & TIMER_ABSTIME)
	sleep_us -= now;
      else
	sleep_to += now;

      DWORD sleep_ms = (sleep_us < 0) ? 0 : (sleep_us / 1000);
      debug_printf ("%p waiting for %u ms, first %d", x, sleep_ms, first);
      tp->it.it_value = tzero;
      switch (WaitForSingleObject (tt.cancel, sleep_ms))
	{
	case WAIT_TIMEOUT:
	  debug_printf ("timed out");
	  break;
	case WAIT_OBJECT_0:
	  now = gtod.usecs (false);
	  sleep_us = sleep_to - now;
	  if (sleep_us < 0)
	    sleep_us = 0;
	  tp->it.it_value.tv_sec = sleep_us / 1000000;
	  tp->it.it_value.tv_nsec = (sleep_us % 1000000) * 1000;
	  debug_printf ("%p cancelled, elapsed %D", x, sleep_us);
	  goto out;
	default:
	  debug_printf ("%p timer wait failed, %E", x);
	  goto out;
	}

      switch (tt.evp.sigev_notify)
	{
	case SIGEV_SIGNAL:
	  {
	    siginfo_t si;
	    memset (&si, 0, sizeof (si));
	    si.si_signo = tt.evp.sigev_signo;
	    si.si_sigval.sival_ptr = tt.evp.sigev_value.sival_ptr;
	    debug_printf ("%p sending sig %d", x, tt.evp.sigev_signo);
	    sig_send (NULL, si);
	    break;
	  }
	case SIGEV_THREAD:
	  {
	    pthread_t notify_thread;
	    debug_printf ("%p starting thread", x);
	    int rc = pthread_create (&notify_thread, tt.evp.sigev_notify_attributes,
				     (void * (*) (void *)) tt.evp.sigev_notify_function,
				     &tt.evp.sigev_value);
	    if (rc)
	      {
		debug_printf ("thread creation failed, %E");
		return 0;
	      }
	    // FIXME: pthread_join?
	    break;
	  }
	}
      if (!tt.it.it_interval.tv_sec && !tt.it.it_interval.tv_nsec)
	break;
      tt.flags = 0;
      debug_printf ("looping");
    }

out:
  CloseHandle (tt.cancel);
  // FIXME: race here but is it inevitable?
  if (tt.cancel == tp->cancel)
    tp->cancel = NULL;
  return 0;
}

static bool
it_bad (const timespec& t)
{
  if (t.tv_nsec < 0 || t.tv_nsec >= 1000000000 || t.tv_sec < 0)
    {
      set_errno (EINVAL);
      return true;
    }
  return false;
}

int
timer_tracker::settime (int in_flags, const itimerspec *value, itimerspec *ovalue)
{
  if (!value)
    {
      set_errno (EINVAL);
      return -1;
    }

  if (__check_invalid_read_ptr_errno (value, sizeof (*value)))
    return -1;

  if (ovalue && check_null_invalid_struct_errno (ovalue))
    return -1;

  itimerspec *elapsed;
  if (!cancel)
    elapsed = &itzero;
  else
    {
      SetEvent (cancel);	// should be closed when the thread exits
      th->detach ();
      elapsed = &it;
    }

  if (ovalue)
    *ovalue = *elapsed;

  if (value->it_value.tv_sec || value->it_value.tv_nsec)
    {
      if (it_bad (value->it_value))
	return -1;
      if (it_bad (value->it_interval))
	return -1;
      flags = in_flags;
      cancel = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
      it = *value;
      th = new cygthread (timer_thread, this, "itimer");
    }

  return 0;
}

extern "C" int
timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
{
  if (evp && check_null_invalid_struct_errno (evp))
    return -1;
  if (check_null_invalid_struct_errno (timerid))
    return -1;

  if (clock_id != CLOCK_REALTIME)
    {
      set_errno (EINVAL);
      return -1;
    }

  *timerid = (timer_t) new timer_tracker (clock_id, evp);
  return 0;
}

extern "C" int
timer_settime (timer_t timerid, int flags, const struct itimerspec *value,
	       struct itimerspec *ovalue)
{
  timer_tracker *tt = (timer_tracker *) timerid;
  if (check_null_invalid_struct_errno (tt) || tt->magic != TT_MAGIC)
    return -1;
  return tt->settime (flags, value, ovalue);
}

extern "C" int
timer_delete (timer_t timerid)
{
  timer_tracker *in_tt = (timer_tracker *) timerid;
  if (check_null_invalid_struct_errno (in_tt) || in_tt->magic != TT_MAGIC)
    return -1;

  timer_tracker::protect->acquire ();
  for (timer_tracker *tt = &ttstart; tt->next != NULL; tt = tt->next)
    if (tt->next == in_tt)
      {
	timer_tracker *deleteme = tt->next;
	tt->next = deleteme->next;
	delete deleteme;
	timer_tracker::protect->release ();
	return 0;
      }
  timer_tracker::protect->release ();

  set_errno (EINVAL);
  return 0;
}

void
fixup_timers_after_fork ()
{
  for (timer_tracker *tt = &ttstart; tt->next != NULL; /* nothing */)
    {
      timer_tracker *deleteme = tt->next;
      tt->next = deleteme->next;
      delete deleteme;
    }
}
@

