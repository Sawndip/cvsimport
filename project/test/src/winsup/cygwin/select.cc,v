head	1.224;
access;
symbols
	cygwin-1_7_35-release:1.223
	cygwin-1_7_34-release:1.223
	cygwin-1_7_33-release:1.220.2.2
	cygwin-1_7_32-release:1.220.2.1
	cygwin-1_7_31-release:1.220.2.1
	cygwin-1_7_30-release:1.220
	cygwin-1_7_29-release:1.220
	cygwin-1_7_29-release-branchpoint:1.220.0.2
	cygwin-pre-user-db:1.220
	cygwin-1_7_28-release:1.220
	cygwin-1_7_27-release:1.220
	cygwin-1_7_26-release:1.219
	cygwin-1_7_25-release:1.217
	cygwin-1_7_24-release:1.217
	cygwin-1_7_23-release:1.217
	cygwin-1_7_22-release:1.217
	cygwin-1_7_21-release:1.217
	cygwin-1_7_20-release:1.217
	cygwin-1_7_19-release:1.217
	cygwin-64bit-postmerge:1.217
	cygwin-64bit-premerge-branch:1.216.0.2
	cygwin-64bit-premerge:1.216
	cygwin-1_7_18-release:1.216
	post-ptmalloc3:1.207.2.9
	pre-ptmalloc3:1.207.2.9
	cygwin-1_7_17-release:1.207
	cygwin-64bit-branch:1.207.0.2
	cygwin-1_7_16-release:1.205
	cygwin-1_7_15-release:1.194
	cygwin-1_7_14_2-release:1.194
	cygwin-1_7_14-release:1.194
	cygwin-1_7_12-release:1.193
	cygwin-1_7_11-release:1.192
	cygwin-1_7_10-release:1.192
	signal-rewrite:1.176.0.2
	pre-notty:1.174
	cygwin-1_7_9-release:1.162
	cv-post-1_7_9:1.162.0.2
	cygwin-1_7_8-release:1.162
	cygwin-1_7_7-release:1.161
	cygwin-1_7_5-release:1.160
	cygwin-1_7_4-release:1.160
	cygwin-1_7_3-release:1.160
	cygwin-1_7_2-release:1.157
	fifo_doover3:1.156.0.2
	cygwin-1_7_1-release:1.154
	prefifo:1.153
	cv-branch-2:1.146.0.2
	pre-ripout-set_console_state_for_spawn:1.140
	EOL_registry_mounts:1.138
	preoverlapped:1.134
	drop_9x_support_start:1.134
	cr-0x5f1:1.128.0.2
	cv-branch:1.127.0.2
	pre-ptymaster-archetype:1.126
	cr-0x3b58:1.121.0.4
	cr-0x5ef:1.121.0.2
	after-mmap-privanon-noreserve:1.120
	after-mmap-revamp:1.120
	before-mmap-revamp:1.120
	cgf-more-exit-sync:1.119
	post_wait_sig_exit:1.118
	pre_wait_sig_exit:1.118
	reparent-point:1.102
	noreparent:1.102.0.2
	cr-0x5e6:1.93.0.2
	cr-0x9e:1.90.0.6
	cr-0x9d:1.90.0.4
	cgf-deleteme:1.90.0.2
	pre-sigrewrite:1.88
	corinna-01:1.88
	cr-0x9c:1.87.0.6
	cr-0x9b:1.87.0.4
	cr-0x99:1.87
	Z-emcb-cygwin_daemon:1.87.0.2
	w32api-2_2:1.84
	mingw-runtime-2_4:1.84
	pre-cgf-merge:1.87
	cgf-dev-branch:1.83.0.6
	predaemon:1.70
	cygwin_daemon_merge_HEAD:1.70
	pregp02r1:1.70.0.2
	cygnus_cvs_20020108_pre:1.69
	Z-cygwin_daemon_merge-new_HEAD:1.79
	Z-cygwin_daemon_merge_HEAD:1.79
	cygwin_daemon:1.48.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.224
date	2015.03.05.12.57.33;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2014.10.11.12.14.29;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2014.06.23.14.56.45;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2013.12.03.20.28.55;	author cgf;	state Exp;
branches
	1.220.2.1;
next	1.219;

1.219
date	2013.11.24.12.13.35;	author corinna;	state Exp;
branches;
next	1.218;

1.218
date	2013.10.30.09.44.47;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2013.03.31.12.37.45;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2013.01.11.15.36.40;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2012.12.22.19.35.40;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2012.12.19.21.15.54;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2012.12.19.18.44.40;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2012.12.18.17.32.45;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2012.12.18.16.41.38;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2012.11.23.13.22.46;	author cgf;	state Exp;
branches;
next	1.207;

1.207
date	2012.07.23.04.36.48;	author cgf;	state Exp;
branches
	1.207.2.1;
next	1.206;

1.206
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2012.07.06.13.52.17;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2012.06.27.21.42.11;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.201;

1.201
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2012.06.10.01.57.53;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2012.06.03.16.31.33;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2012.06.03.03.29.47;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2012.06.03.02.59.19;	author cgf;	state Exp;
branches;
next	1.196;

1.196
date	2012.05.29.13.11.34;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2012.05.25.14.33.18;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2012.04.05.02.54.51;	author cgf;	state Exp;
branches;
next	1.193;

1.193
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2012.02.01.05.27.42;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2012.01.22.06.45.08;	author cgf;	state Exp;
branches;
next	1.190;

1.190
date	2011.12.13.20.08.10;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2011.12.13.20.06.30;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2011.12.11.01.25.20;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2011.12.09.16.02.56;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2011.12.09.03.19.41;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2011.12.08.20.24.33;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2011.12.08.07.03.14;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2011.12.08.06.49.56;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2011.12.07.23.14.47;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2011.12.04.18.32.00;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2011.11.29.15.34.48;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2011.11.24.21.36.52;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2011.07.29.12.47.54;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2011.06.14.21.48.43;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2011.06.04.01.06.17;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2011.06.01.01.20.28;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2011.06.01.00.57.49;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2011.05.04.13.06.10;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2011.05.03.15.58.52;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2011.05.02.15.28.35;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2011.05.01.14.35.12;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2011.04.30.16.34.48;	author corinna;	state Exp;
branches;
next	1.166;

1.166
date	2011.04.29.08.27.11;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2011.04.20.15.32.31;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2011.04.20.01.10.54;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2011.04.04.12.23.36;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2010.09.01.18.24.10;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2010.08.30.10.39.43;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2010.04.02.22.36.44;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2010.04.02.15.50.54;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2010.03.31.15.00.48;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2010.02.15.01.45.05;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2009.12.23.00.35.18;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2009.12.16.14.56.10;	author corinna;	state Exp;
branches;
next	1.154;

1.154
date	2009.09.01.14.25.10;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2009.07.06.15.42.01;	author corinna;	state Exp;
branches;
next	1.152;

1.152
date	2009.06.30.21.18.43;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2009.06.30.14.36.11;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2009.06.29.14.32.58;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2009.06.28.19.27.15;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2009.06.28.19.23.13;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2009.06.28.18.23.35;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2009.02.27.00.34.40;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2009.01.22.16.00.58;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2008.09.11.05.43.11;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2008.07.30.04.58.23;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2008.07.11.16.37.29;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2008.05.30.17.56.37;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2007.07.07.17.29.20;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2007.07.07.17.00.33;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2006.10.11.16.21.12;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2006.07.28.08.50.46;	author corinna;	state Exp;
branches;
next	1.131;

1.131
date	2006.07.27.13.58.54;	author corinna;	state Exp;
branches;
next	1.130;

1.130
date	2006.07.27.09.11.38;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2006.07.25.17.18.05;	author cgf;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2006.06.04.20.32.58;	author cgf;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2006.05.24.03.39.29;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2006.05.24.00.56.24;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2006.05.21.17.27.14;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2006.04.24.15.16.45;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2006.04.23.08.39.07;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2005.12.07.22.28.49;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2005.10.17.21.22.18;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2005.08.23.22.22.52;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2005.07.03.02.40.29;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2005.05.10.20.56.07;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2005.05.02.03.50.08;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2005.04.19.08.32.56;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2005.04.18.18.56.52;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2005.03.24.14.04.05;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2005.03.23.17.27.18;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2005.03.22.19.00.30;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2005.03.21.18.56.50;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2005.02.22.15.39.45;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.13.18.17.29;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2004.11.26.04.15.08;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2004.10.26.21.13.50;	author cgf;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2004.10.20.04.49.34;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2004.10.20.01.03.55;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2004.10.20.01.02.18;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2004.10.13.03.26.31;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2004.10.11.02.21.30;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2004.09.12.03.47.57;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2004.09.03.01.32.02;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2004.08.10.15.05.37;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2004.04.10.13.45.10;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2004.04.09.08.43.29;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2003.12.07.22.37.12;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2003.04.23.01.27.51;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2003.03.09.20.10.25;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.11.04.00.04;	author cgf;	state Exp;
branches
	1.83.4.1
	1.83.6.1;
next	1.82;

1.82
date	2002.11.15.18.58.12;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.30.15.17.44;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2002.08.31.03.35.50;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.19.04.43.58;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.01.16.20.31;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2002.07.29.03.18.41;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2002.07.06.11.16.07;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2002.07.05.18.26.23;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2002.03.05.02.23.39;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2002.02.14.21.20.06;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.12.11.00.24.46;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.08.17.49.52;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.08.15.01.44;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.06.18.02.56;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2001.11.05.06.09.08;	author cgf;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2001.11.05.00.29.27;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2001.11.04.03.29.15;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.04.02.31.58;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.03.05.42.21;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.03.03.32.27;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.02.04.44.06;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.01.23.48.34;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.29.16.12.47;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.29.05.28.24;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.26.04.06.27;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.14.04.14.23;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.01.04.10.07;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.26.22.24.09;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.25.06.19.10;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.24.22.49.12;	author cgf;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2001.09.24.21.50.44;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.31.05.06.14;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.30.08.21.09;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.28.20.39.22;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.28.20.38.07;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.27.15.59.26;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.03.15.00.38;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.04.18.21.10.13;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.14.22.11.03;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.20.19.50.28;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.18.21.11.25;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.18.18.05.01;	author duda;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.18.03.34.05;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.02.01.55.21;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.01.17.14.57.09;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.16.03.11.02;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.09.02.03.33;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.08.03.12.13;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.07.16.23.51;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.24.21.19.14;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.10.19.33.54;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.09.02.33.47;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.04.01.33.33;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.30.17.58.48;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.29.16.24.39;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.27.17.30.48;	author dj;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.06.20.00.47.52;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.18.18.32.05;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.17.05.49.51;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.13.01.42.53;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.11.21.22.53;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.03.18.15.01;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.30.03.51.30;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.12.06.29.54;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.04.07.13;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.220.2.1
date	2014.07.15.14.34.38;	author corinna;	state Exp;
branches;
next	1.220.2.2;

1.220.2.2
date	2014.11.13.12.53.05;	author corinna;	state Exp;
branches;
next	;

1.207.2.1
date	2012.11.12.17.26.24;	author corinna;	state Exp;
branches;
next	1.207.2.2;

1.207.2.2
date	2012.11.16.13.48.24;	author corinna;	state Exp;
branches;
next	1.207.2.3;

1.207.2.3
date	2012.11.23.15.14.39;	author corinna;	state Exp;
branches;
next	1.207.2.4;

1.207.2.4
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.207.2.5;

1.207.2.5
date	2012.12.19.10.34.12;	author corinna;	state Exp;
branches;
next	1.207.2.6;

1.207.2.6
date	2012.12.20.16.52.17;	author corinna;	state Exp;
branches;
next	1.207.2.7;

1.207.2.7
date	2013.01.09.16.27.21;	author corinna;	state Exp;
branches;
next	1.207.2.8;

1.207.2.8
date	2013.01.14.12.57.05;	author corinna;	state Exp;
branches;
next	1.207.2.9;

1.207.2.9
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	;

1.128.2.1
date	2008.02.18.14.08.37;	author corinna;	state Exp;
branches;
next	;

1.127.2.1
date	2006.07.25.17.02.36;	author corinna;	state Exp;
branches;
next	1.127.2.2;

1.127.2.2
date	2006.07.25.17.37.28;	author corinna;	state Exp;
branches;
next	;

1.102.2.1
date	2004.11.16.15.16.57;	author cgf;	state Exp;
branches;
next	1.102.2.2;

1.102.2.2
date	2004.11.18.00.48.40;	author cgf;	state Exp;
branches;
next	1.102.2.3;

1.102.2.3
date	2004.11.24.05.48.30;	author cgf;	state Exp;
branches;
next	;

1.83.4.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	;

1.83.6.1
date	2003.01.16.01.27.31;	author cgf;	state Exp;
branches;
next	1.83.6.2;

1.83.6.2
date	2003.02.05.14.25.11;	author cgf;	state Exp;
branches;
next	1.83.6.3;

1.83.6.3
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.83.6.4;

1.83.6.4
date	2003.03.02.23.39.10;	author cgf;	state Exp;
branches;
next	1.83.6.5;

1.83.6.5
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.83.6.6;

1.83.6.6
date	2003.05.10.17.20.54;	author cgf;	state Exp;
branches;
next	1.83.6.7;

1.83.6.7
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.64.2.1
date	2001.11.06.18.09.42;	author cgf;	state Exp;
branches;
next	;

1.48.2.1
date	2001.09.25.06.38.58;	author rbcollins;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2001.09.27.12.33.43;	author rbcollins;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2001.10.02.12.09.55;	author rbcollins;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.48.2.5;

1.48.2.5
date	2002.02.28.12.53.27;	author rbcollins;	state Exp;
branches;
next	1.48.2.6;

1.48.2.6
date	2002.06.13.14.34.11;	author rbcollins;	state Exp;
branches;
next	1.48.2.7;

1.48.2.7
date	2002.07.06.22.28.19;	author scottc;	state Exp;
branches;
next	1.48.2.8;

1.48.2.8
date	2002.07.29.10.54.14;	author scottc;	state Exp;
branches;
next	1.48.2.9;

1.48.2.9
date	2002.08.01.20.34.07;	author scottc;	state Exp;
branches;
next	1.48.2.10;

1.48.2.10
date	2002.08.24.12.25.31;	author scottc;	state Exp;
branches;
next	1.48.2.11;

1.48.2.11
date	2002.09.03.13.52.07;	author scottc;	state Exp;
branches;
next	1.48.2.12;

1.48.2.12
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.13.2.1
date	2000.07.30.17.58.51;	author cgf;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2000.08.04.00.48.23;	author cgf;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.224
log
@	* fhandler.h (fhandler_base::get_echo_handle): New virtual method.
	(class fhandler_pty_master): Add echo_r and echo_w handles constituting
	read and write side of new echo pipe.
	* select.cc (peek_pipe): On pty masters, check additionally if input
	from the echo pipe is available.
	* fhandler_tty.cc (fhandler_pty_master::doecho): Drop output_mutex
	locking.  Write output to echo pipe.
	(fhandler_pty_master::process_slave_output): Check if input is available
	in echo pipe and prefer to read from it, if so.
	(fhandler_pty_slave::write): Drop output_mutex locking.
	(fhandler_pty_master::fhandler_pty_master): Initialize echo pipe
	handles to NULL.
	(fhandler_pty_master::close): Close and NULL echo pipe handles.
	(fhandler_pty_master::setup): Create echo pipe, close in case of error.
@
text
@/* select.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* The following line means that the BSD socket definitions for
   fd_set, FD_ISSET etc. are used in this file.  */

#define  __INSIDE_CYGWIN_NET__

#include "winsup.h"
#include <stdlib.h>
#include <sys/param.h>
#include "ntdll.h"

#define USE_SYS_TYPES_FD_SET
#include <winsock2.h>
#include <netdb.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "select.h"
#include "dtable.h"
#include "cygheap.h"
#include "pinfo.h"
#include "sigproc.h"
#include "cygtls.h"
#include "cygwait.h"

/*
 * All these defines below should be in sys/types.h
 * but because of the includes above, they may not have
 * been included. We create special UNIX_xxxx versions here.
 */

#ifndef NBBY
#define NBBY 8    /* number of bits in a byte */
#endif /* NBBY */

/*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 */

#define UNIX_NFDBITS (sizeof (fd_mask) * NBBY)       /* bits per mask */
#ifndef unix_howmany
#define unix_howmany(x,y) (((x)+((y)-1))/(y))
#endif

#define unix_fd_set fd_set

#define NULL_fd_set ((fd_set *) NULL)
#define sizeof_fd_set(n) \
  ((size_t) (NULL_fd_set->fds_bits + unix_howmany ((n), UNIX_NFDBITS)))
#define UNIX_FD_SET(n, p) \
  ((p)->fds_bits[(n)/UNIX_NFDBITS] |= (1L << ((n) % UNIX_NFDBITS)))
#define UNIX_FD_CLR(n, p) \
  ((p)->fds_bits[(n)/UNIX_NFDBITS] &= ~(1L << ((n) % UNIX_NFDBITS)))
#define UNIX_FD_ISSET(n, p) \
  ((p)->fds_bits[(n)/UNIX_NFDBITS] & (1L << ((n) % UNIX_NFDBITS)))
#define UNIX_FD_ZERO(p, n) \
  memset ((caddr_t) (p), 0, sizeof_fd_set ((n)))

#define allocfd_set(n) ({\
  size_t __sfds = sizeof_fd_set (n) + 8; \
  void *__res = alloca (__sfds); \
  memset (__res, 0, __sfds); \
  (fd_set *) __res; \
})

#define copyfd_set(to, from, n) memcpy (to, from, sizeof_fd_set (n));

#define set_handle_or_return_if_not_open(h, s) \
  h = (s)->fh->get_handle (); \
  if (cygheap->fdtab.not_open ((s)->fd)) \
    { \
      (s)->thread_errno =  EBADF; \
      return -1; \
    }

static int select (int, fd_set *, fd_set *, fd_set *, DWORD);

/* The main select code.  */
extern "C" int
cygwin_select (int maxfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
	       struct timeval *to)
{
  select_printf ("select(%d, %p, %p, %p, %p)", maxfds, readfds, writefds, exceptfds, to);

  pthread_testcancel ();
  int res;
  if (maxfds < 0)
    {
      set_errno (EINVAL);
      res = -1;
    }
  else
    {
      /* Convert to milliseconds or INFINITE if to == NULL */
      DWORD ms = to ? (to->tv_sec * 1000) + (to->tv_usec / 1000) : INFINITE;
      if (ms == 0 && to->tv_usec)
	ms = 1;			/* At least 1 ms granularity */

      if (to)
	select_printf ("to->tv_sec %ld, to->tv_usec %ld, ms %d", to->tv_sec, to->tv_usec, ms);
      else
	select_printf ("to NULL, ms %x", ms);

      res = select (maxfds, readfds ?: allocfd_set (maxfds),
		    writefds ?: allocfd_set (maxfds),
		    exceptfds ?: allocfd_set (maxfds), ms);
    }
  syscall_printf ("%R = select(%d, %p, %p, %p, %p)", res, maxfds, readfds,
		  writefds, exceptfds, to);
  return res;
}

/* This function is arbitrarily split out from cygwin_select to avoid odd
   gcc issues with the use of allocfd_set and improper constructor handling
   for the sel variable.  */
static int
select (int maxfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
	DWORD ms)
{
  int res = select_stuff::select_loop;

  LONGLONG start_time = gtod.msecs ();	/* Record the current time for later use. */

  select_stuff sel;
  sel.return_on_signal = 0;

  /* Allocate some fd_set structures using the number of fds as a guide. */
  fd_set *r = allocfd_set (maxfds);
  fd_set *w = allocfd_set (maxfds);
  fd_set *e = allocfd_set (maxfds);

  while (res == select_stuff::select_loop)
    {
      /* Build the select record per fd linked list and set state as
	 needed. */
      for (int i = 0; i < maxfds; i++)
	if (!sel.test_and_set (i, readfds, writefds, exceptfds))
	  {
	    select_printf ("aborting due to test_and_set error");
	    return -1;	/* Invalid fd, maybe? */
	  }
      select_printf ("sel.always_ready %d", sel.always_ready);

      /* Degenerate case.  No fds to wait for.  Just wait for time to run out
	 or signal to arrive. */
      if (sel.start.next == NULL)
	switch (cygwait (ms))
	  {
	  case WAIT_SIGNALED:
	    select_printf ("signal received");
	    /* select() is always interrupted by a signal so set EINTR,
	       unconditionally, ignoring any SA_RESTART detection by
	       call_signal_handler().  */
	    _my_tls.call_signal_handler ();
	    set_sig_errno (EINTR);
	    res = select_stuff::select_signalled;
	    break;
	  case WAIT_CANCELED:
	    sel.destroy ();
	    pthread::static_cancel_self ();
	    /*NOTREACHED*/
	  default:
	    res = select_stuff::select_set_zero;	/* Set res to zero below. */
	    break;
	  }
      else if (sel.always_ready || ms == 0)
	res = 0;					/* Catch any active fds via
							   sel.poll() below */
      else
	res = sel.wait (r, w, e, ms);			/* wait for an fd to become
							   become active or time out */
      select_printf ("res %d", res);
      if (res >= 0)
	{
	  copyfd_set (readfds, r, maxfds);
	  copyfd_set (writefds, w, maxfds);
	  copyfd_set (exceptfds, e, maxfds);
	  if (res == select_stuff::select_set_zero)
	    res = 0;
	  else
	    /* Set the bit mask from sel records */
	    res = sel.poll (readfds, writefds, exceptfds) ?: select_stuff::select_loop;
	}
      /* Always clean up everything here.  If we're looping then build it
	 all up again.  */
      sel.cleanup ();
      sel.destroy ();
      /* Recalculate the time remaining to wait if we are going to be looping. */
      if (res == select_stuff::select_loop && ms != INFINITE)
	{
	  select_printf ("recalculating ms");
	  LONGLONG now = gtod.msecs ();
	  if (now > (start_time + ms))
	    {
	      select_printf ("timed out after verification");
	      res = 0;
	    }
	  else
	    {
	      ms -= (now - start_time);
	      start_time = now;
	      select_printf ("ms now %u", ms);
	    }
	}
    }

  if (res < -1)
    res = -1;
  return res;
}

extern "C" int
pselect(int maxfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
	const struct timespec *ts, const sigset_t *set)
{
  struct timeval tv;
  sigset_t oldset = _my_tls.sigmask;

  __try
    {
      if (ts)
	{
	  tv.tv_sec = ts->tv_sec;
	  tv.tv_usec = ts->tv_nsec / 1000;
	}
      if (set)
	set_signal_mask (_my_tls.sigmask, *set);
      int ret = cygwin_select (maxfds, readfds, writefds, exceptfds,
			       ts ? &tv : NULL);
      if (set)
	set_signal_mask (_my_tls.sigmask, oldset);
      return ret;
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

/* Call cleanup functions for all inspected fds.  Gets rid of any
   executing threads. */
void
select_stuff::cleanup ()
{
  select_record *s = &start;

  select_printf ("calling cleanup routines");
  while ((s = s->next))
    if (s->cleanup)
      {
	s->cleanup (s, this);
	s->cleanup = NULL;
      }
}

/* Destroy all storage associated with select stuff. */
inline void
select_stuff::destroy ()
{
  select_record *s;
  select_record *snext = start.next;

  select_printf ("deleting select records");
  while ((s = snext))
    {
      snext = s->next;
      delete s;
    }
  start.next = NULL;
}

select_stuff::~select_stuff ()
{
  cleanup ();
  destroy ();
}

#ifdef DEBUGGING
void
select_record::dump_select_record ()
{
  select_printf ("fd %d, h %p, fh %p, thread_errno %d, windows_handle %p",
		 fd, h, fh, thread_errno, windows_handle);
  select_printf ("read_ready %d, write_ready %d, except_ready %d",
		 read_ready, write_ready, except_ready);
  select_printf ("read_selected %d, write_selected %d, except_selected %d, except_on_write %d",
		 read_selected, write_selected, except_selected, except_on_write);
                    
  select_printf ("startup %p, peek %p, verify %p cleanup %p, next %p",
		 startup, peek, verify, cleanup, next);
}
#endif /*DEBUGGING*/

/* Add a record to the select chain */
bool
select_stuff::test_and_set (int i, fd_set *readfds, fd_set *writefds,
			    fd_set *exceptfds)
{
  if (!UNIX_FD_ISSET (i, readfds) && !UNIX_FD_ISSET (i, writefds)
      && ! UNIX_FD_ISSET (i, exceptfds))
    return true;

  select_record *s = new select_record;
  if (!s)
    return false;

  s->next = start.next;
  start.next = s;

  if (UNIX_FD_ISSET (i, readfds) && !cygheap->fdtab.select_read (i, this))
    goto err;
  if (UNIX_FD_ISSET (i, writefds) && !cygheap->fdtab.select_write (i, this))
    goto err;
  if (UNIX_FD_ISSET (i, exceptfds) && !cygheap->fdtab.select_except (i, this))
    goto err; /* error */

  if (s->read_ready || s->write_ready || s->except_ready)
    always_ready = true;

  if (s->windows_handle)
    windows_used = true;

#ifdef DEBUGGING
  s->dump_select_record ();
#endif
  return true;

err:
  start.next = s->next;
  delete s;
  return false;
}

/* The heart of select.  Waits for an fd to do something interesting. */
select_stuff::wait_states
select_stuff::wait (fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
		    DWORD ms)
{
  HANDLE w4[MAXIMUM_WAIT_OBJECTS];
  select_record *s = &start;
  DWORD m = 0;

  set_signal_arrived here (w4[m++]);
  if ((w4[m] = pthread::get_cancel_event ()) != NULL)
    m++;

  DWORD startfds = m;
  /* Loop through the select chain, starting up anything appropriate and
     counting the number of active fds. */
  while ((s = s->next))
    {
      if (m >= MAXIMUM_WAIT_OBJECTS)
	{
	  set_sig_errno (EINVAL);
	  return select_error;
	}
      if (!s->startup (s, this))
	{
	  s->set_select_errno ();
	  return select_error;
	}
      if (s->h != NULL)
	{
	  for (DWORD i = startfds; i < m; i++)
	    if (w4[i] == s->h)
	      goto next_while;
	  w4[m++] = s->h;
	}
next_while:;
    }

  debug_printf ("m %d, ms %u", m, ms);

  DWORD wait_ret;
  if (!windows_used)
    wait_ret = WaitForMultipleObjects (m, w4, FALSE, ms);
  else
    /* Using MWMO_INPUTAVAILABLE is the officially supported solution for
       the problem that the call to PeekMessage disarms the queue state
       so that a subsequent MWFMO hangs, even if there are still messages
       in the queue. */
    wait_ret = MsgWaitForMultipleObjectsEx (m, w4, ms,
					    QS_ALLINPUT | QS_ALLPOSTMESSAGE,
					    MWMO_INPUTAVAILABLE);
  select_printf ("wait_ret %d, m = %d.  verifying", wait_ret, m);

  wait_states res;
  switch (wait_ret)
    {
    case WAIT_OBJECT_0:
      select_printf ("signal received");
      /* Need to get rid of everything when a signal occurs since we can't
	 be assured that a signal handler won't jump out of select entirely. */
      cleanup ();
      destroy ();
      /* select() is always interrupted by a signal so set EINTR,
	 unconditionally, ignoring any SA_RESTART detection by
	 call_signal_handler().  */
      _my_tls.call_signal_handler ();
      set_sig_errno (EINTR);
      res = select_signalled;	/* Cause loop exit in cygwin_select */
      break;
    case WAIT_FAILED:
      system_printf ("WaitForMultipleObjects failed, %E");
      s = &start;
      s->set_select_errno ();
      res = select_error;
      break;
    case WAIT_TIMEOUT:
      select_printf ("timed out");
      res = select_set_zero;
      break;
    case WAIT_OBJECT_0 + 1:
      if (startfds > 1)
	{
	  cleanup ();
	  destroy ();
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	}
      /* Fall through.  This wasn't a cancel event.  It was just a normal object
	 to wait for.  */
    default:
      s = &start;
      bool gotone = false;
      /* Some types of objects (e.g., consoles) wake up on "inappropriate" events
	 like mouse movements.  The verify function will detect these situations.
	 If it returns false, then this wakeup was a false alarm and we should go
	 back to waiting. */
      while ((s = s->next))
	if (s->saw_error ())
	  {
	    set_errno (s->saw_error ());
	    res = select_error;		/* Somebody detected an error */
	    goto out;
	  }
	else if ((((wait_ret >= m && s->windows_handle) || s->h == w4[wait_ret]))
		 && s->verify (s, readfds, writefds, exceptfds))
	  gotone = true;

      if (!gotone)
	res = select_loop;
      else
	res = select_ok;
      select_printf ("gotone %d", gotone);
      break;
    }
out:
  select_printf ("returning %d", res);
  return res;
}

static int
set_bits (select_record *me, fd_set *readfds, fd_set *writefds,
	  fd_set *exceptfds)
{
  int ready = 0;
  fhandler_socket *sock;
  select_printf ("me %p, testing fd %d (%s)", me, me->fd, me->fh->get_name ());
  if (me->read_selected && me->read_ready)
    {
      UNIX_FD_SET (me->fd, readfds);
      ready++;
    }
  if (me->write_selected && me->write_ready)
    {
      UNIX_FD_SET (me->fd, writefds);
      if (me->except_on_write && (sock = me->fh->is_socket ()))
	{
	  /* Set readfds entry in case of a failed connect. */
	  if (!me->read_ready && me->read_selected
	      && sock->connect_state () == connect_failed)
	    UNIX_FD_SET (me->fd, readfds);
	}
      ready++;
    }
  if (me->except_selected && me->except_ready)
    {
      UNIX_FD_SET (me->fd, exceptfds);
      ready++;
    }
  select_printf ("ready %d", ready);
  return ready;
}

/* Poll every fd in the select chain.  Set appropriate fd in mask. */
int
select_stuff::poll (fd_set *readfds, fd_set *writefds, fd_set *exceptfds)
{
  int n = 0;
  select_record *s = &start;
  while ((s = s->next))
    n += (!s->peek || s->peek (s, true)) ?
	 set_bits (s, readfds, writefds, exceptfds) : 0;
  return n;
}

static int
verify_true (select_record *, fd_set *, fd_set *, fd_set *)
{
  return 1;
}

static int
verify_ok (select_record *me, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds)
{
  return set_bits (me, readfds, writefds, exceptfds);
}

static int
no_startup (select_record *, select_stuff *)
{
  return 1;
}

static int
no_verify (select_record *, fd_set *, fd_set *, fd_set *)
{
  return 0;
}

static int
pipe_data_available (int fd, fhandler_base *fh, HANDLE h, bool writing)
{
  IO_STATUS_BLOCK iosb = {{0}, 0};
  FILE_PIPE_LOCAL_INFORMATION fpli = {0};

  bool res;
  if (fh->has_ongoing_io ())
    res = false;
  else if (NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),
				   FilePipeLocalInformation))
    {
      /* If NtQueryInformationFile fails, optimistically assume the
	 pipe is writable.  This could happen if we somehow
	 inherit a pipe that doesn't permit FILE_READ_ATTRIBUTES
	 access on the write end.  */
      select_printf ("fd %d, %s, NtQueryInformationFile failed",
		     fd, fh->get_name ());
      res = writing ? true : -1;
    }
  else if (!writing)
    {
      paranoid_printf ("fd %d, %s, read avail %u", fd, fh->get_name (),
		       fpli.ReadDataAvailable);
      res = !!fpli.ReadDataAvailable;
    }
  else if ((res = (fpli.WriteQuotaAvailable = (fpli.OutboundQuota -
					       fpli.ReadDataAvailable))))
    /* If there is anything available in the pipe buffer then signal
       that.  This means that a pipe could still block since you could
       be trying to write more to the pipe than is available in the
       buffer but that is the hazard of select().  */
    paranoid_printf ("fd %d, %s, write: size %u, avail %u", fd,
		     fh->get_name (), fpli.OutboundQuota,
		     fpli.WriteQuotaAvailable);
  else if ((res = (fpli.OutboundQuota < PIPE_BUF &&
		   fpli.WriteQuotaAvailable == fpli.OutboundQuota)))
    /* If we somehow inherit a tiny pipe (size < PIPE_BUF), then consider
       the pipe writable only if it is completely empty, to minimize the
       probability that a subsequent write will block.  */
    select_printf ("fd, %s, write tiny pipe: size %u, avail %u",
		   fd, fh->get_name (), fpli.OutboundQuota,
		   fpli.WriteQuotaAvailable);
  return res ?: -!!(fpli.NamedPipeState & FILE_PIPE_CLOSING_STATE);
}

static int
peek_pipe (select_record *s, bool from_select)
{
  HANDLE h;
  set_handle_or_return_if_not_open (h, s);

  int gotone = 0;
  fhandler_base *fh = (fhandler_base *) s->fh;

  DWORD dev = fh->get_device ();
  if (s->read_selected && dev != FH_PIPEW)
    {
      if (s->read_ready)
	{
	  select_printf ("%s, already ready for read", fh->get_name ());
	  gotone = 1;
	  goto out;
	}

      switch (fh->get_major ())
	{
	case DEV_PTYM_MAJOR:
	  {
	    fhandler_pty_master *fhm = (fhandler_pty_master *) fh;
	    fhm->flush_to_slave ();
	    if (fhm->need_nl)
	      {
		gotone = s->read_ready = true;
		goto out;
	      }
	  }
	  break;
	default:
	  if (fh->get_readahead_valid ())
	    {
	      select_printf ("readahead");
	      gotone = s->read_ready = true;
	      goto out;
	    }
	}

      if (fh->bg_check (SIGTTIN) <= bg_eof)
	{
	  gotone = s->read_ready = true;
	  goto out;
	}
      int n = pipe_data_available (s->fd, fh, h, false);
      /* On PTY masters, check if input from the echo pipe is available. */
      if (n == 0 && fh->get_echo_handle ())
	n = pipe_data_available (s->fd, fh, fh->get_echo_handle (), false);

      if (n < 0)
	{
	  select_printf ("read: %s, n %d", fh->get_name (), n);
	  if (s->except_selected)
	    gotone += s->except_ready = true;
	  if (s->read_selected)
	    gotone += s->read_ready = true;
	}
      else if (n > 0)
	{
	  select_printf ("read: %s, ready for read: avail %d", fh->get_name (), n);
	  gotone += s->read_ready = true;
	}
      if (!gotone && s->fh->hit_eof ())
	{
	  select_printf ("read: %s, saw EOF", fh->get_name ());
	  if (s->except_selected)
	    gotone += s->except_ready = true;
	  if (s->read_selected)
	    gotone += s->read_ready = true;
	}
    }

out:
  if (s->write_selected && dev != FH_PIPER)
    {
      gotone += s->write_ready =  pipe_data_available (s->fd, fh, h, true);
      select_printf ("write: %s, gotone %d", fh->get_name (), gotone);
    }
  return gotone;
}

static int start_thread_pipe (select_record *me, select_stuff *stuff);

static DWORD WINAPI
thread_pipe (void *arg)
{
  select_pipe_info *pi = (select_pipe_info *) arg;
  DWORD sleep_time = 0;
  bool looping = true;

  while (looping)
    {
      for (select_record *s = pi->start; (s = s->next); )
	if (s->startup == start_thread_pipe)
	  {
	    if (peek_pipe (s, true))
	      looping = false;
	    if (pi->stop_thread)
	      {
		select_printf ("stopping");
		looping = false;
		break;
	      }
	  }
      if (!looping)
	break;
      Sleep (sleep_time >> 3);
      if (sleep_time < 80)
	++sleep_time;
      if (pi->stop_thread)
	break;
    }
  return 0;
}

static int
start_thread_pipe (select_record *me, select_stuff *stuff)
{
  select_pipe_info *pi = stuff->device_specific_pipe;
  if (pi->start)
    me->h = *((select_pipe_info *) stuff->device_specific_pipe)->thread;
  else
    {
      pi->start = &stuff->start;
      pi->stop_thread = false;
      pi->thread = new cygthread (thread_pipe, pi, "pipesel");
      me->h = *pi->thread;
      if (!me->h)
	return 0;
    }
  return 1;
}

static void
pipe_cleanup (select_record *, select_stuff *stuff)
{
  select_pipe_info *pi = (select_pipe_info *) stuff->device_specific_pipe;
  if (!pi)
    return;
  if (pi->thread)
    {
      pi->stop_thread = true;
      pi->thread->detach ();
    }
  delete pi;
  stuff->device_specific_pipe = NULL;
}

select_record *
fhandler_pipe::select_read (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;

  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->read_selected = true;
  s->read_ready = false;
  return s;
}

select_record *
fhandler_pipe::select_write (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;
  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->write_selected = true;
  s->write_ready = false;
  return s;
}

select_record *
fhandler_pipe::select_except (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;
  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->except_selected = true;
  s->except_ready = false;
  return s;
}

select_record *
fhandler_fifo::select_read (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;
  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->read_selected = true;
  s->read_ready = false;
  return s;
}

select_record *
fhandler_fifo::select_write (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;
  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->write_selected = true;
  s->write_ready = false;
  return s;
}

select_record *
fhandler_fifo::select_except (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;
  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->except_selected = true;
  s->except_ready = false;
  return s;
}

static int
peek_console (select_record *me, bool)
{
  extern const char * get_nonascii_key (INPUT_RECORD& input_rec, char *);
  fhandler_console *fh = (fhandler_console *) me->fh;

  if (!me->read_selected)
    return me->write_ready;

  if (fh->get_readahead_valid ())
    {
      select_printf ("readahead");
      return me->read_ready = true;
    }

  if (me->read_ready)
    {
      select_printf ("already ready");
      return 1;
    }

  INPUT_RECORD irec;
  DWORD events_read;
  HANDLE h;
  char tmpbuf[17];
  set_handle_or_return_if_not_open (h, me);

  for (;;)
    if (fh->bg_check (SIGTTIN) <= bg_eof)
      return me->read_ready = true;
    else if (!PeekConsoleInput (h, &irec, 1, &events_read) || !events_read)
      break;
    else
      {
	fh->send_winch_maybe ();
	if (irec.EventType == KEY_EVENT)
	  {
	    if (irec.Event.KeyEvent.bKeyDown
		&& (irec.Event.KeyEvent.uChar.AsciiChar
		    || get_nonascii_key (irec, tmpbuf)))
	      return me->read_ready = true;
	  }
	else
	  {
	    if (irec.EventType == MOUSE_EVENT
		&& fh->mouse_aware (irec.Event.MouseEvent))
		return me->read_ready = true;
	    if (irec.EventType == FOCUS_EVENT && fh->focus_aware ())
		return me->read_ready = true;
	  }

	/* Read and discard the event */
	ReadConsoleInput (h, &irec, 1, &events_read);
      }

  return me->write_ready;
}

static int
verify_console (select_record *me, fd_set *rfds, fd_set *wfds,
	      fd_set *efds)
{
  return peek_console (me, true);
}


select_record *
fhandler_console::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_console;
      set_cursor_maybe ();
    }

  s->peek = peek_console;
  s->h = get_handle ();
  s->read_selected = true;
  s->read_ready = false;
  return s;
}

select_record *
fhandler_console::select_write (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = no_verify;
      set_cursor_maybe ();
    }

  s->peek = peek_console;
  s->write_selected = true;
  s->write_ready = true;
  return s;
}

select_record *
fhandler_console::select_except (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = no_verify;
      set_cursor_maybe ();
    }

  s->peek = peek_console;
  s->except_selected = true;
  s->except_ready = false;
  return s;
}

select_record *
fhandler_pty_common::select_read (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;

  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->read_selected = true;
  s->read_ready = false;
  return s;
}

select_record *
fhandler_pty_common::select_write (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;
  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->write_selected = true;
  s->write_ready = false;
  return s;
}

select_record *
fhandler_pty_common::select_except (select_stuff *ss)
{
  if (!ss->device_specific_pipe
      && (ss->device_specific_pipe = new select_pipe_info) == NULL)
    return NULL;
  select_record *s = ss->start.next;
  s->startup = start_thread_pipe;
  s->peek = peek_pipe;
  s->verify = verify_ok;
  s->cleanup = pipe_cleanup;
  s->except_selected = true;
  s->except_ready = false;
  return s;
}

static int
verify_tty_slave (select_record *me, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds)
{
  if (IsEventSignalled (me->h))
    me->read_ready = true;
  return set_bits (me, readfds, writefds, exceptfds);
}

select_record *
fhandler_pty_slave::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  s->h = input_available_event;
  s->startup = no_startup;
  s->peek = peek_pipe;
  s->verify = verify_tty_slave;
  s->read_selected = true;
  s->read_ready = false;
  s->cleanup = NULL;
  return s;
}

select_record *
fhandler_dev_null::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = no_verify;
    }
  s->h = get_handle ();
  s->read_selected = true;
  s->read_ready = true;
  return s;
}

select_record *
fhandler_dev_null::select_write (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = no_verify;
    }
  s->h = get_handle ();
  s->write_selected = true;
  s->write_ready = true;
  return s;
}

select_record *
fhandler_dev_null::select_except (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = no_verify;
    }
  s->h = get_handle ();
  s->except_selected = true;
  s->except_ready = false;
  return s;
}

static int start_thread_serial (select_record *me, select_stuff *stuff);

static int
peek_serial (select_record *s, bool)
{
  COMSTAT st;

  fhandler_serial *fh = (fhandler_serial *) s->fh;

  if (fh->get_readahead_valid () || fh->overlapped_armed < 0)
    return s->read_ready = true;

  select_printf ("fh->overlapped_armed %d", fh->overlapped_armed);

  HANDLE h;
  set_handle_or_return_if_not_open (h, s);
  int ready = 0;

  if ((s->read_selected && s->read_ready) || (s->write_selected && s->write_ready))
    {
      select_printf ("already ready");
      ready = 1;
      goto out;
    }

  /* This is apparently necessary for the com0com driver.
     See: http://cygwin.com/ml/cygwin/2009-01/msg00667.html */
  SetCommMask (h, 0);

  SetCommMask (h, EV_RXCHAR);

  if (!fh->overlapped_armed)
    {
      COMSTAT st;

      ResetEvent (fh->io_status.hEvent);

      if (!ClearCommError (h, &fh->ev, &st))
	{
	  debug_printf ("ClearCommError");
	  goto err;
	}
      else if (st.cbInQue)
	return s->read_ready = true;
      else if (WaitCommEvent (h, &fh->ev, &fh->io_status))
	return s->read_ready = true;
      else if (GetLastError () == ERROR_IO_PENDING)
	fh->overlapped_armed = 1;
      else
	{
	  debug_printf ("WaitCommEvent");
	  goto err;
	}
    }

  switch (WaitForSingleObject (fh->io_status.hEvent, 10L))
    {
    case WAIT_OBJECT_0:
      if (!ClearCommError (h, &fh->ev, &st))
	{
	  debug_printf ("ClearCommError");
	  goto err;
	}
      else if (!st.cbInQue)
	Sleep (10L);
      else
	{
	  return s->read_ready = true;
	  select_printf ("got something");
	}
      break;
    case WAIT_TIMEOUT:
      break;
    default:
      debug_printf ("WaitForMultipleObjects");
      goto err;
    }

out:
  return ready;

err:
  if (GetLastError () == ERROR_OPERATION_ABORTED)
    {
      select_printf ("operation aborted");
      return ready;
    }

  s->set_select_errno ();
  select_printf ("error %E");
  return -1;
}

static DWORD WINAPI
thread_serial (void *arg)
{
  select_serial_info *si = (select_serial_info *) arg;
  bool looping = true;

  while (looping)
    for (select_record *s = si->start; (s = s->next); )
      if (s->startup != start_thread_serial)
	continue;
      else
	{
	  if (peek_serial (s, true))
	    looping = false;
	  if (si->stop_thread)
	    {
	      select_printf ("stopping");
	      looping = false;
	      break;
	    }
	}

  select_printf ("exiting");
  return 0;
}

static int
start_thread_serial (select_record *me, select_stuff *stuff)
{
  if (stuff->device_specific_serial)
    me->h = *((select_serial_info *) stuff->device_specific_serial)->thread;
  else
    {
      select_serial_info *si = new select_serial_info;
      si->start = &stuff->start;
      si->stop_thread = false;
      si->thread = new cygthread (thread_serial, si, "sersel");
      me->h = *si->thread;
      stuff->device_specific_serial = si;
    }
  return 1;
}

static void
serial_cleanup (select_record *, select_stuff *stuff)
{
  select_serial_info *si = (select_serial_info *) stuff->device_specific_serial;
  if (!si)
    return;
  if (si->thread)
    {
      si->stop_thread = true;
      si->thread->detach ();
    }
  delete si;
  stuff->device_specific_serial = NULL;
}

select_record *
fhandler_serial::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = start_thread_serial;
      s->verify = verify_ok;
      s->cleanup = serial_cleanup;
    }
  s->peek = peek_serial;
  s->read_selected = true;
  s->read_ready = false;
  return s;
}

select_record *
fhandler_serial::select_write (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_ok;
    }
  s->peek = peek_serial;
  s->h = get_handle ();
  s->write_selected = true;
  s->write_ready = true;
  return s;
}

select_record *
fhandler_serial::select_except (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_ok;
    }
  s->h = NULL;
  s->peek = peek_serial;
  s->except_selected = false;	// Can't do this
  s->except_ready = false;
  return s;
}

select_record *
fhandler_base::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_ok;
    }
  s->h = get_handle ();
  s->read_selected = true;
  s->read_ready = true;
  return s;
}

select_record *
fhandler_base::select_write (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_ok;
    }
  s->h = get_handle ();
  s->write_selected = true;
  s->write_ready = true;
  return s;
}

select_record *
fhandler_base::select_except (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_ok;
    }
  s->h = NULL;
  s->except_selected = true;
  s->except_ready = false;
  return s;
}

static int
peek_socket (select_record *me, bool)
{
  fhandler_socket *fh = (fhandler_socket *) me->fh;
  long events;
  /* Don't play with the settings again, unless having taken a deep look into
     Richard W. Stevens Network Programming book.  Thank you. */
  long evt_mask = (me->read_selected ? (FD_READ | FD_ACCEPT | FD_CLOSE) : 0)
		| (me->write_selected ? (FD_WRITE | FD_CONNECT | FD_CLOSE) : 0)
		| (me->except_selected ? FD_OOB : 0);
  int ret = fh->evaluate_events (evt_mask, events, false);
  if (me->read_selected)
    me->read_ready |= ret || !!(events & (FD_READ | FD_ACCEPT | FD_CLOSE));
  if (me->write_selected)
    me->write_ready |= ret || !!(events & (FD_WRITE | FD_CONNECT | FD_CLOSE));
  if (me->except_selected)
    me->except_ready |= !!(events & FD_OOB);

  select_printf ("read_ready: %d, write_ready: %d, except_ready: %d",
		 me->read_ready, me->write_ready, me->except_ready);
  return me->read_ready || me->write_ready || me->except_ready;
}

static int start_thread_socket (select_record *, select_stuff *);

static DWORD WINAPI
thread_socket (void *arg)
{
  select_socket_info *si = (select_socket_info *) arg;
  DWORD timeout = (si->num_w4 <= MAXIMUM_WAIT_OBJECTS)
		  ? INFINITE
		  : (64 / (roundup2 (si->num_w4, MAXIMUM_WAIT_OBJECTS)
			   / MAXIMUM_WAIT_OBJECTS));
  bool event = false;

  select_printf ("stuff_start %p, timeout %u", si->start, timeout);
  while (!event)
    {
      for (select_record *s = si->start; (s = s->next); )
	if (s->startup == start_thread_socket)
	  if (peek_socket (s, false))
	    event = true;
      if (!event)
	for (int i = 0; i < si->num_w4; i += MAXIMUM_WAIT_OBJECTS)
	  switch (WaitForMultipleObjects (MIN (si->num_w4 - i,
					       MAXIMUM_WAIT_OBJECTS),
					  si->w4 + i, FALSE, timeout))
	    {
	    case WAIT_FAILED:
	      goto out;
	    case WAIT_TIMEOUT:
	      continue;
	    case WAIT_OBJECT_0:
	      if (!i)	/* Socket event set. */
		goto out;
	      /*FALLTHRU*/
	    default:
	      break;
	    }
    }
out:
  select_printf ("leaving thread_socket");
  return 0;
}

static inline bool init_tls_select_info () __attribute__ ((always_inline));
static inline bool
init_tls_select_info ()
{
  if (!_my_tls.locals.select.sockevt)
    {
      _my_tls.locals.select.sockevt = CreateEvent (&sec_none_nih, TRUE, FALSE,
						   NULL);
      if (!_my_tls.locals.select.sockevt)
	return false;
    }
  if (!_my_tls.locals.select.ser_num)
    {
      _my_tls.locals.select.ser_num
	      = (LONG *) malloc (MAXIMUM_WAIT_OBJECTS * sizeof (LONG));
      if (!_my_tls.locals.select.ser_num)
	return false;
      _my_tls.locals.select.w4
	      = (HANDLE *) malloc (MAXIMUM_WAIT_OBJECTS * sizeof (HANDLE));
      if (!_my_tls.locals.select.w4)
	{
	  free (_my_tls.locals.select.ser_num);
	  _my_tls.locals.select.ser_num = NULL;
	  return false;
	}
      _my_tls.locals.select.max_w4 = MAXIMUM_WAIT_OBJECTS;
    }
  return true;
}

static int
start_thread_socket (select_record *me, select_stuff *stuff)
{
  select_socket_info *si;

  if ((si = (select_socket_info *) stuff->device_specific_socket))
    {
      me->h = *si->thread;
      return 1;
    }

  si = new select_socket_info;

  if (!init_tls_select_info ())
    {
      delete si;
      return 0;
    }

  si->ser_num = _my_tls.locals.select.ser_num;
  si->w4 = _my_tls.locals.select.w4;

  si->w4[0] = _my_tls.locals.select.sockevt;
  si->num_w4 = 1;

  select_record *s = &stuff->start;
  while ((s = s->next))
    if (s->startup == start_thread_socket)
      {
	/* No event/socket should show up multiple times.  Every socket
	   is uniquely identified by its serial number in the global
	   wsock_events record. */
	const LONG ser_num = ((fhandler_socket *) s->fh)->serial_number ();
	for (int i = 1; i < si->num_w4; ++i)
	  if (si->ser_num[i] == ser_num)
	    goto continue_outer_loop;
	if (si->num_w4 >= _my_tls.locals.select.max_w4)
	  {
	    LONG *nser = (LONG *) realloc (si->ser_num,
					   (_my_tls.locals.select.max_w4
					    + MAXIMUM_WAIT_OBJECTS)
					   * sizeof (LONG));
	    if (!nser)
	      {
		delete si;
		return 0;
	      }
	    _my_tls.locals.select.ser_num = si->ser_num = nser;
	    HANDLE *nw4 = (HANDLE *) realloc (si->w4,
					   (_my_tls.locals.select.max_w4
					    + MAXIMUM_WAIT_OBJECTS)
					   * sizeof (HANDLE));
	    if (!nw4)
	      {
		delete si;
		return 0;
	      }
	    _my_tls.locals.select.w4 = si->w4 = nw4;
	    _my_tls.locals.select.max_w4 += MAXIMUM_WAIT_OBJECTS;
	  }
	si->ser_num[si->num_w4] = ser_num;
	si->w4[si->num_w4++] = ((fhandler_socket *) s->fh)->wsock_event ();
      continue_outer_loop:
	;
      }
  stuff->device_specific_socket = si;
  si->start = &stuff->start;
  select_printf ("stuff_start %p", &stuff->start);
  si->thread = new cygthread (thread_socket, si, "socksel");
  me->h = *si->thread;
  return 1;
}

void
socket_cleanup (select_record *, select_stuff *stuff)
{
  select_socket_info *si = (select_socket_info *) stuff->device_specific_socket;
  select_printf ("si %p si->thread %p", si, si ? si->thread : NULL);
  if (!si)
    return;
  if (si->thread)
    {
      SetEvent (si->w4[0]);
      /* Wait for thread to go away */
      si->thread->detach ();
      ResetEvent (si->w4[0]);
    }
  delete si;
  stuff->device_specific_socket = NULL;
  select_printf ("returning");
}

select_record *
fhandler_socket::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = start_thread_socket;
      s->verify = verify_true;
      s->cleanup = socket_cleanup;
    }
  s->peek = peek_socket;
  s->read_ready = saw_shutdown_read ();
  s->read_selected = true;
  return s;
}

select_record *
fhandler_socket::select_write (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = start_thread_socket;
      s->verify = verify_true;
      s->cleanup = socket_cleanup;
    }
  s->peek = peek_socket;
  s->write_ready = saw_shutdown_write () || connect_state () == unconnected;
  s->write_selected = true;
  if (connect_state () != unconnected)
    {
      s->except_ready = saw_shutdown_write () || saw_shutdown_read ();
      s->except_on_write = true;
    }
  return s;
}

select_record *
fhandler_socket::select_except (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = start_thread_socket;
      s->verify = verify_true;
      s->cleanup = socket_cleanup;
    }
  s->peek = peek_socket;
  /* FIXME: Is this right?  Should these be used as criteria for except? */
  s->except_ready = saw_shutdown_write () || saw_shutdown_read ();
  s->except_selected = true;
  return s;
}

static int
peek_windows (select_record *me, bool)
{
  MSG m;
  HANDLE h;
  set_handle_or_return_if_not_open (h, me);
  /* We need the hWnd value, not the io_handle. */
  h = ((fhandler_windows *) me->fh)->get_hwnd ();

  if (me->read_selected && me->read_ready)
    return 1;

  if (PeekMessageW (&m, (HWND) h, 0, 0, PM_NOREMOVE))
    {
      me->read_ready = true;
      select_printf ("window %d(%p) ready", me->fd, h);
      return 1;
    }

  select_printf ("window %d(%p) not ready", me->fd, h);
  return me->write_ready;
}

static int
verify_windows (select_record *me, fd_set *rfds, fd_set *wfds,
		fd_set *efds)
{
  return peek_windows (me, true);
}

select_record *
fhandler_windows::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
    }
  s->verify = verify_windows;
  s->peek = peek_windows;
  s->read_selected = true;
  s->read_ready = false;
  s->windows_handle = true;
  return s;
}

select_record *
fhandler_windows::select_write (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_ok;
    }
  s->peek = peek_windows;
  s->write_selected = true;
  s->write_ready = true;
  s->windows_handle = true;
  return s;
}

select_record *
fhandler_windows::select_except (select_stuff *ss)
{
  select_record *s = ss->start.next;
  if (!s->startup)
    {
      s->startup = no_startup;
      s->verify = verify_ok;
    }
  s->peek = peek_windows;
  s->except_selected = true;
  s->except_ready = false;
  s->windows_handle = true;
  return s;
}

static int
peek_mailslot (select_record *me, bool)
{
  HANDLE h;
  set_handle_or_return_if_not_open (h, me);

  if (me->read_selected && me->read_ready)
    return 1;
  DWORD msgcnt = 0;
  if (!GetMailslotInfo (h, NULL, NULL, &msgcnt, NULL))
    {
      select_printf ("mailslot %d(%p) error %E", me->fd, h);
      return 1;
    }
  if (msgcnt > 0)
    {
      me->read_ready = true;
      select_printf ("mailslot %d(%p) ready", me->fd, h);
      return 1;
    }
  select_printf ("mailslot %d(%p) not ready", me->fd, h);
  return 0;
}

static int
verify_mailslot (select_record *me, fd_set *rfds, fd_set *wfds,
		 fd_set *efds)
{
  return peek_mailslot (me, true);
}

static int start_thread_mailslot (select_record *me, select_stuff *stuff);

static DWORD WINAPI
thread_mailslot (void *arg)
{
  select_mailslot_info *mi = (select_mailslot_info *) arg;
  bool gotone = false;
  DWORD sleep_time = 0;

  for (;;)
    {
      select_record *s = mi->start;
      while ((s = s->next))
	if (s->startup == start_thread_mailslot)
	  {
	    if (peek_mailslot (s, true))
	      gotone = true;
	    if (mi->stop_thread)
	      {
		select_printf ("stopping");
		goto out;
	      }
	  }
      /* Paranoid check */
      if (mi->stop_thread)
	{
	  select_printf ("stopping from outer loop");
	  break;
	}
      if (gotone)
	break;
      Sleep (sleep_time >> 3);
      if (sleep_time < 80)
	++sleep_time;
    }
out:
  return 0;
}

static int
start_thread_mailslot (select_record *me, select_stuff *stuff)
{
  if (stuff->device_specific_mailslot)
    {
      me->h = *((select_mailslot_info *) stuff->device_specific_mailslot)->thread;
      return 1;
    }
  select_mailslot_info *mi = new select_mailslot_info;
  mi->start = &stuff->start;
  mi->stop_thread = false;
  mi->thread = new cygthread (thread_mailslot, mi, "mailsel");
  me->h = *mi->thread;
  if (!me->h)
    return 0;
  stuff->device_specific_mailslot = mi;
  return 1;
}

static void
mailslot_cleanup (select_record *, select_stuff *stuff)
{
  select_mailslot_info *mi = (select_mailslot_info *) stuff->device_specific_mailslot;
  if (!mi)
    return;
  if (mi->thread)
    {
      mi->stop_thread = true;
      mi->thread->detach ();
    }
  delete mi;
  stuff->device_specific_mailslot = NULL;
}

select_record *
fhandler_mailslot::select_read (select_stuff *ss)
{
  select_record *s = ss->start.next;
  s->startup = start_thread_mailslot;
  s->peek = peek_mailslot;
  s->verify = verify_mailslot;
  s->cleanup = mailslot_cleanup;
  s->read_selected = true;
  s->read_ready = false;
  return s;
}
@


1.223
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Handle
	connect_state and af_local_connect connect call here, once, independent
	of FD_CONNECT being requested.  Add comment to explain why.
	(fhandler_socket::connect): Drop connect_state handling and calling
	af_local_connect.  Move remaining AF_LOCAL stuff prior  to calling
	::connect and explain why.  Simplify error case.
	* poll.cc (poll): Handle connect state independently of POLLOUT being
	requested for the descriptor to allow setting POLLIN if connect failed.
	Add comment.
	* select.cc (set_bits): Drop connect_state and AF_LOCAL handling here.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d629 3
@


1.222
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d483 4
a486 10
	  /* Special AF_LOCAL handling. */
	  if (!me->read_ready && sock->connect_state () == connect_pending
	      && sock->af_local_connect ())
	    {
	      if (me->read_selected)
		UNIX_FD_SET (me->fd, readfds);
	      sock->connect_state (connect_failed);
	    }
	  else
	    sock->connect_state (connected);
@


1.221
log
@	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d233 18
a250 15
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (ts)
    {
      tv.tv_sec = ts->tv_sec;
      tv.tv_usec = ts->tv_nsec / 1000;
    }
  if (set)
    set_signal_mask (_my_tls.sigmask, *set);
  int ret = cygwin_select (maxfds, readfds, writefds, exceptfds,
			   ts ? &tv : NULL);
  if (set)
    set_signal_mask (_my_tls.sigmask, oldset);
  return ret;
@


1.220
log
@* select.cc (select): Add workaround for, as yet undebugged, pathological case.
@
text
@d1417 4
a1420 1
    return 0;
d1446 4
a1449 1
	      return 0;
d1456 4
a1459 1
	      return 0;
@


1.220.2.1
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d1417 1
a1417 4
    {
      delete si;
      return 0;
    }
d1443 1
a1443 4
	      {
		delete si;
		return 0;
	      }
d1450 1
a1450 4
	      {
		delete si;
		return 0;
	      }
@


1.220.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d233 15
a247 18
  __try
    {
      if (ts)
	{
	  tv.tv_sec = ts->tv_sec;
	  tv.tv_usec = ts->tv_nsec / 1000;
	}
      if (set)
	set_signal_mask (_my_tls.sigmask, *set);
      int ret = cygwin_select (maxfds, readfds, writefds, exceptfds,
			       ts ? &tv : NULL);
      if (set)
	set_signal_mask (_my_tls.sigmask, oldset);
      return ret;
    }
  __except (EFAULT) {}
  __endtry
  return -1;
a472 3
      /* Special AF_LOCAL handling. */
      if ((sock = me->fh->is_socket ()) && sock->connect_state () == connect_pending)
	sock->connect_state (connected);
@


1.219
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d192 5
a196 2
	  /* Actually set the bit mask from sel records */
	  res = (res == select_stuff::select_set_zero) ? 0 : sel.poll (readfds, writefds, exceptfds);
d395 1
a395 1
  select_printf ("wait_ret %d.  verifying", wait_ret);
@


1.218
log
@	* devices.in (dev_cygdrive_storage): Map to \Device\Null.
	(dev_storage): Map /dev and /dev/windows to \Device\Null.
	* devices.cc: Regenerate.
	* dir.cc (opendir): Create unique id.  Explain why.
	* fhandler.h (fhandler_dev::get_dev): Implement inline.
	(fhandler_cygdrive::close): Drop declaration.
	(fhandler_cygdrive::get_dev): Implement inline.
	(fhandler_windows::get_hwnd): Ditto.
	(fhandler_windows::set_close_on_exec): Drop declaration.
	(fhandler_windows::fixup_after_fork): Ditto.
	* fhandler_dev.cc (fhandler_dev::open): Call fhandler_disk_file::open
	without O_CREAT flag.  Explain why.  Create \Device\Null handle if
	/dev/ doesn't actually exist.
	(fhandler_dev::close): Drop nohandle case.
	(fhandler_dev::fstatvfs): Drop nohandle check.  Test for fs_got_fs
	instead.  Set ST_RDONLY fs flag for simulated /dev.
	(fhandler_dev::opendir): If /dev doesn't exist, call open() to create
	fake \Device\Null handle.  Don't set nohandle.  Set dir_exists
	correctly.
	(fhandler_dev::rewinddir): Call fhandler_disk_file::rewinddir only if
	/dev is a real directory.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If called for
	the cygdrive dir, call open() to create fake \Device\Null handle.
	Only attach __DIR_mounts buffer to dir if not called for cygdrive dir.
	Don't set nohandle.
	(fhandler_cygdrive::open): Create \Device\Null handle.
	(fhandler_cygdrive::close): Remove.
	(fhandler_cygdrive::fstatvfs): Set ST_RDONLY fs flag.
	* fhandler_windows.cc (fhandler_windows::open): Create \Device\Null
	handle.
	(fhandler_windows::read): Don't add io_handle to WFMO handle array.
	Change subsequent test for return value accordingly.  Fix test for
	"message arrived".
	(fhandler_windows::set_close_on_exec): Remove.
	(fhandler_windows::fixup_after_fork): Remove.
	* path.h (path_conv::set_path): Make sure wide_path is NULL when
	setting a new path.
	* select.cc (peek_windows): Use correct hWnd value, not io_handle.
	(fhandler_windows::select_read): Don't use io_handle as wait object.
	(fhandler_windows::select_write): Ditto.
	(fhandler_windows::select_except): Ditto.
@
text
@a21 2
#include <wingdi.h>
#include <winuser.h>
@


1.217
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1545 2
a1580 1
  s->h = get_handle ();
a1594 1
  s->h = get_handle ();
a1610 1
  s->h = get_handle ();
@


1.216
log
@whitespace
@
text
@a55 1
typedef long fd_mask;
d65 1
a65 1
  ((unsigned) (NULL_fd_set->fds_bits + unix_howmany ((n), UNIX_NFDBITS)))
d116 1
a116 1
	select_printf ("to->tv_sec %d, to->tv_usec %d, ms %d", to->tv_sec, to->tv_usec, ms);
d297 1
a297 1

d541 1
a541 1
  IO_STATUS_BLOCK iosb = {0};
d570 1
a570 1
    paranoid_printf ("fd %d, %s, write: size %lu, avail %lu", fd,
d578 1
a578 1
    select_printf ("fd, %s, write tiny pipe: size %lu, avail %lu",
@


1.215
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d298 1
a298 1
		     
@


1.214
log
@* DevNotes: Add entry cgf-000021.
* select.cc (select): Unconditionally return when a signal is detected.
(select_stuff::wait): Ditto.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.213
log
@* select.h (select_stuff): Remove variable names from parameter declarations.
(select_info): Ditto.
(select_record::dump_select_record): Declare new debugging-only function.
(select_info): Zero all fields.
(select_pipe_info): Ditto.
(select_socket_info): Ditto.
(select_serial_info): Ditto.
(select_mailslot_info): Ditto.
* select.cc (select_record::dump_select_record): Define new debugging-only
function.
(select_stuff::test_and_set): Call dump_select_record when debugging.
* thread.cc (pthread_mutex::unlock): Revert setting of tid to NULL since, in
this context, it is a number, not a pointer.
(pthread_spinlock::unlock): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d168 6
a173 7
	    if (_my_tls.call_signal_handler ())
	      res = select_stuff::select_loop;		/* Emulate linux behavior */
	    else
	      {
		set_sig_errno (EINTR);
		res = select_stuff::select_error;
	      }
d406 6
a411 7
      if (_my_tls.call_signal_handler ())
	res = select_loop;
      else
	{
	  set_sig_errno (EINTR);
	  res = select_signalled;	/* Cause loop exit in cygwin_select */
	}
@


1.212
log
@* select.h (select_stuff::select_stuff): Make default constructor always zero
everything while constructor with int arg just zeroes next.
* select.cc (select_stuff::test_and_set): Revert to using default constructor.
@
text
@d289 16
d334 3
@


1.211
log
@* select.cc (select_stuff::wait): Add windows error number to error message.
@
text
@d298 1
a298 1
  select_record *s = new select_record (0);
@


1.210
log
@* select.cc (select_stuff::test_and_set): Remove workaround and use proper
constructor.
@
text
@d397 1
a397 1
      system_printf ("WaitForMultipleObjects failed");
@


1.209
log
@* select.cc (select_stuff::test_and_set): Work around problem of new() not
returning zeroed memory.
@
text
@d298 1
a298 1
  select_record *s = (select_record *) calloc (1, sizeof (select_record));
@


1.208
log
@ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.common: Revamp for new configury.  Add default compilation
	targets, include .E processing.  Add magic for allowing "CFLAGS" to
	control optimization options in "CXXFLAGS".
	* configure.cygwin: New include for Cygwin configure.in's.
	* acinclude.m4: Delete old definitions.  Implement AC_WINDOWS_HEADERS,
	AC_WINDOWS_LIBS, AC_CYGWIN_INCLUDES, target_builddir, winsup_srcdir.
	* aclocal.m4: Regenerate.
	* autogen.sh: New file.
	* ccwrap: New script.
	* c++wrap: New script.
	* config.guess: New script.
	* config.sub: New script.
	* configure: Regenerate.
	* configure.in: Eliminate LIB_AC_PROG_* calls in favor of standard.
	Delete ancient target test.
	* install-sh: New script.

cygserver/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.

cygwin/ChangeLog:
2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* select.cc (select): Don't return -1 when we've timed out after
	looping.

2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	(datarootdir): Add variable setting.
	(winver_stamp): Accommodate changes to mkvers.sh setting.
	(libc.a): Fix race when libm.a might not have been built yet.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* mkvers.sh: Find include directives via CFLAGS and friends rather than
	assuming that w32api lives nearby.

utils/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* configure.in: Revamp for new configury.
	* Makefile.in: Revamp for new configury.  Rename ALL_* to just *.
	Always use "VERBOSE" setting.
	(MINGW_CXX): Don't include CFLAGS in definition.
	(all): Define target first, before everything else so that it is the
	default.
	(ps.exe): Don't add useless -lcygwin.
	(ldh.exe): For consistency, add to existing MINGW_LDFLAGS rather than
	redefining them.
	(cygcheck.exe): Always include -lz for MINGW_LDFLAGS.  Don't try to
	figure out where to find it.
	(dumper.exe): Simplify check.  Assume libraries are installed rather
	than trying to retrieve from source tree.
	(install): Just use /bin/mkdir to create directories.
	(Makefile): Regenerate when standard dependencies change.
	* dump_setup.cc: Always include zlib.h.  Remove accommodations for it
	possibly not existing.
	* parse_pe.cc: Add define which allows building with installed
	binutils package.
	* dumper.cc: Ditto.
@
text
@d298 1
a298 1
  select_record *s = new select_record;
@


1.207
log
@Change "set_thread_waiting" to "set_signal_arrived" throughout.
@
text
@d211 1
a211 1
	      res = select_stuff::select_error;
@


1.207.2.1
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d525 1
a525 1
  IO_STATUS_BLOCK iosb = {{0}, 0};
@


1.207.2.2
log
@	* fhandler_netdrive.cc: Use UINT32_MAX rather than UINT_MAX to make
	absolutely clear that we mean the 32 bit maximum.
	* fhandler_socket.cc: Ditto.
	* pinfo.cc: Ditto with INT32_MAX.
	* select.cc (fd_mask): Drop gratuitious definition.
	(sizeof_fd_set): Cast to size_t.
	* shared.cc (pround): Cast to ptrdiff_t.
	* strace.cc (strace::activate): Fix format string.
	(strace::write_childpid): Take pid_t as parameter.
	* include/sys/strace.h (strace::write_childpid): Change declaration
	accordingly.
	* sync.cc (muto::init): Cast in call to InterlockedExchangePointer to
	make compiler happy.
	* sync.h (class muto): De-const name.
	* syslog.cc (try_connect_syslogd): Take size_t as third argument.
	(vsyslog): Convert len to size_t.
	* thread.cc: Use {U}INT32_MAX rather than {U}LONG_MAX.  Througout change
	types used in Windows calls to matching Windows types.
	(pthread::cancel): Fix access to instruction pointer for x86_64.
	(pthread_attr_getstack): Cast to ptrdiff_t for pointer arithmetic.
	* thread.h: Throughout convert 'long' types to uint32_t or LONG.
@
text
@d56 1
d66 1
a66 1
  ((size_t) (NULL_fd_set->fds_bits + unix_howmany ((n), UNIX_NFDBITS)))
@


1.207.2.3
log
@Pull in changes from HEAD
@
text
@d210 1
a210 1
	      res = 0;
@


1.207.2.4
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d116 1
a116 1
	select_printf ("to->tv_sec %ld, to->tv_usec %ld, ms %d", to->tv_sec, to->tv_usec, ms);
d553 1
a553 1
    paranoid_printf ("fd %d, %s, write: size %u, avail %u", fd,
d561 1
a561 1
    select_printf ("fd, %s, write tiny pipe: size %u, avail %u",
@


1.207.2.5
log
@Pull in changes from HEAD
@
text
@d297 1
a297 1
  select_record *s = new select_record (0);
@


1.207.2.6
log
@Pull in changes from HEAD
@
text
@d297 1
a297 1
  select_record *s = new select_record;
d396 1
a396 1
      system_printf ("WaitForMultipleObjects failed, %E");
@


1.207.2.7
log
@Pull in changes from HEAD
@
text
@a287 16
#ifdef DEBUGGING
void
select_record::dump_select_record ()
{
  select_printf ("fd %d, h %p, fh %p, thread_errno %d, windows_handle %p",
		 fd, h, fh, thread_errno, windows_handle);
  select_printf ("read_ready %d, write_ready %d, except_ready %d",
		 read_ready, write_ready, except_ready);
  select_printf ("read_selected %d, write_selected %d, except_selected %d, except_on_write %d",
		 read_selected, write_selected, except_selected, except_on_write);
                    
  select_printf ("startup %p, peek %p, verify %p cleanup %p, next %p",
		 startup, peek, verify, cleanup, next);
}
#endif /*DEBUGGING*/

a316 3
#ifdef DEBUGGING
  s->dump_select_record ();
#endif
@


1.207.2.8
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d167 7
a173 6
	    /* select() is always interrupted by a signal so set EINTR,
	       unconditionally, ignoring any SA_RESTART detection by
	       call_signal_handler().  */
	    _my_tls.call_signal_handler ();
	    set_sig_errno (EINTR);
	    res = select_stuff::select_signalled;
d406 7
a412 6
      /* select() is always interrupted by a signal so set EINTR,
	 unconditionally, ignoring any SA_RESTART detection by
	 call_signal_handler().  */
      _my_tls.call_signal_handler ();
      set_sig_errno (EINTR);
      res = select_signalled;	/* Cause loop exit in cygwin_select */
@


1.207.2.9
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.206
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d335 1
a335 1
  set_thread_waiting here (w4[m++]);
@


1.205
log
@	In terms of network related functionality, rely on Winsock definitions
	as much as possible:
	* dtable.cc: Drop including sys/socket.h.
	* fhandler_procnet.cc: Change includes accordingly.
	* fhandler_socket.cc: Ditto.
	(fhandler_socket::listen): Avoid gcc error message initializing sin6.
	(LPFN_WSARECVMSG): Only define when building against w32api headers.
	* net.cc: Change includes accordingly.  Define USE_SYS_TYPES_FD_SET
	and __WSA_ERR_MACROS_DEFINED.  Define _INC_NETIOAPI temporarily and
	explain why.
	(struct _IP_ADAPTER_UNICAST_ADDRESS_LH): Only define when building
	against w32api headers.
	(struct _IP_ADAPTER_ADDRESSES_LH): Ditto.
	(SIO_GET_INTERFACE_LIST): Ditto.
	(ws_freeaddrinfo): Rename from freeaddrinfo so as not to collide with
	Winsock declaration.  Change througout.
	(ws_getaddrinfo): Ditto.
	(ws_getnameinfo): Ditto.
	* select.cc: Include netdb.h after defining USE_SYS_TYPES_FD_SET.
	* syslog.cc: Drop including netinet/in.h.  Define USE_SYS_TYPES_FD_SET
	and include ws2tcpip.h.
	* include/netdb.h (struct addrinfo): Don't define when building Cygwin.
	* include/cygwin/if.h: Don't declare if_xxx functions when building
	Cygwin.
	* include/cygwin/in.h: Disable most definitions when building Cygwin.
	* include/cygwin/socket.h: Disable sockaddr and sockaddr_storage
	definitions when building Cygwin.  Same for MCAST_INCLUDE/MCAST_EXCLUDE.
	* libc/inet_addr.c: Don't define __INSIDE_CYGWIN__ nor
	__INSIDE_CYGWIN_NET__.
	* libc/inet_network.c: Ditto.
	* libc/minires.h: Drop redundant inclusion of netdb.h.  Define
	__INSIDE_CYGWIN_NET__ only before including netdb.h and resolver
	headers.
@
text
@d103 12
d116 4
a119 4
  /* Convert to milliseconds or INFINITE if to == NULL */
  DWORD ms = to ? (to->tv_sec * 1000) + (to->tv_usec / 1000) : INFINITE;
  if (ms == 0 && to->tv_usec)
    ms = 1;			/* At least 1 ms granularity */
d121 1
a121 6
  if (to)
    select_printf ("to->tv_sec %d, to->tv_usec %d, ms %d", to->tv_sec, to->tv_usec, ms);
  else
    select_printf ("to NULL, ms %x", ms);

  int res = select (maxfds, readfds ?: allocfd_set (maxfds),
d124 1
d190 1
d209 4
a212 1
	    select_printf ("timed out after verification");
d243 1
a243 1
    set_signal_mask (*set, _my_tls.sigmask);
d247 1
a247 1
    set_signal_mask (oldset, _my_tls.sigmask);
d335 1
a335 1
  w4[m++] = signal_arrived;  /* Always wait for the arrival of a signal. */
@


1.204
log
@* cygwait.h (cancelable_wait): Make extern to avoid always including.
* select.cc (allocfd_set): Try to make a little more efficient.
(cygwin_select): Break into two functions to avoid what seems to be a strange
compiler problem with alloca and sel constructor.
(select): New function.  Always honor return from call_signal_handler.
(select_stuff::wait): Always honor return from call_signal_handler.
* select.h (select_stuff::select_stuff): Use NULL to initialize pointers rather
than 0.
@
text
@a23 1
#include <netdb.h>
d26 1
@


1.203
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d76 7
a82 1
#define allocfd_set(n) ((fd_set *) memset (alloca (sizeof_fd_set (n)), 0, sizeof_fd_set (n)))
d93 3
a95 2
/* The main select code.
 */
a101 17
  select_stuff sel;
  fd_set *dummy_readfds = allocfd_set (maxfds);
  fd_set *dummy_writefds = allocfd_set (maxfds);
  fd_set *dummy_exceptfds = allocfd_set (maxfds);

  /* Allocate some fd_set structures using the number of fds as a guide. */
  fd_set *r = allocfd_set (maxfds);
  fd_set *w = allocfd_set (maxfds);
  fd_set *e = allocfd_set (maxfds);

  if (!readfds)
    readfds = dummy_readfds;
  if (!writefds)
    writefds = dummy_writefds;
  if (!exceptfds)
    exceptfds = dummy_exceptfds;

d114 7
a120 1
  sel.return_on_signal = &_my_tls == _main_tls;
d122 7
d133 8
d160 1
a160 2
	    _my_tls.call_signal_handler ();
	    if (!sel.return_on_signal)
a211 2
  syscall_printf ("%R = select(%d, %p, %p, %p, %p)", res, maxfds, readfds,
		  writefds, exceptfds, to);
d376 1
a376 2
      _my_tls.call_signal_handler ();
      if (!return_on_signal)
@


1.202
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d315 1
a315 1
  set_thread_waiting (w4[m++]);
@


1.201
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d315 1
a315 1
  w4[m++] = signal_arrived;  /* Always wait for the arrival of a signal. */
@


1.200
log
@* select.cc (cygwin_select): Remove select_timeout test.
(select_stuff::wait): Return select_set_zero on timeout.
(thread_socket): Report timeout when debugging.
@
text
@d37 1
d147 1
a147 1
	  case WAIT_OBJECT_0:
d158 1
a158 1
	  case WAIT_OBJECT_0 + 1:
@


1.199
log
@* select.cc (cygwin_select): Make sure that we only return -1 as an error
return.
(select_stuff::wait): Semi-revert to previous method for filling out w4.
@
text
@d171 1
a171 3
      if (res == select_stuff::select_timeout)
	res = 0;					/* No fd's were active. */
      else if (res >= 0)
d384 1
a384 1
      res = select_timeout;
d1306 1
a1306 1
  select_printf ("stuff_start %p", si->start);
@


1.198
log
@* select.cc (cygwin_select): Add some comments.
(select_stuff::wait): Ditto.
@
text
@d201 2
d320 1
a320 1
  int startfds = m;
d336 7
a342 5
	for (DWORD i = startfds; i <= m; i++)
	  if (i == m)
	    w4[m = i] = s->h;
	  else if (w4[i] == s->h)
	    break;
@


1.197
log
@* DevNotes: Add entry cgf-000010.
* select.cc (set_handle_or_return_if_not_open): Remove unneeded final backslash
from definition.
(cygwin_select): Reorganize to incorporate outer retry loop.  Move remaining
time recalculation here for retry case.  Use select_stuff::wait_states for loop
control.
(select_stuff::cleanup): Avoid unneeded initialization.
(select_stuff::wait): Modify definition to return select_stuff::wait_states.
Eliminate is_cancelable.  Don't element 1 of an array if it is a cancel handle.
Remove loop.  Rely on being called from enclosing loop in cygwin_select.
Remove time recalculation when restarting.  Try harder to always return from
the bottom.
* select.h (select_stuff::wait_state): New enum.
(select_stuff::wait): Modify declaration to return select_stuff::wait_states.
@
text
@d131 2
d166 2
a167 1
	res = 0;
d169 2
a170 1
	res = sel.wait (r, w, e, ms);
d172 1
a172 1
	res = 0;
d178 1
d181 2
d185 1
d361 2
d371 1
a371 1
	  res = select_signalled;
@


1.196
log
@	* select.cc (select_stuff::wait): Temporarily disable restarting
	entirely.
@
text
@d84 1
a84 1
    } \
d92 2
d99 4
a102 3
  select_printf ("select(%d, %p, %p, %p, %p)", maxfds, readfds, writefds, exceptfds, to);

  pthread_testcancel ();
d111 1
a111 6
  for (int i = 0; i < maxfds; i++)
    if (!sel.test_and_set (i, readfds, writefds, exceptfds))
      {
	select_printf ("aborting due to test_and_set error");
	return -1;	/* Invalid fd, maybe? */
      }
d123 5
a127 1
  select_printf ("sel.always_ready %d", sel.always_ready);
d129 9
a137 4
  /* Allocate some fd_set structures using the number of fds as a guide. */
  fd_set *r = allocfd_set (maxfds);
  fd_set *w = allocfd_set (maxfds);
  fd_set *e = allocfd_set (maxfds);
d139 51
a189 22
  int res = 0;
  sel.return_on_signal = &_my_tls == _main_tls;
  /* Degenerate case.  No fds to wait for.  Just wait. */
  if (sel.start.next == NULL)
    while (!res)
      switch (cygwait (ms))
	{
	case WAIT_OBJECT_0:
	  select_printf ("signal received");
	  _my_tls.call_signal_handler ();
	  if (!sel.return_on_signal)
	    continue;		/* Emulate linux behavior */
	  set_sig_errno (EINTR);
	  res = -1;
	  break;
	case WAIT_OBJECT_0 + 1:
	  sel.destroy ();
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	default:
	  res = 1;	/* temporary flag.  Will be set to zero below. */
	  break;
a190 10
  else if (sel.always_ready || ms == 0)
    res = 0;
  else
    res = sel.wait (r, w, e, ms);
  if (res >= 0)
    {
      copyfd_set (readfds, r, maxfds);
      copyfd_set (writefds, w, maxfds);
      copyfd_set (exceptfds, e, maxfds);
      res = (res > 0) ? 0 : sel.poll (readfds, writefds, exceptfds);
d242 1
a242 1
  select_record *s = &start;
d251 1
d298 1
a298 1
int
a301 1
  int wait_ret;
d304 1
a304 3
  int m = 0;
  int res = 0;
  bool is_cancelable = false;
d308 1
a308 4
    {
      ++m;
      is_cancelable = true;
    }
d310 1
d318 1
a318 1
	  return -1;
d323 1
a323 1
	  return -1;
d325 6
a330 8
      if (s->h == NULL)
	continue;
      for (int i = 1; i < m; i++)
	if (w4[i] == s->h)
	  goto next_while;
      w4[m++] = s->h;
  next_while:
      continue;
d333 14
a346 2
  bool gotone;
  LONGLONG start_time = gtod.msecs ();	/* Record the current time for later use. */
d348 2
a349 2
  debug_printf ("m %d, ms %u", m, ms);
  for (;;)
d351 7
a357 2
      if (!windows_used)
	wait_ret = WaitForMultipleObjects (m, w4, FALSE, ms);
a358 9
	/* Using MWMO_INPUTAVAILABLE is the officially supported solution for
	   the problem that the call to PeekMessage disarms the queue state
	   so that a subsequent MWFMO hangs, even if there are still messages
	   in the queue. */
	wait_ret = MsgWaitForMultipleObjectsEx (m, w4, ms,
						QS_ALLINPUT | QS_ALLPOSTMESSAGE,
						MWMO_INPUTAVAILABLE);

      switch (wait_ret)
a359 15
	case WAIT_OBJECT_0:
	  select_printf ("signal received");
#if 0
	  /* FIXME?  Partial revert of change from 2012-01-22.  If the signal
	     handler is called before the threads are stopped via cleanup,
	     emacs 24.x crashes in thread_pipe.  Just restarting without
	     calling the signal handler makes select entirely uninterruptible
	     when called from a thread not the main thread, see
	     http://cygwin.com/ml/cygwin/2012-05/msg00580.html
	     So, for now, just disable restarting entirely. */
	  if (!return_on_signal)
	    goto looping;		/* Emulate linux behavior */
#endif
	  cleanup ();
	  _my_tls.call_signal_handler ();
d361 16
a376 12
	  return -1;
	case WAIT_OBJECT_0 + 1:
	  if (is_cancelable)
	    {
	      cleanup ();
	      destroy ();
	      pthread::static_cancel_self ();
	    }
	  /* This wasn't a cancel event.  It was just a normal object to wait
	     for.  */
	  break;
	case WAIT_FAILED:
d378 3
a380 9
	  system_printf ("WaitForMultipleObjects failed");
	  s = &start;
	  s->set_select_errno ();
	  return -1;
	case WAIT_TIMEOUT:
	  cleanup ();
	  select_printf ("timed out");
	  res = 1;
	  goto out;
d382 3
a384 2

      select_printf ("woke up.  wait_ret %d.  verifying", wait_ret);
d386 1
a386 1
      gotone = false;
a393 1
	    cleanup ();
d395 2
a396 1
	    return -1;		/* Somebody detected an error */
d402 4
d407 1
a407 25
      if (gotone)
	{
	  cleanup ();
	  goto out;
	}
#if 0
looping:
#endif
      if (ms == INFINITE)
	{
	  select_printf ("looping");
	  continue;
	}
      select_printf ("recalculating ms");

      LONGLONG now = gtod.msecs ();
      if (now > (start_time + ms))
	{
	  cleanup ();
	  select_printf ("timed out after verification");
	  goto out;
	}
      ms -= (now - start_time);
      start_time = now;
      select_printf ("ms now %u", ms);
a408 1

@


1.195
log
@	* select.cc (select_stuff::wait): When not returning after receiving
	a signal, recalculate timeout.  Apply temporary fix to avoid crashes
	after calling the signal handler.  Explain.
@
text
@d334 1
d337 5
a341 3
	     emacs 24.x crashes in thread_pipe.  For now, do not call the
	     signal handler if we're not in the main thread, but cleanup
	     before calling the signal handler. */
d344 1
d396 1
d398 1
@


1.194
log
@* fhandler.h (fhandler_pty_common::bytes_available): Declare new function.
(fhandler_pty_master::flush_to_slave): Ditto.
* fhandler_tty.cc (bytes_available): Define new function.
(fhandler_pty_common::bytes_available): Ditto.
(handler_pty_master::flush_to_slave): Ditto.
(fhandler_pty_master::process_slave_output): Call flush_to_slave () here.  Use
bytes_available () rather than PeekNamedPipe.  Cleanup sloppy logic.
(fhandler_pty_slave::read): Use bytes_available () rather than PeekNamedPipe.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_master::ioctl): Ditto.
(fhandler_pty_master::cleanup): Remove ancient #if 0.
* select.cc (peek_pipe): Call flush_to_slave whenever we're checking for a pty
master.
@
text
@d313 1
d334 5
a338 1
	  _my_tls.call_signal_handler ();
d340 1
a340 1
	    continue;		/* Emulate linux behavior */
d342 1
d370 1
a370 1
      bool gotone = false;
d392 1
a392 1

@


1.193
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d555 9
a563 5
	  if (((fhandler_pty_master *) fh)->need_nl)
	    {
	      gotone = s->read_ready = true;
	      goto out;
	    }
@


1.192
log
@* fhandler.cc (fhandler_base_overlapped::has_ongoing_io): Don't block
GetOverlappedResult since previous IsEventSignalled will have reset the handle.
* select.cc (cygwin_select): Remove space before parentheses in syscall
debugging output.
(pipe_data_available): Streamline if block.
@
text
@d1296 1
a1296 1
	  switch (WaitForMultipleObjects (min (si->num_w4 - i,
@


1.191
log
@* cygheap.h (cygheap_fdget::~cygheap_fdget): Simplify now that refcnt reports
reference count changes itself.
* fhandler.cc (fhandler_base::reset): Set _refcnt to 0.
* fhandler.h (fhandler_base::refcnt): Report refcnt when debugging.
* select.cc (cygwin_select): Set return_on_signal to indicate when select
should be interrupted.
(select_stuff::wait): Keep looping unless return_on_signal is set.
* select.h (select_stuff::return_on_signal): New variable.
(select_stuff::select_stuff): Zero return_on_signal.
@
text
@d167 1
a167 1
  syscall_printf ("%R = select (%d, %p, %p, %p, %p)", res, maxfds, readfds,
d493 37
a529 48
  bool res = false;
  if (!fh->has_ongoing_io ())
    {
      if (NtQueryInformationFile (h,
				  &iosb,
				  &fpli,
				  sizeof (fpli),
				  FilePipeLocalInformation))
	{
	  /* If NtQueryInformationFile fails, optimistically assume the
	     pipe is writable.  This could happen if we somehow
	     inherit a pipe that doesn't permit FILE_READ_ATTRIBUTES
	     access on the write end.  */
	  select_printf ("fd %d, %s, NtQueryInformationFile failed",
			 fd, fh->get_name ());
	  res = writing ? true : -1;
	}
      else if (!writing)
	{
	  res = !!fpli.ReadDataAvailable;
	  paranoid_printf ("fd %d, %s, read avail %u", fd, fh->get_name (), fpli.ReadDataAvailable);
	}
      else
	{
	  /* If there is anything available in the pipe buffer then signal
	     that.  This means that a pipe could still block since you could
	     be trying to write more to the pipe than is available in the
	     buffer but that is the hazard of select().  */
	  if ((fpli.WriteQuotaAvailable = (fpli.OutboundQuota - fpli.ReadDataAvailable)))
	    {
	      paranoid_printf ("fd %d, %s, write: size %lu, avail %lu", fd,
			     fh->get_name (), fpli.OutboundQuota,
			     fpli.WriteQuotaAvailable);
	      res = true;
	    }
	  /* If we somehow inherit a tiny pipe (size < PIPE_BUF), then consider
	     the pipe writable only if it is completely empty, to minimize the
	     probability that a subsequent write will block.  */
	  else if (fpli.OutboundQuota < PIPE_BUF &&
		   fpli.WriteQuotaAvailable == fpli.OutboundQuota)
	    {
	      select_printf ("fd, %s, write tiny pipe: size %lu, avail %lu",
			     fd, fh->get_name (), fpli.OutboundQuota,
			     fpli.WriteQuotaAvailable);
	      res = true;
	    }
	}
    }
@


1.190
log
@add missing change
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d133 1
d140 1
d142 1
a142 1
	  if (&_my_tls != _main_tls)
a143 1
	  select_printf ("signal received");
d332 4
a336 1
	  select_printf ("signal received");
@


1.189
log
@* dcrt0.cc (init_windows_system_directory): Record system_wow64_directory
information.
* exceptions.cc (_cygtls::inside_kernel): Modernize comment.  Consider
executing a DLL from the Wow64 directory as being "in the kernel".
(_cygtls::call_signal_handler): For now, only deal with main_tls signals if
main_tls is known to be executing in the cygwin DLL.  To more closely emulate
linux, consider the operation to be restartable if not executing in the main
thread.
* globals.cc (windows_system_directory): Remove NO_COPY.
(windows_system_directory_length): Ditto.
(system_wow64_directory): New variable.
(system_wow64_directory_length): Ditto.
* select.cc (cygwin_select): Don't issue a EINTR on non-main threads since that
seems to be what Linux does.  Add missing break to signal case/switch.
(select_stuff::wait): Don't issue a EINTR on non-main threads since that seems
to be what Linux does.  Remove now-unneeded accommodation for
WAIT_IO_COMPLETION.  Add a comment.
* sigproc.h (cygwait): Ditto.  Don't return if signal_received noticed and it's
not the main thread.
* signal.cc (sigprocmask): Add standard syscall debug stuff.
* thread.cc (pthread_sigmask): Ditto.
@
text
@a330 3
	  _my_tls.call_signal_handler ();
	  if (&_my_tls != _main_tls)
	    continue;		/* Emulate linux behavior */
@


1.188
log
@* select.cc (select_stuff::wait): Very minor formatting fix.
(peek_windows): Report on HWND handle used in queries.
* select.h: Update copyright.
* sigproc.h (cygwait): Eliminate multi-argument variety since more general
implementation may cause odd problems in select.  Also force to always be
inline.
@
text
@d132 1
a132 1
  int res = 1;
d135 19
a153 14
    switch (cygwait (ms))
      {
      case WAIT_OBJECT_0:
	select_printf ("signal received");
	set_sig_errno (EINTR);
	res = -1;
      case WAIT_OBJECT_0 + 1:
	sel.destroy ();
	pthread::static_cancel_self ();
	/*NOTREACHED*/
      default:
	res = 1;
	break;
      }
d329 1
a329 5
      {
	case WAIT_IO_COMPLETION:
	  syscall_printf ("woke due to apc");
	  continue;	/* Keep going */
	  break;
d331 3
d345 2
d359 1
a359 1
      }
@


1.187
log
@Rename cygWFMO to cygwait throughout and use the magic of polymorphism to "wait
for stuff".
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use simplified arg
form of cygwait.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_audio.cc (fhandler_dev_dsp::Audio_out::waitforspac): Ditto.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* select.cc (cygwin_select): Ditto.
* sigproc.h (cygwait): Rename from cygWFMO.  Define two argument and single
argument forms of this function.
* fhandler_tty.cc (fhandler_pty_slave::open): Use method to query if tty is
open.
(fhandler_pty_slave::read): Send SIGHUP when master is detected as closed.
(fhandler_pty_common::close): Close input_available_event in callers since
master may need to signal it first.
(fhandler_pty_master::close): Lie and set input_available_event when closing,
then close input_available_event.
(fhandler_pty_slave::close): Close input_available_event explicitly here.
* tty.h (tty::is_master_closed): Declare new method.
@
text
@d369 2
a370 2
	else if ((((wait_ret >= m && s->windows_handle) || s->h == w4[wait_ret])) &&
	    s->verify (s, readfds, writefds, exceptfds))
d1501 1
a1501 1
      select_printf ("window %d(%p) ready", me->fd, me->fh->get_handle ());
d1505 1
a1505 1
  select_printf ("window %d(%p) not ready", me->fd, me->fh->get_handle ());
@


1.186
log
@* select.cc (cygwin_select): Fifth time is the charm.
@
text
@d135 1
a135 1
    switch (cygWFMO (0, ms))
@


1.185
log
@* select.cc (cygwin_select): Make sure that 0 is returned when sel.wait times
out.
@
text
@d146 1
a146 1
	res = 0;
d149 5
a153 2
  else if ((sel.always_ready || ms == 0)
  	   || (res = sel.wait (r, w, e, ms)) >= 0)
@


1.184
log
@* select.cc (select_stuff::wait): Temporarily disallow APCS.
@
text
@d150 1
a150 1
  	   || (res = sel.wait (r, w, e, ms)) == 0)
d155 1
a155 1
      res = sel.poll (readfds, writefds, exceptfds);
@


1.183
log
@* select.cc (cygwin_select): Make sure that poll is called when appropriate.
@
text
@d310 1
a310 1
	wait_ret = WaitForMultipleObjectsEx (m, w4, FALSE, ms, true);
d318 1
a318 1
						MWMO_INPUTAVAILABLE | MWMO_ALERTABLE);
@


1.182
log
@* select.cc (cygwin_select): Add common introducer and leaver debug output.
(select_stuff::poll): Remove unneeded debugging.
@
text
@a126 1
  int timeout = 0;
d135 16
a150 22
    {
      switch (cygWFMO (0, ms))
	{
	case WAIT_OBJECT_0:
	  select_printf ("signal received");
	  set_sig_errno (EINTR);
	  return -1;
	case WAIT_OBJECT_0 + 1:
	  sel.destroy ();
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	default:
	  break;
	}
      res = 0;
    }
  else if (sel.always_ready || ms == 0)
    res = 0;
  else if ((timeout = sel.wait (r, w, e, ms) < 0))
    res = -1;	/* some kind of error */

  if (res >= 0)
d155 1
a155 2
      if (res > 0)
	res = sel.poll (readfds, writefds, exceptfds);
@


1.181
log
@* sigproc.cc (cygWFMO): Don't assume that cancellable event is always
available.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::waitforspace): Use cygWFMO
instead of WaitForMultipleObjects.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto for degenerate case.
@
text
@d97 1
a97 1
  select_printf ("%d, %p, %p, %p, %p", maxfds, readfds, writefds, exceptfds, to);
d133 1
d150 1
a150 1
      timeout = 1;
d153 1
a153 1
    /* Don't bother waiting. */;
d155 1
a155 1
    return -1;	/* some kind of error */
d157 12
a168 4
  copyfd_set (readfds, r, maxfds);
  copyfd_set (writefds, w, maxfds);
  copyfd_set (exceptfds, e, maxfds);
  return timeout ? 0 : sel.poll (readfds, writefds, exceptfds);
a456 1
  select_printf ("returning %d", n);
@


1.180
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d136 1
a136 4
      HANDLE w4[2] = { signal_arrived, pthread::get_cancel_event () };
      DWORD cnt = w4[1] ? 2 : 1;

      switch (WaitForMultipleObjects (cnt, w4, FALSE, ms))
@


1.179
log
@* sigproc.cc (remove_proc): Don't terminate the currently executing thread.
@
text
@d657 1
a657 1
      pi->thread = new cygthread (thread_pipe, pi, "select_pipe");
d1141 1
a1141 1
      si->thread = new cygthread (thread_serial, si, "select_serial");
d1410 1
a1410 1
  si->thread = new cygthread (thread_socket, si, "select_socket");
d1648 1
a1648 1
  mi->thread = new cygthread (thread_mailslot, mi, "select_mailslot");
@


1.178
log
@* cygthread.h (cygthread::name): Default name to "main" if we are early in the
process of setting up the DLL and no name is known.
* dcrt0.cc (initial_env): Remove CYGWIN_SLEEP stuff.
(get_cygwin_startup_info): Activate strace here as appropriate.
(dll_crt0_0): Move get_cygwin_startup_info as early as possible to avoid
missing strace output.
* fork.cc (frok::child): Move debugging statement to point where ppid will be
set.
* pinfo.cc (pinfo::thisproc): Remove obsolete call to strace.hello.  Tweak
debug output slightly.
* select.cc (select_stuff::wait): Allow APCS to be triggered while waiting
since we use them now.  Report when that happens.
* sigproc.cc (child_info::child_info): Use strace.active() rather than
strace.attached().
* spawn.cc (child_info_spawn::worker): Only write strace child pid when we know
it's a cygwin process.  Accommodate change to write_child argument list.
* strace.cc (strace::hello): Delete.  Move functionality...
(strace::activate): ...to here.
(mypid): Just use raw GetCurrentProcessId () if myself isn't set.
(strace::write_childpid): Don't wait for subproc_ready.  Remove arg which was
required for it.
* include/sys/strace.h (strace::hello): Delete.
(strace::write_childpid): Delete first argument.
@
text
@d487 1
a487 20
  if (NtQueryInformationFile (h,
			      &iosb,
			      &fpli,
			      sizeof (fpli),
			      FilePipeLocalInformation))
    {
      /* If NtQueryInformationFile fails, optimistically assume the
	 pipe is writable.  This could happen if we somehow
	 inherit a pipe that doesn't permit FILE_READ_ATTRIBUTES
	 access on the write end.  */
      select_printf ("fd %d, %s, NtQueryInformationFile failed",
		     fd, fh->get_name ());
      res = writing ? true : -1;
    }
  else if (!writing)
    {
      res = !!fpli.ReadDataAvailable;
      paranoid_printf ("fd %d, %s, read avail %u", fd, fh->get_name (), fpli.ReadDataAvailable);
    }
  else
d489 5
a493 5
      /* If there is anything available in the pipe buffer then signal
	 that.  This means that a pipe could still block since you could
	 be trying to write more to the pipe than is available in the
	 buffer but that is the hazard of select().  */
      if ((fpli.WriteQuotaAvailable = (fpli.OutboundQuota - fpli.ReadDataAvailable)))
d495 7
a501 4
	  paranoid_printf ("fd %d, %s, write: size %lu, avail %lu", fd,
			 fh->get_name (), fpli.OutboundQuota,
			 fpli.WriteQuotaAvailable);
	  res = true;
d503 1
a503 5
      /* If we somehow inherit a tiny pipe (size < PIPE_BUF), then consider
	 the pipe writable only if it is completely empty, to minimize the
	 probability that a subsequent write will block.  */
      else if (fpli.OutboundQuota < PIPE_BUF &&
	       fpli.WriteQuotaAvailable == fpli.OutboundQuota)
d505 27
a531 4
	  select_printf ("fd, %s, write tiny pipe: size %lu, avail %lu",
			 fd, fh->get_name (), fpli.OutboundQuota,
			 fpli.WriteQuotaAvailable);
	  res = true;
@


1.177
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@d312 1
a312 1
	wait_ret = WaitForMultipleObjects (m, w4, FALSE, ms);
d320 1
a320 1
						MWMO_INPUTAVAILABLE);
d324 4
@


1.176
log
@	Throughout change "WinSock" to "Winsock" in comments.
	* fhandler_socket.cc (fhandler_socket::sendmsg): Add missing call to
	get_inet_addr to convert AF_LOCAL to AF_INET sockets.
	* net.cc (cygwin_socket): Workaround UDP Winsock problem.  Add comment
	to explain why.
	* select.cc: Include winsock2.h rather than winsock.h.
@
text
@d551 1
a551 1
	case DEV_TTYM_MAJOR:
@


1.175
log
@* cygheap.h (init_cygheap::ctty_on_hold): Remove conditionalized variable.
* dcrt0.cc (do_exit): Remove code which handled CYGWIN=tty style ttys.
* devices.in: Remove "/dev/ttym".
* dtable.cc: Rename tty to pty where appropriate throughout.
(dtable::stdio_init): Use new t->is_console rather than using now-deleted hwnd
element in tty structure.
(dtable::init_std_file_from_handle): Remove code which handled CYGWIN=tty style
ttys.
(fh_alloc): Ditto.
* fhandler.h: Rename tty to pty where appropriate.
(fhandler_pty_common): Delete output_done_event, ioctl_request_event,
ioctl_done_event.
(fhandler_pty_master::setup): Delete argument.
(fhandler_tty_master): Delete.
(fhandler_union): Delete __tty_master.
* fhandler_console.cc (use_tty): Delete.
(fhandler_console::get_tty_stuff): Set is_console to true rather than calling
sethwnd.
(fhandler_console::send_winch_maybe): Remove CYGWIN=tty considerations.
(fhandler_console::input_tcsetattr): Ditto.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use new t->is_console
rather than using now-deleted hwnd element in tty structure.
* fhandler_tty.cc: Rename tty to pty where appropriate throughout.
(tty_master): Delete.
(process_input): Ditto.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::*): Ditto.
(fhandler_pty_master::process_slave_output): Remove CYGWIN=tty considerations.
(fhandler_pty_slave::open): Ditto for *_done_event.
(fhandler_pty_slave::write): Ditto.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_slave::fch_open_handles): Ditto.
(fhandler_pty_slave::fch_set_sd): Ditto.
(fhandler_pty_slave::fch_close_handles): Ditto.
(fhandler_pty_common::close): Ditto.
(fhandler_pty_master::setup): Ditto.  Remove now-unneeded ispty parameter.
(fhandler_pty_master::open): Reflect argument removal for tty::allocate.
* select.cc: Rename tty to pty where appropriate throughout.
* sigproc.cc (proc_subproc): Remove CYGWIN=tty considerations.
* tty.cc (ttyslot): Accommodate CYGWIN=tty removal.
(tty_list::init_session): Ditto.
(tty_list::attach): Ditto.
(tty::create_master): Delete.
(tty_list::terminate): Ditto.
(tty_list::allocate): Delete "with_console" parameter.  Remove CYGWIN=tty
considerations.
(tty::init): Set is_console = false.  Use 'false' for was_opened since it is a
boolean.
* tty.h (*_{DONE,REQUEST}_EVENT): Delete.
(tty_min::is_console): Declare new field which replaces hwnd.
(tty_min::gethwnd): Delete.
(tty_min::sethwnd): Ditto.
(tty_list::allocate): Delete parameter.
(tty_list::terminate): Delete declaration.
* include/sys/cygwin.h (PID_USETTY): Redefine to PID_UNUSED1 and change comment
to reflect its availability.
@
text
@d26 1
a26 1
#include <winsock.h>
@


1.174
log
@* ntdll.h (FILE_PIPE_*): Define constants.
* select.cc (pipe_data_available): Detect closing state.
@
text
@d889 1
a889 1
fhandler_tty_common::select_read (select_stuff *ss)
d906 1
a906 1
fhandler_tty_common::select_write (select_stuff *ss)
d922 1
a922 1
fhandler_tty_common::select_except (select_stuff *ss)
d947 1
a947 1
fhandler_tty_slave::select_read (select_stuff *ss)
@


1.173
log
@* external.cc (fillout_pinfo): Don't truncate ctty if it's < 0.
* select.cc (pipe_data_available): Avoid printing debug info by default or
suffer very large strace files.
@
text
@d527 1
a527 1
  return res;
@


1.172
log
@* select.cc (pipe_data_available): New function - uses NtQueryInformationFile
to return information about pipes.
(peek_pipe): Rewrite to use pipe_data_available for both read and write tests.
@
text
@d500 1
a500 1
      select_printf ("fd %d, %s, read avail %u", fd, fh->get_name (), fpli.ReadDataAvailable);
d510 1
a510 1
	  select_printf ("fd %d, %s, write: size %lu, avail %lu", fd,
@


1.171
log
@	* fhandler.h (class fhandler_base): Remove uninterruptible_io status
	flag.
	(fhandler_base::ready_for_read): Remove declaration.
	(fhandler_socket::ready_for_read): Ditto.
	(fhandler_pipe::ready_for_read): Ditto.
	(fhandler_tty_master::is_slow): Remove.
	* fhandler_console.cc (fhandler_console::open): Drop setting
	uninterruptible_io.
	* fhandler_serial.cc (fhandler_serial::open): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Ditto.
	(fhandler_tty_master::init_console): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
	(fhandler_pipe::open): Ditto.
	(_pipe): Ditto.
	* select.cc (fhandler_pipe::ready_for_read): Remove.
	(fhandler_base::ready_for_read): Remove.
	* syscalls.cc (readv): Drop unneeded wait variable.  Remove entire test
	which might lead to calling ready_for_read.  Remove now unused label
	out.
@
text
@d477 54
a535 1
  int n = 0;
d539 2
a540 10
  /* Don't check if this is a non-blocking fd and I/O is still active.
     That could give a false-positive with peek_pipe and friends. */
  if (fh->has_ongoing_io ())
    return 0;

  /* Don't perform complicated tests if we don't need to. */
  if (!s->read_selected && !s->except_selected)
    goto out;

  if (s->read_selected)
d572 1
a572 1
    }
d574 9
a582 44
  if (fh->get_device () == FH_PIPEW)
    select_printf ("%s, select for read/except on write end of pipe",
		   fh->get_name ());
  else if (!PeekNamedPipe (h, NULL, 0, NULL, (DWORD *) &n, NULL))
    switch (GetLastError ())
      {
      case ERROR_BAD_PIPE:
      case ERROR_PIPE_BUSY:
      case ERROR_NO_DATA:
      case ERROR_PIPE_NOT_CONNECTED:
	n = 0;
	break;
      default:
	select_printf ("%s, PeekNamedPipe failed, %E", fh->get_name ());
	n = -1;
	break;
      }

  if (n < 0)
    {
      select_printf ("%s, n %d", fh->get_name (), n);
      if (s->except_selected)
	gotone += s->except_ready = true;
      if (s->read_selected)
	gotone += s->read_ready = true;
    }
  if (n > 0 && s->read_selected)
    {
      select_printf ("%s, ready for read: avail %d", fh->get_name (), n);
      gotone += s->read_ready = true;
    }
  if (!gotone && s->fh->hit_eof ())
    {
      select_printf ("%s, saw EOF", fh->get_name ());
      if (s->except_selected)
	gotone += s->except_ready = true;
      if (s->read_selected)
	gotone += s->read_ready = true;
    }

out:
  if (s->write_selected)
    {
      if (s->write_ready)
d584 2
a585 2
	  select_printf ("%s, already ready for write", fh->get_name ());
	  gotone++;
d587 1
a587 5
      /* Do we need to do anything about SIGTTOU here? */
      else if (fh->get_device () == FH_PIPER)
	select_printf ("%s, select for write on read end of pipe",
		       fh->get_name ());
      else
d589 5
a593 41
	  IO_STATUS_BLOCK iosb = {0};
	  FILE_PIPE_LOCAL_INFORMATION fpli = {0};

	  if (NtQueryInformationFile (h,
				      &iosb,
				      &fpli,
				      sizeof (fpli),
				      FilePipeLocalInformation))
	    {
	      /* If NtQueryInformationFile fails, optimistically assume the
		 pipe is writable.  This could happen if we somehow
		 inherit a pipe that doesn't permit FILE_READ_ATTRIBUTES
		 access on the write end.  */
	      select_printf ("%s, NtQueryInformationFile failed",
			     fh->get_name ());
	      gotone += s->write_ready = true;
	    }
	  /* If there is anything available in the pipe buffer then signal
	     that.  This means that a pipe could still block since you could
	     be trying to write more to the pipe than is available in the
	     buffer but that is the hazard of select().  */
	  else if ((fpli.WriteQuotaAvailable = (fpli.OutboundQuota - fpli.ReadDataAvailable)))
	    {
	      select_printf ("%s, ready for write: size %lu, avail %lu",
			     fh->get_name (),
			     fpli.OutboundQuota,
			     fpli.WriteQuotaAvailable);
	      gotone += s->write_ready = true;
	    }
	  /* If we somehow inherit a tiny pipe (size < PIPE_BUF), then consider
	     the pipe writable only if it is completely empty, to minimize the
	     probability that a subsequent write will block.  */
	  else if (fpli.OutboundQuota < PIPE_BUF &&
		   fpli.WriteQuotaAvailable == fpli.OutboundQuota)
	    {
	      select_printf ("%s, tiny pipe: size %lu, avail %lu",
			     fh->get_name (),
			     fpli.OutboundQuota,
			     fpli.WriteQuotaAvailable);
	      gotone += s->write_ready = true;
	    }
d597 6
@


1.170
log
@	* select.cc (cygwin_select): Make degenerate case cancelable.
	(select_stuff::destroy): New inline method to delete memory taken
	by select_stuff.
	(select_stuff::~select_stuff): Call destroy.
	(select_stuff::wait): Add case to allow canceling select.
	* select.h (select_stuff::destroy): Declare.
	* thread.cc: Mark poll, pselect and poll as cancelable.
@
text
@a696 11
int
fhandler_pipe::ready_for_read (int fd, DWORD howlong)
{
  int res;
  if (!howlong)
    res = fhandler_base::ready_for_read (fd, howlong);
  else
    res = 1;
  return res;
}

a1227 49
int
fhandler_base::ready_for_read (int fd, DWORD howlong)
{
  bool avail = false;

  select_stuff sel;
  fd_set *thisfd = allocfd_set (fd + 1);
  fd_set *dummy_writefds = allocfd_set (fd + 1);
  fd_set *dummy_exceptfds = allocfd_set (fd + 1);
  UNIX_FD_SET(fd, thisfd);

  if (!sel.test_and_set (fd, thisfd, dummy_writefds, dummy_exceptfds))
    select_printf ("aborting due to test_and_set error");
  else
    {
      select_record *me = sel.start.next;
      while (!avail)
	{
	  avail = me->read_ready ?: me->peek (me, false);

	  if (fd >= 0 && cygheap->fdtab.not_open (fd))
	    {
	      set_sig_errno (EBADF);
	      avail = false;
	      break;
	    }

	  if (howlong != INFINITE)
	    {
	      if (!avail)
		set_sig_errno (EAGAIN);
	      break;
	    }

	  if (WaitForSingleObject (signal_arrived, avail ? 0 : 10) == WAIT_OBJECT_0)
	    {
	      debug_printf ("interrupted");
	      set_sig_errno (EINTR);
	      avail = false;
	      break;
	    }
	}
    }

  select_printf ("read_ready %d, avail %d", sel.start.next->read_ready, avail);
  sel.cleanup ();
  return avail;
}

@


1.169
log
@Eliminate trailing whitespace in some files.

* dll_init.cc (dll_list::alloc): Reset 'p' in forked process.
* select.cc (select_stuff::wait): Move cleanup() closer to WFMO to minimize
unavoidable (?) race.
@
text
@d136 4
a139 1
      if (WaitForSingleObject (signal_arrived, ms) == WAIT_OBJECT_0)
d141 1
d145 6
d206 2
a207 1
select_stuff::~select_stuff ()
a208 1
  cleanup ();
d220 6
d273 1
d276 6
d318 3
a320 4
	wait_ret =
	  MsgWaitForMultipleObjectsEx (m, w4, ms,
				       QS_ALLINPUT | QS_ALLPOSTMESSAGE,
				       MWMO_INPUTAVAILABLE);
d329 8
@


1.168
log
@	Throughout, use user32 UNICODE functions rather than ANSI functions.
	* autoload.cc: Convert all definitions for ANSI user32 functions to
	definitions for the corresponding UNICODE function.
	(SendMessageA): Remove.
	(SendNotifyMessageW): Define.
	* fhandler_windows.cc (fhandler_windows::write): Use SendNotifyMessageW
	call rather than SendMessage to make function always return immediately.
	(fhandler_windows::read): Make function interruptible and a cancellation
	point.  Handle O_NONBLOCK.
	* select.cc (peek_serial): Don't wait for signal_arrived here.
	* window.cc (wininfo::winthread): Call CreateWindowExW directly rather
	than CreateWindow wrapper.
@
text
@a148 1
  sel.cleanup ();
d292 1
a292 1
	   the problem that the call to PeekMessage disarms the queue state 
d303 1
d308 1
d314 1
d330 1
d340 4
a343 1
	goto out;
d355 1
@


1.167
log
@	* fcntl.cc (fcntl64): Call pthread_testcancel.
	* fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* flock.cc (lf_setlock): Allow to cancel thread running blocking
	file lock.  Try to make code more readable.
	(lockf): Call pthread_testcancel.
	* mmap.cc (msync): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Call pthread::static_cancel_self
	rather than pthread_testcancel.
	* select.cc (cygwin_select): Call pthread_testcancel.
	* syscalls.cc (pread): Ditto.
	(pwrite): Ditto.
	(readv): Ditto.
	(writev): Ditto.
	(open): Ditto.
	(close): Ditto.
	(fsync): Ditto.
	* termios.cc (tcdrain): Ditto.
	* thread.cc: Align list of cancellation points with above changes.
	Mark not-implemented functions, too.
	(cancelable_wait): Don't set unused object indices to WAIT_FAILED
	since that could result in wrong behaviour.  Set them to the invalid
	value WAIT_TIMEOUT + 1 instead.
@
text
@d1058 1
a1058 8
  HANDLE w4[2];
  DWORD to;

  w4[0] = fh->io_status.hEvent;
  w4[1] = signal_arrived;
  to = 10;

  switch (WaitForMultipleObjects (2, w4, FALSE, to))
d1067 1
a1067 1
	Sleep (to);
a1073 5
    case WAIT_OBJECT_0 + 1:
      select_printf ("interrupt");
      set_sig_errno (EINTR);
      ready = -1;
      break;
d1538 1
a1538 1
  if (PeekMessage (&m, (HWND) h, 0, 0, PM_NOREMOVE))
@


1.166
log
@	* ntdll.h (IsEventSignalled): New inline function.
	* cygthread.cc (cygthread::terminate_thread): Use IsEventSignalled in
	place of WaitForSingleObject on event with 0 timeout.
	* fhandler.cc (fhandler_base_overlapped::has_ongoing_io): Ditto.
	* fhandler_fifo.cc (fhandler_fifo::open_nonserver): Ditto.
	(fhandler_fifo::wait): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* select.cc (verify_tty_slave): Ditto.
	* thread.cc (pthread::testcancel): Ditto.
@
text
@d99 2
@


1.165
log
@* select.cc (serial_cleanup): Make sure that device_specific_pipe is always
deleted regardless of whether it has a unique thread associated with it
(socket_cleanup): Ditto.
(mailslot_cleanup): Ditto.
@
text
@d937 1
a937 1
  if (WaitForSingleObject (me->h, 0) == WAIT_OBJECT_0)
@


1.164
log
@* select.cc (pipe_cleanup): Make sure that device_specific_pipe is always
deleted regardless of whether it has a unique thread associated with it.
@
text
@d1153 3
a1155 1
  if (si && si->thread)
a1158 2
      delete si;
      stuff->device_specific_serial = NULL;
d1160 2
d1470 3
a1472 1
  if (si && si->thread)
a1477 2
      stuff->device_specific_socket = NULL;
      delete si;
d1479 2
d1710 3
a1712 1
  if (mi && mi->thread)
a1715 2
      delete mi;
      stuff->device_specific_mailslot = NULL;
d1717 2
@


1.163
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d647 3
a649 1
  if (pi && pi->thread)
a652 2
      delete pi;
      stuff->device_specific_pipe = NULL;
d654 2
@


1.162
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d293 1
a293 3
	   in the queue.  Unfortunately this flag didn't exist  prior to Win2K,
	   so for NT4 we fall back to a different usage of PeekMessage in
	   peek_windows.  See there for more details. */
d297 1
a297 2
				       wincap.has_mwmo_inputavailable ()
				       ? MWMO_INPUTAVAILABLE : 0);
d1542 1
a1542 8
  /* On NT4 we use a filter pattern which allows to use QS_ALLPOSTMESSAGE
     to keep the queue state as unread.  Note that this only works if the
     application itself does not call PeekMessage or GetQueueState the wrong
     way.  But there's no way around it.  On Win2K and later we rather use
     MsgWaitForMultipleObjectsEx(MWMO_INPUTAVAILABLE). */
  if (PeekMessage (&m, (HWND) h, 0,
		   wincap.has_mwmo_inputavailable () ? 0 : UINT_MAX - 1,
		   PM_NOREMOVE))
@


1.161
log
@	* autoload.cc (MsgWaitForMultipleObjectsEx): Define.
	(MsgWaitForMultipleObjects): Remove.
	* select.cc (select_stuff::wait): Use MsgWaitForMultipleObjectsEx with
	QS_ALLPOSTMESSAGE and, if possible, MWMO_INPUTAVAILABLE flags.  Explain
	why.  Fix a potential crash due to a NULL pointer in WAIT_FAILED case.
	(peek_windows): Use filter pattern on NT4.  Explain why.
	* wincap.h (wincaps::has_mwmo_inputavailable): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d638 1
a638 1
      pi->thread = new cygthread (thread_pipe, 0, pi, "select_pipe");
d1143 1
a1143 1
      si->thread = new cygthread (thread_serial, 0,  si, "select_serial");
d1459 1
a1459 1
  si->thread = new cygthread (thread_socket, 0,  si, "select_socket");
d1702 1
a1702 1
  mi->thread = new cygthread (thread_mailslot, 0,  mi, "select_mailslot");
@


1.160
log
@* fhandler.h (fhandler_base::has_ongoing_io): Declare virtual method.
* select.cc (peek_pipe): Reorganize slightly.  Don't attempt to check a handle
if it has ongoing I/O.
(select_pipe_info::select_pipe_info): Delete definition.
(select_pipe_info::~select_pipe_info): Delete definition.
(thread_pipe): Get rid of WFMO call.  Reorganize loop.
(pipe_cleanup): Remove dependence on destructor.
(thread_serial): Reorganize loop.
* select.h (select_pipe_info): Empty this class since it no longer has any
special requirements (for now).
* syscalls.cc (readv): Remove an unneeded debug printf.
@
text
@d290 11
a300 1
	wait_ret = MsgWaitForMultipleObjects (m, w4, FALSE, ms, QS_ALLINPUT);
d309 2
a310 1
	  select_printf ("WaitForMultipleObjects failed");
d1545 8
a1552 1
  if (PeekMessage (&m, (HWND) h, 0, 0, PM_NOREMOVE))
@


1.159
log
@* select.h (select_pipe_info::add_watch_handle): Delete declaration.
* select.cc (select_pipe_info::add_watch_handle): Delete deinition.
(fhandler_pipe::select_read): Delete call to add_watch_handle.
(fhandler_pipe::select_write): Ditto.
(fhandler_pipe::select_except): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d432 3
d437 1
a437 1
  fhandler_base *fh = s->fh;
d439 4
a442 2
  HANDLE h;
  set_handle_or_return_if_not_open (h, s);
a584 17
select_pipe_info::select_pipe_info ()
{
  n = 1;
  w4[0] = CreateEvent (&sec_none_nih, true, false, NULL);
}

select_pipe_info::~select_pipe_info ()
{
  if (thread)
    {
      SetEvent (w4[0]);
      stop_thread = true;
      thread->detach ();
    }
  ForceCloseHandle (w4[0]);
}

a588 1
  bool gotone = false;
d590 1
d592 1
a592 1
  for (;;)
d594 1
a594 10
      select_record *s = pi->start;
      if (pi->n > 1)
	switch (WaitForMultipleObjects (pi->n, pi->w4, false, INFINITE))
	  {
	  case WAIT_OBJECT_0:
	    goto out;
	  default:
	    break;
	  }
      while ((s = s->next))
d598 1
a598 1
	      gotone = true;
d602 2
a603 1
		goto out;
d606 1
a606 7
      /* Paranoid check */
      if (pi->stop_thread)
	{
	  select_printf ("stopping from outer loop");
	  break;
	}
      if (gotone)
d611 2
a613 1
out:
d638 2
a639 1
  if (stuff->device_specific_pipe)
d641 3
a643 1
      delete stuff->device_specific_pipe;
d1100 1
a1100 1
  bool gotone = false;
d1102 5
a1106 10
  for (;;)
    {
      select_record *s = si->start;
      while ((s = s->next))
	if (s->startup == start_thread_serial)
	  {
	    if (peek_serial (s, true))
	      gotone = true;
	  }
      if (si->stop_thread)
d1108 8
a1115 2
	  select_printf ("stopping");
	  break;
a1116 3
      if (gotone)
	break;
    }
@


1.158
log
@* fhandler.h (fhandler_base_overlapped): Temporarily (?) make select_pipe_info
a friend until the fhandler_tty intertangling can be worked out.
* select.cc (select_pipe_info::add_watch_handle): Don't inspect the overlapped
event if we're not waiting for I/O.
(fhandler_tty_common::select_*): Change to standard function.  Don't do kludgy
fhandler_pipe coercion.
@
text
@a596 7
void
select_pipe_info::add_watch_handle (fhandler_pipe *fh)
{
  if (fh->io_pending && fh->get_overlapped () && fh->get_overlapped ()->hEvent)
    w4[n++] = fh->get_overlapped ()->hEvent;
}

a686 1
  ss->device_specific_pipe->add_watch_handle (this);
a703 1
  ss->device_specific_pipe->add_watch_handle (this);
a719 1
  ss->device_specific_pipe->add_watch_handle (this);
@


1.157
log
@* fhandler.cc (fhandler_base::setup_overlapped): Don't set signalled state to
true initially.
(fhandler_base::has_ongoing_io): Delete ill-advised function.
(fhandler_base::read_overlapped): Rely on caller having checked nonblocking
state.  Don't attempt to (incorrectly) check it here.
(fhandler_base::write_overlapped): Remove call to has_ongoing_io.
* select.cc (peek_pipe): Ditto.
* fhandler.h (fhandler_base::has_ongoing_io): Delete declaration.
@
text
@d600 1
a600 1
  if (fh->get_overlapped () && fh->get_overlapped ()->hEvent)
d909 12
a920 1
  return ((fhandler_pipe *) this)->fhandler_pipe::select_read (ss);
d926 11
a936 1
  return ((fhandler_pipe *) this)->fhandler_pipe::select_write (ss);
d942 11
a952 1
  return ((fhandler_pipe *) this)->fhandler_pipe::select_except (ss);
@


1.156
log
@* select.cc (fhandler_fifo::select_read): Fill in device specific record.
(fhandler_fifo::select_write): Ditto.
(fhandler_fifo::select_except): Ditto.
@
text
@a528 2
      else if (fh->has_ongoing_io (true))
	s->write_ready = false;
@


1.155
log
@	* fhandler_console.cc (read): Detect and handle mouse wheel scrolling
	events (for completion of mouse reporting mode 1000) and mouse
	movement events (for additional mouse reporting modes 1002 and 1003).
	Use mouse_aware() as a guard and only condition for mouse
	reporting in order to enforce consistence of read() and select().
	Add focus reports (for additional focus reporting mode 1004).
	(mouse_aware): Enable detection of additional mouse events for select().
	Tune function to precisely match actual reporting criteria.
	Move adjustment of mouse position (by window scroll offset)
	here to avoid duplicate code.
	(char_command): Initialization of enhanced mouse reporting modes.
	Initialization of focus reporting mode.
	* fhandler.h (use_mouse): Change flag (bool->int) to indicate
	additional mouse modes. Add flag to indicate focus reporting.
	(mouse_aware): Move enhanced function into fhandler_console.cc.
	* select.cc (peek_console): Use modified mouse_aware() for more
	general detection of mouse events. Also check for focus reports.
@
text
@d745 3
d761 3
d777 3
@


1.154
log
@* select.cc (peek_console): Always check window size when there is ANY keyboard
activity.
@
text
@d826 3
a828 3
		&& fh->mouse_aware ()
		&& (irec.Event.MouseEvent.dwEventFlags == 0
		    || irec.Event.MouseEvent.dwEventFlags == DOUBLE_CLICK))
@


1.153
log
@	* cygtls.h (struct _local_storage): Add thread storage pointers for
	memory used by socket select functions.  Combine them into a single
	struct select.
	* cygtls.cc: Accommodate above change throughout.
	(_cygtls::init_thread): Drop initalizing of sockevt to
	INVALID_HANDLE_VALUE.
	(_cygtls::fixup_after_fork): Reset sockevt to NULL.
	(_cygtls::remove): Don't use sockevt value to bail out prematurely.
	Set sockevt to NULL.  Free malloced select members.
	* select.h (struct select_socket_info): Drop max_w4 member.
	* select.cc (thread_socket): Use INFINITE timeout value if number of
	objects to wait for is <= MAXIMUM_WAIT_OBJECTS.  Use num_w4 member
	of select_socket_info struct rather than dropped max_w4.
	(init_tls_select_info): New inline function to initialize TLS select
	members.
	(start_thread_socket): Just call init_tls_select_info to initialize TLS
	select members and use them later on.
	(socket_cleanup): Don't free select_socket_info pointer members since
	they are thread local now.
@
text
@d815 1
a824 1
	    fh->send_winch_maybe ();
@


1.152
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d19 1
d1319 4
a1322 1
  DWORD timeout = 64 / (si->max_w4 / MAXIMUM_WAIT_OBJECTS);
d1333 1
a1333 1
	for (int i = 0; i < si->max_w4; i += MAXIMUM_WAIT_OBJECTS)
d1340 2
d1345 1
a1345 2
	      break;
	    case WAIT_TIMEOUT:
d1355 30
d1397 2
a1398 3
  si->ser_num = (LONG *) malloc (MAXIMUM_WAIT_OBJECTS * sizeof (LONG));
  si->w4 = (HANDLE *) malloc (MAXIMUM_WAIT_OBJECTS * sizeof (HANDLE));
  if (!si->ser_num || !si->w4)
d1400 7
a1406 1
  si->max_w4 = MAXIMUM_WAIT_OBJECTS;
a1407 7
  if (_my_tls.locals.select_sockevt != INVALID_HANDLE_VALUE)
    si->w4[0] = _my_tls.locals.select_sockevt;
  else if (!(si->w4[0] = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL)))
    return 1;
  else
    _my_tls.locals.select_sockevt = si->w4[0];
  si->num_w4 = 1;
d1418 1
a1418 1
	if (si->num_w4 >= si->max_w4)
d1421 2
a1422 1
					   (si->max_w4 + MAXIMUM_WAIT_OBJECTS)
d1426 1
a1426 1
	    si->ser_num = nser;
d1428 2
a1429 1
					   (si->max_w4 + MAXIMUM_WAIT_OBJECTS)
d1433 2
a1434 2
	    si->w4 = nw4;
	    si->max_w4 += MAXIMUM_WAIT_OBJECTS;
a1460 4
      if (si->ser_num)
	free (si->ser_num);
      if (si->w4)
	free (si->w4);
@


1.151
log
@* fhandler.cc (fhandler_base::has_ongoing_io): Accept an argument indicating
whether the overlapped event should be tested.
(fhandler_base::read_overlapped): Pass is_overlapped state to has_ongoing_io.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::has_ongoing_io): Accommodate argument change.
* select.cc (peek_pipe): Ditto.
@
text
@d30 1
d72 1
a72 1
  bzero ((caddr_t)(p), sizeof_fd_set ((n)))
d209 1
a209 1
int
d213 17
a229 9
  select_record *s = NULL;
  if (UNIX_FD_ISSET (i, readfds) && (s = cygheap->fdtab.select_read (i, s)) == NULL)
    return 0; /* error */
  if (UNIX_FD_ISSET (i, writefds) && (s = cygheap->fdtab.select_write (i, s)) == NULL)
    return 0; /* error */
  if (UNIX_FD_ISSET (i, exceptfds) && (s = cygheap->fdtab.select_except (i, s)) == NULL)
    return 0; /* error */
  if (s == NULL)
    return 1; /* nothing to do */
d237 6
a242 3
  s->next = start.next;
  start.next = s;
  return 1;
d581 23
a603 6
struct pipeinf
  {
    cygthread *thread;
    bool stop_thread_pipe;
    select_record *start;
  };
d608 1
a608 1
  pipeinf *pi = (pipeinf *) arg;
d615 8
d628 1
a628 1
	    if (pi->stop_thread_pipe)
d635 1
a635 1
      if (pi->stop_thread_pipe)
d653 4
a656 1
  if (stuff->device_specific_pipe)
d658 6
a663 2
      me->h = *((pipeinf *) stuff->device_specific_pipe)->thread;
      return 1;
a664 8
  pipeinf *pi = new pipeinf;
  pi->start = &stuff->start;
  pi->stop_thread_pipe = false;
  pi->thread = new cygthread (thread_pipe, 0, pi, "select_pipe");
  me->h = *pi->thread;
  if (!me->h)
    return 0;
  stuff->device_specific_pipe = (void *) pi;
d671 1
a671 2
  pipeinf *pi = (pipeinf *) stuff->device_specific_pipe;
  if (pi && pi->thread)
d673 1
a673 3
      pi->stop_thread_pipe = true;
      pi->thread->detach ();
      delete pi;
d690 1
a690 1
fhandler_pipe::select_read (select_record *s)
d692 6
a697 2
  if (!s)
    s = new select_record;
d708 1
a708 1
fhandler_pipe::select_write (select_record *s)
d710 5
a714 2
  if (!s)
    s = new select_record;
d725 1
a725 1
fhandler_pipe::select_except (select_record *s)
d727 5
a731 2
  if (!s)
    s = new select_record;
d742 1
a742 1
fhandler_fifo::select_read (select_record *s)
d744 1
a744 2
  if (!s)
    s = new select_record;
d755 1
a755 1
fhandler_fifo::select_write (select_record *s)
d757 1
a757 2
  if (!s)
    s = new select_record;
d768 1
a768 1
fhandler_fifo::select_except (select_record *s)
d770 1
a770 2
  if (!s)
    s = new select_record;
d847 1
a847 1
fhandler_console::select_read (select_record *s)
d849 2
a850 1
  if (!s)
a851 1
      s = new select_record;
d865 1
a865 1
fhandler_console::select_write (select_record *s)
d867 2
a868 1
  if (!s)
a869 1
      s = new select_record;
d882 1
a882 1
fhandler_console::select_except (select_record *s)
d884 2
a885 1
  if (!s)
a886 1
      s = new select_record;
d899 1
a899 1
fhandler_tty_common::select_read (select_record *s)
d901 1
a901 1
  return ((fhandler_pipe *) this)->fhandler_pipe::select_read (s);
d905 1
a905 1
fhandler_tty_common::select_write (select_record *s)
d907 1
a907 1
  return ((fhandler_pipe *) this)->fhandler_pipe::select_write (s);
d911 1
a911 1
fhandler_tty_common::select_except (select_record *s)
d913 1
a913 1
  return ((fhandler_pipe *) this)->fhandler_pipe::select_except (s);
d926 1
a926 1
fhandler_tty_slave::select_read (select_record *s)
d928 1
a928 2
  if (!s)
    s = new select_record;
d940 1
a940 1
fhandler_dev_null::select_read (select_record *s)
d942 2
a943 1
  if (!s)
a944 1
      s = new select_record;
d955 1
a955 1
fhandler_dev_null::select_write (select_record *s)
d957 2
a958 1
  if (!s)
a959 1
      s = new select_record;
d970 1
a970 1
fhandler_dev_null::select_except (select_record *s)
d972 2
a973 1
  if (!s)
a974 1
      s = new select_record;
a985 7
struct serialinf
  {
    cygthread *thread;
    bool stop_thread_serial;
    select_record *start;
  };

d1092 1
a1092 1
  serialinf *si = (serialinf *) arg;
d1104 1
a1104 1
      if (si->stop_thread_serial)
d1121 2
d1124 6
a1129 2
      me->h = *((serialinf *) stuff->device_specific_serial)->thread;
      return 1;
a1130 6
  serialinf *si = new serialinf;
  si->start = &stuff->start;
  si->stop_thread_serial = false;
  si->thread = new cygthread (thread_serial, 0,  si, "select_serial");
  me->h = *si->thread;
  stuff->device_specific_serial = (void *) si;
d1137 1
a1137 1
  serialinf *si = (serialinf *) stuff->device_specific_serial;
d1140 1
a1140 1
      si->stop_thread_serial = true;
d1148 1
a1148 1
fhandler_serial::select_read (select_record *s)
d1150 2
a1151 1
  if (!s)
a1152 1
      s = new select_record;
d1164 1
a1164 1
fhandler_serial::select_write (select_record *s)
d1166 2
a1167 1
  if (!s)
a1168 1
      s = new select_record;
d1180 1
a1180 1
fhandler_serial::select_except (select_record *s)
d1182 2
a1183 1
  if (!s)
a1184 1
      s = new select_record;
d1199 10
a1208 3
  select_record me (this);
  me.fd = fd;
  while (!avail)
d1210 4
a1213 2
      select_read (&me);
      avail = me.read_ready ?: me.peek (&me, false);
d1215 6
a1220 6
      if (fd >= 0 && cygheap->fdtab.not_open (fd))
	{
	  set_sig_errno (EBADF);
	  avail = false;
	  break;
	}
d1222 6
a1227 6
      if (howlong != INFINITE)
	{
	  if (!avail)
	    set_sig_errno (EAGAIN);
	  break;
	}
d1229 7
a1235 6
      if (WaitForSingleObject (signal_arrived, avail ? 0 : 10) == WAIT_OBJECT_0)
	{
	  debug_printf ("interrupted");
	  set_sig_errno (EINTR);
	  avail = false;
	  break;
d1239 2
a1240 1
  select_printf ("read_ready %d, avail %d", me.read_ready, avail);
d1245 1
a1245 1
fhandler_base::select_read (select_record *s)
d1247 2
a1248 1
  if (!s)
a1249 1
      s = new select_record;
d1260 1
a1260 1
fhandler_base::select_write (select_record *s)
d1262 2
a1263 1
  if (!s)
a1264 1
      s = new select_record;
d1275 1
a1275 1
fhandler_base::select_except (select_record *s)
d1277 2
a1278 1
  if (!s)
a1279 1
      s = new select_record;
a1313 10
struct socketinf
  {
    cygthread *thread;
    int max_w4;
    int num_w4;
    LONG *ser_num;
    HANDLE *w4;
    select_record *start;
  };

d1317 1
a1317 1
  socketinf *si = (socketinf *) arg;
d1353 1
a1353 1
  socketinf *si;
d1355 1
a1355 1
  if ((si = (socketinf *) stuff->device_specific_socket))
d1361 1
a1361 1
  si = new socketinf;
d1406 1
a1406 1
  stuff->device_specific_socket = (void *) si;
d1417 1
a1417 1
  socketinf *si = (socketinf *) stuff->device_specific_socket;
d1436 1
a1436 1
fhandler_socket::select_read (select_record *s)
d1438 2
a1439 1
  if (!s)
a1440 1
      s = new select_record;
d1452 1
a1452 1
fhandler_socket::select_write (select_record *s)
d1454 2
a1455 1
  if (!s)
a1456 1
      s = new select_record;
d1473 1
a1473 1
fhandler_socket::select_except (select_record *s)
d1475 2
a1476 1
  if (!s)
a1477 1
      s = new select_record;
d1518 1
a1518 1
fhandler_windows::select_read (select_record *s)
d1520 2
a1521 1
  if (!s)
a1522 1
      s = new select_record;
d1535 1
a1535 1
fhandler_windows::select_write (select_record *s)
d1537 2
a1538 1
  if (!s)
a1539 1
      s = new select_record;
d1552 1
a1552 1
fhandler_windows::select_except (select_record *s)
d1554 2
a1555 1
  if (!s)
a1556 1
      s = new select_record;
a1600 7
struct mailslotinf
  {
    cygthread *thread;
    bool stop_thread_mailslot;
    select_record *start;
  };

d1604 1
a1604 1
  mailslotinf *mi = (mailslotinf *) arg;
d1616 1
a1616 1
	    if (mi->stop_thread_mailslot)
d1623 1
a1623 1
      if (mi->stop_thread_mailslot)
d1643 1
a1643 1
      me->h = *((mailslotinf *) stuff->device_specific_mailslot)->thread;
d1646 1
a1646 1
  mailslotinf *mi = new mailslotinf;
d1648 1
a1648 1
  mi->stop_thread_mailslot = false;
d1653 1
a1653 1
  stuff->device_specific_mailslot = (void *) mi;
d1660 1
a1660 1
  mailslotinf *mi = (mailslotinf *) stuff->device_specific_mailslot;
d1663 1
a1663 1
      mi->stop_thread_mailslot = true;
d1671 1
a1671 1
fhandler_mailslot::select_read (select_record *s)
d1673 1
a1673 2
  if (!s)
    s = new select_record;
@


1.150
log
@* select.cc (peek_pipe): Turn on (temporarily?) the experimental code which
tries to determine when a pipe is writable.
@
text
@d516 1
a516 1
      else if (fh->has_ongoing_io ())
@


1.149
log
@* select.cc (peek_pipe): Use has_ongoing_io() to determine if the pipe is ready
for writing rather than performing brute-force checks.
@
text
@a519 4
#if 0
/* FIXME: This code is not quite correct.  There's no better solution
   so far but to make simple assumptions based on WriteQuotaAvailable. */

a560 3
#else
	  gotone += s->write_ready = true;
#endif
@


1.148
log
@* fhandler.h (fhandler_base::has_ongoing_io): Declare new function.
* fhandler.cc (fhandler_base::has_ongoing_io): Define new function.
(fhandler_base::read_overlapped): Use has_ongoing_io to avoid writing when
handle has not completed last I/O.
(fhandler_base::write_overlapped): Ditto.
* select.cc (peek_pipe): Be more careful about accessing hEvent field from
get_overlapped().
@
text
@d516 1
a516 3
      else if (fh->get_overlapped () && fh->get_overlapped ()->hEvent
	       && WaitForSingleObject (fh->get_overlapped ()->hEvent, 0)
	           != WAIT_OBJECT_0)
@


1.147
log
@* gendef (cleanup): Rename from 'nocr'.  Remove comments and trailing spaces.
* cygwin.din: Add long-needed comment describing what dll_crt0__FP11per_process
demangles to.
@
text
@d516 1
a516 1
      else if (fh->get_overlapped ()->hEvent
@


1.146
log
@* dtable.cc (dtable::select_read): Add ability to override fh.
* fhandler.h (fhandler_fifo::select_read): Declare new function.
(fhandler_fifo::select_write): Ditto.
(fhandler_fifo::select_except): Ditto.
* select.cc (peek_pipe): Treat certain classes of pipe errors as "no data".
(fhandler_fifo::select_read): Define new function.
(fhandler_fifo::select_write): Ditto.
(fhandler_fifo::select_except): Ditto.
* shared_info.h (CURR_SHARED_MAGIC): Update.
@
text
@d516 4
@


1.145
log
@* select.cc (peek_serial): Add hack to allow proper operation with com0com
driver.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
d468 13
a480 4
    {
      select_printf ("%s, PeekNamedPipe failed, %E", fh->get_name ());
      n = -1;
    }
d703 42
@


1.144
log
@* localtime.cc (increment_overflow): Mark as non-inline to prevent compiler
from complaining about the very thing we're trying to test.
* ntea.cc (read_ea): Reorganize to avoid a new compiler warning/error.
* sched.cc (sched_rr_get_interval): Ditto.
* select.cc (peek_serial): Ditto.
* libc/rexec.cc (ruserpass): Ditto.
* posix_ipc.cc (ipc_names): Make static to avoid a compiler warning
(and it's the right thing to do anyway).
@
text
@d931 4
@


1.143
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d924 1
a924 1
  if (s->read_selected && s->read_ready || (s->write_selected && s->write_ready))
@


1.142
log
@* cygwin.din (_getutline): Remove.
* lib/bsdlib.cc (login): Make argument const as per linux.
(logout): Ditto.
* syscalls.cc (getutid): Ditto.
(getutline): Ditto.
(pututline): Ditto.
(getutxent): Add comment mentioning non-thread-safety.
(getutxid): Ditto.
(getutxline): Ditto.
(pututxline): Ditto.
* sys/utmp.h: Declare arguments to various functions as const as per linux.
Remove bogus _getutline definition.
@
text
@d509 1
a509 1
#if 1
d534 1
a534 1
	  else if (fpli.WriteQuotaAvailable = (fpli.OutboundQuota - fpli.ReadDataAvailable))
@


1.141
log
@	* select.cc (peek_pipe): Temporarily revert patch from 2008-05-30.
@
text
@d509 1
a509 1
#if 0
d534 1
a534 1
	  else if (fpli.WriteQuotaAvailable)
@


1.140
log
@* select.cc (peek_pipe): Semi-reinstate pipe NT-special write detection.
@
text
@d509 4
a541 4
#if 0
/* FIXME: This code is not quite correct.  There's no better solution
   so far but to make simple assumptions based on WriteQuotaAvailable. */

d554 2
@


1.139
log
@Remove unneeded header files from source files throughout.
@
text
@d19 1
d298 1
a298 1
      /* Some types of object (e.g., consoles) wake up on "inappropriate" events
a508 4
#if 0
/* FIXME: This code is not quite correct.  There's no better solution
   so far but to always treat the write side of the pipe as writable. */

d519 1
a519 2
		 pipe is writable.  This could happen on Win9x, because
		 NtQueryInformationFile is not available, or if we somehow
d526 5
a530 5
	  /* Ensure that enough space is available for atomic writes,
	     as required by POSIX.  Subsequent writes with size > PIPE_BUF
	     can still block, but most (all?) UNIX variants seem to work
	     this way (e.g., BSD, Linux, Solaris).  */
	  else if (fpli.WriteQuotaAvailable >= PIPE_BUF)
d538 4
a553 2
#else
	  gotone += s->write_ready = true;
@


1.138
log
@	* Fix copyright dates.
@
text
@a17 1
#include <sys/socket.h>
a18 1
#include <sys/time.h>
a22 2
#include <unistd.h>
#include <limits.h>
a32 2
#include "tty.h"
#include "ntdll.h"
a33 1
#include <asm/byteorder.h>
@


1.137
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.136
log
@update copyright
@
text
@d163 1
a163 1
  sigset_t oldset = myself->getsigmask ();
d174 1
a174 1
    set_signal_mask (*set, myself->getsigmask ());
d178 1
a178 1
    set_signal_mask (oldset, myself->getsigmask ());
@


1.135
log
@Preliminary change to make fifos/pipes interruptible and fifos reliable.
* dtable.cc (dtable::find_fifo): Eliminate definition.
* dtable.h (dtable::find_fifo): Ditto for declaration.
* fhandler.cc (fhandler_base::raw_read): Remove pipe-specific stuff.
(fhandler_base::fhandler_base): Ditto.
(fhandler_base::close): Handle overlapped I/O structure if appropriate.
(fhandler_base::dup): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::setup_overlapped): Define new function.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::get_overlapped): Declare new function.
(fhandler_base::setup_overlapped): Ditto.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_guard): Eliminate.
(fhandler_pipe::*): Rework to eliminate most Win9x related cruft, removing many
variables and defining a new overlapped capability.
(fhandler_fifo::*): Ditto.
(fifo_state): Declare new enum.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove old Win9x stuff.
Initialize overlapped handle to NULL.
(fhandler_fifo::set_use): Eliminate.
(fhandler_fifo::open_nonserver): Define.
(fhandler_fifo::open): Rework to use named pipes and overlapped I/O.
(fhandler_fifo::wait): Define new function to wait for named pipe connection.
(fhandler_fifo::read): Rework to use wait() and new overlapped I/O
functionality.
(fhandler_fifo::write): Ditto.
(fhandler_fifo::dup): Eliminate.
* pinfo.cc (commune_process): Remove fifo handling.
(_pinfo::commune_request): Ditto.
* pinfo.h (picom): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Remove Win9x stuff.  Initialize
overlapped handle to NULL.
(fhandler_pipe::open): Eliminate Win9x stuff.
(fhandler_pipe::set_close_on_exec): Eliminate.
(read_pipe): Eliminate.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::fixup_after_exec): Ditto.
(fhandler_pipe::fixup_in_child): Ditto.
(fhandler_pipe::read): Rework to use overlapped I/O.
(fhandler_pipe::write): New function using overlapped I/O.
(fhandler_pipe::dup): Rework to eliminate Win9x stuff.
(fhandler_pipe::create_selectable): Rework to eliminate Win9x and use
overlapped I/O.
* select.cc (peek_pipe): Rework to eliminate Win9x stuff and use overlapped
I/O.
(fhandler_base::ready_for_read): Ditto.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
@


1.134
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@a431 9
  /* pipes require a guard mutex to guard against the situation where multiple
     readers are attempting to read from the same pipe.  In this scenario, it
     is possible for PeekNamedPipe to report available data to two readers but
     only one will actually get the data.  This will result in the other reader
     entering fhandler_base::raw_read and blocking indefinitely in an interruptible
     state.  This causes things like "make -j2" to hang.  So, for the non-select case
     we use the pipe mutex, if it is available. */
  HANDLE guard_mutex = from_select ? NULL : fh->get_guard ();

a477 20
  else if (!n || !guard_mutex)
    /* no guard mutex or nothing to read from the pipe. */;
  else if (WaitForSingleObject (guard_mutex, 0) != WAIT_OBJECT_0)
    {
      select_printf ("%s, couldn't get mutex %p, %E", fh->get_name (),
		     guard_mutex);
      n = 0;
    }
  else
    {
      /* Now that we have the mutex, make sure that no one else has snuck
	 in and grabbed the data that we originally saw. */
      if (!PeekNamedPipe (h, NULL, 0, NULL, (DWORD *) &n, NULL))
	{
	  select_printf ("%s, PeekNamedPipe failed, %E", fh->get_name ());
	  n = -1;
	}
      if (n <= 0)
	ReleaseMutex (guard_mutex);	/* Oops.  We lost the race.  */
    }
a480 1
      fh->set_eof ();		/* Flag that other end of pipe is gone */
a518 4
	  /* We don't worry about the guard mutex, because that only applies
	     when from_select is false, and peek_pipe is never called that
	     way for writes.  */

d654 1
a654 1
  else if (!get_guard ())
a655 17
  else
    {
      const HANDLE w4[2] = {get_guard (), signal_arrived};
      switch (WaitForMultipleObjects (2, w4, 0, INFINITE))
	{
	case WAIT_OBJECT_0:
	  res = 1;
	  break;
	case WAIT_OBJECT_0 + 1:
	  set_sig_errno (EINTR);
	  res = 0;
	  break;
	default:
	  __seterrno ();
	  res = 0;
	}
    }
a1153 3
  if (get_guard () && !avail && me.read_ready)
    ReleaseMutex (get_guard ());

@


1.133
log
@	* select.cc (struct socketinf): Convert ser_num and w4 to dynamically
	allocated arrays.  Add max_w4 member to keep track.
	(thread_socket): Make timeout depending on number of sockets to wait
	for.  Loop WFMO over all sockets.
	(start_thread_socket): Handle any number of sockets.  Fix typo.  Don't
	close socket event in out of memory condition.
	(socket_cleanup): Free ser_num and w4.
@
text
@a5 3
   Written by Christopher Faylor of Cygnus Solutions
   cgf@@cygnus.com

d1316 1
a1316 1
	        goto out;
d1405 1
a1405 1
        free (si->ser_num);
d1407 1
a1407 1
        free (si->w4);
@


1.132
log
@	* fhandler.h (struct wsa_event): Define here.
	(class fhandler_socket): Make wsock_evt private again.
	(fhandler_socket::wsock_event): New read accessor for wsock_evt.
	(fhandler_socket::serial_number): New read accessor to get the
	socket's serial number.
	(fhandler_socket::ready_for_read): Just return true.
	* fhandler_socket.cc (struct wsa_event): Move definition to fhandler.h.
	* select.cc (struct socketinf): Add serial number vector.
	(start_thread_socket): Identify duplicate sockets by their serial
	number, not (wrongly) by their wsock_evt.
@
text
@d1288 1
d1290 2
a1291 2
    LONG ser_num[MAXIMUM_WAIT_OBJECTS];
    HANDLE w4[MAXIMUM_WAIT_OBJECTS];
d1299 1
d1310 4
a1313 2
        {
	  switch (WaitForMultipleObjects (si->num_w4, si->w4, FALSE, 50))
a1314 1
	    case WAIT_OBJECT_0:
d1317 4
a1324 1
	}
d1343 5
d1362 1
a1362 1
	const LONG ser_num = ((fhandler_socket *) me->fh)->serial_number ();
d1366 1
a1366 1
	if (si->num_w4 < MAXIMUM_WAIT_OBJECTS)
d1368 13
a1380 2
	    si->ser_num[si->num_w4] = ser_num;
	    si->w4[si->num_w4++] = ((fhandler_socket *) me->fh)->wsock_event ();
d1382 2
a1383 2
	else /* for now */
	  goto err;
a1392 4

err:
  CloseHandle (si->w4[0]);
  return 0;
d1407 4
@


1.131
log
@	* fhandler_socket.cc: Revert misguided attempt to handle FD_CLOSE error
	conditions in evaluate_events.
	(search_wsa_event_slot): Move wrongly placed memset in
	fhandler_socket::init_events here.
	(fhandler_socket::init_events): Initially set FD_WRITE event for
	connectionless sockets.
	* poll.cc (poll): Don't add sockets always to except_fds since select
	is now supposed to do it right.
	* select.cc (set_bits): Set connection state correctly for failed
	af_local_connect on local sockets.  Remove socket special handling
	for except_selected descriptors.
	(peek_socket): Try to set the read/write/exception bits actually
	correctly.
@
text
@d1289 1
d1348 4
a1351 2
	HANDLE evt = ((fhandler_socket *) me->fh)->wsock_evt;
	/* No event/socket should show up multiple times. */
d1353 1
a1353 1
	  if (si->w4[i] == evt)
d1356 4
a1359 1
	  si->w4[si->num_w4++] = evt;
@


1.130
log
@	* fhandler.h (class fhandler_socket): Remove prot_info_ptr.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::need_fixup_before): Remove.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Drop
	initializing prot_info_ptr.  Remove unused code.
	(fhandler_socket::~fhandler_socket): Drop free'ing prot_info_ptr.
	(struct wsa_event): Rename connect_errorcode to errorcode.
	(fhandler_socket::evaluate_events): Handle FD_CLOSE error condition
	as FD_CONNECT error condition, except, never reset an FD_CLOSE error
	condition.  Always set FD_WRITE after successfully recorded FD_CONNECT.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_fork): Revert to using handle duplication.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::dup): Revert to using handle duplication.
	(fhandler_socket::send_internal): Only call wait_for_events in case
	of WSAEWOULDBLOCK condition.
	(fhandler_socket::set_close_on_exec): Call
	fhandler_base::set_close_on_exec.
	* net.cc (fdsock): Just set socket to inheritable on non-NT.  Don't
	call inc_need_fixup_before.
	* select.cc (peek_socket): Don't set except_ready on every FD_CLOSE,
	just on error.
@
text
@d367 8
a374 3
	      && sock->af_local_connect () && me->read_selected)
	    UNIX_FD_SET (me->fd, readfds);
	  sock->connect_state (connected);
d378 1
a378 1
  if ((me->except_selected || me->except_on_write) && me->except_ready)
d380 1
a380 8
      if (me->except_on_write) /* Only on sockets */
	{
	  UNIX_FD_SET (me->fd, writefds);
	  if ((sock = me->fh->is_socket ()))
	    sock->connect_state (connect_failed);
	}
      if (me->except_selected)
	UNIX_FD_SET (me->fd, exceptfds);
d1265 5
a1269 4
  long evt_mask = (FD_CLOSE
		   | (me->read_selected ? (FD_READ | FD_ACCEPT) : 0)
		   | (me->write_selected ? (FD_WRITE | FD_CONNECT) : 0)
		   | (me->except_selected ? (FD_OOB | FD_CONNECT) : 0));
d1272 1
a1272 1
    me->read_ready |= !!(events & (FD_READ | FD_ACCEPT | FD_CLOSE));
d1274 1
a1274 6
    {
      if ((events & FD_CONNECT) && !ret)
	me->write_ready = true;
      else
	me->write_ready |= !!(events & (FD_WRITE | FD_CLOSE));
    }
d1276 1
a1276 1
    me->except_ready |= ret || !!(events & FD_OOB);
d1278 2
@


1.129
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@d1282 1
a1282 1
    me->except_ready |= ret || !!(events & (FD_OOB | FD_CLOSE));
@


1.128
log
@update copyright
@
text
@a32 1
#include "select.h"
a1261 8
struct socketinf
  {
    cygthread *thread;
    winsock_fd_set readfds, writefds, exceptfds;
    SOCKET exitsock;
    select_record *start;
  };

d1265 10
a1274 32
  winsock_fd_set ws_readfds, ws_writefds, ws_exceptfds;
  struct timeval tv = {0, 0};
  WINSOCK_FD_ZERO (&ws_readfds);
  WINSOCK_FD_ZERO (&ws_writefds);
  WINSOCK_FD_ZERO (&ws_exceptfds);

  HANDLE h;
  set_handle_or_return_if_not_open (h, me);
  select_printf ("considering handle %p", h);

  if (me->read_selected && !me->read_ready)
    {
      select_printf ("adding read fd_set %s, fd %d", me->fh->get_name (),
		     me->fd);
      WINSOCK_FD_SET (h, &ws_readfds);
    }
  if (me->write_selected && !me->write_ready)
    {
      select_printf ("adding write fd_set %s, fd %d", me->fh->get_name (),
		     me->fd);
      WINSOCK_FD_SET (h, &ws_writefds);
    }
  if ((me->except_selected || me->except_on_write) && !me->except_ready)
    {
      select_printf ("adding except fd_set %s, fd %d", me->fh->get_name (),
		     me->fd);
      WINSOCK_FD_SET (h, &ws_exceptfds);
    }
  int r;
  if ((me->read_selected && !me->read_ready)
      || (me->write_selected && !me->write_ready)
      || ((me->except_selected || me->except_on_write) && !me->except_ready))
d1276 1
a1276 11
      r = WINSOCK_SELECT (0, &ws_readfds, &ws_writefds, &ws_exceptfds, &tv);
      select_printf ("WINSOCK_SELECT returned %d", r);
      if (r == -1)
	{
	  select_printf ("error %d", WSAGetLastError ());
	  set_winsock_errno ();
	  return 0;
	}
      if (WINSOCK_FD_ISSET (h, &ws_readfds))
	me->read_ready = true;
      if (WINSOCK_FD_ISSET (h, &ws_writefds))
d1278 2
a1279 2
      if (WINSOCK_FD_ISSET (h, &ws_exceptfds))
	me->except_ready = true;
d1281 3
d1289 8
d1301 1
d1303 10
a1312 12
  select_printf ("stuff_start %p", &si->start);
  int r = WINSOCK_SELECT (0, &si->readfds, &si->writefds, &si->exceptfds, NULL);
  select_printf ("Win32 select returned %d", r);
  if (r == -1)
    select_printf ("error %d", WSAGetLastError ());
  select_record *s = si->start;
  while ((s = s->next))
    if (s->startup == start_thread_socket)
	{
	  HANDLE h = s->fh->get_handle ();
	  select_printf ("s %p, testing fd %d (%s)", s, s->fd, s->fh->get_name ());
	  if (WINSOCK_FD_ISSET (h, &si->readfds))
d1314 6
a1319 12
	      select_printf ("read_ready");
	      s->read_ready = true;
	    }
	  if (WINSOCK_FD_ISSET (h, &si->writefds))
	    {
	      select_printf ("write_ready");
	      s->write_ready = true;
	    }
	  if (WINSOCK_FD_ISSET (h, &si->exceptfds))
	    {
	      select_printf ("except_ready");
	      s->except_ready = true;
d1322 3
a1324 3

  if (WINSOCK_FD_ISSET (si->exitsock, &si->readfds))
    select_printf ("saw exitsock read");
a1339 3
  WINSOCK_FD_ZERO (&si->readfds);
  WINSOCK_FD_ZERO (&si->writefds);
  WINSOCK_FD_ZERO (&si->exceptfds);
d1341 7
d1351 11
a1361 17
	HANDLE h = s->fh->get_handle ();
	select_printf ("Handle %p", h);
	if (s->read_selected && !s->read_ready)
	  {
	    WINSOCK_FD_SET (h, &si->readfds);
	    select_printf ("Added to readfds");
	  }
	if (s->write_selected && !s->write_ready)
	  {
	    WINSOCK_FD_SET (h, &si->writefds);
	    select_printf ("Added to writefds");
	  }
	if ((s->except_selected || s->except_on_write) && !s->except_ready)
	  {
	    WINSOCK_FD_SET (h, &si->exceptfds);
	    select_printf ("Added to exceptfds");
	  }
a1362 37

  if (_my_tls.locals.exitsock != INVALID_SOCKET)
    si->exitsock = _my_tls.locals.exitsock;
  else
    {
      si->exitsock = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);
      if (si->exitsock == INVALID_SOCKET)
	{
	  set_winsock_errno ();
	  select_printf ("cannot create socket, %E");
	  return 0;
	}
      int sin_len = sizeof (_my_tls.locals.exitsock_sin);
      memset (&_my_tls.locals.exitsock_sin, 0, sin_len);
      _my_tls.locals.exitsock_sin.sin_family = AF_INET;
      _my_tls.locals.exitsock_sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (bind (si->exitsock, (struct sockaddr *) &_my_tls.locals.exitsock_sin, sin_len) < 0)
	{
	  select_printf ("cannot bind socket %p, %E", si->exitsock);
	  goto err;
	}

      if (getsockname (si->exitsock, (struct sockaddr *) &_my_tls.locals.exitsock_sin, &sin_len) < 0)
	{
	  select_printf ("getsockname error");
	  goto err;
	}
      if (wincap.has_set_handle_information ())
	SetHandleInformation ((HANDLE) si->exitsock, HANDLE_FLAG_INHERIT, 0);
      /* else
	   too bad? */
      select_printf ("opened new socket %p", si->exitsock);
      _my_tls.locals.exitsock = si->exitsock;
    }

  select_printf ("exitsock %p", si->exitsock);
  WINSOCK_FD_SET ((HANDLE) si->exitsock, &si->readfds);
d1371 1
a1371 2
  set_winsock_errno ();
  closesocket (si->exitsock);
d1382 1
a1382 5
      char buf[] = "";
      int res = sendto (_my_tls.locals.exitsock, buf, 1, 0,
			(sockaddr *) &_my_tls.locals.exitsock_sin,
			sizeof (_my_tls.locals.exitsock_sin));
      select_printf ("sent a byte to exitsock %p, res %d", _my_tls.locals.exitsock, res);
d1385 1
a1385 4
      /* empty the socket */
      select_printf ("reading a byte from exitsock %p", si->exitsock);
      res = recv (si->exitsock, buf, 1, 0);
      select_printf ("recv returned %d", res);
@


1.128.2.1
log
@	* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and
	use either main sigmask or current thread sigmask.
	(set_process_mask): Ditto.
	(sighold): Ditto.
	(sigrelse): Ditto.
	(sigset): Ditto.
	(set_process_mask_delta): Ditto.
	(_cygtls::call_signal_handler): Ditto.
	* fhandler_process.cc (format_process_status): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* pinfo.h (class pinfo): Ditto.
	* select.cc (pselect): Ditto.
	* signal.cc (sigprocmask): Ditto.
	(abort): Ditto.
	(sigpause): Ditto.
	(sigsend): Ditto.
	(wait_sig): Ditto.
	* sigproc.cc (sig_send): Ditto.
	(pending_signals::add): Ditto.
	(wait_sig): Ditto.
	* thread.h (pthread::parent_tls): New member.
	* thread.cc (pthread::pthread): Record parent_tls here.
	(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d167 1
a167 1
  sigset_t oldset = _my_tls.sigmask;
d178 1
a178 1
    set_signal_mask (*set, _my_tls.sigmask);
d182 1
a182 1
    set_signal_mask (oldset, _my_tls.sigmask);
@


1.127
log
@* ioctl.cc (ioctl): Accommodate change in reported pty master device number.
* select.cc (peek_pipe): Ditto.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
@


1.127.2.1
log
@	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.
@
text
@d1263 8
d1274 32
a1305 10
  fhandler_socket *fh = (fhandler_socket *) me->fh;
  long events;
  long evt_mask = (FD_CLOSE
		   | (me->read_selected ? (FD_READ | FD_ACCEPT) : 0)
		   | (me->write_selected ? (FD_WRITE | FD_CONNECT) : 0)
		   | (me->except_selected ? (FD_OOB | FD_CONNECT) : 0));
  int ret = fh->evaluate_events (evt_mask, events, false);
  if (me->read_selected)
    me->read_ready |= !!(events & (FD_READ | FD_ACCEPT | FD_CLOSE));
  if (me->write_selected)
d1307 11
a1317 1
      if ((events & FD_CONNECT) && !ret)
d1319 2
a1320 2
      else
	me->write_ready |= !!(events & (FD_WRITE | FD_CLOSE));
a1321 3
  if (me->except_selected)
    me->except_ready |= ret || !!(events & (FD_OOB | FD_CLOSE));

a1326 8
struct socketinf
  {
    cygthread *thread;
    int num_w4;
    HANDLE w4[MAXIMUM_WAIT_OBJECTS];
    select_record *start;
  };

a1330 1
  bool event = false;
d1332 22
a1353 10
  select_printf ("stuff_start %p", si->start);
  while (!event)
    {
      for (select_record *s = si->start; (s = s->next); )
	if (s->startup == start_thread_socket)
	  if (peek_socket (s, false))
	    event = true;
      if (!event)
        {
	  switch (WaitForMultipleObjects (si->num_w4, si->w4, FALSE, 50))
d1355 2
a1356 6
	    case WAIT_OBJECT_0:
	    case WAIT_FAILED:
	      goto out;
	    case WAIT_TIMEOUT:
	    default:
	      break;
d1359 3
a1361 3
    }
out:
  select_printf ("leaving thread_socket");
d1377 3
a1380 7
  if (_my_tls.locals.select_sockevt != INVALID_HANDLE_VALUE)
    si->w4[0] = _my_tls.locals.select_sockevt;
  else if (!(si->w4[0] = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL)))
    return 1;
  else
    _my_tls.locals.select_sockevt = si->w4[0];
  si->num_w4 = 1;
d1384 43
a1426 8
	HANDLE evt = ((fhandler_socket *) me->fh)->wsock_evt;
	/* No event/socket should show up multiple times. */
	for (int i = 1; i < si->num_w4; ++i)
	  if (si->w4[i] == evt)
	    goto continue_outer_loop;
	if (si->num_w4 < MAXIMUM_WAIT_OBJECTS)
	  si->w4[si->num_w4++] = evt;
	else /* for now */
d1428 11
a1438 3
      continue_outer_loop:
	;
      }
d1447 2
a1448 1
  CloseHandle (si->w4[0]);
d1459 5
a1463 1
      SetEvent (si->w4[0]);
d1466 4
a1469 1
      ResetEvent (si->w4[0]);
@


1.127.2.2
log
@	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d33 1
@


1.126
log
@* select.cc (start_thread_socket): Delay setting thread local exitsock until we
know it's correct.  Return correct value on error.
@
text
@d460 1
a460 1
      switch (fh->get_device ())
d462 1
a462 2
	case FH_PTYM:
	case FH_TTYM:
@


1.125
log
@* select.cc (start_thread_socket): Clean up exitsock in case of error.  Use
si->exitcode consistently.
@
text
@d1408 1
a1408 1
      si->exitsock = _my_tls.locals.exitsock = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);
d1413 1
a1413 1
	  return -1;
d1435 1
d1450 1
a1450 2
  si->exitsock = INVALID_SOCKET;
  return -1;
@


1.124
log
@check in missing file
@
text
@d1409 1
a1409 1
      if (_my_tls.locals.exitsock == INVALID_SOCKET)
d1434 1
a1434 1
      select_printf ("opened new socket %p", _my_tls.locals.exitsock);
d1449 1
@


1.123
log
@	* select.cc (thread_pipe): Raise sleep time only every 8th iteration.
	(thread_mailslot): Ditto.
@
text
@d651 1
a651 1
        ++sleep_time;
d693 4
a696 2
  if (howlong)
    res = true;
d698 16
a713 4
    res = fhandler_base::ready_for_read (fd, howlong);

  if (res)
    get_guard ();
d1181 1
a1181 1
  int avail = 0;
d1192 1
a1192 1
	  avail = 0;
d1207 1
a1207 1
	  avail = 0;
d1680 1
a1680 1
        ++sleep_time;
@


1.122
log
@	* select.cc (thread_pipe): Raise sleep time dynamically to speed up
	select on pipes when copying lots of data.
	(thread_mailslot): Ditto for mailslots.
@
text
@d649 2
a650 2
      Sleep (sleep_time >> 1);
      if (sleep_time < 20)
d1664 2
a1665 2
      Sleep (sleep_time >> 1);
      if (sleep_time < 20)
@


1.121
log
@* hires.h (hires_ms::initime_ms): Delete.
(hires_ms::initime_us): Just define as LONGLONG.
(hires_ms::uptime): New function.
* select.cc (select_stuff::wait): Use gtod for timing to attempt to avoid
windows 32 bit wraparound.
* times.cc (systime): New function.
(times): Replace GetTickCount with gtod.uptime.
(hires_us::prime): Use systime() to calculate system time rather than calling
GetSystemTimeAsFileTime directly.
(hires_ms::prime): Ditto.  Eliminate initime_ms.
(hires_ms::usecs): Try harder to detect wraparound.
* fhandler_proc.cc (format_proc_partitions): Set drive_size to zero to avoid a
compiler warning.
@
text
@d625 1
d649 3
a651 1
      Sleep (10);
d1640 1
d1664 3
a1666 1
      Sleep (10);
@


1.120
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d279 1
a279 1
  DWORD start_time = GetTickCount ();	/* Record the current time for later use. */
d333 1
a333 1
      DWORD now = GetTickCount ();
@


1.119
log
@	* autoload.cc: Never load wsock32.dll. Load all wsock32 function
	from ws2_32.  Rearrange symbol order accordingly.  None of the ws2_32
	functions is optional right now.
	(wsadata): Move from net.cc here.  Define NO_COPY.
	(wsock_init): Drop unused symbols ws2_32_handle and wsock32_handle.
	(load_wsock32): Remove.
	(WSACleanup): Remove.
	* fhandler_socket.cc: Drop Winsock 1 accommodations throughout.
	(fhandler_socket::readv): Accomodate new POSIX style struct msghdr.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Ditto. Handle "old" applications using
	former struct msghdr correctly.
	* net.cc: Drop Winsock 1 accommodations throughout.
	(wsadata): Move definition to autoload.cc.
	(set_socket_inheritance): Remove.
	(convert_ws1_ip_optname): New static function to convert Winsock1
	IPPROTO_IP option values into Winsock2 IPPROTO_IP option values.
	(cygwin_setsockopt): Remove wrong and incomplete cleartext printing
	of optname.  For "old" applications, convert optname from Winsock1
	to Winsock2 values before using them.  Add comment to describe the
	IP_TOS weirdness on W2K and above.
	(cygwin_getsockopt): Remove wrong and incomplete cleartext printing
	of optname.  For "old" applications, convert optname from Winsock1
	to Winsock2 values before using them.
	* select.cc (start_thread_socket): Forget about winsock2_active.
	* winsup.h (wsock32_handle): Remove declaration.
	(ws2_32_handle): Ditto.
	(netapi32_handle): Ditto.
	(wsadata): Ditto.
	(winsock2_active): Remove definition.
	* include/cygwin/socket.h: Change formatting slightly.
	(socklen_t): Move definition up in file.
	(struct msghdr): Convert to POSIX style.
	(struct cmsghdr): New type.
	(CMSG_ALIGN): New macro.
	(CMSG_LEN): Ditto.
	(CMSG_SPACE): Ditto.
	(CMSG_FIRSTHDR): Ditto.
	(CMSG_NXTHDR): Ditto.
	(CMSG_DATA): Ditto.
	(SCM_RIGHTS): Ditto.
	(struct OLD_msghdr): Define old msghdr structure for Cygwin internal
	purposes.
	(MSG_TRUNC): New macro.
	(MSG_CTRUNC): Ditto.
	(IP_OPTIONS): Redefine IPPROTO_IP option values to Winsock2 values.
	Keep Winsock1 values for Cygwin internal purposes.
	* include/cygwin/version.h: Bump API minor version.
	(CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR): Define to check for
	applications using old struct msghdr.
	(CYGWIN_VERSION_CHECK_FOR_USING_WINSOCK1_VALUES): Define to check for
	applications using old Winsock1 IPPROTO_IP values.
@
text
@d665 1
a665 1
  pi->thread = new cygthread (thread_pipe, (LPVOID) pi, "select_pipe");
d1094 1
a1094 1
  si->thread = new cygthread (thread_serial, (LPVOID) si, "select_serial");
d1425 1
a1425 1
  si->thread = new cygthread (thread_socket, (LPVOID) si, "select_socket");
d1677 1
a1677 1
  mi->thread = new cygthread (thread_mailslot, (LPVOID) mi, "select_mailslot");
@


1.118
log
@* sigproc.h (set_signal_mask): Remove default on second parameter and make pass
by reference.
* signal.cc (abort): Accommodate change to set_signal_mask.
* select.cc (pselect): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
(ctrl_c_handler): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Return ENMFILE if
__handle is not set.  Set __handle to NULL when out of files.
(fhandler_disk_file::rewinddir): Don't close handle if it's NULL.
(fhandler_disk_file::closedir): Ditto.
@
text
@d1413 1
a1413 1
      if (winsock2_active && wincap.has_set_handle_information ())
@


1.117
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d178 1
a178 1
    set_signal_mask (*set);
d182 1
a182 1
    set_signal_mask (oldset);
@


1.116
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d979 1
a979 1
  (void) SetCommMask (h, EV_RXCHAR);
d1169 1
a1169 1
      (void) select_read (&me);
@


1.115
log
@	* Makefile.in (DLL_OFILES): Add fhandler_mailslot.o.
	* devices.h (FH_KMSG): Define new device.
	* devices.in: Add "/dev/kmsg" entry.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Handle case FH_KMSG.
	* fhandler.h (class fhandler_mailslot): New class.
	(class select_stuff): Add device_specific_mailslot pointer.
	* fhandler_mailslot.cc: New file.
	* select.cc (peek_mailslot): New function.
	(verify_mailslot): Ditto.
	(struct mailslotinf): New stuct to handle select on mailslots.
	(thread_mailslot): New function.
	(start_thread_mailslot): Ditto.
	(mailslot_cleanup): Ditto.
	(fhandler_mailslot::select_read): New method.
	* syslog.cc (klog_guard): New muto.
	(dev_kmsg): Local mailslot for kernel message device.
	(vklog): New function.
	(klog): Ditto.
	* winsup.h (vklog): Declare.
	(klog): Ditto.
	* include/sys/syslog.h: Define _PATH_KLOG.
@
text
@d169 3
a173 2
      if (check_invalid_read_struct_errno (ts))
	return -1;
d178 1
a178 5
    {
      if (check_invalid_read_struct_errno (set))
	return -1;
      set_signal_mask (*set);
    }
@


1.114
log
@white space and minor comment cleanup.
@
text
@d1594 120
@


1.113
log
@	* cygwin.din (pselect): Export.
	* select.cc (pselect): New function.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/select.h: Include signal.h.  Declare pselect.
@
text
@d183 1
a183 1
  			   ts ? &tv : NULL);
d606 1
a606 1
          gotone += s->write_ready = true;
@


1.112
log
@	* fhandler.h (enum conn_state): Add connect_failed state.
	* fhandler_socket.cc (fhandler_socket::connect): Set connect_state to
	connect_failed when connect failed.
	* poll.cc (poll): Change errno to EINVAL if allocating memory fails,
	according to SUSv3. Add socket descriptors always to except_fds. Test
	for failed connect and set revents flags appropriately.
	* select.cc (set_bits): Set connect_state to connect_failed when
	select indicates failed nonblocking connect.
	(fhandler_dev_null::select_except): Set except_ready to false so that
	/dev/null is not always in except state.
	(peek_socket): Fix bogus conditional.
	(fhandler_socket::select_write): Treat all connect_states except
	unconnected equivalent to return consistent results.
	(fhandler_windows::select_except): Set except_ready to false so that
	/dev/windows is not always in except state.
@
text
@d39 1
d162 27
@


1.111
log
@	* fhandler.h (fhandler_socket::secret_event): Remove.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_set_cred): New method.
	(fhandler_socket::af_local_copy): New method.
	(fhandler_socket::af_local_recv_secret): New method.
	(fhandler_socket::af_local_send_secret): New method.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::af_local_accept): New method.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::set_connect_secret): Remove.
	(fhandler_socket::get_connect_secret): Remove.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	* fhandler_socket.cc (secret_event_name): Remove.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_recv_secret): New function to receive
	AF_LOCAL connect secret over socket itself.
	(fhandler_socket::af_local_send_secret): New function to send AF_LOCAL
	connect secret over socket itself.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::af_local_connect): Take over connect side handling
	of AF_LOCAL secret and credential handshake.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::af_local_accept): New method, take over accept side
	handling of AF_LOCAL secret and credential handshake.
	(fhandler_socket::af_local_set_cred): New method, set eid credentials
	to start values.
	(fhandler_socket::af_local_copy): New method, copy secret and
	credentials to another socket.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::fixup_after_fork): Drop secret_event handling.
	(fhandler_socket::bind): Call af_local_set_secret.
	(fhandler_socket::connect): Call af_local_set_cred and af_local_connect.
	(fhandler_socket::listen): Call af_local_set_cred.
	(fhandler_socket::accept): Call af_local_copy and af_local_accept on
	accepted socket.
	(fhandler_socket::close): Don't call close_secret_event.
	(fhandler_socket::set_close_on_exec): Don't set secret_event
	inheritance.
	* net.cc (cygwin_getsockopt): Add debug output.
	(socketpair): Call af_local_set_sockpair_cred instead of
	set_socketpair_eids.
	* select.cc (set_bits): Drop AF_LOCAL special handling in case
	of except bit set.
@
text
@d355 1
a355 1
	    sock->connect_state (connected);
d918 1
a918 1
  s->except_ready = true;
d1274 1
a1274 1
      if (WINSOCK_FD_ISSET (h, &ws_readfds) || (me->read_selected && me->read_ready))
d1276 1
a1276 1
      if (WINSOCK_FD_ISSET (h, &ws_writefds) || (me->write_selected && me->write_ready))
d1278 1
a1278 1
      if (WINSOCK_FD_ISSET (h, &ws_exceptfds) || ((me->except_selected || me->except_on_write) && me->except_ready))
d1463 1
a1463 1
  if (connect_state () == connect_pending)
d1562 1
a1562 1
  s->except_ready = true;
@


1.110
log
@	* fhandler.h (fhandler_socket::eid_connect): Make private.
	(fhandler_socket::set_connect_secret): Ditto.
	(fhandler_socket::get_connect_secret): Ditto.
	(fhandler_socket::create_secret_event): Ditto. Remove secret argument.
	(fhandler_socket::check_peer_secret_event): Ditto.
	(fhandler_socket::signal_secret_event): Make private.
	(fhandler_socket::close_secret_event): Ditto.
	(fhandler_socket::sec_event_accept): New private method.
	(fhandler_socket::sec_event_connect): Ditto.
	(fhandler_socket::af_local_connect): New public method.
	* fhandler_socket.cc: Use 'struct sockaddr' and 'struct sockaddr_in'
	rather than just 'sockaddr' and 'sockaddr_in' throughout.
	(fhandler_socket::eid_connect): Drop AF_LOCAL/SOCK_STREAM test.
	(fhandler_socket::create_secret_event): Remove secret argument.
	Always use connect_secret instead.
	(fhandler_socket::check_peer_secret_event): Ditto.
	(fhandler_socket::sec_event_connect): New method, combining entire
	secret event handshake on connect side.
	(fhandler_socket::af_local_connect): New method, combining secret
	event handshake and eid credential transaction on connect side, to
	be called from select.
	(fhandler_socket::sec_event_accept): New method, combining entire
	secret event handshake on accept side.
	(fhandler_socket::connect): Drop secret, use connect_secret instead.
	Move entire secret event handshake to sec_event_connect.
	(fhandler_socket::accept): Move entire secret event handshake to
	sec_event_accept.
	* select.cc (set_bits): Just call af_local_connect here.
@
text
@d355 1
a355 7
	    {
	      /* Special AF_LOCAL handling. */
	      if (!me->read_ready && sock->connect_state () == connect_pending
		  && sock->af_local_connect () && me->read_selected)
		UNIX_FD_SET (me->fd, readfds);
	      sock->connect_state (connected);
	    }
@


1.109
log
@* Makefile.in (DLL_OFILES): Add hookapi.o.  Eliminate some cruft.
* cygheap.h (cygheap_types): Add new enum: HEAP_1_HOOK.
(hook_chain): New struct.
(init_cygheap::hooks): Define new element.
* cygheap.cc (cygheap_fixup_in_child): Zero hook chain on exec.
* dcrt0.cc (dll_crt0_1): Call ld_preload just before calling main function.
* external.cc (cygwin_internal): Implement CW_HOOK.
* fork.cc (fork_child): Call fixup_hooks_after_fork.
* init.cc (cygwin_hmodule): Reinstate after a long absence.
* include/sys/cygwin.h: Define CW_HOOK.
* hookapi.cc: New file.
* select.cc (start_thread_socket): Add debugging output.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): gcc 4.x accommodation.
* fhandler_socket.cc (fhandler_socket::connect): Make sure that err is
initialized.
@
text
@d341 4
a344 5
	  /* eid credential transaction on successful non-blocking connect.
	     Since the read bit indicates an error, don't start transaction
	     if it's set. */
	  if (!me->read_ready && sock->connect_state () == connect_pending)
	    sock->eid_connect ();
d356 4
a359 2
	      if (!me->read_ready && sock->connect_state () == connect_pending)
	        sock->eid_connect ();
@


1.108
log
@	* fhandler.h (class cygthread): Forward declare.
	(fhandler_socket::sec_pipe): Remove.
	(fhandler_socket::eid_pipe_name): Remove.
	(fhandler_socket::eid_setblocking): New private method.
	(fhandler_socket::eid_unsetblocking): Ditto
	(fhandler_socket::eid_recv): Ditto
	(fhandler_socket::eid_send): Ditto
	(fhandler_socket::eid_accept): Ditto
	(fhandler_socket::eid_connect): New public method.
	* fhandler_socket.cc (ASYNC_MASK): Move to beginning of file.
	(fhandler_socket::eid_pipe_name): Remove.
	(fhandler_socket::set_socketpair_eids): Move down to fhandler_socket
	methods.
	(fhandler_socket::fhandler_socket): Drop initializing sec_pipe.
	(fhandler_socket::~fhandler_socket): Drop closing sec_pipe.
	(fhandler_socket::eid_setblocking): New method.
	(fhandler_socket::eid_unsetblocking): New method.
	(fhandler_socket::eid_recv): New method.
	(fhandler_socket::eid_send): New method.
	(fhandler_socket::eid_connect): New method.
	(fhandler_socket::eid_accept): New method.
	(fhandler_socket::dup): Drop sec_pipe handling.
	(fhandler_socket::connect): Fix WinSock error handling. Prepare
	eid credential transaction. Call eid_connect on successful connect.
	(fhandler_socket::listen): Drop creating sec_pipe.
	(fhandler_socket::accept): Slightly simplify code. Call eid_accept
	on accepted socket.
	(fhandler_socket::getpeereid): Reshuffle code for readability. Fix
	test for invalid pid.
	* select.cc (set_bits): Call eid_connect on successfully connected
	socket.
@
text
@d1397 1
@


1.107
log
@	* select.cc (peek_pipe): Disable new pipe code until there's
	a working substitute.
@
text
@d329 1
d339 9
a347 2
      if (me->except_on_write && me->fh->is_socket ())
	((fhandler_socket *) me->fh)->connect_state (connected);
d355 6
a360 2
	  if (me->fh->is_socket ())
	    ((fhandler_socket *) me->fh)->connect_state (connected);
@


1.106
log
@copyright
@
text
@d520 4
d570 3
@


1.105
log
@white space
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.104
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d1349 1
a1349 1
  else 
@


1.103
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d31 1
a32 1
#include "cygerrno.h"
d88 1
a88 2
      (s)->saw_error = true; \
      set_sig_errno (EBADF); \
d240 1
a240 1
	  __seterrno ();
d271 1
a271 1
	  __seterrno ();
d287 5
a291 2
	if (s->saw_error)
	  return -1;		/* Somebody detected an error */
d1010 1
a1010 2
  __seterrno ();
  s->saw_error = true;
@


1.102
log
@* cygtls.cc (_cygtls::fixup_after_fork): Wipe out exitsock local since it
should not be used by the child.
* select.cc (start_thread_socket): Turn off inheritance for exitsock.  Don't
add exitsock to exception mask since it should never get an exception.
(socket_cleanup): Change some debug messages for consistency.
* fhandler_socket.cc (fhandler_socket::dup): Change comment wording slightly.
@
text
@a38 1
#include "perthread.h"
a39 1
#include "cygthread.h"
d210 1
a210 1
  if (s->windows_handle || s->windows_handle || s->windows_handle)
@


1.102.2.1
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d41 1
@


1.102.2.2
log
@checkpoint
@
text
@d39 1
@


1.102.2.3
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
@
text
@d210 1
a210 1
  if (s->windows_handle)
@


1.101
log
@* select.cc (start_thread_socket): Remove attempt to delay reading of exitsock
or suffer occasional mysterious 60 second hangs.
(socket_cleanup): Empty the exitsock here after the thread has terminated.
@
text
@d1374 4
a1381 1
  WINSOCK_FD_SET ((HANDLE) si->exitsock, &si->exceptfds);
d1406 1
a1406 1
      select_printf ("sent a byte to the exit sock %p, res %d", _my_tls.locals.exitsock, res);
d1410 1
a1410 1
      select_printf ("reading a byte from %p", si->exitsock);
@


1.100
log
@revert erroneous checkin
@
text
@d1349 1
a1349 6
    {
      char buf[1];
      si->exitsock = _my_tls.locals.exitsock;
      select_printf ("read a byte from %p", si->exitsock);
      recv (si->exitsock, buf, 1, 0);
    }
d1406 4
@


1.99
log
@* fhandler_console.cc (fhandler_console::fixup_after_exec): Fix error message.
@
text
@d1350 4
a1353 7
      if (!si->exitsock)
	{
	  char buf[1];
	  si->exitsock = _my_tls.locals.exitsock;
	  select_printf ("read a byte from %p", si->exitsock);
	  recv (si->exitsock, buf, 1, 0);
	}
@


1.98
log
@* select.cc (start_thread_socket): Remove unused code.
@
text
@d1350 7
a1356 4
      char buf[1];
      si->exitsock = _my_tls.locals.exitsock;
      select_printf ("read a byte from %p", si->exitsock);
      recv (si->exitsock, buf, 1, 0);
@


1.97
log
@* cygtls.h (exitsock): New element.
(exitsock_sin): Ditto.
* cygtls.cc (_cygtls::init_thread): Initialize exitsock to invalid handle.
(_cygtls::call2): Close exitsock if it is valid.
* select.cc (struct socketinf): Remove sin element.
(start_thread_socket): Initialize one SOCK_DGRAM socket per thread instead of
(apparently) expensive opening and closing of socket with each select call.
(socket_cleanup): Send a byte to the exitsock socket as a way to potentially
signal a waiting-for-socket thread to exit.
* tlsoffsets.h: Regenerate.
@
text
@a1363 6
#if 0
      /* Allow rapid reuse of the port. */
      int tmp = 1;
      (void) setsockopt (si->exitsock, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp, sizeof (tmp));
#endif

@


1.96
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d14 2
a15 5
/*
 * The following line means that the BSD socket
 * definitions for fd_set, FD_ISSET etc. are used in this
 * file.
 */
d43 2
a1212 1
    struct sockaddr_in sin;
a1306 1

a1309 2
extern "C" unsigned long htonl (unsigned long);

d1348 1
a1348 1
  if ((si->exitsock = socket (PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
d1350 6
a1355 13
      set_winsock_errno ();
      select_printf ("cannot create socket, %E");
      return -1;
    }
  /* Allow rapid reuse of the port. */
  int tmp = 1;
  (void) setsockopt (si->exitsock, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp, sizeof (tmp));

  int sin_len = sizeof (si->sin);
  memset (&si->sin, 0, sizeof (si->sin));
  si->sin.sin_family = AF_INET;
  si->sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
  if (bind (si->exitsock, (struct sockaddr *) &si->sin, sizeof (si->sin)) < 0)
d1357 12
a1368 3
      select_printf ("cannot bind socket, %E");
      goto err;
    }
d1370 9
a1378 5
  if (getsockname (si->exitsock, (struct sockaddr *) &si->sin, &sin_len) < 0)
    {
      select_printf ("getsockname error");
      goto err;
    }
d1380 5
a1384 4
  if (listen (si->exitsock, 1))
    {
      select_printf ("listen failed, %E");
      goto err;
d1410 5
a1414 20
      select_printf ("connection to si->exitsock %p", si->exitsock);
      SOCKET s = socket (AF_INET, SOCK_STREAM, 0);

      /* Set LINGER with 0 timeout for hard close */
      struct linger tmp = {1, 0}; /* On, 0 delay */
      (void) setsockopt (s, SOL_SOCKET, SO_LINGER, (char *)&tmp, sizeof (tmp));
      (void) setsockopt (si->exitsock, SOL_SOCKET, SO_LINGER, (char *)&tmp, sizeof (tmp));

      /* Connecting to si->exitsock will cause any executing select to wake
	 up.  When this happens then the exitsock condition will cause the
	 thread to terminate. */
      if (connect (s, (struct sockaddr *) &si->sin, sizeof (si->sin)) < 0)
	{
	  set_winsock_errno ();
	  select_printf ("connect failed");
	  /* FIXME: now what? */
	}
      shutdown (s, SD_BOTH);
      closesocket (s);

a1416 2
      shutdown (si->exitsock, SD_BOTH);
      closesocket (si->exitsock);
@


1.95
log
@Christopher Faylor <cgf@@timesys.com>
* autoload.cc (NtQueryInformationFile): Return nonzero on error.
* ntdll.h (FILE_PIPE_LOCAL_INFORMATION): Add.
(NtQueryInformationFile): Fix types for last two arguments.
* pipe.cc: Include stdlib.h, limits.h, and ntdll.h.
(create_selectable_pipe): New function to create a pipe that can be used with
NtQueryInformationFile for select.
(fhandler_pipe::create): Call create_selectable_pipe instead of CreatePipe.
(pipe): Use DEFAULT_PIPEBUFSIZE as argument to create_pipe.
* select.cc: Include limits.h and ntdll.h.
(peek_pipe): Add select_printf output.  Call NtQueryInformationFile to
implement select for write on pipes.
(fhandler_pipe::select_read): Reorder field assignments to be consistent with
fhandler_pipe::select_write.
(fhandler_pipe::select_write): Initialize startup, verify, cleanup, and
write_ready fields for select_record.
(fhandler_pipe::select_except): Tweak indentation to be consistent with
fhandler_pipe::select_write.
@
text
@d510 4
a513 4
        {
          select_printf ("%s, already ready for write", fh->get_name ());
          gotone++;
        }
d519 48
a566 48
        {
          /* We don't worry about the guard mutex, because that only applies
             when from_select is false, and peek_pipe is never called that
             way for writes.  */

          IO_STATUS_BLOCK iosb = {0};
          FILE_PIPE_LOCAL_INFORMATION fpli = {0};

          if (NtQueryInformationFile (h,
                                      &iosb,
                                      &fpli,
                                      sizeof (fpli),
                                      FilePipeLocalInformation))
            {
              /* If NtQueryInformationFile fails, optimistically assume the
                 pipe is writable.  This could happen on Win9x, because
                 NtQueryInformationFile is not available, or if we somehow
                 inherit a pipe that doesn't permit FILE_READ_ATTRIBUTES
                 access on the write end.  */
              select_printf ("%s, NtQueryInformationFile failed",
                             fh->get_name ());
              gotone += s->write_ready = true;
            }
          /* Ensure that enough space is available for atomic writes,
             as required by POSIX.  Subsequent writes with size > PIPE_BUF
             can still block, but most (all?) UNIX variants seem to work
             this way (e.g., BSD, Linux, Solaris).  */
          else if (fpli.WriteQuotaAvailable >= PIPE_BUF)
            {
              select_printf ("%s, ready for write: size %lu, avail %lu",
                             fh->get_name (),
                             fpli.OutboundQuota,
                             fpli.WriteQuotaAvailable);
              gotone += s->write_ready = true;
            }
          /* If we somehow inherit a tiny pipe (size < PIPE_BUF), then consider
             the pipe writable only if it is completely empty, to minimize the
             probability that a subsequent write will block.  */
          else if (fpli.OutboundQuota < PIPE_BUF &&
                   fpli.WriteQuotaAvailable == fpli.OutboundQuota)
            {
              select_printf ("%s, tiny pipe: size %lu, avail %lu",
                             fh->get_name (),
                             fpli.OutboundQuota,
                             fpli.WriteQuotaAvailable);
              gotone += s->write_ready = true;
            }
        }
@


1.94
log
@* select.cc (select_stuff::wait): Correctly check for w4 array bounds.
@
text
@d31 1
a31 1
#include <stdio.h>
d45 1
d423 1
a423 1
	  select_printf ("already ready");
d455 2
a456 1
    /* nothing */;
d494 1
a494 1
      select_printf ("%s, ready for read", fh->get_name ());
d501 1
a501 1
	gotone = s->except_ready = true;
a503 1
      select_printf ("saw eof on '%s'", fh->get_name ());
d507 63
a569 1
  return gotone || s->write_ready;
d669 1
a671 1
  s->cleanup = pipe_cleanup;
d679 2
a680 5
    {
      s = new select_record;
      s->startup = no_startup;
      s->verify = no_verify;
    }
d682 2
d685 1
a685 1
  s->write_ready = true;
d693 1
a693 1
      s = new select_record;
@


1.93
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d236 1
a236 1
      if (m > MAXIMUM_WAIT_OBJECTS)
@


1.92
log
@	* fhandler.cc (fhandler_base::write): Use bool parameter in calls to
	set_did_lseek.
	(fhandler_base::fhandler_base): Accomodate new status and open_status
	constructor.
	* fhandler.h: Remove status bit enumerator.
	(FHDEVN): Remove.
	(FHISSETF): Remove.
	(FHSETF): Remove.
	(FHCLEARF): Remove.
	(FHCONDSETF): Remove.
	(FHSTATOFF): Remove.
	(UNCONNECTED, CONNECT_PENDING, CONNECTED): Substitute by enum
	connect_state.
	(fhandler_base::status): Define as bitfield struct type status_flags.
	Remove unused flags entirely.  Accomodate all status access methods.
	(open_status): Define as bitfield struct type status_flags.
	(fhandler_socket): Move socket related status bits to here.  Redefine
	had_connect_or_listen to be part of these status bits.  Accomodate
	related access methods.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use pc.issymlink
	instead of dropped method get_symlink_p.
	(fhandler_base::open_fs): Remove setting dropped status flags.
	* fhandler_socket.cc: Use values from enum connect_state throughout.
	(fhandler_socket::fhandler_socket): Initialize status bits.
	* fhandler_virtual.cc (fhandler_virtual::open): Remove setting dropped
	status flags.
	* net.cc: Use values from enum connect_state throughout.
	* select.cc: Ditto.
	* shared_info.h: Protect struct console_state using _FHANDLER_H_
	instead of FHDEVN.
@
text
@d338 1
a338 1
	((fhandler_socket *) me->fh)->set_connect_state (connected);
d347 1
a347 1
	    ((fhandler_socket *) me->fh)->set_connect_state (connected);
d1403 1
a1403 1
  s->write_ready = saw_shutdown_write () || is_unconnected ();
d1405 1
a1405 1
  if (is_connect_pending ())
@


1.91
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d338 1
a338 1
	((fhandler_socket *) me->fh)->set_connect_state (CONNECTED);
d347 1
a347 1
	    ((fhandler_socket *) me->fh)->set_connect_state (CONNECTED);
@


1.90
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.89
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d284 1
a284 1
      int gotone = FALSE;
d514 1
a514 1
    BOOL stop_thread_pipe;
d522 1
a522 1
  BOOL gotone = FALSE;
d562 1
a562 1
  pi->stop_thread_pipe = FALSE;
d851 1
a851 1
    BOOL stop_thread_serial;
d959 1
a959 1
  BOOL gotone= FALSE;
d993 1
a993 1
  si->stop_thread_serial = FALSE;
@


1.88
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a104 1
  sigframe thisframe (mainthread);
d1088 1
@


1.87
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d37 1
a38 1
#include "path.h"
d338 1
a338 1
      if (me->except_on_write && me->fh->get_device () == FH_SOCKET)
d347 1
a347 1
	  if (me->fh->get_device () == FH_SOCKET)
d556 1
a556 1
  if (stuff->device_specific[FHDEVN (FH_PIPE)])
d558 1
a558 1
      me->h = *((pipeinf *) stuff->device_specific[FHDEVN (FH_PIPE)])->thread;
d568 1
a568 1
  stuff->device_specific[FHDEVN (FH_PIPE)] = (void *) pi;
d575 1
a575 1
  pipeinf *pi = (pipeinf *) stuff->device_specific[FHDEVN (FH_PIPE)];
d581 1
a581 1
      stuff->device_specific[FHDEVN (FH_PIPE)] = NULL;
d987 1
a987 1
  if (stuff->device_specific[FHDEVN (FH_SERIAL)])
d989 1
a989 1
      me->h = *((serialinf *) stuff->device_specific[FHDEVN (FH_SERIAL)])->thread;
d997 1
a997 1
  stuff->device_specific[FHDEVN (FH_SERIAL)] = (void *) si;
d1004 1
a1004 1
  serialinf *si = (serialinf *) stuff->device_specific[FHDEVN (FH_SERIAL)];
d1010 1
a1010 1
      stuff->device_specific[FHDEVN (FH_SERIAL)] = NULL;
d1258 1
a1258 1
  if ((si = (socketinf *) stuff->device_specific[FHDEVN (FH_SOCKET)]))
d1326 1
a1326 1
  stuff->device_specific[FHDEVN (FH_SOCKET)] = (void *) si;
d1342 1
a1342 1
  socketinf *si = (socketinf *) stuff->device_specific[FHDEVN (FH_SOCKET)];
d1370 1
a1370 1
      stuff->device_specific[FHDEVN (FH_SOCKET)] = NULL;
@


1.86
log
@* select.cc (fhandler_pipe::ready_for_read): Assure that get_guard is called
for successful non-blocking pipe reads.
@
text
@a22 1
#include <errno.h>
@


1.85
log
@Do some minor reformatting of 'extern "C"' use throughout.
* autoload.cc (GetSystemTimes): Define new autoload function.
* fhandler_proc.cc (proc_listing): Add cpuinfo and partitions entries.
(fhandler_proc::fill_filebuf): Add PROC_CPUINFO and PROC_PARTITIONS cases.
(format_proc_uptime): Use GetSystemTimes if available.
(read_value): New macro.
(print): New macro.
(cpuid): New function.
(can_set_flag): New function.
(format_proc_cpuinfo): New function.
(format_proc_partitions): New function.
@
text
@d589 5
a593 2
  if (!howlong)
    return fhandler_base::ready_for_read (fd, howlong);
d595 3
a597 2
  get_guard ();
  return true;
@


1.84
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d98 1
a98 2
extern "C"
int
@


1.83
log
@* cygthread.h (cygthread::stack_ptr): New element.
(cygthread::detach): Accept a "wait_for_signal" argument.
(cygthread::terminate_thread): New function.
* cygthread.cc (cygthread::stub): Set stack pointer argument.
(cygthread::terminate_thread): New function.  Forcibly terminate thread.
(cygthread::detach): Optionally wait for signals and kill thread when signal
arrives.
* exceptions.cc (signal_exit): Set signal_arrived prior to exiting to wake up
anything blocking on signals.
* fhandler.h (fhandler_base::set_r_no_interrupt): Change to accept bool
argument.
(fhandler_pipe::ready_for_read): Declare.
* pipe.cc (pipeargs): New structure.
(read_pipe): New thread stub wrapper for normal pipe read.
(fhandler_pipe::read): Modify to call reader in a cygthread, terminating on
signal, as appropriate.
* select.cc (fhandler_pipe::ready_for_read): Define new function.
@
text
@d591 1
a591 1
    return this->fhandler_base::ready_for_read (fd, howlong);
@


1.83.6.1
log
@merge from trunk
@
text
@d558 1
a558 1
  if (stuff->device_specific_pipe)
d560 1
a560 1
      me->h = *((pipeinf *) stuff->device_specific_pipe)->thread;
d570 1
a570 1
  stuff->device_specific_pipe = (void *) pi;
d577 1
a577 1
  pipeinf *pi = (pipeinf *) stuff->device_specific_pipe;
d583 1
a583 1
      stuff->device_specific_pipe = NULL;
d985 1
a985 1
  if (stuff->device_specific_serial)
d987 1
a987 1
      me->h = *((serialinf *) stuff->device_specific_serial)->thread;
d995 1
a995 1
  stuff->device_specific_serial = (void *) si;
d1002 1
a1002 1
  serialinf *si = (serialinf *) stuff->device_specific_serial;
d1008 1
a1008 1
      stuff->device_specific_serial = NULL;
d1256 1
a1256 1
  if ((si = (socketinf *) stuff->device_specific_socket))
d1324 1
a1324 1
  stuff->device_specific_socket = (void *) si;
d1340 1
a1340 1
  socketinf *si = (socketinf *) stuff->device_specific_socket;
d1368 1
a1368 1
      stuff->device_specific_socket = NULL;
@


1.83.6.2
log
@merge from trunk
@
text
@d591 1
a591 1
    return fhandler_base::ready_for_read (fd, howlong);
@


1.83.6.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d38 1
a39 1
#include "fhandler.h"
@


1.83.6.4
log
@Merge from trunk.
* Makefile.in (devicess.cc): Make generation dependent on cygwin-gperf.
* cygheap.h (cygheap_fdmanip): Add fhandler_socket cast.
* cygwin-gperf: Autogenerate references to network devices.
* devices.h: Create separate device types for all network types.  Export
references to global network device storage.
* dtable.cc (dtable::release): Use generic determination to control when
need_fixup_before needs to be decremented.
(dtable::init_std_file_from_handle): Replace use of 'socket_dev' with
'tcp_dev'.
(build_fh_pc): Adapt to new socket types.  Don't increment fixup_before here.
* fhandler.h (fhandler_base::need_fixup_before): Declare/define.
(fhandler_socket::need_fixup_before): Ditto.
* fhandler_socket.cc (fhandler_socket::accept): Accommodate new fdsock
definition.
* net.cc: Throughout, change use of fdsock to return true/false for
success/failure and take cygheap_fdmanip type and device
* select.cc (set_bits): Use 'is_socket ()' test rather than specificially
testing device type.
@
text
@d340 1
a340 1
      if (me->except_on_write && me->fh->is_socket ())
d349 1
a349 1
	  if (me->fh->is_socket ())
@


1.83.6.5
log
@merge from trunk
@
text
@d98 2
a99 1
extern "C" int
@


1.83.6.6
log
@merge from trunk
@
text
@d589 2
a590 5
  int res;
  if (howlong)
    res = true;
  else
    res = fhandler_base::ready_for_read (fd, howlong);
d592 2
a593 3
  if (res)
    get_guard ();
  return res;
@


1.83.6.7
log
@merge from trunk
@
text
@d23 1
@


1.83.4.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d558 1
a558 1
  if (stuff->device_specific_pipe)
d560 1
a560 1
      me->h = *((pipeinf *) stuff->device_specific_pipe)->thread;
d570 1
a570 1
  stuff->device_specific_pipe = (void *) pi;
d577 1
a577 1
  pipeinf *pi = (pipeinf *) stuff->device_specific_pipe;
d583 1
a583 1
      stuff->device_specific_pipe = NULL;
d985 1
a985 1
  if (stuff->device_specific_serial)
d987 1
a987 1
      me->h = *((serialinf *) stuff->device_specific_serial)->thread;
d995 1
a995 1
  stuff->device_specific_serial = (void *) si;
d1002 1
a1002 1
  serialinf *si = (serialinf *) stuff->device_specific_serial;
d1008 1
a1008 1
      stuff->device_specific_serial = NULL;
d1256 1
a1256 1
  if ((si = (socketinf *) stuff->device_specific_socket))
d1324 1
a1324 1
  stuff->device_specific_socket = (void *) si;
d1340 1
a1340 1
  socketinf *si = (socketinf *) stuff->device_specific_socket;
d1368 1
a1368 1
      stuff->device_specific_socket = NULL;
@


1.82
log
@* select.cc (peek_serial): Don't call PurgeComm() to avoid characters loss.
@
text
@d434 1
a434 1
	  if (((fhandler_pty_master *)fh)->need_nl)
d524 1
a524 1
  pipeinf *pi = (pipeinf *)arg;
d566 1
a566 1
  pi->thread = new cygthread (thread_pipe, (LPVOID)pi, "select_pipe");
d570 1
a570 1
  stuff->device_specific[FHDEVN (FH_PIPE)] = (void *)pi;
d577 1
a577 1
  pipeinf *pi = (pipeinf *)stuff->device_specific[FHDEVN (FH_PIPE)];
d587 10
d644 1
a644 1
  fhandler_console *fh = (fhandler_console *)me->fh;
d761 1
a761 1
  return ((fhandler_pipe*)this)->fhandler_pipe::select_read (s);
d767 1
a767 1
  return ((fhandler_pipe *)this)->fhandler_pipe::select_write (s);
d773 1
a773 1
  return ((fhandler_pipe *)this)->fhandler_pipe::select_except (s);
d859 1
a859 1
  fhandler_serial *fh = (fhandler_serial *)s->fh;
d957 1
a957 1
  serialinf *si = (serialinf *)arg;
d993 1
a993 1
  si->thread = new cygthread (thread_serial, (LPVOID)si, "select_serial");
d995 1
a995 1
  stuff->device_specific[FHDEVN (FH_SERIAL)] = (void *)si;
d1002 1
a1002 1
  serialinf *si = (serialinf *)stuff->device_specific[FHDEVN (FH_SERIAL)];
d1213 1
a1213 1
  socketinf *si = (socketinf *)arg;
d1256 1
a1256 1
  if ((si = (socketinf *)stuff->device_specific[FHDEVN (FH_SOCKET)]))
d1327 1
a1327 1
  si->thread = new cygthread (thread_socket, (LPVOID)si, "select_socket");
d1340 1
a1340 1
  socketinf *si = (socketinf *)stuff->device_specific[FHDEVN (FH_SOCKET)];
@


1.81
log
@whitespace
@
text
@a914 1
      PurgeComm (h, PURGE_TXABORT | PURGE_RXABORT);
a916 1
      PurgeComm (h, PURGE_TXABORT | PURGE_RXABORT);
a921 1
      PurgeComm (h, PURGE_TXABORT | PURGE_RXABORT);
a923 1
      PurgeComm (h, PURGE_TXABORT | PURGE_RXABORT);
@


1.80
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d341 1
a341 1
        ((fhandler_socket *) me->fh)->set_connect_state (CONNECTED);
d347 1
a347 1
        {
d351 1
a351 1
        }
@


1.79
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d558 1
a558 1
  if (stuff->device_specific[FHDEVN(FH_PIPE)])
d560 1
a560 1
      me->h = *((pipeinf *) stuff->device_specific[FHDEVN(FH_PIPE)])->thread;
d570 1
a570 1
  stuff->device_specific[FHDEVN(FH_PIPE)] = (void *)pi;
d577 1
a577 1
  pipeinf *pi = (pipeinf *)stuff->device_specific[FHDEVN(FH_PIPE)];
d583 1
a583 1
      stuff->device_specific[FHDEVN(FH_PIPE)] = NULL;
d979 1
a979 1
  if (stuff->device_specific[FHDEVN(FH_SERIAL)])
d981 1
a981 1
      me->h = *((serialinf *) stuff->device_specific[FHDEVN(FH_SERIAL)])->thread;
d989 1
a989 1
  stuff->device_specific[FHDEVN(FH_SERIAL)] = (void *)si;
d996 1
a996 1
  serialinf *si = (serialinf *)stuff->device_specific[FHDEVN(FH_SERIAL)];
d1002 1
a1002 1
      stuff->device_specific[FHDEVN(FH_SERIAL)] = NULL;
d1250 1
a1250 1
  if ((si = (socketinf *)stuff->device_specific[FHDEVN(FH_SOCKET)]))
d1318 1
a1318 1
  stuff->device_specific[FHDEVN(FH_SOCKET)] = (void *) si;
d1334 1
a1334 1
  socketinf *si = (socketinf *)stuff->device_specific[FHDEVN(FH_SOCKET)];
d1362 1
a1362 1
      stuff->device_specific[FHDEVN(FH_SOCKET)] = NULL;
@


1.78
log
@(inspired by a patch from Egor Duda)
* select.cc (fhandler_tty_slave::ready_for_read): Remove.
* fhandler.h (fhandler_tty_slave::ready_for_read): Remove declaration.
* fhandler_tty.cc (fhandler_tty_slave::read): Don't do anything special with
vtime when vmin == 0.
* autoload.cc (GetConsoleWindow): Correct parameter count.
@
text
@d74 1
a74 1
  ((unsigned) (NULL_fd_set->fds_bits + unix_howmany((n), UNIX_NFDBITS)))
d1293 1
a1293 1
  int sin_len = sizeof(si->sin);
d1343 2
a1344 2
      (void) setsockopt (s, SOL_SOCKET, SO_LINGER, (char *)&tmp, sizeof(tmp));
      (void) setsockopt (si->exitsock, SOL_SOCKET, SO_LINGER, (char *)&tmp, sizeof(tmp));
@


1.77
log
@* fhandler.h (fhandler_console::send_winch_maybe): New method.
* fhandler_console.cc (set_console_state_for_spawn): Remove if 0'ed code.
(fhandler_console::send_winch_maybe): Define new method.
(fhandler_console::read): Use send_winch_maybe where appropriate.
(fhandler_console::init): Just call all tcsetattr rather than output_tcsetattr.
* select.cc (peek_console): Reorganize so that send_winch_maybe is called for
everything but keyboard input.
@
text
@a789 34
int
fhandler_tty_slave::ready_for_read (int fd, DWORD howlong)
{
  HANDLE w4[2];
  if (cygheap->fdtab.not_open (fd))
    {
      set_sig_errno (EBADF);
      return 0;
    }
  if (get_readahead_valid ())
    {
      select_printf ("readahead");
      return 1;
    }
  w4[0] = signal_arrived;
  w4[1] = input_available_event;
  switch (WaitForMultipleObjects (2, w4, FALSE, howlong))
    {
    case WAIT_OBJECT_0:
      set_sig_errno (EINTR);
      return 0;
    case WAIT_OBJECT_0 + 1:
      return 1;
    case WAIT_FAILED:
      select_printf ("wait failed %E");
      set_sig_errno (EINVAL); /* FIXME: correct errno? */
      return 0;
    default:
      if (!howlong)
	set_sig_errno (EAGAIN);
      return 0;
    }
}

@


1.76
log
@* Makefile.in (DLL_OFILES): Add cygthread.o.
* dcrt0.cc (dll_crt0_1): Eliminate various thread initialization functions in
favor of new cygthread class.
* debug.cc: Remove thread manipulation functions.
* debug.h: Ditto.
* external.cc (cygwin_internal): Use cygthread method for determining thread
name.  Remove capability for setting thread name.
* fhandler_console.cc (fhandler_console::read): Use cygthread method rather
than iscygthread function.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Use cygthread
methods to create threads.
(fhandler_tty_common::__acquire_output_mutex): Use cygthread method to retrieve
thread name.
* select.cc (pipeinf): Use cygthread pointer rather than handle.
(start_thread_pipe): Ditto.
(pipe_cleanup): Ditto.
(serialinf): Ditto.
(start_thread_serial): Ditto.
(serial_cleanup): Ditto.
(socketinf): Ditto.
(start_thread_socket): Ditto.
(socket_cleanup): Ditto.
* sigproc.cc (hwait_sig): Ditto.
(hwait_subproc): Ditto.
(proc_terminate): Ditto.
(sigproc_terminate): Ditto.
(sigproc_init): Initialize cygthread hwait_sig pointer.
(subproc_init): Initialize cygthread hwait_subproc pointer.
(wait_sig): Rely on cygthread HANDLE operator.
* strace.cc (strace::vsprntf): Use cygthread::name rather than threadname.
* window.cc (gethwnd): Use cygthread method to initialize thread.
@
text
@d664 1
a664 5
	if (irec.EventType == WINDOW_BUFFER_SIZE_EVENT)
	  fh->tc->kill_pgrp (SIGWINCH);
	else if (irec.EventType == MOUSE_EVENT &&
		 (irec.Event.MouseEvent.dwEventFlags == 0 ||
		  irec.Event.MouseEvent.dwEventFlags == DOUBLE_CLICK))
d666 3
a668 1
	    if (fh->mouse_aware ())
d671 9
a679 3
	else if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown == true &&
		 (irec.Event.KeyEvent.uChar.AsciiChar || get_nonascii_key (irec, tmpbuf)))
	  return me->read_ready = true;
@


1.75
log
@* fhandler_console.cc (fhandler_console::read): Use appropriate kill_pgrp
method.
* select.cc (peek_console): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Send "stopped" signal to
entire process group as dictated by SUSv3.
* termios.cc (tcsetattr): Detect when stopped signal sent and force a stop
before setting anything.
@
text
@d45 1
d516 1
a516 1
    HANDLE thread;
d560 1
a560 1
      me->h = ((pipeinf *) stuff->device_specific[FHDEVN(FH_PIPE)])->thread;
d566 2
a567 1
  pi->thread = me->h = makethread (thread_pipe, (LPVOID)pi, 0, "select_pipe");
d581 1
a581 2
      WaitForSingleObject (pi->thread, INFINITE);
      CloseHandle (pi->thread);
d869 1
a869 1
    HANDLE thread;
d1011 1
a1011 1
      me->h = ((pipeinf *) stuff->device_specific[FHDEVN(FH_SERIAL)])->thread;
d1017 2
a1018 3
  si->thread = me->h = makethread (thread_serial, (LPVOID)si, 0, "select_serial");
  if (!me->h)
    return 0;
d1030 1
a1030 2
      WaitForSingleObject (si->thread, INFINITE);
      CloseHandle (si->thread);
d1171 1
a1171 1
    HANDLE thread;
d1282 1
a1282 1
      me->h = si->thread;
d1351 3
a1353 3
  si->thread = me->h = makethread (thread_socket, (LPVOID)si, 0,
				  "select_socket");
  return !!me->h;
d1389 1
a1389 1
      WaitForSingleObject (si->thread, INFINITE);
a1391 1
      CloseHandle (si->thread);
@


1.74
log
@	* fhandler.h (fhandler_socket::is_unconnected): Constify.
	(fhandler_socket::is_connect_pending): Ditto.
	(fhandler_socket::is_connected): Ditto.
	(fhandler_socket::set_connect_state): New method.
	(struct select_record): Add member `except_on_write'.
	(select_record::select_record): Initialize all bool values to `false'.
	* fhandler_socket.cc: Use set_connect_state() method throughout.
	(fhandler_socket::connect): Set state always to connected if connection
	isn't pending.
	* net.cc (cygwin_getsockopt): Revert erroneous previous patch.
	* select.cc (set_bits): Check for `except_on_write'.  Set fd in
	write_fds if set.  Set connect state to connected if fd has been
	returned by WINSOCK_SELECT.
	(peek_socket): Check for `except_on_write'.
	(start_thread_socket): Ditto.
	(fhandler_socket::select_write): Don't set `write_ready' if connect
	is pending.  Set `except_on_write' if connect is pending.
@
text
@d664 1
a664 1
	  kill_pgrp (fh->tc->getpgid (), SIGWINCH);
@


1.73
log
@	* fhandler.h (UNCONNECTED): New define.
	(CONNECT_PENDING): Ditto.
	(CONNECTED): Ditto.
	(class fhandler_socket): Add member `had_connect_or_listen'.
	Add member functions `is_unconnected', `is_connect_pending' and
	`is_connected'.
	* fhandler_socket.cc (fhandler_socket::connect): Set member
	`had_connect_or_listen' according to return code of WinSock
	call.
	(fhandler_socket::listen): Ditto.
	* net.cc (cygwin_getsockopt): Modify SO_ERROR return value in
	case of socket with pending connect().
	* select.cc (peek_socket): Only add socket to matching fd_set
	if it's not "ready".  Call WINSOCK_SELECT only if at least one
	socket is in one of the fd_sets.
	(start_thread_socket): Only add socket to matching fd_set
	if it's not "ready".
	(fhandler_socket::select_write): Set write_ready to true also
	if socket isn't connected or listening.
@
text
@d339 2
d343 1
a343 1
  if (me->except_selected && me->except_ready)
d345 8
a352 1
      UNIX_FD_SET (me->fd, exceptfds);
d1204 1
a1204 1
  if (me->except_selected && !me->except_ready)
d1213 1
a1213 1
      || (me->except_selected && !me->except_ready))
d1227 1
a1227 1
      if (WINSOCK_FD_ISSET (h, &ws_exceptfds) || (me->except_selected && me->except_ready))
d1307 1
a1307 1
	if (s->except_selected && !s->except_ready)
d1427 1
a1427 1
  s->write_ready = saw_shutdown_write () || !is_connected ();
d1429 5
@


1.72
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d1183 1
a1183 1
  if (me->read_selected)
d1189 1
a1189 1
  if (me->write_selected)
d1195 1
a1195 1
  if (me->except_selected)
d1201 19
a1219 7
  int r = WINSOCK_SELECT (0, &ws_readfds, &ws_writefds, &ws_exceptfds, &tv);
  select_printf ("WINSOCK_SELECT returned %d", r);
  if (r == -1)
    {
      select_printf ("error %d", WSAGetLastError ());
      set_winsock_errno ();
      return 0;
a1220 7

  if (WINSOCK_FD_ISSET (h, &ws_readfds) || (me->read_selected && me->read_ready))
    me->read_ready = true;
  if (WINSOCK_FD_ISSET (h, &ws_writefds) || (me->write_selected && me->write_ready))
    me->write_ready = true;
  if (WINSOCK_FD_ISSET (h, &ws_exceptfds) || (me->except_selected && me->except_ready))
    me->except_ready = true;
d1288 1
a1288 1
	if (s->read_selected)
d1293 1
a1293 1
	if (s->write_selected)
d1298 1
a1298 1
	if (s->except_selected)
d1418 1
a1418 1
  s->write_ready = saw_shutdown_write ();
@


1.71
log
@bump copyright
@
text
@a41 1
#include "sync.h"
@


1.70
log
@* exceptions.cc (unused_sig_wrapper): Eliminate unused parameter to asm.
* external.cc (cygwin_internal): Change CW_STRACE_ON to CW_STRACE_TOGGLE.
* strace.cc (strace::hello): Toggle strace on and off.
* sync.cc (muto::init): Renamed from constructor.
* sync.h (muto::new): Delete.
(muto::delete): Ditto.
(new_muto): Simplify.  Use muto.init for nearly everything.
* uinfo.cc (uinfo_init): Avoid closing a NULL handle.
* include/sys/cygwin.h (cygwin_getinfo_types): Rename CW_STRACE_OFF to
CW_STRACE_TOGGLE.  Delete CW_STRACE_OFF.
* include/sys/strace.h (strace): Add "inited" field.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.69
log
@* fhandler.h (fhandler_serial::ev): New class member.
* fhandler_serial.cc (fhandler_serial::raw_read): Use class member for event
status.
* select.cc (peek_serial): Ditto.
@
text
@d455 1
a455 1
    /* no guard mutex or nothing to read fromt he pipe. */;
@


1.68
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@a867 1
  DWORD ev;
a891 1
      DWORD ev;
d896 1
a896 1
      if (!ClearCommError (h, &ev, &st))
d903 1
a903 1
      else if (WaitCommEvent (h, &ev, &fh->io_status))
d924 1
a924 1
      if (!ClearCommError (h, &ev, &st))
@


1.67
log
@	* select.cc: Set errno using set_sig_errno() throughout.
	* signal.cc (signal): Always set SA_RESTART flag.
	* syscalls.cc (_read): Revert previous patch.
@
text
@d342 1
a342 1
  if (me->except_ready && me->except_ready)
@


1.66
log
@	* select.cc (fhandler_tty_slave::ready_for_read):  Return 0 on EBADF.
	* syscalls.cc (_read): If ready_for_read() failed, save errno from
	being overwritten by signal handler call.
@
text
@d92 1
a92 1
      set_errno (EBADF); \
d241 1
a241 1
	  set_errno (EINVAL);
d783 1
a783 1
      set_errno (EBADF);
d796 1
a796 1
      set_errno (EINTR);
d802 1
a802 1
      set_errno (EINVAL); /* FIXME: correct errno? */
d806 1
a806 1
	set_errno (EAGAIN);
d1092 1
a1092 1
	  set_errno (EBADF);
d1100 1
a1100 1
	    set_errno (EAGAIN);
d1106 1
a1106 1
	  set_errno (EINTR);
@


1.65
log
@* select.cc (fhandler_tty_slave::ready_for_read): Correct inverted not_open
test.
@
text
@d784 1
a784 1
      return 1;
@


1.64
log
@Eliminate excess whitespace.
@
text
@d781 1
a781 1
  if (!cygheap->fdtab.not_open (fd))
@


1.64.2.1
log
@* select.cc (fhandler_tty_slave::ready_for_read): Correct inverted not_open
test.
@
text
@d781 1
a781 1
  if (cygheap->fdtab.not_open (fd))
@


1.63
log
@* select.cc: Add more comments throughout.  Use bool 'true' where appropriate
throughout.
(fhandler_socket::select_read): Remove duplicate setting for *_ready which
inadvertently overrode previous, correct setting.
(fhandler_socket::select_write): Ditto.
@
text
@d289 1
a289 1
         like mouse movements.  The verify function will detect these situations.
d674 1
a674 1
 
@


1.62
log
@* select.cc (verify_console): New function.
(verify_windows): Ditto.
(fhandler_console::select_read): Really do need to verify that there is
something to read.
(fhandler_console::select_windows): Ditto.
@
text
@d288 4
d399 7
d407 1
d427 1
a427 1
	      gotone = s->read_ready = 1;
d435 1
a435 1
	      gotone = s->read_ready = 1;
d442 1
a442 1
	  gotone = s->read_ready = 1;
d455 1
a455 1
    /* nothing */;
d477 1
a477 1
      fh->set_eof ();
d633 1
a633 1
      return me->read_ready = 1;
d650 1
a650 1
      return me->read_ready = 1;
d662 1
a662 1
	      return me->read_ready = 1;
d666 1
a666 1
	  return me->read_ready = 1;
d758 1
a758 1
    me->read_ready = 1;
d874 1
a874 1
    return s->read_ready = 1;
d904 1
a904 1
	return s->read_ready = 1;
d906 1
a906 1
	return s->read_ready = 1;
d935 1
a935 1
	  return s->read_ready = 1;
a1083 1
  me.read_ready = false;
a1401 1
  s->read_ready = false;
a1417 1
  s->write_ready = false;
@


1.61
log
@* fhandler.h (fhandler_base::ready_for_read): Remove unused argument.
(fhandler_tty_slave::ready_for_read): Ditto.
(select_record): Remove poll, initialize peek.
* select.cc: Remove all poll functions, throughout.  Change second argument of
peek_* functions to 'bool' throughout.  Specifically initialize *_ready
variables throughout.
(select_stuff::poll): Subsume previous poll functionality.
(peek_pipe): Don't grab guard mutex when in select loop.  select()/read() is
racy by design so there is no need to worry about a race in select().
(fhandler_base::ready_for_read): Remove unused argument.
(fhandler_tty_slave::ready_for_read): Ditto.
* syscalls.cc (_read): Eliminate third argument in ready_for_read call.
@
text
@d662 8
d678 1
a678 1
      s->verify = verify_ok;
d1450 7
a1463 1
      s->verify = verify_ok;
d1465 1
@


1.60
log
@* fhandler.cc (fhandler_base::read): Return just read ahead characters if slow
device.
* fhandler.h (fhandler_base::set_eof): New virtual method.
(fhandler_pipe::set_eof): New method.
* pipe.cc (fhandler_pipe::fhandler_pipe): Clear saweof flag.
(fhandler_pipe::read): Return immediately if hit eof.
(fhandler_pipe::hit_eof): Return true if saweof flag is set.
* select.cc (peek_pipe): Don't call PeekNamedPipe if we couldn't grab the guard
mutex.
@
text
@d91 1
a91 1
      (s)->saw_error = TRUE; \
d213 1
a213 1
    always_ready = TRUE;
d216 1
a216 1
    windows_used = TRUE;
a222 12
/* Poll every fd in the select chain.  Set appropriate fd in mask. */
int
select_stuff::poll (fd_set *readfds, fd_set *writefds, fd_set *exceptfds)
{
  int n = 0;
  select_record *s = &start;
  while ((s = s->next))
    n += s->poll (s, readfds, writefds, exceptfds);
  select_printf ("returning %d", n);
  return n;
}

d293 1
a293 1
	  gotone = TRUE;
d347 13
d386 1
a386 1
peek_pipe (select_record *s, int ignra)
d395 1
a395 1
  HANDLE guard_mutex = fh->get_guard ();
d420 1
a420 1
	  if (!ignra && fh->get_readahead_valid ())
d468 1
a468 1
	gotone += s->except_ready = TRUE;
d470 1
a470 1
	gotone += s->read_ready = TRUE;
d475 1
a475 1
      gotone += s->read_ready = TRUE;
d481 1
a481 1
	gotone = s->except_ready = TRUE;
d483 1
a483 1
	gotone += s->read_ready = TRUE;
a490 9
static int
poll_pipe (select_record *me, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds)
{
  return peek_pipe (me, 0) ?
	 set_bits (me, readfds, writefds, exceptfds) :
	 0;
}

d512 2
a513 2
	    if (peek_pipe (s, 0))
	      gotone = TRUE;
d558 1
a558 1
      pi->stop_thread_pipe = TRUE;
a571 1
  s->poll = poll_pipe;
d574 2
a575 1
  s->read_selected = TRUE;
a586 1
      s->poll = poll_pipe;
d589 3
a591 2
  s->write_selected = TRUE;
  s->write_ready = TRUE;
d601 1
a601 1
  s->poll = poll_pipe;
d604 2
a605 1
  s->except_selected = TRUE;
d610 1
a610 1
peek_console (select_record *me, int ignra)
d618 1
a618 1
  if (!ignra && fh->get_readahead_valid ())
d652 1
a652 1
	else if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown == TRUE &&
a662 9
static int
poll_console (select_record *me, fd_set *readfds, fd_set *writefds,
	      fd_set *exceptfds)
{
  return peek_console (me, 0) ?
	 set_bits (me, readfds, writefds, exceptfds) :
	 0;
}

d670 1
a670 2
      s->poll = poll_console;
      s->verify = poll_console;
d676 2
a677 1
  s->read_selected = TRUE;
a687 1
      s->poll = poll_console;
d692 3
a694 2
  s->write_selected = TRUE;
  s->write_ready = TRUE;
a704 1
      s->poll = poll_console;
d709 3
a711 1
  s->except_selected = TRUE;
a748 1
  s->poll = poll_pipe;
d751 2
a752 1
  s->read_selected = TRUE;
d758 1
a758 1
fhandler_tty_slave::ready_for_read (int fd, DWORD howlong, int ignra)
d766 1
a766 1
  if (!ignra && get_readahead_valid ())
a797 1
      s->poll = set_bits;
d801 2
a802 2
  s->read_selected = TRUE;
  s->read_ready = TRUE;
a812 1
      s->poll = set_bits;
d816 2
a817 2
  s->write_selected = TRUE;
  s->write_ready = TRUE;
a827 1
      s->poll = set_bits;
d831 2
a832 2
  s->except_selected = TRUE;
  s->except_ready = TRUE;
d846 1
a846 1
peek_serial (select_record *s, int)
d946 1
a946 1
  s->saw_error = TRUE;
d963 2
a964 2
	    if (peek_serial (s, 0))
	      gotone = TRUE;
d1003 1
a1003 1
      si->stop_thread_serial = TRUE;
a1010 10
static int
poll_serial (select_record *me, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds)

{
  return peek_serial (me, 0) ?
	 set_bits (me, readfds, writefds, exceptfds) :
	 0;
}

a1017 1
      s->poll = poll_serial;
d1022 2
a1023 1
  s->read_selected = TRUE;
a1033 1
      s->poll = set_bits;
d1036 1
d1038 2
a1039 2
  s->write_selected = TRUE;
  s->write_ready = TRUE;
a1049 1
      s->poll = set_bits;
d1053 3
a1055 1
  s->except_selected = FALSE;	// Can't do this
d1060 1
a1060 1
fhandler_base::ready_for_read (int fd, DWORD howlong, int ignra)
d1069 1
a1069 1
      avail = me.read_ready ?: me.peek (&me, ignra);
a1106 1
      s->poll = set_bits;
d1110 2
a1111 2
  s->read_selected = TRUE;
  s->read_ready = TRUE;
a1121 1
      s->poll = set_bits;
d1125 2
a1126 2
  s->write_selected = TRUE;
  s->write_ready = TRUE;
a1136 1
      s->poll = set_bits;
d1140 2
a1141 1
  s->write_selected = TRUE;
d1155 1
a1155 1
peek_socket (select_record *me, int)
d1195 1
a1195 1
    me->read_ready = TRUE;
d1197 1
a1197 1
    me->write_ready = TRUE;
d1199 1
a1199 1
    me->except_ready = TRUE;
a1202 9
static int
poll_socket (select_record *me, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds)
{
  return peek_socket (me, 0) ?
	 set_bits (me, readfds, writefds, exceptfds) :
	 0;
}

d1224 1
a1224 1
	      s->read_ready = TRUE;
d1229 1
a1229 1
	      s->write_ready = TRUE;
d1234 1
a1234 1
	      s->except_ready = TRUE;
a1376 1
      s->poll = poll_socket;
d1382 2
a1383 1
  s->read_selected = TRUE;
a1393 1
      s->poll = poll_socket;
d1397 1
d1399 2
a1400 1
  s->write_selected = TRUE;
a1410 1
      s->poll = poll_socket;
d1414 1
d1417 1
a1417 1
  s->except_selected = TRUE;
d1422 1
a1422 1
peek_windows (select_record *me, int)
d1433 1
a1433 1
      me->read_ready = TRUE;
a1441 10
static int
poll_windows (select_record *me, fd_set *readfds, fd_set *writefds,
	      fd_set *exceptfds)
{

  return peek_windows (me, 0) ?
	 set_bits (me, readfds, writefds, exceptfds) :
	 0;
}

d1449 1
a1449 2
      s->poll = poll_windows;
      s->verify = poll_windows;
d1452 2
d1455 1
a1455 3
  s->read_selected = TRUE;
  s->h = get_handle ();
  s->windows_handle = TRUE;
a1465 1
      s->poll = set_bits;
d1468 1
d1470 3
a1472 3
  s->write_selected = TRUE;
  s->write_ready = TRUE;
  s->windows_handle = TRUE;
a1482 1
      s->poll = set_bits;
d1485 1
d1487 3
a1489 3
  s->except_selected = TRUE;
  s->except_ready = TRUE;
  s->windows_handle = TRUE;
@


1.59
log
@* dll_init.h (class dll_list): Reorder functions to avoid compiler "can't
inline" warnings.
* security.h (class cygsid): Ditto.
* sigproc.cc (get_proc_lock): Ditto.
* sigproc.h (class sigframe): Ditto.
* sync.h (class muto): Ditto.
* fhandler.h (fhandler_base::get_guard): Actually MAKE virtual as previously
indicated.
* pipe.cc (make_pipe): Remove extraneous set_errno.
* syscalls.cc (_open): Ditto.
* select.cc (peek_pipe): Need to check that there is still something to read
from the pipe after acquiring the mutex since another process/thread could have
eaten the input before we got to acquiring the lock.  (Thanks to Nick Duffek
for this inspiration.)
@
text
@a391 1
  HANDLE guard_mutex = fh->get_guard ();
d394 1
d441 9
a449 1
  else if (n && guard_mutex)
a450 6
      if (WaitForSingleObject (guard_mutex, 0) != WAIT_OBJECT_0)
	{
	  select_printf ("%s, couldn't get mutex %p, %E", fh->get_name (),
			 guard_mutex);
	  n = 0;
	}
d452 1
a452 1
         in and grabbed the data that we originally saw. */
d464 1
@


1.58
log
@* fhandler.h: Change Windows 'BOOL's to c++ 'bool's for all variables.
* select.cc (fhandler_base::ready_for_read): Set read_ready to zero prior to
testing it or it will be uninitialized.
* Makefile.in (CFLAGS): Move setting to Makefile.common.
@
text
@d392 1
a392 1
  HANDLE guard_mutex = s->fh->get_guard ();
d441 1
a441 2
  else if (n && guard_mutex
	   && WaitForSingleObject (guard_mutex, 0) != WAIT_OBJECT_0)
d443 15
a457 3
      select_printf ("%s, couldn't get mutex %p, %E", fh->get_name (),
	  	     guard_mutex);
      n = 0;
@


1.57
log
@* cygheap.h (cygheap_fdmanip::isopen): Set appropriate errno if fd not open.
* select.cc (fhandler_base::ready_for_read): Release an open guard mutex when
exiting with an error condition.
* syscalls.cc (_read): Check frequently for closed fd as a kludge until
something better is invented.
@
text
@d1077 1
@


1.56
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d1105 3
@


1.55
log
@* select.cc (MAKEready): Remove extraneous select_read.
@
text
@a86 18
/* Make a fhandler_foo::ready_for_ready method.
   Assumption: The "ready_for_read" methods are called with one level of
   signal blocking. */
#define MAKEready(what) \
int \
fhandler_##what::ready_for_read (int fd, DWORD howlong, int ignra) \
{ \
  select_record me (this); \
  me.fd = fd; \
  while (select_read (&me) && !me.read_ready && \
         !peek_##what (&me, ignra) && howlong == INFINITE) \
    if (fd >= 0 && cygheap->fdtab.not_open (fd)) \
      break; \
    else if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0) \
      break; \
  return me.read_ready; \
}

d385 1
a385 1
peek_pipe (select_record *s, int ignra, HANDLE guard_mutex = NULL)
d392 1
a484 15
int
fhandler_pipe::ready_for_read (int fd, DWORD howlong, int ignra)
{
  select_record me (this);
  me.fd = fd;
  (void) select_read (&me);
  while (!peek_pipe (&me, ignra, guard) && howlong == INFINITE)
    if (fd >= 0 && cygheap->fdtab.not_open (fd))
      break;
    else if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0)
      break;
  select_printf ("returning %d", me.read_ready);
  return me.read_ready;
}

d567 1
a664 2
MAKEready (console)

d677 1
a715 15
int
fhandler_tty_common::ready_for_read (int fd, DWORD howlong, int ignra)
{
  select_record me (this);
  me.fd = fd;
  (void) select_read (&me);
  while (!peek_pipe (&me, ignra) && howlong == INFINITE)
    if (fd >= 0 && cygheap->fdtab.not_open (fd))
      break;
    else if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0)
      break;
  select_printf ("returning %d", me.read_ready);
  return me.read_ready;
}

d751 1
d762 5
d776 3
d783 2
a784 2
    case WAIT_OBJECT_0:
    case WAIT_TIMEOUT:
d786 2
a1024 2
MAKEready (serial)

d1036 1
d1073 1
a1073 1
fhandler_base::ready_for_read (int, DWORD, int)
d1075 32
a1106 1
  return 1;
a1222 2
MAKEready (socket)

d1401 1
a1470 2
MAKEready (windows)

d1481 1
@


1.54
log
@* fhandler.h (fhandler_serial::fhandler_serial): Change to only accept unit
argument.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
(fhandler_serial::open): Avoid else when previous clause is a return().
* path.cc (get_devn): Alias /dev/ttyS0 -> /dev/com1, etc.
(get_device_number): Reallow standalone "com1" as a valid name for /dev/com1.
@
text
@a95 1
  (void) select_read (&me); \
@


1.53
log
@* select.cc (MAKEready): Check for read_ready in loop since select_read could
set it.
(peek_socket): Check ready/write/except specifically since they could have been
set even prior to peek_socket call.
@
text
@d355 1
a355 1
	   fd_set *exceptfds)
@


1.52
log
@* autoload.cc (load_wsock32): Declare dummy function to force loading of
winsock.
* fhandler.cc (fhandler_base::set_inheritance): Make debugging output more
verbose.
* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Force loading of
winsock32 if winsock2 not available.
* net.cc (set_socket_inheritance): Use DuplicateHandle in all cases to set
inheritance correctly.
(fdsock): Use winsock2_active macro to determine when to set socket
inheritance.  Remove fdtab resource locking since this function should already
be protected.
(cygwin_accept): Simplify logic.  Ensure that fdtab unlock is not called
inappropriately.
(cygwin_rcmd): Use fdtab locking.
(cygwin_rresvport): Ditto.
(cygwin_rexec): Ditto.
* select.cc (peek_socket): Set errno appropriately if winsock select fails.
* winsup.h: Declare check_pty_fds.
* syscalls.cc (check_pty_fds): Rename from check_ttys_fds.  Also check pty
master.
(setsid): Use check_pty_fds.
* dtable.cc (dtable::dec_console_fds): Add check on pty fds.
@
text
@d97 2
a98 1
  while (!peek_##what (&me, ignra) && howlong == INFINITE) \
a1179 1
  int gotone = 0;
d1213 1
a1213 1
    gotone = me->read_ready = TRUE;
d1215 1
a1215 1
    gotone = me->write_ready = TRUE;
d1217 2
a1218 2
    gotone = me->except_ready = TRUE;
  return gotone;
@


1.51
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d1208 1
@


1.50
log
@* select.cc (peek_pipe): REALLY only grab mutex when we actually got something
from the pipe.
@
text
@d39 1
@


1.49
log
@* select.cc (fhandler_tty_common::ready_for_read): Rewrite to correctly
call peek_pipe.
@
text
@d457 2
a458 1
  else if (guard_mutex && WaitForSingleObject (guard_mutex, 0) != WAIT_OBJECT_0)
@


1.48
log
@* select.cc (peek_pipe): Only grab mutex when we actually got something from
the pipe.
@
text
@d499 1
d749 10
a758 6
#if 0
  if (myself->pgid && get_ttyp ()->getpgid () != myself->pgid &&
	myself->ctty == ttynum) // background process?
    return 1;	// Yes. Let read return an error
#endif
  return ((fhandler_pipe*)this)->fhandler_pipe::ready_for_read (fd, howlong, ignra);
@


1.48.2.1
log
@Merged changes from HEAD
@
text
@a498 1

d748 6
a753 10
  select_record me (this);
  me.fd = fd;
  (void) select_read (&me);
  while (!peek_pipe (&me, ignra) && howlong == INFINITE)
    if (fd >= 0 && cygheap->fdtab.not_open (fd))
      break;
    else if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0)
      break;
  select_printf ("returning %d", me.read_ready);
  return me.read_ready;
@


1.48.2.2
log
@Merged changes from HEAD
@
text
@d457 1
a457 2
  else if (n && guard_mutex
	   && WaitForSingleObject (guard_mutex, 0) != WAIT_OBJECT_0)
@


1.48.2.3
log
@Merged changes from HEAD
@
text
@a38 1
#include "path.h"
@


1.48.2.4
log
@Merged changes from HEAD
@
text
@d87 18
d109 2
a110 2
      (s)->saw_error = true; \
      set_sig_errno (EBADF); \
d231 1
a231 1
    always_ready = true;
d234 1
a234 1
    windows_used = true;
d241 12
d271 1
a271 1
	  set_sig_errno (EINVAL);
a317 4
      /* Some types of object (e.g., consoles) wake up on "inappropriate" events
	 like mouse movements.  The verify function will detect these situations.
	 If it returns false, then this wakeup was a false alarm and we should go
	 back to waiting. */
d323 1
a323 1
	  gotone = true;
d354 1
a354 1
	  fd_set *exceptfds)
d368 1
a368 1
  if (me->except_selected && me->except_ready)
a376 13
/* Poll every fd in the select chain.  Set appropriate fd in mask. */
int
select_stuff::poll (fd_set *readfds, fd_set *writefds, fd_set *exceptfds)
{
  int n = 0;
  select_record *s = &start;
  while ((s = s->next))
    n += (!s->peek || s->peek (s, true)) ?
	 set_bits (s, readfds, writefds, exceptfds) : 0;
  select_printf ("returning %d", n);
  return n;
}

d403 1
a403 1
peek_pipe (select_record *s, bool from_select)
a411 9
  /* pipes require a guard mutex to guard against the situation where multiple
     readers are attempting to read from the same pipe.  In this scenario, it
     is possible for PeekNamedPipe to report available data to two readers but
     only one will actually get the data.  This will result in the other reader
     entering fhandler_base::raw_read and blocking indefinitely in an interruptible
     state.  This causes things like "make -j2" to hang.  So, for the non-select case
     we use the pipe mutex, if it is available. */
  HANDLE guard_mutex = from_select ? NULL : fh->get_guard ();

d431 1
a431 1
	      gotone = s->read_ready = true;
d436 1
a436 1
	  if (fh->get_readahead_valid ())
d439 1
a439 1
	      gotone = s->read_ready = true;
d446 1
a446 1
	  gotone = s->read_ready = true;
d458 2
a459 3
  else if (!n || !guard_mutex)
    /* no guard mutex or nothing to read fromt he pipe. */;
  else if (WaitForSingleObject (guard_mutex, 0) != WAIT_OBJECT_0)
d462 1
a462 1
		     guard_mutex);
a464 12
  else
    {
      /* Now that we have the mutex, make sure that no one else has snuck
	 in and grabbed the data that we originally saw. */
      if (!PeekNamedPipe (h, NULL, 0, NULL, (DWORD *) &n, NULL))
	{
	  select_printf ("%s, PeekNamedPipe failed, %E", fh->get_name ());
	  n = -1;
	}
      if (n <= 0)
	ReleaseMutex (guard_mutex);	/* Oops.  We lost the race.  */
    }
a467 1
      fh->set_eof ();		/* Flag that other end of pipe is gone */
d470 1
a470 1
	gotone += s->except_ready = true;
d472 1
a472 1
	gotone += s->read_ready = true;
d477 1
a477 1
      gotone += s->read_ready = true;
d483 1
a483 1
	gotone = s->except_ready = true;
d485 1
a485 1
	gotone += s->read_ready = true;
d493 24
d538 2
a539 2
	    if (peek_pipe (s, true))
	      gotone = true;
d584 1
a584 1
      pi->stop_thread_pipe = true;
d598 1
a598 1
  s->peek = peek_pipe;
d600 1
a600 2
  s->read_selected = true;
  s->read_ready = false;
d612 1
d615 2
a616 3
  s->peek = peek_pipe;
  s->write_selected = true;
  s->write_ready = true;
d626 1
a626 1
  s->peek = peek_pipe;
d629 1
a629 2
  s->except_selected = true;
  s->except_ready = false;
d634 1
a634 1
peek_console (select_record *me, bool)
d642 1
a642 1
  if (fh->get_readahead_valid ())
d645 1
a645 1
      return me->read_ready = true;
d662 1
a662 1
      return me->read_ready = true;
d674 1
a674 1
	      return me->read_ready = true;
d676 1
a676 1
	else if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown == true &&
d678 1
a678 1
	  return me->read_ready = true;
d688 2
a689 2
verify_console (select_record *me, fd_set *rfds, fd_set *wfds,
	      fd_set *efds)
d691 3
a693 1
  return peek_console (me, true);
d696 1
d705 2
a706 1
      s->verify = verify_console;
a709 1
  s->peek = peek_console;
d711 1
a711 2
  s->read_selected = true;
  s->read_ready = false;
d722 1
d727 2
a728 3
  s->peek = peek_console;
  s->write_selected = true;
  s->write_ready = true;
d739 1
d744 1
a744 3
  s->peek = peek_console;
  s->except_selected = true;
  s->except_ready = false;
d748 15
d786 1
a786 1
    me->read_ready = true;
d797 1
a797 1
  s->peek = peek_pipe;
d799 1
a799 2
  s->read_selected = true;
  s->read_ready = false;
d805 1
a805 1
fhandler_tty_slave::ready_for_read (int fd, DWORD howlong)
d808 1
a808 6
  if (cygheap->fdtab.not_open (fd))
    {
      set_sig_errno (EBADF);
      return 0;
    }
  if (get_readahead_valid ())
a816 3
    case WAIT_OBJECT_0:
      set_sig_errno (EINTR);
      return 0;
d821 2
a822 2
      set_sig_errno (EINVAL); /* FIXME: correct errno? */
      return 0;
a823 2
      if (!howlong)
	set_sig_errno (EAGAIN);
d835 1
d839 2
a840 2
  s->read_selected = true;
  s->read_ready = true;
d851 1
d855 2
a856 2
  s->write_selected = true;
  s->write_ready = true;
d867 1
d871 2
a872 2
  s->except_selected = true;
  s->except_ready = true;
d886 1
a886 1
peek_serial (select_record *s, bool)
d888 1
d894 1
a894 1
    return s->read_ready = true;
d913 1
d918 1
a918 1
      if (!ClearCommError (h, &fh->ev, &st))
d924 3
a926 3
	return s->read_ready = true;
      else if (WaitCommEvent (h, &fh->ev, &fh->io_status))
	return s->read_ready = true;
d946 1
a946 1
      if (!ClearCommError (h, &fh->ev, &st))
d955 1
a955 1
	  return s->read_ready = true;
d986 1
a986 1
  s->saw_error = true;
d1003 2
a1004 2
	    if (peek_serial (s, true))
	      gotone = true;
d1043 1
a1043 1
      si->stop_thread_serial = true;
d1051 12
d1070 1
d1074 1
a1074 3
  s->peek = peek_serial;
  s->read_selected = true;
  s->read_ready = false;
d1085 1
a1087 1
  s->peek = peek_serial;
d1089 2
a1090 2
  s->write_selected = true;
  s->write_ready = true;
d1101 1
d1105 1
a1105 3
  s->peek = peek_serial;
  s->except_selected = false;	// Can't do this
  s->except_ready = false;
d1110 1
a1110 1
fhandler_base::ready_for_read (int fd, DWORD howlong)
d1112 1
a1112 35
  int avail = 0;
  select_record me (this);
  me.fd = fd;
  while (!avail)
    {
      (void) select_read (&me);
      avail = me.read_ready ?: me.peek (&me, false);

      if (fd >= 0 && cygheap->fdtab.not_open (fd))
	{
	  set_sig_errno (EBADF);
	  avail = 0;
	  break;
	}

      if (howlong != INFINITE)
	{
	  if (!avail)
	    set_sig_errno (EAGAIN);
	  break;
	}

      if (WaitForSingleObject (signal_arrived, avail ? 0 : 10) == WAIT_OBJECT_0)
	{
	  set_sig_errno (EINTR);
	  avail = 0;
	  break;
	}
    }

  if (get_guard () && !avail && me.read_ready)
    ReleaseMutex (get_guard ());

  select_printf ("read_ready %d, avail %d", me.read_ready, avail);
  return avail;
d1122 1
d1126 2
a1127 2
  s->read_selected = true;
  s->read_ready = true;
d1138 1
d1142 2
a1143 2
  s->write_selected = true;
  s->write_ready = true;
d1154 1
d1158 1
a1158 2
  s->except_selected = true;
  s->except_ready = false;
d1172 1
a1172 1
peek_socket (select_record *me, bool)
d1179 1
a1207 1
      set_winsock_errno ();
d1212 1
a1212 1
    me->read_ready = true;
d1214 1
a1214 1
    me->write_ready = true;
d1216 11
a1226 2
    me->except_ready = true;
  return me->read_ready || me->write_ready || me->except_ready;
d1229 2
d1252 1
a1252 1
	      s->read_ready = true;
d1257 1
a1257 1
	      s->write_ready = true;
d1262 1
a1262 1
	      s->except_ready = true;
d1405 1
a1408 1
  s->peek = peek_socket;
d1410 1
a1410 1
  s->read_selected = true;
d1421 1
a1424 1
  s->peek = peek_socket;
d1426 1
a1426 1
  s->write_selected = true;
d1437 1
a1440 1
  s->peek = peek_socket;
d1443 1
a1443 1
  s->except_selected = true;
d1448 1
a1448 1
peek_windows (select_record *me, bool)
d1459 1
a1459 1
      me->read_ready = true;
d1469 2
a1470 2
verify_windows (select_record *me, fd_set *rfds, fd_set *wfds,
		fd_set *efds)
d1472 4
a1475 1
  return peek_windows (me, true);
d1478 2
d1487 2
a1489 4
  s->verify = verify_windows;
  s->peek = peek_windows;
  s->read_selected = true;
  s->read_ready = false;
d1491 3
a1493 1
  s->windows_handle = true;
d1504 1
a1506 1
  s->peek = peek_windows;
d1508 3
a1510 3
  s->write_selected = true;
  s->write_ready = true;
  s->windows_handle = true;
d1521 1
a1523 1
  s->peek = peek_windows;
d1525 3
a1527 3
  s->except_selected = true;
  s->except_ready = true;
  s->windows_handle = true;
@


1.48.2.5
log
@Merged changes from HEAD
@
text
@d455 1
a455 1
    /* no guard mutex or nothing to read from the pipe. */;
@


1.48.2.6
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d42 1
@


1.48.2.7
log
@Merged changes from HEAD
@
text
@a338 2
      if (me->except_on_write && me->fh->get_device () == FH_SOCKET)
        ((fhandler_socket *) me->fh)->set_connect_state (CONNECTED);
d341 1
a341 1
  if ((me->except_selected || me->except_on_write) && me->except_ready)
d343 1
a343 8
      if (me->except_on_write) /* Only on sockets */
        {
	  UNIX_FD_SET (me->fd, writefds);
	  if (me->fh->get_device () == FH_SOCKET)
	    ((fhandler_socket *) me->fh)->set_connect_state (CONNECTED);
        }
      if (me->except_selected)
	UNIX_FD_SET (me->fd, exceptfds);
d1183 1
a1183 1
  if (me->read_selected && !me->read_ready)
d1189 1
a1189 1
  if (me->write_selected && !me->write_ready)
d1195 1
a1195 1
  if ((me->except_selected || me->except_on_write) && !me->except_ready)
d1201 7
a1207 19
  int r;
  if ((me->read_selected && !me->read_ready)
      || (me->write_selected && !me->write_ready)
      || ((me->except_selected || me->except_on_write) && !me->except_ready))
    {
      r = WINSOCK_SELECT (0, &ws_readfds, &ws_writefds, &ws_exceptfds, &tv);
      select_printf ("WINSOCK_SELECT returned %d", r);
      if (r == -1)
	{
	  select_printf ("error %d", WSAGetLastError ());
	  set_winsock_errno ();
	  return 0;
	}
      if (WINSOCK_FD_ISSET (h, &ws_readfds) || (me->read_selected && me->read_ready))
	me->read_ready = true;
      if (WINSOCK_FD_ISSET (h, &ws_writefds) || (me->write_selected && me->write_ready))
	me->write_ready = true;
      if (WINSOCK_FD_ISSET (h, &ws_exceptfds) || ((me->except_selected || me->except_on_write) && me->except_ready))
	me->except_ready = true;
d1209 7
d1283 1
a1283 1
	if (s->read_selected && !s->read_ready)
d1288 1
a1288 1
	if (s->write_selected && !s->write_ready)
d1293 1
a1293 1
	if ((s->except_selected || s->except_on_write) && !s->except_ready)
d1413 1
a1413 1
  s->write_ready = saw_shutdown_write () || is_unconnected ();
a1414 5
  if (is_connect_pending ())
    {
      s->except_ready = saw_shutdown_write () || saw_shutdown_read ();
      s->except_on_write = true;
    }
@


1.48.2.8
log
@Merged changes from HEAD
@
text
@d664 1
a664 1
	  fh->tc->kill_pgrp (SIGWINCH);
@


1.48.2.9
log
@Merged changes from HEAD
@
text
@a44 1
#include "cygthread.h"
d515 1
a515 1
    cygthread *thread;
d559 1
a559 1
      me->h = *((pipeinf *) stuff->device_specific[FHDEVN(FH_PIPE)])->thread;
d565 1
a565 2
  pi->thread = new cygthread (thread_pipe, (LPVOID)pi, "select_pipe");
  me->h = *pi->thread;
d579 2
a580 1
      pi->thread->detach ();
d868 1
a868 1
    cygthread *thread;
d1010 1
a1010 1
      me->h = *((serialinf *) stuff->device_specific[FHDEVN(FH_SERIAL)])->thread;
d1016 3
a1018 2
  si->thread = new cygthread (thread_serial, (LPVOID)si, "select_serial");
  me->h = *si->thread;
d1030 2
a1031 1
      si->thread->detach ();
d1172 1
a1172 1
    cygthread *thread;
d1283 1
a1283 1
      me->h = *si->thread;
d1352 3
a1354 3
  si->thread = new cygthread (thread_socket, (LPVOID)si, "select_socket");
  me->h = *si->thread;
  return 1;
d1390 1
a1390 1
      si->thread->detach ();
d1393 1
@


1.48.2.10
log
@Merged changes from HEAD
@
text
@d664 5
a668 1
	if (irec.EventType == KEY_EVENT)
d670 1
a670 3
	    if (irec.Event.KeyEvent.bKeyDown
		&& (irec.Event.KeyEvent.uChar.AsciiChar
		    || get_nonascii_key (irec, tmpbuf)))
d673 3
a675 9
	else
	  {
	    fh->send_winch_maybe ();
	    if (irec.EventType == MOUSE_EVENT
		&& fh->mouse_aware ()
		&& (irec.Event.MouseEvent.dwEventFlags == 0
		    || irec.Event.MouseEvent.dwEventFlags == DOUBLE_CLICK))
		return me->read_ready = true;
	  }
@


1.48.2.11
log
@Merged changes from HEAD
@
text
@d790 34
@


1.48.2.12
log
@Merged changes from HEAD
@
text
@d74 1
a74 1
  ((unsigned) (NULL_fd_set->fds_bits + unix_howmany ((n), UNIX_NFDBITS)))
d1293 1
a1293 1
  int sin_len = sizeof (si->sin);
d1343 2
a1344 2
      (void) setsockopt (s, SOL_SOCKET, SO_LINGER, (char *)&tmp, sizeof (tmp));
      (void) setsockopt (si->exitsock, SOL_SOCKET, SO_LINGER, (char *)&tmp, sizeof (tmp));
@


1.47
log
@* fhandler.h (fhandler_pipe::hit_eof): New method.
(writepipe_exists): New class element.
(orig_pid): Ditto.
(id): Ditto.
(is_slow): Eliminate.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance on
writepipe_exists, if it exists.
(fhandler_pipe::hit_eof): New method, modelled after tty.
(fhandler_pipe::dup): Duplicate writepipe_exists, if it exists.
(make_pipe): Set up a dummy event for pipes on windows 9x.  The nonexistence
of this event means that the write side of the pipe has closed.
(_dup): Move to syscalls.cc
(_dup2): Ditto.

* dtable.cc (dtable::build_fhandler): Fill out set_names here, if appropriate.
* syscalls.cc (_open): Call set_names in build_fhandler.
@
text
@d452 5
a461 5
    }
  else if (!PeekNamedPipe (h, NULL, 0, NULL, (DWORD *) &n, NULL))
    {
      select_printf ("%s, PeekNamedPipe failed, %E", fh->get_name ());
      n = -1;
@


1.46
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@a422 5
      if (fh->bg_check (SIGTTIN) <= bg_eof)
	{
	  gotone = s->read_ready = 1;
	  goto out;
	}
d441 6
@


1.45
log
@* cygwin.sc: New file -- linker script for building cygwin DLL.
* Makefile.in: Use linker script to control location of cygheap.
* cygheap.cc (buckets): Make static.
(init_cheap): Remove special iswinnt handling.  Allocate cygheap at a fixed
location.  Display more info when allocation fails.
(cygheap_fixup_in_child): Try harder to move cygheap to correct location.
Display more info when allocation fails.
* fhandler.h (fhandler_socket): Add macros for tracking socket shutdown state.
* net.cc (cygwin_shutdown): Set appropriate shutdown value for future use.
* select.cc (select_stuff::cleanup): New method.
(cygwin_select): Call cleanup explicitly to avoid a race.
(select_stuff:~select_stuff): Call cleanup chain via cleanup method.
(fhandler_socket::select_read): Set *_ready when shutdown has been called on
the socket.
(fhandler_socket::select_write): Ditto.
(fhandler_socket::select_except): Ditto.
* winsup.h: Move NO_COPY to "COMMON" section.
* autoload.cc (wsock_started): Avoid initializing NO_COPY value.
* sigproc.cc: Remove initialization from NO_COPY variables.
(sigproc_init): Initialize sig_loop_wait here, rather than via initialization.
(subproc_init): Initialize proc_loop_wait here, rather than via initialization.
@
text
@a125 8
#if 0
  if (n > FD_SETSIZE)
    {
      set_errno (EINVAL);
      return -1;
    }
#endif

d402 1
a402 1
peek_pipe (select_record *s, int ignra)
d449 9
a457 2
  if (fh->get_device() != FH_PIPEW &&
      !PeekNamedPipe (h, NULL, 0, NULL, (DWORD *) &n, NULL))
d498 14
a511 2

MAKEready(pipe)
@


1.44
log
@        * select.cc (select_read): Add setting read_ready flag.
        (select_write): Add setting write_ready flag.
@
text
@d184 1
d191 4
a194 2
/* Cleanup */
select_stuff::~select_stuff ()
d201 5
a205 1
      s->cleanup (s, this);
d207 5
d1390 1
d1406 1
d1422 2
@


1.43
log
@oops
@
text
@d809 1
d825 1
@


1.42
log
@* dir.cc (rmdir): Report ENOENT when file doesn't exist rather than ENOTDIR.
@
text
@d171 1
a171 2
      if (readfds != dummy_readfds && writefds != dummy_writefds && exceptfds != dummy_exceptfds &&
      WaitForSingleObject (signal_arrived, ms) == WAIT_OBJECT_0)
d483 3
a485 6
  int doit = me->read_ready || me->write_ready || me->except_ready;

  if (!doit)
    peek_pipe (me, 0);

  return doit ? set_bits (me, readfds, writefds, exceptfds) : 0;
d1191 3
a1193 6
  int doit = me->read_ready || me->write_ready || me->except_ready;

  if (!doit)
    peek_socket (me, 0);

  return doit ? set_bits (me, readfds, writefds, exceptfds) : 0;
@


1.41
log
@* select.cc (cygwin_select): Ensure that arguments are zeroed on timeout.
(select_stuff::wait): Ditto.
@
text
@d171 2
a172 1
      if (WaitForSingleObject (signal_arrived, ms) == WAIT_OBJECT_0)
d484 6
a489 3
  return peek_pipe (me, 0) ?
	 set_bits (me, readfds, writefds, exceptfds) :
	 0;
d1195 6
a1200 3
  return peek_socket (me, 0) ?
	 set_bits (me, readfds, writefds, exceptfds) :
	 0;
@


1.40
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d162 6
d177 1
a177 1
      return 0;
d179 1
a179 7

  /* Allocate some fd_set structures using the number of fds as a guide. */
  fd_set *r = allocfd_set (maxfds);
  fd_set *w = allocfd_set (maxfds);
  fd_set *e = allocfd_set (maxfds);

  if (sel.always_ready || ms == 0)
d181 1
a181 1
  else if (sel.wait (r, w, e, ms))
d187 1
a187 1
  return sel.poll (readfds, writefds, exceptfds);
d257 1
d306 1
d343 2
a344 2
  select_printf ("returning 0");
  return 0;
@


1.39
log
@forced commit
@
text
@d37 1
@


1.38
log
@* exceptions.cc (handle_exceptions): Break out of "loop" if the debugger
doesn't seem to be attaching to our process.
@
text
@@


1.37
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d1337 1
@


1.36
log
@* net.cc (cygwin_socket): Set SO_LINGER to small value so closed UNIX domain
sockets will not stay around.
* select.cc (socket_cleanup): Set SO_LINGER to small value so closed dummy
sockets do not stay around.  Use correct value for second argument to shutdown.
@
text
@d39 1
d96 1
a96 1
    if (fd >= 0 && fdtab.not_open (fd)) \
d105 1
a105 1
  if (fdtab.not_open ((s)->fd)) \
d215 1
a215 1
  if (UNIX_FD_ISSET (i, readfds) && (s = fdtab.select_read (i, s)) == NULL)
d217 1
a217 1
  if (UNIX_FD_ISSET (i, writefds) && (s = fdtab.select_write (i, s)) == NULL)
d219 1
a219 1
  if (UNIX_FD_ISSET (i, exceptfds) && (s = fdtab.select_except (i, s)) == NULL)
@


1.35
log
@* dtable.cc: Guard against new winsock.h/winsock2.h warnings when mixing
winsock*.h and sys/types.h.
* fhandler_socket.cc: Ditto.
* net.cc: Ditto.
* select.cc: Ditto.
* exceptions.cc: Remove unneeded define.
@
text
@d1332 5
d1346 1
a1346 1
      shutdown (s, 2);
d1351 1
a1351 1
      shutdown (si->exitsock, 2);
@


1.34
log
@Fix spacing, copyrights.
@
text
@a20 1
#define Win32_Winsock
d33 1
d69 1
a69 1
#define NULL_fd_set ((fd_set *)NULL)
@


1.33
log
@* fhandler.h (fhandler_tty_slave): Declare new methods.
* select.cc (fhandler_tty_slave::select_read): New method.
* select.cc (fhandler_tty_slave::ready_for_read): Ditto.
* select.cc (verify_tty_slave): New function.
* fhandler_termios.cc (fhandler_termios::line_edit): Empty input
buffer on signal.
* fhandler_tty.cc (fhandler_tty_slave::read): Check for input data
after reading from pipe. Reset event if input pipe is empty.
* tty.h (class tty): Allow creating events with manual reset.
* tty.cc (tty::get_event): Use manual_reset flag.
* tty.cc (tty::common_init): Create input_available_event with
manual reset.
@
text
@d785 1
a785 1
      select_printf ( "wait failed %E" );
@


1.32
log
@Update copyrights.
@
text
@d746 47
@


1.31
log
@* select.cc (peek_console): Don't report read_ready on mouse events unless we
are looking for mouse events.
* fhandler.h (fhandler_console::mouse_aware): New method.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Red Hat, Inc.
@


1.30
log
@* autoload.cc (LoadDLLinitfunc): Remove debugging statement.
* exceptions.cc (sig_handle_tty_stop): Move setting of PID_STOPPED to earlier
in interrupt.
((interrupt_setup): i.e., here.
(sig_handle): Don't queue multiple SIGSTOPS.
* fhandler.h (bg_check_types): Enumerate return value of bg_check for clarity.
* signal.cc (kill_pgrp): Minor cleanup.
* fhandler_termios.cc (fhandler_termios::bg_check): Use enumerated type for
function return.  Don't raise signal if a signal is already queued.
* fhandler_console.cc (fhandler_console::read): Use enumerated return type for
bg_check.
* select.cc: Ditto, throughout.
* read.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
(_read): YA interrupt detect simplification.
* wait.cc (wait4): Ditto.
@
text
@d641 4
a644 1
	  return me->read_ready = 1;
@


1.29
log
@* fhandler_console.cc (read): Add support for xterm-style mouse event
reporting.
(fhandler_console::char_command): Honor mouse events.
(fhandler_console::open): Enable mouse input events.
(fhandler_console::input_tcsetattr): Ditto.
* select.cc (peek_console): Add check for mouse events.
@
text
@d415 1
a415 1
      if (fh->bg_check (SIGTTIN) <= 0)
d630 1
a630 1
    if (fh->bg_check (SIGTTIN) <= 0)
@


1.28
log
@* select.cc (peek_pipe): Deal with pending newline in pty_master.
@
text
@d638 4
@


1.27
log
@* sigproc.h (sigframe::set): Eliminate second argument.  Default bp to current
frame pointer rather than using this within the function, which is unstable
when this method is not inlined.
* net.cc: Eliminate use of second argument to sigframe.set throughout.
* select.cc (cygwin_select): Ditto.
* sigproc.cc (sig_send): Ditto.
@
text
@d421 1
a421 2
      if (!ignra && fh->get_device () != FH_PTYM && fh->get_device () != FH_TTYM &&
	  fh->get_readahead_valid ())
d423 15
a437 3
	  select_printf ("readahead");
	  gotone = s->read_ready = 1;
	  goto out;
@


1.26
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d122 1
a122 1
  sigframe thisframe (mainthread, 0);
@


1.25
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d42 1
@


1.24
log
@* select.cc (cygwin_select): Correct logic for "always_ready" fds or when there
is no wait specified.
* syslog.cc (pass_handler::set_message): Zero the buffer prior to setting it.
@
text
@d844 4
a847 4
        {
          debug_printf ("ClearCommError");
          goto err;
        }
@


1.23
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d176 3
a178 2
  /* Don't bother waiting if one of the selected fds is "always ready". */
  if ((!sel.always_ready || ms != 0) && sel.wait (r, w, e, ms))
@


1.22
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d36 2
d39 3
a41 1
#include "cygerrno.h"
@


1.21
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d37 1
@


1.20
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d36 1
@


1.19
log
@* winsup.h: Change strchr inline for strange gcc problem.
* select.cc (select_stuff::wait): Bounds check w4 array.
@
text
@d88 1
a88 1
    if (fd >= 0 && dtable.not_open (fd)) \
d97 1
a97 1
  if (dtable.not_open ((s)->fd)) \
d206 1
a206 1
  if (UNIX_FD_ISSET (i, readfds) && (s = dtable.select_read (i, s)) == NULL)
d208 1
a208 1
  if (UNIX_FD_ISSET (i, writefds) && (s = dtable.select_write (i, s)) == NULL)
d210 1
a210 1
  if (UNIX_FD_ISSET (i, exceptfds) && (s = dtable.select_except (i, s)) == NULL)
@


1.18
log
@* select.cc (allocfd_set): Zero allocated fd_set.
(cygwin_select): Move fd_set copying logic from ::wait to here.  Use common
return through sell.poll.
(select_stuff::wait): Just return success or failure and let caller fill in
fd_set.
* pinfo.h (pinfo): Eliminate self-referential pointer to sidbuf since pinfo
structure exists at random locations now.
* fork.cc (fork): Use 'use_psid' element to control when the psid is relevant.
* shared.cc (sec_user): Ditto.
* spawn.cc (spawn_guts): Ditto.
* uinfo.cc (internal_getlogin): Ditto.
* syscall.cc (seteuid): Ditto.  Set use_psid element.
@
text
@d253 5
@


1.17
log
@* select.cc (fhandler_console::select_read): Call set_cursor_maybe since select
may block and cursor may not be visible.
* select.cc (fhandler_console::select_write): Ditto.
* select.cc (fhandler_console::select_except): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
d74 1
a74 1
#define allocfd_set(n) ((fd_set *) alloca (sizeof_fd_set (n)))
d108 2
a109 2
cygwin_select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
		     struct timeval *to)
d112 3
a114 3
  fd_set *dummy_readfds = allocfd_set (n);
  fd_set *dummy_writefds = allocfd_set (n);
  fd_set *dummy_exceptfds = allocfd_set (n);
d125 1
a125 1
  select_printf ("%d, %p, %p, %p, %p", n, readfds, writefds, exceptfds, to);
d128 1
a128 4
    {
      UNIX_FD_ZERO (dummy_readfds, n);
      readfds = dummy_readfds;
    }
d130 1
a130 4
    {
      UNIX_FD_ZERO (dummy_writefds, n);
      writefds = dummy_writefds;
    }
d132 1
a132 4
    {
      UNIX_FD_ZERO (dummy_exceptfds, n);
      exceptfds = dummy_exceptfds;
    }
d134 1
a134 1
  for (int i = 0; i < n; i++)
d165 13
a177 12
  /* If one of the selected fds is "always ready" just poll everything and return
     the result.  There is no need to wait. */
  if (sel.always_ready || ms == 0)
    {
      UNIX_FD_ZERO (readfds, n);
      UNIX_FD_ZERO (writefds, n);
      UNIX_FD_ZERO (exceptfds, n);
      return sel.poll (readfds, writefds, exceptfds);
    }

  /* Wait for an fd to come alive */
  return sel.wait (readfds, writefds, exceptfds, ms);
a267 1
  int n = m - 1;
d270 1
a270 8
  /* Allocate some fd_set structures using the number of fds as a guide. */
  fd_set *r = allocfd_set (n);
  fd_set *w = allocfd_set (n);
  fd_set *e = allocfd_set (n);
  UNIX_FD_ZERO (r, n);
  UNIX_FD_ZERO (w, n);
  UNIX_FD_ZERO (e, n);
  debug_printf ("n %d, ms %u", n, ms);
d300 1
a300 1
	    s->verify (s, r, w, e))
d326 2
a327 5
  copyfd_set (readfds, r, n);
  copyfd_set (writefds, w, n);
  copyfd_set (exceptfds, e, n);

  return poll (readfds, writefds, exceptfds);
@


1.16
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d664 1
d681 1
d698 1
@


1.15
log
@* fhandler_console.cc: Remove VK_DIVIDE detection.
(get_nonascii_key): Simplify previous patch to return ascii char if it is
non-zero.  Add a second "temporary buffer" argument to help with thread safety.
* select.cc (peek_console): Pass a temporary buffer argument to
get_nonascii_key.
@
text
@d23 1
d29 2
a33 3
#include "winsup.h"
#include <wingdi.h>
#include <winuser.h>
@


1.14
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d600 1
a600 1
  extern const char * get_nonascii_key (INPUT_RECORD& input_rec);
d621 1
d634 1
a634 1
		 (irec.Event.KeyEvent.uChar.AsciiChar || get_nonascii_key (irec)))
@


1.13
log
@* testsuite/winsup.api/winsup.exp: ignore stdout by default
* testsuite/winsup.api/crlf.c: non-verbose by default

* winsup.h: prune out windows headers we don't normally need
* assert.cc: add wingdi.h and winuser.h
* fhandler_console.cc: ditto
* fhandler_windows.cc: ditto
* select.cc: ditto
* spawn.cc: ditto
* strace.cc: ditto
* tty.cc: ditto
* window.cc: ditto
* hinfo.cc: add winsock.h
* syscalls.cc: add winnls.h
* uinfo.cc: ditto

* include/windows.h: optimize non-inclusion of repeat headers
@
text
@d28 3
a33 3
#include <netdb.h>
#include <unistd.h>
#include <stdio.h>
@


1.13.2.1
log
@* fhandler_console.cc: Remove VK_DIVIDE detection.
(get_nonascii_key): Simplify previous patch to return ascii char if it is
non-zero.  Add a second "temporary buffer" argument to help with thread safety.
* select.cc (peek_console): Pass a temporary buffer argument to
get_nonascii_key.
@
text
@d600 1
a600 1
  extern const char * get_nonascii_key (INPUT_RECORD& input_rec, char *);
a620 1
  char tmpbuf[17];
d633 1
a633 1
		 (irec.Event.KeyEvent.uChar.AsciiChar || get_nonascii_key (irec, tmpbuf)))
@


1.13.2.2
log
@* select.cc (fhandler_console::select_read): Call set_cursor_maybe since select
may block and cursor may not be visible.
* select.cc (fhandler_console::select_write): Ditto.
* select.cc (fhandler_console::select_except): Ditto.
* environ.cc (cur_environ): Give "C" linkage.
* winsup.h: Ditto.
* winsup.cc: Change include ordering.
@
text
@a663 1
      set_cursor_maybe ();
a679 1
      set_cursor_maybe ();
a695 1
      set_cursor_maybe ();
@


1.12
log
@* select.cc (socket_cleanup): Shutdown I/O on dummy sockets prior to closing
them.
@
text
@d29 2
@


1.11
log
@* select.cc (thread_pipe): Add paranoid check to ensure thread termination.
* external.cc: Eliminate obsolete include.
* getopt.c (getopt_long): Fix compiler warning.
* shared.h: Moved PID_ definitions to include/sys/cygwin so that they can be
used by external programs.
* include/sys/cygwin.h: Move external definitions here.  Include sys/resource.h
to avoid having to do this everywhere.
@
text
@d1276 1
d1281 1
@


1.10
log
@* path.cc (mount_info::cygdrive_posix_path): Don't add trailing slash if
referring to something like c:\.
* dcrt0.cc (dll_crt0_1): Move uinfo initialization prior to sig_send
initialization to give signal thread a chance to finish.
* debug.cc (WFSO): Move to sigproc.cc
(WFMO): Ditto.
* exceptions.cc (interruptible): Allocate slightly more space for directory
just for paranoia's sake.
(call_handler): Eliminate nonmain argument.  Determine if main thread has set a
frame pointer and use it if so.
(sig_handle): Eliminate nonmain argument.
* net.cc: Record frame information in appropriate routines throughout.
* select.cc (select): Ditto.
* sigproc.cc: Use sigthread structure to record mainthread id throughout.
(sig_send): Record frame information for signal handler.
(wait_sig): Reflect argument change in sig_handle.
(WFSO): Move here and record frame information for signal handler.
(WFMO): Ditto.
* sigproc.h: Implement new "sigthread" class.  Implement "sigframe" class for
manipulating signal frame info.
* thread.cc (__pthread_kill): Use standard _kill() function rather than calling
sig_send directly.
* winsup.h: Eliminate ebp element from signal_dispatch class.
@
text
@d508 6
@


1.9
log
@* dcrt0.cc (build_argv): Remove unneeded variable.
* select.cc (peek_pipe): Don't check for "ready" if it's already set.
(peek_console): Ditto.
(peek_serial): Ditto.
(peek_socket): Ditto.
(peek_windows): Ditto.
@
text
@d113 1
@


1.8
log
@Add a debugging line.
@
text
@d412 6
d603 6
d792 8
d866 1
d1102 1
a1102 1
  if (WINSOCK_FD_ISSET (h, &ws_readfds))
d1104 1
a1104 1
  if (WINSOCK_FD_ISSET (h, &ws_writefds))
d1106 1
a1106 1
  if (WINSOCK_FD_ISSET (h, &ws_exceptfds))
d1332 4
@


1.7
log
@* fhandler.h (select_stuff): Eliminate use of 'total'.
* select.cc (cygwin_select): Ditto.
(select_stuff::wait): Use maximum size for w4 rather than calculating what will
fit.
@
text
@d454 1
@


1.6
log
@* fhandler.h (select_record): Explicitly zero elements of this class.
(select_stuff): Ditto.
* select.cc (cygwin_select): Eliminate memset zero of sel.
@
text
@d157 1
a157 1
  select_printf ("sel.total %d, sel.always_ready %d", sel.total, sel.always_ready);
d160 1
a160 1
  if (sel.total == 0)
a227 1
  total++;
d249 1
a249 1
  HANDLE w4[total + 1];
@


1.5
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@a123 1
  memset (&sel, 0, sizeof (sel));
@


1.4
log
@* fhandler.cc (fhandler_base::get_readahead_into_buffer): New function.
* fhandler.h: Declare new function.  Add extra argument to
process_slave_output.
* fhandler_console.cc (fhandler_console::read): Move read ahead code to new
function.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Move common code
here.
(fhandler_tty_slave::read): Understand readahead.
(fhandler_pty_master::read): Move code to process_slave_output.
* select.cc (peek_pipe): Avoid performing certain checks when non-read and on
inappropriate fh types.
@
text
@d429 2
a430 1
  if (!PeekNamedPipe (h, NULL, 0, NULL, (DWORD *) &n, NULL))
@


1.3
log
@Respond to more g++ warnings relating to initializing structures.
@
text
@d412 1
a412 1
  if (s->read_selected && fh->bg_check (SIGTTIN) <= 0)
d414 5
a418 3
      gotone = s->read_ready = 1;
      goto out;
    }
d420 7
a426 5
  if (!ignra && fh->get_readahead_valid ())
    {
      select_printf ("readahead");
      gotone = s->read_ready = 1;
      goto out;
d429 1
a429 1
  else if (!PeekNamedPipe (h, NULL, 0, NULL, (DWORD *) &n, NULL))
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d1041 1
a1041 1
  struct timeval tv = {0};
@


1.1
log
@Initial revision
@
text
@d374 1
a374 2
verify_true (select_record *me, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds)
d387 1
a387 1
no_startup (select_record *me, select_stuff *stuff)
d524 1
a524 1
pipe_cleanup (select_record *me, select_stuff *stuff)
d904 1
a904 1
serial_cleanup (select_record *me, select_stuff *stuff)
d1227 1
a1227 1
socket_cleanup (select_record *me, select_stuff *stuff)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
