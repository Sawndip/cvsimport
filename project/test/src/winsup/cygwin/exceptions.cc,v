head	1.446;
access;
symbols
	cygwin-1_7_35-release:1.446
	cygwin-1_7_34-release:1.446
	cygwin-1_7_33-release:1.432.2.9
	cygwin-1_7_32-release:1.432.2.8
	cygwin-1_7_31-release:1.432.2.8
	cygwin-1_7_30-release:1.432.2.7
	cygwin-1_7_29-release:1.432.2.6
	cygwin-1_7_29-release-branchpoint:1.432.0.2
	cygwin-pre-user-db:1.432
	cygwin-1_7_28-release:1.432
	cygwin-1_7_27-release:1.430
	cygwin-1_7_26-release:1.430
	cygwin-1_7_25-release:1.429
	cygwin-1_7_24-release:1.429
	cygwin-1_7_23-release:1.429
	cygwin-1_7_22-release:1.429
	cygwin-1_7_21-release:1.424
	cygwin-1_7_20-release:1.420
	cygwin-1_7_19-release:1.419
	cygwin-64bit-postmerge:1.417
	cygwin-64bit-premerge-branch:1.416.0.2
	cygwin-64bit-premerge:1.416
	cygwin-1_7_18-release:1.416
	post-ptmalloc3:1.391.2.17
	pre-ptmalloc3:1.391.2.17
	cygwin-1_7_17-release:1.397
	cygwin-64bit-branch:1.391.0.2
	cygwin-1_7_16-release:1.386
	cygwin-1_7_15-release:1.376
	cygwin-1_7_14_2-release:1.376
	cygwin-1_7_14-release:1.376
	cygwin-1_7_12-release:1.376
	cygwin-1_7_11-release:1.375
	cygwin-1_7_10-release:1.373
	signal-rewrite:1.360.0.2
	pre-notty:1.355
	cygwin-1_7_9-release:1.351
	cv-post-1_7_9:1.351.0.2
	cygwin-1_7_8-release:1.351
	cygwin-1_7_7-release:1.350
	cygwin-1_7_5-release:1.342
	cygwin-1_7_4-release:1.342
	cygwin-1_7_3-release:1.342
	cygwin-1_7_2-release:1.342
	fifo_doover3:1.339.0.2
	cygwin-1_7_1-release:1.337
	prefifo:1.333
	cv-branch-2:1.331.0.2
	pre-ripout-set_console_state_for_spawn:1.323
	EOL_registry_mounts:1.321
	preoverlapped:1.301
	drop_9x_support_start:1.300
	cr-0x5f1:1.297.0.2
	cv-branch:1.295.0.2
	pre-ptymaster-archetype:1.293
	cr-0x3b58:1.278.0.4
	cr-0x5ef:1.278.0.2
	after-mmap-privanon-noreserve:1.263
	after-mmap-revamp:1.263
	before-mmap-revamp:1.263
	cgf-more-exit-sync:1.258
	post_wait_sig_exit:1.251
	pre_wait_sig_exit:1.247
	reparent-point:1.220
	noreparent:1.220.0.2
	cr-0x5e6:1.215.0.2
	cr-0x9e:1.193.0.4
	cr-0x9d:1.193.0.2
	cgf-deleteme:1.192.0.2
	pre-sigrewrite:1.174
	corinna-01:1.173
	cr-0x9c:1.167.2.1.0.2
	cr-0x9b:1.167.0.2
	cr-0x99:1.163
	Z-emcb-cygwin_daemon:1.160.0.2
	w32api-2_2:1.141
	mingw-runtime-2_4:1.141
	pre-cgf-merge:1.169
	cgf-dev-branch:1.139.0.2
	predaemon:1.112
	cygwin_daemon_merge_HEAD:1.112
	pregp02r1:1.111.0.2
	cygnus_cvs_20020108_pre:1.103
	Z-cygwin_daemon_merge-new_HEAD:1.123
	Z-cygwin_daemon_merge_HEAD:1.123
	cygwin_daemon:1.97.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.446
date	2014.11.28.20.46.13;	author corinna;	state Exp;
branches;
next	1.445;

1.445
date	2014.08.22.09.21.30;	author corinna;	state Exp;
branches;
next	1.444;

1.444
date	2014.07.09.10.41.11;	author corinna;	state Exp;
branches;
next	1.443;

1.443
date	2014.07.09.10.21.05;	author corinna;	state Exp;
branches;
next	1.442;

1.442
date	2014.07.07.19.58.15;	author corinna;	state Exp;
branches;
next	1.441;

1.441
date	2014.06.23.13.23.14;	author corinna;	state Exp;
branches;
next	1.440;

1.440
date	2014.05.19.10.28.54;	author corinna;	state Exp;
branches;
next	1.439;

1.439
date	2014.04.09.19.20.01;	author corinna;	state Exp;
branches;
next	1.438;

1.438
date	2014.03.29.21.16.09;	author cgf;	state Exp;
branches;
next	1.437;

1.437
date	2014.03.28.22.31.53;	author corinna;	state Exp;
branches;
next	1.436;

1.436
date	2014.03.28.16.56.03;	author corinna;	state Exp;
branches;
next	1.435;

1.435
date	2014.03.19.16.08.21;	author corinna;	state Exp;
branches;
next	1.434;

1.434
date	2014.03.18.13.51.18;	author corinna;	state Exp;
branches;
next	1.433;

1.433
date	2014.03.04.11.56.42;	author corinna;	state Exp;
branches;
next	1.432;

1.432
date	2014.01.08.16.51.20;	author cgf;	state Exp;
branches
	1.432.2.1;
next	1.431;

1.431
date	2013.12.09.20.32.23;	author cgf;	state Exp;
branches;
next	1.430;

1.430
date	2013.11.24.12.13.33;	author corinna;	state Exp;
branches;
next	1.429;

1.429
date	2013.07.20.17.11.44;	author cgf;	state Exp;
branches;
next	1.428;

1.428
date	2013.07.20.16.19.51;	author cgf;	state Exp;
branches;
next	1.427;

1.427
date	2013.07.19.23.19.27;	author cgf;	state Exp;
branches;
next	1.426;

1.426
date	2013.07.19.23.13.58;	author cgf;	state Exp;
branches;
next	1.425;

1.425
date	2013.07.19.23.04.32;	author cgf;	state Exp;
branches;
next	1.424;

1.424
date	2013.06.08.16.54.41;	author cgf;	state Exp;
branches;
next	1.423;

1.423
date	2013.06.08.14.38.19;	author cgf;	state Exp;
branches;
next	1.422;

1.422
date	2013.06.07.17.09.56;	author cgf;	state Exp;
branches;
next	1.421;

1.421
date	2013.06.07.16.05.12;	author cgf;	state Exp;
branches;
next	1.420;

1.420
date	2013.06.06.15.29.41;	author corinna;	state Exp;
branches;
next	1.419;

1.419
date	2013.06.02.09.11.09;	author corinna;	state Exp;
branches;
next	1.418;

1.418
date	2013.04.30.23.47.01;	author cgf;	state Exp;
branches;
next	1.417;

1.417
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.416;

1.416
date	2013.04.09.01.01.19;	author cgf;	state Exp;
branches;
next	1.415;

1.415
date	2013.03.31.12.35.44;	author cgf;	state Exp;
branches;
next	1.414;

1.414
date	2013.03.28.16.14.53;	author cgf;	state Exp;
branches;
next	1.413;

1.413
date	2013.03.09.21.55.18;	author cgf;	state Exp;
branches;
next	1.412;

1.412
date	2013.03.01.16.28.09;	author cgf;	state Exp;
branches;
next	1.411;

1.411
date	2013.03.01.15.48.14;	author cgf;	state Exp;
branches;
next	1.410;

1.410
date	2013.01.31.05.26.46;	author cgf;	state Exp;
branches;
next	1.409;

1.409
date	2013.01.23.05.27.36;	author cgf;	state Exp;
branches;
next	1.408;

1.408
date	2013.01.21.17.17.44;	author cgf;	state Exp;
branches;
next	1.407;

1.407
date	2013.01.21.04.34.50;	author cgf;	state Exp;
branches;
next	1.406;

1.406
date	2013.01.19.05.57.06;	author cgf;	state Exp;
branches;
next	1.405;

1.405
date	2013.01.14.06.03.58;	author cgf;	state Exp;
branches;
next	1.404;

1.404
date	2013.01.09.16.25.15;	author corinna;	state Exp;
branches;
next	1.403;

1.403
date	2013.01.02.18.34.06;	author cgf;	state Exp;
branches;
next	1.402;

1.402
date	2012.12.28.18.06.17;	author cgf;	state Exp;
branches;
next	1.401;

1.401
date	2012.12.07.20.59.44;	author cgf;	state Exp;
branches;
next	1.400;

1.400
date	2012.12.07.17.37.32;	author cgf;	state Exp;
branches;
next	1.399;

1.399
date	2012.12.07.17.23.22;	author cgf;	state Exp;
branches;
next	1.398;

1.398
date	2012.12.04.20.26.18;	author cgf;	state Exp;
branches;
next	1.397;

1.397
date	2012.08.17.17.29.21;	author cgf;	state Exp;
branches;
next	1.396;

1.396
date	2012.08.17.15.56.05;	author cgf;	state Exp;
branches;
next	1.395;

1.395
date	2012.08.16.17.11.41;	author cgf;	state Exp;
branches;
next	1.394;

1.394
date	2012.08.15.19.07.41;	author cgf;	state Exp;
branches;
next	1.393;

1.393
date	2012.08.15.18.50.44;	author cgf;	state Exp;
branches;
next	1.392;

1.392
date	2012.08.15.16.34.59;	author cgf;	state Exp;
branches;
next	1.391;

1.391
date	2012.08.09.19.58.52;	author cgf;	state Exp;
branches
	1.391.2.1;
next	1.390;

1.390
date	2012.08.03.15.38.59;	author cgf;	state Exp;
branches;
next	1.389;

1.389
date	2012.07.30.03.44.40;	author cgf;	state Exp;
branches;
next	1.388;

1.388
date	2012.07.29.21.43.29;	author cgf;	state Exp;
branches;
next	1.387;

1.387
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.386;

1.386
date	2012.07.04.06.06.54;	author cgf;	state Exp;
branches;
next	1.385;

1.385
date	2012.07.03.05.31.11;	author cgf;	state Exp;
branches;
next	1.384;

1.384
date	2012.07.02.02.24.24;	author cgf;	state Exp;
branches;
next	1.383;

1.383
date	2012.06.28.14.06.06;	author corinna;	state Exp;
branches;
next	1.382;

1.382
date	2012.06.27.16.24.54;	author corinna;	state Exp;
branches;
next	1.381;

1.381
date	2012.06.19.00.52.59;	author cgf;	state Exp;
branches;
next	1.380;

1.380
date	2012.06.19.00.38.01;	author cgf;	state Exp;
branches;
next	1.379;

1.379
date	2012.06.19.00.31.14;	author cgf;	state Exp;
branches;
next	1.378;

1.378
date	2012.06.17.20.50.23;	author cgf;	state Exp;
branches;
next	1.377;

1.377
date	2012.06.03.02.26.58;	author cgf;	state Exp;
branches;
next	1.376;

1.376
date	2012.03.29.05.45.49;	author cgf;	state Exp;
branches;
next	1.375;

1.375
date	2012.02.12.22.43.33;	author cgf;	state Exp;
branches;
next	1.374;

1.374
date	2012.02.09.16.05.23;	author cgf;	state Exp;
branches;
next	1.373;

1.373
date	2011.12.17.07.01.19;	author cgf;	state Exp;
branches;
next	1.372;

1.372
date	2011.12.17.00.03.30;	author cgf;	state Exp;
branches;
next	1.371;

1.371
date	2011.12.16.05.27.14;	author cgf;	state Exp;
branches;
next	1.370;

1.370
date	2011.12.13.20.06.30;	author cgf;	state Exp;
branches;
next	1.369;

1.369
date	2011.12.13.04.11.45;	author cgf;	state Exp;
branches;
next	1.368;

1.368
date	2011.12.10.01.33.56;	author cgf;	state Exp;
branches;
next	1.367;

1.367
date	2011.12.08.06.17.49;	author cgf;	state Exp;
branches;
next	1.366;

1.366
date	2011.12.07.13.54.54;	author cgf;	state Exp;
branches;
next	1.365;

1.365
date	2011.12.04.17.58.23;	author cgf;	state Exp;
branches;
next	1.364;

1.364
date	2011.11.26.19.14.22;	author cgf;	state Exp;
branches;
next	1.363;

1.363
date	2011.11.26.02.35.49;	author cgf;	state Exp;
branches;
next	1.362;

1.362
date	2011.11.14.01.29.47;	author cgf;	state Exp;
branches;
next	1.361;

1.361
date	2011.10.28.17.32.38;	author cgf;	state Exp;
branches;
next	1.360;

1.360
date	2011.08.03.16.40.47;	author yselkowitz;	state Exp;
branches;
next	1.359;

1.359
date	2011.07.13.17.53.21;	author cgf;	state Exp;
branches;
next	1.358;

1.358
date	2011.07.06.18.44.06;	author cgf;	state Exp;
branches;
next	1.357;

1.357
date	2011.07.06.18.14.22;	author cgf;	state Exp;
branches;
next	1.356;

1.356
date	2011.07.06.16.33.30;	author cgf;	state Exp;
branches;
next	1.355;

1.355
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.354;

1.354
date	2011.06.01.01.47.51;	author cgf;	state Exp;
branches;
next	1.353;

1.353
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.352;

1.352
date	2011.04.17.19.56.25;	author cgf;	state Exp;
branches;
next	1.351;

1.351
date	2010.10.24.15.26.05;	author cgf;	state Exp;
branches;
next	1.350;

1.350
date	2010.08.28.08.51.21;	author corinna;	state Exp;
branches;
next	1.349;

1.349
date	2010.08.18.14.22.07;	author corinna;	state Exp;
branches;
next	1.348;

1.348
date	2010.08.01.19.10.52;	author cgf;	state Exp;
branches;
next	1.347;

1.347
date	2010.07.18.20.13.26;	author cgf;	state Exp;
branches;
next	1.346;

1.346
date	2010.06.29.10.28.40;	author corinna;	state Exp;
branches;
next	1.345;

1.345
date	2010.06.01.14.51.47;	author corinna;	state Exp;
branches;
next	1.344;

1.344
date	2010.05.18.14.30.50;	author cgf;	state Exp;
branches;
next	1.343;

1.343
date	2010.04.20.10.44.52;	author corinna;	state Exp;
branches;
next	1.342;

1.342
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.341;

1.341
date	2010.02.28.15.54.25;	author cgf;	state Exp;
branches;
next	1.340;

1.340
date	2010.02.26.21.36.31;	author cgf;	state Exp;
branches;
next	1.339;

1.339
date	2009.12.21.09.38.25;	author corinna;	state Exp;
branches;
next	1.338;

1.338
date	2009.12.18.20.32.03;	author corinna;	state Exp;
branches;
next	1.337;

1.337
date	2009.10.08.15.56.14;	author cgf;	state Exp;
branches;
next	1.336;

1.336
date	2009.10.06.03.39.38;	author cgf;	state Exp;
branches;
next	1.335;

1.335
date	2009.09.19.15.34.19;	author cgf;	state Exp;
branches;
next	1.334;

1.334
date	2009.09.18.21.27.02;	author cgf;	state Exp;
branches;
next	1.333;

1.333
date	2009.07.23.02.47.17;	author ericb;	state Exp;
branches;
next	1.332;

1.332
date	2009.07.18.20.25.06;	author cgf;	state Exp;
branches;
next	1.331;

1.331
date	2009.05.04.09.16.42;	author corinna;	state Exp;
branches;
next	1.330;

1.330
date	2009.01.03.05.12.20;	author cgf;	state Exp;
branches;
next	1.329;

1.329
date	2008.12.30.18.18.09;	author cgf;	state Exp;
branches;
next	1.328;

1.328
date	2008.11.29.02.41.38;	author cgf;	state Exp;
branches;
next	1.327;

1.327
date	2008.11.28.16.41.54;	author cgf;	state Exp;
branches;
next	1.326;

1.326
date	2008.11.28.02.56.09;	author cgf;	state Exp;
branches;
next	1.325;

1.325
date	2008.08.01.19.12.49;	author cgf;	state Exp;
branches;
next	1.324;

1.324
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.323;

1.323
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.322;

1.322
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.321;

1.321
date	2008.04.03.15.28.03;	author corinna;	state Exp;
branches;
next	1.320;

1.320
date	2008.03.27.01.50.39;	author cgf;	state Exp;
branches;
next	1.319;

1.319
date	2008.03.12.12.41.49;	author corinna;	state Exp;
branches;
next	1.318;

1.318
date	2008.03.02.22.51.19;	author cgf;	state Exp;
branches;
next	1.317;

1.317
date	2008.03.01.13.18.22;	author cgf;	state Exp;
branches;
next	1.316;

1.316
date	2008.02.28.17.57.42;	author corinna;	state Exp;
branches;
next	1.315;

1.315
date	2008.02.28.17.09.34;	author corinna;	state Exp;
branches;
next	1.314;

1.314
date	2008.02.28.15.50.51;	author corinna;	state Exp;
branches;
next	1.313;

1.313
date	2008.02.27.18.08.52;	author corinna;	state Exp;
branches;
next	1.312;

1.312
date	2008.02.27.17.16.46;	author cgf;	state Exp;
branches;
next	1.311;

1.311
date	2008.02.25.18.32.23;	author corinna;	state Exp;
branches;
next	1.310;

1.310
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.309;

1.309
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.308;

1.308
date	2008.02.13.09.42.22;	author corinna;	state Exp;
branches;
next	1.307;

1.307
date	2007.12.16.21.21.23;	author cgf;	state Exp;
branches;
next	1.306;

1.306
date	2007.12.12.12.12.23;	author corinna;	state Exp;
branches;
next	1.305;

1.305
date	2007.12.06.18.24.06;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2007.11.27.14.45.14;	author corinna;	state Exp;
branches;
next	1.303;

1.303
date	2007.07.29.05.22.05;	author cgf;	state Exp;
branches;
next	1.302;

1.302
date	2007.07.14.15.58.32;	author cgf;	state Exp;
branches;
next	1.301;

1.301
date	2007.02.23.10.51.58;	author corinna;	state Exp;
branches;
next	1.300;

1.300
date	2007.02.20.14.31.26;	author cgf;	state Exp;
branches;
next	1.299;

1.299
date	2007.02.20.00.16.14;	author cgf;	state Exp;
branches;
next	1.298;

1.298
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches
	1.297.2.1;
next	1.296;

1.296
date	2006.07.13.08.33.34;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2006.06.03.20.32.07;	author cgf;	state Exp;
branches
	1.295.2.1;
next	1.294;

1.294
date	2006.06.03.02.58.59;	author cgf;	state Exp;
branches;
next	1.293;

1.293
date	2006.05.28.15.50.13;	author cgf;	state Exp;
branches;
next	1.292;

1.292
date	2006.05.22.04.50.54;	author cgf;	state Exp;
branches;
next	1.291;

1.291
date	2006.04.18.16.24.54;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2006.03.22.03.20.28;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2006.03.20.01.11.30;	author cgf;	state Exp;
branches;
next	1.288;

1.288
date	2006.03.18.19.17.21;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2006.03.16.02.57.37;	author cgf;	state Exp;
branches;
next	1.286;

1.286
date	2006.03.13.21.10.14;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2006.02.28.20.02.16;	author cgf;	state Exp;
branches;
next	1.284;

1.284
date	2006.02.23.19.21.21;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2006.02.22.17.06.14;	author corinna;	state Exp;
branches;
next	1.282;

1.282
date	2006.02.20.02.04.31;	author cgf;	state Exp;
branches;
next	1.281;

1.281
date	2006.02.16.18.21.49;	author corinna;	state Exp;
branches;
next	1.280;

1.280
date	2006.02.06.18.24.06;	author cgf;	state Exp;
branches;
next	1.279;

1.279
date	2006.01.27.06.06.06;	author cgf;	state Exp;
branches;
next	1.278;

1.278
date	2006.01.02.02.57.54;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2006.01.01.17.15.01;	author cgf;	state Exp;
branches;
next	1.276;

1.276
date	2006.01.01.16.51.29;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2005.12.27.20.47.49;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2005.12.27.20.20.09;	author corinna;	state Exp;
branches;
next	1.273;

1.273
date	2005.12.27.20.07.59;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2005.12.23.22.50.20;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2005.12.20.00.31.50;	author cgf;	state Exp;
branches;
next	1.269;

1.269
date	2005.12.17.04.36.39;	author cgf;	state Exp;
branches;
next	1.268;

1.268
date	2005.12.07.11.16.47;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2005.12.05.20.20.17;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2005.12.03.05.01.51;	author cgf;	state Exp;
branches;
next	1.265;

1.265
date	2005.12.03.04.23.35;	author cgf;	state Exp;
branches;
next	1.264;

1.264
date	2005.12.01.20.52.00;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2005.11.25.19.53.52;	author cgf;	state Exp;
branches;
next	1.262;

1.262
date	2005.11.14.20.34.33;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2005.11.01.05.55.30;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2005.10.29.20.33.59;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2005.10.03.17.23.54;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2005.10.02.00.13.41;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2005.09.30.23.52.13;	author cgf;	state Exp;
branches;
next	1.255;

1.255
date	2005.09.26.14.58.16;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2005.09.26.14.51.47;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2005.09.26.13.23.47;	author cgf;	state Exp;
branches;
next	1.252;

1.252
date	2005.09.23.23.37.52;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2005.09.23.03.35.41;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2005.09.20.02.06.56;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2005.09.14.14.00.03;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2005.09.13.17.08.53;	author cgf;	state Exp;
branches;
next	1.247;

1.247
date	2005.09.08.14.58.15;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2005.09.07.03.10.17;	author cgf;	state Exp;
branches;
next	1.245;

1.245
date	2005.09.02.17.35.21;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2005.09.02.17.12.35;	author cgf;	state Exp;
branches;
next	1.243;

1.243
date	2005.09.02.04.51.09;	author cgf;	state Exp;
branches;
next	1.242;

1.242
date	2005.09.02.04.46.50;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2005.08.29.03.12.39;	author cgf;	state Exp;
branches;
next	1.240;

1.240
date	2005.08.28.23.26.23;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2005.08.28.17.30.33;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2005.08.25.03.12.48;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2005.08.23.22.22.52;	author cgf;	state Exp;
branches;
next	1.236;

1.236
date	2005.07.17.00.51.03;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2005.07.06.20.04.59;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2005.07.05.03.16.43;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2005.06.30.02.52.13;	author cgf;	state Exp;
branches;
next	1.231;

1.231
date	2005.06.09.05.11.51;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2005.05.18.23.30.02;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2005.04.14.17.34.03;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2005.04.05.04.30.58;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2005.04.03.08.45.17;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2005.03.27.01.57.37;	author cgf;	state Exp;
branches;
next	1.225;

1.225
date	2005.02.20.04.25.31;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2005.02.07.05.28.49;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2005.01.11.15.31.03;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2004.12.24.18.31.23;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2004.11.26.04.15.07;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2004.09.20.05.35.46;	author cgf;	state Exp;
branches
	1.220.2.1;
next	1.219;

1.219
date	2004.09.20.04.58.36;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.217;

1.217
date	2004.09.03.01.53.11;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2004.05.17.15.27.56;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2004.03.15.15.50.19;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2004.03.12.08.22.22;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2004.03.12.03.09.28;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2004.03.12.02.07.39;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2004.03.09.01.24.08;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2004.03.07.04.57.47;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2004.03.04.05.31.14;	author cgf;	state Exp;
branches;
next	1.207;

1.207
date	2004.02.26.05.10.47;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2004.02.21.22.57.36;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2004.02.14.04.38.37;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2004.02.13.19.34.32;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2004.02.12.03.01.57;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.201;

1.201
date	2004.02.08.19.59.27;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2004.02.01.18.29.11;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2004.01.26.22.25.57;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2004.01.26.18.52.02;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.196;

1.196
date	2004.01.23.15.44.15;	author cgf;	state Exp;
branches;
next	1.195;

1.195
date	2004.01.22.19.03.19;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.193;

1.193
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches
	1.193.4.1;
next	1.192;

1.192
date	2004.01.03.20.57.11;	author cgf;	state Exp;
branches
	1.192.2.1;
next	1.191;

1.191
date	2003.12.27.00.25.02;	author cgf;	state Exp;
branches;
next	1.190;

1.190
date	2003.12.26.18.26.17;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2003.12.17.22.47.32;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2003.12.16.23.28.02;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2003.12.14.16.55.24;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2003.12.14.07.09.22;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2003.12.07.03.27.51;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2003.12.07.02.56.52;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2003.12.07.02.33.31;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2003.12.06.18.08.37;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2003.12.05.04.20.48;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2003.12.03.05.21.55;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2003.11.30.02.19.45;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2003.11.29.00.26.40;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2003.11.28.22.13.57;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.173;

1.173
date	2003.11.04.15.48.18;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2003.10.14.09.21.55;	author corinna;	state Exp;
branches;
next	1.171;

1.171
date	2003.09.27.02.30.46;	author phumblet;	state Exp;
branches;
next	1.170;

1.170
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2003.09.16.03.07.27;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2003.09.13.17.14.15;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2003.09.12.06.41.53;	author cgf;	state Exp;
branches
	1.167.2.1;
next	1.166;

1.166
date	2003.09.10.17.26.12;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2003.09.09.03.11.31;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2003.09.03.14.15.55;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2003.09.01.02.05.32;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2003.08.31.18.26.58;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2003.08.30.20.43.06;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2003.08.29.02.05.00;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2003.08.28.02.04.16;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2003.08.22.19.25.56;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2003.08.22.17.01.53;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2003.08.20.18.09.24;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2003.08.20.05.15.33;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2003.08.20.02.31.26;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2003.08.19.04.10.41;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2003.08.19.00.31.56;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2003.06.12.12.36.07;	author corinna;	state Exp;
branches;
next	1.148;

1.148
date	2003.06.09.13.29.12;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2003.05.30.15.01.33;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2003.05.21.08.01.56;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2003.04.17.20.05.15;	author tpfaff;	state Exp;
branches;
next	1.144;

1.144
date	2003.03.31.21.27.06;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2003.03.20.01.34.53;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2003.02.14.02.52.29;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2003.02.07.15.00.57;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2003.01.14.19.55.42;	author tpfaff;	state Exp;
branches
	1.139.2.1;
next	1.138;

1.138
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2003.01.03.06.20.23;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2002.12.30.23.08.35;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2002.12.25.20.33.21;	author cgf;	state Exp;
branches
	1.135.4.1;
next	1.134;

1.134
date	2002.12.11.04.00.03;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2002.11.22.20.51.13;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2002.11.22.04.43.47;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2002.11.15.04.35.12;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2002.10.14.20.25.52;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2002.10.13.18.16.33;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2002.10.06.01.01.58;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2002.09.30.14.18.43;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2002.09.30.04.26.52;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2002.08.18.04.13.57;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2002.08.16.19.07.28;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2002.08.11.19.19.29;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2002.07.24.05.37.46;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2002.07.15.03.48.52;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2002.07.14.19.15.32;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2002.07.13.21.08.13;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2002.07.13.20.00.25;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2002.05.27.02.25.28;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2002.02.22.19.33.41;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2002.02.17.04.59.54;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2002.02.14.21.20.06;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2002.01.21.17.42.08;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2002.01.20.23.13.03;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2002.01.19.23.57.45;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2002.01.13.20.03.03;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2002.01.11.02.24.06;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2002.01.10.03.21.27;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2002.01.05.22.25.34;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2001.11.15.03.25.52;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2001.10.31.16.30.46;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2001.10.03.03.49.26;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches
	1.97.2.1;
next	1.96;

1.96
date	2001.09.12.05.09.24;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2001.09.12.01.56.32;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2001.09.06.18.06.27;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2001.09.05.02.42.49;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2001.07.26.00.10.52;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2001.06.28.02.19.57;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2001.06.24.22.26.50;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2001.06.24.21.57.50;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2001.06.16.17.09.19;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2001.06.10.16.00.23;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2001.05.24.05.20.17;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2001.05.11.05.11.12;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2001.05.08.15.16.48;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2001.05.05.05.07.20;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2001.05.05.02.44.36;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2001.05.04.21.02.15;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2001.05.04.20.39.38;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2001.05.03.15.00.38;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2001.04.30.03.09.18;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2001.04.28.23.48.27;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2001.04.27.18.50.59;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2001.04.25.19.11.37;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2001.04.09.00.44.25;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2001.04.02.00.18.29;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.04.01.05.38.08;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.04.01.05.24.20;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.04.01.00.06.17;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.03.20.19.50.27;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.03.19.22.48.26;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2001.03.11.01.58.23;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2001.03.10.23.37.50;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2001.03.07.06.19.34;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2001.03.02.02.09.40;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2001.01.27.03.02.15;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.01.27.02.23.46;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.01.17.14.57.09;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.01.12.05.38.25;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.01.08.04.02.01;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2000.12.27.00.13.57;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2000.12.26.03.21.05;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2000.12.20.06.03.16;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2000.12.20.05.57.59;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2000.11.16.05.16.59;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2000.11.15.06.27.48;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2000.11.13.04.06.40;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2000.11.06.23.12.05;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2000.11.06.06.36.32;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2000.11.05.03.08.39;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2000.11.02.02.15.02;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.25.17.57.43;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2000.10.24.02.25.26;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2000.10.19.17.57.28;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2000.10.18.04.53.37;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2000.10.14.05.52.38;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.12.22.15.47;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.09.02.53.44;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.05.04.53.17;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.18.02.20.42;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.16.02.36.10;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.11.00.25.57;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.07.01.18.37;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.29.02.06.49;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.02.19.26.01;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.29.16.24.37;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.26.20.36.19;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.26.20.13.27;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.04.19.07.35;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.03.20.14.06;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.01.05.57.54;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.30.00.38.51;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.20.05.52.33;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.17.05.49.51;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.07.03.29.08;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.26.05.13.32;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.20.21.33.58;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.08.04.13.12;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.09.21.04.05;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.05.06.34.54;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.28.05.05.33;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.26.01.11.54;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.24.19.54.01;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.24.06.45.32;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.04.07.13;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.432.2.1
date	2014.03.09.18.51.48;	author cgf;	state Exp;
branches;
next	1.432.2.2;

1.432.2.2
date	2014.03.18.13.51.30;	author corinna;	state Exp;
branches;
next	1.432.2.3;

1.432.2.3
date	2014.03.19.16.11.44;	author corinna;	state Exp;
branches;
next	1.432.2.4;

1.432.2.4
date	2014.03.28.20.58.58;	author corinna;	state Exp;
branches;
next	1.432.2.5;

1.432.2.5
date	2014.03.28.22.32.27;	author corinna;	state Exp;
branches;
next	1.432.2.6;

1.432.2.6
date	2014.03.29.21.15.45;	author cgf;	state Exp;
branches;
next	1.432.2.7;

1.432.2.7
date	2014.05.19.11.47.53;	author corinna;	state Exp;
branches;
next	1.432.2.8;

1.432.2.8
date	2014.07.15.14.34.37;	author corinna;	state Exp;
branches;
next	1.432.2.9;

1.432.2.9
date	2014.11.13.12.52.58;	author corinna;	state Exp;
branches;
next	;

1.391.2.1
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.391.2.2;

1.391.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.391.2.3;

1.391.2.3
date	2012.10.26.10.49.52;	author corinna;	state Exp;
branches;
next	1.391.2.4;

1.391.2.4
date	2012.10.30.17.31.02;	author corinna;	state Exp;
branches;
next	1.391.2.5;

1.391.2.5
date	2012.10.31.17.00.07;	author corinna;	state Exp;
branches;
next	1.391.2.6;

1.391.2.6
date	2012.12.05.09.38.37;	author corinna;	state Exp;
branches;
next	1.391.2.7;

1.391.2.7
date	2012.12.10.11.45.46;	author corinna;	state Exp;
branches;
next	1.391.2.8;

1.391.2.8
date	2012.12.10.12.19.45;	author corinna;	state Exp;
branches;
next	1.391.2.9;

1.391.2.9
date	2013.01.09.16.27.21;	author corinna;	state Exp;
branches;
next	1.391.2.10;

1.391.2.10
date	2013.01.14.12.57.04;	author corinna;	state Exp;
branches;
next	1.391.2.11;

1.391.2.11
date	2013.01.19.15.41.55;	author corinna;	state Exp;
branches;
next	1.391.2.12;

1.391.2.12
date	2013.01.21.13.52.04;	author corinna;	state Exp;
branches;
next	1.391.2.13;

1.391.2.13
date	2013.01.29.22.16.53;	author corinna;	state Exp;
branches;
next	1.391.2.14;

1.391.2.14
date	2013.02.05.15.30.11;	author corinna;	state Exp;
branches;
next	1.391.2.15;

1.391.2.15
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	1.391.2.16;

1.391.2.16
date	2013.02.25.12.44.29;	author corinna;	state Exp;
branches;
next	1.391.2.17;

1.391.2.17
date	2013.02.26.10.35.29;	author corinna;	state Exp;
branches;
next	1.391.2.18;

1.391.2.18
date	2013.02.28.10.03.29;	author corinna;	state Exp;
branches;
next	1.391.2.19;

1.391.2.19
date	2013.03.01.14.03.01;	author corinna;	state Exp;
branches;
next	1.391.2.20;

1.391.2.20
date	2013.03.01.16.32.32;	author corinna;	state Exp;
branches;
next	1.391.2.21;

1.391.2.21
date	2013.03.01.16.40.18;	author corinna;	state Exp;
branches;
next	1.391.2.22;

1.391.2.22
date	2013.03.11.08.59.19;	author corinna;	state Exp;
branches;
next	1.391.2.23;

1.391.2.23
date	2013.03.19.11.43.28;	author corinna;	state Exp;
branches;
next	1.391.2.24;

1.391.2.24
date	2013.03.29.09.12.13;	author corinna;	state Exp;
branches;
next	1.391.2.25;

1.391.2.25
date	2013.04.11.12.13.01;	author corinna;	state Exp;
branches;
next	;

1.297.2.1
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	1.297.2.2;

1.297.2.2
date	2007.11.29.11.14.52;	author corinna;	state Exp;
branches;
next	1.297.2.3;

1.297.2.3
date	2008.02.13.09.42.24;	author corinna;	state Exp;
branches;
next	1.297.2.4;

1.297.2.4
date	2008.02.18.14.08.37;	author corinna;	state Exp;
branches;
next	1.297.2.5;

1.297.2.5
date	2008.02.27.18.08.45;	author corinna;	state Exp;
branches;
next	1.297.2.6;

1.297.2.6
date	2008.02.28.17.58.11;	author corinna;	state Exp;
branches;
next	1.297.2.7;

1.297.2.7
date	2008.03.02.10.40.39;	author corinna;	state Exp;
branches;
next	1.297.2.8;

1.297.2.8
date	2008.03.05.18.17.39;	author corinna;	state Exp;
branches;
next	;

1.295.2.1
date	2006.07.13.08.34.54;	author corinna;	state Exp;
branches;
next	1.295.2.2;

1.295.2.2
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	1.295.2.3;

1.295.2.3
date	2006.07.18.13.58.51;	author corinna;	state Exp;
branches;
next	;

1.220.2.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	1.220.2.2;

1.220.2.2
date	2004.11.16.15.16.56;	author cgf;	state Exp;
branches;
next	1.220.2.3;

1.220.2.3
date	2004.11.18.00.48.40;	author cgf;	state Exp;
branches;
next	1.220.2.4;

1.220.2.4
date	2004.11.20.18.35.08;	author cgf;	state Exp;
branches;
next	;

1.193.4.1
date	2004.01.22.20.41.27;	author cgf;	state Exp;
branches;
next	1.193.4.2;

1.193.4.2
date	2004.01.23.15.46.42;	author cgf;	state Exp;
branches;
next	1.193.4.3;

1.193.4.3
date	2004.01.24.01.53.56;	author cgf;	state Exp;
branches;
next	1.193.4.4;

1.193.4.4
date	2004.01.24.03.52.43;	author cgf;	state Exp;
branches;
next	1.193.4.5;

1.193.4.5
date	2004.01.26.18.52.52;	author cgf;	state Exp;
branches;
next	1.193.4.6;

1.193.4.6
date	2004.01.26.22.28.57;	author cgf;	state Exp;
branches;
next	;

1.192.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	1.192.2.2;

1.192.2.2
date	2004.01.12.05.15.19;	author cgf;	state Exp;
branches;
next	1.192.2.3;

1.192.2.3
date	2004.01.13.05.13.23;	author cgf;	state Exp;
branches;
next	1.192.2.4;

1.192.2.4
date	2004.01.15.18.29.37;	author cgf;	state Exp;
branches;
next	1.192.2.5;

1.192.2.5
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	1.192.2.6;

1.192.2.6
date	2004.01.19.05.38.24;	author cgf;	state Exp;
branches;
next	;

1.167.2.1
date	2003.09.19.01.55.54;	author cgf;	state Exp;
branches;
next	;

1.139.2.1
date	2003.02.05.14.25.07;	author cgf;	state Exp;
branches;
next	1.139.2.2;

1.139.2.2
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.139.2.3;

1.139.2.3
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.139.2.4;

1.139.2.4
date	2003.03.21.15.15.18;	author cgf;	state Exp;
branches;
next	1.139.2.5;

1.139.2.5
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.139.2.6;

1.139.2.6
date	2003.05.10.17.20.52;	author cgf;	state Exp;
branches;
next	1.139.2.7;

1.139.2.7
date	2003.05.26.19.39.05;	author cgf;	state Exp;
branches;
next	1.139.2.8;

1.139.2.8
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.139.2.9;

1.139.2.9
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.139.2.10;

1.139.2.10
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.139.2.11;

1.139.2.11
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.139.2.12;

1.139.2.12
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	1.139.2.13;

1.139.2.13
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.139.2.14;

1.139.2.14
date	2003.09.14.01.35.37;	author cgf;	state Exp;
branches;
next	;

1.135.4.1
date	2003.01.01.18.16.37;	author cgf;	state Exp;
branches;
next	1.135.4.2;

1.135.4.2
date	2003.01.03.06.17.23;	author cgf;	state Exp;
branches;
next	;

1.97.2.1
date	2002.01.04.03.56.07;	author rbcollins;	state Exp;
branches;
next	1.97.2.2;

1.97.2.2
date	2002.01.15.12.52.50;	author rbcollins;	state Exp;
branches;
next	1.97.2.3;

1.97.2.3
date	2002.01.22.04.52.40;	author rbcollins;	state Exp;
branches;
next	1.97.2.4;

1.97.2.4
date	2002.02.28.12.53.23;	author rbcollins;	state Exp;
branches;
next	1.97.2.5;

1.97.2.5
date	2002.06.13.14.34.02;	author rbcollins;	state Exp;
branches;
next	1.97.2.6;

1.97.2.6
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.97.2.7;

1.97.2.7
date	2002.07.13.21.44.07;	author scottc;	state Exp;
branches;
next	1.97.2.8;

1.97.2.8
date	2002.07.14.19.26.23;	author scottc;	state Exp;
branches;
next	1.97.2.9;

1.97.2.9
date	2002.07.23.03.19.13;	author scottc;	state Exp;
branches;
next	1.97.2.10;

1.97.2.10
date	2002.07.26.19.03.36;	author scottc;	state Exp;
branches;
next	1.97.2.11;

1.97.2.11
date	2002.08.12.14.06.34;	author scottc;	state Exp;
branches;
next	1.97.2.12;

1.97.2.12
date	2002.08.16.21.46.48;	author scottc;	state Exp;
branches;
next	1.97.2.13;

1.97.2.13
date	2002.08.18.12.09.27;	author scottc;	state Exp;
branches;
next	1.97.2.14;

1.97.2.14
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.446
log
@	* cygheap.cc (init_cygheap::init_tls_list): Accommodate threadlist
	having a new type threadlist_t *.  Convert commented out code into an
	#if 0.  Create thread mutex.  Explain why.
	(init_cygheap::remove_tls): Drop timeout value.  Always wait infinitely
	for tls_sentry.  Return mutex HANDLE of just deleted threadlist entry.
	(init_cygheap::find_tls): New implementation taking tls pointer as
	search parameter.  Return threadlist_t *.
	(init_cygheap::find_tls): Return threadlist_t *.  Define ix as auto
	variable.  Drop exception handling since crash must be made impossible
	due to correct synchronization.  Return with locked mutex.
	* cygheap.h (struct threadlist_t): Define.
	(struct init_cygheap): Convert threadlist to threadlist_t type.
	(init_cygheap::remove_tls): Align declaration to above change.
	(init_cygheap::find_tls): Ditto.
	(init_cygheap::unlock_tls): Define.
	* cygtls.cc (_cygtls::remove): Unlock and close mutex when finishing.
	* exceptions.cc (sigpacket::process): Lock _cygtls area of thread before
	accessing it.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* sigproc.cc (sig_send): Ditto.
	* thread.cc (pthread::exit): Ditto.  Add comment.
	(pthread::cancel): Ditto.
@
text
@/* exceptions.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#define CYGTLS_HANDLE
#include "winsup.h"
#include "miscfuncs.h"
#include <imagehlp.h>
#include <stdlib.h>
#include <syslog.h>
#include <wchar.h>

#include "cygtls.h"
#include "pinfo.h"
#include "sigproc.h"
#include "shared_info.h"
#include "perprocess.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "child_info.h"
#include "ntdll.h"
#include "exception.h"

/* Definitions for code simplification */
#ifdef __x86_64__
# define _GR(reg)	R ## reg
# define _AFMT		"%011X"
# define _ADDR		DWORD64
#else
# define _GR(reg)	E ## reg
# define _AFMT		"%08x"
# define _ADDR		DWORD
#endif

#define CALL_HANDLER_RETRY_OUTER 10
#define CALL_HANDLER_RETRY_INNER 10

char debugger_command[2 * NT_MAX_PATH + 20];

static BOOL WINAPI ctrl_c_handler (DWORD);

static const struct
{
  NTSTATUS code;
  const char *name;
} status_info[] =
{
#define X(s) s, #s
  { X (STATUS_ABANDONED_WAIT_0) },
  { X (STATUS_ACCESS_VIOLATION) },
  { X (STATUS_ARRAY_BOUNDS_EXCEEDED) },
  { X (STATUS_BREAKPOINT) },
  { X (STATUS_CONTROL_C_EXIT) },
  { X (STATUS_DATATYPE_MISALIGNMENT) },
  { X (STATUS_FLOAT_DENORMAL_OPERAND) },
  { X (STATUS_FLOAT_DIVIDE_BY_ZERO) },
  { X (STATUS_FLOAT_INEXACT_RESULT) },
  { X (STATUS_FLOAT_INVALID_OPERATION) },
  { X (STATUS_FLOAT_OVERFLOW) },
  { X (STATUS_FLOAT_STACK_CHECK) },
  { X (STATUS_FLOAT_UNDERFLOW) },
  { X (STATUS_GUARD_PAGE_VIOLATION) },
  { X (STATUS_ILLEGAL_INSTRUCTION) },
  { X (STATUS_INTEGER_DIVIDE_BY_ZERO) },
  { X (STATUS_INTEGER_OVERFLOW) },
  { X (STATUS_INVALID_DISPOSITION) },
  { X (STATUS_IN_PAGE_ERROR) },
  { X (STATUS_NONCONTINUABLE_EXCEPTION) },
  { X (STATUS_NO_MEMORY) },
  { X (STATUS_PENDING) },
  { X (STATUS_PRIVILEGED_INSTRUCTION) },
  { X (STATUS_SINGLE_STEP) },
  { X (STATUS_STACK_OVERFLOW) },
  { X (STATUS_TIMEOUT) },
  { X (STATUS_USER_APC) },
  { X (STATUS_WAIT_0) },
  { 0, 0 }
#undef X
};

/* Initialization code.  */

void
init_console_handler (bool install_handler)
{
  BOOL res;

  SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
  SetConsoleCtrlHandler (NULL, FALSE);
  if (install_handler)
    res = SetConsoleCtrlHandler (ctrl_c_handler, TRUE);
  else
    res = SetConsoleCtrlHandler (NULL, TRUE);
  if (!res)
    system_printf ("SetConsoleCtrlHandler failed, %E");
}

extern "C" void
error_start_init (const char *buf)
{
  if (!buf || !*buf)
    {
      debugger_command[0] = '\0';
      return;
    }

  char pgm[NT_MAX_PATH];
  if (!GetModuleFileName (NULL, pgm, NT_MAX_PATH))
    strcpy (pgm, "cygwin1.dll");
  for (char *p = strchr (pgm, '\\'); p; p = strchr (p, '\\'))
    *p = '/';

  __small_sprintf (debugger_command, "%s \"%s\"", buf, pgm);
}

void
cygwin_exception::open_stackdumpfile ()
{
  /* If we have no executable name, or if the CWD handle is NULL,
     which means, the CWD is a virtual path, don't even try to open
     a stackdump file. */
  if (myself->progname[0] && cygheap->cwd.get_handle ())
    {
      const WCHAR *p;
      /* write to progname.stackdump if possible */
      if (!myself->progname[0])
	p = L"unknown";
      else if ((p = wcsrchr (myself->progname, L'\\')))
	p++;
      else
	p = myself->progname;

      WCHAR corefile[wcslen (p) + sizeof (".stackdump")];
      wcpcpy (wcpcpy(corefile, p), L".stackdump");
      UNICODE_STRING ucore;
      OBJECT_ATTRIBUTES attr;
      /* Create the UNICODE variation of <progname>.stackdump. */
      RtlInitUnicodeString (&ucore, corefile);
      /* Create an object attribute which refers to <progname>.stackdump
	 in Cygwin's cwd.  Stick to caseinsensitivity. */
      InitializeObjectAttributes (&attr, &ucore, OBJ_CASE_INSENSITIVE,
				  cygheap->cwd.get_handle (), NULL);
      IO_STATUS_BLOCK io;
      NTSTATUS status;
      /* Try to open it to dump the stack in it. */
      status = NtCreateFile (&h, GENERIC_WRITE | SYNCHRONIZE, &attr, &io,
			     NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF,
			     FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_OPEN_FOR_BACKUP_INTENT, NULL, 0);
      if (NT_SUCCESS (status))
	{
	  if (!myself->cygstarted)
	    system_printf ("Dumping stack trace to %S", &ucore);
	  else
	    debug_printf ("Dumping stack trace to %S", &ucore);
	  SetStdHandle (STD_ERROR_HANDLE, h);
	}
    }
}

/* Utilities for dumping the stack, etc.  */

void
cygwin_exception::dump_exception ()
{
  const char *exception_name = NULL;

  if (e)
    {
      for (int i = 0; status_info[i].name; i++)
	{
	  if (status_info[i].code == (NTSTATUS) e->ExceptionCode)
	    {
	      exception_name = status_info[i].name;
	      break;
	    }
	}
    }

#ifdef __x86_64__
  if (exception_name)
    small_printf ("Exception: %s at rip=%011X\r\n", exception_name, ctx->Rip);
  else
    small_printf ("Signal %d at rip=%011X\r\n", e->ExceptionCode, ctx->Rip);
  small_printf ("rax=%016X rbx=%016X rcx=%016X\r\n", ctx->Rax, ctx->Rbx, ctx->Rcx);
  small_printf ("rdx=%016X rsi=%016X rdi=%016X\r\n", ctx->Rdx, ctx->Rsi, ctx->Rdi);
  small_printf ("r8 =%016X r9 =%016X r10=%016X\r\n", ctx->R8, ctx->R9, ctx->R10);
  small_printf ("r11=%016X r12=%016X r13=%016X\r\n", ctx->R11, ctx->R12, ctx->R13);
  small_printf ("r14=%016X r15=%016X\r\n", ctx->R14, ctx->R15);
  small_printf ("rbp=%016X rsp=%016X\r\n", ctx->Rbp, ctx->Rsp);
  small_printf ("program=%W, pid %u, thread %s\r\n",
		myself->progname, myself->pid, cygthread::name ());
#else
  if (exception_name)
    small_printf ("Exception: %s at eip=%08x\r\n", exception_name, ctx->Eip);
  else
    small_printf ("Signal %d at eip=%08x\r\n", e->ExceptionCode, ctx->Eip);
  small_printf ("eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\r\n",
		ctx->Eax, ctx->Ebx, ctx->Ecx, ctx->Edx, ctx->Esi, ctx->Edi);
  small_printf ("ebp=%08x esp=%08x program=%W, pid %u, thread %s\r\n",
		ctx->Ebp, ctx->Esp, myself->progname, myself->pid,
		cygthread::name ());
#endif
  small_printf ("cs=%04x ds=%04x es=%04x fs=%04x gs=%04x ss=%04x\r\n",
		ctx->SegCs, ctx->SegDs, ctx->SegEs, ctx->SegFs, ctx->SegGs, ctx->SegSs);
}

/* A class for manipulating the stack. */
class stack_info
{
  int walk ();			/* Uses the "old" method */
  char *next_offset () {return *((char **) sf.AddrFrame.Offset);}
  bool needargs;
  PUINT_PTR dummy_frame;
#ifdef __x86_64__
  CONTEXT c;
  UNWIND_HISTORY_TABLE hist;
#endif
public:
  STACKFRAME sf;		 /* For storing the stack information */
  void init (PUINT_PTR, bool, PCONTEXT); /* Called the first time that stack info is needed */

  /* Postfix ++ iterates over the stack, returning zero when nothing is left. */
  int operator ++(int) { return walk (); }
};

/* The number of parameters used in STACKFRAME */
#define NPARAMS (sizeof (thestack.sf.Params) / sizeof (thestack.sf.Params[0]))

/* This is the main stack frame info for this process. */
static NO_COPY stack_info thestack;

/* Initialize everything needed to start iterating. */
void
stack_info::init (PUINT_PTR framep, bool wantargs, PCONTEXT ctx)
{
#ifdef __x86_64__
  memset (&hist, 0, sizeof hist);
  if (ctx)
    memcpy (&c, ctx, sizeof c);
  else
    {
      memset (&c, 0, sizeof c);
      c.ContextFlags = CONTEXT_ALL;
    }
#endif
  memset (&sf, 0, sizeof (sf));
  if (ctx)
    sf.AddrFrame.Offset = (UINT_PTR) framep;
  else
    {
      dummy_frame = framep;
      sf.AddrFrame.Offset = (UINT_PTR) &dummy_frame;
    }
  if (framep)
    sf.AddrReturn.Offset = framep[1];
  sf.AddrFrame.Mode = AddrModeFlat;
  needargs = wantargs;
}

extern "C" void _cygwin_exit_return ();

/* Walk the stack by looking at successive stored 'bp' frames.
   This is not foolproof. */
int
stack_info::walk ()
{
#ifdef __x86_64__
  PRUNTIME_FUNCTION f;
  ULONG64 imagebase;
  DWORD64 establisher;
  PVOID hdl;

  if (!c.Rip)
    return 0;

  sf.AddrPC.Offset = c.Rip;
  sf.AddrStack.Offset = c.Rsp;
  sf.AddrFrame.Offset = c.Rbp;

  f = RtlLookupFunctionEntry (c.Rip, &imagebase, &hist);
  if (f)
    RtlVirtualUnwind (0, imagebase, c.Rip, f, &c, &hdl, &establisher, NULL);
  else
    {
      c.Rip = *(ULONG_PTR *) c.Rsp;
      c.Rsp += 8;
    }
  if (needargs && c.Rip)
    {
      PULONG_PTR p = (PULONG_PTR) c.Rsp;
      for (unsigned i = 0; i < NPARAMS; ++i)
	sf.Params[i] = p[i + 1];
    }
  return 1;
#else
  char **framep;

  if ((void (*) ()) sf.AddrPC.Offset == _cygwin_exit_return)
    return 0;		/* stack frames are exhausted */

  if (((framep = (char **) next_offset ()) == NULL)
      || (framep >= (char **) cygwin_hmodule))
    return 0;

  sf.AddrFrame.Offset = (_ADDR) framep;
  sf.AddrPC.Offset = sf.AddrReturn.Offset;

  /* The return address always follows the stack pointer */
  sf.AddrReturn.Offset = (_ADDR) *++framep;

  if (needargs)
    {
      unsigned nparams = NPARAMS;

      /* The arguments follow the return address */
      sf.Params[0] = (_ADDR) *++framep;
      /* Hack for XP/2K3 WOW64.  If the first stack param points to the
	 application entry point, we can only fetch one additional
	 parameter.  Accessing anything beyond this address results in
	 a SEGV.  This is fixed in Vista/2K8 WOW64. */
      if (wincap.has_restricted_stack_args () && sf.Params[0] == 0x401000)
	nparams = 2;
      for (unsigned i = 1; i < nparams; i++)
	sf.Params[i] = (_ADDR) *++framep;
    }
  return 1;
#endif
}

void
cygwin_exception::dumpstack ()
{
  static bool already_dumped;

  __try
    {
      if (already_dumped || cygheap->rlim_core == 0Ul)
	return;
      already_dumped = true;
      open_stackdumpfile ();

      if (e)
	dump_exception ();

      int i;

      thestack.init (framep, 1, ctx);	/* Initialize from the input CONTEXT */
#ifdef __x86_64__
      small_printf ("Stack trace:\r\nFrame        Function    Args\r\n");
#else
      small_printf ("Stack trace:\r\nFrame     Function  Args\r\n");
#endif
      for (i = 0; i < 16 && thestack++; i++)
	{
	  small_printf (_AFMT "  " _AFMT, thestack.sf.AddrFrame.Offset,
			thestack.sf.AddrPC.Offset);
	  for (unsigned j = 0; j < NPARAMS; j++)
	    small_printf ("%s" _AFMT, j == 0 ? " (" : ", ",
			  thestack.sf.Params[j]);
	  small_printf (")\r\n");
	}
      small_printf ("End of stack trace%s\n",
		    i == 16 ? " (more stack frames may be present)" : "");
      if (h)
	NtClose (h);
    }
  __except (NO_ERROR) {}
  __endtry
}

bool
_cygtls::inside_kernel (CONTEXT *cx)
{
  int res;
  MEMORY_BASIC_INFORMATION m;

  if (!isinitialized ())
    return true;

  memset (&m, 0, sizeof m);
  if (!VirtualQuery ((LPCVOID) cx->_GR(ip), &m, sizeof m))
    sigproc_printf ("couldn't get memory info, pc %p, %E", cx->_GR(ip));

  size_t size = (windows_system_directory_length + 6) * sizeof (WCHAR);
  PWCHAR checkdir = (PWCHAR) alloca (size);
  memset (checkdir, 0, size);

# define h ((HMODULE) m.AllocationBase)
  if (!h || m.State != MEM_COMMIT)	/* Be defensive */
    res = true;
  else if (h == hntdll)
    res = true;				/* Calling GetModuleFilename on ntdll.dll
					   can hang */
  else if (h == user_data->hmodule)
    res = false;
  else if (!GetModuleFileNameW (h, checkdir, windows_system_directory_length + 6))
    res = false;
  else
    {
      /* Skip potential long path prefix. */
      if (!wcsncmp (checkdir, L"\\\\?\\", 4))
	checkdir += 4;
      res = wcsncasecmp (windows_system_directory, checkdir,
			 windows_system_directory_length) == 0;
#ifndef __x86_64__
      if (!res && system_wow64_directory_length)
	res = wcsncasecmp (system_wow64_directory, checkdir,
			   system_wow64_directory_length) == 0;

#endif
    }
  sigproc_printf ("pc %p, h %p, inside_kernel %d", cx->_GR(ip), h, res);
# undef h
  return res;
}

/* Temporary (?) function for external callers to get a stack dump */
extern "C" void
cygwin_stackdump ()
{
  CONTEXT c;
  c.ContextFlags = CONTEXT_FULL;
  RtlCaptureContext (&c);
  cygwin_exception exc ((PUINT_PTR) c._GR(bp), &c);
  exc.dumpstack ();
}

#define TIME_TO_WAIT_FOR_DEBUGGER 10000

extern "C" int
try_to_debug (bool waitloop)
{
  debug_printf ("debugger_command '%s'", debugger_command);
  if (*debugger_command == '\0')
    return 0;
  if (being_debugged ())
    {
      extern void break_here ();
      break_here ();
      return 0;
    }

  __small_sprintf (strchr (debugger_command, '\0'), " %u", GetCurrentProcessId ());

  LONG prio = GetThreadPriority (GetCurrentThread ());
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST);
  PROCESS_INFORMATION pi = {NULL, 0, 0, 0};

  STARTUPINFOW si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL};
  si.lpReserved = NULL;
  si.lpDesktop = NULL;
  si.dwFlags = 0;
  si.cb = sizeof (si);

  /* FIXME: need to know handles of all running threads to
     suspend_all_threads_except (current_thread_id);
  */

  /* If the tty mutex is owned, we will fail to start any cygwin app
     until the trapped app exits.  However, this will only release any
     the mutex if it is owned by this thread so that may be problematic. */

  lock_ttys::release ();

  /* prevent recursive exception handling */
  PWCHAR rawenv = GetEnvironmentStringsW () ;
  for (PWCHAR p = rawenv; *p != L'\0'; p = wcschr (p, L'\0') + 1)
    {
      if (wcsncmp (p, L"CYGWIN=", wcslen (L"CYGWIN=")) == 0)
	{
	  PWCHAR q = wcsstr (p, L"error_start") ;
	  /* replace 'error_start=...' with '_rror_start=...' */
	  if (q)
	    {
	      *q = L'_' ;
	      SetEnvironmentVariableW (L"CYGWIN", p + wcslen (L"CYGWIN=")) ;
	    }
	  break;
	}
    }
  FreeEnvironmentStringsW (rawenv);

  console_printf ("*** starting debugger for pid %u, tid %u\n",
		  cygwin_pid (GetCurrentProcessId ()), GetCurrentThreadId ());
  BOOL dbg;
  WCHAR dbg_cmd[strlen(debugger_command) + 1];
  sys_mbstowcs (dbg_cmd, strlen(debugger_command) + 1, debugger_command);
  dbg = CreateProcessW (NULL,
			dbg_cmd,
			NULL,
			NULL,
			FALSE,
			CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,
			NULL,
			NULL,
			&si,
			&pi);

  if (!dbg)
    system_printf ("Failed to start debugger, %E");
  else
    {
      if (!waitloop)
	return dbg;
      SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
      while (!being_debugged ())
	Sleep (1);
      Sleep (2000);
    }

  console_printf ("*** continuing pid %u from debugger call (%d)\n",
		  cygwin_pid (GetCurrentProcessId ()), dbg);

  SetThreadPriority (GetCurrentThread (), prio);
  return dbg;
}

#ifdef __x86_64__
/* Don't unwind the stack on x86_64.  It's not necessary to do that from the
   exception handler. */
#define rtl_unwind(el,er)
#else
static void __reg3 rtl_unwind (exception_list *, PEXCEPTION_RECORD) __attribute__ ((noinline, regparm (3)));
void __reg3
rtl_unwind (exception_list *frame, PEXCEPTION_RECORD e)
{
  __asm__ ("\n\
  pushl		%%ebx					\n\
  pushl		%%edi					\n\
  pushl		%%esi					\n\
  pushl		$0					\n\
  pushl		%1					\n\
  pushl		$1f					\n\
  pushl		%0					\n\
  call		_RtlUnwind@@16				\n\
1:							\n\
  popl		%%esi					\n\
  popl		%%edi					\n\
  popl		%%ebx					\n\
": : "r" (frame), "r" (e));
}
#endif /* __x86_64 */

#ifdef __x86_64__
/* myfault exception handler. */
EXCEPTION_DISPOSITION
exception::myfault (EXCEPTION_RECORD *e, exception_list *frame, CONTEXT *in,
		    PDISPATCHER_CONTEXT dispatch)
{
  PSCOPE_TABLE table = (PSCOPE_TABLE) dispatch->HandlerData;
  RtlUnwindEx (frame,
	       (char *) dispatch->ImageBase + table->ScopeRecord[0].JumpTarget,
	       e, 0, in, dispatch->HistoryTable);
  /* NOTREACHED, make gcc happy. */
  return ExceptionContinueSearch;
}
#endif

/* Main exception handler. */
EXCEPTION_DISPOSITION
exception::handle (EXCEPTION_RECORD *e, exception_list *frame, CONTEXT *in,
		   PDISPATCHER_CONTEXT dispatch)
{
  static bool NO_COPY debugging;
  _cygtls& me = _my_tls;

#ifndef __x86_64__
  if (me.andreas)
    me.andreas->leave ();	/* Return from a "san" caught fault */
#endif

  if (debugging && ++debugging < 500000)
    {
      SetThreadPriority (hMainThread, THREAD_PRIORITY_NORMAL);
      return ExceptionContinueExecution;
    }

  /* If we're exiting, tell Windows to keep looking for an
     exception handler.  */
  if (exit_state || e->ExceptionFlags)
    return ExceptionContinueSearch;

  siginfo_t si = {};
  si.si_code = SI_KERNEL;
  /* Coerce win32 value to posix value.  */
  switch (e->ExceptionCode)
    {
    case STATUS_FLOAT_DENORMAL_OPERAND:
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
    case STATUS_FLOAT_INVALID_OPERATION:
    case STATUS_FLOAT_STACK_CHECK:
      si.si_signo = SIGFPE;
      si.si_code = FPE_FLTSUB;
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      si.si_signo = SIGFPE;
      si.si_code = FPE_FLTRES;
      break;
    case STATUS_FLOAT_OVERFLOW:
      si.si_signo = SIGFPE;
      si.si_code = FPE_FLTOVF;
      break;
    case STATUS_FLOAT_UNDERFLOW:
      si.si_signo = SIGFPE;
      si.si_code = FPE_FLTUND;
      break;
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      si.si_signo = SIGFPE;
      si.si_code = FPE_INTDIV;
      break;
    case STATUS_INTEGER_OVERFLOW:
      si.si_signo = SIGFPE;
      si.si_code = FPE_INTOVF;
      break;

    case STATUS_ILLEGAL_INSTRUCTION:
      si.si_signo = SIGILL;
      si.si_code = ILL_ILLOPC;
      break;

    case STATUS_PRIVILEGED_INSTRUCTION:
      si.si_signo = SIGILL;
      si.si_code = ILL_PRVOPC;
      break;

    case STATUS_NONCONTINUABLE_EXCEPTION:
      si.si_signo = SIGILL;
      si.si_code = ILL_ILLADR;
      break;

    case STATUS_TIMEOUT:
      si.si_signo = SIGALRM;
      break;

    case STATUS_GUARD_PAGE_VIOLATION:
      si.si_signo = SIGBUS;
      si.si_code = BUS_OBJERR;
      break;

    case STATUS_DATATYPE_MISALIGNMENT:
      si.si_signo = SIGBUS;
      si.si_code = BUS_ADRALN;
      break;

    case STATUS_ACCESS_VIOLATION:
      switch (mmap_is_attached_or_noreserve ((void *)e->ExceptionInformation[1],
					     1))
	{
	case MMAP_NORESERVE_COMMITED:
	  return ExceptionContinueExecution;
	case MMAP_RAISE_SIGBUS:	/* MAP_NORESERVE page, commit failed, or
				   access to mmap page beyond EOF. */
	  si.si_signo = SIGBUS;
	  si.si_code = BUS_OBJERR;
	  break;
	default:
	  MEMORY_BASIC_INFORMATION m;
	  VirtualQuery ((PVOID) e->ExceptionInformation[1], &m, sizeof m);
	  si.si_signo = SIGSEGV;
	  si.si_code = m.State == MEM_FREE ? SEGV_MAPERR : SEGV_ACCERR;
	  break;
	}
      break;

    case STATUS_ARRAY_BOUNDS_EXCEEDED:
    case STATUS_IN_PAGE_ERROR:
    case STATUS_NO_MEMORY:
    case STATUS_INVALID_DISPOSITION:
    case STATUS_STACK_OVERFLOW:
      si.si_signo = SIGSEGV;
      si.si_code = SEGV_MAPERR;
      break;

    case STATUS_CONTROL_C_EXIT:
      si.si_signo = SIGINT;
      break;

    case STATUS_INVALID_HANDLE:
      /* CloseHandle will throw this exception if it is given an
	 invalid handle.  We don't care about the exception; we just
	 want CloseHandle to return an error.  This can be revisited
	 if gcc ever supports Windows style structured exception
	 handling.  */
      return ExceptionContinueExecution;

    default:
      /* If we don't recognize the exception, we have to assume that
	 we are doing structured exception handling, and we let
	 something else handle it.  */
      return ExceptionContinueSearch;
    }

  debug_printf ("In cygwin_except_handler exception %y at %p sp %p", e->ExceptionCode, in->_GR(ip), in->_GR(sp));
  debug_printf ("In cygwin_except_handler signal %d at %p", si.si_signo, in->_GR(ip));

#ifdef __x86_64__
  PUINT_PTR framep = (PUINT_PTR) in->Rbp;
  /* Sometimes, when a stack is screwed up, Rbp tends to be NULL.  In that
     case, base the stacktrace on Rsp.  In most cases, it allows to generate
     useful stack trace. */
  if (!framep)
    framep = (PUINT_PTR) in->Rsp;
#else
  PUINT_PTR framep = (PUINT_PTR) in->_GR(sp);
  for (PUINT_PTR bpend = (PUINT_PTR) __builtin_frame_address (0); framep > bpend; framep--)
    if (*framep == in->SegCs && framep[-1] == in->_GR(ip))
      {
	framep -= 2;
	break;
      }

  /* Temporarily replace windows top level SEH with our own handler.
     We don't want any Windows magic kicking in.  This top level frame
     will be removed automatically after our exception handler returns. */
  _except_list->handler = handle;
#endif

  if (exit_state >= ES_SIGNAL_EXIT
      && (NTSTATUS) e->ExceptionCode != STATUS_CONTROL_C_EXIT)
    api_fatal ("Exception during process exit");
  else if (!try_to_debug (0))
    rtl_unwind (frame, e);
  else
    {
      debugging = true;
      return ExceptionContinueExecution;
    }

  /* FIXME: Probably should be handled in signal processing code */
  if ((NTSTATUS) e->ExceptionCode == STATUS_ACCESS_VIOLATION)
    {
      int error_code = 0;
      if (si.si_code == SEGV_ACCERR)	/* Address present */
	error_code |= 1;
      if (e->ExceptionInformation[0])	/* Write access */
	error_code |= 2;
      if (!me.inside_kernel (in))	/* User space */
	error_code |= 4;
      klog (LOG_INFO,
#ifdef __x86_64__
	    "%s[%d]: segfault at %011X rip %011X rsp %011X error %d",
#else
	    "%s[%d]: segfault at %08x rip %08x rsp %08x error %d",
#endif
		      __progname, myself->pid,
		      e->ExceptionInformation[1], in->_GR(ip), in->_GR(sp),
		      error_code);
    }
  cygwin_exception exc (framep, in, e);
  si.si_cyg = (void *) &exc;
  /* POSIX requires that for SIGSEGV and SIGBUS, si_addr should be set to the
     address of faulting memory reference.  For SIGILL and SIGFPE these should
     be the address of the faulting instruction.  Other signals are apparently
     undefined so we just set those to the faulting instruction too.  */ 
  si.si_addr = (si.si_signo == SIGSEGV || si.si_signo == SIGBUS)
	       ? (void *) e->ExceptionInformation[1] : (void *) in->_GR(ip);
  me.incyg++;
  sig_send (NULL, si, &me);	/* Signal myself */
  me.incyg--;
  e->ExceptionFlags = 0;
  return ExceptionContinueExecution;
}

/* Utilities to call a user supplied exception handler.  */

#define SIG_NONMASKABLE	(SIGTOMASK (SIGKILL) | SIGTOMASK (SIGSTOP))

/* Non-raceable sigsuspend
   Note: This implementation is based on the Single UNIX Specification
   man page.  This indicates that sigsuspend always returns -1 and that
   attempts to block unblockable signals will be silently ignored.
   This is counter to what appears to be documented in some UNIX
   man pages, e.g. Linux.  */
int __stdcall
handle_sigsuspend (sigset_t tempmask)
{
  sigset_t oldmask = _my_tls.sigmask;	// Remember for restoration

  set_signal_mask (_my_tls.sigmask, tempmask);
  sigproc_printf ("oldmask %ly, newmask %ly", oldmask, tempmask);

  pthread_testcancel ();
  cygwait (NULL, cw_infinite, cw_cancel | cw_cancel_self | cw_sig_eintr);

  set_sig_errno (EINTR);	// Per POSIX

  /* A signal dispatch function will have been added to our stack and will
     be hit eventually.  Set the old mask to be restored when the signal
     handler returns and indicate its presence by modifying deltamask. */

  _my_tls.deltamask |= SIG_NONMASKABLE;
  _my_tls.oldmask = oldmask;	// Will be restored by signal handler
  return -1;
}

extern DWORD exec_exit;		// Possible exit value for exec

extern "C" {
static void
sig_handle_tty_stop (int sig, siginfo_t *, void *)
{
  /* Silently ignore attempts to suspend if there is no accommodating
     cygwin parent to deal with this behavior. */
  if (!myself->cygstarted)
    myself->process_state &= ~PID_STOPPED;
  else
    {
      _my_tls.incyg = 1;
      myself->stopsig = sig;
      myself->alert_parent (sig);
      sigproc_printf ("process %d stopped by signal %d", myself->pid, sig);
      /* FIXME! This does nothing to suspend anything other than the main
	 thread. */
      /* Use special cygwait parameter to handle SIGCONT.  _main_tls.sig will
	 be cleared under lock when SIGCONT is detected.  */
      DWORD res = cygwait (NULL, cw_infinite, cw_sig_cont);
      switch (res)
	{
	case WAIT_SIGNALED:
	  myself->stopsig = SIGCONT;
	  myself->alert_parent (SIGCONT);
	  break;
	default:
	  api_fatal ("WaitSingleObject returned %d", res);
	  break;
	}
      _my_tls.incyg = 0;
    }
}
} /* end extern "C" */

bool
_cygtls::interrupt_now (CONTEXT *cx, siginfo_t& si, void *handler,
			struct sigaction& siga)
{
  bool interrupted;

  /* Delay the interrupt if we are
     1) somehow inside the DLL
     2) in _sigfe (spinning is true) and about to enter cygwin DLL
     3) in a Windows DLL.  */
  if (incyg || spinning || inside_kernel (cx))
    interrupted = false;
  else
    {
      _ADDR &ip = cx->_GR(ip);
      push (ip);
      interrupt_setup (si, handler, siga);
      ip = pop ();
      SetThreadContext (*this, cx); /* Restart the thread in a new location */
      interrupted = true;
    }
  return interrupted;
}

void __reg3
_cygtls::interrupt_setup (siginfo_t& si, void *handler, struct sigaction& siga)
{
  push ((__stack_t) sigdelayed);
  deltamask = siga.sa_mask & ~SIG_NONMASKABLE;
  sa_flags = siga.sa_flags;
  func = (void (*) (int, siginfo_t *, void *)) handler;
  if (siga.sa_flags & SA_RESETHAND)
    siga.sa_handler = SIG_DFL;
  saved_errno = -1;		// Flag: no errno to save
  if (handler == sig_handle_tty_stop)
    {
      myself->stopsig = 0;
      myself->process_state |= PID_STOPPED;
    }

  infodata = si;
  this->sig = si.si_signo;		// Should always be last thing set to avoid a race

  if (incyg)
    SetEvent (get_signal_arrived (false));

  if (!have_execed)
    proc_subproc (PROC_CLEARWAIT, 1);
  sigproc_printf ("armed signal_arrived %p, signal %d", signal_arrived, si.si_signo);
}

extern "C" void __stdcall
set_sig_errno (int e)
{
  *_my_tls.errno_addr = e;
  _my_tls.saved_errno = e;
}

int
sigpacket::setup_handler (void *handler, struct sigaction& siga, _cygtls *tls)
{
  CONTEXT cx;
  bool interrupted = false;

  if (tls->sig)
    {
      sigproc_printf ("trying to send signal %d but signal %d already armed",
		      si.si_signo, tls->sig);
      goto out;
    }

  for (int n = 0; n < CALL_HANDLER_RETRY_OUTER; n++)
    {
      for (int i = 0; i < CALL_HANDLER_RETRY_INNER; i++)
	{
	  tls->lock ();
	  if (tls->incyg)
	    {
	      sigproc_printf ("controlled interrupt. stackptr %p, stack %p, stackptr[-1] %p",
			      tls->stackptr, tls->stack, tls->stackptr[-1]);
	      tls->interrupt_setup (si, handler, siga);
	      interrupted = true;
	      tls->unlock ();
	      goto out;
	    }

	  DWORD res;
	  HANDLE hth = (HANDLE) *tls;
	  if (!hth)
	    {
	      tls->unlock ();
	      sigproc_printf ("thread handle NULL, not set up yet?");
	    }
	  else
	    {
	      /* Suspend the thread which will receive the signal.
		 If one of these conditions is not true we loop.
		 If the thread is already suspended (which can occur when a program
		 has called SuspendThread on itself) then just queue the signal. */

	      sigproc_printf ("suspending thread, tls %p, _main_tls %p", tls, _main_tls);
	      res = SuspendThread (hth);
	      /* Just set pending if thread is already suspended */
	      if (res)
		{
		  tls->unlock ();
		  ResumeThread (hth);
		  goto out;
		}
	      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	      if (!GetThreadContext (hth, &cx))
		sigproc_printf ("couldn't get context of thread, %E");
	      else
		interrupted = tls->interrupt_now (&cx, si, handler, siga);

	      tls->unlock ();
	      ResumeThread (hth);
	      if (interrupted)
		goto out;
	    }

	  sigproc_printf ("couldn't interrupt.  trying again.");
	  yield ();
	}
      /* Hit here if we couldn't deliver the signal.  Take a more drastic
	 action before trying again. */
      Sleep (1);
    }

out:
  sigproc_printf ("signal %d %sdelivered", si.si_signo, interrupted ? "" : "not ");
  return interrupted;
}

static inline bool
has_visible_window_station ()
{
  HWINSTA station_hdl;
  USEROBJECTFLAGS uof;
  DWORD len;

  /* Check if the process is associated with a visible window station.
     These are processes running on the local desktop as well as processes
     running in terminal server sessions.
     Processes running in a service session not explicitely associated
     with the desktop (using the "Allow service to interact with desktop"
     property) are running in an invisible window station. */
  if ((station_hdl = GetProcessWindowStation ())
      && GetUserObjectInformationW (station_hdl, UOI_FLAGS, &uof,
				    sizeof uof, &len)
      && (uof.dwFlags & WSF_VISIBLE))
    return true;
  return false;
}

/* Keyboard interrupt handler.  */
static BOOL WINAPI
ctrl_c_handler (DWORD type)
{
  static bool saw_close;

  /* Remove early or we could overthrow the threadlist in cygheap.
     Deleting this line causes ash to SEGV if CTRL-C is hit repeatedly.
     I am not exactly sure why that is.  Maybe it's just because this
     adds some early serialization to ctrl_c_handler which prevents
     multiple simultaneous calls? */
  _my_tls.remove (INFINITE);

#if 0
  if (type == CTRL_C_EVENT || type == CTRL_BREAK_EVENT)
    proc_subproc (PROC_KILLFORKED, 0);
#endif

  /* Return FALSE to prevent an "End task" dialog box from appearing
     for each Cygwin process window that's open when the computer
     is shut down or console window is closed. */

  if (type == CTRL_SHUTDOWN_EVENT)
    {
#if 0
      /* Don't send a signal.  Only NT service applications and their child
	 processes will receive this event and the services typically already
	 handle the shutdown action when getting the SERVICE_CONTROL_SHUTDOWN
	 control message. */
      sig_send (NULL, SIGTERM);
#endif
      return FALSE;
    }

  if (myself->ctty != -1)
    {
      if (type == CTRL_CLOSE_EVENT)
	{
	  sig_send (NULL, SIGHUP);
	  saw_close = true;
	  return FALSE;
	}
      if (!saw_close && type == CTRL_LOGOFF_EVENT)
	{
	  /* The CTRL_LOGOFF_EVENT is sent when *any* user logs off.
	     The below code sends a SIGHUP only if it is not performing the
	     default activity for SIGHUP.  Note that it is possible for two
	     SIGHUP signals to arrive if a process group leader is exiting
	     too.  Getting this 100% right is saved for a future cygwin mailing
	     list goad.  */
	  if (global_sigs[SIGHUP].sa_handler != SIG_DFL)
	    {
	      sig_send (myself, SIGHUP);
	      return TRUE;
	    }
	  return FALSE;
	}
    }

  if (ch_spawn.set_saw_ctrl_c ())
    return TRUE;

  /* We're only the process group leader when we have a valid pinfo structure.
     If we don't have one, then the parent "stub" will handle the signal. */
  if (!pinfo (cygwin_pid (GetCurrentProcessId ())))
    return TRUE;

  tty_min *t = cygwin_shared->tty.get_cttyp ();
  /* Ignore this if we're not the process group leader since it should be handled
     *by* the process group leader. */
  if (t && (!have_execed || have_execed_cygwin)
      && t->getpgid () == myself->pid &&
      (GetTickCount () - t->last_ctrl_c) >= MIN_CTRL_C_SLOP)
    /* Otherwise we just send a SIGINT to the process group and return TRUE (to indicate
       that we have handled the signal).  At this point, type should be
       a CTRL_C_EVENT or CTRL_BREAK_EVENT. */
    {
      int sig = SIGINT;
      /* If intr and quit are both mapped to ^C, send SIGQUIT on ^BREAK */
      if (type == CTRL_BREAK_EVENT
	  && t->ti.c_cc[VINTR] == 3 && t->ti.c_cc[VQUIT] == 3)
	sig = SIGQUIT;
      t->last_ctrl_c = GetTickCount ();
      t->kill_pgrp (sig);
      t->last_ctrl_c = GetTickCount ();
      return TRUE;
    }

  return TRUE;
}

/* Function used by low level sig wrappers. */
extern "C" void __stdcall
set_process_mask (sigset_t newmask)
{
  set_signal_mask (_my_tls.sigmask, newmask);
}

extern "C" int
sighold (int sig)
{
  /* check that sig is in right range */
  if (sig < 0 || sig >= NSIG)
    {
      set_errno (EINVAL);
      syscall_printf ("signal %d out of range", sig);
      return -1;
    }
  sigset_t mask = _my_tls.sigmask;
  sigaddset (&mask, sig);
  set_signal_mask (_my_tls.sigmask, mask);
  return 0;
}

extern "C" int
sigrelse (int sig)
{
  /* check that sig is in right range */
  if (sig < 0 || sig >= NSIG)
    {
      set_errno (EINVAL);
      syscall_printf ("signal %d out of range", sig);
      return -1;
    }
  sigset_t mask = _my_tls.sigmask;
  sigdelset (&mask, sig);
  set_signal_mask (_my_tls.sigmask, mask);
  return 0;
}

extern "C" _sig_func_ptr
sigset (int sig, _sig_func_ptr func)
{
  sig_dispatch_pending ();
  _sig_func_ptr prev;

  /* check that sig is in right range */
  if (sig < 0 || sig >= NSIG || sig == SIGKILL || sig == SIGSTOP)
    {
      set_errno (EINVAL);
      syscall_printf ("SIG_ERR = sigset (%d, %p)", sig, func);
      return (_sig_func_ptr) SIG_ERR;
    }

  sigset_t mask = _my_tls.sigmask;
  /* If sig was in the signal mask return SIG_HOLD, otherwise return the
     previous disposition. */
  if (sigismember (&mask, sig))
    prev = SIG_HOLD;
  else
    prev = global_sigs[sig].sa_handler;
  /* If func is SIG_HOLD, add sig to the signal mask, otherwise set the
     disposition to func and remove sig from the signal mask. */
  if (func == SIG_HOLD)
    sigaddset (&mask, sig);
  else
    {
      /* No error checking.  The test which could return SIG_ERR has already
	 been made above. */
      signal (sig, func);
      sigdelset (&mask, sig);
    }
  set_signal_mask (_my_tls.sigmask, mask);
  return prev;
}

extern "C" int
sigignore (int sig)
{
  return sigset (sig, SIG_IGN) == SIG_ERR ? -1 : 0;
}

/* Update the signal mask for this process and return the old mask.
   Called from call_signal_handler */
extern "C" sigset_t
set_process_mask_delta ()
{
  sigset_t newmask, oldmask;

  if (_my_tls.deltamask & SIG_NONMASKABLE)
    oldmask = _my_tls.oldmask; /* from handle_sigsuspend */
  else
    oldmask = _my_tls.sigmask;
  newmask = (oldmask | _my_tls.deltamask) & ~SIG_NONMASKABLE;
  sigproc_printf ("oldmask %lx, newmask %lx, deltamask %lx", oldmask, newmask,
		  _my_tls.deltamask);
  _my_tls.sigmask = newmask;
  return oldmask;
}

/* Set the signal mask for this process.
   Note that some signals are unmaskable, as in UNIX.  */

void
set_signal_mask (sigset_t& setmask, sigset_t newmask)
{
  newmask &= ~SIG_NONMASKABLE;
  sigset_t mask_bits = setmask & ~newmask;
  sigproc_printf ("setmask %lx, newmask %lx, mask_bits %lx", setmask, newmask,
		  mask_bits);
  setmask = newmask;
  if (mask_bits)
    sig_dispatch_pending (true);
}

/* Exit due to a signal.  Should only be called from the signal thread.  */
extern "C" {
static void
signal_exit (int sig, siginfo_t *si)
{
  debug_printf ("exiting due to signal %d", sig);
  exit_state = ES_SIGNAL_EXIT;

  if (cygheap->rlim_core > 0UL)
    switch (sig)
      {
      case SIGABRT:
      case SIGBUS:
      case SIGFPE:
      case SIGILL:
      case SIGQUIT:
      case SIGSEGV:
      case SIGSYS:
      case SIGTRAP:
      case SIGXCPU:
      case SIGXFSZ:
	sig |= 0x80;		/* Flag that we've "dumped core" */
	if (try_to_debug ())
	  break;
	if (si->si_code != SI_USER && si->si_cyg)
	  ((cygwin_exception *) si->si_cyg)->dumpstack ();
	else
	  {
	    CONTEXT c;
	    c.ContextFlags = CONTEXT_FULL;
#ifdef __x86_64__
	    RtlCaptureContext (&c);
	    cygwin_exception exc ((PUINT_PTR) __builtin_frame_address (0), &c);
#else
	    GetThreadContext (GetCurrentThread (), &c);
	    cygwin_exception exc ((PUINT_PTR) __builtin_frame_address (0), &c);
#endif
	    exc.dumpstack ();
	  }
	break;
      }

  lock_process until_exit (true);

  if (have_execed || exit_state > ES_PROCESS_LOCKED)
    {
      debug_printf ("recursive exit?");
      myself.exit (sig);
    }

  /* Starve other threads in a vain attempt to stop them from doing something
     stupid. */
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL);

  sigproc_printf ("about to call do_exit (%x)", sig);
  do_exit (sig);
}
} /* extern "C" */

/* Attempt to carefully handle SIGCONT when we are stopped. */
void
_cygtls::handle_SIGCONT ()
{
  if (NOTSTATE (myself, PID_STOPPED))
    return;

  myself->stopsig = 0;
  myself->process_state &= ~PID_STOPPED;
  /* Carefully tell sig_handle_tty_stop to wake up.
     Make sure that any pending signal is handled before trying to
     send a new one.  Then make sure that SIGCONT has been recognized
     before exiting the loop.  */
  bool sigsent = false;
  while (1)
    if (sig)		/* Assume that it's ok to just test sig outside of a
			   lock since setup_handler does it this way.  */
      yield ();		/* Attempt to schedule another thread.  */
    else if (sigsent)
      break;		/* SIGCONT has been recognized by other thread */
    else
      {
	sig = SIGCONT;
	SetEvent (signal_arrived); /* alert sig_handle_tty_stop */
	sigsent = true;
      }
  /* Clear pending stop signals */
  sig_clear (SIGSTOP);
  sig_clear (SIGTSTP);
  sig_clear (SIGTTIN);
  sig_clear (SIGTTOU);
}

int __reg1
sigpacket::process ()
{
  int rc = 1;
  bool issig_wait = false;
  struct sigaction& thissig = global_sigs[si.si_signo];
  void *handler = have_execed ? NULL : (void *) thissig.sa_handler;

  threadlist_t *tl_entry = NULL;
  _cygtls *tls = NULL;

  /* Don't try to send signals if we're just starting up since signal masks
     may not be available.  */
  if (!cygwin_finished_initializing)
    {
      rc = -1;
      goto done;
    }

  sigproc_printf ("signal %d processing", si.si_signo);

  myself->rusage_self.ru_nsignals++;

  if (si.si_signo == SIGCONT)
    {
      tl_entry = cygheap->find_tls (_main_tls);
      _main_tls->handle_SIGCONT ();
      cygheap->unlock_tls (tl_entry);
    }

  /* SIGKILL is special.  It always goes through.  */
  if (si.si_signo == SIGKILL)
    {
      tl_entry = cygheap->find_tls (_main_tls);
      tls = _main_tls;
    }
  else if (ISSTATE (myself, PID_STOPPED))
    {
      rc = -1;		/* Don't send signals when stopped */
      goto done;
    }
  else if (!sigtls)
    {
      tl_entry = cygheap->find_tls (si.si_signo, issig_wait);
      if (tl_entry)
	{
	  tls = tl_entry->thread;
	  sigproc_printf ("using tls %p", tls);
	}
    }
  else
    {
      tl_entry = cygheap->find_tls (sigtls);
      if (tl_entry)
	{
	  tls = tl_entry->thread;
	  if (sigismember (&tls->sigwait_mask, si.si_signo))
	    issig_wait = true;
	  else if (!sigismember (&tls->sigmask, si.si_signo))
	    issig_wait = false;
	  else
	    {
	      cygheap->unlock_tls (tl_entry);
	      tls = NULL;
	    }
	}
    }
      
  /* !tls means no threads available to catch a signal. */
  if (!tls)
    {
      sigproc_printf ("signal %d blocked", si.si_signo);
      rc = -1;
      goto done;
    }

  /* Do stuff for gdb */
  if ((HANDLE) *tls)
    tls->signal_debugger (si);

  if (issig_wait)
    {
      tls->sigwait_mask = 0;
      goto dosig;
    }

  if (handler == SIG_IGN)
    {
      sigproc_printf ("signal %d ignored", si.si_signo);
      goto done;
    }

  if (si.si_signo == SIGKILL)
    goto exit_sig;
  if (si.si_signo == SIGSTOP)
    {
      sig_clear (SIGCONT);
      goto stop;
    }

  /* Clear pending SIGCONT on stop signals */
  if (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN
      || si.si_signo == SIGTTOU)
    sig_clear (SIGCONT);

  if (handler == (void *) SIG_DFL)
    {
      if (si.si_signo == SIGCHLD || si.si_signo == SIGIO
	  || si.si_signo == SIGCONT || si.si_signo == SIGWINCH
	  || si.si_signo == SIGURG)
	{
	  sigproc_printf ("signal %d default is currently ignore", si.si_signo);
	  goto done;
	}

      if (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN
	  || si.si_signo == SIGTTOU)
	goto stop;

      goto exit_sig;
    }

  if (handler == (void *) SIG_ERR)
    goto exit_sig;

  goto dosig;

stop:
  if (tls != _main_tls)
    {
      cygheap->unlock_tls (tl_entry);
      tl_entry = cygheap->find_tls (_main_tls);
      tls = _main_tls;
    }
  handler = (void *) sig_handle_tty_stop;
  thissig = global_sigs[SIGSTOP];
  goto dosig;

exit_sig:
  handler = (void *) signal_exit;
  thissig.sa_flags |= SA_SIGINFO;

dosig:
  if (have_execed)
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (ch_spawn, sigExeced = si.si_signo);
    }
  /* Dispatch to the appropriate function. */
  sigproc_printf ("signal %d, signal handler %p", si.si_signo, handler);
  rc = setup_handler (handler, thissig, tls);

done:
  cygheap->unlock_tls (tl_entry);
  sigproc_printf ("returning %d", rc);
  return rc;

}

int
_cygtls::call_signal_handler ()
{
  int this_sa_flags = SA_RESTART;
  while (1)
    {
      lock ();
      if (!sig)
	{
	  unlock ();
	  break;
	}

      /* Pop the stack if the next "return address" is sigdelayed, since
	 this function is doing what sigdelayed would have done anyway. */
      if (retaddr () == (__stack_t) sigdelayed)
	pop ();

      debug_only_printf ("dealing with signal %d", sig);
      this_sa_flags = sa_flags;

      /* Save information locally on stack to pass to handler. */
      int thissig = sig;
      siginfo_t thissi = infodata;
      void (*thisfunc) (int, siginfo_t *, void *) = func;

      sigset_t this_oldmask = set_process_mask_delta ();
      int this_errno = saved_errno;
      reset_signal_arrived ();
      incyg = false;
      sig = 0;		/* Flag that we can accept another signal */
      unlock ();	/* unlock signal stack */

      /* no ucontext_t information provided yet, so third arg is NULL */
      thisfunc (thissig, &thissi, NULL);
      incyg = true;

      set_signal_mask (_my_tls.sigmask, this_oldmask);
      if (this_errno >= 0)
	set_errno (this_errno);
    }

  return this_sa_flags & SA_RESTART || (this != _main_tls);
}

void
_cygtls::signal_debugger (siginfo_t& si)
{
  HANDLE th;
  /* If si.si_cyg is set then the signal was already sent to the debugger. */
  if (isinitialized () && !si.si_cyg && (th = (HANDLE) *this)
      && being_debugged () && SuspendThread (th) >= 0)
    {
      CONTEXT c;
      c.ContextFlags = CONTEXT_FULL;
      if (GetThreadContext (th, &c))
	{
	  if (incyg)
#ifdef __x86_64__
	    c.Rip = retaddr ();
#else
	    c.Eip = retaddr ();
#endif
	  memcpy (&thread_context, &c, (&thread_context._internal -
					(unsigned char *) &thread_context));
	  /* Enough space for 32/64 bit addresses */
	  char sigmsg[2 * sizeof (_CYGWIN_SIGNAL_STRING " ffffffff ffffffffffffffff")];
	  __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %d %y %p", si.si_signo,
			   thread_id, &thread_context);
	  OutputDebugString (sigmsg);
	}
      ResumeThread (th);
    }
}
@


1.445
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d1302 3
a1316 1
  _cygtls *tls;
d1318 5
a1322 1
    _main_tls->handle_SIGCONT ();
d1324 1
d1326 4
a1329 1
    tls = _main_tls;	/* SIGKILL is special.  It always goes through.  */
d1337 6
a1342 2
      tls = cygheap->find_tls (si.si_signo, issig_wait);
      sigproc_printf ("using tls %p", tls);
d1346 14
a1359 7
      tls = sigtls;
      if (sigismember (&tls->sigwait_mask, si.si_signo))
	issig_wait = true;
      else if (!sigismember (&tls->sigmask, si.si_signo))
	issig_wait = false;
      else
	tls = NULL;
d1395 2
a1396 1
  if (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN || si.si_signo == SIGTTOU)
d1401 2
a1402 1
      if (si.si_signo == SIGCHLD || si.si_signo == SIGIO || si.si_signo == SIGCONT || si.si_signo == SIGWINCH
d1409 2
a1410 1
      if (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN || si.si_signo == SIGTTOU)
d1422 6
a1427 1
  tls = _main_tls;
d1447 1
@


1.444
log
@	* exceptions.cc (exception::myfault_handle): Rephrase comment.
@
text
@a343 3
  myfault efault;
  if (efault.faulted ())
    return;
d345 6
a350 4
  if (already_dumped || cygheap->rlim_core == 0Ul)
    return;
  already_dumped = true;
  open_stackdumpfile ();
d352 2
a353 2
  if (e)
    dump_exception ();
d355 1
a355 1
  int i;
d357 1
a357 1
  thestack.init (framep, 1, ctx);	/* Initialize from the input CONTEXT */
d359 1
a359 1
  small_printf ("Stack trace:\r\nFrame        Function    Args\r\n");
d361 1
a361 1
  small_printf ("Stack trace:\r\nFrame     Function  Args\r\n");
d363 16
a378 12
  for (i = 0; i < 16 && thestack++; i++)
    {
      small_printf (_AFMT "  " _AFMT, thestack.sf.AddrFrame.Offset,
		    thestack.sf.AddrPC.Offset);
      for (unsigned j = 0; j < NPARAMS; j++)
	small_printf ("%s" _AFMT, j == 0 ? " (" : ", ", thestack.sf.Params[j]);
      small_printf (")\r\n");
    }
  small_printf ("End of stack trace%s\n",
	      i == 16 ? " (more stack frames may be present)" : "");
  if (h)
    NtClose (h);
d555 12
a566 20
/* myfault vectored exception handler */
LONG
exception::myfault_handle (LPEXCEPTION_POINTERS ep)
{
  _cygtls& me = _my_tls;

  if (me.andreas)
    {
      /* Only handle the minimum amount of exceptions the myfault handler
	 was designed for. */
      switch (ep->ExceptionRecord->ExceptionCode)
	{
	case STATUS_ACCESS_VIOLATION:
	case STATUS_DATATYPE_MISALIGNMENT:
#if 0
	/* PAGE_GUARD-based stack commits are based on structured exception
	   handling.  Short-circuiting STATUS_STACK_OVERFLOW in a vectored
	   exception handler disables that, which can ultimately result in
	   a spurious SEGV. */
	case STATUS_STACK_OVERFLOW:
a567 9
	case STATUS_ARRAY_BOUNDS_EXCEEDED:
	  me.andreas->leave ();	/* Return from a "san" caught fault */
	default:
	  break;
	}
    }
  return EXCEPTION_CONTINUE_SEARCH;
}
#endif /* __x86_64 */
d570 3
a572 2
int
exception::handle (EXCEPTION_RECORD *e, exception_list *frame, CONTEXT *in, void *)
@


1.443
log
@	* exceptions.cc (exception::myfault_handle): Fix typo in comment.
@
text
@d567 4
a570 1
	/* Short-circuiting STATUS_STACK_OVERFLOW disables stack commits. */
@


1.442
log
@	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.
@
text
@d567 1
a567 1
	/* Short-circuting STATUS_STACK_OVERFLOW disables stack commits. */
@


1.441
log
@	* exceptions.cc (try_to_debug): Free environment pointer when not used
	anymore (CID 59968).
@
text
@d566 2
d569 1
@


1.440
log
@	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).
@
text
@d485 1
a485 1
	  break ;
d488 1
@


1.439
log
@	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@d492 1
a492 1
  WCHAR dbg_cmd[strlen(debugger_command)];
@


1.438
log
@* DevNotes: Add entry cgf-000025.
* exceptions.cc (_cygtls::signal_debugger): Reorganize to avoid contacting the
debugger if we have already done so via the exception handler.  Eliminate need
for goto.  Remove an ifdef in favor of just allocating a larger buffer.
@
text
@d558 14
a571 1
    me.andreas->leave ();	/* Return from a "san" caught fault */
@


1.437
log
@	* dcrt0.cc (dll_crt0_0): Install myfault exception handler on x86_64.
	* exception.h (exception_list): Typedef as void on x86_64.
	(exception::handler_installed): Remove.
	(exception::handle_while_being_debugged): Remove.
	(exception::myfault_handle): Declare for x86_64.
	(exception::handle): Declare as ordinary exception handler on x86_64
	as well.
	(exception::exception): Drop previous code (again).  Install
	exception::handle as SEH handler.
	(exception::install_myfault_handler): New x86_64-only method to
	install exception::myfault_handle as VEH handler.  Explain why.
	(exception::~exception): For x86_64, define frame end label (again).
	* exceptions.cc (CYG_EXC_CONTINUE_EXECUTION): Drop definition.
	(CYG_EXC_CONTINUE_SEARCH): Ditto.
	(exception::myfault_handle): New x86_64-only method, VEH handler to
	handle myfault exceptions.
	(exception::handle): Define as ordinary exception handler on x86_64
	as well.  Use ExceptionContinueExecution and ExceptionContinueSearch
	throughout instead of deleted Cygwin macros.  Don't handle myfault
	exceptions on x86_64.
@
text
@d1464 4
a1467 2
  HANDLE th = NULL;
  if (isinitialized () && being_debugged ())
d1470 2
a1471 7
      CONTEXT *pc;

      if (si.si_cyg)
	pc = ((cygwin_exception *) si.si_cyg)->context ();
      else if (!(th = (HANDLE) *this))
	return;
      else
a1472 4
	  SuspendThread (th);
	  c.ContextFlags = CONTEXT_FULL;
	  if (!GetThreadContext (th, &c))
	    goto out;
d1479 7
a1485 1
	  pc = &c;
d1487 1
a1487 10
      memcpy (&thread_context, pc, (&thread_context._internal -
				    (unsigned char *) &thread_context));
#ifdef __x86_64__
      char sigmsg[2 * sizeof (_CYGWIN_SIGNAL_STRING " ffffffff ffffffffffffffff")];
#else
      char sigmsg[2 * sizeof (_CYGWIN_SIGNAL_STRING " ffffffff ffffffff")];
#endif
      __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %d %y %p", si.si_signo,
		       thread_id, &thread_context);
      OutputDebugString (sigmsg);
a1488 3
out:
  if (th)
    ResumeThread (th);
@


1.436
log
@	* exceptions.cc (_cygtls::signal_debugger): Move memcpy to copy context
	from incoming siginfo_t to thread_context, too.
@
text
@d548 1
a548 3
#endif

/* Main exception handler. */
d551 5
a555 2
#define CYG_EXC_CONTINUE_EXECUTION	EXCEPTION_CONTINUE_EXECUTION
#define CYG_EXC_CONTINUE_SEARCH		EXCEPTION_CONTINUE_SEARCH
d557 2
a558 7
bool exception::handler_installed NO_COPY;

int
exception::handle_while_being_debugged (LPEXCEPTION_POINTERS ep)
{
  if (being_debugged ())
    return handle (ep);
d561 1
d563 1
a563 6
int
exception::handle (LPEXCEPTION_POINTERS ep)
#else
#define CYG_EXC_CONTINUE_EXECUTION	ExceptionContinueExecution
#define CYG_EXC_CONTINUE_SEARCH		ExceptionContinueSearch

a565 1
#endif
d570 1
a572 4

#ifdef __x86_64__
  EXCEPTION_RECORD *e = ep->ExceptionRecord;
  CONTEXT *in = ep->ContextRecord;
d578 1
a578 1
      return CYG_EXC_CONTINUE_EXECUTION;
d584 1
a584 1
    return CYG_EXC_CONTINUE_SEARCH;
d653 1
a653 1
	  return CYG_EXC_CONTINUE_EXECUTION;
d687 1
a687 1
      return CYG_EXC_CONTINUE_EXECUTION;
d693 1
a693 1
      return CYG_EXC_CONTINUE_SEARCH;
d729 1
a729 1
      return CYG_EXC_CONTINUE_EXECUTION;
d764 1
a764 1
  return CYG_EXC_CONTINUE_EXECUTION;
@


1.435
log
@	* exception.h (exception::handle_while_being_debugged): Declare.
	(exception::exception): Install unhandled exception filter.
	* exceptions.cc (exception::handle_while_being_debugged): New method.
@
text
@d1490 1
a1490 3
	  if (GetThreadContext (th, &c))
	    pc = &c;
	  else
d1498 1
a1498 2
	  memcpy (&thread_context, pc, (&thread_context._internal -
					(unsigned char *) &thread_context));
d1500 2
@


1.434
log
@	Partially revert patch from 2014-03-04.
	* exception.h (exception::handler_installed): Declare.
	(exception::exception): Install vectored exception handler on x86_64.
	(exception::~exception): Remove for x86_64.
	* exceptions.cc (exception::handler_installed): Define.
@
text
@d559 8
@


1.433
log
@	* exception.h (exception::handler_installed): Remove.
	(exception::exception): Remove old code.  Manually install SEH handler
	instead.
	(exception::~exception): For x86_64, define frame end label.
	* exceptions.cc (exception::handler_installed): Remove.
@
text
@d556 2
@


1.432
log
@* exceptions.h (cygwin_exception::open_stackdumpfile): Move old function into
class.
(cygwin_exception::h): New member.
(cygwin_exception::cygwin_exception): Initialize h to NULL.
* exceptions.cc (cygwin_exception::open_stackdumpfile): Move into
cygwin_exception class.  Use 'h' class member.
(cygwin_exception::dumpstack): Close stack dump file handle if opened.
@
text
@a555 2
bool exception::handler_installed NO_COPY; 

@


1.432.2.1
log
@* exception.h (exception::handler_installed): Remove.
(exception::exception): Remove old code.  Manually install SEH handler instead.
(exception::~exception): For x86_64, define frame end label.
* exceptions.cc (exception::handler_installed): Remove.
@
text
@d556 2
@


1.432.2.2
log
@	Partially revert patch from 2014-03-04.
	* exception.h (exception::handler_installed): Declare.
	(exception::exception): Install vectored exception handler on x86_64.
	(exception::~exception): Remove for x86_64.
	* exceptions.cc (exception::handler_installed): Define.
@
text
@a555 2
bool exception::handler_installed NO_COPY;

@


1.432.2.3
log
@	* exception.h (exception::handle_while_being_debugged): Declare.
	(exception::exception): Install unhandled exception filter.
	* exceptions.cc (exception::handle_while_being_debugged): New method.
@
text
@a558 8
exception::handle_while_being_debugged (LPEXCEPTION_POINTERS ep)
{
  if (being_debugged ())
    return handle (ep);
  return EXCEPTION_CONTINUE_SEARCH;
}

int
@


1.432.2.4
log
@2014-03-28  Corinna Vinschen  <corinna@@vinschen.de>

	* sec_auth.cc (create_token): Initialize lsa handle to NULL, rather than
	to INVALID_HANDLE_VALUE.
	(lsaauth): Ditto.
	(lsaprivkeyauth): Ditto.
	* setlsapwd.cc (setlsapwd): Don't initialize lsa handle.

2014-03-28  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (_cygtls::signal_debugger): Move memcpy to copy context
	from incoming siginfo_t to thread_context, too.

2014-03-27  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (_sigbe/x86_64): Fix typo in .seh_proc pseudo-op.
	(setjmp/x86_64): Drop storing ExceptionList pointer in jmp_buf->Frame.
	Drop comment.  Store likely frame in rdx.  Jump to __setjmpex.
	(__setjmpex): New function providing setjmp functionality.  Fetch
	jmp_buf->Frame from rdx, like MSVCRT setjmpex.
	(__sjfault/x86_64): Store rdx content in jmp_buf->Frame.
	(__ljfault/x86_64): Don't restore ExceptionList pointer.
	(longjmp/x86_64): Ditto.
@
text
@d1490 3
a1492 1
	  if (!GetThreadContext (th, &c))
d1500 2
a1501 1
	  pc = &c;
a1502 2
      memcpy (&thread_context, pc, (&thread_context._internal -
				    (unsigned char *) &thread_context));
@


1.432.2.5
log
@	* dcrt0.cc (dll_crt0_0): Install myfault exception handler on x86_64.
	* exception.h (exception_list): Typedef as void on x86_64.
	(exception::handler_installed): Remove.
	(exception::handle_while_being_debugged): Remove.
	(exception::myfault_handle): Declare for x86_64.
	(exception::handle): Declare as ordinary exception handler on x86_64
	as well.
	(exception::exception): Drop previous code (again).  Install
	exception::handle as SEH handler.
	(exception::install_myfault_handler): New x86_64-only method to
	install exception::myfault_handle as VEH handler.  Explain why.
	(exception::~exception): For x86_64, define frame end label (again).
	* exceptions.cc (CYG_EXC_CONTINUE_EXECUTION): Drop definition.
	(CYG_EXC_CONTINUE_SEARCH): Ditto.
	(exception::myfault_handle): New x86_64-only method, VEH handler to
	handle myfault exceptions.
	(exception::handle): Define as ordinary exception handler on x86_64
	as well.  Use ExceptionContinueExecution and ExceptionContinueSearch
	throughout instead of deleted Cygwin macros.  Don't handle myfault
	exceptions on x86_64.
@
text
@d548 3
a550 1
#endif /* __x86_64 */
d553 7
a559 3
/* myfault vectored exception handler */
LONG
exception::myfault_handle (LPEXCEPTION_POINTERS ep)
d561 2
a562 4
  _cygtls& me = _my_tls;

  if (me.andreas)
    me.andreas->leave ();	/* Return from a "san" caught fault */
a564 1
#endif /* __x86_64 */
d566 6
a571 1
/* Main exception handler. */
d574 1
a578 1
#ifndef __x86_64__
d581 4
d590 1
a590 1
      return ExceptionContinueExecution;
d596 1
a596 1
    return ExceptionContinueSearch;
d665 1
a665 1
	  return ExceptionContinueExecution;
d699 1
a699 1
      return ExceptionContinueExecution;
d705 1
a705 1
      return ExceptionContinueSearch;
d741 1
a741 1
      return ExceptionContinueExecution;
d776 1
a776 1
  return ExceptionContinueExecution;
@


1.432.2.6
log
@* DevNotes: Add entry cgf-000025.
* exceptions.cc (_cygtls::signal_debugger): Reorganize to avoid contacting the
debugger if we have already done so via the exception handler.  Eliminate need
for goto.  Remove an ifdef in favor of just allocating a larger buffer.
@
text
@d1464 2
a1465 4
  HANDLE th;
  /* If si.si_cyg is set then the signal was already sent to the debugger. */
  if (isinitialized () && !si.si_cyg && (th = (HANDLE) *this)
      && being_debugged () && SuspendThread (th) >= 0)
d1468 7
a1474 2
      c.ContextFlags = CONTEXT_FULL;
      if (GetThreadContext (th, &c))
d1476 4
d1486 1
a1486 7
	  memcpy (&thread_context, &c, (&thread_context._internal -
					(unsigned char *) &thread_context));
	  /* Enough space for 32/64 bit addresses */
	  char sigmsg[2 * sizeof (_CYGWIN_SIGNAL_STRING " ffffffff ffffffffffffffff")];
	  __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %d %y %p", si.si_signo,
			   thread_id, &thread_context);
	  OutputDebugString (sigmsg);
d1488 10
a1497 1
      ResumeThread (th);
d1499 3
@


1.432.2.7
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@d492 1
a492 1
  WCHAR dbg_cmd[strlen(debugger_command) + 1];
d558 1
a558 14
    {
      /* Only handle the minimum amount of exceptions the myfault handler
	 was designed for. */
      switch (ep->ExceptionRecord->ExceptionCode)
	{
	case STATUS_ACCESS_VIOLATION:
	case STATUS_DATATYPE_MISALIGNMENT:
	case STATUS_STACK_OVERFLOW:
	case STATUS_ARRAY_BOUNDS_EXCEEDED:
	  me.andreas->leave ();	/* Return from a "san" caught fault */
	default:
	  break;
	}
    }
@


1.432.2.8
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d485 1
a485 1
	  break;
a487 1
  FreeEnvironmentStringsW (rawenv);
a564 5
#if 0
	/* PAGE_GUARD-based stack commits are based on structured exception
	   handling.  Short-circuiting STATUS_STACK_OVERFLOW in a vectored
	   exception handler disables that, which can ultimately result in
	   a spurious SEGV. */
a565 1
#endif
@


1.432.2.9
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d344 3
d348 4
a351 6
  __try
    {
      if (already_dumped || cygheap->rlim_core == 0Ul)
	return;
      already_dumped = true;
      open_stackdumpfile ();
d353 2
a354 2
      if (e)
	dump_exception ();
d356 1
a356 1
      int i;
d358 1
a358 1
      thestack.init (framep, 1, ctx);	/* Initialize from the input CONTEXT */
d360 1
a360 1
      small_printf ("Stack trace:\r\nFrame        Function    Args\r\n");
d362 1
a362 1
      small_printf ("Stack trace:\r\nFrame     Function  Args\r\n");
d364 12
a375 16
      for (i = 0; i < 16 && thestack++; i++)
	{
	  small_printf (_AFMT "  " _AFMT, thestack.sf.AddrFrame.Offset,
			thestack.sf.AddrPC.Offset);
	  for (unsigned j = 0; j < NPARAMS; j++)
	    small_printf ("%s" _AFMT, j == 0 ? " (" : ", ",
			  thestack.sf.Params[j]);
	  small_printf (")\r\n");
	}
      small_printf ("End of stack trace%s\n",
		    i == 16 ? " (more stack frames may be present)" : "");
      if (h)
	NtClose (h);
    }
  __except (NO_ERROR) {}
  __endtry
d552 28
a579 11
/* myfault exception handler. */
EXCEPTION_DISPOSITION
exception::myfault (EXCEPTION_RECORD *e, exception_list *frame, CONTEXT *in,
		    PDISPATCHER_CONTEXT dispatch)
{
  PSCOPE_TABLE table = (PSCOPE_TABLE) dispatch->HandlerData;
  RtlUnwindEx (frame,
	       (char *) dispatch->ImageBase + table->ScopeRecord[0].JumpTarget,
	       e, 0, in, dispatch->HistoryTable);
  /* NOTREACHED, make gcc happy. */
  return ExceptionContinueSearch;
d581 1
a581 1
#endif
d584 2
a585 3
EXCEPTION_DISPOSITION
exception::handle (EXCEPTION_RECORD *e, exception_list *frame, CONTEXT *in,
		   PDISPATCHER_CONTEXT dispatch)
@


1.431
log
@* globals.cc (hntdll): Define/declare.
* exceptions.cc (inside_kernel): Don't call GetModuleFileName if we know we're
in ntdll.
* sigproc.cc (wait_sig): Initialize hntdll.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d125 2
a126 2
static void
open_stackdumpfile ()
a151 1
      HANDLE h;
d374 2
@


1.430
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d397 3
@


1.429
log
@* exceptions.cc (signal_exit): Remove comment.  Use __builtin_frame_address.
@
text
@a14 2
#include <wingdi.h>
#include <winuser.h>
@


1.428
log
@* exceptions.cc (signal_exit): Nope.  Nevermind.  Dump core unconditionally.
@
text
@a1220 2
	/* FIXME: We're still dumping core even if !(sig & 0x80).  Need to
	   investigate if this should be shortcircuited in that case.  */
d1229 1
a1229 1
	    cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.rbp, &c);
d1232 1
a1232 1
	    cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.ebp, &c);
@


1.427
log
@reword comment
@
text
@d1218 1
a1218 2
	if (si->si_code == SI_KERNEL)
	  sig |= 0x80;		/* Flag that we've "dumped core" */
@


1.426
log
@* exceptions.cc (signal_exit): Add a FIXME comment.
@
text
@d1223 1
a1223 1
	   investigate if the else clause can just be nuked.  */
@


1.425
log
@* exceptions.cc (signal_exit): Only dump core when it's a "kernel" signal.
Only use RtlCaptureContext on x86_64.  It doesn't seem to do what's expected on
x86.
@
text
@d1222 2
@


1.424
log
@* exceptions.cc (try_to_debug): Don't use yield() when waiting for another
process.
(sigpacket::setup_handler): Fix long-standing problem where loop could exit
with lock held.
@
text
@d1218 2
a1219 1
	sig |= 0x80;		/* Flag that we've "dumped core" */
d1228 1
a1229 1
#ifdef __x86_64__
d1232 1
@


1.423
log
@* cygwait.cc (cygwait): Remove lock around sig retrieval since this code is
essentially guarded by thread-specific signal_arrived.
* exceptions.cc (_cygtls::handle_SIGCONT): Simplify.  Eliminate lock/unlock
since code is guarded by signal_arrived.
@
text
@d511 1
a511 1
	yield ();
d926 4
a929 1
	    sigproc_printf ("thread handle NULL, not set up yet?");
d942 1
@


1.422
log
@* exceptions.cc (_cygtls::handle_SIGCONT): Reinstate previous behavior but make
sure that yield() isn't called when signal stack is locked.
@
text
@d1255 22
a1276 32
  if (ISSTATE (myself, PID_STOPPED))
    {
      myself->stopsig = 0;
      myself->process_state &= ~PID_STOPPED;
      int state = 0;
      /* Carefully tell sig_handle_tty_stop to wake up.
	 Make sure that any pending signal is handled before trying to
	 send a new one.  Then make sure that SIGCONT has been recognized
	 before exiting the loop.  */
      while (state < 2)
       {
	 lock ();
	 bool do_yield = !!sig;
	 if (do_yield)
	   /* signal still being processed */;
	 else if (state)
	   state++;		/* state == 2: signal no longer being processed */
	 else
	   {
	     sig = SIGCONT;
	     SetEvent (signal_arrived);
	     state++;		/* state == 1: alert sig_handle_tty_stop */
	     do_yield = true;	/* wake up other thread */
	   }
	 unlock ();
	 if (do_yield)
	   yield ();
       }
      /* Tell wait_sig to handle any queued signals now that we're alive
	 again. */
      sig_dispatch_pending (false);
    }
@


1.421
log
@* exceptions.cc (exception::handle): Add comment explaining si_addr behavior.
@
text
@d1259 24
a1282 10
      /* Carefully tell sig_handle_tty_stop to wake up.  */
      lock ();
      sig = SIGCONT;
      SetEvent (signal_arrived);
      /* Make sure yield doesn't run under lock condition to avoid
         starvation of sig_handle_tty_stop. */
      unlock ();
      /* Wait until sig_handle_tty_stop woke up. */
      while (sig)
	yield ();
@


1.420
log
@	* exceptions.cc (_cygtls::handle_SIGCONT): Simplify loop waiting for
	sig_handle_tty_stop to wake up.  Make sure to unlock before calling
	yield to avoid starvation of sig_handle_tty_stop.  Add comments.
	* miscfuncs.cc (yield): Explain why yield should never be called under
	_cygtls::lock conditions.  Call SleepEx with 1ms timeout.  Explain why.
@
text
@d756 4
d774 5
a778 6
 * Note: This implementation is based on the Single UNIX Specification
 * man page.  This indicates that sigsuspend always returns -1 and that
 * attempts to block unblockable signals will be silently ignored.
 * This is counter to what appears to be documented in some UNIX
 * man pages, e.g. Linux.
 */
@


1.419
log
@	*  exceptions.cc (exception::handle): Resurrect accidentally lost
	patch from 2009-07-22: Set si_addr according to POSIX for SIGSEGV.
@
text
@a1255 1
      int state = 0;
d1257 9
a1265 15
      while (state < 2)
       {
	 lock ();
	 if (sig)
	   yield ();           /* state <= 1 */
	 else if (state)
	   state++;            /* state == 2 */
	 else
	   {
	     sig = SIGCONT;
	     SetEvent (signal_arrived);
	     state++;          /* state == 1 */
	   }
	 unlock ();
       }
d1267 1
a1267 1
	again. */
@


1.418
log
@* exceptions.cc (cygwin_exception::dumpstack): Guard against wild pointer
dereference.
(CYG_EXC_CONTINUE_EXECUTION): Define based on standard Windows definition.
(CYG_EXC_CONTINUE_SEARCH): Ditto.
(exception::handle): Move andreas detection earlier.  Make comment clearer.
(signal_exit): Set core-dumped flag.
@
text
@d756 2
a757 1
  si.si_addr = (void *) in->_GR(ip);
@


1.417
log
@	* Merge in cygwin-64bit-branch.
@
text
@d347 3
d559 2
a560 2
#define CYG_EXC_CONTINUE_EXECUTION	0
#define CYG_EXC_CONTINUE_SEARCH		1
d569 3
d583 2
a584 2
  /* If we're exiting, don't do anything here.  Returning 1
     tells Windows to keep looking for an exception handler.  */
a697 3
  if (me.andreas)
    me.andreas->leave ();	/* Return from a "san" caught fault */

d1210 10
a1219 9
       if (try_to_debug ())
	 break;
       if (si->si_code != SI_USER && si->si_cyg)
	 ((cygwin_exception *) si->si_cyg)->dumpstack ();
       else
	 {
	   CONTEXT c;
	   c.ContextFlags = CONTEXT_FULL;
	   RtlCaptureContext (&c);
d1221 1
a1221 1
	   cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.rbp, &c);
d1223 1
a1223 1
	   cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.ebp, &c);
d1225 3
a1227 3
	   exc.dumpstack ();
	 }
       break;
d1233 4
a1236 1
    myself.exit (sig);
@


1.416
log
@* cygtls.h (_cygtls::reset_signal_arrived): Actually reset the signal_arrived
event.
(_cygtls::handle_SIGCONT): Declare ew function.
* cygwait.cc (is_cw_sig_handle): Delete.
(is_cw_sig_cont): New convenience define.
(cygwait): Clear signal if is_cw_sig_cont and we got a SIGCONT.
* cygwait.h (cw_wait_mask): Add cw_sig_cont.
* exceptions.cc (sig_handle_tty_stop): Tighten "incyg" region.  Use cw_sig_cont
param for cygwait.  Don't zero signal here outside of lock.
(sigpacket::setup_handler): Don't check for in_forkee since we will now never
get here in that state.
(_cygtls::handle_SIGCONT): Define new function.
(sigpacket::process): Call handle_SIGCONT early to deal with SIGCONT.  Nuke
continue_now handling.  Allow SIGKILL to kill a suspended process.  Delete a
couple of now-unneeded labels.
(_cygtls::call_signal_handler): Reorganize setting of incyg within lock.
* sigproc.cc (pending_signals): Simplify.
(pending_signals::clear): New method.
(_cygtls::remove_wq): Reorganize to always close wq.thread_ev if it exists to
avoid handle leaks.
(sig_clear): Simplify by just calling sigq.clear().
(sig_dispatch_pending): Always call sigq.pending even in signal thread to force
another loop in wait_sig.
(sig_send): Remove a "goto out" just before out: label.
(pending_signals::add): Simplify.
(pending_signals::del): Delete.
(pending_signals::next): Delete.
(wait_sig): Define variable q to be the start of the signal queue.  Just
iterate through sigq queue, deleting processed or zeroed signals.  Only set
clearwait when the current signal is SIGCHLD.
* sigproc.h: Add a comment about an unused enum.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d35 11
d53 1
a53 1
NO_COPY static struct
d192 14
d213 3
a215 1
		ctx->Ebp, ctx->Esp, myself->progname, myself->pid, cygthread::name ());
d226 5
a230 1
  DWORD dummy_frame;
d233 1
a233 1
  void init (DWORD, bool, bool); /* Called the first time that stack info is needed */
d247 1
a247 1
stack_info::init (DWORD ebp, bool wantargs, bool goodframe)
d249 10
a258 1
# define debp ((DWORD *) ebp)
d260 2
a261 2
  if (!goodframe)
    sf.AddrFrame.Offset = ebp;
d264 2
a265 2
      dummy_frame = ebp;
      sf.AddrFrame.Offset = (DWORD) &dummy_frame;
d267 2
a268 1
  sf.AddrReturn.Offset = debp[1];
a270 1
# undef debp
d280 30
a309 1
  char **ebp;
d314 2
a315 1
  if (((ebp = (char **) next_offset ()) == NULL) || (ebp >= (char **) cygwin_hmodule))
d318 1
a318 1
  sf.AddrFrame.Offset = (DWORD) ebp;
d322 1
a322 1
  sf.AddrReturn.Offset = (DWORD) *++ebp;
d329 1
a329 1
      sf.Params[0] = (DWORD) *++ebp;
d337 1
a337 1
	sf.Params[i] = (DWORD) *++ebp;
a338 1

d340 1
d358 4
a361 1
  thestack.init (ebp, 1, !ctx);	/* Initialize from the input CONTEXT */
d363 1
d366 1
a366 1
      small_printf ("%08x  %08x ", thestack.sf.AddrFrame.Offset,
d369 1
a369 1
	small_printf ("%s%08x", j == 0 ? " (" : ", ", thestack.sf.Params[j]);
d386 2
a387 2
  if (!VirtualQuery ((LPCVOID) cx->Eip, &m, sizeof m))
    sigproc_printf ("couldn't get memory info, pc %p, %E", cx->Eip);
d407 1
d412 1
d414 1
a414 1
  sigproc_printf ("pc %p, h %p, inside_kernel %d", cx->Eip, h, res);
d425 2
a426 2
  GetThreadContext (GetCurrentThread (), &c);
  cygwin_exception exc (c.Ebp);
d519 7
a525 3
extern "C" void WINAPI RtlUnwind (void *, void *, PEXCEPTION_RECORD, void *);
static void __reg3 rtl_unwind (exception_list *, PEXCEPTION_RECORD) __attribute__ ((noinline, ));
void __stdcall
d543 1
d547 11
a557 1
extern exception_list *_except_list asm ("%fs:0");
d561 1
d566 5
d574 1
a574 1
      return 0;
d580 1
a580 1
    return 1;
d649 1
a649 1
	  return 0;
d683 1
a683 1
      return 0;
d689 1
a689 1
      return 1;
d695 2
a696 2
  debug_printf ("In cygwin_except_handler exception %p at %p sp %p", e->ExceptionCode, in->Eip, in->Esp);
  debug_printf ("In cygwin_except_handler signal %d at %p", si.si_signo, in->Eip);
d698 11
a708 3
  DWORD *ebp = (DWORD *) in->Esp;
  for (DWORD *bpend = (DWORD *) __builtin_frame_address (0); ebp > bpend; ebp--)
    if (*ebp == in->SegCs && ebp[-1] == in->Eip)
d710 1
a710 1
	ebp -= 2;
d718 1
d728 1
a728 1
      return 0;
d741 9
a749 3
      klog (LOG_INFO, "%s[%d]: segfault at %08x rip %08x rsp %08x error %d",
		      __progname, myself->pid, e->ExceptionInformation[1],
		      in->Eip, in->Esp, error_code);
d751 1
a751 2

  cygwin_exception exc ((DWORD) ebp, in, e);
d753 1
a753 1
  si.si_addr = (void *) in->Eip;
d758 1
a758 1
  return 0;
d778 1
a778 1
  sigproc_printf ("oldmask %p, newmask %p", oldmask, tempmask);
d844 2
a845 1
      push ((__stack_t) cx->Eip);
d847 1
a847 1
      cx->Eip = pop ();
d854 1
a854 1
void __stdcall
d1165 1
a1165 1
  sigproc_printf ("oldmask %p, newmask %p, deltamask %p", oldmask, newmask,
d1179 1
a1179 1
  sigproc_printf ("setmask %p, newmask %p, mask_bits %p", setmask, newmask,
d1207 17
a1223 10
	if (try_to_debug ())
	  break;
	if (si->si_code != SI_USER && si->si_cyg)
	  ((cygwin_exception *) si->si_cyg)->dumpstack ();
	else
	  {
	    cygwin_exception exc (_my_tls.thread_context.ebp);
	    exc.dumpstack ();
	  }
	break;
d1251 14
a1264 14
	{
	  lock ();
	  if (sig)
	    yield ();		/* state <= 1 */
	  else if (state)
	    state++;		/* state == 2 */
	  else
	    {
	      sig = SIGCONT;
	      SetEvent (signal_arrived);
	      state++;		/* state == 1 */
	    }
	  unlock ();
	}
d1266 1
a1266 1
	 again. */
d1276 1
a1276 1
int __stdcall
d1322 1
a1322 1

d1472 3
d1476 3
d1480 3
a1482 2
      memcpy (&thread_context, pc, (&thread_context._internal -
				   (unsigned char *) &thread_context));
d1484 2
a1485 1
      __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %d %p %p", si.si_signo,
d1490 2
a1491 2
    if (th)
      ResumeThread (th);
@


1.415
log
@* child_info.h (cygheap_exec_info::sigmask): Declare new field.
* cygheap.cc (init_cygheap::find_tls): Rename threadlist_ix -> ix.  Only take
one pass through thread list, looking for eligible threads to signal.  Set a
new param indicating that function has found a sigwait* mask.
* cygheap.h (init_cygheap::find_tls): Reflect new parameter.
* dcrt0.cc (parent_sigmask): New variable.
(child_info_spawn::handle_spawn): Save parent's signal mask here.
(dll_crt0_1): Restore parent's signal mask to tls sigmask as appropriate.  Call
sig_dispatch_pending to flush signal queue when we can finally do something
with signals.
* exceptions.cc (sigpacket::process): Avoid attempting to handle signals if we
haven't finished initializing.  Rely on the fact that find_tls will do mask
checking and don't do it again.  Delete ill-named 'dummy' variable.
* sigproc.cc (cygheap_exec_info::alloc): Save calling thread's signal mask in
new sigmask field.
(wait_sig): Try to debug when WFSO fails and DEBUGGING is defined.
* thread.cc (pthread::set_tls_self_pointer): Make this a true automatic method
rather than inexplicably relying on a thread parameter.
(pthread::thread_init_wrapper): Accommodate set_tls_self_pointer change to
non-static.  Initialize sigmask before setting tid or suffer signal races.
* ehread.h (pthread::set_tls_self_pointer): Make non-static, delete parameter.
@
text
@a688 1
  _my_tls.incyg = 1;
d695 1
d701 3
a703 1
      DWORD res = cygwait (NULL, cw_infinite, cw_sig_eintr);
a706 1
	  _my_tls.sig = 0;
d714 1
a715 1
  _my_tls.incyg = 0;
a788 4
  while (in_forkee)
    yield ();		/* Won't be able to send signals until we're finished
			   processing fork().  */

d1121 36
a1161 1
  bool continue_now = false;
d1165 2
d1170 1
a1170 13
      goto really_done;
    }

  if (si.si_signo == SIGCONT)
    {
      continue_now = ISSTATE (myself, PID_STOPPED);
      myself->stopsig = 0;
      myself->process_state &= ~PID_STOPPED;
      /* Clear pending stop signals */
      sig_clear (SIGSTOP);
      sig_clear (SIGTSTP);
      sig_clear (SIGTTIN);
      sig_clear (SIGTTOU);
d1178 11
a1188 1
  if (!sigtls)
d1204 2
a1205 1
  if (!tls || ISSTATE (myself, PID_STOPPED))
d1261 1
a1268 2
  if (si.si_signo == SIGKILL)
    goto dispatch_sig;
a1270 7
  if (ISSTATE (myself, PID_STOPPED) && !continue_now)
    {
      rc = -1;		/* No signals delivered if stopped */
      goto done;
    }

dispatch_sig:
a1278 1
  continue_now = false;
a1280 6
  if (continue_now)
    {
      (tls ?: _main_tls)->sig = SIGCONT;
      SetEvent (tls->signal_arrived);
    }
really_done:
d1314 2
a1316 1
      reset_signal_arrived ();
a1318 1
      incyg = false;
@


1.414
log
@* exceptions.cc (exception::handle): Generalize comment.
@
text
@d1127 11
a1137 2
  bool continue_now;
  struct sigaction dummy = global_sigs[SIGSTOP];
d1139 1
a1139 3
  if (si.si_signo != SIGCONT)
    continue_now = false;
  else
a1150 2
  int rc = 1;

a1151 1
  struct sigaction& thissig = global_sigs[si.si_signo];
d1156 6
a1161 1
  if (sigtls)
d1164 6
a1169 1
      sigproc_printf ("using sigtls %p", sigtls);
d1171 2
a1172 1
  else
d1174 3
a1176 2
      tls = cygheap->find_tls (si.si_signo);
      sigproc_printf ("using tls %p", tls);
d1183 5
a1187 1
  void *handler = have_execed ? NULL : (void *) thissig.sa_handler;
a1202 12
  if (sigismember (&tls->sigwait_mask, si.si_signo))
    {
      tls->sigwait_mask = 0;
      goto dosig;
    }
  if (sigismember (&tls->sigmask, si.si_signo) || ISSTATE (myself, PID_STOPPED))
    {
      sigproc_printf ("signal %d blocked", si.si_signo);
      rc = -1;
      goto done;
    }

d1229 1
a1229 1
  thissig = dummy;
d1259 1
a1259 1
      tls->sig = SIGCONT;
d1262 1
@


1.413
log
@* cygtls.h (_cygtls::signal_debugger): Change argument type.
(_cygtls::copy_context): Delete declaration.
* exceptions.cc (exception::handle): Don't call copy_context() here.  Move
signal_handler call earlier and always call it.
(_cygtls::copy_context): Delete definition.
(_cygtls::signal_debugger): Move copy_context logic here.  Suspend thread
receiving signal before gathering context information.
@
text
@d625 1
a625 1
  /* FIXME: Probably should be handled in sigpacket::process */
@


1.412
log
@Remove now-inappropriate comment.
@
text
@a608 2
  me.copy_context (in);

d1163 4
a1237 12
  /* Do stuff for gdb */
  if (si.si_code == SI_USER || !si.si_cyg)
    {
      CONTEXT c;
      c.ContextFlags = CONTEXT_FULL;
      GetThreadContext (hMainThread, &c);
      _my_tls.copy_context (&c);

      /* Tell gdb that we got a signal. Presumably, gdb already noticed this
         if we hit an exception.  */
      _my_tls.signal_debugger (si.si_signo);
    }
d1305 1
a1305 7
_cygtls::copy_context (CONTEXT *c)
{
  memcpy (&thread_context, c, (&thread_context._internal - (unsigned char *) &thread_context));
}

void
_cygtls::signal_debugger (int sig)
d1307 1
d1310 20
d1331 2
a1332 1
      __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %d %p %p", sig, thread_id, &thread_context);
d1335 3
@


1.411
log
@* exceptions.cc (exception::handle): Eliminate buggy recursed value and just
check if we're exiting.
@
text
@a615 2
  /* Another exception could happen while tracing or while exiting.
     Only do this once.  */
@


1.410
log
@* DevNotes: Add entry cgf-000022.
* cygtls.h (_cygtls::func): Define as a sa_sigaction style function.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(_cygtls::interrupt_setup): Fix coercion to accommodate 'func' change.
(ctrl_c_handler): Use tty kill_pgrp to send a signal.
(sigpacket::process): Don't process sigflush here.
(_cygtls::call_signal_handler): Reorganize to avoid a race.  Always call
sa_sigaction style function.
* fhandler_termios.cc (is_flush_sig): Define new function.
(tty_min::kill_pgrp): Handle tty flush when signal detected.
(fhandler_termios::bg_check): Be slightly more paranoid about checking for
valid tty.
(fhandler_termios::sigflush): Don't flush unless tty owner.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Use tty kill_pgrp to send
signal.
(fhandler_pty_master::ioctl): Ditto.
* signal.cc (killsys): Delete definition.
* sigproc.h (killsys): Delete declaration.
* include/cygwin/signal.h (siginfo_t): Simplify union/struct nesting slightly.
Implement mechanism to allow cygwin data passing.
@
text
@a471 1
  static int NO_COPY recursed;
d618 3
a620 2
  if (recursed++)
    api_fatal ("Error while dumping state (probably corrupted stack)");
@


1.409
log
@* exceptions.cc (exception::handle): Make attempt to recursively dump stack
fatal.
@
text
@d691 1
a691 1
sig_handle_tty_stop (int sig)
d751 1
a751 1
  func = (void (*) (int)) handler;
d959 1
a959 1
      killsys (-myself->pid, sig);
a1147 13
  switch (si.si_signo)
    {
    case SIGINT:
    case SIGQUIT:
    case SIGSTOP:
    case SIGTSTP:
      if (cygheap->ctty)
	cygheap->ctty->sigflush ();
      break;
    default:
      break;
    }

d1291 2
d1294 2
a1295 1
      void (*thisfunc) (int) = func;
d1299 1
a1299 1
      sig = 0;
d1301 5
a1305 14
      unlock ();	// make sure synchronized
      if (!(this_sa_flags & SA_SIGINFO))
	{
	  incyg = false;
	  thisfunc (thissig);
	}
      else
	{
	  siginfo_t thissi = infodata;
	  void (*sigact) (int, siginfo_t *, void *) = (void (*) (int, siginfo_t *, void *)) thisfunc;
	  /* no ucontext_t information provided yet */
	  incyg = false;
	  sigact (thissig, &thissi, NULL);
	}
d1307 1
@


1.408
log
@* dcrt0.cc (dll_crt0_1): Comment assumption.
* exceptions.cc (sigpacket::setup_handler): Avoid sending signals during fork
processing.
@
text
@d620 1
a620 1
    system_printf ("Error while dumping state (probably corrupted stack)");
@


1.407
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d792 4
@


1.406
log
@* exceptions.cc (ctrl_c_handler): Remove special-case handler for
"cygwin_finished_initializing".
* sigproc.cc (exit_thread): Undefine ExitThread earlier to avoid recursion on
error return.
@
text
@d44 1
a44 1
  unsigned int code;
d173 1
a173 1
	  if (status_info[i].code == e->ExceptionCode)
d444 1
a444 1
static void __stdcall rtl_unwind (exception_list *, PEXCEPTION_RECORD) __attribute__ ((noinline, regparm (3)));
@


1.405
log
@* exceptions.cc (signal_exit): Move captive process termintation...
(_cygtls::interrupt_setup): ...into here.
(sigpacket::process): Simplify setting of handler when have_execed.
(_cygtls::interrupt_setup): Don't call proc_subproc when we've execed.
* globals.cc (exit_states): Delete unneeded ES_EXEC_EXIT.
* pinfo.cc (pinfo::exit): Change debugging output.  Call proc_terminate rather
than the now-obsolete sigproc_terminate.  Don't set exit_state to ES_EXEC_EXIT.
Set exit_state to ES_FINAL later.
* sigproc.cc (sigproc_terminate): Delete function.
(wait_sig): Don't call proc_subproc if have_execed.
* sigproc.h (sigproc_terminate): Delete declaration.
* sync.h (lock_process::lock_process): Don't set exit_state to
ES_PROCESS_LOCKED.
(lock_process::operator LONG): Define.
@
text
@a877 8
  if (!cygwin_finished_initializing)
    {
      if (myself->cygstarted)	/* Was this process created by a cygwin process? */
	return TRUE;		/* Yes.  Let the parent eventually handle CTRL-C issues. */
      debug_printf ("exiting with status %p", STATUS_CONTROL_C_EXIT);
      ExitProcess (STATUS_CONTROL_C_EXIT);
    }

@


1.404
log
@	* cygerrno.h: Fix copyright.
	* exceptions.cc: Drop comment explaining removed variable.
@
text
@d767 2
a768 1
  proc_subproc (PROC_CLEARWAIT, 1);
a1092 6
  if (have_execed)
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (ch_spawn, sigExeced = sig);
    }

d1184 1
a1184 3
  void *handler = (void *) thissig.sa_handler;
  if (have_execed)
    handler = NULL;
d1267 5
@


1.403
log
@* cygtls.h (_cygtls::signal_exit): Delete from class.
* exception.h (cygwin_exception): New class.
(cygwin_exception::dumpstack): Declare new function.
(cygwin_exception::context): Ditto.
(cygwin_exception::dump_exception): Ditto.
* exceptions.cc (cygwin_exception::dump_exception): Move into cygwin_exception
class.  Accommodate new variable names.
(cygwin_exception::dumpstack): Ditto stackdump -> dumpstack.
(exception::handle): Move andreas processing earlier.  Defer signal processing
decisions to the signal thread where they belong.  Pass exception information
to sig_send via new siginfo_t si_cyg field.
(ctrl_c_handler): Wait for SIGHUP signal to be processed since it could cause a
process exit and we don't want races with thread exit lock.
(signal_exit): Move back here from sigproc.cc.  Modify arguments and remove
from sigpacket class.  Decide when to dump core based on signal type.
(sigpacket::process): Handle exiting signals in context of threads rather than
in the signal thread.  Signal debugger on non-Windows signals.  Remove
setup_signal_exit call.
* sigproc.cc (no_signals_available): Remove argument.
(signal_exit_code): Delete.
(close_my_readsig): Ditto.
(_cygtls::signal_exit): Move to exceptions.cc.
(sigproc_terminate): Don't attempt to terminate signal thread.
(setup_signal_exit): Delete.
(exit_thread): Use new si_cyg entry in siginfo_t.
(sig_send): Just use empty initializer for si.  Accommodate change in
no_signals_available argument.
(wait_sig): Remove attempt to "go asynchronous" on process exit.  Delete
__SIGEXIT handling.  Don't ever exit.
* sigproc.h: Remove __SIGEXIT from signal enum.  Renumber.
* include/cygwin/signal.h (siginfo_t): Add si_cyg entry.
@
text
@a41 2
/* This is set to indicate that we have already exited.  */

@


1.402
log
@* DevNotes: Add entry cgf-000019.
* dcrt0.cc (do_exit): Just set exit_state to ES_EVENTS_TERMINATE and nuke call
to events_terminate which just set a superfluous flag.
* sigproc.cc (signal_exit_code): New variable.
(setup_signal_exit): Define new function.
(_cygtls::signal_exit): Remove accommodations for closing the signal pipe
handle.
(exit_thread): Just sleep if we're exiting.
(wait_sig): If signal_exit_code is set, just handle bookkeeping signals and
exit ReadFile loop if there is nothing more to process.  Call signal_exit at
end if signal_exit_code is non-zero.
* sigproc.h (setup_signal_exit): Declare new function.
* exceptions.cc (sigpacket::process): Use setup_signal_exit to control exiting
due to a signal.
(exception::handle): Ditto.  Query exit_state rather than defunct exit_already
to determine if we are exiting.
* globals.cc (ES_SIGNAL_EXIT): New enum.
* sync.h (lock_process::release): New function for explicitly unlocking muto.
(lock_process::~lock_process): Use release method.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d166 2
a167 2
static void
dump_exception (EXCEPTION_RECORD *e,  CONTEXT *in)
d184 1
a184 1
    small_printf ("Exception: %s at eip=%08x\r\n", exception_name, in->Eip);
d186 1
a186 1
    small_printf ("Signal %d at eip=%08x\r\n", e->ExceptionCode, in->Eip);
d188 1
a188 1
		in->Eax, in->Ebx, in->Ecx, in->Edx, in->Esi, in->Edi);
d190 1
a190 1
		in->Ebp, in->Esp, myself->progname, myself->pid, cygthread::name ());
d192 1
a192 1
		in->SegCs, in->SegDs, in->SegEs, in->SegFs, in->SegGs, in->SegSs);
d276 1
a276 1
stackdump (DWORD ebp, PCONTEXT in, EXCEPTION_RECORD *e)
d286 1
a286 1
    dump_exception (e, in);
d290 1
a290 1
  thestack.init (ebp, 1, !in);	/* Initialize from the input CONTEXT */
d352 2
a353 1
  stackdump (c.Ebp);
d488 1
a488 1
  siginfo_t si = {0};
d598 3
a603 8
  bool masked = !!(me.sigmask & SIGTOMASK (si.si_signo));
  if (masked)
    syscall_printf ("signal %d, masked %p", si.si_signo,
		    global_sigs[si.si_signo].sa_mask);

  debug_printf ("In cygwin_except_handler calling %p",
		 global_sigs[si.si_signo].sa_handler);

a611 3
  if (me.andreas)
    me.andreas->leave ();	/* Return from a "san" caught fault */

d619 10
a628 49
  if (masked
      || &me == _sig_tls
      || !cygwin_finished_initializing
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_DFL
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_IGN
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_ERR)
    {
      /* Print the exception to the console */
      if (!myself->cygstarted)
	for (int i = 0; status_info[i].name; i++)
	  if (status_info[i].code == e->ExceptionCode)
	    {
	      system_printf ("Exception: %s", status_info[i].name);
	      break;
	    }

      /* Another exception could happen while tracing or while exiting.
	 Only do this once.  */
      if (recursed++)
	system_printf ("Error while dumping state (probably corrupted stack)");
      else
	{
	  if (try_to_debug (0))
	    {
	      debugging = true;
	      return 0;
	    }

	  rtl_unwind (frame, e);
	  if (cygheap->rlim_core > 0UL)
	    stackdump ((DWORD) ebp, in, e);
	}

      if ((NTSTATUS) e->ExceptionCode == STATUS_ACCESS_VIOLATION)
	{
	  int error_code = 0;
	  if (si.si_code == SEGV_ACCERR)	/* Address present */
	    error_code |= 1;
	  if (e->ExceptionInformation[0])	/* Write access */
	    error_code |= 2;
	  if (!me.inside_kernel (in))		/* User space */
	    error_code |= 4;
	  klog (LOG_INFO, "%s[%d]: segfault at %08x rip %08x rsp %08x error %d",
			  __progname, myself->pid,
			  e->ExceptionInformation[1], in->Eip, in->Esp,
			  error_code);
	}

      setup_signal_exit ((cygheap->rlim_core > 0UL ? 0x80 : 0) | si.si_signo);
d631 18
a648 4
  si.si_addr =  (si.si_signo == SIGSEGV || si.si_signo == SIGBUS
		 ? (void *) e->ExceptionInformation[1]
		 : (void *) in->Eip);
  si.si_errno = si.si_pid = si.si_uid = 0;
d650 1
a650 1
  sig_send (NULL, si, &me);	// Signal myself
d933 1
a933 1
	      sig_send (myself_nowait, SIGHUP);
d1086 53
d1248 7
d1258 1
d1260 1
a1260 6
  else
    {
      /* Dispatch to the appropriate function. */
      sigproc_printf ("signal %d, signal handler %p", si.si_signo, handler);
      rc = setup_handler (handler, thissig, tls);
      continue_now = false;
d1263 18
a1289 4
exit_sig:
  sigproc_printf ("setting up for exit with signal %d", si.si_signo);
  setup_signal_exit (si.si_signo);
  return rc;
@


1.401
log
@* exceptions.cc (sigpacket::process): Reorganize to avoid use of tls before
initialization.
* fhandler_fifo.cc (fhandler_fifo::arm): Avoid improper printing of integer as
a string in debug output.
@
text
@a43 2
static NO_COPY int exit_already = 0;

d482 1
a482 1
  /* If we've already exited, don't do anything here.  Returning 1
d484 1
a484 1
  if (exit_already || e->ExceptionFlags)
d674 1
a674 2
      /* Flag signal + core dump */
      me.signal_exit ((cygheap->rlim_core > 0UL ? 0x80 : 0) | si.si_signo);
d1249 3
a1251 7
  tls->signal_exit (si.si_signo);	/* never returns */
}

void
events_terminate ()
{
  exit_already = 1;
@


1.400
log
@* sigproc.h (sigpacket): Remove parameter names from declarations.
(sigpacket::sigtls): Rename from 'tls'.
* exceptions.cc (sigpacket::process): Define local tls variable and assign that
to sigtls if appropriate.  Clarify debugging output.
* sigproc.cc (sig_send): Accommodate tls -> sigtls rename.
(pending_signals::add): Ditto.
(wait_sig): Ditto.
@
text
@a1125 1
  _cygtls *tls;
d1161 1
a1161 10
  void *handler = (void *) thissig.sa_handler;
  if (handler == SIG_IGN)
    {
      sigproc_printf ("signal %d ignored", si.si_signo);
      goto done;
    }

  if (have_execed)
    handler = NULL;

d1165 1
a1165 1
      sigproc_printf ("using sigtls %p", tls);
d1173 10
@


1.399
log
@* cygtls.h (_cygtls::get_signal_arrived): Add parameter to make lock/unlock
conditional.
* exceptions.cc (_cygtls::interrupt_setup): Don't get a lock when setting
signal_arrived since we already have one.
* gendef: Add some comments to make it easier to find functions.
@
text
@d1126 1
d1172 5
a1176 2
  if (tls)
    sigproc_printf ("using tls %p", tls);
@


1.398
log
@* cygtls.h (_cygtls::will_wait_for_signal): Rename from 'signal_waiting' to
something more expressive.  Reflect rename throughout.
(_cygtls::get_signal_arrived): Rename from create_signal_arrived.  Move lock
here.
(_cygtls::set_signal_arrived): Use get_signal_arrived.
* exceptions.cc (_cygtls::interrupt_setup): Use get_signal_arrived.
* tlsoffsets.h: Regenerate.
@
text
@d802 1
a802 1
    SetEvent (get_signal_arrived ());
@


1.397
log
@* DevNotes: Add entry cgf-000016.
* cygtls.h (_cygtls::push): Inline.
(_cygtls::interrupt_now): Change signal number argument to siginfo_t argument.
(_cygtls::interrupt_setup): Ditto.
(_cygtls::set_siginfo): Delete declaration.
(_cygtls::reset_signal_arrived): Don't reset signal_arrived signal.  Just reset
flag.
* exceptions.cc (_cygtls::interrupt_now): Reflect argument changes.  Pass si to
interrupt_setup.
(_cygtls::interrupt_setup): Reflect argument changes.  Fill out tls infodata
here using passed-in si.  Use si.si_signo instead of sig.
(sigpacket::setup_handler): Move this function into sigpacket class.  Use si
field from the class as appropriate.
(sigpacket::process): Don't call tls->set_siginfo here since setup_handler
could fail.  Eliminate now-unneeded sig argument.
* sigproc.h (sigpacket::setup_handler): Move setup_handler to this class.
@
text
@d802 1
a802 5
    {
      if (!signal_arrived)
	create_signal_arrived ();
      SetEvent (signal_arrived);
    }
@


1.396
log
@* exceptions.cc (sig_handle_tty_stop): Clear tls sig field.
(sigpacket::process): When continuing, set tls->sig before arming
signal_arrived.
@
text
@d760 1
a760 1
_cygtls::interrupt_now (CONTEXT *cx, int sig, void *handler,
d774 1
a774 1
      interrupt_setup (sig, handler, siga);
d783 1
a783 1
_cygtls::interrupt_setup (int sig, void *handler, struct sigaction& siga)
d798 2
a799 1
  this->sig = sig;			// Should always be last thing set to avoid a race
d809 1
a809 1
  sigproc_printf ("armed signal_arrived %p, signal %d", signal_arrived, sig);
d819 2
a820 4
static int setup_handler (int, void *, struct sigaction&, _cygtls *tls)
  __attribute__((regparm(3)));
static int
setup_handler (int sig, void *handler, struct sigaction& siga, _cygtls *tls)
d828 1
a828 1
		      sig, tls->sig);
d841 1
a841 1
	      tls->interrupt_setup (sig, handler, siga);
d870 1
a870 1
		interrupted = tls->interrupt_now (&cx, sig, handler, siga);
d887 1
a887 1
  sigproc_printf ("signal %d %sdelivered", sig, interrupted ? "" : "not ");
a1235 1
      tls->set_siginfo (this);
d1238 1
a1238 1
      rc = setup_handler (si.si_signo, handler, thissig, tls);
@


1.395
log
@* cygheap.cc (init_cygheap::find_tls): Don't consider unitialized threads.
* cygtls.cc (_cygtls::operator HANDLE): Return NULL when tid is not set.
* exceptions.cc (setup_handler): Don't try to suspend a thread if it has no
handle.
@
text
@d746 1
d1246 4
a1249 1
    SetEvent (tls->signal_arrived);
@


1.394
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d849 22
d872 1
a872 10
	  /* Suspend the thread which will receive the signal.
	     If one of these conditions is not true we loop.
	     If the thread is already suspended (which can occur when a program
	     has called SuspendThread on itself) then just queue the signal. */

	  sigproc_printf ("suspending thread, tls %p, _main_tls %p", tls, _main_tls);
	  res = SuspendThread (hth);
	  /* Just set pending if thread is already suspended */
	  if (res)
	    {
d874 2
a875 1
	      goto out;
a876 10
	  cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	  if (!GetThreadContext (hth, &cx))
	    sigproc_printf ("couldn't get context of thread, %E");
	  else
	    interrupted = tls->interrupt_now (&cx, sig, handler, siga);

	  tls->unlock ();
	  ResumeThread (hth);
	  if (interrupted)
	    goto out;
@


1.393
log
@* cygtls.h (_cygtls::create_signal_arrived): New function.
(_cygtls::set_signal_arrived): Lock creation of signal_arrived.
* cygwait.cc (cancelable_wait): Ignore signal_arrived event if _my_tls 'sig'
element does not exist.
* exceptions.cc (_cygtls::interrupt_setup): Create signal_arrived if recipient
thread has not created it.
@
text
@d711 1
a711 1
  cancelable_wait (NULL, cw_infinite, cw_cancel | cw_cancel_self | cw_sig_eintr);
d742 1
a742 1
      DWORD res = cancelable_wait (NULL, cw_infinite, cw_sig_eintr);
@


1.392
log
@* exceptions.cc (sigdelayed): Move declaration to sigproc.h.
* sigproc.h (sigdelayed): Make symbol globally available.
* gendef (sigdelayed): Specifically zero incyg and stacklock.
* signal.cc (sigwaitinfo): Lock _my_tls and try harder to clean up signal
information.
@
text
@d799 6
a804 2
  if (incyg && signal_arrived)
    SetEvent (signal_arrived);
@


1.391
log
@* DevNotes: Add entry cgf-000014.
* cygheap.cc (tls_sentry): Move here, rename from 'sentry' in cygtls.cc
(tls_sentry::lock): Ditto.
(nthreads): Move from cygtls.cc
(THREADLIST_CHUNK): Ditto.
(cygheap_init): Call init_tls_list().
(init_cygheap::init_tls_list): Define new function.
(init_cygheap::add_tls): Ditto.
(init_cygheap::remove_tls): Ditto.
(init_cygheap::find_tls): Ditto.  Semi-resurrect from _cygtls::find_tls.
* cygheap.h (init_cygheap::init_tls_list): Declare new function.
(init_cygheap::add_tls): Ditto.
(init_cygheap::remove_tls): Ditto.
(init_cygheap::find_tls): Ditto.
* cygtls.cc (sentry): Delete.
(sentry::lock): Ditto.
(nthreads): Ditto.
(THREADLIST_CHUNK): Ditto.
(_cygtls::init): Delete definition.
(_cygtls::init_thread): Call cygheap->add_tls() to add thread to global list.
(_cygtls::remove): cygheap->remove_tls() to remove thread from global list.
* cygtls.h (_cygtls::init): Delete declaration.
* dcrt0.cc (dll_crt0_0): Delete call to _cygtls::init().
* exceptions.cc (sigpacket::process): When no thread is specified, try to find
one via cygheap->find_tls.
@
text
@a39 2
extern "C" void sigdelayed ();

@


1.391.2.1
log
@Pull in changes from HEAD
@
text
@d40 2
d713 1
a713 1
  cygwait (NULL, cw_infinite, cw_cancel | cw_cancel_self | cw_sig_eintr);
d744 1
a744 1
      DWORD res = cygwait (NULL, cw_infinite, cw_sig_eintr);
d801 2
a802 6
  if (incyg)
    {
      if (!signal_arrived)
	create_signal_arrived ();
      SetEvent (signal_arrived);
    }
@


1.391.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@a745 1
	  _my_tls.sig = 0;
d759 1
a759 1
_cygtls::interrupt_now (CONTEXT *cx, siginfo_t& si, void *handler,
d773 1
a773 1
      interrupt_setup (si, handler, siga);
d782 1
a782 1
_cygtls::interrupt_setup (siginfo_t& si, void *handler, struct sigaction& siga)
d797 1
a797 2
  infodata = si;
  this->sig = si.si_signo;		// Should always be last thing set to avoid a race
d807 1
a807 1
  sigproc_printf ("armed signal_arrived %p, signal %d", signal_arrived, si.si_signo);
d817 4
a820 2
int
sigpacket::setup_handler (void *handler, struct sigaction& siga, _cygtls *tls)
d828 1
a828 1
		      si.si_signo, tls->sig);
d841 1
a841 1
	      tls->interrupt_setup (si, handler, siga);
d849 10
a858 3
	  if (!hth)
	    sigproc_printf ("thread handle NULL, not set up yet?");
	  else
a859 20
	      /* Suspend the thread which will receive the signal.
		 If one of these conditions is not true we loop.
		 If the thread is already suspended (which can occur when a program
		 has called SuspendThread on itself) then just queue the signal. */

	      sigproc_printf ("suspending thread, tls %p, _main_tls %p", tls, _main_tls);
	      res = SuspendThread (hth);
	      /* Just set pending if thread is already suspended */
	      if (res)
		{
		  ResumeThread (hth);
		  goto out;
		}
	      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	      if (!GetThreadContext (hth, &cx))
		sigproc_printf ("couldn't get context of thread, %E");
	      else
		interrupted = tls->interrupt_now (&cx, si, handler, siga);

	      tls->unlock ();
d861 1
a861 2
	      if (interrupted)
		goto out;
d863 10
d883 1
a883 1
  sigproc_printf ("signal %d %sdelivered", si.si_signo, interrupted ? "" : "not ");
d1232 1
d1235 1
a1235 1
      rc = setup_handler (handler, thissig, tls);
d1241 1
a1241 4
    {
      tls->sig = SIGCONT;
      SetEvent (tls->signal_arrived);
    }
@


1.391.2.3
log
@	* exception.h (stackdump): Change first parameter to PUINT_PTR.
	* exceptions.cc: Define cpu specific macros _GR, _AFMT and _ADDR.
	Use throughout to avoid ifdef's.  Fix debug printfs to work in
	64 bit mode as well, throughout.
	(status_info): Define member code as NTSTATUS.  Add casts where
	necessary throughout.
	(dump_exception): Dump all x86_64 registers if building for it.
	(class stack_info): Define dummy_frame as PUINT_PTR.
	(stack_info::init): Change first parameter to PUINT_PTR.  Rename
	ebp to framep for CPU independent naming.  Drop debp macro.
	(stack_info::walk): Rename ebp to framep for CPU independent naming.
	Disable WOW64 hack in 64 bit mode.
	(stackdump): Change first parameter to PUINT_PTR.  Rename ebp to framep
	for CPU independent naming.
	(_cygtls::inside_kernel): Ignore system_wow64_directory on 64 bit.
	(rtl_unwind): Redefine for x86_64 cpu.
	(_except_list): Drop redundant definition.
	(_cygtls::copy_context): Just use __COPY_CONTEXT_SIZE.
	* sigproc.cc (_cygtls::signal_exit): Conditionalize stackdump call per
	cpu.
	* smallprint.cc (__small_vsprintf): Fix up for 64 bit.  Handle 'l' size
	modifier in 'd', 'o', 'u', 'x' conversion to print "long" values on a
	per cpu base.  Add 'O' conversion.  Change comment accrdingly.
	* include/cygwin/signal.h (struct _uc_fpxreg): Define for 64 bit.
	(struct _uc_xmmreg): Ditto.
	(struct _fpstate): Ditto.
	(struct ucontext): Ditto.
	(struct _uc_fpreg): Define for 32 bit.
	(struct _fpstate): Use struct _uc_fpreg for _st.  Use explicit sized
	types.
	(struct ucontext): Use explicit sized types.
	(__COPY_CONTEXT_SIZE): Cast safely.
	(sigset_t): Define as __uint64_t on 64 bit.  Add FIXME comment in 32
	bit case.
@
text
@a34 11
/* Definitions for code simplification */
#ifdef __x86_64__
# define _GR(reg)	R ## reg
# define _AFMT		"%016X"
# define _ADDR		DWORD64
#else
# define _GR(reg)	E ## reg
# define _AFMT		"%08x"
# define _ADDR		DWORD
#endif

d48 1
a48 1
  NTSTATUS code;
d177 1
a177 1
	  if (status_info[i].code == (NTSTATUS) e->ExceptionCode)
a184 14
#ifdef __x86_64__
  if (exception_name)
    small_printf ("Exception: %s at rip=%016X\r\n", exception_name, in->Rip);
  else
    small_printf ("Signal %d at rip=%016X\r\n", e->ExceptionCode, in->Rip);
  small_printf ("rax=%16X rbx=%16X rcx=%16X\r\n", in->Rax, in->Rbx, in->Rcx);
  small_printf ("rdx=%16X rsi=%16X rdi=%16X\r\n", in->Rdx, in->Rsi, in->Rdi);
  small_printf ("r8 =%16X r9 =%16X r10=%16X\r\n", in->R8, in->R9, in->R10);
  small_printf ("r11=%16X r12=%16X r13=%16X\r\n", in->R11, in->R12, in->R13);
  small_printf ("r14=%16X r15=%16X\r\n", in->R14, in->R15);
  small_printf ("rbp=%16X rsp=%16X program=%W, pid %u, thread %s\r\n",
		in->Rbp, in->Rsp, myself->progname, myself->pid,
		cygthread::name ());
#else
d192 1
a192 3
		in->Ebp, in->Esp, myself->progname, myself->pid,
		cygthread::name ());
#endif
d203 1
a203 1
  PUINT_PTR dummy_frame;
d206 1
a206 1
  void init (PUINT_PTR, bool, bool); /* Called the first time that stack info is needed */
d220 1
a220 1
stack_info::init (PUINT_PTR framep, bool wantargs, bool goodframe)
d222 1
d225 1
a225 1
    sf.AddrFrame.Offset = (UINT_PTR) framep;
d228 2
a229 2
      dummy_frame = framep;
      sf.AddrFrame.Offset = (UINT_PTR) &dummy_frame;
d231 1
a231 1
  sf.AddrReturn.Offset = framep[1];
d234 1
d244 1
a244 1
  char **framep;
d249 1
a249 2
  if (((framep = (char **) next_offset ()) == NULL)
      || (framep >= (char **) cygwin_hmodule))
d252 1
a252 1
  sf.AddrFrame.Offset = (_ADDR) framep;
d256 1
a256 1
  sf.AddrReturn.Offset = (_ADDR) *++framep;
d263 1
a263 2
      sf.Params[0] = (_ADDR) *++framep;
#ifndef __x86_64__
a269 1
#endif
d271 1
a271 1
	sf.Params[i] = (_ADDR) *++framep;
d273 1
d278 1
a278 1
stackdump (PUINT_PTR framep, PCONTEXT in, EXCEPTION_RECORD *e)
d292 1
a292 1
  thestack.init (framep, 1, !in);	/* Initialize from the input CONTEXT */
d296 1
a296 1
      small_printf (_AFMT "  " _AFMT, thestack.sf.AddrFrame.Offset,
d299 1
a299 1
	small_printf ("%s" _AFMT, j == 0 ? " (" : ", ", thestack.sf.Params[j]);
d316 2
a317 2
  if (!VirtualQuery ((LPCVOID) cx->_GR(ip), &m, sizeof m))
    sigproc_printf ("couldn't get memory info, pc %p, %E", cx->_GR(ip));
a336 1
#ifndef __x86_64__
a340 1
#endif
d342 1
a342 1
  sigproc_printf ("pc %p, h %p, inside_kernel %d", cx->_GR(ip), h, res);
d354 1
a354 1
  stackdump ((PUINT_PTR) c._GR(bp));
d446 1
a446 8
#ifdef __x86_64__
static void __stdcall rtl_unwind (exception_list *, PEXCEPTION_RECORD) __attribute__ ((noinline));
void __stdcall
rtl_unwind (exception_list *frame, PEXCEPTION_RECORD e)
{
  RtlUnwind (frame, __builtin_return_address (0), e, 0);
}
#else
a465 1
#endif
d469 2
d599 2
a600 2
  debug_printf ("In cygwin_except_handler exception 0x%x at %p sp %p", e->ExceptionCode, in->_GR(ip), in->_GR(sp));
  debug_printf ("In cygwin_except_handler signal %d at %p", si.si_signo, in->_GR(ip));
d604 1
a604 1
    syscall_printf ("signal %d, masked 0x%lx", si.si_signo,
d610 3
a612 3
  PUINT_PTR framep = (PUINT_PTR) in->_GR(sp);
  for (PUINT_PTR bpend = (PUINT_PTR) __builtin_frame_address (0); framep > bpend; framep--)
    if (*framep == in->SegCs && framep[-1] == in->_GR(ip))
d614 1
a614 1
	framep -= 2;
d638 1
a638 1
	  if (status_info[i].code == (NTSTATUS) e->ExceptionCode)
d658 1
a658 1
	    stackdump (framep, in, e);
d670 1
a670 1
	  klog (LOG_INFO, "%s[%d]: segfault at " _AFMT " rip " _AFMT " rsp " _AFMT " error %d",
d672 1
a672 1
			  e->ExceptionInformation[1], in->_GR(ip), in->_GR(sp),
d682 1
a682 1
		 : (void *) in->_GR(ip));
d708 1
a708 1
  sigproc_printf ("oldmask 0x%lx, newmask 0x%lx", oldmask, tempmask);
d773 1
a773 2
      _ADDR &ip = cx->_GR(ip);
      push (ip);
d775 1
a775 1
      ip = pop ();
d922 1
a922 1
      debug_printf ("exiting with status 0x%08x", STATUS_CONTROL_C_EXIT);
d1104 1
a1104 1
  sigproc_printf ("oldmask %lx, newmask %lx, deltamask %lx", oldmask, newmask,
d1118 1
a1118 1
  sigproc_printf ("setmask %lx, newmask %lx, mask_bits %lx", setmask, newmask,
d1314 1
a1314 1
  memcpy (&thread_context, c, __COPY_CONTEXT_SIZE);
@


1.391.2.4
log
@	* dtable.cc: Use %y rather than 0x%x.
	* exceptions.cc: Ditto.
@
text
@d634 1
a634 1
  debug_printf ("In cygwin_except_handler exception %y at %p sp %p", e->ExceptionCode, in->_GR(ip), in->_GR(sp));
@


1.391.2.5
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d1359 1
a1359 1
      __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %d %y %p", sig, thread_id, &thread_context);
@


1.391.2.6
log
@Pull in changes from HEAD
@
text
@d838 5
a842 1
    SetEvent (get_signal_arrived ());
@


1.391.2.7
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d639 1
a639 1
    syscall_printf ("signal %d, masked %ly", si.si_signo,
d743 1
a743 1
  sigproc_printf ("oldmask %ly, newmask %ly", oldmask, tempmask);
d954 1
a954 1
      debug_printf ("exiting with status %y", STATUS_CONTROL_C_EXIT);
@


1.391.2.8
log
@Pull in changes from HEAD
@
text
@d838 1
a838 1
    SetEvent (get_signal_arrived (false));
d1197 2
a1198 2
  _cygtls *tls;
  if (sigtls)
d1200 2
a1201 7
      tls = sigtls;
      sigproc_printf ("using sigtls %p", sigtls);
    }
  else
    {
      tls = cygheap->find_tls (si.si_signo);
      sigproc_printf ("using tls %p", tls);
a1203 1
  void *handler = (void *) thissig.sa_handler;
d1207 3
a1209 1
  if (handler == SIG_IGN)
d1211 2
a1212 2
      sigproc_printf ("signal %d ignored", si.si_signo);
      goto done;
@


1.391.2.9
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d53 4
d179 2
a180 2
void
cygwin_exception::dump_exception ()
d198 1
a198 1
    small_printf ("Exception: %s at rip=%016X\r\n", exception_name, ctx->Rip);
d200 6
a205 6
    small_printf ("Signal %d at rip=%016X\r\n", e->ExceptionCode, ctx->Rip);
  small_printf ("rax=%16X rbx=%16X rcx=%16X\r\n", ctx->Rax, ctx->Rbx, ctx->Rcx);
  small_printf ("rdx=%16X rsi=%16X rdi=%16X\r\n", ctx->Rdx, ctx->Rsi, ctx->Rdi);
  small_printf ("r8 =%16X r9 =%16X r10=%16X\r\n", ctx->R8, ctx->R9, ctx->R10);
  small_printf ("r11=%16X r12=%16X r13=%16X\r\n", ctx->R11, ctx->R12, ctx->R13);
  small_printf ("r14=%16X r15=%16X\r\n", ctx->R14, ctx->R15);
d207 1
a207 1
		ctx->Rbp, ctx->Rsp, myself->progname, myself->pid,
d211 1
a211 1
    small_printf ("Exception: %s at eip=%08x\r\n", exception_name, ctx->Eip);
d213 1
a213 1
    small_printf ("Signal %d at eip=%08x\r\n", e->ExceptionCode, ctx->Eip);
d215 1
a215 1
		ctx->Eax, ctx->Ebx, ctx->Ecx, ctx->Edx, ctx->Esi, ctx->Edi);
d217 1
a217 1
		ctx->Ebp, ctx->Esp, myself->progname, myself->pid,
d221 1
a221 1
		ctx->SegCs, ctx->SegDs, ctx->SegEs, ctx->SegFs, ctx->SegGs, ctx->SegSs);
d305 1
a305 1
cygwin_exception::dumpstack ()
d315 1
a315 1
    dump_exception ();
d319 1
a319 1
  thestack.init (framep, 1, !ctx);	/* Initialize from the input CONTEXT */
d383 1
a383 2
  cygwin_exception exc ((PUINT_PTR) c._GR(bp));
  exc.dumpstack ();
d519 1
a519 1
  /* If we're exiting, don't do anything here.  Returning 1
d521 1
a521 1
  if (exit_state || e->ExceptionFlags)
d524 1
a524 1
  siginfo_t si = {};
a633 3
  if (me.andreas)
    me.andreas->leave ();	/* Return from a "san" caught fault */

d637 8
d653 3
d663 50
a712 10
  /* Another exception could happen while tracing or while exiting.
     Only do this once.  */
  if (recursed++)
    system_printf ("Error while dumping state (probably corrupted stack)");
  else if (!try_to_debug (0))
    rtl_unwind (frame, e);
  else
    {
      debugging = true;
      return 0;
d715 4
a718 19
  /* FIXME: Probably should be handled in sigpacket::process */
  if ((NTSTATUS) e->ExceptionCode == STATUS_ACCESS_VIOLATION)
    {
      int error_code = 0;
      if (si.si_code == SEGV_ACCERR)	/* Address present */
	error_code |= 1;
      if (e->ExceptionInformation[0])	/* Write access */
	error_code |= 2;
      if (!me.inside_kernel (in))	/* User space */
	error_code |= 4;
      klog (LOG_INFO, "%s[%d]: segfault at " _AFMT " rip " _AFMT " rsp " _AFMT " error %d",
		      __progname, myself->pid,
		      e->ExceptionInformation[1], in->_GR(ip), in->_GR(sp),
		      error_code);
    }

  cygwin_exception exc (framep, in, e);
  si.si_cyg = (void *) &exc;
  si.si_addr = (void *) in->_GR(ip);
d720 1
a720 1
  sig_send (NULL, si, &me);	/* Signal myself */
d1004 1
a1004 1
	      sig_send (myself, SIGHUP);
a1156 57
/* Exit due to a signal.  Should only be called from the signal thread.  */
extern "C" {
static void
signal_exit (int sig, siginfo_t *si)
{
  debug_printf ("exiting due to signal %d", sig);
  exit_state = ES_SIGNAL_EXIT;

  if (have_execed)
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (ch_spawn, sigExeced = sig);
    }

  if (cygheap->rlim_core > 0UL)
    switch (sig)
      {
      case SIGABRT:
      case SIGBUS:
      case SIGFPE:
      case SIGILL:
      case SIGQUIT:
      case SIGSEGV:
      case SIGSYS:
      case SIGTRAP:
      case SIGXCPU:
      case SIGXFSZ:
       if (try_to_debug ())
	 break;
       if (si->si_code != SI_USER && si->si_cyg)
	 ((cygwin_exception *) si->si_cyg)->dumpstack ();
       else
	 {
#ifdef __x86_64__
	   cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.rbp);
#else
	   cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.ebp);
#endif
	   exc.dumpstack ();
	 }
       break;
      }

  lock_process until_exit (true);

  if (have_execed || exit_state > ES_PROCESS_LOCKED)
    myself.exit (sig);

  /* Starve other threads in a vain attempt to stop them from doing something
     stupid. */
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL);

  sigproc_printf ("about to call do_exit (%x)", sig);
  do_exit (sig);
}
} /* extern "C" */

a1265 7
  goto dosig;

exit_sig:
  handler = (void *) signal_exit;
  thissig.sa_flags |= SA_SIGINFO;
  if (si.si_signo == SIGKILL)
    goto dispatch_sig;
d1269 2
d1272 4
a1275 2
      rc = -1;		/* No signals delivered if stopped */
      goto done;
a1277 18
dispatch_sig:
  /* Do stuff for gdb */
  if (si.si_code == SI_USER || !si.si_cyg)
    {
      CONTEXT c;
      c.ContextFlags = CONTEXT_FULL;
      GetThreadContext (hMainThread, &c);
      _my_tls.copy_context (&c);

      /* Tell gdb that we got a signal. Presumably, gdb already noticed this
	 if we hit an exception.  */
      _my_tls.signal_debugger (si.si_signo);
    }
  /* Dispatch to the appropriate function. */
  sigproc_printf ("signal %d, signal handler %p", si.si_signo, handler);
  rc = setup_handler (handler, thissig, tls);
  continue_now = false;

d1287 8
@


1.391.2.10
log
@Pull in changes from HEAD
@
text
@d804 1
a804 2
  if (!have_execed)
    proc_subproc (PROC_CLEARWAIT, 1);
d1129 6
d1230 3
a1232 1
  void *handler = have_execed ? NULL : (void *) thissig.sa_handler;
a1314 5
  if (have_execed)
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (ch_spawn, sigExeced = si.si_signo);
    }
@


1.391.2.11
log
@Pull in changes from HEAD
@
text
@d915 8
@


1.391.2.12
log
@Pull in changes from HEAD
@
text
@d473 2
a474 2
static void rtl_unwind (exception_list *, PEXCEPTION_RECORD) __attribute__ ((noinline));
void
d480 2
a481 2
static void __reg3 rtl_unwind (exception_list *, PEXCEPTION_RECORD) __attribute__ ((noinline, regparm (3)));
void __reg3
@


1.391.2.13
log
@...and pull in changes from HEAD
@
text
@d655 1
a655 1
    api_fatal ("Error while dumping state (probably corrupted stack)");
a828 4
  while (in_forkee)
    yield ();		/* Won't be able to send signals until we're finished
			   processing fork().  */

@


1.391.2.14
log
@Pull in changes from HEAD
@
text
@d727 1
a727 1
sig_handle_tty_stop (int sig, siginfo_t *, void *)
d782 1
a782 1
void __reg3
d788 1
a788 1
  func = (void (*) (int, siginfo_t *, void *)) handler;
d996 1
a996 1
      t->kill_pgrp (sig);
d1169 1
a1169 1
int __reg1
d1189 13
a1344 2

      /* Save information locally on stack to pass to handler. */
d1346 1
a1346 2
      siginfo_t thissi = infodata;
      void (*thisfunc) (int, siginfo_t *, void *) = func;
d1350 1
a1350 1
      sig = 0;		/* Flag that we can accept another signal */
d1352 14
a1365 5
      unlock ();	/* unlock signal stack */

      incyg = false;
      /* no ucontext_t information provided yet, so third arg is NULL */
      thisfunc (thissig, &thissi, NULL);
a1366 1

@


1.391.2.15
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d53 1
a53 1
static const struct
@


1.391.2.16
log
@	* exception.h (class exception): Add handler_installed member.
	Change parameters to handle method to match high-level exception
	handler calls.
	(exception::exception): On x86_64, install exception handler only
	once.  Explain what we do.
	* exceptions.cc (_AFMT): Change to only 11 digits on x86_64.
	(cygwin_exception::dump_exception): Print Rip with only 11 digits.
	Print 64 bit registers with 0-padding.
	(class stack_info): Add members c and hist on x86_64.
	(stack_info::init): Take PCONTEXT rather than bool as third parameter.
	Tweak code accordingly.  Initialize c and hist on x86_64.
	(stack_info::walk): Add implementation for x86_64.  Drop unneeded
	#ifndef in 32 bit code.
	(cygwin_exception::dumpstack): Call thestack.init with context as
	parameter.  Change header output for x86_64.
	(cygwin_stackdump): Prefer RtlCaptureContext over GetThreadContext.
	(CYG_EXC_CONTINUE_EXECUTION): Define generic definition matching all
	platforms.
	(CYG_EXC_CONTINUE_SEARCH): Ditto.
	(exception::handler_installed): Define here.
	(exception::handle): Define according to declaration in exception.h.
	Create 32 bit parameters as local variable on 64 bit.  Change all
	return statements to use generic definitions.  Simplify setting framep
	on x86_64.  Disable setting frame-based exception handler on x86_64.
	Fix formatting of klog output for x86_64.
	(signal_exit): Create context for cygwin_exception creation.
	(sigpacket::process): Prefer RtlCaptureContext over GetThreadContext.
	* wincap.h (wincaps::has_rtl_capture_context): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d38 1
a38 1
# define _AFMT		"%011X"
d194 1
a194 1
    small_printf ("Exception: %s at rip=%011X\r\n", exception_name, ctx->Rip);
d196 9
a204 9
    small_printf ("Signal %d at rip=%011X\r\n", e->ExceptionCode, ctx->Rip);
  small_printf ("rax=%016X rbx=%016X rcx=%016X\r\n", ctx->Rax, ctx->Rbx, ctx->Rcx);
  small_printf ("rdx=%016X rsi=%016X rdi=%016X\r\n", ctx->Rdx, ctx->Rsi, ctx->Rdi);
  small_printf ("r8 =%016X r9 =%016X r10=%016X\r\n", ctx->R8, ctx->R9, ctx->R10);
  small_printf ("r11=%016X r12=%016X r13=%016X\r\n", ctx->R11, ctx->R12, ctx->R13);
  small_printf ("r14=%016X r15=%016X\r\n", ctx->R14, ctx->R15);
  small_printf ("rbp=%016X rsp=%016X\r\n", ctx->Rbp, ctx->Rsp);
  small_printf ("program=%W, pid %u, thread %s\r\n",
		myself->progname, myself->pid, cygthread::name ());
a226 4
#ifdef __x86_64__
  CONTEXT c;
  UNWIND_HISTORY_TABLE hist;
#endif
d229 1
a229 1
  void init (PUINT_PTR, bool, PCONTEXT); /* Called the first time that stack info is needed */
d243 1
a243 1
stack_info::init (PUINT_PTR framep, bool wantargs, PCONTEXT ctx)
a244 10
#ifdef __x86_64__
  memset (&hist, 0, sizeof hist);
  if (ctx)
    memcpy (&c, ctx, sizeof c);
  else
    {
      memset (&c, 0, sizeof c);
      c.ContextFlags = CONTEXT_ALL;
    }
#endif
d246 1
a246 1
  if (ctx)
a264 29
#ifdef __x86_64__
  PRUNTIME_FUNCTION f;
  ULONG64 imagebase;
  DWORD64 establisher;
  PVOID hdl;

  if (!c.Rip)
    return 0;

  sf.AddrPC.Offset = c.Rip;
  sf.AddrStack.Offset = c.Rsp;
  sf.AddrFrame.Offset = c.Rbp;

  f = RtlLookupFunctionEntry (c.Rip, &imagebase, &hist);
  if (f)
    RtlVirtualUnwind (0, imagebase, c.Rip, f, &c, &hdl, &establisher, NULL);
  else
    {
      c.Rip = *(ULONG_PTR *) c.Rsp;
      c.Rsp += 8;
    }
  if (needargs && c.Rip)
    {
      PULONG_PTR p = (PULONG_PTR) c.Rsp;
      for (unsigned i = 0; i < NPARAMS; ++i)
	sf.Params[i] = p[i + 1];
    }
  return 1;
#else
d286 1
d293 1
a297 1
#endif
d315 1
a315 4
  thestack.init (framep, 1, ctx);	/* Initialize from the input CONTEXT */
#ifdef __x86_64__
  small_printf ("Stack trace:\r\nFrame        Function    Args\r\n");
#else
a316 1
#endif
d378 2
a379 5
  if (wincap.has_rtl_capture_context ())
    RtlCaptureContext (&c);
  else
    GetThreadContext (GetCurrentThread (), &c);
  cygwin_exception exc ((PUINT_PTR) c._GR(bp), &c);
a502 12
#ifdef __x86_64__
#define CYG_EXC_CONTINUE_EXECUTION	EXCEPTION_CONTINUE_EXECUTION
#define CYG_EXC_CONTINUE_SEARCH		EXCEPTION_CONTINUE_SEARCH

bool exception::handler_installed NO_COPY; 

int
exception::handle (LPEXCEPTION_POINTERS ep)
#else
#define CYG_EXC_CONTINUE_EXECUTION	0
#define CYG_EXC_CONTINUE_SEARCH		1

a504 1
#endif
a509 6
#ifdef __x86_64__
  EXCEPTION_RECORD *e = ep->ExceptionRecord;
  CONTEXT *in = ep->ContextRecord;
  exception_list *frame = (exception_list *) __builtin_frame_address (0);
#endif

d513 1
a513 1
      return CYG_EXC_CONTINUE_EXECUTION;
d519 1
a519 1
    return CYG_EXC_CONTINUE_SEARCH;
d588 1
a588 1
	  return CYG_EXC_CONTINUE_EXECUTION;
d622 1
a622 1
      return CYG_EXC_CONTINUE_EXECUTION;
d628 1
a628 1
      return CYG_EXC_CONTINUE_SEARCH;
a636 3
#ifdef __x86_64__
  PUINT_PTR framep = (PUINT_PTR) in->Rbp;
#else
a643 1
#endif
a646 1
#ifndef __x86_64__
a650 1
#endif
d661 1
a661 1
      return CYG_EXC_CONTINUE_EXECUTION;
d674 1
a674 6
      klog (LOG_INFO,
#ifdef __x86_64__
	    "%s[%d]: segfault at %011X rip %011X rsp %011X error %d",
#else
	    "%s[%d]: segfault at %08x rip %08x rsp %08x error %d",
#endif
d687 1
a687 1
  return CYG_EXC_CONTINUE_EXECUTION;
a1144 6
	   CONTEXT c;
	   c.ContextFlags = CONTEXT_FULL;
	   if (wincap.has_rtl_capture_context ())
	     RtlCaptureContext (&c);
	   else
	     GetThreadContext (GetCurrentThread (), &c);
d1146 1
a1146 1
	   cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.rbp, &c);
d1148 1
a1148 1
	   cygwin_exception exc ((PUINT_PTR) _my_tls.thread_context.ebp, &c);
d1284 1
a1284 4
      if (_my_tls == _main_tls && wincap.has_rtl_capture_context ())
	RtlCaptureContext (&c);
      else
	GetThreadContext (hMainThread, &c);
@


1.391.2.17
log
@	* exception.h (_except_list): Don't define on x86_64.
	(class exception): Don't define members el and save on x86_64.
	(exception::~exception): Don't define on x86_64.
	* exceptions.cc (signal_exit): Fix typo in condition.
@
text
@d1369 1
a1369 1
      if (&_my_tls == _main_tls && wincap.has_rtl_capture_context ())
@


1.391.2.18
log
@	* exceptions.cc (_cygtls::signal_debugger): Raise size of sigmsg buffer
	on x86_64.
	* tlsoffsets64.h: Regenerate.
@
text
@a1455 3
#ifdef __x86_64__
      char sigmsg[2 * sizeof (_CYGWIN_SIGNAL_STRING " ffffffff ffffffffffffffff")];
#else
a1456 1
#endif
@


1.391.2.19
log
@	* exceptions.cc (rtl_unwind): Convert to macro doing nothing on x86_64.
	(exception::handle): Drop creating frame variable on x86_64.
	* wincap.cc (wincap_2000sp4): Set has_rtl_capture_context to false.
@
text
@d522 6
a527 3
/* Don't unwind the stack on x86_64.  It's not necessary to do that from the
   exception handler. */
#define rtl_unwind(el,er)
d575 1
a577 1
  system_printf ("Here");
@


1.391.2.20
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d424 4
a427 1
  RtlCaptureContext (&c);
d574 1
d1223 4
a1226 1
	   RtlCaptureContext (&c);
d1366 1
a1366 1
      if (&_my_tls == _main_tls)
@


1.391.2.21
log
@Pull in changes from HEAD
@
text
@d563 1
d719 4
a722 3
  if (exit_state >= ES_SIGNAL_EXIT
      && (NTSTATUS) e->ExceptionCode != STATUS_CONTROL_C_EXIT)
    api_fatal ("Exception during process exit");
@


1.391.2.22
log
@Pull in changes from HEAD
@
text
@d707 3
d711 1
a1280 4
  /* Do stuff for gdb */
  if ((HANDLE) *tls)
    tls->signal_debugger (si);

d1352 15
d1434 7
a1440 1
_cygtls::signal_debugger (siginfo_t& si)
a1441 1
  HANDLE th = NULL;
a1443 24
      CONTEXT c;
      CONTEXT *pc;

      if (si.si_cyg)
	pc = ((cygwin_exception *) si.si_cyg)->context ();
      else if (!(th = (HANDLE) *this))
	return;
      else
	{
	  SuspendThread (th);
	  c.ContextFlags = CONTEXT_FULL;
	  if (GetThreadContext (th, &c))
	    pc = &c;
	  else
	    goto out;
	  if (incyg)
#ifdef __x86_64__
	    c.Rip = retaddr ();
#else
	    c.Eip = retaddr ();
#endif
	  memcpy (&thread_context, pc, (&thread_context._internal -
					(unsigned char *) &thread_context));
	}
d1449 1
a1449 2
      __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %d %y %p", si.si_signo,
		       thread_id, &thread_context);
a1451 3
out:
  if (th)
    ResumeThread (th);
@


1.391.2.23
log
@	* exceptions.cc (stack_info::init): Don't attempt to dereference NULL
	framep.
	(exception::handle): On x86_64, if Rbp is NULL, use Rsp as frame
	pointer.
@
text
@d267 1
a267 2
  if (framep)
    sf.AddrReturn.Offset = framep[1];
a698 5
  /* Sometimes, when a stack is screwed up, Rbp tends to be NULL.  In that
     case, base the stacktrace on Rsp.  In most cases, it allows to generate
     useful stack trace. */
  if (!framep)
    framep = (PUINT_PTR) in->Rsp;
d745 1
@


1.391.2.24
log
@Pull in changes from HEAD
@
text
@d731 1
a731 1
  /* FIXME: Probably should be handled in signal processing code */
@


1.391.2.25
log
@Pull in changes from HEAD
@
text
@d800 1
a806 1
      _my_tls.incyg = 1;
d812 1
a812 3
      /* Use special cygwait parameter to handle SIGCONT.  _main_tls.sig will
	 be cleared under lock when SIGCONT is detected.  */
      DWORD res = cygwait (NULL, cw_infinite, cw_sig_cont);
d816 1
a823 1
      _my_tls.incyg = 0;
d825 1
d900 4
d1243 2
a1244 3
/* Attempt to carefully handle SIGCONT when we are stopped. */
void
_cygtls::handle_SIGCONT ()
d1246 6
a1251 1
  if (ISSTATE (myself, PID_STOPPED))
d1253 1
d1256 6
a1261 27
      int state = 0;
      /* Carefully tell sig_handle_tty_stop to wake up.  */
      while (state < 2)
       {
	 lock ();
	 if (sig)
	   yield ();           /* state <= 1 */
	 else if (state)
	   state++;            /* state == 2 */
	 else
	   {
	     sig = SIGCONT;
	     SetEvent (signal_arrived);
	     state++;          /* state == 1 */
	   }
	 unlock ();
       }
      /* Tell wait_sig to handle any queued signals now that we're alive
	again. */
      sig_dispatch_pending (false);
    }
  /* Clear pending stop signals */
  sig_clear (SIGSTOP);
  sig_clear (SIGTSTP);
  sig_clear (SIGTTIN);
  sig_clear (SIGTTOU);
}
a1262 3
int __reg1
sigpacket::process ()
{
a1263 11
  bool issig_wait = false;
  struct sigaction& thissig = global_sigs[si.si_signo];
  void *handler = have_execed ? NULL : (void *) thissig.sa_handler;

  /* Don't try to send signals if we're just starting up since signal masks
     may not be available.  */
  if (!cygwin_finished_initializing)
    {
      rc = -1;
      goto done;
    }
d1266 1
d1271 1
a1271 6
  if (si.si_signo == SIGCONT)
    _main_tls->handle_SIGCONT ();

  if (si.si_signo == SIGKILL)
    tls = _main_tls;	/* SIGKILL is special.  It always goes through.  */
  else if (ISSTATE (myself, PID_STOPPED))
d1273 2
a1274 2
      rc = -1;		/* Don't send signals when stopped */
      goto done;
d1276 1
a1276 1
  else if (!sigtls)
d1278 1
a1278 1
      tls = cygheap->find_tls (si.si_signo, issig_wait);
a1280 18
  else
    {
      tls = sigtls;
      if (sigismember (&tls->sigwait_mask, si.si_signo))
	issig_wait = true;
      else if (!sigismember (&tls->sigmask, si.si_signo))
	issig_wait = false;
      else
	tls = NULL;
    }
      
  /* !tls means no threads available to catch a signal. */
  if (!tls)
    {
      sigproc_printf ("signal %d blocked", si.si_signo);
      rc = -1;
      goto done;
    }
d1286 1
a1286 5
  if (issig_wait)
    {
      tls->sigwait_mask = 0;
      goto dosig;
    }
d1302 12
a1338 1
  tls = _main_tls;
d1340 1
a1340 1
  thissig = global_sigs[SIGSTOP];
d1346 2
d1350 7
d1365 1
d1368 5
d1406 1
a1407 2
      incyg = false;
      sig = 0;		/* Flag that we can accept another signal */
d1410 1
@


1.390
log
@* exceptions.cc (sigdelayed): Simplify declaration.
(_cygtls::call_signal_handler): Fix test for when to pop signal stack.  Only do
it exactly when what is on the stack is a no-op.
@
text
@d1173 2
a1174 2
      tls = _main_tls;
      sigproc_printf ("using main tls %p", _main_tls);
@


1.389
log
@* cygwait.cc (cancelable_wait): Add some debugging-only output.
* exceptions.cc (sig_handle_tty_stop): Make sure that incyg is cleared when
exiting if we have no parent process.  Only wait for signal_arrived.
(sigpacket::process): Make continue_now a bool.  Delay sending signal_arrived
until the end.  Make code more defensive to avoid calling signal handler when
stopped.  Only set signal_arrived when stopped.
* sigproc.cc (sig_hold): Rename from sigCONT.  Make static.
(sig_send): Accommodate sigCONT -> sig_hold rename.
(wait_sig): Ditto.
* sigproc.h (sigCONT): Delete declaration.
* fhandler_console.cc (fhandler_console::write): Use new '%0c' facility to
print characters.  Change to paranoid to avoid excessive strace output.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Make frequent strace
printf "paranoid" to help cut down on strace output size.
* signal.cc (sigsuspend): Add standard syscall strace output.
(sigpause): Ditto.
(pause): Ditto.
* cygtls.h (_cygtls::reset_signal_arrived): New function.
@
text
@d40 1
a40 3
extern "C" {
extern void sigdelayed ();
};
d1087 1
a1087 1
   Called from sigdelayed */
d1266 3
a1268 1
      if (incyg)
@


1.388
log
@* cygtls.cc (_cygtls::reset_signal_arrived): New function.
(set_signal_arrived::~set_signal_arrived): Use reset_signal_arrived to reset
state.
* exceptions.cc (sig_handle_tty_stop): Use WAIT_SIGNALED rather than assume we
know the return from cancelable_wait.
(_cygtls::interrupt_setup): Modify to allow calling when executing in
non-cygwin code via sigdelayed.  Always reset signal_arrived.
* gendef: Throughout use start_offset rather than the completely wrong
sizeof__cygtls.
(_sigdelayed): Rewrite to avoid duplication when calling the signal handler.
(sigreturn): Delete.
* gentls_offsets: Define start_offset rather than sizeof__cygtls.
* tlsoffsets.h: Regenerate.
@
text
@d738 2
d741 16
a756 19
      myself->process_state &= ~PID_STOPPED;
      return;
    }

  myself->stopsig = sig;
  myself->alert_parent (sig);
  sigproc_printf ("process %d stopped by signal %d", myself->pid, sig);
  HANDLE w4[2];
  w4[0] = sigCONT;
  switch (cancelable_wait (sigCONT, cw_infinite, cw_sig_eintr))
    {
    case WAIT_OBJECT_0:
    case WAIT_SIGNALED:
      myself->stopsig = SIGCONT;
      myself->alert_parent (SIGCONT);
      break;
    default:
      api_fatal ("WaitSingleObject failed, %E");
      break;
d760 1
a760 1
}
d1124 1
a1124 1
  DWORD continue_now;
d1131 1
a1131 1
      continue_now = myself->process_state & PID_STOPPED;
d1208 1
a1208 3
	  sigproc_printf ("default signal %d ignored", si.si_signo);
	  if (continue_now)
	    SetEvent (tls->signal_arrived);
a1223 3
  /* Eat multiple attempts to STOP */
  if (ISSTATE (myself, PID_STOPPED))
    goto done;
d1228 10
a1237 4
  tls->set_siginfo (this);
  /* Dispatch to the appropriate function. */
  sigproc_printf ("signal %d, signal handler %p", si.si_signo, handler);
  rc = setup_handler (si.si_signo, handler, thissig, tls);
d1241 1
a1241 1
    SetEvent (sigCONT);
@


1.387
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d751 1
a751 1
    case WAIT_OBJECT_0 + 1:
d804 1
a804 1
  if (signal_arrived)
d1262 7
a1268 1
      if (sig)
a1269 2
      else
	break;
d1279 1
a1282 1
	  void (*sigfunc) (int) = thisfunc;
d1284 1
a1284 1
	  sigfunc (thissig);
a1299 1
  unlock ();
@


1.386
log
@* exceptions.cc (setup_handler): Remove unneeded assignment found by Clang.
@
text
@d22 1
a23 1
#include "cygtls.h"
a33 1
#include "cygwait.h"
a48 1
static muto NO_COPY mask_sync;
d711 1
a711 1
  set_signal_mask (tempmask, _my_tls.sigmask);
d715 1
a715 1
  cancelable_wait (signal_arrived, LARGE_NULL, cw_cancel | cw_cancel_self);
d748 1
a748 2
  w4[1] = signal_arrived;
  switch (WaitForMultipleObjects (2, w4, TRUE, INFINITE))
d804 2
a805 8
  if (!event)
    threadkill = false;
  else
    {
      HANDLE h = event;
      event = NULL;
      SetEvent (h);
    }
a806 2
  /* Clear any waiting threads prior to dispatching to handler function */
  int res = SetEvent (signal_arrived);	// For an EINTR case
d808 1
a808 2
  sigproc_printf ("armed signal_arrived %p, signal %d, res %d", signal_arrived,
		  sig, res);
d1012 1
a1012 1
  set_signal_mask (newmask, _my_tls.sigmask);
a1024 1
  mask_sync.acquire (INFINITE);
d1027 1
a1027 2
  set_signal_mask (mask, _my_tls.sigmask);
  mask_sync.release ();
a1040 1
  mask_sync.acquire (INFINITE);
d1043 1
a1043 2
  set_signal_mask (mask, _my_tls.sigmask);
  mask_sync.release ();
a1060 1
  mask_sync.acquire (INFINITE);
d1079 1
a1079 2
  set_signal_mask (mask, _my_tls.sigmask);
  mask_sync.release ();
a1093 1
  mask_sync.acquire (INFINITE);
a1103 1
  mask_sync.release ();
d1109 3
a1111 2
extern "C" void __stdcall
set_signal_mask (sigset_t newmask, sigset_t& oldmask)
a1112 5
#ifdef CGF
  if (&_my_tls == _sig_tls)
    small_printf ("********* waiting in signal thread\n");
#endif
  mask_sync.acquire (INFINITE);
d1114 2
a1115 2
  sigset_t mask_bits = oldmask & ~newmask;
  sigproc_printf ("oldmask %p, newmask %p, mask_bits %p", oldmask, newmask,
d1117 1
a1117 1
  oldmask = newmask;
a1119 1
  mask_sync.release ();
d1162 8
a1169 7
  bool masked;
  void *handler;
  if (!have_execed || (void *) thissig.sa_handler == (void *) SIG_IGN)
    handler = (void *) thissig.sa_handler;
  else if (tls)
    return 1;
  else
d1172 7
a1178 2
  _cygtls *use_tls = tls ?: _main_tls;
  sigproc_printf ("tls %p, use_tls %p", tls, use_tls);
d1188 1
a1188 8
  bool insigwait_mask;
  if ((masked = ISSTATE (myself, PID_STOPPED)))
    insigwait_mask = false;
  else if (tls)
    insigwait_mask = sigismember (&tls->sigwait_mask, si.si_signo);
  else if (!(tls = _cygtls::find_tls (si.si_signo)))
    insigwait_mask = false;
  else
d1190 2
a1191 2
      use_tls = tls;
      insigwait_mask = true;
d1193 1
a1193 12

  if (insigwait_mask)
    goto thread_specific;

  if (masked)
    /* nothing to do */;
  else if (sigismember (mask, si.si_signo))
    masked = true;
  else if (tls)
    masked  = sigismember (&tls->sigmask, si.si_signo);

  if (masked)
a1205 2
      if (insigwait_mask)
	goto thread_specific;
d1211 1
a1211 1
	    SetEvent (signal_arrived);
a1220 6
  if (handler == (void *) SIG_IGN)
    {
      sigproc_printf ("signal %d ignored", si.si_signo);
      goto done;
    }

a1223 1
  use_tls->set_siginfo (this);
d1234 1
d1236 2
a1237 2
  sigproc_printf ("signal %d, about to call %p", si.si_signo, handler);
  rc = setup_handler (si.si_signo, handler, thissig, use_tls);
a1239 1
  tls = use_tls;
a1244 8
thread_specific:
  use_tls->sig = si.si_signo;
  use_tls->set_siginfo (this);
  use_tls->func = NULL;
  sigproc_printf ("releasing sigwait for thread");
  SetEvent (use_tls->event);
  goto done;

d1246 1
a1246 7
  use_tls->signal_exit (si.si_signo);	/* never returns */
}

void
events_init ()
{
  mask_sync.init ("mask_sync");
d1264 1
a1264 17
      else if (this != _main_tls)
	{
	  _main_tls->lock ();
	  if (_main_tls->sig && _main_tls->incyg)
	    {
	      paranoid_printf ("Redirecting to main_tls signal %d", _main_tls->sig);
	      sig = _main_tls->sig;
	      sa_flags = _main_tls->sa_flags;
	      func = _main_tls->func;
	      infodata = _main_tls->infodata;
	      _main_tls->pop ();
	      _main_tls->sig = 0;

	    }
	  _main_tls->unlock ();
	}
      if (!sig)
d1291 1
a1291 1
      set_signal_mask (this_oldmask, _my_tls.sigmask);
@


1.385
log
@* exceptions.cc (exception::handle): Use error_code in klog, as intended.
Found by Clang.
@
text
@d883 1
a883 1
	  res = ResumeThread (hth);
@


1.384
log
@* Makefile.in: Add some more optimization flags for cygwait, malloc and path.  Explain
why -fomit-frame-pointer doesn't work right for passwd.o and path.o.  Add
-static to link command line for cygwin0.dll.
* fhandler_disk_file.cc (fhandler_disk_file::facl): Reorganize slightly to
silence compiler warning when compiling with -fstack-check.
* net.cc (inet_ntop6): Initialize structure members to silence compiler warning
when compiling with -fstack-check.
* pseudo-reloc.cc (_pei386_runtime_relocator): Make this a C function.  Detect
NULL u.
* winsup.h (_pei386_runtime_relocator): Declare this as extern "C".
* lib/_cygwin_crt0_common.cc (_pei386_runtime_relocator): Call with NULL
argument.
* signal.cc (sigaction_worker): Eliminate last argument.  Let callers report
their own strace info.  Regparmize.
(sigaction): Reflect sigaction_worker changes.
(siginterrupt): Ditto.
* exceptions.cc: Update copyright.
@
text
@d679 1
a679 2
			  ((in->Eip >= 0x61000000 && in->Eip < 0x61200000)
			   ? 0 : 4) | (e->ExceptionInformation[0] << 1));
@


1.383
log
@	* exceptions.cc (RtlUnwind): Align declaration with MSDN.
	* ntdll.h: Define CreateDisposition Flags.  Add comments.
	* winlean.h: Define FILE_SHARE_VALID_FLAGS if using Mingw64 headers.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.382
log
@	* exceptions.cc (exception::handle): Cast exception code to NTSTATUS
	for comparison.
	* ntdll.h: Drop defining NT status codes in favor of including
	ntstatus.h.
@
text
@d452 1
a452 1
extern "C" DWORD __stdcall RtlUnwind (void *, void *, void *, DWORD);
@


1.381
log
@* cygwait.h (LARGE_NULL): Define.
(cancelable_wait): Define variant which accepts DWORD time argument.
(cygwait): Use cancelable_wait with DWORD argument.
(cygwait): Use cancelable_wait with DWORD argument and cw_sig_eintr for
timeout-only case.
* exceptions.cc (handle_sigsuspend): Use LARGE_NULL as second argument to
distinguish between cancelable_wait variants.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_timedwait): Ditto.
* thread.h (fast_mutex::lock): Ditto.
* wait.cc (wait4): Ditto.
@
text
@d667 1
a667 1
      if (e->ExceptionCode == STATUS_ACCESS_VIOLATION)
@


1.380
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d718 1
a718 1
  cancelable_wait (signal_arrived, NULL, cw_cancel | cw_cancel_self);
@


1.379
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d718 1
a718 1
  cancelable_wait (NULL, NULL, cw_cancel | cw_cancel_self | cw_sig_eintr);
d751 2
a752 1
  switch (cancelable_wait (sigCONT, NULL, cw_sig_eintr))
d1251 1
a1251 1
	    SetEvent (use_tls->signal_arrived);
@


1.378
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d718 1
a718 1
  cancelable_wait (signal_arrived, NULL, cw_cancel | cw_cancel_self);
d751 1
a751 2
  w4[1] = signal_arrived;
  switch (WaitForMultipleObjects (2, w4, TRUE, INFINITE))
d1250 1
a1250 1
	    SetEvent (signal_arrived);
@


1.377
log
@* exceptions.cc (setup_handler): Make debugging output a little more verbose.
@
text
@d34 1
d718 1
a718 1
  cancelable_wait (signal_arrived);
d1198 1
@


1.376
log
@* exceptions.cc (ctrl_c_handler): Don't generate a SIGINT if we've execed a
non-cygwin process.  Let the Windows process deal with it itself.
@
text
@d868 1
a868 1
	  sigproc_printf ("suspending thread");
@


1.375
log
@* exception.h (stackdump): Declare.
* exceptions.cc (stackdump): Rework to perform all operations needed for a
stackdump and to avoid recursion.
(exception::handle): Use simplified stackdump interface.
* sigproc.cc (signal::exit): Ditto.  Delete now, uneeded declaration.
@
text
@d999 3
a1001 2
  if (t && t->getpgid () == myself->pid &&
       (GetTickCount () - t->last_ctrl_c) >= MIN_CTRL_C_SLOP)
@


1.374
log
@* exceptions.cc (setup_handler): Reduce system_printf to sigproc_printf since
it is for a transient situation which will undoubtedly be handled.
@
text
@d283 1
a283 1
stackdump (DWORD ebp, int open_file, bool isexception)
d287 1
a287 1
  if (cygheap->rlim_core == 0UL || (open_file && already_dumped))
d289 2
d292 2
a293 4
  if (open_file)
    open_stackdumpfile ();

  already_dumped = true;
d297 1
a297 1
  thestack.init (ebp, 1, !isexception);	/* Initialize from the input CONTEXT */
d359 1
a359 1
  stackdump (c.Ebp, 0, 0);
d663 1
a663 5
	    {
	      open_stackdumpfile ();
	      dump_exception (e, in);
	      stackdump ((DWORD) ebp, 0, 1);
	    }
@


1.373
log
@* exceptions.cc (set_signal_mask): Remove useless debugging output.
* fhandler.cc (fhandler_base::write): Ditto.
(fhandler_base_overlapped::close): Cancel any ongoing I/O before closing.
* syscalls.cc (write): Default to always reporting all writes in strace output
via syscall_printf.
* wait.cc (wait4): Fix debugging output.  Use standard syscall leaver output.
@
text
@d882 1
a882 1
	    system_printf ("couldn't get context of thread, %E");
@


1.372
log
@Implement fhandler reference counting.
* cygheap.h
(cygheap_fdmanip::release): Make virtual.
(cygheap_fdnew::~cygheap_fdnew): New destructor increments reference count when
fd has been allocated.
(cygheap_fdget::fh): New (old?) field.
(cygheap_fdget::cygheap_fdget): Increment reference count when we've found an
active fd.  Set fh appropriately.
(cygheap_fdget::~cygheap_fdget): Decrement reference count when appropriate.
Delete fh if reference count goes to zero.
(cygheap_fdget::release): New function.  Do more bookkeping on release.
* dtable.cc (dtable::release): Change from void to boolean return.  Only delete
the fhandler when its reference count is <= 0 (this should be a fairly unusual
case).  Return true if fhandler has been deleted.
(cygwin_attach_handle_to_fd): Increment reference count when fh is assigned.
(dtable::init_std_file_from_handle): Ditto.
* dtable.h (dtable::release): Change return to boolean.
* fhandler.cc (fhandler_base::fhandler_base): Set new isclosed flag to false.
Set _refcnt to zero.
(fhandler_base::close): Simplify paranoid debugging output.  Set new isclosed()
flag.
(fhandler_base_overlapped::wait_overlapped): Use isclosed() flag to avoid
querying the exception handle.
* fhandler.h (fhandler_base::_refcnt): New field.
(fhandler_base::refcnt): New function.
(fhandler_base::isclosed): Implement.
(fhandler_base::fhandler_base): Set isclosed to false.
* syscalls.cc: Remove space after function before parentheses for several
strace printfs.
(dup): Add standard strace "leaver" code.
(dup2): Ditto.
(dup3): Ditto.
(remove): Ditto.
(getpid): Ditto.
(getppid): Ditto.
(lseek64): Fix strace debugging to correctly use %R.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Avoid sending signals to
other processes if we're debugging since it can cause a deadlock with the
calling debugger.
* exceptions.cc (_cygtls::call_signal_handler): Add debugging-only strace
output.
@
text
@a1146 2
  else
    sigproc_printf ("not calling sig_dispatch_pending");
@


1.371
log
@* exceptions.cc (_cygtls::call_signal_handler): Fix debugging to not go to
console.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Add temporary kludge
to work around problem of make closing a handler while it is being read.
* gendef (sigdelayed): Don't call a function if sig has been cleared.
* sigproc.h (cygwait): Simplify slightly.
@
text
@d1347 1
@


1.370
log
@* dcrt0.cc (init_windows_system_directory): Record system_wow64_directory
information.
* exceptions.cc (_cygtls::inside_kernel): Modernize comment.  Consider
executing a DLL from the Wow64 directory as being "in the kernel".
(_cygtls::call_signal_handler): For now, only deal with main_tls signals if
main_tls is known to be executing in the cygwin DLL.  To more closely emulate
linux, consider the operation to be restartable if not executing in the main
thread.
* globals.cc (windows_system_directory): Remove NO_COPY.
(windows_system_directory_length): Ditto.
(system_wow64_directory): New variable.
(system_wow64_directory_length): Ditto.
* select.cc (cygwin_select): Don't issue a EINTR on non-main threads since that
seems to be what Linux does.  Add missing break to signal case/switch.
(select_stuff::wait): Don't issue a EINTR on non-main threads since that seems
to be what Linux does.  Remove now-unneeded accommodation for
WAIT_IO_COMPLETION.  Add a comment.
* sigproc.h (cygwait): Ditto.  Don't return if signal_received noticed and it's
not the main thread.
* signal.cc (sigprocmask): Add standard syscall debug stuff.
* thread.cc (pthread_sigmask): Ditto.
@
text
@d1333 1
a1333 1
	      small_printf ("Redirecting to main_tls signal %d", _main_tls->sig);
@


1.369
log
@* cygthread.h (cygthread::name): Very minor formatting tweak.
* exceptions.cc (_cygtls::call_signal_handler): Add paranoid debugging output.
* sigproc.h (cygwait): Call signal handler when signal is detected and loop as
appropriate.
* fhandler.h (fhandler_base_overlapped::wait_return): Remove overlapped_signal.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove restartable
signal accommodations in light of cygwait improvements.
(fhandler_base_overlapped::raw_read): Remove now-obsolete signal loop behavior.
(fhandler_base_overlapped::raw_write): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* ioctl.cc (ioctl): Add standard syscall introducer and leaver debug output.
@
text
@d329 1
a329 4
  /* Apparently Windows 95 can sometimes return bogus addresses from
     GetThreadContext.  These resolve to a strange allocation base.
     These should *never* be treated as interruptible. */
  if (!h || m.State != MEM_COMMIT)
d340 6
a345 2
      res = !wcsncasecmp (windows_system_directory, checkdir,
			  windows_system_directory_length);
a831 1
  // sigproc_printf ("errno %d", e);
d1331 1
a1331 1
	  if (_main_tls->sig)
d1333 1
a1333 1
	      paranoid_printf ("Redirecting to main_tls signal %d", _main_tls->sig);
d1376 1
a1376 1
  return this_sa_flags & SA_RESTART;
@


1.368
log
@* exceptions.cc (ctrl_c_handler): YA in a series or reversions.  Put back
_my_tls.remove along with a comment.
(sigpacket::process): Remove code which now causes a gdb deadlock.
* sigproc.cc (_cygtls::signal_exit): Signal debugger with signal number
earlier.
@
text
@d1333 1
@


1.367
log
@* dll_init.cc (dll_dllcrt0): Don't try to initialize dll data if we're
dynamically loaded since fork() doesn't work in that scenario anyway.
(dll_dllcrt0_1): Don't accommodate dynamically loaded dlls.
* exceptions.cc (ctrl_c_handler): Don't lock the process; there's too much risk
of deadlock.
* sigproc.cc (_cygtls::remove_wq): Don't try to remove anything from the waitq
if there is obviously nothing there.
* strace.cc (strace::activate): Allow stracing dynamically loaded cygwin1.dll.
@
text
@d939 7
a1244 9
#ifdef CGF
  if (being_debugged ())
    {
      char sigmsg[sizeof (_CYGWIN_SIGNAL_STRING " 0xffffffff")];
      __small_sprintf (sigmsg, _CYGWIN_SIGNAL_STRING " %p", si.si_signo);
      OutputDebugString (sigmsg);
    }
#endif

@


1.366
log
@* exceptions.cc (ctrl_c_handler): Remove _my_tls.remove since it can cause
deadlocks during exec and will eventually be handled anyway.
@
text
@a929 1
  lock_process now;
@


1.365
log
@* exceptions.cc (exception::handle): Drop abbreviation for "exception" since I
never remember what it stands for.
(sig_handle_tty_stop): Remove obsolete call to sig_handle_tty_stop.
(_cygtls::call_signal_handler): Rework to grab signal information from
_main_tls if none is set for _my_tls.  Try harder to keep thread locked.
(reset_signal_arrived): Delete.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use new cygWFMO call
to wait for an event + standard cygwin stuff.  Modify debug output to
acccomodate new function.
* fhandler_console.cc (fhandler_console::read): Replace WaitForMultipleObjects
with cygWFMO.
* fhandler_socket.cc (get_inet_addr): Add comment.
* gendef (_sigdelayed): Remove call to reset_signal_arrived.
* sigproc.cc (_cygtls::signal_exit): Don't close my_readsig here unless we're
in the signal thread.
(create_signal_arrived): Create signal_arrived as auto-reset so that only one
thread is woken when a signal arrives.
* sigproc.h (cygWFMO): New function.
(reset_signal_arrived): Delete declaration.
@
text
@a939 2
  _my_tls.remove (INFINITE);

@


1.364
log
@* exceptions.cc (stackdump): Make global.
(signal_exit): Move to sigproc.cc.
* sigproc.cc (signal_exit): Move here.  Declare stackdump extern.  Set
my_sendsig to indicate that signals are no longer available.
(my_readsig): Make Static again.
(sig_send): Interpret ERROR_BROKEN_PIPE as ESRCH.  Remove special-case EACCESS
errno setting, just setting errno generally, even for "its_me" case.
@
text
@d603 1
a603 1
  debug_printf ("In cygwin_except_handler exc %p at %p sp %p", e->ExceptionCode, in->Eip, in->Esp);
a757 1
      reset_signal_arrived ();
d1327 2
a1328 3
  int this_sa_flags = 0;
  /* Call signal handler.  */
  while (sig && func)
d1331 20
a1354 2
      pop ();
      reset_signal_arrived ();
a1358 1
      incyg = 0;
d1362 1
d1370 1
d1373 1
a1373 1
      incyg = 1;
d1379 1
a1382 10
extern "C" void __stdcall
reset_signal_arrived ()
{
  // NEEDED? WaitForSingleObject (signal_arrived, 10);
  ResetEvent (signal_arrived);
  sigproc_printf ("reset signal_arrived");
  if (_my_tls.stackptr > _my_tls.stack)
    debug_printf ("stackptr[-1] %p", _my_tls.stackptr[-1]);
}

@


1.363
log
@* exceptions.cc (sigpacket::process): Move signal_exit processing into...
(_cygtls::signal_exit): ...here.  Close my_readsig and comment on why.
* pinfo.cc (pinfo::exit): Move sigproc_terminate earlier.  Set exiting flag in
lock_process.
* sigproc.cc (my_readsig): Make global.
* sync.cc (muto::exiting_thread): Delete.
(muto::acquire): Delete #if 0'ed code.
* sync.h (muto::exiting_thread): Delete.
(set_exiting_thread): Ditto.
(lock_process::lock_process): Don't worry about setting the exiting thread
since it had no meaning.
@
text
@d282 1
a282 1
static void
a1312 42
/* Cover function to `do_exit' to handle exiting even in presence of more
   exceptions.  We used to call exit, but a SIGSEGV shouldn't cause atexit
   routines to run.  */
void
_cygtls::signal_exit (int rc)
{
  extern HANDLE my_readsig;
  ForceCloseHandle (my_readsig); /* Disallow further signal sends */
  SetEvent (signal_arrived);	 /* Avoid potential deadlock with proc_lock */

  if (rc == SIGQUIT || rc == SIGABRT)
    {
      CONTEXT c;
      c.ContextFlags = CONTEXT_FULL;
      GetThreadContext (hMainThread, &c);
      copy_context (&c);
      if (cygheap->rlim_core > 0UL)
	rc |= 0x80;
    }

  if (have_execed)
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (ch_spawn, sigExeced = rc);
    }

  signal_debugger (rc & 0x7f);
  if ((rc & 0x80) && !try_to_debug ())
    stackdump (thread_context.ebp, 1, 1);

  lock_process until_exit (true);
  if (have_execed || exit_state > ES_PROCESS_LOCKED)
    myself.exit (rc);

  /* Starve other threads in a vain attempt to stop them from doing something
     stupid. */
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL);

  sigproc_printf ("about to call do_exit (%x)", rc);
  do_exit (rc);
}

@


1.362
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@a1309 11
  if (si.si_signo == SIGQUIT || si.si_signo == SIGABRT)
    {
      CONTEXT c;
      c.ContextFlags = CONTEXT_FULL;
      GetThreadContext (hMainThread, &c);
      use_tls->copy_context (&c);
      if (cygheap->rlim_core > 0UL)
	si.si_signo |= 0x80;
    }
  SetEvent (signal_arrived);	// To avoid a potential deadlock with proc_lock
  sigproc_printf ("signal %d, about to call do_exit", si.si_signo);
d1319 14
@


1.361
log
@* exceptions.cc (sigpacket::process): Avoid a potential deadlock when exiting
due to a signal.
@
text
@a43 2
extern child_info_spawn *chExeced;

d604 1
a604 1
  debug_printf ("In cygwin_except_handler sig %d at %p", si.si_signo, in->Eip);
d823 1
a823 1
  sigproc_printf ("armed signal_arrived %p, sig %d, res %d", signal_arrived,
d845 1
a845 1
      sigproc_printf ("trying to send sig %d but signal %d already armed",
d989 2
a990 5
  if (chExeced)
    {
      chExeced->set_saw_ctrl_c ();
      return TRUE;
    }
d1191 1
a1191 1
  if (!hExeced || (void *) thissig.sa_handler == (void *) SIG_IGN)
d1330 1
a1330 1
  if (hExeced)
d1333 1
a1333 1
      TerminateProcess (hExeced, sigExeced = rc);
d1341 1
a1341 1
  if (hExeced || exit_state > ES_PROCESS_LOCKED)
@


1.360
log
@* cygtls.h (struct _local_storage): Add cw_timer member.
* cygtls.cc (_cygtls::init_thread): Initialize locals.cw_timer.
(_cygtls::fixup_after_fork): Ditto.
* tlsoffsets.h: Regenerate.
* ntdll.h (enum _TIMER_INFORMATION_CLASS): Define.
(struct _TIMER_BASIC_INFORMATION): Define.
(NtQueryTimer): Declare function.
* thread.h (cancelable_wait): Change timeout argument to
PLARGE_INTEGER and provide NULL default.
(fast_mutex::lock): Adjust accordingly.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER
and default to NULL.
* thread.cc (cancelable_wait): Change timeout argument to
PLARGE_INTEGER.  Initialize _cygtls.locals.cw_timer if needed.
Use NT waitable timers for handling timeout.  Return remaining time
to timeout argument if timeout was relative.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER.
Adjust to change in cancelable_wait.
(pthread_mutex::lock): Adjust to change in cancelable_wait.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(__pthread_cond_dowait): Change waitlength argument to PLARGE_INTEGER.
Adjust to changes in cancelable_wait and pthread_cond::wait.
(pthread_cond_timedwait): Adjust to change in __pthread_cond_dowait.
(pthread_cond_wait): Ditto.
(semaphore::_timedwait): Adjust to change in cancelable_wait.
(semaphore::_wait): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
* signal.cc (nanosleep): Ditto.
* wait.cc (wait4): Ditto. Fix copyright dates.
* times.cc (FACTOR, NSPERSEC): Move from here...
* hires.h (FACTOR, NSPERSEC): ...to here.
@
text
@d1324 1
@


1.359
log
@* setup_handler (setup_handler): Change break to goto out, missed in 2011-07-06
changes.
@
text
@d722 1
a722 1
  cancelable_wait (signal_arrived, INFINITE);
@


1.358
log
@* exceptions.cc (_cygtls::interrupt_now): Back out previous change since it
could theoretically cause a non-CTRL-C-able program if a program has suffered
memory corruption.
(setup_handler): Ditto.
@
text
@d864 1
a864 1
	      break;
@


1.357
log
@* exceptions.cc (_cygtls::interrupt_now): Don't check for spinning here.
(setup_handler): Check for spinning here, assuming that it is transitory and
should not affect the retry loop.
@
text
@d780 3
a782 2
     2) in a Windows DLL.  */
  if (incyg ||inside_kernel (cx))
d886 1
a886 1
	  else if (!tls->spinning)
a887 7
	  else
	    {
	      /* We should be out of this state very soon so force a retry
		 without incrementing loop counter.  */
	      i--;
	      interrupted = false;
	    }
@


1.356
log
@* exceptions.cc (CALL_HANDLER_RETRY_INNER): Rename to reflect different
functionality.
(CALL_HANDLER_RETRY_OUTER): New define.
(setup_handler): Add outer loop to signal handler to try harder to deliver the
signal.
* miscfuncs.cc (yield): Drop priority and use SleepEx() to force thread
rescheduling rather than relying on SwitchToThread().
@
text
@d780 2
a781 3
     2) in _sigfe (spinning is true) and about to enter cygwin DLL
     3) in a Windows DLL.  */
  if (incyg || spinning || inside_kernel (cx))
d885 2
d888 6
a893 1
	    interrupted = tls->interrupt_now (&cx, sig, handler, siga);
@


1.355
log
@whitespace elimination
@
text
@d35 2
a36 1
#define CALL_HANDLER_RETRY 20
d852 1
a852 1
  for (int i = 0; i < CALL_HANDLER_RETRY; i++)
d854 1
a854 2
      tls->lock ();
      if (tls->incyg)
d856 10
a865 7
	  sigproc_printf ("controlled interrupt. stackptr %p, stack %p, stackptr[-1] %p",
			  tls->stackptr, tls->stack, tls->stackptr[-1]);
	  tls->interrupt_setup (sig, handler, siga);
	  interrupted = true;
	  tls->unlock ();
	  break;
	}
d867 2
a868 2
      DWORD res;
      HANDLE hth = (HANDLE) *tls;
d870 18
a887 22
      /* Suspend the thread which will receive the signal.
	 For Windows 95, we also have to ensure that the addresses returned by
	 GetThreadContext are valid.
	 If one of these conditions is not true we loop for a fixed number of times
	 since we don't want to stall the signal handler.  FIXME: Will this result in
	 noticeable delays?
	 If the thread is already suspended (which can occur when a program has called
	 SuspendThread on itself) then just queue the signal. */

      sigproc_printf ("suspending thread");
      res = SuspendThread (hth);
      /* Just set pending if thread is already suspended */
      if (res)
	{
	  ResumeThread (hth);
	  break;
	}
      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
      if (!GetThreadContext (hth, &cx))
	system_printf ("couldn't get context of thread, %E");
      else
	interrupted = tls->interrupt_now (&cx, sig, handler, siga);
d889 4
a892 4
      tls->unlock ();
      res = ResumeThread (hth);
      if (interrupted)
	break;
d894 6
a899 2
      sigproc_printf ("couldn't interrupt.  trying again.");
      yield ();
@


1.354
log
@* exceptions.cc (ctrl_c_handler): Simplify test for no parent tty.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Return NULL if ctty is
not tty/console.  Improve test for slave tty/pty device.
@
text
@d691 2
a692 2
                 ? (void *) e->ExceptionInformation[1]
                 : (void *) in->Eip);
@


1.353
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d1002 1
a1002 1
  if (myself->ctty != -1 && t->getpgid () == myself->pid &&
@


1.352
log
@* cygheap.h (init_cygheap::ctty): Use base class so that console can join in
the fun.
* dtable.cc (dtable::stdio_init): Remove special-case call to set_console_ctty
().
* exceptions.cc (sigpacket::process): Conditionally flush terminal input on
certain signals.
* fhandler.h (fhandler_console::get_tty_stuff): Make non-static.
(fhandler_termios::get_ttyp): Move here.
(fhandler_termios::sigflush): Declare.
(fhandler_tty_common::get_ttyp): Delete.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass this as "arch"
argument.
(set_console_ctty): Delete.
(tty_list::get_tty): Just return pointer to shared console region, delaying
get_tty_stuff until open().
(fhandler_console::init): Treat NULL handle as signifying that console should
be opened with O_NOCTTY flag.  Rename handle argument to the more common 'h'.
* fhandler_termios.cc (fhandler_termios::sigflush): Define.
* fhandler_tty.cc (handler_tty_master::init_console): Pass NULL as first
argument to fhandler_console::init.
* pinfo.cc (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
Add extra debugging.
* pinfo.h (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
* sigproc.cc (handle_sigsuspend): Don't special-case non-main threads.
@
text
@d999 1
a999 1
  tty_min *t = cygwin_shared->tty.get_tty (myself->ctty);
@


1.351
log
@* exceptions.cc (try_to_debug): Improve comment.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Add a comment.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
a714 6
  if (&_my_tls != _main_tls)
    {
      cancelable_wait (signal_arrived, INFINITE, cw_cancel_self);
      return -1;
    }

d1171 13
@


1.350
log
@	* autoload.cc (LoadDLLprime): Change dllname storage to string16.
	(struct dll_info): Convert name to WCHAR.
	(std_dll_init): Load DLLs with full path to windows system directory.
	Add hint to Microsoft security advisory.
	* dcrt0.cc (init_windows_system_directory): New function.
	(dll_crt0_0): Call init_windows_system_directory first.
	* exceptions.cc (windows_system_directory): Move to globals.cc.
	(windows_system_directory_length): Ditto.
	(events_init): Drop code fetching windows_system_directory.
	* globals.cc (windows_system_directory): New global variable.
	(windows_system_directory_length): Ditto.
	* net.cc (load_ipv6_funcs): Use windows_system_directory rather than
	GetSystemDirectoryW.
	* netdb.cc (open_system_file): Ditto.  Simplify debug output.
@
text
@d393 3
a395 2
  /* if any of these mutexes is owned, we will fail to start any cygwin app
     until trapped app exits */
@


1.349
log
@	* exceptions.cc (open_stackdumpfile): Don't try to open file if we
	have no filesystem based CWD.  Add comment.
	* path.cc (cwdstuff::set): Set CWD handle to NULL if CWD is a virtual
	path.  Simplify matching comment.
@
text
@a45 2
static WCHAR windows_system_directory[1024];
static size_t windows_system_directory_length;
a1348 13
  windows_system_directory[0] = L'\0';
  GetSystemDirectoryW (windows_system_directory, sizeof (windows_system_directory) / sizeof (WCHAR) - 2);
  PWCHAR end = wcschr (windows_system_directory, L'\0');
  if (end == windows_system_directory)
    api_fatal ("can't find windows system directory");
  if (end[-1] != L'\\')
    {
      *end++ = L'\\';
      *end = L'\0';
    }
  windows_system_directory_length = end - windows_system_directory;
  debug_printf ("windows_system_directory '%W', windows_system_directory_length %d",
		windows_system_directory, windows_system_directory_length);
@


1.348
log
@* exceptions.cc (_cygtls::interrupt_now): Revert to checking for "spinning"
when choosing to defer signal.
(_cygtls::call_signal_handler): Grab func when we have the lock.
* gendef: Update copyright.
(__sigbe): Simplify slightly.
(_sigdelayed): Grab a lock before manipulating stuff.
(_cygtls::pop): Properly return popped value.
(stabilize_sig_stack): Set incyg when we have the lock.
* sigproc.cc: Update copyright.
@
text
@d131 4
a134 1
  if (myself->progname[0])
@


1.347
log
@* exceptions.cc (_cygtls::interrupt_now): Avoid nonsensical tests which delay
an interrupt.
(setup_handler): Remove unneeded DEBUGGING handling.  Ensure that stack is
locked when we are about to do push/pop to it.  Fix debugging output.
@
text
@d781 5
a785 1
  if (incyg || inside_kernel (cx))
d1379 1
d1390 1
a1390 1
	  void (*sigfunc) (int) = func;
d1396 1
a1396 1
	  void (*sigact) (int, siginfo_t *, void *) = (void (*) (int, siginfo_t *, void *)) func;
@


1.346
log
@	* exceptions.cc (dump_exception): Use %W instead of %s for printing
	progname.
	* fork.cc (frok::parent): Fix typos in debug output.
	* spawn.cc (spawn_guts): Copy wide Win32 filename into _pinfo::progname,
	rather than native NT name.
@
text
@d781 1
a781 1
  if (incyg || spinning || locked () || inside_kernel (cx))
a863 1
      tls->unlock ();
d876 1
a876 8
#ifndef DEBUGGING
      sigproc_printf ("suspending mainthread");
#else
      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
      if (!GetThreadContext (hth, &cx))
	memset (&cx, 0, sizeof cx);
      sigproc_printf ("suspending mainthread PC %p", cx.Eip);
#endif
d886 1
a886 1
	system_printf ("couldn't get context of main thread, %E");
d890 1
@


1.345
log
@	* exceptions.cc (open_stackdumpfile): Correctly append .stackdump
	suffix.

	* nlsfuncs.cc (rebase_locale_buf): Reorder arguments.  Accommodate
	throughout.  Add pointer to end of buffer and avoid changing pointers
	not pointing into the buffer.
@
text
@d196 1
a196 1
  small_printf ("ebp=%08x esp=%08x program=%s, pid %u, thread %s\r\n",
@


1.344
log
@* environ.cc (regopt): Change the first argument to wide char string.
(environ_init): Accommodate change to the first argument of regopt.
* exception.cc (open_stackdumpfile): Accommodate change to the type of progname
in _pinfo.
* external.cc (fillout_pinfo): Ditto.
* fhandler_process.cc (format_process_winexename): Ditto.
(format_process_stat): Ditto.
* fork.cc (fork::parent): Ditto.
* pinfo.cc (pinfo_basic::pinfo_basic): Call GetModuleFileNameW instead of
GetModuleFileName.
(pinfo::thisproc): Accommodate change to the type of progname in _pinfo.
(pinfo_init): Ditto.
* pinfo.h (_pinfo): Change the type of progname to a wide char array.
* registry.h (reg_key::get_int): Change the first argument from constant point
to pointer to constant.
(reg_key::get_string): Ditto.  Change the last argument likewise.
* registry.cc (reg_key::get_int): Accommodate change to the declaration.
(reg_key::get_string): Ditto.
* strace.cc (strace::hello): Accommodate change to the type of progname in
_pinfo.
(strace::vsprntf): Ditto.
@
text
@d143 1
a143 1
      wcscpy(corefile, p);
a147 1
      RtlAppendUnicodeToString (&ucore, L".stackdump");
@


1.343
log
@	* cygheap.h (struct init_cygheap): Add rlim_core member.
	* cygheap.cc (cygheap_init): Initialize rlim_core to RLIM_INFINITY.
	* exceptions.cc (stackdump): Drop extern declaration of rlim_core.
	Refer to cygheap->rlim_core instead.
	(exception::handle): Disable stackdumping if cygheap->rlim_core is 0.
	Don't set WCOREDUMP flag in exit code, if cygheap->rlim_core is 0.
	(sigpacket::process): Ditto.
	* resource.cc (rlim_core): Remove.
	(getrlimit): Fetch RLIMIT_CORE value from cygheap->rlim_core.
	(setrlimit): Store RLIMIT_CORE value in cygheap->rlim_core.
@
text
@d133 1
a133 1
      const char *p;
d136 2
a137 2
	p = "unknown";
      else if ((p = strrchr (myself->progname, '\\')))
d142 2
a143 1
      WCHAR corefile[strlen (p) + sizeof (".stackdump")];
d147 1
a147 5
      RtlInitEmptyUnicodeString (&ucore, corefile,
				 sizeof corefile - sizeof (WCHAR));
      ucore.Length = sys_mbstowcs (ucore.Buffer,
				   ucore.MaximumLength / sizeof (WCHAR),
				   p, strlen (p)) * sizeof (WCHAR);
@


1.342
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@a288 1
  extern unsigned long rlim_core;
d291 1
a291 1
  if (rlim_core == 0UL || (open_file && already_dumped))
d664 6
a669 3
	  open_stackdumpfile ();
	  dump_exception (e, in);
	  stackdump ((DWORD) ebp, 0, 1);
d688 2
a689 1
      me.signal_exit (0x80 | si.si_signo);	// Flag signal + core dump
d1316 2
a1317 1
      si.si_signo |= 0x80;
@


1.341
log
@Update some copyrights.
* cygtls.cc (_cygtls::call): Invoke new exception protection here.
(_cygtls::init_thread): Remove conditionalized exception handler setup.
(exception_list): Delete declaration.
(_cygtls::init_exception_handler): Delete obsolete function.
* cygtls.h: Remove (now) unneeded include.
(_cygtls): Make this a real C++ class.
(_cygtls::handle_exceptions): Remove.
(_cygtls::init_exception_handler): Remove.
(_cygtls::call2): Make private.
(myfault::faulted): Remove unneeded parentheses.
* dcrt0.cc (dll_crt0_1): Remove exception handler setup.
* dlfcn.cc (dlopen): Ditto.
(dlclose): Ditto.
* dll_init.cc (dll_dllcrt0_1): Ditto.
(dll_list::detach): Use new exception handler protection.
* exceptions.cc (dump_exception): Rename to prevent confusion with new class.
(exception::handle): Rename from _cygtls::handle_exceptions.  Accommodate new
exception class.  Accommodate rename to dump_exception.
* tlsoffsets.h: Regenerate.
@
text
@d443 1
a443 1
	low_priority_sleep (0);
d904 1
a904 1
      low_priority_sleep (0);
@


1.340
log
@* cygtls.h (_cygtls::init_exception_handler): Eliminate argument.
(_cygtls::andreas): Convert to a pointer.
(san): Convert to a real class with methods.  Use a linked list to keep track
of previous handlers on the "stack".
(myfault): Rewrite to use new san class rather than calling directly into
_cygtls.
* cygtls.cc (_cygtls::init_exception_handler): Just assume that we're always
using the standard exception handler.
(_cygtls::init_thread): Reflect loss of argument to init_exception_handler.
* dcrt0.cc (dll_crt0_1): Ditto.
* dfcn.cc (dlopen): Ditto.
(dlclose): Reset the exception handler after FreeLibrary.
* dll_init.cc (dll_list::detach): Make sure that the exception handler is
initialized before calling destructors.
* exceptions.cc (_cygtls::handle_exceptions): Accommodate new andreas pointer.
* thread.cc (verifyable_object_isvalid): Pass objectptr to faulted for explicit
NULL pointer checking.
* tlsoffsets.h: Regenerate.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d33 1
d178 1
a178 1
exception (EXCEPTION_RECORD *e,  CONTEXT *in)
d480 1
a480 1
_cygtls::handle_exceptions (EXCEPTION_RECORD *e, exception_list *frame, CONTEXT *in, void *)
d634 1
a634 1
  _except_list->handler = _cygtls::handle_exceptions;
d666 1
a666 1
	  exception (e, in);
@


1.339
log
@	Throughout, revert ill-conceived replacement of hMainThread with
	GetCurrentThread/NtCurrentThread.
	* dcrt0.cc (dll_crt0_0): Duplicate main thread handle to hMainThread
	again.
@
text
@d625 2
a626 2
  if (me.fault_guarded ())
    me.return_from_fault ();
@


1.338
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d487 1
a487 1
      SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_NORMAL);
d1310 1
a1310 1
      GetThreadContext (GetCurrentThread (), &c);
@


1.337
log
@* exceptions.cc (_cygtls::signal_exit): There's no need to set signal_arrived
if we're exiting.
@
text
@d487 1
a487 1
      SetThreadPriority (hMainThread, THREAD_PRIORITY_NORMAL);
d1310 1
a1310 1
      GetThreadContext (hMainThread, &c);
@


1.336
log
@* exceptions.cc: Move global variable sigExeced...
* globals.cc: here.
* pinfo.cc (pinfo::maybe_set_exit_code_from_windows): Remove now unneeded
declaration.
@
text
@a1342 1
  SetEvent (signal_arrived);
@


1.335
log
@* exceptions.cc (sigpacket::process): Explicitly set thread-specific handler
function to zero to avoid transferring to incorrect location.
(_cygtls::call_signal_handler): Don't transfer to handler if there is no
handler to transfer to.
@
text
@a42 1
int NO_COPY sigExeced;
@


1.334
log
@* exceptions.cc (sigpacket::process): Give sigwait() processing precedence even
when a handler is present.
* syscalls.cc (getpagesize): Change return to 'int'.
@
text
@d1301 1
d1378 1
a1378 1
  while (sig)
@


1.333
log
@	* exceptions.cc (handle_exceptions): Set si_addr according to
	POSIX for SIGSEGV.
@
text
@d1210 2
d1214 2
a1215 3
      insigwait_mask = !handler && (tls = _cygtls::find_tls (si.si_signo));
      if (tls)
	use_tls = tls;
@


1.332
log
@* exceptions.cc (sig_handle_tty_stop): Set stopsig to SIGCONT when continuing.
(stopped_or_terminated): Honor WCONTINUED.
* wait.cc (wait4): Ditto.
* include/cygwin/wait.h (WCONTINUED): Define.
(__W_CONTINUED): Ditto.
(WIFCONTINUED): Ditto.
@
text
@d689 3
a691 1
  si.si_addr = (void *) in->Eip;
@


1.331
log
@	* security.cc (set_file_sd): Drop using FILE_OPEN_FOR_RECOVERY flag in
	call to NtOpenFile.
	* exceptions.cc (open_stackdumpfile): Ditto in call to NtCreateFile.
	* fhandler.cc (fhandler_base::open): Ditto.  Simplify setting
	create_options.

	* mount.cc (fs_info::update): Recognize offline storage.
	(fillout_mntent): Report UDF and offline storage.
	* mount.h (class fs_info): Add is_csc_cache status flag.
@
text
@d763 1
@


1.330
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d163 1
a163 2
			     | FILE_OPEN_FOR_BACKUP_INTENT
			     | FILE_OPEN_FOR_RECOVERY, NULL, 0);
@


1.329
log
@* exceptions.cc (try_to_debug): Avoid creating a huge buffer on the stack.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
d12 1
a479 1
extern "C" char *__progname;
@


1.328
log
@* exceptions.c (sigpacket::process): Set tls on return since it is assumed to
be set to a valid value by the caller.
@
text
@a370 2
  WCHAR dbg_cmd[sizeof debugger_command];

d422 2
a423 1
  sys_mbstowcs (dbg_cmd, sizeof debugger_command, debugger_command);
@


1.327
log
@* exceptions.cc (sigpacket::process): Rework previous change.  tls could still
become NULL.
@
text
@d1290 1
@


1.326
log
@* exceptions.cc (sigpacket::process): Make sure that 'tls' is never NULL when
used.
@
text
@d1194 1
a1194 3
  bool tls_was_null = !tls;
  if (tls_was_null)
    tls = _main_tls;
d1207 2
a1208 2
  else if (tls_was_null)
    insigwait_mask = !handler && (tls = _cygtls::find_tls (si.si_signo));
d1210 5
a1214 1
    insigwait_mask = sigismember (&tls->sigwait_mask, si.si_signo);
d1223 1
a1223 1
  else
d1274 1
a1274 1
  tls->set_siginfo (this);
d1287 1
a1287 1
  rc = setup_handler (si.si_signo, handler, thissig, tls);
d1296 2
a1297 2
  tls->sig = si.si_signo;
  tls->set_siginfo (this);
d1299 1
a1299 1
  SetEvent (tls->event);
d1308 1
a1308 1
      tls->copy_context (&c);
d1312 1
a1312 1
  tls->signal_exit (si.si_signo);	/* never returns */
@


1.325
log
@* dcrt0.cc (dll_crt0_1): Add a symbol denoting return from call to main().
* exceptions.cc (stack_info::walk): Stop walking the stack when we hit
_cygwin_exit_return rather than just blindly stopping when PC becomes zero.
@
text
@d1194 4
a1202 2
      if (!tls)
	tls = _main_tls;
d1209 1
a1209 1
  else if (!tls)
d1221 1
a1221 1
  else if (tls)
a1223 3
  if (!tls)
    tls = _main_tls;

@


1.324
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d246 2
d254 4
a263 3
  if (!sf.AddrPC.Offset)
    return 0;		/* stack frames are exhausted */

@


1.323
log
@Remove unneeded header files from source files throughout.
@
text
@d152 1
a152 1
	 in Cygwin's cwd. */
@


1.322
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a17 2
#include <setjmp.h>
#include <assert.h>
a20 2
#include "exceptions.h"
#include "sync.h"
a23 1
#include "cygerrno.h"
a25 1
#include "security.h"
@


1.321
log
@	Cleanup.
	* exceptions.cc (windows_system_directory): Make static.  Convert to
	WCHAR.
	(_cygtls::inside_kernel): Accommodate above change.  Check module
	path name for leading \\?\ and skip, if so.
	(try_to_debug): Call GetEnvironmentStringsW and convert evaluation to
	WCHAR to avoid truncated environment problem.
	(has_visible_window_station): Call GetUserObjectInformationW.
	(events_init): Accommodate above conversion of windows_system_directory.
	* init.cc (respawn_wow64_process): Use WCHAR functions to start new
	process.
	* net.cc (__dup_ent): Drop Windows 9x consideration.
	(load_ipv6_funcs): Use WCHAR functions to load IPv6 libs.
	* syscalls.cc (syscalls.cc): Remove call to GetDiskFreeSpace.
@
text
@d13 1
@


1.320
log
@* hookapi.cc (find_first_notloaded_dll): New function.
* pinfo.cc (status_exit): New function.  Issue message when dll not found.  Use
find_first_notloaded_dll to find a nonexistent dll.
(pinfo::maybe_set_exit_code_from_windows): Call status_exit when exit code >=
0xc0000000UL.
* sigproc.cc (child_info::proc_retry): Return exit code when
STATUS_DLL_NOT_FOUND.
* spawn.cc (spawn_guts): Minor cleanup.
* syscalls.cc (close_all_files): Don't actually close stderr filehandle.  Just
make it noninheritable.
* winsup.h (find_first_notloaded_dll): Declare new function.
* ntdll.h: Add several missing NTSTATUS defines.
@
text
@d20 1
d50 1
a50 1
char windows_system_directory[1024];
d331 3
a333 2
  char *checkdir = (char *) alloca (windows_system_directory_length + 4);
  memset (checkdir, 0, sizeof (checkdir));
d343 1
a343 1
  else if (!GetModuleFileName (h, checkdir, windows_system_directory_length + 2))
d346 7
a352 2
    res = strncasematch (windows_system_directory, checkdir,
			 windows_system_directory_length);
d407 2
a408 2
  char* rawenv = GetEnvironmentStrings () ;
  for (char* p = rawenv; *p != '\0'; p = strchr (p, '\0') + 1)
d410 1
a410 1
      if (strncmp (p, "CYGWIN=", strlen ("CYGWIN=")) == 0)
d412 1
a412 1
	  char* q = strstr (p, "error_start") ;
d416 2
a417 2
	      *q = '_' ;
	      SetEnvironmentVariable ("CYGWIN", p + strlen ("CYGWIN=")) ;
d927 1
a927 1
      && GetUserObjectInformationA (station_hdl, UOI_FLAGS, &uof,
d1349 3
a1351 3
  windows_system_directory[0] = '\0';
  GetSystemDirectory (windows_system_directory, sizeof (windows_system_directory) - 2);
  char *end = strchr (windows_system_directory, '\0');
d1354 1
a1354 1
  if (end[-1] != '\\')
d1356 2
a1357 2
      *end++ = '\\';
      *end = '\0';
d1360 1
a1360 1
  debug_printf ("windows_system_directory '%s', windows_system_directory_length %d",
@


1.319
log
@	* winsup.h (NT_MAX_PATH): Revert ill-advised change to 32767.
	Accommodate change throughout.

	* cygwin.din (cygwin_conv_path): Export.
	(cygwin_conv_path_list): Export.
	(cygwin_create_path): Export.
	* dcrt0.cc (dll_crt0_1): Use cygwin_conv_path.
	* dtable.cc (handle_to_fn): Ditto.  Don't expect UNICODE_STRING being
	0-terminated.
	* environ.cc (env_plist_to_posix): New helper function.
	(env_plist_to_win32): Ditto.
	(env_path_to_posix): Ditto.
	(env_path_to_win32): Ditto.
	(return_MAX_PATH): Remove.
	(conv_envvars): Use new helper functions.  Drop removed members.
	(win_env::operator =): Accommodate removal of path length functions.
	(win_env::add_cache): Accommodate new env helper function API.
	(posify): Ditto.
	* environ.h (struct win_env): Ditto. Remove path length function
	pointers since they are unused.
	* path.cc (warn_msdos): Use cygwin_conv_path.
	(getfileattr): Use new tmp_pathbuf::u_get method.
	(fillout_mntent): Ditto.
	(symlink_info::check): Ditto.
	(path_conv::check): Use sizeof (WCHAR) instead of constant 2.
	(symlink_info::check_reparse_point): Ditto.
	(conv_path_list): Get max size of target string as argument.  Call
	cygwin_conv_path as helper function.
	(cygwin_conv_path): New function.
	(cygwin_create_path): New function.
	(cygwin_conv_to_win32_path): Just call cygwin_conv_path with size set
	to MAX_PATH.
	(cygwin_conv_to_full_win32_path): Ditto.
	(cygwin_conv_to_posix_path): Ditto.
	(cygwin_conv_to_full_posix_path): Ditto.
	(conv_path_list_buf_size): Add FIXME comment.
	(env_PATH_to_posix): Rename from env_win32_to_posix_path_list.
	Add size argument as required for env helper functions.
	(cygwin_win32_to_posix_path_list): Call conv_path_list with size set to
	MAX_PATH.
	(cygwin_posix_to_win32_path_list): Ditto.
	(cygwin_conv_path_list): New function.
	(cwdstuff::get): Fix length argument in call to sys_wcstombs.
	* spawn.cc (find_exec): Use cygwin_conv_path_list.
	* tls_pbuf.h (tmp_pathbuf::u_get: New method.
	* uinfo.cc (cygheap_user::ontherange): Allocate temporary path buffers
	using tmp_pathbuf.  Use cygwin_conv_path.
	* winf.cc (av::unshift): Use cygwin_conv_path.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h: Comment out old cygwin32_XXX API.
	Mark old path handling API as deprecated.
	(cygwin_conv_path_t): Typedef.  Define values.
	(cygwin_conv_path): Declare.
	(cygwin_create_path): Declare.
	(cygwin_conv_path_list): Declare.
@
text
@d156 1
a156 1
         in Cygwin's cwd. */
@


1.318
log
@* cygtls.cc (_cygtls::init_exception_handler): Semi-revert to making only
ourselves the exception handler and nothing else.
* exceptions.cc (open_stackdumpfile): Use correct format specifiers for unicode
when printing nameof stackdump file.
(stack_info::walk): Stop walking if ebp points into cygwin itself.
(_cygtls::handle_exceptions): Detect when signal is masked and treat as if it
was not caught.  Reinitialize exception handler to known state to avoid
subsequent attempts to call Windows exception handlers if an exception occurs
in a signal handler.  Revert to a 'return 0' rather than using a goto.
* strfuncs.cc (sys_wcstombs_alloc): Minor formatting tweak.
* winsup.h: Fix comment typo.
@
text
@d473 2
d628 4
a631 3
  /* Reinitialize exception handler list to include just ourselves so that any
     exceptions that occur in a signal handler will be properly caught. */
  me.init_exception_handler (handle_exceptions);
a639 1
      rtl_unwind (frame, e);
d661 1
@


1.317
log
@* exceptions.cc (_cygtls::handle_exceptions): Only call rtl_unwind when
exiting.  Just return, don't set thread context.
* gendef (_setjmp): Store %fs:0 in jmp_buf.
(_sjfault): Ditto.
(_ljfault): Restore %fs:0 from jmp_buf.
(_longjmp): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d171 1
a171 1
	    system_printf ("Dumping stack trace to %s", corefile);
d173 1
a173 1
	    debug_printf ("Dumping stack trace to %s", corefile);
d256 1
a256 1
  if ((ebp = (char **) next_offset ()) == NULL)
d605 2
a606 1
  if (global_sigs[si.si_signo].sa_mask & SIGTOMASK (si.si_signo))
d625 6
a630 1
  if (!cygwin_finished_initializing
d632 1
d637 1
d656 1
a656 1
	      goto out;
a658 1
	  rtl_unwind (frame, e);
a688 1
out:
@


1.316
log
@	* exceptions.cc (_cygtls::handle_exceptions): When being debugged,
	leave through SetThreadContext, too, to keep exception handler stack
	intact.
@
text
@a601 2
  rtl_unwind (frame, e);

d651 1
a681 12
  /* The OS adds an exception list frame to the stack.  It expects to be
     able to remove this entry after the exception handler returned.
     However, when unwinding to our frame, our frame becomes the uppermost
     frame on the stack (%fs:0 points to frame).  This way, our frame
     is removed from the exception stack and just disappears.  So, we can't
     just return here or things will be screwed up by the helpful function
     in (presumably) ntdll.dll.

     So, instead, we will do the equivalent of a longjmp here and return
     to the caller without visiting any of the helpful code installed prior
     to this function.  This should work ok, since a longjmp() out of here has
     to work if linux signal semantics are to be maintained. */
d683 1
a683 2
  SetThreadContext (GetCurrentThread (), in);
  return 0; /* Never actually returns.  This is just to keep gcc happy. */
@


1.315
log
@	* exceptions.cc (open_stackdumpfile): Add comments.
@
text
@d650 1
a650 1
	      return 0;
d695 1
a695 1

@


1.314
log
@	* exceptions.cc (open_stackdumpfile): Use NtCreateFile to create
	stackdump file.
@
text
@d148 1
d155 2
d162 1
a162 1

@


1.313
log
@	* exceptions.cc (stack_info::walk): Fix typo.
@
text
@d35 1
d144 22
a165 5
      char corefile[strlen (p) + sizeof (".stackdump")];
      __small_sprintf (corefile, "%s.stackdump", p);
      HANDLE h = CreateFile (corefile, GENERIC_WRITE, 0, &sec_none_nih,
			     CREATE_ALWAYS, 0, 0);
      if (h != INVALID_HANDLE_VALUE)
@


1.312
log
@* cygtls.cc (_cygtls::handle_threadlist_exception): Make it clear that the
function never actually returns.
* exceptions.cc (_cygtls::handle_exceptions): Jump out of function rather than
returning to avoid meddling by previously installed exception handlers.
@
text
@d259 1
a259 1
      for (unsigned i = 0; i < nparams; i++)
@


1.311
log
@	* dcrt0.cc (initial_env): Only use local buffer "buf" if DEBUGGING is
	enabled.  Replace calls to GetEnvironmentVariable by calls to
	GetEnvironmentVariableA for clarity.  Call GetEnvironmentVariableA
	with NULL buffer.
	(cygbench): Ditto, drop local buffer.
	* environ.cc (getearly): Call GetEnvironmentVariableA.
	(environ_init): Retrieve unicode environment and convert to current
	codepage locally.
	(getwinenveq): Ditto.
	* exceptions.cc (try_to_debug): Accommodate new sys_mbstowcs calling
	convention.
	* fhandler_clipboard.cc (set_clipboard): Call sys_mbstowcs to retrieve
	required buffer length.
	* fork.cc (frok::child): Call GetEnvironmentVariableA.
	* miscfuncs.cc: Accommodate changed arguments in calls to sys_mbstowcs.
	* sec_auth.cc: Ditto.
	* strfuncs.cc (sys_wcstombs_alloc): Fix formatting.
	(sys_mbstowcs): Change arguments to allow specifying a source string
	length.
	(sys_mbstowcs_alloc): Ditto.
	* uinfo.cc (cygheap_user::ontherange): Accommodate changed arguments in
	calls to sys_mbstowcs.
	* winsup.h (sys_mbstowcs): Adjust declaration.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d662 15
a676 1
  return 0;
@


1.310
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d398 1
a398 1
  sys_mbstowcs (dbg_cmd, debugger_command, sizeof debugger_command);
@


1.309
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d685 1
a685 1
  sigset_t oldmask = myself->getsigmask ();	// Remember for restoration
d687 1
a687 1
  set_signal_mask (tempmask, myself->getsigmask ());
d998 1
a998 2
  set_signal_mask (newmask, myself->getsigmask ());
sigproc_printf ("mask now %p\n", myself->getsigmask ());
d1012 1
a1012 1
  sigset_t mask = myself->getsigmask ();
d1014 1
a1014 1
  set_signal_mask (mask, myself->getsigmask ());
d1030 1
a1030 1
  sigset_t mask = myself->getsigmask ();
d1032 1
a1032 1
  set_signal_mask (mask, myself->getsigmask ());
d1052 1
a1052 1
  sigset_t mask = myself->getsigmask ();
d1070 1
a1070 1
  set_signal_mask (mask, myself->getsigmask ());
d1092 1
a1092 1
    oldmask = myself->getsigmask ();
d1096 1
a1096 1
  myself->setsigmask (newmask);
d1364 1
a1364 1
      set_signal_mask (this_oldmask, myself->getsigmask ());
@


1.308
log
@        * cygtls.cc (_cygtls::init_exception_handler): Revert patch
        from 2005-12-02.
        * exceptions.cc (stack_info::walk): Add workaround for NT 5.2
        64 bit OSes.
        * wincap.h (wincaps::has_restricted_stack_args): New element.
        * wincap.cc: Implement above element throughout.
        (wincapc::init): Reset has_restricted_stack_args if not running
        under WOW64.
@
text
@d38 1
a38 1
char debugger_command[2 * PATH_MAX + 20];
d121 2
a122 2
  char pgm[PATH_MAX];
  if (!GetModuleFileName (NULL, pgm, PATH_MAX))
@


1.307
log
@* dtable.cc (POSIX_NAMED_PIPE): New define.
(POSIX_NAMED_PIPE_LEN): Ditto.
(dtable::add_archetype): Use crealloc_abort.
(dtable::init_std_file_from_handle): Specifically detect pipe stdin/stdout.
Pass name to build_fh_dev so that proper name is recorded.  Use binmode of fh
if it is set before using get_default_mode.  Set proper read/write access when
calling init().
(handle_to_fn): Handle pipes.
* fhandler.cc (fhandler_base::wait_overlapped): Add some debugging.
* fhandler.h (fhandler_base::set_name): Default to just setting the path_conv
name.
(fhandler_pipe::init): Declare.
* pipe.cc (struct pipesync): New struct.
(getov_result): New function.  Blocks and retrieves the result of an overlay
I/O operation.
(pipe_handler): New function.
(pipesync::pipesync): New function.  Initializer for pipesync struct.
(handler_pipe::init): Define.  Detects attempts to set up a "native" pipe
fhandler and creates a thread which accepts input from or output to the
non-cygwin pipe, creating a cygwin pipe wrapper around the non-cygwin pipe.
(fhandler_pipe::create): Add pipe-specific flags to call to init().
* exceptions.cc (ctrl_c_handler): Lock process while we determine what to do.
@
text
@d248 14
a261 3
    /* The arguments follow the return address */
    for (unsigned i = 0; i < NPARAMS; i++)
      sf.Params[i] = (DWORD) *++ebp;
@


1.306
log
@	* dcrt0.cc: Include string.h.
	(initial_env): Use small_printf's %P specifier.
	* dll_init.cc (dll_list::alloc): Use PATH_MAX instead of CYG_MAX_PATH
	for path name buffer size.
	* dll_init.h (struct dll): Ditto.
	* environ.cc: Include string.h.
	(win_env::add_cache): Use temporary local buffer for path conversion.
	(posify): Ditto.
	* exceptions.cc (try_to_debug): Use CreateProcessW to allow long path
	names.
	* miscfuncs.cc: Drop unused implementations of strcasematch and
	strncasematch.
	(ch_case_eq): Drop.
	(strcasestr): Drop.
	(cygwin_wcscasecmp): New function.
	(cygwin_wcsncasecmp): New function.
	(cygwin_strcasecmp): New function.
	(cygwin_strncasecmp): New function.
	(cygwin_wcslwr): New function.
	(cygwin_wcsupr): New function.
	(cygwin_strlwr): New function.
	(cygwin_strupr): New function.
	* ntdll.h (RtlDowncaseUnicodeString): Declare.
	(RtlUpcaseUnicodeString): Declare.
	(RtlInt64ToHexUnicodeString): Fix typo in comment.
	* string.h: Disable not NLS aware implementations of strcasematch
	and strncasematch.
	(cygwin_strcasecmp): Declare.
	(strcasecmp): Define as cygwin_strcasecmp.
	(cygwin_strncasecmp): Declare.
	(strncasecmp): Define as cygwin_strncasecmp.
	(strcasematch):Define using cygwin_strcasecmp.
	(strncasematch):Define using cygwin_strncasecmp.
	(cygwin_strlwr): Declare.
	(strlwr): Define as cygwin_strlwr.
	(cygwin_strupr): Declare.
	(strupr): Define as cygwin_strupr.
	* wchar.h: New file.
	* wincap.cc (wincapc::init): Use "NT" as fix OS string.
	* winsup.h (strcasematch): Drop declaration.
	(strncasematch): Ditto.
	(strcasestr): Ditto.
@
text
@d891 1
@


1.305
log
@	* dcrt0.cc (initial_env): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	(dll_crt0_1): Allocate new_argv0 with PATH_MAX size.
	* exceptions.cc (debugger_command): Set size to 2 * PATH_MAX + 20;
	(error_start_init): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	* external.cc (fillout_pinfo): Always fill out ep.progname 0-terminated.
	Fill out ep.progname_long.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Allocate
	buffer for executable filename with PATH_MAX size.
	* pinfo.cc: Throughout use PATH_MAX instead of CYG_MAX_PATH.
	* pinfo.h (class _pinfo): Set progname size to PATH_MAX.
	* smallprint.cc: Include limits.h.  Use PATH_MAX instead of CYG_MAX_PATH
	for path name buffer size.
	* strace.cc (strace::vsprntf): Ditto.
	* include/sys/cygwin.h (EXTERNAL_PINFO_VERSION_32_LP): Define.
	(EXTERNAL_PINFO_VERSION): Set to EXTERNAL_PINFO_VERSION_32_LP.
	(struct external_pinfo): Add progname_long member.
	* include/sys/dirent.h: Correctly include limits.h instead of
	sys/limits.h.
@
text
@d334 2
d352 1
a352 1
  STARTUPINFO si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL};
d387 11
a397 10
  dbg = CreateProcess (NULL,
		       debugger_command,
		       NULL,
		       NULL,
		       FALSE,
		       CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,
		       NULL,
		       NULL,
		       &si,
		       &pi);
@


1.304
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.
@
text
@d38 1
a38 1
char debugger_command[2 * CYG_MAX_PATH + 20];
d121 2
a122 2
  char pgm[CYG_MAX_PATH];
  if (!GetModuleFileName (NULL, pgm, CYG_MAX_PATH))
@


1.303
log
@* cygtls.h (_cygtls::inside_kernel): Move function declaration into _cygtls
class.
* exceptions.cc (_cygtls::inside_kernel): Move function definition into _cygtls
class.
* fhandler.cc (fhandler_base::wait_overlapped): Make return tri-state to detect
when there is a EINTR situation.  Add a pointer to a length parameter.  Move
GetOverlappedResult into this function.
(fhandler_base::read_overlapped): Accommodate above changes and loop if we
receive a restartable signal.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::wait_overlapped): Reflect above changes.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
@
text
@a1288 3
  user_data->resourcelocks->Delete ();
  user_data->resourcelocks->Init ();

@


1.302
log
@* init.cc (in_dllentry): Delete.
(dll_entry): Remove assignment to deleted variable.
* winsup.h (in_dllentry): Delete declaration.
* exceptions.cc (inside_kernel): Use another method to see if we are in
dll_entry phase.
@
text
@d285 2
a286 2
static bool
inside_kernel (CONTEXT *cx)
d291 1
a291 1
  if (!_my_tls.isinitialized ())
d630 1
a630 1
	  if (!inside_kernel (in))		/* User space */
@


1.301
log
@	* exceptions.cc (dummy_ctrl_c_handler): Remove.
	(init_console_handler): Drop has_null_console_handler_routine checks.
	* fhandler_raw.cc (fhandler_dev_raw::open): Drop has_raw_devices check.
	* fhandler_serial.cc (fhandler_serial::open): Drop
	.supports_reading_modem_output_lines check.
	* miscfuncs.cc (low_priority_sleep): Drop has_switch_to_thread check.
	* shared.cc (open_shared): Drop needs_memory_protection checks.
	* spawn.cc (spawn_guts): Drop start_proc_suspended check.
	* uname.cc (uname): Drop has_valid_processorlevel check.
	* wincap.cc: Remove has_raw_devices, has_valid_processorlevel,
	supports_reading_modem_output_lines, needs_memory_protection,
	has_switch_to_thread, start_proc_suspended and
	has_null_console_handler_routine throughout.
	* wincap.h: Ditto.
@
text
@d291 1
a291 1
  if (in_dllentry)
@


1.300
log
@* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
exit_state indicates that we've visited do_exit.
* sync.h (lock_process::lock_process): Use renamed exit_state -
ES_PROCESS_LOCKED.
* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.
@
text
@a96 6
BOOL WINAPI
dummy_ctrl_c_handler (DWORD)
{
  return TRUE;
}

d103 1
a103 2
  if (wincap.has_null_console_handler_routine ())
    SetConsoleCtrlHandler (NULL, FALSE);
d106 1
a106 1
  else if (wincap.has_null_console_handler_routine ())
a107 2
  else
    res = SetConsoleCtrlHandler (dummy_ctrl_c_handler, TRUE);
@


1.299
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d1291 1
a1291 1
  if (hExeced || exit_state)
@


1.298
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@d531 1
a531 1
        {
@


1.297
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d529 2
a530 1
      switch (mmap_is_attached_or_noreserve_page (e->ExceptionInformation[1]))
d532 1
a532 1
	case 2:		/* MAP_NORESERVE page, now commited. */
d534 2
a535 2
	case 1:		/* MAP_NORESERVE page, commit failed, or
			   access to mmap page beyond EOF. */
@


1.297.2.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d300 1
a300 1
  if (!_my_tls.isinitialized ())
d1290 1
a1290 1
  if (hExeced || exit_state > ES_PROCESS_LOCKED)
@


1.297.2.2
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.

	* mmap.cc: Convert usage of dynamically growing cmalloced arrays to
	cmalloced linked lists throughout.
	(class mmap_record): Add LIST_ENTRY element.
	(mmap_record::match): New method, taking over match algorithm from
	list::search_record.
	(class mmap_list): Rename from class list.  Add LIST_ENTRY.  Convert
	recs to a LIST_HEAD.  Drop nrecs and maxrecs members.
	(mmap_list::get_record): Drop entirely.
	(mmap_list::free_recs): Drop entirely.
	(mmap_list::del_record): Take mmap_record to delete as parameter.
	(mmap_list::search_record): Convert to mmap_record::match.
	(class mmap_areas): Rename from class map.  Convert lists to LIST_HEAD.
	(mmap_areas::get_list): Drop entirely.
	(mmap_areas::del_list): Take mmap_list to delete as parameter.
	(mprotect): Fix indentation.
@
text
@d1297 3
@


1.297.2.3
log
@        * cygtls.cc (_cygtls::init_exception_handler): Revert patch
        from 2005-12-02.
        * exceptions.cc (stack_info::walk): Add workaround for NT 5.2
        64 bit OSes.
        * wincap.h (wincaps::has_restricted_stack_args): New element.
        * wincap.cc: Implement above element throughout.
        (wincapc::init): Reset has_restricted_stack_args if not running
        under WOW64.
@
text
@d257 3
a259 14
    {
      unsigned nparams = NPARAMS;

      /* The arguments follow the return address */
      sf.Params[0] = (DWORD) *++ebp;
      /* Hack for XP/2K3 WOW64.  If the first stack param points to the
	 application entry point, we can only fetch one additional
	 parameter.  Accessing anything beyond this address results in
	 a SEGV.  This is fixed in Vista/2K8 WOW64. */
      if (wincap.has_restricted_stack_args () && sf.Params[0] == 0x401000)
	nparams = 2;
      for (unsigned i = 1; i < nparams; i++)
	sf.Params[i] = (DWORD) *++ebp;
    }
@


1.297.2.4
log
@	* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and
	use either main sigmask or current thread sigmask.
	(set_process_mask): Ditto.
	(sighold): Ditto.
	(sigrelse): Ditto.
	(sigset): Ditto.
	(set_process_mask_delta): Ditto.
	(_cygtls::call_signal_handler): Ditto.
	* fhandler_process.cc (format_process_status): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* pinfo.h (class pinfo): Ditto.
	* select.cc (pselect): Ditto.
	* signal.cc (sigprocmask): Ditto.
	(abort): Ditto.
	(sigpause): Ditto.
	(sigsend): Ditto.
	(wait_sig): Ditto.
	* sigproc.cc (sig_send): Ditto.
	(pending_signals::add): Ditto.
	(wait_sig): Ditto.
	* thread.h (pthread::parent_tls): New member.
	* thread.cc (pthread::pthread): Record parent_tls here.
	(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d690 1
a690 1
  sigset_t oldmask = _my_tls.sigmask;	// Remember for restoration
d692 1
a692 1
  set_signal_mask (tempmask, _my_tls.sigmask);
d1002 2
a1003 1
  set_signal_mask (newmask, _my_tls.sigmask);
d1017 1
a1017 1
  sigset_t mask = _my_tls.sigmask;
d1019 1
a1019 1
  set_signal_mask (mask, _my_tls.sigmask);
d1035 1
a1035 1
  sigset_t mask = _my_tls.sigmask;
d1037 1
a1037 1
  set_signal_mask (mask, _my_tls.sigmask);
d1057 1
a1057 1
  sigset_t mask = _my_tls.sigmask;
d1075 1
a1075 1
  set_signal_mask (mask, _my_tls.sigmask);
d1097 1
a1097 1
    oldmask = _my_tls.sigmask;
d1101 1
a1101 1
  _my_tls.sigmask = newmask;
d1369 1
a1369 1
      set_signal_mask (this_oldmask, _my_tls.sigmask);
@


1.297.2.5
log
@	* cygtls.cc (_cygtls::init_exception_handler): Fix comment.

	* cygtls.cc (_cygtls::handle_threadlist_exception): Make it clear that
	the function never actually returns.
	* exceptions.cc (_cygtls::handle_exceptions): Jump out of function
	rather than returning to avoid meddling by previously installed
	exception handlers.
@
text
@d667 1
a667 15
  /* The OS adds an exception list frame to the stack.  It expects to be
     able to remove this entry after the exception handler returned.
     However, when unwinding to our frame, our frame becomes the uppermost
     frame on the stack (%fs:0 points to frame).  This way, our frame
     is removed from the exception stack and just disappears.  So, we can't
     just return here or things will be screwed up by the helpful function
     in (presumably) ntdll.dll.

     So, instead, we will do the equivalent of a longjmp here and return
     to the caller without visiting any of the helpful code installed prior
     to this function.  This should work ok, since a longjmp() out of here has
     to work if linux signal semantics are to be maintained. */

  SetThreadContext (GetCurrentThread (), in);
  return 0; /* Never actually returns.  This is just to keep gcc happy. */
@


1.297.2.6
log
@	* exceptions.cc (_cygtls::handle_exceptions): When being debugged,
	leave through SetThreadContext, too, to keep exception handler stack
	intact.
@
text
@d634 1
a634 1
	      goto out;
d679 1
a679 1
out:
@


1.297.2.7
log
@2008-03-01  Christopher Faylor  <me+cygwin@@cgf.cx>

	* cygtls.h (_cygtls::handle_threadlist_exception): Eliminate.
	(_cygtls::init_threadlist_exceptions): Ditto.
	* cygtls.cc (_cygtls::handle_threadlist_exception): Eliminate.
	(_cygtls::init_threadlist_exceptions): Ditto.
	(_cygtls::find_tls): Use myfault handling to deal with errors caused by
	nonexistent threads.
	* sigproc.cc (wait_sig): Eliminate call to init_threadlist_exceptions.

2008-03-01  Christopher Faylor  <me+cygwin@@cgf.cx>

	* cygtls.cc (_cygtls::init_exception_handler): Just return.

2008-03-01  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (_cygtls::handle_exceptions): Only call rtl_unwind when
	exiting.  Just return, don't set thread context.
	* gendef (_setjmp): Store %fs:0 in jmp_buf.
	(_sjfault): Ditto.
	(_ljfault): Restore %fs:0 from jmp_buf.
	(_longjmp): Ditto.
@
text
@d586 2
a636 1
	  rtl_unwind (frame, e);
d667 12
d680 2
a681 1
  return 0;
@


1.297.2.8
log
@2008-03-05  Corinna Vinschen  <corinna@@vinschen.de>

	* child_info.h (~child_info_spawn): Check moreinfo->myself_pinfo for
	NULL before closing.
	* spawn.cc (spawn_guts): Don't close moreinfo->myself_pinfo explicitely
	in case of failing CloseProcess.

	* exceptions.cc (_cygtls::handle_exceptions): Replace top level SEH
	installed by Windows with our own handler.

	* fhandler.cc (fhandler_base::open_): Return EISDIR when trying to
	create a directory.
	(fhandler_base::open_9x): Ditto.
	* ntdll.h (STATUS_OBJECT_NAME_INVALID): Define.
	* path.cc (path_conv::check): If input path had a trailing dir
	separator, tack it on to the native path if directory doesn't exist.

2008-03-05  Christopher Faylor  <me+cygwin@@cgf.cx>

	* exceptions.cc (_cygtls::handle_exceptions): Detect when signal is
	masked and treat as if it was not caught.  Revert to a 'return 0'
	rather than using a goto.
@
text
@a457 2
extern exception_list *_except_list asm ("%fs:0");

d589 1
a589 2
  bool masked = !!(me.sigmask & SIGTOMASK (si.si_signo));
  if (masked)
d608 1
a608 7

  /* Temporarily replace windows top level SEH with our own handler.
     We don't want any Windows magic kicking in.  This top level frame
     will be removed automatically after our exception handler returns. */
  _except_list->handler = _cygtls::handle_exceptions;

  if (masked
a609 1
      || !cygwin_finished_initializing
d632 1
a632 1
	      return 0;
d666 1
@


1.296
log
@	* exceptions.cc (_cygtls::handle_exceptions): Call new
	mmap_is_attached_or_noreserve_page function in case of access violation
	and allow application to retry access on noreserve pages.
	* mmap.cc (mmap_is_attached_or_noreserve_page): Changed from
	mmap_is_attached_page.  Handle also noreserve pages now.  Change
	comment accordingly.
	* winsup.h (mmap_is_attached_or_noreserve_page): Declare instead of
	mmap_is_attached_page.
@
text
@d1121 2
a1239 1
  struct sigaction dummy = global_sigs[SIGSTOP];
@


1.295
log
@* dcrt0.cc (dll_crt0_0): Call tty_list::init_session here.
(dll_crt0_1): Reflect renaming from tty_init to tty::init_session.
(do_exit): Reflect moving of tty_terminate into tty_list.
* exceptions.cc (events_init): Move tty_mutex stuff elsewhere.
* fhandler_console.cc (set_console_title): Use lock_ttys class.
* fhandler_termios.cc (fhandler_termios::bg_check): Make debug output more
accurate.
* fhandler_tty.cc (fhandler_tty_slave::open): Reflect move of attach_tty into
tty_list class.  Don't attempt to grab master end of pty if master doesn't
exist.
(fhandler_pty_master::open): Reflect move of allocate_tty into tty_list class.
Use lock_ttys::release to release mutex.  Improve debugging output.
(fhandler_pty_master::setup): Remove if 0'ed block.  Fix argument to
SetNamedPipeHandleState.
* pinfo.cc (_pinfo::set_ctty): Lock ttys before setting sid/pgid.  Improve
debugging.  Add temporary debugging.
* tty.cc (tty_list::init_session): New function.
(tty::init_session): Rename from tty_init.  Reflect move of attach_tty to
tty_list class.
(tty::create_master): Rename from create_tty_master.
(tty_list::attach): Rename from attach_tty.  Reflect renaming of connect_tty to
connect.  Ditto for allocate_tty.
(tty_terminate): Delete.
(tty_list::terminate): Subsume tty_terminate.  Use lock_ttys rather than
manipulating mutex directly.
(tty_list::allocate): Rename from allocate_tty.  Use lock_ttys rather than
manipulating mutex directly.  Don't set sid here since linux apparently doesn't
do this.  Reflect move of create_tty_master into tty.
(lock_ttys::lock_ttys): Define new constructor.
(lock_ttys::release): New function.
* tty.h (tty::exists): Return false immediately if !master_pid.
(tty::set_master_closed): Define new function.
(tty::create_master): Ditto.
(tty::init_session): Ditto.
(tty_list::mutex): New field.
(tty_list::allocate): Define new function.
(tty_list::connect): Ditto.
(tty_list::attach): Ditto.
(tty_list::init_session): Ditto.
(lock_ttys): New class.
(tty_init): Delete declaration.
(tty_terminate): Ditto.
(attach_tty): Ditto.
(create_tty_master): Ditto.
@
text
@d529 6
a534 2
      if (mmap_is_attached_page (e->ExceptionInformation[1]))
	{
d537 2
a538 3
	}
      else
	{
d543 1
@


1.295.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d529 2
a530 6
      switch (mmap_is_attached_or_noreserve_page (e->ExceptionInformation[1]))
        {
	case 2:		/* MAP_NORESERVE page, now commited. */
	  return 0;
	case 1:		/* MAP_NORESERVE page, commit failed, or
			   access to mmap page beyond EOF. */
d533 3
a535 2
	  break;
	default:
a539 1
	  break;
@


1.295.2.2
log
@	* Merge HEAD into cv-branch.
@
text
@a1120 2
  struct sigaction dummy = global_sigs[SIGSTOP];

d1238 1
@


1.295.2.3
log
@	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.
@
text
@d529 1
a529 2
      switch (mmap_is_attached_or_noreserve ((void *)e->ExceptionInformation[1],
					     1))
d531 1
a531 1
	case MMAP_NORESERVE_COMMITED:
d533 2
a534 2
	case MMAP_RAISE_SIGBUS:	/* MAP_NORESERVE page, commit failed, or
				   access to mmap page beyond EOF. */
@


1.294
log
@* cygtls.h (CYGTLS_PADSIZE): Bump up or suffer a regrettable collision with the
call chain.
@
text
@d372 1
a372 1
  ReleaseMutex (tty_mutex);
a1299 2
HANDLE NO_COPY tty_mutex = NULL;

a1302 11
  char *name;
  char mutex_name[CYG_MAX_PATH];
  /* tty_mutex is on while searching for a tty slot. It's necessary
     while finding console window handle */

  if (!(tty_mutex = CreateMutex (&sec_all_nih, FALSE,
				   name = shared_name (mutex_name,
						       "tty_mutex", 0))))
    api_fatal ("can't create title mutex '%s', %E", name);

  ProtectHandle (tty_mutex);
d1383 1
a1383 1
  if (being_debugged ())
@


1.293
log
@white space
@
text
@d348 2
a349 1
      DebugBreak ();
@


1.292
log
@* child_info.h (_CI_SAW_CTRL_C): New enum.
(CURR_CHILD_INFO_MAGIC): Reset.
(saw_ctrl_c): New function.
(set_saw_ctrl_c): Ditto.
* sigproc.cc (child_info::proc_retry): Return EXITCODE_OK if we get
STATUS_CONTROL_C_EXIT and we actually saw a CTRL-C.
* spawn.cc (dwExeced): Delete.
(chExeced): New variable.
(spawn_guts): Set chExeced;
* exceptions.cc (dwExeced): Delete declaration.
(chExeced): Declare.
(ctrl_c_handler): Detect if we're an exec stub process and set a flag, if so.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Add extra
DEBUGGING test.
* pinfo.cc: Fix comment.
@
text
@d534 1
a534 1
        {
d1055 1
a1055 1
         been made above. */
@


1.291
log
@* exceptions.cc (ctrl_c_handler): Only exit TRUE on CTRL_LOGOFF_EVENT when we
have actually handled the event.
@
text
@d34 1
d44 1
a44 1
extern NO_COPY DWORD dwExeced;
d948 5
a952 4
  /* If we are a stub and the new process has a pinfo structure, let it
     handle this signal. */
  if (dwExeced && pinfo (dwExeced))
    return TRUE;
@


1.290
log
@* child_info.h (child_status): Fix typo which made it impossible to set
iscygwin.
(child_info::isstraced): Booleanize.
(child_info::iscygwin): Ditto.
* sigproc.cc (child_info::child_info): Minor cleanup of flag setting.
* spawn.cc (spawn_guts): Only close_all_files when we know the process has
started successfully.
* exceptions.cc (init_console_handler): Fix indentation.
@
text
@d932 12
a943 20
#if 0
	  /* CV, 2005-09-08: The CTRL_LOGOFF_EVENT is only send to services.
	     It's send when *any* user logs off.  Services generally have
	     a modified console handler which allows services to survive
	     also after a user logged out, even if the service has a console
	     window attached to the visible window station of the user
	     ("Interact with desktop").  The below code contradicts this
	     standard behaviour, so for now, we disable it and just return
	     FALSE to get the default behaviour or the one the application's
	     own console handler (if any) requires.
	     In other words: We never send SIGHUP to services and their
	     child processes on a LOGOFF event. */

	  /* Check if the process is actually associated with a visible
	     window station, one which actually represents a visible desktop.
	     If not, the CTRL_LOGOFF_EVENT doesn't concern this process. */
	  if (has_visible_window_station ())
	    sig_send (myself_nowait, SIGHUP);
#endif
	  return TRUE;
@


1.289
log
@* dcrt0.cc (dll_crt0_0): Don't bother with setting init_console_handler here
since it will be set later when we discover if we have a ctty or not.
* exceptions.cc (init_console_handler): Properly remove NULL handler.
@
text
@d107 3
a109 3
   SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
   if (wincap.has_null_console_handler_routine ())
     SetConsoleCtrlHandler (NULL, FALSE);
@


1.288
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Regenerate.
(child_info::retry): Move here from fork subclass.
(child_info::exit_code): New field.
(child_info::retry_count): Max retry count for process start.
(child_info::proc_retry): Declare new function.
(child_info_fork::retry): Move to parent.
(child_info_fork::fork_retry): Ditto.
* dcrt0.cc (child_info::fork_retry): Rename and move.
(child_info_fork::handle_failure): Move.
(dll_crt0_0): Initialize console handler based on whether we have a controlling
tty or not.  Avoid nonsensical check for fork where it can never occur.
* environ.cc (set_proc_retry): Rename from set_fork_retry.  Set retry_count in
child_info.
(parse_thing): Reflect above change.
* exceptions.cc (dummy_ctrl_c_handler): Remove unused variable name.
(ctrl_c_handler): Always return TRUE for the annoying CTRL_LOGOFF_EVENT.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Remove call to
init_console_handler.
* fhandler_tty.cc (fhandler_tty_slave::open): Just call mange_console_count
here and let it decide what to do with initializing console control handling.
* fork.cc (fork_retry): Remove definition.
(frok::parent): Define static errbuf and use in error messages (not thread safe
yet).  Close pi.hThread as soon as possible.  Protect pi.hProcess as soon as
possible.  Don't set retry_count.  That happens automatically in the
constructor now.  Accommodate name change from fork_retry to proc_retry.
* init.cc (dll_entry): Turn off ctrl-c handling early until we know how it is
supposed to be handled.
* pinfo.cc (_pinfo::dup_proc_pipe): Remember original proc pipe value for
failure error message.  Tweak debug message slightly.
* sigproc.cc (child_info::retry_count): Define.
(child_info::child_info): Initialize retry count.
(child_info::sync): Set exit code if process dies before synchronization.
(child_info::proc_retry): Rename from child_info_fork::fork_retry.  Use
previously derived exit code.  Be more defensive about what is classified as an
error exit.
(child_info_fork::handle_failure): Move here from dcrt0.cc.
* spawn.cc (spawn_guts): Maintain error mode when starting new process to avoid
annoying pop ups.  Move deimpersonate call within new loop.  Move envblock
freeing to end.  Loop if process dies prematurely with bad exit code.
* syscalls.cc (init_console_handler): Remove hopefully unneeded call to
init_console_handler.
@
text
@d107 3
a109 2
  while (SetConsoleCtrlHandler (ctrl_c_handler, FALSE))
    continue;
a117 1
  return;
@


1.287
log
@* cygheap.cc (init_cygheap::manage_console_count): Turn console control handler
on/off depending on whether we have allocated a console or not.
* dcrt0.cc (child_info_fork::fork_retry): Add more potential retry statuses.
(dll_crt0_0): Turn on/off console control depending on whether we have a
controlling tty or not.
* exceptions.cc (init_console_handler): Change BOOL to bool.
* fhandler_console.cc (fhandler_console::need_invisible): Cosmetic change.
* winsup.h (init_console_handler): Reflect argument type change.
* wincap.h (supports_setconsolectrlhandler_null): Remove duplicate capability
throughout.
* wincap.cc: Ditto.
@
text
@d97 1
a97 1
dummy_ctrl_c_handler (DWORD dwCtrlType)
d106 1
d117 1
d951 1
a951 1
	  return FALSE;
@


1.286
log
@* child_info.h (child_info_fork::handle_failure): Declare new function.
(child_info_fork::retry): New field.
* dcrt0.cc (__api_fatal_exit_val): Define.
(child_info_fork::handle_failure): Define new function.
(__api_fatal): Exit using __api_fatal_exit_val value.
* environ.cc (set_fork_retry): Set fork_retry based on CYGWIN environment
variable.
(parse_thing): Add "fork_retry" setting.
* fork.cc (fork_retry): Define.
(frok::parent): Reorganize to allow retry of failed child creation if child
signalled that it was ok to do so.
* heap.cc (heap_init): Signal parent via handle_failure when VirtualAlloc
fails.
* pinfo.h (EXITCODE_RETRY): Declare.
* sigproc.cc (child_info::sync): Properly exit with failure condition if called
for fork and didn't see subproc_ready.
* spawn.cc (spawn_guts): Use windows pid as first argument.
* winsup.h: Remove obsolete NEW_MACRO_VARARGS define.
(__api_fatal_exit_val): Declare.
(set_api_fatal_return): Define.
(in_dllentry): Declare.
* exceptions.cc (inside_kernel): Remove unneeded in_dllentry declaration.
@
text
@d103 1
a103 1
init_console_handler (BOOL install_handler)
@


1.285
log
@* exceptions.cc (_cygtls::interrupt_now): Remove "inside cygwin" check since
some cygwin functions are meant to be interrupted.
@
text
@a295 1
  extern bool in_dllentry;
@


1.284
log
@* winsup.h (cygwin_hmodule): Declare.
* exceptions.cc (inside_kernel): Reverse return values to reflect function
name.  Return true if we're in cygwin1.dll or if we're executing in dll_entry.
(_cygtls::interrupt_now): Reflect reversal of inside_kernel return value.
* hookapi.cc (cygwin_hmodule): Remove declaration.
* init.cc (dll_entry): Use in_dllentry global to record that we are executing
in dllentry.
@
text
@d312 1
a312 1
  if (!h || m.State != MEM_COMMIT || h == cygwin_hmodule)
@


1.283
log
@	* exceptions.cc (_cygtls::interrupt_now): Reorder conditional
	to call inside_kernel only if this isn't locked.
@
text
@d296 4
d312 3
a314 1
  if (!h || m.State != MEM_COMMIT)
a315 2
  else if (h == user_data->hmodule)
    res = true;
d317 1
a317 1
    res = true;
d319 3
a321 3
    res = !strncasematch (windows_system_directory, checkdir,
			  windows_system_directory_length);
  sigproc_printf ("pc %p, h %p, interruptible %d", cx->Eip, h, res);
d733 1
a733 1
  if (incyg || spinning || locked () || !inside_kernel (cx))
@


1.282
log
@* exceptions.cc (stackdump): Avoid dumping more than once.
@
text
@d729 1
a729 1
  if (!inside_kernel (cx) || (incyg || spinning || locked ()))
@


1.281
log
@	* cygwin.din: Export sigignore and sigset.
	* exceptions.cc (sigset): New function.
	(sigignore): New function.
	* include/cygwin/signal.h (SIG_HOLD): Define.
	(sigignore): Declare.
	(sigset): Declare.
	* include/cygwin/version.h: Bump API minor number to 154.
@
text
@d265 1
d267 1
a267 1
  if (rlim_core == 0UL)
d273 2
@


1.280
log
@Always zero all elements of siginfo_t throughout.
* cygtls.h (_cygtls::thread_context): Declare new field.
(_cygtls::thread_id): Ditto.
(_cygtls::signal_exit): Move into this class.
(_cygtls::copy_context): Declare new function.
(_cygtls::signal_debugger): Ditto.
* cygtls.cc (_cygtls::init_thread): Fill out thread id field.
* exceptions.cc (exception): Change message when exception info is unknown.
Copy context to thread local storage.
(_cygtls::handle_exceptions): Avoid double test for fault_guarded.  Reflect
move of signal_exit to _cygtls class.
(sigpacket::process): Copy context to thread local storage.
(_cygtls::signal_exit): Move to _cygtls class.  Call signal_debugger to notify
debugger of exiting signal (WIP).  Call stackdump here (WIP).
(_cygtls::copy_context): Define new function.
(_cygtls::signal_debugger): Ditto.
* tlsoffsets.h: Regenerate.
* include/cygwin.h (_fpstate): New internal structure.
(ucontext): Declare new structure (WIP).
(__COPY_CONTEXT_SIZE): New define.
* exceptions.cc (_cygtls::interrupt_setup): Clear "threadkill" field when there
is no sigwaiting thread.
(setup_handler): Move event handling into interrupt_setup.
@
text
@d1024 44
@


1.279
log
@* exceptions.cc (inside_kernel): Fix to return true if we can't get the name of
the DLL for the given memory block since we are not in kernel code.
@
text
@a46 1
static void signal_exit (int) __attribute__ ((noreturn));
d186 1
a186 1
    small_printf ("Exception %d at eip=%08x\r\n", e->ExceptionCode, in->Eip);
d456 1
a456 1
  siginfo_t si;
d581 9
a589 6
  if (!me.fault_guarded ()
      && (!cygwin_finished_initializing
	  || &me == _sig_tls
	  || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_DFL
	  || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_IGN
	  || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_ERR))
d618 1
a618 1
        {
d633 1
a633 1
      signal_exit (0x80 | si.si_signo);	// Flag signal + core dump
a635 3
  if (me.fault_guarded ())
    me.return_from_fault ();

d757 9
a851 6
  if (interrupted && tls->event)
    {
      HANDLE h = tls->event;
      tls->event = NULL;
      SetEvent (h);
    }
d1214 1
a1214 2
      if (!try_to_debug ())
	stackdump (c.Ebp, 1, 1);
d1218 1
a1218 1
  signal_exit (si.si_signo);	/* never returns */
d1224 2
a1225 2
static void
signal_exit (int rc)
d1233 4
d1339 17
@


1.278
log
@add copyright
@
text
@d311 1
a311 1
    res = false;
@


1.277
log
@* exceptions.cc (sigpacket::process): Pass actual reference to signal's
sigaction structure to setup_handler.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
@


1.276
log
@* exceptions.cc (_cygtls::interrupt_setup): Implement SA_RESETHAND.
* include/cygwin/signal.h: Define SA_ONESHOT and SA_NOMASK.
* dcrt0.cc (get_cygwin_startup_info): Remove commented out code.
@
text
@d1085 1
a1085 1
  struct sigaction thissig = global_sigs[si.si_signo];
d1185 2
a1186 1
  thissig = global_sigs[SIGSTOP];
@


1.275
log
@	* exceptions.cc (_cygtls::handle_exceptions): Drop redundant `break'.
@
text
@d747 2
@


1.274
log
@	* exceptions.cc (inside_kernel): Rename from interruptible.
	Accommodate change throughout file.
@
text
@a523 1
	  break;
@


1.273
log
@	* exceptions.cc (interruptible): New function, code stripped from
	_cygtls::interrupt_now.
	(_cygtls::handle_exceptions): Handle STATUS_DATATYPE_MISALIGNMENT as
	SIGBUS error.  Differ between unmapped memory (SEGV_MAPERR) and access
	violation (SEGV_ACCERR) in case of STATUS_ACCESS_VIOLATION.  Write
	kernel log message in case of uncatched STATUS_ACCESS_VIOLATION.
	(_cygtls::interrupt_now): Just call interruptible now instead of
	evaluating interruptibility here.
@
text
@d290 1
a290 1
interruptible (CONTEXT *cx)
d623 1
a623 1
	  if (!interruptible (in))		/* User space */
d728 1
a728 1
  if (!interruptible (cx) || (incyg || spinning || locked ()))
@


1.272
log
@* cygtls.cc (_cygtls::handle_threadlist_exception): Make an error fatal.
* cygtls.h (sockaddr_in): Use header rather than defining our own structure.
* exceptions.cc (_cygtls::interrupt_setup): Use exact contents of sa_mask
rather than assuming tht current sig should be masked, too.
(_cygtls::call_signal_handler): Use more aggressive locking.
* gendef (_sigbe): Wait until later before releasing incyg.
(_sigreturn): Remove more arguments to accommodate quasi-sa_sigaction support.
(_sigdelayed): Push arguments for sa_sigaction.  More work needed here.
* signal.cc (sigaction): Implement SA_NODEFER.
* tlsoffsets.h: Regenerate.

* sigproc.cc (wait_sig): Use default buffer size of Windows 9x complains.
* pinfo.cc (_onreturn::dummy_handle): Remove.
(_onreturn::h): Make this a pointer.
(_onreturn::~_onreturn): Detect whether pointer is NULL rather than value is
NULL.
(_onreturn::_onreturn): Set h to NULL initially.
(_onreturn::no_close_p_handle): Set h to NULL.
(winpids::add): Initialize onreturn with value from p.hProcess immediately.
@
text
@d19 1
d289 31
d438 1
d514 5
d526 9
a534 2
      /*FALLTHRU*/
    case STATUS_DATATYPE_MISALIGNMENT:
d616 16
a725 1
  int res;
a726 24
  MEMORY_BASIC_INFORMATION m;

  memset (&m, 0, sizeof m);
  if (!VirtualQuery ((LPCVOID) cx->Eip, &m, sizeof m))
    sigproc_printf ("couldn't get memory info, pc %p, %E", cx->Eip);

  char *checkdir = (char *) alloca (windows_system_directory_length + 4);
  memset (checkdir, 0, sizeof (checkdir));

# define h ((HMODULE) m.AllocationBase)
  /* Apparently Windows 95 can sometimes return bogus addresses from
     GetThreadContext.  These resolve to a strange allocation base.
     These should *never* be treated as interruptible. */
  if (!h || m.State != MEM_COMMIT)
    res = false;
  else if (h == user_data->hmodule)
    res = true;
  else if (!GetModuleFileName (h, checkdir, windows_system_directory_length + 2))
    res = false;
  else
    res = !strncasematch (windows_system_directory, checkdir,
			  windows_system_directory_length);
  sigproc_printf ("pc %p, h %p, interruptible %d", cx->Eip, h, res);
# undef h
d728 1
a728 1
  if (!res || (incyg || spinning || locked ()))
@


1.271
log
@whitespace cleanup to force snapshot.
@
text
@d53 1
a53 1
static NO_COPY muto mask_sync;
d709 1
a709 1
  deltamask = (siga.sa_mask | SIGTOMASK (sig)) & ~SIG_NONMASKABLE;
d985 1
a985 2
/* Update the signal mask for this process
   and return the old mask.
d1255 1
a1255 1
      lock (); unlock ();	// make sure synchronized
a1262 1
      incyg--;
d1264 2
d1278 1
a1278 1
      incyg++;
@


1.270
log
@* cygtls.h (_cygtls::interrupt_now): Subsume interruptible().
(interruptible): Delete.
(setup_handler): Remove interruptible call and just use return from
interrupt_now.
@
text
@d930 2
a931 2
          && t->ti.c_cc[VINTR] == 3 && t->ti.c_cc[VQUIT] == 3)
        sig = SIGQUIT;
d1272 1
a1272 1
        {
d1274 4
a1277 4
          void (*sigact) (int, siginfo_t *, void *) = (void (*) (int, siginfo_t *, void *)) func;
          /* no ucontext_t information provided yet */
          sigact (thissig, &thissi, NULL);
        }
@


1.269
log
@* winsup.h (child_copy): Change prototype to match new functionality.
* cygheap.cc (cygheap_fixup_in_child): Accommodate new child_copy arguments.
* dcrt0.cc (dll_data_start): Move definition here from fork.
(dll_data_end): Ditto.
(dll_bss_start): Ditto.
(dll_bss_end): Ditto.
(handle_fork): New function.  Called when forked to deal with fork issues and
copy data to this process from the parent.
(dll_crt0_0): Call handle_fork when _PROC_FORK condition.
(dll_crt0): Don't copy user_data when we've forked.  Don't zero first element
of main_environment ever.
(cygwin_dll_init): Ditto.
* fork.cc (child_copy): Rename from fork_copy and change arguments so that each
pair of things to copy gets its own descriptor.
(frok::child): Remove fixup_mmaps_after_fork call here.  Move to handle_fork in
dcrt0.cc.
(frok::parent): Use child_copy rather than fork_copy and accommodate changes in
parameters.
* exceptions.cc (setup_handler): Delay test of whether we're locked until after
GetThreadContext has been called since there are apparently cases where
SuspendThread does not cause an immediate thread suspension.
@
text
@d662 2
a663 1
interruptible (DWORD pc)
d666 1
d670 2
a671 2
  if (!VirtualQuery ((LPCVOID) pc, &m, sizeof m))
    sigproc_printf ("couldn't get memory info, pc %p, %E", pc);
d689 1
a689 1
  sigproc_printf ("pc %p, h %p, interruptible %d", pc, h, res);
d691 12
a702 1
  return res;
d704 1
a727 11
bool
_cygtls::interrupt_now (CONTEXT *ctx, int sig, void *handler,
			struct sigaction& siga)
{
  push ((__stack_t) ctx->Eip);
  interrupt_setup (sig, handler, siga);
  ctx->Eip = pop ();
  SetThreadContext (*this, ctx); /* Restart the thread in a new location */
  return 1;
}

d795 1
a795 2
      else if (interruptible (cx.Eip) &&
	       !(tls->incyg || tls->spinning || tls->locked ()))
@


1.268
log
@	* exceptions.cc (_cygtls::handle_exceptions): In case of a
	STATUS_ACCESS_VIOLATION, check if the page is a mmaped page beyond
	a file's EOF.  Generate SIGBUS instead of SIGSEGV then.
	* mmap.cc (__PROT_ATTACH): New define.
	(__PROT_FILLER): Ditto.
	(fh_anonymous): Rename from fh_paging_file;
	(fh_disk_file): New global static variable.
	(attached): New inline function.
	(filler): Ditto.
	(gen_create_protect): Split off from gen_protect to use the file's
	access mode to create mapping always with maximum allowed protections.
	(gen_protect): Accomodate pages attached beyond EOF.  Use symbolic
	values instead of numerics when possible.  Drop create parameter.
	(gen_access): Use file's access mode instead of protection.
	(CreateMapping9x): Create named mapping names so that different
	creation access modes result in different mappings.
	(CreateMappingNT): Only reserve attached pages, don't commit them.
	(MapViewNT): Ditto.  Set AT_ROUND_TO_PAGE for all non-NULL base
	addresses.
	(mmap_func_t): Define CreateMapping and MapView function pointers
	with additional openflags parameter.
	(class mmap_record): Add openflags member.
	(mmap_record::mmap_record): Add openflags parameter.
	(mmap_record::get_openflags): New accessor.
	(mmap_record::attached): Call global attached function.
	(mmap_record::filler): Call global filler function.
	(mmap_record::gen_create_protect): Call global gen_create_protect
	function.
	(mmap_record::gen_protect): Drop create parameter.
	(mmap_record::alloc_fh): Set fhandler's access flags.
	(list::search_record): Accomodate filler pages.
	(list::set): Use inode number as hash value.
	(map::get_list_by_fd): Check hash value against file's inode number.
	(mmap_is_attached_page): New function to evaluate if a given address
	is on a attached page.  Called from _cygtls::handle_exceptions.
	(mmap_worker): New function to do mapping and bookkeeping in a
	single call.
	(mmap64): Use roundup2 to round length to pagesize alignment.
	Initialize global fhandlers.  Simplify anonymous initialization.
	Add SUSv3 compatible check of file open mode vs. requested protection.
	Try creating new file handles to allow maximum page protection.
	Allow creating attached pages in case of mapping beyond EOF.
	Close new file handle if one has been created.
	(munmap): Align len to pagesize.
	(msync): Rework argument checks. Align len to pagesize.
	(mprotect): Ditto.  Accomodate attached pages.
	(mlock): Use roundup/rounddown macros instead of homemade expressions.
	(munlock): Add page alignment as in mlock.
	(fhandler_dev_zero::munmap): Fix unmapping of non-private mappings.
	(fhandler_dev_zero::fixup_mmap_after_fork): Accomodate filler pages.
	(fixup_mmaps_after_fork): Don't fail if attached pages couldn't be
	created in child.  Avoid superfluous call to VirtualFree.  Check for
	original allocation protection to fix PAGE_WRITECOPY protection.
	* ntdll.h: Revert deletion of AT_ROUND_TO_PAGE define.
	* winsup.h (mmap_is_attached_page): Declare.
@
text
@d789 6
a794 11
      if (tls->incyg || tls->spinning || tls->locked ())
	sigproc_printf ("incyg %d, spinning %d, locked %d\n",
			tls->incyg, tls->spinning, tls->locked ());
      else
	{
	  cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	  if (!GetThreadContext (hth, &cx))
	    system_printf ("couldn't get context of main thread, %E");
	  else if (interruptible (cx.Eip))
	    interrupted = tls->interrupt_now (&cx, sig, handler, siga);
	}
@


1.267
log
@Remove unneeded whitespace.
* cygtls.cc (_cygtls::set_state): Delete.
(_cygtls::reset_exception): Ditto.
(_cygtls::init_thread): Set initialized state directly here.
(_cygtls::push): Remove exception argument.  Don't treat exceptions specially.
* cygtls.h (_cygtls::push): Ditto.
(_cygtls::isinitialized): Don't treat exceptions specially.
(_cygtls::reset_exception): Delete.
(_cygtls::set_state): Ditto.
(_cygtls::handle_exceptions): Don't push ebp on the stack prior to calling
sig_send.  Just set incyg instead.
(_cygtls::interrupt_setup): Accommodate _cygtls::push argument change.
(_cygtls::interrupt_now): Ditto.
(setup_handler): Don't treat exceptions specially.
* gendef (longjmp): Always zero incyg flag.
@
text
@d482 7
@


1.266
log
@* include/exceptions.h (exception_list): Revert previous change.  Windows
doesn't care.
(exception_handler): Use real exception_list parameter type rather than void *
* tlsoffsets.h: Regenerate.
* cygtls.h (_cygtls::handle_exceptions): Use real exception_list parameter type
rather than void *.
(handle_threadlist_exception): Ditto.
(init_exception_handler): Ditto.
* cygtls.cc (_cygtls::handle_threadlist_exception ): Ditto.
(_cygtls::init_exception_handler): Add kludge to terminate linked list with a
loop, which seems to solve problem of RtlUnwind causing problems
* exceptions.cc (rtl_unwind): Use real exception_list parameter type rather
than void *.
(_cygtls::handle_exceptions): Ditto.
@
text
@d572 1
a572 1
  me.push ((__stack_t) ebp, true);
d574 1
d687 1
a687 1
  push ((__stack_t) sigdelayed, false);
d711 1
a711 1
  push ((__stack_t) ctx->Eip, false);
d744 1
a744 1
      if (tls->incyg || tls->in_exception ())
d746 2
a747 3
	  sigproc_printf ("controlled interrupt. incyg %d, exception %d, stackptr %p, stack %p, stackptr[-1] %p",
			  tls->incyg, tls->in_exception (), tls->stackptr, tls->stack, tls->stackptr[-1]);
	  tls->reset_exception ();
d782 3
a784 3
      if (tls->incyg || tls->in_exception () || tls->spinning || tls->locked ())
	sigproc_printf ("incyg %d, in_exception %d, spinning %d, locked %d\n",
			tls->incyg, tls->in_exception (), tls->spinning, tls->locked ());
d1055 1
a1055 1
  else 
@


1.265
log
@* cygtls.h (_cygtls::el): New field.
(_cygtls::handle_exceptions): New function declaration.
(_cygtls::handle_threadlist_exception): Ditto.
(_cygtls::init_exception_handler): Ditto.
(_cygtls::init_threadlist_exceptions): Remove arg from declaration.
* cygtls.cc (_cygtls::call2): Don't initialize exceptions here.
(_cygtls::init_thread): Do it here instead and use member function.
(_cygtls::handle_threadlist_exception): Move into _cygtls class.
(_cygtls::init_exception_handler): Ditto.  Rely on existence of 'el' memmber in
_cygtls.
(_cygtls::init_threadlist_exceptions): Ditto.
* dcrt0.cc (dll_crt0_1): Remove exception_list definition and setting since it
now commonly resides in the tls.
* exceptions.cc (init_exception_handler): Move to cygtls.cc.
(init_exceptions): Ditto.
(rtl_unwind): New, safe wrapper function for RtlUnwind.
(_cygtls::handle_exceptions): Move to _cygtls.  Call rtl_unwind to unwind
frames and eliminate copying of structures.  Put address of failing instruction
in si_addr, not the address on the stack.  Return 0 to indicate that we've
handled this exception.
* external.cc (cygwin_internal): Make CW_INIT_EXCEPTIONS a no-op.
* sigproc.cc (wait_sig): Accommodate argument change to
_cygtls::init_threadlist_exceptions.
* tlsoffsets.h: Regenerate.
* include/exceptions.h (exception_list): Add more stuff to the exception list.
Apparently windows needs this?
(init_exceptions): Remove bogus declaration.
* include/cygwin/signal.h (SI_USER): Redefine as zero as per SUSv3.
* thread.cc (pthread_kill): Set si_pid and si_uid.
* timer.cc (timer_thread): Set si_code to SI_TIMER.
@
text
@d384 1
a384 1
static void __stdcall rtl_unwind (void *, PEXCEPTION_RECORD) __attribute__ ((noinline, regparm (3)));
d386 1
a386 1
rtl_unwind (void *frame, PEXCEPTION_RECORD e)
d407 1
a407 1
_cygtls::handle_exceptions (EXCEPTION_RECORD *e, void *frame, CONTEXT *in, void *)
d512 1
@


1.264
log
@* exceptions.cc (handle_exceptions): Translate a guard page exception to a
"SIGBUS".
@
text
@a38 1
static int handle_exceptions (EXCEPTION_RECORD *, void *, CONTEXT *, void *);
a95 22
// Set up the exception handler for the current thread.  The PowerPC & Mips
// use compiler generated tables to set up the exception handlers for each
// region of code, and the kernel walks the call list until it finds a region
// of code that handles exceptions.  The x86 on the other hand uses segment
// register fs, offset 0 to point to the current exception handler.

extern exception_list *_except_list asm ("%fs:0");

void
init_exception_handler (exception_list *el, exception_handler *eh)
{
  el->handler = eh;
  el->prev = _except_list;
  _except_list = el;
}

extern "C" void
init_exceptions (exception_list *el)
{
  init_exception_handler (el, handle_exceptions);
}

d383 21
d406 2
a407 3
extern "C" DWORD __stdcall RtlUnwind (void *, void *, void *, DWORD);
static int
handle_exceptions (EXCEPTION_RECORD *e0, void *frame, CONTEXT *in0, void *)
d421 1
a421 1
  if (exit_already)
a423 3
  EXCEPTION_RECORD e = *e0;
  CONTEXT in = *in0;

d427 1
a427 1
  switch (e.ExceptionCode)
d511 3
a513 2
  debug_printf ("In cygwin_except_handler exc %p at %p sp %p", e.ExceptionCode, in.Eip, in.Esp);
  debug_printf ("In cygwin_except_handler sig %d at %p", si.si_signo, in.Eip);
d522 1
a522 1
  DWORD *ebp = (DWORD *)in.Esp;
d524 1
a524 1
    if (*ebp == in.SegCs && ebp[-1] == in.Eip)
d532 1
a532 1
	  || &_my_tls == _sig_tls
d540 1
a540 1
	  if (status_info[i].code == e.ExceptionCode)
d559 1
a559 1
	  exception (&e, &in);
a565 4
  extern DWORD ret_here[];
  RtlUnwind (frame, ret_here, e0, 0);
  __asm__ volatile (".equ _ret_here,.");

d569 1
a569 1
  si.si_addr = ebp;
d573 2
a574 1
  return 1;
@


1.263
log
@* heap.cc: Remove spurious getpagesize declaration.
* exceptions.cc (ctrl_c_handler): Distinguish CTRL-BREAK from CTRL-C in some
cases.
@
text
@d482 5
a489 1
    case STATUS_GUARD_PAGE_VIOLATION:
@


1.262
log
@* include/sys/elf64.h: Fix types to reflect linux usage.
@
text
@d926 5
d932 1
a932 1
      killsys (-myself->pid, SIGINT);
@


1.261
log
@* include/sys/cygwin.h: Define CYGWIN_SIGNAL_STRING.
* exceptins.cc (sigpacket::process): Send a _CYGWIN_SIGNAL_STRING to gdb if the
process is being debugged.  A WIP.
@
text
@d1098 1
d1105 1
@


1.260
log
@* exceptions.cc (signal_exit): Eliminate setting of main thread priority since
process lock should make that unnecessary.
* fork.cc (stack_base): Eliminate.
(frok::parent): Subsume stack_base and just set stack stuff here.  Report on
priority class in debugging output.
* spawn.cc (spawn_guts): Report on priority class in debugging output.
@
text
@d1098 6
a1103 5
#if 0
  char sigmsg[24];
  __small_sprintf (sigmsg, "cygwin: signal %d\n", si.si_signo);
  OutputDebugString (sigmsg);
#endif
@


1.259
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d1190 2
a1191 4
  /* We'd like to stop the main thread from executing but when we do that it
     causes random, inexplicable hangs.  So, instead, we set up the priority
     of this thread really high so that it should do its thing and then exit. */
  SetThreadPriority (hMainThread, THREAD_PRIORITY_IDLE);
@


1.258
log
@* cygheap.h (class process_lock): New class.
* dtable.h (class dtable): Add class process_lock as a friend.
* dcrt0.cc (get_exit_lock): Delete.
(do_exit): Use process_lock class instead of get_exit_lock.
* exceptions.cc (signal_exit): Ditto.
* pinfo.cc (pinfo::exit): Ditto.
(_pinfo::commune_process): Set process lock around this whole function.
(_pinfo::commune_request): Use process_lock rather than myself.lock.
* pinfo.h (pinfo::_lock): Delete.
(pinfo::initialize_lock): Delete.
(pinfo::lock): Delete.
(pinfo::unlock): Delete.
* winsup.h (get_exit_lock): Delete declaration.
@
text
@d1186 1
a1186 1
  process_lock until_exit (true);
@


1.257
log
@* dcrt0.cc (get_exit_lock): Use myself.lock rather than exit_lock.
* exceptions.cc (exit_lock): Delete.
(events_init): Don't init exit_lock.
* (_pinfo::commune_process): Add per-PICOM debugging.
* sigproc.cc (talktome): Add some temporary debugging statements.
* fhandler_proc.cc (format_proc_cpuinfo): Cosmetic change.
(format_proc_partitions): Ditto.
* syscalls.cc (locked_append): Ditto.
@
text
@d29 4
d1186 1
a1186 1
  get_exit_lock ();
@


1.256
log
@* dcrt0.cc (do_exit): Don't set ES_SET_MUTO here.  Call get_exit_lock()
instead.
(get_exit_lock): New function.  Grabs the lock and sets initial exit_state.
* exceptions.cc (try_to_debug): Use low_priority_sleep.
(sigpacket::process): Avoid handler if this is an exec stub.
(signal_exit): Use get_exit_lock rather than manipulating the exit_lock
critical section directly.
* pinfo.cc (pinfo::exit): Ditto.
* winsup.h (get_exit_lock): Declare.
(exit_lock): Delete declaration.
@
text
@a1169 2
CRITICAL_SECTION NO_COPY exit_lock;

a1229 1
  InitializeCriticalSection (&exit_lock);
@


1.255
log
@* exceptions.cc (_cygtls::call_signal_handler): Minor cleanup.
@
text
@d391 1
a391 1
	Sleep (0);
d1044 7
a1050 1
  void *handler = (void *) thissig.sa_handler;
d1184 1
a1184 1
  EnterCriticalSection (&exit_lock);
@


1.254
log
@* exceptions.cc (handle_exceptions): Just si_code to SI_KERNEL first and let it
be overridden.
* exceptions.cc (_cygtls::call_signal_handler): Call signal handler with extra
siginfo_t * and void * parameters when SA_SIGINFO flag is set.
* signal.cc (signal): Clear SA_SIGINFO flag.
(sigqueue): Fix incorrect setting of si_code.
* sigproc.cc (signal_fixup_after_exec): Clear SA_SIGINFO flag when setting
handler to SIG_DFL.
@
text
@a1244 1
      void (*sigfunc) (int) = func;
d1252 5
a1256 2
      if (this_sa_flags & SA_SIGINFO == 0)
	sigfunc (thissig);
@


1.253
log
@* exceptions.cc (handle_exceptions): Properly fill out si_code.
@
text
@d427 1
a475 1
      si.si_code = 0;
a491 1
      si.si_code = 0;
a570 2
  if (!si_code)
    si.si_code = SI_KERNEL;
d1253 9
a1261 1
      sigfunc (thissig);
@


1.252
log
@Semi-reversion of always-exit-from-sigthread change of 2005-09-15.
* exceptions.cc (sigpacket::process): Eliminate return after call to reinstated
noreturn function.
(signal_exit): Allow function to exit when a captive process has been
terminated.
* pinfo.cc (pinfo::exit): Enter exit_lock here.  Once again exit here under
control of exit_lock.
* sigproc.cc (sig_send): Don't wait for completion if process is exiting.
Remove special __SIGEXIT accommodations.
(wait_sig): Just exit the thread when a __SIGEXIT has been detected.  Don't
exit the process.
@
text
@d435 1
a435 1
      si.si_sigval.sival_int = FPE_FLTSUB;
d439 1
a439 1
      si.si_sigval.sival_int = FPE_FLTRES;
d443 1
a443 1
      si.si_sigval.sival_int = FPE_FLTOVF;
d447 1
a447 1
      si.si_sigval.sival_int = FPE_FLTUND;
d451 1
a451 1
      si.si_sigval.sival_int = FPE_INTDIV;
d455 1
a455 1
      si.si_sigval.sival_int = FPE_INTOVF;
d460 1
a460 1
      si.si_sigval.sival_int = ILL_ILLOPC;
d465 1
a465 1
      si.si_sigval.sival_int = ILL_PRVOPC;
d470 1
a470 1
      si.si_sigval.sival_int = ILL_ILLADR;
d475 1
a475 1
      si.si_sigval.sival_int = 0;
d487 1
a487 1
      si.si_sigval.sival_int = SEGV_MAPERR;
d492 1
a492 1
      si.si_sigval.sival_int = 0;
d572 2
a573 1
  si.si_code = SI_KERNEL;
@


1.251
log
@* cygheap.cc (cygheap_fixup_in_child): It's not just for exec.
* cygtls.h (struct _cygtls::thread_handle): New field.
* dcrt0.cc (exit_lock): Remove declaration.
* winsup.h (exit_lock): Add declaration.
* exceptions.cc (sigpacket::process): Properly return after signal_exit.
* pinfo.cc (pinfo::exit): Only exit the process if _my_tls.thread_handle has
not been filled out -- which should be an impossible event.
* sigproc.cc (sigproc_terminate): Fillout _my_tls.thread_handle to provide
something for wait_sig to wait for.  Use the siginfo_t version of sig_send and
fill out the tls argument with _my_tls.
(wait_sig): Wait for the thread specified in pack.tls or (for now) complain
bitterly if it doesn't exit.
@
text
@d43 1
a43 1
static void signal_exit (int);
d1163 1
a1163 3
  signal_exit (si.si_signo);
  /* May not return */
  return rc;
a1177 1
      return;
d1181 1
a1181 1
  if (exit_already++)
@


1.250
log
@* dcrt0.cc (do_exit): Only call sigproc_terminate from one location --
pinfo::exit.
* pinfo.cc (pinfo::exit): Move sigproc_terminate later so that signals can be
processed while waiting for hExeced child.
(pinfo::maybe_set_exit_code_from_windows): Set exit code from sigExeced if it
is non-zero.  Set exit_state to ES_EXEC_EXIT prior to waiting for captive
process exit code.
* exceptions.cc (sigExeced): New global variable.
(signal_exit): Remove noreturn attribute from declaration.
(signal_exit): Just terminate captive process and return if hExeced on the
theory that the exit will be subsequently handled in the main thread.
* sigproc.cc (sigproc_terminate): Eliminate test for ES_SIGPROCTERMINATE and
use ES_FINAL instead.
(sig_send): Use no_signals_available instead of duplicate test.
* winsup.h (ES_EXEC_EXIT): New enum.
(ES_SIGPROCTERMINATE): Delete.
@
text
@d1165 1
@


1.249
log
@* exceptions.cc (sigtid): Remove declaration.
(handle_exceptions): Use _sig_tls rather than sigtid to determine if this is
the signal thread.
(set_signal_mask): Ditto for conditionalized CGF code.
* pinfo.cc (pinfo::exit): Exit the thread if we forcefully terminated the main
thread
* sigproc.cc (sigtid): Delete.
(_sig_tls): Define.
(sig_clear): Use _sig_tls rather than sigtid to determine if this is the signal
thread.
(sig_dispatch_pending): Ditto.
(wait_sig): Set _sig_tls here.
* dcrt0.cc (do_exit): Move sigproc_terminate call later since signal handling
was still needed for subsequent stuff.  Call sigproc_terminate with new
exit_state value.
* pinfo.cc (pinfo::exit): Call sigproc_terminate with new exit_state value.
* sigproc.cc (proc_terminate): Remove unnecessary (void) parameter.
(sigproc_terminate): Ditto.  Add new argument to accept exit state to be set.
(wait_sig): Reorganize __SIGEXIT handling.  Add more debugging output.
* winsup.h (sigproc_terminate): Declare with new exit_state argument.
(exit_states): Reorganize to reflect new exit ordering of sigproc_terminate.
@
text
@d39 2
a40 1
extern DWORD dwExeced;
d43 1
a43 1
static void signal_exit (int) __attribute__ ((noreturn));
d1164 1
a1164 1
  /* Never returns */
d1175 7
a1194 6
  if (hExeced)
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (hExeced, rc);
    }

@


1.248
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@a38 2
extern DWORD sigtid;

d529 1
a529 1
	  || GetCurrentThreadId () == sigtid
d1003 1
a1003 1
  if (GetCurrentThreadId () == sigtid)
@


1.247
log
@	* exceptions.cc (ctrl_c_handler): Disable any special CTRL_LOGOFF_EVENT
	handling and add longish comment about the reasons.
@
text
@a651 1
  return;
a1018 1
  return;
@


1.246
log
@* dcrt0.cc (initial_env): Don't attempt stracing if dynamically loaded.
(dll_crt0_0): Move console initialization earlier.
* init.cc (dll_entry): Move console initialization here.
* exceptions.cc (init_console_handler): Fully remove any old console handler.
* spawn.cc (spawn_guts): Don't fill out windows argv if we've deduced that this
is a cygwin-using program.
(av::fixup): Always check executables to see if they are using cygwin1.dll.
Don't consider .com files to be scripts.
* hookapi.cc (rvadelta): New function.
(PEHeaderFromHModule): Simplify slightly.
(hook_or_detect_cygwin): Use passed in name argument for "HMODULE" rather than
incorrectly reading current program.  Calculate delta needed to read image data
and file names if this isn't a real "HMODULE".
@
text
@d884 13
d902 1
@


1.245
log
@Grr.  REVERT erroneous checkin.  AGAIN.
@
text
@d126 2
a127 1
  SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
d595 5
a599 1
    Sleep (INFINITE);
d853 5
@


1.244
log
@* Makefile.in (CXXFLAGS): Use 'override' to correctly set flags to generate
dependencies when invoked from top-level make.
@
text
@d126 1
a126 2
  while (SetConsoleCtrlHandler (ctrl_c_handler, FALSE))
    continue;
a835 1
console_printf ("%u OUCH!\n", GetCurrentProcessId ());
a847 5
#if 0
  if (type == CTRL_C_EVENT || type == CTRL_BREAK_EVENT)
    proc_subproc (PROC_KILLFORKED, 0);
#endif

@


1.243
log
@revert inexplicable previous checkin
@
text
@d126 2
a127 1
  SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
d837 1
d850 5
@


1.242
log
@bad_addresses
@
text
@d126 1
a126 2
  while (SetConsoleCtrlHandler (ctrl_c_handler, FALSE))
    continue;
a835 1
console_printf ("%u OUCH!\n", GetCurrentProcessId ());
a847 5
#if 0
  if (type == CTRL_C_EVENT || type == CTRL_BREAK_EVENT)
    proc_subproc (PROC_KILLFORKED, 0);
#endif

@


1.241
log
@* exceptions.cc (set_process_mask_delta): Conditionalize debugging output.
* sigproc.cc (proc_subproc): Make strace output a little more verbose.
@
text
@d126 2
a127 1
  SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
d837 1
d850 5
@


1.240
log
@* cygtls.h (__ljfault): Declare.
(_cygtls::return_from_fault): Use __ljfault.
* exceptions.cc (set_signal_mask): Revert previous checkin.
* gendef (__sjfault): Split out into a separate function which doesn't bother
with any special signal locking.  routines.
(_ljfault): Return from a __sjfault without bothering with signals.
@
text
@d981 1
d984 1
@


1.239
log
@* cygwin.din: Correct readdir_r typo.
@
text
@d981 2
a988 1
  mask_sync.release ();
d993 1
@


1.238
log
@* exceptions.cc (handle_sigsuspend): Just sleep forever if called from non-main
thread.
(sigpacket:process): Simplify logic which determines when and how a signal is
masked.  Don't trigger sigwait if there is a signal handler.
* sigproc.cc (wait_sig): Update comment.  Try to process a signal which is in
the queue if it isn't queued for the target thread (this is still not right).
@
text
@d987 1
a991 1
  mask_sync.release ();
@


1.237
log
@* sigproc.h (set_signal_mask): Remove default on second parameter and make pass
by reference.
* signal.cc (abort): Accommodate change to set_signal_mask.
* select.cc (pselect): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
(ctrl_c_handler): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Return ENMFILE if
__handle is not set.  Set __handle to NULL when out of files.
(fhandler_disk_file::rewinddir): Don't close handle if it's NULL.
(fhandler_disk_file::closedir): Ditto.
@
text
@d593 2
d916 1
d1020 3
d1025 1
a1025 1
  if ( si.si_signo == SIGSTOP)
a1032 2
  bool masked;
  bool special_case;
d1034 6
a1039 9
  insigwait_mask = masked = false;
  if (special_case = (/*VFORKPID || */ISSTATE (myself, PID_STOPPED)))
    /* nothing to do */;
  else if (tls && sigismember (&tls->sigwait_mask, si.si_signo))
    insigwait_mask = true;
  else if (!tls && (tls = _cygtls::find_tls (si.si_signo)))
    insigwait_mask = true;
  else if (!(masked = sigismember (mask, si.si_signo)) && tls)
    masked  = sigismember (&tls->sigmask, si.si_signo);
d1044 7
d1054 1
a1054 1
  if (special_case || masked)
a1060 3
  void *handler;
  handler = (void *) thissig.sa_handler;

@


1.236
log
@* child_info.h (child_info::sync): Pass pid and HANDLE rather than using pinfo.
(child_info::child_info): Accept an argument controlling whether to create
proc_subproc.
(child_info_spawn::child_info_spawn): Ditto.
* sigproc.cc (child_info::child_info): Ditto.
(child_info_spawn::child_info_spawn): Ditto.
(child_info::sync): Use passed in pid and HANDLE.
* fork.cc (fork_parent): Reflect additional arguments required for
child_info::sync.
* hookapi.cc (hook_or_detect_cygwin): Rename.  Change so that NULL 'fn'
argument just returns "true", indicating that program uses cygwin1.dll.
* spawn.cc (av::win16_exe): New element.
* spawn.cc (av::iscygwin): New element.
(av::fixup): New function.
(spawn_guts): Protect against SEGV.  Use fixup function to detect when it is
safe to wait for a spawned (as opposed to an execed) program.  Reflect changes
in child_info::sync arguments.
* external.cc (cygwin_internal): Reflect function renaming to
hook_or_detect_cygwin.
* cygheap.cc (cygheap_fixup_in_child): Close handle after debug fixup has been
done to prevent false positives in handle collision.
* exceptions.cc (try_to_debug): Notify debugger if already being debugged.
@
text
@d595 1
a595 1
  set_signal_mask (tempmask, oldmask);
d913 1
a913 1
  set_signal_mask (newmask);
d929 1
a929 1
  set_signal_mask (mask);
d947 1
a947 1
  set_signal_mask (mask);
d976 1
a976 1
set_signal_mask (sigset_t newmask, sigset_t oldmask)
d983 1
a983 1
  myself->setsigmask (newmask);	// Set a new mask
d1228 1
a1228 1
      set_signal_mask (this_oldmask);
@


1.235
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d323 1
a323 1
  if (*debugger_command == '\0' || being_debugged ())
d325 5
@


1.234
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d126 1
a126 1
  (void) SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
d770 1
a770 1
	  (void) ResumeThread (hth);
d1147 2
a1148 2
  (void) SetThreadPriority (hMainThread, THREAD_PRIORITY_IDLE);
  (void) SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL);
d1160 1
a1160 1
  (void) SetEvent (signal_arrived);
d1182 1
a1182 1
  (void) GetSystemDirectory (windows_system_directory, sizeof (windows_system_directory) - 2);
d1215 1
a1215 1
      (void) pop ();
d1235 1
a1235 1
  (void) ResetEvent (signal_arrived);
@


1.233
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@a40 1
extern HANDLE hExeced;
d1167 1
a1167 1
events_init (void)
d1198 1
a1198 1
events_terminate (void)
@


1.232
log
@* cygerrno.h: Make multi-inclusion safe.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Deal with EINTR.
* dcrt0.cc (dll_crt0_0): Accommodate init_console_handler argument change.
* winsup.h: Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* exceptions.cc (init_console_handler): Ditto.  Ignore console events if we're
not attached to a terminal.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* wincap.cc: Implement has_null_console_handler_routine throughout.
* wincap.h: Ditto.
@
text
@d406 1
d524 6
a529 5
  if (!cygwin_finished_initializing
      || GetCurrentThreadId () == sigtid
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_DFL
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_IGN
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_ERR)
d564 3
d570 2
a571 2
  _my_tls.push ((__stack_t) ebp, true);
  sig_send (NULL, si, &_my_tls);	// Signal myself
@


1.231
log
@Change pthread::cancelable_wait to just cancelable_wait, throughout.
* thread.h (cw_sig_wait): New enum.
(fast_mutex::lock): Use cancelable_wait with resumable signal.
(cancelable_wait): Change fourth argument to cw_sig_wait enum.
* thread.cc (cancelable_wait): Ditto.  Loop on signal detection if fourth
argument == cw_sig_resume.
@
text
@d117 6
d124 1
a124 1
init_console_handler ()
d126 1
d128 7
a134 1
  if (!SetConsoleCtrlHandler (ctrl_c_handler, TRUE))
@


1.230
log
@* cygtls.h (_local_storage::unknown_thread_name): New buffer.
* tlsoffsets.h: Regenerate.
* cygthread.cc (cygthread::name): Use new thread-local buffer.
* exceptions.cc (handle_exceptions): Avoid unnecessary initialization of static
variables to zero.
* fork.cc (slow_pid_reuse) Ditto.
@
text
@d577 1
a577 1
  pthread::cancelable_wait (signal_arrived, INFINITE);
@


1.229
log
@* dcrt0.cc (do_global_dtors): Run DLL dtors.
(__main): Don't rely on atexit to run dtors.
(do_exit): Specifically call do_global_dtors here.
(cygwin_exit): Ditto.
* dll_init.cc (dll_global_dtors): Make global.  Only run dtors once.
(dll_list::init): Just set flag that dtors should be run.  Don't rely on
atexit.
* dll_init.h (dll_global_dtors): Declare.
* exceptions.cc (sigrelse): Define.
* path.h (is_fs_device): New method.
(is_lnk_special): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::link): Use "is_lnk_special" rather
than "is_lnk_symlink".
* syscalls.cc (rename): Ditto.
* hookapi.cc (ld_preload): Use colon as a separator rather than space.
@
text
@d391 2
a392 2
  static bool NO_COPY debugging = false;
  static int NO_COPY recursed = 0;
@


1.228
log
@* sync.h (muto::operator int): New operator.
(locker): Remove unused class.
(new_muto): Delete.
(new_muto1): Ditto.
(new_muto_name): Ditto.
* cygheap.cc (cygheap_setup_for_child): Reflect use of static storage for muto
rather than pointer.
(_csbrk): Ditto.
(_cmalloc): Ditto.
(_cmalloc): Ditto.
(_cfree): Ditto.
* cygheap.h (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_drive): Ditto.
* cygmalloc.h (__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* cygtls.cc (sentry::lock): Ditto.
(sentry::sentry): Ditto.
(~sentry): Ditto.
(_cygtls::init): Ditto.
* dcrt0.cc: Ditto.
(cygwin_atexit): Ditto.
(cygwin_exit): Ditto.
* debug.cc (lock_debug::locker): Ditto.
(lock_debug::lock_debug): Ditto.
(lock_debug::unlock): Ditto.
(debug_init): Ditto.
* dtable.cc (dtable::init_lock): Ditto.
* dtable.h (dtable::lock_cs): Ditto.
(dtable::lock): Ditto.
(dtable::unlock): Ditto.
* exceptions.cc (mask_sync): Ditto.
(sighold): Ditto.
(set_process_mask_delta): Ditto.
(set_signal_mask): Ditto.
(events_init): Ditto.
* grp.cc (pwdgrp::pwdgrp): Ditto.
* malloc_wrapper.cc (mallock): Ditto.
(malloc_init): Ditto.
* path.cc (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::init): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* pwdgrp.h (pwdgrp::pglock): Ditto.
(pwdgrp::refresh): Ditto.
* sigproc.cc (sync_proc_subproc): Ditto.
(get_proc_lock): Ditto.
(proc_subproc): Ditto.
(_cygtls::remove_wq): Ditto.
(proc_terminate): Ditto.
(sigproc_init): Ditto.
* timer.cc (lock_timer_tracker::protect): Ditto.
(lock_timer_tracker::lock_timer_tracker): Ditto.
(lock_timer_tracker::~lock_timer_tracker): Ditto.
* wininfo.cc (wininfo::_lock;): Ditto.
(wininfo::winthread): Ditto.
(operator HWND): Ditto.
(wininfo::lock): Ditto.
(wininfo::release): Ditto.
* wininfo.h (wininfo::_lock;): Ditto.
@
text
@d912 18
@


1.227
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@d52 1
a52 1
static NO_COPY muto *mask_sync = NULL;
d904 1
a904 1
  mask_sync->acquire (INFINITE);
d908 1
a908 1
  mask_sync->release ();
d918 1
a918 1
  mask_sync->acquire (INFINITE);
d929 1
a929 1
  mask_sync->release ();
d938 1
a938 1
  mask_sync->acquire (INFINITE);
d948 1
a948 1
  mask_sync->release ();
d1145 1
a1145 1
  new_muto (mask_sync);
@


1.226
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@d134 1
a134 1
  char pgm[CYG_MAX_PATH + 1];
@


1.225
log
@copyright
@
text
@d13 2
d787 21
@


1.224
log
@* exceptions.cc: Make windows_system_directory non-static.
* pinfo.cc (pinfo::exit): Change innocuous cd'ed location to one that is more
likely to exist.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.223
log
@* pinfo.h (_pinfo::set_exit_state): Declare new function.
(pinfo::exit): Move here from _pinfo::exit.
* sigproc.cc (child_info::sync): Use new function to set exitcode and
process_state.
* pinfo.cc (_pinfo::exit): Ditto.
(proc_waiter): Ditto.
(_pinfo::set_exit_state): Define new function.
(_pinfo::dup_proc_pipe): Close handle when there is no parent process around to
care about the exit value.
* dcrt0.cc (dll_crt0_0): Move subproc_ready synchronization later to make sure
that myself is still mapped in parent.
(do_exit): Reflect movement to pinfo::exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* errno.cc (errmap): Map PROC_NOT_FOUND.
* init.cc (dll_entry): Release myself before exiting.
* sigproc.cc (proc_can_be_signalled): Set errno appropriately.
(sig_send): Ditto.  Also remove ill-advised test for !myself->sendsig since
this is an indication of a process which is still initializating -- it is not
an error.
(child_info::sync): Don't set exitcode here.  Assume that will happen in
proc_waiter, if necessary.
* spawn.cc (spawn_guts): Delay "wait_for_myself" logic until later.  Don't wait
at all if the process has already exited.  Reflect movement to pinfo::exit.
@
text
@d43 1
a43 1
static char windows_system_directory[1024];
@


1.222
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
(child_info::parent_wr_proc_pipe): Eliminate.
* pinfo.h (_pinfo::alert_parent): Move here from pinfo class.
(_pinfo::dup_proc_pipe): New method.
(_pinfo::sync_proc_pipe): Ditto.
* exceptions.cc (sig_handle_tty_stop): Reflect move of alert_parent.
* init.cc (dll_entry): Exit with status one if main process called ExitProcess.
* pinfo.cc (set_myself): Remove handling of parent_wr_proc_pipe.
(_pinfo::exit): Reflect move of alert_parent.  Set procinfo to NULL to flag
that we are exiting normally.  Always use exitcode when exiting
(although this could be a little racy).
(pinfo::init): Set default exit to SIGTERM.  This will be the exit code
reported if process is terminated.
(_pinfo::dup_proc_pipe): New function.
(pinfo::wait): Duplicate wr_proc_pipe to the right place.  Use dup_proc_pipe to
move the pipe to the child.
(_pinfo::sync_proc_pipe): New function.
(_pinfo::alert_parent): Move to _pinfo.  Make sure that wr_proc_pipe is ours
before using it.
* sigproc.cc (child_info::child_info): Remove handling of parent_wr_proc_pipe.
* spawn.cc (spawn_guts): Pass our wr_proc_pipe to the child when execing.
Ensure that exit code of cygwin process started from windows is correctly set.
@
text
@d1083 1
a1083 1
    myself->exit (rc);
@


1.221
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d603 1
a603 1
  myself.alert_parent (sig);
d613 1
a613 1
      myself.alert_parent (SIGCONT);
@


1.220
log
@* exceptions.cc (sig_handle_tty_stop): Set flag earlier.
@
text
@a22 2
#define NEED_VFORK
#include "perthread.h"
a25 1
#include "cygthread.h"
d159 1
a159 1
	  if (!myself->ppid_handle)
d514 1
a514 1
      if (!myself->ppid_handle)
d596 1
a596 1
  if (!myself->ppid_handle)
d603 2
a604 18
  /* See if we have a living parent.  If so, send it a special signal.
     It will figure out exactly which pid has stopped by scanning
     its list of subprocesses.  */
  if (my_parent_is_alive ())
    {
      pinfo parent (myself->ppid);
      if (NOTSTATE (parent, PID_NOCLDSTOP))
	{
	  siginfo_t si;
	  si.si_signo = SIGCHLD;
	  si.si_code = SI_KERNEL;
	  si.si_sigval.sival_int = CLD_STOPPED;
	  si.si_errno = si.si_pid = si.si_uid = si.si_errno = 0;
	  sig_send (parent, si);
	}
    }
  sigproc_printf ("process %d stopped by signal %d, myself->ppid_handle %p",
		  myself->pid, sig, myself->ppid_handle);
d613 1
d792 1
a792 1
      if (myself->ppid_handle)	/* Was this process created by a cygwin process? */
d967 1
a967 1
  if (special_case = (VFORKPID || ISSTATE (myself, PID_STOPPED)))
a1081 1
  rc = EXIT_SIGNAL | (rc << 8);
@


1.220.2.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@d162 1
a162 1
	  if (!myself->cygstarted)
d517 1
a517 1
      if (!myself->cygstarted)
d599 1
a599 1
  if (!myself->cygstarted)
a605 2
  char pipesig;
  DWORD nb;
d614 6
a619 3
	  pipesig = sig;
	  if (!WriteFile (myself->wr_proc_pipe, &pipesig, 1, &nb, NULL))
	    debug_printf ("sending stop notification to parent failed, %E");
d622 2
a623 1
  sigproc_printf ("process %d stopped by signal %d", myself->pid, sig);
a631 10
      if (my_parent_is_alive ())
	{
	  pinfo parent (myself->ppid);
	  if (parent)
	    {
	      sig = SIGCONT;
	      if (!WriteFile (myself->wr_proc_pipe, &sig, 1, &nb, NULL))
		debug_printf ("sending stop notification to parent failed, %E");
	    }
	}
d810 1
a810 1
      if (myself->cygstarted)	/* Was this process created by a cygwin process? */
d1100 1
@


1.220.2.2
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d28 1
@


1.220.2.3
log
@checkpoint
@
text
@d23 2
d992 1
a992 1
  if (special_case = (/*VFORKPID || */ISSTATE (myself, PID_STOPPED)))
@


1.220.2.4
log
@* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.
@
text
@d603 15
a617 1
  myself.alert_parent (sig);
d627 10
a636 1
      myself.alert_parent (SIGCONT);
@


1.219
log
@* exceptions.cc (sig_handle_tty_stop): Set flag that we are in a cygwin
function to avoid a probably erroneous stack walk.
@
text
@d596 1
a626 1
  _my_tls.incyg = 1;
@


1.218
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d596 1
a596 1
  /* Silently ignore attempts to suspend if there is no accomodating
d626 1
d637 1
@


1.217
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d808 2
@


1.216
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d367 1
a367 1
    system_printf ("Failed to start debugger: %E");
d493 1
a493 1
  debug_printf ("In cygwin_except_handler sig = %d at %p", si.si_signo, in.Eip);
@


1.215
log
@Change the name "title_mutex" to "tty_mutex" throughout.
* tty.h (tty_list::allocate_tty): Turn argument into a boolean.
* tty.cc (tty_list::init): Protect entire allocation operation with tty_mutex
(formerly title_mutex) to protect against allocation races.
@
text
@d833 1
a833 1
        {
d839 1
a839 1
        {
@


1.214
log
@* exceptions.cc (try_to_debug): Report on tid of caller.
* sync.cc (muto::acquire): Fix some races.
* sync.h (muto): Expose some fields for easier debugging.
@
text
@d333 1
a333 1
  ReleaseMutex (title_mutex);
d1120 1
a1120 1
HANDLE NO_COPY title_mutex = NULL;
d1127 1
a1127 1
  /* title_mutex protects modification of console title. It's necessary
d1130 1
a1130 1
  if (!(title_mutex = CreateMutex (&sec_all_nih, FALSE,
d1132 1
a1132 1
						       "title_mutex", 0))))
d1135 1
a1135 1
  ProtectHandle (title_mutex);
@


1.213
log
@	* exceptions.cc (sigpacket::process): Simplify code slightly.
@
text
@d352 2
a353 2
  console_printf ("*** starting debugger for pid %u\n",
		  cygwin_pid (GetCurrentProcessId ()));
@


1.212
log
@* cygtls.h (waitq): Declare structure here.
(_cygtls::wq): Declare.
* cygtls.cc (_cygtls::fixup_after_fork): Clear wq.thread_ev to avoid using an
invalid event handle in forked process.
* dcrt0.cc (waitq_storage): Delete.
(threadstuff): Remove waitq_storage.
* perthread.h (per_thread_waitq): Delete.
(waitq_storage): Delete declaration.
* sigproc.cc (sigproc_init): Remove perthread waitq consideration.
* sigproc.h (waitq): Delete declaration.
* wait.cc (wait4): Use _my_tls waitq structure rather than per_thread.
* cygtls.h (_cygtls::newmask): Delete member.
(_cygtls::deltamask): New member.
* gendef (_sigdelayed): Replace the call to set_process_mask by a call to
set_process_mask_delta.
* exceptions.cc (handle_sigsuspend): Do not filter tempmask.  Or
SIG_NONMASKABLE in deltamask as a flag.
(_cygtls::interrupt_setup): Set deltamask only.
(set_process_mask_delta): New function.
(_cygtls::call_signal_handler): Replace the first call to set_process_mask by a
call to set_process_mask_delta.
* tlsoffsets.h: Regenerate.
@
text
@d1044 1
a1052 1
  goto dosig1;
a1054 2
  tls->set_siginfo (this);
dosig1:
@


1.211
log
@* cygtls.cc (_cygtls::fixup_after_fork): Remove unneeded setting of oldmask.
* exceptions.cc: Remove some __I386__ conditionals.
(handle_exceptions): Move ppid test to outside of a loop for efficiency.
(setup_handler): Make debugging output more wordy.
(_cygtls::call_signal_handler): To avoid a race, use lock/unlock to synchronize
with signal thread and ensure that signal_arrived event has actually been set.
* gendef (_sigfe): Use ebx for all sigstack manipulations to ensure that the
register is saved.  Move setting of incyg to within stack lock to avoid
setup_handler confusion.
(_sigbe): Use ebx for all sigstack manipulations to ensure that the register is
saved.
(_cygtls::pop): Ditto.
(_cygtls::lock): Ditto.
(stabilize_sig_stack): Ditto.
(setjmp): Ditto.
(longjmp): Ditto.
@
text
@d573 1
a573 2
  // Let signals we're interested in through.
  set_signal_mask (tempmask &= ~SIG_NONMASKABLE, oldmask);
d583 1
a583 1
     handler returns. */
d585 1
d674 1
a674 2
  oldmask = myself->getsigmask ();
  newmask = oldmask | siga.sa_mask | SIGTOMASK (sig);
d902 21
d1175 1
a1175 1
      sigset_t this_oldmask = oldmask;
a1176 1
      set_process_mask (newmask);
d1181 1
a1181 1
      set_process_mask (this_oldmask);
@


1.210
log
@* exceptions.cc (setup_handler): Avoid suspending a thread if it in a cygwin
function, in an exception, spinning, or locked.
* gendef (_sigfe): Move incyg setting earlier.
(sigreturn): Set incyg flag to avoid interrupting called cygwin functions.
(sigdelayed): Ditto.
(stabilize_sig_stack): Ditto.
* sigproc.cc (proc_subproc): Don't restore process lock early in exec case.
* cygtls.h: Reorganize fields in _cygtls slightly.
* tlsoffsets.h: Regenerate.
@
text
@a189 2
#ifdef __i386__
#define HAVE_STATUS
d195 3
a197 3
	      in->Eax, in->Ebx, in->Ecx, in->Edx, in->Esi, in->Edi);
  small_printf ("ebp=%08x esp=%08x program=%s\r\n",
	      in->Ebp, in->Esp, myself->progname);
d199 1
a199 6
	      in->SegCs, in->SegDs, in->SegEs, in->SegFs, in->SegGs, in->SegSs);
#endif

#ifndef HAVE_STATUS
  system_printf ("Had an exception");
#endif
a201 5
#ifdef __i386__
/* Print a stack backtrace. */

#define HAVE_STACK_TRACE

d291 1
a291 1
  small_printf ("End of stack trace%s",
d517 4
a520 4
      for (int i = 0; status_info[i].name; i++)
	if (status_info[i].code == e.ExceptionCode)
	  {
	    if (!myself->ppid_handle)
d522 2
a523 2
	    break;
	  }
a555 9
#endif /* __i386__ */

#ifndef HAVE_STACK_TRACE
void
stack (void)
{
  system_printf ("Stack trace not yet supported on this machine.");
}
#endif
a560 3
#ifdef __i386__
#define HAVE_CALL_HANDLER

d671 1
a671 2
_cygtls::interrupt_setup (int sig, void *handler,
			      struct sigaction& siga)
d696 1
a696 1
			    struct sigaction& siga)
d733 2
a736 1
	  sigproc_printf ("interrupted known cygwin routine");
d770 4
a773 1
      if (!tls->incyg && !tls->in_exception () && !tls->spinning && !tls->locked ())
a799 5
#endif /* i386 */

#ifndef HAVE_CALL_HANDLER
#error "Need to supply machine dependent setup_handler"
#endif
d1145 1
a1145 2
  /* Call signal handler.  No need to set stacklock since sig effectively
     implies that.  */
d1148 1
d1173 1
d1176 2
a1177 1
if (_my_tls.stackptr > _my_tls.stack) debug_printf ("stackptr[-1] %p", _my_tls.stackptr[-1]);
@


1.209
log
@* fork.cc (fork_parent): Save parent pid in a temporary variable since child
could conceivably exit before function returns, rendering the child's shared
memory area invalid.
* cygtls.h (_cygtls::incyg): Declare new field.
(_cygtls::in_exception): Define new function.
* exceptions.cc (setup_handler): Remove locked flag.  Use 'incyg' flag and
in_exception function to determine when we're in a cygwin function.
(_cygtls::call_signal_handler): Decrement incyg flag prior to calling a
handler.  Increment it on return.
* gendef (_sigfe): Increment incyg flag.  Use testl for zero testing rather
than orl, for consistency.
(_sigbe): Decrement incyg flag.  Use testl for zero testing rather than orl,
for consistency.
(_cygtls::pop): Use testl for zero testing rather than orl, for consistency.
(stabilize_sig_stack): Ditto.
@
text
@d789 1
a789 1
      if (res || tls->incyg)
d794 1
a794 1
      if (!tls->locked () && !tls->spinning)
@


1.208
log
@* gendef (sigreturn): Call stabilize_sig_stack to ensure that there are no
pending signals.  Restore edx later.
(sigdelayed): Save edx earlier.
* malloc_wrapper.cc (malloc_init): Add some more debugging output.
@
text
@a744 1
  bool locked = false;
d756 1
a756 2
      locked = true;
      if (tls->stackptr > tls->stack)
d762 1
a766 1
      locked = false;
d777 1
a777 1
	 SuspendThread on itself then just queue the signal. */
d789 1
a789 1
      if (res || tls->stackptr > tls->stack)
a811 2
  if (locked)
    tls->unlock ();
d1184 1
d1187 1
@


1.207
log
@* exceptions.cc (setup_handler): Signal event for any sigwaitinfo if it exists
to force signal to be handled.  Zero event here to prevent races.
* signal.cc (sigwaitinfo): Use local handle value for everything since signal
thread could zero event element at any time.  Detect when awaking due to thread
not in mask and set return value and errno accordingly.  Don't set signal
number to zero unless we've recognized the signal.
* sigproc.cc (sigq): Rename from sigqueue throughout.
* thread.cc (pthread::join): Handle signals received while waiting for thread
to terminate.
* cygwin.din: Export sighold, sigqueue.
* exceptions.cc (sighold): Define new function.
* signal.cc (handle_sigprocmask): Set correct errno for invalid signal.
Simplify debugging output.
(sigqueue): Define new function.
* include/cygwin/signal.h (sighold): Declare new function.
(sigqueue): Ditto.
* include/cygwin/version.h: Bump API minor version number.
* include/limits.h (TIMER_MAX): Define.
(_POSIX_TIMER_MAX): Ditto.
@
text
@d1203 1
@


1.206
log
@* exceptions.cc (sigpacket::process): Make sure that tls is filled in for
SIGSTOP condition.
(_cygtls::call_signal_handler): Restore signal mask using saved oldmask rather
than current oldmask.
@
text
@d816 6
d913 18
@


1.205
log
@* dcrt0.cc (alloc_stack_hard_way): Revert to previous implementation.
(alloc_stack): Ditto.
* exceptions.cc (ctrl_c_handler): Add debugging output.
@
text
@d710 1
a710 1
  this->sig = sig;			// Should ALWAYS be last setting set to avoid a race
d958 2
d1161 1
a1161 1
      sigset_t oldmask = oldmask;
d1166 1
a1166 1
      set_process_mask (oldmask);
@


1.204
log
@* Makefile.in (clean): Remove sigfe.s.
(sigfe.s): Ensure that sigfe.s will be regenerated if it does not exist.
* dll_init.cc (dll_dllcrt0): Simplify initializing tests.
* exceptions.cc (setup_handler): Detect when stub caller is either spinning or
has acquired the lock after being suspended to avoid windows problems with
suspending a win32 API call.
* cygtls.h (_cygtls::spinning): Declare new element.
* gendef: Remove unused _siglist_index and _siglist declaration.
(_sigfe): Set spinning element when potentially looping, waiting for lock.
(_sigbe): Ditto.
(_cygtls::lock): Ditto.
(_longjmp): Ditto.
* tlsoffsets.h: Regenerate.
* pinfo.cc (_pinfo::exit): Set final exit state here.  Call sigproc_terminate
if invoked with 'norecord'.  Clear any residual _cygtls stuff.
* winsup.h (exit_states): Define ES_FINAL.
* spawn.cc (spawn_guts): Don't call proc_terminate specifically when execing.
Let _pinfo::exit handle that case.
* sigproc.cc (wait_subproc): Always exit loop early when proc_loop_wait.
* init.cc (munge_threadfunc): Eliminate unused argument.
(dll_entry): Reflect above change in call to munge_threadfunc.
@
text
@d832 4
a835 1
    ExitProcess (STATUS_CONTROL_C_EXIT);
@


1.203
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d791 1
a791 1
      if (res)
d796 1
a796 1
      if (!tls->locked ())
@


1.202
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d522 1
a522 1
  if (!myself->progname[0]
d695 1
a695 1
_threadinfo::interrupt_setup (int sig, void *handler,
d698 1
a698 1
  push ((__stack_t) sigdelayed);
d720 1
a720 1
_threadinfo::interrupt_now (CONTEXT *ctx, int sig, void *handler,
d723 1
a723 1
  push ((__stack_t) ctx->Eip);
a729 12
void __stdcall
signal_fixup_after_fork ()
{
  if (_my_tls.sig)
    {
      _my_tls.sig = 0;
      _my_tls.stackptr = _my_tls.stack + 1;	// FIXME?
      set_signal_mask (_my_tls.oldmask);
    }
  sigproc_init ();
}

d738 1
a738 1
static int setup_handler (int, void *, struct sigaction&, _threadinfo *tls)
d741 1
a741 1
setup_handler (int sig, void *handler, struct sigaction& siga, _threadinfo *tls)
d745 1
a753 1
  int locked;
d756 3
a758 3
      locked = tls->lock ();
      __stack_t *retaddr_on_stack = tls->stackptr - 1;
      if (retaddr_on_stack >= tls->stack)
d767 2
d772 3
a774 5
      /* Suspend the thread which will receive the signal.  But first ensure that
	 this thread doesn't have any mutos.  (FIXME: Someday we should just grab
	 all of the mutos rather than checking for them)
	 For Windows 95, we also have to ensure that the addresses returned by GetThreadContext
	 are valid.
a789 4
      /* Just release the lock now since we hav suspended the main thread and it
	 definitely can't be grabbing it now.  This will have to change, of course,
	 if/when we can send signals to other than the main thread. */

d796 8
a803 8

      // FIXME - add check for reentering of DLL here

      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
      if (!GetThreadContext (hth, &cx))
	system_printf ("couldn't get context of main thread, %E");
      else if (interruptible (cx.Eip))
	interrupted = tls->interrupt_now (&cx, sig, handler, siga);
a808 2
      tls->unlock ();
      locked = false;
d830 4
d966 1
a966 1
  else if (!tls && (tls = _threadinfo::find_tls (si.si_signo)))
d1142 2
a1143 3
extern "C" {
int __stdcall
call_signal_handler_now ()
d1145 8
a1152 6
  int sa_flags = 0;
  while (_my_tls.sig && _my_tls.stackptr > _my_tls.stack)
    {
      sa_flags = _my_tls.sa_flags;
      int sig = _my_tls.sig;
      void (*sigfunc) (int) = _my_tls.func;
d1154 1
a1154 1
      (void) _my_tls.pop ();
d1156 5
a1160 5
      sigset_t oldmask = _my_tls.oldmask;
      int this_errno = _my_tls.saved_errno;
      set_process_mask (_my_tls.newmask);
      _my_tls.sig = 0;
      sigfunc (sig);
d1166 1
a1166 1
  return sa_flags & SA_RESTART;
d1169 1
a1169 1
void __stdcall
a1173 1
}
@


1.201
log
@* localtime.cc (localtime_r): Call tzset.
* Makefile.in: Make version.h/cygwin.din version check a warning since it is
not foolproof.
* cygheap.h (CYGHEAPSIZE): Bump size down.
* cygtls.h (_threadinfo::stacklock): New element.
(_threadinfo::pop): Make regparm.
(_threadinfo::lock): New function.
(_threadinfo::unlock): New function.
* cygtls.cc (_threadinfo::push): Wait for a lock on the stack before performing
the operation.
(_threadinfo::pop): Move to another file.
* cygwin.din: More SIGFE changes.
* exceptions.cc (try_to_debug): Always display messages on console.
(handle_exceptions): Unwind stack only when actually about to call sig_send.
(setup_handler): Lock stack prior to performing any operations.
* gendef (_sigfe): Ditto.
(_sigbe): Ditto.
(_threadinfo::pop): Ditto.  Move here.
* gen_tlsoffsets: Generate positive offsets.
* tlsoffsets.h: Regenerate.
@
text
@d696 1
a696 1
			      struct sigaction& siga, __stack_t retaddr)
a697 1
  __stack_t *retaddr_in_tls = stackptr - 1;
d709 3
a711 2
  this->sig = sig;			// Should ALWAYS be second to last setting set to avoid a race
  *retaddr_in_tls = retaddr;
d723 2
a724 2
  push (0);
  interrupt_setup (sig, handler, siga, (__stack_t) ctx->Eip);
d765 1
d768 1
a771 5
	  if (!tls->lock (false))
	    continue;
	  __stack_t retaddr = InterlockedExchange ((LONG *) retaddr_on_stack, 0);
	  if (!retaddr)
	    continue;
d773 1
a773 1
	  tls->interrupt_setup (sig, handler, siga, retaddr);
a774 1
	  tls->unlock ();
d825 2
d832 2
@


1.200
log
@* cygerrno.h (set_errno): Set global errno whenever setting thread specific
version.
* debug.cc (__set_errno): Ditto.
* exceptions.cc (handle_sigsuspend): Remove spurious sig_dispatch_pending call.
(set_signal_mask): When there seem to be pending signals to dispatch, tell
signal_dispatch_pending/sig_send not to specifically call any handlers.
* sigproc.h (sig_dispatch_pending): Change declaration to void.
* sigproc.cc (sig_dispatch_pending): Change definition to void.  Take an
argument to determine whether to tell sig_send to wait for handler to be
called.
* sigproc.cc (sig_send): Don't call signal handler when sig == __SIGFLUSHFAST.
(wait_sig): Honor __SIGFLUSHFAST.  Guard against sigpacket::process nuking
si_signo.
* sigproc.h (__SIGFLUSHFAST): Define new special signal.
(sig_dispatch_pending): Change declaration to void.  Take optional boolean
argument.
* fork.cc (vfork): Add debugging output.
@
text
@d364 2
a365 2
  small_printf ("*** starting debugger for pid %u\n",
		cygwin_pid (GetCurrentProcessId ()));
d383 1
a383 1
	return 1;
a387 2
      small_printf ("*** continuing pid %u from debugger call\n",
		    cygwin_pid (GetCurrentProcessId ()));
d390 3
d394 1
a394 1
  return 0;
a419 4
  extern DWORD ret_here[];
  RtlUnwind (frame, ret_here, e0, 0);
  __asm__ volatile (".equ _ret_here,.");

d557 4
d770 2
d778 1
@


1.199
log
@* exceptions.cc (sig_handle_tty_stop): Avoid races by waiting for both
signal_arrived and for sigCONT.
(sigpacket::process): Enforce sending of both signal_arrived and sigCONT, where
appropriate.
* gendef (sigreturn): Save tls pointer in ebx so that it can jump into
sigdelayed and use the same register.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
a593 1
  sig_dispatch_pending ();
d596 2
a597 2
  set_signal_mask (tempmask &= ~SIG_NONMASKABLE, oldmask);// Let signals we're
				//  interested in through.
a926 1
  mask_sync->release ();
d928 1
a928 1
    sig_dispatch_pending ();
d931 1
@


1.198
log
@* cygtls.cc (_threadinfo::init_thread): Add more local reent stdio
initialization.
* dcrt0.cc (initial_env): Can it really be true that XP doesn't allow attaching
a debugger during DLL attach?  Add temporary workaround.
(dll_crt0_0): Ensure that _impure_ptr stdio is initialized before any threads.
(dll_crt0_1): Move _impure_ptr initialization to dll_crt0_0.
* exceptions.cc (try_to_debug): Reinstate old method for looping while
debugging.
* syscalls.cc (_cygwin_istext_for_stdio): Regularize debugging output.  Remove
hopefully extraneous check.
(setmode_helper): Add debugging output for improbable case.  Use "binary"
rather "raw" for consistency.
@
text
@d647 13
a659 2
  if (WaitForSingleObject (sigCONT, INFINITE) != WAIT_OBJECT_0)
    api_fatal ("WaitSingleObject failed, %E");
d939 4
a942 1
  if (si.si_signo == SIGCONT)
d944 1
a944 1
      DWORD stopped = myself->process_state & PID_STOPPED;
a951 2
      if (stopped)
	SetEvent (sigCONT);
d1016 2
d1054 2
@


1.197
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d386 2
a387 1
	low_priority_sleep (0);
@


1.196
log
@* exceptions.cc (sig_handle_tty_stop): Fix boneheaded mistake by using correct
check for parent state rather than inverted check mistakenly introduced on
2003-09-15.
@
text
@d960 1
a960 1
  if (special_case = (main_vfork->pid || ISSTATE (myself, PID_STOPPED)))
@


1.195
log
@* cygtls.cc (_threadinfo::remove): Don't assume that we are removing _my_tls.
* exceptions.cc (setup_handler): Improve debugging output.
(call_signal_handler_now): Remove ill-advised debugger call.
* sigproc.cc (sigcomplete_main): Delete.
(sig_send): Honor FIXME and avoid using main thread's completion event for
everything or suffer races.
(pending_signals::add): Default stored mask to current process mask rather than
mask at time of signal send.
(wait_sig): Add debugging output.
* sigproc.h (sigpacket::mask_storage): Delete.
@
text
@d634 1
a634 1
      if (ISSTATE (parent, PID_NOCLDSTOP))
@


1.194
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d747 5
a751 1
    goto out;
a1147 4
#ifdef DEBUGGING
      if (_my_tls.stackptr > (_my_tls.stack + 1))
	try_to_debug ();
#endif
@


1.193
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d422 1
a422 1
  int sig;
d428 5
d434 3
a436 1
    case STATUS_FLOAT_INVALID_OPERATION:
d438 3
a440 1
    case STATUS_FLOAT_STACK_CHECK:
d442 3
d446 3
d450 2
a451 1
      sig = SIGFPE;
d455 4
d460 4
d465 2
a466 1
      sig = SIGILL;
d470 2
a471 1
      sig = SIGALRM;
d482 2
a483 1
      sig = SIGSEGV;
d487 2
a488 1
      sig = SIGINT;
d507 1
a507 1
  debug_printf ("In cygwin_except_handler sig = %d at %p", sig, in.Eip);
d509 3
a511 2
  if (global_sigs[sig].sa_mask & SIGTOMASK (sig))
    syscall_printf ("signal %d, masked %p", sig, global_sigs[sig].sa_mask);
d514 1
a514 1
		 global_sigs[sig].sa_handler);
d526 3
a528 3
      || (void *) global_sigs[sig].sa_handler == (void *) SIG_DFL
      || (void *) global_sigs[sig].sa_handler == (void *) SIG_IGN
      || (void *) global_sigs[sig].sa_handler == (void *) SIG_ERR)
d531 7
a537 12
      if (1)
	{
	  for (int i = 0; status_info[i].name; i++)
	    {
	      if (status_info[i].code == e.ExceptionCode)
		{
		  if (!myself->ppid_handle)
		    system_printf ("Exception: %s", status_info[i].name);
		  break;
		}
	    }
	}
d556 1
a556 1
      signal_exit (0x80 | sig);	// Flag signal + core dump
d559 3
d563 1
a563 1
  sig_send (NULL, sig, &_my_tls);	// Signal myself
d635 8
a642 1
	sig_send (parent, SIGCHLD);
d851 1
a852 1
	  sig_send (NULL, SIGHUP);
d886 1
a886 1
      kill (-myself->pid, SIGINT);
d921 1
a921 1
sig_handle (int sig, sigset_t mask, int pid, _threadinfo *tls)
d923 1
a923 1
  if (sig == SIGCONT)
d938 36
a973 11
  bool insigwait_mask = tls ? sigismember (&tls->sigwait_mask, sig) : false;
  bool special_case = ISSTATE (myself, PID_STOPPED) || main_vfork->pid;
  bool masked = sigismember (&mask, sig);
  if (sig != SIGKILL && sig != SIGSTOP
      && (special_case || main_vfork->pid || masked || insigwait_mask
	  || (tls && sigismember (&tls->sigmask, sig))))
    {
      sigproc_printf ("signal %d blocked", sig);
      if ((!special_case && !masked)
	  && (insigwait_mask || (tls = _threadinfo::find_tls (sig)) != NULL))
	goto thread_specific;
a977 6
  /* Clear pending SIGCONT on stop signals */
  if (sig == SIGSTOP || sig == SIGTSTP || sig == SIGTTIN || sig == SIGTTOU)
    sig_clear (SIGCONT);

  sigproc_printf ("signal %d processing", sig);
  struct sigaction thissig = global_sigs[sig];
d981 3
a983 7
  myself->rusage_self.ru_nsignals++;

  if (sig == SIGKILL)
    goto exit_sig;

  if (sig == SIGSTOP)
    goto stop;
d987 1
a987 1
  __small_sprintf (sigmsg, "cygwin: signal %d\n", sig);
d995 2
a996 2
      if (sig == SIGCHLD || sig == SIGIO || sig == SIGCONT || sig == SIGWINCH
	  || sig == SIGURG)
d998 1
a998 1
	  sigproc_printf ("default signal %d ignored", sig);
d1002 1
a1002 1
      if (sig == SIGTSTP || sig == SIGTTIN || sig == SIGTTOU)
d1010 1
a1010 1
      sigproc_printf ("signal %d ignored", sig);
d1025 1
d1028 2
d1031 2
a1032 2
  sigproc_printf ("signal %d, about to call %p", sig, handler);
  rc = setup_handler (sig, handler, thissig, tls ?: _main_tls);
d1039 2
a1040 1
  tls->sig = sig;
d1046 1
a1046 1
  if (sig == SIGQUIT || sig == SIGABRT)
d1053 1
a1053 1
      sig |= 0x80;
d1055 2
a1056 2
  sigproc_printf ("signal %d, about to call do_exit", sig);
  signal_exit (sig);
@


1.193.4.1
log
@* dcrt0.cc (reent_data): Make global.
* cygwin.din: Reexport reent_data.
* cygtls.cc (_threadinfo::remove): Don't assume that we are removing _my_tls.
* exceptions.cc (setup_handler): Improve debugging output.
(call_signal_handler_now): Remove ill-advised debugger call.
* sigproc.cc (sigcomplete_main): Delete.
(sig_send): Honor FIXME and avoid using main thread's completion event for
everything or suffer races.
(pending_signals::add): Default stored mask to current process mask rather than
mask at time of signal send.
(wait_sig): Add debugging output.
* sigproc.h (sigpacket::mask_storage): Delete.
* fhandler.cc (fhandler_base::open): Revert isfs change.
@
text
@d713 1
a713 5
    {
      sigproc_printf ("trying to send sig %d but signal %d already armed",
		      sig, tls->sig);
      goto out;
    }
d1091 4
@


1.193.4.2
log
@* exceptions.cc (sig_handle_tty_stop): Fix boneheaded mistake by using correct
check for parent state rather than inverted check mistakenly introduced on
2003-09-15.
@
text
@d607 1
a607 1
      if (NOTSTATE (parent, PID_NOCLDSTOP))
@


1.193.4.3
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d909 1
a909 1
  bool special_case = ISSTATE (myself, PID_STOPPED) || VFORKPID;
@


1.193.4.4
log
@* exceptions.cc (sig_handle): Remove extraneous vforkism.
@
text
@d912 1
a912 1
      && (special_case || masked || insigwait_mask
@


1.193.4.5
log
@* cygtls.cc (_threadinfo::init_thread): Add more local reent stdio
initialization.
* dcrt0.cc (initial_env): Can it really be true that XP doesn't allow attaching
a debugger during DLL attach?  Add temporary workaround.
(dll_crt0_0): Ensure that _impure_ptr stdio is initialized before any threads.
(dll_crt0_1): Move _impure_ptr initialization to dll_crt0_0.
* exceptions.cc (try_to_debug): Reinstate old method for looping while
debugging.
* syscalls.cc (_cygwin_istext_for_stdio): Regularize debugging output.  Remove
hopefully extraneous check.
(setmode_helper): Add debugging output for improbable case.  Use "binary"
rather "raw" for consistency.
@
text
@d386 1
a386 2
	Sleep (0);
      Sleep (2000);
@


1.193.4.6
log
@* exceptions.cc (sig_handle_tty_stop): Avoid races by waiting for both
signal_arrived and for sigCONT.
(sigpacket::process): Enforce sending of both signal_arrived and sigCONT, where
appropriate.
* gendef (sigreturn): Save tls pointer in ebx so that it can jump into
sigdelayed and use the same register.
@
text
@d613 2
a614 13
  HANDLE w4[2];
  w4[0] = sigCONT;
  w4[1] = signal_arrived;
  switch (WaitForMultipleObjects (2, w4, TRUE, INFINITE))
    {
    case WAIT_OBJECT_0:
    case WAIT_OBJECT_0 + 1:
      reset_signal_arrived ();
      break;
    default:
      api_fatal ("WaitSingleObject failed, %E");
      break;
    }
d894 1
a894 4
  DWORD continue_now;
  if (sig != SIGCONT)
    continue_now = false;
  else
d896 1
a896 1
      continue_now = myself->process_state & PID_STOPPED;
d904 2
a954 2
	  if (continue_now)
	    SetEvent (signal_arrived);
a987 2
  if (continue_now)
    SetEvent (sigCONT);
@


1.192
log
@* exceptions.cc (_threadinfo::interrupt_now): Avoid double call to sigdelayed.
* pinfo.cc (_pinfo::commune_send): Avoid inexplicable test which caused most
pids to be shown as "<defunct>" on Win9x.
@
text
@d101 1
a101 1
asm (".equ __except_list,0");
d103 2
a104 4
extern exception_list *_except_list asm ("%fs:__except_list");

static void
init_exception_handler (exception_list *el)
d106 1
a106 1
  el->handler = handle_exceptions;
d111 6
a125 6
init_exceptions (exception_list *el)
{
  init_exception_handler (el);
}

extern "C" void
d364 2
d386 3
a388 3
	Sleep (0);
      Sleep (2000);
      small_printf ("*** continuing from debugger call\n");
d618 1
a618 1
int
d636 1
a636 1
    res = 0;
d638 1
a638 1
    res = 1;
d640 1
a640 1
    res = 0;
d669 2
a670 1
  sigproc_printf ("armed signal_arrived %p, res %d", signal_arrived, res);
a765 9
      muto *m;
      /* FIXME: Make multi-thread aware */
      for (m = muto_start.next;  m != NULL; m = m->next)
	if (m->unstable () || m->owner () == cygthread::main_thread_id)
	  {
	    sigproc_printf ("suspended thread owns a muto (%s)", m->name);
	    goto resume_thread;
	  }

a771 1
    resume_thread:
a772 1

d775 1
d795 1
a795 1
  _my_tls.remove ();
a885 13
extern _threadinfo *_last_thread;

_threadinfo *
_threadinfo::find_tls (int sig)
{
  EnterCriticalSection (&protect_linked_list);
  for (_threadinfo *t = _last_thread; t ; t = t->prev)
    if (sigismember (&t->sigwait_mask, sig))
      return t;
  LeaveCriticalSection (&protect_linked_list);
  return NULL;
}

d905 2
d908 2
a909 5
      && (sigismember (&mask, sig)
	  || (tls
	      && (insigwait_mask || sigismember (&tls->sigmask, sig)))
	  || main_vfork->pid
	  || ISSTATE (myself, PID_STOPPED)))
d912 2
a913 1
      if (insigwait_mask || (tls = _threadinfo::find_tls (sig)) != NULL)
a1025 6
  /* Unlock any main thread mutos since we're executing with prejudice. */
  muto *m;
  for (m = muto_start.next;  m != NULL; m = m->next)
    if (m->unstable () || m->owner () == cygthread::main_thread_id)
      m->reset ();

d1089 1
@


1.192.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d101 1
a101 1
extern exception_list *_except_list asm ("%fs:0");
d103 4
a106 2
void
init_exception_handler (exception_list *el, exception_handler *eh)
d108 1
a108 1
  el->handler = eh;
a112 6
extern "C" void
init_exceptions (exception_list *el)
{
  init_exception_handler (el, handle_exceptions);
}

d122 6
a320 2
int keep_looping = 1;

a365 2
  small_printf ("*** starting debugger for pid %u\n",
		cygwin_pid (GetCurrentProcessId ()));
d386 3
a388 3
	low_priority_sleep (0);
      small_printf ("*** continuing pid %u from debugger call\n",
		    cygwin_pid (GetCurrentProcessId ()));
d669 1
a669 2
  sigproc_printf ("armed signal_arrived %p, sig %d, res %d", signal_arrived,
		  sig, res);
d804 1
a804 1
  _my_tls.remove (INFINITE);
d895 13
a926 2
  bool special_case = ISSTATE (myself, PID_STOPPED) || main_vfork->pid;
  bool masked = sigismember (&mask, sig);
d928 5
a932 2
      && (special_case || main_vfork->pid || masked || insigwait_mask
	  || (tls && sigismember (&tls->sigmask, sig))))
d935 1
a935 2
      if ((!special_case && !masked)
	  && (insigwait_mask || (tls = _threadinfo::find_tls (sig)) != NULL))
a1116 1

@


1.192.2.2
log
@* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
@
text
@d319 2
d620 1
a620 1
bool
d638 1
a638 1
    res = false;
d640 1
a640 1
    res = true;
d642 1
a642 1
    res = false;
@


1.192.2.3
log
@* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
@
text
@d766 9
d781 1
d783 1
a785 1

d1035 6
@


1.192.2.4
log
@* gentls_offsets: Reinstate unlink of temp files.
@
text
@d422 1
a422 1
  siginfo_t si;
d428 1
d430 1
a431 11
      si.si_signo = SIGFPE;
      si.si_sigval.sival_int = FPE_FLTSUB;
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      si.si_signo = SIGFPE;
      si.si_sigval.sival_int = FPE_FLTRES;
      break;
    case STATUS_FLOAT_OVERFLOW:
      si.si_signo = SIGFPE;
      si.si_sigval.sival_int = FPE_FLTOVF;
      break;
a432 3
      si.si_signo = SIGFPE;
      si.si_sigval.sival_int = FPE_FLTUND;
      break;
a433 3
      si.si_signo = SIGFPE;
      si.si_sigval.sival_int = FPE_INTDIV;
      break;
d435 1
a435 2
      si.si_signo = SIGFPE;
      si.si_sigval.sival_int = FPE_INTOVF;
a438 4
      si.si_signo = SIGILL;
      si.si_sigval.sival_int = ILL_ILLOPC;
      break;

a439 4
      si.si_signo = SIGILL;
      si.si_sigval.sival_int = ILL_PRVOPC;
      break;

d441 1
a441 2
      si.si_signo = SIGILL;
      si.si_sigval.sival_int = ILL_ILLADR;
d445 1
a445 2
      si.si_signo = SIGALRM;
      si.si_sigval.sival_int = 0;
d456 1
a456 2
      si.si_signo = SIGSEGV;
      si.si_sigval.sival_int = SEGV_MAPERR;
d460 1
a460 2
      si.si_signo = SIGINT;
      si.si_sigval.sival_int = 0;
d479 1
a479 1
  debug_printf ("In cygwin_except_handler sig = %d at %p", si.si_signo, in.Eip);
d481 2
a482 3
  if (global_sigs[si.si_signo].sa_mask & SIGTOMASK (si.si_signo))
    syscall_printf ("signal %d, masked %p", si.si_signo,
		    global_sigs[si.si_signo].sa_mask);
d485 1
a485 1
		 global_sigs[si.si_signo].sa_handler);
d497 3
a499 3
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_DFL
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_IGN
      || (void *) global_sigs[si.si_signo].sa_handler == (void *) SIG_ERR)
d502 12
a513 7
      for (int i = 0; status_info[i].name; i++)
	if (status_info[i].code == e.ExceptionCode)
	  {
	    if (!myself->ppid_handle)
	      system_printf ("Exception: %s", status_info[i].name);
	    break;
	  }
d532 1
a532 1
      signal_exit (0x80 | si.si_signo);	// Flag signal + core dump
d535 2
a536 4
  si.si_addr = ebp;
  si.si_code = SI_KERNEL;
  si.si_errno = si.si_pid = si.si_uid = 0;
  sig_send (NULL, si, &_my_tls);	// Signal myself
d608 1
a608 8
	{
	  siginfo_t si;
	  si.si_signo = SIGCHLD;
	  si.si_code = SI_KERNEL;
	  si.si_sigval.sival_int = CLD_STOPPED;
	  si.si_errno = si.si_pid = si.si_uid = si.si_errno = 0;
	  sig_send (parent, si);
	}
d817 1
a818 1
	  saw_close = true;
d852 1
a852 1
      killsys (-myself->pid, SIGINT);
d887 1
a887 1
sigpacket::process ()
d889 1
a889 1
  if (si.si_signo == SIGCONT)
d904 1
a904 1
  bool insigwait_mask = tls ? sigismember (&tls->sigwait_mask, si.si_signo) : false;
d906 2
a907 2
  bool masked = sigismember (mask, si.si_signo);
  if (si.si_signo != SIGKILL && si.si_signo != SIGSTOP
d909 1
a909 1
	  || (tls && sigismember (&tls->sigmask, si.si_signo))))
d911 1
a911 1
      sigproc_printf ("signal %d blocked", si.si_signo);
d913 1
a913 1
	  && (insigwait_mask || (tls = _threadinfo::find_tls (si.si_signo)) != NULL))
d920 1
a920 1
  if (si.si_signo == SIGSTOP || si.si_signo == SIGTSTP || si.si_signo == SIGTTIN || si.si_signo == SIGTTOU)
d923 2
a924 2
  sigproc_printf ("signal %d processing", si.si_signo);
  struct sigaction thissig = global_sigs[si.si_signo];
d930 1
a930 1
  if (si.si_signo == SIGKILL)
d933 1
a933 4
  if (!tls)
    tls = _main_tls;

  if (si.si_signo == SIGSTOP)
d938 1
a938 1
  __small_sprintf (sigmsg, "cygwin: signal %d\n", si.si_signo);
d946 2
a947 2
      if (si.si_signo == SIGCHLD || si.si_signo == SIGIO || si.si_signo == SIGCONT || si.si_signo == SIGWINCH
	  || si.si_signo == SIGURG)
d949 1
a949 1
	  sigproc_printf ("default signal %d ignored", si.si_signo);
d953 1
a953 1
      if (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN || si.si_signo == SIGTTOU)
d961 1
a961 1
      sigproc_printf ("signal %d ignored", si.si_signo);
a975 1
  goto dosig1;
a977 2
  tls->set_siginfo (this);
dosig1:
d979 2
a980 2
  sigproc_printf ("signal %d, about to call %p", si.si_signo, handler);
  rc = setup_handler (si.si_signo, handler, thissig, tls);
d987 1
a987 1
  tls->sig = si.si_signo;
d993 1
a993 1
  if (si.si_signo == SIGQUIT || si.si_signo == SIGABRT)
d1000 1
a1000 1
      si.si_signo |= 0x80;
d1002 2
a1003 2
  sigproc_printf ("signal %d, about to call do_exit", si.si_signo);
  signal_exit (si.si_signo);
@


1.192.2.5
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@a561 1
  _my_tls.push ((__stack_t) ebp, true);
@


1.192.2.6
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
@
text
@d938 18
d959 2
a965 21
  if ( si.si_signo == SIGSTOP)
    {
      sig_clear (SIGCONT);
      goto stop;
    }

  bool masked;
  bool special_case;
  bool insigwait_mask;
  insigwait_mask = masked = false;
  if (special_case = (main_vfork->pid || ISSTATE (myself, PID_STOPPED)))
    /* nothing to do */;
  else if (tls && sigismember (&tls->sigwait_mask, si.si_signo))
    insigwait_mask = true;
  else if (!tls && (tls = _threadinfo::find_tls (si.si_signo)))
    insigwait_mask = true;
  else if (!(masked = sigismember (mask, si.si_signo)) && tls)
    masked  = sigismember (&tls->sigmask, si.si_signo);

  if (insigwait_mask)
    goto thread_specific;
d970 2
a971 13
  if (special_case || masked)
    {
      sigproc_printf ("signal %d blocked", si.si_signo);
      rc = -1;
      goto done;
    }

  void *handler;
  handler = (void *) thissig.sa_handler;

  /* Clear pending SIGCONT on stop signals */
  if (si.si_signo == SIGTSTP || si.si_signo == SIGTTIN || si.si_signo == SIGTTOU)
    sig_clear (SIGCONT);
a1027 1
  tls->set_siginfo (this);
@


1.191
log
@* exceptions.cc (try_to_debug): Fix off-by-one problem when resetting
environment variable after error_start detected.
* fhandler_tty_slave.cc (fhandler_tty_slave::close): Clarify debug message.
* syscalls.cc (setsid): Don't increment usecount here, since it will be
automatically decremented on close.
@
text
@d678 1
a678 1
  ctx->Eip = (DWORD) sigdelayed;
a1135 1
#define pid_offset (unsigned)(((_pinfo *)NULL)->pid)
@


1.190
log
@* path.cc (mount_item::build_win32): Backslashify paths in non-managed case.
@
text
@d353 1
a353 1
      if (strncmp (p, "CYGWIN=", sizeof ("CYGWIN=") - 1) == 0)
d357 5
a361 2
	  if (q) *q = '_' ;
	  SetEnvironmentVariable ("CYGWIN", p + sizeof ("CYGWIN=")) ;
@


1.189
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@a712 1
      __stack_t retaddr;
d714 1
a714 2
      if (retaddr_on_stack >= tls->stack
	  && (retaddr = InterlockedExchange ((LONG *) retaddr_on_stack, 0)))
d716 1
@


1.188
log
@* pinfo.h (pinfo::operator ==): Add a way to check for _pinfo types.
* sigproc.cc (proc_subproc): Ensure that zombie is removed when SIGCHLD ==
SIG_IGN but still allow wait()ing threads to wake up.
@
text
@a38 5
_threadinfo NO_COPY dummy_thread;
_threadinfo NO_COPY *_last_thread = &dummy_thread;

CRITICAL_SECTION NO_COPY _threadinfo::protect_linked_list;

a126 95
void
_threadinfo::set_state (bool is_exception)
{
  initialized = CYGTLS_INITIALIZED + is_exception;
}

void
_threadinfo::reset_exception ()
{
  if (initialized == CYGTLS_EXCEPTION)
    {
#ifdef DEBUGGING
      debug_printf ("resetting stack after an exception stack %p, stackptr %p", stack, stackptr);
#endif
      set_state (false);
      stackptr--;
    }
}

void
_threadinfo::call (DWORD (*func) (void *, void *), void *arg)
{
  char buf[CYGTLS_PADSIZE];
  _my_tls.call2 (func, arg, buf);
}

void
_threadinfo::call2 (DWORD (*func) (void *, void *), void *arg, void *buf)
{
  init_thread (buf);
  ExitThread (func (arg, buf));
}

void
_threadinfo::init ()
{
  InitializeCriticalSection (&protect_linked_list);
}

void
_threadinfo::init_thread (void *x)
{
  if (x)
    {
      memset (this, 0, sizeof (*this));
      stackptr = stack;
    }

  EnterCriticalSection (&protect_linked_list);
  prev = _last_thread;
  _last_thread->next = this;
  _last_thread = this;
  LeaveCriticalSection (&protect_linked_list);

  set_state (false);
  errno_addr = &errno;
}

void
_threadinfo::remove ()
{
  EnterCriticalSection (&protect_linked_list);
  if (prev)
    {
      prev->next = next;
      if (next)
	next->prev = prev;
      if (this == _last_thread)
	_last_thread = prev;
      prev = next = NULL;
    }
  LeaveCriticalSection (&protect_linked_list);
}

void
_threadinfo::push (__stack_t addr, bool exception)
{
  *stackptr++ = (__stack_t) addr;
  set_state (exception);
}

__stack_t
_threadinfo::pop ()
{
#ifdef DEBUGGING
  assert (stackptr > stack);
#endif
  __stack_t res = *--stackptr;
#ifdef DEBUGGING
  *stackptr = 0;
  debug_printf ("popped %p, stack %p, stackptr %p", res, stack, stackptr);
#endif
  return res;
}

d566 1
a566 1
  set_signal_mask (tempmask & ~SIG_NONMASKABLE);// Let signals we're
d568 1
a568 1
  sigproc_printf ("old mask %x, new mask %x", oldmask, tempmask);
d877 1
a877 1
set_signal_mask (sigset_t newmask, sigset_t& oldmask)
d881 3
a883 1
  sigproc_printf ("old mask %p, new mask %p", oldmask, newmask);
d886 1
a886 1
  if (oldmask & ~newmask)
d892 2
@


1.187
log
@* exceptions.cc (set_signal_mask): Report on input argument rather than
getsigmask.
* fhandler.h (fhandler_base): Make friends with close_all_files.
* pinfo.cc (_pinfo::set_ctty): Add more debugging.
* sigproc.cc (proc_can_be_signalled): Detect state when signal handler thread
is gone in target process as an EPERM situation.  Set errno to ESRCH if process
doesn't exist.
(sigproc_terminate): Set sendsig to illegal value when closed.
(sig_send): Rely on proc_can_be_signalled setting the proper errno.
* syscalls.cc (close_all_files): Detect when all ttys are closed prior to
calling close_all_files.  The ctty needs to be closed explicitly in this case.
@
text
@d795 1
a795 1
  set_errno (e);
@


1.186
log
@* exceptions.cc (ctrl_c_handler): Remove this thread from the signal handler
chain.
@
text
@d981 1
a981 1
  sigproc_printf ("old mask = %x, new mask = %x", myself->getsigmask (), newmask);
@


1.185
log
@* cygthread.cc (cygthread::stub): Revert previous change and again subsume
cygthread::stub2.  Just return from function now since ExitThread is guaranteed
by automatic _threadinfo wrapper.  Define as per ThreadProc convention.
(cygthread::stub2): Remove.
(cygthread::simplestub): Perform similar operations to cygthread::stub.
(cygthread::simplestub2): Remove.
* cygthread.h (cygthread::stub): Declare as per ThreadProc convention.
(cygthread::stub2): Remove declaration.
(cygthread::simplestub): Declare as per ThreadProc convention.
(cygthread::simplestub2): Remove declaration.
* cygtls.h (_threadinfo::call): Define first argument as per ThreadProc
convention.
(_threadinfo::call2): Ditto.
(_tlsbase): Define as char * pointer.
(_tlstop): New definition.
(_main_tls): Define here.
* dcrt0.cc (alloc_stack): Revert previous change which called init_thread since
information would be overwritten by fork later anyway.
(dll_crt0_1): Use _tlsbase and _tlstop for setting stack bottom, top.
* exceptions.cc: Move _main_tls declaration to cygtls.h.
(_threadinfo::call): Define first argument as per ThreadProc convention.
(_threadinfo::call2): Call ExitThread with thread function return value.
(_threadinfo::init_thread): Don't initialize cygtls to zero if input arg is
NULL.
* fork.cc (fork_child): Reset _main_tls here.  Reinitialize parts of _my_tls
after copying data from parent.
* init.cc (threadfunc_fe): New function.  Front-end for all threads created in
cygwin processes.
(munge_threadfunc): New function.
(dll_entry): Call munge_threadfunc to force the call of a thread wrapper.
* thread.cc (pthread::thread_init_wrapper): Perform similar operations to
cygthread::stub.
(pthread::thread_init_wrapper2): Remove.
* thread.h (pthread::thread_init_wrapper): Declare as per ThreadProc
convention.
(pthread::thread_init_wrapper2): Remove declaration.
* window.cc (Winmain): Just return from function now since ExitThread is
guaranteed by automatic _threadinfo wrapper.
@
text
@d902 1
@


1.184
log
@* exceptions.cc (_threadinfo::remove): Avoid a linked list walk.
@
text
@a40 1
extern _threadinfo *_main_tls;
d152 1
a152 1
_threadinfo::call (void (*func) (void *, void *), void *arg)
d159 1
a159 1
_threadinfo::call2 (void (*func) (void *, void *), void *arg, void *buf)
d162 1
a162 1
  func (arg, buf);
d172 1
a172 1
_threadinfo::init_thread (void *)
d174 5
a178 2
  memset (this, 0, sizeof (*this));
  stackptr = stack;
@


1.183
log
@* cygtls.h (_threadinfo::find_tls): New function.
* exceptions.cc (_threadinfo::find_tls): Rename from find_tls.  Use critical
section to protect access to linked list.
@
text
@a190 1
  _threadinfo *t;
d192 1
a192 3
  for (t = _last_thread; t && t != this; t = t->prev)
    continue;
  if (t)
d194 6
a199 5
      t->prev->next = t->next;
      if (t->next)
	t->next->prev = t->prev;
      if (t == _last_thread)
	_last_thread = t->prev;
@


1.182
log
@* exceptions.cc (_threadinfo::remove): Avoid returning without unlocking
critical section in the (hopefully impossible) case of an unrecognized thread.
@
text
@d991 1
a991 1
find_tls (int sig)
d993 1
d997 1
d1028 1
a1028 1
      if (insigwait_mask || (tls = find_tls (sig)) != NULL)
@


1.181
log
@* cygtls.h: Add more "don't parse this" guards.
(_threadinfo::init_thread): Rename from 'init'.
(_threadinfo::init): Declare new function.
(_threadinfo::protect_linked_list): Declare new critical section.
* dcrt0.cc (dll_crt0_1): Call init_thread to initialize thread stuff.
(_dll_crt0): Call _threadinfo::init prior to invoking dll_crt0_1.
* exceptions.cc (_threadinfo::init_thread): Rename from 'init'.
(_threadinfo::init): Define new function.  Protect linked list manipulation
with new critical section.
(_threadinfo::call): Reflect function name change.
(_threadinfo::remove): Protect linked list manipulation with new critical
section
* gentls_offsets: Rework to allow multi-line "don't parse this" protection.
* init.cc (dll_entry): Don't remove threads info stuff here since the remove
function uses a critical section which can't be used during thread creation or
destruction.
* thread.cc (pthread::exit): Call _threadinfo remove function here.
@
text
@d195 8
a202 7
  if (!t)
    return;
  t->prev->next = t->next;
  if (t->next)
    t->next->prev = t->prev;
  if (t == _last_thread)
    _last_thread = t->prev;
@


1.180
log
@* exceptions.cc (setup_handler): Remove ill-advised debugging output.
@
text
@d43 2
d162 1
a162 1
  init (buf);
d167 7
a173 1
_threadinfo::init (void *)
d177 2
d182 2
d192 1
d202 1
@


1.179
log
@* cygthread.cc (cygthread::stub): Properly establish _threadinfo environment.
(cygthread::stub2): New function.
(cygthread::simplestub): Ditto.
(cygthread::simplestub2): New function.
* cygthread.h (cygthread::stub2): Declare new function.
(cygthread::simplestub2): Ditto.
* cygtls.h (_threadinfo::call): Declare new function.
(_threadinfo::call2): Ditto.
* dcrt0.cc (dll_crt0_1): Accommodate new _threadinfo::init which doesn't return
pointer to tls.
(_dll_crt0): Remove obsolete DECLARE_TLS_STORAGE.
(dll_crt0): Ditto.
* exceptions.cc (_threadinfo::call): New function.
(_threadinfo::call2): Ditto.
(_threadinfo::init): Don't return pointer.
* thread.cc (pthread::thread_init_wrapper): Properly establish _threadinfo
environment.
(pthread::thread_init_wrapper2): New function.
* thread.h (pthread::thread_init_wrapper): Remove noreturn attribute
(pthread::thread_init_wrapper2): Declare new function.
* winbase.h: Remove obsolete code.
@
text
@a799 4
#ifdef DEBUGGING
      if (tls->stackptr > (tls->stack + 1))
	try_to_debug ();
#endif
@


1.178
log
@* exceptions.cc (_threadinfo::pop): Zero *contents* of popped stack location
rather than the actual stack pointer.
@
text
@d150 16
a165 2
_threadinfo *
_threadinfo::init (void *, void *thread)
a173 1
  return this;
@


1.177
log
@* pinfo.h (_pinfo::getthread2signal): Remove obsolete function.
* cygtls.h (_threadinfo): Define tid more precisely.
(_threadinfo::operator HANDLE): Define.
* exceptions.cc (_threadinfo::interupt_now): Use _threadinfo HANDLE operator to
derive thread handle.
(setup_handler): Ditto.
* sigproc.cc: Reorganize includes.
@
text
@d192 2
a193 2
#ifndef DEBUGGING
  _my_tls.stackptr = 0;
@


1.176
log
@* pinfo.h (_pinfo::getsig): Remove obsolete function, here and throughout.
* exceptions.cc: Ditto.
* fhandler_termios.cc: Ditto.
* signal.cc: Ditto.
* sigproc.cc: Ditto.
* Makefile.in: Revert previous change which made a cygwin.din newer than a
version.h a warning rather than an error.
@
text
@d748 1
a748 1
  SetThreadContext (myself->getthread2signal (), ctx); /* Restart the thread in a new location */
d804 1
a804 1
      HANDLE hth = myself->getthread2signal ();
@


1.175
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d550 2
a551 2
  if (myself->getsig (sig).sa_mask & SIGTOMASK (sig))
    syscall_printf ("signal %d, masked %p", sig, myself->getsig (sig).sa_mask);
d554 1
a554 1
		 myself->getsig (sig).sa_handler);
d566 3
a568 3
      || (void *) myself->getsig (sig).sa_handler == (void *) SIG_DFL
      || (void *) myself->getsig (sig).sa_handler == (void *) SIG_IGN
      || (void *) myself->getsig (sig).sa_handler == (void *) SIG_ERR)
d1013 1
a1013 1
  struct sigaction thissig = myself->getsig (sig);
d1064 1
a1064 1
  thissig = myself->getsig (SIGSTOP);
@


1.174
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d15 1
a15 2
#include <wingdi.h>
#include <winuser.h>
d19 2
a21 1
#include "pinfo.h"
d28 1
a35 1
extern void sigreturn ();
a36 3
extern void sigdelayed0 ();
extern void siglast ();
extern DWORD __no_sig_start, __no_sig_end;
d39 4
a57 2
HMODULE NO_COPY cygwin_hmodule;

a98 2
#ifdef __i386__

a115 1
#endif
d131 68
a307 1
static signal_dispatch sigsave;
a457 1
      SetThreadPriority (GetCurrentThread (), prio);
d460 1
a460 3
  /* FIXME: need to know handles of all running threads to
    resume_all_threads_except (current_thread_id);
  */
d466 1
d468 1
a468 1
handle_exceptions (EXCEPTION_RECORD *e, void *, CONTEXT *in, void *)
d470 1
a470 2
  int sig;
  static int NO_COPY debugging = 0;
d484 8
d493 1
a493 1
  switch (e->ExceptionCode)
d547 2
a548 2
  debug_printf ("In cygwin_except_handler exc %p at %p sp %p", e->ExceptionCode, in->Eip, in->Esp);
  debug_printf ("In cygwin_except_handler sig = %d at %p", sig, in->Eip);
d556 1
a556 1
  DWORD *ebp = (DWORD *)in->Esp;
d558 1
a558 1
    if (*ebp == in->SegCs && ebp[-1] == in->Eip)
d571 1
a571 1
      if (e)
d575 1
a575 1
	      if (status_info[i].code == e->ExceptionCode)
d592 1
a592 1
	      debugging = 1;
d597 1
a597 1
	  exception (e, in);
d604 3
a606 2
  sig_send (NULL, sig, (DWORD) ebp, 1);		// Signal myself
  return 0;
a635 1
  sigframe thisframe (mainthread);
d638 1
a638 1
  set_process_mask (tempmask & ~SIG_NONMASKABLE);// Let signals we're
d651 1
a651 1
  sigsave.oldmask = oldmask;	// Will be restored by signal handler
d688 1
a688 1
interruptible (DWORD pc, int testvalid = 0)
a705 2
  else if (testvalid)
    res = 1;	/* All we wanted to know was if this was a valid module. */
a707 2
  else if (h == cygwin_hmodule)
    res = 0;
d713 1
a713 1
  sigproc_printf ("pc %p, h %p, interruptible %d, testvalid %d", pc, h, res, testvalid);
d717 3
a719 16

bool
sigthread::get_winapi_lock (int test)
{
  if (test)
    return !InterlockedExchange (&winapi_lock, 1);

  /* Need to do a busy loop because we can't block or a potential SuspendThread
     will hang. */
  while (InterlockedExchange (&winapi_lock, 1))
    low_priority_sleep (0);
  return 1;
}

void
sigthread::release_winapi_lock ()
d721 7
a727 20
  /* Assumes that we have the lock. */
  InterlockedExchange (&winapi_lock, 0);
}

static void __stdcall interrupt_setup (int sig, void *handler, DWORD retaddr,
				       DWORD *retaddr_on_stack,
				       struct sigaction& siga)
		      __attribute__((regparm(3)));
static void __stdcall
interrupt_setup (int sig, void *handler, DWORD retaddr, DWORD *retaddr_on_stack,
		 struct sigaction& siga)
{
  sigsave.retaddr = retaddr;
  sigsave.retaddr_on_stack = retaddr_on_stack;
  /* FIXME: Not multi-thread aware */
  sigsave.oldmask = myself->getsigmask ();
  sigsave.newmask = sigsave.oldmask | siga.sa_mask | SIGTOMASK (sig);
  sigsave.sa_flags = siga.sa_flags;
  sigsave.func = (void (*)(int)) handler;
  sigsave.saved_errno = -1;		// Flag: no errno to save
d733 2
d736 1
a737 2
  int res = SetEvent (signal_arrived);	// For an EINTR case
  sigsave.sig = sig;			// Should ALWAYS be last thing set to avoid a race
d741 3
a743 3
static bool interrupt_now (CONTEXT *, int, void *, struct sigaction&) __attribute__((regparm(3)));
static bool
interrupt_now (CONTEXT *ctx, int sig, void *handler, struct sigaction& siga)
d745 2
a746 1
  interrupt_setup (sig, handler, ctx->Eip, 0, siga);
d755 1
a755 1
  if (sigsave.sig)
d757 3
a759 6
      sigsave.sig = 0;
      if (sigsave.retaddr_on_stack)
	{
	  *sigsave.retaddr_on_stack = sigsave.retaddr;
	  set_process_mask (sigsave.oldmask);
	}
a763 27
static int interrupt_on_return (sigthread *, int, void *, struct sigaction&) __attribute__((regparm(3)));
static int
interrupt_on_return (sigthread *th, int sig, void *handler, struct sigaction& siga)
{
  int i;
  DWORD ebp = th->frame;

  if (!ebp)
    return 0;

  thestack.init (ebp, 0, 1);  /* Initialize from the input CONTEXT */
  for (i = 0; i < 32 && thestack++ ; i++)
    if (th->exception || interruptible (thestack.sf.AddrReturn.Offset))
      {
	DWORD *addr_retaddr = ((DWORD *)thestack.sf.AddrFrame.Offset) + 1;
	if (*addr_retaddr  == thestack.sf.AddrReturn.Offset)
	  {
	    interrupt_setup (sig, handler, *addr_retaddr, addr_retaddr, siga);
	    *addr_retaddr = (DWORD) sigdelayed;
	  }
	return 1;
      }

  sigproc_printf ("couldn't find a stack frame, i %d", i);
  return 0;
}

d768 1
a768 1
  sigsave.saved_errno = e;
d772 2
a773 1
static int setup_handler (int, void *, struct sigaction&) __attribute__((regparm(3)));
d775 1
a775 1
setup_handler (int sig, void *handler, struct sigaction& siga)
a778 1
  sigthread *th = NULL;		// Initialization needed to shut up gcc
d780 1
a780 1
  if (sigsave.sig)
d785 8
a792 5
      DWORD res;
      HANDLE hth;

      EnterCriticalSection (&mainthread.lock);
      if (mainthread.frame)
d794 7
a800 2
	  hth = NULL;
	  th = &mainthread;
a801 3
      else
	{
	  LeaveCriticalSection (&mainthread.lock);
d803 2
a804 5
	  if (!mainthread.get_winapi_lock (1))
	    continue;

	  hth = myself->getthread2signal ();
	  th = NULL;
d806 10
a815 10
	  /* Suspend the thread which will receive the signal.  But first ensure that
	     this thread doesn't have any mutos.  (FIXME: Someday we should just grab
	     all of the mutos rather than checking for them)
	     For Windows 95, we also have to ensure that the addresses returned by GetThreadContext
	     are valid.
	     If one of these conditions is not true we loop for a fixed number of times
	     since we don't want to stall the signal handler.  FIXME: Will this result in
	     noticeable delays?
	     If the thread is already suspended (which can occur when a program has called
	     SuspendThread on itself then just queue the signal. */
a816 1
	  EnterCriticalSection (&mainthread.lock);
d818 1
a818 1
	  sigproc_printf ("suspending mainthread");
d820 4
a823 8
	  cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	  if (!GetThreadContext (hth, &cx))
	    memset (&cx, 0, sizeof cx);
#if 0
	  if ((cx.Eip & 0xff000000) == 0x77000000)
	    try_to_debug ();
#endif
	  sigproc_printf ("suspending mainthread PC %p", cx.Eip);
d825 4
a828 5
	  res = SuspendThread (hth);
	  /* Just release the lock now since we hav suspended the main thread and it
	     definitely can't be grabbing it now.  This will have to change, of course,
	     if/when we can send signals to other than the main thread. */
	  LeaveCriticalSection (&mainthread.lock);
d830 6
a835 7
	  /* Just set pending if thread is already suspended */
	  if (res)
	    {
	      mainthread.release_winapi_lock ();
	      (void) ResumeThread (hth);
	      break;
	    }
d837 1
a837 14
	  mainthread.release_winapi_lock ();
	  if (mainthread.frame)
	    goto resume_thread;	/* We just got the frame.  What are the odds?
				   Just loop and we'll hopefully pick it up on
				   the next pass through. */

	  muto *m;
	  /* FIXME: Make multi-thread aware */
	  for (m = muto_start.next;  m != NULL; m = m->next)
	    if (m->unstable () || m->owner () == mainthread.id)
	      {
		sigproc_printf ("suspended thread owns a muto (%s)", m->name);
		goto resume_thread;
	      }
d839 8
a846 12
	  if (mainthread.frame)
	    th = &mainthread;
	  else
	    {
	      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	      if (!GetThreadContext (hth, &cx))
		{
		  system_printf ("couldn't get context of main thread, %E");
		  goto resume_thread;
		}
	    }
	}
d848 3
a850 5
      if (th)
	{
	  interrupted = interrupt_on_return (th, sig, handler, siga);
	  LeaveCriticalSection (&th->lock);
	}
d852 1
a852 1
	interrupted = interrupt_now (&cx, sig, handler, siga);
d855 1
a855 2
      if (hth)
	res = ResumeThread (hth);
a858 1

d860 1
d909 1
a909 1
	    sig_send (NULL, SIGHUP);
d942 7
d952 1
a952 1
set_process_mask (sigset_t newmask)
a953 1
  sigframe thisframe (mainthread);
a954 1
  sigset_t oldmask = myself->getsigmask ();
d962 1
a962 2
    sigproc_printf ("not calling sig_dispatch_pending.  sigtid %p current %p",
		    sigtid, GetCurrentThreadId ());
d966 9
d976 1
a976 1
sig_handle (int sig, sigset_t mask)
d992 2
d995 4
a998 1
      && (sigismember (&mask, sig) || main_vfork->pid
d1002 4
a1005 1
      return -1;
d1008 3
a1010 1
  int rc = 1;
d1014 2
a1015 1
  void *handler = (void *) thissig.sa_handler;
a1018 4
  /* Clear pending SIGCONT on stop signals */
  if (sig == SIGSTOP || sig == SIGTSTP || sig == SIGTTIN || sig == SIGTTOU)
    sig_clear (SIGCONT);

d1033 2
d1069 1
a1069 1
  rc = setup_handler (sig, handler, thissig);
d1075 6
d1118 1
a1118 1
    if (m->unstable () || m->owner () == mainthread.id)
a1164 1
  debug_printf ("cygwin_hmodule %p", cygwin_hmodule);
d1175 1
a1175 1
static int __stdcall
d1178 2
a1179 1
  if (!sigsave.sig)
d1181 17
a1197 2
      sigproc_printf ("call_signal_handler_now called when no signal active");
      return 0;
a1199 4
  int sa_flags = sigsave.sa_flags;
  sigproc_printf ("sa_flags %p", sa_flags);
  *sigsave.retaddr_on_stack = sigsave.retaddr;
  sigdelayed0 ();
a1201 11
/* This kludge seems to keep a copy of call_signal_handler_now around
   even when compiling with -finline-functions. */
static int __stdcall call_signal_handler_now_dummy ()
  __attribute__((alias ("call_signal_handler_now")));
};

int
sigframe::call_signal_handler ()
{
  return unregister () ? call_signal_handler_now () : 0;
}
a1203 1
extern "C" {
a1208 75
}

#undef errno
#define errno ((DWORD volatile) _impure_ptr) + (((char *) &_impure_ptr->_errno) - ((char *) _impure_ptr))

__attribute__((const, used, noinline)) static void
unused_sig_wrapper ()
{
/* Signal cleanup stuff.  Cleans up stack (too bad that we didn't
   prototype signal handlers as __stdcall), calls _set_process_mask
   to restore any mask, restores any potentially clobbered registers
   and returns to original caller. */
__asm__ volatile ("\n\
	.text								\n\
_sigreturn:								\n\
	addl	$4,%%esp	# Remove argument			\n\
	call	_set_process_mask@@4					\n\
									\n\
	cmpl	$0,%4		# Did a signal come in?			\n\
	jz	1f		# No, if zero				\n\
	movl	%2,%%eax						\n\
	movl	%8,%%ebx	# Where return address lives		\n\
	movl	%%eax,(%%ebx)	# Restore return address of		\n\
				# most recent caller			\n\
	jmp	3f							\n\
									\n\
1:	popl	%%eax		# saved errno				\n\
	testl	%%eax,%%eax	# Is it < 0				\n\
	jl	2f		# yup.  ignore it			\n\
	movl	%1,%%ebx						\n\
	movl	%%eax,(%%ebx)						\n\
2:	popl	%%eax							\n\
	popl	%%ebx							\n\
	popl	%%ecx							\n\
	popl	%%edx							\n\
	popl	%%edi							\n\
	popl	%%esi							\n\
	popf								\n\
	popl	%%ebp							\n\
	ret								\n\
									\n\
__no_sig_start:								\n\
_sigdelayed:								\n\
	pushl	%2			# original return address	\n\
_sigdelayed0:								\n\
	pushl	%%ebp							\n\
	movl	%%esp,%%ebp						\n\
	pushf								\n\
	pushl	%%esi							\n\
	pushl	%%edi							\n\
	pushl	%%edx							\n\
	pushl	%%ecx							\n\
	pushl	%%ebx							\n\
	pushl	%%eax							\n\
	pushl	%6			# saved errno			\n\
3:	pushl	%3			# oldmask			\n\
	pushl	%4			# signal argument		\n\
	pushl	$_sigreturn						\n\
									\n\
	call	_reset_signal_arrived@@0					\n\
	pushl	%5			# signal number			\n\
	pushl	%7			# newmask			\n\
									\n\
	call	_set_process_mask@@4					\n\
	movl	$0,%0			# zero the signal number as a	\n\
					# flag to the signal handler thread\n\
					# that it is ok to set up sigsave\n\
	popl	%%eax							\n\
	jmp	*%%eax							\n\
__no_sig_end:								\n\
" : "=m" (sigsave.sig)/*0*/:  "X" ((char *) &_impure_ptr->_errno)/*1*/,
  "g" (sigsave.retaddr)/*2*/, "g" (sigsave.oldmask)/*3*/, "g" (sigsave.sig)/*4*/,
    "g" (sigsave.func)/*5*/, "g" (sigsave.saved_errno)/*6*/, "g" (sigsave.newmask)/*7*/,
    "g" (sigsave.retaddr_on_stack)/*8*/
);
@


1.173
log
@	* external.cc (cygwin_internal): Add CW_GET_POSIX_SECURITY_ATTRIBUTE
	handling.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add
	CW_GET_POSIX_SECURITY_ATTRIBUTE.

	* exceptions.cc (init_global_security): Move from here...
	* sec_helper.cc (init_global_security): ...to here.
@
text
@d31 1
a31 1
char debugger_command[2 * MAX_PATH + 20];
d144 2
a145 2
  char pgm[MAX_PATH + 1];
  if (!GetModuleFileName (NULL, pgm, MAX_PATH))
d1128 1
a1128 1
  char mutex_name[MAX_PATH];
@


1.172
log
@	* exceptions.cc (ctrl_c_handler): Don't send SIGHUP on
	CTRL_LOGOFF_EVENT to processes running in invisible Windows Stations.
	* window.cc (has_visible_window_station): New function.
	* winsup.h: Add declaration for has_visible_window_station.
@
text
@a128 14
void
init_global_security ()
{
  /* Initialize global security attribute stuff */

  sec_none.nLength = sec_none_nih.nLength =
  sec_all.nLength = sec_all_nih.nLength = sizeof (SECURITY_ATTRIBUTES);
  sec_none.bInheritHandle = sec_all.bInheritHandle = TRUE;
  sec_none_nih.bInheritHandle = sec_all_nih.bInheritHandle = FALSE;
  sec_none.lpSecurityDescriptor = sec_none_nih.lpSecurityDescriptor = NULL;
  sec_all.lpSecurityDescriptor = sec_all_nih.lpSecurityDescriptor =
    get_null_sd ();
}

@


1.171
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* pinfo.cc (pinfo::init): Do not give FILE_MAP_WRITE access to Everybody.
	* exceptions.cc (sig_handle_tty_stop): Do not create pinfo parent with
	PID_MAP_WRITE.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Ditto for pinfo p.
	* signal.cc (kill_worker): Ditto for pinfo dest.
@
text
@d15 2
d924 1
a924 2
  if (myself->ctty != -1
      && (type == CTRL_CLOSE_EVENT || (!saw_close && type == CTRL_LOGOFF_EVENT)))
d927 14
a940 3
	saw_close = true;
      sig_send (NULL, SIGHUP);
      return FALSE;
@


1.170
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d619 1
a619 1
      pinfo parent (myself->ppid, PID_MAP_RW);
@


1.169
log
@* exceptions.cc (sig_handle_tty_stop): Fix boneheaded mistake by using correct
check for parent state rather than inverted check.
@
text
@d14 1
d21 1
d971 3
a973 1
  if (!(oldmask & ~newmask))
a975 6
  else
    {
      extern bool pending_signals;
      pending_signals = true;
      sig_dispatch_pending ();
    }
d980 1
a980 1
sig_handle (int sig)
d982 22
d1006 1
a1006 2
  sigproc_printf ("signal %d", sig);

a1020 19

  /* FIXME: Should we still do this if SIGCONT has a handler? */
  if (sig == SIGCONT)
    {
      DWORD stopped = myself->process_state & PID_STOPPED;
      myself->stopsig = 0;
      myself->process_state &= ~PID_STOPPED;
      /* Clear pending stop signals */
      sig_clear (SIGSTOP);
      sig_clear (SIGTSTP);
      sig_clear (SIGTTIN);
      sig_clear (SIGTTOU);
      if (stopped)
	SetEvent (sigCONT);
      /* process pending signals */
#if 0 // FIXME?
      sig_dispatch_pending ();
#endif
    }
@


1.168
log
@* include/sys/cygwin.h: Rename PID_UNUSED to PID_MAP_RW.
* pinfo.cc (pinfo_init): Initialize myself->gid.
(pinfo::init): Create the "access" variable, set it appropriately and use it to
specify the requested access.
* exceptions.cc (sig_handle_tty_stop): Add PID_MAP_RW in pinfo parent.
* signal.cc (kill_worker): Ditto for pinfo dest.
* syscalls.cc (setpgid): Ditto for pinfo p.
@
text
@d618 1
a618 1
      if (NOTSTATE (parent, PID_NOCLDSTOP))
@


1.167
log
@* dcrt0.cc (_dll_crt0): Accommodate breaking apart of early_stuff_init.
* exceptions.cc (early_stuff_init): Delete.
(init_console_handler): New function - top half of early_stuff_init.
(init_global_security): New function - bottom half of early_stuff_init.
(sig_handle): Avoid special hExeced test for SIGINT.  Just terminate the
captive process.
(signal_exit): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't allocate a console if one
already seems to exist.  Properly initialize ctrl-c handling if we do allocate
a console.
* winsup.h (early_stuff_init): Delete declaration.
(init_console_handler): New declaration.
(init_global_security): New declaration.
@
text
@d617 1
a617 1
      pinfo parent (myself->ppid);
@


1.167.2.1
log
@* fhandler_disk_file.cc (path_conv::ndisk_links): Fix potential off-by-one
problem when first file in a directory is a directory.
* Makefile.in: Make malloc_wrapper -fomit-frame-pointer.
* cygwin.din: Remove extraneous mallinfo definition.
* dcrt0.cc (quoted): Use strechr for efficiency.
* exceptions.cc (sig_handle_tty_stop): Fix boneheaded mistake by using correct
check for parent state rather than inverted check.
* getopt.c (opterr): Reinstate initialization.
(optind): Ditto.
(optopt): Ditto.
@
text
@d618 1
a618 1
      if (ISSTATE (parent, PID_NOCLDSTOP))
@


1.166
log
@* exceptions.cc (sig_handle_tty_stop): Check parent PID_NOCLDSTOP rather than
erroneously checking *my own* sigtodo.
@
text
@d118 1
a118 1
early_stuff_init ()
d123 1
d125 3
d1031 1
a1031 1
	  || sig == SIGURG || (hExeced && sig == SIGINT))
d1114 4
a1117 1
    TerminateProcess (hExeced, rc);
@


1.165
log
@* dcrt0.cc (dlL_crt0_1): Set __argc_safe after __argc is absolutely know to be
set.
* exceptions.cc (sig_handle_tty_stop): Don't reset sigCONT event since it is
reset automatically.
* fork.cc (fork): Remove obsolete usage of PID_SPLIT_HEAP.
* include/sys/cygwin.h: Ditto.
* sigproc.cc (sig_send): Use sigframe init method to set frame since it checks
for previous ownership of the frame.
* sigproc.h (sigframe::init): Accept an "is_exception" argument.
@
text
@d614 1
a614 1
      if (!(parent->getsig (SIGCHLD).sa_flags & SA_NOCLDSTOP))
@


1.164
log
@* exceptions.cc (set_process_mask): Set pending signals only when signals
become unmasked.
* sigproc.cc (pending_signals): Flip back to a global.
(wait_sig): Don't set pending signals when there is an armed semaphore or
signal is blocked.
* shared.cc (shared_info::initialize): Add a username parameter for user-mode
mounts.  Reorganize to try to avoid startup race.
(memory_init): Move some stuff into shared_info::initialize.
* shared_info.h (shared_info::initialize): Change declaration.
(CURR_SHARED_MAGIC): Update.
@
text
@a620 1
  (void) ResetEvent (sigCONT);
d1050 1
a1050 1
 stop:
d1057 1
a1057 1
 dosig:
d1062 1
a1062 1
 done:
d1066 1
a1066 1
 exit_sig:
@


1.163
log
@* cygheap.cc (cygheap_init): Allocate space for sigaction array in cygheap.
* cygheap.h (cygheap_types): Add HEAP_SIGS.
* exceptions.cc (signal_fixup_after_exec): Remove from this file.
* pinfo.h (pinfo::getsig): Just return global_sigs array.
(pinfo::sigs): Delete.
* sigproc.cc (signal_fixup_after_exec): Move it here.
(global_sigs): New global array, moved from pinfo structure.
(sigalloc): New function.  Allocate global sigaction array here.
(proc_subproc): Remove copysigs call.  It's automatic now.
* include/sys/cygwin.h (PID_NOCLDSTOP): New value.
* signal.cc (sigaction): Set myself->PID_NODCLDSTOP when appropriate.
* sigproc.h (sigalloc): Declare.
* fnmatch.c (fnmatch): Use C90 parameters.
(rangematch): Ditto.
* fhandler.cc (fhandler_base::raw_read): Use right coercion to avoid a compiler
warning.
@
text
@d966 1
a966 3
  if (oldmask != newmask)
    sig_dispatch_pending ();
  else
d969 6
@


1.162
log
@* Makefile.in (MALLOC_OFILES): Always fill in with correct malloc object.
* configure.in: Fill in MALLOC_OFILES with either debugging or regular malloc.
* configure: Regenerate.
* dlmalloc.c: Make various fruitless changes to attempt to get to work.
* dlmalloc.h: Ditto.
* malloc.cc (free): Check malloc pool when debugging.
* path.cc (win32_device_name): Eliminate compiler warning.
* sigproc.cc (sig_dispatch_pending): Remove use of was_pending.  Let
thisframe.call_signal_handler decide if handler should be called rather than
using bogus was_pending check.
* exceptions.cc (interrupt_setup): Remove accidentally checked in debugging
code.
* heap.cc (sbrk): Save rounded addess in user_heap_max.
@
text
@a733 12
void __stdcall
signal_fixup_after_exec ()
{
  /* Set up child's signal handlers */
  for (int i = 0; i < NSIG; i++)
    {
      myself->getsig (i).sa_mask = 0;
      if (myself->getsig (i).sa_handler != SIG_IGN)
	myself->getsig (i).sa_handler = SIG_DFL;
    }
}

@


1.161
log
@* sigproc.cc (sig_dispatch_pending): Remove explicit call to
thisframe.call_signal_handler.
@
text
@a690 1
small_printf ("retaddr_on_stack %p\n", retaddr_on_stack);
@


1.160
log
@* exceptions.cc (sigreturn): Fix problem where old return address was not
properly restored for a nested signal.
@
text
@d691 1
@


1.159
log
@* syscalls.cc (mount): Don't check win32_path when doing cygdrive mount.
@
text
@d1222 3
a1224 1
	movl	%%eax,36(%%esp)	# Restore return address		\n\
d1271 4
a1274 4
" : "=m" (sigsave.sig):  "X" ((char *) &_impure_ptr->_errno),
  "g" (sigsave.retaddr), "g" (sigsave.oldmask), "g" (sigsave.sig),
    "g" (sigsave.func), "g" (sigsave.saved_errno), "g" (sigsave.newmask),
    "g" (sigsave.retaddr_on_stack)
@


1.158
log
@* exceptions.cc (sigreturn): Don't clobber ebp in recursive signal calls.
@
text
@a787 1
  int prio = INFINITE;
d790 1
a790 1
    goto set_pending;
d825 1
d827 10
a878 7
      if ((DWORD) prio != INFINITE)
	{
	  /* Reset the priority so we can finish this off quickly. */
	  SetThreadPriority (GetCurrentThread (), WAIT_SIG_PRIORITY);
	  prio = INFINITE;
	}

a893 2
      if ((DWORD) prio != INFINITE && !mainthread.frame)
	prio = low_priority_sleep (SLEEP_0_STAY_LOW);
d897 2
a898 9
 set_pending:
  if (interrupted)
    {
      if ((DWORD) prio != INFINITE)
	SetThreadPriority (GetCurrentThread (), WAIT_SIG_PRIORITY);
      sigproc_printf ("signal successfully delivered");
    }

  sigproc_printf ("returning %d", interrupted);
@


1.157
log
@* exceptions.cc (sig_handle): Change so that default signals indicate success.
@
text
@d1228 1
a1228 2
	movl	%%esp,%%ebp						\n\
	movl	%%eax,36(%%ebp)	# Restore return address		\n\
d1277 2
a1278 1
    "g" (sigsave.func), "g" (sigsave.saved_errno), "g" (sigsave.newmask)
@


1.156
log
@* exceptions.cc (interrupt_setup): Set sigsave.sig last to avoid a race.
@
text
@d995 1
a995 1
  int rc = 0;
@


1.155
log
@* sigproc.cc (wait_sig): Ensure that myself->getsigtodo array is flushed on a
__SIGFLUSH.  Christopher Faylor <cgf@@redhat.com>
* exceptions.cc (_sigreturn): Handle nested signals without growing the stack.
@
text
@a695 1
  sigsave.sig = sig;
d705 1
@


1.154
log
@* exceptions.cc (pending_signals): Remove unneeded declaration.
* sigproc.cc (pending_signals): Make static.
(wait_sig): Use defined values rather than integers for rc.  Never scan both
todo arrays as this could cause hangs if signals arrive from two different
sources.  Rename saw_pending_signals to saw_failed_interrupt.  Exit loop when
signal found.  Enter low-priority sleep, if necessary, after finished
signalling completion.  Set pending_signals when blocked
(from Pierre Humblet).
@
text
@a1222 2
	movl	%%esp,%%ebp						\n\
	addl	$36,%%ebp						\n\
d1227 4
a1230 1
	call	_call_signal_handler_now@@0 # yes handle the signal	\n\
d1261 1
a1261 1
	pushl	%3			# oldmask			\n\
@


1.153
log
@Throughout, eliminate argument to sig_dispatch_pending.
* exceptions.cc (setup_handler): Move non-interruptible condition handling
(back) to wait_sig (as suggested by Pierre Humblet).
(set_process_mask): Don't worry about calling sig_dispatch_pending from
sigthread since it is detected in the function anyway.
(sig_handle): Eliminate thisproc arg.  Don't call sig_dispatch_pending on
SIGCONT since that should happen automatically.
* sigproc.cc (sig_dispatch_pending): Eliminate justwake argument.  Just return
when called from sigthread.
(wait_sig): Change some variables to bool.  Change inner while to an if.  Move
uninterruptible signal handling here.
(sigproc_terminate): Don't call sig_dispatch_pending.  Just increment semaphore
on exit.
* speclib: Use slightly different (but still flawed) method for determining
symbols to extract from libraries.
@
text
@a593 1
extern int pending_signals;
@


1.152
log
@* exceptions.cc (sigdelayed): Fix race where signal handler could get the wrong
mask.
@
text
@d572 1
a572 1
  sig_dispatch_pending (0);
a903 8
  else
    {
      pending_signals = 1;	/* FIXME: Probably need to be more tricky here */
      sig_set_pending (sig);
      sig_dispatch_pending (1);
      low_priority_sleep (SLEEP_0_STAY_LOW);	/* Hopefully, other process will be waking up soon. */
      sigproc_printf ("couldn't send signal %d", sig);
    }
d985 1
a985 1
  if (oldmask != newmask && GetCurrentThreadId () != sigtid)
d994 1
a994 1
sig_handle (int sig, bool thisproc)
d1029 3
a1031 1
      sig_dispatch_pending (1);
d1043 1
a1043 1
	  || sig == SIGURG || (thisproc && hExeced && sig == SIGINT))
@


1.151
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d1274 2
a1278 2
									\n\
	call	_set_process_mask@@4					\n\
@


1.150
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d926 1
a926 2
  if (type == CTRL_LOGOFF_EVENT)
    return TRUE;
d931 1
d936 1
a936 1
         processes will receive this event and the services typically already
d943 3
a945 1
  if (type == CTRL_CLOSE_EVENT)
d947 2
@


1.149
log
@	* exceptions.cc (ctrl_c_handler): Don't send a signal on
	CTRL_SHUTDOWN_EVENT.  Add a comment to rationalize the patch.
@
text
@a12 1
#include <errno.h>
@


1.148
log
@	* spawn.cc (spawn_guts): Call CreateProcess while impersonated,
	when the real {u,g}ids and the groups are original.
	Move RevertToSelf and ImpersonateLoggedOnUser to the main line.
	* uinfo.cc (uinfo_init): Reorganize. If CreateProcess was called
	while impersonated, preserve the uids and gids and call
	ImpersonateLoggedOnUser. Preserve the uids and gids on Win9X.

	* exceptions.cc (error_start_init): Quote the pgm in the command.
@
text
@d935 5
d941 1
@


1.147
log
@* cygheap.cc (init_cheap): Temporarily remove inline that newer gcc's have
problems with.
* path.cc (path_conv::check): Rework has_acls logic slightly.  Uncouple exec
tests away from filesystem tests.
@
text
@d157 1
a157 1
  __small_sprintf (debugger_command, "%s %s", buf, pgm);
@


1.146
log
@	* shared_info.h: Match shared_name declaration with below change.
	* shared.cc (shared_name): Use incoming char * parameter instead of
	local static buffer.
	(open_shared): Accomodate new calling convention for shared_name.
	* exceptions.cc (events_init): Ditto.
	* sigproc.cc (getsem): Ditto.
	* syscalls.cc (login): Ditto.
	(logout): Ditto.
	(pututline): Ditto.
@
text
@d611 2
a612 3
   * It will figure out exactly which pid has stopped by scanning
   * its list of subprocesses.
   */
@


1.145
log
@
* Makefile.in: Add finline-functions optimization to CXXFLAGS.
* autoload.cc (LoadDLLprime): Rename std_dll_init to
_std_dll_init.
(std_dll_init): Remove name mangling prototype. Add attributes
used and noinline.
(wsock_init): Ditto.
Change wsock_init to _wsock_init in wsock32 and ws2_32
LoadDLLprime.
* exceptions.cc (unused_sig_wrapper): Remove prototype. Add
attributes used and noinline.
* pwdgrp.h ((pwdgrp (passwd *&)): Remove inline code.
(pwdgrp (__group32 *&)): Ditto.
* grp.cc (pwdgrp (passwd *&)): Outline constructor.
(pwdgrp (__group32 *&)): Ditto.
@
text
@d1137 1
d1142 2
a1143 1
				   name = shared_name ("title_mutex", 0))))
@


1.144
log
@* exceptions.cc (setup_handler): Make sure winapi lock is released when exiting
loop.
@
text
@a1205 2
static void unused_sig_wrapper () __attribute__((const, unused));

d1209 1
a1209 1
static void
@


1.143
log
@* sigproc.h (signal_fixup_after_exec): Eliminate argument in declaration.
* exceptions.cc (signal_fixup_after_exec): Eliminate argument in definition.
Don't reset signal handlers after spawm.  Just treat like fork/exec.
* dcrt0.cc (dll_crt0_1): Don't pass PROC_SPAWN argument to
signal_fixup_after_exec.
* syscalls.cc (unlink): Don't change attributes of file if not readonly/system.
Ditto for resetting of arguments.
@
text
@d839 1
@


1.142
log
@* exceptions.cc (try_to_debug): Don't reset priority when returning from
non-waitloop call.
@
text
@d738 1
a738 1
signal_fixup_after_exec (bool isspawn)
d744 1
a744 1
      if (myself->getsig (i).sa_handler != SIG_IGN || isspawn)
@


1.141
log
@Christopher Faylor <cgf@@redhat.com>
* exceptions.cc (try_to_debug): Set priority of current thread rather than the
main thread.  Make busy waiting loop less busy.  Restore priority when function
returns.
@
text
@a394 1
      SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
d397 1
d402 1
a403 2

  SetThreadPriority (GetCurrentThread (), prio);
@


1.140
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d346 2
a347 1
  SetThreadPriority (hMainThread, THREAD_PRIORITY_HIGHEST);
d395 1
a395 1
      SetThreadPriority (hMainThread, THREAD_PRIORITY_IDLE);
d399 2
a400 2
	/* spin */;
      Sleep (4000);
d403 2
@


1.139
log
@Apply handle_sigsuspend patch
@
text
@d243 1
a243 1
  int operator ++(int) { return this->walk (); }
@


1.139.2.1
log
@merge from trunk
@
text
@d243 1
a243 1
  int operator ++(int) { return walk (); }
@


1.139.2.2
log
@merge from trunk
@
text
@d346 1
a346 2
  LONG prio = GetThreadPriority (GetCurrentThread ());
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST);
d394 1
a394 1
      SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
d398 2
a399 2
	Sleep (0);
      Sleep (2000);
a401 2

  SetThreadPriority (GetCurrentThread (), prio);
@


1.139.2.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d395 1
a397 1
      SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
a401 1
      SetThreadPriority (GetCurrentThread (), prio);
d403 2
@


1.139.2.4
log
@merge from trunk
@
text
@d738 1
a738 1
signal_fixup_after_exec ()
d744 1
a744 1
      if (myself->getsig (i).sa_handler != SIG_IGN)
@


1.139.2.5
log
@merge from trunk
@
text
@a838 1
	      mainthread.release_winapi_lock ();
@


1.139.2.6
log
@merge from trunk
@
text
@d1206 2
d1211 1
a1211 1
__attribute__((const, used, noinline)) static void
@


1.139.2.7
log
@merge from trunk
@
text
@a1136 1
  char mutex_name[MAX_PATH];
d1141 1
a1141 2
				   name = shared_name (mutex_name,
						       "title_mutex", 0))))
@


1.139.2.8
log
@merge from trunk
@
text
@d611 3
a613 2
     It will figure out exactly which pid has stopped by scanning
     its list of subprocesses.  */
@


1.139.2.9
log
@merge from trunk
@
text
@d13 1
d157 1
a157 1
  __small_sprintf (debugger_command, "%s \"%s\"", buf, pgm);
a934 5
#if 0
      /* Don't send a signal.  Only NT service applications and their child
         processes will receive this event and the services typically already
	 handle the shutdown action when getting the SERVICE_CONTROL_SHUTDOWN
	 control message. */
a935 1
#endif
@


1.139.2.10
log
@merge from trunk
@
text
@d926 2
a927 1
  static bool saw_close;
a931 1

d936 1
a936 1
	 processes will receive this event and the services typically already
d943 1
a943 3

  if (myself->ctty != -1
      && (type == CTRL_CLOSE_EVENT || (!saw_close && type == CTRL_LOGOFF_EVENT)))
a944 2
      if (type == CTRL_CLOSE_EVENT)
	saw_close = true;
@


1.139.2.11
log
@merge from trunk
@
text
@d572 1
a572 1
  sig_dispatch_pending ();
d594 1
d697 1
a706 1
  sigsave.sig = sig;			// Should ALWAYS be last thing set to avoid a race
d904 8
d993 1
a993 1
  if (oldmask != newmask)
d1002 1
a1002 1
sig_handle (int sig)
d1004 1
a1004 1
  int rc = 1;
d1037 1
a1037 3
#if 0 // FIXME?
      sig_dispatch_pending ();
#endif
d1049 1
a1049 1
	  || sig == SIGURG || (hExeced && sig == SIGINT))
d1230 2
d1236 1
a1236 3
	movl	%2,%%eax						\n\
	movl	%%eax,36(%%esp)	# Restore return address		\n\
	jmp	3f							\n\
d1267 1
a1267 1
3:	pushl	%3			# oldmask			\n\
a1273 2
									\n\
	call	_set_process_mask@@4					\n\
d1277 2
d1284 1
a1284 2
    "g" (sigsave.func), "g" (sigsave.saved_errno), "g" (sigsave.newmask),
    "g" (sigsave.retaddr_on_stack)
@


1.139.2.12
log
@merge from trunk
@
text
@d734 12
d788 1
d791 1
a791 1
    goto out;
a825 1
#ifndef DEBUGGING
a826 10
#else
	  cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	  if (!GetThreadContext (hth, &cx))
	    memset (&cx, 0, sizeof cx);
#if 0
	  if ((cx.Eip & 0xff000000) == 0x77000000)
	    try_to_debug ();
#endif
	  sigproc_printf ("suspending mainthread PC %p", cx.Eip);
#endif
d869 7
d891 2
d896 9
a904 2
out:
  sigproc_printf ("signal %d %sdelivered", sig, interrupted ? "" : "not ");
d1228 1
a1228 3
	movl	%8,%%ebx	# Where return address lives		\n\
	movl	%%eax,(%%ebx)	# Restore return address of		\n\
				# most recent caller			\n\
d1275 4
a1278 4
" : "=m" (sigsave.sig)/*0*/:  "X" ((char *) &_impure_ptr->_errno)/*1*/,
  "g" (sigsave.retaddr)/*2*/, "g" (sigsave.oldmask)/*3*/, "g" (sigsave.sig)/*4*/,
    "g" (sigsave.func)/*5*/, "g" (sigsave.saved_errno)/*6*/, "g" (sigsave.newmask)/*7*/,
    "g" (sigsave.retaddr_on_stack)/*8*/
@


1.139.2.13
log
@merge from trunk
@
text
@a13 1
#include <setjmp.h>
a19 1
#define NEED_VFORK
d614 1
a614 1
      if (NOTSTATE (parent, PID_NOCLDSTOP))
d621 1
d966 1
a966 1
  if (oldmask & ~newmask)
d975 1
a975 1
sig_handle (int sig, sigset_t mask)
d977 1
a977 13
  if (sig == SIGCONT)
    {
      DWORD stopped = myself->process_state & PID_STOPPED;
      myself->stopsig = 0;
      myself->process_state &= ~PID_STOPPED;
      /* Clear pending stop signals */
      sig_clear (SIGSTOP);
      sig_clear (SIGTSTP);
      sig_clear (SIGTTIN);
      sig_clear (SIGTTOU);
      if (stopped)
	SetEvent (sigCONT);
    }
d979 1
a979 7
  if (sig != SIGKILL && sig != SIGSTOP
      && (sigismember (&mask, sig) || main_vfork->pid
	  || ISSTATE (myself, PID_STOPPED)))
    {
      sigproc_printf ("signal %d blocked", sig);
      return -1;
    }
a980 3
  int rc = 1;

  sigproc_printf ("signal %d processing", sig);
d996 19
d1047 1
a1047 1
stop:
d1054 1
a1054 1
dosig:
d1059 1
a1059 1
done:
d1063 1
a1063 1
exit_sig:
@


1.139.2.14
log
@merge from trunk
@
text
@d120 1
a120 1
init_console_handler ()
a124 1
}
a125 3
void
init_global_security ()
{
d615 1
a615 1
      pinfo parent (myself->ppid, PID_MAP_RW);
d1027 1
a1027 1
	  || sig == SIGURG)
d1110 1
a1110 4
    {
      sigproc_printf ("terminating captive process");
      TerminateProcess (hExeced, rc);
    }
@


1.138
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d579 2
a580 1
  WaitForSingleObject (signal_arrived, INFINITE);
@


1.137
log
@* dtable.h (dtable::in_vfork_cleanup): New function.  True if vfork cleanup
needed.
* dtable.cc (dtable::vfork_parent_restore): Remove assertion.
* pipe.cc (fhandler_pipe::close): Don't close read_state during fork_fixup
since it wasn't inherited.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.136
log
@* exceptions.cc (events_init): Display name of mutex on failure.
@
text
@d1133 1
a1133 1
  /* title_mutex protects modification of console title. It's neccessary
@


1.135
log
@* exceptions.cc (events_init): Initialize critical section to control exiting
via signal.
(signal_exit): Enter critical section early to avoid exit races with main
thread.
* dcrt0.cc (do_exit): Use exit_lock critical section to avoid races.
@
text
@d1132 1
d1137 2
a1138 2
				   shared_name ("title_mutex", 0))))
    api_fatal ("can't create title mutex, %E");
@


1.135.4.1
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
* exceptions.cc (events_init): Display name of mutex on failure.
* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@a1131 1
  char *name;
d1136 2
a1137 2
				   name = shared_name ("title_mutex", 0))))
    api_fatal ("can't create title mutex '%s', %E", name);
@


1.135.4.2
log
@* dtable.h (dtable::in_vfork_cleanup): New function.  True if vfork cleanup
needed.
* dtable.cc (dtable::vfork_parent_restore): Remove assertion.
* pipe.cc (fhandler_pipe::close): Don't close read_state during fork_fixup
since it wasn't inherited.
@
text
@d1133 1
a1133 1
  /* title_mutex protects modification of console title. It's necessary
@


1.134
log
@* cygthread.h (cygthread::stack_ptr): New element.
(cygthread::detach): Accept a "wait_for_signal" argument.
(cygthread::terminate_thread): New function.
* cygthread.cc (cygthread::stub): Set stack pointer argument.
(cygthread::terminate_thread): New function.  Forcibly terminate thread.
(cygthread::detach): Optionally wait for signals and kill thread when signal
arrives.
* exceptions.cc (signal_exit): Set signal_arrived prior to exiting to wake up
anything blocking on signals.
* fhandler.h (fhandler_base::set_r_no_interrupt): Change to accept bool
argument.
(fhandler_pipe::ready_for_read): Declare.
* pipe.cc (pipeargs): New structure.
(read_pipe): New thread stub wrapper for normal pipe read.
(fhandler_pipe::read): Modify to call reader in a cygthread, terminating on
signal, as appropriate.
* select.cc (fhandler_pipe::ready_for_read): Define new function.
@
text
@d1091 2
d1099 1
d1155 1
@


1.133
log
@* exceptions.cc (handle_sigsuspend): Force pending signal delivery before
waiting for signals to happen.
* signal.cc (sleep): Force pending signal delivery before sleeping.
(usleep): Ditto.
(signal): Force pending signal delivery before manipulating signal stuff.
(sigprocmask): Ditto.
(kill_worker): Ditto.
(abort): Ditto.
(sigaction): Ditto.
* syscalls.cc (readv): Force pending signal delivery before I/O.
(writev): Ditto.
(open): Ditto.
* net.cc: Ditto, throughout.
* sigproc.cc (sig_dispatch_pending): Deliver any pending signals prior to
returning.
* tty.cc (tty::make_pipes): Increase pipe buffer size.
@
text
@d1120 1
@


1.132
log
@* exceptions.cc (sigthread::get_winapi_lock): Just do standard 'give up
timeslice' wait.
(setup_handler): Revamp YA to attempt to deliver signal multiple times on
failure rather than punting to wait_sig.
* miscfuncs.cc (low_priority_sleep): Accept INFINITE sleep to mean "don't reset
the priority after setting it to idle".  Return previous priority.
* winsup.h (SLEEP_0_STAY_LOW): Define.
(low_priority_sleep): Return an int.
* sigproc.h: Define WAIT_SIG_PRIORITY here.
* sigproc.cc: Remove WAIT_SIG_PRIORITY definition.
@
text
@d571 1
@


1.131
log
@* exceptions.cc (setup_handler): Add debugging output.  Set thread priority to
idle if pending signals to allow other threads to get into interruptible state.
* miscfuncs.cc (sys_mbstowcs): Save current thread in variable to avoid an OS
call.
* wait.cc (wait_sig): Reset thread priority each time through loop since the
priority may have been set down to deal with pending signals.
@
text
@d669 1
a669 1
    low_priority_sleep (1);
d785 1
a785 3
  bool interrupted = 0;
  HANDLE hth = NULL;
  int res;
d787 1
d792 1
a792 1
  for (int i = 0; !interrupted && i < CALL_HANDLER_RETRY; i++)
d794 3
d799 4
a802 1
	th = &mainthread;
d807 2
a808 1
	  th = NULL;
d811 1
d821 2
a822 2
	     If the thread is already suspended (which can occur when a program is stopped) then
	     just queue the signal. */
d824 1
a824 2
	  if (!mainthread.get_winapi_lock (1))
	    continue;
d827 4
a830 3
	  mainthread.release_winapi_lock ();
	  if (mainthread.frame)
	    goto resume_thread;	/* In case the main thread *just* set the frame */
d834 10
a843 1
	    goto set_pending;
a853 1
	  EnterCriticalSection (&mainthread.lock);
d855 2
d858 6
a863 2
	      th = &mainthread;
	      goto try_to_interrupt;
d865 1
d867 5
a871 15
	  LeaveCriticalSection (&mainthread.lock);

	  cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	  if (!GetThreadContext (hth, &cx))
	    system_printf ("couldn't get context of main thread, %E");
	  else if (!interruptible (cx.Eip, 1))
	    sigproc_printf ("suspended thread in a strange state pc %p, sp %p",
			    cx.Eip, cx.Esp);
	  else
	    goto try_to_interrupt;

	resume_thread:
	  ResumeThread (hth);
	  low_priority_sleep (0);
	  continue;
a873 1
    try_to_interrupt:
d880 7
a886 8
	{
	  interrupted = interrupt_now (&cx, sig, handler, siga);
#ifdef DEBUGGING
	  if (!interrupted)
	    sigproc_printf ("couldn't deliver signal %d via %p", sig, cx.Eip);
#endif
	}
      else
d888 4
d896 5
a900 1
    res = 1;
d906 1
a906 1
      low_priority_sleep (0);	/* Hopefully, other process will be waking up soon. */
a909 8
  if (!hth)
    sigproc_printf ("good.  Didn't suspend main thread, th %p", th);
  else
    {
      res = ResumeThread (hth);
      sigproc_printf ("ResumeThread returned %d", res);
    }

a910 2
  if (pending_signals)
    SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
@


1.130
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d640 1
a640 1
     GetThreadContext.  These resolve to an allocation base == 0.
d869 7
a875 1
	interrupted = interrupt_now (&cx, sig, handler, siga);
d901 2
@


1.129
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::heaptop): Remove obsolete element.
(child_info_fork::heabbase): Ditto.
(child_info_fork::heapptr): Ditto.
(child_info_fork::mount_table): New element.
(child_info_fork::myself_addr): Ditto.
* dcrt0.cc (dll_crt0_1): Set mount_table and myself_addr when forking.
(initial_env): Add newline to "sleeping" message.
* dll_init.cc (reserve_upto): Accommodate cygwin heap when freeing memory.
Make debugging output a little more descriptive.
* fork.cc (fork_parent): Save mount_table and myself_addr.
* pinfo.cc (myself_addr): New variable.
(set_myself): Pass PID_MYSELF flag to init.
(pinfo::Init): Honor PID_MYSELF.  Save address where myself shared memory
resides in myself_addr, for fork.
* pinfo.h (myself_addr): Declare.
* shared.cc (memory_init): On fork, use previously saved address for location
of mount table.
* include/sys/cygwin.h (PID_MYSELF): New value.
* dtable.cc (dtable::stdio_init): Don't pass access type to
init_std_file_from_handle.  It's always the same.
(dtable::init_std_file_from_handle): Remove access type argument.  Assume
read/write.
* dtable.h (dtable::init_std_file_from_handle): Ditto for declaration.
* exceptions.cc (try_to_debug): Don't try to debug if already being debugged.
* fhandler_console.cc (shared_console_info_save): New variable.
(fhandler_console::get_tty_stuff): Save address of shared console stuff for
fork.
@
text
@d669 1
a669 1
    Sleep (1);
d858 1
a858 1
	  Sleep (0);
d882 1
a882 1
      Sleep (0);		/* Hopefully, other process will be waking up soon. */
@


1.128
log
@* cygthread.cc (cygthread::stub): Don't create event for long-running threads.
Initialize thread_sync event here which is used to Suspend using an event
rather than relying on SuspendThread/ResumeThread.
(cygthread::init): Save handle to runner thread for future termination.
(cygthread::cygthread): Only resume thread when it is actually suspended.
Otherwise signal thread completion event.
(cygthread::terminate): Forcibly terminate runner thread and any helper
threads.  Call DisableThreadLibrary calls if execing.
* cygthread.h (cygthread::thread_sync): Declare.
* dcrt0.cc (do_exit): Eliminate calls to obsolete window_terminate and
shared_terminate.
* exceptions.cc (events_terminate): Don't bother closing title_mutex since it
is going away anyway.
* pinfo.cc (_pinfo::exit): Call cygthread::terminate to ensure that threads are
shut down before process exit or otherwise strange races seem to occur.
* shared.cc (shared_terminate): Eliminate.
* shared.h (shared_terminate): Eliminate declaration.
* winsup.h (window_terminate): Eliminate declaration.
* spawn.cc (spawn_guts): Call cygthread::terminate early in process if execing.
Call DisableThreadLibrary calls if execing.
* window.cc (Winmain): Call ExitThread to force exit.
(window_terminate): Eliminate.
* dcrt0.cc (do_exit): Track exit state more closely.
@
text
@d341 1
a341 1
  if (*debugger_command == '\0')
@


1.127
log
@* cygthread.cc (cygthread::stub): Very minor cleanup.
(cygthread::stub): Report overflows in cygwin thread pool when DEBUGGING is on
and special environment variable is not set.
(cygthread::terminate): Set event only when event actually exists.
* exceptions.cc (signal_exit): Set priority of main thread to low before
setting current thread to high.
@
text
@a1138 1
  ForceCloseHandle (title_mutex);
@


1.126
log
@* exceptions.cc (unused_sig_wrapper): Still need additional level of
indirection when setting errno.
@
text
@d1087 1
a1088 1
  (void) SetThreadPriority (hMainThread, THREAD_PRIORITY_IDLE);
a1168 1

@


1.125
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d1208 2
a1209 1
	movl	%%eax,%1						\n\
d1249 1
a1249 1
" : "=m" (sigsave.sig):  "X" (errno),
@


1.124
log
@* exceptions.cc (unused_sig_wrapper): Accommodate newer compilers.
@
text
@d768 1
a768 1
  sigproc_printf ("couldn't find a stack frame, i %d\n", i);
@


1.123
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d1181 7
a1187 1
void unused_sig_wrapper ()
d1208 1
a1208 2
	movl	%1,%%ebx						\n\
	movl	%%eax,(%%ebx)						\n\
d1248 1
a1248 1
" : "=m" (sigsave.sig) : "m" (&_impure_ptr->_errno),
@


1.122
log
@* sigproc.cc (sigCONT): Define.
* sigproc.h (sigCONT): Declare.
(wait_sig): Create sigCONT event here.
* exceptions.cc (sig_handle_tty_stop): Wait for sigCONT event rather than
stopping thread.
(sig_handle): Set sigCONT event as appropriate on SIGCONT rather than calling
ResumeThread.
@
text
@d739 3
a741 3
      myself->getsig(i).sa_mask = 0;
      if (myself->getsig(i).sa_handler != SIG_IGN || isspawn)
	myself->getsig(i).sa_handler = SIG_DFL;
@


1.121
log
@* exceptions.cc (interrupt_setup): Ensure that the previous signal mask is
properly saved.
@
text
@d618 3
a620 1
  SuspendThread (hMainThread);
d997 1
d1005 2
a1006 4
      /* Windows 95 hangs on resuming non-suspended thread */
      SuspendThread (hMainThread);
      while (ResumeThread (hMainThread) > 1)
	;
@


1.120
log
@* assert.cc (__assert): Call debugger on assertion failure if debugging.
* dcrt0.cc (dll_crt0_1): Just wait for signal thread to go live rather than
going through the overhead of invoking it.
* fork.cc (fork_child): Ditto.
* exceptions.cc (signal_fixup_after_fork): Call sigproc_init here.
* sigproc.cc (proc_can_be_signalled): Assume that the signal thread is live.
(sig_dispatch): Ditto.
(sig_send): Ditto.
(wait_for_sigthread): Renamed from "wait_for_me".  Assume that wait_sig_inited
has been set and that this function is only called from the main thread.
* winsup.h (wait_for_sigthread): Declare new function.
@
text
@d689 2
a690 1
  sigsave.newmask = myself->getsigmask () | siga.sa_mask | SIGTOMASK (sig);
@


1.119
log
@* path.cc (path_conv::check): Always set fileattr when component == 0.
(readlink): Use path_conv method rather than field.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto, throughout.
* path.h (path_conv): Make fileattr private.
* exceptions.cc (try_to_debug): Default to idle priority when looping.
@
text
@d718 1
a718 5
  if (!sigsave.sig)
    return;

  sigsave.sig = 0;
  if (sigsave.retaddr_on_stack)
d720 6
a725 2
      *sigsave.retaddr_on_stack = sigsave.retaddr;
      set_process_mask (sigsave.oldmask);
d727 1
@


1.118
log
@* dcrt0.cc (initial_env): Force path and CYGWIN_DEBUG contents to lower case.
* exceptions.cc (error_start_init): Use the name derived from GetModuleName
rather than myself->progname.
@
text
@d394 1
a396 1
      SetThreadPriority (hMainThread, THREAD_PRIORITY_IDLE);
@


1.117
log
@* dcrt0.cc (dll_crt0_1): Move debug_init call back to here.  Avoid a compiler
warning.
* shared.cc (memory_init): Remove debug_init call.
* debug.h (handle_list): Change "clexec" to "inherited".
* debug.cc: Remove a spurious declaration.
(setclexec): Conditionalize away since it is currently unused.
(add_handle): Use inherited field rather than clexec.
(debug_fixup_after_fork_exec): Ditto.  Move debugging output to delete_handle.
(delete_handle): Add debugging output.
* fhandler.cc (fhandler_base::set_inheritance): Don't bother setting
inheritance in debugging table since the handle was never protected anyway.
(fhandler_base::fork_fixup): Ditto.
* exceptions.cc (debugger_command): Revert.
@
text
@d151 5
a155 1
  char myself_posix_name[MAX_PATH];
d157 1
a157 3
  /* FIXME: gdb cannot use win32 paths, but what if debugger isn't gdb? */
  cygwin_conv_to_posix_path (myself->progname, myself_posix_name);
  __small_sprintf (debugger_command, "%s %s", buf, myself_posix_name);
a345 2
  BOOL dbg;

d378 1
@


1.116
log
@* dcrt0.cc (dll_crt0_1): Delay closing of some handles until cygheap has been
set up.
(break_here): New function, for debugging.
(initial_env): Add program name to "Sleeping" message.  Implement new
"CYGWIN_DEBUG" environment variable option.
* exceptions.cc (debugger_command): Add argument to dumper call.
* strace.cc (strace::hello): Use winpid if cygwin pid is unavailable.
(strace::vsprntf): Ditto.
@
text
@d28 1
a28 1
char debugger_command[2 * MAX_PATH + 20] = "dumper.exe %s";
@


1.115
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d28 1
a28 1
char debugger_command[2 * MAX_PATH + 20] = "dumper.exe";
@


1.114
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d28 1
a28 1
char debugger_command[2 * MAX_PATH + 20];
@


1.113
log
@* debug.h (being_debugged): New macro.
* dtable.cc (dtable::extend): Use new macro.
* exceptions.cc (try_to_debug): Ditto.
* strace.cc (strace::hello): Only output debugging info when we think we're
being debugged.
@
text
@d1016 1
a1016 1
          || sig == SIGURG || (thisproc && hExeced && sig == SIGINT))
@


1.112
log
@* sync.h (new_muto): Just accept an argument which denotes the name of the
muto.  Use this argument to construct static storage.
* cygheap.cc (cygheap_init): Reflect above change.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* cygheap.h (cwdstuff): Change name of lock element to make it less generic.
* path.cc (cwdstuff::get_hash): Ditto.
(cwdstuff::get_initial): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* sigproc.cc (proc_subproc): Ditto.
* debug.cc (lock_debug): Change to method.  Use method rather than macro
throughout.
* tty.h (tty_min::kill_pgrp): Declare new method.
* fhandler_termios.cc (tty_min::kill_pgrp): New method.
(fhandler_termios::line_edit): Use new method for killing process.
* dcrt0.cc (do_exit): Ditto.
* dtable.cc (dtable::get_debugger_info): New method for inheriting dtable info
from a debugger.
* tty.cc (tty_init): Attempt to grab file handle info from parent debugger, if
appropriate.  # dtable.cc (dtable::stdio_init): Make this a method.
(dtable::init_std_file_from_handle): Don't set fd unless it's not open.
(dtable::build_fhandler_from_name): Move name setting to
dtable::build_fhandler.
(dtable::build_fhandler): Add win32 name parameter.
* dcrt0.cc (dll_crt0_1): Change to use dtable stdio_init.
* dtable.h (dtable): Reflect build_fhandler parameter change.
* mmap.cc (mmap_record::alloc_fh): Don't set name parameter in build_fhandler.
* net.cc (fdsock): Remove set_name call since it is now handled by
build_fhandler.
* sigproc.cc (proc_subproc): Release muto as early as possible.
@
text
@d396 1
a396 1
      while (!IsDebuggerPresent ())
@


1.111
log
@* times.cc (hires::prime): Restore thread priority on failure condition.
* uinfo.cc (uinfo_init): Use more robust method for determining if process was
invoked from a non-cygwin process.
* sync.h (muto::init): Eliminate "inheritance" parameter.
(new_muto): Reflect removal of parameter.
* sync.cc (muto::init): Ditto.
* cygheap.cc (cygheap_init): Ditto.
* debug.cc (threadname_init): Ditto.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* grp.cc (group_lock): Use different method for locking with static member.
(read_etc_group): REALLY ensure that read lock mutex is released.
* passwd.cc (passwd_lock): Use different method for locking with static member.
(read_etc_passwd): REALLY ensure that read lock mutex is released.
* shared.cc (sec_user): Correct reversed inheritance test.
@
text
@d1115 1
a1115 1
  mask_sync = new_muto ("mask_sync");
@


1.110
log
@* exceptions.cc (unused_sig_wrapper): Eliminate unused parameter to asm.
* external.cc (cygwin_internal): Change CW_STRACE_ON to CW_STRACE_TOGGLE.
* strace.cc (strace::hello): Toggle strace on and off.
* sync.cc (muto::init): Renamed from constructor.
* sync.h (muto::new): Delete.
(muto::delete): Ditto.
(new_muto): Simplify.  Use muto.init for nearly everything.
* uinfo.cc (uinfo_init): Avoid closing a NULL handle.
* include/sys/cygwin.h (cygwin_getinfo_types): Rename CW_STRACE_OFF to
CW_STRACE_TOGGLE.  Delete CW_STRACE_OFF.
* include/sys/strace.h (strace): Add "inited" field.
@
text
@d1115 1
a1115 1
  mask_sync = new_muto (FALSE, "mask_sync");
@


1.109
log
@* speclib: Don't use /dev/null as DLL name.  Just default to what's already in
.def file.
* exceptions.cc (sig_handle): Remove last vestiges of SA_NOCLDSTOP code which
caused SIGCHLD to be ignored.
@
text
@d1223 1
a1223 1
	pushl	%7			# saved errno			\n\
d1230 1
a1230 1
	pushl	%8			# newmask			\n\
d1241 1
a1241 1
    "g" (sigsave.func), "o" (pid_offset), "g" (sigsave.saved_errno), "g" (sigsave.newmask)
@


1.108
log
@* exceptions.cc (ctrl_c_handler): Convert windows pid to cygwin pid when
detecting if we should actually handle CTRL-C.
@
text
@a1036 3
  if (sig == SIGCHLD)
    goto done;

@


1.107
log
@* exceptions.cc (sig_handle_tty_stop): Don't send SIGCHLD if parent doesn't
want it.
(sig_handle): Don't check for SA_NOCLDSTOP here.  We don't have enough
information.
@
text
@d926 1
a926 1
  if (!pinfo (GetCurrentProcessId ()))
@


1.106
log
@Add copyright stuff
@
text
@d603 1
d612 2
a613 1
      sig_send (parent, SIGCHLD);
d1037 1
a1037 1
  if ((sig == SIGCHLD) && (thissig.sa_flags & SA_NOCLDSTOP))
@


1.105
log
@* exceptions.cc (sig_handle): Accept a second argument indicating whether the
signal came from this process or not.
* sigproc.h: Reflect sig_handle arg change.
* signal.cc (kill_pgrp): Add sigframe info.
(abort): New function.  Eliminates newlib function of same name.
* sigproc.cc (wait_sig): Pass "signal from this process" value as arg 2.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.104
log
@* exceptions.cc (early_stuff_init): Rename from misnamed set_console_handler.
(ctrl_c_handler): Attempt to work around potential signal duplication during
process startup.
(sig_handle): Ignore SIGINT when we're just an "exec stub".
* spawn.cc (spawn_guts): Store pid of spawned process in global for use by
ctrl_c_handler.
* dcrt0.cc (dll_crt0_1): Call renamed initialization function.
* winsup.h: Reflect function name change.
@
text
@d896 1
a896 1
/* CGF Keyboard interrupt handler.  */
d966 1
a966 1
sig_handle (int sig)
d1014 1
a1014 1
          || sig == SIGURG || (hExeced && sig == SIGINT))
@


1.103
log
@	exceptions.cc (sig_handle): Set default action for SIGURG to SIG_IGN.
@
text
@d41 3
d119 1
a119 1
set_console_handler ()
d121 4
a133 4

  (void) SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
  if (!SetConsoleCtrlHandler (ctrl_c_handler, TRUE))
    system_printf ("SetConsoleCtrlHandler failed, %E");
d917 10
d928 1
a928 1
  /* Ignore this if we're not the process group lead since it should be handled
d941 1
d1014 1
a1014 1
          || sig == SIGURG)
a1076 2
  extern HANDLE hExeced;

@


1.102
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d999 2
a1000 1
      if (sig == SIGCHLD || sig == SIGIO || sig == SIGCONT || sig == SIGWINCH)
@


1.101
log
@* exceptions.cc: Add stdlib.h include for alloca declaration.
* poll.cc: Ditto.
* termios.cc: Ditto.
* syscalls.cc (_write): Only allow zero length when fd is valid.
@
text
@d386 3
a388 3
  static int NO_COPY keep_looping = 0;

  if (dbg)
d393 1
a393 1
      while (keep_looping)
d395 2
a398 2

  system_printf ("Failed to start debugger: %E");
@


1.100
log
@* environ.cc: Set reset_com to false to mimic linux behavior more closely.
@
text
@d14 1
@


1.99
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d1071 1
@


1.98
log
@* cygheap.cc (cfree): Remove malloc debugging probe.
* dlmalloc.c (errprint): Remove abort() call which causes interesting error
message printing to abort prematurely.
* environ.cc: Sprinkle MALLOC_CHECKs liberally throughout.
(_addenv): Allocate two empty elements at end of environ to
(apparently) work around problems with some buggy applications.
(winenv): Avoid calling alloca if no forced environment variable is present.

* exceptions.cc (open_stackdumpfile): Don't print "Dumping stack trace to..."
when running in a cygwin environment (i.e., the parent is a cygwin process).

* dtable.cc (dtable::init_std_file_from_handle): Move device type detection
code from build_fhandler here since it is only used by this function.
(dtable::build_fhandler_from_name): New method.  Renamed from
dtable::build_fhandler.
(dtable::build_fhandler): Use build_fhandler_from_name.
(cygwin_attach_handle_to_fd): Ditto.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
* dtable.h (dtable::build_fhandler_from_name): Rename declaration from
dtable::build_fhandler.
@
text
@d52 1
a52 1
static const struct
d56 1
a56 1
} status_info[] NO_COPY =
@


1.97
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@d173 4
a176 1
	  system_printf ("Dumping stack trace to %s", corefile);
@


1.97.2.1
log
@Merged changes from HEAD
@
text
@a13 1
#include <stdlib.h>
d52 1
a52 1
NO_COPY static struct
d56 1
a56 1
} status_info[] =
d173 1
a173 4
	  if (!myself->ppid_handle)
	    system_printf ("Dumping stack trace to %s", corefile);
	  else
	    debug_printf ("Dumping stack trace to %s", corefile);
d382 3
a384 3
  if (!dbg)
    system_printf ("Failed to start debugger: %E");
  else
d389 1
a389 1
      while (!IsDebuggerPresent ())
a390 2
      Sleep (4000);
      small_printf ("*** continuing from debugger call\n");
d393 2
a1067 1
  (void) SetThreadPriority (hMainThread, THREAD_PRIORITY_IDLE);
@


1.97.2.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a40 3
extern HANDLE hExeced;
extern DWORD dwExeced;

d116 1
a116 1
early_stuff_init ()
a117 4
  (void) SetConsoleCtrlHandler (ctrl_c_handler, FALSE);
  if (!SetConsoleCtrlHandler (ctrl_c_handler, TRUE))
    system_printf ("SetConsoleCtrlHandler failed, %E");

d127 4
d893 1
a893 1
/* Keyboard interrupt handler.  */
a913 10
  /* If we are a stub and the new process has a pinfo structure, let it
     handle this signal. */
  if (dwExeced && pinfo (dwExeced))
    return TRUE;

  /* We're only the process group leader when we have a valid pinfo structure.
     If we don't have one, then the parent "stub" will handle the signal. */
  if (!pinfo (GetCurrentProcessId ()))
    return TRUE;

d915 1
a915 1
  /* Ignore this if we're not the process group leader since it should be handled
a927 1

d952 1
a952 1
sig_handle (int sig, bool thisproc)
d999 1
a999 2
      if (sig == SIGCHLD || sig == SIGIO || sig == SIGCONT || sig == SIGWINCH
          || sig == SIGURG || (thisproc && hExeced && sig == SIGINT))
d1062 2
@


1.97.2.3
log
@Merged changes from HEAD
@
text
@a602 1

d611 1
a611 2
      if (!(parent->getsig (SIGCHLD).sa_flags & SA_NOCLDSTOP))
	sig_send (parent, SIGCHLD);
d924 1
a924 1
  if (!pinfo (cygwin_pid (GetCurrentProcessId ())))
d1034 3
@


1.97.2.4
log
@Merged changes from HEAD
@
text
@d1115 1
a1115 1
  new_muto (mask_sync);
d1223 1
a1223 1
	pushl	%6			# saved errno			\n\
d1230 1
a1230 1
	pushl	%7			# newmask			\n\
d1241 1
a1241 1
    "g" (sigsave.func), "g" (sigsave.saved_errno), "g" (sigsave.newmask)
@


1.97.2.5
log
@Merged changes from HEAD
@
text
@d396 1
a396 1
      while (!being_debugged ())
d1016 1
a1016 1
	  || sig == SIGURG || (thisproc && hExeced && sig == SIGINT))
@


1.97.2.6
log
@Merged changes from HEAD
@
text
@d28 1
a28 1
char debugger_command[2 * MAX_PATH + 20] = "dumper.exe";
@


1.97.2.7
log
@Merged changes from HEAD
@
text
@d28 1
a28 1
char debugger_command[2 * MAX_PATH + 20] = "dumper.exe %s";
@


1.97.2.8
log
@Merged changes from HEAD
@
text
@d28 1
a28 1
char debugger_command[2 * MAX_PATH + 20];
@


1.97.2.9
log
@Merged changes from HEAD
@
text
@d151 1
a151 5
  char pgm[MAX_PATH + 1];
  if (!GetModuleFileName (NULL, pgm, MAX_PATH))
    strcpy (pgm, "cygwin1.dll");
  for (char *p = strchr (pgm, '\\'); p; p = strchr (p, '\\'))
    *p = '/';
d153 3
a155 1
  __small_sprintf (debugger_command, "%s %s", buf, pgm);
d344 2
a377 1
  BOOL dbg;
@


1.97.2.10
log
@Merged changes from HEAD
@
text
@a393 1
      SetThreadPriority (hMainThread, THREAD_PRIORITY_IDLE);
d396 1
@


1.97.2.11
log
@Merged changes from HEAD
@
text
@d718 5
a722 1
  if (sigsave.sig)
d724 2
a725 6
      sigsave.sig = 0;
      if (sigsave.retaddr_on_stack)
	{
	  *sigsave.retaddr_on_stack = sigsave.retaddr;
	  set_process_mask (sigsave.oldmask);
	}
a726 1
  sigproc_init ();
@


1.97.2.12
log
@Merged changes from HEAD
@
text
@d689 1
a689 2
  sigsave.oldmask = myself->getsigmask ();
  sigsave.newmask = sigsave.oldmask | siga.sa_mask | SIGTOMASK (sig);
@


1.97.2.13
log
@Merged changes from HEAD
@
text
@d618 1
a618 3
  if (WaitForSingleObject (sigCONT, INFINITE) != WAIT_OBJECT_0)
    api_fatal ("WaitSingleObject failed, %E");
  (void) ResetEvent (sigCONT);
a994 1
      DWORD stopped = myself->process_state & PID_STOPPED;
d1002 4
a1005 2
      if (stopped)
	SetEvent (sigCONT);
@


1.97.2.14
log
@Merged changes from HEAD
@
text
@d739 3
a741 3
      myself->getsig (i).sa_mask = 0;
      if (myself->getsig (i).sa_handler != SIG_IGN || isspawn)
	myself->getsig (i).sa_handler = SIG_DFL;
@


1.96
log
@* exceptions.cc (call_signal_handler_now): Add additional guard against
inappropriately calling signal handler.
* syscalls.cc (_read): Reset errno if not exiting due to signal.
@
text
@d852 1
a852 2
	  if (!interrupted)
	    LeaveCriticalSection (&th->lock);
a870 3

  if (th)
    LeaveCriticalSection (&th->lock);
@


1.95
log
@* sigproc.h (sigframe::unregister): Return true/false whether this frame is
capable of responding to signals.
* exceptions.cc (sigframe::call_signal_handler): Don't call signal handler if
it is not armed for this thread.
@
text
@d1130 6
@


1.94
log
@* cygheap.cc (cygheap_fixup_in_child): Don't consider a NULL bucket as a
candidate for deletion.  It is actually the end of a linked list chain.
* exceptions.cc (open_stackdumpfile): Default to "unknown" program name if
myself->progname hasn't been filled out yet.
@
text
@d1145 2
a1146 2
  unregister ();
  return call_signal_handler_now ();
@


1.93
log
@* exceptions.cc (ctrl_c_handler): Only send SIGINT when we have a controlling
terminal and we are the head of the process group.
@
text
@d161 3
a163 1
      if ((p = strrchr (myself->progname, '\\')))
@


1.92
log
@* syscalls.cc (setsid): Detach process from its console if the current
controlling tty is the console and already closed.
* dtable.h (class dtable): Add members to count descriptors referring to the
console.
* dtable.cc (dtable::dec_console_fds): New function to detach process from its
console.
(dtable::release): Decrement the counter of console descriptors.
(dtable::build_fhandler): Increment it.
* exception.cc (ctrl_c_handler): Send SIGTERM to myself when catch
CTRL_SHUTDOWN_EVENT.
@
text
@d915 2
a916 5
  if (t->getpgid () && pid_exists (t->getpgid ()) &&
      (t->getpgid () != myself->pid ||
       (GetTickCount () - t->last_ctrl_c) < MIN_CTRL_C_SLOP))
    return TRUE;
  else
d926 1
@


1.91
log
@Change check_null_empty_path* to check_null_empty_str* throughout.
* path.cc (path_conv::check): Add signal protection here since retrieving info
about remote shares can take some time.
* path.h (check_null_empty_str_errno): Convert to a function prototype.
* path.cc (check_null_empty_str): Move to miscfuncs.cc.
* miscfuncs.cc (check_null_empty_str_errno): New function.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(check_null_empty_str): Change from VirtualQuery to IsBadWritePtr.
* thread.cc (check_valid_pointer): Ditto.
* resource.cc (getrlimit): Use check_null_invalid_struct macro for checking
validity of pointer.
(setrlimit): Ditto.
@
text
@d898 9
a906 4
  if ((type == CTRL_CLOSE_EVENT) || (type == CTRL_SHUTDOWN_EVENT))
    /* Return FALSE to prevent an "End task" dialog box from appearing
       for each Cygwin process window that's open when the computer
       is shut down or console window is closed. */
d911 1
@


1.90
log
@forced commit
@
text
@d641 1
a642 1
  sigproc_printf ("h %p, interruptible %d", res);
@


1.89
log
@* exceptions.cc (interrupt_setup): Move actions from setup_handler to here.
(setup_handler): Move actions after a successful interrupt to interrupt_setup.
* fork.cc (vfork): Augment debugging output.
* sigproc.cc (proc_subproc): Ditto.
* spawn.cc (spawn_guts): Ditto.  Correctly fill out progname when spawn
NO_WAIT.  Call signal handler when a signal arrives.
* sigproc.h: Declare a function.
@
text
@@


1.88
log
@* exceptions.cc (sig_handle_tty_stop): Reset PID_STOPPED if not actually
stopping.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Don't set
controlling terminal if just inheriting a handle.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
* signal.cc (kill_worker): Set appropriate errno if proc_exists determines that
process does not really exist.
@
text
@d687 4
d699 1
a699 1
  SetThreadContext (myself->getthread2signal (), ctx); /* Restart the thread */
d860 3
a862 1
  if (!interrupted)
a869 7
  else
    {
      /* Clear any waiting threads prior to dispatching to handler function */
      proc_subproc (PROC_CLEARWAIT, 1);
      res = SetEvent (signal_arrived);	// For an EINTR case
      sigproc_printf ("armed signal_arrived %p, res %d", signal_arrived, res);
    }
d1159 48
a1206 54
	.text\n\
\n\
_sigreturn:\n\
	addl	$4,%%esp	# Remove argument\n\
	movl	%%esp,%%ebp\n\
	addl	$36,%%ebp\n\
\n\
	cmpl	$0,%4		# Did a signal come in?\n\
	jz	1f		# No, if zero\n\
	call	_call_signal_handler_now@@0 # yes handle the signal\n\
\n\
# FIXME: There is a race here.  The signal handler could set up\n\
# the sigsave structure between _call_signal_handler and the\n\
# end of _set_process_mask.  This would make cygwin detect an\n\
# incorrect signal mask.\n\
\n\
1:	call	_set_process_mask@@4\n\
	popl	%%eax		# saved errno\n\
	testl	%%eax,%%eax	# Is it < 0\n\
	jl	2f		# yup.  ignore it\n\
	movl	%1,%%ebx\n\
	movl	%%eax,(%%ebx)\n\
2:	popl	%%eax\n\
	popl	%%ebx\n\
	popl	%%ecx\n\
	popl	%%edx\n\
	popl	%%edi\n\
	popl	%%esi\n\
	popf\n\
	popl	%%ebp\n\
	ret\n\
\n\
__no_sig_start:\n\
_sigdelayed:\n\
	pushl	%2			# original return address\n\
_sigdelayed0:\n\
	pushl	%%ebp\n\
	movl	%%esp,%%ebp\n\
	pushf\n\
	pushl	%%esi\n\
	pushl	%%edi\n\
	pushl	%%edx\n\
	pushl	%%ecx\n\
	pushl	%%ebx\n\
	pushl	%%eax\n\
	pushl	%7			# saved errno\n\
	pushl	%3			# oldmask\n\
	pushl	%4			# signal argument\n\
	pushl	$_sigreturn\n\
\n\
	call	_reset_signal_arrived@@0\n\
	pushl	%5			# signal number\n\
	pushl	%8			# newmask\n\
	movl	$0,%0			# zero the signal number as a\n\
d1209 5
a1213 6
\n\
	call	_set_process_mask@@4\n\
	popl	%%eax\n\
	jmp	*%%eax\n\
__no_sig_end:\n\
\n\
@


1.87
log
@* exceptions.cc (sigdelayed): Ensure that signal is cleared as the last
operation or suffer races.
* sigproc.cc (proc_subproc): Deal with zombie array overflow.
@
text
@d590 4
a593 1
    return;
@


1.86
log
@* exceptions.cc (handle_exceptions): Bump repeat count for debugging kick out.
* fhandler.h (fhandler_dev_dsp): Add a fixup_after_exec.
* fhandler_dsp.cc (class Audio): Add TOT_BLOCK_SIZE to enum.
(operator new): New.
(bigwavebuffer): Declare using TOT_BLOCK_SIZE to avoid buffer overruns.
(Audio::Audio): Optimize slightly.
(fhandler_dev_dsp::open): Allocate s_audio using static buffer.
(fhandler_dev_dsp::fixup_after_exec): New function.  Ditto.
@
text
@d1209 1
a1213 1
	pushl	%8\n\
@


1.85
log
@* exceptions.cc (handle_exceptions): Don't print message when executing from a
cygwin program.
@
text
@d408 1
a408 1
  if (debugging && ++debugging < 50000)
@


1.84
log
@* cygheap.cc (_cfree): Add regparm attribute.
(_crealloc): Ditto.
* dcrt0.cc (dll_crt0_1): Default to always checking for executable for now.
* dtable.cc (dtable::not_open): Move method.
* dtable.h (dtable): Here.
* exceptions.cc (ctrl_c_handler): Don't expect process group leader to handle a
signal if it doesn't exist.
* fhandler.h (fhandler_base): Make openflags protected.
* localtime.c (tzsetwall): Check for __CYGWIN__ as well as __WIN32__.
* path.cc (path_conv::check): Add some comments.  Change strcat to assignment.
* lib/_cygwin_S_IEXEC.cc (_cygwin_bob__): Eliminate.
* fhandler_tty.cc (fhandler_console::dup): Set controlling terminal if
necessary.
* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
@
text
@a360 1
	  system_printf ("%s", p);
d504 2
a505 1
		  system_printf ("Exception: %s", status_info[i].name);
@


1.83
log
@* exceptions.cc (handle_exceptions): Vastly increase test for exception loop
guard variable.
@
text
@d907 3
a909 2
  if (t->getpgid () && (t->getpgid () != myself->pid ||
      (GetTickCount () - t->last_ctrl_c) < MIN_CTRL_C_SLOP))
@


1.82
log
@* exceptions.cc (stack_info): Add some controls.
(stack_info::init): Add extra arguments to control method of initialization..
If we have a known good frame, set things up so that this frame is not skipped
the first time through.  Record whether caller cares about arguments or not.
(stack_info::walk): Don't store arguments if they're unwanted.
(stackdump): Add isexception parameter for use when called by exception
handler.
(cygwin_stackdump): Accomodate extra argument to stackdump.
(handle_exceptions): Ditto.
(sig_handle): Ditto.
(interrupt_on_return): Accomodate extra arguments to stack walk initialization.
@
text
@d409 5
a413 2
  if (debugging && ++debugging < 50)
    return 0;
@


1.81
log
@Revert much of previous erroneous checkin.  Add ChangeLog entry.

* pinfo.h: Correctly set __SIGOFFSET.
* path.cc (hash_path_name): Avoid calling library functions for simple copying
of characters.
* shortcut.c: Use WIN32_LEAN_AND_MEAN.
* smallprint.c: Ditto.
* environ.cc (getwinenv): Minor clarity fix.
* localtime.c: No need to include windows.h
* string.h: New file.
@
text
@d225 2
d228 2
a229 2
  STACKFRAME sf;		/* For storing the stack information */
  void init (DWORD);		/* Called the first time that stack info is needed */
d244 1
a244 1
stack_info::init (DWORD ebp)
d248 7
a254 1
  sf.AddrFrame.Offset = ebp;
d257 1
d267 1
a267 6
  if ((ebp = (char **) next_offset ()) != NULL)
    {
      sf.AddrFrame.Offset = (DWORD) ebp;
      sf.AddrPC.Offset = sf.AddrReturn.Offset;
    }
  else
d270 3
d279 5
a283 3
  /* The arguments follow the return address */
  for (unsigned i = 0; i < NPARAMS; i++)
    sf.Params[i] = (DWORD) *++ebp;
d288 1
a288 1
stackdump (DWORD ebp, int open_file)
d300 1
a300 1
  thestack.init (ebp);		/* Initialize from the input CONTEXT */
d321 1
a321 1
  stackdump (c.Ebp, 0);
d522 1
a522 1
	  stackdump ((DWORD) ebp, 0);
d729 1
a729 1
  thestack.init (ebp);  /* Initialize from the input CONTEXT */
d1036 1
a1036 1
	stackdump (c.Ebp, 1);
@


1.80
log
@* exceptions.cc (ctrl_c_handler): Always send signal to process if it has no
tty.
@
text
@d635 1
a635 1
    return !ilockexch (&winapi_lock, 1);
d639 1
a639 1
  while (ilockexch (&winapi_lock, 1))
d648 1
a648 1
  ilockexch (&winapi_lock, 0);
@


1.79
log
@* exceptions.cc (handle_exceptions): Break out of "loop" if the debugger
doesn't seem to be attaching to our process.
@
text
@d635 1
a635 1
    return !InterlockedExchange (&winapi_lock, 1);
d639 1
a639 1
  while (InterlockedExchange (&winapi_lock, 1))
d648 1
a648 1
  InterlockedExchange (&winapi_lock, 0);
d895 2
a896 2
  if (!t->getpgid () || t->getpgid () != myself->pid ||
      (GetTickCount () - t->last_ctrl_c) < MIN_CTRL_C_SLOP)
@


1.78
log
@* exceptions.cc (INIT_EXCEPTION_HANDLER): Eliminate.
(init_exceptions): Just use init_exception_handler.
(open_stackdumpfile): New function.
(stack_info::first_time): Eliminate.
(stack_info::init): Set up fields to avoid "first_time" consideration.
(stack_info::walk): Remove "first_time" consideration.
(stackdump): Change arguments to accept initial frame pointer and open stack
file flag.
(stack): Eliminate.
(cygwin_stackdump): Use stackdump() rather than stack().
(try_to_debug): Remove all synchronization logic.  Just keep looping in
exception handler until debugger notices us.  Return 1 if successfully started
debugger.
(handle_exceptions): Just return if we know that we're debugging.  Reorganize
to avoid creating a stackdump file if we are starting a debugger.  Return from
exception handler if debugger started successfully.
(sig_handle): Create a stackdump only if debugger wasn't started.
* winsup.h (try_to_debug): Add an argument.
@
text
@d400 1
a400 1
  if (debugging)
@


1.77
log
@Throughout, change 'tty_attached' to 'real_tty_attached', for clarity.
Throughout, change 'OutputStopped' to 'output_stopped', for consistency.
* dtable.cc (stdio_init): Set controlling tty if not set by stdio opens.
* exceptions.cc (ctrl_c_handler): Avoid special pgid checking if no tty is
associated with the process.
(Suggested by Tim Baker <dbaker@@direct.ca>)
* external.cc (fillout_pinfo): Return actual tty number for ctty.
* fhandler_console.cc (get_tty_stuff): Set ctty when shared memory is
allocated.  Accept flags input from open().
(set_console_ctty): New function.
(fhandler_console::open): Pass flags to get_tty_stuff and rely on this function
to set the ctty, if appropriate.
* fhandler_termios.cc (fhandler_termios::set_ctty): Move to tty_min class.
* fhandler_tty.cc (fhandler_tty_slave::open): Use tc field to access
set_ctty().
* tty.h (TTY_CONSOLE): Move to include/sys/cygwin.h.
(tty_min): Add set_ctty class here.
* include/sys/cygwin.h (TTY_CONSOLE): New home here.
* path.cc (symlink_info): Make contents an actual buffer.  Pass more flags to
case_check.
(path_conv::check): Reorganize to do parsing based on posix path rather than
native path.
(symlink_info::check): Expect posix path as input.  Translate to native path
here.  Accept path_conv flags.  Stop parsing if not a symlink regardless of
whether previous path was a symlink.
@
text
@a111 2

#define INIT_EXCEPTION_HANDLER(el) init_exception_handler (el)
d135 1
a135 3
#ifdef INIT_EXCEPTION_HANDLER
  INIT_EXCEPTION_HANDLER (el);
#endif
d154 23
a222 1
  int first_time;		/* True if just starting to iterate. */
a227 1
  stack_info (): first_time (1) {}
d244 1
a244 1
  first_time = 1;
d247 1
a247 1
  sf.AddrPC.Offset = ((DWORD *) ebp)[1];
d249 1
d258 1
a258 4
  if (first_time)
    /* Everything is filled out already */
    ebp = (char **) sf.AddrFrame.Offset;
  else if ((ebp = (char **) next_offset ()) != NULL)
a265 1
  first_time = 0;
a277 1
/* Dump the stack */
d279 1
a279 1
stack (CONTEXT *cx)
d281 8
d291 1
a291 1
  thestack.init (cx->Ebp);	/* Initialize from the input CONTEXT */
d312 1
a312 1
  stack (&c);
a314 2
static int NO_COPY keep_looping = 0;

d318 1
a318 1
try_to_debug ()
d328 1
d371 4
a374 1
  if (!dbg)
d376 3
a378 12
      system_printf ("Failed to start debugger: %E");
      /* FIXME: need to know handles of all running threads to
	resume_all_threads_except (current_thread_id);
      */
    }
  else
    {
      char event_name [sizeof ("cygwin_error_start_event") + 9];
      DWORD win32_pid = GetCurrentProcessId ();
      __small_sprintf (event_name, "cygwin_error_start_event%x", win32_pid);
      HANDLE sync_with_dbg = CreateEvent (NULL, TRUE, FALSE, event_name);
      keep_looping = 1;
d380 1
a380 10
	{
	  if (sync_with_dbg == NULL)
	    Sleep (TIME_TO_WAIT_FOR_DEBUGGER);
	  else
	    {
	      if (WaitForSingleObject (sync_with_dbg,
				       TIME_TO_WAIT_FOR_DEBUGGER) == WAIT_OBJECT_0)
		break;
	    }
	 }
d383 5
a390 31
static void
stackdump (EXCEPTION_RECORD *e, CONTEXT *in)
{
  extern unsigned long rlim_core;
  const char *p;

  if (rlim_core == 0UL)
    return;

  if (myself->progname[0])
    {
      /* write to progname.stackdump if possible */
      if ((p = strrchr (myself->progname, '\\')))
	p++;
      else
	p = myself->progname;
      char corefile[strlen (p) + sizeof (".stackdump")];
      __small_sprintf (corefile, "%s.stackdump", p);
      HANDLE h = CreateFile (corefile, GENERIC_WRITE, 0, &sec_none_nih,
			     CREATE_ALWAYS, 0, 0);
      if (h != INVALID_HANDLE_VALUE)
	{
	  system_printf ("Dumping stack trace to %s", corefile);
	  SetStdHandle (STD_ERROR_HANDLE, h);
	}
    }
  if (e)
    exception (e, in);
  stack (in);
}

d397 5
a485 2
      static NO_COPY int traced = 0;

d501 1
a501 1
      if (traced++)
d505 9
a513 7
	  CONTEXT c = *in;
	  DWORD stack[6];
	  stack[0] = in->Ebp;
	  stack[1] = in->Eip;
	  stack[2] = stack[3] = stack[4] = stack[5] = 0;
	  c.Ebp = (DWORD) &stack;
	  stackdump (e, &c);
d515 2
a516 2
      try_to_debug ();
      signal_exit (0x80 | sig);		// Flag signal + core dump
d1004 1
a1004 1
stop:
d1011 1
a1011 1
dosig:
d1016 1
a1016 1
done:
d1020 1
a1020 1
exit_sig:
d1026 2
a1027 2
      stackdump (NULL, &c);
      try_to_debug ();
@


1.76
log
@* thread.cc (thread_init_wrapper): Use _REENT_INIT to initialize the reent
structure of newlib.
* sigproc.h (sig_send): Add exception parameter to sig_send.
* sigproc.cc (sig_send): Ditto.  Use it when setting frame info.
* exceptions.cc (handle_exceptions): Use exception flag when calling sig_send.
@
text
@d893 1
a893 1
/* Keyboard interrupt handler.  */
d911 1
a911 1
  if (t->getpgid () != myself->pid ||
@


1.75
log
@* sigproc.h [sigthread]: Add exception field.
[sigframe::~sigframe]: Clear exception field.
[sigframe::set]: Set exception field from caller.
* sigproc.cc (sig_send): Set exception field when frame pointer is passed in.
* exceptions.cc (interrupt_on_return): Always treat exception as interruptible.
@
text
@d535 1
a535 1
  sig_send (NULL, sig, (DWORD) ebp);		// Signal myself
@


1.74
log
@* Makefile.in: Put -lgcc last in list of libraries, since stdc++ library needs
it.
* cygwin.din: Remove obsolete "__empty" export.
* exceptions.cc (call_signal_handler_now): Force inclusion of function even
when -finline-functions is specified.
* sigproc.h: Remove obsolete call_signal_handler declaration.
* fhandler_console.cc (cp_get_internal): New function.
(cp_convert): New function.
(con_to_str): New function.
(str_to_con): New function.
(fhandler_console::read): Replace OemToCharBuff with con_to_str.
(fhandler_console::write_normal): Replace CharToOemBuff with str_to_con.
@
text
@d738 1
a738 1
    if (interruptible (thestack.sf.AddrReturn.Offset))
@


1.73
log
@* exceptions.cc (sigframe::call_signal_handler): Return value of
call_signal_handler_now.
* sigproc.h (sigframe): Use constructor.
* syscalls.cc (_read): Correct errno test prior to calling signal handler.
@
text
@d1131 4
@


1.72
log
@* exceptions.cc (sigframe::call_signal_handler): Move out side of "C" block or
some compilers will complain.
@
text
@d1122 9
a1130 1
static int __stdcall call_signal_handler_now ();
d1137 1
a1137 1
  call_signal_handler_now ();
a1146 10
}

static int __stdcall
call_signal_handler_now ()
{
  int sa_flags = sigsave.sa_flags;
  sigproc_printf ("sa_flags %p", sa_flags);
  *sigsave.retaddr_on_stack = sigsave.retaddr;
  sigdelayed0 ();
  return sa_flags & SA_RESTART;
@


1.71
log
@* exceptions.cc (call_signal_handler_now): Rename from call_signal_handler to
avoid C++ confusion.
@
text
@d1121 11
a1148 7
}

int
sigframe::call_signal_handler ()
{
  unregister ();
  call_signal_handler_now ();
@


1.70
log
@* sigproc.h (class sigframe): Implement 'unregister()' method.
(sigframe::~sigframe): Use unregister method.
(sigframe::call_signal_handler): Declare new method.
* exceptions.cc (sigframe::call_signal_handler): New method.  Unregisters
current sigframe before calling signal handler.
(setup_handler): Clear waiting threads prior to arming signal_arrived.
* syscalls.cc (_read): Change goto to loop.  Recalculate sigframe inside of
loop so that constructor is called when appropriate.
* wait.cc (wait4): Ditto.
* signal.cc: Change "sig" to "signal" in debugging messages throughout.
* sigproc.cc: Ditto.
@
text
@d1130 2
a1131 9
int
sigframe::call_signal_handler ()
{
  unregister ();
  ::call_signal_handler ();
}

int __stdcall
call_signal_handler ()
d1140 7
d1163 1
a1163 1
	call	_call_signal_handler@@0 # yes handle the signal\n\
@


1.69
log
@* dtable.cc: Guard against new winsock.h/winsock2.h warnings when mixing
winsock*.h and sys/types.h.
* fhandler_socket.cc: Ditto.
* net.cc: Ditto.
* select.cc: Ditto.
* exceptions.cc: Remove unneeded define.
@
text
@d867 2
a870 2
      /* Clear any waiting threads prior to dispatching to handler function */
      proc_subproc (PROC_CLEARWAIT, 1);
d1128 7
@


1.68
log
@* exceptions.cc (interruptible): Update debugging output.
(setup_handler): Ensure that wait_sig loop wakes up when we punt on sending a
signal.
* poll.cc (poll): Add signal guard here.
@
text
@a10 1
#define Win32_Winsock
@


1.67
log
@* autoload.cc (noload): Use proper method for multiline strings or newer gcc's
complain.
* exceptions.cc (unused_sig_wrapper): Ditto.
* fhandler.h (fhandler_base): Make get_io_handle and friends return self.
* fhandler_tty.cc (fhandler_pty_common::close_on_exec): Accomodate DEBUGGING
flag to avoid spurious warnings when inheritance is set.
@
text
@a642 1
  minimal_printf ("h %p", h);
d644 1
a644 2

  minimal_printf ("interruptible %d", res);
d857 1
a857 1
set_pending:
d862 2
@


1.66
log
@* shortcut.c (PATH_ALL_EXEC): Add parentheses to avoid a compiler warning.
* exceptions.cc (setup_handler): Clarify debugging message.
* sigproc.cc (proc_subproc): Remove PROC_CHILDSTOPPED test.  It is handled by
normal PROC_CLEARWAIT case.
(wait_sig): Eliminate "dispatched" tracking.  Remove __SIGCHILDSTOPPED test.
Decrement counter again before jumping out of InterlockedDecrement loop so that
subsequent InterlockedIncrement will keep the counter at the correctly
decremented value and also detect when there are pending signals.
* sigproc.h: Remove __SIGCHILDSTOPPED element.
(procstuff): Remove PROC_CHILDSTOPPED element.
@
text
@d1147 63
a1209 63
__asm__ volatile ("
	.text

_sigreturn:
	addl	$4,%%esp	# Remove argument
	movl	%%esp,%%ebp
	addl	$36,%%ebp

	cmpl	$0,%4		# Did a signal come in?
	jz	1f		# No, if zero
	call	_call_signal_handler@@0 # yes handle the signal

# FIXME: There is a race here.  The signal handler could set up
# the sigsave structure between _call_signal_handler and the
# end of _set_process_mask.  This would make cygwin detect an
# incorrect signal mask.

1:	call	_set_process_mask@@4
	popl	%%eax		# saved errno
	testl	%%eax,%%eax	# Is it < 0
	jl	2f		# yup.  ignore it
	movl	%1,%%ebx
	movl	%%eax,(%%ebx)
2:	popl	%%eax
	popl	%%ebx
	popl	%%ecx
	popl	%%edx
	popl	%%edi
	popl	%%esi
	popf
	popl	%%ebp
	ret

__no_sig_start:
_sigdelayed:
	pushl	%2			# original return address
_sigdelayed0:
	pushl	%%ebp
	movl	%%esp,%%ebp
	pushf
	pushl	%%esi
	pushl	%%edi
	pushl	%%edx
	pushl	%%ecx
	pushl	%%ebx
	pushl	%%eax
	pushl	%7			# saved errno
	pushl	%3			# oldmask
	pushl	%4			# signal argument
	pushl	$_sigreturn

	call	_reset_signal_arrived@@0
	pushl	%5			# signal number
	movl	$0,%0			# zero the signal number as a
					# flag to the signal handler thread
					# that it is ok to set up sigsave

	pushl	%8
	call	_set_process_mask@@4
	popl	%%eax
	jmp	*%%eax
__no_sig_end:

@


1.65
log
@* sigproc.h (sigthread): Declare new methods.  Create new winapi_lock field.
(sigframe:;set): Call get_winapi_lock after frame is set so that signal handler
thread knows not to call SuspendThread.
(sigframe::~sigframe): Release winapi_lock.
* exceptions.cc (sigthread::get_winapi_lock): New method.
(sigthread::release_winapi_lock): New method.
(setup_handler): Use get_winapi_lock to ensure that signalled thread is not
blocked in a Windows API.
* path.h (path_types): Avoid broken GCC warning.
@
text
@d604 1
a604 1
      sig_send (parent, __SIGCHILDSTOPPED);
d878 1
a878 1
    sigproc_printf ("didn't suspend main thread, th %p", th);
@


1.64
log
@* exceptions.cc (sig_handle_tty_stop): Ignore attempts to suspend a process if
started by non-cygwin parent.
@
text
@d650 20
d801 2
d805 3
@


1.63
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d592 4
@


1.62
log
@Fix typos.  Add some comments.
@
text
@d302 1
a302 1
  debug_printf ("debugger_command %s", debugger_command);
d361 1
a361 1
      char event_name [ sizeof ("cygwin_error_start_event") + 9 ];
@


1.61
log
@* exceptions.cc (sigreturn): Call any pending signals prior to resetting the
signal mask so that stacked signals behave correctly.
(sigdelayed): Avoid a race where a signal could end up calling an incorrect
signal handler if two signals come in close together.
@
text
@d1116 2
a1117 2
   to restore any mask, restores any potentially clobbered registered
   and returns to orignal caller. */
d1170 4
a1173 2
	pushl	%5
	movl	$0,%0
@


1.60
log
@* autoload.cc (LoadDLLinitfunc): Remove debugging statement.
* exceptions.cc (sig_handle_tty_stop): Move setting of PID_STOPPED to earlier
in interrupt.
((interrupt_setup): i.e., here.
(sig_handle): Don't queue multiple SIGSTOPS.
* fhandler.h (bg_check_types): Enumerate return value of bg_check for clarity.
* signal.cc (kill_pgrp): Minor cleanup.
* fhandler_termios.cc (fhandler_termios::bg_check): Use enumerated type for
function return.  Don't raise signal if a signal is already queued.
* fhandler_console.cc (fhandler_console::read): Use enumerated return type for
bg_check.
* select.cc: Ditto, throughout.
* read.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
(_read): YA interrupt detect simplification.
* wait.cc (wait4): Ditto.
@
text
@a655 1
  sigsave.oldmask = myself->getsigmask ();	// Remember for restoration
d740 1
a740 1
static int call_handler (int, void *, struct sigaction&) __attribute__((regparm(3)));
d742 1
a742 1
call_handler (int sig, void *handler, struct sigaction& siga)
d862 1
a862 1
#error "Need to supply machine dependent call_handler"
d1002 1
a1002 1
  rc = call_handler (sig, handler, thissig);
d1125 11
a1135 1
	call	_set_process_mask@@4
d1138 1
a1138 1
	jl	1f		# yup.  ignore it
d1141 1
a1141 1
1:	popl	%%eax
d1170 1
d1175 2
a1176 1
	jmp	*%5
@


1.59
log
@* debug.h: Add regparm attributes to some functions.
* signal.cc (sigaction): Don't treat SIGCONT specially.
* exceptions.cc (interrupt_setup): Save sa_flags of interrupted signal for
later use.
(sig_handler): Default any stopping signal to SIGSTOP.
(call_signal_handler): New function.
(sigdelayed0): New function.
* sigproc.cc (sigproc_init): Initialize SIGSTOP sigaction for special behavior.
* sigproc.h: Define call_signal_handler.
* syscalls.cc (_read): Allow restartable signal behavior.
@
text
@d588 21
d663 5
a918 23
extern "C" {
static void
sig_handle_tty_stop (int sig)
{
  myself->stopsig = sig;
  myself->process_state |= PID_STOPPED;
  /* See if we have a living parent.  If so, send it a special signal.
   * It will figure out exactly which pid has stopped by scanning
   * its list of subprocesses.
   */
  if (my_parent_is_alive ())
    {
      pinfo parent (myself->ppid);
      sig_send (parent, __SIGCHILDSTOPPED);
    }
  sigproc_printf ("process %d stopped by signal %d, myself->ppid_handle %p",
		  myself->pid, sig, myself->ppid_handle);
  /* There is a small race here with the above two mutexes */
  SuspendThread (hMainThread);
  return;
}
}

d994 3
d1002 1
a1002 1
  sigproc_printf ("signal %d, about to call %p", sig, thissig.sa_handler);
@


1.58
log
@* pinfo.cc (codepage_init): Move function.
* environ.cc (codepage_init): To here.
* exceptoins.cc (SIG_NONMASKABLE): Remove SIGCONT from consideration since it
is supposed to be maskable.
* signal.cc (sigaction): Ditto.
* sigproc.cc (wait_sig): Ditto.
* winsup.h: Eliminate global declaration of codepage_init.
@
text
@d34 1
d638 1
d992 1
d1097 10
d1139 1
@


1.57
log
@        * cygwin.din: Add symbols for `getrlimit' and `setrlimit'.
        * exceptions.cc (stackdump): Avoid creating stackdump when
        `rlim_core' is 0.
        * resource.cc: New global variable `rlim_core'.
        (getrlimit): New function.
        (setrlimit): Ditto.
        include/cygwin/version.h: Bump minor API version to 32 due to
        adding `getrlimit' and `setrlimit'.
        include/sys/resource.h: Add defines, types and prototypes for
        `getrlimit' and `setrlimit'.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
d550 1
a550 1
#define SIG_NONMASKABLE	(SIGTOMASK (SIGCONT) | SIGTOMASK (SIGKILL) | SIGTOMASK (SIGSTOP))
@


1.56
log
@* autoload.h: Make DLL initializers global to avoid inlining.
* exceptions.cc (interrupt_setup): Reorganize arguments to allow use of
regparm.
(interrupt_now): Ditto.
(interrupt_on_return): Ditto.
(call_handler): Ditto.
@
text
@d384 1
d386 4
@


1.55
log
@* exceptions.cc (reset_signal_arrived): Make global to avoid inlining.
@
text
@d619 4
d624 2
a625 2
interrupt_setup (int sig, struct sigaction& siga, void *handler,
		 DWORD retaddr, DWORD *retaddr_on_stack)
d637 1
d639 1
a639 1
interrupt_now (CONTEXT *ctx, int sig, struct sigaction& siga, void *handler)
d641 1
a641 1
  interrupt_setup (sig, siga, handler, ctx->Eip, 0);
d673 1
d675 1
a675 1
interrupt_on_return (sigthread *th, int sig, struct sigaction& siga, void *handler)
d690 1
a690 1
	    interrupt_setup (sig, siga, handler, *addr_retaddr, addr_retaddr);
d708 1
d710 1
a710 1
call_handler (int sig, struct sigaction& siga, void *handler)
d788 1
a788 1
	  interrupted = interrupt_on_return (th, sig, siga, handler);
d793 1
a793 1
	interrupted = interrupt_now (&cx, sig, siga, handler);
d989 1
a989 1
  rc = call_handler (sig, thissig, handler);
@


1.54
log
@* fhandler_serial.cc (fhandler_serial::raw_read): Always find number of bytes
ready to be read whether overlapped_armed or not.
@
text
@d1075 1
a1075 2
static void volatile __stdcall reset_signal_arrived () __attribute__ ((unused));
static void volatile __stdcall
@


1.53
log
@* sigproc.cc (wait_sig): Remove unneeded for loop iteration.
* exceptions.cc (interrupt_setup): Don't set signal mask here or races occur
with main thread.  Set it in sigdelayed instead.
(sigreturn): Reflect change in stack order of ebp and flags.
(sigdelayed): Set stack frame correctly.  Call set_process_mask here with flags
for last trapped signal.
(signal_dispatch): Add newmask.
* sigproc.cc (wait_sig): Eliminate ill-considered attempt to halt looping
signal processors.
@
text
@d1075 2
a1076 2
static void __stdcall reset_signal_arrived () __attribute__ ((unused));
static void __stdcall
@


1.52
log
@Throughout use myself->ppid_handle rather than parent_alive.
* child_info.h (child_info): Eliminate parent_alive.
* dcrt0.cc (dll_crt0_1): Call fork_init for debugging pid creation.
* fork.cc (fork_child): Reflect change to fixup_mmaps_after_fork arguments.
(slow_pid_reuse): New function to grab last 'n' pids to prevent pid reuse.
(fork_parent): Move last_fork_proc into slow_pid_reuse.  Handle fork_pids
debugging.  Eliminate unnecessary call to set_child_mmap_ptr.
(fork_init): New debugging function.
* mmap.cc (fixup_mmaps_after_fork): Renamed from recreate_mmaps_after_fork.
Rely on copied data after a fork.
(set_child_mmap_ptr): Eliminate.
* pinfo.h (_pinfo): Eliminate parent_alive, mmap_ptr and reflect above changes.
* spawn.cc (spawn_guts): Eliminate vestiges of "old way" of sending new hProc
to parent process.
@
text
@d627 1
a627 1
  set_process_mask (myself->getsigmask () | siga.sa_mask | SIGTOMASK (sig));
d690 1
d810 1
a810 1
    sigproc_printf ("modified main-thread stack");
d860 1
a860 2
 * Note that some signals are unmaskable, as in UNIX.
 */
d1108 1
a1109 1
	popf
d1114 3
a1116 1
	pushl	%2	# original return address
a1117 1
	pushl	%%ebp
d1124 3
a1126 3
	pushl	%7	# saved errno
	pushl	%3	# oldmask
	pushl	%4	# signal argument
a1127 2
	pushl	%%ebp
	movl	%%esp,%%esp
d1132 2
a1133 6
	cmpl	$0,_pending_signals
	je	2f
	pushl	$0
	call	_sig_dispatch_pending@@4

2:	popl	%%ebp
d1139 1
a1139 1
    "g" (sigsave.func), "o" (pid_offset), "g" (sigsave.saved_errno)
@


1.51
log
@* path.cc (get_device_number): Allow /dev/ttySn to designate a com port.
@
text
@d894 2
a895 2
  sigproc_printf ("process %d stopped by signal %d, parent_alive %p",
		  myself->pid, sig, parent_alive);
@


1.50
log
@* dcrt0.cc (sigthread::init): Reinstitute sigthread lock as a critical section.
(dll_crt0_1): Move sigthread lock initialization to earlier in startup.
* exceptions.cc (interrupt_on_return): Remove previous kludgy attempt to detect
an invalid frame.
(call_handler): Eliminate inner for loop.  Grab signal critical section lock
where appropriate.
* sigproc.cc (proc_subproc): Restore uid setting.
* sigproc.h (sigthread): Reinstitute sigthread lock as a critical section.
(sigframe): Grab the sigthread lock before clearing frame to avoid having the
signal thread use an invalid frame.
@
text
@d560 1
a560 1
  sigframe thisframe (mainthread); 
d864 1
a864 1
  sigframe thisframe (mainthread); 
@


1.49
log
@* child_info.h (child_info): Add pppid_handle for closing the parent's of the
parent handle.
* dcrt0.cc (_dll_crt0): Close parent's parent handle when spawned or forked.
* debug.cc (add_handle): Correct erroneous reference to handle structure when
printing warning.
* exceptions.cc (interrupt_now): Always return 1.
(interrupt_on_return): Accept a sigthread argument.  Check to see if this
argument has been trashed prior to setting up the stack return.
(call_handler): Add a loop around attempts to dispatch signals to detect case
where interrupt_on_return fails.
(_sigdelayed): Set up a temporary frame pointer prior to calling stuff that
could trigger an interrupt or the stack walking code will be very confused.
* fork.cc (fork_parent): Move a lot of the setup of the child process into
proc_subproc.
* spawn.cc (spawn_guts): Ditto.  Use ppid_handle to contact logical parent when
reparenting.
* pinfo.h (_pinfo): Remember the logical handle of the parent process.
* sigproc.cc (proc_subproc): Record most stuff necessary for the _pinfo
structure that is inferrable from myself when adding children.
(wait_sig): Always set 'pending_signals' flag when about to kick off the signal
scanning loop.  Reset it only if there are no pending signals.
@
text
@d26 2
a684 5
	    if (ebp != th->frame)
	      {
		sigsave.sig = 0;
		break;
	      }
a700 2
#define SUSPEND_TRIES 10000

d708 1
a708 5
  sigthread *th;

#if 0
  mainthread.lock->acquire ();
#endif
d713 1
a713 1
  for (int i = 0; !interrupted && i < 10; i++)
d715 1
d720 2
a721 1
	  int i;
a722 3
    #if 0
	  mainthread.lock->release ();
    #endif
d725 1
a735 4
	  for (i = 0; i < SUSPEND_TRIES; i++)
	    {
	      sigproc_printf ("suspending mainthread");
	      res = SuspendThread (hth);
d737 2
a738 21
	      /* Just set pending if thread is already suspended */
	      if (res)
		goto set_pending;

	      muto *m;
	      /* FIXME: Make multi-thread aware */
	      for (m = muto_start.next;  m != NULL; m = m->next)
		if (m->unstable () || m->owner () == mainthread.id)
		  goto owns_muto;

    #if 0
	      mainthread.lock->acquire ();
    #endif
	      if (mainthread.frame)
		{
		  th = &mainthread;
		  goto next;
		}
    #if 0
	      mainthread.lock->release ();
    #endif
d740 3
a742 6
	      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	      if (!GetThreadContext (hth, &cx))
		{
		  system_printf ("couldn't get context of main thread, %E");
		  goto out;
		}
d744 8
a751 2
	      if (interruptible (cx.Eip, 1))
		break;
d753 5
a757 10
	      sigproc_printf ("suspended thread in a strange state pc %p, sp %p",
			      cx.Eip, cx.Esp);
	      goto resume_thread;

	    owns_muto:
	      sigproc_printf ("suspended thread owns a muto (%s)", m->name);

	    resume_thread:
	      ResumeThread (hth);
	      Sleep (0);
d760 10
a769 2
	  if (i >= SUSPEND_TRIES)
	    goto set_pending;
d771 4
a774 1
	  sigproc_printf ("SuspendThread returned %d", res);
d777 1
a777 1
    next:
d779 5
a783 1
	interrupted = interrupt_on_return (th, sig, siga, handler);
d805 3
a807 1
out:
a814 4

#if 0
  mainthread.lock->release ();
#endif
@


1.48
log
@* exceptions.cc (handle_sigsuspend): Record frame here for signalling.
(set_process_mask): Ditto.
@
text
@d33 1
d631 1
a631 1
static void
d637 1
d667 1
a667 1
interrupt_on_return (DWORD ebp, int sig, struct sigaction& siga, void *handler)
d670 1
d672 2
a673 2
  if (sigsave.sig)
    return 0;	/* Already have a signal stacked up */
d683 5
a692 1
  api_fatal ("couldn't send signal %d", sig);
d710 1
a710 1
  int interrupted = 1;
a711 1
  DWORD ebp;
d713 1
a713 1
  int using_mainthread_frame;
d722 1
a722 1
  if (mainthread.frame)
d724 3
a726 23
      ebp = mainthread.frame;
      using_mainthread_frame = 1;
    }
  else
    {
      int i;
      using_mainthread_frame = 0;
#if 0
      mainthread.lock->release ();
#endif

      hth = myself->getthread2signal ();
      /* Suspend the thread which will receive the signal.  But first ensure that
	 this thread doesn't have any mutos.  (FIXME: Someday we should just grab
	 all of the mutos rather than checking for them)
	 For Windows 95, we also have to ensure that the addresses returned by GetThreadContext
	 are valid.
	 If one of these conditions is not true we loop for a fixed number of times
	 since we don't want to stall the signal handler.  FIXME: Will this result in
	 noticeable delays?
	 If the thread is already suspended (which can occur when a program is stopped) then
	 just queue the signal. */
      for (i = 0; i < SUSPEND_TRIES; i++)
d728 5
a732 8
	  sigproc_printf ("suspending mainthread");
	  res = SuspendThread (hth);

	  muto *m;
	  /* FIXME: Make multi-thread aware */
	  for (m = muto_start.next;  m != NULL; m = m->next)
	    if (m->unstable () || m->owner () == mainthread.id)
	      goto owns_muto;
d734 12
a745 4
#if 0
	  mainthread.lock->acquire ();
#endif
	  if (mainthread.frame)
d747 2
a748 7
	      ebp = mainthread.frame;	/* try to avoid a race */
	      using_mainthread_frame = 1;
	      goto next;
	    }
#if 0
	  mainthread.lock->release ();
#endif
d750 21
a770 6
	  cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	  if (!GetThreadContext (hth, &cx))
	    {
	      system_printf ("couldn't get context of main thread, %E");
	      goto out;
	    }
d772 6
a777 2
	  if (interruptible (cx.Eip, 1))
	    break;
d779 2
a780 3
	  sigproc_printf ("suspended thread in a strange state pc %p, sp %p",
			  cx.Eip, cx.Esp);
	  goto resume_thread;
d782 11
a792 2
	owns_muto:
	  sigproc_printf ("suspended thread owns a muto (%s)", m->name);
d794 1
a794 1
	  if (res)
d797 1
a797 3
	resume_thread:
	  ResumeThread (hth);
	  Sleep (0);
d800 7
a806 5
      if (i >= SUSPEND_TRIES)
	goto set_pending;

      sigproc_printf ("SuspendThread returned %d", res);
      ebp = cx.Ebp;
d809 2
a810 4
next:
  if (!using_mainthread_frame && interruptible (cx.Eip))
    interrupt_now (&cx, sig, siga, handler);
  else if (!interrupt_on_return (ebp, sig, siga, handler))
a811 1
    set_pending:
d814 1
a814 1
      interrupted = 0;
d816 1
a816 2

  if (interrupted)
d894 3
d1114 1
a1114 1
	addl	$4,%%esp
d1133 1
d1148 2
d1159 3
a1161 1
2:	jmp	*%5
@


1.47
log
@* exceptions.cc (interruptible): Remove obsolete tests.
(sigreturn): Construct pseudo-frame-pointer so that signal handler can figure
out where to put return address when signals are coming in quickly.
* path.cc (cwdstuff::get): Allow length 0 buffer length when buffer when NULL.
@
text
@d557 1
d876 1
@


1.46
log
@* exceptions.cc (sig_handle): Just make sure that wait_sig loops when receiving
a SIGCONT.  Don't block waiting for completion that will never occur.
@
text
@a32 1
extern DWORD __sigfirst, __siglast;
d582 22
a603 1
  if ((pc >= (DWORD) &__sigfirst) && (pc <= (DWORD) &__siglast))
d606 4
a609 28
    {
      MEMORY_BASIC_INFORMATION m;
      memset (&m, 0, sizeof m);
      if (!VirtualQuery ((LPCVOID) pc, &m, sizeof m))
	sigproc_printf ("couldn't get memory info, pc %p, %E", pc);

      char *checkdir = (char *) alloca (windows_system_directory_length + 4);
      memset (checkdir, 0, sizeof (checkdir));
#     define h ((HMODULE) m.AllocationBase)
      /* Apparently Windows 95 can sometimes return bogus addresses from
	 GetThreadContext.  These resolve to an allocation base == 0.
	 These should *never* be treated as interruptible. */
      if (!h || m.State != MEM_COMMIT)
	res = 0;
      else if (testvalid)
	res = 1;	/* All we wanted to know was if this was a valid module. */
      else if (h == user_data->hmodule)
	res = 1;
      else if (h == cygwin_hmodule)
	res = 0;
      else if (!GetModuleFileName (h, checkdir, windows_system_directory_length + 2))
	res = 0;
      else
	res = !strncasematch (windows_system_directory, checkdir,
			      windows_system_directory_length);
      minimal_printf ("h %p", h);
#     undef h
    }
d1039 1
d1082 1
a1082 2
static void __stdcall
reset_signal_arrived () __attribute__ ((unused));
d1101 2
d1115 1
d1122 1
a1138 1
___sigfirst:
a1140 1
___siglast:
@


1.45
log
@* exceptions.cc (signal_exit): Kill any executing child process if we're dying.
* path.h: Remove unneeded extern.
* spawn.cc (std_suffixes): Make static.  Don't set dwProcessId here since it
makes the process unsignalable.  Set strace flag that this is an execed process
stub.
* strace.cc (strace::vsprntf): Use strace flag to indicate when to visually
flag that this is an exec stub.
* include/sys/strace.h (strace): Add 'execing' flag.
@
text
@d950 1
a950 1
      sig_dispatch_pending ();
@


1.44
log
@* dcrt0.cc (sigthread::init): Correct overzealous ifdef.
* exceptions.cc (call_handler): Avoid calling sigthread acquire lock.
* sigproc.h (sigthread): Comment out lock for now.
* sync.cc (muto::acquire): Add a minor optimization.
@
text
@d1020 2
d1039 3
@


1.43
log
@* exceptions.cc (call_handler): Make signal pending if sigsave.sig is still
active.
* syscalls.cc (_read): Don't clear errno.
* sigproc.cc (wait_sig): Don't scan the waiting process list after a SIGCHLD if
there are no zombies to reap.
* winsup.h: Use __builtin_strcmp.
* environ.cc (posify): Don't initialize len unless it is required
(from DJ Delorie <dj@@redhat.com>).
@
text
@d712 1
d714 1
d728 1
d730 1
d754 1
d756 1
d763 1
d765 1
d827 1
d829 1
@


1.42
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d219 1
a219 1
signal_dispatch sigsave;
d713 3
@


1.41
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@a20 1
#include "thread.h"
d641 1
a641 1
void __cdecl
d655 12
d789 1
a789 1
  if (hExeced != NULL || (!using_mainthread_frame && interruptible (cx.Eip)))
@


1.40
log
@* cygheap.cc (cygheap_fixup_in_child): Don't page round cygheap copied from
parent.
* dcrt0.cc (do_exit): Don't cleanup pinfo on exit.  That happens automatically
now.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_parent): Use stack_here value passed in from fork().
(fork): Figure out top of stack here and pass it to fork_parent.
* pinfo.cc (_pinfo::record_death): Eliminate.
* pinfo.h (_pinfo): Ditto.
* sigproc.cc (proc_exists): Simplify.
(proc_terminate): Ditto.
(remove_zombie): Don't cleanup pinfo stuff.
(wait_sig): Send subproc_ready signal whether execed or spawned.
* spawn.cc (spawn_guts): Always create subproc_ready event.  Use it for both
exec and spawn.
(_spawnve): Send proper mode to spawn_guts when mode != _P_OVERLAY.
@
text
@a49 1
HANDLE NO_COPY console_handler_thread_waiter = NULL;
a127 4
  /* Allocate the event needed for ctrl_c_handler synchronization with
     wait_sig. */
  if (!console_handler_thread_waiter)
    CreateEvent (&sec_none_nih, TRUE, TRUE, NULL);
a822 5
  /* Wait for sigproc_init to tell us that it's safe to send something.
     This event will always be in a signalled state when wait_sig is
     ready to process signals. */
  (void) WaitForSingleObject (console_handler_thread_waiter, 5000);

d998 1
a998 1
    ExitProcess (rc);
@


1.39
log
@* child_info: Bump child_info "version".
(child_info): Move some fields from child_info_spawn to here.
* cygheap.cc: Make cygheap pointers NOCOPY.
* dcrt0.cc (dll_crt0_1): Copy cygwin heap here regardless of whether we've been
forked or execed.
* dtable.cc (dtable::fixup_after_fork): Just release close-on-exec fds.
* exceptions.cc (stackdump): Respond to C warning.
* fork.cc: Reorganize to minimize stack copying.
(fork_child): New function.
(fork_parent): Ditto.
(sync_with_child): Don't suspend the forkee.
(sync_with_parent): Ditto.  Make into a function.
* heap.cc (heap_init): Add some debugging output.
* path.cc (path_conv::check): Add an assertion.
(has_suffix): Ditto.
* security.cc (get_pw_sid): Defend against NULL.
* sigproc.cc (proc_subproc): Fix debugging output.
(wait_sig): Ditto.
* strace.cc: Make statics NO_COPY throughout.
(strace::vsprntf): Defend against NULL.
@
text
@d1008 1
a1008 5
    {
      /* We are going down - reset our process_state without locking. */
      myself->record_death ();
      ExitProcess (rc);
    }
@


1.38
log
@* dtable.cc (set_std_handle): Use std_consts array to control SetStdHandle
settings.
(dtable::fixup_after_fork): Ditto.
* exceptions.cc (set_sig_errno): Remove some debugging output.
* path.cc (path_conv::check): Don't OR need_directory with flags sent to
symlink_info::check.
(symlink_info::check): Use PATH_ALL_EXEC to determine when a file is
executable.
* path.h (path_types): Add PATH_ALL_EXEC.
(isexec): Use PATH_ALL_EXEC so that cygexec types will be considered
executable.
* pinfo.h (_pinfo): Add a process handle that is kept open throughout the life
of a cygwin pid.
* sigproc.cc (proc_exists): Remove hopefully obsolete stuff.
(proc_subproc): Set up process handle that is kept open throughout the life of
a cygwin pid.  Reorganize PROC_WAIT stuff to use common code.
(proc_terminate): Close pid lifetime process handle.
(checkstate): Cleanup.
(stopped_or_terminated): Move zombie cleanup.
(remove_zombie): To here.
* spawn.cc (spawn_guts): Reorganize reparenting code for 1247th time.
@
text
@d388 1
a388 1
  char *p;
@


1.37
log
@* exceptions.cc (interruptible): Add extra debugging.
* sigproc.h (wait_sig): Fill in frame pointer, by default, prior to calling or
suffer confusion due to September 7 change below.
@
text
@d691 1
a691 1
  debug_printf ("errno %d", e);
@


1.36
log
@* exceptions.cc (interruptible): Return 0 if given an address in uncommitted
memory.
@
text
@d596 1
a596 1
	sigproc_printf ("couldn't get memory info, %E");
@


1.35
log
@* exceptions.cc (handle_exceptions): Just "core dump" if SIGSEGV in signal
thread.
* external.cc (fillout_pinfo): Fix compiler warning.
* sigproc.h: Eliminate special asm naming for sig_dispatch_pending.
* sigproc.cc (sig_send): Remove debugging statements.
@
text
@d604 1
a604 1
      if (!h)
@


1.34
log
@* cygheap.cc (init_cheap): Just use any old address for the cygwin heap.
* exceptions.cc (signal_exit): Don't terminate the main thread.  Just try to
exit in this thread really quickly.
* signal.cc (kill_pgrp): Fix typo which caused pinfo structure to be assigned
incorrectly.
@
text
@d37 2
d496 1
a864 2
  extern DWORD sigtid;

@


1.33
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@a994 5
  TerminateThread (hMainThread, 0);
  /* FIXME: This just works around the problem so that we don't attempt to
     use a resource lock when exiting.  */
  user_data->resourcelocks->Delete ();
  user_data->resourcelocks->Init ();
a1004 9
  /* If the exception handler gets a trap, we could recurse awhile.
     If this is non-zero, skip the cleaning up and exit NOW.  */

  muto *m;
  /* FIXME: Make multi-thread aware */
  for (m = muto_start.next;  m != NULL; m = m->next)
    if (m->unstable () || m->owner () == mainthread.id)
      m->reset ();

d1012 14
@


1.32
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@a22 1
#include "tty.h"
d24 2
@


1.31
log
@* exceptions.cc (signal_exit): Reset all mutos owned by the main thread.
* fhandler.h: Define *_output_mutex macros for serializing tty output.
(fhandler_termios): Remove restart_output_event.  Define dummy output mutex
methods.
(fhandler_pty_master): Remove unneeded fixup_after_fork method.
* fhandler_termios.cc (fhandler_termios::line_edit): Acquire output_mutex when
CTRL-S is hit.  Release it on CTRL-Q.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Remove
inappropriate OutputStopped test here.  Just use the output mutex.
(fhandler_pty_master::fhandler_pty_master): Remove obsolete reference to
restart_output_event.
(fhandler_tty_common::close): Ditto.
(fhandler_pty_master::set_close_on_exec): Ditto.
(fhandler_pty_master::fixup_after_fork): Delete.
* tty.cc (tty::common_init): Ditto.
* sync.cc (muto::reset): New method.
* sync.h: Declare above method.
@
text
@d23 2
@


1.30
log
@* signal.cc (_raise): New function.
* exceptions.cc (unused_sig_wrapper): Remove _raise.
* sigproc.h (class sigframe): Default frames to skip to zero or suffer from
exuberant optimization.
* fhandler_tty.cc (fhandler_tty::write): Set appropriate errno when WriteFile
to pipe fails.
@
text
@d1010 6
@


1.29
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@a1076 12
	.globl	__raise
__raise:
	pushl	%%ebp
	movl	%%esp,%%ebp
	movl	8(%%ebp),%%eax
	pushl	%%eax
	movl	$_myself,%%eax
	pushl	%6(%%eax)
	call	__kill
	mov	%%ebp,%%esp
	popl	%%ebp
	ret
@


1.28
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d13 1
a13 1
#include <stdio.h>
d17 2
a18 1
#include <imagehlp.h>
d21 2
@


1.27
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d19 1
@


1.26
log
@* strace.cc (strace::prntf): Make second argument the function name, rather
than use special format options.
(strace::vprntf): Ditto.
(getfunc): New function.
* include/sys/strace.h: Reflect above changes.
* smallprint.c (__small_vsprintf): Eliminate '%F' formatting.
* pinfo.cc (set_myself): Modify for new strace::prntf parameter.
* errno.cc (seterrno_from_win_error): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Ditto.
@
text
@d18 1
@


1.25
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d157 1
a157 1
  const char *exception_name = 0;
@


1.24
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d11 2
a15 2
#define Win32_Winsock
#include "winsup.h"
@


1.23
log
@Give signal_exit noreturn attribute.
@
text
@a317 1
  ReleaseMutex (pinfo_mutex);
d879 1
a879 1
      pinfo *parent = procinfo (myself->ppid);
d1009 1
a1009 1
      myself->record_death (FALSE);
a1015 1
HANDLE NO_COPY pinfo_mutex = NULL;
a1020 8
  /* pinfo_mutex protects access to process table */

  if (!(pinfo_mutex = CreateMutex (&sec_all_nih, FALSE,
				   shared_name ("pinfo_mutex", 0))))
    api_fatal ("catastrophic failure - unable to create pinfo_mutex, %E");

  ProtectHandle (pinfo_mutex);

a1048 1
//CloseHandle (pinfo_mutex);	// Use implicit close on exit to avoid race
d1053 1
a1053 1
#define pid_offset (unsigned)(((pinfo *)NULL)->pid)
@


1.22
log
@* exceptions.cc (signal_exit): Renamed from "really+exit".  Always sets
EXIT_SIGNAL bit and reorganizes exit value for backwards cygwin handling.
(handle_exceptions): Call signal_exit.  Set "core dumped" bit.
(sig_handle): Call signal_exit.  Set "core dumped" bit appropriately.
@
text
@d30 1
a30 1
static void signal_exit (int);
@


1.21
log
@* exceptions.cc (try_to_debug): Prevent recursive spawning of JIT debugger.
Treat special event from debugger as command to continue.
@
text
@d30 1
a30 1
static void really_exit (int);
d521 1
a521 1
      really_exit (EXIT_SIGNAL | sig);
a871 11
#if 0
  HANDLE waitbuf[2];

  /* Be sure that process's main thread isn't an owner of vital
     mutex to prevent cygwin subsystem lockups */
  waitbuf[0] = pinfo_mutex;
  waitbuf[1] = title_mutex;
  WaitForMultipleObjects (2, waitbuf, TRUE, INFINITE);
  ReleaseMutex (pinfo_mutex);
  ReleaseMutex (title_mutex);
#endif
d985 1
a985 1
      really_exit (EXIT_SIGNAL | sig);
d993 1
a993 1
  do_exit (EXIT_SIGNAL | (sig << 8));
d998 1
a998 1
   exceptions.  We use to call exit, but a SIGSEGV shouldn't cause atexit
a999 1

d1001 1
a1001 1
really_exit (int rc)
d1006 1
@


1.20
log
@* exceptions.cc (stack_info::walk): Use method to find offset.
(handle_exceptions): Be more assertive in finding ebp for use under W2K.
Create a dummy stack frame for cases where program is dying and a stack dump is
being output.
(sig_handle): Fill out a GetThreadContext for use with a user-generated "core
dump".
@
text
@d199 1
a199 1
  int walk ();		 	/* Uses the "old" method */
d204 1
a204 1
  stack_info (): first_time(1) {}
d211 1
a211 1
#define NPARAMS (sizeof(thestack.sf.Params) / sizeof(thestack.sf.Params[0]))
d222 1
a222 1
  memset (&sf, 0, sizeof(sf));
d280 1
a280 1
cygwin_stackdump()
d290 2
d321 15
d350 1
a350 1
        resume_all_threads_except (current_thread_id);
d355 4
d361 10
a370 1
	Sleep (10000);
d387 1
a387 1
      char corefile[strlen(p) + sizeof(".stackdump")];
d472 2
a473 2
  if (myself->getsig(sig).sa_mask & SIGTOMASK (sig))
    syscall_printf ("signal %d, masked %p", sig, myself->getsig(sig).sa_mask);
d476 1
a476 1
		 myself->getsig(sig).sa_handler);
d487 3
a489 3
      || (void *) myself->getsig(sig).sa_handler == (void *) SIG_DFL
      || (void *) myself->getsig(sig).sa_handler == (void *) SIG_IGN
      || (void *) myself->getsig(sig).sa_handler == (void *) SIG_ERR)
d509 1
a509 1
        system_printf ("Error while dumping state (probably corrupted stack)");
d605 1
a605 1
        res = !strncasematch (windows_system_directory, checkdir,
d634 1
a634 1
  SetThreadContext (myself->getthread2signal(), ctx); /* Restart the thread */
d650 1
a650 1
  
d756 1
a756 1
	  
d788 1
a788 1
      proc_subproc(PROC_CLEARWAIT, 1);
d831 1
a831 1
  tty_min *t = cygwin_shared->tty.get_tty(myself->ctty);
d891 1
a891 1
      pinfo *parent = procinfo(myself->ppid);
d909 1
a909 1
  struct sigaction thissig = myself->getsig(sig);
d1002 2
a1003 2
  user_data->resourcelocks->Delete();
  user_data->resourcelocks->Init();
d1086 1
a1086 1
void unused_sig_wrapper()
d1153 1
a1153 1
  );
@


1.19
log
@* exceptions.cc: Remove unneeded include.
* dcrt0.cc: Wrap LoadDLLfunc stuff in dummy function.
* init.cc: Ditto.
* uinfo.cc: Ditto.
@
text
@d200 1
d237 1
a237 1
  else if ((ebp = (char **) *(char **) sf.AddrFrame.Offset) != NULL)
d259 1
a259 1
void
d266 1
a266 1
  for (i = 0; i < 16 && thestack++ ; i++)
d285 1
a285 1
  stack(&c);
d346 1
a346 1
void
d445 11
d482 7
a488 4
	  HANDLE hthread;
	  DuplicateHandle (hMainProc, GetCurrentThread (),
			   hMainProc, &hthread, 0, FALSE, DUPLICATE_SAME_ACCESS);
	  stackdump (e, in);
a493 11
  debug_printf ("In cygwin_except_handler calling %p",
		 myself->getsig(sig).sa_handler);

  DWORD *ebp = (DWORD *)in->Esp;
  for (DWORD *bpend = ebp - 16; ebp > bpend; ebp--)
    if (*ebp == in->SegCs && ebp[-1] == in->Eip)
      {
	ebp -= 2;
	break;
      }

d961 4
a964 1
      stackdump (NULL, NULL);
d966 1
@


1.18
log
@* Makefile.in: Remove libadvapi32.a.
* autoload.h: Add additional field to autoload block for handling unimplemented
functions.
(LoadDLLfuncEx): New function which accepts additional parameter for
controlling unimplemented function behavior.
(LoadDLLfunc): Use LoadDLLfuncEx.
* dcrt0.cc: Use new arguments for LoadDLLfunc.  Add advapi32 routines.
(noload): Rewrite in assembler.  Handle new unimplemented function type.
* exceptions.cc: Eliminate another vestige of StackWalk stuff.
* net.cc: Use new arguments for LoadDLLfunc.
* uinfo.cc: Ditto.

* config.h.in: Remove obsolete define.
* path.h (isdrive): New macro.
* dcrt0.cc (globify): Use new macro to determine if a string refers to an
MS-DOS drive.
* environ.cc (winenv): Ditto.
* spawn.cc (find_exec): Ditto.
* path.cc (get_raw_device_number): Ditto.
(mount_info::conv_to_posix_path): Ditto.
(chdir): Ditto.
(cygwin_posix_path_list_p): Ditto.
(cygwin_split_path): Ditto.
(path_conv::check): Move tmp_buf to beginning of function since it can be used
earlier in the loop.  Use tmp_buf rather than 'root' to hold root information.
(mount_info::conv_to_win32_path): Add trailing slash to end of mount path when
it translates to a drive.  Add defensive code to avoid writing beyond the end
of 'dst'.
@
text
@a16 2
#undef DECLSPEC_IMPORT
#define DECLSPEC_IMPORT
a17 1
#include "autoload.h"
@


1.17
log
@* exceptions.cc (interruptible): Add an argument to control whether function
just checks for validity.  Flag module handle == 0 as noninterrupible.
(call_handler): Always acquire and release ebp lock.  Loop for only a fixed
amount of time attempting to grab mutos and find an interruptible PC.
@
text
@a197 11
/* The function used to load the imagehlp DLL.  Returns TRUE if the
   DLL was found. */
static LoadDLLinitfunc (imagehlp)
{
  imagehlp_handle = LoadLibrary ("imagehlp.dll");
  return !!imagehlp_handle;
}

LoadDLLinit (imagehlp)	/* Set up storage for imagehlp.dll autoload */
LoadDLLfunc (StackWalk, StackWalk@@36, imagehlp)

@


1.16
log
@* path.cc (mount_info::cygdrive_posix_path): Don't add trailing slash if
referring to something like c:\.
* dcrt0.cc (dll_crt0_1): Move uinfo initialization prior to sig_send
initialization to give signal thread a chance to finish.
* debug.cc (WFSO): Move to sigproc.cc
(WFMO): Ditto.
* exceptions.cc (interruptible): Allocate slightly more space for directory
just for paranoia's sake.
(call_handler): Eliminate nonmain argument.  Determine if main thread has set a
frame pointer and use it if so.
(sig_handle): Eliminate nonmain argument.
* net.cc: Record frame information in appropriate routines throughout.
* select.cc (select): Ditto.
* sigproc.cc: Use sigthread structure to record mainthread id throughout.
(sig_send): Record frame information for signal handler.
(wait_sig): Reflect argument change in sig_handle.
(WFSO): Move here and record frame information for signal handler.
(WFMO): Ditto.
* sigproc.h: Implement new "sigthread" class.  Implement "sigframe" class for
manipulating signal frame info.
* thread.cc (__pthread_kill): Use standard _kill() function rather than calling
sig_send directly.
* winsup.h: Eliminate ebp element from signal_dispatch class.
@
text
@d556 1
a556 1
interruptible (DWORD pc)
d571 8
a578 1
      if (h == user_data->hmodule)
d664 2
d674 3
a676 1
  int locked;
d678 1
a678 3
  if (!mainthread.lock)
    locked = 0;
  else
d680 2
a681 2
      mainthread.lock->acquire ();
      locked = 1;
a682 3

  if (mainthread.frame)
    ebp = mainthread.frame;
d685 3
a687 5
      if (locked)
	{
	  mainthread.lock->release ();
	  locked = 0;
	}
d691 10
a700 5
	 this thread doesn't have the sync_proc_subproc and mask_sync mutos, since
	 we need those (hack alert).  If the thread-to-be-suspended has either of
	 these mutos, enter a busy loop until it is released.  If the thread is
	 already suspended (which should never occur) then just queue the signal. */
      for (;;)
d709 1
a709 1
	      goto keep_looping;
d711 1
d715 2
a716 1
	      goto ebp_set;
d718 11
d730 3
a732 1
	  break;
d734 1
a734 1
	keep_looping:
d736 1
d738 1
a738 1
	      goto set_pending;
d740 1
d745 3
a748 7

      cx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
      if (!GetThreadContext (hth, &cx))
	{
	  system_printf ("couldn't get context of main thread, %E");
	  goto out;
	}
d752 2
a753 2
ebp_set:
  if (hExeced != NULL || (!mainthread.frame && interruptible (cx.Eip)))
d780 1
a780 2
  if (locked)
    mainthread.lock->release ();
@


1.15
log
@* dcrt0.cc (insert_file): Eliminate unused parameter.
(build_argv): Ditto.
* exceptions.cc (stack): Eliminate unused parameters.
(stackdump): Ditto.
(cygwin_stackdump): Reflect above changes.
(sig_handle): Ditto.
* fhandler.cc (fhandler_base::set_inheritance): Use kludge to avoid unused
parameter warning.
@
text
@a20 1
#include "sync.h"
d568 2
a569 1
      char *checkdir = (char *) alloca (windows_system_directory_length + 2);
a599 1
  sigsave.ebp = 0;
d658 1
a658 1
call_handler (int sig, struct sigaction& siga, void *handler, int nonmain)
a660 1
  DWORD ebp;
d663 1
d665 1
d667 2
a668 2
  if (!nonmain)
    ebp = sigsave.ebp;
d671 14
d699 1
a699 1
	    if (m->unstable () || m->owner () == maintid)
d702 6
d730 2
a731 1
  if (hExeced != NULL || (nonmain && interruptible (cx.Eip)))
d758 3
d862 1
a862 1
sig_handle (int sig, int nonmain)
d941 1
a941 1
  rc = call_handler (sig, thissig, handler, nonmain);
@


1.14
log
@* exceptions.cc (interruptible): Allocate slightly more space for directory
name check.  Windows 95 seems to null-terminate the directory otherwise.
(interrupt_on_return): Issue a fatal error if we can't find the caller's stack.
* spawn.cc (find_exec): Accept a path_conv argument rather than a buffer so
that the caller can find things out about a translated path.
(perhaps_suffix): Ditto.
(spawn_guts): Allocate path_conv stuff here so that we can find out stuff about
the translated path (this is work in progress).
* environ.cc (environ_init): Accept an as-yet unused argument indicating
whether we were invoked from a cygwin parent or not.
(winenv): Ditto.
(posify): Accept an argument indicating whether the path has already been
translated.
* dlfcn.cc (check_access): Provide a path_conv buffer to find_exec.
* exec.cc (sexecvpe): Ditto.
* path.cc (path_conv::check): Rename from path_conv::path_conv.
(mount_item::getmntent): Recognize "Cygwin executable" bit.
(symlink_info::check): Remove debugging statements.
* path.h (class path_conv): Add iscygexec method.  Rewrite constructor to call
"check" method to allow multiple operations on a path_conv variable.
* pinfo.cc (pinfo_init): Pass argument to environ_init.
* shared.h: Bump PROC_MAGIC.
* winsup.h: Reflect above changes to function arguments.
* include/sys/mount.h: Add MOUNT_CYGWIN_EXEC type.
@
text
@d272 1
a272 1
/* Dump the stack using either the old method or the new Win32 API method */
d274 1
a274 1
stack (HANDLE hproc, HANDLE hthread, CONTEXT *cx)
d298 2
a299 4
  HANDLE h1 = GetCurrentProcess ();
  HANDLE h2 = GetCurrentThread ();
  GetThreadContext (h2, &c);
  stack(h1, h2, &c);
d361 1
a361 1
stackdump (HANDLE hproc, HANDLE hthread, EXCEPTION_RECORD *e, CONTEXT *in)
d383 1
a383 1
  stack (hproc, hthread, in);
d488 1
a488 1
	  stackdump (hMainProc, hthread, e, in);
d926 1
a926 1
      stackdump (NULL, NULL, NULL, NULL);
@


1.13
log
@* exceptions.cc (handle_exceptions): Search further for stack info to
accomodate Windows 95.
@
text
@d571 1
a571 1
      char *checkdir = (char *) alloca (windows_system_directory_length);
d577 1
a577 1
      else if (!GetModuleFileName (h, checkdir, windows_system_directory_length))
d645 1
a645 1
	break;
d648 2
a649 1
  return 1;
@


1.12
log
@* exceptions.cc (sigsave): Copy on fork so that we can restore correct behavior
in forked process.
(interruptible): Flag as interruptible when running in main process module.
(interrupt_setup): Save return address and address of return address.
(signal_fixup_after_fork): New function.  Uses above two values to restore
proper behavior to forked process.
(interrupt_on_return): Pass return address address to interupt_setup.
(interrupt_now): Pass NULL for return address address to interrupt_setup.
* fork.cc (fork): Call signal_fixup_after_fork.
* shared.h: Lint cleanups.
* winsup.h: Ditto.
@
text
@d500 1
a500 1
  for (DWORD *bpend = ebp - 8; ebp > bpend; ebp--)
@


1.11
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@d43 1
a43 1
HMODULE cygwin_hmodule;
d229 1
a229 1
signal_dispatch NO_COPY sigsave;
d561 1
a561 6
#if 0
  DWORD pchigh = pc & 0xf0000000;
  return ((pc >= (DWORD) &__sigfirst) && (pc <= (DWORD) &__siglast)) ||
	 !(pchigh == 0xb0000000 || pchigh == 0x70000000 || pchigh == 0x60000000);
#else
  int res = 1;
d573 3
a575 1
      if (h == cygwin_hmodule)
d582 2
d586 1
a586 1
  sigproc_printf ("interruptible %d", res);
a587 2
# undef h
#endif
d591 2
a592 1
interrupt_setup (int sig, struct sigaction& siga, void *handler, DWORD retaddr)
d595 1
d608 1
a608 1
  interrupt_setup (sig, siga, handler, ctx->Eip);
d613 14
d642 1
a642 1
	    interrupt_setup (sig, siga, handler, *addr_retaddr);
a1070 2
#	pushl	_signal_arrived	# Everybody waiting for this should
#	call	_ResetEvent@@4	# have woken up by now.
@


1.10
log
@* environ.cc: Eliminate oldstack CYGWIN option.
* exceptions.cc (sfta): Eliminate obsolete function.
(sgmb): Eliminate obsolete function.
(class stack_info): Remove MS method for walking the stack.
(stack_info::init): Just initialize required fields.
(stack_info::brute_force): Rename to stack_info::walk.
(handle_exceptions): Pass derived frame pointer to sig_send.
(interrupt_setup): Clear saved frame pointer here.
(interrupt_on_return): thestack is no longer a pointer.
(call_handler): Accept a flag to indicate when a signal was sent from other
than the main thread.  Use saved frame pointer for determining where to place
signal handler call.
(sig_handle): Accept "nonmain" argument.  Pass it to call_handler.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Change
debugging output slightly.
* (fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_tty_slave::read): Fix a comment, remove a goto.
* sigproc.cc (sig_send): Accept an optional frame pointer argument for use when
suspending the main process.  sigcomplete_main is an autoreset event now.  Save
frame pointer for non-main operation.
(wait_sig): Make sigcomplete_main an autoreset event.  Eliminate NOSIGQUEUE.
Pass rc to sig_handle to signify if this was a nonmain process.
* sigproc.h: Reflect change to sig_send argument.
* syscalls.cc (swab): Eliminate swab function since it is now available in
newlib.
* winsup.h (signal_dispatch): Change CONTEXT cx to DWORD ebp.
@
text
@a654 8
  if (hExeced != NULL && hExeced != INVALID_HANDLE_VALUE)
    {
      SetEvent (signal_arrived);	// For an EINTR case
      sigproc_printf ("armed signal_arrived");
      exec_exit = sig;			// Maybe we'll exit with this value
      goto out1;
    }

d670 1
d672 1
a672 1
	  for (muto *m = muto_start.next;  m != NULL; m = m->next)
d679 1
a679 1
	  sigproc_printf ("suspended thread owns a muto");
d698 1
a698 1
  if (nonmain && interruptible (cx.Eip))
a724 1
out1:
d969 1
a969 1
  mask_sync = new_muto (FALSE, NULL);
@


1.9
log
@* exceptions.cc (call_handler): Streamline to use only one call to
ResumeThread.
* sigproc.cc (sig_send): Use a muto around the ReleaseSemaphore.  Remove
priority setting since it didn't solve anything.
@
text
@a193 13
extern "C" {
static LPVOID __stdcall
sfta(HANDLE, DWORD)
{
  return NULL;
}

static DWORD __stdcall
sgmb(HANDLE, DWORD)
{
  return 4;
}

a198 3
/* Set from CYGWIN environment variable if want to use old method. */
BOOL NO_COPY oldstack = 0;

d214 1
a214 3
  HANDLE hproc;			/* Handle of process to inspect. */
  HANDLE hthread;		/* Handle of thread to inspect. */
  int (stack_info::*get) (HANDLE, HANDLE); /* Gets the next stack frame */
d217 3
a219 13
  int walk (HANDLE, HANDLE);	/* Uses the StackWalk function */
  int brute_force (HANDLE, HANDLE); /* Uses the "old" method */
  void init (CONTEXT *);	/* Called the first time that stack info is needed */

  /* The constructor remembers hproc and hthread and determines which stack walking
     method to use */
  stack_info (int use_old_stack, HANDLE hp, HANDLE ht): hproc(hp), hthread(ht)
  {
    if (!use_old_stack && LoadDLLinitnow (imagehlp))
      get = &stack_info::walk;
    else
      get = &stack_info::brute_force;
  }
d221 1
a221 1
  int operator ++(int) { return (this->*get) (hproc, hthread); }
d225 1
a225 1
#define NPARAMS (sizeof(thestack->sf.Params) / sizeof(thestack->sf.Params[0]))
d228 2
a229 2
static stack_info *thestack = NULL;
static signal_dispatch sigsave;
d233 1
a233 1
stack_info::init (CONTEXT *cx)
d237 2
a238 5
  sf.AddrPC.Offset = cx->Eip;
  sf.AddrPC.Mode = AddrModeFlat;
  sf.AddrStack.Offset = cx->Esp;
  sf.AddrStack.Mode = AddrModeFlat;
  sf.AddrFrame.Offset = cx->Ebp;
d245 1
a245 1
stack_info::brute_force (HANDLE, HANDLE)
a271 20
/* Use Win32 StackWalk() API to display the stack.  This is theoretically
   more foolproof than the brute force method above. */
int
stack_info::walk (HANDLE hproc, HANDLE hthread)
{
#ifdef SOMEDAY
  /* It would be nice to get more information (like DLL symbols and module name)
     for each stack frame but in order to do that we have to call SymInitialize.
     It doesn't seem to be possible to do this inside of an excaption handler for
     some reason. */
  static int initialized = 0;
  if (!initialized && !SymInitialize(hproc, NULL, TRUE))
    small_printf("SymInitialize error, %E\n");
  initialized = 1;
#endif

  return StackWalk (IMAGE_FILE_MACHINE_I386, hproc, hthread, &sf, NULL, NULL,
		    sfta, sgmb, NULL) && !!sf.AddrFrame.Offset;
}

d278 1
a278 5
  /* Set this up if it's the first time. */
  if (!thestack)
    thestack = new stack_info (oldstack, hproc, hthread);

  thestack->init (cx);	/* Initialize from the input CONTEXT */
d280 1
a280 1
  for (i = 0; i < 16 && (*thestack)++ ; i++)
d282 2
a283 2
      small_printf ("%08x  %08x ", thestack->sf.AddrFrame.Offset,
		    thestack->sf.AddrPC.Offset);
d285 1
a285 1
	small_printf ("%s%08x", j == 0 ? " (" : ", ", thestack->sf.Params[j]);
d499 3
a501 3
  DWORD *bp = (DWORD *)in->Esp;
  for (DWORD *bpend = bp - 8; bp > bpend; bp--)
    if (*bp == in->SegCs && bp[-1] == in->Eip)
d503 1
a503 1
	bp -= 2;
d507 1
a507 4
  in->Ebp = (DWORD) bp;
  sigsave.cx = in;
  sig_send (NULL, sig);		// Signal myself
  sigsave.cx = NULL;
a518 1
}
d603 1
d615 1
a615 1
interrupt_on_return (CONTEXT *ctx, int sig, struct sigaction& siga, void *handler)
d622 3
a624 8
  /* Set this up if it's the first time. */
  /* FIXME: Eventually augment to handle more than one thread */
  if (!thestack)
    thestack = new stack_info (oldstack, hMainProc, hMainThread);

  thestack->init (ctx);  /* Initialize from the input CONTEXT */
  for (i = 0; i < 32 && (*thestack)++ ; i++)
    if (interruptible (thestack->sf.AddrReturn.Offset))
d626 2
a627 2
	DWORD *addr_retaddr = ((DWORD *)thestack->sf.AddrFrame.Offset) + 1;
	if (*addr_retaddr  == thestack->sf.AddrReturn.Offset)
d647 1
a647 1
call_handler (int sig, struct sigaction& siga, void *handler)
d649 2
a650 1
  CONTEXT *cx, orig;
d652 1
a652 1
  HANDLE hth;
a661 1
  hth = myself->getthread2signal ();
d663 14
a676 14
  /* Suspend the thread which will receive the signal.  But first ensure that
     this thread doesn't have the sync_proc_subproc and mask_sync mutos, since
     we need those (hack alert).  If the thread-to-be-suspended has either of
     these mutos, enter a busy loop until it is released.  If the thread is
     already suspended (which should never occur) then just queue the signal. */
  for (;;)
    {
      sigproc_printf ("suspending mainthread");
      res = SuspendThread (hth);

      /* FIXME: Make multi-thread aware */
      for (muto *m = muto_start.next;  m != NULL; m = m->next)
	if (m->unstable () || m->owner () == maintid)
	  goto keep_looping;
d678 11
a688 1
      break;
d690 3
a692 8
    keep_looping:
      sigproc_printf ("suspended thread owns a muto");
      if (res)
	  goto set_pending;

      ResumeThread (hth);
      Sleep (0);
    }
d694 1
a694 1
  sigproc_printf ("SuspendThread returned %d", res);
d696 2
a697 11
  if (sigsave.cx)
    {
      cx = sigsave.cx;
      sigsave.cx = NULL;
    }
  else
    {
      cx = &orig;
      /* FIXME - this does not preserve FPU state */
      orig.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
      if (!GetThreadContext (hth, cx))
d702 1
d705 3
a707 3
  if (cx == &orig && interruptible (cx->Eip))
    interrupt_now (cx, sig, siga, handler);
  else if (!interrupt_on_return (cx, sig, siga, handler))
d717 1
a717 1
      (void) SetEvent (signal_arrived);	// For an EINTR case
d724 7
a730 2
  res = ResumeThread (hth);
  sigproc_printf ("ResumeThread returned %d", res);
d834 1
a834 1
sig_handle (int sig)
d913 1
a913 1
  rc = call_handler (sig, thissig, handler);
@


1.8
log
@* dcrt0.cc (set_os_type): Record OS name string.
(getprogname): Eliminate obsolete function.
(dll_crt0_1): Move initial strace initialization output to set_myself.
* exceptions.cc (interruptible): Add debugging output.
(interrupt_setup): New function.
(interrupt_now): Use interrupt_setup to set up common interrupt handler stuff.
(interrupt_on_return): Ditto.
(call_handler): Move signal_arrived arm and clear threads to region where
signalled thread is suspended or suffer races.
* pinfo.cc (set_myself): Output interesting information when strace is first
initialized.  Initialize progname here.
* sigproc.cc (sig_dispatch_pending): Modify to ensure that flush signal are
sent synchronously.
* strace.cc (strace_vsprintf): Move code into strace program.
* uname.cc (uname): Use 'osname' global to construct cygwin name + Windows type
+ version.
@
text
@d722 1
a722 1
      goto out;
d752 1
a752 1
  sigproc_printf ("suspend said %d, %E", res);
a766 1
	  ResumeThread (hth);
d789 3
a791 1
  (void) ResumeThread (hth);
d793 1
a793 1
out:
d1050 3
@


1.7
log
@* exceptions.cc (interruptible): Make a little more structured.
(call_handler): Allow signals to be sent even if signalled thread is stopped.
Change order of signal_arrived arming/waiting threads clearing to eliminate a
race.
(reset_signal_arrived): New helper function.
* malloc.cc (malloc_init): Use mutos so that signal handler can keep track of
who owns the lock.
(__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* sync.h (new_muto): Actually use a muto for the "buffer".
* Makefile.in: Fix a dependency.
@
text
@d646 1
d652 2
a653 2
void
interrupt_now (CONTEXT *ctx, int sig, struct sigaction& siga, void *handler)
d655 3
a657 1
  DWORD oldmask = myself->getsigmask ();
d659 4
d664 5
a668 17
  DWORD *sp = (DWORD *) ctx->Esp;
  *(--sp) = ctx->Eip; /*  ctxinal IP where program was suspended */
  *(--sp) = ctx->EFlags;
  *(--sp) = ctx->Esi;
  *(--sp) = ctx->Edi;
  *(--sp) = ctx->Edx;
  *(--sp) = ctx->Ecx;
  *(--sp) = ctx->Ebx;
  *(--sp) = ctx->Eax;
  *(--sp) = (DWORD)-1;	/* no saved errno. */
  *(--sp) = oldmask;
  *(--sp) = sig;
  *(--sp) = (DWORD) sigreturn;

  ctx->Esp = (DWORD) sp;
  ctx->Eip = (DWORD) handler;

d672 1
a672 1
int
d690 5
a694 9
	if (*addr_retaddr  != thestack->sf.AddrReturn.Offset)
	  break;
	sigsave.retaddr = *addr_retaddr;
	*addr_retaddr = (DWORD) sigdelayed;
	sigsave.oldmask = myself->getsigmask ();	// Remember for restoration
	set_process_mask (myself->getsigmask () | siga.sa_mask | SIGTOMASK (sig));
	sigsave.func = (void (*)(int)) handler;
	sigsave.sig = sig;
	sigsave.saved_errno = -1;		// Flag: no errno to save
d714 1
d722 1
a722 1
      return 1;
d724 1
a725 6
  /* Suspend the running thread, grab its context somewhere safe
     and run the exception handler in the context of the thread -
     we have to do that since sometimes they don't return - and if
     this thread doesn't return, you won't ever get another exception. */

  HANDLE hth = myself->getthread2signal ();
a781 2
  (void) ResumeThread (hth);

a783 2
      /* Apparently we have to set signal_arrived after resuming the thread or it
	 is possible that the event will be ignored. */
d785 1
d789 2
a790 1
  sigproc_printf ("armed signal_arrived %p, res %d", signal_arrived, res);
d793 1
a793 1
  sigproc_printf ("returning");
@


1.6
log
@* exceptions.cc (call_handler): Use new muto linked list to look for all
potential mutos owned by suspended thread.  Clear waiting threads while thread
is stopped.
(proc_subproc): Clarify debugging output.
* sync.h (class muto): Add 'next' field.
(new_muto): Keep linked list alive.
@
text
@d21 1
d561 1
a561 1
  
d625 1
d627 18
a644 1
    return 1;
d646 1
a646 12
  MEMORY_BASIC_INFORMATION m;
  memset (&m, 0, sizeof m);
  if (!VirtualQuery ((LPCVOID) pc, &m, sizeof m))
    sigproc_printf ("couldn't get memory info, %E");

# define h ((HMODULE) m.AllocationBase)
  if (h == cygwin_hmodule)
    return 0;
  char *checkdir = (char *) alloca (windows_system_directory_length);
  if (!GetModuleFileName (h, checkdir, windows_system_directory_length))
    return 0;
  return !strncasematch (windows_system_directory, checkdir, windows_system_directory_length);
a737 1
  sigproc_printf ("Suspending %p (mainthread)", myself->getthread2signal());
d746 1
a748 3
      if (res)
	goto set_pending;

d757 4
d764 1
a764 1
      
a794 6
  if (interrupted)
    {
      /* Clear any waiting threads prior to dispatching to handler function */
      proc_subproc(PROC_CLEARWAIT, 1);
    }

d802 2
d1076 9
a1092 1
___sigfirst:
d1136 4
a1141 3
	pushl	_signal_arrived	# Everybody waiting for this should
	call	_ResetEvent@@4	# have woken up by now.

d1144 1
d1147 1
a1150 1
___siglast:
@


1.5
log
@Fix final round of gcc warnings relating to unused parameters.
* debug.cc (iscygthread): New function.
* debug.h: Declare it.
* exceptions.cc (set_process_mask): Flush pending signals.
(handle_sigsuspend): No need to flush pending signals.
(call_handler): Refine previous tests of muto ownership.  Only clear wait()'s
when we have definitely responded to a signal.
* fhandler_console.cc (fhandler_console::read): Don't set EINTR if executing in
a "cygwin" thread.
* sigproc.cc (proc_subproc): Use second argument to control whether CLEARWAIT
actually sets "signalled" flag.
* sync.h (muto): Add 'unstable' method.
@
text
@a715 1
  extern muto *sync_proc_subproc;
d745 3
a747 3
      if (!sync_proc_subproc->unstable () && sync_proc_subproc->owner () != maintid &&
	  !mask_sync->unstable () && mask_sync->owner () != maintid)
	break;
d749 3
d786 6
a795 2
      /* Clear any waiting threads prior to dispatching to handler function */
      proc_subproc(PROC_CLEARWAIT, 1);
@


1.4
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@a600 1
  sig_dispatch_pending (0);
d707 1
d741 4
d746 2
a747 1
      if (sync_proc_subproc->owner () != maintid && mask_sync->owner () != maintid)
a749 2
      if (res)
	goto set_pending;
a755 3
  /* Clear any waiting threads prior to dispatching to handler function */
  proc_subproc(PROC_CLEARWAIT, 0);

d785 1
d787 7
a793 1
    (void) SetEvent (signal_arrived);	// For an EINTR case
d850 2
d853 1
d858 2
d1091 1
a1091 1
	testl	%%eax,%%eax	# lt 0
@


1.3
log
@Respond to more g++ warnings relating to initializing structures.
@
text
@d34 2
d42 1
d617 1
a617 1
extern __inline int
d620 1
d624 18
d714 1
d716 1
d733 18
a750 1
  res = SuspendThread (hth);
d778 1
d781 1
d785 2
a786 1
  (void) SetEvent (signal_arrived);	// For an EINTR case
d791 1
a791 1
  return 1;
d1030 11
d1093 1
a1093 6
	# addl	4,%%esp
	cmpl	$0,_pending_signals
	je	2f
	pushl	$0
	call	_sig_dispatch_pending@@4
2:	pushl	%2	# original return address
d1106 10
a1115 3
	pushl	$_signal_arrived
	call	_ResetEvent@@4
	jmp	*%5
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d368 1
a368 1
  PROCESS_INFORMATION pi = {0};
d370 1
a370 1
  STARTUPINFO si = {0};
@


1.1
log
@Initial revision
@
text
@d442 1
a442 1
handle_exceptions (EXCEPTION_RECORD *e, void *arg, CONTEXT *in, void *x)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
