head	1.43;
access;
symbols
	cygwin-1_7_35-release:1.43
	cygwin-1_7_34-release:1.43
	cygwin-1_7_33-release:1.43
	cygwin-1_7_32-release:1.43
	cygwin-1_7_31-release:1.43
	cygwin-1_7_30-release:1.43
	cygwin-1_7_29-release:1.43
	cygwin-1_7_29-release-branchpoint:1.43.0.2
	cygwin-pre-user-db:1.43
	cygwin-1_7_28-release:1.43
	cygwin-1_7_27-release:1.43
	cygwin-1_7_26-release:1.43
	cygwin-1_7_25-release:1.40
	cygwin-1_7_24-release:1.39
	cygwin-1_7_23-release:1.39
	cygwin-1_7_22-release:1.39
	cygwin-1_7_21-release:1.39
	cygwin-1_7_20-release:1.38
	cygwin-1_7_19-release:1.38
	cygwin-64bit-postmerge:1.38
	cygwin-64bit-premerge-branch:1.37.0.2
	cygwin-64bit-premerge:1.37
	cygwin-1_7_18-release:1.37
	post-ptmalloc3:1.36.2.3
	pre-ptmalloc3:1.36.2.3
	cygwin-1_7_17-release:1.36
	cygwin-64bit-branch:1.36.0.2
	cygwin-1_7_16-release:1.36
	cygwin-1_7_15-release:1.36
	cygwin-1_7_14_2-release:1.36
	cygwin-1_7_14-release:1.36
	cygwin-1_7_12-release:1.36
	cygwin-1_7_11-release:1.36
	cygwin-1_7_10-release:1.35
	signal-rewrite:1.34.0.2
	pre-notty:1.34
	cygwin-1_7_9-release:1.33
	cv-post-1_7_9:1.33.0.2
	cygwin-1_7_8-release:1.33
	cygwin-1_7_7-release:1.33
	cygwin-1_7_5-release:1.30
	cygwin-1_7_4-release:1.29
	cygwin-1_7_3-release:1.29
	cygwin-1_7_2-release:1.26;
locks; strict;
comment	@// @;


1.43
date	2013.11.26.17.27.25;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2013.11.26.17.08.56;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2013.11.24.12.13.35;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2013.08.19.16.21.29;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.19.15.24.48;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2012.02.13.13.12.37;	author corinna;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.01.14.51.47;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.26.11.36.17;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.28.10.00.24;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.09.21.20.21;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.01.20.30.07;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.01.20.13.22;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.27.21.07.17;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.22.11.01.46;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2010.02.20.22.10.26;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2010.02.19.17.30.19;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2010.02.18.18.07.14;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2010.02.11.10.04.51;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2010.02.10.12.29.26;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2010.02.10.10.44.21;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.09.12.22.26;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2010.02.09.11.44.03;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.09.08.59.49;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2010.02.08.21.33.59;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2010.02.08.09.55.35;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.07.17.35.59;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2010.02.07.13.31.08;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.06.21.57.33;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.06.21.40.53;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.06.18.30.18;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.05.21.35.34;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.04.12.35.49;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.25.21.20.31;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.25.11.55.46;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.25.10.44.56;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.24.14.43.51;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.24.12.29.49;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.23.10.11.43;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.22.22.31.31;	author corinna;	state Exp;
branches;
next	;

1.36.2.1
date	2012.11.12.17.26.23;	author corinna;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2013.01.21.13.52.09;	author corinna;	state Exp;
branches;
next	1.36.2.4;

1.36.2.4
date	2013.03.30.19.57.28;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.43
log
@	* nlsfuncs.cc (wcscoll): Add "__restrict" to definition.
	(wcsxfrm): Ditto.
@
text
@/* nlsfuncs.cc: NLS helper functions

   Copyright 2010, 2011, 2012, 2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <wchar.h>
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "tls_pbuf.h"
/* Internal headers from newlib */
#include "../locale/timelocal.h"
#include "../locale/lctype.h"
#include "../locale/lnumeric.h"
#include "../locale/lmonetary.h"
#include "../locale/lmessages.h"
#include "lc_msg.h"
#include "lc_era.h"

#define _LC(x)	&lc_##x##_ptr,lc_##x##_end-lc_##x##_ptr

#define getlocaleinfo(category,type) \
	    __getlocaleinfo(lcid,(type),_LC(category))
#define eval_datetimefmt(type,flags) \
	    __eval_datetimefmt(lcid,(type),(flags),&lc_time_ptr,\
			       lc_time_end-lc_time_ptr)
#define charfromwchar(category,in) \
	    __charfromwchar (_##category##_locale->in,_LC(category),\
			     f_wctomb,charset)

#define has_modifier(x)	((x)[0] && !strcmp (modifier, (x)))

static char last_locale[ENCODING_LEN + 1];
static LCID last_lcid;

/* Fetch LCID from POSIX locale specifier.
   Return values:

     -1: Invalid locale
      0: C or POSIX
     >0: LCID
*/
static LCID
__get_lcid_from_locale (const char *name)
{
  char locale[ENCODING_LEN + 1];
  char *c;
  LCID lcid;

  /* Speed up reusing the same locale as before, for instance in LC_ALL case. */
  if (!strcmp (name, last_locale))
    {
      debug_printf ("LCID=%04y", last_lcid);
      return last_lcid;
    }
  stpcpy (last_locale, name);
  stpcpy (locale, name);
  /* Store modifier for later use. */
  const char *modifier = strchr (last_locale, '@@') ? : "";
  /* Drop charset and modifier */
  c = strchr (locale, '.');
  if (!c)
    c = strchr (locale, '@@');
  if (c)
    *c = '\0';
  /* "POSIX" already converted to "C" in loadlocale. */
  if (!strcmp (locale, "C"))
    return last_lcid = 0;
  c = strchr (locale, '_');
  if (!c)
    return last_lcid = (LCID) -1;
  if (wincap.has_localenames ())
    {
      wchar_t wlocale[ENCODING_LEN + 1];

      /* Convert to RFC 4646 syntax which is the standard for the locale names
	 replacing LCIDs starting with Vista. */
      *c = '-';
      mbstowcs (wlocale, locale, ENCODING_LEN + 1);
      lcid = LocaleNameToLCID (wlocale, 0);
      if (lcid == 0)
	{
	  /* Unfortunately there are a couple of locales for which no form
	     without a Script part per RFC 4646 exists.
	     Linux also supports no_NO which is equivalent to nb_NO. */
	  struct {
	    const char    *loc;
	    const wchar_t *wloc;
	  } sc_only_locale[] = {
	    { "az-AZ" , L"az-Latn-AZ"  },
	    { "bs-BA" , L"bs-Latn-BA"  },
	    { "chr-US", L"chr-Cher-US"},
	    { "ff-SN" , L"ff-Latn-SN"  },
	    { "ha-NG" , L"ha-Latn-NG"  },
	    { "iu-CA" , L"iu-Latn-CA"  },
	    { "ku-IQ" , L"ku-Arab-IQ"  },
	    { "mn-CN" , L"mn-Mong-CN"  },
	    { "no-NO" , L"nb-NO"       },
	    { "pa-PK" , L"pa-Arab-PK"  },
	    { "sd-PK" , L"sd-Arab-PK"  },
	    { "sr-BA" , L"sr-Cyrl-BA"  },
	    { "sr-CS" , L"sr-Cyrl-CS"  },
	    { "sr-ME" , L"sr-Cyrl-ME"  },
	    { "sr-RS" , L"sr-Cyrl-RS"  },
	    { "tg-TJ" , L"tg-Cyrl-TJ"  },
	    { "tzm-DZ", L"tzm-Latn-DZ" },
	    { "tzm-MA", L"tzm-Tfng-MA" },
	    { "uz-UZ" , L"uz-Latn-UZ"  },
	    { NULL    , NULL	       }
	  };
	  for (int i = 0; sc_only_locale[i].loc
			  && sc_only_locale[i].loc[0] <= locale[0]; ++i)
	    if (!strcmp (locale, sc_only_locale[i].loc))
	      {
		lcid = LocaleNameToLCID (sc_only_locale[i].wloc, 0);
		if (!strncmp (locale, "sr-", 3))
		  {
		    /* Vista/2K8 is missing sr-ME and sr-RS.  It has only the
		       deprecated sr-CS.  So we map ME and RS to CS here. */
		    if (lcid == 0)
		      lcid = LocaleNameToLCID (L"sr-Cyrl-CS", 0);
		    /* "@@latin" modifier for the sr_XY locales changes
			collation behaviour so lcid should accommodate that
			by being set to the Latin sublang. */
		    if (lcid != 0 && has_modifier ("@@latin"))
		      lcid = MAKELANGID (lcid & 0x3ff, (lcid >> 10) - 1);
		  }
		else if (!strncmp (locale, "uz-", 3))
		  {
		    /* Equivalent for "@@cyrillic" modifier in uz_UZ locale */
		    if (lcid != 0 && has_modifier ("@@cyrillic"))
		      lcid = MAKELANGID (lcid & 0x3ff, (lcid >> 10) + 1);
		  }
		break;
	      }
	}
      last_lcid = lcid ?: (LCID) -1;
      debug_printf ("LCID=%04y", last_lcid);
      return last_lcid;
    }
  /* Pre-Vista we have to loop through the LCID values and see if they
     match language and TERRITORY. */
  *c++ = '\0';
  /* locale now points to the language, c points to the TERRITORY */
  const char *language = locale;
  const char *territory = c;
  LCID lang, sublang;
  char iso[10];

  /* In theory the lang part takes 10 bits (0x3ff), but up to Windows 2003 R2
     the highest lang value is 0x81. */
  for (lang = 1; lang <= 0x81; ++lang)
    if (GetLocaleInfo (lang, LOCALE_SISO639LANGNAME, iso, 10)
	&& !strcmp (language, iso))
      break;
  if (lang > 0x81)
    lcid = 0;
  else if (!territory)
    lcid = lang;
  else
    {
      /* In theory the sublang part takes 7 bits (0x3f), but up to
	 Windows 2003 R2 the highest sublang value is 0x14. */
      for (sublang = 1; sublang <= 0x14; ++sublang)
	{
	  lcid = (sublang << 10) | lang;
	  if (GetLocaleInfo (lcid, LOCALE_SISO3166CTRYNAME, iso, 10)
	      && !strcmp (territory, iso))
	    break;
	}
      if (sublang > 0x14)
	lcid = 0;
    }
  if (lcid == 0 && territory)
    {
      /* Unfortunately there are four language LCID number areas representing
	 multiple languages.  Fortunately only two of them already existed
	 pre-Vista.  The concealed languages have to be tested explicitly,
	 since they are not catched by the above loops.
	 This also enables the serbian ISO 3166 territory codes which have
	 been changed post 2003, and maps them to the old wrong (SP was never
	 a valid ISO 3166 code) territory code sr_SP which fortunately has the
	 same LCID as the newer sr_CS.
	 Linux also supports no_NO which is equivalent to nb_NO. */
      struct {
	const char *loc;
	LCID	    lcid;
      } ambiguous_locale[] = {
	{ "bs_BA", MAKELANGID (LANG_BOSNIAN, 0x05)			    },
	{ "nn_NO", MAKELANGID (LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK)   },
	{ "no_NO", MAKELANGID (LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL)    },
	{ "sr_BA", MAKELANGID (LANG_BOSNIAN,
			       SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC) },
	{ "sr_CS", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_CYRILLIC)      },
	{ "sr_ME", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_CYRILLIC)      },
	{ "sr_RS", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_CYRILLIC)      },
	{ "sr_SP", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_CYRILLIC)      },
	{ NULL,    0 },
      };
      *--c = '_';
      for (int i = 0; ambiguous_locale[i].loc
		      && ambiguous_locale[i].loc[0] <= locale[0]; ++i)
	if (!strcmp (locale, ambiguous_locale[i].loc)
	    && GetLocaleInfo (ambiguous_locale[i].lcid, LOCALE_SISO639LANGNAME,
			      iso, 10))
	  {
	    lcid = ambiguous_locale[i].lcid;
	    /* "@@latin" modifier for the sr_XY locales changes collation
	       behaviour so lcid should accommodate that by being set to
	       the Latin sublang. */
	    if (!strncmp (locale, "sr_", 3) && has_modifier ("@@latin"))
	      lcid = MAKELANGID (lcid & 0x3ff, (lcid >> 10) - 1);
	    break;
	  }
    }
  else if (lcid == 0x0443)		/* uz_UZ (Uzbek/Uzbekistan) */
    {
      /* Equivalent for "@@cyrillic" modifier in uz_UZ locale */
      if (lcid != 0 && has_modifier ("@@cyrillic"))
	lcid = MAKELANGID (lcid & 0x3ff, (lcid >> 10) + 1);
    }
  last_lcid = lcid ?: (LCID) -1;
  debug_printf ("LCID=%04y", last_lcid);
  return last_lcid;
}

/* Never returns -1.  Just skips invalid chars instead.  Only if return_invalid
   is set, s==NULL returns -1 since then it's used to recognize invalid strings
   in the used charset. */
static size_t
lc_wcstombs (wctomb_p f_wctomb, const char *charset,
	     char *s, const wchar_t *pwcs, size_t n,
	     bool return_invalid = false)
{
  char *ptr = s;
  size_t max = n;
  char buf[8];
  size_t i, bytes, num_to_copy;
  mbstate_t state;

  memset (&state, 0, sizeof state);
  if (s == NULL)
    {
      size_t num_bytes = 0;
      while (*pwcs != 0)
	{
	  bytes = f_wctomb (_REENT, buf, *pwcs++, charset, &state);
	  if (bytes != (size_t) -1)
	    num_bytes += bytes;
	  else if (return_invalid)
	    return (size_t) -1;
	}
      return num_bytes;
    }
  while (n > 0)
    {
      bytes = f_wctomb (_REENT, buf, *pwcs, charset, &state);
      if (bytes == (size_t) -1)
	{
	  memset (&state, 0, sizeof state);
	  ++pwcs;
	  continue;
	}
      num_to_copy = (n > bytes ? bytes : n);
      for (i = 0; i < num_to_copy; ++i)
	*ptr++ = buf[i];

      if (*pwcs == 0x00)
	return ptr - s - (n >= bytes);
      ++pwcs;
      n -= num_to_copy;
    }
  return max;
}

/* Never returns -1.  Invalid sequences are translated to replacement
   wide-chars. */
static size_t
lc_mbstowcs (mbtowc_p f_mbtowc, const char *charset,
	     wchar_t *pwcs, const char *s, size_t n)
{
  size_t ret = 0;
  char *t = (char *) s;
  size_t bytes;
  mbstate_t state;

  memset (&state, 0, sizeof state);
  if (!pwcs)
    n = 1;
  while (n > 0)
    {
      bytes = f_mbtowc (_REENT, pwcs, t, 6 /* fake, always enough */,
			charset, &state);
      if (bytes == (size_t) -1)
	{
	  state.__count = 0;
	  bytes = 1;
	  if (pwcs)
	    *pwcs = L' ';
	}
      else if (bytes == 0)
	break;
      t += bytes;
      ++ret;
      if (pwcs)
	{
	  ++pwcs;
	  --n;
	}
    }
  return ret;
}

static int
locale_cmp (const void *a, const void *b)
{
  char **la = (char **) a;
  char **lb = (char **) b;
  return strcmp (*la, *lb);
}

/* Helper function to workaround reallocs which move blocks even if they shrink.
   Cygwin's realloc is not doing this, but tcsh's, for instance.  All lc_foo
   structures consist entirely of pointers so they are practically pointer
   arrays.  What we do here is just treat the lc_foo pointers as char ** and
   rebase all char * pointers within, up to the given size of the structure. */
static void
rebase_locale_buf (const void *ptrv, const void *ptrvend, const char *newbase,
		   const char *oldbase, const char *oldend)
{
  const char **ptrsend = (const char **) ptrvend;
  for (const char **ptrs = (const char **) ptrv; ptrs < ptrsend; ++ptrs)
    if (*ptrs >= oldbase && *ptrs < oldend)
      *ptrs += newbase - oldbase;
}

static wchar_t *
__getlocaleinfo (LCID lcid, LCTYPE type, char **ptr, size_t size)
{
  size_t num;
  wchar_t *ret;

  if ((uintptr_t) *ptr % 1)
    ++*ptr;
  ret = (wchar_t *) *ptr;
  num = GetLocaleInfoW (lcid, type, ret, size / sizeof (wchar_t));
  *ptr = (char *) (ret + num);
  return ret;
}

static char *
__charfromwchar (const wchar_t *in, char **ptr, size_t size,
		 wctomb_p f_wctomb, const char *charset)
{
  size_t num;
  char *ret;

  num = lc_wcstombs (f_wctomb, charset, ret = *ptr, in, size);
  *ptr += num + 1;
  return ret;
}

static UINT
getlocaleint (LCID lcid, LCTYPE type)
{
  UINT val;
  return GetLocaleInfoW (lcid, type | LOCALE_RETURN_NUMBER, (PWCHAR) &val,
			 sizeof val) ? val : 0;
}

enum dt_flags {
  DT_DEFAULT	= 0x00,
  DT_AMPM	= 0x01,	/* Enforce 12 hour time format. */
  DT_ABBREV	= 0x02,	/* Enforce abbreviated month and day names. */
};

static wchar_t *
__eval_datetimefmt (LCID lcid, LCTYPE type, dt_flags flags, char **ptr,
		    size_t size)
{
  wchar_t buf[80];
  wchar_t fc;
  size_t idx;
  const wchar_t *day_str = L"edaA";
  const wchar_t *mon_str = L"mmbB";
  const wchar_t *year_str = L"yyyY";
  const wchar_t *hour12_str = L"lI";
  const wchar_t *hour24_str = L"kH";
  const wchar_t *t_str;

  if ((uintptr_t) *ptr % 1)
    ++*ptr;
  wchar_t *ret = (wchar_t *) *ptr;
  wchar_t *p = (wchar_t *) *ptr;
  GetLocaleInfoW (lcid, type, buf, 80);
  for (wchar_t *fmt = buf; *fmt; ++fmt)
    switch (fc = *fmt)
      {
      case L'\'':
	if (fmt[1] == L'\'')
	  *p++ = L'\'';
	else
	  while (fmt[1] && *++fmt != L'\'')
	    *p++ = *fmt;
	break;
      case L'd':
      case L'M':
      case L'y':
	t_str = (fc == L'd' ? day_str : fc == L'M' ? mon_str : year_str);
	for (idx = 0; fmt[1] == fc; ++idx, ++fmt);
	if (idx > 3)
	  idx = 3;
	if ((flags & DT_ABBREV) && fc != L'y' && idx == 3)
	  idx = 2;
	*p++ = L'%';
	*p++ = t_str[idx];
	break;
      case L'g':
	/* TODO */
	break;
      case L'h':
      case L'H':
	t_str = (fc == L'h' || (flags & DT_AMPM) ? hour12_str : hour24_str);
	idx = 0;
	if (fmt[1] == fc)
	  {
	    ++fmt;
	    idx = 1;
	  }
	*p++ = L'%';
	*p++ = t_str[idx];
	break;
      case L'm':
      case L's':
      case L't':
	if (fmt[1] == fc)
	  ++fmt;
	*p++ = L'%';
	*p++ = (fc == L'm' ? L'M' : fc == L's' ? L'S' : L'p');
	break;
      case L'\t':
      case L'\n':
      case L'%':
	*p++ = L'%';
	*p++ = fc;
	break;
      default:
	*p++ = *fmt;
	break;
      }
  *p++ = L'\0';
  *ptr = (char *) p;
  return ret;
}

/* Convert Windows grouping format into POSIX grouping format. */
static char *
conv_grouping (LCID lcid, LCTYPE type, char **lc_ptr)
{
  char buf[10]; /* Per MSDN max size of LOCALE_SGROUPING element incl. NUL */
  bool repeat = false;
  char *ptr = *lc_ptr;
  char *ret = ptr;

  GetLocaleInfoA (lcid, type, buf, 10);
  /* Convert Windows grouping format into POSIX grouping format. */
  for (char *c = buf; *c; ++c)
    {
      if (*c < '0' || *c > '9')
	continue;
      char val = *c - '0';
      if (!val)
	{
	  repeat = true;
	  break;
	}
      *ptr++ = val;
    }
  if (!repeat)
    *ptr++ = CHAR_MAX;
  *ptr++ = '\0';
  *lc_ptr = ptr;
  return ret;
}

/* Called from newlib's setlocale() via __time_load_locale() if category
   is LC_TIME.  Returns LC_TIME values fetched from Windows locale data
   in the structure pointed to by _time_locale.  This is subsequently
   accessed by functions like nl_langinfo, strftime, strptime. */
extern "C" int
__set_lc_time_from_win (const char *name,
			const struct lc_time_T *_C_time_locale,
			struct lc_time_T *_time_locale,
			char **lc_time_buf, wctomb_p f_wctomb,
			const char *charset)
{
  LCID lcid = __get_lcid_from_locale (name);
  if (lcid == (LCID) -1)
    return lcid;
  if (!lcid && !strcmp (charset, "ASCII"))
    return 0;

# define MAX_TIME_BUFFER_SIZE	4096

  char *new_lc_time_buf = (char *) malloc (MAX_TIME_BUFFER_SIZE);
  const char *lc_time_end = new_lc_time_buf + MAX_TIME_BUFFER_SIZE;

  if (!new_lc_time_buf)
    return -1;
  char *lc_time_ptr = new_lc_time_buf;

  /* C.foo is just a copy of "C" with fixed charset. */
  if (!lcid)
    memcpy (_time_locale, _C_time_locale, sizeof (struct lc_time_T));
  /* codeset */
  _time_locale->codeset = lc_time_ptr;
  lc_time_ptr = stpcpy (lc_time_ptr, charset) + 1;

  if (lcid)
    {
      char locale[ENCODING_LEN + 1];
      strcpy (locale, name);
      /* Removes the charset from the locale and attach the modifer to the
	 language_TERRITORY part. */
      char *c = strchr (locale, '.');
      if (c)
	{
	  *c = '\0';
	  char *c2 = strchr (c + 1, '@@');
	  /* Ignore @@cjknarrow modifier since it's a very personal thing between
	     Cygwin and newlib... */
	  if (c2 && strcmp (c2, "@@cjknarrow"))
	    memmove (c, c2, strlen (c2) + 1);
	}
      /* Now search in the alphabetically order lc_era array for the
	 locale. */
      lc_era_t locale_key = { locale, NULL, NULL, NULL, NULL, NULL ,
				      NULL, NULL, NULL, NULL, NULL };
      lc_era_t *era = (lc_era_t *) bsearch ((void *) &locale_key, (void *) lc_era,
					    sizeof lc_era / sizeof *lc_era,
					    sizeof *lc_era, locale_cmp);

      /* mon */
      /* Windows has a bug in Japanese and Korean locales.  In these
	 locales, strings returned for LOCALE_SABBREVMONTHNAME* are missing
	 the suffix representing a month.  Unfortunately this is not
	 documented in English.  A Japanese article describing the problem
	 is http://msdn.microsoft.com/ja-jp/library/cc422084.aspx
	 The workaround is to use LOCALE_SMONTHNAME* in these locales,
	 even for the abbreviated month name. */
      const LCTYPE mon_base =
		lcid == MAKELANGID (LANG_JAPANESE, SUBLANG_JAPANESE_JAPAN)
		|| lcid == MAKELANGID (LANG_KOREAN, SUBLANG_KOREAN)
		? LOCALE_SMONTHNAME1 : LOCALE_SABBREVMONTHNAME1;
      for (int i = 0; i < 12; ++i)
	{
	  _time_locale->wmon[i] = getlocaleinfo (time, mon_base + i);
	  _time_locale->mon[i] = charfromwchar (time, wmon[i]);
	}
      /* month and alt_month */
      for (int i = 0; i < 12; ++i)
	{
	  _time_locale->wmonth[i] = getlocaleinfo (time, LOCALE_SMONTHNAME1 + i);
	  _time_locale->month[i] = _time_locale->alt_month[i]
				 = charfromwchar (time, wmonth[i]);
	}
      /* wday */
      _time_locale->wwday[0] = getlocaleinfo (time, LOCALE_SABBREVDAYNAME7);
      _time_locale->wday[0] = charfromwchar (time, wwday[0]);
      for (int i = 0; i < 6; ++i)
	{
	  _time_locale->wwday[i + 1] = getlocaleinfo (time,
						      LOCALE_SABBREVDAYNAME1 + i);
	  _time_locale->wday[i + 1] = charfromwchar (time, wwday[i + 1]);
	}
      /* weekday */
      _time_locale->wweekday[0] = getlocaleinfo (time, LOCALE_SDAYNAME7);
      _time_locale->weekday[0] = charfromwchar (time, wweekday[0]);
      for (int i = 0; i < 6; ++i)
	{
	  _time_locale->wweekday[i + 1] = getlocaleinfo (time,
							 LOCALE_SDAYNAME1 + i);
	  _time_locale->weekday[i + 1] = charfromwchar (time, wweekday[i + 1]);
	}
      size_t len;
      /* X_fmt */
      if (era && *era->t_fmt)
	{
	  _time_locale->wX_fmt = (const wchar_t *) lc_time_ptr;
	  lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wX_fmt,
					  era->t_fmt) + 1);
	}
      else
	_time_locale->wX_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
      _time_locale->X_fmt = charfromwchar (time, wX_fmt);
      /* x_fmt */
      if (era && *era->d_fmt)
	{
	  _time_locale->wx_fmt = (const wchar_t *) lc_time_ptr;
	  lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wx_fmt,
					  era->d_fmt) + 1);
	}
      else
	_time_locale->wx_fmt = eval_datetimefmt (LOCALE_SSHORTDATE, DT_DEFAULT);
      _time_locale->x_fmt = charfromwchar (time, wx_fmt);
      /* c_fmt */
      if (era && *era->d_t_fmt)
	{
	  _time_locale->wc_fmt = (const wchar_t *) lc_time_ptr;
	  lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wc_fmt,
					  era->d_t_fmt) + 1);
	}
      else
	{
	  _time_locale->wc_fmt = eval_datetimefmt (LOCALE_SLONGDATE, DT_ABBREV);
	  ((wchar_t *) lc_time_ptr)[-1] = L' ';
	  eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
	}
      _time_locale->c_fmt = charfromwchar (time, wc_fmt);
      /* AM/PM */
      _time_locale->wam_pm[0] = getlocaleinfo (time, LOCALE_S1159);
      _time_locale->wam_pm[1] = getlocaleinfo (time, LOCALE_S2359);
      _time_locale->am_pm[0] = charfromwchar (time, wam_pm[0]);
      _time_locale->am_pm[1] = charfromwchar (time, wam_pm[1]);
      /* date_fmt */
      if (era && *era->date_fmt)
	{
	  _time_locale->wdate_fmt = (const wchar_t *) lc_time_ptr;
	  lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wdate_fmt,
					  era->date_fmt) + 1);
	}
      else
	_time_locale->wdate_fmt = _time_locale->wc_fmt;
      _time_locale->date_fmt = charfromwchar (time, wdate_fmt);
      /* md */
      {
	wchar_t buf[80];
	GetLocaleInfoW (lcid, LOCALE_IDATE, buf, 80);
	_time_locale->md_order = (const char *) lc_time_ptr;
	lc_time_ptr = stpcpy (lc_time_ptr, *buf == L'1' ? "dm" : "md") + 1;
      }
      /* ampm_fmt */
      if (era)
	{
	  _time_locale->wampm_fmt = (const wchar_t *) lc_time_ptr;
	  lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wampm_fmt,
					  era->t_fmt_ampm) + 1);
	}
      else
	_time_locale->wampm_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, DT_AMPM);
      _time_locale->ampm_fmt = charfromwchar (time, wampm_fmt);

      if (era)
	{
	  /* Evaluate string length in target charset.  Characters invalid in the
	     target charset are simply ignored, as on Linux. */
	  len = 0;
	  len += lc_wcstombs (f_wctomb, charset, NULL, era->era, 0) + 1;
	  len += lc_wcstombs (f_wctomb, charset, NULL, era->era_d_fmt, 0) + 1;
	  len += lc_wcstombs (f_wctomb, charset, NULL, era->era_d_t_fmt, 0) + 1;
	  len += lc_wcstombs (f_wctomb, charset, NULL, era->era_t_fmt, 0) + 1;
	  len += lc_wcstombs (f_wctomb, charset, NULL, era->alt_digits, 0) + 1;
	  len += (wcslen (era->era) + 1) * sizeof (wchar_t);
	  len += (wcslen (era->era_d_fmt) + 1) * sizeof (wchar_t);
	  len += (wcslen (era->era_d_t_fmt) + 1) * sizeof (wchar_t);
	  len += (wcslen (era->era_t_fmt) + 1) * sizeof (wchar_t);
	  len += (wcslen (era->alt_digits) + 1) * sizeof (wchar_t);

	  /* Make sure data fits into the buffer */
	  if (lc_time_ptr + len > lc_time_end)
	    {
	      len = lc_time_ptr + len - new_lc_time_buf;
	      char *tmp = (char *) realloc (new_lc_time_buf, len);
	      if (!tmp)
		era = NULL;
	      else
		{
		  if (tmp != new_lc_time_buf)
		    rebase_locale_buf (_time_locale, _time_locale + 1, tmp,
				       new_lc_time_buf, lc_time_ptr);
		  lc_time_ptr = tmp + (lc_time_ptr - new_lc_time_buf);
		  new_lc_time_buf = tmp;
		  lc_time_end = new_lc_time_buf + len;
		}
	    }
	  /* Copy over */
	  if (era)
	    {
	      /* era */
	      _time_locale->wera = (const wchar_t *) lc_time_ptr;
	      lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wera,
					      era->era) + 1);
	      _time_locale->era = charfromwchar (time, wera);
	      /* era_d_fmt */
	      _time_locale->wera_d_fmt = (const wchar_t *) lc_time_ptr;
	      lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wera_d_fmt,
					      era->era_d_fmt) + 1);
	      _time_locale->era_d_fmt = charfromwchar (time, wera_d_fmt);
	      /* era_d_t_fmt */
	      _time_locale->wera_d_t_fmt = (const wchar_t *) lc_time_ptr;
	      lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wera_d_t_fmt,
					      era->era_d_t_fmt) + 1);
	      _time_locale->era_d_t_fmt = charfromwchar (time, wera_d_t_fmt);
	      /* era_t_fmt */
	      _time_locale->wera_t_fmt = (const wchar_t *) lc_time_ptr;
	      lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->wera_t_fmt,
					      era->era_t_fmt) + 1);
	      _time_locale->era_t_fmt = charfromwchar (time, wera_t_fmt);
	      /* alt_digits */
	      _time_locale->walt_digits = (const wchar_t *) lc_time_ptr;
	      lc_time_ptr = (char *) (wcpcpy ((wchar_t *) _time_locale->walt_digits,
					      era->alt_digits) + 1);
	      _time_locale->alt_digits = charfromwchar (time, walt_digits);
	    }
	}
      if (!era)
	{
	  _time_locale->wera =
	  _time_locale->wera_d_fmt =
	  _time_locale->wera_d_t_fmt =
	  _time_locale->wera_t_fmt =
	  _time_locale->walt_digits = (const wchar_t *) lc_time_ptr;
	  _time_locale->era =
	  _time_locale->era_d_fmt =
	  _time_locale->era_d_t_fmt =
	  _time_locale->era_t_fmt =
	  _time_locale->alt_digits = (const char *) lc_time_ptr;
	  /* Twice, to make sure wide char strings are correctly terminated. */
	  *lc_time_ptr++ = '\0';
	  *lc_time_ptr++ = '\0';
	}
    }

  char *tmp = (char *) realloc (new_lc_time_buf, lc_time_ptr - new_lc_time_buf);
  if (!tmp)
    {
      free (new_lc_time_buf);
      return -1;
    }
  if (tmp != new_lc_time_buf)
    rebase_locale_buf (_time_locale, _time_locale + 1, tmp,
		       new_lc_time_buf, lc_time_ptr);
  if (*lc_time_buf)
    free (*lc_time_buf);
  *lc_time_buf = tmp;
  return 1;
}

/* Called from newlib's setlocale() via __ctype_load_locale() if category
   is LC_CTYPE.  Returns LC_CTYPE values fetched from Windows locale data
   in the structure pointed to by _ctype_locale.  This is subsequently
   accessed by functions like nl_langinfo, localeconv, printf, etc. */
extern "C" int
__set_lc_ctype_from_win (const char *name,
			 const struct lc_ctype_T *_C_ctype_locale,
			 struct lc_ctype_T *_ctype_locale,
			 char **lc_ctype_buf, wctomb_p f_wctomb,
			 const char *charset, int mb_cur_max)
{
  LCID lcid = __get_lcid_from_locale (name);
  if (lcid == (LCID) -1)
    return lcid;
  if (!lcid && !strcmp (charset, "ASCII"))
    return 0;

# define MAX_CTYPE_BUFFER_SIZE	256

  char *new_lc_ctype_buf = (char *) malloc (MAX_CTYPE_BUFFER_SIZE);

  if (!new_lc_ctype_buf)
    return -1;
  char *lc_ctype_ptr = new_lc_ctype_buf;
  /* C.foo is just a copy of "C" with fixed charset. */
  if (!lcid)
    memcpy (_ctype_locale, _C_ctype_locale, sizeof (struct lc_ctype_T));
  /* codeset */
  _ctype_locale->codeset = lc_ctype_ptr;
  lc_ctype_ptr = stpcpy (lc_ctype_ptr, charset) + 1;
  /* mb_cur_max */
  _ctype_locale->mb_cur_max = lc_ctype_ptr;
  *lc_ctype_ptr++ = mb_cur_max;
  *lc_ctype_ptr++ = '\0';
  if (lcid)
    {
      /* outdigits and woutdigits */
      wchar_t digits[11];
      GetLocaleInfoW (lcid, LOCALE_SNATIVEDIGITS, digits, 11);
      for (int i = 0; i <= 9; ++i)
	{
	  mbstate_t state;

	  /* Make sure the wchar_t's are always 2 byte aligned. */
	  if ((uintptr_t) lc_ctype_ptr % 2)
	    ++lc_ctype_ptr;
	  wchar_t *woutdig = (wchar_t *) lc_ctype_ptr;
	  _ctype_locale->woutdigits[i] = (const wchar_t *) woutdig;
	  *woutdig++ = digits[i];
	  *woutdig++ = L'\0';
	  lc_ctype_ptr = (char *) woutdig;
	  _ctype_locale->outdigits[i] = lc_ctype_ptr;
	  memset (&state, 0, sizeof state);
	  lc_ctype_ptr += f_wctomb (_REENT, lc_ctype_ptr, digits[i], charset,
				      &state);
	  *lc_ctype_ptr++ = '\0';
	}
    }

  char *tmp = (char *) realloc (new_lc_ctype_buf,
				lc_ctype_ptr - new_lc_ctype_buf);
  if (!tmp)
    {
      free (new_lc_ctype_buf);
      return -1;
    }
  if (tmp != new_lc_ctype_buf)
    rebase_locale_buf (_ctype_locale, _ctype_locale + 1, tmp,
		       new_lc_ctype_buf, lc_ctype_ptr);
  if (*lc_ctype_buf)
    free (*lc_ctype_buf);
  *lc_ctype_buf = tmp;
  return 1;
}

/* Called from newlib's setlocale() via __numeric_load_locale() if category
   is LC_NUMERIC.  Returns LC_NUMERIC values fetched from Windows locale data
   in the structure pointed to by _numeric_locale.  This is subsequently
   accessed by functions like nl_langinfo, localeconv, printf, etc. */
extern "C" int
__set_lc_numeric_from_win (const char *name,
			   const struct lc_numeric_T *_C_numeric_locale,
			   struct lc_numeric_T *_numeric_locale,
			   char **lc_numeric_buf, wctomb_p f_wctomb,
			   const char *charset)
{
  LCID lcid = __get_lcid_from_locale (name);
  if (lcid == (LCID) -1)
    return lcid;
  if (!lcid && !strcmp (charset, "ASCII"))
    return 0;

# define MAX_NUMERIC_BUFFER_SIZE	256

  char *new_lc_numeric_buf = (char *) malloc (MAX_NUMERIC_BUFFER_SIZE);
  const char *lc_numeric_end = new_lc_numeric_buf + MAX_NUMERIC_BUFFER_SIZE;

  if (!new_lc_numeric_buf)
    return -1;
  char *lc_numeric_ptr = new_lc_numeric_buf;
  /* C.foo is just a copy of "C" with fixed charset. */
  if (!lcid)
    memcpy (_numeric_locale, _C_numeric_locale, sizeof (struct lc_numeric_T));
  else
    {
      /* decimal_point */
      _numeric_locale->wdecimal_point = getlocaleinfo (numeric, LOCALE_SDECIMAL);
      _numeric_locale->decimal_point = charfromwchar (numeric, wdecimal_point);
      /* thousands_sep */
      _numeric_locale->wthousands_sep = getlocaleinfo (numeric, LOCALE_STHOUSAND);
      _numeric_locale->thousands_sep = charfromwchar (numeric, wthousands_sep);
      /* grouping */
      _numeric_locale->grouping = conv_grouping (lcid, LOCALE_SGROUPING,
						 &lc_numeric_ptr);
    }
  /* codeset */
  _numeric_locale->codeset = lc_numeric_ptr;
  lc_numeric_ptr = stpcpy (lc_numeric_ptr, charset) + 1;

  char *tmp = (char *) realloc (new_lc_numeric_buf,
				lc_numeric_ptr - new_lc_numeric_buf);
  if (!tmp)
    {
      free (new_lc_numeric_buf);
      return -1;
    }
  if (tmp != new_lc_numeric_buf)
    rebase_locale_buf (_numeric_locale, _numeric_locale + 1, tmp,
		       new_lc_numeric_buf, lc_numeric_ptr);
  if (*lc_numeric_buf)
    free (*lc_numeric_buf);
  *lc_numeric_buf = tmp;
  return 1;
}

/* Called from newlib's setlocale() via __monetary_load_locale() if category
   is LC_MONETARY.  Returns LC_MONETARY values fetched from Windows locale data
   in the structure pointed to by _monetary_locale.  This is subsequently
   accessed by functions like nl_langinfo, localeconv, printf, etc. */
extern "C" int
__set_lc_monetary_from_win (const char *name,
			    const struct lc_monetary_T *_C_monetary_locale,
			    struct lc_monetary_T *_monetary_locale,
			    char **lc_monetary_buf, wctomb_p f_wctomb,
			    const char *charset)
{
  LCID lcid = __get_lcid_from_locale (name);
  if (lcid == (LCID) -1)
    return lcid;
  if (!lcid && !strcmp (charset, "ASCII"))
    return 0;

# define MAX_MONETARY_BUFFER_SIZE	512

  char *new_lc_monetary_buf = (char *) malloc (MAX_MONETARY_BUFFER_SIZE);
  const char *lc_monetary_end = new_lc_monetary_buf + MAX_MONETARY_BUFFER_SIZE;

  if (!new_lc_monetary_buf)
    return -1;
  char *lc_monetary_ptr = new_lc_monetary_buf;
  /* C.foo is just a copy of "C" with fixed charset. */
  if (!lcid)
    memcpy (_monetary_locale, _C_monetary_locale, sizeof (struct lc_monetary_T));
  else
    {
      /* int_curr_symbol */
      _monetary_locale->wint_curr_symbol = getlocaleinfo (monetary,
							  LOCALE_SINTLSYMBOL);
      /* No spacing char means space. */
      if (!_monetary_locale->wint_curr_symbol[3])
	{
	  wchar_t *wc = (wchar_t *) _monetary_locale->wint_curr_symbol + 3;
	  *wc++ = L' ';
	  *wc++ = L'\0';
	  lc_monetary_ptr = (char *) wc;
	}
      _monetary_locale->int_curr_symbol = charfromwchar (monetary,
							 wint_curr_symbol);
      /* currency_symbol */
      _monetary_locale->wcurrency_symbol = getlocaleinfo (monetary,
							  LOCALE_SCURRENCY);
      /* As on Linux:  If the currency_symbol can't be represented in the
	 given charset, use int_curr_symbol. */
      if (lc_wcstombs (f_wctomb, charset, NULL,
		       _monetary_locale->wcurrency_symbol,
		       0, true) == (size_t) -1)
	_monetary_locale->currency_symbol = _monetary_locale->int_curr_symbol;
      else
	_monetary_locale->currency_symbol = charfromwchar (monetary,
							   wcurrency_symbol);
      /* mon_decimal_point */
      _monetary_locale->wmon_decimal_point = getlocaleinfo (monetary,
							    LOCALE_SMONDECIMALSEP);
      _monetary_locale->mon_decimal_point = charfromwchar (monetary,
							   wmon_decimal_point);
      /* mon_thousands_sep */
      _monetary_locale->wmon_thousands_sep = getlocaleinfo (monetary,
							    LOCALE_SMONTHOUSANDSEP);
      _monetary_locale->mon_thousands_sep = charfromwchar (monetary,
							   wmon_thousands_sep);
      /* mon_grouping */
      _monetary_locale->mon_grouping = conv_grouping (lcid, LOCALE_SMONGROUPING,
						      &lc_monetary_ptr);
      /* positive_sign */
      _monetary_locale->wpositive_sign = getlocaleinfo (monetary,
							LOCALE_SPOSITIVESIGN);
      _monetary_locale->positive_sign = charfromwchar (monetary, wpositive_sign);
      /* negative_sign */
      _monetary_locale->wnegative_sign = getlocaleinfo (monetary,
							LOCALE_SNEGATIVESIGN);
      _monetary_locale->negative_sign = charfromwchar (monetary, wnegative_sign);
      /* int_frac_digits */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IINTLCURRDIGITS);
      _monetary_locale->int_frac_digits = lc_monetary_ptr++;
      /* frac_digits */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_ICURRDIGITS);
      _monetary_locale->frac_digits = lc_monetary_ptr++;
      /* p_cs_precedes and int_p_cs_precedes */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IPOSSYMPRECEDES);
      _monetary_locale->p_cs_precedes
	    = _monetary_locale->int_p_cs_precedes = lc_monetary_ptr++;
      /* p_sep_by_space and int_p_sep_by_space */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IPOSSEPBYSPACE);
      _monetary_locale->p_sep_by_space
	    = _monetary_locale->int_p_sep_by_space = lc_monetary_ptr++;
      /* n_cs_precedes and int_n_cs_precedes */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_INEGSYMPRECEDES);
      _monetary_locale->n_cs_precedes
	    = _monetary_locale->int_n_cs_precedes = lc_monetary_ptr++;
      /* n_sep_by_space and int_n_sep_by_space */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_INEGSEPBYSPACE);
      _monetary_locale->n_sep_by_space
	    = _monetary_locale->int_n_sep_by_space = lc_monetary_ptr++;
      /* p_sign_posn and int_p_sign_posn */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IPOSSIGNPOSN);
      _monetary_locale->p_sign_posn
	    = _monetary_locale->int_p_sign_posn = lc_monetary_ptr++;
      /* n_sign_posn and int_n_sign_posn */
      *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_INEGSIGNPOSN);
      _monetary_locale->n_sign_posn
	    = _monetary_locale->int_n_sign_posn = lc_monetary_ptr++;
    }
  /* codeset */
  _monetary_locale->codeset = lc_monetary_ptr;
  lc_monetary_ptr = stpcpy (lc_monetary_ptr, charset) + 1;

  char *tmp = (char *) realloc (new_lc_monetary_buf,
				lc_monetary_ptr - new_lc_monetary_buf);
  if (!tmp)
    {
      free (new_lc_monetary_buf);
      return -1;
    }
  if (tmp != new_lc_monetary_buf)
    rebase_locale_buf (_monetary_locale, _monetary_locale + 1, tmp,
		       new_lc_monetary_buf, lc_monetary_ptr);
  if (*lc_monetary_buf)
    free (*lc_monetary_buf);
  *lc_monetary_buf = tmp;
  return 1;
}

extern "C" int
__set_lc_messages_from_win (const char *name,
			    const struct lc_messages_T *_C_messages_locale,
			    struct lc_messages_T *_messages_locale,
			    char **lc_messages_buf,
			    wctomb_p f_wctomb, const char *charset)
{
  LCID lcid = __get_lcid_from_locale (name);
  if (lcid == (LCID) -1)
    return lcid;
  if (!lcid && !strcmp (charset, "ASCII"))
    return 0;

  char locale[ENCODING_LEN + 1];
  char *c, *c2;
  lc_msg_t *msg = NULL;

  /* C.foo is just a copy of "C" with fixed charset. */
  if (!lcid)
    memcpy (_messages_locale, _C_messages_locale, sizeof (struct lc_messages_T));
  else
    {
      strcpy (locale, name);
      /* Removes the charset from the locale and attach the modifer to the
	 language_TERRITORY part. */
      c = strchr (locale, '.');
      if (c)
	{
	  *c = '\0';
	  c2 = strchr (c + 1, '@@');
	  /* Ignore @@cjknarrow modifier since it's a very personal thing between
	     Cygwin and newlib... */
	  if (c2 && strcmp (c2, "@@cjknarrow"))
	    memmove (c, c2, strlen (c2) + 1);
	}
      /* Now search in the alphabetically order lc_msg array for the
	 locale. */
      lc_msg_t locale_key = { locale, NULL, NULL, NULL, NULL };
      msg = (lc_msg_t *) bsearch ((void *) &locale_key, (void *) lc_msg,
				  sizeof lc_msg / sizeof *lc_msg,
				  sizeof *lc_msg, locale_cmp);
      if (!msg)
	return 0;
    }

  /* Evaluate string length in target charset.  Characters invalid in the
     target charset are simply ignored, as on Linux. */
  size_t len = 0;
  len += (strlen (charset) + 1);
  if (lcid)
    {
      len += lc_wcstombs (f_wctomb, charset, NULL, msg->yesexpr, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, msg->noexpr, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, msg->yesstr, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, msg->nostr, 0) + 1;
      len += (wcslen (msg->yesexpr) + 1) * sizeof (wchar_t);
      len += (wcslen (msg->noexpr) + 1) * sizeof (wchar_t);
      len += (wcslen (msg->yesstr) + 1) * sizeof (wchar_t);
      len += (wcslen (msg->nostr) + 1) * sizeof (wchar_t);
      if (len % 1)
	++len;
    }
  /* Allocate. */
  char *new_lc_messages_buf = (char *) malloc (len);
  const char *lc_messages_end = new_lc_messages_buf + len;

  if (!new_lc_messages_buf)
    return -1;
  /* Copy over. */
  c = new_lc_messages_buf;
  /* codeset */
  _messages_locale->codeset = c;
  c = stpcpy (c, charset) + 1;
  if (lcid)
    {
      _messages_locale->yesexpr = (const char *) c;
      len = lc_wcstombs (f_wctomb, charset, c, msg->yesexpr, lc_messages_end - c);
      _messages_locale->noexpr = (const char *) (c += len + 1);
      len = lc_wcstombs (f_wctomb, charset, c, msg->noexpr, lc_messages_end - c);
      _messages_locale->yesstr = (const char *) (c += len + 1);
      len = lc_wcstombs (f_wctomb, charset, c, msg->yesstr, lc_messages_end - c);
      _messages_locale->nostr = (const char *) (c += len + 1);
      len = lc_wcstombs (f_wctomb, charset, c, msg->nostr, lc_messages_end - c);
      c += len + 1;
      if ((uintptr_t) c % 1)
	++c;
      wchar_t *wc = (wchar_t *) c;
      _messages_locale->wyesexpr = (const wchar_t *) wc;
      wc = wcpcpy (wc, msg->yesexpr) + 1;
      _messages_locale->wnoexpr = (const wchar_t *) wc;
      wc = wcpcpy (wc, msg->noexpr) + 1;
      _messages_locale->wyesstr = (const wchar_t *) wc;
      wc = wcpcpy (wc, msg->yesstr) + 1;
      _messages_locale->wnostr = (const wchar_t *) wc;
      wcpcpy (wc, msg->nostr);
    }
  /* Aftermath. */
  if (*lc_messages_buf)
    free (*lc_messages_buf);
  *lc_messages_buf = new_lc_messages_buf;
  return 1;
}

LCID collate_lcid = 0;
static mbtowc_p collate_mbtowc = __ascii_mbtowc;
char collate_charset[ENCODING_LEN + 1] = "ASCII";

/* Called from newlib's setlocale() if category is LC_COLLATE.  Stores
   LC_COLLATE locale information.  This is subsequently accessed by the
   below functions strcoll, strxfrm, wcscoll, wcsxfrm. */
extern "C" int
__collate_load_locale (const char *name, mbtowc_p f_mbtowc, const char *charset)
{
  LCID lcid = __get_lcid_from_locale (name);
  if (lcid == (LCID) -1)
    return -1;
  collate_lcid = lcid;
  collate_mbtowc = f_mbtowc;
  stpcpy (collate_charset, charset);
  return 0;
}

extern "C" const char *
__get_current_collate_codeset (void)
{
  return collate_charset;
}

/* We use the Windows functions for locale-specific string comparison and
   transformation.  The advantage is that we don't need any files with
   collation information. */
extern "C" int
wcscoll (const wchar_t *__restrict ws1, const wchar_t *__restrict ws2)
{
  int ret;

  if (!collate_lcid)
    return wcscmp (ws1, ws2);
  ret = CompareStringW (collate_lcid, 0, ws1, -1, ws2, -1);
  if (!ret)
    set_errno (EINVAL);
  return ret - CSTR_EQUAL;
}

extern "C" int
strcoll (const char *__restrict s1, const char *__restrict s2)
{
  size_t n1, n2;
  wchar_t *ws1, *ws2;
  tmp_pathbuf tp;
  int ret;

  if (!collate_lcid)
    return strcmp (s1, s2);
  /* The ANSI version of CompareString uses the default charset of the lcid,
     so we must use the Unicode version. */
  n1 = lc_mbstowcs (collate_mbtowc, collate_charset, NULL, s1, 0) + 1;
  ws1 = (n1 > NT_MAX_PATH ? (wchar_t *) malloc (n1 * sizeof (wchar_t))
			  : tp.w_get ());
  lc_mbstowcs (collate_mbtowc, collate_charset, ws1, s1, n1);
  n2 = lc_mbstowcs (collate_mbtowc, collate_charset, NULL, s2, 0) + 1;
  ws2 = (n2 > NT_MAX_PATH ? (wchar_t *) malloc (n2 * sizeof (wchar_t))
			  : tp.w_get ());
  lc_mbstowcs (collate_mbtowc, collate_charset, ws2, s2, n2);
  ret = CompareStringW (collate_lcid, 0, ws1, -1, ws2, -1);
  if (n1 > NT_MAX_PATH)
    free (ws1);
  if (n2 > NT_MAX_PATH)
    free (ws2);
  if (!ret)
    set_errno (EINVAL);
  return ret - CSTR_EQUAL;
}

/* BSD.  Used from glob.cc, fnmatch.c and regcomp.c.  Make sure caller is
   using wide chars.  Unfortunately the definition of this functions hides
   the required input type. */
extern "C" int
__collate_range_cmp (int c1, int c2)
{
  wchar_t s1[2] = { (wchar_t) c1, L'\0' };
  wchar_t s2[2] = { (wchar_t) c2, L'\0' };
  return wcscoll (s1, s2);
}

extern "C" size_t
wcsxfrm (wchar_t *__restrict ws1, const wchar_t *__restrict ws2, size_t wsn)
{
  size_t ret;

  if (!collate_lcid)
    return wcslcpy (ws1, ws2, wsn);
  ret = LCMapStringW (collate_lcid, LCMAP_SORTKEY | LCMAP_BYTEREV,
		      ws2, -1, ws1, wsn * sizeof (wchar_t));
  /* LCMapStringW returns byte count including the terminating NUL character,
     wcsxfrm is supposed to return length in wchar_t excluding the NUL.
     Since the array is only single byte NUL-terminated we must make sure
     the result is wchar_t-NUL terminated. */
  if (ret)
    {
      ret = (ret + 1) / sizeof (wchar_t);
      if (ret >= wsn)
	return wsn;
      ws1[ret] = L'\0';
      return ret;
    }
  if (GetLastError () != ERROR_INSUFFICIENT_BUFFER)
    set_errno (EINVAL);
  return wsn;
}

extern "C" size_t
strxfrm (char *__restrict s1, const char *__restrict s2, size_t sn)
{
  size_t ret;
  size_t n2;
  wchar_t *ws2;
  tmp_pathbuf tp;

  if (!collate_lcid)
    return strlcpy (s1, s2, sn);
  /* The ANSI version of LCMapString uses the default charset of the lcid,
     so we must use the Unicode version. */
  n2 = lc_mbstowcs (collate_mbtowc, collate_charset, NULL, s2, 0) + 1;
  ws2 = (n2 > NT_MAX_PATH ? (wchar_t *) malloc (n2 * sizeof (wchar_t))
			  : tp.w_get ());
  lc_mbstowcs (collate_mbtowc, collate_charset, ws2, s2, n2);
  /* The sort key is a NUL-terminated byte string. */
  ret = LCMapStringW (collate_lcid, LCMAP_SORTKEY, ws2, -1, (PWCHAR) s1, sn);
  if (n2 > NT_MAX_PATH)
    free (ws2);
  if (ret == 0)
    {
      if (GetLastError () != ERROR_INSUFFICIENT_BUFFER)
	set_errno (EINVAL);
      return sn;
    }
  /* LCMapStringW returns byte count including the terminating NUL character.
     strxfrm is supposed to return length excluding the NUL. */
  return ret - 1;
}

/* Fetch default ANSI codepage from locale info and generate a setlocale
   compatible character set code.  Called from newlib's setlocale(), if the
   charset isn't given explicitely in the POSIX compatible locale specifier. */
extern "C" void
__set_charset_from_locale (const char *locale, char *charset)
{
  UINT cp;
  LCID lcid = __get_lcid_from_locale (locale);
  wchar_t wbuf[9];

  /* "C" locale, or invalid locale? */
  if (lcid == 0 || lcid == (LCID) -1)
    cp = 20127;
  else if (!GetLocaleInfoW (lcid,
			    LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
			    (PWCHAR) &cp, sizeof cp))
    cp = 0;
  /* Translate codepage and lcid to a charset closely aligned with the default
     charsets defined in Glibc. */
  const char *cs;
  const char *modifier = strchr (locale, '@@') ?: "";
  switch (cp)
    {
    case 20127:
      cs = "ASCII";
      break;
    case 874:
      cs = "CP874";
      break;
    case 932:
      cs = "EUCJP";
      break;
    case 936:
      cs = "GB2312";
      break;
    case 949:
      cs = "EUCKR";
      break;
    case 950:
      cs = "BIG5";
      break;
    case 1250:
      if (lcid == 0x081a		/* sr_CS (Serbian Language/Former
						  Serbia and Montenegro) */
	  || lcid == 0x181a		/* sr_BA (Serbian Language/Bosnia
						  and Herzegovina) */
	  || lcid == 0x241a		/* sr_RS (Serbian Language/Serbia) */
	  || lcid == 0x2c1a		/* sr_ME (Serbian Language/Montenegro)*/
	  || lcid == 0x0442)		/* tk_TM (Turkmen/Turkmenistan) */
	cs = "UTF-8";
      else if (lcid == 0x041c)		/* sq_AL (Albanian/Albania) */
	cs = "ISO-8859-1";
      else
	cs = "ISO-8859-2";
      break;
    case 1251:
      if (lcid == 0x0c1a		/* sr_CS (Serbian Language/Former
						  Serbia and Montenegro) */
	  || lcid == 0x1c1a		/* sr_BA (Serbian Language/Bosnia
						  and Herzegovina) */
	  || lcid == 0x281a		/* sr_RS (Serbian Language/Serbia) */
	  || lcid == 0x301a		/* sr_ME (Serbian Language/Montenegro)*/
	  || lcid == 0x0440		/* ky_KG (Kyrgyz/Kyrgyzstan) */
	  || lcid == 0x0843		/* uz_UZ (Uzbek/Uzbekistan) */
					/* tt_RU (Tatar/Russia),
						 IQTElif alphabet */
	  || (lcid == 0x0444 && has_modifier ("@@iqtelif"))
	  || lcid == 0x0450)		/* mn_MN (Mongolian/Mongolia) */
	cs = "UTF-8";
      else if (lcid == 0x0423)		/* be_BY (Belarusian/Belarus) */
	cs = has_modifier ("@@latin") ? "UTF-8" : "CP1251";
      else if (lcid == 0x0402)		/* bg_BG (Bulgarian/Bulgaria) */
	cs = "CP1251";
      else if (lcid == 0x0422)		/* uk_UA (Ukrainian/Ukraine) */
	cs = "KOI8-U";
      else
	cs = "ISO-8859-5";
      break;
    case 1252:
      if (lcid == 0x0452)		/* cy_GB (Welsh/Great Britain) */
	cs = "ISO-8859-14";
      else if (lcid == 0x4009		/* en_IN (English/India) */
	       || lcid == 0x0867	/* ff_SN (Fulah/Senegal) */
	       || lcid == 0x0464	/* fil_PH (Filipino/Philippines) */
	       || lcid == 0x0462	/* fy_NL (Frisian/Netherlands) */
	       || lcid == 0x0468	/* ha_NG (Hausa/Nigeria) */
	       || lcid == 0x0475	/* haw_US (Hawaiian/United States) */
	       || lcid == 0x0470	/* ig_NG (Igbo/Nigeria) */
	       || lcid == 0x085d	/* iu_CA (Inuktitut/Canada) */
	       || lcid == 0x046c	/* nso_ZA (Northern Sotho/South Africa) */
	       || lcid == 0x0487	/* rw_RW (Kinyarwanda/Rwanda) */
	       || lcid == 0x043b	/* se_NO (Northern Saami/Norway) */
	       || lcid == 0x0832	/* tn_BW (Tswana/Botswana) */
	       || lcid == 0x0432	/* tn_ZA (Tswana/South Africa) */
	       || lcid == 0x0488	/* wo_SN (Wolof/Senegal) */
	       || lcid == 0x046a)	/* yo_NG (Yoruba/Nigeria) */
	cs = "UTF-8";
      else if (lcid == 0x042e)		/* hsb_DE (Upper Sorbian/Germany) */
	cs = "ISO-8859-2";
      else if (lcid == 0x0491		/* gd_GB (Scots Gaelic/Great Britain) */
	       || (has_modifier ("@@euro")
		   && GetLocaleInfoW (lcid, LOCALE_SINTLSYMBOL, wbuf, 9)
		   && !wcsncmp (wbuf, L"EUR", 3)))
	cs = "ISO-8859-15";
      else
	cs = "ISO-8859-1";
      break;
    case 1253:
      cs = "ISO-8859-7";
      break;
    case 1254:
      if (lcid == 0x042c)		/* az_AZ (Azeri/Azerbaijan) */
	cs = "UTF-8";
      else if (lcid == 0x0443)		/* uz_UZ (Uzbek/Uzbekistan) */
	cs = "ISO-8859-1";
      else
	cs = "ISO-8859-9";
      break;
    case 1255:
      cs = "ISO-8859-8";
      break;
    case 1256:
      if (lcid == 0x0429		/* fa_IR (Persian/Iran) */
	  || lcid == 0x0846		/* pa_PK (Punjabi/Pakistan) */
	  || lcid == 0x0859		/* sd_PK (Sindhi/Pakistan) */
	  || lcid == 0x0480		/* ug_CN (Uyghur/China) */
	  || lcid == 0x0420)		/* ur_PK (Urdu/Pakistan) */
	cs = "UTF-8";
      else
	cs = "ISO-8859-6";
      break;
    case 1257:
      if (lcid == 0x0425)		/* et_EE (Estonian/Estonia) */
	cs = "ISO-8859-15";
      else
	cs = "ISO-8859-13";
      break;
    case 1258:
    default:
      if (lcid == 0x3c09 		/* en_HK (English/Hong Kong) */
	  || lcid == 0x200c		/* fr_RE (French/Runion) */
	  || lcid == 0x240c		/* fr_CD (French/Congo) */
	  || lcid == 0x280c		/* fr_SN (French/Senegal) */
	  || lcid == 0x2c0c		/* fr_CM (French/Cameroon) */
	  || lcid == 0x300c		/* fr_CI (French/Ivory Coast) */
	  || lcid == 0x340c		/* fr_ML (French/Mali) */
	  || lcid == 0x380c		/* fr_MA (French/Morocco) */
	  || lcid == 0x3c0c		/* fr_HT (French/Haiti) */
	  || lcid == 0x0477		/* so_SO (Somali/Somali) */
	  || lcid == 0x0430)		/* st_ZA (Sotho/South Africa) */
      	cs = "ISO-8859-1";
      else if (lcid == 0x818)		/* ro_MD (Romanian/Moldovia) */
      	cs = "ISO-8859-2";
      else if (lcid == 0x043a)		/* mt_MT (Maltese/Malta) */
	cs = "ISO-8859-3";
      else if (lcid == 0x0481)		/* mi_NZ (Maori/New Zealand) */
	cs = "ISO-8859-13";
      else if (lcid == 0x0437)		/* ka_GE (Georgian/Georgia) */
	cs = "GEORGIAN-PS";
      else if (lcid == 0x043f)		/* kk_KZ (Kazakh/Kazakhstan) */
	cs = "PT154";
      else
	cs = "UTF-8";
    }
  stpcpy (charset, cs);
}

/* This function is called from newlib's loadlocale if the locale identifier
   was invalid, one way or the other.  It looks for the file

     /usr/share/locale/locale.alias

   which is part of the gettext package, and if it finds the locale alias
   in that file, it replaces the locale with the correct locale string from
   that file.

   If successful, it returns a pointer to new_locale, NULL otherwise.*/
extern "C" char *
__set_locale_from_locale_alias (const char *locale, char *new_locale)
{
  wchar_t wlocale[ENCODING_LEN + 1];
  wchar_t walias[ENCODING_LEN + 1];
#define LOCALE_ALIAS_LINE_LEN 255
  char alias_buf[LOCALE_ALIAS_LINE_LEN + 1], *c;
  wchar_t *wc;
  const char *alias, *replace;
  char *ret = NULL;

  FILE *fp = fopen ("/usr/share/locale/locale.alias", "rt");
  if (!fp)
    return NULL;
  /* The incoming locale is given in the application charset, or in
     the Cygwin internal charset.  We try both. */
  if (mbstowcs (wlocale, locale, ENCODING_LEN + 1) == (size_t) -1)
    sys_mbstowcs (wlocale, ENCODING_LEN + 1, locale);
  wlocale[ENCODING_LEN] = L'\0';
  /* Ignore @@cjknarrow modifier since it's a very personal thing between
     Cygwin and newlib... */
  if ((wc = wcschr (wlocale, L'@@')) && !wcscmp (wc + 1, L"cjknarrow"))
    *wc = L'\0';
  while (fgets (alias_buf, LOCALE_ALIAS_LINE_LEN + 1, fp))
    {
      alias_buf[LOCALE_ALIAS_LINE_LEN] = '\0';
      c = strrchr (alias_buf, '\n');
      if (c)
	*c = '\0';
      c = alias_buf;
      c += strspn (c, " \t");
      if (!*c || *c == '#')
	continue;
      alias = c;
      c += strcspn (c, " \t");
      *c++ = '\0';
      c += strspn (c, " \t");
      if (*c == '#')
	continue;
      replace = c;
      c += strcspn (c, " \t");
      *c++ = '\0';
      if (strlen (replace) > ENCODING_LEN)
	continue;
      /* The file is latin1 encoded */
      lc_mbstowcs (__iso_mbtowc, "ISO-8859-1", walias, alias, ENCODING_LEN + 1);
      walias[ENCODING_LEN] = L'\0';
      if (!wcscmp (wlocale, walias))
	{
	  ret = strcpy (new_locale, replace);
	  break;
	}
    }
  fclose (fp);
  return ret;
}

static char *
check_codepage (char *ret)
{
  if (!wincap.has_always_all_codepages ())
    {
      /* Prior to Windows Vista, many codepages are not installed by
	 default, or can be deinstalled.  The following codepages require
	 that the respective conversion tables are installed into the OS.
	 So we check if they are installed and if not, setlocale should
	 fail. */
      CPINFO cpi;
      UINT cp = 0;
      if (__mbtowc == __sjis_mbtowc)
	cp = 932;
      else if (__mbtowc == __eucjp_mbtowc)
	cp = 20932;
      else if (__mbtowc == __gbk_mbtowc)
	cp = 936;
      else if (__mbtowc == __kr_mbtowc)
	cp = 949;
      else if (__mbtowc == __big5_mbtowc)
	cp = 950;
      if (cp && !GetCPInfo (cp, &cpi)
	  && GetLastError () == ERROR_INVALID_PARAMETER)
	return NULL;
    }
  return ret;
}

/* Can be called via cygwin_internal (CW_INTERNAL_SETLOCALE) for application
   which really (think they) know what they are doing. */
extern "C" void
internal_setlocale ()
{
  /* Each setlocale from the environment potentially changes the
     multibyte representation of the CWD.  Therefore we have to
     reevaluate the CWD's posix path and store in the new charset.
     Same for the PATH environment variable. */
  /* FIXME: Other buffered paths might be affected as well. */
  /* FIXME: It could be necessary to convert the entire environment,
	    not just PATH. */
  tmp_pathbuf tp;
  char *path;
  wchar_t *w_path = NULL, *w_cwd;

  /* Don't do anything if the charset hasn't actually changed. */
  if (strcmp (cygheap->locale.charset, __locale_charset ()) == 0)
    return;

  debug_printf ("Cygwin charset changed from %s to %s",
		cygheap->locale.charset, __locale_charset ());
  /* Fetch PATH and CWD and convert to wchar_t in previous charset. */
  path = getenv ("PATH");
  if (path && *path)	/* $PATH can be potentially unset. */
    {
      w_path = tp.w_get ();
      sys_mbstowcs (w_path, 32768, path);
    }
  w_cwd = tp.w_get ();
  cwdstuff::cwd_lock.acquire ();
  sys_mbstowcs (w_cwd, 32768, cygheap->cwd.get_posix ());
  /* Set charset for internal conversion functions. */
  if (*__locale_charset () == 'A'/*SCII*/)
    {
      cygheap->locale.mbtowc = __utf8_mbtowc;
      cygheap->locale.wctomb = __utf8_wctomb;
    }
  else
    {
      cygheap->locale.mbtowc = __mbtowc;
      cygheap->locale.wctomb = __wctomb;
    }
  strcpy (cygheap->locale.charset, __locale_charset ());
  /* Restore CWD and PATH in new charset. */
  cygheap->cwd.reset_posix (w_cwd);
  cwdstuff::cwd_lock.release ();
  if (w_path)
    {
      char *c_path = tp.c_get ();
      sys_wcstombs (c_path, 32768, w_path);
      setenv ("PATH", c_path, 1);
    }
}

/* Called from dll_crt0_1, before fetching the command line from Windows.
   Set the internal charset according to the environment locale settings.
   Check if a required codepage is available, and only switch internal
   charset if so.
   Make sure to reset the application locale to "C" per POSIX. */
void
initial_setlocale ()
{
  char *ret = _setlocale_r (_REENT, LC_CTYPE, "");
  if (ret && check_codepage (ret))
    internal_setlocale ();
}

/* Like newlib's setlocale, but additionally check if the charset needs
   OS support and the required codepage is actually installed.  If codepage
   is not available, revert to previous locale and return NULL.  For details
   about codepage availability, see the comment in check_codepage() above. */
extern "C" char *
setlocale (int category, const char *locale)
{
  char old[(LC_MESSAGES + 1) * (ENCODING_LEN + 1/*"/"*/ + 1)];
  if (locale && !wincap.has_always_all_codepages ())
    stpcpy (old, _setlocale_r (_REENT, category, NULL));
  char *ret = _setlocale_r (_REENT, category, locale);
  if (ret && locale && !(ret = check_codepage (ret)))
    _setlocale_r (_REENT, category, old);
  return ret;
}
@


1.42
log
@	* nlsfuncs.cc (strcoll): Add "__restrict" to definition.
	(strxfrm): Ditto.
@
text
@d1153 1
a1153 1
wcscoll (const wchar_t *ws1, const wchar_t *ws2)
d1207 1
a1207 1
wcsxfrm (wchar_t *ws1, const wchar_t *ws2, size_t wsn)
@


1.41
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d1166 1
a1166 1
strcoll (const char *s1, const char *s2)
d1233 1
a1233 1
strxfrm (char *s1, const char *s2, size_t sn)
@


1.40
log
@	* lc_msg.h: Regenerate.
	* nlsfuncs.cc (__get_lcid_from_locale): Update list of Script-only
	locales to Windows 8.
	(__set_charset_from_locale): Take locales added with Windows 8 and 8.1
	into account.
@
text
@a11 1
#include <winnls.h>
@


1.39
log
@	* nlsfuncs.cc (__collate_range_cmp): Convert input to wchar_t and call
	wcscoll since all calling functions are using wide chars.  Explain in
	preceeding comment.
@
text
@d103 2
d107 1
d110 2
d118 1
d1346 1
d1350 1
d1352 1
d1356 1
d1359 1
a1359 2
	       || lcid == 0x046a	/* yo_NG (Yoruba/Nigeria) */
	       || lcid == 0x085d)	/* iu_CA (Inuktitut/Canada) */
d1387 2
d1403 14
a1416 2
      if (lcid == 0x0481)		/* mi_NZ (Maori/New Zealand) */
	cs = "ISO-8859-13";
d1419 2
a1426 1
      break;
@


1.38
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1190 3
a1192 1
/* BSD.  Used in glob.cc and regcomp.c, for instance. */
d1196 3
a1198 3
  char s1[2] = { (char) c1, '\0' };
  char s2[2] = { (char) c2, '\0' };
  return strcoll (s1, s2);
@


1.37
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d3 1
a3 1
   Copyright 2010, 2011, 2012 Red Hat, Inc.
a43 5
/* Vista and later.  Not defined in w32api yet. */
extern "C" {
WINBASEAPI LCID WINAPI LocaleNameToLCID (LPCWSTR, DWORD);
};

d64 1
a64 1
      debug_printf ("LCID=0x%04x", last_lcid);
d143 1
a143 1
      debug_printf ("LCID=0x%04x", last_lcid);
d228 1
a228 1
  debug_printf ("LCID=0x%04x", last_lcid);
d1194 2
a1195 2
  char s1[2] = { c1, '\0' };
  char s2[2] = { c2, '\0' };
@


1.36
log
@	* Makefile.in (clean): Remove non-existant regexp dir.

	* collate.h: New header.
	(__collate_range_cmp): Declare.
	(__collate_load_error): Define.
	* glob.cc: Pull in latest version from FreeBSD.  Simplify and reduce
	Cygwin-specific changes.
	* regex/regcomp.c: Include collate.h on Cygwin as well.
	(__collate_range_cmp): Move from here...
	* nlsfuncs.cc (__collate_range_cmp): ...to here.

	* miscfuncs.cc (thread_wrapper): Fix typo in comment.
	(CygwinCreateThread): Take dead zone of Windows stack into account.
	Change the way how the stack is commited and how to handle guardpages.
	Explain how and why.
	* thread.h (PTHREAD_DEFAULT_STACKSIZE): Change definition.  Explain why.
@
text
@d3 1
a3 1
   Copyright 2010 Red Hat, Inc.
@


1.36.2.1
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d1199 2
a1200 2
  char s1[2] = { (char) c1, '\0' };
  char s2[2] = { (char) c2, '\0' };
@


1.36.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d69 1
a69 1
      debug_printf ("LCID=%04y", last_lcid);
d148 1
a148 1
      debug_printf ("LCID=%04y", last_lcid);
d233 1
a233 1
  debug_printf ("LCID=%04y", last_lcid);
@


1.36.2.3
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2010, 2011, 2012 Red Hat, Inc.
@


1.36.2.4
log
@	* lc_msg.h: Regenerate from F18 glibc 2.16-28.  In the first place this
	fixes fi_FI and adds ta_LK (new in Windows 8).
	* nlsfuncs.cc (LocaleNameToLCID): Drop unneeded declaration.
@
text
@d3 1
a3 1
   Copyright 2010, 2011, 2012, 2013 Red Hat, Inc.
d44 5
@


1.35
log
@Clean up whitespace.
@
text
@d1195 9
@


1.34
log
@whitespace elimination
@
text
@d1409 1
a1409 1
 
@


1.33
log
@	* exceptions.cc (open_stackdumpfile): Correctly append .stackdump
	suffix.

	* nlsfuncs.cc (rebase_locale_buf): Reorder arguments.  Accommodate
	throughout.  Add pointer to end of buffer and avoid changing pointers
	not pointing into the buffer.
@
text
@d119 1
a119 1
	    { NULL    , NULL          }
d200 2
a201 2
        { "nn_NO", MAKELANGID (LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK)   },
        { "no_NO", MAKELANGID (LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL)    },
d303 1
a303 1
      			charset, &state);
d305 3
a307 3
        {
          state.__count = 0;
          bytes = 1;
d310 1
a310 1
        }
d312 1
a312 1
        break;
d480 1
a480 1
      	continue;
d483 1
a483 1
      	{
d528 1
a528 1
  
d562 1
a562 1
      		lcid == MAKELANGID (LANG_JAPANESE, SUBLANG_JAPANESE_JAPAN)
d729 1
a729 1
	  _time_locale->wera_d_fmt = 
d734 1
a734 1
	  _time_locale->era_d_fmt = 
d819 1
a819 1
  				lc_ctype_ptr - new_lc_ctype_buf);
d877 1
a877 1
  
d879 1
a879 1
  				lc_numeric_ptr - new_lc_numeric_buf);
d1006 1
a1006 1
  				lc_monetary_ptr - new_lc_monetary_buf);
d1301 1
a1301 1
      	cs = "UTF-8";
d1320 1
a1320 1
      	cs = "UTF-8";
d1324 1
a1324 1
      	cs = "CP1251";
d1345 1
a1345 1
      	cs = "UTF-8";
d1361 1
a1361 1
      	cs = "UTF-8";
d1409 1
a1409 1
   
@


1.32
log
@	* nlsfuncs.cc (__set_lc_time_from_win): Use LOCALE_SMONTHNAME1
	instead of LOCALE_SABBREVMONTHNAME1 in Japanese and Korean
	locales to get abbreviated month names.  Explain why.
@
text
@d338 2
a339 2
rebase_locale_buf (const void *ptrv, const char *newbase, const char *oldbase,
		   const void *ptrvend)
a340 1
  const char **ptrs = (const char **) ptrv;
d342 3
a344 2
  while (ptrs < ptrsend)
    *ptrs++ += newbase - oldbase;
d689 2
a690 2
		    rebase_locale_buf (_time_locale, tmp, new_lc_time_buf,
				       _time_locale + 1);
d751 2
a752 2
    rebase_locale_buf (_time_locale, tmp, new_lc_time_buf,
		       _time_locale + 1);
d826 2
a827 2
    rebase_locale_buf (_ctype_locale, tmp, new_lc_ctype_buf,
		       _ctype_locale + 1);
d886 2
a887 2
    rebase_locale_buf (_numeric_locale, tmp, new_lc_numeric_buf,
		       _numeric_locale + 1);
d1013 2
a1014 2
    rebase_locale_buf (_monetary_locale, tmp, new_lc_monetary_buf,
		       _monetary_locale + 1);
@


1.31
log
@	* cygwin.din (__locale_mb_cur_max): Export.
	* nlsfuncs.cc (__getlocaleinfo): Drop conversion to multibyte.
	(__charfromwchar): New function to convert to multibyte.
	(__eval_datetimefmt): Convert to return wchar_t pointer.  Work on
	wide char string.
	(__set_lc_time_from_win): Take additional pointer to "C" category info
	to accommodate C.foo locales.  Rework to fill wide char members in
	category info.
	(__set_lc_ctype_from_win): New function.
	(__set_lc_numeric_from_win): Take additional pointer to "C" category
	info to accommodate C.foo locales.  Rework to fill wide char members
	in category info.
	(__set_lc_monetary_from_win): Ditto.
	(__set_lc_messages_from_win): Ditto.
	(__get_current_collate_codeset): New function, called from nl_langinfo.
	* include/cygwin/config.h (__HAVE_LOCALE_INFO_EXTENDED__): Define.
@
text
@d554 11
d567 1
a567 2
	  _time_locale->wmon[i] = getlocaleinfo (time,
						 LOCALE_SABBREVMONTHNAME1 + i);
@


1.30
log
@	* nlsfuncs.cc (__set_lc_time_from_win): Actually set
	_time_locale->md_order to the D_MD_ORDER value written to the buffer.
@
text
@d24 1
d34 1
a34 1
	    __getlocaleinfo(lcid,(type),_LC(category),f_wctomb,charset)
d37 4
a40 1
			       lc_time_end-lc_time_ptr,f_wctomb, charset)
d347 14
d362 1
a362 1
__getlocaleinfo (LCID lcid, LCTYPE type, char **ptr, size_t size,
a364 1
  wchar_t wbuf[80];
d368 1
a368 2
  GetLocaleInfoW (lcid, type, wbuf, 80);
  num = lc_wcstombs (f_wctomb, charset, ret = *ptr, wbuf, size);
d387 1
a387 1
static char *
d389 1
a389 1
		    size_t size, wctomb_p f_wctomb, const char *charset)
a392 2
  size_t num;
  mbstate_t mb;
d394 11
a404 9
  const char *day_str = "edaA";
  const char *mon_str = "mmbB";
  const char *year_str = "yyyY";
  const char *hour12_str = "lI";
  const char *hour24_str = "kH";
  const char *t_str;
  char *ret = *ptr;
  char *p = *ptr;

a405 1
  memset (&mb, 0, sizeof mb);
d411 1
a411 1
	  *p++ = '\'';
d414 1
a414 7
	    {
	      num = f_wctomb (_REENT, p, *fmt, charset, &mb);
	      if (num == (size_t) -1)
		memset (&mb, 0, sizeof mb);
	      else
		p += num;
	    }
d425 1
a425 1
	*p++ = '%';
d440 1
a440 1
	*p++ = '%';
d448 2
a449 2
	*p++ = '%';
	*p++ = (fc == L'm' ? 'M' : fc == L's' ? 'S' : 'p');
d454 2
a455 2
	*p++ = '%';
	*p++ = (char) fc;
d458 1
a458 5
	num = f_wctomb (_REENT, p, *fmt, charset, &mb);
	if (num == (size_t) -1)
	  memset (&mb, 0, sizeof mb);
	else
	  p += num;
d461 2
a462 2
  *p++ = '\0';
  *ptr = p;
d501 3
a503 1
__set_lc_time_from_win (const char *name, struct lc_time_T *_time_locale,
d508 1
a508 1
  if (!lcid || lcid == (LCID) -1)
d510 4
d515 2
a516 2
  char *new_lc_time_buf = (char *) malloc (4096);
  const char *lc_time_end = new_lc_time_buf + 4096;
d522 146
a667 112
  char locale[ENCODING_LEN + 1];
  strcpy (locale, name);
  /* Removes the charset from the locale and attach the modifer to the
     language_TERRITORY part. */
  char *c = strchr (locale, '.');
  if (c)
    {
      *c = '\0';
      char *c2 = strchr (c + 1, '@@');
      /* Ignore @@cjknarrow modifier since it's a very personal thing between
	 Cygwin and newlib... */
      if (c2 && strcmp (c2, "@@cjknarrow"))
      	memmove (c, c2, strlen (c2) + 1);
    }
  /* Now search in the alphabetically order lc_era array for the
     locale. */
  lc_era_t locale_key = { locale, NULL, NULL, NULL, NULL, NULL ,
				  NULL, NULL, NULL, NULL, NULL };
  lc_era_t *era = (lc_era_t *) bsearch ((void *) &locale_key, (void *) lc_era,
					sizeof lc_era / sizeof *lc_era,
					sizeof *lc_era, locale_cmp);

  /* mon */
  for (int i = 0; i < 12; ++i)
    _time_locale->mon[i] = getlocaleinfo (time, LOCALE_SABBREVMONTHNAME1 + i);
  /* month and alt_month */
  for (int i = 0; i < 12; ++i)
    _time_locale->month[i] = _time_locale->alt_month[i]
			   = getlocaleinfo (time, LOCALE_SMONTHNAME1 + i);
  /* wday */
  _time_locale->wday[0] = getlocaleinfo (time, LOCALE_SABBREVDAYNAME7);
  for (int i = 0; i < 6; ++i)
    _time_locale->wday[i + 1] = getlocaleinfo (time,
					       LOCALE_SABBREVDAYNAME1 + i);
  /* weekday */
  _time_locale->weekday[0] = getlocaleinfo (time, LOCALE_SDAYNAME7);
  for (int i = 0; i < 6; ++i)
    _time_locale->weekday[i + 1] = getlocaleinfo (time, LOCALE_SDAYNAME1 + i);

  size_t len;
  /* X_fmt */
  if (era && *era->t_fmt)
    {
      _time_locale->X_fmt = (const char *) lc_time_ptr;
      len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->t_fmt,
			 lc_time_end - lc_time_ptr) + 1;
      lc_time_ptr += len;
    }
  else
    _time_locale->X_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
  /* x_fmt */
  if (era && *era->d_fmt)
    {
      _time_locale->x_fmt = (const char *) lc_time_ptr;
      len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->d_fmt,
			 lc_time_end - lc_time_ptr) + 1;
      lc_time_ptr += len;
    }
  else
    _time_locale->x_fmt = eval_datetimefmt (LOCALE_SSHORTDATE, DT_DEFAULT);
  /* c_fmt */
  if (era && *era->d_t_fmt)
    {
      _time_locale->c_fmt = (const char *) lc_time_ptr;
      len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->d_t_fmt,
			 lc_time_end - lc_time_ptr) + 1;
      lc_time_ptr += len;
    }
  else
    {
      _time_locale->c_fmt = eval_datetimefmt (LOCALE_SLONGDATE, DT_ABBREV);
      --lc_time_ptr;
      *lc_time_ptr++ = ' ';
      eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
    }
  /* AM/PM */
  _time_locale->am_pm[0] = getlocaleinfo (time, LOCALE_S1159);
  _time_locale->am_pm[1] = getlocaleinfo (time, LOCALE_S2359);
  /* date_fmt */
  if (era && *era->date_fmt)
    {
      _time_locale->date_fmt = (const char *) lc_time_ptr;
      len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->date_fmt,
			 lc_time_end - lc_time_ptr) + 1;
      lc_time_ptr += len;
    }
  else
    {
      _time_locale->date_fmt = eval_datetimefmt (LOCALE_SLONGDATE, DT_ABBREV);
      --lc_time_ptr;
      *lc_time_ptr++ = ' ';
      eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
      --lc_time_ptr;
      lc_time_ptr = stpcpy (lc_time_ptr, " %Z") + 1;
    }
  /* md */
  {
    wchar_t buf[80];
    GetLocaleInfoW (lcid, LOCALE_IDATE, buf, 80);
    _time_locale->md_order = (const char *) lc_time_ptr;
    lc_time_ptr = stpcpy (lc_time_ptr, *buf == L'1' ? "dm" : "md") + 1;
  }
  /* ampm_fmt */
  if (era)
    {
      _time_locale->ampm_fmt = (const char *) lc_time_ptr;
      len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->t_fmt_ampm,
			 lc_time_end - lc_time_ptr) + 1;
      lc_time_ptr += len;
    }
  else
    _time_locale->ampm_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, DT_AMPM);
d669 19
a687 19
  if (era)
    {
      /* Evaluate string length in target charset.  Characters invalid in the
	 target charset are simply ignored, as on Linux. */
      len = 0;
      len += lc_wcstombs (f_wctomb, charset, NULL, era->era, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, era->era_d_fmt, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, era->era_d_t_fmt, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, era->era_t_fmt, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, era->alt_digits, 0) + 1;

      /* Make sure data fits into the buffer */
      if (lc_time_ptr + len > lc_time_end)
	{
	  len = lc_time_ptr + len - new_lc_time_buf;
	  char *tmp = (char *) realloc (new_lc_time_buf, len);
	  if (!tmp)
	    era = NULL;
	  else
d689 25
a713 6
	      if (tmp != new_lc_time_buf)
		rebase_locale_buf (_time_locale, tmp, new_lc_time_buf,
				   _time_locale + 1);
	      lc_time_ptr = tmp + (lc_time_ptr - new_lc_time_buf);
	      new_lc_time_buf = tmp;
	      lc_time_end = new_lc_time_buf + len;
d716 1
a716 2
      /* Copy over */
      if (era)
d718 14
a731 33
	  /* era */
	  _time_locale->era = (const char *) lc_time_ptr;
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->era,
			     lc_time_end - lc_time_ptr) + 1;
	  /* era_d_fmt */
	  _time_locale->era_d_fmt = (const char *) (lc_time_ptr += len);
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->era_d_fmt,
			     lc_time_end - lc_time_ptr) + 1;
	  /* era_d_t_fmt */
	  _time_locale->era_d_t_fmt = (const char *) (lc_time_ptr += len);
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->era_d_t_fmt,
			     lc_time_end - lc_time_ptr) + 1;
	  /* era_t_fmt */
	  _time_locale->era_t_fmt = (const char *) (lc_time_ptr += len);
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->era_t_fmt,
			     lc_time_end - lc_time_ptr) + 1;
	  /* alt_digits */
	  _time_locale->alt_digits = (const char *) (lc_time_ptr += len);
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, era->alt_digits,
			     lc_time_end - lc_time_ptr) + 1;
	  lc_time_ptr += len;
	}
    }
  if (!era)
    {
      _time_locale->era =
      _time_locale->era_d_fmt = 
      _time_locale->era_d_t_fmt =
      _time_locale->era_t_fmt =
      _time_locale->alt_digits = (const char *) lc_time_ptr;
      /* Twice, to make sure era and alt_strings are correctly terminated
         with two NULs */
      *lc_time_ptr++ = '\0';
d749 75
d830 1
d836 1
a836 1
  if (!lcid || lcid == (LCID) -1)
d838 2
d841 4
a844 2
  char *new_lc_numeric_buf = (char *) malloc (48);
  const char *lc_numeric_end = new_lc_numeric_buf + 48;
d849 19
a867 10
  /* decimal_point */
  _numeric_locale->decimal_point = getlocaleinfo (numeric,
						  LOCALE_SDECIMAL);
  /* thousands_sep */
  _numeric_locale->thousands_sep = getlocaleinfo (numeric,
						  LOCALE_STHOUSAND);
  /* grouping */
  _numeric_locale->grouping = conv_grouping (lcid, LOCALE_SGROUPING,
					     &lc_numeric_ptr);

d890 1
d896 1
a896 1
  if (!lcid || lcid == (LCID) -1)
d898 2
d901 4
a904 2
  char *new_lc_monetary_buf = (char *) malloc (256);
  const char *lc_monetary_end = new_lc_monetary_buf + 256;
d909 85
a993 65
  /* int_curr_symbol */
  _monetary_locale->int_curr_symbol = getlocaleinfo (monetary,
						     LOCALE_SINTLSYMBOL);
  /* No spacing char means space. */
  if (!_monetary_locale->int_curr_symbol[3])
    {
      lc_monetary_ptr[-1] = ' ';
      *lc_monetary_ptr++ = '\0';
    }
  /* currency_symbol */
  {
    /* As on Linux:  If the currency_symbol can't be represented in the
       given charset, use int_curr_symbol. */
    wchar_t wbuf[14];
    GetLocaleInfoW (lcid, LOCALE_SCURRENCY, wbuf, 14);
    if (lc_wcstombs (f_wctomb, charset, NULL, wbuf, 0, true) == (size_t) -1)
      {
	_monetary_locale->currency_symbol = lc_monetary_ptr;
	lc_monetary_ptr = stpncpy (lc_monetary_ptr,
				   _monetary_locale->int_curr_symbol, 3);
	*lc_monetary_ptr++ = '\0';
      }
    else
      _monetary_locale->currency_symbol = getlocaleinfo (monetary,
							 LOCALE_SCURRENCY);
  }
  /* mon_decimal_point */
  _monetary_locale->mon_decimal_point = getlocaleinfo (monetary,
						       LOCALE_SMONDECIMALSEP);
  /* mon_thousands_sep */
  _monetary_locale->mon_thousands_sep = getlocaleinfo (monetary,
						       LOCALE_SMONTHOUSANDSEP);
  /* mon_grouping */
  _monetary_locale->mon_grouping = conv_grouping (lcid, LOCALE_SMONGROUPING,
						  &lc_monetary_ptr);
  /* positive_sign */
  _monetary_locale->positive_sign = getlocaleinfo (monetary,
						   LOCALE_SPOSITIVESIGN);
  /* negative_sign */
  _monetary_locale->negative_sign = getlocaleinfo (monetary,
						   LOCALE_SNEGATIVESIGN);
  /* int_frac_digits */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IINTLCURRDIGITS);
  _monetary_locale->int_frac_digits = lc_monetary_ptr++;
  /* frac_digits */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_ICURRDIGITS);
  _monetary_locale->frac_digits = lc_monetary_ptr++;
  /* p_cs_precedes */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IPOSSYMPRECEDES);
  _monetary_locale->p_cs_precedes = lc_monetary_ptr++;
  /* p_sep_by_space */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IPOSSEPBYSPACE);
  _monetary_locale->p_sep_by_space = lc_monetary_ptr++;
  /* n_cs_precedes */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_INEGSYMPRECEDES);
  _monetary_locale->n_cs_precedes = lc_monetary_ptr++;
  /* n_sep_by_space */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_INEGSEPBYSPACE);
  _monetary_locale->n_sep_by_space = lc_monetary_ptr++;
  /* p_sign_posn */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_IPOSSIGNPOSN);
  _monetary_locale->p_sign_posn = lc_monetary_ptr++;
  /* p_sign_posn */
  *lc_monetary_ptr = (char) getlocaleint (lcid, LOCALE_INEGSIGNPOSN);
  _monetary_locale->n_sign_posn = lc_monetary_ptr++;
d1013 1
d1019 1
a1019 1
  if (!lcid || lcid == (LCID) -1)
d1021 2
d1026 1
d1028 4
a1031 5
  strcpy (locale, name);
  /* Removes the charset from the locale and attach the modifer to the
     language_TERRITORY part. */
  c = strchr (locale, '.');
  if (c)
d1033 22
a1054 15
      *c = '\0';
      c2 = strchr (c + 1, '@@');
      /* Ignore @@cjknarrow modifier since it's a very personal thing between
	 Cygwin and newlib... */
      if (c2 && strcmp (c2, "@@cjknarrow"))
      	memmove (c, c2, strlen (c2) + 1);
    }
  /* Now search in the alphabetically order lc_msg array for the
     locale. */
  lc_msg_t locale_key = { locale, NULL, NULL, NULL, NULL };
  lc_msg_t *msg = (lc_msg_t *) bsearch ((void *) &locale_key, (void *) lc_msg,
					sizeof lc_msg / sizeof *lc_msg,
					sizeof *lc_msg, locale_cmp);
  if (!msg)
    return 0;
d1059 14
a1072 4
  len += lc_wcstombs (f_wctomb, charset, NULL, msg->yesexpr, 0) + 1;
  len += lc_wcstombs (f_wctomb, charset, NULL, msg->noexpr, 0) + 1;
  len += lc_wcstombs (f_wctomb, charset, NULL, msg->yesstr, 0) + 1;
  len += lc_wcstombs (f_wctomb, charset, NULL, msg->nostr, 0) + 1;
d1081 26
a1106 8
  _messages_locale->yesexpr = (const char *) c;
  len = lc_wcstombs (f_wctomb, charset, c, msg->yesexpr, lc_messages_end - c);
  _messages_locale->noexpr = (const char *) (c += len + 1);
  len = lc_wcstombs (f_wctomb, charset, c, msg->noexpr, lc_messages_end - c);
  _messages_locale->yesstr = (const char *) (c += len + 1);
  len = lc_wcstombs (f_wctomb, charset, c, msg->yesstr, lc_messages_end - c);
  _messages_locale->nostr = (const char *) (c += len + 1);
  lc_wcstombs (f_wctomb, charset, c, msg->nostr, lc_messages_end - c);
d1133 6
@


1.29
log
@	* nlsfuncs.cc: Fix indentation.
@
text
@d610 1
@


1.28
log
@	* nlsfuncs.cc (rebase_locale_buf): New helper function to rebase
	function pointers in locale structures.  Explain why this is necessary.
	(__set_lc_time_from_win): Use rebase_locale_buf after realloc.
	(__set_lc_numeric_from_win): Ditto.
	(__set_lc_monetary_from_win): Ditto.
@
text
@d335 1
a335 1
                   const void *ptrvend)
d697 1
a697 1
                       _time_locale + 1);
d743 1
a743 1
                       _numeric_locale + 1);
d845 1
a845 1
                       _monetary_locale + 1);
@


1.27
log
@	* nlsfuncs.cc (__set_charset_from_locale):  Set default charset for
	locales defaulting to codepage 936 to GB2312.
@
text
@d328 15
d643 3
d695 3
d741 3
d843 3
@


1.26
log
@	* lc_era.h: Redefine lc_era_t to keep
	default date and time formats as well to workaround YA Windows
	shortcoming.  Refresh with latest data.
	* lc_msg.h: Refresh with latest data.
	* nlsfuncs.cc (__eval_datetimefmt): Revert latest change.
	(__set_lc_time_from_win): Rename res to era.  Prefer default date and
	time formats from era array if available.
	(__set_lc_messages_from_win): Rename res to msg.
@
text
@d1045 1
a1045 1
      cs = "GBK";
@


1.25
log
@	* lc_era.h (lc_era): Fix "ja_JP" era_t_fmt entry to use traditional
	format.
	* nlsfuncs.cc (dt_flags): Remove DT_ERACAL since crippled era data
	in Windows makes it useless.
	(__eval_datetimefmt): Check if locale's default calender has
	non-gregorian start year.  Use era year also in default date entries,
	if so.
@
text
@a362 1
  DWORD cal;
a401 11
	/* Check for default calender with offset to gregorian calendar.
	   If so, make era representation the default. */
	if (fc == L'y'
	    && GetLocaleInfoW (lcid, LOCALE_ICALENDARTYPE
				     | LOCALE_RETURN_NUMBER,
			       (PWCHAR) &cal, sizeof cal / sizeof (WCHAR))
	    && cal > CAL_GREGORIAN_US)
	  {
	    *p++ = 'E';
	    idx = 2;
	  }
d495 23
d534 2
d537 9
a545 1
  _time_locale->X_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
d547 9
a555 1
  _time_locale->x_fmt = eval_datetimefmt (LOCALE_SSHORTDATE, DT_DEFAULT);
d557 14
a570 4
  _time_locale->c_fmt = eval_datetimefmt (LOCALE_SLONGDATE, DT_ABBREV);
  --lc_time_ptr;
  *lc_time_ptr++ = ' ';
  eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
d575 16
a590 6
  _time_locale->date_fmt = eval_datetimefmt (LOCALE_SLONGDATE, DT_ABBREV);
  --lc_time_ptr;
  *lc_time_ptr++ = ' ';
  eval_datetimefmt (LOCALE_STIMEFORMAT, DT_DEFAULT);
  --lc_time_ptr;
  lc_time_ptr = stpcpy (lc_time_ptr, " %Z") + 1;
d598 1
a598 11
  _time_locale->ampm_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, DT_AMPM);

  /* TODO */
  char locale[ENCODING_LEN + 1];
  char *c, *c2;

  strcpy (locale, name);
  /* Removes the charset from the locale and attach the modifer to the
     language_TERRITORY part. */
  c = strchr (locale, '.');
  if (c)
d600 4
a603 6
      *c = '\0';
      c2 = strchr (c + 1, '@@');
      /* Ignore @@cjknarrow modifier since it's a very personal thing between
	 Cygwin and newlib... */
      if (c2 && strcmp (c2, "@@cjknarrow"))
      	memmove (c, c2, strlen (c2) + 1);
d605 4
a608 7
  /* Now search in the alphabetically order lc_era array for the
     locale. */
  lc_era_t locale_key = { locale, NULL, NULL, NULL, NULL, NULL };
  lc_era_t *res = (lc_era_t *) bsearch ((void *) &locale_key, (void *) lc_era,
					sizeof lc_era / sizeof *lc_era,
					sizeof *lc_era, locale_cmp);
  if (res)
d612 6
a617 6
      size_t len = 0;
      len += lc_wcstombs (f_wctomb, charset, NULL, res->era, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, res->era_d_fmt, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, res->era_d_t_fmt, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, res->era_t_fmt, 0) + 1;
      len += lc_wcstombs (f_wctomb, charset, NULL, res->alt_digits, 0) + 1;
d625 1
a625 1
	    res = NULL;
d634 1
a634 1
      if (res)
d638 1
a638 1
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, res->era,
d642 1
a642 1
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, res->era_d_fmt,
d646 1
a646 1
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, res->era_d_t_fmt,
d650 1
a650 1
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, res->era_t_fmt,
d654 1
a654 1
	  len = lc_wcstombs (f_wctomb, charset, lc_time_ptr, res->alt_digits,
d659 1
a659 1
  if (!res)
d854 1
a854 1
  lc_msg_t *res = (lc_msg_t *) bsearch ((void *) &locale_key, (void *) lc_msg,
d857 1
a857 1
  if (!res)
d863 4
a866 4
  len += lc_wcstombs (f_wctomb, charset, NULL, res->yesexpr, 0) + 1;
  len += lc_wcstombs (f_wctomb, charset, NULL, res->noexpr, 0) + 1;
  len += lc_wcstombs (f_wctomb, charset, NULL, res->yesstr, 0) + 1;
  len += lc_wcstombs (f_wctomb, charset, NULL, res->nostr, 0) + 1;
d876 1
a876 1
  len = lc_wcstombs (f_wctomb, charset, c, res->yesexpr, lc_messages_end - c);
d878 1
a878 1
  len = lc_wcstombs (f_wctomb, charset, c, res->noexpr, lc_messages_end - c);
d880 1
a880 1
  len = lc_wcstombs (f_wctomb, charset, c, res->yesstr, lc_messages_end - c);
d882 1
a882 1
  lc_wcstombs (f_wctomb, charset, c, res->nostr, lc_messages_end - c);
@


1.24
log
@	* lc_era.h: New file.
	* nlsfuncs.cc: Include lc_era.h.
	(locale_cmp): convert arguments to char** to be usable for both types,
	lc_msg_t and lc_era_t.
	(__set_lc_time_from_win): Handle era-related data
@
text
@a353 3
  DT_ERACAL	= 0x04,	/* Retrieve era information (ignored otherwise).
			   Also switch to optional calendar with era
			   information, if necessary. */
d363 1
d403 11
@


1.23
log
@	* nlsfuncs.cc (eval_datetimefmt): Rename force to flags.
	(enum dt_flags): Define.
	(__eval_datetimefmt): Change force to flags and change type to
	dt_flags.  Accommodate throughout.
	(__set_lc_time_from_win): Accommodate above change.  Set era-related
	values to empty strings for now.
@
text
@d28 1
d320 8
d543 2
d546 81
a626 15
  /* era */
  _time_locale->era = lc_time_ptr;
  *lc_time_ptr++ = '\0';
  /* era_d_fmt */
  _time_locale->era_d_fmt = lc_time_ptr;
  *lc_time_ptr++ = '\0';
  /* era_d_t_fmt */
  _time_locale->era_d_t_fmt = lc_time_ptr;
  *lc_time_ptr++ = '\0';
  /* era_t_fmt */
  _time_locale->era_t_fmt = lc_time_ptr;
  *lc_time_ptr++ = '\0';
  /* alt_digits */
  _time_locale->alt_digits = lc_time_ptr;
  *lc_time_ptr++ = '\0';
a781 8
static int
locale_cmp (const void *a, const void *b)
{
  struct lc_msg_t *la = (struct lc_msg_t *) a;
  struct lc_msg_t *lb = (struct lc_msg_t *) b;
  return strcmp (la->locale, lb->locale);
}

@


1.22
log
@	* nlsfuncs.cc (initial_setlocale): Move check whether charset has
	changed from here...
	(internal_setlocale): ...to here, to avoid unnecessary work when invoked
	via CW_INT_SETLOCALE.
@
text
@d33 2
a34 2
#define eval_datetimefmt(type,force) \
	    __eval_datetimefmt(lcid,(type),(force),&lc_time_ptr,\
d341 9
d351 1
a351 1
__eval_datetimefmt (LCID lcid, LCTYPE type, int force, char **ptr,
d390 2
a391 4
	if (fc == L'y')
	  force = 0;
	for (idx = 1; fmt[1] == fc; ++idx, ++fmt);
	if (--idx > 3)
d393 1
a393 1
	if (force && idx == 3)
d399 1
d403 1
a403 1
	t_str = (fc == L'h' || force ? hour12_str : hour24_str);
d506 1
a506 1
  _time_locale->X_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, 0);
d508 1
a508 1
  _time_locale->x_fmt = eval_datetimefmt (LOCALE_SSHORTDATE, 0);
d510 1
a510 1
  _time_locale->c_fmt = eval_datetimefmt (LOCALE_SLONGDATE, 1);
d513 1
a513 1
  eval_datetimefmt (LOCALE_STIMEFORMAT, 0);
d518 1
a518 1
  _time_locale->date_fmt = eval_datetimefmt (LOCALE_SLONGDATE, 1);
d521 1
a521 1
  eval_datetimefmt (LOCALE_STIMEFORMAT, 0);
d531 19
a549 1
  _time_locale->ampm_fmt = eval_datetimefmt (LOCALE_STIMEFORMAT, 1);
@


1.21
log
@	* nlsfuncs.cc (__set_charset_from_locale): Allow "@@euro" modifier only
	for locales which use EUR as currency.
@
text
@d1132 1
a1132 1
  char *path = getenv ("PATH");
d1135 4
d1142 1
d1183 1
a1183 2
  if (ret && check_codepage (ret)
      && strcmp (cygheap->locale.charset, __locale_charset ()) != 0)
@


1.20
log
@	* nlsfuncs.cc (__get_lcid_from_locale): Convert iu_CA to iu-Latn-CA
	rather than iu-Cans-CA on Vista and later.
	(__set_charset_from_locale): Set default charset for iu_CA to UTF-8.
@
text
@d882 1
d971 3
a973 1
	       || has_modifier ("@@euro"))
@


1.19
log
@	* nlsfuncs.cc (lc_wcstombs): Add `return_invalid' flag to specify
	whether invalid chars should be ignored or not.  Change comment.
	(__set_lc_monetary_from_win): Call lc_wcstombs with return_invalid
	flag set.
	(__set_lc_messages_from_win): Simplify to accommodate the fact that
	lc_wcstombs just ignores invalid chars.  Explain why.
@
text
@d104 1
a104 1
	    { "iu-CA" , L"iu-Cans-CA"  },
d964 2
a965 1
	       || lcid == 0x046a)	/* yo_NG (Yoruba/Nigeria) */
@


1.18
log
@	* nlsfuncs.cc (__set_lc_messages_from_win): Fix typo.
@
text
@d232 3
a234 3
/* Never returns -1, *iff* s is not NULL.  Just skips invalid chars
   instead.  s==NULL returns -1 since it's used to recognize invalid
   strings in the used charset. */
d237 2
a238 1
	     char *s, const wchar_t *pwcs, size_t n)
d253 3
a255 1
	  if (bytes == (size_t) -1)
a256 1
	  num_bytes += bytes;
d615 1
a615 1
    if (lc_wcstombs (f_wctomb, charset, NULL, wbuf, 0) == (size_t) -1)
d722 7
a728 14
  /* Evaluate string length in target charset. */
  size_t len, total = 0;
  total += (len = lc_wcstombs (f_wctomb, charset, NULL, res->yesexpr, 0)) + 1;
  if (len == (size_t) -1)
    return -1;
  total += (len = lc_wcstombs (f_wctomb, charset, NULL, res->noexpr, 0)) + 1;
  if (len == (size_t) -1)
    return -1;
  total += (len = lc_wcstombs (f_wctomb, charset, NULL, res->yesstr, 0)) + 1;
  if (len == (size_t) -1)
    return -1;
  total += (len = lc_wcstombs (f_wctomb, charset, NULL, res->nostr, 0)) + 1;
  if (len == (size_t) -1)
    return -1;
d730 2
a731 2
  char *new_lc_messages_buf = (char *) malloc (total);
  const char *lc_messages_end = new_lc_messages_buf + total;
@


1.17
log
@	* lc_msg.h: New file, autogenerated from CLDR data.
	* nlsfuncs.cc: Include lc_msg.h.
	(lc_time_buf): Remove.
	(lc_numeric_buf): Remove.
	(lc_monetary_buf): Remove.
	(lc_mbstowcs): Fix previous fix.
	(__set_lc_time_from_win): Take additional pointer to buffer pointer,
	defined in newlib.
	(__set_lc_numeric_from_win): Ditto.
	(__set_lc_monetary_from_win): Ditto.
	(locale_cmp): New static function.
	(__set_lc_messages_from_win): New function to be called from newlib.
@
text
@d708 1
a708 1
      if (c2 && !strcmp (c2, "@@cjknarrow"))
@


1.16
log
@	Now *really* check in what should have been checked in 12 hours ago.
@
text
@d26 2
a27 4

static char *lc_time_buf;
static char *lc_numeric_buf;
static char *lc_monetary_buf;
d296 1
a296 1
			charset, &state);
d466 2
a467 1
			wctomb_p f_wctomb, const char *charset)
d529 3
a531 3
  if (lc_time_buf)
    free (lc_time_buf);
  lc_time_buf = tmp;
d542 2
a543 1
			   wctomb_p f_wctomb, const char *charset)
d572 3
a574 3
  if (lc_numeric_buf)
    free (lc_numeric_buf);
  lc_numeric_buf = tmp;
d585 2
a586 1
			    wctomb_p f_wctomb, const char *charset)
d671 83
a753 3
  if (lc_monetary_buf)
    free (lc_monetary_buf);
  lc_monetary_buf = tmp;
@


1.15
log
@	This patch got lost in the previous checkin, accidentally:
	* nlsfuncs.cc (lc_mbstowcs): Fix call to f_mbtowc.
@
text
@d297 2
a298 1
      bytes = f_mbtowc (_REENT, pwcs, t, n, charset, &state);
d960 1
d972 4
d1039 3
a1041 1
static void
@


1.14
log
@	* nlsfuncs.cc (__get_lcid_from_locale): Handle "@@cyrillic" modifier
	for uz_UZ locale here.
	(__set_charset_from_locale): Accommodate above change.
@
text
@d297 1
a297 1
      bytes = f_mbtowc (_REENT, pwcs, t, MB_CUR_MAX, charset, &state);
@


1.13
log
@	* nlsfuncs.cc (__set_locale_from_locale_alias): New function to read
	locale aliases from /usr/share/locale/locale.alias.
@
text
@d135 6
d223 6
d859 1
a859 1
	  || lcid == 0x0450		/* mn_MN (Mongolian/Mongolia) */
d862 2
a863 1
	  || (lcid == 0x0444 && has_modifier ("@@iqtelif")))	
d904 1
a904 1
	cs = has_modifier ("@@cyrillic") ? "UTF-8" : "ISO-8859-1";
@


1.12
log
@	* nlsfuncs.cc (__get_lcid_from_locale): Handle no_NO as nb_NO, rather
	than nn_NO.
@
text
@d13 1
d929 62
@


1.11
log
@	* nlsfuncs.cc (has_modifier): MOve up in file to use in
	__get_lcid_from_locale as well.
	(__get_lcid_from_locale): Handle no_NO locale as alias for nn_NO.
	Default all sr_XY locales to Cyrillic script.  Change lcid to Latin
	script if "@@latin" modifier has been specified.
	(__set_charset_from_locale): Handle Serbian in codepage 1251 case as
	well.  Also check for sr_BA lcid.  Restrict "@@euro" modifier to
	locales otherwise defaulting to ISO-8859-1.
@
text
@d97 1
a97 2
	     Linux also supports the no_NO locale which is equivalent to
	     nn_NO. */
d107 1
a107 1
	    { "no-NO" , L"nn-NO"       },
d183 2
a184 1
	 same LCID as the newer sr_CS. */
d191 1
a191 1
        { "no_NO", MAKELANGID (LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK)   },
@


1.10
log
@	* nlsfuncs.cc (__set_charset_from_locale): Set default charset for
	"ka_GE" locale to GEORGIAN-PS, for "kk_KZ" to PT154.
@
text
@d38 2
d70 2
d96 3
a98 1
	     without a Script part per RFC 4646 exists. */
d108 5
a112 4
	    { "sr-BA" , L"sr-Latn-BA"  },
	    { "sr-CS" , L"sr-Latn-CS"  },
	    { "sr-ME" , L"sr-Latn-ME"  },
	    { "sr-RS" , L"sr-Latn-RS"  },
d123 12
a134 4
		/* Vista/2K8 is missing sr-ME and sr-RS.  It has only the
		   deprecated sr-CS.  So we map ME and RS to CS here. */
		if (lcid == 0 && !strncmp (locale, "sr-", 3))
		  lcid = LocaleNameToLCID (L"sr-Latn-CS", 0);
d189 3
a191 2
	{ "bs_BA", MAKELANGID (LANG_BOSNIAN, 0x05)			  },
        { "nn_NO", MAKELANGID (LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK) },
d193 5
a197 5
			       SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN)  },
	{ "sr_CS", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_LATIN)       },
	{ "sr_ME", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_LATIN)       },
	{ "sr_RS", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_LATIN)       },
	{ "sr_SP", MAKELANGID (LANG_SERBIAN, SUBLANG_SERBIAN_LATIN)       },
d208 5
a783 2
#define has_modifier(x)	((x)[0] && !strcmp (modifier, (x)))

d827 3
a830 1
	  || lcid == 0x241a		/* sr_RS (Serbian Language/Serbia) */
a832 2
      else if (has_modifier ("@@euro"))
	cs = "ISO-8859-15";
d839 7
a845 1
      if (lcid == 0x0440		/* ky_KG (Kyrgyz/Kyrgyzstan) */
a856 2
      else if (has_modifier ("@@euro"))
	cs = "ISO-8859-15";
d884 1
a884 1
      cs = has_modifier ("@@euro") ? "ISO-8859-15" : "ISO-8859-7";
d892 1
a892 1
	cs = has_modifier ("@@euro") ? "ISO-8859-15" : "ISO-8859-9";
d895 1
a895 1
      cs = has_modifier ("@@euro") ? "ISO-8859-15" : "ISO-8859-8";
@


1.9
log
@	* nlsfuncs.cc (__set_charset_from_locale): Set default locale for
	"uz_UZ" locale to ISO-8859-1, with the "@@cyrillic" modifier to UTF-8.
@
text
@d894 4
@


1.8
log
@	Replace regex files with multibyte-aware version from FreeBSD.
	* Makefile.in (install-headers): Remove extra command to install
	regex.h.
	(uninstall-headers): Remove extra command to uninstall regex.h.
	* nlsfuncs.cc (collate_lcid): Make externally available to allow
	access to collation internals from regex functions.
	(collate_charset): Ditto.
	* wchar.h: Add __cplusplus guards to make C-clean.
	* include/regex.h: New file, replacing regex/regex.h.  Remove UCB
	advertising clause.
	* regex/COPYRIGHT: Accommodate BSD license.  Remove UCB advertising
	clause.
	* regex/cclass.h: Remove.
	* regex/cname.h: New file from FreeBSD.
	* regex/engine.c: Ditto.
	(NONCHAR): Tweak for Cygwin.
	* regex/engine.ih: Remove.
	* regex/mkh: Remove.
	* regex/regcomp.c: New file from FreeBSD.  Tweak slightly for Cygwin.
	Import required collate internals from nlsfunc.cc.
	(p_ere_exp): Add GNU-specific \< and \> handling for word boundaries.
	(p_simp_re): Ditto.
	(__collate_range_cmp): Define.
	(p_b_term): Use Cygwin-specific collate internals.
	(findmust): Ditto.
	* regex/regcomp.ih: Remove.
	* regex/regerror.c: New file from FreeBSD.  Fix a few compiler warnings.
	* regex/regerror.ih: Remove.
	* regex/regex.7: New file from FreeBSD.  Remove UCB advertising clause.
	* regex/regex.h: Remove.  Replaced by include/regex.h.
	* regex/regexec.c: New file from FreeBSD.  Fix a few compiler warnings.
	* regex/regfree.c: New file from FreeBSD.
	* regex/tests: Remove.
	* regex/utils.h: New file from FreeBSD.
@
text
@d864 1
a864 2
      if (lcid == 0x042c		/* az_AZ (Azeri/Azerbaijan) */
	  || lcid == 0x0443)		/* uz_UZ (Uzbek/Uzbekistan) */
d866 2
@


1.7
log
@	* nlsfuncs.cc (__get_lcid_from_locale): Add comments.  Fix typos in
	comments.  Make sure to set last_lcid every time.  Return locale
	without territory part as invalid.  Handle modern serbian territory
	names per ISO 3166 on older systems as well.  Add appropriate comment.
	(__set_charset_from_locale): Handle LCID for sr_CS as well to make older
	systems happy.
@
text
@d641 1
a641 1
static LCID collate_lcid = 0;
d643 1
a643 1
static char collate_charset[ENCODING_LEN + 1] = "ASCII";
@


1.6
log
@	* nlsfuncs.cc (__set_charset_from_locale): Rearrange to set charset
	more closely aligned to Glibc.
@
text
@d60 1
d76 1
a76 1
    return 0;
d78 2
d86 1
a86 2
      if (c)
	*c = '-';
d102 1
d104 1
a104 1
	    { "sr-BA" , L"sr-Latn-BA"  },
a105 1
	    { "sr-ME" , L"sr-Latn-ME"  },
d116 4
d129 1
a129 2
  if (c)
    *c++ = '\0';
d162 8
a169 4
      /* Unfortunately there are a four language LCID number areas
         representing multiple languages.  Fortunately onle two of them
	 already existed pre-Vista.  The concealed languages have to be
	 tested explicitly, since they are not catched by the above loops. */
d178 3
d806 3
a808 1
      if (lcid == 0x2c1a		/* sr_ME (Serbian Language/Montenegro) */
@


1.5
log
@	* nlsfuncs.cc (__get_lcid_from_locale):  Fix a comment.  Handle special
	language/TERRITORY combinations explicitely.  Explain why.
@
text
@d751 2
d764 4
a767 7
    {
      __small_sprintf (charset, "ASCII");
      return;
    }
  if (!GetLocaleInfoW (lcid,
		       LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
		       (PWCHAR) &cp, sizeof cp))
d769 4
a772 1
  /* codepage to de-facto standard charset transition. */
d775 3
d779 1
a779 1
      __small_sprintf (charset, "CP%u", cp);
d782 1
a782 1
      strcpy (charset, "EUCJP");
d785 1
a785 1
      strcpy (charset, "GBK");
d788 1
a788 1
      strcpy (charset, "EUCKR");
d791 1
a791 1
      strcpy (charset, "BIG5");
d794 10
a803 1
      strcpy (charset, "ISO-8859-2");
d806 16
a821 1
      strcpy (charset, "ISO-8859-5");
d824 21
a844 1
      strcpy (charset, "ISO-8859-1");
d847 1
a847 1
      strcpy (charset, "ISO-8859-7");
d850 5
a854 1
      strcpy (charset, "ISO-8859-9");
d857 1
a857 1
      strcpy (charset, "ISO-8859-8");
d860 6
a865 1
      strcpy (charset, "ISO-8859-6");
d868 4
a871 1
      strcpy (charset, "ISO-8859-13");
d875 6
a880 1
      strcpy (charset, "UTF-8");
d883 1
a883 6
  if (cp >= 1250 && cp <= 1257)
    {
      char *c = strchr (locale, '@@');
      if (c && !strcmp (c + 1, "euro"))
      	strcpy (charset, "ISO-8859-15");
    }
@


1.4
log
@	* nlsfuncs.cc (__set_charset_from_locale): Fix comment.
@
text
@a75 1
  /* Convert to form understood by LocaleNameToLCID */
a76 2
  if (c)
    *c = '-';
d80 5
d87 30
d155 28
@


1.3
log
@	* nlsfuncs.cc (check_codepage): Move from syscalls.cc here.
	(internal_setlocale): Ditto.
	(initial_setlocale): Ditto.
	(setlocale): Ditto.
	* strfuncs.cc (__sjis_wctomb): Revert previous patch.
	(__sjis_mbtowc): Ditto.
	* syscalls.cc: Move setlocale-related functions to nlsfuncs.cc.
@
text
@d693 1
a693 3
   charset isn't given explicitely in the POSIX compatible locale specifier.
   The function also returns a pointer to the corresponding _mbtowc_r function
   which is used subsequently. */
@


1.2
log
@	* nlsfuncs.cc (wcsxfrm): Call LCMapStringW with LCMAP_BYTEREV flag to
	allow correct comparison using wcscmp.
@
text
@d12 1
d14 1
a14 1
#include <winnls.h>
d766 107
@


1.1
log
@	* Makefile.in (DLL_OFILES): Add nlsfunc.o and strfmon.o.
	* autoload.cc (LocaleNameToLCID): Define.
	* cygwin.din (strfmon): Export.
	* nlsfuncs.cc: New file.  Define a lot of internal functions called
	from setlocale.
	(wcscoll): Implement locale-aware here, using CompareStringW function.
	(strcoll): Ditto.
	(wcsxfrm): Implement locale-aware here, usingLCMapStringW function.
	(strxfrm): Ditto.
	(__set_charset_from_locale): Replace __set_charset_from_codepage.
	Return Linux-compatible charset.
	* strfuncs.cc (__set_charset_from_codepage): Remove.
	* wchar.h (__set_charset_from_codepage): Drop definition.
	* wincap.h (wincaps::has_localenames): New element.
	* wincap.cc: Implement above element throughout.
	* libc/strfmon.c: New file.
	* libc/strptime.cc: Remove locale constant strings in favor of
	access to locale-specifc data.
	(strptime): Point _CurrentTimeLocale to locale-specific data.
	Throughout use correct locale-specific format fields for all
	locale-specific formats.
	* include/monetary.h: New file.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d640 1
a640 1
  ret = LCMapStringW (collate_lcid, LCMAP_SORTKEY,
@

