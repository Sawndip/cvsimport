head	1.331;
access;
symbols
	cygwin-1_7_35-release:1.331
	cygwin-1_7_34-release:1.331
	cygwin-1_7_33-release:1.328.2.2
	cygwin-1_7_32-release:1.328.2.2
	cygwin-1_7_31-release:1.328.2.2
	cygwin-1_7_30-release:1.328.2.1
	cygwin-1_7_29-release:1.328.2.1
	cygwin-1_7_29-release-branchpoint:1.328.0.2
	cygwin-pre-user-db:1.328
	cygwin-1_7_28-release:1.328
	cygwin-1_7_27-release:1.325
	cygwin-1_7_26-release:1.325
	cygwin-1_7_25-release:1.325
	cygwin-1_7_24-release:1.325
	cygwin-1_7_23-release:1.325
	cygwin-1_7_22-release:1.325
	cygwin-1_7_21-release:1.325
	cygwin-1_7_20-release:1.325
	cygwin-1_7_19-release:1.325
	cygwin-64bit-postmerge:1.322
	cygwin-64bit-premerge-branch:1.321.0.2
	cygwin-64bit-premerge:1.321
	cygwin-1_7_18-release:1.321
	post-ptmalloc3:1.309.2.14
	pre-ptmalloc3:1.309.2.13
	cygwin-1_7_17-release:1.315
	cygwin-64bit-branch:1.309.0.2
	cygwin-1_7_16-release:1.309
	cygwin-1_7_15-release:1.307
	cygwin-1_7_14_2-release:1.305
	cygwin-1_7_14-release:1.305
	cygwin-1_7_12-release:1.305
	cygwin-1_7_11-release:1.297
	cygwin-1_7_10-release:1.295
	signal-rewrite:1.279.0.2
	pre-notty:1.276
	cygwin-1_7_9-release:1.266
	cv-post-1_7_9:1.266.0.2
	cygwin-1_7_8-release:1.266
	cygwin-1_7_7-release:1.261
	cygwin-1_7_5-release:1.260
	cygwin-1_7_4-release:1.260
	cygwin-1_7_3-release:1.260
	cygwin-1_7_2-release:1.260
	fifo_doover3:1.258.0.2
	cygwin-1_7_1-release:1.257
	prefifo:1.253
	cv-branch-2:1.252.0.2
	pre-ripout-set_console_state_for_spawn:1.247
	EOL_registry_mounts:1.245
	preoverlapped:1.237
	drop_9x_support_start:1.236
	cr-0x5f1:1.232.0.2
	cv-branch:1.231.0.2
	pre-ptymaster-archetype:1.230
	cr-0x3b58:1.221.0.4
	cr-0x5ef:1.221.0.2
	after-mmap-privanon-noreserve:1.209
	after-mmap-revamp:1.209
	before-mmap-revamp:1.209
	cgf-more-exit-sync:1.202
	post_wait_sig_exit:1.192
	pre_wait_sig_exit:1.185
	reparent-point:1.121
	noreparent:1.121.0.2
	cr-0x5e6:1.114.0.2
	cr-0x9e:1.107.0.4
	cr-0x9d:1.107.0.2
	cgf-deleteme:1.105.0.2
	pre-sigrewrite:1.91
	corinna-01:1.90
	cr-0x9c:1.83.0.4
	cr-0x9b:1.83.0.2
	cr-0x99:1.82
	Z-emcb-cygwin_daemon:1.82.0.2
	w32api-2_2:1.76
	mingw-runtime-2_4:1.76
	pre-cgf-merge:1.87
	cgf-dev-branch:1.76.0.2
	predaemon:1.55
	cygwin_daemon_merge_HEAD:1.55
	pregp02r1:1.55.0.2
	cygnus_cvs_20020108_pre:1.52
	Z-cygwin_daemon_merge-new_HEAD:1.62
	Z-cygwin_daemon_merge_HEAD:1.62
	cygwin_daemon:1.48.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.331
date	2014.05.19.10.46.47;	author corinna;	state Exp;
branches;
next	1.330;

1.330
date	2014.02.15.04.17.27;	author cgf;	state Exp;
branches;
next	1.329;

1.329
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.328;

1.328
date	2013.12.18.17.44.20;	author cgf;	state Exp;
branches
	1.328.2.1;
next	1.327;

1.327
date	2013.12.18.04.28.46;	author cgf;	state Exp;
branches;
next	1.326;

1.326
date	2013.12.18.03.58.11;	author cgf;	state Exp;
branches;
next	1.325;

1.325
date	2013.05.24.13.43.26;	author corinna;	state Exp;
branches;
next	1.324;

1.324
date	2013.05.24.13.32.10;	author corinna;	state Exp;
branches;
next	1.323;

1.323
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.322;

1.322
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.321;

1.321
date	2013.03.29.16.19.11;	author cgf;	state Exp;
branches;
next	1.320;

1.320
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.319;

1.319
date	2013.01.14.17.16.02;	author corinna;	state Exp;
branches;
next	1.318;

1.318
date	2013.01.14.06.03.58;	author cgf;	state Exp;
branches;
next	1.317;

1.317
date	2012.12.21.18.52.00;	author cgf;	state Exp;
branches;
next	1.316;

1.316
date	2012.11.11.10.56.00;	author corinna;	state Exp;
branches;
next	1.315;

1.315
date	2012.10.09.15.12.07;	author cgf;	state Exp;
branches;
next	1.314;

1.314
date	2012.09.17.20.07.49;	author cgf;	state Exp;
branches;
next	1.313;

1.313
date	2012.08.26.17.20.30;	author cgf;	state Exp;
branches;
next	1.312;

1.312
date	2012.08.23.14.45.52;	author cgf;	state Exp;
branches;
next	1.311;

1.311
date	2012.08.16.23.34.44;	author cgf;	state Exp;
branches;
next	1.310;

1.310
date	2012.08.15.14.11.35;	author cgf;	state Exp;
branches;
next	1.309;

1.309
date	2012.07.02.19.55.51;	author cgf;	state Exp;
branches
	1.309.2.1;
next	1.308;

1.308
date	2012.05.30.14.37.53;	author corinna;	state Exp;
branches;
next	1.307;

1.307
date	2012.05.08.15.06.43;	author cgf;	state Exp;
branches;
next	1.306;

1.306
date	2012.05.07.15.05.56;	author cgf;	state Exp;
branches;
next	1.305;

1.305
date	2012.03.21.05.23.12;	author cgf;	state Exp;
branches;
next	1.304;

1.304
date	2012.03.21.04.45.57;	author cgf;	state Exp;
branches;
next	1.303;

1.303
date	2012.03.20.15.07.30;	author cgf;	state Exp;
branches;
next	1.302;

1.302
date	2012.03.20.02.07.53;	author cgf;	state Exp;
branches;
next	1.301;

1.301
date	2012.03.19.16.51.30;	author cgf;	state Exp;
branches;
next	1.300;

1.300
date	2012.03.16.20.20.27;	author cgf;	state Exp;
branches;
next	1.299;

1.299
date	2012.03.07.17.09.37;	author cgf;	state Exp;
branches;
next	1.298;

1.298
date	2012.03.05.12.12.10;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2012.02.14.19.08.19;	author cgf;	state Exp;
branches;
next	1.296;

1.296
date	2012.02.07.16.54.14;	author cgf;	state Exp;
branches;
next	1.295;

1.295
date	2012.01.11.19.07.10;	author cgf;	state Exp;
branches;
next	1.294;

1.294
date	2012.01.08.06.24.17;	author cgf;	state Exp;
branches;
next	1.293;

1.293
date	2011.12.23.17.12.10;	author corinna;	state Exp;
branches;
next	1.292;

1.292
date	2011.12.22.11.02.34;	author corinna;	state Exp;
branches;
next	1.291;

1.291
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2011.11.28.16.00.07;	author corinna;	state Exp;
branches;
next	1.289;

1.289
date	2011.11.26.02.35.49;	author cgf;	state Exp;
branches;
next	1.288;

1.288
date	2011.11.24.21.36.52;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2011.11.14.18.22.46;	author cgf;	state Exp;
branches;
next	1.286;

1.286
date	2011.11.14.01.29.48;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2011.11.07.20.05.48;	author cgf;	state Exp;
branches;
next	1.284;

1.284
date	2011.11.05.18.47.39;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2011.11.05.18.29.51;	author cgf;	state Exp;
branches;
next	1.282;

1.282
date	2011.10.26.19.42.39;	author cgf;	state Exp;
branches;
next	1.281;

1.281
date	2011.10.22.16.26.29;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2011.10.15.22.37.30;	author cgf;	state Exp;
branches;
next	1.279;

1.279
date	2011.08.13.10.28.15;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2011.08.11.07.28.42;	author corinna;	state Exp;
branches;
next	1.277;

1.277
date	2011.06.16.23.00.00;	author cgf;	state Exp;
branches;
next	1.276;

1.276
date	2011.06.04.00.29.19;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2011.06.04.00.12.29;	author cgf;	state Exp;
branches;
next	1.274;

1.274
date	2011.05.28.18.17.09;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.272;

1.272
date	2011.05.05.15.03.54;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2011.05.05.14.46.14;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2011.04.28.15.54.47;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2011.04.28.09.30.36;	author corinna;	state Exp;
branches;
next	1.268;

1.268
date	2011.04.18.11.26.37;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2011.04.17.19.56.25;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2010.12.12.05.48.29;	author cgf;	state Exp;
branches;
next	1.265;

1.265
date	2010.10.23.18.57.43;	author cgf;	state Exp;
branches;
next	1.264;

1.264
date	2010.10.23.18.55.01;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2010.09.01.21.06.36;	author cgf;	state Exp;
branches;
next	1.262;

1.262
date	2010.09.01.18.24.10;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2010.05.18.14.30.51;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2010.03.09.21.26.55;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.257;

1.257
date	2009.10.14.04.17.05;	author ericb;	state Exp;
branches;
next	1.256;

1.256
date	2009.10.07.15.47.38;	author cwilson;	state Exp;
branches;
next	1.255;

1.255
date	2009.10.06.21.51.17;	author cwilson;	state Exp;
branches;
next	1.254;

1.254
date	2009.10.06.03.39.38;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2009.07.12.21.15.47;	author cgf;	state Exp;
branches;
next	1.252;

1.252
date	2009.01.26.13.42.37;	author corinna;	state Exp;
branches;
next	1.251;

1.251
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2008.12.31.21.33.34;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2008.12.20.17.32.31;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2008.12.19.19.09.49;	author cgf;	state Exp;
branches;
next	1.247;

1.247
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.246;

1.246
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.245;

1.245
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2008.03.27.01.50.40;	author cgf;	state Exp;
branches;
next	1.243;

1.243
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2007.12.06.18.24.06;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2007.07.19.08.36.32;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2007.07.07.17.00.33;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2006.12.18.21.28.31;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2006.11.30.10.17.24;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2006.08.10.20.25.54;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2006.07.19.16.00.28;	author corinna;	state Exp;
branches
	1.232.2.1;
next	1.231;

1.231
date	2006.06.03.20.32.07;	author cgf;	state Exp;
branches
	1.231.2.1;
next	1.230;

1.230
date	2006.05.22.04.50.54;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2006.03.23.23.58.52;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2006.03.21.01.37.25;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2006.03.20.01.59.23;	author cgf;	state Exp;
branches;
next	1.226;

1.226
date	2006.03.18.19.17.21;	author cgf;	state Exp;
branches;
next	1.225;

1.225
date	2006.02.11.04.53.14;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2006.02.11.00.07.43;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2006.02.11.00.06.50;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2006.02.06.18.24.06;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2006.01.02.13.01.42;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2006.01.02.03.14.56;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2005.12.29.20.46.34;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2005.12.26.19.34.59;	author cgf;	state Exp;
branches;
next	1.217;

1.217
date	2005.12.23.22.50.20;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2005.12.22.05.26.14;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2005.12.22.05.11.44;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2005.12.22.03.16.36;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2005.12.21.19.39.53;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2005.12.13.00.54.32;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2005.12.12.18.43.30;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2005.11.24.02.34.31;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2005.11.17.16.36.00;	author cgf;	state Exp;
branches;
next	1.207;

1.207
date	2005.11.14.05.36.16;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2005.10.24.15.42.14;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2005.10.19.14.19.37;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2005.10.03.17.23.54;	author cgf;	state Exp;
branches;
next	1.201;

1.201
date	2005.10.02.00.13.41;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2005.09.30.23.52.13;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2005.09.28.22.56.42;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2005.09.28.19.22.23;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2005.09.28.19.02.51;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2005.09.28.13.55.04;	author cgf;	state Exp;
branches;
next	1.195;

1.195
date	2005.09.26.13.47.27;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2005.09.26.01.27.36;	author cgf;	state Exp;
branches;
next	1.193;

1.193
date	2005.09.23.23.37.52;	author cgf;	state Exp;
branches;
next	1.192;

1.192
date	2005.09.23.20.05.50;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2005.09.23.19.23.26;	author cgf;	state Exp;
branches;
next	1.190;

1.190
date	2005.09.23.03.35.41;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2005.09.22.21.10.07;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2005.09.20.02.06.57;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2005.09.14.14.00.04;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2005.09.13.17.08.54;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2005.09.05.17.30.04;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2005.09.02.17.35.22;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2005.09.02.17.12.36;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2005.09.02.04.51.09;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2005.09.02.04.46.51;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2005.08.24.17.45.11;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2005.08.24.04.38.39;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2005.08.06.23.00.05;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2005.07.29.14.33.50;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2005.07.29.14.25.28;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2005.07.05.03.16.45;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2005.06.07.19.31.39;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2005.05.02.03.50.08;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2005.04.28.23.59.44;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2005.04.22.13.58.08;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2005.04.17.00.12.14;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2005.04.03.08.45.19;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2005.03.08.14.31.21;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2005.03.08.05.05.02;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2005.02.27.04.30.08;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2005.02.26.20.50.25;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2005.02.13.18.17.29;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2005.02.11.15.24.15;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2005.02.07.05.28.49;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2005.02.06.11.15.28;	author corinna;	state Exp;
branches;
next	1.159;

1.159
date	2005.02.01.15.11.47;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2005.01.31.14.34.07;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2005.01.31.10.28.55;	author corinna;	state Exp;
branches;
next	1.156;

1.156
date	2005.01.29.11.23.07;	author corinna;	state Exp;
branches;
next	1.155;

1.155
date	2005.01.28.05.53.22;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2005.01.26.18.21.22;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2005.01.26.00.15.11;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2005.01.25.22.45.09;	author corinna;	state Exp;
branches;
next	1.151;

1.151
date	2005.01.22.21.47.04;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2005.01.22.21.17.53;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2005.01.22.18.07.10;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2005.01.17.04.12.08;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2005.01.16.17.00.27;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2005.01.13.22.18.57;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2005.01.13.16.38.35;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2005.01.12.18.05.07;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2005.01.11.16.58.31;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2005.01.11.15.31.03;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2005.01.06.16.36.40;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2005.01.04.14.57.42;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2004.12.28.06.07.45;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2004.12.28.01.27.26;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2004.12.27.17.19.25;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2004.12.27.02.13.30;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2004.12.27.00.35.19;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2004.12.26.02.10.30;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2004.12.24.18.31.23;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2004.12.23.14.57.07;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2004.12.22.18.12.30;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2004.12.22.16.59.03;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2004.12.06.19.20.24;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2004.12.06.00.29.38;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2004.12.05.21.29.37;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2004.12.05.19.41.24;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2004.12.03.04.46.00;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2004.12.03.02.49.54;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2004.11.26.04.15.08;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2004.10.05.02.10.15;	author cgf;	state Exp;
branches
	1.121.2.1;
next	1.120;

1.120
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2004.08.30.22.08.50;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2004.07.24.19.18.58;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2004.07.22.18.25.52;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2004.07.16.15.49.22;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2004.06.07.04.26.32;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2004.03.21.17.41.40;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2004.02.22.23.21.19;	author joshuadfranklin;	state Exp;
branches;
next	1.112;

1.112
date	2004.02.13.19.34.32;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2004.01.24.03.40.33;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches
	1.107.4.1;
next	1.106;

1.106
date	2004.01.11.18.52.50;	author joshuadfranklin;	state Exp;
branches;
next	1.105;

1.105
date	2004.01.03.20.57.11;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2003.12.30.01.57.16;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2003.12.27.17.41.17;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2003.12.27.02.20.07;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2003.12.27.01.59.29;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2003.12.16.23.28.03;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2003.12.11.06.19.36;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2003.12.11.06.12.41;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2003.12.09.03.27.05;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2003.12.03.16.35.52;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2003.12.02.04.10.56;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.90;

1.90
date	2003.09.27.02.30.46;	author phumblet;	state Exp;
branches;
next	1.89;

1.89
date	2003.09.27.01.58.23;	author phumblet;	state Exp;
branches;
next	1.88;

1.88
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2003.09.17.01.15.55;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2003.09.16.03.39.55;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2003.09.16.00.45.50;	author phumblet;	state Exp;
branches;
next	1.84;

1.84
date	2003.09.13.17.14.15;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2003.09.05.01.55.01;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2003.07.12.21.37.07;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2003.07.06.23.24.13;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.21.00.08.02;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2003.03.08.19.22.08;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2003.03.08.16.44.25;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2003.01.10.12.32.47;	author corinna;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2003.01.05.06.36.50;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2002.12.16.18.56.33;	author cgf;	state Exp;
branches
	1.74.4.1;
next	1.73;

1.73
date	2002.11.29.07.05.26;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.05.04.52.52;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.05.04.43.02;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2002.11.05.04.24.48;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2002.11.05.04.23.41;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2002.11.05.03.39.25;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2002.10.30.21.05.17;	author cgf;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2002.10.15.07.03.44;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2002.10.14.20.25.52;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2002.10.13.18.16.33;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.19.15.27.24;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.09.03.54.07;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.30.07.45.30;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.15.21.49.11;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.14.23.14.19;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.29.02.02.01;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2001.12.26.04.53.34;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.11.17.57.10;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.29.02.54.36;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.30.08.10.04;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.08.04.02.01;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.10.00.45.11;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.05.06.42.23;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.04.05.54.57;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.03.04.27.01;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.02.05.25.56;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.31.17.01.56;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.22.10.13.30;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.21.20.57.40;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.21.19.28.49;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.21.04.53.49;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.20.04.20.21;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.19.00.53.25;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.14.05.52.38;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.13.03.13.59;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.09.02.53.44;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.26.03.48.37;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.26.01.36.20;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.24.04.07.50;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.23.14.56.28;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.23.14.53.24;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.02.19.26.01;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.29.16.24.38;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.17.17.53.08;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.17.11.34.33;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.05.13.32;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.07.05.33.09;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.28.16.25.34;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.28.05.05.33;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.328.2.1
date	2014.02.19.18.44.45;	author cgf;	state Exp;
branches;
next	1.328.2.2;

1.328.2.2
date	2014.07.16.09.54.56;	author corinna;	state Exp;
branches;
next	;

1.309.2.1
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.309.2.2;

1.309.2.2
date	2012.10.16.15.18.39;	author corinna;	state Exp;
branches;
next	1.309.2.3;

1.309.2.3
date	2012.11.11.10.58.44;	author corinna;	state Exp;
branches;
next	1.309.2.4;

1.309.2.4
date	2012.11.12.17.26.23;	author corinna;	state Exp;
branches;
next	1.309.2.5;

1.309.2.5
date	2012.11.16.13.48.24;	author corinna;	state Exp;
branches;
next	1.309.2.6;

1.309.2.6
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.309.2.7;

1.309.2.7
date	2012.12.13.18.45.40;	author corinna;	state Exp;
branches;
next	1.309.2.8;

1.309.2.8
date	2013.01.09.16.27.21;	author corinna;	state Exp;
branches;
next	1.309.2.9;

1.309.2.9
date	2013.01.14.12.57.04;	author corinna;	state Exp;
branches;
next	1.309.2.10;

1.309.2.10
date	2013.01.14.17.16.30;	author corinna;	state Exp;
branches;
next	1.309.2.11;

1.309.2.11
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.309.2.12;

1.309.2.12
date	2013.02.09.20.29.35;	author corinna;	state Exp;
branches;
next	1.309.2.13;

1.309.2.13
date	2013.02.15.13.36.36;	author corinna;	state Exp;
branches;
next	1.309.2.14;

1.309.2.14
date	2013.02.27.08.36.58;	author corinna;	state Exp;
branches;
next	1.309.2.15;

1.309.2.15
date	2013.03.13.16.51.25;	author corinna;	state Exp;
branches;
next	1.309.2.16;

1.309.2.16
date	2013.03.29.16.42.35;	author corinna;	state Exp;
branches;
next	1.309.2.17;

1.309.2.17
date	2013.04.10.12.29.49;	author corinna;	state Exp;
branches;
next	1.309.2.18;

1.309.2.18
date	2013.04.23.09.06.12;	author corinna;	state Exp;
branches;
next	;

1.232.2.1
date	2006.08.11.09.02.58;	author corinna;	state Exp;
branches;
next	1.232.2.2;

1.232.2.2
date	2006.12.18.21.59.08;	author corinna;	state Exp;
branches;
next	1.232.2.3;

1.232.2.3
date	2006.12.18.22.04.20;	author corinna;	state Exp;
branches;
next	;

1.231.2.1
date	2006.07.19.16.00.29;	author corinna;	state Exp;
branches;
next	;

1.121.2.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	1.121.2.2;

1.121.2.2
date	2004.11.16.15.16.56;	author cgf;	state Exp;
branches;
next	1.121.2.3;

1.121.2.3
date	2004.11.18.00.48.40;	author cgf;	state Exp;
branches;
next	1.121.2.4;

1.121.2.4
date	2004.11.18.02.55.43;	author cgf;	state Exp;
branches;
next	1.121.2.5;

1.121.2.5
date	2004.11.20.02.56.34;	author cgf;	state Exp;
branches;
next	1.121.2.6;

1.121.2.6
date	2004.11.20.04.17.22;	author cgf;	state Exp;
branches;
next	1.121.2.7;

1.121.2.7
date	2004.11.20.05.28.31;	author cgf;	state Exp;
branches;
next	1.121.2.8;

1.121.2.8
date	2004.11.20.18.35.10;	author cgf;	state Exp;
branches;
next	1.121.2.9;

1.121.2.9
date	2004.11.21.04.39.13;	author cgf;	state Exp;
branches;
next	1.121.2.10;

1.121.2.10
date	2004.11.24.05.48.30;	author cgf;	state Exp;
branches;
next	;

1.107.4.1
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	1.107.4.2;

1.107.4.2
date	2004.01.24.03.41.29;	author cgf;	state Exp;
branches;
next	;

1.76.2.1
date	2003.01.16.01.27.31;	author cgf;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.76.2.3;

1.76.2.3
date	2003.03.09.16.22.58;	author cgf;	state Exp;
branches;
next	1.76.2.4;

1.76.2.4
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.76.2.5;

1.76.2.5
date	2003.07.10.01.06.23;	author cgf;	state Exp;
branches;
next	1.76.2.6;

1.76.2.6
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.76.2.7;

1.76.2.7
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.76.2.8;

1.76.2.8
date	2003.09.14.01.35.38;	author cgf;	state Exp;
branches;
next	;

1.74.4.1
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	1.74.4.2;

1.74.4.2
date	2003.01.05.06.48.55;	author cgf;	state Exp;
branches;
next	;

1.66.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.48.2.1
date	2001.10.02.12.09.55;	author rbcollins;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2002.01.04.03.56.10;	author rbcollins;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2002.02.28.12.53.26;	author rbcollins;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2002.06.13.14.34.09;	author rbcollins;	state Exp;
branches;
next	1.48.2.5;

1.48.2.5
date	2002.06.19.20.58.58;	author scottc;	state Exp;
branches;
next	1.48.2.6;

1.48.2.6
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.331
log
@	* pinfo.cc (pinfo_basic::pinfo_basic): Fix size of progname array in
	call to GetModuleFileNameW (CID 59935).
@
text
@/* pinfo.cc: process table support

   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <stdlib.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "sigproc.h"
#include "pinfo.h"
#include "perprocess.h"
#include "environ.h"
#include "ntdll.h"
#include "shared_info.h"
#include "cygheap.h"
#include "cygmalloc.h"
#include "cygtls.h"
#include "tls_pbuf.h"
#include "child_info.h"

class pinfo_basic: public _pinfo
{
public:
  pinfo_basic();
};

pinfo_basic::pinfo_basic ()
{
  pid = dwProcessId = GetCurrentProcessId ();
  GetModuleFileNameW (NULL, progname, sizeof (progname) / sizeof (WCHAR));
  /* Default uid/gid are needed very early to initialize shared user info. */
  uid = ILLEGAL_UID;
  gid = ILLEGAL_GID;
}

pinfo_basic myself_initial NO_COPY;

pinfo NO_COPY myself (static_cast<_pinfo *> (&myself_initial));	// Avoid myself != NULL checks

/* Setup the pinfo structure for this process.  There may already be a
   _pinfo for this "pid" if h != NULL. */

void
pinfo::thisproc (HANDLE h)
{
  procinfo = NULL;

  DWORD flags = PID_IN_USE | PID_ACTIVE;
  if (!h)
    {
      h = INVALID_HANDLE_VALUE;
      cygheap->pid = cygwin_pid (myself_initial.pid);
      flags |= PID_NEW;
    }

  init (cygheap->pid, flags, h);
  procinfo->process_state |= PID_IN_USE;
  procinfo->dwProcessId = myself_initial.pid;
  procinfo->sendsig = myself_initial.sendsig;
  wcscpy (procinfo->progname, myself_initial.progname);
  debug_printf ("myself dwProcessId %u", procinfo->dwProcessId);
  if (h != INVALID_HANDLE_VALUE)
    {
      /* here if execed */
      static pinfo NO_COPY myself_identity;
      myself_identity.init (cygwin_pid (procinfo->dwProcessId), PID_EXECED, NULL);
      procinfo->exec_sendsig = NULL;
      procinfo->exec_dwProcessId = 0;
      myself_identity->ppid = procinfo->pid;
    }
}

/* Initialize the process table entry for the current task.
   This is not called for forked tasks, only execed ones.  */
void __stdcall
pinfo_init (char **envp, int envc)
{
  if (envp)
    {
      environ_init (envp, envc);
      /* spawn has already set up a pid structure for us so we'll use that */
      myself->process_state |= PID_CYGPARENT;
    }
  else
    {
      /* Invent our own pid.  */

      myself.thisproc (NULL);
      myself->pgid = myself->sid = myself->pid;
      myself->ctty = -1;
      myself->uid = ILLEGAL_UID;
      myself->gid = ILLEGAL_GID;
      environ_init (NULL, 0);	/* call after myself has been set up */
      myself->nice = winprio_to_nice (GetPriorityClass (GetCurrentProcess ()));
      myself->ppid = 1;		/* always set last */
      debug_printf ("Set nice to %d", myself->nice);
    }

  myself->process_state |= PID_ACTIVE;
  myself->process_state &= ~(PID_INITIALIZING | PID_EXITED | PID_REAPED);
  myself.preserve ();
  debug_printf ("pid %d, pgid %d, process_state %y", myself->pid, myself->pgid, myself->process_state);
}

DWORD
pinfo::status_exit (DWORD x)
{
  switch (x)
    {
    case STATUS_DLL_NOT_FOUND:
      {
	char posix_prog[NT_MAX_PATH];
	path_conv pc;
	if (!procinfo)
	   pc.check ("/dev/null");
	else
	  {
	    UNICODE_STRING uc;
	    RtlInitUnicodeString(&uc, procinfo->progname);
	    pc.check (&uc, PC_NOWARN);
	  }
	mount_table->conv_to_posix_path (pc.get_win32 (), posix_prog, 1);
	small_printf ("%s: error while loading shared libraries: %s: cannot "
		      "open shared object file: No such file or directory\n",
		      posix_prog, find_first_notloaded_dll (pc));
	x = 127 << 8;
      }
      break;
    case STATUS_ILLEGAL_DLL_PSEUDO_RELOCATION: /* custom error value */
      /* We've already printed the error message in pseudo-reloc.c */
      x = 127 << 8;
      break;
    case STATUS_ACCESS_VIOLATION:
      x = SIGSEGV;
      break;
    case STATUS_ILLEGAL_INSTRUCTION:
      x = SIGILL;
      break;
    case STATUS_NO_MEMORY:
      /* If the PATH environment variable is longer than about 30K and the full
	 Windows environment is > 32K, startup of an exec'ed process fails with
	 STATUS_NO_MEMORY.  This happens with all Cygwin executables, as well
	 as, for instance, notepad, but it does not happen with CMD for some
	 reason (but note, the environment *in* CMD is broken and shortened).
	 This occurs at a point where there's no return to the exec'ing parent
	 process, so we have to find some way to inform the user what happened.
	 
	 FIXME: For now, just return with SIGBUS set.  Maybe it's better to add
	 a lengthy small_printf instead. */
      x = SIGBUS;
      break;
    default:
      debug_printf ("*** STATUS_%y\n", x);
      x = 127 << 8;
    }
  return EXITCODE_SET | x;
}

# define self (*this)
void
pinfo::set_exit_code (DWORD x)
{
  if (x >= 0xc0000000UL)
    self->exitcode = status_exit (x);
  else
    self->exitcode = EXITCODE_SET | (sigExeced ?: (x & 0xff) << 8);
}

void
pinfo::maybe_set_exit_code_from_windows ()
{
  DWORD x = 0xdeadbeef;
  DWORD oexitcode = self->exitcode;

  if (hProcess && !(self->exitcode & EXITCODE_SET))
    {
      WaitForSingleObject (hProcess, INFINITE);	/* just to be safe, in case
						   process hasn't quite exited
						   after closing pipe */
      GetExitCodeProcess (hProcess, &x);
      set_exit_code (x);
    }
  sigproc_printf ("pid %d, exit value - old %y, windows %y, cygwin %y",
		  self->pid, oexitcode, x, self->exitcode);
}

void
pinfo::exit (DWORD n)
{
  debug_only_printf ("winpid %d, exit %d", GetCurrentProcessId (), n);
  proc_terminate ();
  lock_process until_exit (true);
  cygthread::terminate ();

  if (n != EXITCODE_NOSET)
    self->exitcode = EXITCODE_SET | n;/* We're really exiting.  Record the UNIX exit code. */
  else
    maybe_set_exit_code_from_windows ();	/* may block */
  exit_state = ES_FINAL;

  if (myself->ctty > 0 && !iscons_dev (myself->ctty))
    {
      lock_ttys here;
      tty *t = cygwin_shared->tty[device::minor(myself->ctty)];
      if (!t->slave_alive ())
	t->setpgid (0);
    }

  /* FIXME:  There is a potential race between an execed process and its
     parent here.  I hated to add a mutex just for that, though.  */
  struct rusage r;
  fill_rusage (&r, GetCurrentProcess ());
  add_rusage (&self->rusage_self, &r);
  int exitcode = self->exitcode & 0xffff;
  if (!self->cygstarted)
    exitcode = ((exitcode & 0xff) << 8) | ((exitcode >> 8) & 0xff);
  sigproc_printf ("Calling ExitProcess n %y, exitcode %y", n, exitcode);
  if (!TerminateProcess (GetCurrentProcess (), exitcode))
    system_printf ("TerminateProcess failed, %E");
  ExitProcess (exitcode);
}
# undef self

inline void
pinfo::_pinfo_release ()
{
  if (procinfo)
    {
      void *unmap_procinfo = procinfo;
      procinfo = NULL;
      UnmapViewOfFile (unmap_procinfo);
    }
  HANDLE close_h;
  if (h)
    {
      close_h = h;
      h = NULL;
      ForceCloseHandle1 (close_h, pinfo_shared_handle);
    }
}

void
pinfo::init (pid_t n, DWORD flag, HANDLE h0)
{
  shared_locations shloc;
  h = NULL;
  if (myself && !(flag & PID_EXECED)
      && (n == myself->pid || (DWORD) n == myself->dwProcessId))
    {
      procinfo = myself;
      destroy = 0;
      return;
    }

  int createit = flag & (PID_IN_USE | PID_EXECED);
  DWORD access = FILE_MAP_READ
		 | (flag & (PID_IN_USE | PID_EXECED | PID_MAP_RW)
		    ? FILE_MAP_WRITE : 0);
  if (!h0 || myself.h)
    shloc = (flag & (PID_IN_USE | PID_EXECED)) ? SH_JUSTCREATE : SH_JUSTOPEN;
  else
    {
      shloc = SH_MYSELF;
      if (h0 == INVALID_HANDLE_VALUE)
	h0 = NULL;
    }

  procinfo = NULL;
  PSECURITY_ATTRIBUTES sa_buf = (PSECURITY_ATTRIBUTES) alloca (1024);
  PSECURITY_ATTRIBUTES sec_attribs = sec_user_nih (sa_buf, cygheap->user.sid(),
						   well_known_world_sid,
						   FILE_MAP_READ);

  for (int i = 0; i < 20; i++)
    {
      DWORD mapsize;
      if (flag & PID_EXECED)
	mapsize = PINFO_REDIR_SIZE;
      else
	mapsize = sizeof (_pinfo);

      procinfo = (_pinfo *) open_shared (L"cygpid", n, h0, mapsize, &shloc,
					 sec_attribs, access);
      if (!h0)
	{
	  if (createit)
	    __seterrno ();
	  return;
	}

      if (!procinfo)
	{
	  if (exit_state)
	    return;

	  if (GetLastError () == ERROR_INVALID_HANDLE)
	    api_fatal ("MapViewOfFileEx h0 %p, i %d failed, %E", h0, i);

	  debug_printf ("MapViewOfFileEx h0 %p, i %d failed, %E", h0, i);
	  yield ();
	  continue;
	}

      bool created = shloc != SH_JUSTOPEN;

      /* Detect situation where a transitional memory block is being retrieved.
	 If the block has been allocated with PINFO_REDIR_SIZE but not yet
	 updated with a PID_EXECED state then we'll retry.  */
      if (!created && !(flag & PID_NEW))
	/* If not populated, wait 2 seconds for procinfo to become populated.
	   Would like to wait with finer granularity but that is not easily
	   doable.  */
	for (int i = 0; i < 200 && !procinfo->ppid; i++)
	  Sleep (10);

      if (!created && createit && (procinfo->process_state & PID_REAPED))
	{
	  memset (procinfo, 0, sizeof (*procinfo));
	  created = true;	/* Lie that we created this - just reuse old
				   shared memory */
	}

      if ((procinfo->process_state & PID_REAPED)
	  || ((procinfo->process_state & PID_INITIALIZING) && (flag & PID_NOREDIR)
	      && cygwin_pid (procinfo->dwProcessId) != procinfo->pid))
	{
	  set_errno (ESRCH);
	  break;
	}

      if (procinfo->process_state & PID_EXECED)
	{
	  pid_t realpid = procinfo->pid;
	  debug_printf ("execed process windows pid %u, cygwin pid %d", n, realpid);
	  if (realpid == n)
	    api_fatal ("retrieval of execed process info for pid %d failed due to recursion.", n);

	  n = realpid;
	  CloseHandle (h0);
	  h0 = NULL;
	  goto loop;
	}

      /* In certain pathological cases, it is possible for the shared memory
	 region to exist for a while after a process has exited.  This should
	 only be a brief occurrence, so rather than introduce some kind of
	 locking mechanism, just loop.  */
      if (!created && createit && (procinfo->process_state & (PID_EXITED | PID_REAPED)))
	{
	  debug_printf ("looping because pid %d, procinfo->pid %d, "
			"procinfo->dwProcessid %u has PID_EXITED|PID_REAPED set",
			n, procinfo->pid, procinfo->dwProcessId);
	  goto loop;
	}

      if (flag & PID_NEW)
	procinfo->start_time = time (NULL);
      if (!created)
	/* nothing */;
      else if (!(flag & PID_EXECED))
	procinfo->pid = n;
      else
	{
	  procinfo->process_state |= PID_IN_USE | PID_EXECED;
	  procinfo->pid = myself->pid;
	}

      h = h0;	/* Success! */
      break;

    loop:
      _pinfo_release ();
      if (h0)
	yield ();
    }

  if (h)
    {
      destroy = 1;
      ProtectHandle1 (h, pinfo_shared_handle);
    }
  else
    {
      h = h0;
      _pinfo_release ();
    }
}

void
pinfo::set_acl()
{
  PACL acl_buf = (PACL) alloca (1024);
  SECURITY_DESCRIPTOR sd;
  NTSTATUS status;

  sec_acl (acl_buf, true, true, cygheap->user.sid (),
	   well_known_world_sid, FILE_MAP_READ);
  RtlCreateSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
  status = RtlSetDaclSecurityDescriptor (&sd, TRUE, acl_buf, FALSE);
  if (!NT_SUCCESS (status))
    debug_printf ("RtlSetDaclSecurityDescriptor %y", status);
  else if ((status = NtSetSecurityObject (h, DACL_SECURITY_INFORMATION, &sd)))
    debug_printf ("NtSetSecurityObject %y", status);
}

pinfo::pinfo (HANDLE parent, pinfo_minimal& from, pid_t pid):
  pinfo_minimal (), destroy (false), procinfo (NULL), waiter_ready (false),
  wait_thread (NULL)
{
  HANDLE herr;
  const char *duperr = NULL;
  if (!DuplicateHandle (parent, herr = from.rd_proc_pipe, GetCurrentProcess (),
			&rd_proc_pipe, 0, false, DUPLICATE_SAME_ACCESS))
    duperr = "couldn't duplicate parent rd_proc_pipe handle %p for forked child %d after exec, %E";
  else if (!DuplicateHandle (parent, herr = from.hProcess, GetCurrentProcess (),
			     &hProcess, 0, false, DUPLICATE_SAME_ACCESS))
    duperr = "couldn't duplicate parent process handle %p for forked child %d after exec, %E";
  else
    {
      h = NULL;
      DuplicateHandle (parent, from.h, GetCurrentProcess (), &h, 0, false,
		       DUPLICATE_SAME_ACCESS);
      init (pid, PID_MAP_RW, h);
      if (*this)
	return;
    }

  if (duperr)
    debug_printf (duperr, herr, pid);

  /* Returning with procinfo == NULL.  Any open handles will be closed by the
     destructor. */
}

const char *
_pinfo::_ctty (char *buf)
{
  if (ctty <= 0)
    strcpy (buf, "no ctty");
  else
    {
      device d;
      d.parse (ctty);
      __small_sprintf (buf, "ctty %s", d.name);
    }
  return buf;
}

bool
_pinfo::set_ctty (fhandler_termios *fh, int flags)
{
  tty_min& tc = *fh->tc ();
  debug_printf ("old %s, ctty device number %y, tc.ntty device number %y flags & O_NOCTTY %y", __ctty (), ctty, tc.ntty, flags & O_NOCTTY);
  if (fh && &tc && (ctty <= 0 || ctty == tc.ntty) && !(flags & O_NOCTTY))
    {
      ctty = tc.ntty;
      if (cygheap->ctty != fh->archetype)
	{
	  debug_printf ("cygheap->ctty %p, archetype %p", cygheap->ctty, fh->archetype);
	  if (!cygheap->ctty)
	    syscall_printf ("ctty was NULL");
	  else
	    {
	      syscall_printf ("ctty %p, usecount %d", cygheap->ctty,
			      cygheap->ctty->archetype_usecount (0));
	      cygheap->ctty->close ();
	    }
	  cygheap->ctty = (fhandler_termios *) fh->archetype;
	  if (cygheap->ctty)
	    {
	      fh->archetype_usecount (1);
	      /* guard ctty fh */
	      report_tty_counts (cygheap->ctty, "ctty", "");
	    }
	}

      lock_ttys here;
      syscall_printf ("attaching %s sid %d, pid %d, pgid %d, tty->pgid %d, tty->sid %d",
		      __ctty (), sid, pid, pgid, tc.getpgid (), tc.getsid ());
      if (!cygwin_finished_initializing && !myself->cygstarted
	  && pgid == pid && tc.getpgid () && tc.getsid ())
	pgid = tc.getpgid ();

      /* May actually need to do this:

	 if (sid == pid && !tc.getsid () || !procinfo (tc.getsid ())->exists)

	 but testing for process existence is expensive so we avoid it until
	 an obvious bug surfaces. */
      if (sid == pid && !tc.getsid ())
	tc.setsid (sid);
      sid = tc.getsid ();
      /* See above */
      if (!tc.getpgid () && pgid == pid)
	tc.setpgid (pgid);
    }
  debug_printf ("cygheap->ctty now %p, archetype %p", cygheap->ctty, fh->archetype);
  return ctty > 0;
}

/* Test to determine if a process really exists and is processing signals.
 */
bool __reg1
_pinfo::exists ()
{
  return this && process_state && !(process_state & (PID_EXITED | PID_REAPED | PID_EXECED));
}

bool
_pinfo::alive ()
{
  HANDLE h = OpenProcess (PROCESS_QUERY_INFORMATION, false, dwProcessId);
  if (h)
    CloseHandle (h);
  return !!h;
}

DWORD WINAPI
commune_process (void *arg)
{
  siginfo_t& si = *((siginfo_t *) arg);
  tmp_pathbuf tp;
  char *path = tp.c_get ();
  DWORD nr;
  HANDLE& tothem = si._si_commune._si_write_handle;
  HANDLE process_sync =
    OpenSemaphore (SYNCHRONIZE, false, shared_name (path, "commune", si.si_pid));
  if (process_sync)		// FIXME: this test shouldn't be necessary
    ProtectHandle (process_sync);

  lock_process now;
  if (si._si_commune._si_code & PICOM_EXTRASTR)
    si._si_commune._si_str = (char *) (&si + 1);

  switch (si._si_commune._si_code)
    {
    case PICOM_CMDLINE:
      {
	sigproc_printf ("processing PICOM_CMDLINE");
	unsigned n = 0;
	const char *argv[__argc_safe + 1];

	for (int i = 0; i < __argc_safe; i++)
	  {
	    if (IsBadStringPtr (__argv[i], INT32_MAX))
	      argv[i] = "";
	    else
	      argv[i] = __argv[i];
	    n += strlen (argv[i]) + 1;
	  }
	argv[__argc_safe] = NULL;
	if (!WritePipeOverlapped (tothem, &n, sizeof n, &nr, 1000L))
	  {
	    /*__seterrno ();*/	// this is run from the signal thread, so don't set errno
	    sigproc_printf ("WritePipeOverlapped sizeof argv failed, %E");
	  }
	else
	  for (const char **a = argv; *a; a++)
	    if (!WritePipeOverlapped (tothem, *a, strlen (*a) + 1, &nr, 1000L))
	      {
		sigproc_printf ("WritePipeOverlapped arg %d failed, %E",
				a - argv);
		break;
	      }
	break;
      }
    case PICOM_CWD:
      {
	sigproc_printf ("processing PICOM_CWD");
	unsigned int n = strlen (cygheap->cwd.get (path, 1, 1, NT_MAX_PATH)) + 1;
	if (!WritePipeOverlapped (tothem, &n, sizeof n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped sizeof cwd failed, %E");
	else if (!WritePipeOverlapped (tothem, path, n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped cwd failed, %E");
	break;
      }
    case PICOM_ROOT:
      {
	sigproc_printf ("processing PICOM_ROOT");
	unsigned n;
	if (cygheap->root.exists ())
	  n = strlen (strcpy (path, cygheap->root.posix_path ())) + 1;
	else
	  n = strlen (strcpy (path, "/")) + 1;
	if (!WritePipeOverlapped (tothem, &n, sizeof n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped sizeof root failed, %E");
	else if (!WritePipeOverlapped (tothem, path, n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped root failed, %E");
	break;
      }
    case PICOM_FDS:
      {
	sigproc_printf ("processing PICOM_FDS");
	unsigned int n = 0;
	int fd;
	cygheap_fdenum cfd;
	while ((fd = cfd.next ()) >= 0)
	  n += sizeof (int);
	cfd.rewind ();
	if (!WritePipeOverlapped (tothem, &n, sizeof n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped sizeof fds failed, %E");
	else
	  while ((fd = cfd.next ()) >= 0)
	    if (!WritePipeOverlapped (tothem, &fd, sizeof fd, &nr, 1000L))
	      {
		sigproc_printf ("WritePipeOverlapped fd %d failed, %E", fd);
		break;
	      }
	break;
      }
    case PICOM_PIPE_FHANDLER:
      {
	sigproc_printf ("processing PICOM_FDS");
	HANDLE hdl = si._si_commune._si_pipe_fhandler;
	unsigned int n = 0;
	cygheap_fdenum cfd;
	while (cfd.next () >= 0)
	  if (cfd->get_handle () == hdl)
	    {
	      fhandler_pipe *fh = cfd;
	      n = sizeof *fh;
	      if (!WritePipeOverlapped (tothem, &n, sizeof n, &nr, 1000L))
		sigproc_printf ("WritePipeOverlapped sizeof hdl failed, %E");
	      else if (!WritePipeOverlapped (tothem, fh, n, &nr, 1000L))
		sigproc_printf ("WritePipeOverlapped hdl failed, %E");
	      break;
	    }
	if (!n && !WritePipeOverlapped (tothem, &n, sizeof n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped sizeof hdl failed, %E");
	break;
      }
    case PICOM_FD:
      {
	sigproc_printf ("processing PICOM_FD");
	int fd = si._si_commune._si_fd;
	unsigned int n = 0;
	cygheap_fdget cfd (fd);
	if (cfd < 0)
	  n = strlen (strcpy (path, "")) + 1;
	else
	  n = strlen (cfd->get_proc_fd_name (path)) + 1;
	if (!WritePipeOverlapped (tothem, &n, sizeof n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped sizeof fd failed, %E");
	else if (!WritePipeOverlapped (tothem, path, n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped fd failed, %E");
	break;
      }
    }
  if (process_sync)
    {
      DWORD res = WaitForSingleObject (process_sync, 5000);
      if (res != WAIT_OBJECT_0)
	sigproc_printf ("WFSO failed - %u, %E", res);
      else
	sigproc_printf ("synchronized with pid %d", si.si_pid);
      ForceCloseHandle (process_sync);
    }
  CloseHandle (tothem);
  _my_tls._ctinfo->auto_release ();
  return 0;
}

commune_result
_pinfo::commune_request (__uint32_t code, ...)
{
  DWORD nr;
  commune_result res;
  va_list args;
  siginfo_t si = {0};
  HANDLE& hp = si._si_commune._si_process_handle;
  HANDLE& fromthem = si._si_commune._si_read_handle;
  HANDLE request_sync = NULL;

  res.s = NULL;
  res.n = 0;

  if (!this || !pid)
    {
      set_errno (ESRCH);
      goto err;
    }

  va_start (args, code);
  si._si_commune._si_code = code;
  switch (code)
    {
    case PICOM_PIPE_FHANDLER:
      si._si_commune._si_pipe_fhandler = va_arg (args, HANDLE);
      break;

    case PICOM_FD:
      si._si_commune._si_fd = va_arg (args, int);
      break;

    break;
    }
  va_end (args);

  char name_buf[MAX_PATH];
  request_sync = CreateSemaphore (&sec_none_nih, 0, INT32_MAX,
				  shared_name (name_buf, "commune", myself->pid));
  if (!request_sync)
    goto err;
  ProtectHandle (request_sync);

  si.si_signo = __SIGCOMMUNE;
  if (sig_send (this, si))
    {
      ForceCloseHandle (request_sync);	/* don't signal semaphore since there was apparently no receiving process */
      request_sync = NULL;
      goto err;
    }

  DWORD n;
  switch (code)
    {
    case PICOM_CMDLINE:
    case PICOM_CWD:
    case PICOM_ROOT:
    case PICOM_FDS:
    case PICOM_FD:
    case PICOM_PIPE_FHANDLER:
      if (!ReadPipeOverlapped (fromthem, &n, sizeof n, &nr, 1000L)
	  || nr != sizeof n)
	{
	  __seterrno ();
	  goto err;
	}
      if (!n)
	res.s = NULL;
      else
	{
	  res.s = (char *) cmalloc_abort (HEAP_COMMUNE, n);
	  char *p;
	  for (p = res.s;
	       n && ReadPipeOverlapped (fromthem, p, n, &nr, 1000L);
	       p += nr, n -= nr)
	    continue;
	  if (n)
	    {
	      __seterrno ();
	      goto err;
	    }
	  res.n = p - res.s;
	}
      break;
    }
  goto out;

err:
  memset (&res, 0, sizeof (res));

out:
  if (request_sync)
    {
      LONG res;
      ReleaseSemaphore (request_sync, 1, &res);
      ForceCloseHandle (request_sync);
    }
  if (hp)
    CloseHandle (hp);
  if (fromthem)
    CloseHandle (fromthem);
  return res;
}

fhandler_pipe *
_pinfo::pipe_fhandler (HANDLE hdl, size_t &n)
{
  if (!this || !pid)
    return NULL;
  if (pid == myself->pid)
    return NULL;
  commune_result cr = commune_request (PICOM_PIPE_FHANDLER, hdl);
  n = cr.n;
  return (fhandler_pipe *) cr.s;
}

char *
_pinfo::fd (int fd, size_t &n)
{
  char *s;
  if (!this || !pid)
    return NULL;
  if (pid != myself->pid)
    {
      commune_result cr = commune_request (PICOM_FD, fd);
      s = cr.s;
      n = cr.n;
    }
  else
    {
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	s = cstrdup ("");
      else
	s = cfd->get_proc_fd_name ((char *) cmalloc_abort (HEAP_COMMUNE, NT_MAX_PATH));
      n = strlen (s) + 1;
    }
  return s;
}

char *
_pinfo::fds (size_t &n)
{
  char *s;
  if (!this || !pid)
    return NULL;
  if (pid != myself->pid)
    {
      commune_result cr = commune_request (PICOM_FDS);
      s = cr.s;
      n = cr.n;
    }
  else
    {
      n = 0;
      int fd;
      cygheap_fdenum cfd (true);
      while ((fd = cfd.next ()) >= 0)
	n += sizeof (int);
      cfd.rewind ();
      s = (char *) cmalloc_abort (HEAP_COMMUNE, n);
      int *p = (int *) s;
      while ((fd = cfd.next ()) >= 0 && (char *) p - s < (int) n)
	*p++ = fd;
    }
  return s;
}

char *
_pinfo::root (size_t& n)
{
  char *s;
  if (!this || !pid)
    return NULL;
  if (pid != myself->pid)
    {
      commune_result cr = commune_request (PICOM_ROOT);
      s = cr.s;
      n = cr.n;
    }
  else
    {
      if (cygheap->root.exists ())
	s = cstrdup (cygheap->root.posix_path ());
      else
	s = cstrdup ("/");
      n = strlen (s) + 1;
    }
  return s;
}

char *
_pinfo::cwd (size_t& n)
{
  char *s;
  if (!this || !pid)
    return NULL;
  if (pid != myself->pid)
    {
      commune_result cr = commune_request (PICOM_CWD);
      s = cr.s;
      n = cr.n;
    }
  else
    {
      s = (char *) cmalloc_abort (HEAP_COMMUNE, NT_MAX_PATH);
      cygheap->cwd.get (s, 1, 1, NT_MAX_PATH);
      n = strlen (s) + 1;
    }
  return s;
}

char *
_pinfo::cmdline (size_t& n)
{
  char *s;
  if (!this || !pid)
    return NULL;
  if (pid != myself->pid)
    {
      commune_result cr = commune_request (PICOM_CMDLINE);
      s = cr.s;
      n = cr.n;
    }
  else
    {
      n = 0;
      for (char **a = __argv; *a; a++)
	n += strlen (*a) + 1;
      char *p;
      p = s = (char *) cmalloc_abort (HEAP_COMMUNE, n);
      for (char **a = __argv; *a; a++)
	{
	  strcpy (p, *a);
	  p = strchr (p, '\0') + 1;
	}
    }
  return s;
}

/* This is the workhorse which waits for the write end of the pipe
   created during new process creation.  If the pipe is closed or a zero
   is received on the pipe, it is assumed that the cygwin pid has exited.
   Otherwise, various "signals" can be sent to the parent to inform the
   parent to perform a certain action. */
static DWORD WINAPI
proc_waiter (void *arg)
{
  pinfo vchild = *(pinfo *) arg;
  ((pinfo *) arg)->waiter_ready = true;

  siginfo_t si = {0};
  si.si_signo = SIGCHLD;
  si.si_code = CLD_EXITED;
  si.si_pid = vchild->pid;
#if 0	// FIXME: This is tricky to get right
  si.si_utime = pchildren[rc]->rusage_self.ru_utime;
  si.si_stime = pchildren[rc].rusage_self.ru_stime;
#endif
  pid_t pid = vchild->pid;
  bool its_me = vchild == myself;

  for (;;)
    {
      DWORD nb;
      char buf = '\0';

      if (!ReadFile (vchild.rd_proc_pipe, &buf, 1, &nb, NULL)
	  && GetLastError () != ERROR_BROKEN_PIPE)
	{
	  system_printf ("error on read of child wait pipe %p, %E", vchild.rd_proc_pipe);
	  break;
	}

      if (!its_me && have_execed_cygwin)
	break;

      si.si_uid = vchild->uid;

      switch (buf)
	{
	case __ALERT_ALIVE:
	  continue;
	case 0:
	  /* Child exited.  Do some cleanup and signal myself.  */
	  vchild.maybe_set_exit_code_from_windows ();
	  if (WIFEXITED (vchild->exitcode))
	    si.si_code = CLD_EXITED;
	  else if (WCOREDUMP (vchild->exitcode))
	    si.si_code = CLD_DUMPED;
	  else
	    si.si_code = CLD_KILLED;
	  si.si_status = vchild->exitcode;
	  vchild->process_state = PID_EXITED;
	  /* This should always be last.  Do not use vchild-> beyond this point */
	  break;
	case SIGTTIN:
	case SIGTTOU:
	case SIGTSTP:
	case SIGSTOP:
	  if (ISSTATE (myself, PID_NOCLDSTOP))	// FIXME: No need for this flag to be in _pinfo any longer
	    continue;
	  /* Child stopped.  Signal myself.  */
	  si.si_code = CLD_STOPPED;
	  break;
	case SIGCONT:
	  continue;
	default:
	  system_printf ("unknown value %d on proc pipe", buf);
	  continue;
	}

      if (its_me && ch_spawn.signal_myself_exited ())
	break;

      /* Send a SIGCHLD to myself.   We do this here, rather than in proc_subproc
	 to avoid the proc_subproc lock since the signal thread will eventually
	 be calling proc_subproc and could unnecessarily block. */
      sig_send (myself_nowait, si);

      /* If we're just stopped or got a continue signal, keep looping.
	 Otherwise, return this thread to the pool. */
      if (buf != '\0')
	sigproc_printf ("looping");
      else
	break;
    }

  sigproc_printf ("exiting wait thread for pid %d", pid);
  vchild.wait_thread = NULL;
  _my_tls._ctinfo->auto_release ();	/* automatically return the cygthread to the cygthread pool */
  return 0;
}

/* function to set up the process pipe and kick off proc_waiter */
bool
pinfo::wait ()
{
  preserve ();		/* Preserve the shared memory associated with the pinfo */

  waiter_ready = false;
  /* Fire up a new thread to track the subprocess */
  cygthread *h = new cygthread (proc_waiter, this, "waitproc");
  if (!h)
    sigproc_printf ("tracking thread creation failed for pid %d", (*this)->pid);
  else
    {
      wait_thread = h;
      sigproc_printf ("created tracking thread for pid %d, winpid %y, rd_proc_pipe %p",
		      (*this)->pid, (*this)->dwProcessId, rd_proc_pipe);
    }

  return true;
}

/* function to send a "signal" to the parent when something interesting happens
   in the child. */
bool
_pinfo::alert_parent (char sig)
{
  DWORD nb = 0;

  /* Send something to our parent.  If the parent has gone away, close the pipe.
     Don't send if this is an exec stub.

     FIXME: Is there a race here if we run this while another thread is attempting
     to exec()? */
  if (my_wr_proc_pipe)
    {
      if (WriteFile (my_wr_proc_pipe, &sig, 1, &nb, NULL))
	/* all is well */;
      else if (GetLastError () != ERROR_BROKEN_PIPE)
	debug_printf ("sending %d notification to parent failed, %E", sig);
      else
	{
	  ppid = 1;
	  HANDLE closeit = my_wr_proc_pipe;
	  my_wr_proc_pipe = NULL;
	  ForceCloseHandle1 (closeit, wr_proc_pipe);
	}
    }
  return (bool) nb;
}

void
pinfo::release ()
{
  _pinfo_release ();
  HANDLE close_h;
  if (rd_proc_pipe)
    {
      close_h = rd_proc_pipe;
      rd_proc_pipe = NULL;
      ForceCloseHandle1 (close_h, rd_proc_pipe);
    }
  if (hProcess)
    {
      close_h = hProcess;
      hProcess = NULL;
      ForceCloseHandle1 (close_h, childhProc);
    }
}

/* DOCTOOL-START

<sect1 id="func-cygwin-winpid-to-pid">
  <title>cygwin_winpid_to_pid</title>

  <funcsynopsis><funcprototype>
    <funcdef>extern "C" pid_t
      <function>cygwin_winpid_to_pid</function>
      </funcdef>
      <paramdef>int <parameter>winpid</parameter></paramdef>
  </funcprototype></funcsynopsis>

  <para>Given a windows pid, converts to the corresponding Cygwin
pid, if any.  Returns -1 if windows pid does not correspond to
a cygwin pid.</para>
  <example>
    <title>Example use of cygwin_winpid_to_pid</title>
    <programlisting>
      extern "C" cygwin_winpid_to_pid (int winpid);
      pid_t mypid;
      mypid = cygwin_winpid_to_pid (windows_pid);
    </programlisting>
  </example>
</sect1>

   DOCTOOL-END */

extern "C" pid_t
cygwin_winpid_to_pid (int winpid)
{
  pinfo p (cygwin_pid (winpid));
  if (p)
    return p->pid;

  set_errno (ESRCH);
  return (pid_t) -1;
}


#define slop_pidlist 200
#define size_pidlist(i) (sizeof (pidlist[0]) * ((i) + 1))
#define size_pinfolist(i) (sizeof (pinfolist[0]) * ((i) + 1))
class _onreturn
{
  HANDLE h;
public:
  ~_onreturn ()
  {
    if (h)
      {
	CloseHandle (h);
      }
  }
  void no_close_handle (pinfo& p)
  {
    p.hProcess = h;
    h = NULL;
  }
  _onreturn (): h (NULL) {}
  void operator = (HANDLE h0) {h = h0;}
  operator HANDLE () const {return h;}
};

inline void
winpids::add (DWORD& nelem, bool winpid, DWORD pid)
{
  pid_t cygpid = cygwin_pid (pid);

  if (nelem >= npidlist)
    {
      npidlist += slop_pidlist;
      pidlist = (DWORD *) realloc (pidlist, size_pidlist (npidlist + 1));
      pinfolist = (pinfo *) realloc (pinfolist, size_pinfolist (npidlist + 1));
    }

  _onreturn onreturn;
  pinfo& p = pinfolist[nelem];
  memset (&p, 0, sizeof (p));

  bool perform_copy;
  if (cygpid == myself->pid)
    {
      p = myself;
      perform_copy = false;
    }
  else
    {
      /* Open a process to prevent a subsequent exit from invalidating the
	 shared memory region. */
      onreturn = OpenProcess (PROCESS_QUERY_INFORMATION, false, pid);

      /* If we couldn't open the process then we don't have rights to it and should
	 make a copy of the shared memory area when it exists (it may not).  */
      perform_copy = onreturn ? make_copy : true;

      p.init (cygpid, PID_NOREDIR | pinfo_access, NULL);
    }

  /* If we're just looking for winpids then don't do any special cygwin "stuff* */
  if (winpid)
    {
      perform_copy = true;
      goto out;
    }

  /* !p means that we couldn't find shared memory for this pid.  Probably means
     that it isn't a cygwin process. */
  if (!p)
    {
      if (!pinfo_access)
	return;
      p.init (cygpid, PID_NOREDIR, NULL);
      if (!p)
	return;
    }

  /* Scan list of previously recorded pids to make sure that this pid hasn't
     shown up before.  This can happen when a process execs. */
  for (unsigned i = 0; i < nelem; i++)
    if (pinfolist[i]->pid == p->pid)
      {
	if ((_pinfo *) p != (_pinfo *) myself)
	  p.release ();
	return;
      }

out:
  /* Exit here.

     If p is "false" then, eventually any opened process handle will be closed and
     the function will exit without adding anything to the pid list.

     If p is "true" then we've discovered a cygwin process.

     Handle "myself" differently.  Don't copy it and close/zero the handle we
     just opened to it.
     If not performing a copy, then keep the process handle open for the duration
     of the life of the procinfo region to potential races when a new process uses
     this pid.
     Otherwise, malloc some memory for a copy of the shared memory.

     If the malloc failed, then "oh well".  Just keep the shared memory around
     and eventually close the handle when the winpids goes out of scope.

     If malloc succeeds, copy the procinfo we just grabbed into the new region,
     release the shared memory and allow the handle to be closed when this
     function returns.

     Oh, and add the pid to the list and bump the number of elements.  */

  if (p)
    {
      if (p == (_pinfo *) myself)
	/* handle specially.  Close the handle but (eventually) don't
	   deallocate procinfo in release call */;
      else if (!perform_copy)
	onreturn.no_close_handle (p);	/* Don't close the handle until release */
      else
	{
	  _pinfo *pnew = (_pinfo *) malloc (sizeof (*p.procinfo));
	  if (!pnew)
	    onreturn.no_close_handle (p);
	  else
	    {
	      *pnew = *p.procinfo;
	      p.release ();
	      p.procinfo = pnew;
	      p.destroy = false;
	      if (winpid)
		p->dwProcessId = pid;
	    }
	}
    }
  if (p || winpid)
    pidlist[nelem++] = !p ? pid : p->dwProcessId;
}

DWORD
winpids::enum_processes (bool winpid)
{
  DWORD nelem = 0;

  if (!winpid)
    {
      HANDLE dir = get_shared_parent_dir ();
      BOOLEAN restart = TRUE;
      ULONG context;
      struct fdbi
	{
	  DIRECTORY_BASIC_INFORMATION dbi;
	  WCHAR buf[2][NAME_MAX + 1];
	} f;
      while (NT_SUCCESS (NtQueryDirectoryObject (dir, &f, sizeof f, TRUE,
						 restart, &context, NULL)))
	{
	  restart = FALSE;
	  f.dbi.ObjectName.Buffer[f.dbi.ObjectName.Length / sizeof (WCHAR)] = L'\0';
	  if (wcsncmp (f.dbi.ObjectName.Buffer, L"cygpid.", 7) == 0)
	    {
	    DWORD pid = wcstoul (f.dbi.ObjectName.Buffer + 7, NULL, 10);
	    add (nelem, false, pid);
	  }
	}
    }
  else
    {
      static DWORD szprocs;
      static PSYSTEM_PROCESS_INFORMATION procs;

      while (1)
	{
	  PSYSTEM_PROCESS_INFORMATION new_p = (PSYSTEM_PROCESS_INFORMATION)
	    realloc (procs, szprocs += 200 * sizeof (*procs));
	  if (!new_p)
	    {
	      system_printf ("out of memory reading system process "
			     "information");
	      return 0;
	    }
	  procs = new_p;
	  NTSTATUS status = NtQuerySystemInformation (SystemProcessInformation,
						      procs, szprocs, NULL);
	  if (NT_SUCCESS (status))
	    break;

	  if (status != STATUS_INFO_LENGTH_MISMATCH)
	    {
	      system_printf ("error %y reading system process information",
			     status);
	      return 0;
	    }
	}

      PSYSTEM_PROCESS_INFORMATION px = procs;
      char *&pxc = (char *&)px;
      while (1)
	{
	  if (px->UniqueProcessId)
	    add (nelem, true, (DWORD) (uintptr_t) px->UniqueProcessId);
	  if (!px->NextEntryOffset)
	    break;
	  pxc += px->NextEntryOffset;
	}
    }
  return nelem;
}

void
winpids::set (bool winpid)
{
  npids = enum_processes (winpid);
  if (pidlist)
    pidlist[npids] = 0;
}

DWORD
winpids::enum_init (bool winpid)
{
  return enum_processes (winpid);
}

void
winpids::release ()
{
  _pinfo *p;
  for (unsigned i = 0; i < npids; i++)
    if (pinfolist[i] == (_pinfo *) myself)
      continue;
    else if (pinfolist[i].hProcess)
      pinfolist[i].release ();
    else if ((p = pinfolist[i]))
      {
	pinfolist[i].procinfo = NULL;
	free (p);
      }
}

winpids::~winpids ()
{
  if (npidlist)
    {
      release ();
      free (pidlist);
      free (pinfolist);
    }
}
@


1.330
log
@* pinfo.cc (winpids::add): Always copy pinfo structure when winpid.  Fill out
dwProcessId explicitly to handle exec from a windows process.
(winpids::enum_processes): Reorganize to iterate over known cygwin pids when
!winpid.  Simplify logic.  Don't do duplicate detection for winpid.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d41 1
a41 1
  GetModuleFileNameW (NULL, progname, sizeof (progname));
@


1.329
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d1177 4
a1180 1
    goto out;
d1245 2
d1258 7
a1264 17
  DWORD cygwin_pid_nelem = 0;
  NTSTATUS status;
  ULONG context;
  struct fdbi
    {
      DIRECTORY_BASIC_INFORMATION dbi;
      WCHAR buf[2][NAME_MAX + 1];
    } f;
  HANDLE dir = get_shared_parent_dir ();
  BOOLEAN restart = TRUE;

  while (NT_SUCCESS (NtQueryDirectoryObject (dir, &f, sizeof f, TRUE, restart,
					     &context, NULL)))
    {
      restart = FALSE;
      f.dbi.ObjectName.Buffer[f.dbi.ObjectName.Length / sizeof (WCHAR)] = L'\0';
      if (wcsncmp (f.dbi.ObjectName.Buffer, L"cygpid.", 7) == 0)
d1266 13
a1278 2
	  DWORD pid = wcstoul (f.dbi.ObjectName.Buffer + 7, NULL, 10);
	  add (nelem, false, pid);
d1281 1
a1281 3
  cygwin_pid_nelem = nelem;

  if (winpid)
d1286 1
a1286 1
      if (!szprocs)
d1288 3
a1290 3
	  procs = (PSYSTEM_PROCESS_INFORMATION)
		  malloc (sizeof (*procs) + (szprocs = 200 * sizeof (*procs)));
	  if (!procs)
d1296 3
a1298 7
	}

      for (;;)
	{
	  status =
		NtQuerySystemInformation (SystemProcessInformation,
					  procs, szprocs, NULL);
d1302 1
a1302 15
	  if (status == STATUS_INFO_LENGTH_MISMATCH)
	    {
	      PSYSTEM_PROCESS_INFORMATION new_p;

	      new_p = (PSYSTEM_PROCESS_INFORMATION)
		      realloc (procs, szprocs += 200 * sizeof (*procs));
	      if (!new_p)
		{
		  system_printf ("out of memory reading system process "
				 "information");
		  return 0;
		}
	      procs = new_p;
	    }
	  else
d1311 2
a1312 1
      for (;;)
d1315 1
a1315 11
	    {
	      bool do_add = true;
	      for (unsigned i = 0; i < cygwin_pid_nelem; ++i)
		if (pidlist[i] == (uintptr_t) px->UniqueProcessId)
		  {
		    do_add = false;
		    break;
		  }
	      if (do_add)
		add (nelem, true, (DWORD) (uintptr_t) px->UniqueProcessId);
	    }
d1318 1
a1318 1
	  px = (PSYSTEM_PROCESS_INFORMATION) ((char *) px + px->NextEntryOffset);
@


1.328
log
@* dcrt0.cc (dll_crt0_1): Remove NtSetTimerResolution.
* pinfo.cc (pinfo::init): Increase wait interval when waiting for procinfo to
stabilize.
@
text
@d44 1
a44 1
  gid = UNKNOWN_GID;
d103 1
a103 1
      myself->gid = UNKNOWN_GID;
@


1.328.2.1
log
@* pinfo.cc (winpids::add): Always copy pinfo structure when winpid.  Fill out
dwProcessId explicitly to handle exec from a windows process.
(winpids::enum_processes): Reorganize to iterate over known cygwin pids when
!winpid.  Simplify logic.  Don't do duplicate detection for winpid.
@
text
@d1177 1
a1177 4
    {
      perform_copy = true;
      goto out;
    }
a1241 2
	      if (winpid)
		p->dwProcessId = pid;
d1253 17
a1269 7

  if (!winpid)
    {
      HANDLE dir = get_shared_parent_dir ();
      BOOLEAN restart = TRUE;
      ULONG context;
      struct fdbi
d1271 2
a1272 13
	  DIRECTORY_BASIC_INFORMATION dbi;
	  WCHAR buf[2][NAME_MAX + 1];
	} f;
      while (NT_SUCCESS (NtQueryDirectoryObject (dir, &f, sizeof f, TRUE,
						 restart, &context, NULL)))
	{
	  restart = FALSE;
	  f.dbi.ObjectName.Buffer[f.dbi.ObjectName.Length / sizeof (WCHAR)] = L'\0';
	  if (wcsncmp (f.dbi.ObjectName.Buffer, L"cygpid.", 7) == 0)
	    {
	    DWORD pid = wcstoul (f.dbi.ObjectName.Buffer + 7, NULL, 10);
	    add (nelem, false, pid);
	  }
d1275 3
a1277 1
  else
d1282 1
a1282 1
      while (1)
d1284 3
a1286 3
	  PSYSTEM_PROCESS_INFORMATION new_p = (PSYSTEM_PROCESS_INFORMATION)
	    realloc (procs, szprocs += 200 * sizeof (*procs));
	  if (!new_p)
d1292 7
a1298 3
	  procs = new_p;
	  NTSTATUS status = NtQuerySystemInformation (SystemProcessInformation,
						      procs, szprocs, NULL);
d1302 15
a1316 1
	  if (status != STATUS_INFO_LENGTH_MISMATCH)
d1325 1
a1325 2
      char *&pxc = (char *&)px;
      while (1)
d1328 11
a1338 1
	    add (nelem, true, (DWORD) (uintptr_t) px->UniqueProcessId);
d1341 1
a1341 1
	  pxc += px->NextEntryOffset;
@


1.328.2.2
log
@Add more missing patches
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d41 1
a41 1
  GetModuleFileNameW (NULL, progname, sizeof (progname) / sizeof (WCHAR));
@


1.327
log
@* autoload.cc (timeBeginPeriod): Autoload.
* dcrt0.cc (dll_crt0_1): Use timeBeginPeriod to set default resolution to 1 ms.
* pinfo.cc (pinfo::thisproc): Set ppid for redirected _pinfo blocks too.
(pinfo::init): Avoid using VirtualQuery.  Just rely on the assumption that
procinfo will be populated.
* pinfo.h (_pinfo::ppid): Move into redirected block.
@
text
@d321 5
a325 3
	/* If not populated, wait 2 seconds for procinfo to become populated  */
	for (int i = 0; i < 2000 && !procinfo->ppid; i++)
	  Sleep (1);
@


1.326
log
@* external.cc (fillout_pinfo): Remove nonsensical loop.
* fork.cc (frok::parent): When initializing pinfo for child new PID_NEW flag +
actual defined constant rather than raw number.  Don't set start_time here.
* pinfo.cc (pinfo::thisproc): Use PID_NEW when initializing pinfo.  Avoid
checking h for NULL multiple times.  Don't set start_time here.
(pinfo_init): Aways set ppid last.  Tweak strace output.
(pinfo::init): Handle new PID_NEW flag.  Wait for shared memory to contain
useful information.  Set start_time if PID_NEW.
(_onreturn:h): Define as HANDLE rather than HANDLE *.
(_onreturn::~onreturn): Accommodate h definition change.
(_onreturn::no_close_handle): Rename from no_close_p_handle.  Take a pinfo arg
and set hProcess to h before zeroing.
(winpids::add): Don't open a handle to our own process.  Change logic
associated with when a handle gets closed.  Accommodate no_close_handle
changes.
(winpids::enum_processes): Simplify process enumeration loop.
(winpids::set): Eliminate ill-considered malloc locking.
* sigproc.cc (proc_subproc): Always set ppid last.
@
text
@d80 1
d321 3
a323 8
	{
	  MEMORY_BASIC_INFORMATION mbi;
	  for (int i = 0; i < 1000 && !procinfo->ppid; i++)
	    Sleep (0);
	  if (procinfo->exists () && VirtualQuery (procinfo, &mbi, sizeof (mbi))
	      && mbi.RegionSize < sizeof (_pinfo))
	    goto loop;
	}
@


1.325
log
@	* pinfo.cc (pinfo::status_exit): Enhance comment.
@
text
@d59 1
d61 5
a65 1
    cygheap->pid = cygwin_pid (myself_initial.pid);
d67 1
a67 1
  init (cygheap->pid, PID_IN_USE, h ?: INVALID_HANDLE_VALUE);
d73 1
a73 1
  if (h)
a80 3
  else if (!child_proc_info)	/* child_proc_info is only set when this process
				   was started by another cygwin process */
    procinfo->start_time = time (NULL); /* Register our starting time. */
a98 1
      myself->ppid = 1;
d105 1
d112 1
a112 1
  debug_printf ("pid %d, pgid %d", myself->pid, myself->pgid);
d319 9
a327 5
      MEMORY_BASIC_INFORMATION mbi;
      if (!created && procinfo->exists ()
	  && VirtualQuery (procinfo, &mbi, sizeof (mbi))
	  && mbi.RegionSize < sizeof (_pinfo))
	goto loop;
d369 2
d1123 1
a1123 1
  HANDLE *h;
d1127 1
a1127 1
    if (h && *h)
d1129 1
a1129 3
	CloseHandle (*h);
	*h = NULL;
	h = NULL;
d1132 8
a1139 2
  void no_close_p_handle () {h = NULL;}
  _onreturn (HANDLE& _h): h (&_h) {}
d1154 1
a1157 7
  /* Open a process to prevent a subsequent exit from invalidating the
     shared memory region. */
  p.hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, false, pid);
  _onreturn onreturn (p.hProcess);

  /* If we couldn't open the process then we don't have rights to it and should
     make a copy of the shared memory area if it exists (it may not).  */
d1159 5
a1163 2
  if (!p.hProcess)
    perform_copy = true;
d1165 8
a1172 1
    perform_copy = make_copy;
d1174 2
a1175 1
  p.init (cygpid, PID_NOREDIR | pinfo_access, NULL);
d1190 1
a1190 1
      }
d1232 1
a1232 1
	onreturn.no_close_p_handle ();	/* Don't close the handle until release */
d1237 1
a1237 1
	    onreturn.no_close_p_handle ();
d1266 2
a1267 1
  do
d1269 3
a1271 3
      status = NtQueryDirectoryObject (dir, &f, sizeof f, TRUE, restart,
				       &context, NULL);
      if (NT_SUCCESS (status))
d1273 2
a1274 8
	  restart = FALSE;
	  f.dbi.ObjectName.Buffer[f.dbi.ObjectName.Length / sizeof (WCHAR)]
	    = L'\0';
	  if (wcsncmp (f.dbi.ObjectName.Buffer, L"cygpid.", 7) == 0)
	    {
	      DWORD pid = wcstoul (f.dbi.ObjectName.Buffer + 7, NULL, 10);
	      add (nelem, false, pid);
	    }
a1276 1
  while (NT_SUCCESS (status));
a1345 1

a1351 1
  __malloc_lock ();
a1354 1
  __malloc_unlock ();
@


1.324
log
@	* environ.cc (win_env::add_cache): Set the Windows environment variable
	using wide chars to make sure native chars don't get scrambled.
	* environ.h (build_env): Fix formatting in declaration.
	* pinfo.cc (pinfo::status_exit): Handle STATUS_NO_MEMORY.  Explain why.
@
text
@d152 3
a154 3
	 reason.  This occurs at a point where there's no return to the exec'ing
	 parent process, so we have to find some way to inform the user what
	 happened.
@


1.323
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d147 13
@


1.322
log
@	* Merge in cygwin-64bit-branch.
@
text
@d495 1
a495 1
bool __stdcall
@


1.321
log
@* pinfo.h (pinfo::status_exit): Rename from former static function in pinfo.cc.
(pinfo::operator == (char *)): Remove unused operator.
* pinfo.cc (pinfo::status_exit): Move this function info pinfo class.  Use
progname from the pinfo rather than myself.  Be defensive when inspecting
procinfo.
@
text
@d123 1
a123 1
	  pc.check ("/dev/null");
d131 2
a132 1
	small_printf ("%s: error while loading shared libraries: %s: cannot open shared object file: No such file or directory\n",
d148 1
a148 1
      debug_printf ("*** STATUS_%p\n", x);
d178 1
a178 1
  sigproc_printf ("pid %d, exit value - old %p, windows %p, cygwin %p",
d212 1
a212 1
  sigproc_printf ("Calling ExitProcess n %p, exitcode %p", n, exitcode);
d328 1
a328 1
	  debug_printf ("execed process windows pid %d, cygwin pid %d", n, realpid);
d393 1
a393 1
    debug_printf ("RtlSetDaclSecurityDescriptor %p", status);
d395 1
a395 1
    debug_printf ("NtSetSecurityObject %p", status);
d445 1
a445 1
  debug_printf ("old %s, ctty device number %p, tc.ntty device number %p flags & O_NOCTTY %p", __ctty (), ctty, tc.ntty, flags & O_NOCTTY);
d645 1
a645 1
	sigproc_printf ("WFSO failed - %d, %E", res);
d692 1
a692 1
  request_sync = CreateSemaphore (&sec_none_nih, 0, LONG_MAX,
d706 1
a706 1
  size_t n;
d715 1
a715 1
      if (!ReadPipeOverlapped (fromthem, &n, sizeof n, &nr, 500L)
d728 1
a728 1
	       n && ReadPipeOverlapped (fromthem, p, n, &nr, 500L);
d1003 1
a1003 1
      sigproc_printf ("created tracking thread for pid %d, winpid %p, rd_proc_pipe %p",
d1258 1
a1258 1
      static PSYSTEM_PROCESSES procs;
d1262 1
a1262 1
	  procs = (PSYSTEM_PROCESSES)
d1275 1
a1275 1
		NtQuerySystemInformation (SystemProcessesAndThreadsInformation,
d1282 1
a1282 1
	      PSYSTEM_PROCESSES new_p;
d1284 1
a1284 1
	      new_p = (PSYSTEM_PROCESSES)
d1296 1
a1296 1
	      system_printf ("error %p reading system process information",
d1302 1
a1302 1
      PSYSTEM_PROCESSES px = procs;
d1305 1
a1305 1
	  if (px->ProcessId)
d1309 1
a1309 1
		if (pidlist[i] == px->ProcessId)
d1315 1
a1315 1
		add (nelem, true, px->ProcessId);
d1317 1
a1317 1
	  if (!px->NextEntryDelta)
d1319 1
a1319 1
	  px = (PSYSTEM_PROCESSES) ((char *) px + px->NextEntryDelta);
@


1.320
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d113 2
a114 2
static DWORD
status_exit (DWORD x)
d121 9
a129 3
	UNICODE_STRING uc;
	RtlInitUnicodeString(&uc, myself->progname);
	path_conv pc (&uc, PC_NOWARN);
@


1.319
log
@Fix copyrights
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.318
log
@* exceptions.cc (signal_exit): Move captive process termintation...
(_cygtls::interrupt_setup): ...into here.
(sigpacket::process): Simplify setting of handler when have_execed.
(_cygtls::interrupt_setup): Don't call proc_subproc when we've execed.
* globals.cc (exit_states): Delete unneeded ES_EXEC_EXIT.
* pinfo.cc (pinfo::exit): Change debugging output.  Call proc_terminate rather
than the now-obsolete sigproc_terminate.  Don't set exit_state to ES_EXEC_EXIT.
Set exit_state to ES_FINAL later.
* sigproc.cc (sigproc_terminate): Delete function.
(wait_sig): Don't call proc_subproc if have_execed.
* sigproc.h (sigproc_terminate): Delete declaration.
* sync.h (lock_process::lock_process): Don't set exit_state to
ES_PROCESS_LOCKED.
(lock_process::operator LONG): Define.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.317
log
@* DevNotes: Add entry cgf-000017.
* _cygtls.cc (_cygtls::call2): Use new exit_thread function in place of
ExitThread.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
(pthread_mutex::unlock): Set tid to NULL rather than 0.
(pthread_spinlock::unlock): Ditto.
* pinfo.cc (commune_process): Actually call lock_process constructor.
* sigproc.cc (exit_thread): New function.
(wait_sig): Handle __SIGTHREADEXIT case.  Don't just block rather than
returning from this function.
* sigproc.h (__SIGTHREADEXIT): New enum.
(exit_thread): Declare.
* sync.cc (muto::release): Accept a tls command-line argument.
* sync.h (muto::release): Accept a tls command-line parameter.  Default to
&_my_tls.
@
text
@d178 2
a179 2
  minimal_printf ("winpid %d, exit %d", GetCurrentProcessId (), n);
  sigproc_terminate (ES_FINAL);
d186 2
a187 4
    {
      exit_state = ES_EXEC_EXIT;
      maybe_set_exit_code_from_windows ();
    }
@


1.316
log
@	* winbase.h: Semi-reinstantiate to workaround lack inline assembler
	implementation of InterlockedCompareExchange for i686 in Mingw64
	headers.
	* pinfo.cc (pinfo::init): Remove unused variable mapaddr.
@
text
@d518 1
a518 1
  lock_process now ();
@


1.315
log
@* pinfo.cc: Remove unneeded assert.h.
@
text
@a244 1
  void *mapaddr;
d286 3
a288 7
	  switch (GetLastError ())
	    {
	    case ERROR_INVALID_HANDLE:
	      api_fatal ("MapViewOfFileEx h0 %p, i %d failed, %E", h0, i);
	    case ERROR_INVALID_ADDRESS:
	      mapaddr = NULL;
	    }
@


1.314
log
@* pinfo.cc (pinfo::init): Detect potential race where short block has been
retrieved but PID_EXECED flag is not set.
@
text
@a23 1
#include <assert.h>
@


1.313
log
@* pinfo.cc (pinfo::init): Remove assertion.
@
text
@d302 9
@


1.312
log
@* pinfo.cc (_pinfo::exists): Don't consider a process with no state to exist.
@
text
@a318 1
	  assert (i == 0);
@


1.311
log
@whitespace cleanup
@
text
@d491 1
a491 1
  return this && !(process_state & (PID_EXITED | PID_REAPED | PID_EXECED));
@


1.310
log
@* pinfo.cc (_pinfo::exists): Don't consider an execed process to exist.
@
text
@d307 1
a307 1
	} 
@


1.309
log
@* pinfo.cc (_pinfo::commune_request): Eliminate unneeded assignment found by
Clang.
@
text
@d491 1
a491 1
  return this && !(process_state & (PID_EXITED | PID_REAPED));
@


1.309.2.1
log
@Pull in changes from HEAD
@
text
@d491 1
a491 1
  return this && !(process_state & (PID_EXITED | PID_REAPED | PID_EXECED));
@


1.309.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d24 1
a301 9
      /* Detect situation where a transitional memory block is being retrieved.
	 If the block has been allocated with PINFO_REDIR_SIZE but not yet
	 updated with a PID_EXECED state then we'll retry.  */
      MEMORY_BASIC_INFORMATION mbi;
      if (!created && procinfo->exists ()
	  && VirtualQuery (procinfo, &mbi, sizeof (mbi))
	  && mbi.RegionSize < sizeof (_pinfo))
	goto loop;

d307 1
a307 1
	}
d319 1
d491 1
a491 1
  return this && process_state && !(process_state & (PID_EXITED | PID_REAPED | PID_EXECED));
@


1.309.2.3
log
@	* pinfo.cc (_pinfo::commune_request): Accommodate the fact that LONG_MAX
	does not match sizeof LONG.

	Pull in changes from HEAD.
@
text
@d245 1
d287 7
a293 3
	  if (GetLastError () == ERROR_INVALID_HANDLE)
	    api_fatal ("MapViewOfFileEx h0 %p, i %d failed, %E", h0, i);

d692 1
a692 1
  request_sync = CreateSemaphore (&sec_none_nih, 0, INT_MAX,
@


1.309.2.4
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d1253 1
a1253 1
      static PSYSTEM_PROCESS_INFORMATION procs;
d1257 1
a1257 1
	  procs = (PSYSTEM_PROCESS_INFORMATION)
d1270 1
a1270 1
		NtQuerySystemInformation (SystemProcessInformation,
d1277 1
a1277 1
	      PSYSTEM_PROCESS_INFORMATION new_p;
d1279 1
a1279 1
	      new_p = (PSYSTEM_PROCESS_INFORMATION)
d1297 1
a1297 1
      PSYSTEM_PROCESS_INFORMATION px = procs;
d1300 1
a1300 1
	  if (px->UniqueProcessId)
d1304 1
a1304 1
		if (pidlist[i] == (uintptr_t) px->UniqueProcessId)
d1310 1
a1310 1
		add (nelem, true, (DWORD) (uintptr_t) px->UniqueProcessId);
d1312 1
a1312 1
	  if (!px->NextEntryOffset)
d1314 1
a1314 1
	  px = (PSYSTEM_PROCESS_INFORMATION) ((char *) px + px->NextEntryOffset);
@


1.309.2.5
log
@	* fhandler_netdrive.cc: Use UINT32_MAX rather than UINT_MAX to make
	absolutely clear that we mean the 32 bit maximum.
	* fhandler_socket.cc: Ditto.
	* pinfo.cc: Ditto with INT32_MAX.
	* select.cc (fd_mask): Drop gratuitious definition.
	(sizeof_fd_set): Cast to size_t.
	* shared.cc (pround): Cast to ptrdiff_t.
	* strace.cc (strace::activate): Fix format string.
	(strace::write_childpid): Take pid_t as parameter.
	* include/sys/strace.h (strace::write_childpid): Change declaration
	accordingly.
	* sync.cc (muto::init): Cast in call to InterlockedExchangePointer to
	make compiler happy.
	* sync.h (class muto): De-const name.
	* syslog.cc (try_connect_syslogd): Take size_t as third argument.
	(vsyslog): Convert len to size_t.
	* thread.cc: Use {U}INT32_MAX rather than {U}LONG_MAX.  Througout change
	types used in Windows calls to matching Windows types.
	(pthread::cancel): Fix access to instruction pointer for x86_64.
	(pthread_attr_getstack): Cast to ptrdiff_t for pointer arithmetic.
	* thread.h: Throughout convert 'long' types to uint32_t or LONG.
@
text
@d687 1
a687 1
  request_sync = CreateSemaphore (&sec_none_nih, 0, INT32_MAX,
@


1.309.2.6
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d141 1
a141 1
      debug_printf ("*** STATUS_%y\n", x);
d171 1
a171 1
  sigproc_printf ("pid %d, exit value - old %y, windows %y, cygwin %y",
d178 1
a178 1
  minimal_printf ("winpid %u, exit %u", GetCurrentProcessId (), n);
d207 1
a207 1
  sigproc_printf ("Calling ExitProcess n %y, exitcode %y", n, exitcode);
d323 1
a323 1
	  debug_printf ("execed process windows pid %u, cygwin pid %d", n, realpid);
d388 1
a388 1
    debug_printf ("RtlSetDaclSecurityDescriptor %y", status);
d390 1
a390 1
    debug_printf ("NtSetSecurityObject %y", status);
d440 1
a440 1
  debug_printf ("old %s, ctty device number %y, tc.ntty device number %y flags & O_NOCTTY %y", __ctty (), ctty, tc.ntty, flags & O_NOCTTY);
d640 1
a640 1
	sigproc_printf ("WFSO failed - %u, %E", res);
d998 1
a998 1
      sigproc_printf ("created tracking thread for pid %d, winpid %y, rd_proc_pipe %p",
d1291 1
a1291 1
	      system_printf ("error %y reading system process information",
@


1.309.2.7
log
@	* pinfo.h (enum picom): Add PICOM_HEAP_INFO.
	(_pinfo::win_heap_info): Declare.
	(struct win_heap_info): Rename from heap_info and define here.  Change
	to accommodate 64 bit.
	* fhandler_process.cc (struct win_heap_info): Just implement here.
	(win_heap_info::gen_heap_info): New method.
	(format_process_maps): Accommodate above changes.  Add FIXME comment
	to explain 32->64 bit problem with VirtualQueryEx.
	* pinfo.cc (commune_process): Handle PICOM_HEAP_INFO.
	(_pinfo::commune_request): Ditto.
	(_pinfo::win_heap_info): New method.
@
text
@a634 12
    case PICOM_HEAP_INFO:
      {
	sigproc_printf ("processing PICOM_HEAP_INFO");
      	commune_result cr = win_heap_info::gen_heap_info ();
	if (!WritePipeOverlapped (tothem, &cr.n, sizeof cr.n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped sizeof heaps failed, %E");
	else if (cr.n && !WritePipeOverlapped (tothem, cr.s, cr.n, &nr, 1000L))
	  sigproc_printf ("WritePipeOverlapped heaps failed, %E");
	if (cr.s)
	  cfree (cr.s);
	break;
      }
a708 1
    case PICOM_HEAP_INFO:
a889 15
char *
_pinfo::win_heap_info (size_t& n)
{
  commune_result cr;

  if (!this || !pid)
    return NULL;
  if (pid != myself->pid)
    cr = commune_request (PICOM_HEAP_INFO);
  else
    cr = win_heap_info::gen_heap_info ();
  n = cr.n;
  return cr.s;
}

@


1.309.2.8
log
@Pull in changes from HEAD
@
text
@d518 1
a518 1
  lock_process now;
@


1.309.2.9
log
@Pull in changes from HEAD
@
text
@d178 2
a179 2
  debug_only_printf ("winpid %d, exit %d", GetCurrentProcessId (), n);
  proc_terminate ();
d186 4
a189 2
    maybe_set_exit_code_from_windows ();	/* may block */
  exit_state = ES_FINAL;
@


1.309.2.10
log
@Fix copyrights
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.309.2.11
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.309.2.12
log
@	* fhandler_process.cc (win_heap_info::~win_heap_info): Only try to free
	heap_vm_chunks if it's not NULL.
	* pinfo.h (struct commune_result): Change type of n to DWORD.
	* pinfo.cc (_pinfo::commune_request): Change type of n to DWORD to
	fix subsequent sizeof test after reading from commune pipe on x86_64.
	Raise read timeout to match write timeout.
@
text
@d711 1
a711 1
  DWORD n;
d721 1
a721 1
      if (!ReadPipeOverlapped (fromthem, &n, sizeof n, &nr, 1000L)
d734 1
a734 1
	       n && ReadPipeOverlapped (fromthem, p, n, &nr, 1000L);
@


1.309.2.13
log
@	* Makefile.in (toollibdir): Remove.  Revert to using tooldir instead.
	* configure.ac (DLL_NAME): Set to cygwin1.dll in x86_64 case, too.
	* configure: Regenerate.
	* cygwin.sc.in (SEARCH_DIR): Align to 32 bit search dir, use lib, rather
	than lib64.
	* cygwin64.din (LIBRARY): Set name to cygwin1.dll.
	* fhandler_process.cc (struct heap_info): Drop win_heap_info class
	and revert code to former heap_info implementation.
	(format_process_maps): Define heaps back to heap_info
	* hookapi.cc (hook_or_detect_cygwin): Add shortcut so the code does
	not search executable for being a Cygwin executable, if the architecture
	is not matching the current Cygwin.  Always use for "cygwin1.dll".
	* pinfo.cc (commune_process): Drop PICOM_HEAP_INFO code.
	(_pinfo::commune_request): Ditto.
	(_pinfo::win_heap_info): Remove.
	* pinfo.h (enum picom): Remove PICOM_HEAP_INFO.
@
text
@d633 12
d719 1
d901 15
@


1.309.2.14
log
@	* configure.ac (MALLOC_OFILES): Add ptmalloc3.o.
	* configure: Regenerate.
	* cygmalloc.h: Declare pt* functions rather than dl* functions.
	(mmap64): Declare.
	(mmap): Define as mmap64.
	(__malloc_lock): Drop macro.
	(__malloc_unlock): Ditto.
	(MSPACES): Define.
	(ONLY_MSPACES): Define.
	* debug.h: Include malloc.h rather than otherwise unused dlmalloc.h.
	* fork.cc (frok::parent): Drop malloc locking since that's performed
	by malloc_atfork now.
	* heap.cc (heap_init): Accommodate the fact that there's a chance
	that no heap space has been allocated at fork time.
	* malloc-private.h: New file from ptmalloc3, having malloc-machine.h
	and malloc-2.8.3.h folded in.
	* malloc.cc: Replaced by new file from ptmalloc3.
	* malloc_wrapper.cc: Throughout, remove malloc locks and call pt*
	functions rather than dl* functions.
	* pinfo.cc (winpids::set): Drop malloc locking.
	* ptmalloc3.cc: New file from ptmalloc3.
@
text
@d1322 1
d1326 1
@


1.309.2.15
log
@	* Revert to old malloc.
	* mmap.cc (MMAP_STORAGE_LOW): Set higher.  Add comment.
	(MMAP_STORAGE_HIGH): Add comment.
	(class mmap_allocator): Change comment.  Add mmap_current_low member.
	(mmap_allocator::mmap_allocator): Define default constructor.
	(mmap_allocator::alloc): Change to a round-robin mechanism.  Add or
	change comments accordingly.
@
text
@a1321 1
  __malloc_lock ();
a1324 1
  __malloc_unlock ();
@


1.309.2.16
log
@Pull in changes from HEAD
@
text
@d113 2
a114 2
DWORD
pinfo::status_exit (DWORD x)
d121 3
a123 9
	path_conv pc;
	if (!procinfo)
	   pc.check ("/dev/null");
	else
	  {
	    UNICODE_STRING uc;
	    RtlInitUnicodeString(&uc, procinfo->progname);
	    pc.check (&uc, PC_NOWARN);
	  }
d125 1
a125 2
	small_printf ("%s: error while loading shared libraries: %s: cannot "
		      "open shared object file: No such file or directory\n",
@


1.309.2.17
log
@	* Reinstantiate ptmalloc3.
	* configure.ac (MALLOC_OFILES): Drop here.
	* configure: Regenerate.
	* Makefile.in (MALLOC_OFILES): Set to fixed value here.
	* cygmalloc.h (HAVE_MORECORE): Define.
	* malloc.cc (init_user_mstate): Don't disable MORECORE if building
	with ONLY_MSPACES.
@
text
@d1329 1
d1333 1
@


1.309.2.18
log
@	* Remove ptmalloc3 once and for all.
@
text
@a1328 1
  __malloc_lock ();
a1331 1
  __malloc_unlock ();
@


1.308
log
@	* hookapi.cc (find_first_notloaded_dll): Extend comment.  Fix usage of
	mapped memory.  Shorten static library name buffer to MAX_PATH.  Use
	strlcpy to copy library name to buffer.  Only Unmap "map" if it has been
	Mapped before.
	* pinfo.cc (status_exit): Drop unneeded declaration of
	find_first_notloaded_dll in favor of the declaration in winsup.h.
@
text
@a657 1
  bool locked = false;
a683 1
  locked = true;
@


1.307
log
@* DevNotes: Add entry cgf-000004.
* pinfo.cc (pinfo::init): Reuse shared memory if the state is marked with
PID_REAPED.
* spawn.cc (child_info_spawn::worker): Don't duplicate myself_pinfo into
non-cygwin child.
* fork.cc (frok::parent): Improve error output.
@
text
@a116 1
  const char *find_first_notloaded_dll (path_conv &);
@


1.306
log
@* DevNotes: Add entry cgf-000003.
* cygheap.h (init_cygheap::pid_handle): Delete.
* dcrt0.cc (child_info_spawn::handle_spawn): Keep parent open if we have
execed.
* pinfo.cc (pinfo::thisproc): Remove pid_handle manipulations.
(pinfo::init): Don't consider a reaped process to be available.
* spawn.cc (child_info_spawn::worker): Remove pid_handle manipulations.  Make
wr_proc_pipe and parent noninheritable when starting a program which doesn't
use the Cygwin DLL.  Conditionally reset wr_proc_pipe to inheritable if
CreateProcess fails.  Inject wr_proc_pipe handle into non-Cygwin process.
Consider a non-cygwin process to be 'synced'.
@
text
@d303 7
@


1.305
log
@* child_info.h: Reset magic number.
(child_info_spawn::wait_for_myself): Move function to sigproc.cc.
* pinfo.cc (is_toplevel_proc): Delete unneeded variable.
* sigproc.cc (child_info_spawn::wait_for_myself): Move function from header to
here.  Do all setup required to properly wait for top-level execed process to
exit.
* spawn.cc (child_info_spawn::worker): Attempt to properly handle _P_DETACH.
Set wr_proc_pipe if top-level process even when execing.  Just call
wait_for_myself() to...  wait for myself.  Don't call cleanup twice.
@
text
@a79 5
  else if (::cygheap->pid_handle)
    {
      ForceCloseHandle (::cygheap->pid_handle);
      ::cygheap->pid_handle = NULL;
    }
d303 3
a305 2
      if ((procinfo->process_state & PID_INITIALIZING) && (flag & PID_NOREDIR)
	  && cygwin_pid (procinfo->dwProcessId) != procinfo->pid)
@


1.304
log
@* pinfo.cc (proc_waiter): Remove debugging.
@
text
@a51 2
bool is_toplevel_proc;

@


1.303
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::rd_proc_pipe): Declare new field.
(child_info::wr_proc_pipe): Ditto.
(child_info::prefork): Declare new function, derived from previous pinfo
version.
* dcrt0.cc (child_info_fork::handle_fork): Close previous wr_proc_pipe when
appropriate and assign new one from passed-in child_info block.
(child_info_spawn::handle_spawn): Assign our wr_proc_pipe handle from passed-in
child_info block.
* fork.cc (child_info::prefork): Define new function.
(frok::child): Clear rd_proc_pipe and wr_proc_pipe so they will not be closed
by the child_info destructor.
(frok::parent): Use child_info prefork handling, outside of retry loop.  Set
rd_proc_pipe in child's pinfo after successful CreateProcess.  Eliminate
postfork call.
* globals.cc (my_wr_proc_pipe): Define/declare new variable.
* pinfo.cc (pinfo::pending_rd_proc_pipe): Delete.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wait): Assume that rd_proc_pipe is set up correctly prior to call.
(_pinfo::alert_parent): Replace "wr_proc_pipe" with "my_wr_proc_pipe".
* pinfo.h (_pinfo::_wr_proc_pipe): Delete declaration.
(_pinfo::set_rd_proc_pipe): Define new function.
(pinfo::pending_rd_proc_pipe): Delete declaration.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wr_proc_pipe): Ditto.
* sigproc.cc (child_info::child_info): Clear rd_proc_pipe and wr_proc_pipe.
(child_info::cleanup): Close rd_proc_pipe and wr_proc_pipe if necessary.
(child_info_fork::child_info_fork): Set forker_finished to NULL by default.
(child_info_spawn::child_info_spawn): Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.
(child_info::sync): Ditto.
(child_info_spawn::cleanup): Call child_info::cleanup.
* spawn.cc (child_info_spawn::worker): Remove call to myself.prefork().  Set
wr_proc_pipe when execing or set up new rd_proc_pipe/wr_proc_pipe via
child_info::prefork when spawning.  Remove call to pinfo::postexec.  Set
rd_proc_pipe in child pinfo when spawning.  Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.  Remove call to postfork.
@
text
@a933 1
debug_printf ("%d exited buf %d\n", vchild->pid, buf);
@


1.302
log
@* pinfo.cc (pinfo_init): Cosmetic change: unset "destroy" for myself.
(pinfo::wait): Change some comments.
(pinfo::prefork): Move a comment.
(pinfo::postfork): Set pending_*_pipe variables to NULL if closed.
(pinfo::postexec): Use right name when closing handle.
(_pinfo::alert_parent): Ditto.
* sigproc.h (hold_everything): Remove debugging label.
@
text
@a51 3
HANDLE NO_COPY pinfo::pending_rd_proc_pipe;
HANDLE NO_COPY pinfo::pending_wr_proc_pipe;

a988 16
  /* If pending_rd_proc_pipe == NULL we're in an execed process which has
     already grabbed the read end of the pipe from the previous cygwin process
     running with this pid.  */
  if (pending_rd_proc_pipe)
    {
      /* Our end of the pipe, previously set in prefork() . */
      rd_proc_pipe = pending_rd_proc_pipe;
      pending_rd_proc_pipe = NULL;

      /* This sets wr_proc_pipe in the child which, after the following
	 ForceCloseHandle1, will be only process with the handle open.  */
      wr_proc_pipe () = pending_wr_proc_pipe;
      ForceCloseHandle1 (pending_wr_proc_pipe, wr_proc_pipe);
      pending_wr_proc_pipe = NULL;
    }

a1005 48
void
pinfo::prefork (bool detached)
{
  if (wr_proc_pipe () && wr_proc_pipe () != INVALID_HANDLE_VALUE
      && !SetHandleInformation (wr_proc_pipe (), HANDLE_FLAG_INHERIT, 0))
    api_fatal ("couldn't set process pipe(%p) inherit state, %E", wr_proc_pipe ());
  if (!detached)
    {
      if (!CreatePipe (&pending_rd_proc_pipe, &pending_wr_proc_pipe,
		       &sec_none_nih, 16))
	api_fatal ("Couldn't create pipe tracker for pid %d, %E", (*this)->pid);

      if (!SetHandleInformation (pending_wr_proc_pipe, HANDLE_FLAG_INHERIT,
				 HANDLE_FLAG_INHERIT))
	api_fatal ("prefork: couldn't set process pipe(%p) inherit state, %E",
		   pending_wr_proc_pipe);
      ProtectHandle1 (pending_rd_proc_pipe, rd_proc_pipe);
      ProtectHandle1 (pending_wr_proc_pipe, wr_proc_pipe);
    }
}

void
pinfo::postfork ()
{
  if (wr_proc_pipe () && wr_proc_pipe () != INVALID_HANDLE_VALUE
      && !SetHandleInformation (wr_proc_pipe (), HANDLE_FLAG_INHERIT,
			       HANDLE_FLAG_INHERIT))
    api_fatal ("postfork: couldn't set process pipe(%p) inherit state, %E", wr_proc_pipe ());
  if (pending_rd_proc_pipe)
    {
      ForceCloseHandle1 (pending_rd_proc_pipe, rd_proc_pipe);
      pending_rd_proc_pipe = NULL;
    }
  if (pending_wr_proc_pipe)
    {
      ForceCloseHandle1 (pending_wr_proc_pipe, wr_proc_pipe);
      pending_wr_proc_pipe = NULL;
    }
}

void
pinfo::postexec ()
{
  if (wr_proc_pipe () && wr_proc_pipe () != INVALID_HANDLE_VALUE
      && !ForceCloseHandle1 (wr_proc_pipe (), wr_proc_pipe))
    api_fatal ("postexec: couldn't close wr_proc_pipe(%p), %E", wr_proc_pipe ());
}

d1018 1
a1018 3
  if (wr_proc_pipe == INVALID_HANDLE_VALUE || !myself.wr_proc_pipe () || have_execed)
    /* no parent */;
  else
d1020 1
a1020 1
      if (WriteFile (wr_proc_pipe, &sig, 1, &nb, NULL))
d1027 2
a1028 2
	  HANDLE closeit = wr_proc_pipe;
	  wr_proc_pipe = INVALID_HANDLE_VALUE;
@


1.301
log
@* pinfo.cc (pinfo::wait): Handle case where prefork was not called prior to
calling wait().  This is the case when we are reabsorbing processes after being
execed.
@
text
@d120 1
d937 1
d992 3
d997 1
d1001 2
a1030 3
  /* If rd_proc_pipe != NULL we're in an execed process which already has
     grabbed the read end of the pipe from the previous cygwin process running
     with this pid.  */
d1054 4
a1057 1
    ForceCloseHandle1 (pending_rd_proc_pipe, rd_proc_pipe);
d1059 4
a1062 1
    ForceCloseHandle1 (pending_wr_proc_pipe, wr_proc_pipe);
d1069 1
a1069 1
      && !ForceCloseHandle (wr_proc_pipe ()))
d1098 1
a1098 1
	  CloseHandle (closeit);
@


1.300
log
@* fork.cc (lock_signals): Move to sigproc.h.
(lock_pthread): Ditto.
(hold_everything): Ditto.
(frok::parent): Call myself.prefork() just before calling CreateProcess.  Call
myself.postfork () on function exit.
* pinfo.cc (pinfo::pending_rd_proc_pipe): Define.
(pinfo::pending_wr_proc_pipe): Ditto.
(_pinfo::dup_proc_pipe): Delete.
(pinfo::wait): Move pipe creation into pinfo::prefork.  Set pipe variables from
pending_*.
(_pinfo::sync_proc_pipe): Delete.
(_pinfo::proc_pipe_owner): Ditto.
(pinfo::prefork): Define new function.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(_pinfo::alert_parent): Remove obsolete call to sync_proc_pipe.
(_pinfo::dup_proc_pipe): Delete declaration.
(_pinfo::sync_proc_pipe): Ditto.
(pinfo::pending_rd_proc_pipe): Declare.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Declare new function.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wr_proc_pipe): Define new wrapper function.
* sigproc.h: Include "sync.h".  Move locking functions from fork to here.
* spawn.cc (child_info_spawn::worker): Delete now-unneeded requirement to
record orig_wr_proc_pipe.  Call hold_everything prior to doing anything.  Call
myself.prefork() if spawning.  Replace wr_proc_pipe synchronization with call
to myself.postexec().  Call myself.postfork() if not execing.
* sync.h: Replace #ifdef wrapper with "#pragma once".
@
text
@d990 4
a993 2
  rd_proc_pipe = pending_rd_proc_pipe;
  pending_rd_proc_pipe = NULL;
d995 4
a998 3
  wr_proc_pipe () = pending_wr_proc_pipe;
  ForceCloseHandle1 (pending_wr_proc_pipe, wr_proc_pipe);
  pending_wr_proc_pipe = NULL;
@


1.299
log
@* pinfo.cc (_pinfo::dup_proc_pipe): Reorganize to provide more information for
failing condition.
(pinfo::wait): Pass name of function to dup_proc_pipe.  Eliminate error check
for dup_proc_pipe since it never actually returned an error.
* pinfo.h (_pinfo::dup_proc_pipe): Add an argument.
* spawn.cc (child_info_spawn::worker): Pass name of function to dup_proc_pipe.
@
text
@d52 3
a985 40
#ifdef DEBUGGING
#define warn_printf api_fatal
#else
#define warn_printf system_printf
#endif
HANDLE
_pinfo::dup_proc_pipe (HANDLE hProcess, const char *func)
{
  DWORD flags = DUPLICATE_SAME_ACCESS;
  HANDLE orig_wr_proc_pipe = wr_proc_pipe;
  /* Can't set DUPLICATE_CLOSE_SOURCE for exec case because we could be
     execing a non-cygwin process and we need to set the exit value before the
     parent sees it.  */
  if (this != myself || is_toplevel_proc)
    flags |= DUPLICATE_CLOSE_SOURCE;
  bool res = DuplicateHandle (GetCurrentProcess (), wr_proc_pipe,
			      hProcess, &wr_proc_pipe, 0, FALSE, flags);
  if (res)
    {
      wr_proc_pipe_owner = dwProcessId;
      sigproc_printf ("(%s) duped wr_proc_pipe %p for pid %d(%u)", func,
		      wr_proc_pipe, pid, dwProcessId);
    }
  else
    {
      DWORD duperr = GetLastError ();
      DWORD wfsores = WaitForSingleObject (hProcess, 0);
      if (wfsores != WAIT_OBJECT_0)
	{
	  warn_printf ("(%s) process synchronization failed for pid %u/%p, "
		       "wr_proc_pipe %p vs. %p: DuplicateHandle winerr %d, "
		       "WFSO returned %u, %E",
		       func, pid, hProcess, wr_proc_pipe, orig_wr_proc_pipe, duperr,
		       wfsores);
	}
      wr_proc_pipe = orig_wr_proc_pipe;
    }
  return orig_wr_proc_pipe;
}

d990 2
a991 13
  /* If rd_proc_pipe != NULL we're in an execed process which already has
     grabbed the read end of the pipe from the previous cygwin process running
     with this pid.  */
  if (!rd_proc_pipe)
    {
      /* FIXME: execed processes should be able to wait for pids that were started
	 by the process which execed them. */
      if (!CreatePipe (&rd_proc_pipe, &((*this)->wr_proc_pipe), &sec_none_nih, 16))
	{
	  system_printf ("Couldn't create pipe tracker for pid %d, %E",
			 (*this)->pid);
	  return false;
	}
d993 3
a995 2
      (*this)->dup_proc_pipe (hProcess, "pinfo::wait");
    }
d1015 38
a1052 1
_pinfo::sync_proc_pipe ()
d1054 3
a1056 3
  if (wr_proc_pipe && wr_proc_pipe != INVALID_HANDLE_VALUE)
    while (wr_proc_pipe_owner != GetCurrentProcessId ())
      yield ();
d1071 1
a1071 1
  if (wr_proc_pipe == INVALID_HANDLE_VALUE || !myself->wr_proc_pipe || have_execed)
a1074 1
      sync_proc_pipe ();
@


1.298
log
@	* pinfo.cc (_pinfo::dup_proc_pipe): Fix order of arguments in debug
	output.
@
text
@d989 1
a989 1
_pinfo::dup_proc_pipe (HANDLE hProcess)
d1000 1
a1000 1
  if (!res && WaitForSingleObject (hProcess, 0) != WAIT_OBJECT_0)
d1002 3
a1004 3
      wr_proc_pipe = orig_wr_proc_pipe;
      warn_printf ("something failed for pid %d: res %d, hProcess %p, wr_proc_pipe %p vs. %p, %E",
		   pid, res, hProcess, wr_proc_pipe, orig_wr_proc_pipe);
d1008 11
a1018 3
      wr_proc_pipe_owner = dwProcessId;
      sigproc_printf ("duped wr_proc_pipe %p for pid %d(%u)", wr_proc_pipe,
		      pid, dwProcessId);
d1041 1
a1041 5
      if (!(*this)->dup_proc_pipe (hProcess))
	{
	  system_printf ("Couldn't duplicate pipe topid %d(%p), %E", (*this)->pid, hProcess);
	  return false;
	}
@


1.297
log
@* pinfo.cc (_pinfo::set_ctty): Revert 2012-02-07 change to skip function if tty
in question == our ctty.
* syscalls.cc (setsid): Avoid two function calls.
* dtable.cc (dtable::dup_worker): Remove debugging.
* init.cc (search_for): Calculate for every new process rather than using
shared value.
(threadfunc_ix): Fill in for ever new process rather than sing shared value.
@
text
@d1004 1
a1004 1
		   res, pid, hProcess, wr_proc_pipe, orig_wr_proc_pipe);
@


1.296
log
@* cygheap.cc (init_cygheap::manage_console_count): Delete.
* cygheap.h (init_cygheap::manage_console_count): Ditto.
(init_cygheap::console_count): Ditto.
* fhandler.h (fhandler_console::has_a): Ditto.
(fhandler_console::free_console): Declare new function.
* fhandler_console.cc (fhandler_console::free_console): Define new function.
(fhandler_console::open_setup): Delete call to manage_console_count.
(fhandler_console::close): Ditto.  Replace with call to free_console().
* fhandler_tty.cc (fhandler_pty_slave::open): Delete call to
manage_console_count.
(fhandler_pty_slave::cleanup): Ditto.
(fhandler_pty_slave::close): Call fhandler_console::free_console() if this is
our controlling tty.
* pinfo.cc (_pinfo::set_ctty): Skip function if tty in question == our ctty.
Delete call to manage_console_count.
* syscalls.cc (close_all_files): Avoid locking and avoid setting errno when
iterating over fds.
@
text
@d438 1
a438 1
  if (fh && &tc && (ctty <= 0 || ctty != tc.ntty) && !(flags & O_NOCTTY))
d466 1
a466 3
	{
	  pgid = tc.getpgid ();
	}
@


1.295
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@d438 1
a438 1
  if (fh && &tc && (ctty <= 0 || ctty == tc.ntty) && !(flags & O_NOCTTY))
a456 1
	      cygheap->manage_console_count ("_pinfo::set_ctty", 1);
@


1.294
log
@* dtable.cc (dtable::stdio_init): Always initialize console when we have one.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use a better method to
print tty name for debugging.
(fhandler_termios::bg_check): Ditto.
* pinfo.cc (_pinfo::set_ctty): Remove leftover debugging stuff.  Simplify
behavior when setting tty's sid and pgid to avoid overwriting previously set
values.
* spawn.cc (ch_spawn): Cosmetic change.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.293
log
@	* pinfo.cc (pinfo_basic::pinfo_basic): Fix formatting.  Set uid and gid
	to default values to accommodate early initialization of shared user
	info.  Add comment.
@
text
@a435 3
debug_printf ("fh %p", fh);
debug_printf ("tc %p", fh->tc ());
if (!this || !fh->tc ()) try_to_debug ();
d466 1
a466 1
	  && myself->pgid == myself->pid && tc.getpgid () && tc.getsid ())
d468 1
a468 2
	  myself->pgid = tc.getpgid ();
	  myself->sid = tc.getsid ();
d471 12
a482 18
      pinfo p (tc.getsid ());
      if (sid == pid && (!p || p->pid == pid || !p->exists ()))
	{
#ifdef DEBUGGING
	  debug_printf ("resetting %s sid.  Was %d, now %d.  pgid was %d, now %d.",
			   __ctty (), tc.getsid (), sid, tc.getpgid (), pgid);
#else
	  paranoid_printf ("resetting %s sid.  Was %d, now %d.  pgid was %d, now %d.",
			   __ctty (), tc.getsid (), sid, tc.getpgid (), pgid);
#endif
	  /* We are the session leader */
	  tc.setsid (sid);
	  tc.setpgid (pgid);
	}
      else
	sid = tc.getsid ();
      if (tc.getpgid () == 0)
	  tc.setpgid (pgid);
@


1.292
log
@	Throughout use wincap.allocation_granularity instead of getpagesize.
	Throughout use wincap.page_size instead of getsystempagesize.
	Throughout use "status" as variable name to hold NTSTATUS values.
	* fhandler_mem.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	Fix debug_printf output.  Rectify long statements.  Fix comment
	formatting.
	* fhandler_proc.cc: Ditto.
	(format_proc_swaps): Drop useless test for ERROR_PROC_NOT_FOUND.
	* fhandler_process.cc: Ditto as in fhandler_mem.cc.
	(get_process_state): Rearrange allocation loop.  Use malloc/realloc.
	(get_mem_values): Fix potential NULL pointer usage.  Drop unused
	variable.
	* pinfo.cc (winpids::enum_processes): Handle low memory gracefully.
	* sec_auth.cc (get_priv_list): Drop local variable ret.
	* shared.cc (memory_init): Drop outdated call to getpagesize.
	* syscalls.cc (getsystempagesize): Remove.
	* sysconf.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	(sysinfo): Constify sizeof_stodi.  Drop useless test for
	ERROR_PROC_NOT_FOUND.
	* thread.cc (pthread_getattr_np): Cast pointers to uintptr_t rather
	than to int for pointer arithmetic.
	* winsup.h (getsystempagesize): Drop declaration.
@
text
@d39 1
a39 1
pinfo_basic::pinfo_basic()
d43 3
@


1.291
log
@Clean up whitespace.
@
text
@d1326 1
a1326 1
      static SYSTEM_PROCESSES *procs;
d1329 10
a1338 1
	procs = (SYSTEM_PROCESSES *) malloc (sizeof (*procs) + (szprocs = 200 * sizeof (*procs)));
a1339 1
      NTSTATUS res;
d1342 2
a1343 1
	  res = NtQuerySystemInformation (SystemProcessesAndThreadsInformation,
d1345 1
a1345 1
	  if (res == 0)
d1348 14
a1361 2
	  if (res == STATUS_INFO_LENGTH_MISMATCH)
	    procs =  (SYSTEM_PROCESSES *) realloc (procs, szprocs += 200 * sizeof (*procs));
d1364 2
a1365 1
	      system_printf ("error %p reading system process information", res);
d1370 1
a1370 1
      SYSTEM_PROCESSES *px = procs;
d1387 1
a1387 1
	  px = (SYSTEM_PROCESSES *) ((char *) px + px->NextEntryDelta);
@


1.290
log
@	* pinfo.cc (pinfo::exit): Call TerminateProcess to avoid potential
	busy loop in ntdll.dll when calling ExitProcess. Only call ExitProcess
	as a fallback.
@
text
@d389 1
a389 1
  wait_thread (NULL) 
@


1.289
log
@* exceptions.cc (sigpacket::process): Move signal_exit processing into...
(_cygtls::signal_exit): ...here.  Close my_readsig and comment on why.
* pinfo.cc (pinfo::exit): Move sigproc_terminate earlier.  Set exiting flag in
lock_process.
* sigproc.cc (my_readsig): Make global.
* sync.cc (muto::exiting_thread): Delete.
(muto::acquire): Delete #if 0'ed code.
* sync.h (muto::exiting_thread): Delete.
(set_exiting_thread): Ditto.
(lock_process::lock_process): Don't worry about setting the exiting thread
since it had no meaning.
@
text
@d213 2
@


1.288
log
@* cygthread.h (cygthread::name): Default name to "main" if we are early in the
process of setting up the DLL and no name is known.
* dcrt0.cc (initial_env): Remove CYGWIN_SLEEP stuff.
(get_cygwin_startup_info): Activate strace here as appropriate.
(dll_crt0_0): Move get_cygwin_startup_info as early as possible to avoid
missing strace output.
* fork.cc (frok::child): Move debugging statement to point where ppid will be
set.
* pinfo.cc (pinfo::thisproc): Remove obsolete call to strace.hello.  Tweak
debug output slightly.
* select.cc (select_stuff::wait): Allow APCS to be triggered while waiting
since we use them now.  Report when that happens.
* sigproc.cc (child_info::child_info): Use strace.active() rather than
strace.attached().
* spawn.cc (child_info_spawn::worker): Only write strace child pid when we know
it's a cygwin process.  Accommodate change to write_child argument list.
* strace.cc (strace::hello): Delete.  Move functionality...
(strace::activate): ...to here.
(mypid): Just use raw GetCurrentProcessId () if myself isn't set.
(strace::write_childpid): Don't wait for subproc_ready.  Remove arg which was
required for it.
* include/sys/strace.h (strace::hello): Delete.
(strace::write_childpid): Delete first argument.
@
text
@d184 2
a185 1
  lock_process until_exit ();
a195 1
  sigproc_terminate (ES_FINAL);
@


1.287
log
@* pinfo.cc (_pinfo::dup_proc_pipe): Fatalize a warning when debugging.
@
text
@d67 1
a67 2
  strace.hello ();
  debug_printf ("myself->dwProcessId %u", procinfo->dwProcessId);
@


1.286
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d992 5
d1012 2
a1013 2
      system_printf ("DuplicateHandle failed, pid %d, hProcess %p, wr_proc_pipe %p, %E",
		     pid, hProcess, wr_proc_pipe);
@


1.285
log
@* cygwin.din (ptsname_r): Export.
* fhandler.cc (fhandler_base::ptsname_r): Define.
* fhandler.h (fhandler_base::ptsname): Delete.
(fhandler_base::ptsname_r): Declare.
(fhandler_pty_master::ptsname_r): Declare.
* fhandler_tty.cc (fhandler_pty_master::ptsname): Delete.
(fhandler_pty_master::ptsname_r): New reentrant function derived from previous
ptsname.
* syscalls.cc (ptsname_r): Implement new function with functionality similar to
Linux.
(ptsname): Use ptsname_r () to fill out buf.
* include/cygwin/stdlib.h (ptsname_r): Declare.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 255 to reflect
export of ptsname_r.
* pinfo.cc (pinfo::wait): Return bool rather than int.
* pinfo.h (info::wait): Ditto.
(pinfo::reattach): Define !defined(_SIGPROC_H) case for consistency.
* sigproc.cc (child_info_spawn::reattach_children): Use correct dwProcessId
rather than pid when duplicating handle.
@
text
@d80 1
a80 1
  else if (cygheap->pid_handle)
d82 2
a83 2
      ForceCloseHandle (cygheap->pid_handle);
      cygheap->pid_handle = NULL;
d218 18
d254 1
a254 1
  if (!h0)
d352 1
a352 1
      release ();
d365 1
a365 1
      release ();
d386 29
d918 1
d932 3
a942 2
	  CloseHandle (vchild.rd_proc_pipe);
	  vchild.rd_proc_pipe = NULL;
d970 2
a971 9
      /* Special case:  If the "child process" that died is us, then we're
	 execing.  Just call proc_subproc directly and then exit this loop.
	 We're done here.  */
      if (hExeced)
	{
	  /* execing.  no signals available now. */
	  proc_subproc (PROC_CLEARWAIT, 0);
	  break;
	}
d1048 1
a1048 1
  cygthread *h = new cygthread (proc_waiter, this, "proc_waiter");
d1054 1
a1054 1
      sigproc_printf ("created tracking thread for pid %d, winpid %p, rd_pipe %p",
d1081 1
a1081 1
  if (wr_proc_pipe == INVALID_HANDLE_VALUE || !myself->wr_proc_pipe || hExeced)
d1104 13
a1116 11
  if (procinfo)
    {
      void *unmap_procinfo = procinfo;
      procinfo = NULL;
      UnmapViewOfFile (unmap_procinfo);
    }
  if (h)
    {
      HANDLE close_h = h;
      h = NULL;
      ForceCloseHandle1 (close_h, pinfo_shared_handle);
d1192 1
d1194 1
a1194 1
  /* Open a the process to prevent a subsequent exit from invalidating the
d1200 1
a1200 2
     make a copy of the shared memory area if it exists (it may not).
  */
d1273 1
a1273 2
	      if ((_pinfo *) p != (_pinfo *) myself)
		p.release ();
d1390 1
a1390 5
      {
	if (pinfolist[i])
	  pinfolist[i].release ();
	CloseHandle (pinfolist[i].hProcess);
      }
@


1.284
log
@* pinfo.cc (status_exit): Recognize STATUS_ILLEGAL_INSTRUCTION.
(child_info::proc_retry): Ditto.
@
text
@d978 1
a978 1
int
d981 1
a981 1
  /* If rd_proc_pipe that means we're in an execed process which already has
d992 1
a992 1
	  return 0;
d998 1
a998 1
	  return 0;
d1016 1
a1016 1
  return 1;
@


1.283
log
@* pinfo.cc (status_exit): Return complete error code.  Handle
STATUS_ACCESS_VIOLATION correctly.
(pinfo::set_exit_code): Set self->exitcode directly from status_exit.
@
text
@d143 3
@


1.282
log
@* child_info.h (cchildren): New struct.
(child_info_spawn::nchildren): Rename from nprocs.
(child_info_spawn::children): Change type to cchildren for more bookkeeping
possibilities.
(child_info_spawn::child_info_spawn): Clear nchildren.
(child_info_spawn::record_children): Declare new function.
(child_info_spawn::reattach_children): Ditto.
* dcrt0.cc (child_info_spawn::handle_spawn): Call reattach_children to gather
list of processes we are potentially waiting for.
* pinfo.h (pinfo::pinfo): Make sure that rd_proc_pipe is always cleared.
(pinfo::reattach): New function.
* sigproc.cc: Move pinfo.h earlier so that it can be used in sigproc.h.
(get_proc_lock): Don't bother with a lock during DLL initialization.
(proc_subproc): Handle PROC_REATTACH_CHILD.
(proc_terminate): Orphan children only when we are not an execed process or
when the pid is about to be occupied by a non-cygwin process.
(child_info_spawn::record_children): Define new function.
(child_info_spawn::reattach_children): Ditto.
* sigproc.h (procstuff): Define PROC_REATTACH_CHILD and renumber other
elements.
* spawn.cc (spawn_guts): Record any to-be-waited-for subprocesses if about to
exec a cygwin process.
* sigproc.cc (sig_send): Fix harmless transposition of fifth and six arguments
to DuplicateHandle().
(child_info::child_info): Ditto.
* globals.cc (hExeced): Make NO_COPY.
@
text
@d133 1
a133 1
	x = 127;
d138 4
a141 1
      x = 127;
d145 1
a145 1
      x = 127;
d147 1
a147 1
  return x;
d155 3
a157 2
    x = status_exit (x);
  self->exitcode = EXITCODE_SET | (sigExeced ?: (x & 0xff) << 8);
@


1.281
log
@* dtable.cc (dtable::delete_archetype): Improve debugging output.
(dtable::init_std_file_from_handle): Close console handle early, before
initialization.  Build up openflags for passing to open_setup, just to be safe.
(last_tty_dev): New variable.
(fh_last_tty_dev): New macro.
(fh_alloc): Try again to keep track of previously opened tty, this time by just
saving the device and using that to potentially open an archetype.  Avoid
setting the "/dev/tty" name if the creation of the fhandler failed.
(build_fh_pc): Remove unused second argument.  Reorganize how and where the
name is set.  Set last_tty_dev as appropriate.  Avoid a NULL dereference in a
debug printf.
* dtable.h (build_fh_pc): Reflect removal of second parameter.
* fhandler.cc (fhandler_base::reset): Use new '<<' operator to copy pc since it
preserves any potentially previously set name.
(fhandler_base::set_name): Ditto.
* fhandler.h (fhandler_*::clone): Throughout use ccalloc to allocate new
fhandler, primarily to make sure that pc field is properly zeroed.
(fhandler_termios::last): Eliminate.
(fhandler_termios): Remove setting of last.
(fhandler_base::~fhandler_termios): Ditto.
* fhandler_console.cc (fhandler_console::open): Don't make decisions about
opening close-on-exec handles here since it makes no sense for archetypes.
(fhandler_console::init): Assume that input handle has already been opened.
* fhandler_termios.cc (fhandler_termios::last): Delete.
* path.h (path_conv::eq_worker): New function.  Move bulk of operator = here.
(operator <<): New function.
(operator =): Use eq_worker to perform old functionality.
@
text
@d974 13
a986 8
  /* FIXME: execed processes should be able to wait for pids that were started
     by the process which execed them. */
  if (!CreatePipe (&rd_proc_pipe, &((*this)->wr_proc_pipe), &sec_none_nih, 16))
    {
      system_printf ("Couldn't create pipe tracker for pid %d, %E",
		     (*this)->pid);
      return 0;
    }
d988 5
a992 4
  if (!(*this)->dup_proc_pipe (hProcess))
    {
      system_printf ("Couldn't duplicate pipe topid %d(%p), %E", (*this)->pid, hProcess);
      return 0;
@


1.280
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d378 3
@


1.279
log
@	* miscfuncs.cc (CreatePipeOverlapped): New function.
	(ReadPipeOverlapped): Ditto.
	(WritePipeOverlapped): Ditto.
	* miscfuncs.h: Declare new functions.
	* pinfo.cc (commune_process): Call WritePipeOverlapped instead of
	WriteFile.  Set timeout to 1 sec.
	(_pinfo::commune_request): Call ReadPipeOverlapped instead of ReadFile.
	Set timeout to 0.5 secs.
	* sigproc.cc (sig_send): Create pipe using CreatePipeOverlapped.
@
text
@d375 2
a376 2
void
_pinfo::set_ctty (tty_min *tc, int flags, fhandler_termios *fh)
d378 3
a380 2
  debug_printf ("old %s, ctty device number %p, tc->ntty device number %p flags & O_NOCTTY %p", __ctty (), ctty, tc->ntty, flags & O_NOCTTY);
  if ((ctty <= 0 || ctty == tc->ntty) && !(flags & O_NOCTTY))
d382 1
a382 1
      ctty = tc->ntty;
d406 1
a406 1
		      __ctty (), sid, pid, pgid, tc->getpgid (), tc->getsid ());
d408 1
a408 1
	  && myself->pgid == myself->pid && tc->getpgid () && tc->getsid ())
d410 2
a411 2
	  myself->pgid = tc->getpgid ();
	  myself->sid = tc->getsid ();
d414 1
a414 1
      pinfo p (tc->getsid ());
d419 1
a419 1
			   __ctty (), tc->getsid (), sid, tc->getpgid (), pgid);
d422 1
a422 1
			   __ctty (), tc->getsid (), sid, tc->getpgid (), pgid);
d425 2
a426 2
	  tc->setsid (sid);
	  tc->setpgid (pgid);
d429 3
a431 3
	sid = tc->getsid ();
      if (tc->getpgid () == 0)
	  tc->setpgid (pgid);
d433 2
a434 1
    debug_printf ("cygheap->ctty now %p, archetype %p", cygheap->ctty, fh->archetype);
@


1.278
log
@	* (winpids::add): Make sure to store always a Windows PID in
	pidlist, even if pid is a Cygwin PID.
	(winpids::enum_processes): Fetch Cygwin processes from listing of
	shared cygwin object dir in the native NT namespace.  Only if winpid
	is true, fetch Windows processes using an additional call to
	NtQuerySystemInformation.
@
text
@d486 1
a486 1
	if (!WriteFile (tothem, &n, sizeof n, &nr, NULL))
d489 1
a489 1
	    sigproc_printf ("WriteFile sizeof argv failed, %E");
d493 1
a493 1
	    if (!WriteFile (tothem, *a, strlen (*a) + 1, &nr, NULL))
d495 2
a496 1
		sigproc_printf ("WriteFile arg %d failed, %E", a - argv);
d505 4
a508 4
	if (!WriteFile (tothem, &n, sizeof n, &nr, NULL))
	  sigproc_printf ("WriteFile sizeof cwd failed, %E");
	else if (!WriteFile (tothem, path, n, &nr, NULL))
	  sigproc_printf ("WriteFile cwd failed, %E");
d519 4
a522 4
	if (!WriteFile (tothem, &n, sizeof n, &nr, NULL))
	  sigproc_printf ("WriteFile sizeof root failed, %E");
	else if (!WriteFile (tothem, path, n, &nr, NULL))
	  sigproc_printf ("WriteFile root failed, %E");
d534 2
a535 2
	if (!WriteFile (tothem, &n, sizeof n, &nr, NULL))
	  sigproc_printf ("WriteFile sizeof fds failed, %E");
d538 1
a538 1
	    if (!WriteFile (tothem, &fd, sizeof fd, &nr, NULL))
d540 1
a540 1
		sigproc_printf ("WriteFile fd %d failed, %E", fd);
d556 4
a559 4
	      if (!WriteFile (tothem, &n, sizeof n, &nr, NULL))
		sigproc_printf ("WriteFile sizeof hdl failed, %E");
	      else if (!WriteFile (tothem, fh, n, &nr, NULL))
		sigproc_printf ("WriteFile hdl failed, %E");
d562 2
a563 2
	if (!n && !WriteFile (tothem, &n, sizeof n, &nr, NULL))
	  sigproc_printf ("WriteFile sizeof hdl failed, %E");
d576 4
a579 4
	if (!WriteFile (tothem, &n, sizeof n, &nr, NULL))
	  sigproc_printf ("WriteFile sizeof fd failed, %E");
	else if (!WriteFile (tothem, path, n, &nr, NULL))
	  sigproc_printf ("WriteFile fd failed, %E");
d659 2
a660 1
      if (!ReadFile (fromthem, &n, sizeof n, &nr, NULL) || nr != sizeof n)
d671 3
a673 1
	  for (p = res.s; n && ReadFile (fromthem, p, n, &nr, NULL); p += nr, n -= nr)
@


1.277
log
@* fhandler_console.cc (fhandler_console::set_unit): Set pc.file_attributes() to
reflect existence.
* fhandler.h (fhandler_pty_common::fhandler_pty_common): Ditto.
* pinfo.cc (_pinfo::set_ctty): Output device numbers in hex.
@
text
@d1215 1
a1215 1
    pidlist[nelem++] = pid;
a1220 3
  static DWORD szprocs;
  static SYSTEM_PROCESSES *procs;

d1222 10
a1231 2
  if (!szprocs)
    procs = (SYSTEM_PROCESSES *) malloc (sizeof (*procs) + (szprocs = 200 * sizeof (*procs)));
d1233 1
a1233 2
  NTSTATUS res;
  for (;;)
d1235 3
a1237 8
      res = NtQuerySystemInformation (SystemProcessesAndThreadsInformation,
				      procs, szprocs, NULL);
      if (res == 0)
	break;

      if (res == STATUS_INFO_LENGTH_MISMATCH)
	procs =  (SYSTEM_PROCESSES *) realloc (procs, szprocs += 200 * sizeof (*procs));
      else
d1239 8
a1246 2
	  system_printf ("error %p reading system process information", res);
	  return 0;
d1249 2
d1252 1
a1252 2
  SYSTEM_PROCESSES *px = procs;
  for (;;)
d1254 42
a1295 5
      if (px->ProcessId)
	add (nelem, winpid, px->ProcessId);
      if (!px->NextEntryDelta)
	break;
      px = (SYSTEM_PROCESSES *) ((char *) px + px->NextEntryDelta);
@


1.276
log
@* pinfo.cc (_pinfo::set_ctty): Don't reset myself->{pgid,sid} if terminal has
no pgid or sid settings.
@
text
@d378 1
a378 1
  debug_printf ("old %s, ctty %d, tc->ntty %d flags & O_NOCTTY %p", __ctty (), ctty, tc->ntty, flags & O_NOCTTY);
@


1.275
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Only raise SIGPIPE
when writing.
* fhandler.h: Include "tty.h".
(fhandler_termios::_tc): Rename from tc.
(fhandler_termios::tc): New method.
(fhandler_termios::tcinit): Remove an argument.
(fhandler_termios::get_ttyp): Use method to retrieve value.
(fhandler_console::console_state): Move here.
(fhandler_console::dev_state): Delete.
(fhandler_console::shared_console_info): Define.
(fhandler_console::open_shared_console): Move this function under
fhandler_console umbrella.
(fhandler_console::tc): Define.  Return static value.
(fhandler_console::focus_aware): Accommodate deletion of dev_state.
(fhandler_console): Add tty_list::get_cttyp as a friend.
* fhandler_console.cc (dev_state): Redefine as a pointer within
shared_console_info and change dev-> to dev.  throughout.
(fhandler_console::shared_console_info): Move into fhandler_console.
(fhandler_console::open_shared_console): Move into fhandler_console change
argument to simple bool.
(enum_windows): Accommodate changes to console_state and open_shared_console.
(console_unit::console_unit): Ditto.
(fhandler_console::get_tty_stuff): Accommodate change to dev_state.
(tty_list::get_cttyp): Accommodate change to
handler_console::shared_console_info.
(fhandler_console::read): Accommodate change from tc to tc ().
(fhandler_console::set_input_state): Ditto.
(fhandler_console::open): Accommodate tcinit argument change and change from tc
to tc().
(fhandler_console::input_tcsetattr): Accomodate change from tc to tc().
(fhandler_console::input_tcsetattr): Ditto.
(fhandler_console::write_normal): Ditto.
(fhandler_console::init): Ditto.
(fhandler_console::igncr_enabled): Ditto.
* fhandler_termios.cc (fhandler_termios::tcinit): Remove first argument.
Expect tc() to have been set up first.  Use tc() rather than tc.
(fhandler_termios::tcsetpgrp): Accomodate change from tc to tc().
(fhandler_termios::tcgetpgrp): Ditto.
(fhandler_termios::bg_check): Ditto.
(fhandler_termios::line_edit: Ditto.
(fhandler_tty_master::set_winsize): Ditto.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::init): Ditto.
(fhandler_pty_master::write): Ditto.
(fhandler_pty_master::setup): Ditto.  Accommodate change in arguments to
tcinit.
(fhandler_tty_slave::fch_open_handles): Set _tc directly.
(tty_min::is_orphaned_process_group): Don't assume that parent pid exists.
* pinfo.cc (_pinfo::set_ctty): Reset myself->{pgid,sid} here if we were started
by a non-Cygwin process but the tty exists.
* shared_info.h (console_state): Delete from here.
* tty.h: Make multiple inclusion safe.
@
text
@d407 1
a407 1
	  && myself->pgid == myself->pid)
@


1.274
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d406 6
@


1.273
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d190 1
a190 1
  if (myself->ctty >= 0 && myself->ctty != TTY_CONSOLE)
d193 1
a193 1
      tty *t = cygwin_shared->tty[myself->ctty];
d364 1
a364 3
  if (ctty == TTY_CONSOLE)
    strcpy (buf, "ctty /dev/console");
  else if (ctty < 0)
d367 5
a371 1
    __small_sprintf (buf, "ctty /dev/tty%d", ctty);
d379 1
a379 1
  if ((ctty < 0 || ctty == tc->ntty) && !(flags & O_NOCTTY))
d384 1
a384 1
	  debug_printf ("/dev/tty%d cygheap->ctty %p, archetype %p", ctty, cygheap->ctty, fh->archetype);
@


1.272
log
@* fork.cc (fork): Clear PID_REAPED.
* pinfo.cc (pinfo_init): Ditto.
(pinfo::init): Check for PID_REAPED.
* sigproc.cc (stopped_or_terminated): Ditto.
@
text
@d374 1
a374 1
_pinfo::set_ctty (tty_min *tc, int flags, fhandler_termios *arch)
d376 1
a376 1
  debug_printf ("old %s", __ctty ());
d380 21
a422 20
      if (cygheap->ctty != arch)
	{
	  debug_printf ("cygheap->ctty %p, arch %p", cygheap->ctty, arch);
	  if (!cygheap->ctty)
	    syscall_printf ("ctty NULL");
	  else
	    {
	      syscall_printf ("ctty %p, usecount %d", cygheap->ctty,
			      cygheap->ctty->usecount);
	      cygheap->ctty->close ();
	    }
	  cygheap->ctty = arch;
	  if (arch)
	    {
	      arch->usecount++;
	      /* guard ctty arch */
	      cygheap->manage_console_count ("_pinfo::set_ctty", 1);
	      report_tty_counts (cygheap->ctty, "ctty", "");
	    }
	}
d424 1
a424 1
    debug_printf ("cygheap->ctty now %p, arch %p", cygheap->ctty, arch);
@


1.271
log
@* pinfo.cc (_pinfo::exists): Check for PID_REAPED.
@
text
@d114 1
a114 1
  myself->process_state &= ~(PID_INITIALIZING | PID_EXITED);
d305 1
a305 1
      if (!created && createit && (procinfo->process_state & PID_EXITED))
d308 1
a308 1
			"procinfo->dwProcessid %u has PID_EXITED set",
@


1.270
log
@	* advapi32.cc (SetSecurityDescriptorDacl): Remove.
	(SetSecurityDescriptorGroup): Remove.
	(SetSecurityDescriptorOwner): Remove.
	* pinfo.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.

	* sec_helper.cc (__sec_user): Remove old comment.
@
text
@d431 1
a431 1
  return this && !(process_state & PID_EXITED);
@


1.269
log
@	* advapi32.cc (InitializeAcl): Remove.
	(AddAce): Remove.
	(FindFirstFreeAce): Remove.
	(GetAce): Remove.
	(InitializeSecurityDescriptor): Remove.
	(OpenProcessToken): Remove.
	* dcrt0.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* fhandler_tty.cc: Ditto.
	* flock.cc: Ditto.
	* pinfo.cc: Ditto.  Drop unnecessary error handling.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d354 3
a356 2
  if (!SetSecurityDescriptorDacl (&sd, TRUE, acl_buf, FALSE))
    debug_printf ("SetSecurityDescriptorDacl %E");
d358 1
a358 1
    debug_printf ("NtSetSecurityObject %lx", status);
@


1.268
log
@	* Fix various copyrights.
@
text
@d353 2
a354 3
  if (!InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION))
    debug_printf ("InitializeSecurityDescriptor %E");
  else if (!SetSecurityDescriptorDacl (&sd, TRUE, acl_buf, FALSE))
@


1.267
log
@* cygheap.h (init_cygheap::ctty): Use base class so that console can join in
the fun.
* dtable.cc (dtable::stdio_init): Remove special-case call to set_console_ctty
().
* exceptions.cc (sigpacket::process): Conditionally flush terminal input on
certain signals.
* fhandler.h (fhandler_console::get_tty_stuff): Make non-static.
(fhandler_termios::get_ttyp): Move here.
(fhandler_termios::sigflush): Declare.
(fhandler_tty_common::get_ttyp): Delete.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass this as "arch"
argument.
(set_console_ctty): Delete.
(tty_list::get_tty): Just return pointer to shared console region, delaying
get_tty_stuff until open().
(fhandler_console::init): Treat NULL handle as signifying that console should
be opened with O_NOCTTY flag.  Rename handle argument to the more common 'h'.
* fhandler_termios.cc (fhandler_termios::sigflush): Define.
* fhandler_tty.cc (handler_tty_master::init_console): Pass NULL as first
argument to fhandler_console::init.
* pinfo.cc (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
Add extra debugging.
* pinfo.h (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
* sigproc.cc (handle_sigsuspend): Don't special-case non-main threads.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
@


1.266
log
@* init.cc (search_for): Put this in shared section or suffer subtle problems
with the tls.
* pinfo.cc (status_exit): Add debug output to report on unexpected exit.
* tls_pbuf.cc (tmp_pathbuf::c_get): Add more details to internal error.
@
text
@d374 1
a374 1
_pinfo::set_ctty (tty_min *tc, int flags, fhandler_tty_slave *arch)
d423 1
@


1.265
log
@* pinfo.cc (pinfo::exit): Grab a tty lock before setting pgid.
@
text
@d141 1
@


1.264
log
@* pinfo.cc (pinfo::exit): Reset tty pgrp to zero if no more handles open.
(_pinfo::set_ctty): Remove debugging stuff.
@
text
@d191 1
@


1.263
log
@* dcrt0.cc (dll_crt0_0): Remove myself settings.
* fork.cc (fork): Set myself process_state
* pinfo.cc (pinfo_init): Ditto.
(pinfo::thisproc): Make sure any sendsig setting is correctly copied.
* pinfo.h: Update copyright.  Remove unused code.
@
text
@d189 6
a398 1
{debug_printf ("setting pgid to %d", pgid);
a399 1
}
@


1.262
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d65 1
d113 2
@


1.261
log
@* environ.cc (regopt): Change the first argument to wide char string.
(environ_init): Accommodate change to the first argument of regopt.
* exception.cc (open_stackdumpfile): Accommodate change to the type of progname
in _pinfo.
* external.cc (fillout_pinfo): Ditto.
* fhandler_process.cc (format_process_winexename): Ditto.
(format_process_stat): Ditto.
* fork.cc (fork::parent): Ditto.
* pinfo.cc (pinfo_basic::pinfo_basic): Call GetModuleFileNameW instead of
GetModuleFileName.
(pinfo::thisproc): Accommodate change to the type of progname in _pinfo.
(pinfo_init): Ditto.
* pinfo.h (_pinfo): Change the type of progname to a wide char array.
* registry.h (reg_key::get_int): Change the first argument from constant point
to pointer to constant.
(reg_key::get_string): Ditto.  Change the last argument likewise.
* registry.cc (reg_key::get_int): Accommodate change to the declaration.
(reg_key::get_string): Ditto.
* strace.cc (strace::hello): Accommodate change to the type of progname in
_pinfo.
(strace::vsprntf): Ditto.
@
text
@d965 1
a965 1
  cygthread *h = new cygthread (proc_waiter, 0, this, "proc_waiter");
@


1.260
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d42 1
a42 1
  GetModuleFileName (NULL, progname, sizeof (progname));
d65 1
a65 1
  strcpy (procinfo->progname, myself_initial.progname);
d124 3
a126 1
	path_conv pc (myself->progname, PC_NOWARN);
@


1.259
log
@* shared_info.h (open_shared): Create function wrapper for common use case.
(open_shared): Change fifth argument to a pointer rather than a reference.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Eliminate use of dummy
variable and call open_shared with constant.
* fhandler_process.cc (format_process_mounts): Ditto.
* pinfo.cc (pinfo::init): Pass pointer to shloc.
* shared.cc (shared_mem_inited): New variable.
(open_shared): Crate function wrapper for common use case.
(open_shared): Accommodate change to fifth argument to a pointer.
(shared_info::initialize): Remove spinlock test.  Simplify function.  Move
get_session_parent_dir call back here.
(memory_init): Protect global shared settings with shared_mem_inited spinlock.
Move get_session_parent_dir call to shared_info::initialize.
@
text
@d261 1
a261 1
	  low_priority_sleep (0);
d316 1
a316 1
	low_priority_sleep (0);
d981 1
a981 1
      low_priority_sleep (0);
@


1.258
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d239 1
a239 1
      procinfo = (_pinfo *) open_shared (L"cygpid", n, h0, mapsize, shloc,
@


1.257
log
@Consistently use va_end.

* external.cc (cygwin_internal): Use va_end.
* fork.cc (child_copy): Likewise.
* libc/bsdlib.cc (warn, warnx, err, errx): Likewise.
* pinfo.cc (commune_request): Likewise.
* strace.cc (strace::prntf, strace_printf): Likewise.
@
text
@d108 1
a108 1
      myself->nice = winprio_to_nice (GetPriorityClass (hMainProc));
d188 1
a188 1
  fill_rusage (&r, hMainProc);
d923 2
a924 2
  bool res = DuplicateHandle (hMainProc, wr_proc_pipe, hProcess, &wr_proc_pipe,
			      0, FALSE, flags);
@


1.256
log
@Support pseudo-reloc version 2
@
text
@a586 2
  va_start (args, code);

d596 1
d610 1
@


1.255
log
@Add cygwin wrapper for ExitProcess and TerminateProcess.
@
text
@d131 4
@


1.254
log
@* exceptions.cc: Move global variable sigExeced...
* globals.cc: here.
* pinfo.cc (pinfo::maybe_set_exit_code_from_windows): Remove now unneeded
declaration.
@
text
@d139 8
d158 1
a158 3
      if (x >= 0xc0000000UL)
	x = status_exit (x);
      self->exitcode = EXITCODE_SET | (sigExeced ?: (x & 0xff) << 8);
@


1.253
log
@* Makefile.in: Don't do anything special with any RCS directories.
* ntdll.h (PROCESSINFOCLASS): Remove unneeded trailing comma.
* pinfo.cc (_pinfo::dup_proc_pipe): Remove unneeded assignment.
* sigproc.cc (sig_send): Don't send signal to myself if this is an exec stub.
@
text
@a142 1
  extern int sigExeced;
@


1.252
log
@	* shared.cc (shared_name): New function for WCHAR names.
	(open_shared): Take name parameter as WCHAR.  Accommodate throughout.
	* shared_info.h ((CURR_SHARED_MAGIC): Redefine.
	(shared_name): Add declaration for function taking a WCHAR name.
	(open_shared): Change declaration according to above change.
	* pinfo.cc (pinfo::init) : Accommodate above change.
@
text
@a926 1
      res = true;
@


1.251
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d230 1
a230 1
      procinfo = (_pinfo *) open_shared ("cygpid", n, h0, mapsize, shloc,
@


1.250
log
@* glob_pattern_p.cc: New file.
* Makefile.in (DLL_OFILES): Add glob_pattern_p.o.
* glob.h: Add declaration for glob_pattern_p.
* pinfo.cc (pinfo::thisproc): Remove __stdcall attribute.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
a421 2
extern char **__argv;

a444 1
	extern int __argc_safe;
@


1.249
log
@* pinfo.h (pinfo::thisproc): Declare.  Rename from set_myself.
* pinfo.cc (pinfo::thisproc): Define.  Rename from set_myself.  Set procinfo to
NULL to avoid confusing subsequent init.
(pinfo_init): Accommodate set_myself -> pinfo::thisproc rename.
* dcrt0.cc (child_info_fork::handle_fork): Ditto.
(child_info_spawn::handle_spawn): Ditto.
@
text
@d54 1
a54 1
void __stdcall
@


1.248
log
@* pinfo.cc (pinfo_basic): New class.
(pinfo_basic::pinfo_basic): Define constructor for new class.
(myself): Initialize from myself_initial.
(set_myself): Set pid and progname from already myself_initial.
* strace.cc (strace::strace): Split apart strace::hello.  Send notification to
strace as early as possible.
(strace::hello): Just send clause which describes the current process.  This
can now be preceded by early initialization strace output.
* include/sys/strace.h (strace::strace): Declare new constructor.
@
text
@d55 1
a55 1
set_myself (HANDLE h)
d57 2
d62 4
a65 4
  myself.init (cygheap->pid, PID_IN_USE, h ?: INVALID_HANDLE_VALUE);
  myself->process_state |= PID_IN_USE;
  myself->dwProcessId = myself_initial.pid;
  strcpy (myself->progname, myself_initial.progname);
d67 1
a67 1
  debug_printf ("myself->dwProcessId %u", myself->dwProcessId);
d72 3
a74 3
      myself_identity.init (cygwin_pid (myself->dwProcessId), PID_EXECED, NULL);
      myself->exec_sendsig = NULL;
      myself->exec_dwProcessId = 0;
d78 1
a78 1
    myself->start_time = time (NULL); /* Register our starting time. */
d101 1
a101 1
      set_myself (NULL);
@


1.247
log
@Remove unneeded header files from source files throughout.
@
text
@d33 5
a37 1
static char NO_COPY pinfo_dummy[sizeof (_pinfo)] = {0};
d39 9
a47 1
pinfo NO_COPY myself ((_pinfo *)&pinfo_dummy);	// Avoid myself != NULL checks
d58 2
a59 1
    cygheap->pid = cygwin_pid (GetCurrentProcessId ());
d62 2
a63 3
  myself->dwProcessId = GetCurrentProcessId ();

  GetModuleFileName (NULL, myself->progname, sizeof (myself->progname));
@


1.246
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a14 3
#include <time.h>
#include <limits.h>
#include <stdarg.h>
a21 1
#include "cygwin_version.h"
a24 2
#include <sys/wait.h>
#include <ntdef.h>
a27 1
#include "fhandler.h"
a1051 1
#include <tlhelp32.h>
@


1.245
log
@	* Fix copyright dates.
@
text
@d13 1
@


1.244
log
@* hookapi.cc (find_first_notloaded_dll): New function.
* pinfo.cc (status_exit): New function.  Issue message when dll not found.  Use
find_first_notloaded_dll to find a nonexistent dll.
(pinfo::maybe_set_exit_code_from_windows): Call status_exit when exit code >=
0xc0000000UL.
* sigproc.cc (child_info::proc_retry): Return exit code when
STATUS_DLL_NOT_FOUND.
* spawn.cc (spawn_guts): Minor cleanup.
* syscalls.cc (close_all_files): Don't actually close stderr filehandle.  Just
make it noninheritable.
* winsup.h (find_first_notloaded_dll): Declare new function.
* ntdll.h: Add several missing NTSTATUS defines.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
@


1.243
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d107 22
d139 3
a141 3
      WaitForSingleObject (hProcess, INFINITE);	// just to be safe, in case
						// process hasn't quite exited
						// after closing pipe
d143 2
@


1.242
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d36 1
d396 2
a397 1
  char path[NT_MAX_PATH];
@


1.241
log
@	* dcrt0.cc (initial_env): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	(dll_crt0_1): Allocate new_argv0 with PATH_MAX size.
	* exceptions.cc (debugger_command): Set size to 2 * PATH_MAX + 20;
	(error_start_init): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	* external.cc (fillout_pinfo): Always fill out ep.progname 0-terminated.
	Fill out ep.progname_long.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Allocate
	buffer for executable filename with PATH_MAX size.
	* pinfo.cc: Throughout use PATH_MAX instead of CYG_MAX_PATH.
	* pinfo.h (class _pinfo): Set progname size to PATH_MAX.
	* smallprint.cc: Include limits.h.  Use PATH_MAX instead of CYG_MAX_PATH
	for path name buffer size.
	* strace.cc (strace::vsprntf): Ditto.
	* include/sys/cygwin.h (EXTERNAL_PINFO_VERSION_32_LP): Define.
	(EXTERNAL_PINFO_VERSION): Set to EXTERNAL_PINFO_VERSION_32_LP.
	(struct external_pinfo): Add progname_long member.
	* include/sys/dirent.h: Correctly include limits.h instead of
	sys/limits.h.
@
text
@d395 1
a395 1
  char path[PATH_MAX];
d442 1
a442 1
	unsigned int n = strlen (cygheap->cwd.get (path, 1, 1, PATH_MAX)) + 1;
d668 1
a668 1
	s = cfd->get_proc_fd_name ((char *) cmalloc_abort (HEAP_COMMUNE, PATH_MAX));
d739 2
a740 2
      s = (char *) cmalloc_abort (HEAP_COMMUNE, PATH_MAX);
      cygheap->cwd.get (s, 1, 1, PATH_MAX);
@


1.240
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d395 1
a395 1
  char path[CYG_MAX_PATH];
d442 1
a442 2
	unsigned int n = strlen (cygheap->cwd.get (path, 1, 1,
						   CYG_MAX_PATH)) + 1;
d573 1
a573 1
  char name_buf[CYG_MAX_PATH];
d668 1
a668 1
	s = cfd->get_proc_fd_name ((char *) cmalloc_abort (HEAP_COMMUNE, CYG_MAX_PATH));
d739 2
a740 2
      s = (char *) cmalloc_abort (HEAP_COMMUNE, CYG_MAX_PATH);
      cygheap->cwd.get (s, 1, 1, CYG_MAX_PATH);
@


1.239
log
@	* autoload.cc (SetUserObjectSecurity): Drop.
	* pinfo.cc (pinfo::set_acl): Use NtSetSecurityObject instead of
	SetKernelObjectSecurity.
	* spawn.cc (spawn_guts): Use NtSetSecurityObject instead of
	SetUserObjectSecurity.
	* uinfo.cc (cygheap_user::init): Ditto.
@
text
@d607 1
a607 1
	  res.s = (char *) cmalloc (HEAP_COMMUNE, n);
d669 1
a669 1
	s = cfd->get_proc_fd_name ((char *) cmalloc (HEAP_COMMUNE, CYG_MAX_PATH));
d695 1
a695 1
      s = (char *) cmalloc (HEAP_COMMUNE, n);
d740 1
a740 1
      s = (char *) cmalloc (HEAP_COMMUNE, CYG_MAX_PATH);
d765 1
a765 1
      p = s = (char *) cmalloc (HEAP_COMMUNE, n);
@


1.238
log
@Preliminary change to make fifos/pipes interruptible and fifos reliable.
* dtable.cc (dtable::find_fifo): Eliminate definition.
* dtable.h (dtable::find_fifo): Ditto for declaration.
* fhandler.cc (fhandler_base::raw_read): Remove pipe-specific stuff.
(fhandler_base::fhandler_base): Ditto.
(fhandler_base::close): Handle overlapped I/O structure if appropriate.
(fhandler_base::dup): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::setup_overlapped): Define new function.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::get_overlapped): Declare new function.
(fhandler_base::setup_overlapped): Ditto.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_guard): Eliminate.
(fhandler_pipe::*): Rework to eliminate most Win9x related cruft, removing many
variables and defining a new overlapped capability.
(fhandler_fifo::*): Ditto.
(fifo_state): Declare new enum.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove old Win9x stuff.
Initialize overlapped handle to NULL.
(fhandler_fifo::set_use): Eliminate.
(fhandler_fifo::open_nonserver): Define.
(fhandler_fifo::open): Rework to use named pipes and overlapped I/O.
(fhandler_fifo::wait): Define new function to wait for named pipe connection.
(fhandler_fifo::read): Rework to use wait() and new overlapped I/O
functionality.
(fhandler_fifo::write): Ditto.
(fhandler_fifo::dup): Eliminate.
* pinfo.cc (commune_process): Remove fifo handling.
(_pinfo::commune_request): Ditto.
* pinfo.h (picom): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Remove Win9x stuff.  Initialize
overlapped handle to NULL.
(fhandler_pipe::open): Eliminate Win9x stuff.
(fhandler_pipe::set_close_on_exec): Eliminate.
(read_pipe): Eliminate.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::fixup_after_exec): Ditto.
(fhandler_pipe::fixup_in_child): Ditto.
(fhandler_pipe::read): Rework to use overlapped I/O.
(fhandler_pipe::write): New function using overlapped I/O.
(fhandler_pipe::dup): Rework to eliminate Win9x stuff.
(fhandler_pipe::create_selectable): Rework to eliminate Win9x and use
overlapped I/O.
* select.cc (peek_pipe): Rework to eliminate Win9x stuff and use overlapped
I/O.
(fhandler_base::ready_for_read): Ditto.
@
text
@d294 1
d302 2
a303 2
  else if (!SetKernelObjectSecurity (h, DACL_SECURITY_INFORMATION, &sd))
    debug_printf ("SetKernelObjectSecurity %E");
@


1.237
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@a519 25
    case PICOM_FIFO:
      {
	sigproc_printf ("processing PICOM_FIFO for %s", si._si_commune._si_str);
	fhandler_fifo *fh = cygheap->fdtab.find_fifo (si._si_commune._si_str);
	HANDLE it[2];
	if (fh == NULL)
	  it[0] = it[1] = NULL;
	else
	  {
	    it[0] = fh->get_handle ();
	    it[1] = fh->get_output_handle ();
	  }

	debug_printf ("fifo %sfound %p, %p", fh ? "" : "not ", it[0], it[1]);
	if (!WriteFile (tothem, it, sizeof (it), &nr, NULL))
	  {
	    /*__seterrno ();*/	// this is run from the signal thread, so don't set errno
	    sigproc_printf ("WriteFile read handle failed, %E");
	  }
	WaitForSingleObject (process_sync, INFINITE);
	process_sync = NULL;
	if (fh)
	  fh->close_one_end ();
	break;
      }
a568 2
    case PICOM_FIFO:
      si._si_commune._si_str = va_arg (args, char *);
a617 20
    case PICOM_FIFO:
      {
	lock_process now ();
	DWORD x = ReadFile (fromthem, res.handles, sizeof (res.handles), &nr, NULL);
	if (!x || nr != sizeof (res.handles))
	  {
	    __seterrno ();
	    goto err;
	  }
	for (int i = 0; i < 2; i++)
	  if (!DuplicateHandle (hp, res.handles[i], hMainProc, &res.handles[i],
				0, false, DUPLICATE_SAME_ACCESS))
	    {
	      if (i)
		CloseHandle (res.handles[0]);
	      res.handles[0] = res.handles[1] = NULL;	/* FIXME: possibly left a handle open in child? */
	      goto err;
	    }
	break;
      }
@


1.236
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
d1207 1
a1207 1
winpids::enumNT (bool winpid)
a1245 27
DWORD
winpids::enum9x (bool winpid)
{
  DWORD nelem = 0;

  HANDLE h = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);
  if (!h)
    {
      system_printf ("Couldn't create process snapshot, %E");
      return 0;
    }

  PROCESSENTRY32 proc;
  proc.dwSize = sizeof (proc);

  if (Process32First (h, &proc))
    do
      {
	if (proc.th32ProcessID)
	  add (nelem, winpid, proc.th32ProcessID);
      }
    while (Process32Next (h, &proc));

  CloseHandle (h);
  return nelem;
}

d1250 1
a1250 1
  npids = (this->*enum_processes) (winpid);
d1259 1
a1259 6
  if (wincap.is_winnt ())
    enum_processes = &winpids::enumNT;
  else
    enum_processes = &winpids::enum9x;

  return (this->*enum_processes) (winpid);
@


1.235
log
@* pinfo.cc (set_myself): Use a more foolproof method for determining if the
current process was started from another cygiwn process.
@
text
@d402 1
a402 1
  lock_process now (false);
@


1.234
log
@	* dir.cc (mkdir): Check last path component for "..".
	(rmdir): Don't check last path component for "..".
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop kludge
	which tries to allow deleting the current working directory.
	* path.cc (has_dot_last_component): Add parameter to indicate testing
	for "..".  Take trailing slash into account.
	(symlink_info::posixify): Rely on cygheap->cwd.win32 having a
	useful value.
	(cwdstuff::init): Initialize cygheap->cwd with current working
	directory.  Change to windows_system_directory afterwards.
	(cwdstuff::set): Never call SetCurrentDirectory here.  Just check
	if changing into target directory would be allowed.  Add comment to
	explain why.
	* path.h (has_dot_last_component): Declare with second parameter.
	* pinfo.cc (pinfo::zap_cwd): Remove.
	(pinfo::exit): Drop call to zap_cwd.
	* pinfo.h (class pinfo): Remove declaration of zap_cwd.
	* spawn.cc (spawn_guts): Set current working directory for non-Cygwin
	child applications.  Drop call to zap_cwd.
@
text
@d67 2
a68 1
  else if (!myself->wr_proc_pipe)
@


1.233
log
@* pinfo.cc (_onreturn::~onreturn): Don't attempt to close a NULL handle.
@
text
@a125 10
pinfo::zap_cwd ()
{
  extern char windows_system_directory[];
  /* Move to an innocuous location to avoid a race with other processes
     that may want to manipulate the current directory before this
     process has completely exited.  */
  SetCurrentDirectory (windows_system_directory);
}

void
a140 1
  zap_cwd ();
@


1.232
log
@	* pinfo.cc (commune_process): Don't add extra \0 to cmdline.
	(_pinfo::cmdline): Ditto process internal.
@
text
@d1100 1
a1100 1
    if (h)
d1104 1
@


1.232.2.1
log
@	* pinfo.cc (_onreturn::~onreturn): Don't attempt to close a NULL
	handle.
@
text
@d1100 1
a1100 1
    if (h && *h)
a1103 1
	h = NULL;
@


1.232.2.2
log
@	* pinfo.cc (set_myself): Use a more foolproof method for determining if
	the current process was started from another cygiwn process.
@
text
@d67 1
a67 2
  else if (!child_proc_info)	/* child_proc_info is only set when this process
				   was started by another cygwin process */
d126 10
d151 1
@


1.232.2.3
log
@	Fix erroneous merge from HEAD.
@
text
@a126 10
pinfo::zap_cwd ()
{
  extern char windows_system_directory[];
  /* Move to an innocuous location to avoid a race with other processes
     that may want to manipulate the current directory before this
     process has completely exited.  */
  SetCurrentDirectory (windows_system_directory);
}

void
a141 1
  zap_cwd ();
@


1.231
log
@* dcrt0.cc (dll_crt0_0): Call tty_list::init_session here.
(dll_crt0_1): Reflect renaming from tty_init to tty::init_session.
(do_exit): Reflect moving of tty_terminate into tty_list.
* exceptions.cc (events_init): Move tty_mutex stuff elsewhere.
* fhandler_console.cc (set_console_title): Use lock_ttys class.
* fhandler_termios.cc (fhandler_termios::bg_check): Make debug output more
accurate.
* fhandler_tty.cc (fhandler_tty_slave::open): Reflect move of attach_tty into
tty_list class.  Don't attempt to grab master end of pty if master doesn't
exist.
(fhandler_pty_master::open): Reflect move of allocate_tty into tty_list class.
Use lock_ttys::release to release mutex.  Improve debugging output.
(fhandler_pty_master::setup): Remove if 0'ed block.  Fix argument to
SetNamedPipeHandleState.
* pinfo.cc (_pinfo::set_ctty): Lock ttys before setting sid/pgid.  Improve
debugging.  Add temporary debugging.
* tty.cc (tty_list::init_session): New function.
(tty::init_session): Rename from tty_init.  Reflect move of attach_tty to
tty_list class.
(tty::create_master): Rename from create_tty_master.
(tty_list::attach): Rename from attach_tty.  Reflect renaming of connect_tty to
connect.  Ditto for allocate_tty.
(tty_terminate): Delete.
(tty_list::terminate): Subsume tty_terminate.  Use lock_ttys rather than
manipulating mutex directly.
(tty_list::allocate): Rename from allocate_tty.  Use lock_ttys rather than
manipulating mutex directly.  Don't set sid here since linux apparently doesn't
do this.  Reflect move of create_tty_master into tty.
(lock_ttys::lock_ttys): Define new constructor.
(lock_ttys::release): New function.
* tty.h (tty::exists): Return false immediately if !master_pid.
(tty::set_master_closed): Define new function.
(tty::create_master): Ditto.
(tty::init_session): Ditto.
(tty_list::mutex): New field.
(tty_list::allocate): Define new function.
(tty_list::connect): Ditto.
(tty_list::attach): Ditto.
(tty_list::init_session): Ditto.
(lock_ttys): New class.
(tty_init): Delete declaration.
(tty_terminate): Ditto.
(attach_tty): Ditto.
(create_tty_master): Ditto.
@
text
@d421 1
a421 1
	unsigned n = 1;
a445 5
	if (!WriteFile (tothem, "", 1, &nr, NULL))
	  {
	    sigproc_printf ("WriteFile null failed, %E");
	    break;
	  }
d817 1
a817 1
      n = 1;
a826 1
      *p = '\0';
@


1.231.2.1
log
@	* pinfo.cc (commune_process): Don't add extra \0 to cmdline.
	(_pinfo::cmdline): Ditto process internal.
@
text
@d421 1
a421 1
	unsigned n = 0;
d446 5
d822 1
a822 1
      n = 0;
d832 1
@


1.230
log
@* child_info.h (_CI_SAW_CTRL_C): New enum.
(CURR_CHILD_INFO_MAGIC): Reset.
(saw_ctrl_c): New function.
(set_saw_ctrl_c): Ditto.
* sigproc.cc (child_info::proc_retry): Return EXITCODE_OK if we get
STATUS_CONTROL_C_EXIT and we actually saw a CTRL-C.
* spawn.cc (dwExeced): Delete.
(chExeced): New variable.
(spawn_guts): Set chExeced;
* exceptions.cc (dwExeced): Delete declaration.
(chExeced): Declare.
(ctrl_c_handler): Detect if we're an exec stub process and set a flag, if so.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Add extra
DEBUGGING test.
* pinfo.cc: Fix comment.
@
text
@d334 3
a336 2
      syscall_printf ("attached %s sid %d, pid %d, tty->pgid %d, tty->sid %d",
		      __ctty (), sid, pid, pgid, tc->getsid ());
d341 4
d347 1
d355 3
a357 1
	tc->setpgid (pgid);
@


1.229
log
@* fhandler_console.cc (fhandler_console::fixup_after_fork_exec): Make error
message more explicit.
* pinfo.cc (_pinfo::commune_request): Don't lock process unless we're looking
for fifos.
@
text
@d44 2
a45 2
/* Initialize the process table.
   This is done once when the dll is first loaded.  */
@


1.228
log
@* dcrt0.cc (dll_crt0_0): Call SetErrorMode earlier.
* pinfo.cc (_pinfo::dup_proc_pipe): Reset wr_proc_pipe on failure.  Return
previous pipe handle.
* pinfo.h (_pinfo::dup_proc_pipe): Reflect change to return value.
* spawn.cc (spawn_guts): Restore previous proc pipe on retry or if process
exits before synchronization.
@
text
@a605 1
  lock_process now ();
d654 1
@


1.227
log
@* pinfo.cc (commune_process): Fix randomly invalid pointer which caused fifos
to work incorrectly.
@
text
@d928 1
a928 1
bool
d941 5
a945 2
    system_printf ("DuplicateHandle failed, pid %d, hProcess %p, wr_proc_pipe %p, %E",
		   pid, hProcess, orig_wr_proc_pipe);
d953 1
a953 1
  return res;
@


1.226
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Regenerate.
(child_info::retry): Move here from fork subclass.
(child_info::exit_code): New field.
(child_info::retry_count): Max retry count for process start.
(child_info::proc_retry): Declare new function.
(child_info_fork::retry): Move to parent.
(child_info_fork::fork_retry): Ditto.
* dcrt0.cc (child_info::fork_retry): Rename and move.
(child_info_fork::handle_failure): Move.
(dll_crt0_0): Initialize console handler based on whether we have a controlling
tty or not.  Avoid nonsensical check for fork where it can never occur.
* environ.cc (set_proc_retry): Rename from set_fork_retry.  Set retry_count in
child_info.
(parse_thing): Reflect above change.
* exceptions.cc (dummy_ctrl_c_handler): Remove unused variable name.
(ctrl_c_handler): Always return TRUE for the annoying CTRL_LOGOFF_EVENT.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Remove call to
init_console_handler.
* fhandler_tty.cc (fhandler_tty_slave::open): Just call mange_console_count
here and let it decide what to do with initializing console control handling.
* fork.cc (fork_retry): Remove definition.
(frok::parent): Define static errbuf and use in error messages (not thread safe
yet).  Close pi.hThread as soon as possible.  Protect pi.hProcess as soon as
possible.  Don't set retry_count.  That happens automatically in the
constructor now.  Accommodate name change from fork_retry to proc_retry.
* init.cc (dll_entry): Turn off ctrl-c handling early until we know how it is
supposed to be handled.
* pinfo.cc (_pinfo::dup_proc_pipe): Remember original proc pipe value for
failure error message.  Tweak debug message slightly.
* sigproc.cc (child_info::retry_count): Define.
(child_info::child_info): Initialize retry count.
(child_info::sync): Set exit code if process dies before synchronization.
(child_info::proc_retry): Rename from child_info_fork::fork_retry.  Use
previously derived exit code.  Be more defensive about what is classified as an
error exit.
(child_info_fork::handle_failure): Move here from dcrt0.cc.
* spawn.cc (spawn_guts): Maintain error mode when starting new process to avoid
annoying pop ups.  Move deimpersonate call within new loop.  Move envblock
freeing to end.  Loop if process dies prematurely with bad exit code.
* syscalls.cc (init_console_handler): Remove hopefully unneeded call to
init_console_handler.
@
text
@d405 2
d529 1
a529 1
	sigproc_printf ("processing PICOM_FIFO");
@


1.225
log
@* fhandler_process.cc (format_process_stat): Use cygwin-derived start time even
on NT since it is the logical start time of the "process".
* pinfo.cc (set_myself): Don't set start time when it should have already been
set previously.
@
text
@d930 2
a931 1
  /* Grr.  Can't set DUPLICATE_CLOSE_SOURCE for exec case because we could be
d939 2
a940 1
    system_printf ("DuplicateHandle failed, pid %d, hProcess %p, %E", pid, hProcess);
d944 1
a944 1
      sigproc_printf ("closed wr_proc_pipe %p for pid %d(%u)", wr_proc_pipe,
@


1.224
log
@revert previously applied patch.
@
text
@a63 1
      myself->start_time = time (NULL); /* Register our starting time. */
@


1.223
log
@* times.cc (clock_getres): Use correct conversion from milliseconds to
seconds/nanoseconds.
(clock_setres): Use correct conversion to nanoseconds.
@
text
@d64 1
a64 1
      // myself->start_time = time (NULL); /* Register our starting time. */
@


1.222
log
@Always zero all elements of siginfo_t throughout.
* cygtls.h (_cygtls::thread_context): Declare new field.
(_cygtls::thread_id): Ditto.
(_cygtls::signal_exit): Move into this class.
(_cygtls::copy_context): Declare new function.
(_cygtls::signal_debugger): Ditto.
* cygtls.cc (_cygtls::init_thread): Fill out thread id field.
* exceptions.cc (exception): Change message when exception info is unknown.
Copy context to thread local storage.
(_cygtls::handle_exceptions): Avoid double test for fault_guarded.  Reflect
move of signal_exit to _cygtls class.
(sigpacket::process): Copy context to thread local storage.
(_cygtls::signal_exit): Move to _cygtls class.  Call signal_debugger to notify
debugger of exiting signal (WIP).  Call stackdump here (WIP).
(_cygtls::copy_context): Define new function.
(_cygtls::signal_debugger): Ditto.
* tlsoffsets.h: Regenerate.
* include/cygwin.h (_fpstate): New internal structure.
(ucontext): Declare new structure (WIP).
(__COPY_CONTEXT_SIZE): New define.
* exceptions.cc (_cygtls::interrupt_setup): Clear "threadkill" field when there
is no sigwaiting thread.
(setup_handler): Move event handling into interrupt_setup.
@
text
@d64 1
a64 1
      myself->start_time = time (NULL); /* Register our starting time. */
@


1.221
log
@	Bump copyright dates.
@
text
@d839 1
a839 1
  siginfo_t si;
a842 1
  si.si_errno = 0;
a845 3
#else
  si.si_utime = 0;
  si.si_stime = 0;
@


1.220
log
@* pinfo.cc (pinfo::exit): Swap signal and normal exit value when not started
from a cygwin process - just like the good-old-days of B20.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005
   Red Hat, Inc.
@


1.219
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@d161 1
a161 1
    exitcode >>= 8;
@


1.218
log
@* dcrt0.cc (__api_fatal): Simplify to just use strace mechamisms.
(do_exit): Move minimal_printf...
* pinfo.cc (pinfo::exit): ...into here.
* strace.cc (strace::vprntf): Guarantee output to the console when
system_printf/api_fatal.
* heap.cc (heap_init): Wait a second before issuing an error when
ERROR_INVALID_ADDRESS since this is probably due to a CTRL-C handler sneaking
in, using the memory that we want to use for the heap, and, eventually exiting.
@
text
@d57 1
a57 4
#ifndef DEBUGGING
  if (!strace.active)
#endif
    strace.hello ();
@


1.217
log
@* cygtls.cc (_cygtls::handle_threadlist_exception): Make an error fatal.
* cygtls.h (sockaddr_in): Use header rather than defining our own structure.
* exceptions.cc (_cygtls::interrupt_setup): Use exact contents of sa_mask
rather than assuming tht current sig should be masked, too.
(_cygtls::call_signal_handler): Use more aggressive locking.
* gendef (_sigbe): Wait until later before releasing incyg.
(_sigreturn): Remove more arguments to accommodate quasi-sa_sigaction support.
(_sigdelayed): Push arguments for sa_sigaction.  More work needed here.
* signal.cc (sigaction): Implement SA_NODEFER.
* tlsoffsets.h: Regenerate.

* sigproc.cc (wait_sig): Use default buffer size of Windows 9x complains.
* pinfo.cc (_onreturn::dummy_handle): Remove.
(_onreturn::h): Make this a pointer.
(_onreturn::~_onreturn): Detect whether pointer is NULL rather than value is
NULL.
(_onreturn::_onreturn): Set h to NULL initially.
(_onreturn::no_close_p_handle): Set h to NULL.
(winpids::add): Initialize onreturn with value from p.hProcess immediately.
@
text
@d142 1
@


1.216
log
@whitespace cleanup to force snapshot.
@
text
@d1094 1
a1094 2
  HANDLE& h;
  HANDLE dummy_handle;
d1100 2
a1101 2
	CloseHandle (h);
	h = NULL;
d1104 2
a1105 3
  void no_close_p_handle () {h = dummy_handle;}
  _onreturn (): h (dummy_handle), dummy_handle (NULL) {}
  void set (HANDLE& _h) {h = _h;}
a1110 2
  _onreturn onreturn;
  bool perform_copy = make_copy;
d1125 1
a1125 2

  p.init (cygpid, PID_NOREDIR | pinfo_access, NULL);
a1128 5
     Otherwise, if p is "false" then we couldn't open the shared memory region
     for the given pid, so close the handle to that process since we don't need to
     protect this pid while the shared memory is open.
     If p is true and we've opened the handle then things look good but we want
     to track the handle to eventually close it if things fall apart subsequently.
d1130 1
a1132 2
  else if (!p)
    CloseHandle (p.hProcess);
d1134 3
a1136 1
    onreturn.set (p.hProcess);
@


1.215
log
@* pinfo.cc (winpids::add): Increment nelem when winpid is true since we don't
care if it's a cygwin process in that case.
@
text
@d1179 1
a1179 1
     
d1186 1
a1186 1
     
@


1.214
log
@* pinfo.cc (winpids::release): Fix typo.
@
text
@a1216 1
      pidlist[nelem++] = pid;
d1218 2
@


1.213
log
@* pinfo.cc (pinfo::init): Clarify comment slightly.
(_onreturn): New helper class.
(winpids:add): Remove copied stuff.  Try to put process handle into pinfo in
question and use _onreturn class to control when to close it.
(winpids::release): Remove use of copied array.  Free procinfo when hProc is
NULL.  Otherwise call release and call CloseHandle on hProc.
* pinfo.h (winpids::copied): Remove throughout class.
@
text
@d1316 1
a1316 1
    else if (pinfolist[i].hProc)
d1320 1
a1320 1
	CloseHandle (pinfolist[i].hProc);
@


1.212
log
@* pinfo.cc (pinfo::init): Remove spurious low_priority_sleep.
@
text
@d259 4
a262 4
      /* In certain rare cases, it is possible for the shared memory region to
	 exist for a while after a process has exited.  This should only be a
	 brief occurrence, so rather than introduce some kind of locking
	 mechanism, just loop.  */
d265 2
a266 1
	  debug_printf ("looping because pid %d, procinfo->pid %d, procinfo->dwProcessid %u has PID_EXITED set",
d1092 17
a1108 1
#define size_copied(i) (sizeof (copied[0]) * ((i) + 1))
d1113 2
d1116 1
a1119 1
      copied = (bool *) realloc (copied, size_copied (npidlist + 1));
d1126 4
d1131 17
d1151 2
d1173 24
a1196 2
  copied[nelem] = false;
  if (make_copy && p)
d1198 6
a1203 2
      _pinfo *pnew = (_pinfo *) malloc (sizeof (*p.procinfo));
      if (pnew)
d1205 11
a1215 6
	  copied[nelem] = true;
	  *pnew = *p.procinfo;
	  if ((_pinfo *) p != (_pinfo *) myself)
	    p.release ();
	  p.procinfo = pnew;
	  p.destroy = false;
d1217 1
a1218 1
  pidlist[nelem++] = pid;
d1314 13
a1326 8
    if (pinfolist[i] && (_pinfo *) pinfolist[i] != (_pinfo *) myself)
      if (!copied[i])
	pinfolist[i].release ();
      else if ((p = pinfolist[i].procinfo))
	{
	  pinfolist[i].procinfo = NULL;
	  free (p);
	}
a1333 1
      free (copied);
@


1.211
log
@* pinfo.cc (winpids::add): Don't copy procinfo when there is no cygwin process
associated with the pid, i.e., procinfo == NULL.
@
text
@d259 4
a262 4
	/* In certain rare cases, it is possible for the shared memory region to
	   exist for a while after a process has exited.  This should only be a
	   brief occurrence, so rather than introduce some kind of locking
	   mechanism, just loop.  */
a266 1
	  low_priority_sleep (0);
@


1.210
log
@* pinfo.cc (size_copied): New convenience macro.
(winpids::add): Alias the element that we are working on for slightly better
clarity.  Honor the "make_copy" flag.
(winpids::release): Free and zero procinfo field if it was allocated via
malloc.
(winpids::~winpids): Free copied array.
* pinfo.h (class pinfo): Make winpids class a friend.
(winpids::make_copy): New field.
(winpids::copied): New array.
(winpids::reset): Reset npids after releasing pinfos or suffer a memory leak.
(winpids::winpids): Try harder to allocate all fields in the class.
@
text
@d1133 1
a1133 1
  if (make_copy)
@


1.209
log
@* fhandler_tty.cc (fhandler_tty_slave::open): Reset the current windows station
whenever ctty == -1 regardles of whetehr there's a windows station already
assigned.  Close the old windows station in this situation.
* pinfo.cc (_pinfo::set_ctty): Reinstate incrementing of console count when
recording ctty so that the current tty is always around.
@
text
@d1092 1
d1101 1
d1106 3
a1108 1
  pinfolist[nelem].init (cygpid, PID_NOREDIR | pinfo_access, NULL);
d1112 1
a1112 1
  if (!pinfolist[nelem])
d1116 2
a1117 2
      pinfolist[nelem].init (cygpid, PID_NOREDIR, NULL);
      if (!pinfolist[nelem])
d1124 1
a1124 1
    if (pinfolist[i]->pid == pinfolist[nelem]->pid)
d1126 2
a1127 2
	if ((_pinfo *) pinfolist[nelem] != (_pinfo *) myself)
	  pinfolist[nelem].release ();
d1132 14
d1240 1
d1243 7
a1249 1
      pinfolist[i].release ();
d1257 1
@


1.208
log
@* fork.cc (fork): Move top-of-stack calculation later.
* pinfo.cc (_pinfo::set_ctty): Use __ctty to print current console in debugging
output.
@
text
@d368 2
@


1.207
log
@* fhandler.h (fhandler_console::fixup_after_fork_exec): Declare new function.
(fhandler_console::fixup_after_fork): Use fixup_after_fork_exec.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Delete definition.
(fhandler_console::fixup_after_fork_exec): Rename from fixup_after_exec.
* pinfo.cc (_pinfo::set_ctty): Don't play with console count here.
* syscalls.cc (close_all_files): Don't close cygheap ctty if hExeced since the
child will be copying information from us.
(setsid): Use myctty() rather than raw ctty #.
@
text
@d333 1
a333 1
  debug_printf ("checking if /dev/tty%d changed", ctty);
d337 2
a338 2
      syscall_printf ("attached tty%d sid %d, pid %d, tty->pgid %d, tty->sid %d",
		      tc->ntty, sid, pid, pgid, tc->getsid ());
d343 2
a344 2
	  paranoid_printf ("resetting tty%d sid.  Was %d, now %d.  pgid was %d, now %d.",
			   tc->ntty, tc->getsid (), sid, tc->getpgid (), pgid);
@


1.206
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@a367 1
	      cygheap->manage_console_count ("pinfo::set_ctty", 1);
@


1.205
log
@* pinfo.cc (_pinfo::fds): Lock fdtab while enumerating.
@
text
@d318 12
d368 2
a369 2
	      cygheap->open_fhs++;
	      report_tty_counts (cygheap->ctty, "ctty", "incremented ", "");
@


1.204
log
@* pinfo.cc (_pinfo::dup_proc_pipe): Make warning more severe by actually
printing it.
(_pinfo::alert_parent): Fix comment.  Don't send to parent if we are in an exec
stub.
@
text
@d732 1
a732 1
      cygheap_fdenum cfd;
@


1.203
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d932 1
a932 1
    sigproc_printf ("DuplicateHandle failed, pid %d, hProcess %p, %E", pid, hProcess);
d993 7
a999 4
  /* Send something to our parent.  If the parent has gone away,
     close the pipe. */
  if (wr_proc_pipe == INVALID_HANDLE_VALUE
      || !myself->wr_proc_pipe)
@


1.202
log
@* cygheap.h (class process_lock): New class.
* dtable.h (class dtable): Add class process_lock as a friend.
* dcrt0.cc (get_exit_lock): Delete.
(do_exit): Use process_lock class instead of get_exit_lock.
* exceptions.cc (signal_exit): Ditto.
* pinfo.cc (pinfo::exit): Ditto.
(_pinfo::commune_process): Set process lock around this whole function.
(_pinfo::commune_request): Use process_lock rather than myself.lock.
* pinfo.h (pinfo::_lock): Delete.
(pinfo::initialize_lock): Delete.
(pinfo::lock): Delete.
(pinfo::unlock): Delete.
* winsup.h (get_exit_lock): Delete declaration.
@
text
@d142 1
a142 1
  process_lock until_exit ();
d144 1
d382 2
a383 2
void
_pinfo::commune_process (siginfo_t& si)
d385 1
d394 1
a394 1
  process_lock now (false);
d551 2
d594 1
a594 1
  process_lock now ();
d966 1
a966 1
  cygthread *h = new cygthread (proc_waiter, this, "proc_waiter");
@


1.201
log
@* dcrt0.cc (get_exit_lock): Use myself.lock rather than exit_lock.
* exceptions.cc (exit_lock): Delete.
(events_init): Don't init exit_lock.
* (_pinfo::commune_process): Add per-PICOM debugging.
* sigproc.cc (talktome): Add some temporary debugging statements.
* fhandler_proc.cc (format_proc_cpuinfo): Cosmetic change.
(format_proc_partitions): Ditto.
* syscalls.cc (locked_append): Ditto.
@
text
@a61 1
  myself.initialize_lock ();
d142 1
a142 1
  get_exit_lock ();
d392 2
d590 1
a590 1
  myself.lock ();
a668 2
  if (locked)
    myself.unlock ();
@


1.200
log
@* dcrt0.cc (do_exit): Don't set ES_SET_MUTO here.  Call get_exit_lock()
instead.
(get_exit_lock): New function.  Grabs the lock and sets initial exit_state.
* exceptions.cc (try_to_debug): Use low_priority_sleep.
(sigpacket::process): Avoid handler if this is an exec stub.
(signal_exit): Use get_exit_lock rather than manipulating the exit_lock
critical section directly.
* pinfo.cc (pinfo::exit): Ditto.
* winsup.h (get_exit_lock): Declare.
(exit_lock): Delete declaration.
@
text
@d397 1
d432 1
d443 1
d457 1
d476 20
a495 19
	{
	  HANDLE hdl = si._si_commune._si_pipe_fhandler;
	  unsigned int n = 0;
	  cygheap_fdenum cfd;
	  while (cfd.next () >= 0)
	    if (cfd->get_handle () == hdl)
	      {
		fhandler_pipe *fh = cfd;
		n = sizeof *fh;
		if (!WriteFile (tothem, &n, sizeof n, &nr, NULL))
		  sigproc_printf ("WriteFile sizeof hdl failed, %E");
		else if (!WriteFile (tothem, fh, n, &nr, NULL))
		  sigproc_printf ("WriteFile hdl failed, %E");
		break;
	      }
	  if (!n && !WriteFile (tothem, &n, sizeof n, &nr, NULL))
	    sigproc_printf ("WriteFile sizeof hdl failed, %E");
	  break;
	}
d498 1
d514 1
d540 5
a544 1
      WaitForSingleObject (process_sync, INFINITE);
d600 5
a604 1
    goto err;
@


1.199
log
@Change name from commune_recv to commune_process throughout.  Change name from
commune_send to commune_request throughout.
* pinfo.h (PICOM_EXTRASTR): New flag.
(PICOM_FIFO): Define with new flag.
(_pinfo::hello_pid): Delete.
(_pinfo::tothem): Delete.
(_pinfo::fromthem): Delete.
(_pinfo::commune_process): Rename from commune_recv.  Add a siginfo_t argument
to declaration.
(_pinfo::commune_request): Rename from commune_send.  Change DWORD to
__uint32_t in declaration.
* pinfo.cc (_pinfo::commune_process): Rename from commune_recv.  Add siginfo_t
argument.  Use information from argument rather than reading from another pipe.
Synchronize with other process's commune event.
(_pinfo::commune_request): Rename from commune_send.  Change DWORD to __uint32
in argument.  Fill out information in new siginfo_t element and rely on
extended operation of sig_send rather than trying to deal with synchronization
issues here.  Use process handle and read pipe information filled out by
sig_send to gather information from the other process.
* sigproc.cc (sig_send): Take special action if "communing" to ensure
synchronization with the other process and to return information about the
other process to the caller.
(talktome): Accept a siginfo_t and handle arguments.  Read additional
information from the signal pipe when _si_commune._si_code has the
PICOM_EXTRASTR flag set.
(wait_sig): Pass the transmitted siginfo_t struct and the pipe handle to
talktome.  Close pipe read handle as soon as possible after we detect that
we're exiting.
@
text
@d143 1
a143 1
  EnterCriticalSection (&exit_lock);
@


1.198
log
@	Revert erroneous checkin.
@
text
@d383 1
a383 1
_pinfo::commune_recv ()
d387 5
a391 4
  DWORD code;
  HANDLE hp;
  HANDLE __fromthem = NULL;
  HANDLE __tothem = NULL;
d393 1
a393 34
  hp = OpenProcess (PROCESS_DUP_HANDLE, false, dwProcessId);
  if (!hp)
    {
      sigproc_printf ("couldn't open handle for pid %d(%u)", pid, dwProcessId);
      hello_pid = -1;
      return;
    }
  if (!DuplicateHandle (hp, fromthem, hMainProc, &__fromthem, 0, false, DUPLICATE_SAME_ACCESS))
    {
      sigproc_printf ("couldn't duplicate fromthem, %E");
      CloseHandle (hp);
      hello_pid = -1;
      return;
    }

  if (!DuplicateHandle (hp, tothem, hMainProc, &__tothem, 0, false, DUPLICATE_SAME_ACCESS))
    {
      sigproc_printf ("couldn't duplicate tothem, %E");
      CloseHandle (__fromthem);
      CloseHandle (hp);
      hello_pid = -1;
      return;
    }

  hello_pid = 0;

  if (!ReadFile (__fromthem, &code, sizeof code, &nr, NULL) || nr != sizeof code)
    {
      CloseHandle (hp);
      /* __seterrno ();*/	// this is run from the signal thread, so don't set errno
      goto out;
    }

  switch (code)
a397 1
	CloseHandle (__fromthem); __fromthem = NULL;
a400 1
	CloseHandle (hp);
d410 1
a410 1
	if (!WriteFile (__tothem, &n, sizeof n, &nr, NULL))
d417 1
a417 1
	    if (!WriteFile (__tothem, *a, strlen (*a) + 1, &nr, NULL))
d422 1
a422 1
	if (!WriteFile (__tothem, "", 1, &nr, NULL))
a430 2
	CloseHandle (__fromthem); __fromthem = NULL;
	CloseHandle (hp);
d433 1
a433 1
	if (!WriteFile (__tothem, &n, sizeof n, &nr, NULL))
d435 1
a435 1
	else if (!WriteFile (__tothem, path, n, &nr, NULL))
d441 1
a441 3
	CloseHandle (__fromthem); __fromthem = NULL;
	CloseHandle (hp);
	unsigned int n;
d446 1
a446 1
	if (!WriteFile (__tothem, &n, sizeof n, &nr, NULL))
d448 1
a448 1
	else if (!WriteFile (__tothem, path, n, &nr, NULL))
a453 2
	CloseHandle (__fromthem); __fromthem = NULL;
	CloseHandle (hp);
d460 1
a460 1
	if (!WriteFile (__tothem, &n, sizeof n, &nr, NULL))
d464 1
a464 1
	    if (!WriteFile (__tothem, &fd, sizeof fd, &nr, NULL))
d473 1
a473 10
	  HANDLE hdl;
	  if (!ReadFile (__fromthem, &hdl, sizeof hdl, &nr, NULL)
	      || nr != sizeof hdl)
	    {
	      sigproc_printf ("ReadFile hdl failed, %E");
	      CloseHandle (hp);
	      goto out;
	    }
	  CloseHandle (__fromthem); __fromthem = NULL;
	  CloseHandle (hp);
d481 1
a481 1
		if (!WriteFile (__tothem, &n, sizeof n, &nr, NULL))
d483 1
a483 1
		else if (!WriteFile (__tothem, fh, n, &nr, NULL))
d485 1
d487 1
a487 1
	  if (!n && !WriteFile (__tothem, &n, sizeof n, &nr, NULL))
d493 1
a493 10
	int fd;
	if (!ReadFile (__fromthem, &fd, sizeof fd, &nr, NULL)
	    || nr != sizeof fd)
	  {
	    sigproc_printf ("ReadFile fd failed, %E");
	    CloseHandle (hp);
	    goto out;
	  }
	CloseHandle (__fromthem); __fromthem = NULL;
	CloseHandle (hp);
d500 1
a500 1
	if (!WriteFile (__tothem, &n, sizeof n, &nr, NULL))
d502 1
a502 1
	else if (!WriteFile (__tothem, path, n, &nr, NULL))
d508 1
a508 18
	unsigned len;
	if (!ReadFile (__fromthem, &len, sizeof len, &nr, NULL)
	    || nr != sizeof len)
	  {
	    CloseHandle (hp);
	    /* __seterrno ();*/	// this is run from the signal thread, so don't set errno
	    goto out;
	  }
	/* Get null-terminated path */
	if (!ReadFile (__fromthem, path, len, &nr, NULL)
	    || nr != len)
	  {
	    CloseHandle (hp);
	    /* __seterrno ();*/	// this is run from the signal thread, so don't set errno
	    goto out;
	  }

	fhandler_fifo *fh = cygheap->fdtab.find_fifo (path);
a515 9
	    for (int i = 0; i < 2; i++)
	      if (!DuplicateHandle (hMainProc, it[i], hp, &it[i], 0, false,
				    DUPLICATE_SAME_ACCESS))
		{
		  it[0] = it[1] = NULL;	/* FIXME: possibly left a handle open in child? */
		  break;
		}
	    debug_printf ("fifo found %p, %p", it[0], it[1]);
	    fh->close_one_end ();  /* FIXME: not quite right - need more handshaking */
d518 2
a519 2
	CloseHandle (hp);
	if (!WriteFile (__tothem, it, sizeof (it), &nr, NULL))
d524 4
a527 2

	ReadFile (__fromthem, &nr, sizeof (nr), &nr, NULL);
d531 6
a536 6

out:
  if (__fromthem)
    CloseHandle (__fromthem);
  if (__tothem)
    CloseHandle (__tothem);
a538 2
#define PIPEBUFSIZE (4096 * sizeof (DWORD))

d540 1
a540 1
_pinfo::commune_send (DWORD code, ...)
a541 2
  HANDLE fromthem = NULL, tome = NULL;
  HANDLE fromme = NULL, tothem = NULL;
d545 5
d561 3
a563 1
  if (!CreatePipe (&fromthem, &tome, &sec_all_nih, PIPEBUFSIZE))
d565 3
a567 19
      sigproc_printf ("first CreatePipe failed, %E");
      __seterrno ();
      goto err;
    }
  if (!CreatePipe (&fromme, &tothem, &sec_all_nih, PIPEBUFSIZE))
    {
      sigproc_printf ("second CreatePipe failed, %E");
      __seterrno ();
      goto err;
    }
  myself.lock ();
  myself->tothem = tome;
  myself->fromthem = fromme;
  myself->hello_pid = pid;
  if (!WriteFile (tothem, &code, sizeof code, &nr, NULL) || nr != sizeof code)
    {
      __seterrno ();
      goto err;
    }
d569 2
a570 7
  if (sig_send (this, __SIGCOMMUNE))
    goto err;

  /* FIXME: Need something better than an busy loop here */
  bool isalive;
  for (int i = 0; (isalive = alive ()) && (i < 10000); i++)
    if (myself->hello_pid <= 0)
a571 2
    else
      low_priority_sleep (0);
d573 4
a576 4
  CloseHandle (tome);
  tome = NULL;
  CloseHandle (fromme);
  fromme = NULL;
d578 8
a585 5
  if (!isalive)
    {
      set_errno (ESRCH);
      goto err;
    }
d587 3
a589 5
  if (myself->hello_pid < 0)
    {
      set_errno (ENOSYS);
      goto err;
    }
a593 22
    case PICOM_PIPE_FHANDLER:
      {
	HANDLE hdl = va_arg (args, HANDLE);
	if (!WriteFile (tothem, &hdl, sizeof hdl, &nr, NULL)
	    || nr != sizeof hdl)
	  {
	    __seterrno ();
	    goto err;
	  }
      }
      goto business_as_usual;
    case PICOM_FD:
      {
	int fd = va_arg (args, int);
	if (!WriteFile (tothem, &fd, sizeof fd, &nr, NULL)
	    || nr != sizeof fd)
	  {
	    __seterrno ();
	    goto err;
	  }
      }
      goto business_as_usual;
d598 2
a599 1
  business_as_usual:
d623 2
a624 4
	char *path = va_arg (args, char *);
	size_t len = strlen (path) + 1;
	if (!WriteFile (tothem, &len, sizeof (len), &nr, NULL)
	    || nr != sizeof (len))
d629 9
a637 16
	if (!WriteFile (tothem, path, len, &nr, NULL) || nr != len)
	  {
	    __seterrno ();
	    goto err;
	  }

	DWORD x = ReadFile (fromthem, res.handles, sizeof (res.handles), &nr, NULL);
	WriteFile (tothem, &x, sizeof (x), &x, NULL);
	if (!x)
	  goto err;

	if (nr != sizeof (res.handles))
	  {
	    set_errno (EPIPE);
	    goto err;
	  }
a640 2
  CloseHandle (tothem);
  CloseHandle (fromthem);
a643 8
  if (tome)
    CloseHandle (tome);
  if (fromthem)
    CloseHandle (fromthem);
  if (tothem)
    CloseHandle (tothem);
  if (fromme)
    CloseHandle (fromme);
d647 12
a658 2
  myself->hello_pid = 0;
  myself.unlock ();
d669 1
a669 1
  commune_result cr = commune_send (PICOM_PIPE_FHANDLER, hdl);
d682 1
a682 1
      commune_result cr = commune_send (PICOM_FD, fd);
d706 1
a706 1
      commune_result cr = commune_send (PICOM_FDS);
d734 1
a734 1
      commune_result cr = commune_send (PICOM_ROOT);
d757 1
a757 1
      commune_result cr = commune_send (PICOM_CWD);
d778 1
a778 1
      commune_result cr = commune_send (PICOM_CMDLINE);
@


1.197
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d388 3
d392 23
a414 6
  /* Don't remove.  It's necessary to copy to local variables for process
     synchronization. */
  HANDLE __fromthem = this->__fromthem;
  HANDLE __tothem = this->__tothem;
  HANDLE __them = this->__them;
  HANDLE __gotit = this->__gotit;
d416 1
a416 1
  SetEvent (__gotit);
d420 1
d434 1
d466 1
d478 1
d493 1
d518 1
d522 1
d546 1
d550 1
d569 1
d577 1
d591 1
a591 1
	      if (!DuplicateHandle (hMainProc, it[i], __them, &it[i], 0, false,
d601 1
d614 4
a617 4
  CloseHandle (__fromthem);
  CloseHandle (__tothem);
  CloseHandle (__them);
  CloseHandle (__gotit);
d666 12
a677 17
  {
    bool isalive = true;
    HANDLE w4[2] = { myself->gotit, myself->them };
    /* FIXME: How long should we wait here? */
    switch (WaitForMultipleObjects (2, w4, false, INFINITE))
      {
      case WAIT_OBJECT_0:
	myself->hello_pid = 0;
	break;
      case WAIT_OBJECT_0 + 1:
	isalive = false;
	break;
      default:
	debug_printf ("WFMO failed with %E");
	myself->hello_pid = -1;
	break;
      }
d679 5
a683 12
    CloseHandle (tome);
    tome = NULL;
    CloseHandle (fromme);
    fromme = NULL;
    CloseHandle (myself->them);
    myself->them = NULL;
    CloseHandle (myself->gotit);
    myself->gotit = NULL;
    myself->__tothem = NULL;
    myself->__fromthem = NULL;
    myself->__them = NULL;
    myself->__gotit = NULL;
d685 5
a689 5
    if (!isalive)
      {
	set_errno (ESRCH);
	goto err;
      }
a690 6
    if (myself->hello_pid < 0)
      {
	set_errno (ENOSYS);
	goto err;
      }
  }
a787 1
  tothem = fromthem = NULL;
a928 38
bool
_pinfo::send_descriptors (int cnt, int *fds)
{
  HANDLE target_proc;
  HANDLE my_proc;

  /* First try to create a handle of this process into the space of the
     target process which allows the target process to duplicate handles.
     If this fails, the target process will try the same. */
  for (int i = 0; i < cnt; ++i)
    {
      cygheap_fdget cfd (fds[i]);
      if (cfd < 0)
        {
	  set_errno (ENOENT);
	  goto fault;
	}
      
    }
  return true;

fault:
  destroy_inflight_descriptors ();
  return false;
}

void
_pinfo::destroy_inflight_descriptors ()
{
}

#if 0
bool
_pinfo::recv_descriptors ()
{
}
#endif

@


1.196
log
@* pinfo.cc (_pinfo::dup_proc_pipe): Ignore error if the child process has just
gone away.
@
text
@a387 3
  HANDLE hp;
  HANDLE __fromthem = NULL;
  HANDLE __tothem = NULL;
d389 6
a394 23
  hp = OpenProcess (PROCESS_DUP_HANDLE, false, dwProcessId);
  if (!hp)
    {
      sigproc_printf ("couldn't open handle for pid %d(%u)", pid, dwProcessId);
      hello_pid = -1;
      return;
    }
  if (!DuplicateHandle (hp, fromthem, hMainProc, &__fromthem, 0, false, DUPLICATE_SAME_ACCESS))
    {
      sigproc_printf ("couldn't duplicate fromthem, %E");
      CloseHandle (hp);
      hello_pid = -1;
      return;
    }

  if (!DuplicateHandle (hp, tothem, hMainProc, &__tothem, 0, false, DUPLICATE_SAME_ACCESS))
    {
      sigproc_printf ("couldn't duplicate tothem, %E");
      CloseHandle (__fromthem);
      CloseHandle (hp);
      hello_pid = -1;
      return;
    }
d396 1
a396 1
  hello_pid = 0;
a399 1
      CloseHandle (hp);
a412 1
	CloseHandle (hp);
a443 1
	CloseHandle (hp);
a454 1
	CloseHandle (hp);
a468 1
	CloseHandle (hp);
a492 1
	      CloseHandle (hp);
a495 1
	  CloseHandle (hp);
a518 1
	    CloseHandle (hp);
a521 1
	CloseHandle (hp);
a539 1
	    CloseHandle (hp);
a546 1
	    CloseHandle (hp);
d560 1
a560 1
	      if (!DuplicateHandle (hMainProc, it[i], hp, &it[i], 0, false,
a569 1
	CloseHandle (hp);
d582 4
a585 4
  if (__fromthem)
    CloseHandle (__fromthem);
  if (__tothem)
    CloseHandle (__tothem);
d634 17
a650 7
  /* FIXME: Need something better than an busy loop here */
  bool isalive;
  for (int i = 0; (isalive = alive ()) && (i < 10000); i++)
    if (myself->hello_pid <= 0)
      break;
    else
      low_priority_sleep (0);
d652 12
a663 4
  CloseHandle (tome);
  tome = NULL;
  CloseHandle (fromme);
  fromme = NULL;
d665 5
a669 11
  if (!isalive)
    {
      set_errno (ESRCH);
      goto err;
    }

  if (myself->hello_pid < 0)
    {
      set_errno (ENOSYS);
      goto err;
    }
d671 6
d774 1
d916 38
@


1.195
log
@* pinfo.cc (proc_waiter): Properly fill out si_code as according to SUSv3.
* exceptions.cc (handle_exceptions): Properly fill out si_code as according to
SUSv3.
@
text
@d1043 1
a1043 1
  if (!res)
d1050 1
@


1.194
log
@* sigproc.cc (wait_sig): Cosmetic change.
* pinfo.cc (pinfo::exit): Don't explicitly remove myself since some other
thread may still be using it.
@
text
@d942 1
a942 1
  si.si_code = SI_KERNEL;
d978 1
a978 1
	    si.si_sigval.sival_int = CLD_EXITED;
d980 1
a980 1
	    si.si_sigval.sival_int = CLD_DUMPED;
d982 1
a982 1
	    si.si_sigval.sival_int = CLD_KILLED;
d994 1
a994 1
	  si.si_sigval.sival_int = CLD_STOPPED;
@


1.193
log
@Semi-reversion of always-exit-from-sigthread change of 2005-09-15.
* exceptions.cc (sigpacket::process): Eliminate return after call to reinstated
noreturn function.
(signal_exit): Allow function to exit when a captive process has been
terminated.
* pinfo.cc (pinfo::exit): Enter exit_lock here.  Once again exit here under
control of exit_lock.
* sigproc.cc (sig_send): Don't wait for completion if process is exiting.
Remove special __SIGEXIT accommodations.
(wait_sig): Just exit the thread when a __SIGEXIT has been detected.  Don't
exit the process.
@
text
@a163 1
  release ();
@


1.192
log
@* pinfo.cc (pinfo::exit): Call ExitProcess if called from signal thread.
@
text
@d154 1
a160 7

  if (n != EXITCODE_NOSET)
    {
      zap_cwd ();
      self->alert_parent (0);		/* Shave a little time by telling our
					   parent that we have now exited.  */
    }
d164 3
a166 9

  _my_tls.stacklock = 0;
  _my_tls.stackptr = _my_tls.stack;
  sigproc_printf ("Calling ExitThread hProcess %p, n %p, exitcode %p",
		  hProcess, n, exitcode);
  if (&_my_tls == _sig_tls)
    ExitProcess (exitcode);
  else
    ExitThread (exitcode);
@


1.191
log
@* pinfo.cc (pinfo::exit): Eliminate use of _my_tls.thread_handle.
@
text
@d175 4
a178 1
  ExitThread (exitcode);
@


1.190
log
@* cygheap.cc (cygheap_fixup_in_child): It's not just for exec.
* cygtls.h (struct _cygtls::thread_handle): New field.
* dcrt0.cc (exit_lock): Remove declaration.
* winsup.h (exit_lock): Add declaration.
* exceptions.cc (sigpacket::process): Properly return after signal_exit.
* pinfo.cc (pinfo::exit): Only exit the process if _my_tls.thread_handle has
not been filled out -- which should be an impossible event.
* sigproc.cc (sigproc_terminate): Fillout _my_tls.thread_handle to provide
something for wait_sig to wait for.  Use the siginfo_t version of sig_send and
fill out the tls argument with _my_tls.
(wait_sig): Wait for the thread specified in pack.tls or (for now) complain
bitterly if it doesn't exit.
@
text
@d173 1
a173 8
  if (_my_tls.thread_handle)
    {
      sigproc_printf ("Calling ExitThread hProcess %p, n %p, exitcode %p",
		      hProcess, n, exitcode);
      ExitThread (exitcode);
    }

  sigproc_printf ("Calling ExitProcess since hMainthread is 0, hProcess %p, n %p, exitcode %p",
d175 1
a175 2
  release ();
  ExitProcess (exitcode);
@


1.189
log
@* pinfo.cc (set_myself): Call strace.hello unconditionally when DEBUGGING.
(pinfo::init): Sleep and issue debugging output before looping when a
PID_EXITED is found.
@
text
@d143 1
d156 1
a156 1
     parent here.  I hated to add a mutex just for this, though.  */
d173 1
a173 1
  if (&_my_tls == _main_tls)
a178 11
  else if (hMainThread)
    {
#if 0	/* This would be nice, but I don't think that Windows guarantees that
	   TerminateThread will not block. */
      sigproc_printf ("Calling TerminateThread since %p != %p, %p, n %p, exitcode %p",
		      &_my_tls, _main_tls, hProcess, n, exitcode);
      TerminateThread (hMainThread, exitcode);
      if (&_my_tls != _sig_tls)
	ExitThread (0);
#endif
    }
d182 1
a182 1
  // release ();  Could race with signal thread.  Sigh.
@


1.188
log
@* dcrt0.cc (do_exit): Only call sigproc_terminate from one location --
pinfo::exit.
* pinfo.cc (pinfo::exit): Move sigproc_terminate later so that signals can be
processed while waiting for hExeced child.
(pinfo::maybe_set_exit_code_from_windows): Set exit code from sigExeced if it
is non-zero.  Set exit_state to ES_EXEC_EXIT prior to waiting for captive
process exit code.
* exceptions.cc (sigExeced): New global variable.
(signal_exit): Remove noreturn attribute from declaration.
(signal_exit): Just terminate captive process and return if hExeced on the
theory that the exit will be subsequently handled in the main thread.
* sigproc.cc (sigproc_terminate): Eliminate test for ES_SIGPROCTERMINATE and
use ES_FINAL instead.
(sig_send): Use no_signals_available instead of duplicate test.
* winsup.h (ES_EXEC_EXIT): New enum.
(ES_SIGPROCTERMINATE): Delete.
@
text
@d57 1
d59 1
d292 6
a297 1
	goto loop;
@


1.187
log
@* exceptions.cc (sigtid): Remove declaration.
(handle_exceptions): Use _sig_tls rather than sigtid to determine if this is
the signal thread.
(set_signal_mask): Ditto for conditionalized CGF code.
* pinfo.cc (pinfo::exit): Exit the thread if we forcefully terminated the main
thread
* sigproc.cc (sigtid): Delete.
(_sig_tls): Define.
(sig_clear): Use _sig_tls rather than sigtid to determine if this is the signal
thread.
(sig_dispatch_pending): Ditto.
(wait_sig): Set _sig_tls here.
* dcrt0.cc (do_exit): Move sigproc_terminate call later since signal handling
was still needed for subsequent stuff.  Call sigproc_terminate with new
exit_state value.
* pinfo.cc (pinfo::exit): Call sigproc_terminate with new exit_state value.
* sigproc.cc (proc_terminate): Remove unnecessary (void) parameter.
(sigproc_terminate): Ditto.  Add new argument to accept exit state to be set.
(wait_sig): Reorganize __SIGEXIT handling.  Add more debugging output.
* winsup.h (sigproc_terminate): Declare with new exit_state argument.
(exit_states): Reorganize to reflect new exit ordering of sigproc_terminate.
@
text
@d114 2
d122 1
a122 1
      self->exitcode = EXITCODE_SET | (x & 0xff) << 8;
a140 2
  sigproc_terminate (ES_FINAL);

d144 7
a157 2
  maybe_set_exit_code_from_windows ();

@


1.186
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@d139 1
a139 2
  sigproc_terminate ();
  exit_state = ES_FINAL;
d167 1
a167 1
      sigproc_printf ("Calling ExitProcess hProcess %p, n %p, exitcode %p",
d173 2
d178 3
d185 1
a185 1
  release ();
@


1.185
log
@* cygheap.cc (cygheap_init): Eliminate debugging #if.
* fork.cc (fork_parent): Don't issue errors if "somebody" has set the
PID_EXITED flag on a child.  Don't close process handle if it has potentially
already been closed.
* pinfo.cc (winpids::add): Eliminate PID_ALLPIDS handling which was obsoleted
by previous changes.
* spawn.cc (av::fixup): Do win16 detection for .com files.  Make sure that
buffer has been unmapped in all cases.
@
text
@d139 1
d141 1
d144 1
a144 4
    {
      sigproc_terminate ();		/* Just terminate signal and process stuff */
      self->exitcode = EXITCODE_SET | n;/* We're really exiting.  Record the UNIX exit code. */
    }
a162 1
  release ();
d166 14
a179 1
  sigproc_printf ("Calling ExitProcess hProcess %p, n %p, exitcode %p",
d181 1
@


1.184
log
@Grr.  REVERT erroneous checkin.  AGAIN.
@
text
@d1199 1
a1199 2
  pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0)
			 | pinfo_access, NULL);
d1207 1
a1207 1
      pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0), NULL);
@


1.183
log
@* Makefile.in (CXXFLAGS): Use 'override' to correctly set flags to generate
dependencies when invoked from top-level make.
@
text
@d1199 2
a1200 1
  pinfolist[nelem].init (cygpid, PID_NOREDIR | pinfo_access, NULL);
d1208 1
a1208 1
      pinfolist[nelem].init (cygpid, PID_NOREDIR, NULL);
@


1.182
log
@revert inexplicable previous checkin
@
text
@d1199 1
a1199 2
  pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0)
			 | pinfo_access, NULL);
d1207 1
a1207 1
      pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0), NULL);
@


1.181
log
@bad_addresses
@
text
@d1199 2
a1200 1
  pinfolist[nelem].init (cygpid, PID_NOREDIR | pinfo_access, NULL);
d1208 1
a1208 1
      pinfolist[nelem].init (cygpid, PID_NOREDIR, NULL);
@


1.180
log
@* fhandler_virtual.cc (fhandler_virtual::close): Don't free filebuf if it's
NULL.
* pinfo.cc (_pinfo::commune_send): Fix test for incorrect number of bytes read
from pipe.
@
text
@d1199 1
a1199 2
  pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0)
			 | pinfo_access, NULL);
d1207 1
a1207 1
      pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0), NULL);
@


1.179
log
@* cygheap.h (cygheap_types): Add HEAP_COMMUNE.
* fhandler_proc.cc: Use cygheap rather than user heap for allocation of filebuf
throughout.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_process.cc: Ditto.
(get_mem_values): Use malloc/realloc/free rather than new.
* pinfo.cc (_pinfo::commune_send): Allocate on cygwin heap rather than user
heap.  Avoid calling ReadFile when correct number of characters have been read
or suffer buffer corruption.
(_pinfo::fd): Allocate on cygwin heap rather than user heap.
(_pinfo::fds): Ditto.
(_pinfo::root): Ditto.
(_pinfo::cwd): Ditto.
(_pinfo::cmdline): Ditto.
* devices.h (FH_DEV): New define.
* devices.in: Detect lone /dev.
* devices.cc: Regenerate.
* path.cc (path_conv::check): Treat FH_DEV as a special case.
@
text
@d734 1
a734 1
	  if ((unsigned) (p - res.s) != n)
d739 1
a740 1
      res.n = n;
@


1.178
log
@* include/endian.h: Move everything into this file and define things more like
linux.
* include/cygwin/types.h: Include endian.h.
* include/sys/dirent.h: Define DT_* types and conversion macros.
* pinfo.cc (pinfo::init): Remove special handling for PID_ALLPIDS and execed
code, even though it probably still isn't quite right.
@
text
@d730 1
a730 1
	  res.s = (char *) malloc (n);
d732 1
a732 1
	  for (p = res.s; ReadFile (fromthem, p, n, &nr, NULL); p += nr)
d820 1
a820 1
	s = strdup ("");
d822 1
a822 1
	s = cfd->get_proc_fd_name ((char *) malloc (CYG_MAX_PATH));
d848 1
a848 1
      s = (char *) malloc (n);
d871 1
a871 1
	s = strdup (cygheap->root.posix_path ());
d873 1
a873 1
	s = strdup ("/");
d893 1
a893 1
      s = (char *) malloc (CYG_MAX_PATH);
d918 1
a918 1
      p = s = (char *) malloc (n);
@


1.177
log
@* pinfo.cc (pinfo::init): Put back accidentally removed debug_printf.
@
text
@a257 5
	  if ((flag & PID_ALLPIDS))
	    {
	      set_errno (ESRCH);
	      break;
	    }
@


1.176
log
@* pinfo.cc (pinfo::init): Sleep before retrying open_shared().
@
text
@d236 1
@


1.175
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d236 1
a236 2

	  debug_printf ("MapViewOfFileEx h0 %p, i %d failed, %E", h0, i);
@


1.174
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d56 1
a56 1
  (void) GetModuleFileName (NULL, myself->progname, sizeof (myself->progname));
d133 1
a133 1
  (void) SetCurrentDirectory (windows_system_directory);
d613 1
a613 1
	(void) ReadFile (__fromthem, &nr, sizeof (nr), &nr, NULL);
d764 1
a764 1
	(void) WriteFile (tothem, &x, sizeof (x), &x, NULL);
@


1.173
log
@	* pinfo.cc (pinfo::init): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	(pinfo::set_acl): Replace sa_buf by dynamically allocated acl_buf.
	* sec_acl.cc (setacl): Allocate acl dynamically.
	* sec_helper.cc (sec_acl): Add test for alignment of acl when
	DEBUGGING is defined.
	(__sec_user): Same for sa_buf.
	* security.cc (verify_token): Define sd_buf as PSECURITY_DESCRIPTOR
	and allocate dynamically.
	(alloc_sd): Allocate acl dynamically.
	security.h (sec_user_nih): Change first parameter to
	SECURITY_ATTRIBUTES *.
	(sec_user): Ditto.
	* sigproc.cc (wait_sig): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	* syscalls.cc (seteuid32): Define dacl_buf as PACL and allocate
	dynamically.
	* uinfo.cc (cygheap_user::init): Define sa_buf as PSECURITY_ATTRIBUTES
	and allocate dynamically.
	* winbase.h (ilockincr): Mark first argument of inline assembly as
	earlyclobber.
	(ilockdecr): Ditto.
@
text
@a962 1
      extern HANDLE hExeced;
@


1.172
log
@white space and minor comment cleanup.
@
text
@d202 1
a202 1
  char sa_buf[1024];
d310 1
a310 1
  char sa_buf[1024];
d313 1
a313 1
  sec_acl ((PACL) sa_buf, true, true, cygheap->user.sid (),
d317 1
a317 1
  else if (!SetSecurityDescriptorDacl (&sd, TRUE, (PACL) sa_buf, FALSE))
@


1.171
log
@* shared_info.h (cygwin_shared_address): Bump to a higher value to avoid
collision with large data areas.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Accommodate changes to
open_shared arguments.
* fhandler_tape.cc (mtinfo_init): Ditto.
* pinfo.cc (pinfo::init): Use open_shared rather than win32 mmap calls.
* shared.cc (user_shared_initialize): Ditto.
(memory_init): Ditto.
(open_shared): Change to allow use a smore general mmap handler.
* shared_info.h (shared_locations): Add SH_JUSTCREATE, SH_JUSTOPEN.
(open_shared): Change declaration to match new usage.
* autoload.cc (LoadDLLfuncEx2): Define in terms of LoadDLLfuncEx3.
(LoadDLLfuncEx3): New macro.
@
text
@d117 1
a117 1
      						// process hasn't quite exited
d470 1
a470 1
        CloseHandle (__fromthem); __fromthem = NULL;
d482 1
a482 1
        CloseHandle (__fromthem); __fromthem = NULL;
d497 1
a497 1
        CloseHandle (__fromthem); __fromthem = NULL;
d514 1
a514 1
        break;
d566 1
a566 1
        break;
d732 1
a732 1
        res.s = NULL;
d734 1
a734 1
        {
d744 1
a744 1
        }
@


1.170
log
@* fhandler.cc (fhandler_base::read): Remove unused signal state tweaks.
* fhandler.h (fhandler_pipe::create_selectable): Declare.
(fhandler_fifo::close_one_end): Declare.
* fhandler_fifo.cc (fhandler_fifo::close_one_end): Define.
(fhandler_fifo::open_not_mine): Use close_one_end to close appropriate end of
pipe.
* pinfo.cc (_pinfo::commune_recv): Ditto.
* pipe.cc (fhandler_pipe::create_selectable): Rename from
create_selectable_pipe.  Reorganize.
(fhandler_pipe::create): Use create_selectable.
@
text
@d177 1
a188 1
  bool created = false;
d193 1
a193 1
    mapaddr = NULL;
d196 1
a196 2
      /* Try to enforce that myself is always created in the same place */
      mapaddr = open_shared (NULL, 0, h0, 0, SH_MYSELF);
d202 5
d209 8
d219 3
a221 31
	  char mapname[CYG_MAX_PATH];
	  shared_name (mapname, "cygpid", n);

	  int mapsize;
	  if (flag & PID_EXECED)
	    mapsize = PINFO_REDIR_SIZE;
	  else
	    mapsize = sizeof (_pinfo);

	  if (!createit)
	    {
	      h0 = OpenFileMapping (access, FALSE, mapname);
	      created = false;
	    }
	  else
	    {
	      char sa_buf[1024];
	      PSECURITY_ATTRIBUTES sec_attribs =
		sec_user_nih (sa_buf, cygheap->user.sid(), well_known_world_sid,
			      FILE_MAP_READ);
	      h0 = CreateFileMapping (INVALID_HANDLE_VALUE, sec_attribs,
				      PAGE_READWRITE, 0, mapsize, mapname);
	      created = GetLastError () != ERROR_ALREADY_EXISTS;
	    }

	  if (!h0)
	    {
	      if (createit)
		__seterrno ();
	      return;
	    }
a223 2
      procinfo = (_pinfo *) MapViewOfFileEx (h0, access, 0, 0, 0, mapaddr);

d229 7
a235 2
	  if (GetLastError () == ERROR_INVALID_HANDLE)
	    api_fatal ("MapViewOfFileEx h0 %p, i %d failed, %E", h0, i);
d241 2
@


1.169
log
@Actually check in files.
@
text
@d614 1
@


1.168
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@d613 1
@


1.167
log
@* pinfo.cc (pinfo::exit): Right shift exit value by eight when not started in a
cygwin environment.
@
text
@d401 1
a401 1
  char path[CYG_MAX_PATH + 1];
d836 1
a836 1
	s = cfd->get_proc_fd_name ((char *) malloc (CYG_MAX_PATH + 1));
@


1.166
log
@* dcrt0.cc (dll_crt0_0): Eliminate muto::init call.
* sync.h (locker): New, currently unused class.
(muto::init): Eliminate.
* sync.cc (muto::init): Ditto.
(muto::init): Eliminate critical section lock and instead use name as a guard
to prevent against multiple attempts to initialize the same muto.
* pinfo.cc (pinfo::init): Set myself procinfo when not execing and pid matches
windows pid or cygwin pid.
@
text
@d161 3
a163 1
  int exitcode = self->exitcode;
d170 1
a170 1
  ExitProcess (exitcode & 0xffff);
@


1.165
log
@* sigproc.cc (_pinfo::set_ctty): Move function
* pinfo.cc (_pinfo::set_ctty): to here.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Don't fill out structure if this
is an on-disk device rather than an "auto" device.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.
* path.cc (normalize_posix_path): Don't treat a standalone '//' as introducing
a UNC path.
(normalize_win32_path): Ditto.
@
text
@d176 2
a177 1
  if (myself && n == myself->pid)
@


1.164
log
@* debug.cc (delete_handle): Report on handle value in debugging output.
* pinfo.h (_pinfo::exists): Declare "new" function.
(_pinfo::kill): Ditto.
* fhandler_termios.cc (tty_min::kill_pgrp): Use _pinfo::exists rather than
proc_exists.
* pinfo.cc (pinfo::init): Ditto.  Don't do a low_priority_sleep(0) when looping
to find exec'ed procinfo.
(pinfo::release): Be more careful about unmapping and closing.
* signal.cc (_pinfo::kill): Rename from kill_worker.  Accommodate entry into
_pinfo class.
(kill0): Use _pinfo::kill rather than kill_worker.
(kill_pgrp): Ditto.  Use _pinfo::exists rather than proc_exists.
* sigproc.cc (_pinfo::exists): Rename from proc_exists.
(pid_exists): Use _pinfo::exists rather than proc_exists.
(remove_proc): Ditto.
* sigproc.h (proc_exists): Delete declaration.
@
text
@d376 8
@


1.163
log
@white space
@
text
@d184 1
a184 1
  bool createit = !!(flag & (PID_IN_USE | PID_EXECED));
d260 1
a260 1
	  assert (!i);
d299 2
a300 1
      low_priority_sleep (0);
d342 1
a342 1
      if (sid == pid && (!p || p->pid == pid || !proc_exists (p)))
d1136 1
a1136 5
#ifdef DEBUGGING
      if (((DWORD) procinfo & 0x77000000) == 0x61000000)
	try_to_debug ();
#endif
      UnmapViewOfFile (procinfo);
d1138 1
d1142 1
a1142 1
      ForceCloseHandle1 (h, pinfo_shared_handle);
d1144 1
@


1.162
log
@* cygthread.cc (cygthread::release): Reset ev here if it exists.
(cygthread::terminate_thread): Eliminat racy code which reset ev and
thread_sync.  Remove a few nonsensical inuse checks.  Exit at the bottom.
(cygthread::detach): Rewrite to again try to ensure that we don't say we're
signalled when we are not signalled.
* fhandler.cc (fhandler_base::raw_read): Revert to signalling read success
quickly.
* pipe.cc (fhandler_pipe::close): Use base method to close handle.
* sigproc.h (WAIT_SIG_PRIORITY): Just trundle along at normal priority to allow
the pipe thread to do its thing if possible.
* pinfo.h (pinfo::zap_cwd): Declare new function.
(pinfo::zap_cwd): Move 'cd out of the way code' here.
(pinfo::exit): Use it here.
* spawn.cc (spawn_guts): And here.
@
text
@d163 1
a163 1
  
@


1.161
log
@* exceptions.cc: Make windows_system_directory non-static.
* pinfo.cc (pinfo::exit): Change innocuous cd'ed location to one that is more
likely to exist.
@
text
@d127 10
d157 1
a157 5
      extern char windows_system_directory[];
      /* Move to an innocuous location to avoid a race with other processes
	 that may want to manipulate the current directory before this
	 process has completely exited.  */
      (void) SetCurrentDirectory (windows_system_directory);
@


1.160
log
@	* path.cc (path_conv::check): Leave symlink expansion loop in case
	a not-ENOENT error happens.

	* cygheap.h (cygheap_fdmanip::fhandler_pipe *): New cast operator.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_PIPE_FHANDLER handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::pipe_fhandler): New method.
	* pinfo.h (enum picom): Add PICOM_PIPE_FHANDLER.
	(_pinfo::pipe_fhandler): Declare.
	* pipe.cc (fhandler_pipe::open): Rewrite.  Allow to open foreign
	pipe handles.
@
text
@d147 5
a151 5
      SetCurrentDirectory ("c:\\");	/* Move to an innocuous location to
					   avoid races with other processes
					   that may want to manipulate the
					   current directory before this process
					   has completely exited.  */
@


1.159
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d509 28
d549 1
a549 1
	unsigned int n;
d690 11
d711 1
a711 1
      /*FALLTHRU*/
d716 1
d722 14
a735 9
      res.s = (char *) malloc (n);
      char *p;
      for (p = res.s; ReadFile (fromthem, p, n, &nr, NULL); p += nr)
	continue;
      if ((unsigned) (p - res.s) != n)
	{
	  __seterrno ();
	  goto err;
	}
d788 12
@


1.158
log
@* pinfo.cc (pinfo::exit): Only return low-order 16 bits when exiting.
@
text
@d524 1
a524 1
	  n = strlen (strcpy (path, "<disconnected>")) + 1;
d759 1
a759 1
	s = strdup ("<disconnected>");
@


1.157
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d162 1
a162 1
  ExitProcess (exitcode);
@


1.156
log
@	* autoload.cc (GetModuleFileNameExA): Add.
	(GetModuleInformation): Add.
	(QueryWorkingSet): Add.
	* fhandler.h (fhandler_virtual::get_filebuf): New method.
	* fhandler_proc.cc (PROC_SELF): Define.
	(proc_fhandlers): Change type of self to FH_PROC.
	(fhandler_proc::exists): Return -3 if self.
	(fhandler_proc::fstat): Handle self as symlink.
	(fhandler_proc::fill_filebuf): Handle self.
	* fhandler_process.cc: Include psapi.h.
	(PROCESS_EXENAME): Remove.
	(PROCESS_MAPS): Define.
	(PROCESS_ROOT): Define.
	(PROCESS_EXE): Define.
	(PROCESS_CWD): Define.
	(process_listing): Remove "exename", add "maps, "root", "exe" and
	"cwd" elements.
	(fhandler_process::exists): Return -2 for symlinks.
	(fhandler_process::fstat): Handle symlinks.
	(fill_filebuf): Evaluate pid if pid is 0.  Use exename handling for
	exe.  Handle maps, root and cwd.
	(format_process_maps): New function evaluating "maps".
	* path.cc (symlink_info::set): New method to fill symlink_info
	with data matching virtual symlinks.
	(path_conv::check): Handle virtual symlinks.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_CWD and PICOM_ROOT
	handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::root): New function.
	(_pinfo::cwd): New function.
	* pinfo.h (enum picom): Add PICOM_CWD and PICOM_ROOT.
	(_pinfo::root): Declare.
	(_pinfo::cwd): Declare.
@
text
@d383 1
a383 1
  char pathbuf[CYG_MAX_PATH];
a462 1
	unsigned int n = strlen (cygheap->cwd.get (pathbuf, 1, 1, CYG_MAX_PATH)) + 1;
d465 2
d468 3
a470 3
	  sigproc_printf ("WriteFile sizeof argv failed, %E");
	else if (!WriteFile (__tothem, pathbuf, n, &nr, NULL))
	  sigproc_printf ("WriteFile sizeof argv failed, %E");
d475 2
d479 1
a479 1
	  n = strlen (strcpy (pathbuf, cygheap->root.posix_path ())) + 1;
d481 9
a489 1
	  n = strlen (strcpy (pathbuf, "/")) + 1;
d492 6
d499 33
a531 4
	  sigproc_printf ("WriteFile sizeof argv failed, %E");
	else if (!WriteFile (__tothem, pathbuf, n, &nr, NULL))
	  sigproc_printf ("WriteFile sizeof argv failed, %E");
	break;
a534 1
	char path[CYG_MAX_PATH + 1];
d662 11
d676 1
d744 52
@


1.155
log
@.
@
text
@d383 1
d461 26
d618 2
d687 44
@


1.154
log
@* pinfo.cc (pinfo::init): Avoid a compiler warning.
@
text
@a142 2
  /* The below call could be moved down two lines, but this provides consistent
     output from strace and the overhead should be extremely negligible.  */
a144 1

@


1.153
log
@* pinfo.h (pinfo::init): Make third parameter non-optional and propagate change
throughout.
* pinfo.cc (set_myself): Pass INVALID_HANDLE_POINTER if h is NULL.
(pinfo::init): Make third parameter non-optional.  Eliminate use of PID_EXECED
as an argument.  Put setting of handle back inside loop but reorganize to try
to open it only when necessary.
@
text
@d182 1
a182 1
  bool created;
a191 1
      created = false;
@


1.152
log
@	* cygwin.din: Export getpriority and setpriority.
	* fork.cc (fork_parent): Copy parent's nice value into child.
	* spawn.cc (spawn_guts): Ditto.
	* miscfuncs.cc (winprio_to_nice): New function.
	(nice_to_winprio): Ditto.
	* pinfo.cc (pinfo_init): If parent is not a Cygwin process, set
	default nice value according to current Win32 priority class.
	* pinfo.h (class _pinfo): Add nice member.
	* syscalls.cc (setpriority): New function, only implementing
	PRIO_PROCESS for now.
	(getpriority): Ditto.
	(nice): Just call setpriority.
	* wincap.h (wincaps::has_extended_priority_class): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h: Add prototypes for winprio_to_nice and nice_to_winprio.
	* include/limits.h (NZERO): New define.
	* include/cygwin/types.h (id_t): New datatype.
	* include/cygwin/version.h: Bump API minor version.
	* include/sys/resource.h: Add PRIO_XXX defines and prototypes for
	getpriority and setpriority.
@
text
@d52 1
a52 1
  myself.init (cygheap->pid, PID_IN_USE | PID_MYSELF, h);
d65 1
a65 1
      myself_identity.init (cygwin_pid (myself->dwProcessId), PID_EXECED);
d172 1
a176 1
      h = NULL;
a179 3
  h = NULL;
  procinfo = NULL;

d181 6
a186 1
  if (!(flag & PID_MYSELF))
d190 5
a194 3
      flag &= ~PID_MYSELF;
      HANDLE hdummy;
      mapaddr = open_shared (NULL, 0, hdummy, 0, SH_MYSELF);
d197 2
a198 8
  int createit = flag & (PID_IN_USE | PID_EXECED);
  DWORD access = FILE_MAP_READ
		 | (flag & (PID_IN_USE | PID_EXECED | PID_MAP_RW) ? FILE_MAP_WRITE : 0);

  bool created;
  if (h0)
    created = 0;
  else
d200 4
a203 2
      char mapname[CYG_MAX_PATH];
      shared_name (mapname, "cygpid", n);
d205 5
a209 5
      int mapsize;
      if (flag & PID_EXECED)
	mapsize = PINFO_REDIR_SIZE;
      else
	mapsize = sizeof (_pinfo);
d211 15
a225 15
      if (!createit)
	{
	  h0 = OpenFileMapping (access, FALSE, mapname);
	  created = 0;
	}
      else
	{
	  char sa_buf[1024];
	  PSECURITY_ATTRIBUTES sec_attribs =
	    sec_user_nih (sa_buf, cygheap->user.sid(), well_known_world_sid,
			  FILE_MAP_READ);
	  h0 = CreateFileMapping (INVALID_HANDLE_VALUE, sec_attribs,
				  PAGE_READWRITE, 0, mapsize, mapname);
	  created = GetLastError () != ERROR_ALREADY_EXISTS;
	}
d227 6
a232 5
      if (!h0)
	{
	  if (createit)
	    __seterrno ();
	  return;
a233 1
    }
d235 1
a235 1
  ProtectHandle1 (h0, pinfo_shared_handle);
a236 3
  for (int i = 0; i < 20; i++)
    {
      procinfo = (_pinfo *) MapViewOfFileEx (h0, access, 0, 0, 0, mapaddr);
a262 1
	  n = realpid;
d269 3
d301 4
a304 1
    destroy = 1;
d964 1
a964 1
			 | pinfo_access);
d972 1
a972 1
      pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0));
@


1.151
log
@* spawn.cc (spawn_guts): Perform same "cd" as in pinfo::exit below to make sure
that a stub process does not keep the current working directory busy after the
"execed" process has exited.
@
text
@d101 2
@


1.150
log
@* pinfo.cc (pinfo::init): Move everything but the MapViewOfFileEx out of the
loop since trying multiple times to call CreateFileMapping doesn't make much
sense.  Try to structure the loop a little better so that exiting with a break
does the right thing.
(pinfo::release): Release shared memory area if it exists and close handle if
it exists.
@
text
@d141 1
a141 1
  /* The below call could be moved down two lines, but I like to see consistent
d144 2
d148 7
a154 7
      /* Move to an innocuous location to avoid races with other processes
	 that may want to manipulate the current directory before this process
	 has completely exited.  */
      SetCurrentDirectory ("c:\\");
      /* Shave a little time off by telling our parent that we have now
	 exited.  */
      self->alert_parent (0);
@


1.149
log
@* pinfo.cc (pinfo::maybe_set_exit_code_from_windows): Make sure that process
has exited before getting an error code.
(pinfo::exit): "cd" to innocuous location before exiting to make sure that
process does not keep the current working directory busy while it is in the
process of really exiting.
@
text
@d120 2
a121 2
  sigproc_printf ("exit value - old %p, windows %p, cygwin %p", oexitcode, x,
		  self->exitcode);
d141 2
d146 3
d150 2
d166 1
a166 1
pinfo::init (pid_t n, DWORD flag, HANDLE in_h)
d176 3
d192 5
a196 1
  for (int i = 0; i < 10; i++)
d198 1
a198 2
      int created;
      char mapname[CYG_MAX_PATH]; /* XXX Not a path */
d207 1
a207 6
      if (in_h)
	{
	  h = in_h;
	  created = 0;
	}
      else if (!createit)
d209 1
a209 1
	  h = OpenFileMapping (access, FALSE, mapname);
d218 3
a220 3
	  h = CreateFileMapping (INVALID_HANDLE_VALUE, sec_attribs,
				 PAGE_READWRITE, 0, mapsize, mapname);
	  created = h && GetLastError () != ERROR_ALREADY_EXISTS;
d223 1
a223 1
      if (!h)
a226 1
	  procinfo = NULL;
d229 3
d233 4
a236 6
      procinfo = (_pinfo *) MapViewOfFileEx (h, access, 0, 0, 0, mapaddr);
      if (procinfo)
	/* it worked */;
      else if (exit_state)
	return;		/* exiting */
      else
d238 3
d242 4
a245 11
	    api_fatal ("MapViewOfFileEx(%p, in_h %p) failed, %E", h, in_h);
	  else
	    {
	      debug_printf ("MapViewOfFileEx(%p, in_h %p) failed, %E", h, in_h);
	      if (h != in_h)
		CloseHandle (h);
	    }
	  if (i < 9)
	    continue;
	  else
	    return;
a247 2
      ProtectHandle1 (h, pinfo_shared_handle);

d251 2
a252 3
	  release ();
	  set_errno (ENOENT);
	  return;
d263 2
a264 2
	  release ();
	  if (flag & PID_ALLPIDS)
d266 1
a266 1
	      set_errno (ENOENT);
d269 1
a269 1
	  continue;
d272 6
a277 11
	/* In certain rare, pathological cases, it is possible for the shared
	   memory region to exist for a while after a process has exited.  This
	   should only be a brief occurrence, so rather than introduce some kind
	   of locking mechanism, just loop.  FIXME: I'm sure I'll regret doing it
	   this way at some point.  */
      if (i < 9 && !created && createit && (procinfo->process_state & PID_EXITED))
	{
	  low_priority_sleep (5);
	  release ();
	  continue;
	}
d289 1
d291 12
a303 1
  destroy = 1;
d886 1
a886 1
  if (h)
d894 3
@


1.148
log
@* pinfo.h (maybe_set_exit_code_from_windows): Renamed from set_exit_state.
* pinfo.cc (pinfo::exit): Use renamed function.
(proc_waiter): Ditto.  Make a copy of input argument to avoid problems when
procs array is shuffled.  Flag when copy is made so that remove_proc knows when
it is safe to reshuffle.
* sigproc.cc (proc_terminate): Don't flag process_state as PID_EXITED.
(remove_proc): Wait for waiter to finish copying pinfo element before moving it
(an actual wait should be an extremely rare event).
@
text
@d114 3
d143 4
a146 1
    self->alert_parent (0);
@


1.147
log
@* init.cc (dll_entry): Remove unused extern.
* include/sys/cygwin.h: Remove PID_ZOMBIE.
* pinfo.h: Rename EXITCODE_* defines.
(pinfo::set_exit_state): Remove parameter.
* pinfo.cc (set_exit_state): Remove parameter.  Reverse sense of test so that
exitcode is checked for having been set rather than not having been set.  Set
flag when exitcode has been established.  Don't set PID_STATE here.
(pinfo::init): Remove exitcode initialization.
(pinfo::exit): Reflect change in EXITCODE_* naming.  Set flag when exitcode has
been established.  Reflect change in arguments to set_process_state.
(proc_waiter): Reflect change in arguments to set_process_state.  Set
process_state here and only here.
* fhandler_process.cc (fhandler_process::fill_filebuf): Reflect removal of
PID_ZOMBIE define.
(format_process_stat): Ditto.
(format_process_status): Ditto.
* sigproc.cc (pid_exists): Ditto.
(stopped_or_terminated): Ditto.  Make sure that only low-order 16 bits of
exitcode are used.
* spawn.cc (spawn_guts): Reflect change in EXITCODE_* naming.
@
text
@d108 1
a108 1
pinfo::set_exit_state ()
d138 1
a138 1
  set_exit_state ();
d678 2
a679 1
  pinfo& vchild = *(pinfo *) arg;
d718 1
a718 2
	  vchild.set_exit_state ();
	  vchild->process_state = PID_EXITED;
d726 2
d817 1
d860 1
@


1.146
log
@	* pinfo.cc (pinfo::exit): Don't access self after releasing it.
	* path.h (path_conv::path_conv): Fill path with native device
	name in case of device argument.
@
text
@d108 1
a108 1
pinfo::set_exit_state (DWORD pidstate)
d112 1
a112 1
  if (hProcess && self->exitcode == EXITCODE_UNSET)
d115 1
a115 1
      self->exitcode = (x & 0xff) << 8;
a118 2
  if (self->exitcode != EXITCODE_NOSET)
    self->process_state = pidstate;
d126 1
a126 1
  if (n != EXITCODE_EXEC)
d128 2
a129 2
      sigproc_terminate ();	/* Just terminate signal and process stuff */
      self->exitcode = n;	/* We're really exiting.  Record the UNIX exit code. */
d138 2
a139 2
  set_exit_state (PID_EXITED);
  if (n != EXITCODE_EXEC)
d280 1
a280 4
	{
	  procinfo->pid = n;
	  procinfo->exitcode = EXITCODE_UNSET;
	}
d717 2
a718 1
	  vchild.set_exit_state (PID_ZOMBIE);
@


1.145
log
@* init.cc (dll_entry): Nuke attempt to set exit code since parent will use
windows exit code if needed.
* pinfo.cc (pinfo::exit): Move release() here to minimize pid creation race
(suggested by Pierre Humblet).
@
text
@d143 1
d149 2
a150 2
		  hProcess, n, self->exitcode);
  ExitProcess (self->exitcode);
@


1.144
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d143 1
@


1.143
log
@* pinfo.cc (pinfo::exit): Don't assume that this == myself.
@
text
@d17 1
a21 1
#include "cygerrno.h"
@


1.142
log
@* pinfo.cc (pinfo::init): Don't close input handle on temporary (?) failure.
@
text
@a132 1
  sigproc_printf ("1 hProcess %p, n %p, exitcode %p", hProcess, n, self->exitcode);
a140 1
  sigproc_printf ("2 hProcess %p, n %p, exitcode %p, EXITCODE_EXEC %p", hProcess, n, self->exitcode, EXITCODE_EXEC);
d142 1
a142 3
{sigproc_printf ("3 hProcess %p, n %p, exitcode %p, EXITCODE_EXE %pC", hProcess, n, self->exitcode, EXITCODE_EXEC);
    myself->alert_parent (0);
}
@


1.141
log
@* pinfo.h (_pinfo::set_exit_state): Declare new function.
(pinfo::exit): Move here from _pinfo::exit.
* sigproc.cc (child_info::sync): Use new function to set exitcode and
process_state.
* pinfo.cc (_pinfo::exit): Ditto.
(proc_waiter): Ditto.
(_pinfo::set_exit_state): Define new function.
(_pinfo::dup_proc_pipe): Close handle when there is no parent process around to
care about the exit value.
* dcrt0.cc (dll_crt0_0): Move subproc_ready synchronization later to make sure
that myself is still mapped in parent.
(do_exit): Reflect movement to pinfo::exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* errno.cc (errmap): Map PROC_NOT_FOUND.
* init.cc (dll_entry): Release myself before exiting.
* sigproc.cc (proc_can_be_signalled): Set errno appropriately.
(sig_send): Ditto.  Also remove ill-advised test for !myself->sendsig since
this is an indication of a process which is still initializating -- it is not
an error.
(child_info::sync): Don't set exitcode here.  Assume that will happen in
proc_waiter, if necessary.
* spawn.cc (spawn_guts): Delay "wait_for_myself" logic until later.  Don't wait
at all if the process has already exited.  Reflect movement to pinfo::exit.
@
text
@d233 2
a234 1
	      CloseHandle (h);
@


1.140
log
@update copyright
@
text
@d42 2
d106 1
d108 17
a124 1
_pinfo::exit (UINT n, bool norecord)
d128 1
a128 6
  if (norecord)
    sigproc_terminate ();		/* Just terminate signal and process stuff */
  else
    exitcode = n;			/* We're really exiting.  Record the UNIX exit code. */

  if (this)
d130 2
a131 14
      /* FIXME:  There is a potential race between an execed process and its
	 parent here.  I hated to add a mutex just for this, though.  */
      struct rusage r;
      fill_rusage (&r, hMainProc);
      add_rusage (&rusage_self, &r);

      if (!norecord)
	{
	  process_state = PID_EXITED;
	  /* Ensure that the parent knows that this logical process has
	     terminated. */
	  myself->alert_parent (0);
	    
	}
d133 1
d135 13
a147 2
  sigproc_printf ("Calling ExitProcess norecord %d, n %p, exitcode %p",
		  norecord, n, exitcode);
d150 3
a152 1
  ExitProcess (exitcode);
d154 1
a683 1
  extern HANDLE hExeced;
d704 2
d723 1
a723 6
	  if (vchild->exitcode == EXITCODE_UNSET)
	    {
	      DWORD x;
	      GetExitCodeProcess (vchild.hProcess, &x);
	      vchild->exitcode = (x & 0xff) << 8;
	    }
a730 1
	  vchild->process_state = PID_ZOMBIE;
d784 1
a784 1
  if (this != myself)
@


1.139
log
@* pinfo.cc (_pinfo::dup_proc_pipe): Can't close proc pipe when execing or we
will suffer an exit code race.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.138
log
@* pinfo.cc (_pinfo::dup_proc_pipe): DUPLICATE_CLOSE_SOURCE closes the handle
regardless, so revert previous change.
@
text
@d767 6
d774 1
a774 2
			      0, FALSE,
			      DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);
@


1.137
log
@* cygthread.cc (cygthread::stub): Add better debug output.
(cygthread::cygthread): Ditto.
(cygthread::terminate_thread): Ditto.  Move inuse test earlier or suffer
infinite loop.
* pinfo.cc (_pinfo::dup_proc_pipe): Close handle if DuplicateHandle fails and
process no longer exists.
* spawn.cc (spawn_guts): Create process in suspended state if OS demands it.
* wincap.cc: Add "start_proc_suspended" throughout.
* wincap.h (wincaps): Ditto.
(wincapc): Ditto.
@
text
@d771 1
a771 5
    {
      if (WaitForSingleObject (hProcess, 0) == WAIT_OBJECT_0)
	CloseHandle (wr_proc_pipe);
      sigproc_printf ("DuplicateHandle failed, pid %d, hProcess %p, %E", pid, hProcess);
    }
@


1.136
log
@* pinfo.cc (_pinfo::exit): Beef up debugging output.
* sigproc.cc (proc_subproc): Detached children apparently need a ppid of 1.
@
text
@d131 1
a131 1
  sigproc_printf ("Calling ExitProcess norecord %d, n %d, exitcode %d",
d771 5
a775 1
    sigproc_printf ("DuplicateHandle failed, pid %d, hProcess %p, %E", pid, hProcess);
@


1.135
log
@* init.cc (dll_entry): Previous code reversion was ill-advised.  Revert it.
* sigproc.cc (child_info::sync): Ditto.
* pinfo.cc (_pinfo::exit): Don't set myself.procinfo to NULL since it is no
longer required.
@
text
@d124 2
a125 3
	  /* We could just let this happen automatically when the process
	     exits but this should gain us a microsecond or so by notifying
	     the parent early.  */
d131 2
a132 1
  sigproc_printf ("Calling ExitProcess %d", n);
@


1.134
log
@* init.cc (dll_entry): Remove exit code setting.
* pinfo.cc (pinfo::init): Initialize exitcode to unset state rather than
SIGTERM.
(proc_waiter): Detect if exit code is unset and use status from
GetExitCodeProcess.
* sigproc.cc (child_info::sync): Remove exit code detection here since
proc_waiter now (again) detects it.
@
text
@a134 1
  myself.procinfo = NULL;	// This breaks the abstraction a little doesn't it?
@


1.133
log
@* fhandler.cc (fhandler_base::fchmod): Do the right thing when changing an "on
disk" device or fifo.
(fhandler_base::fchown): Ditto for changing ownership.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Accommodate device files
on ntfs partitions.
* path.cc (path_conv::check): Use isfs function to figure out if a path exists
on a filesystem to make sure that device files are caught.
@
text
@d268 1
a268 1
	  procinfo->exitcode = SIGTERM;
d705 6
@


1.132
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
(child_info::parent_wr_proc_pipe): Eliminate.
* pinfo.h (_pinfo::alert_parent): Move here from pinfo class.
(_pinfo::dup_proc_pipe): New method.
(_pinfo::sync_proc_pipe): Ditto.
* exceptions.cc (sig_handle_tty_stop): Reflect move of alert_parent.
* init.cc (dll_entry): Exit with status one if main process called ExitProcess.
* pinfo.cc (set_myself): Remove handling of parent_wr_proc_pipe.
(_pinfo::exit): Reflect move of alert_parent.  Set procinfo to NULL to flag
that we are exiting normally.  Always use exitcode when exiting
(although this could be a little racy).
(pinfo::init): Set default exit to SIGTERM.  This will be the exit code
reported if process is terminated.
(_pinfo::dup_proc_pipe): New function.
(pinfo::wait): Duplicate wr_proc_pipe to the right place.  Use dup_proc_pipe to
move the pipe to the child.
(_pinfo::sync_proc_pipe): New function.
(_pinfo::alert_parent): Move to _pinfo.  Make sure that wr_proc_pipe is ours
before using it.
* sigproc.cc (child_info::child_info): Remove handling of parent_wr_proc_pipe.
* spawn.cc (spawn_guts): Pass our wr_proc_pipe to the child when execing.
Ensure that exit code of cygwin process started from windows is correctly set.
@
text
@a73 1
  return;
@


1.131
log
@* cygthread.cc (cygthread::stub): Detect if thread function wants to release
itself here, to avoid a race.
(cygthread::release): Clear more stuff.  Add a diagnostic for an internal
error.
* cygthread.h (auto_release): New function.
* pinfo.h (pinfo::remember): Add an argument to denote whether child is
detached.
* fork.cc (fork_parent): Reflect change in arguments to pinfo::remember.
* pinfo.cc (_pinfo::exit): Signal exit more forcibly.
(proc_waiter): Use cygthread::auto_release to signify that cygthread::stub
should release the thread.  This should avoid a race.
(pinfo::alert_parent): Don't signify an error when wr_proc_pipe == NULL.
* sigproc.cc (proc_subproc): Add support for PROC_DETACHED_CHILD.
* sigproc.h: Ditto.
* spawn.cc (spawn_guts): Specify whether child is detached or not when calling
pinfo::remember.
@
text
@a46 2
  extern child_info *child_proc_info;

d69 1
a69 1
  else
d71 2
a72 9
      /* We've inherited the parent's wr_proc_pipe.  We don't need it,
	 so close it. */
      if (child_proc_info->parent_wr_proc_pipe)
	CloseHandle (child_proc_info->parent_wr_proc_pipe);
      if (cygheap->pid_handle)
	{
	  ForceCloseHandle (cygheap->pid_handle);
	  cygheap->pid_handle = NULL;
	}
a73 1
# undef child_proc_info
d110 1
a110 1
    sigproc_terminate ();	/* Just terminate signal and process stuff */
d112 1
a112 1
    exitcode = n;		/* We're really exiting.  Record the UNIX exit code. */
d128 1
a128 1
	  myself.alert_parent (0);
d136 2
a137 1
  ExitProcess (n);
d267 4
a270 1
	procinfo->pid = n;
d661 4
a664 9
   created during new process creation.  If the pipe is closed, it is
   assumed that the cygwin pid has exited.  Otherwise, various "signals"
   can be sent to the parent to inform the parent to perform a certain
   action.

   This code was originally written to eliminate the need for "reparenting"
   but, unfortunately, reparenting is still needed in order to get the
   exit code of an execed windows process.  Otherwise, the exit code of
   a cygwin process comes from the exitcode field in _pinfo. */
d760 17
a780 1
  HANDLE out;
d783 1
a783 1
  if (!CreatePipe (&rd_proc_pipe, &out, &sec_none_nih, 16))
d789 2
a790 4
  /* Duplicate the write end of the pipe into the subprocess.  Make it inheritable
     so that all of the execed children get it.  */
  if (!DuplicateHandle (hMainProc, out, hProcess, &((*this)->wr_proc_pipe), 0,
			TRUE, DUPLICATE_SAME_ACCESS))
d792 1
a792 2
      system_printf ("Couldn't duplicate pipe topid %d(%p), %E", (*this)->pid,
		     hProcess);
a794 1
  CloseHandle (out);	/* Don't need this end in this proces */
d812 8
d823 1
a823 1
pinfo::alert_parent (char sig)
d828 1
a828 1
  if (myself->wr_proc_pipe == INVALID_HANDLE_VALUE
a830 4
  else if (WriteFile (myself->wr_proc_pipe, &sig, 1, &nb, NULL))
    /* all is well */;
  else if (GetLastError () != ERROR_BROKEN_PIPE)
    debug_printf ("sending %d notification to parent failed, %E", sig);
d833 11
a843 3
      HANDLE closeit = myself->wr_proc_pipe;
      myself->wr_proc_pipe = INVALID_HANDLE_VALUE;
      CloseHandle (closeit);
@


1.130
log
@* cygheap.cc (cygheap_setup_for_child): Add api_fatal to catch failing
MapViewOfFileEx.
* cygthread.cc (cygthread::stub): Previous change to make diagnostic output
more informative was really a bust.  Try again.  Capture previous name in a new
field in cygthread for diagnostic purposes.
(cygthread::cygthread): Ditto.
(cygthread::release): Add an argument to control whether h should be cleared or
not.
(cygthread::terminate_thread): Use 'inuse' for tests rather than 'h'.
(cygthread): Add some diagnostic fields.
(cygthread::release): Add an argument.
* pinfo.cc (proc_waiter): Accommodate change to cygthread::release.
@
text
@d138 2
a139 2
	  if (wr_proc_pipe)
	    CloseHandle (wr_proc_pipe);
d767 1
a767 1
  _my_tls._ctinfo->release (false);	/* return the cygthread to the cygthread pool */
d819 2
a820 1
  if (myself->wr_proc_pipe == INVALID_HANDLE_VALUE)
d822 1
a822 2
  else if (myself->wr_proc_pipe
	   && WriteFile (myself->wr_proc_pipe, &sig, 1, &nb, NULL))
@


1.129
log
@* pinfo.cc (proc_waiter): Zero wait_thread in child to avoid races with process
termination.
* cygthread.cc (cygthread::terminate): Clumsily detect when h has gone away and
attempt no further action.
@
text
@d767 1
a767 1
  _my_tls._ctinfo->release ();	/* return the cygthread to the cygthread pool */
@


1.128
log
@* pinfo.h (proc_pipe::*): Delete class.
* pinfo.cc (proc_pipe::*): Ditto.
@
text
@d766 1
@


1.127
log
@* fork.cc (fork_parent): Reinstate "childhProc" protection.  Don't close
hProcess handle here since it is used to ensure that a new process isn't
created with the old pid after the old pid exits.
* spawn.cc (spawn_guts): Ditto.
* pinfo.cc (proc_waiter): Don't send any signals if we've execed since this
process doesn't officially exist.
* pinfo.h (pinfo::pid_handle): Eliminate.  Just use hProc.
* sigproc.cc (sig_send): Don't send any signals if our sendsig doesn't exist.
That's a sign that we are execing.
(remove_proc): Eliminate pid_handle close.
@
text
@a769 34
void
proc_pipe::set (bool closeem)
{
  myself.lock ();
  if (!CreatePipe (&in, &out, &sec_none_nih, 16))
    {
      system_printf ("couldn't create pipe, %E");
      return;
    }
  /* Duplicate the write end of the pipe into the subprocess.  Make it inheritable
     so that all of the execed children get it.  */
  if (!DuplicateHandle (hMainProc, out, hMainProc, &out, 0, TRUE,
			DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
    {
      CloseHandle (in);
      in = out = NULL;
      system_printf ("couldn't make handle %p noninheritable, %E", out);
      return;
    }
  _closeem = closeem;
}

proc_pipe::~proc_pipe ()
{
  if (_closeem)
    {
      if (in)
	CloseHandle (in);
      if (out)
	CloseHandle (out);
    }
  myself.unlock ();
}

@


1.126
log
@* cygthread.cc (cygthread::terminate_thread): Make public.
* pinfo.h (pinfo::wait_thread): New element.
* pinfo.cc (pinfo::wait): Store "handle" to started thread in pinfo.
* sigproc.cc (proc_terminate): Kill any threads waiting for a process pipe.
@
text
@d745 1
a745 1
      if (hExeced && vchild->pid == myself->pid)
@


1.125
log
@* sigproc.cc (mychild): Reimplement as list scan.
(proc_subproc): Don't mess with pinfo if it's myself.
* child_info.h (child_info_types): Label enum for _PROC constants.
(child_info::child_info): New constructor.
(child_info::~child_info): New destructor.
(child_info::sync): Declare new function.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): Remove old constructor.
(child_info_spawn::child_info_spawn): New constructor.
* dcrt0.cc (dll_crt0_0): Use correct sizeof when doing sanity check on passed
in child_info.  Signal readiness to parent when not forking (and not spawning).
* fork.cc (sync_with_child): Delete.
(resume_child): Remove extra argument.
(sync_with_parent): Use child_info method to sync with parent.
(fork_child): Don't close fork_info->subproc_ready since that is now handled by
the destructor.
(fork_parent): Remove subproc_ready stuff.  Use child_info sync method for
waiting..  Set start time here for child.  Rename "forked" to "child".
(fork): Check ch.subproc_ready for validity here.
* pinfo.h (_pinfo::exec_sendsig): Temp storage for exec stub which may be
staying around to handle non-cygwin captive process.
(_pinfo::exec_dwProcessId): Ditto.
(_pinfo::_lock): Renamed from lock.
(_pinfo::lock): New method.
(_pinfo::unlock): Ditto.
(_pinfo::initialize_lock): Ditto.
* pinfo.cc (set_myself): Use initialize_lock method to initialize myself lock.
Set "exec" fields in _pinfo to zero to indicate that we've started
successfully.  Set start time here when appropriate.
(_pinfo::commune_send): Use pinfo lock/unlock methods.
(proc_waiter): Remove special case for non-cywin processes.  Reinstitute
handling for PID_NOCLDSTOP.
* sigproc.cc (proc_subproc): Set proper EAGAIN errno when process table is
filled.
(sig_send): Use exec_* fields from _pinfo for sending signals if the the _pinfo
sendsig never materializes.
(child_info::child_info): New constructor, renamed from init_child_info.
Zeroes child_info structure and sets appropriate fields in structure based on
chtype.
(child_info::~child_info): New destructor.  Closes subproc_ready if it exists.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): New constructor.
(child_info::ready): New function.  Signals parent when child is ready.
(child_info::sync): New function.  Wait for child to signal us or process to
die.
(remove_proc): Remove closing of hProcess since this should now be handled
shortly after process creation.
* spawn.cc (spawn_guts): Use child_info_spawn constructor rather than
init_child_info.  Save exec_sendsig and exec_dwProcessId in execing _pinfo.
Rely on child_info constructor to properly set parent_wr_proc_pipe in ciresrv.
Revert to previous determination on whether to start a process in suspended
mode.  Remove reparenting stuff.  Just keep a stub around if starting a
non-cygwin process.
@
text
@d836 1
a836 1
      h->zap_h ();
@


1.124
log
@* child_info.h (child_info_fork::parent_wr_proc_pipe): New element.
* fork.cc (fork_parent): Set parent_wr_proc.
* pinfo.cc (set_myself): Close child_proc_info->parent_wr_proc if it exists
rather than trying to get value from parent _pinfo.
* pinfo.h (enum parent_aleter): New enum.
(pinfo::alert_parent): Declare as returning a value.
(pinfo::parent_alive): New function.
* pinfo.cc (pinfo::alert_parent): Set wr_proc_pipe to invalid non-NULL value
when parent disappears.  Return success of operation.
(proc_waiter): Use __ALERT_* enum for control since these are not really
signals.  Implement __ALERT_ALIVE.
* sigproc.cc (my_parent_is_alive): Eliminate.
* sigproc.h (my_parent_is_alive): Ditto for declaration.
(__SIGREPARENT): Eliminate.
@
text
@d53 1
a53 1
  myself->start_time = time (NULL); /* Register our starting time. */
d59 1
a59 2
  InitializeCriticalSection (&myself.lock);
  myself->dwProcessId = GetCurrentProcessId ();
d65 3
d69 3
a71 1
  else if (myself->wr_proc_pipe)
d529 1
a529 1
  EnterCriticalSection (&myself.lock);
d633 1
a633 1
  LeaveCriticalSection (&myself.lock);
a716 7

	  if (vchild->process_state != PID_EXITED && vchild.hProcess)
	    {
	      DWORD exit_code;
	      if (GetExitCodeProcess (vchild.hProcess, &exit_code))
		vchild->exitcode = (exit_code & 0xff) << 8;
	    }
d730 2
a736 22
	case __ALERT_REPARENT: /* sigh */
	  /* spawn_guts has signalled us that it has just started a new
	     subprocess which will take over this cygwin pid.  */

	  /* We need to keep a handle to the original windows process which
	     represents the cygwin process around to make sure that the
	     windows pid is not reused before we are through with it.
	     So, detect the first time that a subprocess calls exec
	     and save the current hprocess in the pid_handle field.
	     On subsequent execs just close the handle. */
	  if (!vchild.hProcess)
	    /* something went wrong.  oh well. */;
	  else if (vchild.pid_handle)
	    ForceCloseHandle1 (vchild.hProcess, childhProc);
	  else
	    vchild.pid_handle = vchild.hProcess;
	  vchild.hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, FALSE,
					 vchild->dwProcessId);
	  vchild->cygstarted++;
	  if (vchild.hProcess)
	    ProtectHandle1 (vchild.hProcess, childhProc);
	  continue;
d770 34
@


1.123
log
@* pinfo.cc (pinfo::wait): Use better name for cygthread.
@
text
@d35 1
d47 2
d67 1
a67 1
  else if (myself->ppid)
a68 2
      /* here if forked/spawned */
      pinfo parent (myself->ppid);
d70 3
a72 5
	 so close it.  This could cause problems for the spawn case since there
	 is no guarantee that a parent will still be around by the time we get
	 here.  If so, we would have a handle leak.  FIXME?  */
      if (parent && parent->wr_proc_pipe)
	CloseHandle (parent->wr_proc_pipe);
d79 1
d707 2
d738 1
a738 1
	case __SIGREPARENT: /* sigh */
d835 1
a835 1
void
d838 1
a838 1
  DWORD nb;
d841 4
a844 2
  if (myself->wr_proc_pipe
      && WriteFile (myself->wr_proc_pipe, &sig, 1, &nb, NULL))
d851 1
a851 1
      myself->wr_proc_pipe = NULL;
d854 1
@


1.122
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d818 1
a818 1
  cygthread *h = new cygthread (proc_waiter, this, "sig");
@


1.121
log
@* pinfo.cc (_pinfo::commune_send): Correct debugging output.
@
text
@d27 1
a29 1
#include "cygthread.h"
a39 17
HANDLE hexec_proc;

void __stdcall
pinfo_fixup_after_fork ()
{
  if (hexec_proc)
    CloseHandle (hexec_proc);
  /* Keeps the cygpid from being reused.  No rights required */
  if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &hexec_proc, 0,
			TRUE, 0))
    {
      system_printf ("couldn't save current process handle %p, %E", hMainProc);
      hexec_proc = NULL;
    }
  VerifyHandle (hexec_proc);
}

d56 24
a79 1
  InitializeCriticalSection (&myself->lock);
d116 4
a119 1
    sigproc_terminate ();
a121 3
      if (!norecord)
	process_state = PID_EXITED;

d127 10
d278 1
d525 1
a525 1
  EnterCriticalSection (&myself->lock);
d629 1
a629 1
  LeaveCriticalSection (&myself->lock);
d662 190
@


1.121.2.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@a26 1
#include <sys/wait.h>
d73 1
a73 7
  InitializeCriticalSection (&myself.lock);
  if (!h && myself->ppid)
    {
      pinfo parent (myself->ppid);
      if (parent && parent->wr_proc_pipe)
	CloseHandle (parent->wr_proc_pipe);
    }
a110 2
  else
    exitcode = n;
a261 1

d508 1
a508 1
  EnterCriticalSection (&myself.lock);
d612 1
a612 1
  LeaveCriticalSection (&myself.lock);
a644 123
static DWORD WINAPI
proc_waiter (void *arg)
{
  pinfo vchild = *(pinfo *) arg;
  vchild.preserve ();

  siginfo_t si;
  si.si_signo = SIGCHLD;
  si.si_code = SI_KERNEL;
  si.si_pid = vchild->pid;
  si.si_errno = 0;
#if 0	// FIXME: This is tricky to get right
  si.si_utime = pchildren[rc]->rusage_self.ru_utime;
  si.si_stime = pchildren[rc].rusage_self.ru_stime;
#else
  si.si_utime = 0;
  si.si_stime = 0;
#endif
  pid_t pid = vchild->pid;

  for (;;)
    {
      DWORD nb;
      char buf = '\0';
      if (!ReadFile (vchild.rd_proc_pipe, &buf, 1, &nb, NULL)
	  && GetLastError () != ERROR_BROKEN_PIPE)
	{
	  system_printf ("error on read of child wait pipe %p, %E", vchild.rd_proc_pipe);
	  break;
	}

      si.si_uid = vchild->uid;

      int proc_todo;
      switch (buf)
	{
	case 0:
	  if (WIFEXITED (vchild->exitcode))
	    si.si_sigval.sival_int = CLD_STOPPED;
	  else if (WCOREDUMP (vchild->exitcode))
	    si.si_sigval.sival_int = CLD_DUMPED;
	  else
	    si.si_sigval.sival_int = CLD_KILLED;
	  CloseHandle (vchild.rd_proc_pipe);
	  vchild.rd_proc_pipe = NULL;
	  si.si_status = vchild->exitcode;
	  // proc_todo = PROC_CHILDTERMINATED;
	  vchild->process_state = PID_ZOMBIE;
	  break;
	case SIGTTIN:
	case SIGTTOU:
	case SIGTSTP:
	case SIGSTOP:
	  si.si_sigval.sival_int = CLD_STOPPED;
	  // proc_todo = PROC_CHILDSTOPPED;
	  break;
	case SIGCONT:
	  // proc_todo = PROC_CHILDCONTINUED;
	  continue;
	default:
	  system_printf ("unknown value %d on proc pipe", buf);
	  continue;
	}

      /* Send a SIGCHLD to myself.   We do this here, rather than in proc_subproc
	 to avoid the proc_subproc lock since the signal thread will eventually
	 be calling proc_subproc and could unnecessarily block. */
      sig_send (myself_nowait, si);

      /* If we're just stopped or got a continue signal, keep looping.
	 Otherwise, return this thread to the pool. */
      if (buf != '\0')
	sigproc_printf ("looping");
      else
	break;
    }
  sigproc_printf ("exiting wait thread for pid %d", pid);
  return 0;
}

int
pinfo::wait ()
{
  HANDLE out;
  /* FIXME: execed processes should be able to wait for pids that were started
     by the process which execed them. */
  if (!CreatePipe (&rd_proc_pipe, &out, &sec_none_nih, 16))
    {
      system_printf ("Couldn't create pipe tracker for pid %d, %E",
		     (*this)->pid);
      return 0;
    }
  if (!DuplicateHandle (hMainProc, out, hProcess, &((*this)->wr_proc_pipe), 0,
			TRUE, DUPLICATE_SAME_ACCESS))
    {
      system_printf ("Couldn't duplicate pipe topid %d(%p), %E", (*this)->pid,
		     hProcess);
      return 0;
    }
  CloseHandle (out);


#if 1
  DWORD tid;
  HANDLE h = CreateThread (&sec_none_nih, 0, proc_waiter, this, 0, &tid);
  if (!h)
    sigproc_printf ("tracking thread creation failed for pid %d", (*this)->pid);
  else
    CloseHandle (h);
#else
  cygthread *h = new cygthread (proc_waiter, this, "sig");
  if (!h)
    sigproc_printf ("tracking thread creation failed for pid %d", (*this)->pid);
  else
    {
      h->zap_h ();
      sigproc_printf ("created tracking thread for pid %d, winpid %p, rd_pipe %p",
		      (*this)->pid, (*this)->dwProcessId, rd_proc_pipe);
    }
#endif
  return 1;
}

@


1.121.2.2
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d30 1
d688 1
a731 1
  _my_tls._ctinfo->release ();
d757 1
a757 1
#if 0
@


1.121.2.3
log
@checkpoint
@
text
@d42 15
d74 1
a74 7
  myself->dwProcessId = GetCurrentProcessId ();
  if (h)
    {
      static pinfo NO_COPY myself_identity;
      myself_identity.init (cygwin_pid (myself->dwProcessId), PID_EXECED);
    }
  else if (myself->ppid)
a109 15
void __stdcall
pinfo_fixup_after_fork ()
{
  if (hexec_proc)
    CloseHandle (hexec_proc);
  /* Keeps the cygpid from being reused.  No rights required */
  if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &hexec_proc, 0,
			TRUE, 0))
    {
      system_printf ("couldn't save current process handle %p, %E", hMainProc);
      hexec_proc = NULL;
    }
  VerifyHandle (hexec_proc);
}

d658 1
d699 1
d707 1
d710 1
a754 1
  preserve ();
@


1.121.2.4
log
@race
@
text
@d663 1
a663 2
  pinfo& vchild = *(pinfo *) arg;
  // SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_NORMAL);
@


1.121.2.5
log
@experiment
@
text
@a124 1

d128 1
a128 9
	{
	  process_state = PID_EXITED;
	  if (CGFFAST && myself->ppid != 1)
	    {
	      pinfo parent (myself->ppid);
	      if (parent)
		sig_send (parent, SIGCHLD);
	    }
	}
@


1.121.2.6
log
@unexperiment
@
text
@d128 11
a143 7

      if (!norecord)
	{
	  process_state = PID_EXITED;
	  if (wr_proc_pipe)
	    CloseHandle (wr_proc_pipe);
	}
d769 8
d786 1
a786 1

@


1.121.2.7
log
@fix wait when invoked from non-cygwin process.
@
text
@d669 1
a669 1
  extern HANDLE hExeced;
d702 1
a702 1
	    si.si_sigval.sival_int = CLD_EXITED;
a724 7
      if (hExeced)
	{
	  /* execing.  no signals available now. */
	  proc_subproc (PROC_CLEARWAIT, 0);
	  break;
	}

a736 1

@


1.121.2.8
log
@* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.
@
text
@a700 10
	  CloseHandle (vchild.rd_proc_pipe);
	  vchild.rd_proc_pipe = NULL;

	  if (vchild->process_state != PID_EXITED && vchild.hProcess)
	    {
	      DWORD exit_code;
	      if (GetExitCodeProcess (vchild.hProcess, &exit_code))
		vchild->exitcode = (exit_code & 0xff) << 8;
	    }
	  ForceCloseHandle1 (vchild.hProcess, childhProc);
d707 2
a719 10
	case __SIGREPARENT: /* sigh */
	  if (vchild.hProcess)
	    ForceCloseHandle1 (vchild.hProcess, childhProc);
	  vchild.hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, FALSE,
					 vchild->dwProcessId);
	  vchild->cygstarted++;
	  if (vchild.hProcess)
	    ProtectHandle1 (vchild.hProcess, childhProc);
	  continue;
	  break;
a786 19
pinfo::alert_parent (int sig)
{
  /* See if we have a living parent.  If so, send it a special signal.
     It will figure out exactly which pid has stopped by scanning
     its list of subprocesses.  */
  if (my_parent_is_alive ())
    {
      pinfo parent (myself->ppid);
      if (NOTSTATE (parent, PID_NOCLDSTOP))
	{
	  DWORD nb;
	  unsigned char pipesig = sig;
	  if (!WriteFile (myself->wr_proc_pipe, &pipesig, 1, &nb, NULL))
	    debug_printf ("sending %d notification to parent failed, %E", sig);
	}
    }
}

void
@


1.121.2.9
log
@* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
@
text
@a61 1
      /* here if execed */
a66 1
      /* here if forked/spawned */
a69 2
      if (cygheap->pid_handle)
	CloseHandle (cygheap->pid_handle);
a786 7
  if (!DuplicateHandle (hMainProc, hProcess, hMainProc, &pid_handle, 0,
			FALSE, DUPLICATE_SAME_ACCESS))
    {
      system_printf ("Couldn't duplicate pipe topid %d(%p), %E", (*this)->pid,
		     hProcess);
      return 0;
    }
@


1.121.2.10
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
@
text
@d40 2
d73 1
a73 4
	{
	  ForceCloseHandle (cygheap->pid_handle);
	  cygheap->pid_handle = NULL;
	}
d105 15
d714 1
d733 1
a733 3
	  if (!vchild.hProcess)
	    /* something went wrong.  oh well. */;
	  else if (vchild.pid_handle)
a734 2
	  else
	    vchild.pid_handle = vchild.hProcess;
d741 1
d791 7
d816 1
a816 1
pinfo::alert_parent (char sig)
d818 4
a821 9
  DWORD nb;
  /* Send something to our parent.  If the parent has gone away,
     close the pipe. */
  if (myself->wr_proc_pipe
      && WriteFile (myself->wr_proc_pipe, &sig, 1, &nb, NULL))
    /* all is well */;
  else if (GetLastError () != ERROR_BROKEN_PIPE)
    debug_printf ("sending %d notification to parent failed, %E", sig);
  else
d823 8
a830 3
      HANDLE closeit = myself->wr_proc_pipe;
      myself->wr_proc_pipe = NULL;
      CloseHandle (closeit);
@


1.120
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d504 1
a504 1
      sigproc_printf ("first CreatePipe failed, %E");
@


1.119
log
@* fork.cc (fork_parent): Record child's pid when we're sure that it has been
filled out by the child.
* pinfo.cc (pinfo::init): Trivial change.
@
text
@d47 1
a47 1
  /* Keeps the cygpid from being reused. No rights required */
d61 1
a61 1
set_myself (pid_t pid, HANDLE h)
d63 3
a65 5
  DWORD winpid = GetCurrentProcessId ();
  if (pid == 1)
    pid = cygwin_pid (winpid);
  myself.init (pid, PID_IN_USE | PID_MYSELF, h);
  myself->dwProcessId = winpid;
d72 1
d92 1
a92 1
      set_myself (1);
@


1.118
log
@* dcrt0.cc (dll_crt0_0): Use proper boolean arguments.
* pinfo.cc (pinfo::init): Don't consider MapViewOfFileEx error to be fatal if
exiting.
* pinfo.h (pinfo::init): Eliminate default argument and supply the argument in
the one case that needed it.
@
text
@d173 1
a173 1
	  h = OpenFileMappingA (access, FALSE, mapname);
@


1.117
log
@* pinfo.cc (pinfo::init): Print handle in hex when MapViewOfFile fails.
@
text
@d196 19
a214 2
      if (!procinfo)
	api_fatal ("MapViewOfFileEx(%p) failed, %E", h);
@


1.116
log
@* pinfo.cc (pinfo::init): Guard against MapViewOfFileEx failure.
@
text
@d197 1
a197 1
	api_fatal ("MapViewOfFileEx failed, %E");
@


1.115
log
@* dtable.cc (dtable::find_fifo): Release lock after fifo found (still racy).
* fhandler.h (fhandler_fifo::get_io_handle): New fifo-specific method.
* fhandler_fifo.cc (fhandler_fifo::close): Close output_handle only if it is
open.
(fhandler_fifo::open_not_mine): Reorganize slightly.  Don't call _pinfo methods
when the fifo is owned by me or suffer dtable lock_cs deadlock.
(fhandler_fifo::open): Call open_not_mine first, otherwise open myself
(racy).
* pinfo.cc (_pinfo::commune_recv): Duplicate fifo handles here in requesting
processes arena to avoid one potential race (of many).
(_pinfo::commune_send): Move all PICOM_FIFO code under one case statement.
* thread.cc (pthread::init_mainthread) Use existing hMainProc handle rather
than calling GetCurrentProcess.
@
text
@d196 2
@


1.114
log
@* cygheap.cc (init_cheap): Add ability to specify minimal cygwin heap size when
debugging.
(_csbrk): Report error in allocation to stderr.
(ccalloc): Ditto.
* dtable.cc (dtable::find_fifo): Remove use of atoms.
* dtable.h (dtable::find_fifo): Ditto.
* fhandler.h (fhandler_fifo): Ditto.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Ditto.
(fhandler_fifo::set_use): Ditto.
(fhandler_fifo::open_not_mine): Ditto.
(fhandler_fifo::open): Ditto.
* pinfo.cc (_pinfo::commune_recv): Ditto.
(_pinfo::commune_send): Ditto.
@
text
@a353 1
  CloseHandle (hp);
d358 1
d371 2
d408 1
d416 1
d429 7
d438 1
d457 1
a457 1
#define PIPEBUFSIZE (16 * sizeof (DWORD))
a499 15
  switch (code)
    {
    case PICOM_FIFO:
      {
	char *path = va_arg (args, char *);
	size_t len = strlen (path) + 1;
	if (!WriteFile (tothem, path, len, &nr, NULL) || nr != len)
	  {
	    __seterrno ();
	    goto err;
	  }
	break;
      }
    }

d550 14
d565 1
a565 1
	WriteFile (tothem, &x, sizeof (x), &x, NULL);
d568 1
@


1.113
log
@2004-01-12  Joshua Daniel Franklin <joshuadfranklin@@yahoo.com>

	* dll_init.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * dtable.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * external.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * path.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * pinfo.cc: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * shared.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * stackdump.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
@
text
@d401 11
a411 3
	int formic;
	if (!ReadFile (__fromthem, &formic, sizeof formic, &nr, NULL)
	    || nr != sizeof formic)
d417 9
a425 2
	fhandler_fifo *fh = cygheap->fdtab.find_fifo ((ATOM) formic);
	HANDLE it[] = {(fh->get_handle ()), (fh->get_output_handle ())};
d492 3
a494 2
	int formic = va_arg (args, int);
	if (!WriteFile (tothem, &formic, sizeof formic, &nr, NULL) || nr != sizeof formic)
@


1.112
log
@* Makefile.in (clean): Remove sigfe.s.
(sigfe.s): Ensure that sigfe.s will be regenerated if it does not exist.
* dll_init.cc (dll_dllcrt0): Simplify initializing tests.
* exceptions.cc (setup_handler): Detect when stub caller is either spinning or
has acquired the lock after being suspended to avoid windows problems with
suspending a win32 API call.
* cygtls.h (_cygtls::spinning): Declare new element.
* gendef: Remove unused _siglist_index and _siglist declaration.
(_sigfe): Set spinning element when potentially looping, waiting for lock.
(_sigbe): Ditto.
(_cygtls::lock): Ditto.
(_longjmp): Ditto.
* tlsoffsets.h: Regenerate.
* pinfo.cc (_pinfo::exit): Set final exit state here.  Call sigproc_terminate
if invoked with 'norecord'.  Clear any residual _cygtls stuff.
* winsup.h (exit_states): Define ES_FINAL.
* spawn.cc (spawn_guts): Don't call proc_terminate specifically when execing.
Let _pinfo::exit handle that case.
* sigproc.cc (wait_subproc): Always exit loop early when proc_loop_wait.
* init.cc (munge_threadfunc): Eliminate unused argument.
(dll_entry): Reflect above change in call to munge_threadfunc.
@
text
@d620 1
a620 1
  <funcsynopsis>
d625 1
a625 1
  </funcsynopsis>
@


1.111
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d34 1
d108 4
a123 1
  cygthread::terminate ();
d125 2
@


1.110
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d33 1
a758 2
NO_COPY CRITICAL_SECTION winpids::cs;

d762 1
a762 1
  EnterCriticalSection (&cs);
d766 1
a766 7
  LeaveCriticalSection (&cs);
}

void
winpids::init ()
{
  InitializeCriticalSection (&cs);
@


1.109
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.108
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d261 1
a261 1
  debug_printf ("checking if /dev/tty%d differs from input", ctty);
@


1.107
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d52 1
@


1.107.4.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a51 1
  VerifyHandle (hexec_proc);
@


1.107.4.2
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d261 1
a261 1
  debug_printf ("checking if /dev/tty%d changed", ctty);
@


1.106
log
@2004-01-12  Joshua Daniel Franklin <joshuadfranklin@@yahoo.com>

	* dll_init.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * dtable.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * external.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * path.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * pinfo.cc: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * shared.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
        * stackdump.sgml: Update funcsynopsis for DocBook 4.2 SGML DTD.
@
text
@a612 1
    <funcprototype>
a616 1
    </funcprototype>
@


1.105
log
@* exceptions.cc (_threadinfo::interrupt_now): Avoid double call to sigdelayed.
* pinfo.cc (_pinfo::commune_send): Avoid inexplicable test which caused most
pids to be shown as "<defunct>" on Win9x.
@
text
@d613 1
d618 1
@


1.104
log
@Move open_fhs from fhandler.h to cygheap.h for easier tracking.  Accommodate
this change throughout.
* dtable.cc (dtable::add_archetype): Use correct count when iterating through
*active* archetypes.
* dtable.cc (dtable::fixup_after_exec): Close handle if close_on_exec and
archetype exists since archetype currently does not set windows close-on-exec
flag (FIXME).
* fhandler_tty.cc (fhandler_tty_slave::open): Change debugging output slightly.
(fhandler_tty_slave::close): Ditto.
(fhandler_tty_slave::fixup_after_fork): Just report on inherited use counts
since since archetype currently does not set windows close-on-exec flag
(FIXME).
* pinfo.cc (_pinfo::set_ctty): Change debugging output slightly.
* cygheap.cc (cygheap_init): Remove open_fhs accommodation and use count
reporting.
* perthread.h (vfork_save::fhctty): New element.
* perthread.h (vfork_save::open_fhs): New element.
* fork.cc (vfork): Muck around with ctty and open_fhs stuff, both of which are
now saved in the vfork_save structure.
@
text
@d438 1
a438 1
  if (!pid || !this || (dwProcessId != (DWORD) pid && !pinfo (myself->dwProcessId)))
@


1.103
log
@* fhandler.h (fhandler_tty_slave::archetype): Make public.
(report_tty_counts): New macro.  Use throughout for reporting tty use counts.
* dtable.cc (dtable::vfork_child_dup): Add debugging output for usecount
increment.  Increment open_fhs if appropriate.
(dtable::vfork_parent_restore): "Close" artificially bumped ctty.
(dtable::vfork_child_fixup): Close ctty since it was bumped prior to vfork.
Save open_fhs around close since the closing of these handles has no effect on
the console.
* fhandler_tty.cc (fhandler_tty_slave::open): Reorganize calls to allow for
easier tracking of usecount modification.
(fhandler_tty_slave::open): Ditto.
@
text
@d260 1
a260 1
  debug_printf ("ctty %d", ctty);
d295 1
a295 1
	      fhandler_console::open_fhs++;
@


1.102
log
@* pinfo.cc (_pinfo::set_ctty): *Always* call close on opened ctty since it
counts as an opened handle.
@
text
@d296 1
a296 2
	      debug_printf ("tty%d, open_fhs %d, arch usecount %d", tc->ntty,
			    fhandler_console::open_fhs, arch->usecount);
@


1.101
log
@* fhandler.h (fhandler_tty_master::fixup_after_fork): Remove declaration.
(fhandler_tty_master::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Fix so that children do not
inherit master tty handles.
(fhandler_tty_master::fixup_after_fork): Remove, since it was never used.
(fhandler_tty_master::fixup_after_exec): Ditto.
* pinfo.cc (_pinfo::set_ctty): Increment open_fhs when ctty is set.
* cygheap.cc (cygheap_init): Ditto.
* syscalls.cc (setsid): *Always* call close on opened ctty since the archetype
is associated with the ctty and it counts as an opened handle.
* tty.cc (tty::common_init): Don't protect input/output mutex since it confuses
subsequent fork/execs when CYGWIN=tty.
@
text
@d289 1
a289 2
	      if (!--cygheap->ctty->usecount)
		cygheap->ctty->close ();
@


1.100
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d296 3
a298 1
	      debug_printf ("arch usecount for tty%d is %d", tc->ntty, arch->usecount);
@


1.99
log
@* exceptions.cc (set_signal_mask): Report on input argument rather than
getsigmask.
* fhandler.h (fhandler_base): Make friends with close_all_files.
* pinfo.cc (_pinfo::set_ctty): Add more debugging.
* sigproc.cc (proc_can_be_signalled): Detect state when signal handler thread
is gone in target process as an EPERM situation.  Set errno to ESRCH if process
doesn't exist.
(sigproc_terminate): Set sendsig to illegal value when closed.
(sig_send): Rely on proc_can_be_signalled setting the proper errno.
* syscalls.cc (close_all_files): Detect when all ttys are closed prior to
calling close_all_files.  The ctty needs to be closed explicitly in this case.
@
text
@d260 1
@


1.98
log
@* pinfo.cc (_pinfo::set_ctty): Correct stupid typo.
@
text
@d281 1
d293 4
a296 1
	    arch->usecount++;
@


1.97
log
@* cygheap.h (cygheap_types): Add HEAP_ARCHETYPES.
(init_cheap::ctty): Change to pointer.
* dtable.h (dtable::find_archetype): Declare new function.
(dtable::add_archetype): Declare new function.
(dtable::delete_archetype): Declare new function.
(dtable::narchetypes): Declare.
(dtable::farchetypes): Declare.
(dtable::initial_archetype_size): Declare.
(dtable::dtable): Initialize new fields.
(dtable::initial_archetype_size): Declare.
* dtable.cc (dtable::find_archetype): Define new function.
(dtable::add_archetype): Define new function.
(dtable::delete_archetype): Define new function.
(dtable::initial_archetype_size): Define.
* fhandler.h (fhandler_base::archetype): Declare.
(fhandler_base::usecount): Declare.
* fhandler.cc (fhandler_base::fhandler_base): Initialize new fields.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass NULL to third
argument of set_ctty.
* fhandler_tty.cc (fhandler_tty_slave::open): Accommodate new archetype method
to create only one instance of a tty.
(fhandler_tty_slave::close): Don't close handles unless archetype usecount is
zero.  When that happens, close archetype too.
(fhandler_tty_slave::dup): Just copy archetype.  Set use count appropriately.
Set ctty, if appropriate.
(fhandler_tty_common::dup): Remove slave considerations.
(fhandler_tty_common::set_close_on_exec): Remove cygheap->ctty considerations.
* pinfo.cc (_pinfo::set_ctty): Accommodate new archetype methods.
* pinfo.h (_pinfo::set_ctty): Make third argument explicit.
* syscalls.cc (close_all_files): Decrement controlling tty use count before
closing all handles to allow controlling tty to be closed.  Remove previous
controlling tty considerations.
@
text
@d281 1
a281 1
	  if (cygheap->ctty)
@


1.96
log
@* pinfo.cc (_pinfo::set_ctty): Don't copy over existing ctty if it is active.
@
text
@d258 1
a258 1
_pinfo::set_ctty (tty_min *tc, int flags, fhandler_tty_slave *fhctty)
d279 15
a293 2
      if (fhctty && !cygheap->ctty.get_io_handle ())
	cygheap->ctty  = *fhctty;
@


1.95
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@a259 1
  int initial_ctty = ctty;
d279 1
a279 1
      if (fhctty)
a280 2
      else if (initial_ctty < 0)
	assert (cygheap->ctty.get_io_handle () == NULL);
@


1.94
log
@	Substitute 0x7fffffff and 0xffffffff by INT32_MAX and UINT32_MAX
	throughout, except in assembler code.
@
text
@d257 30
@


1.93
log
@* pinfo.cc (pinfo::init): Use shared_name to construct the mapname.
@
text
@d320 1
a320 1
	    if (IsBadStringPtr (__argv[i], 0x7fffffff))
@


1.92
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d150 1
a150 1
      __small_sprintf (mapname, "cygpid.%x", n);
@


1.91
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d145 1
a145 1
                 | (flag & (PID_IN_USE | PID_EXECED | PID_MAP_RW) ? FILE_MAP_WRITE : 0);
d246 2
a247 2
  
  sec_acl ((PACL) sa_buf, true, true, cygheap->user.sid (), 
d249 5
a253 5
  if (!InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION))
    debug_printf("InitializeSecurityDescriptor %E");
  else if (!SetSecurityDescriptorDacl(&sd, TRUE, (PACL) sa_buf, FALSE)) 
    debug_printf("SetSecurityDescriptorDacl %E");
  else if (!SetKernelObjectSecurity(h, DACL_SECURITY_INFORMATION, &sd))
@


1.90
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* pinfo.cc (pinfo::init): Do not give FILE_MAP_WRITE access to Everybody.
	* exceptions.cc (sig_handle_tty_stop): Do not create pinfo parent with
	PID_MAP_WRITE.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Ditto for pinfo p.
	* signal.cc (kill_worker): Ditto for pinfo dest.
@
text
@d149 1
a149 1
      char mapname[MAX_PATH];
@


1.89
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* pinfo.h (pinfo::set_acl): Declare.
	* pinfo.cc (pinfo_fixup_after_fork): Duplicate with no rights.
	(pinfo::set_acl): New.
	* spawn.cc (spawn_guts): Call myself.set_acl.
@
text
@d173 1
a173 1
			  FILE_MAP_READ | FILE_MAP_WRITE); /* FIXME */
@


1.88
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d45 1
a45 1

d47 1
a47 1
			TRUE, DUPLICATE_SAME_ACCESS))
d239 16
@


1.87
log
@* pinfo.h (winpids::pid_access): New element.
(winpids::winpids): Rejigger to set pinfo_access.
* pinfo.cc (winpids::add): Try to open shared memory region with supplied
pinfo_access first, then default to readonly.
* fhandler_termios.cc (tty_min::kill_pgrp): When getting list of pids to work
with, suggest opening with PID_MAP_RW.
* signal.cc (kill_pgrp): Ditto.
* sigproc.cc (sig_send): Perform a write check on todo prior to attempting to
increment it.  Return EACCES if we can't write to it.
@
text
@d15 1
d17 1
a18 1
#include "path.h"
d32 1
d323 28
a350 5
	  if (!WriteFile (__tothem, "", 1, &nr, NULL))
	    {
	      sigproc_printf ("WriteFile null failed, %E");
	      break;
	    }
d364 1
a364 1
_pinfo::commune_send (DWORD code)
d370 3
d404 14
a446 5
  if (!ReadFile (fromthem, &n, sizeof n, &nr, NULL) || nr != sizeof n)
    {
      __seterrno ();
      goto err;
    }
d450 5
d466 13
d493 2
a494 1
  res.n = 0;
d536 2
a537 1
      if (((DWORD) procinfo & 0x77000000) == 0x61000000) try_to_debug ();
@


1.86
log
@* getopt.cc (opterr): Reinstate initialization.
(optind): Ditto.
(optopt): Ditto.
* pinfo.cc: Include cygheap.h or suffer compile error.
* shared.h: Reset magic number.
@
text
@d544 2
a545 1
  pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0));
d547 1
a547 13
    /* nothing to do */;
  else if (!pinfolist[nelem])
    return;
  else
    /* Scan list of previously recorded pids to make sure that this pid hasn't
       shown up before.  This can happen when a process execs. */
    for (unsigned i = 0; i < nelem; i++)
      if (pinfolist[i]->pid == pinfolist[nelem]->pid)
	{
	  if ((_pinfo *) pinfolist[nelem] != (_pinfo *) myself)
	    pinfolist[nelem].release ();
	  return;
	}
d549 20
@


1.85
log
@2003-09-15  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h (__sec_user): Add "access2" argument.
	(sec_acl): Add "original" and "access2" arguments.
	(sec_user): Add "sid2" and "access2" argument. Remove dependence on
	allow_ntsec.
	(sec_user_nih): Ditto.
	* sec_helper.cc (__sec_user): Add "has_security" test.
	Call sec_acl with new arguments, letting it handle original_sid.
	(sec_acl): Add "original" and "access2" arguments. Handle original_sid
	depending on flag but avoiding duplicates. Use "access2" for sid2.
	* pinfo.cc (pinfo::init): Use security attributes created by sec_user
	when creating the mapping.
	* security.cc (create_token): Adjust arguments in call to sec_acl.
	Call sec_user instead of __sec_user.
	* syscall.cc (seteuid32):  Adjust arguments in call to sec_acl. Remove
	now unnecessary test. Remove useless conversions to psid.
	* dcrt0.cc (dll_crt0_1): Call cygsid::init before pinfo_init.
@
text
@d30 1
@


1.84
log
@* include/sys/cygwin.h: Rename PID_UNUSED to PID_MAP_RW.
* pinfo.cc (pinfo_init): Initialize myself->gid.
(pinfo::init): Create the "access" variable, set it appropriately and use it to
specify the requested access.
* exceptions.cc (sig_handle_tty_stop): Add PID_MAP_RW in pinfo parent.
* signal.cc (kill_worker): Ditto for pinfo dest.
* syscalls.cc (setpgid): Ditto for pinfo p.
@
text
@d167 5
a171 1
	  h = CreateFileMapping (INVALID_HANDLE_VALUE, &sec_all_nih,
@


1.83
log
@* dcrt0.cc (__argc_safe): New variable.
(dll_crt0_1): Store argc in __argc_safe, which will theoretically remain
untouched by the user.
* fhandler_console.cc (fhandler_console::read): Silence some compiler warnings.
* fhandler_raw.cc (fhandler_dev_raw::raw_read): Ditto.
* pinfo.cc (_pinfo::commune_recv): Carefully bound argv scan and check for
potentially bad pointers since user could have set argv cell to anythinw.
* cygheap.h (CYGHEAPSIZE): Bump up size.
@
text
@d92 1
a92 1

d141 2
d162 1
a162 1
	  h = OpenFileMappingA (FILE_MAP_READ | FILE_MAP_WRITE, FALSE, mapname);
d180 1
a180 2
      procinfo = (_pinfo *) MapViewOfFileEx (h, FILE_MAP_READ | FILE_MAP_WRITE,
					     0, 0, 0, mapaddr);
@


1.82
log
@* pinfo.cc (_pinfo::commune_send): Fix bounds test so that poll of
communicating pid actually stops eventually.
@
text
@d292 11
a302 2
	for (char **a = __argv; *a; a++)
	  n += strlen (*a) + 1;
d309 1
a309 1
	  for (char **a = __argv; *a; a++)
d312 1
a312 1
		sigproc_printf ("WriteFile arg %d failed, %E", a - __argv);
@


1.81
log
@* newsym: Use correct prefix for generating imports.
* pinfo.cc (_pinfo::commune_send): Don't wait forever for a response from
another process.
@
text
@d366 1
a366 1
  for (int i = 0; (isalive = alive ()) || (i < 65536); i++)
@


1.80
log
@* pinfo.cc (_pinfo::commune_send): Don't attempt to communicate with a pure
windows process.
@
text
@d366 1
a366 1
  while ((isalive = alive ()))
@


1.79
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d334 1
a334 1
  if (!pid || !this)
@


1.78
log
@missed in last checkin
@
text
@a13 1
#include <errno.h>
@


1.77
log
@	* external.cc (cygwin_internal): Change n to __off64_t to match change
	of _pinfo::cmdline.
	* fhandler.h (class fhandler_virtual): Change filesize member to
	__off64_t.
	* fhandler_proc.cc (format_proc_meminfo): Change to return __off64_t.
	(format_proc_stat): Ditto.
	(format_proc_uptime): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(format_process_statm): Ditto.
	* pinfo.cc (_pinfo::cmdline): Expect __off64_t parameter.
	* pinfo.h (class _pinfo): Change declaration of cmdline accordingly.
@
text
@d432 1
a432 1
_pinfo::cmdline (__off64_t& n)
@


1.76
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d432 1
a432 1
_pinfo::cmdline (size_t& n)
@


1.76.2.1
log
@merge from trunk
@
text
@a15 1
#include <stdarg.h>
a30 2
#include "cygheap.h"
#include "fhandler.h"
d307 5
a311 28
	if (!WriteFile (__tothem, "", 1, &nr, NULL))
	  {
	    sigproc_printf ("WriteFile null failed, %E");
	    break;
	  }
	break;
      }
    case PICOM_FIFO:
      {
	int formic;
	if (!ReadFile (__fromthem, &formic, sizeof formic, &nr, NULL)
	    || nr != sizeof formic)
	  {
	    /* __seterrno ();*/	// this is run from the signal thread, so don't set errno
	    goto out;
	  }

	fhandler_fifo *fh = cygheap->fdtab.find_fifo ((ATOM) formic);
	HANDLE it[] = {(fh->get_handle ()), (fh->get_output_handle ())};

	if (!WriteFile (__tothem, it, sizeof (it), &nr, NULL))
	  {
	    /*__seterrno ();*/	// this is run from the signal thread, so don't set errno
	    sigproc_printf ("WriteFile read handle failed, %E");
	  }

	(void) ReadFile (__fromthem, &nr, sizeof (nr), &nr, NULL);
	break;
d325 1
a325 1
_pinfo::commune_send (DWORD code, ...)
a330 3
  va_list args;

  va_start (args, code);
a361 14
  switch (code)
    {
    case PICOM_FIFO:
      {
	int formic = va_arg (args, int);
	if (!WriteFile (tothem, &formic, sizeof formic, &nr, NULL) || nr != sizeof formic)
	  {
	    __seterrno ();
	    goto err;
	  }
	break;
      }
    }

d391 5
a398 5
      if (!ReadFile (fromthem, &n, sizeof n, &nr, NULL) || nr != sizeof n)
	{
	  __seterrno ();
	  goto err;
	}
a409 13
    case PICOM_FIFO:
      {
	DWORD x = ReadFile (fromthem, res.handles, sizeof (res.handles), &nr, NULL);
	WriteFile (tothem, &x, sizeof (x), &x, NULL);
	if (!x)
	  goto err;
	if (nr != sizeof (res.handles))
	  {
	    set_errno (EPIPE);
	    goto err;
	  }
	break;
      }
d424 1
a424 2
  memset (&res, 0, sizeof (res));

@


1.76.2.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d18 1
a19 1
#include "fhandler.h"
@


1.76.2.3
log
@merge from trunk
@
text
@d523 1
a523 2
      if (((DWORD) procinfo & 0x77000000) == 0x61000000)
	try_to_debug ();
@


1.76.2.4
log
@merge from trunk
@
text
@d14 1
d364 1
a364 1
  if (!pid || !this || (dwProcessId != (DWORD) pid && !pinfo (myself->dwProcessId)))
@


1.76.2.5
log
@merge from trunk
@
text
@d409 1
a409 1
  for (int i = 0; (isalive = alive ()) || (i < 65536); i++)
@


1.76.2.6
log
@merge from trunk
@
text
@d409 1
a409 1
  for (int i = 0; (isalive = alive ()) && (i < 10000); i++)
@


1.76.2.7
log
@merge from trunk
@
text
@d295 2
a296 11
	extern int __argc_safe;
	const char *argv[__argc_safe + 1];
	for (int i = 0; i < __argc_safe; i++)
	  {
	    if (IsBadStringPtr (__argv[i], 0x7fffffff))
	      argv[i] = "";
	    else
	      argv[i] = __argv[i];
	    n += strlen (argv[i]) + 1;
	  }
	argv[__argc_safe] = NULL;
d303 1
a303 1
	  for (const char **a = argv; *a; a++)
d306 1
a306 1
		sigproc_printf ("WriteFile arg %d failed, %E", a - argv);
@


1.76.2.8
log
@merge from trunk
@
text
@d95 1
a95 1
      myself->gid = UNKNOWN_GID;
a143 2
  DWORD access = FILE_MAP_READ
                 | (flag & (PID_IN_USE | PID_EXECED | PID_MAP_RW) ? FILE_MAP_WRITE : 0);
d163 1
a163 1
	  h = OpenFileMappingA (access, FALSE, mapname);
d181 2
a182 1
      procinfo = (_pinfo *) MapViewOfFileEx (h, access, 0, 0, 0, mapaddr);
@


1.75
log
@* pinfo.cc (_pinfo::commune_send): Use myself->lock rather than just lock when
leaving.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
@


1.74
log
@* pinfo.cc (_pinfo::cmdline): Allocate sufficient space for myself command line
args.
@
text
@d427 1
a427 1
  LeaveCriticalSection (&lock);
@


1.74.4.1
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@a15 1
#include <stdarg.h>
a30 2
#include "cygheap.h"
#include "fhandler.h"
d307 5
a311 29
	if (!WriteFile (__tothem, "", 1, &nr, NULL))
	  {
	    sigproc_printf ("WriteFile null failed, %E");
	    break;
	  }
	break;
      }
    case PICOM_FIFO:
      {
	int formic;
	if (!ReadFile (__fromthem, &formic, sizeof formic, &nr, NULL)
	    || nr != sizeof formic)
	  {
	    /* __seterrno ();*/	// this is run from the signal thread, so don't set errno
	    goto out;
	  }
	fhandler_fifo *fh = cygheap->fdtab.find_fifo ((ATOM) formic);
	if (!WriteFile (__tothem, &(fh->get_handle ()), sizeof (HANDLE), &nr, NULL))
	  {
	    /*__seterrno ();*/	// this is run from the signal thread, so don't set errno
	    sigproc_printf ("WriteFile read handle failed, %E");
	  }

	if (!WriteFile (__tothem, &(fh->get_output_handle ()), sizeof (HANDLE), &nr, NULL))
	  {
	    /*__seterrno ();*/	// this is run from the signal thread, so don't set errno
	    sigproc_printf ("WriteFile write handle failed, %E");
	  }
	break;
d325 1
a325 1
_pinfo::commune_send (DWORD code, ...)
a330 3
  va_list args;

  va_start (args, code);
a361 11
  switch (code)
    {
    case PICOM_FIFO:
      {
	int formic = va_arg (args, int);
	if (WriteFile (tothem, &formic, sizeof formic, &nr, NULL) != sizeof formic)
	  goto err;
	break;
      }
    }

a409 6
    case PICOM_FIFO:
      if (n != sizeof (res.handles)
	  || !ReadFile (fromthem, res.handles, sizeof (res.handles), &nr, NULL)
	  || nr != n)
	goto err;
      break;
d424 1
a424 2
  memset (&res, 0, sizeof (res));

@


1.74.4.2
log
@* pinfo.cc (_pinfo::commune_send): Use myself->lock rather than just lock when
leaving.
@
text
@a325 1

d327 1
a327 3
	HANDLE it[] = {(fh->get_handle ()), (fh->get_output_handle ())};

	if (!WriteFile (__tothem, it, sizeof (it), &nr, NULL))
d333 5
a337 1
	(void) ReadFile (__fromthem, &nr, sizeof (nr), &nr, NULL);
d397 2
a398 5
	if (!WriteFile (tothem, &formic, sizeof formic, &nr, NULL) || nr != sizeof formic)
	  {
	    __seterrno ();
	    goto err;
	  }
d432 5
a439 5
      if (!ReadFile (fromthem, &n, sizeof n, &nr, NULL) || nr != sizeof n)
	{
	  __seterrno ();
	  goto err;
	}
d452 5
a456 12
      {
	DWORD x = ReadFile (fromthem, res.handles, sizeof (res.handles), &nr, NULL);
	WriteFile (tothem, &x, sizeof (x), &x, NULL);
	if (!x)
	  goto err;
	if (nr != sizeof (res.handles))
	  {
	    set_errno (EPIPE);
	    goto err;
	  }
	break;
      }
d475 1
a475 1
  LeaveCriticalSection (&myself->lock);
@


1.73
log
@* pinfo.h (winpids::set): Renamed from init.
(winpids::init): New declaration.
(winpids::cs): Ditto.
(winpids::winpids): Use set rather than init.
* external.cc (fillout_pinfo): Ditto.
* dcrt0.cc (dll_crt0_1): Call winpids::init.
* pinfo.cc (winpids::set): Renamed from init.  Wrap calls in critical section.
(winpids::init): New function.
(winpids::cs): Define.
@
text
@d447 1
a447 1
	n += strlen (*a);
@


1.72
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d616 2
d619 1
a619 1
winpids::init (bool winpid)
d621 1
d625 7
@


1.71
log
@* pinfo.cc (_pinfo::commune_send): Fix thinko in previous checkin.
@
text
@d215 1
a215 1
	  Sleep (5);
d371 1
a371 6
      {
	DWORD prio = GetThreadPriority (GetCurrentThread ());
	SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
	Sleep (0);
	SetThreadPriority (GetCurrentThread (), prio);
      }
@


1.70
log
@* pinfo.cc (_pinfo::commune_send): Set priority low when sleeping, waiting for
commune completion so that we don't spin waiting for lower priority processes.
@
text
@d372 2
a373 1
	DWORD prio = SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
@


1.69
log
@revert erroneous checkins
@
text
@d365 1
d371 5
a375 1
      Sleep (0);
@


1.68
log
@* sigproc.cc (WAIT_SIG_PRIORITY): Bump to THREAD_PRIORITY_TIME_CRITICAL.
@
text
@a236 2
  if (!dwProcessId)
    return 0;
@


1.67
log
@* pinfo.cc (_pinfo::commune_send): Initialize buffer or suffer random crashes.
@
text
@d237 2
@


1.66
log
@* external.cc (cygwin_internal): Implement CW_CMDLINE.
* pinfo.h (SIGCOMMUNE): New signal type.
(commune_result): New structure for commune functions.
(picom): New enum for commune functions.
(_pinfo::hello_pid): New.  Pid who's communicating with me.
(_pinfo::tothem): New.  Handle of communicating pipe.
(_pinfo::fromthem): Ditto.
(_pinfo::commune_recv): Declare.
(_pinfo::commune_send): Declare.
(_pinfo::alive): Declare.
(_pinfo::cmdline): Declare.
(_pinfo::lock): Declare.
* pinfo.cc (set_myself): Initialize new _pinfo lock.
(_pinfo::alive): Define.  Determines if process still exists.
(_pinfo::commune_recv): Define.  Receive info from another cooperating process.
(_pinfo::commune_send): Define.  Send info to another cooperating process.
(_pinfo::cmdline): Define.  Determine command line of a given process.
* include/sys/cygwin.h (CW_CMDLINE): Define.
*sigproc.cc (talktome): Communicate with any processes who want to talk to me.
(wait_sig): Honor __SIGCOMMUNE.
* fhandler.cc (fhandler_virtual::fixup_after_exec): Declare.
* fhandler_proc.cc: Use malloc/free/realloc throughout rather than cmalloc
since buffers don't need to be propagated to subprocesses.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
(fhandler_virtual::fixup_after_exec): Define.
* fhandler_process.cc: Ditto for malloc/free/realloc.
(process_listin): Add "cmdline".
(fhandler_process::fill_filebuf): Implement PROCESS_CMDLINE.
* miscfuncs.cc (isalpha_array): New array populated with xor values for alpha
characters to switch from one case to another.
* string.h (cygwin_strcasematch): New asm implementation of case match.
* string.h (cygwin_nstrcasematch): New asm implementation of counted case
match.
@
text
@d331 4
@


1.66.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d69 1
d232 221
@


1.65
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::mount_table): Remove.
(child_info_fork::myself_addr): Remove.
* fork.cc (fork_child): Don't set either of the above.
* dcrt0.cc (dll_crt0_1): Call memory_init as early as possible.
* fhandler_console.cc (console_state): Move to shared_info.h.
(fhandler_console::get_tty_stuff): Reflect open_shared arg change.
* pinfo.cc (myself_addr): Remove definition.
(pinfo::init): Get myself address from open_shared.
* pinfo.h (myself_addr): Remove declaration.
* shared.cc (open_shared): Rework so that known shared memory locations are
protected.  Take shared memory type as fifth argument.
(memory_init): Reflect open_shared arg change.
* shared_info.h (shared_locations): New enum.
(console_state): Move here.
(open_shared): Reflect open_shared arg change in declaration.
@
text
@d69 1
d232 221
@


1.64
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::heaptop): Remove obsolete element.
(child_info_fork::heabbase): Ditto.
(child_info_fork::heapptr): Ditto.
(child_info_fork::mount_table): New element.
(child_info_fork::myself_addr): Ditto.
* dcrt0.cc (dll_crt0_1): Set mount_table and myself_addr when forking.
(initial_env): Add newline to "sleeping" message.
* dll_init.cc (reserve_upto): Accommodate cygwin heap when freeing memory.
Make debugging output a little more descriptive.
* fork.cc (fork_parent): Save mount_table and myself_addr.
* pinfo.cc (myself_addr): New variable.
(set_myself): Pass PID_MYSELF flag to init.
(pinfo::Init): Honor PID_MYSELF.  Save address where myself shared memory
resides in myself_addr, for fork.
* pinfo.h (myself_addr): Declare.
* shared.cc (memory_init): On fork, use previously saved address for location
of mount table.
* include/sys/cygwin.h (PID_MYSELF): New value.
* dtable.cc (dtable::stdio_init): Don't pass access type to
init_std_file_from_handle.  It's always the same.
(dtable::init_std_file_from_handle): Remove access type argument.  Assume
read/write.
* dtable.h (dtable::init_std_file_from_handle): Ditto for declaration.
* exceptions.cc (try_to_debug): Don't try to debug if already being debugged.
* fhandler_console.cc (shared_console_info_save): New variable.
(fhandler_console::get_tty_stuff): Save address of shared console stuff for
fork.
@
text
@d30 1
a36 1
_pinfo NO_COPY *myself_addr;
a130 1
  bool itsme;
d132 1
a132 4
    {
      mapaddr = NULL;
      itsme = false;
    }
d136 2
a137 2
      mapaddr = myself_addr;
      itsme = true;
a180 2
      if (itsme)
	myself_addr = procinfo;
@


1.63
log
@* cygthread.cc (cygthread::stub): Don't create event for long-running threads.
Initialize thread_sync event here which is used to Suspend using an event
rather than relying on SuspendThread/ResumeThread.
(cygthread::init): Save handle to runner thread for future termination.
(cygthread::cygthread): Only resume thread when it is actually suspended.
Otherwise signal thread completion event.
(cygthread::terminate): Forcibly terminate runner thread and any helper
threads.  Call DisableThreadLibrary calls if execing.
* cygthread.h (cygthread::thread_sync): Declare.
* dcrt0.cc (do_exit): Eliminate calls to obsolete window_terminate and
shared_terminate.
* exceptions.cc (events_terminate): Don't bother closing title_mutex since it
is going away anyway.
* pinfo.cc (_pinfo::exit): Call cygthread::terminate to ensure that threads are
shut down before process exit or otherwise strange races seem to occur.
* shared.cc (shared_terminate): Eliminate.
* shared.h (shared_terminate): Eliminate declaration.
* winsup.h (window_terminate): Eliminate declaration.
* spawn.cc (spawn_guts): Call cygthread::terminate early in process if execing.
Call DisableThreadLibrary calls if execing.
* window.cc (Winmain): Call ExitThread to force exit.
(window_terminate): Eliminate.
* dcrt0.cc (do_exit): Track exit state more closely.
@
text
@d36 1
d61 1
a61 1
  myself.init (pid, 1, h);
d130 14
d182 2
a183 1
      procinfo = (_pinfo *) MapViewOfFile (h, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
d185 2
@


1.62
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d29 1
d113 1
@


1.61
log
@Use hMainProc where appropriate, throughout.
* environ.cc (spenv::retrieve): Add debugging statements.
* pinfo.cc (set_myself): Don't call strace.hello if already stracing.
* strace.cc (strace): Move NO_COPY keyword so that it will actually take
effect.
@
text
@d64 1
a64 2
  (void) GetModuleFileName (NULL, myself->progname,
			    sizeof(myself->progname));
@


1.60
log
@* pinfo.cc (pinfo_dummy): Initialize to correct size.
@
text
@d66 2
a67 1
  strace.hello ();
@


1.59
log
@	* autoload.cc: Replace autoload statments for ZwXXX by NtXXX.
	Drop ZwQuerySystemInformation since NtQuerySystemInformation was
	already available.
	* fhandler_proc.cc (format_proc_uptime): Replace call to
	ZwQuerySystemInformation by call to NtQuerySystemInformation.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Replace call to
	ZwQueryInformationProcess by call to NtQueryInformationProcess.
	(get_process_state): Ditto.
	(get_mem_values): Ditto.  Replace call to ZwQueryVirtualMemory by
	call to NtQueryVirtualMemory.
	* ntdll.h: Cleanup.  Drop ZwQuerySystemInformation since
	NtQuerySystemInformation was already available.  Replace declarations
	of ZwXXX functions by declarations of NtXXX.
	* pinfo.cc (winpids::enumNT): Replace call to ZwQuerySystemInformation
	by call to NtQuerySystemInformation.
@
text
@d30 1
a30 1
static char NO_COPY pinfo_dummy[sizeof(pinfo)] = {0};
@


1.58
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d321 1
a321 1
      res = ZwQuerySystemInformation (SystemProcessesAndThreadsInformation,
@


1.57
log
@* pinfo.cc (pinfo::init): Use PID_ALLPIDS flag to control when a redirected
block should be marked as nonexistent.
(winpids::add): Use PID_ALLPIDS when looking for all pids.
* cygwin.h (PID_ALLPIDS): New enum element.
@
text
@a20 1
#include "sync.h"
@


1.56
log
@* pinfo.cc (pinfo::init): Properly handle execed process stub when PID_NOREDIR
is specified.
@
text
@d186 1
a186 1
	  if (flag & PID_NOREDIR)
d290 1
a290 1
  pinfolist[nelem].init (cygpid, PID_NOREDIR);
@


1.55
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d186 5
@


1.54
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001 Red Hat, Inc.
@


1.53
log
@* external.cc (cygwin_internal): Initialize various internal settings if
required to allow use of some things from user loaded DLL.
(CW_STRACE_ON): Add new feature.
(CW_CYGWIN_PID_TO_WINPID): Ditto.
* pinfo.cc (set_myself): Call "strace.hello" to initiate possible strace
session.
(pinfo::init): Guard against dereferencing uninitialized myself.
* sigproc.cc (wait_sig): Call strace.hello() when __SIGTRACE "signal" received.
* strace.cc (strace::hello): New method.
* wincap.cc (wincapc::init): Avoid initializing if already initialized.
* wincap.h (wincapc::wincapc): New method.
* include/sys/cygwin.h: Add new CW_ enums.  Kludge typedefs of {g,u}id_t if
required.
* strace.h (strace::hello): Declare new method.
@
text
@d90 1
a90 1
      myself->uid = USHRT_MAX;
@


1.52
log
@* Makefile.in: Autogenerate some header files which provide magic numbers.
Force dependencies for files which depend on autogenerated headers to ensure
that they are always built.
* child_info.h (child_info): Add new fields to accommodate new magic number
header stuff.
* dcrt0.cc: Rely on "child_info_magic.h" to ensure that correct child_info
magic numbers are used.
(dll_crt0_1): Temporarily remove _cygwin_testing_magic test.
(_dll_crt0): Do more testing on magic numbers from fork_info structure.  Call
"multiple_cygwin_problem" where appropriate.
(multiple_cygwin_problem): Rename from multiple_cygwin_die.  Issue a warning or
die, as appropriate based on cygwin version/magic number mismatch.
* pinfo.cc (pinfo::exit): Don't attempt to dereference `this' if it doesn't
exist.  This can happen when a fatal error occurs early in process
initialization.
* shared.cc: Rely on "shared_info_magic.h" to accommodate that new magic number
header stuff.
(shared_info::initialize): Use new magic number stuff, for shared region.
(memory_init): Ditto, for mount table.
* shared_info.h: Accomodate new magic number stuff for shared region and mount
table.
* sigproc.cc: Rely on "child_info_magic.h" to accommodate new magic number
header stuff.
(init_child_info): Initialize new fields in child_info) to accomodate magic
numbers.
* winsup.h: Rename multiple_cygwin_die to multiple_cygwin_problem.
* include/cygwin/version.h: Define macros for manipulating version magic.
* cygmagic: New shell script for generating magic numbers.
@
text
@a64 5
  char buf[30];
  __small_sprintf (buf, "cYg%8x %x", _STRACE_INTERFACE_ACTIVATE_ADDR,
		   &strace.active);
  OutputDebugString (buf);

d67 1
a67 15
  if (strace.active)
    {
      strace.prntf (1, NULL, "**********************************************");
      strace.prntf (1, NULL, "Program name: %s (%d)", myself->progname, myself->pid);
      strace.prntf (1, NULL, "App version:  %d.%d, api: %d.%d",
		       user_data->dll_major, user_data->dll_minor,
		       user_data->api_major, user_data->api_minor);
      strace.prntf (1, NULL, "DLL version:  %d.%d, api: %d.%d",
		       cygwin_version.dll_major, cygwin_version.dll_minor,
		       cygwin_version.api_major, cygwin_version.api_minor);
      strace.prntf (1, NULL, "DLL build:    %s", cygwin_version.dll_build_date);
      strace.prntf (1, NULL, "OS version:   Windows %s", wincap.osname ());
      strace.prntf (1, NULL, "**********************************************");
    }

d72 1
a72 1
   This is not called for fork'd tasks, only exec'd ones.  */
d120 1
a120 1
  if (n == myself->pid)
d260 1
a260 1
  pinfo p (winpid);
@


1.51
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d120 4
a123 2
  if (!norecord)
    process_state = PID_EXITED;
d125 6
a130 5
  /* FIXME:  There is a potential race between an execed process and its
     parent here.  I hated to add a mutex just for this, though.  */
  struct rusage r;
  fill_rusage (&r, hMainProc);
  add_rusage (&rusage_self, &r);
@


1.50
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d185 2
a186 1
      if ((procinfo->process_state & PID_INITIALIZING) && (flag & PID_NOREDIR))
@


1.49
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d296 2
a297 2
      pidlist = (DWORD *) realloc (pidlist, size_pidlist (npidlist));
      pinfolist = (pinfo *) realloc (pinfolist, size_pinfolist (npidlist));
d327 1
a327 1
    procs = (SYSTEM_PROCESSES *) malloc (szprocs = 200 * sizeof (*procs));
d390 2
a391 1
  pidlist[npids] = 0;
@


1.48
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d18 1
@


1.48.2.1
log
@Merged changes from HEAD
@
text
@a17 1
#include "path.h"
@


1.48.2.2
log
@Merged changes from HEAD
@
text
@d120 2
a121 4
  if (this)
    {
      if (!norecord)
	process_state = PID_EXITED;
d123 5
a127 6
      /* FIXME:  There is a potential race between an execed process and its
	 parent here.  I hated to add a mutex just for this, though.  */
      struct rusage r;
      fill_rusage (&r, hMainProc);
      add_rusage (&rusage_self, &r);
    }
d185 1
a185 2
      if ((procinfo->process_state & PID_INITIALIZING) && (flag & PID_NOREDIR)
	  && cygwin_pid (procinfo->dwProcessId) != procinfo->pid)
d296 2
a297 2
      pidlist = (DWORD *) realloc (pidlist, size_pidlist (npidlist + 1));
      pinfolist = (pinfo *) realloc (pinfolist, size_pinfolist (npidlist + 1));
d327 1
a327 1
    procs = (SYSTEM_PROCESSES *) malloc (sizeof (*procs) + (szprocs = 200 * sizeof (*procs)));
d390 1
a390 2
  if (pidlist)
    pidlist[npids] = 0;
@


1.48.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
d65 5
d72 15
a86 1
  strace.hello ();
d91 1
a91 1
   This is not called for forked tasks, only execed ones.  */
d109 1
a109 1
      myself->uid = ILLEGAL_UID;
d139 1
a139 1
  if (myself && n == myself->pid)
d279 1
a279 1
  pinfo p (cygwin_pid (winpid));
@


1.48.2.4
log
@Merged changes from HEAD
@
text
@d21 1
d31 1
a31 1
static char NO_COPY pinfo_dummy[sizeof (_pinfo)] = {0};
a185 5
	  if (flag & PID_ALLPIDS)
	    {
	      set_errno (ENOENT);
	      break;
	    }
d285 1
a285 1
  pinfolist[nelem].init (cygpid, PID_NOREDIR | (winpid ? PID_ALLPIDS : 0));
d317 1
a317 1
      res = NtQuerySystemInformation (SystemProcessesAndThreadsInformation,
@


1.48.2.5
log
@Merged changes from HEAD
@
text
@d66 1
a66 2
  if (!strace.active)
    strace.hello ();
@


1.48.2.6
log
@Merged changes from HEAD
@
text
@d64 2
a65 1
  (void) GetModuleFileName (NULL, myself->progname, sizeof (myself->progname));
@


1.47
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@a72 1
      extern char osname[];
d82 1
a82 1
      strace.prntf (1, NULL, "OS version:   Windows %s", osname);
d395 1
a395 1
  if (iswinnt)
@


1.46
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d34 1
a34 1
HANDLE hexec_proc = NULL;
d322 1
a322 1
  static DWORD szprocs = 0;
@


1.45
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d396 1
a396 1
  if (os_being_run == winNT)
@


1.44
log
@forced commit
@
text
@d16 1
a25 1
#include "security.h"
@


1.43
log
@* pinfo.cc: Use autoloaded ToolHelp functions throughout for Win9x.
* autoload.cc: Autoload ToolHelp functions.
@
text
@@


1.42
log
@minor formatting changes.
@
text
@a284 8
typedef HANDLE (WINAPI * CREATESNAPSHOT) (DWORD, DWORD);
typedef BOOL (WINAPI * PROCESSWALK) (HANDLE, LPPROCESSENTRY32);
typedef BOOL (WINAPI * CLOSESNAPSHOT) (HANDLE);

static NO_COPY CREATESNAPSHOT myCreateToolhelp32Snapshot = NULL;
static NO_COPY PROCESSWALK myProcess32First = NULL;
static NO_COPY PROCESSWALK myProcess32Next  = NULL;

d364 1
a364 1
  HANDLE h = myCreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);
d374 1
a374 1
  if (myProcess32First (h, &proc))
d380 1
a380 1
    while (myProcess32Next (h, &proc));
a395 1
  HINSTANCE h;
d399 1
a399 16
    {
      h = GetModuleHandle ("kernel32.dll");
      myCreateToolhelp32Snapshot = (CREATESNAPSHOT)
		  GetProcAddress(h, "CreateToolhelp32Snapshot");
      myProcess32First = (PROCESSWALK)
	      GetProcAddress (h, "Process32First");
      myProcess32Next  = (PROCESSWALK)
	      GetProcAddress (h, "Process32Next");
      if (!myCreateToolhelp32Snapshot || !myProcess32First || !myProcess32Next)
	{
	  system_printf ("Couldn't find toolhelp processes, %E");
	  return 0;
	}

      enum_processes = &winpids::enum9x;
    }
@


1.41
log
@        * pinfo.cc (pinfo::init): Use INVALID_HANDLE_VALUE instead of
        explicit cast (HANDLE) 0xffffffff.
        * shared.cc (open_shared): Ditto.
@
text
@d346 1
a346 1
	procs =  (SYSTEM_PROCESSES *)realloc (procs, szprocs += 200 * sizeof (*procs));
d382 1
a382 1
  if (myProcess32First(h, &proc))
d409 1
a409 1
      h = GetModuleHandle("kernel32.dll");
d413 1
a413 1
	      GetProcAddress(h, "Process32First");
d415 1
a415 1
	      GetProcAddress(h, "Process32Next");
@


1.40
log
@* pinfo.cc (codepage_init): Move function.
* environ.cc (codepage_init): To here.
* exceptoins.cc (SIG_NONMASKABLE): Remove SIGCONT from consideration since it
is supposed to be maskable.
* signal.cc (sigaction): Ditto.
* sigproc.cc (wait_sig): Ditto.
* winsup.h: Eliminate global declaration of codepage_init.
@
text
@d169 2
a170 2
	  h = CreateFileMapping ((HANDLE) 0xffffffff, &sec_all_nih,
				  PAGE_READWRITE, 0, mapsize, mapname);
@


1.39
log
@* autoload.cc: Autoload CharToOemA.
* dcrt0.cc (dll_crt0_1): Translate command line to OEM if current codepage is
OEM.
* environ.cc: Add new option 'codepage' to CYGWIN environment variable.
* fhandler_clipboard.cc (fhandler_clipboard::read): Read clipboard in OEM mode
if current codepage is OEM.
* fhandler_console.cc (fhandler_console::read): Only translate console input if
current codepage is ANSI.
* fhandler_console.cc (fhandler_console::write_normal): Translate output data
if current codepage is ANSI.
* pinfo.cc (codepage_init): New function.  Setup current codepage from CYGWIN
environment variable and set codepage for file APIs.
* security.cc (read_sd): Translate file name to it if current codepage is OEM.
* winsup.h: (sys_wcstombs,sys_mbstowcs): Use current codepage for translations
between multibyte and widechar string and vice versa.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000 Cygnus Solutions.
a89 25
extern "C" void
codepage_init (const char *buf)
{
  if (!buf || !*buf)
    return;

  if ( strcmp ( buf, "oem" ) == 0 )
    {
      current_codepage = oem_cp;
      SetFileApisToOEM ();
      debug_printf ( "File APIs set to OEM" );
    }
  else if ( strcmp ( buf, "ansi" ) == 0 )
    {
      current_codepage = ansi_cp;
      SetFileApisToANSI ();
      debug_printf ( "File APIs set to ANSI" );
    }
  else
    {
      debug_printf ( "Wrong codepage name: %s", buf );
    }
}


d317 1
a317 1
      if (pinfolist[i]->pid == pinfolist[nelem]->pid )
@


1.38
log
@* pinfo.cc (winpids:add): New method.
(winpids::enumNT): New method renamed from EnumProcessesNT.  Use add method to
add elements to the lists.
(winpids::enum9x): New method renamed from EnumProcesses9x.  Use add method to
add elements to the lists.
(winpids::enum_init): Accept 'winpid' parameter to control whether to add all
windows pids to the list.
(winpids::release): New method.
* pinfo.h (winpids): Reflect above changes.
* signal.cc (kill_pgrp): Ditto.
* external.cc (fillout_pinfo): Ditto.
@
text
@d90 25
@


1.37
log
@* pinfo.cc (EnumProcessesNT): Avoid 0 pids.
(EnumProcesses9x): Ditto.
* sigproc.cc (remove_childe): Eliminate.
(proc_subproc): Move remove_child stuff here.
(wait_subproc): Synchronize with proc_subproc when error occurs.  Add more
debugging info.
* sigproc.h (procstuff): Add an entry.
* spawn.cc (spawn_guts): Add sigframe here.
@
text
@a284 1
typedef DWORD (WINAPI * ENUMPROCESSES) (DWORD* &, DWORD &);
a291 3
static DWORD WINAPI enum_init (DWORD* &, DWORD&);

static NO_COPY ENUMPROCESSES myEnumProcesses = enum_init;
d295 28
d324 5
a328 2
static DWORD WINAPI
EnumProcessesNT (DWORD* &pidlist, DWORD &npidlist)
d358 3
a360 10
	{
	  if (nelem >= npidlist)
	    {
	      npidlist += slop_pidlist;
	      pidlist = (DWORD *) realloc (pidlist, size_pidlist (npidlist));
	    }
	  pidlist[nelem++] = cygwin_pid (px->ProcessId);
	  if (!px->NextEntryDelta)
	    break;
	}
d367 2
a368 2
static DWORD WINAPI
EnumProcesses9x (DWORD* &pidlist, DWORD &npidlist)
d385 2
a386 8
	if (!proc.th32ProcessID)
	  continue;
	if (nelem >= npidlist)
	  {
	    npidlist += slop_pidlist;
	    pidlist = (DWORD *) realloc (pidlist, size_pidlist (npidlist));
	  }
	pidlist[nelem++] = cygwin_pid (proc.th32ProcessID);
d395 1
a395 1
winpids::init ()
d397 1
a397 1
  npids = myEnumProcesses (pidlist, npidlist);
d401 2
a402 2
static DWORD WINAPI
enum_init (DWORD* &pidlist, DWORD& npidlist)
d406 1
a406 1
    myEnumProcesses = EnumProcessesNT;
d422 1
a422 1
      myEnumProcesses = EnumProcesses9x;
d425 19
a443 1
  return myEnumProcesses (pidlist, npidlist);
@


1.36
log
@* pinfo.cc (pinfo::init): Reverse order of setting status and pid info in an
execed process to avoid a race.
* sigproc.cc (wait_subproc): Print more info when a WFSO error occurs.
* automode.c: New file.
* syscalls.cc (close_all_files): Streamline slightly.
* cygheap.cc (ccalloc): Clear *entire* allocated array.
@
text
@d330 1
a330 1
      if (nelem >= npidlist)
d332 8
a339 2
	  npidlist += slop_pidlist;
	  pidlist = (DWORD *) realloc (pidlist, size_pidlist (npidlist));
a340 3
      pidlist[nelem++] = cygwin_pid (px->ProcessId);
      if (!px->NextEntryDelta)
	break;
d365 2
@


1.35
log
@* pinfo.cc (EnumProcessesNT): New function.  Eliminates dependence on psapi.h.
(EnumProcesses9x): Rename from EnumProcessesW95.  Change arguments to be more
useful for cygwin.
(winpids::init): Accomodate argument changes.
(enum_init): Ditto.
* pinfo.h (winpids): Make pidlist dynamically extendable by storing it as a
pointer and remembering the size.
* ntdll.h: Add extra definitions needed for EnumProcessesNT.  Reformat via
'indent'.
@
text
@d222 1
a223 1
	  procinfo->process_state |= PID_IN_USE | PID_EXECED;
@


1.34
log
@* pinfo.cc (enum_init): Don't suffer silently if we can't load the process
enumerators.
@
text
@d27 2
a283 1
#include <psapi.h>
d285 1
a285 1
typedef BOOL (WINAPI * ENUMPROCESSES) (DWORD *, DWORD, DWORD *);
d293 1
a293 1
static BOOL WINAPI enum_init (DWORD *lpidProcess, DWORD cb, DWORD *cbneeded);
d297 49
a345 2
static BOOL WINAPI
EnumProcessesW95 (DWORD *lpidProcess, DWORD cb, DWORD *cbneeded)
d347 1
a347 1
  HANDLE h;
d349 1
a349 2
  *cbneeded = 0;
  h = myCreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);
d351 4
a354 1
    return 0;
a356 1
  int i = 0;
d358 1
d361 8
a368 1
      lpidProcess[i++] = cygwin_pid (proc.th32ProcessID);
d370 1
d372 1
a372 4
  if (i == 0)
    return 0;
  *cbneeded = i * sizeof (DWORD);
  return 1;
d378 1
a378 6
  DWORD n;
  if (!myEnumProcesses (pidlist, sizeof (pidlist) / sizeof (pidlist[0]), &n))
    npids = 0;
  else
    npids = n / sizeof (pidlist[0]);

d382 2
a383 2
static BOOL WINAPI
enum_init (DWORD *lpidProcess, DWORD cb, DWORD *cbneeded)
d387 1
a387 14
    {
      h = LoadLibrary ("psapi.dll");
      if (!h)
	{
	  system_printf ("couldn't load psapi.dll, %E");
	  return 0;
	}
      myEnumProcesses = (ENUMPROCESSES) GetProcAddress (h, "EnumProcesses");
      if (!myEnumProcesses)
	{
	  system_printf ("couldn't locate EnumProcesses in psapi.dll, %E");
	  return 0;
	}
    }
d403 1
a403 1
      myEnumProcesses = EnumProcessesW95;
d406 1
a406 1
  return myEnumProcesses (lpidProcess, cb, cbneeded);
@


1.33
log
@        * pinfo.cc (pinfo_init): Eliminate call to `set_process_privileges'.
        * security.cc (write_sd): Call `set_process_privileges' on the first
        call to `write_sd'.
        (set_process_privileges): Eliminate adjusting SE_BACKUP_NAME privilege.
@
text
@d340 4
a343 1
	return 0;
d346 4
a349 1
	return 0;
d361 4
a364 1
	return 0;
@


1.32
log
@Fix typo.
@
text
@a111 5
  /* Allow backup semantics. It's better done only once on process start
     instead of each time a file is opened. */
  if (allow_ntsec)
    set_process_privileges ();

@


1.31
log
@* pinfo.cc (pinfo::init): Make PID_EXECED signal creation as well as
PID_IN_USE.
@
text
@d147 1
a147 1
  int createit = flag & PID_IN_USE | PID_EXECED;
@


1.30
log
@* fhandler.h (fhandler_console): Remove tcsetpgrp.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Eliminate.
* fork.cc (fork_parent): Avoid returning same pid twice in a row regardless of
OS.
* pinfo.cc (pinfo::init): Rename create argument to flags and treat it as such.
* signal.cc (set_sigcatchers): New function.
(signal): Use set_sigcatchers to increment or decrement sigcatcher tracker.
(sigaction): Ditto.  Add debugging output.
* spawn.cc (spawn_guts): Always quote first argv[0] argument when it's a
COMSPEC shell.
@
text
@d147 1
a147 1
  int createit = flag & PID_IN_USE;
@


1.29
log
@* external.cc (fillout_pinfo): Pass PID_NOREDIR flag to pinfo init to avoid
finding execed processes twice.
* signal.cc (kill_pgrp): Ditto.
* spawn.cc (spawn_guts): Avoid passing first argument to CreateProcess when
running a windows shell so that CreateProcess will locate the shell.
Reorganize so that correct error is returned when CreateProcess fails.
@
text
@d137 1
a137 1
pinfo::init (pid_t n, DWORD create, HANDLE in_h)
d147 1
d155 1
a155 1
      if (create & PID_EXECED)
d165 1
a165 1
      else if (!create)
d179 1
a179 1
	  if (create)
d188 1
a188 1
      if ((procinfo->process_state & PID_INITIALIZING) && (create & PID_NOREDIR))
d212 1
a212 1
      if (i < 9 && !created && create && (procinfo->process_state & PID_EXITED))
d221 1
a221 1
      else if (!(create & PID_EXECED))
@


1.28
log
@* sigproc.h (sigthread): Eliminate locking for now since per thread signalling
is not available.
* dcrt0.cc (sigthread::init): Ditto.
(dll_crt0_1): Move set_process_privileges call (temporarily?) to pinfo_init.
(pinfo_init): Only call set_process_privileges when allow_ntsec.
@
text
@a165 1
	  /* CGF FIXME -- deal with inheritance after an exec */
d187 7
d241 1
@


1.27
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d112 5
@


1.26
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@a18 1
#include "thread.h"
d32 1
a32 1
static HANDLE hexec_proc = NULL;
a47 13
void __stdcall
pinfo_fixup_in_spawned_child (HANDLE hchild)
{
  HANDLE h;
  if (!hexec_proc)
    return;
  if (!DuplicateHandle (hchild, hexec_proc, hMainProc, &h, 0, TRUE,
			DUPLICATE_CLOSE_SOURCE))
    system_printf ("couldn't close handle %p in child, %E", hexec_proc);
  else
    CloseHandle (h);
}

d91 1
a91 1
pinfo_init (char **envp)
d95 1
a95 1
      environ_init (envp);
d109 1
a109 1
      environ_init (NULL);	/* call after myself has been set up */
d116 1
a116 1
_pinfo::exit (UINT n)
d118 9
a126 1
  process_state = PID_EXITED;
a128 78
}

struct sigaction&
_pinfo::getsig(int sig)
{
#ifdef _MT_SAFE
  if (thread2signal)
    return thread2signal->sigs[sig];
  return sigs[sig];
#else
  return sigs[sig];
#endif
};

sigset_t&
_pinfo::getsigmask ()
{
#ifdef _MT_SAFE
  if (thread2signal)
    return *thread2signal->sigmask;
  return sig_mask;
#else
  return sig_mask;
#endif
};

void
_pinfo::setsigmask (sigset_t _mask)
{
#ifdef _MT_SAFE
  if (thread2signal)
	*(thread2signal->sigmask) = _mask;
  sig_mask=_mask;
#else
  sig_mask=_mask;
#endif
}

LONG *
_pinfo::getsigtodo(int sig)
{
#ifdef _MT_SAFE
  if (thread2signal)
    return thread2signal->sigtodo + __SIGOFFSET + sig;
  return _sigtodo + __SIGOFFSET + sig;
#else
  return _sigtodo + __SIGOFFSET + sig;
#endif
}

extern HANDLE hMainThread;

HANDLE
_pinfo::getthread2signal()
{
#ifdef _MT_SAFE
  if (thread2signal)
    return thread2signal->win32_obj_id;
  return hMainThread;
#else
  return hMainThread;
#endif
}

void
_pinfo::setthread2signal(void *_thr)
{
#ifdef _MT_SAFE
   // assert has myself lock
   thread2signal=(ThreadItem*)_thr;
#else
#endif
}

void
_pinfo::copysigs(_pinfo *_other)
{
  sigs = _other->sigs;
@


1.25
log
@* cygheap.cc (cygheap_fixup_in_child): Don't page round cygheap copied from
parent.
* dcrt0.cc (do_exit): Don't cleanup pinfo on exit.  That happens automatically
now.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_parent): Use stack_here value passed in from fork().
(fork): Figure out top of stack here and pass it to fork_parent.
* pinfo.cc (_pinfo::record_death): Eliminate.
* pinfo.h (_pinfo): Ditto.
* sigproc.cc (proc_exists): Simplify.
(proc_terminate): Ditto.
(remove_zombie): Don't cleanup pinfo stuff.
(wait_sig): Send subproc_ready signal whether execed or spawned.
* spawn.cc (spawn_guts): Always create subproc_ready event.  Use it for both
exec and spawn.
(_spawnve): Send proper mode to spawn_guts when mode != _P_OVERLAY.
@
text
@d27 1
d33 29
d129 8
d226 29
a254 9
  int created;
  char mapname[MAX_PATH];
  __small_sprintf (mapname, "cygpid.%x", n);

  int mapsize;
  if (create & PID_EXECED)
    mapsize = PINFO_REDIR_SIZE;
  else
    mapsize = sizeof (_pinfo);
d256 7
a262 17
  if (in_h)
    {
      h = in_h;
      created = 0;
    }
  else if (!create)
    {
      /* CGF FIXME -- deal with inheritance after an exec */
      h = OpenFileMappingA (FILE_MAP_READ | FILE_MAP_WRITE, FALSE, mapname);
      created = 0;
    }
  else
    {
      h = CreateFileMapping ((HANDLE) 0xffffffff, &sec_all_nih,
			      PAGE_READWRITE, 0, mapsize, mapname);
      created = h && GetLastError () != ERROR_ALREADY_EXISTS;
    }
d264 2
a265 7
  if (!h)
    {
      if (create)
	__seterrno ();
      procinfo = NULL;
      return;
    }
d267 11
a277 2
  ProtectHandle1 (h, pinfo_shared_handle);
  procinfo = (_pinfo *) MapViewOfFile (h, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
d279 11
a289 9
  if (procinfo->process_state & PID_EXECED)
    {
      pid_t realpid = procinfo->pid;
      debug_printf ("execed process windows pid %d, cygwin pid %d", n, realpid);
      release ();
      if (realpid == n)
	api_fatal ("retrieval of execed process info for pid %d failed due to recursion.", n);
      return init (realpid);
    }
d291 3
a293 3
  if (created)
    {
      if (!(create & PID_EXECED))
d300 1
a301 1

@


1.24
log
@* dtable.cc (dtable::fixup_after_fork): Revert thinko below.
* pinfo.cc (set_myself): Show pid in initial strace line.
@
text
@a177 11
_pinfo::record_death ()
{
  /* CGF FIXME - needed? */
  if (dwProcessId == GetCurrentProcessId () && !my_parent_is_alive ())
    {
      process_state = PID_NOT_IN_USE;
      hProcess = NULL;
    }
}

void
@


1.23
log
@* dtable.cc (set_std_handle): Use std_consts array to control SetStdHandle
settings.
(dtable::fixup_after_fork): Ditto.
* exceptions.cc (set_sig_errno): Remove some debugging output.
* path.cc (path_conv::check): Don't OR need_directory with flags sent to
symlink_info::check.
(symlink_info::check): Use PATH_ALL_EXEC to determine when a file is
executable.
* path.h (path_types): Add PATH_ALL_EXEC.
(isexec): Use PATH_ALL_EXEC so that cygexec types will be considered
executable.
* pinfo.h (_pinfo): Add a process handle that is kept open throughout the life
of a cygwin pid.
* sigproc.cc (proc_exists): Remove hopefully obsolete stuff.
(proc_subproc): Set up process handle that is kept open throughout the life of
a cygwin pid.  Reorganize PROC_WAIT stuff to use common code.
(proc_terminate): Close pid lifetime process handle.
(checkstate): Cleanup.
(stopped_or_terminated): Move zombie cleanup.
(remove_zombie): To here.
* spawn.cc (spawn_guts): Reorganize reparenting code for 1247th time.
@
text
@d57 1
a57 1
      strace.prntf (1, NULL, "Program name: %s", myself->progname);
@


1.22
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d261 1
@


1.21
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d23 4
@


1.20
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d99 1
a99 1
  if ( thread2signal )
d111 1
a111 1
  if ( thread2signal )
d123 1
a123 1
  if ( thread2signal )
d135 1
a135 1
  if ( thread2signal )
d149 1
a149 1
  if ( thread2signal )
@


1.19
log
@* pinfo.h (pinfo): Un-inline release.
* pinfo.cc (pinfo::release): Move here from pinfo.h.
* sigproc.cc (proc_terminate): Remove bogus 'pinfo child' which caused strange
destruction of random regions of memory when destructor was invoked.
@
text
@d71 1
a71 1
pinfo_init (LPBYTE info)
d73 1
a73 1
  if (info != NULL)
d75 1
a75 4
      /* The process was execed.  Reuse entry from the original
	 owner of this pid. */
      environ_init (0);	  /* Needs myself but affects calls below */

a76 1

a77 7

      /* Inherit file descriptor information from parent in info.
       */
      LPBYTE b = fdtab.de_linearize_fd_array (info);
      extern char title_buf[];
      if (b && *b)
	old_title = strcpy (title_buf, (char *)b);
d89 1
a89 1
      environ_init (0);		/* call after myself has been set up */
@


1.18
log
@* dcrt0.cc (dll_crt0_1): Move set_os_type.
(_dll_crt0): To here.
(cygwin_dll_init): And here.
* external.cc (fillout_pinfo): Use more foolproof method for scanning for pids.
* pinfo.cc (set_myself): Eliminate myself_identity.init.
* sigproc.cc (wait_sig): Do it here instead to reduce the amount of time where
there could potentially be two processes with the same pid.
* spawn.cc (spawn_guts): Eliminate duplicate initialization.
* include/sys/cygwin.h: Mark unused PID_* elements.
@
text
@d200 1
a200 1
      child = myself;
d238 1
a238 1
      child = NULL;
d243 1
a243 1
  child = (_pinfo *) MapViewOfFile (h, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
d245 1
a245 1
  if (child->process_state & PID_EXECED)
d247 1
a247 1
      pid_t realpid = child->pid;
d258 1
a258 1
	child->pid = n;
d261 2
a262 2
	  child->pid = myself->pid;
	  child->process_state |= PID_IN_USE | PID_EXECED;
d267 13
@


1.17
log
@* dcrt0.cc (dll_crt0_1): Move exception list and constructor stuff earlier in
the process.  Use new second argument to set_myself.
(cygwin_dll_init): Initialize exception list and constructor stuff here.
(_dll_crt0): And here.  Also, deal with inherited pinfo shared memory region
from parent.
* pinfo.cc (set_myself): Accept a second argument signifying the a shared
memory region, passed from an execing parent.
(pinfo_init): Ditto.
* pinfo.h: Ditto.
* shared.h (child_info): Add a handle field to pass to child.
* spawn.cc (spawn_guts): Create a shared handle to pass to an execed child.
* winsup.h: Remove extraneous declaration.
@
text
@a26 1
static pinfo NO_COPY myself_identity ((_pinfo *)&pinfo_dummy);
a40 3
  pid_t myself_cyg_pid = cygwin_pid (myself->dwProcessId);
  if (pid != myself_cyg_pid && parent_alive)
    myself_identity.init (myself_cyg_pid, PID_EXECED);
d94 1
a94 1
      set_myself (1, NULL);
@


1.16
log
@Revert previous erroneous checkin.
@
text
@d33 1
a33 1
set_myself (pid_t pid)
d38 1
a38 1
  myself.init (pid, 1);
d43 1
a43 1
  if (pid != myself_cyg_pid)
d98 1
a98 1
      set_myself (1);
d200 1
a200 1
pinfo::init (pid_t n, DWORD create)
d220 6
a225 1
  if (!create)
d233 1
a233 1
      h = CreateFileMapping ((HANDLE) 0xffffffff, &sec_none_nih,
d246 1
d252 1
@


1.15
log
@* include/sys/cygwin.h: Protect class definitions.
@
text
@d33 1
a33 1
set_myself (pid_t pid, HANDLE h)
d38 1
a38 1
  myself.init (pid, 1, h);
d43 1
a43 1
  if (pid != myself_cyg_pid && parent_alive)
d98 1
a98 1
      set_myself (1, NULL);
d200 1
a200 1
pinfo::init (pid_t n, DWORD create, HANDLE in_h)
d220 1
a220 6
  if (in_h)
    {
      h = in_h;
      created = 0;
    }
  else if (!create)
d228 1
a228 1
      h = CreateFileMapping ((HANDLE) 0xffffffff, &sec_all_nih,
a240 1
  ProtectHandle1 (h, pinfo_shared_handle);
a245 1
      debug_printf ("execed process windows pid %d, cygwin pid %d", n, realpid);
@


1.14
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d33 1
a33 1
set_myself (pid_t pid)
d38 1
a38 1
  myself.init (pid, 1);
d43 1
a43 1
  if (pid != myself_cyg_pid)
d98 1
a98 1
      set_myself (1);
d200 1
a200 1
pinfo::init (pid_t n, DWORD create)
d220 6
a225 1
  if (!create)
d233 1
a233 1
      h = CreateFileMapping ((HANDLE) 0xffffffff, &sec_none_nih,
d246 1
d252 1
@


1.13
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d16 1
d18 4
a22 1
#include "cygerrno.h"
@


1.12
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d18 1
@


1.11
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d16 2
@


1.10
log
@* strace.cc (strace::prntf): Make second argument the function name, rather
than use special format options.
(strace::vprntf): Ditto.
(getfunc): New function.
* include/sys/strace.h: Reflect above changes.
* smallprint.c (__small_vsprintf): Eliminate '%F' formatting.
* pinfo.cc (set_myself): Modify for new strace::prntf parameter.
* errno.cc (seterrno_from_win_error): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Ditto.
@
text
@d82 1
a82 1
      LPBYTE b = dtable.de_linearize_fd_array (info);
@


1.9
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d49 11
a59 11
      strace.prntf (1, "**********************************************");
      strace.prntf (1, "Program name: %s", myself->progname);
      strace.prntf (1, "App version:  %d.%d, api: %d.%d",
			user_data->dll_major, user_data->dll_minor,
			user_data->api_major, user_data->api_minor);
      strace.prntf (1, "DLL version:  %d.%d, api: %d.%d",
			cygwin_version.dll_major, cygwin_version.dll_minor,
			cygwin_version.api_major, cygwin_version.api_minor);
      strace.prntf (1, "DLL build:    %s", cygwin_version.dll_build_date);
      strace.prntf (1, "OS version:   Windows %s", osname);
      strace.prntf (1, "**********************************************");
@


1.8
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d11 1
a15 1
#include "winsup.h"
@


1.7
log
@        * pinfo.cc (pinfo_init): Revert previous patch.
@
text
@a16 3
/* The first pid used; also the lowest value allowed. */
#define PBASE 1000

d19 2
a20 1
pinfo NO_COPY *myself = (pinfo *)&pinfo_dummy;	// Avoid myself != NULL checks
d25 2
a26 11
void
pinfo_list::init (void)
{
  next_pid = PBASE;	/* Next pid to try to allocate.  */

  /* We assume the shared data area is already initialized to zeros.
     Note that SIG_DFL is zero.  */
}

pinfo * __stdcall
set_myself (pinfo *p)
d28 6
a33 4
  myself = p;
  if (!p)
    return NULL;

d35 3
d62 1
a62 1
  return myself;
d91 3
a93 3
      if (!set_myself (cygwin_shared->p.allocate_pid ()))
	api_fatal ("No more processes");
      myself->ppid = myself->pgid = myself->sid = myself->pid;
a102 17
/* [] operator.  This is the mechanism for table lookups.  */
/* Returns the index into the pinfo_list table for pid arg */

pinfo *
pinfo_list::operator[] (pid_t pid)
{
  if (pid <= 0)
    return NULL;

  pinfo *p = vec + (pid % size ());

  if (p->pid != pid || p->process_state == PID_NOT_IN_USE)
    return NULL;
  else
    return p;
}

d104 1
a104 1
pinfo::getsig(int sig)
d116 1
a116 1
pinfo::getsigmask ()
d128 1
a128 1
pinfo::setsigmask (sigset_t _mask)
d140 1
a140 1
pinfo::getsigtodo(int sig)
d154 1
a154 1
pinfo::getthread2signal()
d166 1
a166 1
pinfo::setthread2signal(void *_thr)
d176 1
a176 1
pinfo::copysigs(pinfo *_other)
d181 2
a182 2
pinfo * __stdcall
procinfo (int pid)
d184 6
a189 30
  return cygwin_shared->p[pid];
}

#ifdef DEBUGGING
/*
 * Code to lock/unlock the process table.
 */

int __stdcall
lpfu (const char *func, int ln, DWORD timeout)
{
  int rc;
  DWORD t;

  debug_printf ("timeout %d, pinfo_mutex %p", timeout, pinfo_mutex);
  t = (timeout == INFINITE) ? 10000 : timeout;
  SetLastError(0);
  while ((rc = WaitForSingleObject (pinfo_mutex, t)) != WAIT_OBJECT_0)
    {
      if (rc == WAIT_ABANDONED_0)
	break;
      system_printf ("%s:%d having problems getting lock", func, ln);
      system_printf ("*** %s, rc %d, %E", cygwin_shared->p.lock_info, rc);
      if (t == timeout)
	break;
     }

  __small_sprintf (cygwin_shared->p.lock_info, "%s(%d), pid %d ", func, ln,
		   (user_data && myself) ? (int)myself->dwProcessId : -1);
  return rc;
d193 1
a193 1
unlock_pinfo (void)
d195 7
d203 9
a211 1
  debug_printf ("handle %d", pinfo_mutex);
d213 6
a218 2
  if (!cygwin_shared->p.lock_info[0])
    system_printf ("lock_info not set?");
d220 5
a224 30
    strcat (cygwin_shared->p.lock_info, " unlocked");
  if (!ReleaseMutex (pinfo_mutex))
    system_printf ("ReleaseMutext (pinfo_mutex<%p>) failed, %E", pinfo_mutex);
}
#else
/*
 * Code to lock/unlock the process table.
 */

int __stdcall
lock_pinfo_for_update (DWORD timeout)
{
  DWORD rc;
  DWORD t;

  debug_printf ("timeout %d, pinfo_mutex %p", timeout, pinfo_mutex);
  t = (timeout == INFINITE) ? 10000 : timeout;
  SetLastError(0);
  while ((rc = WaitForSingleObject (pinfo_mutex, t)) != WAIT_OBJECT_0)
    {
      if (rc == WAIT_ABANDONED_0)
	break;
      system_printf ("rc %d, pinfo_mutex %p, %E", pinfo_mutex, rc);
      if (t == timeout)
	break;
      if (rc == WAIT_FAILED)
	/* sigh, must be properly fixed up later. */
	return rc;
      Sleep(10); /* to prevent 100% CPU in those rare cases */
     }
d226 7
a232 6
  return (int)rc;
}

void
unlock_pinfo (void)
{
d234 1
a234 1
  debug_printf ("handle %d", pinfo_mutex);
d236 8
a243 13
  ReleaseMutex (pinfo_mutex);
}
#endif


/* Allocate a process table entry by finding an empty slot in the
   fixed-size process table.  We could use a linked list, but this
   would probably be too slow.

   Try to allocate next_pid, incrementing next_pid and trying again
   up to size() times at which point we reach the conclusion that
   table is full.  Eventually at this point we would grow the table
   by size() and start over.  If we find a pid to use,
d245 1
a245 18
   If all else fails, sweep through the loop looking for processes that
   may have died abnormally without registering themselves as "dead".
   Clear out these pinfo structures.  Then scan the table again.

   Note that the process table is in the shared data space and thus
   is susceptible to corruption.  The amount of time spent scanning the
   table is presumably quite small compared with the total time to
   create a process.
*/

pinfo *
pinfo_list::allocate_pid (void)
{

  pinfo *newp;

  lock_pinfo_for_update (INFINITE);
  for (int tries = 0; ; tries++)
d247 3
a249 1
      for (int i = next_pid; i < (next_pid + size ()); i++)
d251 2
a252 9
	  /* i mod size() gives place to check */
	  newp = vec + (i % size());
	  if (newp->process_state == PID_NOT_IN_USE)
	    {
	      debug_printf ("found empty slot %d for pid %d",
			     (i % size ()), i);
	      next_pid = i;
	      goto gotit;
	    }
a253 8

      if (tries > 0)
	break;

      /* try once to remove bogus dead processes */
      debug_printf ("clearing out deadwood");
      for (newp = vec; newp < vec + size(); newp++)
	proc_exists (newp);
d256 1
a256 40
  /* The process table is full.  */
  debug_printf ("process table is full");
  unlock_pinfo ();

  return NULL;

gotit:

  /* Set new pid based on the position of this element in the pinfo list */
  newp->pid = next_pid;

  /* Determine next slot to consider, wrapping if we hit the end of
   * the array.  Since allocation involves looping through size () pids,
   * don't allow next_pid to be greater than SHRT_MAX - size ().
   */
  if (next_pid < (SHRT_MAX - size ()))
    next_pid++;
  else
    next_pid = PBASE;

  newp->process_state = PID_IN_USE;
  unlock_pinfo ();

  memset (newp, 0, PINFO_ZERO);
  debug_printf ("pid %d, state %x", newp->pid, newp->process_state);
  return newp;
}

void
pinfo::record_death (int lock)
{
  int unlock = lock ? 0 : lock_pinfo_for_update (999);
  if (dwProcessId == GetCurrentProcessId () && !my_parent_is_alive ())
    {
      process_state = PID_NOT_IN_USE;
      hProcess = NULL;
    }

  if (unlock)
    unlock_pinfo ();
d289 64
a352 1
  for (int i = 0; i < cygwin_shared->p.size (); i++)
d354 18
a371 4
      pinfo *p = &cygwin_shared->p.vec[i];

      if (p->process_state == PID_NOT_IN_USE)
	continue;
d373 1
a373 3
      /* FIXME: signed vs unsigned comparison: winpid can be < 0 !!! */
      if (p->dwProcessId == (DWORD)winpid)
	return p->pid;
d376 1
a376 2
  set_errno (ESRCH);
  return (pid_t) -1;
@


1.6
log
@        * pinfo.cc (pinfo_init): Add missing initializers.
        * uinfo.cc (internal_getlogin): Request domain infos only
        when ntsec is ON.
@
text
@a101 2
      myself->logsrv[0] = '\0';
      myself->domain[0] = '\0';
@


1.5
log
@* exceptions.cc (interruptible): Allocate slightly more space for directory
name check.  Windows 95 seems to null-terminate the directory otherwise.
(interrupt_on_return): Issue a fatal error if we can't find the caller's stack.
* spawn.cc (find_exec): Accept a path_conv argument rather than a buffer so
that the caller can find things out about a translated path.
(perhaps_suffix): Ditto.
(spawn_guts): Allocate path_conv stuff here so that we can find out stuff about
the translated path (this is work in progress).
* environ.cc (environ_init): Accept an as-yet unused argument indicating
whether we were invoked from a cygwin parent or not.
(winenv): Ditto.
(posify): Accept an argument indicating whether the path has already been
translated.
* dlfcn.cc (check_access): Provide a path_conv buffer to find_exec.
* exec.cc (sexecvpe): Ditto.
* path.cc (path_conv::check): Rename from path_conv::path_conv.
(mount_item::getmntent): Recognize "Cygwin executable" bit.
(symlink_info::check): Remove debugging statements.
* path.h (class path_conv): Add iscygexec method.  Rewrite constructor to call
"check" method to allow multiple operations on a path_conv variable.
* pinfo.cc (pinfo_init): Pass argument to environ_init.
* shared.h: Bump PROC_MAGIC.
* winsup.h: Reflect above changes to function arguments.
* include/sys/mount.h: Add MOUNT_CYGWIN_EXEC type.
@
text
@d102 2
@


1.4
log
@Throughout use strace class in place of individual functions and variables.
* cygwin.din: Eliminate _strace_wm.
* sigproc.cc (wait_sig): Temporarily add more debugging output.
* include/cygwin/version.h: Bump minor api to reflect export change.
@
text
@d80 1
a80 1
      environ_init ();	  /* Needs myself but affects calls below */
d103 1
a103 1
      environ_init ();		/* call after myself has been set up */
@


1.3
log
@* pinfo.cc (set_myself): Add build date to strace output.
* sigproc.cc (proc_subproc): Only clear wait event when not attending to a
signal.
@
text
@d46 2
a47 2
  __small_sprintf (buf, "cYg%8x %x %x", _STRACE_INTERFACE_ACTIVATE_ADDR,
		   &strace_active);
d52 1
a52 1
  if (strace_active)
d55 3
a57 3
      strace_printf (1, "**********************************************");
      strace_printf (1, "Program name: %s", myself->progname);
      strace_printf (1, "App version:  %d.%d, api: %d.%d",
d60 1
a60 1
      strace_printf (1, "DLL version:  %d.%d, api: %d.%d",
d63 3
a65 3
      strace_printf (1, "DLL build:    %s", cygwin_version.dll_build_date);
      strace_printf (1, "OS version:   Windows %s", osname);
      strace_printf (1, "**********************************************");
@


1.2
log
@* dcrt0.cc (set_os_type): Record OS name string.
(getprogname): Eliminate obsolete function.
(dll_crt0_1): Move initial strace initialization output to set_myself.
* exceptions.cc (interruptible): Add debugging output.
(interrupt_setup): New function.
(interrupt_now): Use interrupt_setup to set up common interrupt handler stuff.
(interrupt_on_return): Ditto.
(call_handler): Move signal_arrived arm and clear threads to region where
signalled thread is suspended or suffer races.
* pinfo.cc (set_myself): Output interesting information when strace is first
initialized.  Initialize progname here.
* sigproc.cc (sig_dispatch_pending): Modify to ensure that flush signal are
sent synchronously.
* strace.cc (strace_vsprintf): Move code into strace program.
* uname.cc (uname): Use 'osname' global to construct cygwin name + Windows type
+ version.
@
text
@d63 1
@


1.1
log
@Initial revision
@
text
@d49 18
a97 3

      (void) GetModuleFileName (NULL, myself->progname,
				sizeof(myself->progname));
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
