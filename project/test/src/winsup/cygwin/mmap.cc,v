head	1.184;
access;
symbols
	cygwin-1_7_35-release:1.184
	cygwin-1_7_34-release:1.184
	cygwin-1_7_33-release:1.184
	cygwin-1_7_32-release:1.184
	cygwin-1_7_31-release:1.184
	cygwin-1_7_30-release:1.184
	cygwin-1_7_29-release:1.184
	cygwin-1_7_29-release-branchpoint:1.184.0.2
	cygwin-pre-user-db:1.184
	cygwin-1_7_28-release:1.184
	cygwin-1_7_27-release:1.184
	cygwin-1_7_26-release:1.184
	cygwin-1_7_25-release:1.183
	cygwin-1_7_24-release:1.183
	cygwin-1_7_23-release:1.183
	cygwin-1_7_22-release:1.183
	cygwin-1_7_21-release:1.182
	cygwin-1_7_20-release:1.182
	cygwin-1_7_19-release:1.182
	cygwin-64bit-postmerge:1.182
	cygwin-64bit-premerge-branch:1.181.0.2
	cygwin-64bit-premerge:1.181
	cygwin-1_7_18-release:1.181
	post-ptmalloc3:1.177.2.9
	pre-ptmalloc3:1.177.2.9
	cygwin-1_7_17-release:1.177
	cygwin-64bit-branch:1.177.0.2
	cygwin-1_7_16-release:1.177
	cygwin-1_7_15-release:1.177
	cygwin-1_7_14_2-release:1.177
	cygwin-1_7_14-release:1.177
	cygwin-1_7_12-release:1.176
	cygwin-1_7_11-release:1.176
	cygwin-1_7_10-release:1.176
	signal-rewrite:1.171.0.2
	pre-notty:1.171
	cygwin-1_7_9-release:1.167
	cv-post-1_7_9:1.163.0.2
	cygwin-1_7_8-release:1.163
	cygwin-1_7_7-release:1.162
	cygwin-1_7_5-release:1.162
	cygwin-1_7_4-release:1.162
	cygwin-1_7_3-release:1.162
	cygwin-1_7_2-release:1.162
	fifo_doover3:1.162.0.2
	cygwin-1_7_1-release:1.161
	prefifo:1.159
	cv-branch-2:1.158.0.2
	pre-ripout-set_console_state_for_spawn:1.153
	EOL_registry_mounts:1.150
	preoverlapped:1.144
	drop_9x_support_start:1.140
	cr-0x5f1:1.132.0.2
	cv-branch:1.127.0.2
	pre-ptymaster-archetype:1.127
	cr-0x3b58:1.126.0.4
	cr-0x5ef:1.126.0.2
	after-mmap-privanon-noreserve:1.116
	after-mmap-revamp:1.115
	before-mmap-revamp:1.114
	cgf-more-exit-sync:1.113
	post_wait_sig_exit:1.113
	pre_wait_sig_exit:1.113
	reparent-point:1.100
	noreparent:1.100.0.2
	cr-0x5e6:1.95.0.2
	cr-0x9e:1.92.0.6
	cr-0x9d:1.92.0.4
	cgf-deleteme:1.92.0.2
	pre-sigrewrite:1.89
	corinna-01:1.88
	cr-0x9c:1.85.0.4
	cr-0x9b:1.85.0.2
	cr-0x99:1.83
	Z-emcb-cygwin_daemon:1.83.0.2
	w32api-2_2:1.70
	mingw-runtime-2_4:1.70
	pre-cgf-merge:1.85
	cgf-dev-branch:1.68.0.2
	predaemon:1.52
	cygwin_daemon_merge_HEAD:1.52
	pregp02r1:1.50.0.2
	cygnus_cvs_20020108_pre:1.48
	Z-cygwin_daemon_merge-new_HEAD:1.61
	Z-cygwin_daemon_merge_HEAD:1.61
	cygwin_daemon:1.41.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.184
date	2013.10.15.08.13.42;	author corinna;	state Exp;
branches;
next	1.183;

1.183
date	2013.07.15.13.54.27;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.181;

1.181
date	2013.04.05.20.25.39;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2013.01.18.09.35.05;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2013.01.18.00.28.21;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2012.04.07.17.32.44;	author cgf;	state Exp;
branches
	1.177.2.1;
next	1.176;

1.176
date	2011.12.22.11.02.34;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2011.12.05.15.46.26;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2011.12.03.23.55.21;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2011.12.03.23.03.15;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2011.05.17.15.37.01;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2011.05.16.09.55.17;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2011.04.30.16.34.48;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2011.03.25.20.39.26;	author corinna;	state Exp;
branches;
next	1.166;

1.166
date	2011.03.18.13.56.56;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2011.03.18.13.42.03;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2011.03.18.13.38.34;	author corinna;	state Exp;
branches;
next	1.163;

1.163
date	2010.09.13.11.17.35;	author corinna;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2009.08.21.08.47.59;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2009.08.20.08.34.21;	author corinna;	state Exp;
branches;
next	1.159;

1.159
date	2009.07.14.17.37.42;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2009.06.06.19.56.41;	author corinna;	state Exp;
branches;
next	1.157;

1.157
date	2009.01.17.17.20.37;	author corinna;	state Exp;
branches;
next	1.156;

1.156
date	2008.11.21.10.52.10;	author corinna;	state Exp;
branches;
next	1.155;

1.155
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.153;

1.153
date	2008.04.21.12.46.57;	author corinna;	state Exp;
branches;
next	1.152;

1.152
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2007.11.27.14.45.14;	author corinna;	state Exp;
branches;
next	1.148;

1.148
date	2007.11.27.10.09.05;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2007.09.18.15.59.50;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2007.08.13.19.44.31;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2007.07.19.08.33.22;	author corinna;	state Exp;
branches;
next	1.144;

1.144
date	2007.02.26.12.22.41;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2007.02.22.17.35.14;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2007.02.07.17.22.40;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2007.01.18.17.15.59;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2007.01.17.10.49.24;	author corinna;	state Exp;
branches;
next	1.136;

1.136
date	2007.01.10.09.30.38;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2007.01.09.11.18.57;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2006.10.31.18.41.16;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2006.07.19.08.58.09;	author corinna;	state Exp;
branches
	1.132.2.1;
next	1.131;

1.131
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2006.07.13.10.29.21;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2006.07.13.08.33.34;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2006.07.12.20.15.00;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2006.01.12.15.53.51;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2006.01.10.18.11.32;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2005.12.19.15.25.23;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2005.12.15.09.04.28;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2005.12.12.10.00.32;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2005.12.07.11.16.47;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2005.12.05.20.20.17;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2005.12.01.20.35.13;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2005.11.30.15.05.48;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2005.11.29.16.28.05;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2005.11.28.22.32.29;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2005.10.18.18.51.33;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2005.07.06.20.05.01;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2005.07.05.03.16.45;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2005.05.19.08.43.17;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2005.05.18.17.23.17;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2005.05.02.03.50.07;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2005.04.13.16.41.32;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2005.03.08.09.18.46;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2005.03.01.11.51.29;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.25.21.23.15;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.25.11.47.17;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2005.02.25.11.15.22;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2004.09.03.01.53.12;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2004.07.16.14.32.03;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2004.07.15.17.00.44;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2004.07.15.09.21.16;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2004.02.26.11.32.20;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2004.02.25.10.54.31;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2003.12.03.16.35.52;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.88;

1.88
date	2003.11.06.14.33.16;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2003.09.26.08.50.12;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2003.09.09.09.41.17;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2003.09.04.10.27.51;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2003.08.23.00.03.54;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2003.08.15.12.05.08;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2003.07.21.13.06.49;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2003.07.05.18.59.35;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2003.07.04.09.06.54;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2003.07.03.20.53.26;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.09.20.10.25;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2003.02.25.12.46.39;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.14.21.15.16;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2003.02.07.20.57.30;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2003.01.16.14.11.10;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2003.01.15.10.21.23;	author corinna;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2003.01.14.21.01.43;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.14.20.40.09;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2002.10.21.01.00.57;	author cgf;	state Exp;
branches
	1.65.12.1;
next	1.64;

1.64
date	2002.09.24.14.17.50;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2002.09.24.13.48.07;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.27.13.01.35;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.24.05.44.10;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.13.20.54.57;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.11.20.23.09;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.11.17.57.22;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.25.17.47.47;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.22.19.33.41;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.05.20.58.22;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.16.14.04.26;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.15.23.39.32;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.27.22.39.50;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.18.17.10.09;	author corinna;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.09.03.02.13.05;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.10.21.04.14;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.19.07.44.34;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.16.17.26.04;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.27.09.35.39;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.26.18.17.15;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.19.13.33.51;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.23.09.49.19;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.08.21.10.45;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.08.21.02.36;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.05.12.36.41;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.29.13.39.17;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.29.09.25.10;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.24.04.00.41;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.16.17.02.46;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.15.22.18.14;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.15.19.42.33;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.11.12.33.12;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.28.21.25.45;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.15.06.27.48;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.07.17.35.36;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.05.13.07.02;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.29.16.24.38;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.11.22.30.45;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.177.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.177.2.2;

1.177.2.2
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	1.177.2.3;

1.177.2.3
date	2012.11.12.17.26.21;	author corinna;	state Exp;
branches;
next	1.177.2.4;

1.177.2.4
date	2012.12.10.11.45.49;	author corinna;	state Exp;
branches;
next	1.177.2.5;

1.177.2.5
date	2013.01.18.16.24.03;	author corinna;	state Exp;
branches;
next	1.177.2.6;

1.177.2.6
date	2013.01.21.13.52.07;	author corinna;	state Exp;
branches;
next	1.177.2.7;

1.177.2.7
date	2013.02.05.15.04.37;	author corinna;	state Exp;
branches;
next	1.177.2.8;

1.177.2.8
date	2013.02.12.11.24.35;	author corinna;	state Exp;
branches;
next	1.177.2.9;

1.177.2.9
date	2013.02.12.13.25.41;	author corinna;	state Exp;
branches;
next	1.177.2.10;

1.177.2.10
date	2013.03.13.16.51.25;	author corinna;	state Exp;
branches;
next	1.177.2.11;

1.177.2.11
date	2013.04.05.20.25.55;	author corinna;	state Exp;
branches;
next	;

1.163.2.1
date	2011.03.12.10.57.40;	author corinna;	state Exp;
branches;
next	1.163.2.2;

1.163.2.2
date	2011.03.18.17.50.58;	author corinna;	state Exp;
branches;
next	1.163.2.3;

1.163.2.3
date	2011.03.28.20.16.56;	author corinna;	state Exp;
branches;
next	;

1.132.2.1
date	2006.11.08.10.00.06;	author corinna;	state Exp;
branches;
next	1.132.2.2;

1.132.2.2
date	2007.01.12.19.44.19;	author corinna;	state Exp;
branches;
next	1.132.2.3;

1.132.2.3
date	2007.01.17.10.49.28;	author corinna;	state Exp;
branches;
next	1.132.2.4;

1.132.2.4
date	2007.01.18.17.14.43;	author corinna;	state Exp;
branches;
next	1.132.2.5;

1.132.2.5
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	1.132.2.6;

1.132.2.6
date	2007.11.29.11.14.52;	author corinna;	state Exp;
branches;
next	;

1.127.2.1
date	2006.07.13.08.34.54;	author corinna;	state Exp;
branches;
next	1.127.2.2;

1.127.2.2
date	2006.07.13.10.29.26;	author corinna;	state Exp;
branches;
next	1.127.2.3;

1.127.2.3
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	1.127.2.4;

1.127.2.4
date	2006.07.18.13.58.51;	author corinna;	state Exp;
branches;
next	1.127.2.5;

1.127.2.5
date	2006.07.19.11.11.14;	author corinna;	state Exp;
branches;
next	1.127.2.6;

1.127.2.6
date	2006.07.19.11.17.04;	author corinna;	state Exp;
branches;
next	;

1.68.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2003.01.24.04.04.20;	author cgf;	state Exp;
branches;
next	1.68.2.3;

1.68.2.3
date	2003.02.09.05.46.40;	author cgf;	state Exp;
branches;
next	1.68.2.4;

1.68.2.4
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.68.2.5;

1.68.2.5
date	2003.02.15.05.29.00;	author cgf;	state Exp;
branches;
next	1.68.2.6;

1.68.2.6
date	2003.02.27.15.10.22;	author cgf;	state Exp;
branches;
next	1.68.2.7;

1.68.2.7
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.68.2.8;

1.68.2.8
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.68.2.9;

1.68.2.9
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.68.2.10;

1.68.2.10
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.68.2.11;

1.68.2.11
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.68.2.12;

1.68.2.12
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.65.12.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	;

1.41.2.1
date	2001.09.29.09.35.31;	author rbcollins;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2001.10.02.12.09.55;	author rbcollins;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.01.04.03.56.09;	author rbcollins;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2002.02.28.12.53.25;	author rbcollins;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2002.06.13.14.34.07;	author rbcollins;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2002.06.28.18.15.47;	author scottc;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.184
log
@	* mmap.cc (mmap64): Convert pagesize from DWORD to size_t to avoid
	a rounding error for allocations beyond 4 Gigs.
@
text
@/* mmap.cc

   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/param.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "ntdll.h"
#include <sys/queue.h>

/* __PROT_ATTACH indicates an anonymous mapping which is supposed to be
   attached to a file mapping for pages beyond the file's EOF.  The idea
   is to support mappings longer than the file, without the file growing
   to mapping length (POSIX semantics). */
#define __PROT_ATTACH   0x8000000
/* Filler pages are the pages from the last file backed page to the next
   64K boundary.  These pages are created as anonymous pages, but with
   the same page protection as the file's pages, since POSIX applications
   expect to be able to access this part the same way as the file pages. */
#define __PROT_FILLER   0x4000000

/* Stick with 4K pages for bookkeeping, otherwise we just get confused
   when trying to do file mappings with trailing filler pages correctly. */
#define PAGE_CNT(bytes) howmany((bytes), wincap.page_size())

#define PGBITS		(sizeof (DWORD)*8)
#define MAPSIZE(pages)	howmany ((pages), PGBITS)

#define MAP_SET(n)	(page_map[(n)/PGBITS] |= (1L << ((n) % PGBITS)))
#define MAP_CLR(n)	(page_map[(n)/PGBITS] &= ~(1L << ((n) % PGBITS)))
#define MAP_ISSET(n)	(page_map[(n)/PGBITS] & (1L << ((n) % PGBITS)))

/* Used for anonymous mappings. */
static fhandler_dev_zero fh_anonymous;

/* Used for thread synchronization while accessing mmap bookkeeping lists. */
static NO_COPY muto mmap_guard;
#define LIST_LOCK()    (mmap_guard.init ("mmap_guard")->acquire ())
#define LIST_UNLOCK()  (mmap_guard.release ())

/* Small helpers to avoid having lots of flag bit tests in the code. */
static inline bool
priv (int flags)
{
  return (flags & MAP_PRIVATE) == MAP_PRIVATE;
}

static inline bool
fixed (int flags)
{
  return (flags & MAP_FIXED) == MAP_FIXED;
}

static inline bool
anonymous (int flags)
{
  return (flags & MAP_ANONYMOUS) == MAP_ANONYMOUS;
}

static inline bool
noreserve (int flags)
{
  return (flags & MAP_NORESERVE) == MAP_NORESERVE;
}

static inline bool
autogrow (int flags)
{
  return (flags & MAP_AUTOGROW) == MAP_AUTOGROW;
}

static inline bool
attached (int prot)
{
  return (prot & __PROT_ATTACH) == __PROT_ATTACH;
}

static inline bool
filler (int prot)
{
  return (prot & __PROT_FILLER) == __PROT_FILLER;
}

static inline DWORD
gen_create_protect (DWORD openflags, int flags)
{
  DWORD ret = PAGE_READONLY;

  if (priv (flags))
    ret = PAGE_WRITECOPY;
  else if (openflags & GENERIC_WRITE)
    ret = PAGE_READWRITE;

  if (openflags & GENERIC_EXECUTE)
    ret <<= 4;

  return ret;
}

/* Generate Windows protection flags from mmap prot and flag values. */
static inline DWORD
gen_protect (int prot, int flags)
{
  DWORD ret = PAGE_NOACCESS;

  /* Attached pages are only reserved, but the protection must be a
     valid value, so we just return PAGE_READWRITE. */
  if (attached (prot))
    return PAGE_EXECUTE_READWRITE;

  if (prot & PROT_WRITE)
    ret = (priv (flags) && (!anonymous (flags) || filler (prot)))
	  ? PAGE_WRITECOPY : PAGE_READWRITE;
  else if (prot & PROT_READ)
    ret = PAGE_READONLY;

  if (prot & PROT_EXEC)
    ret <<= 4;

  return ret;
}

static HANDLE
CreateMapping (HANDLE fhdl, size_t len, off_t off, DWORD openflags,
	       int prot, int flags)
{
  HANDLE h;
  NTSTATUS status;

  LARGE_INTEGER sectionsize = { QuadPart: (LONGLONG) len };
  ULONG protect = gen_create_protect (openflags, flags);
  ULONG attributes = attached (prot) ? SEC_RESERVE : SEC_COMMIT;

  OBJECT_ATTRIBUTES oa;
  InitializeObjectAttributes (&oa, NULL, OBJ_INHERIT, NULL,
			      sec_none.lpSecurityDescriptor);

  if (fhdl == INVALID_HANDLE_VALUE)
    {
      /* Standard anonymous mapping needs non-zero len. */
      status = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa, &sectionsize,
				protect, attributes, NULL);
    }
  else if (autogrow (flags))
    {
      /* Auto-grow only works if the protection is PAGE_READWRITE.  So,
	 first we call NtCreateSection with PAGE_READWRITE, then, if the
	 requested protection is different, we close the mapping and
	 reopen it again with the correct protection, if auto-grow worked. */
      sectionsize.QuadPart += off;
      status = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa, &sectionsize,
				PAGE_READWRITE, attributes, fhdl);
      if (NT_SUCCESS (status) && protect != PAGE_READWRITE)
	{
	  NtClose (h);
	  status = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa, &sectionsize,
				    protect, attributes, fhdl);
	}
    }
  else
    {
      /* Zero len creates mapping for whole file and allows
	 AT_EXTENDABLE_FILE mapping, if we ever use it... */
      sectionsize.QuadPart = 0;
      status = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa, &sectionsize,
				protect, attributes, fhdl);
    }
  if (!NT_SUCCESS (status))
    {
      h = NULL;
      SetLastError (RtlNtStatusToDosError (status));
    }
  return h;
}

static void *
MapView (HANDLE h, void *addr, size_t len, DWORD openflags,
	 int prot, int flags, off_t off)
{
  NTSTATUS status;
  LARGE_INTEGER offset = { QuadPart:off };
  DWORD protect = gen_create_protect (openflags, flags);
  void *base = addr;
  SIZE_T commitsize = attached (prot) ? 0 : len;
  SIZE_T viewsize = len;
#ifdef __x86_64__ /* AT_ROUND_TO_PAGE isn't supported on 64 bit systems. */
  ULONG alloc_type = MEM_TOP_DOWN;
#else
  ULONG alloc_type = (base && !wincap.is_wow64 () ? AT_ROUND_TO_PAGE : 0)
		     | MEM_TOP_DOWN;
#endif

  /* Try mapping using the given address first, even if it's NULL.
     If it failed, and addr was not NULL and flags is not MAP_FIXED,
     try again with NULL address.

     Note: Retrying the mapping might be unnecessary, now that mmap64 checks
	   for a valid memory area first. */
  status = NtMapViewOfSection (h, NtCurrentProcess (), &base, 0, commitsize,
			       &offset, &viewsize, ViewShare, alloc_type,
			       protect);
  if (!NT_SUCCESS (status) && addr && !fixed (flags))
    {
      base = NULL;
      status = NtMapViewOfSection (h, NtCurrentProcess (), &base, 0, commitsize,
				   &offset, &viewsize, ViewShare, 0, protect);
    }
  if (!NT_SUCCESS (status))
    {
      base = NULL;
      SetLastError (RtlNtStatusToDosError (status));
    }
  debug_printf ("%p (status %p) = NtMapViewOfSection (h:%p, addr:%p, len:%lu,"
		" off:%Y, protect:%y, type:%y)",
		base, status, h, addr, len, off, protect, 0);
  return base;
}

/* Class structure used to keep a record of all current mmap areas
   in a process.  Needed for bookkeeping all mmaps in a process and
   for duplicating all mmaps after fork() since mmaps are not propagated
   to child processes by Windows.  All information must be duplicated
   by hand, see fixup_mmaps_after_fork().

   The class structure:

   One member of class map per process, global variable mmapped_areas.
   Contains a singly-linked list of type class mmap_list.  Each mmap_list
   entry represents all mapping to a file, keyed by file descriptor and
   file name hash.
   Each list entry contains a singly-linked list of type class mmap_record.
   Each mmap_record represents exactly one mapping.  For each mapping, there's
   an additional so called `page_map'.  It's an array of bits, one bit
   per mapped memory page.  The bit is set if the page is accessible,
   unset otherwise. */

#pragma pack(push, 4)
class mmap_record
{
  public:
    LIST_ENTRY (mmap_record) mr_next;

  private:
    /* 4 byte on 32 bit, 8 byte on 64 bit */
    HANDLE mapping_hdl;
    SIZE_T len;
    caddr_t base_address;
    /* Always 8 bytes */
    off_t offset;
    /* Always 4 bytes */
    int fd;
    DWORD openflags;
    int prot;
    int flags;
    dev_t dev;
    DWORD page_map[0];

  public:
    mmap_record (int nfd, HANDLE h, DWORD of, int p, int f, off_t o, DWORD l,
		 caddr_t b) :
       mapping_hdl (h),
       len (l),
       base_address (b),
       offset (o),
       fd (nfd),
       openflags (of),
       prot (p),
       flags (f)
      {
	dev = 0;
	if (fd >= 0 && !cygheap->fdtab.not_open (fd))
	  dev = cygheap->fdtab[fd]->dev ();
	else if (fd == -1)
	  dev = FH_ZERO;
      }

    int get_fd () const { return fd; }
    HANDLE get_handle () const { return mapping_hdl; }
    int get_device () { return dev; }
    int get_prot () const { return prot; }
    int get_openflags () const { return openflags; }
    int get_flags () const { return flags; }
    bool priv () const { return ::priv (flags); }
    bool fixed () const { return ::fixed (flags); }
    bool anonymous () const { return ::anonymous (flags); }
    bool noreserve () const { return ::noreserve (flags); }
    bool autogrow () const { return ::autogrow (flags); }
    bool attached () const { return ::attached (prot); }
    bool filler () const { return ::filler (prot); }
    off_t get_offset () const { return offset; }
    SIZE_T get_len () const { return len; }
    caddr_t get_address () const { return base_address; }

    void init_page_map (mmap_record &r);

    DWORD find_unused_pages (DWORD pages) const;
    bool match (caddr_t addr, SIZE_T len, caddr_t &m_addr, DWORD &m_len);
    off_t map_pages (off_t off, SIZE_T len);
    bool map_pages (caddr_t addr, SIZE_T len);
    bool unmap_pages (caddr_t addr, SIZE_T len);
    int access (caddr_t address);

    fhandler_base *alloc_fh ();
    void free_fh (fhandler_base *fh);

    DWORD gen_create_protect () const
      { return ::gen_create_protect (get_openflags (), get_flags ()); }
    DWORD gen_protect () const
      { return ::gen_protect (get_prot (), get_flags ()); }
    bool compatible_flags (int fl) const;
};
#pragma pack(pop)

class mmap_list
{
  public:
    LIST_ENTRY (mmap_list) ml_next;
    LIST_HEAD (, mmap_record) recs;

  private:
    int fd;
    ino_t hash;

  public:
    int get_fd () const { return fd; }
    ino_t get_hash () const { return hash; }

    bool anonymous () const { return fd == -1; }
    void set (int nfd, struct stat *st);
    mmap_record *add_record (mmap_record &r);
    bool del_record (mmap_record *rec);
    caddr_t try_map (void *addr, size_t len, int flags, off_t off);
};

class mmap_areas
{
  public:
    LIST_HEAD (, mmap_list) lists;

    mmap_list *get_list_by_fd (int fd, struct stat *st);
    mmap_list *add_list (int fd, struct stat *st);
    void del_list (mmap_list *ml);
};

/* This is the global map structure pointer. */
static mmap_areas mmapped_areas;

bool
mmap_record::compatible_flags (int fl) const
{
#define MAP_COMPATMASK	(MAP_TYPE | MAP_NORESERVE)
  return (get_flags () & MAP_COMPATMASK) == (fl & MAP_COMPATMASK);
}

DWORD
mmap_record::find_unused_pages (DWORD pages) const
{
  DWORD mapped_pages = PAGE_CNT (get_len ());
  DWORD start;

  if (pages > mapped_pages)
    return (DWORD)-1;
  for (start = 0; start <= mapped_pages - pages; ++start)
    if (!MAP_ISSET (start))
      {
	DWORD cnt;
	for (cnt = 0; cnt < pages; ++cnt)
	  if (MAP_ISSET (start + cnt))
	    break;
	if (cnt >= pages)
	  return start;
      }
  return (DWORD)-1;
}

bool
mmap_record::match (caddr_t addr, SIZE_T len, caddr_t &m_addr, DWORD &m_len)
{
  caddr_t low = (addr >= get_address ()) ? addr : get_address ();
  caddr_t high = get_address ();
  if (filler ())
    high += get_len ();
  else
    high += (PAGE_CNT (get_len ()) * wincap.page_size ());
  high = (addr + len < high) ? addr + len : high;
  if (low < high)
    {
      m_addr = low;
      m_len = high - low;
      return true;
    }
  return false;
}

void
mmap_record::init_page_map (mmap_record &r)
{
  *this = r;
  DWORD start_protect = gen_create_protect ();
  DWORD real_protect = gen_protect ();
  if (real_protect != start_protect && !noreserve ()
      && !VirtualProtect (get_address (), get_len (),
			  real_protect, &start_protect))
    system_printf ("Warning: VirtualProtect (addr: %p, len: %ly, "
		   "new_prot: %y, old_prot: %y), %E",
		   get_address (), get_len (),
		   real_protect, start_protect);
  SIZE_T len = PAGE_CNT (get_len ());
  while (len-- > 0)
    MAP_SET (len);
}

off_t
mmap_record::map_pages (off_t off, SIZE_T len)
{
  /* Used ONLY if this mapping matches into the chunk of another already
     performed mapping in a special case of MAP_ANON|MAP_PRIVATE.

     Otherwise it's job is now done by init_page_map(). */
  DWORD old_prot;
  debug_printf ("map_pages (fd=%d, off=%Y, len=%lu)", get_fd (), off, len);
  len = PAGE_CNT (len);

  if ((off = find_unused_pages (len)) == (DWORD)-1)
    return 0L;
  if (!noreserve ()
      && !VirtualProtect (get_address () + off * wincap.page_size (),
			  len * wincap.page_size (), gen_protect (),
			  &old_prot))
    {
      __seterrno ();
      return (off_t)-1;
    }

  while (len-- > 0)
    MAP_SET (off + len);
  return off * wincap.page_size ();
}

bool
mmap_record::map_pages (caddr_t addr, SIZE_T len)
{
  debug_printf ("map_pages (addr=%p, len=%lu)", addr, len);
  DWORD old_prot;
  DWORD off = addr - get_address ();
  off /= wincap.page_size ();
  len = PAGE_CNT (len);
  /* First check if the area is unused right now. */
  for (DWORD l = 0; l < len; ++l)
    if (MAP_ISSET (off + l))
      {
	set_errno (EINVAL);
	return false;
      }
  if (!noreserve ()
      && !VirtualProtect (get_address () + off * wincap.page_size (),
			  len * wincap.page_size (), gen_protect (),
			  &old_prot))
    {
      __seterrno ();
      return false;
    }
  for (; len-- > 0; ++off)
    MAP_SET (off);
  return true;
}

bool
mmap_record::unmap_pages (caddr_t addr, SIZE_T len)
{
  DWORD old_prot;
  DWORD off = addr - get_address ();
  if (noreserve ()
      && !VirtualFree (get_address () + off, len, MEM_DECOMMIT))
    debug_printf ("VirtualFree in unmap_pages () failed, %E");
  else if (!VirtualProtect (get_address () + off, len, PAGE_NOACCESS,
			    &old_prot))
    debug_printf ("VirtualProtect in unmap_pages () failed, %E");

  off /= wincap.page_size ();
  len = PAGE_CNT (len);
  for (; len-- > 0; ++off)
    MAP_CLR (off);
  /* Return TRUE if all pages are free'd which may result in unmapping
     the whole chunk. */
  for (len = MAPSIZE (PAGE_CNT (get_len ())); len > 0; )
    if (page_map[--len])
      return false;
  return true;
}

int
mmap_record::access (caddr_t address)
{
  if (address < get_address () || address >= get_address () + get_len ())
    return 0;
  DWORD off = (address - get_address ()) / wincap.page_size ();
  return MAP_ISSET (off);
}

fhandler_base *
mmap_record::alloc_fh ()
{
  if (anonymous ())
    {
      fh_anonymous.set_io_handle (INVALID_HANDLE_VALUE);
      fh_anonymous.set_access (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
      return &fh_anonymous;
    }

  /* The file descriptor could have been closed or, even
     worse, could have been reused for another file before
     the call to fork(). This requires creating a fhandler
     of the correct type to be sure to call the method of the
     correct class. */
  device fdev;
  fdev.name = fdev.native = "";
  fdev.parse (get_device ());
  fhandler_base *fh = build_fh_dev (fdev);
  if (fh)
    fh->set_access (get_openflags ());
  return fh;
}

void
mmap_record::free_fh (fhandler_base *fh)
{
  if (!anonymous ())
    delete fh;
}

mmap_record *
mmap_list::add_record (mmap_record &r)
{
  mmap_record *rec = (mmap_record *) ccalloc (HEAP_MMAP,
		      sizeof (mmap_record)
		      + MAPSIZE (PAGE_CNT (r.get_len ())) * sizeof (DWORD), 1);
  if (!rec)
    return NULL;
  rec->init_page_map (r);

  LIST_INSERT_HEAD (&recs, rec, mr_next);
  return rec;
}

void
mmap_list::set (int nfd, struct stat *st)
{
  fd = nfd;
  if (!anonymous ())
    {
      /* The fd isn't sufficient since it could already be the fd of another
	 file.  So we use the inode number as evaluated by fstat to identify
	 the file. */
      hash = st ? st->st_ino : (ino_t) 0;
    }
  LIST_INIT (&recs);
}

bool
mmap_list::del_record (mmap_record *rec)
{
  LIST_REMOVE (rec, mr_next);
  cfree (rec);
  /* Return true if the list is empty which allows the caller to remove
     this list from the list of lists. */
  return !LIST_FIRST(&recs);
}

caddr_t
mmap_list::try_map (void *addr, size_t len, int flags, off_t off)
{
  mmap_record *rec;

  if (off == 0 && !fixed (flags))
    {
      /* If MAP_FIXED isn't given, check if this mapping matches into the
	 chunk of another already performed mapping. */
      SIZE_T plen = PAGE_CNT (len);
      LIST_FOREACH (rec, &recs, mr_next)
	if (rec->find_unused_pages (plen) != (DWORD) -1)
	  break;
      if (rec && rec->compatible_flags (flags))
	{
	  if ((off = rec->map_pages (off, len)) == (off_t) -1)
	    return (caddr_t) MAP_FAILED;
	  return (caddr_t) rec->get_address () + off;
	}
    }
  else if (fixed (flags))
    {
      /* If MAP_FIXED is given, test if the requested area is in an
	 unmapped part of an still active mapping.  This can happen
	 if a memory region is unmapped and remapped with MAP_FIXED. */
      caddr_t u_addr;
      DWORD u_len;

      LIST_FOREACH (rec, &recs, mr_next)
	if (rec->match ((caddr_t) addr, len, u_addr, u_len))
	  break;
      if (rec)
	{
	  if (u_addr > (caddr_t) addr || u_addr + len < (caddr_t) addr + len
	      || !rec->compatible_flags (flags))
	    {
	      /* Partial match only, or access mode doesn't match. */
	      /* FIXME: Handle partial mappings gracefully if adjacent
		 memory is available. */
	      set_errno (EINVAL);
	      return (caddr_t) MAP_FAILED;
	    }
	  if (!rec->map_pages ((caddr_t) addr, len))
	    return (caddr_t) MAP_FAILED;
	  return (caddr_t) addr;
	}
    }
  return NULL;
}

mmap_list *
mmap_areas::get_list_by_fd (int fd, struct stat *st)
{
  mmap_list *ml;
  LIST_FOREACH (ml, &lists, ml_next)
    {
      if (fd == -1 && ml->anonymous ())
	return ml;
      /* The fd isn't sufficient since it could already be the fd of another
	 file.  So we use the inode number as evaluated by fstat to identify
	 the file. */
      if (fd != -1 && st && ml->get_hash () == st->st_ino)
	return ml;
    }
  return 0;
}

mmap_list *
mmap_areas::add_list (int fd, struct stat *st)
{
  mmap_list *ml = (mmap_list *) cmalloc (HEAP_MMAP, sizeof (mmap_list));
  if (!ml)
    return NULL;
  ml->set (fd, st);
  LIST_INSERT_HEAD (&lists, ml, ml_next);
  return ml;
}

void
mmap_areas::del_list (mmap_list *ml)
{
  LIST_REMOVE (ml, ml_next);
  cfree (ml);
}

/* This function allows an external function to test if a given memory
   region is part of an mmapped memory region. */
bool
is_mmapped_region (caddr_t start_addr, caddr_t end_address)
{
  size_t len = end_address - start_addr;

  LIST_LOCK ();
  mmap_list *map_list = mmapped_areas.get_list_by_fd (-1, NULL);

  if (!map_list)
    {
      LIST_UNLOCK ();
      return false;
    }

  mmap_record *rec;
  caddr_t u_addr;
  DWORD u_len;
  bool ret = false;

  LIST_FOREACH (rec, &map_list->recs, mr_next)
    {
      if (rec->match (start_addr, len, u_addr, u_len))
	{
	  ret = true;
	  break;
	}
    }
  LIST_UNLOCK ();
  return ret;
}

/* This function is called from exception_handler when a segmentation
   violation has occurred.  It should also be called from all Cygwin
   functions that want to support passing noreserve mmap page addresses
   to Windows system calls.  In that case, it should be called only after
   a system call indicates that the application buffer passed had an
   invalid virtual address to avoid any performance impact in non-noreserve
   cases.

   Check if the address range is all within noreserve mmap regions.  If so,
   call VirtualAlloc to commit the pages and return MMAP_NORESERVE_COMMITED
   on success.  If the page has __PROT_ATTACH (SUSv3 memory protection
   extension), or if VirutalAlloc fails, return MMAP_RAISE_SIGBUS.
   Otherwise, return MMAP_NONE if the address range is not covered by an
   attached or noreserve map.

   On MAP_NORESERVE_COMMITED, the exeception handler should return 0 to
   allow the application to retry the memory access, or the calling Cygwin
   function should retry the Windows system call. */

mmap_region_status
mmap_is_attached_or_noreserve (void *addr, size_t len)
{
  mmap_region_status ret = MMAP_NONE;

  LIST_LOCK ();
  mmap_list *map_list = mmapped_areas.get_list_by_fd (-1, NULL);

  size_t pagesize = wincap.allocation_granularity ();
  caddr_t start_addr = (caddr_t) rounddown ((uintptr_t) addr, pagesize);
  len += ((caddr_t) addr - start_addr);
  len = roundup2 (len, pagesize);

  if (map_list == NULL)
    goto out;

  mmap_record *rec;
  caddr_t u_addr;
  DWORD u_len;

  LIST_FOREACH (rec, &map_list->recs, mr_next)
    {
      if (!rec->match (start_addr, len, u_addr, u_len))
	continue;
      if (rec->attached ())
	{
	  ret = MMAP_RAISE_SIGBUS;
	  break;
	}
      if (!rec->noreserve ())
	break;

      size_t commit_len = u_len - (start_addr - u_addr);
      if (commit_len > len)
	commit_len = len;

      if (!VirtualAlloc (start_addr, commit_len, MEM_COMMIT,
			 rec->gen_protect ()))
	{
	  ret = MMAP_RAISE_SIGBUS;
	  break;
	}

      start_addr += commit_len;
      len -= commit_len;
      if (!len)
	{
	  ret = MMAP_NORESERVE_COMMITED;
	  break;
	}
    }
out:
  LIST_UNLOCK ();
  return ret;
}

static caddr_t
mmap_worker (mmap_list *map_list, fhandler_base *fh, caddr_t base, size_t len,
	     int prot, int flags, int fd, off_t off, struct stat *st)
{
  HANDLE h = fh->mmap (&base, len, prot, flags, off);
  if (h == INVALID_HANDLE_VALUE)
    return NULL;
  if (!map_list
      && !(map_list = mmapped_areas.get_list_by_fd (fd, st))
      && !(map_list = mmapped_areas.add_list (fd, st)))
    {
      fh->munmap (h, base, len);
      return NULL;
    }
  mmap_record mmap_rec (fd, h, fh->get_access (), prot, flags, off, len, base);
  mmap_record *rec = map_list->add_record (mmap_rec);
  if (!rec)
    {
      fh->munmap (h, base, len);
      return NULL;
    }
  return base;
}

#ifdef __x86_64__

/* The memory region used for memory maps */
#define MMAP_STORAGE_LOW	0x00800000000L	/* Leave 8 Gigs for heap. */
#define MMAP_STORAGE_HIGH	0x70000000000L	/* Leave enough room for OS. */

/* FIXME?  Unfortunately the OS doesn't support a top down allocation with
	   a ceiling value.  The ZeroBits mechanism only works for
	   NtMapViewOfSection and it only evaluates the high bit of ZeroBits
	   on 64 bit, so it's pretty much useless for our purposes.

	   If the below simple mechanism to perform top-down allocations
	   turns out to be too dumb, we need something else.  One idea is to
	   dived the space in (3835) 4 Gig chunks and simply store the
	   available free space per slot.  Then we can go top down from slot
	   to slot and only try slots which are supposed to have enough space.
	   Bookkeeping would be very simple and fast. */
class mmap_allocator
{
  caddr_t mmap_current_low;

public:
  mmap_allocator () : mmap_current_low ((caddr_t) MMAP_STORAGE_HIGH) {}

  PVOID alloc (PVOID in_addr, SIZE_T in_size, bool fixed)
  {
    MEMORY_BASIC_INFORMATION mbi;

    SIZE_T size = roundup2 (in_size, wincap.allocation_granularity ());
    /* First check for the given address. */
    if (in_addr)
      {
	/* If it points to a free area, big enough to fulfill the request,
	   return the address. */
      	if (VirtualQuery (in_addr, &mbi, sizeof mbi)
	    && mbi.State == MEM_FREE
	    && mbi.RegionSize >= size)
	  return in_addr;
	/* Otherwise, if MAP_FIXED was given, give up. */
	if (fixed)
	  return NULL;
	/* Otherwise, fall through to the usual free space search mechanism. */
      }
    /* Start with the last allocation start address - requested size. */
    caddr_t addr = mmap_current_low - size;
    bool merry_go_round = false;
    do
      {
	/* Did we hit the lower ceiling?  If so, restart from the upper
	   ceiling, but note that we did it. */
	if (addr < (caddr_t) MMAP_STORAGE_LOW)
	  {
	    addr = (caddr_t) MMAP_STORAGE_HIGH - size;
	    merry_go_round = true;
	  }
	/* Shouldn't fail, but better test. */
	if (!VirtualQuery ((PVOID) addr, &mbi, sizeof mbi))
	  return NULL;
	/* If the region is free... */
	if (mbi.State == MEM_FREE)
	  {
	    /* ...and the region is big enough to fulfill the request... */
	    if (mbi.RegionSize >= size)
	      {
		/* ...note the address as next start address for our simple
		   merry-go-round and return the address. */
		mmap_current_low = addr;
		return (PVOID) addr;
	      }
	    /* Otherwise, subtract what's missing in size and try again. */
	    addr -= size - mbi.RegionSize;
	  }
	/* If the region isn't free, skip to address below AllocationBase
	   and try again. */
	else
	  addr = (caddr_t) mbi.AllocationBase - size;
      }
    /* Repeat until we had a full ride on the merry_go_round. */
    while (!merry_go_round || addr >= mmap_current_low);
    return NULL;
  }
};

static mmap_allocator mmap_alloc;	/* Inherited by forked child. */
#endif

extern "C" void *
mmap64 (void *addr, size_t len, int prot, int flags, int fd, off_t off)
{
  syscall_printf ("addr %p, len %lu, prot %y, flags %y, fd %d, off %Y",
		  addr, len, prot, flags, fd, off);

  caddr_t ret = (caddr_t) MAP_FAILED;
  fhandler_base *fh = NULL;
  fhandler_disk_file *fh_disk_file = NULL; /* Used for reopening a disk file
					      when necessary. */
  mmap_list *map_list = NULL;
  size_t orig_len = 0;
  caddr_t base = NULL;
  struct stat st;

  size_t pagesize = wincap.allocation_granularity ();

  fh_anonymous.set_io_handle (INVALID_HANDLE_VALUE);
  fh_anonymous.set_access (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);

  /* EINVAL error conditions. */
  if (off % pagesize
      || ((prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC)))
      || ((flags & MAP_TYPE) != MAP_SHARED
	  && (flags & MAP_TYPE) != MAP_PRIVATE)
      || (fixed (flags) && ((uintptr_t) addr % pagesize))
      || !len)
    {
      set_errno (EINVAL);
      goto out;
    }

  if (!anonymous (flags) && fd != -1)
    {
      /* Ensure that fd is open */
      cygheap_fdget cfd (fd);
      if (cfd < 0)
	goto out;

      fh = cfd;

      /* mmap /dev/zero is like MAP_ANONYMOUS. */
      if (fh->get_device () == FH_ZERO)
	flags |= MAP_ANONYMOUS;

      /* The autoconf mmap test maps a file of size 1 byte.  It then tests
	 every byte of the entire mapped page of 64K for 0-bytes since that's
	 what POSIX requires.  The problem is, we can't create that mapping on
	 64 bit systems.  The file mapping will be only a single page, 4K, and
	 since 64 bit systems don't support the AT_ROUND_TO_PAGE flag, the
	 remainder of the 64K slot will result in a SEGV when accessed.

	 So, what we do here is cheating for the sake of the autoconf test
	 on 64 bit systems.  The justification is that there's very likely
	 no application actually utilizing the map beyond EOF, and we know that
	 all bytes beyond EOF are set to 0 anyway.  If this test doesn't work
	 on 64 bit systems, it will result in not using mmap at all in a
	 package.  But we want that mmap is treated as usable by autoconf,
	 regardless whether the autoconf test runs on a 32 bit or a 64 bit
	 system.

	 Ok, so we know exactly what autoconf is doing.  The file is called
	 "conftest.txt", it has a size of 1 byte, the mapping size is the
	 pagesize, the requested protection is PROT_READ | PROT_WRITE, the
	 mapping is MAP_SHARED, the offset is 0.

	 If all these requirements are given, we just return an anonymous map.
	 This will help to get over the autoconf test even on 64 bit systems.
	 The tests are ordered for speed. */
#ifdef __x86_64__
      if (1)
#else
      if (wincap.is_wow64 ())
#endif
	{
	  UNICODE_STRING fname;
	  IO_STATUS_BLOCK io;
	  FILE_STANDARD_INFORMATION fsi;

	  if (len == pagesize
	      && prot == (PROT_READ | PROT_WRITE)
	      && flags == MAP_SHARED
	      && off == 0
	      && (RtlSplitUnicodePath (fh->pc.get_nt_native_path (), NULL,
				       &fname),
		  wcscmp (fname.Buffer, L"conftest.txt") == 0)
	      && NT_SUCCESS (NtQueryInformationFile (fh->get_handle (), &io,
						     &fsi, sizeof fsi,
						     FileStandardInformation))
	      && fsi.EndOfFile.QuadPart == 1LL)
	    flags |= MAP_ANONYMOUS;
	}
    }

  if (anonymous (flags) || fd == -1)
    {
      fh = &fh_anonymous;
      fd = -1;
      flags |= MAP_ANONYMOUS;
      /* Anonymous mappings are always forced to pagesize length with
	 no offset. */
      len = roundup2 (len, pagesize);
      off = 0;
    }
  else if (fh->get_device () == FH_FS)
    {
      /* EACCES error conditions according to SUSv3.  File must be opened
	 for reading, regardless of the requested protection, and file must
	 be opened for writing when PROT_WRITE together with MAP_SHARED
	 is requested. */
      if (!(fh->get_access () & GENERIC_READ)
	  || (!(fh->get_access () & GENERIC_WRITE)
	      && (prot & PROT_WRITE) && !priv (flags)))
	{
	  set_errno (EACCES);
	  goto out;
	}

      /* You can't create mappings with PAGE_EXECUTE protection if
	 the file isn't explicitely opened with EXECUTE access. */
      OBJECT_ATTRIBUTES attr;
      NTSTATUS status;
      HANDLE h;
      IO_STATUS_BLOCK io;

      InitializeObjectAttributes (&attr, &ro_u_empty, fh->pc.objcaseinsensitive (),
				  fh->get_handle (), NULL);
      status = NtOpenFile (&h,
			   fh->get_access () | GENERIC_EXECUTE | SYNCHRONIZE,
			   &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT);
      if (NT_SUCCESS (status))
	{
	  fh_disk_file = new (ccalloc (HEAP_FHANDLER, 1, sizeof *fh_disk_file))
			     fhandler_disk_file;
	  fh_disk_file->set_name (fh->pc);
	  fh_disk_file->set_io_handle (h);
	  fh_disk_file->set_access (fh->get_access () | GENERIC_EXECUTE);
	  fh = fh_disk_file;
	}
      else if (prot & PROT_EXEC)
	{
	  /* TODO: To be or not to be... I'm opting for refusing this
	     mmap request rather than faking it, but that might break
	     some non-portable code. */
	  set_errno (EACCES);
	  goto out;
	}

      if (fh->fstat_fs (&st))
	{
	  __seterrno ();
	  goto out;
	}
      off_t fsiz = st.st_size;

      /* Don't allow file mappings beginning beyond EOF since Windows can't
	 handle that POSIX like, unless MAP_AUTOGROW flag is set, which
	 mimics Windows behaviour. */
      if (off >= fsiz && !autogrow (flags))
	{
	  /* Instead, it seems suitable to return an anonymous mapping of
	     the given size instead.  Mapped addresses beyond EOF aren't
	     written back to the file anyway, so the handling is identical
	     to other pages beyond EOF. */
	  fh = &fh_anonymous;
	  len = roundup2 (len, pagesize);
	  prot = PROT_READ | PROT_WRITE | __PROT_ATTACH;
	  flags &= MAP_FIXED;
	  flags |= MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE;
	  fd = -1;
	  off = 0;
	  goto go_ahead;
	}
      fsiz -= off;
      /* We're creating the pages beyond EOF as reserved, anonymous pages.
	 Note that this isn't done in 64 bit environments since apparently
	 64 bit systems don't support the AT_ROUND_TO_PAGE flag, which is
	 required to get this right.  Too bad. */
#ifndef __x86_64__
      if (!wincap.is_wow64 ()
	  && (((off_t) len > fsiz && !autogrow (flags))
	      || roundup2 (len, wincap.page_size ())
		 < roundup2 (len, pagesize)))
	orig_len = len;
#endif
      if ((off_t) len > fsiz)
	{
	  if (autogrow (flags))
	    {
	      /* Allow mapping beyond EOF if MAP_AUTOGROW flag is set.
		 Check if file has been opened for writing, otherwise
		 MAP_AUTOGROW is invalid. */
	      if (!(fh->get_access () & GENERIC_WRITE))
		{
		  set_errno (EINVAL);
		  goto out;
		}
	    }
	  else
	    /* Otherwise, don't map beyond EOF, since Windows would change
	       the file to the new length, in contrast to POSIX. */
	    len = fsiz;
	}

      /* If the requested offset + len is <= file size, drop MAP_AUTOGROW.
	 This simplifes fhandler::mmap's job. */
      if (autogrow (flags) && (off + (off_t) len) <= fsiz)
	flags &= ~MAP_AUTOGROW;
    }

go_ahead:

  /* MAP_NORESERVE is only supported on private anonymous mappings.
     Remove that bit from flags so that later code doesn't have to
     test all bits. */
  if (noreserve (flags) && (!anonymous (flags) || !priv (flags)))
    flags &= ~MAP_NORESERVE;

  LIST_LOCK ();
  map_list = mmapped_areas.get_list_by_fd (fd, &st);

  /* Test if an existing anonymous mapping can be recycled. */
  if (map_list && anonymous (flags))
    {
      caddr_t tried = map_list->try_map (addr, len, flags, off);
      /* try_map returns NULL if no map matched, otherwise it returns
	 a valid address, or MAP_FAILED in case of a fatal error. */
      if (tried)
	{
	  ret = tried;
	  goto out_with_unlock;
	}
    }

#ifdef __x86_64__
  addr = mmap_alloc.alloc (addr, orig_len ?: len, fixed (flags));
#else
  if (orig_len)
    {
      /* If the requested length is bigger than the file size, we try to
	 allocate an area of the full size first.  This area is immediately
	 deallocated and the address we got is used as base address for the
	 subsequent real mappings.  This ensures that we have enough space
	 for the whole thing. */
      orig_len = roundup2 (orig_len, pagesize);
      PVOID newaddr = VirtualAlloc (addr, orig_len, MEM_TOP_DOWN | MEM_RESERVE,
				    PAGE_READWRITE);
      if (!newaddr)
	{
	  /* If addr is not NULL, but MAP_FIXED isn't given, allow the OS
	     to choose. */
	  if (addr && !fixed (flags))
	    newaddr = VirtualAlloc (NULL, orig_len, MEM_TOP_DOWN | MEM_RESERVE,
				    PAGE_READWRITE);
	  if (!newaddr)
	    {
	      __seterrno ();
	      goto out_with_unlock;
	    }
	}
      if (!VirtualFree (newaddr, 0, MEM_RELEASE))
	{
	  __seterrno ();
	  goto out_with_unlock;
	}
      addr = newaddr;
    }
#endif

  base = mmap_worker (map_list, fh, (caddr_t) addr, len, prot, flags, fd, off,
		      &st);
  if (!base)
    goto out_with_unlock;

  if (orig_len)
    {
      /* If the requested length is bigger than the file size, the
	 remainder is created as anonymous mapping.  Actually two
	 mappings are created, first the remainder from the file end to
	 the next 64K boundary as accessible pages with the same
	 protection as the file's pages, then as much pages as necessary
	 to accomodate the requested length, but as reserved pages which
	 raise a SIGBUS when trying to access them.  AT_ROUND_TO_PAGE
	 and page protection on shared pages is only supported by 32 bit NT,
	 so don't even try on WOW64.  This is accomplished by not setting
	 orig_len on WOW64 above. */
#if 0
      orig_len = roundup2 (orig_len, pagesize);
#endif
      len = roundup2 (len, wincap.page_size ());
      if (orig_len - len)
	{
	  orig_len -= len;
	  size_t valid_page_len = orig_len % pagesize;
	  size_t sigbus_page_len = orig_len - valid_page_len;

	  caddr_t at_base = base + len;
	  if (valid_page_len)
	    {
	      prot |= __PROT_FILLER;
	      flags &= MAP_SHARED | MAP_PRIVATE;
	      flags |= MAP_ANONYMOUS | MAP_FIXED;
	      at_base = mmap_worker (NULL, &fh_anonymous, at_base,
				     valid_page_len, prot, flags, -1, 0, NULL);
	      if (!at_base)
		{
		  fh->munmap (fh->get_handle (), base, len);
		  set_errno (ENOMEM);
		  goto out_with_unlock;
		}
	      at_base += valid_page_len;
	    }
	  if (sigbus_page_len)
	    {
	      prot = PROT_READ | PROT_WRITE | __PROT_ATTACH;
	      flags = MAP_ANONYMOUS | MAP_NORESERVE | MAP_FIXED;
	      at_base = mmap_worker (NULL, &fh_anonymous, at_base,
				     sigbus_page_len, prot, flags, -1, 0, NULL);
	      if (!at_base)
		debug_printf ("Warning: Mapping beyond EOF failed, %E");
	    }
	}
    }

  ret = base;

out_with_unlock:
  LIST_UNLOCK ();

out:

  if (fh_disk_file)
    {
      NtClose (fh_disk_file->get_handle ());
      delete fh;
    }

  syscall_printf ("%p = mmap() ", ret);
  return ret;
}

#ifdef __x86_64__
EXPORT_ALIAS (mmap64, mmap)
#else
extern "C" void *
mmap (void *addr, size_t len, int prot, int flags, int fd, _off_t off)
{
  return mmap64 (addr, len, prot, flags, fd, (off_t)off);
}
#endif

/* munmap () removes all mmapped pages between addr and addr+len. */

extern "C" int
munmap (void *addr, size_t len)
{
  syscall_printf ("munmap (addr %p, len %lu)", addr, len);

  /* Error conditions according to SUSv3 */
  if (!addr || !len || check_invalid_virtual_addr (addr, len))
    {
      set_errno (EINVAL);
      return -1;
    }
  size_t pagesize = wincap.allocation_granularity ();
  if (((uintptr_t) addr % pagesize) || !len)
    {
      set_errno (EINVAL);
      return -1;
    }
  len = roundup2 (len, pagesize);

  LIST_LOCK ();

  /* Iterate through the map, unmap pages between addr and addr+len
     in all maps. */
  mmap_list *map_list, *next_map_list;
  LIST_FOREACH_SAFE (map_list, &mmapped_areas.lists, ml_next, next_map_list)
    {
      mmap_record *rec, *next_rec;
      caddr_t u_addr;
      DWORD u_len;

      LIST_FOREACH_SAFE (rec, &map_list->recs, mr_next, next_rec)
	{
	  if (!rec->match ((caddr_t) addr, len, u_addr, u_len))
	    continue;
	  if (rec->unmap_pages (u_addr, u_len))
	    {
	      /* The whole record has been unmapped, so we now actually
		 unmap it from the system in full length... */
	      fhandler_base *fh = rec->alloc_fh ();
	      fh->munmap (rec->get_handle (),
			  rec->get_address (),
			  rec->get_len ());
	      rec->free_fh (fh);

	      /* ...and delete the record. */
	      if (map_list->del_record (rec))
		{
		  /* Yay, the last record has been removed from the list,
		     we can remove the list now, too. */
		  mmapped_areas.del_list (map_list);
		  break;
		}
	    }
	}
    }

  LIST_UNLOCK ();
  syscall_printf ("0 = munmap(): %p", addr);
  return 0;
}

/* Sync file with memory. Ignore flags for now. */

extern "C" int
msync (void *addr, size_t len, int flags)
{
  int ret = -1;
  mmap_list *map_list;

  syscall_printf ("msync (addr: %p, len %lu, flags %y)", addr, len, flags);

  pthread_testcancel ();

  LIST_LOCK ();

  if (((uintptr_t) addr % wincap.allocation_granularity ())
      || (flags & ~(MS_ASYNC | MS_SYNC | MS_INVALIDATE))
      || ((flags & (MS_ASYNC | MS_SYNC)) == (MS_ASYNC | MS_SYNC)))
    {
      set_errno (EINVAL);
      goto out;
    }
#if 0 /* If I only knew why I did that... */
  len = roundup2 (len, wincap.allocation_granularity ());
#endif

  /* Iterate through the map, looking for the mmapped area.
     Error if not found. */
  LIST_FOREACH (map_list, &mmapped_areas.lists, ml_next)
    {
      mmap_record *rec;
      LIST_FOREACH (rec, &map_list->recs, mr_next)
	{
	  if (rec->access ((caddr_t) addr))
	    {
	      /* Check whole area given by len. */
	      for (DWORD i = wincap.allocation_granularity ();
		   i < len;
		   i += wincap.allocation_granularity ())
		if (!rec->access ((caddr_t) addr + i))
		  {
		    set_errno (ENOMEM);
		    goto out;
		  }
	      fhandler_base *fh = rec->alloc_fh ();
	      ret = fh->msync (rec->get_handle (), (caddr_t) addr, len, flags);
	      rec->free_fh (fh);
	      goto out;
	    }
	}
    }

  /* No matching mapping exists. */
  set_errno (ENOMEM);

out:
  LIST_UNLOCK ();
  syscall_printf ("%R = msync()", ret);
  return ret;
}

/* Set memory protection */

extern "C" int
mprotect (void *addr, size_t len, int prot)
{
  bool in_mapped = false;
  bool ret = false;
  DWORD old_prot;
  DWORD new_prot = 0;

  syscall_printf ("mprotect (addr: %p, len %lu, prot %y)", addr, len, prot);

  /* See comment in mmap64 for a description. */
  size_t pagesize = wincap.allocation_granularity ();
  if ((uintptr_t) addr % pagesize)
    {
      set_errno (EINVAL);
      goto out;
    }
  len = roundup2 (len, pagesize);

  LIST_LOCK ();

  /* Iterate through the map, protect pages between addr and addr+len
     in all maps. */
  mmap_list *map_list;
  LIST_FOREACH (map_list, &mmapped_areas.lists, ml_next)
    {
      mmap_record *rec;
      caddr_t u_addr;
      DWORD u_len;

      LIST_FOREACH (rec, &map_list->recs, mr_next)
	{
	  if (!rec->match ((caddr_t) addr, len, u_addr, u_len))
	    continue;
	  in_mapped = true;
	  if (rec->attached ())
	    continue;
	  new_prot = gen_protect (prot, rec->get_flags ());
	  if (rec->noreserve ())
	    {
	      if (new_prot == PAGE_NOACCESS)
		ret = VirtualFree (u_addr, u_len, MEM_DECOMMIT);
	      else
		ret = !!VirtualAlloc (u_addr, u_len, MEM_COMMIT, new_prot);
	    }
	  else
	    ret = VirtualProtect (u_addr, u_len, new_prot, &old_prot);
	  if (!ret)
	    {
	      __seterrno ();
	      break;
	    }
	}
    }

  LIST_UNLOCK ();

  if (!in_mapped)
    {
      int flags = 0;
      MEMORY_BASIC_INFORMATION mbi;

      ret = VirtualQuery (addr, &mbi, sizeof mbi);
      if (ret)
	{
	  /* If write protection is requested, check if the page was
	     originally protected writecopy.  In this case call VirtualProtect
	     requesting PAGE_WRITECOPY, otherwise the VirtualProtect will fail
	     on NT version >= 5.0 */
	  if (prot & PROT_WRITE)
	    {
	      if (mbi.AllocationProtect == PAGE_WRITECOPY
		  || mbi.AllocationProtect == PAGE_EXECUTE_WRITECOPY)
		flags = MAP_PRIVATE;
	    }
	  new_prot = gen_protect (prot, flags);
	  if (new_prot != PAGE_NOACCESS && mbi.State == MEM_RESERVE)
	    ret = VirtualAlloc (addr, len, MEM_COMMIT, new_prot);
	  else
	    ret = VirtualProtect (addr, len, new_prot, &old_prot);
	}
      if (!ret)
	__seterrno ();
    }

out:

  syscall_printf ("%R = mprotect ()", ret ? 0 : -1);
  return ret ? 0 : -1;
}

extern "C" int
mlock (const void *addr, size_t len)
{
  int ret = -1;

  /* Align address and length values to page size. */
  size_t pagesize = wincap.allocation_granularity ();
  PVOID base = (PVOID) rounddown((uintptr_t) addr, pagesize);
  SIZE_T size = roundup2 (((uintptr_t) addr - (uintptr_t) base) + len,
			  pagesize);
  NTSTATUS status = 0;
  do
    {
      status = NtLockVirtualMemory (NtCurrentProcess (), &base, &size,
				    MAP_PROCESS);
      if (status == STATUS_WORKING_SET_QUOTA)
	{
	  /* The working set is too small, try to increase it so that the
	     requested locking region fits in.  Unfortunately I don't know
	     any function which would return the currently locked pages of
	     a process (no go with NtQueryVirtualMemory).

	     So, except for the border cases, what we do here is something
	     really embarrassing.  We raise the working set by 64K at a time
	     and retry, until either we fail to raise the working set size
	     further, or until NtLockVirtualMemory returns successfully (or
	     with another error).  */
	  SIZE_T min, max;
	  if (!GetProcessWorkingSetSize (GetCurrentProcess (), &min, &max))
	    {
	      set_errno (ENOMEM);
	      break;
	    }
	  if (min < size)
	    min = size + pagesize;
	  else if (size < pagesize)
	    min += size;
	  else
	    min += pagesize;
	  if (max < min)
	    max = min;
	  if (!SetProcessWorkingSetSize (GetCurrentProcess (), min, max))
	    {
	      set_errno (ENOMEM);
	      break;
	    }
	}
      else if (!NT_SUCCESS (status))
	__seterrno_from_nt_status (status);
      else
	ret = 0;
    }
  while (status == STATUS_WORKING_SET_QUOTA);

  syscall_printf ("%R = mlock(%p, %lu)", ret, addr, len);
  return ret;
}

extern "C" int
munlock (const void *addr, size_t len)
{
  int ret = -1;

  /* Align address and length values to page size. */
  size_t pagesize = wincap.allocation_granularity ();
  PVOID base = (PVOID) rounddown((uintptr_t) addr, pagesize);
  SIZE_T size = roundup2 (((uintptr_t) addr - (uintptr_t) base) + len,
			  pagesize);
  NTSTATUS status = NtUnlockVirtualMemory (NtCurrentProcess (), &base, &size,
					   MAP_PROCESS);
  if (!NT_SUCCESS (status))
    __seterrno_from_nt_status (status);
  else
    ret = 0;

  syscall_printf ("%R = munlock(%p, %lu)", ret, addr, len);
  return ret;
}

extern "C" int
posix_madvise (void *addr, size_t len, int advice)
{
  int ret;
  /* Check parameters. */
  if (advice < POSIX_MADV_NORMAL || advice > POSIX_MADV_DONTNEED
      || !len)
    ret = EINVAL;
  else
    {
      /* Check requested memory area. */
      MEMORY_BASIC_INFORMATION m;
      char *p = (char *) addr;
      char *endp = p + len;
      while (p < endp)
	{
	  if (!VirtualQuery (p, &m, sizeof m) || m.State == MEM_FREE)
	    {
	      ret = ENOMEM;
	      break;
	    }
	  p = (char *) m.BaseAddress + m.RegionSize;
	}
      ret = 0;
    }

  syscall_printf ("%d = posix_madvise(%p, %lu, %d)", ret, addr, len, advice);
  /* Eventually do nothing. */
  return 0;
}

/*
 * Base implementation:
 *
 * `mmap' returns ENODEV as documented in SUSv2.
 * In contrast to the global function implementation, the member function
 * `mmap' has to return the mapped base address in `addr' and the handle to
 * the mapping object as return value. In case of failure, the fhandler
 * mmap has to close that handle by itself and return INVALID_HANDLE_VALUE.
 *
 * `munmap' and `msync' get the handle to the mapping object as first parameter
 * additionally.
*/
HANDLE
fhandler_base::mmap (caddr_t *addr, size_t len, int prot,
		     int flags, off_t off)
{
  set_errno (ENODEV);
  return INVALID_HANDLE_VALUE;
}

int
fhandler_base::munmap (HANDLE h, caddr_t addr, size_t len)
{
  set_errno (ENODEV);
  return -1;
}

int
fhandler_base::msync (HANDLE h, caddr_t addr, size_t len, int flags)
{
  set_errno (ENODEV);
  return -1;
}

bool
fhandler_base::fixup_mmap_after_fork (HANDLE h, int prot, int flags,
				      off_t offset, DWORD size,
				      void *address)
{
  set_errno (ENODEV);
  return -1;
}

/* Implementation for anonymous maps.  Using fhandler_dev_zero looks
   quite the natural way. */
HANDLE
fhandler_dev_zero::mmap (caddr_t *addr, size_t len, int prot,
			 int flags, off_t off)
{
  HANDLE h;
  void *base;

  if (priv (flags) && !filler (prot))
    {
      /* Private anonymous maps are now implemented using VirtualAlloc.
	 This has two advantages:

	 - VirtualAlloc has a smaller footprint than a copy-on-write
	   anonymous map.

	 - It supports decommitting using VirtualFree, in contrast to
	   section maps.  This allows minimum footprint private maps,
	   when using the (non-POSIX, yay-Linux) MAP_NORESERVE flag.
      */
      DWORD protect = gen_protect (prot, flags);
      DWORD alloc_type = MEM_TOP_DOWN | MEM_RESERVE
			 | (noreserve (flags) ? 0 : MEM_COMMIT);
      base = VirtualAlloc (*addr, len, alloc_type, protect);
      if (!base && addr && !fixed (flags))
	base = VirtualAlloc (NULL, len, alloc_type, protect);
      if (!base || (fixed (flags) && base != *addr))
	{
	  if (!base)
	    __seterrno ();
	  else
	    {
	      VirtualFree (base, 0, MEM_RELEASE);
	      set_errno (EINVAL);
	      debug_printf ("VirtualAlloc: address shift with MAP_FIXED given");
	    }
	  return INVALID_HANDLE_VALUE;
	}
      h = (HANDLE) 1; /* Fake handle to indicate success. */
    }
  else
    {
      h = CreateMapping (get_handle (), len, off, get_access (), prot, flags);
      if (!h)
	{
	  __seterrno ();
	  debug_printf ("CreateMapping failed with %E");
	  return INVALID_HANDLE_VALUE;
	}

      base = MapView (h, *addr, len, get_access(), prot, flags, off);
      if (!base || (fixed (flags) && base != *addr))
	{
	  if (!base)
	    __seterrno ();
	  else
	    {
	      NtUnmapViewOfSection (NtCurrentProcess (), base);
	      set_errno (EINVAL);
	      debug_printf ("MapView: address shift with MAP_FIXED given");
	    }
	  NtClose (h);
	  return INVALID_HANDLE_VALUE;
	}
    }
  *addr = (caddr_t) base;
  return h;
}

int
fhandler_dev_zero::munmap (HANDLE h, caddr_t addr, size_t len)
{
  if (h == (HANDLE) 1)	/* See fhandler_dev_zero::mmap. */
    VirtualFree (addr, 0, MEM_RELEASE);
  else
    {
      NtUnmapViewOfSection (NtCurrentProcess (), addr);
      NtClose (h);
    }
  return 0;
}

int
fhandler_dev_zero::msync (HANDLE h, caddr_t addr, size_t len, int flags)
{
  return 0;
}

bool
fhandler_dev_zero::fixup_mmap_after_fork (HANDLE h, int prot, int flags,
				      off_t offset, DWORD size,
				      void *address)
{
  /* Re-create the map */
  void *base;
  if (priv (flags) && !filler (prot))
    {
      DWORD alloc_type = MEM_RESERVE | (noreserve (flags) ? 0 : MEM_COMMIT);
      /* Always allocate R/W so that ReadProcessMemory doesn't fail
	 due to a non-writable target address.  The protection is
	 set to the correct one anyway in the fixup loop. */
      base = VirtualAlloc (address, size, alloc_type, PAGE_READWRITE);
    }
  else
    base = MapView (h, address, size, get_access (), prot, flags, offset);
  if (base != address)
    {
      MEMORY_BASIC_INFORMATION m;
      VirtualQuery (address, &m, sizeof (m));
      system_printf ("requested %p != %p mem alloc base %p, state %y, "
		     "size %lu, %E", address, base, m.AllocationBase, m.State,
		     m.RegionSize);
    }
  return base == address;
}

/* Implementation for disk files and anonymous mappings. */
HANDLE
fhandler_disk_file::mmap (caddr_t *addr, size_t len, int prot,
			  int flags, off_t off)
{
  HANDLE h = CreateMapping (get_handle (), len, off, get_access (),
			    prot, flags);
  if (!h)
    {
      __seterrno ();
      debug_printf ("CreateMapping failed with %E");
      return INVALID_HANDLE_VALUE;
    }

  void *base = MapView (h, *addr, len, get_access (), prot, flags, off);
  if (!base || (fixed (flags) && base != *addr))
    {
      if (!base)
	__seterrno ();
      else
	{
	  NtUnmapViewOfSection (NtCurrentProcess (), base);
	  set_errno (EINVAL);
	  debug_printf ("MapView: address shift with MAP_FIXED given");
	}
      NtClose (h);
      return INVALID_HANDLE_VALUE;
    }

  *addr = (caddr_t) base;
  return h;
}

int
fhandler_disk_file::munmap (HANDLE h, caddr_t addr, size_t len)
{
  NtUnmapViewOfSection (NtCurrentProcess (), addr);
  NtClose (h);
  return 0;
}

int
fhandler_disk_file::msync (HANDLE h, caddr_t addr, size_t len, int flags)
{
  const int retry = 100;
  /* The wisdom of google tells us that FlushViewOfFile may fail with
     ERROR_LOCK_VIOLATION if "if the memory system is writing dirty
     pages to disk".  And, we've seen reports of this happening in the
     cygwin list.  So retry 99 times and hope we get lucky.  */
  for (int i = 0; i < retry; i++)
    if (FlushViewOfFile (addr, len))
      {
	/* FlushViewOfFile just triggers the action and returns immediately,
	   so it's equivalent to MS_ASYNC.  MS_SYNC requires another call to
	   FlushFileBuffers. */
	if (flags & MS_SYNC)
	  FlushFileBuffers (h);
	return 0;
      }
    else if (GetLastError () != ERROR_LOCK_VIOLATION)
      break;
    else if (i < (retry - 1))
      yield ();

  __seterrno ();
  return -1;
}

bool
fhandler_disk_file::fixup_mmap_after_fork (HANDLE h, int prot, int flags,
					   off_t offset, DWORD size,
					   void *address)
{
  /* Re-create the map */
  void *base = MapView (h, address, size, get_access (), prot, flags, offset);
  if (base != address)
    {
      MEMORY_BASIC_INFORMATION m;
      VirtualQuery (address, &m, sizeof (m));
      system_printf ("requested %p != %p mem alloc base %p, state %y, "
		     "size %lu, %E", address, base, m.AllocationBase, m.State,
		     m.RegionSize);
    }
  return base == address;
}

/* Call to re-create all the file mappings in a forked child. Called from
   the child in initialization. At this point we are passed a valid
   mmapped_areas map, and all the HANDLE's are valid for the child, but
   none of the mapped areas are in our address space. We need to iterate
   through the map, doing the MapViewOfFile calls.  */

int __stdcall
fixup_mmaps_after_fork (HANDLE parent)
{
  /* Iterate through the map */
  mmap_list *map_list;
  LIST_FOREACH (map_list, &mmapped_areas.lists, ml_next)
    {
      mmap_record *rec;
      LIST_FOREACH (rec, &map_list->recs, mr_next)
	{
	  debug_printf ("fd %d, h %p, address %p, len %ly, prot: %y, "
			"flags: %y, offset %Y",
			rec->get_fd (), rec->get_handle (), rec->get_address (),
			rec->get_len (), rec->get_prot (), rec->get_flags (),
			rec->get_offset ());

	  fhandler_base *fh = rec->alloc_fh ();
	  bool ret = fh->fixup_mmap_after_fork (rec->get_handle (),
						rec->get_prot (),
						rec->get_flags () | MAP_FIXED,
						rec->get_offset (),
						rec->get_len (),
						rec->get_address ());
	  rec->free_fh (fh);

	  if (!ret)
	    {
	      if (rec->attached ())
		{
		  system_printf ("Warning: Fixup mapping beyond EOF failed");
		  continue;
		}
	      return -1;
	    }

	  MEMORY_BASIC_INFORMATION mbi;
	  DWORD old_prot;

	  for (char *address = rec->get_address ();
	       address < rec->get_address () + rec->get_len ();
	       address += mbi.RegionSize)
	    {
	      if (!VirtualQueryEx (parent, address, &mbi, sizeof mbi))
		{
		  system_printf ("VirtualQueryEx failed for MAP_PRIVATE "
				 "address %p, %E", address);
		  return -1;
		}
	      /* Just skip reserved pages. */
	      if (mbi.State == MEM_RESERVE)
		continue;
	      /* Copy-on-write pages must be copied to the child to circumvent
		 a strange notion how copy-on-write is supposed to work. */
	      if (rec->priv ())
		{
		  if (rec->noreserve ()
		      && !VirtualAlloc (address, mbi.RegionSize,
					MEM_COMMIT, PAGE_READWRITE))
		    {
		      system_printf ("VirtualAlloc failed for MAP_PRIVATE "
				     "address %p, %E", address);
		      return -1;
		    }
		  if (mbi.Protect == PAGE_NOACCESS
		      && !VirtualProtectEx (parent, address, mbi.RegionSize,
					    PAGE_READONLY, &old_prot))
		    {
		      system_printf ("VirtualProtectEx failed for MAP_PRIVATE "
				     "address %p, %E", address);
		      return -1;
		    }
		  else if ((mbi.AllocationProtect == PAGE_WRITECOPY
			    || mbi.AllocationProtect == PAGE_EXECUTE_WRITECOPY)
			   && (mbi.Protect == PAGE_READWRITE
			       || mbi.Protect == PAGE_EXECUTE_READWRITE))
		    /* A WRITECOPY page which has been written to is set to
		       READWRITE, but that's an incompatible protection to
		       set the page to.  Convert the protection to WRITECOPY
		       so that the below VirtualProtect doesn't fail. */
		    mbi.Protect <<= 1;

		  if (!ReadProcessMemory (parent, address, address,
					  mbi.RegionSize, NULL))
		    {
		      system_printf ("ReadProcessMemory failed for MAP_PRIVATE "
				     "address %p, %E", address);
		      return -1;
		    }
		  if (mbi.Protect == PAGE_NOACCESS
		      && !VirtualProtectEx (parent, address, mbi.RegionSize,
					    PAGE_NOACCESS, &old_prot))
		    {
		      system_printf ("WARNING: VirtualProtectEx to return to "
				     "PAGE_NOACCESS state in parent failed for "
				     "MAP_PRIVATE address %p, %E", address);
		      return -1;
		    }
		}
	      /* Set child page protection to parent protection */
	      if (!VirtualProtect (address, mbi.RegionSize,
				   mbi.Protect, &old_prot))
		{
		  MEMORY_BASIC_INFORMATION m;
		  VirtualQuery (address, &m, sizeof m);
		  system_printf ("VirtualProtect failed for "
				 "address %p, "
				 "parentstate: %y, "
				 "state: %y, "
				 "parentprot: %y, "
				 "prot: %y, %E",
				 address, mbi.State, m.State,
				 mbi.Protect, m.Protect);
		  return -1;
		}
	    }
	}
    }

  debug_printf ("succeeded");
  return 0;
}
@


1.183
log
@	Remove /dev/mem, /dev/kmem, /dev/port support.
	* Makefile.in (DLL_OFILES): Drop fhandler_mem.o.
	(fhandler_mem_CFLAGS): Remove rule.
	* devices.in (enum fh_devices): Remove FH_MEM, FH_KMEM and FH_PORT.
	* devices.cc: Regenerate.
	* dtable.cc (fh_alloc): Drop handling for FH_MEM, FH_KMEM and FH_PORT.
	* fhandler.h (class fhandler_dev_mem): Remove.
	* fhandler_mem.cc: Remove file.
	* globals.cc (ro_u_pmem): Remove.
	* mmap.cc (fhandler_dev_mem::mmap): Remove.
	(fhandler_dev_mem::munmap): Remove.
	(fhandler_dev_mem::fixup_mmap_after_fork): Remove.
@
text
@d904 1
a904 1
  DWORD pagesize = wincap.allocation_granularity ();
@


1.182
log
@	* Merge in cygwin-64bit-branch.
@
text
@a1813 94
HANDLE
fhandler_dev_mem::mmap (caddr_t *addr, size_t len, int prot,
			int flags, off_t off)
{
  if (off >= (off_t) mem_size
      || len >= mem_size
      || off + len >= mem_size)
    {
      set_errno (EINVAL);
      debug_printf ("-1 = mmap(): illegal parameter, set EINVAL");
      return INVALID_HANDLE_VALUE;
    }

  OBJECT_ATTRIBUTES attr;
  InitializeObjectAttributes (&attr, &ro_u_pmem,
			      OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
			      NULL, NULL);

  /* Section access is bit-wise ored, while on the Win32 level access
     is only one of the values.  It's not quite clear if the section
     access has to be defined this way, or if SECTION_ALL_ACCESS would
     be sufficient but this worked fine so far, so why change? */
  ACCESS_MASK section_access;
  if (prot & PROT_WRITE)
    section_access = SECTION_MAP_READ | SECTION_MAP_WRITE;
  else
    section_access = SECTION_MAP_READ;

  HANDLE h;
  NTSTATUS status = NtOpenSection (&h, section_access, &attr);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      debug_printf ("-1 = mmap(): NtOpenSection failed with %E");
      return INVALID_HANDLE_VALUE;
    }

  void *base = MapView (h, *addr, len, get_access (), prot,
			flags | MAP_ANONYMOUS, off);
  if (!base || (fixed (flags) && base != *addr))
    {
      if (!base)
	__seterrno ();
      else
	{
	  NtUnmapViewOfSection (NtCurrentProcess (), base);
	  set_errno (EINVAL);
	  debug_printf ("MapView: address shift with MAP_FIXED given");
	}
      NtClose (h);
      return INVALID_HANDLE_VALUE;
    }

  *addr = (caddr_t) base;
  return h;
}

int
fhandler_dev_mem::munmap (HANDLE h, caddr_t addr, size_t len)
{
  NTSTATUS status;
  if (!NT_SUCCESS (status = NtUnmapViewOfSection (NtCurrentProcess (), addr)))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  NtClose (h);
  return 0;
}

int
fhandler_dev_mem::msync (HANDLE h, caddr_t addr, size_t len, int flags)
{
  return 0;
}

bool
fhandler_dev_mem::fixup_mmap_after_fork (HANDLE h, int prot, int flags,
					 off_t offset, DWORD size,
					 void *address)
{
  void *base = MapView (h, address, size, get_access (), prot,
			flags | MAP_ANONYMOUS, offset);
  if (base != address)
    {
      MEMORY_BASIC_INFORMATION m;
      VirtualQuery (address, &m, sizeof (m));
      system_printf ("requested %p != %p mem alloc base %p, state %y, "
		     "size %lu, %E", address, base, m.AllocationBase, m.State,
		     m.RegionSize);
    }
  return base == address;
}

@


1.181
log
@	* mmap.cc (is_mmapped_region): Call LIST_UNLOCK on premature return.
@
text
@d140 1
a140 1
CreateMapping (HANDLE fhdl, size_t len, _off64_t off, DWORD openflags,
d146 1
a146 1
  LARGE_INTEGER sectionsize = { QuadPart: len };
d194 1
a194 1
	 int prot, int flags, _off64_t off)
d200 5
a204 2
  ULONG commitsize = attached (prot) ? 0 : len;
  ULONG viewsize = len;
d207 1
d229 2
a230 2
  debug_printf ("%p (status %p) = NtMapViewOfSection (h:%x, addr:%x, len:%u,"
		" off:%X, protect:%x, type:%x)",
d260 7
a267 1
    HANDLE mapping_hdl;
d271 1
a271 4
    _off64_t offset;
    DWORD len;
    caddr_t base_address;
    int dev;
d275 1
a275 1
    mmap_record (int nfd, HANDLE h, DWORD of, int p, int f, _off64_t o, DWORD l,
d277 4
a281 1
       mapping_hdl (h),
d284 1
a284 4
       flags (f),
       offset (o),
       len (l),
       base_address (b)
d306 2
a307 2
    _off64_t get_offset () const { return offset; }
    DWORD get_len () const { return len; }
d313 4
a316 4
    bool match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len);
    _off64_t map_pages (_off64_t off, DWORD len);
    bool map_pages (caddr_t addr, DWORD len);
    bool unmap_pages (caddr_t addr, DWORD len);
d338 1
a338 1
    __ino64_t hash;
d342 1
a342 1
    __ino64_t get_hash () const { return hash; }
d345 1
a345 1
    void set (int nfd, struct __stat64 *st);
d348 1
a348 1
    caddr_t try_map (void *addr, size_t len, int flags, _off64_t off);
d356 2
a357 2
    mmap_list *get_list_by_fd (int fd, struct __stat64 *st);
    mmap_list *add_list (int fd, struct __stat64 *st);
d393 1
a393 1
mmap_record::match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len)
d420 2
a421 2
    system_printf ("Warning: VirtualProtect (addr: %p, len: 0x%x, "
		   "new_prot: 0x%x, old_prot: 0x%x), %E",
d424 1
a424 1
  DWORD len = PAGE_CNT (get_len ());
d429 2
a430 2
_off64_t
mmap_record::map_pages (_off64_t off, DWORD len)
d437 1
a437 1
  debug_printf ("map_pages (fd=%d, off=%D, len=%u)", get_fd (), off, len);
d448 1
a448 1
      return (_off64_t)-1;
d457 1
a457 1
mmap_record::map_pages (caddr_t addr, DWORD len)
d459 1
a459 1
  debug_printf ("map_pages (addr=%x, len=%u)", addr, len);
d485 1
a485 1
mmap_record::unmap_pages (caddr_t addr, DWORD len)
d563 1
a563 1
mmap_list::set (int nfd, struct __stat64 *st)
d571 1
a571 1
      hash = st ? st->st_ino : (__ino64_t) 0;
d587 1
a587 1
mmap_list::try_map (void *addr, size_t len, int flags, _off64_t off)
d595 1
a595 1
      DWORD plen = PAGE_CNT (len);
d601 1
a601 1
	  if ((off = rec->map_pages (off, len)) == (_off64_t) -1)
d637 1
a637 1
mmap_areas::get_list_by_fd (int fd, struct __stat64 *st)
d654 1
a654 1
mmap_areas::add_list (int fd, struct __stat64 *st)
d781 1
a781 1
	     int prot, int flags, int fd, _off64_t off, struct __stat64 *st)
d803 86
d890 1
a890 1
mmap64 (void *addr, size_t len, int prot, int flags, int fd, _off64_t off)
d892 1
a892 1
  syscall_printf ("addr %x, len %u, prot %x, flags %x, fd %d, off %D",
d902 1
a902 1
  struct __stat64 st;
d958 3
d962 1
d1044 1
a1044 1
      _off64_t fsiz = st.st_size;
d1066 4
a1069 3
	 Note that this isn't done in WOW64 environments since apparently
	 WOW64 does not support the AT_ROUND_TO_PAGE flag which is required
	 to get this right.  Too bad. */
d1071 1
a1071 1
	  && ((len > fsiz && !autogrow (flags))
d1075 2
a1076 1
      if (len > fsiz)
d1097 1
a1097 1
      if (autogrow (flags) && (off + len) <= fsiz)
d1125 3
d1158 1
d1232 3
d1238 1
a1238 1
  return mmap64 (addr, len, prot, flags, fd, (_off64_t)off);
d1240 1
d1247 1
a1247 1
  syscall_printf ("munmap (addr %x, len %u)", addr, len);
d1301 1
a1301 1
  syscall_printf ("0 = munmap(): %x", addr);
d1313 1
a1313 1
  syscall_printf ("msync (addr: %p, len %u, flags %x)", addr, len, flags);
d1375 1
a1375 1
  syscall_printf ("mprotect (addr: %p, len %u, prot %x)", addr, len, prot);
d1466 2
a1467 1
  ULONG size = roundup2 (((uintptr_t) addr - (uintptr_t) base) + len, pagesize);
d1485 1
a1485 1
	  ULONG min, max;
d1512 1
a1512 1
  syscall_printf ("%R = mlock(%p, %u)", ret, addr, len);
d1524 2
a1525 1
  ULONG size = roundup2 (((uintptr_t) addr - (uintptr_t) base) + len, pagesize);
d1533 1
a1533 1
  syscall_printf ("%R = munlock(%p, %u)", ret, addr, len);
d1563 1
a1563 1
  syscall_printf ("%d = posix_madvise(%p, %u, %d)", ret, addr, len, advice);
d1582 1
a1582 1
		     int flags, _off64_t off)
d1604 1
a1604 1
				      _off64_t offset, DWORD size,
d1615 1
a1615 1
			 int flags, _off64_t off)
d1702 1
a1702 1
				      _off64_t offset, DWORD size,
d1721 2
a1722 2
      system_printf ("requested %p != %p mem alloc base %p, state %p, "
		     "size %d, %E", address, base, m.AllocationBase, m.State,
d1731 1
a1731 1
			  int flags, _off64_t off)
d1798 1
a1798 1
					   _off64_t offset, DWORD size,
d1807 2
a1808 2
      system_printf ("requested %p != %p mem alloc base %p, state %p, "
		     "size %d, %E", address, base, m.AllocationBase, m.State,
d1816 1
a1816 1
			int flags, _off64_t off)
d1818 2
a1819 2
  if (off >= mem_size
      || (DWORD) len >= mem_size
d1892 1
a1892 1
					 _off64_t offset, DWORD size,
d1901 2
a1902 2
      system_printf ("requested %p != %p mem alloc base %p, state %p, "
		     "size %d, %E", address, base, m.AllocationBase, m.State,
d1924 2
a1925 2
	  debug_printf ("fd %d, h 0x%x, address %p, len 0x%x, prot: 0x%x, "
			"flags: 0x%x, offset %X",
d2020 4
a2023 4
				 "parentstate: 0x%x, "
				 "state: 0x%x, "
				 "parentprot: 0x%x, "
				 "prot: 0x%x, %E",
@


1.180
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d675 4
a678 1
    return false;
@


1.179
log
@	* mmap.cc (handler_disk_file::msync): Add call to FlushFileBuffers
	to implement MS_SYNC.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.178
log
@* mmap.cc (handler_disk_file::msync): Retry up to 99 times if FlushViewOFile
fails with ERROR_LOCK_VIOLATION.
@
text
@d1667 8
a1674 1
      return 0;
@


1.177
log
@* dtable.cc (cygwin_attach_handle_to_fd): Defend against NULL return from
build_fh_*.
(dtable::init_std_file_from_handle): Ditto.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* path.cc (path_conv::check): Ditto.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d1660 15
a1674 6
  if (FlushViewOfFile (addr, len) == 0)
    {
      __seterrno ();
      return -1;
    }
  return 0;
@


1.177.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d140 1
a140 1
CreateMapping (HANDLE fhdl, size_t len, off_t off, DWORD openflags,
d194 1
a194 1
	 int prot, int flags, off_t off)
d261 1
a261 1
    off_t offset;
d268 1
a268 1
    mmap_record (int nfd, HANDLE h, DWORD of, int p, int f, off_t o, DWORD l,
d299 1
a299 1
    off_t get_offset () const { return offset; }
d307 1
a307 1
    off_t map_pages (off_t off, DWORD len);
d331 1
a331 1
    ino_t hash;
d335 1
a335 1
    ino_t get_hash () const { return hash; }
d338 1
a338 1
    void set (int nfd, struct stat *st);
d341 1
a341 1
    caddr_t try_map (void *addr, size_t len, int flags, off_t off);
d349 2
a350 2
    mmap_list *get_list_by_fd (int fd, struct stat *st);
    mmap_list *add_list (int fd, struct stat *st);
d422 2
a423 2
off_t
mmap_record::map_pages (off_t off, DWORD len)
d441 1
a441 1
      return (off_t)-1;
d556 1
a556 1
mmap_list::set (int nfd, struct stat *st)
d564 1
a564 1
      hash = st ? st->st_ino : (ino_t) 0;
d580 1
a580 1
mmap_list::try_map (void *addr, size_t len, int flags, off_t off)
d594 1
a594 1
	  if ((off = rec->map_pages (off, len)) == (off_t) -1)
d630 1
a630 1
mmap_areas::get_list_by_fd (int fd, struct stat *st)
d647 1
a647 1
mmap_areas::add_list (int fd, struct stat *st)
d771 1
a771 1
	     int prot, int flags, int fd, off_t off, struct stat *st)
d794 1
a794 1
mmap64 (void *addr, size_t len, int prot, int flags, int fd, off_t off)
d806 1
a806 1
  struct stat st;
d944 1
a944 1
      off_t fsiz = st.st_size;
a1125 3
#ifdef __x86_64__
EXPORT_ALIAS (mmap64, mmap)
#else
d1129 1
a1129 1
  return mmap64 (addr, len, prot, flags, fd, (off_t)off);
a1130 1
#endif
d1470 1
a1470 1
		     int flags, off_t off)
d1492 1
a1492 1
				      off_t offset, DWORD size,
d1503 1
a1503 1
			 int flags, off_t off)
d1590 1
a1590 1
				      off_t offset, DWORD size,
d1619 1
a1619 1
			  int flags, off_t off)
d1670 1
a1670 1
					   off_t offset, DWORD size,
d1688 1
a1688 1
			int flags, off_t off)
d1764 1
a1764 1
					 off_t offset, DWORD size,
@


1.177.2.2
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d264 1
a264 1
    dev_t dev;
@


1.177.2.3
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d146 1
a146 1
  LARGE_INTEGER sectionsize = { QuadPart: (LONGLONG) len };
d970 1
a970 1
	  && (((off_t) len > fsiz && !autogrow (flags))
d974 1
a974 1
      if ((off_t) len > fsiz)
d995 1
a995 1
      if (autogrow (flags) && (off + (off_t) len) <= fsiz)
d1378 1
a1378 1
	  SIZE_T min, max;
@


1.177.2.4
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d200 2
a201 2
  SIZE_T commitsize = attached (prot) ? 0 : len;
  SIZE_T viewsize = len;
d225 2
a226 2
  debug_printf ("%p (status %p) = NtMapViewOfSection (h:%p, addr:%p, len:%lu,"
		" off:%Y, protect:%y, type:%y)",
d262 1
a262 1
    SIZE_T len;
d300 1
a300 1
    SIZE_T get_len () const { return len; }
d306 4
a309 4
    bool match (caddr_t addr, SIZE_T len, caddr_t &m_addr, DWORD &m_len);
    off_t map_pages (off_t off, SIZE_T len);
    bool map_pages (caddr_t addr, SIZE_T len);
    bool unmap_pages (caddr_t addr, SIZE_T len);
d386 1
a386 1
mmap_record::match (caddr_t addr, SIZE_T len, caddr_t &m_addr, DWORD &m_len)
d413 2
a414 2
    system_printf ("Warning: VirtualProtect (addr: %p, len: %ly, "
		   "new_prot: %y, old_prot: %y), %E",
d417 1
a417 1
  SIZE_T len = PAGE_CNT (get_len ());
d423 1
a423 1
mmap_record::map_pages (off_t off, SIZE_T len)
d430 1
a430 1
  debug_printf ("map_pages (fd=%d, off=%Y, len=%lu)", get_fd (), off, len);
d450 1
a450 1
mmap_record::map_pages (caddr_t addr, SIZE_T len)
d452 1
a452 1
  debug_printf ("map_pages (addr=%p, len=%lu)", addr, len);
d478 1
a478 1
mmap_record::unmap_pages (caddr_t addr, SIZE_T len)
d588 1
a588 1
      SIZE_T plen = PAGE_CNT (len);
d796 1
a796 1
  syscall_printf ("addr %p, len %lu, prot %y, flags %y, fd %d, off %Y",
d1141 1
a1141 1
  syscall_printf ("munmap (addr %p, len %lu)", addr, len);
d1195 1
a1195 1
  syscall_printf ("0 = munmap(): %p", addr);
d1207 1
a1207 1
  syscall_printf ("msync (addr: %p, len %lu, flags %y)", addr, len, flags);
d1269 1
a1269 1
  syscall_printf ("mprotect (addr: %p, len %lu, prot %y)", addr, len, prot);
d1360 1
a1360 2
  SIZE_T size = roundup2 (((uintptr_t) addr - (uintptr_t) base) + len,
			  pagesize);
d1405 1
a1405 1
  syscall_printf ("%R = mlock(%p, %lu)", ret, addr, len);
d1417 1
a1417 2
  SIZE_T size = roundup2 (((uintptr_t) addr - (uintptr_t) base) + len,
			  pagesize);
d1425 1
a1425 1
  syscall_printf ("%R = munlock(%p, %lu)", ret, addr, len);
d1455 1
a1455 1
  syscall_printf ("%d = posix_madvise(%p, %lu, %d)", ret, addr, len, advice);
d1613 2
a1614 2
      system_printf ("requested %p != %p mem alloc base %p, state %y, "
		     "size %lu, %E", address, base, m.AllocationBase, m.State,
d1683 2
a1684 2
      system_printf ("requested %p != %p mem alloc base %p, state %y, "
		     "size %lu, %E", address, base, m.AllocationBase, m.State,
d1694 2
a1695 2
  if (off >= (off_t) mem_size
      || len >= mem_size
d1777 2
a1778 2
      system_printf ("requested %p != %p mem alloc base %p, state %y, "
		     "size %lu, %E", address, base, m.AllocationBase, m.State,
d1800 2
a1801 2
	  debug_printf ("fd %d, h %p, address %p, len %ly, prot: %y, "
			"flags: %y, offset %Y",
d1896 4
a1899 4
				 "parentstate: %y, "
				 "state: %y, "
				 "parentprot: %y, "
				 "prot: %y, %E",
@


1.177.2.5
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1666 6
a1671 22
  const int retry = 100;
  /* The wisdom of google tells us that FlushViewOfFile may fail with
     ERROR_LOCK_VIOLATION if "if the memory system is writing dirty
     pages to disk".  And, we've seen reports of this happening in the
     cygwin list.  So retry 99 times and hope we get lucky.  */
  for (int i = 0; i < retry; i++)
    if (FlushViewOfFile (addr, len))
      {
	/* FlushViewOfFile just triggers the action and returns immediately,
	   so it's equivalent to MS_ASYNC.  MS_SYNC requires another call to
	   FlushFileBuffers. */
	if (flags & MS_SYNC)
	  FlushFileBuffers (h);
	return 0;
      }
    else if (GetLastError () != ERROR_LOCK_VIOLATION)
      break;
    else if (i < (retry - 1))
      yield ();

  __seterrno ();
  return -1;
@


1.177.2.6
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.177.2.7
log
@	* miscfuncs.cc (RtlFillMemory): Declare.
	(RtlCopyMemory): Declare.
	(memset): Just call RtlFillMemory.
	(memcpy): Just call RtlCopyMemory.
	* mmap.cc (class mmap_record): Drop enforced packing.  Reorder members
	to allow tight packing on 32 as well as on 64 bit.
	* include/sys/dirent.h: Don't enforced structure packing on x86_64.
	(__DIRENT_COOKIE): Use different value on 64 bit.
@
text
@d256 1
a256 1
    /* 4 byte on 32 bit, 8 byte on 64 bit */
a257 6
    SIZE_T len;
    caddr_t base_address;
    /* Always 8 bytes */
    off_t offset;
    /* Always 4 bytes */
    int fd;
d261 3
d270 1
a271 4
       len (l),
       base_address (b),
       offset (o),
       fd (nfd),
d274 4
a277 1
       flags (f)
@


1.177.2.8
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::open): Cast second parameter
	in roundup2 to same size as first parameter to make sure mask size is
	correct.
	* fhandler_process.cc (format_process_maps): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* hookapi.cc (find_first_notloaded_dll): Add cast.
	* spawn.cc (av::fixup): Ditto.
	* wincap.h: Add comment to explain the folowing change.
	(wincapc::page_size): Return size_t.
	(wincapc::allocation_granularity): Ditto.

	* mmap.cc: Throughout, accommodate the fact that AT_ROUND_TO_PAGE isn't
	support on 64 bit at all.
	(class mmap_allocator): New class to allocate mmap slots on x86_64.
	(mmap_alloc): Define global instant of mmap_allocator.
	(mmap64): Call mmap_alloc.alloc on x86_64.
@
text
@a201 3
#ifdef __x86_64__ /* AT_ROUND_TO_PAGE isn't supported on 64 bit systems. */
  ULONG alloc_type = MEM_TOP_DOWN;
#else
a203 1
#endif
a795 69
#ifdef __x86_64__

/* The memory region used for memory maps */
#define MMAP_STORAGE_LOW	0x00500000000L
#define MMAP_STORAGE_HIGH	0x70000000000L

/* FIXME?  Unfortunately the OS doesn't support a top down allocation with
	   a ceiling value.  The ZeroBits mechanism only works for
	   NtMapViewOfSection and it only evaluates the high bit of ZeroBits
	   on 64 bit, so it's pretty much useless for our purposes.

	   If the below super simple mechanism to perform top-down allocations
	   turns out to be too slow, we need something else.  One idea is to
	   dived the space in (3835) 4 Gig chunks and simply store the
	   available free space per slot.  Then we can go top down from slot
	   to slot and only try slots which are supposed to have enough space.
	   Bookkeeping would be very simple and fast. */
class mmap_allocator
{
public:
  PVOID alloc (PVOID in_addr, SIZE_T in_size, bool fixed)
  {
    MEMORY_BASIC_INFORMATION mbi;

    SIZE_T size = roundup2 (in_size, wincap.allocation_granularity ());
    /* First check for the given address. */
    if (in_addr)
      {
	/* If it points to a free area, big enough to fulfill the request,
	   return the address. */
      	if (VirtualQuery (in_addr, &mbi, sizeof mbi)
	    && mbi.State == MEM_FREE
	    && mbi.RegionSize >= size)
	  return in_addr;
	/* Otherwise, if MAP_FIXED was given, give up. */
	if (fixed)
	  return NULL;
	/* Otherwise, fall through to the usual free space search mechanism. */
      }
    caddr_t addr = (caddr_t) MMAP_STORAGE_HIGH - size;
    do
      {
	/* Shouldn't fail, but better test. */
	if (!VirtualQuery ((PVOID) addr, &mbi, sizeof mbi))
	  return NULL;
	/* If the region is free... */
	if (mbi.State == MEM_FREE)
	  {
	    /* ...and the region is big enough to fulfill the request, return
	       the address. */
	    if (mbi.RegionSize >= size)
	      return (PVOID) addr;
	    /* Otherwise, subtract what's missing in size and try again. */
	    addr -= size - mbi.RegionSize;
	  }
	/* If the region isn't free, skip to address below AllocationBase
	   and try again. */
	else
	  addr = (caddr_t) mbi.AllocationBase - size;
      }
    /* Give up when we are lower than the lowest address we search. */
    while (addr >= (caddr_t) MMAP_STORAGE_LOW);
    return NULL;
  }
};

static mmap_allocator mmap_alloc;	/* Inherited by forked child. */
#endif

a864 3
#ifdef __x86_64__
      if (1)
#else
a865 1
#endif
d969 3
a971 4
	 Note that this isn't done in 64 bit environments since apparently
	 64 bit systems don't support the AT_ROUND_TO_PAGE flag, which is
	 required to get this right.  Too bad. */
#ifndef __x86_64__
a976 1
#endif
a1025 3
#ifdef __x86_64__
  addr = mmap_alloc.alloc (addr, orig_len ?: len, fixed (flags));
#else
a1055 1
#endif
@


1.177.2.9
log
@	* heap.cc (eval_start_address): Move heap to 0x6:00000000.  Change
	comment to explain why.
	* mmap.cc (MMAP_STORAGE_LOW): Accommodate above change.
@
text
@d803 1
a803 1
#define MMAP_STORAGE_LOW	0x00700000000L
@


1.177.2.10
log
@	* Revert to old malloc.
	* mmap.cc (MMAP_STORAGE_LOW): Set higher.  Add comment.
	(MMAP_STORAGE_HIGH): Add comment.
	(class mmap_allocator): Change comment.  Add mmap_current_low member.
	(mmap_allocator::mmap_allocator): Define default constructor.
	(mmap_allocator::alloc): Change to a round-robin mechanism.  Add or
	change comments accordingly.
@
text
@d803 2
a804 2
#define MMAP_STORAGE_LOW	0x00800000000L	/* Leave 8 Gigs for heap. */
#define MMAP_STORAGE_HIGH	0x70000000000L	/* Leave enough room for OS. */
d811 2
a812 2
	   If the below simple mechanism to perform top-down allocations
	   turns out to be too dumb, we need something else.  One idea is to
a818 2
  caddr_t mmap_current_low;

a819 2
  mmap_allocator () : mmap_current_low ((caddr_t) MMAP_STORAGE_HIGH) {}

d839 1
a839 3
    /* Start with the last allocation start address - requested size. */
    caddr_t addr = mmap_current_low - size;
    bool merry_go_round = false;
a841 7
	/* Did we hit the lower ceiling?  If so, restart from the upper
	   ceiling, but note that we did it. */
	if (addr < (caddr_t) MMAP_STORAGE_LOW)
	  {
	    addr = (caddr_t) MMAP_STORAGE_HIGH - size;
	    merry_go_round = true;
	  }
d848 2
a849 1
	    /* ...and the region is big enough to fulfill the request... */
d851 1
a851 6
	      {
		/* ...note the address as next start address for our simple
		   merry-go-round and return the address. */
		mmap_current_low = addr;
		return (PVOID) addr;
	      }
d860 2
a861 2
    /* Repeat until we had a full ride on the merry_go_round. */
    while (!merry_go_round || addr >= mmap_current_low);
@


1.177.2.11
log
@Pull in change from HEAD
@
text
@d682 1
a682 4
    {
      LIST_UNLOCK ();
      return false;
    }
@


1.176
log
@	Throughout use wincap.allocation_granularity instead of getpagesize.
	Throughout use wincap.page_size instead of getsystempagesize.
	Throughout use "status" as variable name to hold NTSTATUS values.
	* fhandler_mem.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	Fix debug_printf output.  Rectify long statements.  Fix comment
	formatting.
	* fhandler_proc.cc: Ditto.
	(format_proc_swaps): Drop useless test for ERROR_PROC_NOT_FOUND.
	* fhandler_process.cc: Ditto as in fhandler_mem.cc.
	(get_process_state): Rearrange allocation loop.  Use malloc/realloc.
	(get_mem_values): Fix potential NULL pointer usage.  Drop unused
	variable.
	* pinfo.cc (winpids::enum_processes): Handle low memory gracefully.
	* sec_auth.cc (get_priv_list): Drop local variable ret.
	* shared.cc (memory_init): Drop outdated call to getpagesize.
	* syscalls.cc (getsystempagesize): Remove.
	* sysconf.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	(sysinfo): Constify sizeof_stodi.  Drop useless test for
	ERROR_PROC_NOT_FOUND.
	* thread.cc (pthread_getattr_np): Cast pointers to uintptr_t rather
	than to int for pointer arithmetic.
	* winsup.h (getsystempagesize): Drop declaration.
@
text
@d529 2
a530 1
  fh->set_access (get_openflags ());
@


1.175
log
@	* mmap.cc (mlock): Replace LOCK_VM_IN_WSL with correct MAP_PROCESS.
	(munlock): Ditto.
	* ntdll.h: Rearrange to have all preprocessor definitions at the start
	of the file.  Add comments to each definition block.
	(MAP_PROCESS): Rename from LOCK_VM_IN_WSL.
	(MAP_SYSTEM): Rename from LOCK_VM_IN_RAM.
@
text
@d40 1
a40 1
#define PAGE_CNT(bytes) howmany((bytes),getsystempagesize())
d144 1
a144 1
  NTSTATUS ret;
d157 2
a158 2
      ret = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa,
			     &sectionsize, protect, attributes, NULL);
d167 3
a169 3
      ret = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa,
			     &sectionsize, PAGE_READWRITE, attributes, fhdl);
      if (NT_SUCCESS (ret) && protect != PAGE_READWRITE)
d172 2
a173 2
	  ret = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa,
				 &sectionsize, protect, attributes, fhdl);
d181 2
a182 2
      ret = NtCreateSection (&h, SECTION_ALL_ACCESS, &oa,
			     &sectionsize, protect, attributes, fhdl);
d184 1
a184 1
  if (!NT_SUCCESS (ret))
d187 1
a187 1
      SetLastError (RtlNtStatusToDosError (ret));
d196 1
a196 1
  NTSTATUS ret;
d211 4
a214 3
  ret = NtMapViewOfSection (h, NtCurrentProcess (), &base, 0, commitsize,
			    &offset, &viewsize, ViewShare, alloc_type, protect);
  if (!NT_SUCCESS (ret) && addr && !fixed (flags))
d217 2
a218 2
      ret = NtMapViewOfSection (h, NtCurrentProcess (), &base, 0, commitsize,
				&offset, &viewsize, ViewShare, 0, protect);
d220 1
a220 1
  if (!NT_SUCCESS (ret))
d223 1
a223 1
      SetLastError (RtlNtStatusToDosError (ret));
d227 1
a227 1
		base, ret, h, addr, len, off, protect, 0);
d393 1
a393 1
    high += (PAGE_CNT (get_len ()) * getsystempagesize ());
d436 2
a437 2
      && !VirtualProtect (get_address () + off * getsystempagesize (),
			  len * getsystempagesize (), gen_protect (),
d446 1
a446 1
  return off * getsystempagesize ();
d455 1
a455 1
  off /= getsystempagesize ();
d465 2
a466 2
      && !VirtualProtect (get_address () + off * getsystempagesize (),
			  len * getsystempagesize (), gen_protect (),
d489 1
a489 1
  off /= getsystempagesize ();
d506 1
a506 1
  DWORD off = (address - get_address ()) / getsystempagesize ();
d720 1
a720 1
  size_t pagesize = getpagesize ();
d807 1
a807 1
  DWORD pagesize = getpagesize ();
d970 1
a970 1
	      || roundup2 (len, getsystempagesize ())
d1073 1
a1073 1
      len = roundup2 (len, getsystempagesize ());
d1144 1
a1144 1
  size_t pagesize = getpagesize ();
d1208 1
a1208 1
  if (((uintptr_t) addr % getpagesize ())
d1216 1
a1216 1
  len = roundup2 (len, getpagesize ());
d1229 3
a1231 1
	      for (DWORD i = getpagesize (); i < len; i += getpagesize ())
d1267 1
a1267 1
  size_t pagesize = getpagesize ();
d1353 1
a1353 1
  size_t pagesize = getpagesize ();
d1410 1
a1410 1
  size_t pagesize = getpagesize ();
d1714 2
a1715 2
  NTSTATUS ret = NtOpenSection (&h, section_access, &attr);
  if (!NT_SUCCESS (ret))
d1717 1
a1717 1
      __seterrno_from_nt_status (ret);
d1745 2
a1746 2
  NTSTATUS ret;
  if (!NT_SUCCESS (ret = NtUnmapViewOfSection (NtCurrentProcess (), addr)))
d1748 1
a1748 1
      __seterrno_from_nt_status (ret);
@


1.174
log
@* mmap.cc (mlock): Add standard syscall return value debugging output.
(munlock): Ditto.
(posix_madvise): Ditto.
* signal.cc: Remove obsolete sigcatchers stuff throughout.
(sigaction_worker): Add function name parameter and use it to show standard
syscall return value debugging output.  Also add fault protection.
(sigaction): Accommodate extra argument to sigaction_worker.
(siginterrupt): Ditto.
* syscalls.cc (read): Remove obsolete sigcatchers stuff.
(readv): Ditto.
@
text
@d1357 1
a1357 1
				    LOCK_VM_IN_WSL);
d1411 1
a1411 1
					   LOCK_VM_IN_WSL);
@


1.173
log
@	* mmap.cc (mlock): Drop requesting SE_LOCK_MEMORY_PRIVILEGE.  Drop
	outdated comment.  Call NtLockVirtualMemory with LOCK_VM_IN_WSL flag.
	(munlock): Drop requesting SE_LOCK_MEMORY_PRIVILEGE.  Call
	NtUnlockVirtualMemory with LOCK_VM_IN_WSL flag.
@
text
@d1397 1
d1417 1
d1424 1
d1428 17
a1444 11
    return EINVAL;

  /* Check requested memory area. */
  MEMORY_BASIC_INFORMATION m;
  char *p = (char *) addr;
  char *endp = p + len;
  while (p < endp)
    {
      if (!VirtualQuery (p, &m, sizeof m) || m.State == MEM_FREE)
	return ENOMEM;
      p = (char *) m.BaseAddress + m.RegionSize;
d1447 1
@


1.172
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@a1348 8
  /* Instead of using VirtualLock, which does not guarantee that the pages
     aren't swapped out when the process is inactive, we're using
     ZwLockVirtualMemory with the LOCK_VM_IN_RAM flag to do what mlock on
     POSIX systems does.  On NT, this requires SeLockMemoryPrivilege,
     which is given only to SYSTEM by default. */

  push_thread_privilege (SE_LOCK_MEMORY_PRIVILEGE, true);

d1357 1
a1357 1
				    LOCK_VM_IN_RAM);
a1396 2
  pop_thread_privilege ();

a1404 2
  push_thread_privilege (SE_LOCK_MEMORY_PRIVILEGE, true);

d1410 1
a1410 1
					   LOCK_VM_IN_RAM);
a1415 2
  pop_thread_privilege ();

@


1.171
log
@whitespace elimination
@
text
@d1247 1
a1247 1
  syscall_printf ("%d = msync()", ret);
d1340 1
a1340 1
  syscall_printf ("%d = mprotect ()", ret ? 0 : -1);
@


1.170
log
@	* miscfuncs.cc (thread_wrapper): Remove unused _cygtls record.
	* mmap.cc (is_mmapped_region): Avoid crash if no mmaps exist.
@
text
@d225 1
a225 1
  		" off:%X, protect:%x, type:%x)",
@


1.169
log
@	* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Check if the
	requested stack is application-provided within the user heap or an
	mmapped region.  If so, just use it.  Add comment to explain why.
	* miscfuncs.cc (thread_wrapper): If an application-provided stack
	has been given, implement cygtls area at the stackbase.  Fix comment.
	* mmap.cc (is_mmapped_region): New function.
	* winsup.h (is_mmapped_region): Declare.
@
text
@a666 2
  bool ret = false;

d672 3
d678 1
@


1.168
log
@	* fcntl.cc (fcntl64): Call pthread_testcancel.
	* fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* flock.cc (lf_setlock): Allow to cancel thread running blocking
	file lock.  Try to make code more readable.
	(lockf): Call pthread_testcancel.
	* mmap.cc (msync): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Call pthread::static_cancel_self
	rather than pthread_testcancel.
	* select.cc (cygwin_select): Call pthread_testcancel.
	* syscalls.cc (pread): Ditto.
	(pwrite): Ditto.
	(readv): Ditto.
	(writev): Ditto.
	(open): Ditto.
	(close): Ditto.
	(fsync): Ditto.
	* termios.cc (tcdrain): Ditto.
	* thread.cc: Align list of cancellation points with above changes.
	Mark not-implemented functions, too.
	(cancelable_wait): Don't set unused object indices to WAIT_FAILED
	since that could result in wrong behaviour.  Set them to the invalid
	value WAIT_TIMEOUT + 1 instead.
@
text
@d662 28
d708 1
@


1.167
log
@	* mmap.cc (mmap64): Add a cheat to let a certain autoconf test succeed
	on 64 bit systems.  Explain why.
@
text
@d1172 2
@


1.166
log
@	* mmap.cc (mmap_record::alloc_fh): Initialize nmae strings in fdev to
	empty strings or suffer a SEGV.  Drop second parameter in call to
	build_fh_dev.
@
text
@d804 44
@


1.165
log
@	* mmap.cc (class mmap_record): Pack 4 byte-aligned.  Convert member dev
	to plain int.
	(mmap_record::alloc_fh): Create temporary device from dev and use in
	call to build_fh_dev.
@
text
@d525 1
d527 1
a527 1
  fhandler_base *fh = build_fh_dev (fdev, "");
@


1.164
log
@	* mmap.cc (mmap_record::page_map): Define as variable array rather than
	as pointer.
	(mmap_record::alloc_page_map): Remove.
	(mmap_record::free_page_map): Remove.
	(mmap_record::init_page_map): New method.
	(mmap_record::add_record): Take mmap_record parameter by reference
	rather than by value.
	(mmap_record::map_pages): Fix comment.
	(mmap_list::add_record): Allocate space for mmap_record including the
	page_map in a single ccalloc call.  Call init_page_map afterwards.
	(mmap_list::del_record): Remove call to mmap_record::free_page_map.
@
text
@d248 1
d263 1
a263 1
    device dev;
d278 1
a278 1
	dev.devn = 0;
d282 1
a282 1
	  dev.parse (FH_ZERO);
d287 1
a287 1
    device& get_device () { return dev; }
d320 1
d524 3
a526 1
  fhandler_base *fh = build_fh_dev (get_device ());
@


1.163
log
@	* fhandler.h (class fhandler_base): Change inheritance of fstat_helper
	and fstat_by_...  methods to private.
	(fhandler_base::fstat_helper): Drop all redundant arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call
	to fstat_by_nfs_ea here.  Drop fetching basic file information.
	Drop setting file attributes.  Accommodate change in fstat_helper call.
	(fhandler_base::fstat_by_name): Simplify.  Only fetch directory
	information to get the inode number.  Drop setting file attributes.
	Accommodate change in fstat_helper call.
	(fhandler_base::fstat_fs): Call fstat_by_nfs_ea if on NFS.
	(fhandler_base::fstat_helper): Drop all redundant arguments.  Use
	information already collected in the fhandler.  Move heading comment
	into code and drop dwFileAttributes comment.
	* mmap.cc (mmap64): Call fstat_fs rather than fstat_by_handle.
	* mount.cc (fs_info::update): Note that has_buggy_basic_info is unused.
	* path.cc (symlink_info::check_reparse_point): Add comment.
	(symlink_info::check): Fetch FileNetworkOpenInformation rather than
	FileBasicInformation throughout, except on NFS.  Explain why.  Store
	FILE_NETWORK_OPEN_INFORMATION in conv_hdl.  Remove
	FILE_ATTRIBUTE_DIRECTORY attribute in conv_hdl for reparse point
	symlinks.
	* path.h (class path_conv_handle): Add FILE_NETWORK_OPEN_INFORMATION
	member _fnoi.
	(path_conv_handle::fnoi): New accessor method for _fnoi.
	(path_conv::fnoi): New accessor method for cubv_hdl._fnoi.

	* fhandler_tty.cc (fhandler_tty_slave::init): Use tty::setpgid method.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
a261 1
    DWORD *page_map;
d263 1
d275 1
a275 2
       base_address (b),
       page_map (NULL)
d301 1
a301 2
    bool alloc_page_map ();
    void free_page_map () { if (page_map) cfree (page_map); }
d336 1
a336 1
    mmap_record *add_record (mmap_record r);
d401 2
a402 2
bool
mmap_record::alloc_page_map ()
d404 1
a404 6
  /* Allocate one bit per page */
  if (!(page_map = (DWORD *) ccalloc (HEAP_MMAP,
				      MAPSIZE (PAGE_CNT (get_len ())),
				      sizeof (DWORD))))
    return false;

a416 1
  return true;
d425 1
a425 1
     Otherwise it's job is now done by alloc_page_map(). */
d535 1
a535 1
mmap_list::add_record (mmap_record r)
d537 3
a539 1
  mmap_record *rec = (mmap_record *) cmalloc (HEAP_MMAP, sizeof (mmap_record));
d542 2
a543 6
  *rec = r;
  if (!rec->alloc_page_map ())
    {
      cfree (rec);
      return NULL;
    }
a564 1
  rec->free_page_map ();
@


1.163.2.1
log
@	* mmap.cc (mmap_record::page_map): Define as variable array rather than
	as pointer.
	(mmap_record::alloc_page_map): Remove.
	(mmap_record::free_page_map): Remove.
	(mmap_record::init_page_map): New method.
	(mmap_record::add_record): Take mmap_record parameter by reference
	rather than by value.
	(mmap_record::map_pages): Fix comment.
	(mmap_list::add_record): Allocate space for mmap_record including the
	page_map in a single ccalloc call.  Call init_page_map afterwards.
	(mmap_list::del_record): Remove call to mmap_record::free_page_map.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d262 1
a263 1
    DWORD page_map[0];
d275 2
a276 1
       base_address (b)
d302 2
a303 1
    void init_page_map (mmap_record &r);
d338 1
a338 1
    mmap_record *add_record (mmap_record &r);
d403 2
a404 2
void
mmap_record::init_page_map (mmap_record &r)
d406 6
a411 1
  *this = r;
d424 1
d433 1
a433 1
     Otherwise it's job is now done by init_page_map(). */
d543 1
a543 1
mmap_list::add_record (mmap_record &r)
d545 1
a545 3
  mmap_record *rec = (mmap_record *) ccalloc (HEAP_MMAP,
		      sizeof (mmap_record)
		      + MAPSIZE (PAGE_CNT (r.get_len ())) * sizeof (DWORD), 1);
d548 6
a553 2
  rec->init_page_map (r);

d575 1
@


1.163.2.2
log
@2011-03-18  Christopher Faylor  <me.cygwin2011@@cgf.cx>

	* fhandler.h (DEFAULT_PIPEBUFSIZE): Reset to 64K.

2011-03-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap_record::alloc_fh): Initialize name strings in fdev to
	empty strings or suffer a SEGV.  Drop second parameter in call to
	build_fh_dev.

2011-03-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (class mmap_record): Pack 4 byte-aligned.  Convert member dev
	to plain int.
	(mmap_record::alloc_fh): Create temporary device from dev and use in
	call to build_fh_dev.
@
text
@a247 1
#pragma pack(push, 4)
d262 1
a262 1
    int dev;
d277 1
a277 1
	dev = 0;
d281 1
a281 1
	  dev = FH_ZERO;
d286 1
a286 1
    int get_device () { return dev; }
a318 1
#pragma pack(pop)
d522 1
a522 4
  device fdev;
  fdev.name = fdev.native = "";
  fdev.parse (get_device ());
  fhandler_base *fh = build_fh_dev (fdev);
@


1.163.2.3
log
@Pull in HEAD changes
@
text
@a803 44

      /* The autoconf mmap test maps a file of size 1 byte.  It then tests
	 every byte of the entire mapped page of 64K for 0-bytes since that's
	 what POSIX requires.  The problem is, we can't create that mapping on
	 64 bit systems.  The file mapping will be only a single page, 4K, and
	 since 64 bit systems don't support the AT_ROUND_TO_PAGE flag, the
	 remainder of the 64K slot will result in a SEGV when accessed.

	 So, what we do here is cheating for the sake of the autoconf test
	 on 64 bit systems.  The justification is that there's very likely
	 no application actually utilizing the map beyond EOF, and we know that
	 all bytes beyond EOF are set to 0 anyway.  If this test doesn't work
	 on 64 bit systems, it will result in not using mmap at all in a
	 package.  But we want that mmap is treated as usable by autoconf,
	 regardless whether the autoconf test runs on a 32 bit or a 64 bit
	 system.

	 Ok, so we know exactly what autoconf is doing.  The file is called
	 "conftest.txt", it has a size of 1 byte, the mapping size is the
	 pagesize, the requested protection is PROT_READ | PROT_WRITE, the
	 mapping is MAP_SHARED, the offset is 0.

	 If all these requirements are given, we just return an anonymous map.
	 This will help to get over the autoconf test even on 64 bit systems.
	 The tests are ordered for speed. */
      if (wincap.is_wow64 ())
	{
	  UNICODE_STRING fname;
	  IO_STATUS_BLOCK io;
	  FILE_STANDARD_INFORMATION fsi;

	  if (len == pagesize
	      && prot == (PROT_READ | PROT_WRITE)
	      && flags == MAP_SHARED
	      && off == 0
	      && (RtlSplitUnicodePath (fh->pc.get_nt_native_path (), NULL,
				       &fname),
		  wcscmp (fname.Buffer, L"conftest.txt") == 0)
	      && NT_SUCCESS (NtQueryInformationFile (fh->get_handle (), &io,
						     &fsi, sizeof fsi,
						     FileStandardInformation))
	      && fsi.EndOfFile.QuadPart == 1LL)
	    flags |= MAP_ANONYMOUS;
	}
@


1.162
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
d868 1
a868 1
      if (fh->fstat_by_handle (&st))
@


1.161
log
@	* mmap.cc (mmap64): Allocate fh_disk_file on cygheap.  Delete
	explicitely before returning.
@
text
@d211 1
a211 1
  ret = NtMapViewOfSection (h, GetCurrentProcess (), &base, 0, commitsize,
d216 1
a216 1
      ret = NtMapViewOfSection (h, GetCurrentProcess (), &base, 0, commitsize,
d1293 2
a1294 1
      status = NtLockVirtualMemory (hMainProc, &base, &size, LOCK_VM_IN_RAM);
d1308 1
a1308 1
	  if (!GetProcessWorkingSetSize (hMainProc, &min, &max))
d1321 1
a1321 1
	  if (!SetProcessWorkingSetSize (hMainProc, min, max))
d1350 1
a1350 1
  NTSTATUS status = NtUnlockVirtualMemory (hMainProc, &base, &size,
d1486 1
a1486 1
	      NtUnmapViewOfSection (GetCurrentProcess (), base);
d1505 1
a1505 1
      NtUnmapViewOfSection (GetCurrentProcess (), addr);
d1566 1
a1566 1
	  NtUnmapViewOfSection (GetCurrentProcess (), base);
d1581 1
a1581 1
  NtUnmapViewOfSection (GetCurrentProcess (), addr);
d1660 1
a1660 1
	  NtUnmapViewOfSection (GetCurrentProcess (), base);
d1676 1
a1676 1
  if (!NT_SUCCESS (ret = NtUnmapViewOfSection (GetCurrentProcess (), addr)))
@


1.160
log
@	* dtable.cc (build_fh_dev): Take additional bool parameter indicating
	whether set_name should be called or not.
	(dtable::dup_worker): Call build_fh_pc with new second parameter set
	to false.  Explain why.  If fhandler's dup failed, delete rather than
	cfree newfh and set newfh to NULL to indicate failure correctly.
	* dtable.h (build_fh_pc): Change declaration according to above change.
	Default set_name parameter to true.
	* mmap.cc (mmap_record::free_fh): Delete rather than cfree fh.
@
text
@d852 2
a853 1
	  fh_disk_file = new (alloca (sizeof *fh_disk_file)) fhandler_disk_file;
d1046 4
a1049 1
    NtClose (fh_disk_file->get_handle ());
@


1.159
log
@	Throughout avoid having to initialize constant UNICODE_STRINGs.
	* globals.cc: Define constant UNICODE_STRINGs and store in .rdata
	section.
	* fhandler_disk_file.cc: Throughout, use readonly UNICODE_STRINGs
	rather then initializing local UNICODE_STRING variable where
	applicable.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* flock.cc (inode_t::inode_t): Ditto.
	* mmap.cc: Ditto.
	* syscalls.cc: Ditto.
	* mount.cc (fs_info::update): Ditto.
	* path.cc: Ditto.

	* ntdll.h (RtlEqualUnicodePathPrefix): Redefine to take prefix as
	UNICODE_STRING.
	(RtlEqualUnicodePathSuffix): Redefine to take suffix as UNICODE_STRING.
	* fhandler_disk_file.cc: Accommodate throughout.
	* mount.cc (fs_info::update): Ditto.
	* path.cc (cwdstuff::set): Ditto.
	* syscalls.cc: Ditto.
@
text
@d539 1
a539 1
    cfree (fh);
@


1.158
log
@	* mmap.cc: Use NtUnmapViewOfSection instead of UnmapViewOfFile
	throughout for symmetry.
	(fhandler_dev_mem::munmap): Use correct process handle in call to
	NtUnmapViewOfSection.
@
text
@a837 1
      UNICODE_STRING fname;
d843 1
a843 2
      RtlInitUnicodeString (&fname, L"");
      InitializeObjectAttributes (&attr, &fname, fh->pc.objcaseinsensitive (),
a1622 3
  UNICODE_STRING memstr;
  RtlInitUnicodeString (&memstr, L"\\device\\physicalmemory");

d1624 1
a1624 1
  InitializeObjectAttributes (&attr, &memstr,
@


1.157
log
@	* mmap.cc (mmap64): Fix condition checking if anonymous mapping beyond
	EOF is required.
@
text
@d1483 1
a1483 1
	      UnmapViewOfFile (base);
d1502 1
a1502 1
      UnmapViewOfFile (addr);
d1563 1
a1563 1
	  UnmapViewOfFile (base);
d1578 1
a1578 1
  UnmapViewOfFile (addr);
d1676 1
a1676 1
  if (!NT_SUCCESS (ret = NtUnmapViewOfSection (INVALID_HANDLE_VALUE, addr)))
@


1.156
log
@	* mmap.cc (MapView): Add NT status to debug output.
@
text
@d900 3
a902 1
	  && ((len > fsiz && !autogrow (flags)) || len < pagesize))
@


1.155
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d224 3
a226 2
  debug_printf ("%x = NtMapViewOfSection (h:%x, addr:%x, len:%u, off:%D, "
		"protect:%x, type:%x)", base, h, addr, len, off, protect, 0);
@


1.154
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d1133 1
a1133 1
      || (flags & (MS_ASYNC | MS_SYNC) == (MS_ASYNC | MS_SYNC)))
@


1.153
log
@	* Makefile.in (DLL_OFILES): Add kernel32.o.
	* autoload.cc (WSACloseEvent): Remove.
	(WSACreateEvent): Remove.
	* cygheap.cc (cygheap_init): Drop initializing shared_prefix.
	* cygheap.h (struct init_cygheap): Drop shared_prefix and
	shared_prefix_buf members.
	* fhandler_socket.cc (sock_shared_name): New static function.
	(search_wsa_event_slot): Convert name buffers to WCHAR.  Call
	NtCreateMutant/NtOpenMutant to create mutexes in session local
	namespace.
	(fhandler_socket::init_events): Ditto.  Fix debug output.
	(fhandler_socket::release_events): Close mutexes using NtClose.
	(fhandler_socket::dup): Ditto.
	* kernel32.cc: New file, implementing Win32 calls in a Cygwin-specific
	way.
	* mmap.cc (MapView): Make static.
	* ntdll.h: Fix status code sorting.
	(STATUS_OBJECT_NAME_EXISTS): Define.
	(SEMAPHORE_QUERY_STATE): Define.
	(CYG_SHARED_DIR_ACCESS): Define.
	(CYG_MUTANT_ACCESS): Define.
	(CYG_EVENT_ACCESS): Define.
	(CYG_SEMAPHORE_ACCESS): Define.
	(enum _PROCESSINFOCLASS): Define ProcessSessionInformation.
	(struct _PROCESS_SESSION_INFORMATION): Define.
	(NtCreateSemaphore): Declare.
	(NtOpenSemaphore): Declare.
	* flock.cc: Use CYG_xxx_ACCESS access masks where appropriate.
	* posix_ipc.cc (ipc_mutex_init): Use native functions to create mutex.
	Create in cygwin-shared subdir.
	(ipc_cond_init): Ditto for event.
	(ipc_mutex_close): Use NtClose.
	(ipc_cond_close): Ditto.
	(mq_open): Drop "cyg" prefix from mqh_uname.
	* shared.cc (CYG_SHARED_DIR_ACCESS): Drop definition here.
	(_cygwin_testing): Declare extern on file level.
	(get_shared_parent_dir): Change name of shared directory.  Add name
	to api_fatal output.
	(get_session_parent_dir): New function.
	(shared_name): Simplify.
	(shared_info::initialize): Call get_session_parent_dir.
	* shared_info.h (get_session_parent_dir): Declare.
	* smallprint.cc (__small_vswprintf): Fix bug in multibyte string
	conversion.
	* thread.cc (semaphore::semaphore): Align semaphore name to object
	names in posix IPC functions.
	* include/cygwin/version.h (CYGWIN_VERSION_SHARED_DATA): Bump.
@
text
@d844 1
a844 1
      InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE,
@


1.152
log
@Remove unneeded header files from source files throughout.
@
text
@d192 1
a192 1
void *
@


1.151
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a15 1
#include <stddef.h>
a23 2
#include "pinfo.h"
#include "sys/cygwin.h"
@


1.150
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d13 1
@


1.149
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.
@
text
@d1091 1
a1091 1
        {
d1210 1
a1210 1
        {
d1652 1
a1652 1
  			flags | MAP_ANONYMOUS, off);
@


1.148
log
@	* mmap.cc: Convert usage of dynamically growing cmalloced arrays to
	cmalloced linked lists throughout.
	(class mmap_record): Add LIST_ENTRY element.
	(mmap_record::match): New method, taking over match algorithm from
	list::search_record.
	(class mmap_list): Rename from class list.  Add LIST_ENTRY.  Convert
	recs to a LIST_HEAD.  Drop nrecs and maxrecs members.
	(mmap_list::get_record): Drop entirely.
	(mmap_list::free_recs): Drop entirely.
	(mmap_list::del_record): Take mmap_record to delete as parameter.
	(mmap_list::search_record): Convert to mmap_record::match.
	(class mmap_areas): Rename from class map.  Convert lists to LIST_HEAD.
	(mmap_areas::get_list): Drop entirely.
	(mmap_areas::del_list): Take mmap_list to delete as parameter.
	(mprotect): Fix indentation.
@
text
@d54 5
a340 1
    mmap_record *search_record (_off64_t off, DWORD len);
a558 25
/* Used in mmap() */
mmap_record *
mmap_list::search_record (_off64_t off, DWORD len)
{
  mmap_record *rec;

  if (anonymous () && !off)
    {
      len = PAGE_CNT (len);
      LIST_FOREACH (rec, &recs, mr_next)
	if (rec->find_unused_pages (len) != (DWORD)-1)
	  return rec;
    }
  else
    {
      LIST_FOREACH (rec, &recs, mr_next)
	if (off >= rec->get_offset ()
	    && off + len
	       <= rec->get_offset ()
		  + (PAGE_CNT (rec->get_len ()) * getsystempagesize ()))
	  return rec;
    }
  return NULL;
}

d593 5
a597 2
      if ((rec = search_record (off, len)) != NULL
	  && rec->compatible_flags (flags))
d599 1
a599 1
	  if ((off = rec->map_pages (off, len)) == (_off64_t)-1)
d690 3
d701 1
a701 1
    return MMAP_NONE;
d712 4
a715 1
	return MMAP_RAISE_SIGBUS;
d717 1
a717 1
	return MMAP_NONE;
d725 4
a728 1
	return MMAP_RAISE_SIGBUS;
d733 4
a736 1
	return MMAP_NORESERVE_COMMITED;
d738 3
a740 1
  return MMAP_NONE;
a786 2
  SetResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");

d936 1
d944 1
a944 1
	 a valid address, of MAP_FAILED in case of a fatal error. */
d948 1
a948 1
	  goto out;
d972 1
a972 1
	      goto out;
d978 1
a978 1
	  goto out;
d986 1
a986 1
    goto out;
d1022 1
a1022 1
		  goto out;
d1040 3
a1044 2
  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");

d1079 1
a1079 1
  SetResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d1116 1
a1116 1
  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d1131 1
a1131 1
  SetResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d1172 1
a1173 1
  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d1198 1
a1198 1
  SetResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "mprotect");
d1234 1
a1234 1
  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "mprotect");
@


1.147
log
@	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.  Call fstat_by_handle instead of
	fstat to avoid overhead.
@
text
@d27 1
d235 5
a239 4
   Contains a dynamic class list array.  Each list entry represents all
   mapping to a file, keyed by file descriptor and file name hash.
   Each list entry contains a dynamic class mmap_record array.  Each
   mmap_record represents exactly one mapping.  For each mapping, there's
d246 3
d302 1
d318 1
a318 1
class list
d320 4
a324 2
    mmap_record *recs;
    int nrecs, maxrecs;
a330 1
    mmap_record *get_record (int i) { return i >= nrecs ? NULL : recs + i; }
d335 1
a335 2
    bool del_record (int i);
    void free_recs () { if (recs) cfree (recs); }
a336 2
    long search_record (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
		long start);
d340 1
a340 1
class map
d342 2
a343 3
  private:
    list *lists;
    unsigned nlists, maxlists;
d345 3
a347 5
  public:
    list *get_list (unsigned i) { return i >= nlists ? NULL : lists + i; }
    list *get_list_by_fd (int fd, struct __stat64 *st);
    list *add_list (int fd, struct __stat64 *st);
    void del_list (unsigned i);
d351 1
a351 1
static map mmapped_areas;
d382 19
d540 1
a540 1
list::add_record (mmap_record r)
d542 5
a546 1
  if (nrecs == maxrecs)
d548 2
a549 11
      mmap_record *new_recs;
      if (maxrecs == 0)
	new_recs = (mmap_record *)
			cmalloc (HEAP_MMAP, 5 * sizeof (mmap_record));
      else
	new_recs = (mmap_record *)
			crealloc (recs, (maxrecs + 5) * sizeof (mmap_record));
      if (!new_recs)
	return NULL;
      maxrecs += 5;
      recs = new_recs;
d551 2
a552 4
  recs[nrecs] = r;
  if (!recs[nrecs].alloc_page_map ())
    return NULL;
  return recs + nrecs++;
d557 1
a557 1
list::search_record (_off64_t off, DWORD len)
d559 2
d564 3
a566 3
      for (int i = 0; i < nrecs; ++i)
	if (recs[i].find_unused_pages (len) != (DWORD)-1)
	  return recs + i;
d570 2
a571 2
      for (int i = 0; i < nrecs; ++i)
	if (off >= recs[i].get_offset ()
d573 3
a575 3
	       <= recs[i].get_offset ()
		  + (PAGE_CNT (recs[i].get_len ()) * getsystempagesize ()))
	  return recs + i;
a579 26
/* Used in munmap() */
long
list::search_record (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
		     long start)
{
  caddr_t low, high;

  for (long i = start + 1; i < nrecs; ++i)
    {
      low = (addr >= recs[i].get_address ()) ? addr : recs[i].get_address ();
      high = recs[i].get_address ();
      if (recs[i].filler ())
	high += recs[i].get_len ();
      else
	high += (PAGE_CNT (recs[i].get_len ()) * getsystempagesize ());
      high = (addr + len < high) ? addr + len : high;
      if (low < high)
	{
	  m_addr = low;
	  m_len = high - low;
	  return i;
	}
    }
  return -1;
}

d581 1
a581 1
list::set (int nfd, struct __stat64 *st)
d591 1
a591 2
  nrecs = maxrecs = 0;
  recs = NULL;
d595 1
a595 1
list::del_record (int i)
d597 3
a599 7
  if (i < nrecs)
    {
      recs[i].free_page_map ();
      for (; i < nrecs - 1; i++)
	recs[i] = recs[i + 1];
      nrecs--;
    }
d601 2
a602 2
     this list from the list array. */
  return !nrecs;
d606 1
a606 1
list::try_map (void *addr, size_t len, int flags, _off64_t off)
d629 5
a633 3
      long record_idx = -1;
      if ((record_idx = search_record ((caddr_t) addr, len, u_addr, u_len,
				       record_idx)) >= 0)
a634 1
	  rec = get_record (record_idx);
d652 2
a653 2
list *
map::get_list_by_fd (int fd, struct __stat64 *st)
d655 2
a656 2
  unsigned i;
  for (i = 0; i < nlists; i++)
d658 2
a659 2
      if (fd == -1 && lists[i].anonymous ())
	return lists + i;
d663 2
a664 2
      if (fd != -1 && st && lists[i].get_hash () == st->st_ino)
	return lists + i;
d669 2
a670 2
list *
map::add_list (int fd, struct __stat64 *st)
d672 6
a677 14
  if (nlists == maxlists)
    {
      list *new_lists;
      if (maxlists == 0)
	new_lists = (list *) cmalloc (HEAP_MMAP, 5 * sizeof (list));
      else
	new_lists = (list *) crealloc (lists, (maxlists + 5) * sizeof (list));
      if (!new_lists)
	return NULL;
      maxlists += 5;
      lists = new_lists;
    }
  lists[nlists].set (fd, st);
  return lists + nlists++;
d681 1
a681 1
map::del_list (unsigned i)
d683 2
a684 7
  if (i < nlists)
    {
      lists[i].free_recs ();
      for (; i < nlists - 1; i++)
	lists[i] = lists[i + 1];
      nlists--;
    }
d708 1
a708 1
  list *map_list = mmapped_areas.get_list_by_fd (-1, NULL);
d718 5
a722 1
  while (len > 0)
d724 2
a725 8
      caddr_t u_addr;
      DWORD u_len;
      long record_idx = map_list->search_record (start_addr, len,
						 u_addr, u_len, -1);
      if (record_idx < 0)
	return MMAP_NONE;

      mmap_record *rec = map_list->get_record (record_idx);
d741 2
d744 1
a744 2

    return MMAP_NORESERVE_COMMITED;
d748 1
a748 1
mmap_worker (list *map_list, fhandler_base *fh, caddr_t base, size_t len,
d781 1
a781 1
  list *map_list = NULL;
d1087 2
a1088 4
  list *map_list;
  for (unsigned list_idx = 0;
       (map_list = mmapped_areas.get_list (list_idx));
       ++list_idx)
d1090 1
a1090 1
      long record_idx = -1;
d1094 4
a1097 4
      while ((record_idx = map_list->search_record((caddr_t)addr, len, u_addr,
						   u_len, record_idx)) >= 0)
	{
	  mmap_record *rec = map_list->get_record (record_idx);
d1109 1
a1109 1
	      if (map_list->del_record (record_idx--))
d1113 1
a1113 1
		  mmapped_areas.del_list (list_idx--);
d1131 1
a1131 1
  list *map_list;
d1150 1
a1150 3
  for (unsigned list_idx = 0;
       (map_list = mmapped_areas.get_list (list_idx));
       ++list_idx)
d1153 1
a1153 3
      for (int record_idx = 0;
	   (rec = map_list->get_record (record_idx));
	   ++record_idx)
d1155 1
a1155 1
	  if (rec->access ((caddr_t)addr))
d1159 1
a1159 1
		if (!rec->access ((caddr_t)addr + i))
d1165 1
a1165 1
	      ret = fh->msync (rec->get_handle (), (caddr_t)addr, len, flags);
d1206 31
a1236 34
  list *map_list;
  for (unsigned list_idx = 0;
      (map_list = mmapped_areas.get_list (list_idx));
      ++list_idx)
   {
     long record_idx = -1;
     caddr_t u_addr;
     DWORD u_len;

     while ((record_idx = map_list->search_record((caddr_t)addr, len,
						  u_addr, u_len,
						  record_idx)) >= 0)
       {
	 mmap_record *rec = map_list->get_record (record_idx);
	 in_mapped = true;
	 if (rec->attached ())
	   continue;
	 new_prot = gen_protect (prot, rec->get_flags ());
	 if (rec->noreserve ())
	   {
	     if (new_prot == PAGE_NOACCESS)
	       ret = VirtualFree (u_addr, u_len, MEM_DECOMMIT);
	     else
	       ret = !!VirtualAlloc (u_addr, u_len, MEM_COMMIT, new_prot);
	   }
	 else
	   ret = VirtualProtect (u_addr, u_len, new_prot, &old_prot);
	 if (!ret)
	   {
	     __seterrno ();
	     break;
	   }
       }
   }
d1722 2
a1723 4
  list *map_list;
  for (unsigned list_idx = 0;
       (map_list = mmapped_areas.get_list (list_idx));
       ++list_idx)
d1726 1
a1726 3
      for (int record_idx = 0;
	   (rec = map_list->get_record (record_idx));
	   ++record_idx)
@


1.146
log
@	* mmap.cc: Call NtClose instead of CloseHandle throughout.
	(CreateMapping): Drop unused last argument.  Accommodate throughout.
	(mmap64): Re-open file with execute permissions using NtOpenFile.
@
text
@a51 2
/* Used for reopening a disk file when necessary. */
static fhandler_disk_file fh_disk_file;
d808 2
a818 1
  fh_disk_file.set_io_handle (NULL);
d890 5
a894 3
	  fh_disk_file.set_io_handle (h);
	  fh_disk_file.set_access (fh->get_access () | GENERIC_EXECUTE);
	  fh = &fh_disk_file;
d905 1
a905 1
      if (fh->fstat (&st))
d1078 2
a1079 2
  if (fh_disk_file.get_handle ())
    NtClose (fh_disk_file.get_handle ());
@


1.145
log
@	* cygheap.h (init_cygheap::luid): Remove.
	* mmap.cc (mlock): Accommodate parameter change in call to
	push_thread_privilege.
	(munlock): Ditto.
	* ntdll.h (STATUS_NOT_ALL_ASSIGNED): Define.
	(NtAdjustPrivilegesToken): Declare.
	* sec_helper.cc (cygpriv): Reorder to match numerical privilege order.
	(privilege_luid): Take job of privilege_luid_by_name, using new
	cygpriv.
	(privilege_luid_by_name): Remove.
	(privilege_name): Accommodate new cygpriv array.
	(set_privilege): Call NtAdjustPrivilegesToken to avoid using advapi32.
	Accommodate changes to privilege_name.
	(set_cygwin_privileges): Simplify.  Don't try to set
	SE_CREATE_GLOBAL_PRIVILEGE on systems not supporting it.
	* security.cc (sys_privs): Reorder to match numerical privilege order.
	Use real privilege values as defined in security.h.
	(get_system_priv_list): Drop unused grp_list argument.  Create
	list of privileges according to new wincapc::max_sys_priv value.
	(get_priv_list): Call privilege_luid instead of privilege_luid_by_name.
	Make priv a local value instead of a pointer.
	(create_token): Accommodate parameter change in call to
	push_self_privilege.
	(lsaauth): Ditto.
	(check_access): Use privilege values directly instead of calling
	privilege_luid.
	* security.h: Define real privilege values.
	(cygpriv_idx): Remove.
	(privilege_luid): Change declaration.
	(privilege_luid_by_name): Drop declaration.
	(set_privilege): Change declaration.
	(set_process_privilege): Drop definition.
	(_push_thread_privilege): Accomodate new set_privilege parameters.
	* wincap.h (wincapc::max_sys_priv): New element.
	* wincap.cc: Implement above element throughout.
	(wincap_2000sp4): New wincaps structure.
	(wincap_xpsp1): Ditto.
	(wincap_xpsp2): Ditto.
	(wincapc::init): Use new wincaps.
	(wincapc::max_sys_priv): New element.
@
text
@d139 1
a139 1
	       int prot, int flags, const char *)
d169 1
a169 1
	  CloseHandle (h);
d875 15
a889 5
      HANDLE h = CreateFile (fh->get_win32_name (),
			     fh->get_access () | GENERIC_EXECUTE,
			     FILE_SHARE_VALID_FLAGS, &sec_none_nih,
			     OPEN_EXISTING, 0, NULL);
      if (h != INVALID_HANDLE_VALUE)
d1078 1
a1078 1
    CloseHandle (fh_disk_file.get_handle ());
d1508 1
a1508 2
      h = CreateMapping (get_handle (), len, off, get_access (),
			 prot, flags, get_win32_name ());
d1527 1
a1527 1
	  CloseHandle (h);
d1543 1
a1543 1
      CloseHandle (h);
d1588 1
a1588 1
			    prot, flags, get_win32_name ());
d1607 1
a1607 1
      CloseHandle (h);
d1619 1
a1619 1
  CloseHandle (h);
d1704 1
a1704 1
      CloseHandle (h);
d1721 1
a1721 1
  CloseHandle (h);
@


1.144
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop comment.
	* mmap.cc (gen_access): Remove.
	(mmap_record::gen_access): Remove.
	(mmap64): Don't mention 9x any longer.
	* syscalls.cc (statvfs): Drop status code consideration for 9x.
	* libc/minires-os-if.c (get_registry_dns_items): Don't mention 9x any
	longer.
	(get_registry_dns): Drop getting registry key on 9x.  Drop is9x
	variable.
@
text
@d1312 1
a1312 1
  push_thread_privilege (SE_LOCK_MEMORY_PRIV, true);
d1371 1
a1371 1
  push_thread_privilege (SE_LOCK_MEMORY_PRIV, true);
@


1.143
log
@	* fhandler_console.cc (fhandler_console::read): Drop 9x specific
	handling of AltGr key.
	* mmap.cc: Take NT for granted throughout.
	* wincap.cc: Remove map_view_of_file_ex_sucks, altgr_is_ctrl_alt,
	has_working_copy_on_write, share_mmaps_only_by_name,
	virtual_protect_works_on_shared_pages, has_mmap_alignment_bug and
	has_working_virtual_lock throughout.
	* wincap.h: Ditto.
@
text
@a136 14
/* Generate Windows access flags from mmap prot and flag values.
   Only used on 9x.  PROT_EXEC not supported here since it's not
   necessary. */
static inline DWORD
gen_access (DWORD openflags, int flags)
{
  DWORD ret = FILE_MAP_READ;
  if (priv (flags))
    ret = FILE_MAP_COPY;
  else if (openflags & GENERIC_WRITE)
    ret = priv (flags) ? FILE_MAP_COPY : FILE_MAP_WRITE;
  return ret;
}

a310 2
    DWORD gen_access () const
      { return ::gen_access (get_openflags (), get_flags ()); }
d1021 2
a1022 2
	 so don't even try on 9x and in WOW64.  This is accomplished by not
	 setting orig_len on 9x and in WOW64 above. */
@


1.142
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@d108 1
a108 3
  /* Ignore EXECUTE permission on 9x. */
  if ((openflags & GENERIC_EXECUTE)
      && wincap.virtual_protect_works_on_shared_pages ())
d131 1
a131 3
  /* Ignore EXECUTE permission on 9x. */
  if ((prot & PROT_EXEC)
      && wincap.virtual_protect_works_on_shared_pages ())
a831 1
  DWORD checkpagesize;
d839 1
a839 2
  /* EINVAL error conditions.  Note that the addr%pagesize test is deferred
     to workaround a serious alignment problem in Windows 98.  */
a843 1
#if 0
a844 1
#endif
a850 15
  /* There's a serious alignment problem in Windows 98.  MapViewOfFile
     sometimes returns addresses which are page aligned instead of
     granularity aligned.  OTOH, it's not possible to force such an
     address using MapViewOfFileEx.  So what we do here to let it work
     at least most of the time is, allow 4K aligned addresses in 98,
     to enable remapping of formerly mapped pages.  If no matching
     free pages exist, check addr again, this time for the real alignment. */
  checkpagesize = wincap.has_mmap_alignment_bug () ?
		  getsystempagesize () : pagesize;
  if (fixed (flags) && ((uintptr_t) addr % checkpagesize))
    {
      set_errno (EINVAL);
      goto out;
    }

d936 1
a936 6
      /* On NT systems we're creating the pages beyond EOF as reserved,
	 anonymous pages.  That's not possible on 9x for two reasons.
	 It neither allows to create reserved pages in the shared memory
	 area, nor does it allow to create page aligend mappings (in
	 contrast to granularity aligned mappings).

d940 2
a941 4
      if (wincap.virtual_protect_works_on_shared_pages ()
	  && !wincap.is_wow64 ()
	  && ((len > fsiz && !autogrow (flags))
	      || len < pagesize))
a990 8
  /* Deferred alignment test, see above. */
  if (wincap.has_mmap_alignment_bug ()
      && fixed (flags) && ((uintptr_t) addr % pagesize))
    {
      set_errno (EINVAL);
      goto out;
    }

d1109 1
a1109 3
  /* See comment in mmap64 for a description. */
  size_t pagesize = wincap.has_mmap_alignment_bug () ?
		    getsystempagesize () : getpagesize ();
d1173 1
a1173 4
  /* See comment in mmap64 for a description. */
  size_t pagesize = wincap.has_mmap_alignment_bug () ?
		    getsystempagesize () : getpagesize ();
  if (((uintptr_t) addr % pagesize)
d1181 1
a1181 1
  len = roundup2 (len, pagesize);
d1234 1
a1234 2
  size_t pagesize = wincap.has_mmap_alignment_bug () ?
		    getsystempagesize () : getpagesize ();
a1319 3
  if (!wincap.has_working_virtual_lock ())
    return 0;

a1384 3
  if (!wincap.has_working_virtual_lock ())
    return 0;

@


1.141
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d916 1
a916 1
			     wincap.shared (), &sec_none_nih,
@


1.140
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@a154 34
/* OS specific wrapper functions for map/section functions. */
static BOOL
VirtualProt9x (PVOID addr, SIZE_T len, DWORD prot, PDWORD oldprot)
{
  if (addr >= (caddr_t)0x80000000 && addr <= (caddr_t)0xBFFFFFFF)
    return TRUE; /* FAKEALARM! */
  return VirtualProtect (addr, len, prot, oldprot);
}

static BOOL
VirtualProtNT (PVOID addr, SIZE_T len, DWORD prot, PDWORD oldprot)
{
  return VirtualProtect (addr, len, prot, oldprot);
}

static BOOL
VirtualProtEx9x (HANDLE parent, PVOID addr, SIZE_T len, DWORD prot,
		 PDWORD oldprot)
{
  if (addr >= (caddr_t)0x80000000 && addr <= (caddr_t)0xBFFFFFFF)
    return TRUE; /* FAKEALARM! */
  return VirtualProtectEx (parent, addr, len, prot, oldprot);
}
static BOOL
VirtualProtExNT (HANDLE parent, PVOID addr, SIZE_T len, DWORD prot,
		 PDWORD oldprot)
{
  return VirtualProtectEx (parent, addr, len, prot, oldprot);
}

/* This allows to stay lazy about VirtualProtect usage in subsequent code. */
#define VirtualProtect(a,l,p,o) (mmap_func->VirtualProt((a),(l),(p),(o)))
#define VirtualProtectEx(h,a,l,p,o) (mmap_func->VirtualProtEx((h),(a),(l),(p),(o)))

d156 2
a157 80
CreateMapping9x (HANDLE fhdl, size_t len, _off64_t off, DWORD openflags,
		 int prot, int flags, const char *name)
{
  HANDLE h;
  DWORD high, low;

  DWORD protect = gen_create_protect (openflags, flags);

  /* copy-on-write doesn't work properly on 9x with real files.  While the
     changes are not propagated to the file, they are visible to other
     processes sharing the same file mapping object.  Workaround: Don't
     use named file mapping.  That should work since sharing file
     mappings only works reliable using named file mapping on 9x.

     On 9x/ME try first to open the mapping by name when opening a
     shared file object. This is needed since 9x/ME only shares objects
     between processes by name. What a mess... */

  if (fhdl != INVALID_HANDLE_VALUE && !priv (flags))
    {
      /* Grrr, the whole stuff is just needed to try to get a reliable
	 mapping of the same file. Even that uprising isn't bullet
	 proof but it does it's best... */
      char namebuf[CYG_MAX_PATH];
      cygwin_conv_to_full_posix_path (name, namebuf);
      for (int i = strlen (namebuf) - 1; i >= 0; --i)
	namebuf[i] = cyg_tolower (namebuf [i]);

      debug_printf ("named sharing");
      DWORD access = gen_access (openflags, flags);
      /* Different access modes result in incompatible mappings.  So we
	 create different maps per access mode by using different names. */
      switch (access)
	{
	  case FILE_MAP_READ:
	    namebuf[0] = 'R';
	    break;
	  case FILE_MAP_WRITE:
	    namebuf[0] = 'W';
	    break;
	  case FILE_MAP_COPY:
	    namebuf[0] = 'C';
	    break;
	}
      if (!(h = OpenFileMapping (access, TRUE, namebuf)))
	h = CreateFileMapping (fhdl, &sec_none, protect, 0, 0, namebuf);
    }
  else if (fhdl == INVALID_HANDLE_VALUE)
    {
      /* Standard anonymous mapping needs non-zero len. */
      h = CreateFileMapping (fhdl, &sec_none, protect, 0, len, NULL);
    }
  else if (autogrow (flags))
    {
      high = (off + len) >> 32;
      low = (off + len) & UINT32_MAX;
      /* Auto-grow only works if the protection is PAGE_READWRITE.  So,
	 first we call CreateFileMapping with PAGE_READWRITE, then, if the
	 requested protection is different, we close the mapping and
	 reopen it again with the correct protection, if auto-grow worked. */
      h = CreateFileMapping (fhdl, &sec_none, PAGE_READWRITE,
			     high, low, NULL);
      if (h && protect != PAGE_READWRITE)
	{
	  CloseHandle (h);
	  h = CreateFileMapping (fhdl, &sec_none, protect,
				 high, low, NULL);
	}
    }
  else
    {
      /* Zero len creates mapping for whole file. */
      h = CreateFileMapping (fhdl, &sec_none, protect, 0, 0, NULL);
    }
  return h;
}

static HANDLE
CreateMappingNT (HANDLE fhdl, size_t len, _off64_t off, DWORD openflags,
		 int prot, int flags, const char *)
d209 2
a210 30
MapView9x (HANDLE h, void *addr, size_t len, DWORD openflags,
	   int prot, int flags, _off64_t off)
{
  DWORD high = off >> 32;
  DWORD low = off & UINT32_MAX;
  DWORD access = gen_access (openflags, flags);
  void *base;

  /* Try mapping using the given address first, even if it's NULL.
     If it failed, and addr was not NULL and flags is not MAP_FIXED,
     try again with NULL address.

     Note: Retrying the mapping might be unnecessary, now that mmap64 checks
	   for a valid memory area first. */
  if (!addr)
    base = MapViewOfFile (h, access, high, low, len);
  else
    {
      base = MapViewOfFileEx (h, access, high, low, len, addr);
      if (!base && !fixed (flags))
	base = MapViewOfFile (h, access, high, low, len);
    }
  debug_printf ("%x = MapViewOfFileEx (h:%x, access:%x, 0, off:%D, "
		"len:%u, addr:%x)", base, h, access, off, len, addr);
  return base;
}

void *
MapViewNT (HANDLE h, void *addr, size_t len, DWORD openflags,
	   int prot, int flags, _off64_t off)
a244 33
struct mmap_func_t
{
  HANDLE (*CreateMapping)(HANDLE, size_t, _off64_t, DWORD, int, int,
			  const char *);
  void * (*MapView)(HANDLE, void *, size_t, DWORD, int, int, _off64_t);
  BOOL	 (*VirtualProt)(PVOID, SIZE_T, DWORD, PDWORD);
  BOOL	 (*VirtualProtEx)(HANDLE, PVOID, SIZE_T, DWORD, PDWORD);
};

mmap_func_t mmap_funcs_9x =
{
  CreateMapping9x,
  MapView9x,
  VirtualProt9x,
  VirtualProtEx9x
};

mmap_func_t mmap_funcs_nt =
{
  CreateMappingNT,
  MapViewNT,
  VirtualProtNT,
  VirtualProtExNT
};

mmap_func_t *mmap_func;

void
mmap_init ()
{
  mmap_func = wincap.is_winnt () ? &mmap_funcs_nt : &mmap_funcs_9x;
}

d912 8
a919 14
      /* On 9x you can't create mappings with PAGE_WRITECOPY protection if
	 the file isn't explicitely opened with WRITE access. */
      if (!wincap.is_winnt () && priv (flags)
	  && !(fh->get_access () & GENERIC_WRITE))
	{
	  HANDLE h = CreateFile (fh->get_win32_name (),
				 fh->get_access () | GENERIC_WRITE,
				 wincap.shared (), &sec_none_nih,
				 OPEN_EXISTING, 0, NULL);
	  if (h == INVALID_HANDLE_VALUE)
	    {
	      set_errno (EACCES);
	      goto out;
	    }
d921 1
a921 4
	  fh_disk_file.set_access (fh->get_access () | GENERIC_WRITE);
	  path_conv pc;
	  pc.set_name (fh->get_win32_name (), "");
	  fh_disk_file.set_name (pc);
d924 1
a924 4

      /* On NT you can't create mappings with PAGE_EXECUTE protection if
	 the file isn't explicitely opened with EXECUTE access. */
      if (wincap.is_winnt ())
d926 5
a930 18
	  HANDLE h = CreateFile (fh->get_win32_name (),
				 fh->get_access () | GENERIC_EXECUTE,
				 wincap.shared (), &sec_none_nih,
				 OPEN_EXISTING, 0, NULL);
	  if (h != INVALID_HANDLE_VALUE)
	    {
	      fh_disk_file.set_io_handle (h);
	      fh_disk_file.set_access (fh->get_access () | GENERIC_EXECUTE);
	      fh = &fh_disk_file;
	    }
	  else if (prot & PROT_EXEC)
	    {
	      /* TODO: To be or not to be... I'm opting for refusing this
		 mmap request rather than faking it, but that might break
		 some non-portable code. */
	      set_errno (EACCES);
	      goto out;
	    }
d1564 2
a1565 2
      h = mmap_func->CreateMapping (get_handle (), len, off, get_access (),
				    prot, flags, get_win32_name ());
d1573 1
a1573 1
      base = mmap_func->MapView (h, *addr, len, get_access(), prot, flags, off);
d1627 1
a1627 2
    base = mmap_func->MapView (h, address, size, get_access (),
			       prot, flags, offset);
d1644 2
a1645 2
  HANDLE h = mmap_func->CreateMapping (get_handle (), len, off, get_access (),
				       prot, flags, get_win32_name ());
d1653 1
a1653 2
  void *base = mmap_func->MapView (h, *addr, len, get_access (),
				   prot, flags, off);
d1697 1
a1697 2
  void *base = mmap_func->MapView (h, address, size, get_access (),
				   prot, flags, offset);
d1749 2
a1750 2
  void *base = MapViewNT (h, *addr, len, get_access (),
			  prot, flags | MAP_ANONYMOUS, off);
d1793 2
a1794 2
  void *base = MapViewNT (h, address, size, get_access (), prot,
			  flags | MAP_ANONYMOUS, offset);
@


1.139
log
@	* cygmalloc.h (MALLOC_FAILURE_ACTION): Define empty.
	* cygwin.din (posix_madvise): Export.
	(posix_memalign): Export.
	* fhandler.cc (fhandler_base::fpathconf): Return useful values in
	_PC_VDISABLE, _PC_SYNC_IO and _PC_SYMLINK_MAX cases.
	* malloc_wrapper.cc (malloc): Set errno here since it's not set in
	dlmalloc.c anymore.
	(realloc): Ditto.
	(calloc): Ditto.
	(memalign): Ditto.
	(valloc): Ditto.
	(posix_memalign): New function.
	* mmap.cc (posix_madvise): New function.
	* sysconf.cc (get_open_max): New function.
	(get_page_size): Ditto.
	(get_nproc_values): Ditto.
	(get_avphys): Ditto.
	(sc_type): New type.
	(sca): New array to map _SC_xxx options to sysconf return values.
	(sysconf): Reimplement using sca array.
	* include/limits.h: Add all missing values as defined by SUSv3.
	* include/pthread.h (PTHREAD_DESTRUCTOR_ITERATIONS): Move definition
	to sys/limits.h.
	(PTHREAD_KEYS_MAX): Ditto.
	* include/semaphore.h (SEM_VALUE_MAX): Ditto.
	* include/cygwin/stdlib.h (posix_memalign): Declare.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/mman.h: Add posix_madvise flags.
	(posix_madvise): Declare.
	* include/sys/termios.h (_POSIX_VDISABLE): Move definition to
	sys/limits.h.
@
text
@d332 1
a332 1
     
d364 1
a364 1
     
d917 1
a917 1
   
d941 1
a941 1
  while (len > 0) 
d1040 1
a1040 1
    		  getsystempagesize () : pagesize;
d1132 1
a1132 1
        {
d1238 1
a1238 1
        {
d1251 1
a1251 1
        {
d1742 1
a1742 1
      			 | (noreserve (flags) ? 0 : MEM_COMMIT);
@


1.138
log
@	* mmap.cc (list::hash): Fix type to __ino64_t.
	(list::get_hash): Ditto.
	(list::set): Add struct stat parameter.  Use that instead of calling
	fstat.
	(map::get_list_by_fd): Ditto.
	(map::add_list): Ditto.
	(mmap_is_attached_or_noreserve): Call get_list_by_fd appropriately.
	(mmap_worker): Add pameters for map list and file stat information.
	Propagate to called functions.
	(mmap64): Use fstat on files early.  Replace call to GetFileSize.
	Call get_list_by_fd and mmap_worker appropriately.
@
text
@d1653 23
@


1.137
log
@	* mmap.cc (MapView9x): Note possible uselessness of retrying.
	(MapViewNT): Ditto.
	(mmap64): Fix pre-reservation to work for non NULL, non MAP_FIXED.
@
text
@d513 1
a513 1
    DWORD hash;
d517 1
a517 1
    DWORD get_hash () const { return hash; }
d521 1
a521 1
    void set (int nfd);
d539 2
a540 2
    list *get_list_by_fd (int fd);
    list *add_list (int fd);
d787 1
a787 1
list::set (int nfd)
d795 1
a795 3
      struct stat st;
      fstat (nfd, &st);
      hash = st.st_ino;
d863 1
a863 1
map::get_list_by_fd (int fd)
d873 1
a873 2
      struct stat st;
      if (fd != -1 && !fstat (fd, &st) && lists[i].get_hash () == st.st_ino)
d880 1
a880 1
map::add_list (int fd)
d894 1
a894 1
  lists[nlists].set (fd);
d931 1
a931 1
  list *map_list = mmapped_areas.get_list_by_fd (-1);
d972 2
a973 2
mmap_worker (fhandler_base *fh, caddr_t base, size_t len, int prot, int flags,
	     int fd, _off64_t off)
a974 1
  list *map_list;
d978 3
a980 2
  if (!(map_list = mmapped_areas.get_list_by_fd (fd))
      && !(map_list = mmapped_areas.add_list (fd)))
d1006 1
d1131 6
a1136 3
      DWORD high;
      DWORD low = GetFileSize (fh->get_handle (), &high);
      _off64_t fsiz = ((_off64_t)high << 32) + low;
d1204 1
a1204 1
  map_list = mmapped_areas.get_list_by_fd (fd);
d1258 2
a1259 1
  base = mmap_worker (fh, (caddr_t) addr, len, prot, flags, fd, off);
d1291 2
a1292 2
	      at_base = mmap_worker (&fh_anonymous, at_base, valid_page_len,
				     prot, flags, -1, 0);
d1305 2
a1306 2
	      at_base = mmap_worker (&fh_anonymous, at_base, sigbus_page_len,
				     prot, flags, -1, 0);
@


1.136
log
@	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.
@
text
@d331 4
a334 1
     try again with NULL address. */
d363 4
a366 1
     try again with NULL address. */
d1234 3
a1236 3
      addr = VirtualAlloc (addr, orig_len, MEM_TOP_DOWN | MEM_RESERVE,
      			   PAGE_READWRITE);
      if (!addr)
d1238 10
a1247 2
	  __seterrno ();
	  goto out;
d1249 1
a1249 1
      if (!VirtualFree (addr, 0, MEM_RELEASE))
d1254 1
@


1.135
log
@	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.
@
text
@d1220 22
d1250 1
a1250 1
	 mappings are created, first the reminder from the file end to
d1258 1
d1260 1
@


1.134
log
@	* cygheap.h (struct user_heap_info): Add slop member.
	* heap.cc (heap_init): Add slop factor to heap allocation.  Add
	comment.
	* mmap.cc (MapViewNT): Allocate memory maps top down.
	(fhandler_dev_zero::mmap): Ditto.
	* shared.cc (shared_info::heap_slop_size): New method.
	(shared_info::heap_chunk_size): Don't use debug_printf at early stage.
	* shared_info.h (SHARED_INFO_CB): Accomodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop member.  Declare heap_slop_size.
	* wincap.h: Define heapslop throughout.
	* wincap.cc: Ditto.
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
d39 3
a41 1
#define PAGE_CNT(bytes) howmany((bytes),getpagesize())
d607 3
a609 2
      && !VirtualProtect (get_address () + off * getpagesize (),
			  len * getpagesize (), gen_protect (), &old_prot))
d617 1
a617 1
  return off * getpagesize ();
d626 1
a626 1
  off /= getpagesize ();
d636 3
a638 2
      && !VirtualProtect (get_address () + off * getpagesize (),
			  len * getpagesize (), gen_protect (), &old_prot))
a652 2
  off /= getpagesize ();
  len = PAGE_CNT (len);
d654 1
a654 2
      && !VirtualFree (get_address () + off * getpagesize (),
		       len * getpagesize (), MEM_DECOMMIT))
d656 2
a657 2
  else if (!VirtualProtect (get_address () + off * getpagesize (),
			    len * getpagesize (), PAGE_NOACCESS, &old_prot))
d660 2
d677 1
a677 1
  DWORD off = (address - get_address ()) / getpagesize ();
d746 3
a748 2
	    && off + len <= recs[i].get_offset ()
			 + (PAGE_CNT (recs[i].get_len ()) * getpagesize ()))
d768 1
a768 1
	high += (PAGE_CNT (recs[i].get_len ()) * getpagesize ());
@


1.133
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@d353 2
a354 1
  ULONG alloc_type = base && !wincap.is_wow64 () ? AT_ROUND_TO_PAGE : 0;
d1673 2
a1674 1
      DWORD alloc_type = MEM_RESERVE | (noreserve (flags) ? 0 : MEM_COMMIT);
@


1.132
log
@	* mmap.cc (msync): Disable rounding up len.  Fix bug in access check
	loop.
@
text
@d903 6
a908 1
   violation has happened.  We have two cases to check here.
d910 12
a921 17
   First, is it an address within "attached" mmap pages (indicated by
   the __PROT_ATTACH protection, see there)?  In this case the function
   returns 1 and the exception_handler raises SIGBUS, as demanded by the
   memory protection extension described in SUSv3 (see the mmap man
   page).
   
   Second, check if the address is within "noreserve" mmap pages
   (indicated by MAP_NORESERVE flag).  If so, the function calls
   VirtualAlloc to commit the page and returns 2.  The exception handler
   then just returns with 0 and the affected application retries the
   failing memory access.  If VirtualAlloc fails, the function returns
   1, so that the exception handler raises a SIGBUS, as described in the
   MAP_NORESERVE man pages for Linux and Solaris.
   
   In any other case 0 is returned and a normal SIGSEGV is raised. */
int
mmap_is_attached_or_noreserve_page (ULONG_PTR addr)
d923 36
a958 5
  list *map_list;
  long record_idx;
  caddr_t u_addr;
  DWORD u_len;
  DWORD pagesize = getsystempagesize ();
d960 1
a960 12
  addr = rounddown (addr, pagesize);
  if (!(map_list = mmapped_areas.get_list_by_fd (-1)))
    return 0;
  if ((record_idx = map_list->search_record ((caddr_t)addr, pagesize,
					     u_addr, u_len, -1)) < 0)
    return 0;
  if (map_list->get_record (record_idx)->attached ())
    return 1;
  if (!map_list->get_record (record_idx)->noreserve ())
    return 0;
  DWORD new_prot = map_list->get_record (record_idx)->gen_protect ();
  return VirtualAlloc ((void *)addr, pagesize, MEM_COMMIT, new_prot) ? 2 : 1;
@


1.132.2.1
log
@	* dtable.cc (build_fh_pc): Add missing DEV_SD1_MAJOR case (Thanks to
	Joe Loh for noticing).

	* cygheap.h (struct user_heap_info): Add slop member.
	* heap.cc (heap_init): Add slop factor to heap allocation.  Add
	comment.
	* mmap.cc (MapViewNT): Allocate memory maps top down.
	(fhandler_dev_zero::mmap): Ditto.
	* shared.cc (shared_info::heap_slop_size): New method.
	(shared_info::heap_chunk_size): Don't use debug_printf at early stage.
	* shared_info.h (SHARED_INFO_CB): Accomodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop member.  Declare heap_slop_size.
	* wincap.h: Define heapslop throughout.
	* wincap.cc: Ditto.
@
text
@d353 1
a353 2
  ULONG alloc_type = (base && !wincap.is_wow64 () ? AT_ROUND_TO_PAGE : 0)
		     | MEM_TOP_DOWN;
d1652 1
a1652 2
      DWORD alloc_type = MEM_TOP_DOWN | MEM_RESERVE
      			 | (noreserve (flags) ? 0 : MEM_COMMIT);
@


1.132.2.2
log
@2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
d39 1
a39 3
/* Stick with 4K pages for bookkeeping, otherwise we just get confused
   when trying to do file mappings with trailing filler pages correctly. */
#define PAGE_CNT(bytes) howmany((bytes),getsystempagesize())
d605 2
a606 3
      && !VirtualProtect (get_address () + off * getsystempagesize (),
			  len * getsystempagesize (), gen_protect (),
			  &old_prot))
d614 1
a614 1
  return off * getsystempagesize ();
d623 1
a623 1
  off /= getsystempagesize ();
d633 2
a634 3
      && !VirtualProtect (get_address () + off * getsystempagesize (),
			  len * getsystempagesize (), gen_protect (),
			  &old_prot))
d649 2
d652 2
a653 1
      && !VirtualFree (get_address () + off, len, MEM_DECOMMIT))
d655 2
a656 2
  else if (!VirtualProtect (get_address () + off, len, PAGE_NOACCESS,
			    &old_prot))
a658 2
  off /= getsystempagesize ();
  len = PAGE_CNT (len);
d674 1
a674 1
  DWORD off = (address - get_address ()) / getsystempagesize ();
d743 2
a744 3
	    && off + len
	       <= recs[i].get_offset ()
		  + (PAGE_CNT (recs[i].get_len ()) * getsystempagesize ()))
d764 1
a764 1
	high += (PAGE_CNT (recs[i].get_len ()) * getsystempagesize ());
a1195 22
  if (orig_len)
    {
      /* If the requested length is bigger than the file size, we try to
	 allocate an area of the full size first.  This area is immediately
	 deallocated and the address we got is used as base address for the
	 subsequent real mappings.  This ensures that we have enough space
	 for the whole thing. */
      orig_len = roundup2 (orig_len, pagesize);
      addr = VirtualAlloc (addr, orig_len, MEM_TOP_DOWN | MEM_RESERVE,
      			   PAGE_READWRITE);
      if (!addr)
        {
	  __seterrno ();
	  goto out;
	}
      if (!VirtualFree (addr, 0, MEM_RELEASE))
        {
	  __seterrno ();
	  goto out;
	}
    }

d1204 1
a1204 1
	 mappings are created, first the remainder from the file end to
a1211 1
#if 0
a1212 1
#endif
@


1.132.2.3
log
@	* mmap.cc (MapView9x): Note possible uselessness of retrying.
	(MapViewNT): Ditto.
	(mmap64): Fix pre-reservation to work for non NULL, non MAP_FIXED.
@
text
@d331 1
a331 4
     try again with NULL address.
     
     Note: Retrying the mapping might be unnecessary, now that mmap64 checks
	   for a valid memory area first. */
d360 1
a360 4
     try again with NULL address.
     
     Note: Retrying the mapping might be unnecessary, now that mmap64 checks
	   for a valid memory area first. */
d1208 3
a1210 3
      PVOID newaddr = VirtualAlloc (addr, orig_len, MEM_TOP_DOWN | MEM_RESERVE,
				    PAGE_READWRITE);
      if (!newaddr)
d1212 2
a1213 10
	  /* If addr is not NULL, but MAP_FIXED isn't given, allow the OS
	     to choose. */
	  if (addr && !fixed (flags))
	    newaddr = VirtualAlloc (NULL, orig_len, MEM_TOP_DOWN | MEM_RESERVE,
				    PAGE_READWRITE);
	  if (!newaddr)
	    {
	      __seterrno ();
	      goto out;
	    }
d1215 1
a1215 1
      if (!VirtualFree (newaddr, 0, MEM_RELEASE))
a1219 1
      addr = newaddr;
@


1.132.2.4
log
@	* mmap.cc (list::hash): Fix type to __ino64_t.
	(list::get_hash): Ditto.
@
text
@d513 1
a513 1
    __ino64_t hash;
d517 1
a517 1
    __ino64_t get_hash () const { return hash; }
@


1.132.2.5
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d52 2
a985 2
  fhandler_disk_file *fh_disk_file = NULL; /* Used for reopening a disk file
					      when necessary. */
d995 1
d1081 2
a1082 1
	  fh_disk_file = new (alloca (sizeof *fh_disk_file)) fhandler_disk_file;
d1085 2
a1086 4
	  fh_disk_file->set_name (pc);
	  fh_disk_file->set_io_handle (h);
	  fh_disk_file->set_access (fh->get_access () | GENERIC_WRITE);
	  fh = fh_disk_file;
d1099 3
a1101 7
	      fh_disk_file = new (alloca (sizeof *fh_disk_file)) fhandler_disk_file;
	      path_conv pc;
	      pc.set_name (fh->get_win32_name (), "");
	      fh_disk_file->set_name (pc);
	      fh_disk_file->set_io_handle (h);
	      fh_disk_file->set_access (fh->get_access () | GENERIC_EXECUTE);
	      fh = fh_disk_file;
d1297 2
a1298 2
  if (fh_disk_file)
    CloseHandle (fh_disk_file->get_handle ());
@


1.132.2.6
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.

	* mmap.cc: Convert usage of dynamically growing cmalloced arrays to
	cmalloced linked lists throughout.
	(class mmap_record): Add LIST_ENTRY element.
	(mmap_record::match): New method, taking over match algorithm from
	list::search_record.
	(class mmap_list): Rename from class list.  Add LIST_ENTRY.  Convert
	recs to a LIST_HEAD.  Drop nrecs and maxrecs members.
	(mmap_list::get_record): Drop entirely.
	(mmap_list::free_recs): Drop entirely.
	(mmap_list::del_record): Take mmap_record to delete as parameter.
	(mmap_list::search_record): Convert to mmap_record::match.
	(class mmap_areas): Rename from class map.  Convert lists to LIST_HEAD.
	(mmap_areas::get_list): Drop entirely.
	(mmap_areas::del_list): Take mmap_list to delete as parameter.
	(mprotect): Fix indentation.
@
text
@a26 1
#include <sys/queue.h>
a52 5
/* Used for thread synchronization while accessing mmap bookkeeping lists. */
static NO_COPY muto mmap_guard;
#define LIST_LOCK()    (mmap_guard.init ("mmap_guard")->acquire ())
#define LIST_UNLOCK()  (mmap_guard.release ())

d425 4
a428 5
   Contains a singly-linked list of type class mmap_list.  Each mmap_list
   entry represents all mapping to a file, keyed by file descriptor and
   file name hash.
   Each list entry contains a singly-linked list of type class mmap_record.
   Each mmap_record represents exactly one mapping.  For each mapping, there's
a434 3
  public:
    LIST_ENTRY (mmap_record) mr_next;

a487 1
    bool match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len);
d505 1
a505 1
class mmap_list
a506 4
  public:
    LIST_ENTRY (mmap_list) ml_next;
    LIST_HEAD (, mmap_record) recs;

d508 2
d516 1
d521 5
a525 1
    bool del_record (mmap_record *rec);
d529 1
a529 1
class mmap_areas
d531 4
d536 4
a539 5
    LIST_HEAD (, mmap_list) lists;

    mmap_list *get_list_by_fd (int fd);
    mmap_list *add_list (int fd);
    void del_list (mmap_list *ml);
d543 1
a543 1
static mmap_areas mmapped_areas;
a573 19
mmap_record::match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len)
{
  caddr_t low = (addr >= get_address ()) ? addr : get_address ();
  caddr_t high = get_address ();
  if (filler ())
    high += get_len ();
  else
    high += (PAGE_CNT (get_len ()) * getsystempagesize ());
  high = (addr + len < high) ? addr + len : high;
  if (low < high)
    {
      m_addr = low;
      m_len = high - low;
      return true;
    }
  return false;
}

bool
d713 1
a713 1
mmap_list::add_record (mmap_record r)
d715 16
a730 2
  mmap_record *rec = (mmap_record *) cmalloc (HEAP_MMAP, sizeof (mmap_record));
  if (!rec)
d732 15
a746 2
  *rec = r;
  if (!rec->alloc_page_map ())
d748 32
a779 2
      cfree (rec);
      return NULL;
d781 1
a781 2
  LIST_INSERT_HEAD (&recs, rec, mr_next);
  return rec;
d785 1
a785 1
mmap_list::set (int nfd)
d797 2
a798 1
  LIST_INIT (&recs);
d802 1
a802 1
mmap_list::del_record (mmap_record *rec)
d804 7
a810 3
  rec->free_page_map ();
  LIST_REMOVE (rec, mr_next);
  cfree (rec);
d812 2
a813 2
     this list from the list of lists. */
  return !LIST_FIRST(&recs);
d817 1
a817 1
mmap_list::try_map (void *addr, size_t len, int flags, _off64_t off)
d825 2
a826 5
      DWORD plen = PAGE_CNT (len);
      LIST_FOREACH (rec, &recs, mr_next)
	if (rec->find_unused_pages (plen) != (DWORD) -1)
	  break;
      if (rec && rec->compatible_flags (flags))
d828 1
a828 1
	  if ((off = rec->map_pages (off, len)) == (_off64_t) -1)
d840 3
a842 4
      LIST_FOREACH (rec, &recs, mr_next)
	if (rec->match ((caddr_t) addr, len, u_addr, u_len))
	  break;
      if (rec)
d844 1
d862 2
a863 2
mmap_list *
mmap_areas::get_list_by_fd (int fd)
d865 2
a866 2
  mmap_list *ml;
  LIST_FOREACH (ml, &lists, ml_next)
d868 2
a869 2
      if (fd == -1 && ml->anonymous ())
	return ml;
d874 2
a875 2
      if (fd != -1 && !fstat (fd, &st) && ml->get_hash () == st.st_ino)
	return ml;
d880 2
a881 2
mmap_list *
mmap_areas::add_list (int fd)
d883 14
a896 6
  mmap_list *ml = (mmap_list *) cmalloc (HEAP_MMAP, sizeof (mmap_list));
  if (!ml)
    return NULL;
  ml->set (fd);
  LIST_INSERT_HEAD (&lists, ml, ml_next);
  return ml;
d900 1
a900 1
mmap_areas::del_list (mmap_list *ml)
d902 7
a908 2
  LIST_REMOVE (ml, ml_next);
  cfree (ml);
d932 2
a933 2
  mmap_list *map_list;
  mmap_record *rec;
a936 1
  int ret;
a938 1
  LIST_LOCK ();
d940 10
a949 19
    ret = 0;
  else
    {
      LIST_FOREACH (rec, &map_list->recs, mr_next)
	if (rec->match ((caddr_t) addr, pagesize, u_addr, u_len))
	  break;
      if (!rec)
	ret = 0;
      else if (rec->attached ())
	ret = 1;
      else if (!rec->noreserve ())
	ret = 0;
      else
	ret = VirtualAlloc ((void *)addr, pagesize, MEM_COMMIT,
			    rec->gen_protect ())
	      ? 2 : 1;
    }
  LIST_UNLOCK ();
  return ret;
d956 1
a956 1
  mmap_list *map_list;
d986 1
a986 1
  mmap_list *map_list = NULL;
d996 2
a1186 1
  LIST_LOCK ();
d1198 1
a1198 1
	  goto out_with_unlock;
d1207 1
a1207 1
      goto out_with_unlock;
d1230 1
a1230 1
	      goto out_with_unlock;
d1236 1
a1236 1
	  goto out_with_unlock;
d1243 1
a1243 1
    goto out_with_unlock;
d1279 1
a1279 1
		  goto out_with_unlock;
d1297 1
a1297 2
out_with_unlock:
  LIST_UNLOCK ();
d1299 1
a1299 1
out:
d1337 1
a1337 1
  LIST_LOCK ();
d1341 4
a1344 2
  mmap_list *map_list, *next_map_list;
  LIST_FOREACH_SAFE (map_list, &mmapped_areas.lists, ml_next, next_map_list)
d1346 1
a1346 1
      mmap_record *rec, *next_rec;
d1350 2
a1351 1
      LIST_FOREACH_SAFE (rec, &map_list->recs, mr_next, next_rec)
d1353 1
a1353 2
	  if (!rec->match ((caddr_t) addr, len, u_addr, u_len))
	    continue;
d1365 1
a1365 1
	      if (map_list->del_record (rec))
d1369 1
a1369 1
		  mmapped_areas.del_list (map_list);
d1376 1
a1376 1
  LIST_UNLOCK ();
d1387 1
a1387 1
  mmap_list *map_list;
d1391 1
a1391 1
  LIST_LOCK ();
d1409 3
a1411 1
  LIST_FOREACH (map_list, &mmapped_areas.lists, ml_next)
d1414 3
a1416 1
      LIST_FOREACH (rec, &map_list->recs, mr_next)
d1418 1
a1418 1
	  if (rec->access ((caddr_t) addr))
d1422 1
a1422 1
		if (!rec->access ((caddr_t) addr + i))
d1428 1
a1428 1
	      ret = fh->msync (rec->get_handle (), (caddr_t) addr, len, flags);
d1440 1
a1440 1
  LIST_UNLOCK ();
d1466 1
a1466 1
  LIST_LOCK ();
d1470 34
a1503 31
  mmap_list *map_list;
  LIST_FOREACH (map_list, &mmapped_areas.lists, ml_next)
    {
      mmap_record *rec;
      caddr_t u_addr;
      DWORD u_len;

      LIST_FOREACH (rec, &map_list->recs, mr_next)
	{
	  if (!rec->match ((caddr_t) addr, len, u_addr, u_len))
	    continue;
	  in_mapped = true;
	  if (rec->attached ())
	    continue;
	  new_prot = gen_protect (prot, rec->get_flags ());
	  if (rec->noreserve ())
	    {
	      if (new_prot == PAGE_NOACCESS)
		ret = VirtualFree (u_addr, u_len, MEM_DECOMMIT);
	      else
		ret = !!VirtualAlloc (u_addr, u_len, MEM_COMMIT, new_prot);
	    }
	  else
	    ret = VirtualProtect (u_addr, u_len, new_prot, &old_prot);
	  if (!ret)
	    {
	      __seterrno ();
	      break;
	    }
	}
    }
d1505 1
a1505 1
  LIST_UNLOCK ();
d1976 4
a1979 2
  mmap_list *map_list;
  LIST_FOREACH (map_list, &mmapped_areas.lists, ml_next)
d1982 3
a1984 1
      LIST_FOREACH (rec, &map_list->recs, mr_next)
@


1.131
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d1355 1
d1357 1
d1373 1
a1373 1
	      for (DWORD i = getpagesize (); i < len; ++i)
@


1.130
log
@	* mmap.cc (mmap64): Drop MAP_NORESERVE flag for non-anonymous,
	non-private mappings.
	(mmap_record::unmap_pages): Only check noreserve flag which now implies
	anonymous and private.
	(mprotect): Ditto.
	(fixup_mmaps_after_fork): Ditto.
@
text
@d980 1
d1010 2
a1011 2
  DWORD checkpagesize = wincap.has_mmap_alignment_bug () ?
			getsystempagesize () : pagesize;
@


1.129
log
@	* exceptions.cc (_cygtls::handle_exceptions): Call new
	mmap_is_attached_or_noreserve_page function in case of access violation
	and allow application to retry access on noreserve pages.
	* mmap.cc (mmap_is_attached_or_noreserve_page): Changed from
	mmap_is_attached_page.  Handle also noreserve pages now.  Change
	comment accordingly.
	* winsup.h (mmap_is_attached_or_noreserve_page): Declare instead of
	mmap_is_attached_page.
@
text
@d650 1
a650 1
  if (anonymous () && priv () && noreserve ()
d1030 1
d1165 6
d1437 1
a1437 1
	 if (rec->anonymous () && rec->priv () && rec->noreserve ())
d1979 1
a1979 1
		  if (rec->anonymous () && rec->noreserve ()
@


1.128
log
@	* mmap.cc (mmap_record::alloc_page_map): Don't call VirtualProtect
	on maps created with MAP_NORESERVE.
@
text
@d903 19
a921 7
   violation has happened.  The function should return true, if the
   faulting address (the parameter) is within attached pages.  In this
   case the exception_handler raises SIGBUS, as demanded by the memory
   protection extension described in SUSv3 (see the mmap man page).
   If false is returned, a normal SIGSEGV is raised. */
bool
mmap_is_attached_page (ULONG_PTR addr)
d931 1
a931 1
    return false;
d934 7
a940 4
    return false;
  if (!map_list->get_record (record_idx)->attached ())
    return false;
  return true;
@


1.127
log
@white space
@
text
@d577 1
a577 1
  if (real_protect != start_protect
@


1.127.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d577 1
a577 1
  if (real_protect != start_protect && !noreserve ()
d903 7
a909 19
   violation has happened.  We have two cases to check here.
   
   First, is it an address within "attached" mmap pages (indicated by
   the __PROT_ATTACH protection, see there)?  In this case the function
   returns 1 and the exception_handler raises SIGBUS, as demanded by the
   memory protection extension described in SUSv3 (see the mmap man
   page).
   
   Second, check if the address is within "noreserve" mmap pages
   (indicated by MAP_NORESERVE flag).  If so, the function calls
   VirtualAlloc to commit the page and returns 2.  The exception handler
   then just returns with 0 and the affected application retries the
   failing memory access.  If VirtualAlloc fails, the function returns
   1, so that the exception handler raises a SIGBUS, as described in the
   MAP_NORESERVE man pages for Linux and Solaris.
   
   In any other case 0 is returned and a normal SIGSEGV is raised. */
int
mmap_is_attached_or_noreserve_page (ULONG_PTR addr)
d919 1
a919 1
    return 0;
d922 4
a925 7
    return 0;
  if (map_list->get_record (record_idx)->attached ())
    return 1;
  if (!map_list->get_record (record_idx)->noreserve ())
    return 0;
  DWORD new_prot = map_list->get_record (record_idx)->gen_protect ();
  return VirtualAlloc ((void *)addr, pagesize, MEM_COMMIT, new_prot) ? 2 : 1;
@


1.127.2.2
log
@	* mmap.cc (mmap64): Drop MAP_NORESERVE flag for non-anonymous,
	non-private mappings.
	(mmap_record::unmap_pages): Only check noreserve flag which now implies
	anonymous and private.
	(mprotect): Ditto.
	(fixup_mmaps_after_fork): Ditto.
@
text
@d650 1
a650 1
  if (noreserve ()
a1029 1

a1163 6
  /* MAP_NORESERVE is only supported on private anonymous mappings.
     Remove that bit from flags so that later code doesn't have to
     test all bits. */
  if (noreserve (flags) && (!anonymous (flags) || !priv (flags)))
    flags &= ~MAP_NORESERVE;

d1430 1
a1430 1
	 if (rec->noreserve ())
d1972 1
a1972 1
		  if (rec->noreserve ()
@


1.127.2.3
log
@	* Merge HEAD into cv-branch.
@
text
@a979 1
  DWORD checkpagesize;
d1009 2
a1010 2
  checkpagesize = wincap.has_mmap_alignment_bug () ?
    		  getsystempagesize () : pagesize;
@


1.127.2.4
log
@	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.
@
text
@d903 1
a903 6
   violation has occurred.  It should also be called from all Cygwin
   functions that want to support passing noreserve mmap page addresses
   to Windows system calls.  In that case, it should be called only after
   a system call indicates that the application buffer passed had an
   invalid virtual address to avoid any performance impact in non-noreserve
   cases.
d905 17
a921 12
   Check if the address range is all within noreserve mmap regions.  If so,
   call VirtualAlloc to commit the pages and return MMAP_NORESERVE_COMMITED
   on success.  If the page has __PROT_ATTACH (SUSv3 memory protection
   extension), or if VirutalAlloc fails, return MMAP_RAISE_SIGBUS.
   Otherwise, return MMAP_NONE if the address range is not covered by an
   attached or noreserve map.

   On MAP_NORESERVE_COMMITED, the exeception handler should return 0 to
   allow the application to retry the memory access, or the calling Cygwin
   function should retry the Windows system call. */
mmap_region_status
mmap_is_attached_or_noreserve (void *addr, size_t len)
d923 5
a927 1
  list *map_list = mmapped_areas.get_list_by_fd (-1);
d929 12
a940 36
  size_t pagesize = getpagesize ();
  caddr_t start_addr = (caddr_t) rounddown ((uintptr_t) addr, pagesize);
  len += ((caddr_t) addr - start_addr);
  len = roundup2 (len, pagesize);

  if (map_list == NULL)
    return MMAP_NONE;

  while (len > 0) 
    {
      caddr_t u_addr;
      DWORD u_len;
      long record_idx = map_list->search_record (start_addr, len,
						 u_addr, u_len, -1);
      if (record_idx < 0)
	return MMAP_NONE;

      mmap_record *rec = map_list->get_record (record_idx);
      if (rec->attached ())
	return MMAP_RAISE_SIGBUS;
      if (!rec->noreserve ())
	return MMAP_NONE;

      size_t commit_len = u_len - (start_addr - u_addr);
      if (commit_len > len)
	commit_len = len;

      if (!VirtualAlloc (start_addr, commit_len, MEM_COMMIT,
			 rec->gen_protect ()))
	return MMAP_RAISE_SIGBUS;

      start_addr += commit_len;
      len -= commit_len;
    }

    return MMAP_NORESERVE_COMMITED;
@


1.127.2.5
log
@	* Merge HEAD into cv-branch.
@
text
@d903 6
a908 1
   violation has happened.  We have two cases to check here.
d910 12
a921 17
   First, is it an address within "attached" mmap pages (indicated by
   the __PROT_ATTACH protection, see there)?  In this case the function
   returns 1 and the exception_handler raises SIGBUS, as demanded by the
   memory protection extension described in SUSv3 (see the mmap man
   page).
   
   Second, check if the address is within "noreserve" mmap pages
   (indicated by MAP_NORESERVE flag).  If so, the function calls
   VirtualAlloc to commit the page and returns 2.  The exception handler
   then just returns with 0 and the affected application retries the
   failing memory access.  If VirtualAlloc fails, the function returns
   1, so that the exception handler raises a SIGBUS, as described in the
   MAP_NORESERVE man pages for Linux and Solaris.
   
   In any other case 0 is returned and a normal SIGSEGV is raised. */
int
mmap_is_attached_or_noreserve_page (ULONG_PTR addr)
d923 36
a958 5
  list *map_list;
  long record_idx;
  caddr_t u_addr;
  DWORD u_len;
  DWORD pagesize = getsystempagesize ();
d960 1
a960 12
  addr = rounddown (addr, pagesize);
  if (!(map_list = mmapped_areas.get_list_by_fd (-1)))
    return 0;
  if ((record_idx = map_list->search_record ((caddr_t)addr, pagesize,
					     u_addr, u_len, -1)) < 0)
    return 0;
  if (map_list->get_record (record_idx)->attached ())
    return 1;
  if (!map_list->get_record (record_idx)->noreserve ())
    return 0;
  DWORD new_prot = map_list->get_record (record_idx)->gen_protect ();
  return VirtualAlloc ((void *)addr, pagesize, MEM_COMMIT, new_prot) ? 2 : 1;
a1374 1
#if 0 /* If I only knew why I did that... */
a1375 1
#endif
d1391 1
a1391 1
	      for (DWORD i = getpagesize (); i < len; i += getpagesize ())
@


1.127.2.6
log
@	* Correctly merge HEAD into cv-branch.
@
text
@d903 1
a903 6
   violation has occurred.  It should also be called from all Cygwin
   functions that want to support passing noreserve mmap page addresses
   to Windows system calls.  In that case, it should be called only after
   a system call indicates that the application buffer passed had an
   invalid virtual address to avoid any performance impact in non-noreserve
   cases.
d905 17
a921 12
   Check if the address range is all within noreserve mmap regions.  If so,
   call VirtualAlloc to commit the pages and return MMAP_NORESERVE_COMMITED
   on success.  If the page has __PROT_ATTACH (SUSv3 memory protection
   extension), or if VirutalAlloc fails, return MMAP_RAISE_SIGBUS.
   Otherwise, return MMAP_NONE if the address range is not covered by an
   attached or noreserve map.

   On MAP_NORESERVE_COMMITED, the exeception handler should return 0 to
   allow the application to retry the memory access, or the calling Cygwin
   function should retry the Windows system call. */
mmap_region_status
mmap_is_attached_or_noreserve (void *addr, size_t len)
d923 5
a927 1
  list *map_list = mmapped_areas.get_list_by_fd (-1);
d929 12
a940 36
  size_t pagesize = getpagesize ();
  caddr_t start_addr = (caddr_t) rounddown ((uintptr_t) addr, pagesize);
  len += ((caddr_t) addr - start_addr);
  len = roundup2 (len, pagesize);

  if (map_list == NULL)
    return MMAP_NONE;

  while (len > 0) 
    {
      caddr_t u_addr;
      DWORD u_len;
      long record_idx = map_list->search_record (start_addr, len,
						 u_addr, u_len, -1);
      if (record_idx < 0)
	return MMAP_NONE;

      mmap_record *rec = map_list->get_record (record_idx);
      if (rec->attached ())
	return MMAP_RAISE_SIGBUS;
      if (!rec->noreserve ())
	return MMAP_NONE;

      size_t commit_len = u_len - (start_addr - u_addr);
      if (commit_len > len)
	commit_len = len;

      if (!VirtualAlloc (start_addr, commit_len, MEM_COMMIT,
			 rec->gen_protect ()))
	return MMAP_RAISE_SIGBUS;

      start_addr += commit_len;
      len -= commit_len;
    }

    return MMAP_NORESERVE_COMMITED;
@


1.126
log
@	* Update copyrights.
@
text
@d1113 1
a1113 1
	 
@


1.125
log
@	* dcrt0.cc (dll_crt0_0): Remove call to wincap.init.
	* init.cc (dll_entry): Rename is_wow64_proc to wow64_test_stack_marker.
	Call wincap.init here before doing anything else.  Use wincap.is_wow64
	to determine if we're running in a WOW64 emulator.
	* mmap.cc (MapViewNT): Don't use AT_ROUND_TO_PAGE in WOW64, it's
	apparently not supported.
	(mmap64): Don't create mappings beyond EOF, which would need to use
	AT_ROUND_TO_PAGE, on WOW64.
	* wincap.cc (wincap): Throw into the .cygwin_dll_common section.
	(wincapc::init): Determine if running in WOW64 and set wow_64 flag.
	* wincap.h (class wincapc): Add wow64 member.
	(wincapc::is_wow64): New method.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005
   Red Hat, Inc.
@


1.124
log
@whitespace cleanup to force snapshot.
@
text
@d353 1
a353 1
  ULONG alloc_type = base ? AT_ROUND_TO_PAGE : 0;
d1112 5
a1116 1
	 contrast to granularity aligned mappings). */
d1118 1
d1185 3
a1187 3
	 and page protection on shared pages is only supported by NT, so
	 don't even try on 9x.  This is accomplished by not setting
	 orig_len on 9x above. */
@


1.123
log
@	* mmap.cc (fhandler_dev_zero::mmap): Call VirtualFree(MEM_RELEASE)
	with zero length parameter, otherwise it fails.
	(fhandler_dev_zero::munmap): Ditto.
@
text
@d219 1
a219 1
         create different maps per access mode by using different names. */
d221 1
a221 1
        {
d245 1
a245 1
         first we call CreateFileMapping with PAGE_READWRITE, then, if the
d289 1
a289 1
         first we call NtCreateSection with PAGE_READWRITE, then, if the
d296 1
a296 1
        {
d305 1
a305 1
         AT_EXTENDABLE_FILE mapping, if we ever use it... */
d364 1
a364 1
      				&offset, &viewsize, ViewShare, 0, protect);
d379 1
a379 1
  			  const char *);
d442 1
a442 1
    		 caddr_t b) :
d488 1
a488 1
    
d761 1
a761 1
        high += recs[i].get_len ();
d995 1
a995 1
  			getsystempagesize () : pagesize;
d1021 1
a1021 1
         no offset. */
d1028 1
a1028 1
         for reading, regardless of the requested protection, and file must
d1040 1
a1040 1
         the file isn't explicitely opened with WRITE access. */
d1042 1
a1042 1
      	  && !(fh->get_access () & GENERIC_WRITE))
d1062 1
a1062 1
         the file isn't explicitely opened with EXECUTE access. */
d1064 1
a1064 1
        {
d1122 1
a1122 1
	         Check if file has been opened for writing, otherwise
d1151 1
a1151 1
         a valid address, of MAP_FAILED in case of a fatal error. */
d1153 1
a1153 1
        {
d1436 1
a1436 1
        {
d1493 1
a1493 1
 
d1522 1
a1522 1
        ret = 0;
d1612 1
a1612 1
         This has two advantages:
d1700 1
a1700 1
         due to a non-writable target address.  The protection is
d1733 1
a1733 1
  				   prot, flags, off);
d1831 1
a1831 1
  			  prot, flags | MAP_ANONYMOUS, off);
d1835 1
a1835 1
        __seterrno ();
d1837 1
a1837 1
        {
d1925 1
a1925 1
	        {
d1940 1
a1940 1
	        {
d1942 1
a1942 1
		  		 "address %p, %E", address);
d1949 1
a1949 1
	         a strange notion how copy-on-write is supposed to work. */
d1954 1
a1954 1
		      			MEM_COMMIT, PAGE_READWRITE))
d2002 1
a2002 1
		  		 "address %p, "
@


1.122
log
@	* mmap.cc (fhandler_dev_zero::fixup_mmap_after_fork): Use
	system_printf like any other fixup_mmap_after_fork.
@
text
@d1632 1
a1632 1
	      VirtualFree (base, len, MEM_RELEASE);
d1674 1
a1674 1
    VirtualFree (addr, len, MEM_RELEASE);
@


1.121
log
@	* mmap.cc (gen_create_protect): Always generate WRITECOPY protection
	for private maps.
	(fixup_mmaps_after_fork): Fix calculation of WRITECOPY protection for
	VirtualProtect.  Add some words to the comment.
@
text
@d1711 3
a1713 3
      debug_printf ("requested %p != %p mem alloc base %p, state %p, "
		    "size %d, %E", address, base, m.AllocationBase, m.State,
		    m.RegionSize);
@


1.120
log
@	* exceptions.cc (_cygtls::handle_exceptions): In case of a
	STATUS_ACCESS_VIOLATION, check if the page is a mmaped page beyond
	a file's EOF.  Generate SIGBUS instead of SIGSEGV then.
	* mmap.cc (__PROT_ATTACH): New define.
	(__PROT_FILLER): Ditto.
	(fh_anonymous): Rename from fh_paging_file;
	(fh_disk_file): New global static variable.
	(attached): New inline function.
	(filler): Ditto.
	(gen_create_protect): Split off from gen_protect to use the file's
	access mode to create mapping always with maximum allowed protections.
	(gen_protect): Accomodate pages attached beyond EOF.  Use symbolic
	values instead of numerics when possible.  Drop create parameter.
	(gen_access): Use file's access mode instead of protection.
	(CreateMapping9x): Create named mapping names so that different
	creation access modes result in different mappings.
	(CreateMappingNT): Only reserve attached pages, don't commit them.
	(MapViewNT): Ditto.  Set AT_ROUND_TO_PAGE for all non-NULL base
	addresses.
	(mmap_func_t): Define CreateMapping and MapView function pointers
	with additional openflags parameter.
	(class mmap_record): Add openflags member.
	(mmap_record::mmap_record): Add openflags parameter.
	(mmap_record::get_openflags): New accessor.
	(mmap_record::attached): Call global attached function.
	(mmap_record::filler): Call global filler function.
	(mmap_record::gen_create_protect): Call global gen_create_protect
	function.
	(mmap_record::gen_protect): Drop create parameter.
	(mmap_record::alloc_fh): Set fhandler's access flags.
	(list::search_record): Accomodate filler pages.
	(list::set): Use inode number as hash value.
	(map::get_list_by_fd): Check hash value against file's inode number.
	(mmap_is_attached_page): New function to evaluate if a given address
	is on a attached page.  Called from _cygtls::handle_exceptions.
	(mmap_worker): New function to do mapping and bookkeeping in a
	single call.
	(mmap64): Use roundup2 to round length to pagesize alignment.
	Initialize global fhandlers.  Simplify anonymous initialization.
	Add SUSv3 compatible check of file open mode vs. requested protection.
	Try creating new file handles to allow maximum page protection.
	Allow creating attached pages in case of mapping beyond EOF.
	Close new file handle if one has been created.
	(munmap): Align len to pagesize.
	(msync): Rework argument checks. Align len to pagesize.
	(mprotect): Ditto.  Accomodate attached pages.
	(mlock): Use roundup/rounddown macros instead of homemade expressions.
	(munlock): Add page alignment as in mlock.
	(fhandler_dev_zero::munmap): Fix unmapping of non-private mappings.
	(fhandler_dev_zero::fixup_mmap_after_fork): Accomodate filler pages.
	(fixup_mmaps_after_fork): Don't fail if attached pages couldn't be
	created in child.  Avoid superfluous call to VirtualFree.  Check for
	original allocation protection to fix PAGE_WRITECOPY protection.
	* ntdll.h: Revert deletion of AT_ROUND_TO_PAGE define.
	* winsup.h (mmap_is_attached_page): Declare.
@
text
@d101 4
a104 2
  if (openflags & GENERIC_WRITE)
    ret = priv (flags) ? PAGE_WRITECOPY : PAGE_READWRITE;
d1968 2
a1969 1
		  else if ((mbi.AllocationProtect & PAGE_WRITECOPY)
d1972 6
a1977 7
		    {
		      /* A PAGE_WRITECOPY page which has been written to is
			 set to PAGE_READWRITE, but that's an incompatible
			 protection to set the page to. */
		      mbi.Protect &= ~PAGE_READWRITE;
		      mbi.Protect |= PAGE_WRITECOPY;
		    }
@


1.119
log
@Remove unneeded whitespace.
* cygtls.cc (_cygtls::set_state): Delete.
(_cygtls::reset_exception): Ditto.
(_cygtls::init_thread): Set initialized state directly here.
(_cygtls::push): Remove exception argument.  Don't treat exceptions specially.
* cygtls.h (_cygtls::push): Ditto.
(_cygtls::isinitialized): Don't treat exceptions specially.
(_cygtls::reset_exception): Delete.
(_cygtls::set_state): Ditto.
(_cygtls::handle_exceptions): Don't push ebp on the stack prior to calling
sig_send.  Just set incyg instead.
(_cygtls::interrupt_setup): Accommodate _cygtls::push argument change.
(_cygtls::interrupt_now): Ditto.
(setup_handler): Don't treat exceptions specially.
* gendef (longjmp): Always zero incyg flag.
@
text
@d17 1
d28 11
d48 4
a51 2
/* Used for accessing the page file (anonymous mmaps). */
static fhandler_dev_zero fh_paging_file;
d84 28
d114 1
a114 1
gen_protect (int prot, int flags, bool create = false)
d117 9
a125 15
  /* When creating a private map/section, the protection must be set to
     PAGE_WRITECOPY, otherwise the page protection can't be set to
     PAGE_WRITECOPY in later calls to VirtualProtect.  This does not
     hold for private anonymous maps, since these are mapped using
     VirtualAlloc.  The PAGE_WRITECOPY protection is never used for
     them. */
  if (create && priv (flags) && !anonymous (flags))
    ret = PAGE_WRITECOPY;
  else if (prot & PROT_WRITE)
    {
      /* Windows doesn't support write without read. */
      ret <<= 2;
      if (priv (flags) && !anonymous (flags))
	ret <<= 1;
    }
d127 2
a128 1
    ret <<= 1;
d133 1
d141 1
a141 1
gen_access (int prot, int flags)
d143 1
a143 1
  DWORD ret = 0;
d146 1
a146 1
  else if (prot & PROT_WRITE)
a147 2
  else if (prot & PROT_READ)
    ret = FILE_MAP_READ;
d186 2
a187 2
CreateMapping9x (HANDLE fhdl, size_t len, _off64_t off, int prot, int flags,
		 const char *name)
d192 1
a192 1
  DWORD protect = gen_protect (prot, flags, true);
d215 15
a229 1
      DWORD access = gen_access (prot, flags);
d231 1
a231 2
	h = CreateFileMapping (fhdl, &sec_none, protect, 0, 0,
			       namebuf);
d264 2
a265 2
CreateMappingNT (HANDLE fhdl, size_t len, _off64_t off, int prot, int flags,
		 const char *)
d271 2
a272 2
  ULONG protect = gen_protect (prot, flags, true);
  ULONG attributes = SEC_COMMIT;	/* For now! */
d317 2
a318 1
MapView9x (HANDLE h, void *addr, size_t len, int prot, int flags, _off64_t off)
d322 1
a322 1
  DWORD access = gen_access (prot, flags);
d342 2
a343 1
MapViewNT (HANDLE h, void *addr, size_t len, int prot, int flags, _off64_t off)
d347 1
a347 1
  DWORD protect = gen_protect (prot, flags, true);
d349 3
a351 1
  ULONG size = len;
d356 2
a357 2
  ret = NtMapViewOfSection (h, GetCurrentProcess (), &base, 0, size, &offset,
			    &size, ViewShare, 0, protect);
d361 2
a362 2
      ret = NtMapViewOfSection (h, GetCurrentProcess (), &base, 0, size,
      				&offset, &size, ViewShare, 0, protect);
d376 3
a378 2
  HANDLE (*CreateMapping)(HANDLE, size_t, _off64_t, int, int, const char*);
  void * (*MapView)(HANDLE, void *, size_t, int, int, _off64_t);
d429 1
d439 1
a439 1
    mmap_record (int nfd, HANDLE h, int p, int f, _off64_t o, DWORD l,
d443 1
d462 1
d469 2
d486 5
a490 3

    DWORD gen_protect (bool create = false) const
      { return ::gen_protect (get_prot (), get_flags (), create); }
d492 1
a492 1
      { return ::gen_access (get_prot (), get_flags ()); }
d573 1
a573 1
  DWORD start_protect = gen_protect (true);
d680 3
a682 2
      fh_paging_file.set_io_handle (INVALID_HANDLE_VALUE);
      return &fh_paging_file;
d690 3
a692 1
  return build_fh_dev (get_device ());
d757 5
a761 2
      high = recs[i].get_address ()
	     + (PAGE_CNT (recs[i].get_len ()) * getpagesize ());
d778 8
a785 1
    hash = cygheap->fdtab[fd]->get_namehash ();
d856 10
a865 7
    /* The fd isn't sufficient since it could already be the fd of another
       file.  So we use the name hash value to identify the file unless
       it's an anonymous mapping in which case the fd (-1) is sufficient. */
    if ((fd == -1 && lists[i].anonymous ())
	|| (fd != -1
	    && lists[i].get_hash () == cygheap->fdtab[fd]->get_namehash ()))
      return lists + i;
d900 50
d958 3
a960 1
  mmap_record *rec;
d964 4
d970 1
a970 1
  /* Error conditions.  Note that the addr%pagesize test is deferred
d977 1
a977 1
      || (fixed (flags) && ((DWORD)addr % pagesize))
d994 1
a994 1
  if (fixed (flags) && ((DWORD) addr % checkpagesize))
d1000 1
a1000 3
  if (anonymous (flags))
    fd = -1;
  else if (fd != -1)
a1006 1
      /* Convert /dev/zero mapping to MAP_ANONYMOUS mapping. */
d1008 2
d1011 1
a1011 5
	{
	  /* mmap /dev/zero is like MAP_ANONYMOUS. */
	  fd = -1;
	  flags |= MAP_ANONYMOUS;
	}
d1013 1
a1013 3
  /* Don't use anonymous() here since that doesn't catch the fd == -1 case
     with no MAP_ANONYMOUS flags set. */
  if (fd == -1)
d1015 2
a1016 4
      fh_paging_file.set_io_handle (INVALID_HANDLE_VALUE);
      fh = &fh_paging_file;
      /* Anonymous mappings are always forced to pagesize length. */
      len = PAGE_CNT (len) * pagesize;
d1018 3
d1025 58
a1082 1
      /* File mappings needs some extra care. */
d1087 1
a1087 1
      /* Don't allow mappings beginning beyond EOF since Windows can't
d1089 1
a1089 2
	 mimics Windows behaviour.  FIXME: Still looking for a good idea
	 to allow that under POSIX rules. */
d1092 12
a1103 2
	  set_errno (ENXIO);
	  goto out;
a1104 3
      /* Don't map beyond EOF.  Windows would change the file to the
	 new length otherwise, in contrast to POSIX.  Allow mapping
	 beyond EOF if MAP_AUTOGROW flag is set. */
d1106 9
d1119 3
a1121 1
	      /* Check if file has been opened for writing. */
d1129 2
d1140 3
a1142 1
  list *map_list = mmapped_areas.get_list_by_fd (fd);
d1159 1
a1159 1
      && fixed (flags) && ((DWORD) addr % pagesize))
d1165 2
a1166 3
  caddr_t base = (caddr_t)addr;
  HANDLE h = fh->mmap (&base, len, prot, flags, off);
  if (h == INVALID_HANDLE_VALUE)
d1169 1
a1169 6
  /* At this point we should have a successfully mmapped area.
     Now it's time for bookkeeping stuff. */

  /* Get list of mmapped areas for this fd, create a new one if
     one does not exist yet.  */
  if (!map_list && !(map_list = mmapped_areas.add_list (fd)))
d1171 17
a1187 4
      fh->munmap (h, base, len);
      set_errno (ENOMEM);
      goto out;
    }
d1189 26
a1214 10
  /* Insert into the list */
  {
    mmap_record mmap_rec (fd, h, prot, flags, off, len, base);
    rec = map_list->add_record (mmap_rec);
  }
  if (!rec)
    {
      fh->munmap (h, base, len);
      set_errno (ENOMEM);
      goto out;
d1222 4
d1250 3
a1252 3
  DWORD checkpagesize = wincap.has_mmap_alignment_bug () ?
  			getsystempagesize () : getpagesize ();
  if (((DWORD) addr % checkpagesize) || !len)
d1257 1
a1307 2
  syscall_printf ("addr %x, len %u, flags %x", addr, len, flags);

d1311 2
d1315 6
a1320 3
  /* However, check flags for validity. */
  if ((flags & ~(MS_ASYNC | MS_SYNC | MS_INVALIDATE))
      || ((flags & MS_ASYNC) && (flags & MS_SYNC)))
d1325 1
d1369 2
d1374 1
a1374 1
  syscall_printf ("mprotect (addr %x, len %u, prot %x)", addr, len, prot);
d1376 9
a1384 2
  bool in_mapped = false;
  bool ret = false;
d1405 2
a1418 2
	     ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK,
				  "mprotect");
d1420 1
a1420 2
	     syscall_printf ("-1 = mprotect (), %E");
	     return -1;
d1432 2
a1433 1
      if (!VirtualQuery (addr, &mbi, sizeof mbi))
d1435 15
a1449 3
	  __seterrno ();
	  syscall_printf ("-1 = mprotect (), %E");
	  return -1;
a1450 16

      /* If write protection is requested, check if the page was
	 originally protected writecopy.  In this case call VirtualProtect
	 requesting PAGE_WRITECOPY, otherwise the VirtualProtect will fail
	 on NT version >= 5.0 */
      if (prot & PROT_WRITE)
	{
	  if (mbi.AllocationProtect == PAGE_WRITECOPY
	      || mbi.AllocationProtect == PAGE_EXECUTE_WRITECOPY)
	    flags = MAP_PRIVATE;
	}
      new_prot = gen_protect (prot, flags);
      if (new_prot != PAGE_NOACCESS && mbi.State == MEM_RESERVE)
	ret = VirtualAlloc (addr, len, MEM_COMMIT, new_prot);
      else
	ret = VirtualProtect (addr, len, new_prot, &old_prot);
d1452 1
a1452 5
	{
	  __seterrno ();
	  syscall_printf ("-1 = mprotect (), %E");
	  return -1;
	}
d1455 4
a1458 2
  syscall_printf ("0 = mprotect ()");
  return 0;
a1468 4
  /* Note that we're using getpagesize, not getsystempagesize.  This way, the
     alignment matches the notion the application has of the page size. */
  size_t pagesize = getpagesize ();

d1478 3
a1480 3
  PVOID base = (PVOID) ((uintptr_t) addr & ~(pagesize - 1));
  ULONG size = ((uintptr_t) addr - (uintptr_t) base) + len;
  size = (size + pagesize - 1) & ~(pagesize - 1);
d1491 1
a1491 1

d1539 4
a1542 2
  PVOID base = (PVOID) addr;
  ULONG size = len;
d1607 1
a1607 1
  if (priv (flags))
d1640 2
a1641 2
      h = mmap_func->CreateMapping (get_handle (), len, off, prot, flags,
				    get_name ());
d1649 1
a1649 1
      base = mmap_func->MapView (h, *addr, len, prot, flags, off);
d1671 7
a1677 1
  VirtualFree (addr, len, MEM_RELEASE);
d1694 1
a1694 1
  if (priv (flags))
d1703 2
a1704 1
    base = mmap_func->MapView (h, address, size, prot, flags, offset);
d1721 2
a1722 2
  HANDLE h = mmap_func->CreateMapping (get_handle (), len, off, prot, flags,
				       get_name ());
d1730 2
a1731 1
  void *base = mmap_func->MapView (h, *addr, len, prot, flags, off);
d1775 2
a1776 1
  void *base = mmap_func->MapView (h, address, size, prot, flags, offset);
d1828 2
a1829 1
  void *base = MapViewNT (h, *addr, len, prot, flags | MAP_ANONYMOUS, off);
d1872 1
a1872 1
  void *base = MapViewNT (h, address, size, prot,
d1921 8
a1928 1
	    return -1;
d1943 1
a1943 1
	      /* Set reserved pages to reserved in child. */
d1945 1
a1945 4
	        {
		  VirtualFree (address, mbi.RegionSize, MEM_DECOMMIT);
		  continue;
		}
d1966 1
a1966 1
		  else if (!rec->anonymous ()
@


1.118
log
@	* mmap.cc: Make debug output more consistently.  Fix some comments.
	(gen_protect): Convert to inline function.
	(gen_access): Ditto.
	(mmap_record::gen_protect): Add create parameter as in global function.
	(mmap_record::alloc_page_map): Change condition so that always the
	correct protection setting is set after mapping has been established.
	(mmap64): For anonymous mappings set offset always to 0.
	(fixup_mmaps_after_fork): Always call fixup_mmap_after_fork method
	with the MAP_FIXED flag set.
@
text
@d329 1
a329 1
mmap_func_t mmap_funcs_9x = 
d337 1
a337 1
mmap_func_t mmap_funcs_nt = 
d427 1
a427 1
    
d1141 1
a1141 1
 
d1255 1
a1255 1
	     
d1718 1
a1718 1
		      /* A PAGE_WRITECOPY page which has been written to is 
@


1.117
log
@	* mmap.cc (list::try_map): New method, implementing trying to map
	within another already existing map, moved from mmap64 here.
	(mmap64): Just call try_map now.
	(fhandler_dev_zero::fixup_mmap_after_fork): Always create new private
	map with PAGE_READWRITE protection.
	(fixup_mmaps_after_fork): Fix comment.
@
text
@d71 1
a71 1
static DWORD
d102 1
a102 1
static DWORD
d305 1
a305 1
  if (!NT_SUCCESS (ret) && addr  && !fixed (flags))
d316 2
a317 2
  debug_printf ("%x = NtMapViewOfSection (h:%x, addr:%x 0, len:%u, off:%D, "
		"protect:%x,)", base, h, addr, len, off, protect);
d428 2
a429 2
    DWORD gen_protect () const
      { return ::gen_protect (get_prot (), get_flags ()); }
d472 1
a472 2
/* This is the global map structure pointer.  It's allocated once on the
   first call to mmap64(). */
d512 9
a520 1
  DWORD old_prot;
a521 6
  DWORD protect = gen_protect ();
  if (protect != PAGE_WRITECOPY && priv () && !anonymous ()
      && !VirtualProtect (get_address (), len * getpagesize (),
      			  protect, &old_prot))
    syscall_printf ("VirtualProtect(%x,%D,%d) failed, %E",
		    get_address (), len * getpagesize ());
d590 1
a590 1
    syscall_printf ("VirtualFree in unmap_pages () failed, %E");
d593 1
a593 1
    syscall_printf ("VirtualProtect in unmap_pages () failed, %E");
d894 1
d1394 1
a1394 1
	      syscall_printf ("VirtualAlloc: address shift with MAP_FIXED given");
d1407 1
a1407 1
	  syscall_printf ("CreateMapping failed with %E");
d1420 1
a1420 1
	      syscall_printf ("MapView: address shift with MAP_FIXED given");
a1424 1

d1464 3
a1466 3
      system_printf ("requested %p != %p mem alloc base %p, state %p, "
		     "size %d, %E", address, base, m.AllocationBase, m.State,
		     m.RegionSize);
d1481 1
a1481 1
      syscall_printf ("CreateMapping failed with %E");
d1494 1
a1494 1
	  syscall_printf ("MapView: address shift with MAP_FIXED given");
d1550 1
a1550 1
      syscall_printf ("-1 = mmap(): illegal parameter, set EINVAL");
d1577 1
a1577 1
      syscall_printf ("-1 = mmap(): NtOpenSection failed with %E");
d1590 1
a1590 1
	  syscall_printf ("MapView: address shift with MAP_FIXED given");
d1624 2
a1625 1
  void *base = MapViewNT (h, address, size, prot, flags | MAP_ANONYMOUS, offset);
d1657 5
a1661 4
	  debug_printf ("fd %d, h %x, access %x, offset %D, size %u, "
	  		"address %p", rec->get_fd (), rec->get_handle (),
			rec->gen_access (), rec->get_offset (),
			rec->get_len (), rec->get_address ());
d1666 1
a1666 1
						rec->get_flags (),
@


1.116
log
@	* fhandler.h (fhandler_dev_zero::mmap): Add method.
	(fhandler_dev_zero::munmap): Ditto.
	(fhandler_dev_zero::msync): Ditto.
	(fhandler_dev_zero::fixup_mmap_after_fork): Ditto.
	* mmap.cc: Implement anonymous mapping using fhandler_dev_zero class.
	Implement private anonymous maps using VirtualAlloc/VirtualFree.  Fix
	or add some more comments.
	(fh_paging_file): Change to type fhandler_dev_zero.
	(priv): New static inline function to avoid having lots of flag bit
	tests in the code.  Use throughout were appropriate.
	(fixed): Ditto.
	(anonymous): Ditto.
	(noreserve): Ditto.
	(autogrow): Ditto.
	(gen_protect): Never generate PAGE_WRITECOPY protection for
	private anonymous maps.
	(gen_access): Drop FILE_MAP_EXECUTE handling since it's not supported
	correctly on 9x.
	(VirtualProt9x): Move comment from mmap64 here.
	(mmap_record::mmap_record): Gegerate correct device entry for
	anonymous maps, though unused right now.
	(mmap_record::priv): Call global priv function.
	(mmap_record::fixed): Call global fixed function.
	(mmap_record::anonymous): Call global anonymous function.
	(mmap_record::noreserve): Call global noreserve function.
	(mmap_record::autogrow): Call global autogrow function.
	(list::anonymous): New method.  Use throughout were appropriate.
	(mmap_record::compatible_flags): Drop now useless ifdef.
	(mmap_record::alloc_page_map): Accomodate private anonymous maps.
	(mmap_record::map_pages): Accomodate MAP_NORESERVE mappings.
	(mmap_record::unmap_pages): Accomodate private anonymous maps.
	(mmap64): Simplify argument check.  Don't remove the MAP_PRIVATE flag
	for anonymous mappings on 9x anymore since that's now handled
	gracefully.
	(mprotect): Accomodate MAP_NORESERVE mappings.  Fix case when
	non-mmap areas are just MEM_RESERVEd.
	(fhandler_dev_zero::mmap): Implement anonymous mapping here.
	(fhandler_dev_zero::munmap): Ditto.
	(fhandler_dev_zero::msyn): Ditto.
	(fhandler_dev_zero::fixup_mmap_after_fork): Ditto.
	(fixup_mmaps_after_fork): Accomodate private anonymous maps.  Enhance
	debug output in case VirtualProtect fails.
	* include/sys/mman.h: Really define MAP_NORESERVE now.
@
text
@d456 1
d730 46
d940 7
a946 40
      if (off == 0 && !fixed (flags))
	{
	  /* If MAP_FIXED isn't given, check if this mapping matches into the
	     chunk of another already performed mapping. */
	  if ((rec = map_list->search_record (off, len)) != NULL
	      && rec->compatible_flags (flags))
	    {
	      if ((off = rec->map_pages (off, len)) == (_off64_t)-1)
		goto out;
	      ret = rec->get_address () + off;
	      goto out;
	    }
	}
      else if (fixed (flags))
	{
	  /* If MAP_FIXED is given, test if the requested area is in an
	     unmapped part of an still active mapping.  This can happen
	     if a memory region is unmapped and remapped with MAP_FIXED. */
	  caddr_t u_addr;
	  DWORD u_len;
	  long record_idx = -1;
	  if ((record_idx = map_list->search_record ((caddr_t)addr, len,
						     u_addr, u_len,
						     record_idx)) >= 0)
	    {
	      rec = map_list->get_record (record_idx);
	      if (u_addr > (caddr_t)addr || u_addr + len < (caddr_t)addr + len
		  || !rec->compatible_flags (flags))
		{
		  /* Partial match only, or access mode doesn't match. */
		  /* FIXME: Handle partial mappings gracefully if adjacent
		     memory is available. */
		  set_errno (EINVAL);
		  goto out;
		}
	      if (!rec->map_pages ((caddr_t)addr, len))
		goto out;
	      ret = (caddr_t)addr;
	      goto out;
	    }
a1450 1
      DWORD protect = gen_protect (prot, flags);
d1452 4
a1455 1
      base = VirtualAlloc (address, size, alloc_type, protect);
d1738 1
a1738 2
	      /* Set child page protection to parent protection if
	         protection differs from original protection. */
@


1.115
log
@	* autoload.cc (NtCreateSection): Define.
	* cygheap.cc (_csbrk): Call getpagesize instead of getshmlba.
	* dcrt0.cc (dll_crt0_0): Call mmap_init.
	* external.cc (cygwin_internal): Call getpagesize instead of getshmlba.
	* fhandler.h (fhandler_base::mmap): Change access to prot parameter.
	(fhandler_base::fixup_mmap_after_fork): Ditto.
	(fhandler_disk_file::mmap): Ditto.
	(fhandler_disk_file::fixup_mmap_after_fork): Ditto.
	(fhandler_dev_mem::mmap): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::write): Call getsystempagesize
	instead of getpagesize.
	(fhandler_dev_mem::read): Ditto.
	(fhandler_dev_mem::fstat): Ditto.
	(fhandler_dev_mem::mmap): Move to mmap.cc.
	(fhandler_dev_mem::munmap): Ditto.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_proc.cc (format_proc_meminfo): Call getsystempagesize
	instead of getpagesize.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(get_mem_values): Ditto.
	* mmap.cc: Fix formatting.  Try to make more readable and modular.
	Take advantage of pagesize==granularity.
	(gen_protect): New static function to evaluate Windows
	protection bits from POSIX protection and flags.
	(gen_access): Ditto for Windows access mode.
	(VirtualProt9x): Wrapper function to call VirtualProtect on 9x.
	(VirtualProtNT): Ditto for NT.
	(VirtualProtEx9x): Ditto for VirtualProtectEx on 9x.
	(VirtualProtExNT): Ditto for NT.
	(CreateMapping9x): Wrapper function for creating a mapping handle on 9x.
	(CreateMappingNT): Ditto for NT.
	(MapView9x): Wrapper function to map a view on 9x.
	(MapViewNT): Ditto for NT.
	(mmap_funcs_9x): Structure containing function pointers to wrapper
	functions for 9x.
	(mmap_funcs_nt): Ditto for NT.
	(mmap_func): Pointer to wrapper functions used in subsequent code.
	(mmap_init): Initialize mmap_func depending on OS.
	(class mmap_record): Use sensible member names.  Add POSIX protection
	member. Drop Windows access flags member.  Constify more methods.
	Use accessors instead of direct member access inside of own methods.
	(mmap_record::gen_protect): Class wrapper to evaluate matching
	Windows protection bits.
	(mmap_record::gen_access): Ditto for Windows access flags.
	(mmap_record::compatible_flags): New function to check if flags are
	compatible with flags of existing map.
	(list::add_record): Drop offset and length arguments.
	(class map): Change counters to unsigned.  Match usage throughout.
	(mmapped_areas): Convert from pointer to global struct.
	(mmap_record::alloc_page_map): Simplify.
	(mmap_record::map_pages): Ditto.
	(mmap_record::fixup_page_map): Delete.
	(mmap64): Simplify.  Add workaround for Windows 98 bug.  Fix bug on
	NT that existing anonymous mappings weren't searched for a match.
	(munmap): Add workaround for Windows 98 bug.
	(msync): Simplify.
	(mprotect): Handle existing maps correctly.
	(mlock): Add local pagesize variable and enlightening comment.
	(fhandler_disk_file::mmap): Main functionality now in CreateMapping/
	MapView wrapper functions.
	(fhandler_disk_file::fixup_mmap_after_fork): Call MapView wrapper.
	(fhandler_dev_mem::mmap): Moved from fhandler_mem.cc.  Simplify by
	calling MapViewNT.
	(fhandler_dev_mem::munmap): Moved from fhandler_mem.cc.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.  Call MapViewNT.
	(fixup_mmaps_after_fork): Restructure and hopefully speed up loop for
	setting protection and memory content on MAP_PRIVATE maps.
	* ntdll.h (AT_ROUND_TO_PAGE): Remove define.
	(AT_EXTENDABLE_FILE): Add define.
	(NtCreateSection): Add prototype.
	* syscalls.cc (getpagesize): Return granularity as pagesize now.
	(getsystempagesize): New function to retrieve "real" pagesize.
	(getshmlba): Delete since it's replaced by getpagesize now.
	* wincap.h (wincaps::has_mmap_alignment_bug): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (getshmlba): Drop prototype.
	(getsystempagesize): Add prototype.
	(mmap_init): Ditto.
	* include/sys/mman.h: (Not yet) define MAP_NORESERVE.
@
text
@d37 32
a68 1
static fhandler_disk_file fh_paging_file;
d75 7
a81 4
  /* When creating a map/section and MAP_PRIVATE is requested, the protection
     must be set to PAGE_WRITECOPY, otherwise the page protection can't be set
     to PAGE_WRITECOPY in later calls to VirtualProtect. */
  if (create && (flags & MAP_PRIVATE))
d87 1
a87 1
      if (flags & MAP_PRIVATE)
d99 3
a101 5
#ifndef FILE_MAP_EXECUTE
#define FILE_MAP_EXECUTE SECTION_MAP_EXECUTE
#endif

/* Generate Windows access flags from mmap prot and flag values. */
d106 1
a106 1
  if (flags & MAP_PRIVATE)
a107 3
  else if ((prot & PROT_EXEC)
	   && wincap.virtual_protect_works_on_shared_pages ())
    ret = FILE_MAP_EXECUTE;
d109 1
a109 1
    ret = (flags & MAP_PRIVATE) ? FILE_MAP_COPY : FILE_MAP_WRITE;
d115 1
d158 11
a168 4
  /* On 9x/ME try first to open the mapping by name when opening a
     shared file object. This is needed since 9x/ME only shares
     objects between processes by name. What a mess... */
  if (fhdl != INVALID_HANDLE_VALUE && !(flags & MAP_PRIVATE))
d189 1
a189 1
  else if (flags & MAP_AUTOGROW)
d235 1
a235 1
  else if (flags & MAP_AUTOGROW)
d283 1
a283 1
      if (!base && !(flags & MAP_FIXED))
d305 1
a305 1
  if (!NT_SUCCESS (ret) && addr  && !(flags & MAP_FIXED))
d398 2
d407 5
a411 1
    bool priv () const { return (flags & MAP_PRIVATE) == MAP_PRIVATE; }
d448 1
a477 1
#ifdef MAP_NORESERVE
a478 3
#else
#define MAP_COMPATMASK	(MAP_TYPE)
#endif
d515 1
a515 1
  if (protect != PAGE_WRITECOPY && priv ()
d538 3
a540 2
  if (!VirtualProtect (get_address () + off * getpagesize (),
		       len * getpagesize (), gen_protect (), &old_prot))
d566 3
a568 2
  if (!VirtualProtect (get_address () + off * getpagesize (),
		       len * getpagesize (), gen_protect (), &old_prot))
d585 7
a591 3
  if (!VirtualProtect (get_address () + off * getpagesize (),
		       len * getpagesize (), PAGE_NOACCESS, &old_prot))
    syscall_printf ("-1 = unmap_pages (), %E");
d615 1
a615 1
  if (get_fd () == -1)
d632 1
a632 1
  if (get_fd () != -1)
d663 1
a663 1
  if (fd == -1 && !off)
d707 2
a708 1
  if ((fd = nfd) != -1)
d737 1
a737 1
    if ((fd == -1 && lists[i].get_fd () == -1)
d793 2
a794 2
      || (!(flags & MAP_SHARED) && !(flags & MAP_PRIVATE))
      || ((flags & MAP_SHARED) && (flags & MAP_PRIVATE))
d796 1
a796 1
      || ((flags & MAP_FIXED) && ((DWORD)addr % pagesize))
d813 1
a813 1
  if ((flags & MAP_FIXED) && ((DWORD) addr % checkpagesize))
d819 1
a819 1
  if (flags & MAP_ANONYMOUS)
a820 1
  /* Get fhandler and convert /dev/zero mapping to MAP_ANONYMOUS mapping. */
d828 1
d837 2
d847 1
a847 3

  /* File mappings needs some extra care. */
  if (!(flags & MAP_ANONYMOUS) && fh->get_device () == FH_FS)
d849 1
d858 1
a858 1
      if (off >= fsiz && !(flags & MAP_AUTOGROW))
d869 1
a869 1
	  if ((flags & MAP_AUTOGROW))
d884 1
a884 1
      if ((flags & MAP_AUTOGROW) && (off + len) <= fsiz)
a887 13
  /* copy-on-write doesn't work at all on 9x using anonymous maps.
     Workaround: Anonymous mappings always use normal READ or WRITE
		 access and don't use named file mapping.
     copy-on-write also doesn't work properly on 9x with real files.
     While the changes are not propagated to the file, they are
     visible to other processes sharing the same file mapping object.
     Workaround: Don't use named file mapping.  That should work since
		 sharing file mappings only works reliable using named
		 file mapping on 9x.
  */
  if ((flags & MAP_PRIVATE) && !wincap.has_working_copy_on_write () && fd == -1)
    flags &= ~MAP_PRIVATE;

d891 1
a891 1
  if (map_list && (flags & MAP_ANONYMOUS))
d893 1
a893 1
      if (off == 0 && !(flags & MAP_FIXED))
d906 1
a906 1
      else if ((flags & MAP_FIXED))
d938 1
a938 1
      && (flags & MAP_FIXED) && ((DWORD) addr % pagesize))
d1144 10
a1153 1
	 if (!(ret = VirtualProtect (addr, len, new_prot, &old_prot)))
d1169 8
d1184 3
a1186 7
	  MEMORY_BASIC_INFORMATION mbi;
	  if (VirtualQuery (addr, &mbi, sizeof mbi))
	    {
	      if (mbi.AllocationProtect == PAGE_WRITECOPY
		  || mbi.AllocationProtect == PAGE_EXECUTE_WRITECOPY)
		flags = MAP_PRIVATE;
	    }
d1189 5
a1193 1
      if (!VirtualProtect (addr, len, new_prot, &old_prot) == 0)
d1344 110
d1469 1
a1469 1
  if (!base || ((flags & MAP_FIXED) && base != *addr))
d1565 1
a1565 1
  if (!base || ((flags & MAP_FIXED) && base != *addr))
d1679 8
d1695 10
a1704 5
		  else if (mbi.Protect == PAGE_READWRITE)
		    /* A PAGE_WRITECOPY page which has been written to is 
		       set to PAGE_READWRITE, but that's in incomatible
		       protection to set the page to. */
		    mbi.Protect = PAGE_WRITECOPY;
d1722 2
a1723 1
	      /* Set child page protection to parent protection. */
d1727 2
d1730 7
a1736 1
		  		 "address %p, %E", address);
@


1.114
log
@	* autoload.cc (NtLockVirtualMemory): Import.
	(NtUnlockVirtualMemory): Import.
	(GetProcessWorkingSetSize): Import.
	(SetProcessWorkingSetSize): Import.
	* cygwin.din (mlock): Export.
	(munlock): Export.
	* mmap.cc (mlock): New function.
	(munlock): Ditto.
	* ntdll.h (STATUS_WORKING_SET_QUOTA): Define.
	(LOCK_VM_IN_WSL): Define.
	(LOCK_VM_IN_RAM): Define.
	(NtLockVirtualMemory): Declare.
	(NtUnlockVirtualMemory): Declare.
	* sysconf.cc (sysconf): Implement _SC_MEMLOCK_RANGE.
	* wincap.h: Implement has_working_virtual_lock throughout.
	* wincap.cc: Ditto.
	* include/cygwin/version.h: Bump API minor version.
	* include/sys/mman.h (mlock): Declare,
	(munlock): Declare.
@
text
@d32 3
a34 3
#define MAP_SET(n)	(page_map_[(n)/PGBITS] |= (1L << ((n) % PGBITS)))
#define MAP_CLR(n)	(page_map_[(n)/PGBITS] &= ~(1L << ((n) % PGBITS)))
#define MAP_ISSET(n)	(page_map_[(n)/PGBITS] & (1L << ((n) % PGBITS)))
d39 277
d336 8
a343 8
    int fdesc_;
    HANDLE mapping_handle_;
    DWORD access_mode_;
    int flags_;
    _off64_t offset_;
    DWORD size_to_map_;
    caddr_t base_address_;
    DWORD *page_map_;
d347 1
a347 1
    mmap_record (int fd, HANDLE h, DWORD ac, int f, _off64_t o, DWORD s,
d349 8
a356 8
       fdesc_ (fd),
       mapping_handle_ (h),
       access_mode_ (ac),
       flags_ (f),
       offset_ (o),
       size_to_map_ (s),
       base_address_ (b),
       page_map_ (NULL)
d363 2
a364 2
    int get_fd () const { return fdesc_; }
    HANDLE get_handle () const { return mapping_handle_; }
d366 9
a374 9
    DWORD get_access () const { return access_mode_; }
    DWORD get_flags () const { return flags_; }
    _off64_t get_offset () const { return offset_; }
    DWORD get_size () const { return size_to_map_; }
    caddr_t get_address () const { return base_address_; }

    bool alloc_page_map (_off64_t off, DWORD len);
    void free_page_map () { if (page_map_) cfree (page_map_); }
    void fixup_page_map ();
d376 1
a376 1
    DWORD find_unused_pages (DWORD pages);
d384 6
d406 1
a406 1
    mmap_record *add_record (mmap_record r, _off64_t off, DWORD len);
d418 1
a418 2
    int nlists, maxlists;
    caddr_t next_anon_addr;
d421 1
a421 1
    list *get_list (int i) { return i >= nlists ? NULL : lists + i; }
d424 1
a424 3
    void del_list (int i);
    caddr_t get_next_anon_addr () { return next_anon_addr; }
    void set_next_anon_addr (caddr_t addr) { next_anon_addr = addr; }
d429 12
a440 1
static map *mmapped_areas;
d443 1
a443 1
mmap_record::find_unused_pages (DWORD pages)
d445 1
a445 1
  DWORD mapped_pages = PAGE_CNT (size_to_map_);
d464 1
a464 1
mmap_record::alloc_page_map (_off64_t off, DWORD len)
d467 3
a469 3
  if (!(page_map_ = (DWORD *) ccalloc (HEAP_MMAP,
				       MAPSIZE (PAGE_CNT (size_to_map_)),
				       sizeof (DWORD))))
d472 8
a479 21
  off -= offset_;
  len = PAGE_CNT (len);

  if (wincap.virtual_protect_works_on_shared_pages ())
    {
      DWORD old_prot;
      DWORD vlen = len * getpagesize ();

      if (off > 0 &&
	  !VirtualProtect (base_address_, off, PAGE_NOACCESS, &old_prot))
	syscall_printf ("VirtualProtect(%x,%D) failed, %E", base_address_, off);
      if (off + vlen < size_to_map_
	  && !VirtualProtect (base_address_ + off + vlen,
			      size_to_map_ - vlen - off,
			      PAGE_NOACCESS, &old_prot))
	syscall_printf ("VirtualProtect(%x,%D) failed, %E",
			base_address_ + off + vlen, size_to_map_ - vlen - off);
    }

  off /= getpagesize ();

d481 1
a481 1
    MAP_SET (off + len);
d492 2
a493 15
  DWORD prot, old_prot;
  switch (access_mode_)
    {
    case FILE_MAP_WRITE:
      prot = PAGE_READWRITE;
      break;
    case FILE_MAP_READ:
      prot = PAGE_READONLY;
      break;
    default:
      prot = PAGE_WRITECOPY;
      break;
    }

  debug_printf ("map_pages (fd=%d, off=%D, len=%u)", fdesc_, off, len);
d498 2
a499 3
  if (wincap.virtual_protect_works_on_shared_pages ()
      && !VirtualProtect (base_address_ + off * getpagesize (),
			  len * getpagesize (), prot, &old_prot))
d514 2
a515 2
  DWORD prot, old_prot;
  DWORD off = addr - base_address_;
d525 2
a526 15
  switch (access_mode_)
    {
    case FILE_MAP_WRITE:
      prot = PAGE_READWRITE;
      break;
    case FILE_MAP_READ:
      prot = PAGE_READONLY;
      break;
    default:
      prot = PAGE_WRITECOPY;
      break;
    }
  if (wincap.virtual_protect_works_on_shared_pages ()
      && !VirtualProtect (base_address_ + off * getpagesize (),
			  len * getpagesize (), prot, &old_prot))
d540 1
a540 1
  DWORD off = addr - base_address_;
d543 2
a544 3
  if (wincap.virtual_protect_works_on_shared_pages ()
      && !VirtualProtect (base_address_ + off * getpagesize (),
			  len * getpagesize (), PAGE_NOACCESS, &old_prot))
d551 2
a552 2
  for (len = MAPSIZE (PAGE_CNT (size_to_map_)); len > 0; )
    if (page_map_[--len])
a556 25
void
mmap_record::fixup_page_map ()
{
  if (!wincap.virtual_protect_works_on_shared_pages ())
    return;

  DWORD prot, old_prot;
  switch (access_mode_)
    {
    case FILE_MAP_WRITE:
      prot = PAGE_READWRITE;
      break;
    case FILE_MAP_READ:
      prot = PAGE_READONLY;
      break;
    default:
      prot = PAGE_WRITECOPY;
      break;
    }

  for (DWORD off = PAGE_CNT (size_to_map_); off > 0; --off)
    VirtualProtect (base_address_ + (off - 1) * getpagesize (), getpagesize (),
		    MAP_ISSET (off - 1) ? prot : PAGE_NOACCESS, &old_prot);
}

d560 1
a560 1
  if (address < base_address_ || address >= base_address_ + size_to_map_)
d562 1
a562 1
  DWORD off = (address - base_address_) / getpagesize ();
d591 1
a591 1
list::add_record (mmap_record r, _off64_t off, DWORD len)
d608 1
a608 1
  if (!recs[nrecs].alloc_page_map (off, len))
d629 1
a629 1
			 + (PAGE_CNT (recs[i].get_size ()) * getpagesize ()))
d646 1
a646 1
	     + (PAGE_CNT (recs[i].get_size ()) * getpagesize ());
d685 2
a686 2
  int i;
  for (i=0; i<nlists; i++)
d717 1
a717 1
map::del_list (int i)
d734 5
a738 1
  DWORD granularity = getshmlba ();
d740 6
a745 2
  /* Error conditions according to SUSv2 */
  if (off % getpagesize ()
d748 3
a750 1
      || ((flags & MAP_FIXED) && ((DWORD)addr % getpagesize ()))
d754 1
a754 2
      syscall_printf ("-1 = mmap(): EINVAL");
      return MAP_FAILED;
d757 10
a766 3
  SetResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");

  if (mmapped_areas == NULL)
d768 2
a769 9
      /* First mmap call, create STL map */
      mmapped_areas = (map *) ccalloc (HEAP_MMAP, 1, sizeof (map));
      if (mmapped_areas == NULL)
	{
	  set_errno (ENOMEM);
	  syscall_printf ("-1 = mmap(): ENOMEM");
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
	  return MAP_FAILED;
	}
a773 3

  fhandler_base *fh = NULL;

d775 1
a775 1
  if (fd != -1)
d780 2
a781 5
	{
	  syscall_printf ("-1 = mmap(): EBADF");
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
	  return MAP_FAILED;
	}
d794 3
a796 16
    }

  /* 9x only: If MAP_FIXED is requested on a non-granularity boundary,
     change request so that this looks like a request with offset
     addr % granularity. */
  if (wincap.share_mmaps_only_by_name () && fd == -1 && (flags & MAP_FIXED)
      && ((DWORD)addr % granularity) && !off)
    off = (DWORD)addr % granularity;
  /* Map always in multipliers of `granularity'-sized chunks.
     Not necessary for anonymous maps on NT. */
  _off64_t gran_off = off;
  DWORD gran_len = len;
  if (wincap.share_mmaps_only_by_name () || fd != -1)
    {
      gran_off = off & ~(granularity - 1);
      gran_len = howmany (off + len, granularity) * granularity - gran_off;
d800 1
a800 1
  if (fd != -1 && fh->get_device () == FH_FS)
d810 1
a810 1
      if (gran_off >= fsiz && !(flags & MAP_AUTOGROW))
d813 1
a813 3
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
			       "mmap");
	  return MAP_FAILED;
d817 3
a819 3
	 beyon EOF if MAP_AUTOGROW flag is set. */
      fsiz -= gran_off;
      if (gran_len > fsiz)
d821 1
a821 1
	  if ((flags & MAP_AUTOGROW) && (off - gran_off) + len > fsiz)
d827 1
a827 3
		  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				       "mmap");
		  return MAP_FAILED;
a828 1
	      gran_len = (off - gran_off) + len;
d831 1
a831 1
	    gran_len = fsiz;
d833 2
a834 1
      /* If the requested len is <= file size, drop the MAP_AUTOGROW flag.
d836 1
a836 1
      if ((flags & MAP_AUTOGROW) && gran_len <= fsiz)
a839 1
  DWORD access = (prot & PROT_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ;
d843 1
a843 1
     copy-on-write doesn't also work properly on 9x with real files.
d850 8
a857 12
  if ((flags & MAP_PRIVATE)
      && (wincap.has_working_copy_on_write () || fd != -1))
    access = FILE_MAP_COPY;

  list *map_list = mmapped_areas->get_list_by_fd (fd);

  /* A bit of memory munging on 9x. */
  if (map_list && fd == -1 && wincap.share_mmaps_only_by_name ())
    {
      /* First check if this mapping matches into the chunk of another
	 already performed mapping. Only valid for MAP_ANON in a special
	 case of MAP_PRIVATE. */
d860 2
a861 1
	  mmap_record *rec;
d863 1
a863 1
	      && rec->get_access () == access)
d866 3
a868 11
		{
		  syscall_printf ("-1 = mmap()");
		  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK|WRITE_LOCK,
				       "mmap");
		  return MAP_FAILED;
		}
	      caddr_t ret = rec->get_address () + off;
	      syscall_printf ("%x = mmap() succeeded", ret);
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				   "mmap");
	      return ret;
d871 1
a871 1
      if ((flags & MAP_FIXED))
d873 3
d883 1
a883 1
	      mmap_record *rec = map_list->get_record (record_idx);
d885 1
a885 1
		  || rec->get_access () != access)
d891 1
a891 4
		  syscall_printf ("-1 = mmap()");
		  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				       "mmap");
		  return MAP_FAILED;
d894 3
a896 11
		{
		  syscall_printf ("-1 = mmap()");
		  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				       "mmap");
		  return MAP_FAILED;
		}
	      caddr_t ret = (caddr_t)addr;
	      syscall_printf ("%x = mmap() succeeded", ret);
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				   "mmap");
	      return ret;
d901 8
d910 1
a910 7
  /* This shifts the base address to the next lower 64K boundary.
     The offset is re-added when evaluating the return value. */
  if (base)
    base -= off - gran_off;

  HANDLE h = fh->mmap (&base, gran_len, access, flags, gran_off);

d912 1
a912 4
    {
      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
      return MAP_FAILED;
    }
a915 3
  if (fd == -1)
    gran_len = PAGE_CNT (gran_len) * getpagesize ();
  mmap_record mmap_rec (fd, h, access, flags, gran_off, gran_len, base);
d918 2
a919 3
     one does not exist yet.
  */
  if (!map_list)
d921 4
a924 11
      /* Create a new one */
      map_list = mmapped_areas->add_list (fd);
      if (!map_list)
	{
	  fh->munmap (h, base, gran_len);
	  set_errno (ENOMEM);
	  syscall_printf ("-1 = mmap(): ENOMEM");
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
	  return MAP_FAILED;
	}
  }
d927 4
a930 2
  mmap_record *rec = map_list->add_record (mmap_rec, off,
					   len > gran_len ? gran_len : len);
d933 1
a933 1
      fh->munmap (h, base, gran_len);
d935 1
a935 3
      syscall_printf ("-1 = mmap(): ENOMEM");
      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
      return MAP_FAILED;
d938 4
a941 2
  caddr_t ret = rec->get_address () + (off - gran_off);
  syscall_printf ("%x = mmap() succeeded", ret);
d943 1
d961 9
a969 2
  if (!addr || ((DWORD)addr % getpagesize ()) || !len
      || check_invalid_virtual_addr (addr, len))
a971 1
      syscall_printf ("-1 = munmap(): Invalid parameters");
a975 6
  if (mmapped_areas == NULL)
    {
      syscall_printf ("-1 = munmap(): mmapped_areas == NULL");
      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
      return 0;
    }
d980 2
a981 2
  for (int list_idx = 0;
       (map_list = mmapped_areas->get_list (list_idx));
d999 1
a999 1
			  rec->get_size ());
d1007 1
a1007 1
		  mmapped_areas->del_list (list_idx--);
d1026 5
a1034 10
      syscall_printf ("-1 = msync(): Invalid flags");
      set_errno (EINVAL);
      return -1;
    }

  SetResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
  /* Check if a mmap'ed area was ever created */
  if (mmapped_areas == NULL)
    {
      syscall_printf ("-1 = msync(): mmapped_areas == NULL");
d1036 1
a1036 2
      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
      return -1;
d1041 2
a1042 4

  list *map_list;
  for (int list_idx = 0;
       (map_list = mmapped_areas->get_list (list_idx));
d1055 4
a1058 1
		  goto invalid_address_range;
d1060 1
a1060 2
	      int ret = fh->msync (rec->get_handle (), (caddr_t)addr, len,
				   flags);
d1062 1
a1062 9

	      if (ret)
		syscall_printf ("%d = msync(), %E", ret);
	      else
		syscall_printf ("0 = msync()");

	      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK,
				   "msync");
	      return 0;
d1067 1
a1067 2
invalid_address_range:
  /* SUSv2: Return code if indicated memory was not mapped is ENOMEM. */
a1068 1
  syscall_printf ("-1 = msync(): ENOMEM");
d1070 2
d1073 1
a1073 1
  return -1;
d1086 2
a1087 6
  if (!wincap.virtual_protect_works_on_shared_pages ()
      && addr >= (caddr_t)0x80000000 && addr <= (caddr_t)0xBFFFFFFF)
    {
      syscall_printf ("0 = mprotect (9x: No VirtualProtect on shared memory)");
      return 0;
    }
d1089 53
a1141 9
  /* If write protection is requested, check if the page was
     originally protected writecopy.  In this case call VirtualProtect
     requesting PAGE_WRITECOPY, otherwise the VirtualProtect will fail
     on NT version >= 5.0 */
  bool writecopy = false;
  if (prot & PROT_WRITE)
    {
      MEMORY_BASIC_INFORMATION mbi;
      if (VirtualQuery (addr, &mbi, sizeof mbi))
d1143 3
a1145 3
	  if (mbi.AllocationProtect == PAGE_WRITECOPY
	      || mbi.AllocationProtect == PAGE_EXECUTE_WRITECOPY)
	    writecopy = true;
a1148 35
  switch (prot)
    {
      case PROT_READ | PROT_WRITE | PROT_EXEC:
      case PROT_WRITE | PROT_EXEC:
	new_prot = writecopy ? PAGE_EXECUTE_WRITECOPY : PAGE_EXECUTE_READWRITE;
	break;
      case PROT_READ | PROT_WRITE:
      case PROT_WRITE:
	new_prot = writecopy ? PAGE_WRITECOPY : PAGE_READWRITE;
	break;
      case PROT_READ | PROT_EXEC:
	new_prot = PAGE_EXECUTE_READ;
	break;
      case PROT_READ:
	new_prot = PAGE_READONLY;
	break;
      case PROT_EXEC:
	new_prot = PAGE_EXECUTE;
	break;
      case PROT_NONE:
	new_prot = PAGE_NOACCESS;
	break;
      default:
	syscall_printf ("-1 = mprotect (): invalid prot value");
	set_errno (EINVAL);
	return -1;
     }

  if (VirtualProtect (addr, len, new_prot, &old_prot) == 0)
    {
      __seterrno ();
      syscall_printf ("-1 = mprotect (), %E");
      return -1;
    }

d1161 4
d1174 1
a1174 1
  PVOID base = (PVOID) ((uintptr_t) addr & ~(getpagesize () - 1));
d1176 1
a1176 1
  size = (size + getpagesize () - 1) & ~(getpagesize () - 1);
d1200 2
a1201 2
	    min = size + 12 * getpagesize ();	/* Evaluated by testing */
	  else if (size < 65536)
d1204 1
a1204 1
	    min += 65536;
d1262 1
a1262 1
fhandler_base::mmap (caddr_t *addr, size_t len, DWORD access,
d1284 1
a1284 1
fhandler_base::fixup_mmap_after_fork (HANDLE h, DWORD access, int flags,
d1292 1
a1292 1
/* Implementation for disk files. */
d1294 1
a1294 1
fhandler_disk_file::mmap (caddr_t *addr, size_t len, DWORD access,
d1297 2
a1298 66
  DWORD protect;

  switch (access)
    {
      case FILE_MAP_WRITE:
	protect = PAGE_READWRITE;
	break;
      case FILE_MAP_READ:
	protect = PAGE_READONLY;
	break;
      default:
	protect = PAGE_WRITECOPY;
	break;
    }

  HANDLE h;
  DWORD high, low;

  /* On 9x/ME try first to open the mapping by name when opening a
     shared file object. This is needed since 9x/ME only shares
     objects between processes by name. What a mess... */
  if (wincap.share_mmaps_only_by_name ()
      && get_handle () != INVALID_HANDLE_VALUE
      && !(access & FILE_MAP_COPY))
    {
      /* Grrr, the whole stuff is just needed to try to get a reliable
	 mapping of the same file. Even that uprising isn't bullet
	 proof but it does it's best... */
      char namebuf[CYG_MAX_PATH];
      cygwin_conv_to_full_posix_path (get_name (), namebuf);
      for (int i = strlen (namebuf) - 1; i >= 0; --i)
	namebuf[i] = cyg_tolower (namebuf [i]);

      debug_printf ("named sharing");
      if (!(h = OpenFileMapping (access, TRUE, namebuf)))
	h = CreateFileMapping (get_handle (), &sec_none, protect, 0, 0,
			       namebuf);
    }
  else if (get_handle () == INVALID_HANDLE_VALUE)
    {
      /* Standard anonymous mapping needs non-zero len. */
      h = CreateFileMapping (get_handle (), &sec_none, protect, 0, len, NULL);
    }
  else if (flags & MAP_AUTOGROW)
    {
      high = (off + len) >> 32;
      low = (off + len) & UINT32_MAX;
      /* Auto-grow in CreateFileMapping only works if the protection is
	 PAGE_READWRITE.  So, first we call CreateFileMapping with
	 PAGE_READWRITE, then, if the requested protection is different, we
	 close the mapping and reopen it again with the correct protection,
	 *iff* auto-grow worked. */
      h = CreateFileMapping (get_handle (), &sec_none, PAGE_READWRITE,
			     high, low, NULL);
      if (h && protect != PAGE_READWRITE)
	{
	  CloseHandle (h);
	  h = CreateFileMapping (get_handle (), &sec_none, protect,
				 high, low, NULL);
	}
    }
  else
    {
      /* Zero len creates mapping for whole file. */
      h = CreateFileMapping (get_handle (), &sec_none, protect, 0, 0, NULL);
    }
d1302 1
a1302 1
      syscall_printf ("-1 = mmap(): CreateFileMapping failed with %E");
d1306 1
a1306 29
  high = off >> 32;
  low = off & UINT32_MAX;
  void *base = NULL;
  /* If a non-zero address is given, try mapping using the given address first.
     If it fails and flags is not MAP_FIXED, try again with NULL address. */
  if (!wincap.share_mmaps_only_by_name ()
      && get_handle () == INVALID_HANDLE_VALUE)
    {
      PHYSICAL_ADDRESS phys;
      phys.QuadPart = (ULONGLONG) off;
      ULONG ulen = len;
      base = *addr ?: (void *) mmapped_areas->get_next_anon_addr ();
      NTSTATUS ret = NtMapViewOfSection (h, INVALID_HANDLE_VALUE, &base, 0L,
					 ulen, &phys, &ulen, ViewShare,
					 base ? AT_ROUND_TO_PAGE : 0, protect);
      if (ret != STATUS_SUCCESS)
	{
	  __seterrno_from_nt_status (ret);
	  base = NULL;
	}
      else
	mmapped_areas->set_next_anon_addr ((caddr_t) base + len);
    }
  else if (*addr)
    base = MapViewOfFileEx (h, access, high, low, len, *addr);
  if (!base && !(flags & MAP_FIXED))
    base = MapViewOfFileEx (h, access, high, low, len, NULL);
  debug_printf ("%x = MapViewOfFileEx (h:%x, access:%x, 0, off:%D, "
		"len:%u, addr:%x)", base, h, access, off, len, *addr);
d1310 1
a1310 4
	{
	  __seterrno ();
	  syscall_printf ("-1 = mmap(): MapViewOfFileEx failed with %E");
	}
d1313 1
d1315 1
a1315 1
	  syscall_printf ("-1 = mmap(): address shift with MAP_FIXED given");
d1345 1
a1345 1
fhandler_disk_file::fixup_mmap_after_fork (HANDLE h, DWORD access, int flags,
d1349 55
a1403 3
  /* Re-create the MapViewOfFileEx call */
  void *base;
  if (!wincap.share_mmaps_only_by_name () && (flags & MAP_ANONYMOUS))
d1405 7
a1411 16
      PHYSICAL_ADDRESS phys;
      phys.QuadPart = (ULONGLONG) offset;
      ULONG ulen = size;
      base = address;
      DWORD protect;
      switch (access)
	{
	  case FILE_MAP_WRITE:
	    protect = PAGE_READWRITE;
	    break;
	  case FILE_MAP_READ:
	    protect = PAGE_READONLY;
	    break;
	  default:
	    protect = PAGE_WRITECOPY;
	    break;
d1413 16
a1428 5
      NTSTATUS ret = NtMapViewOfSection (h, INVALID_HANDLE_VALUE, &base, 0L,
					 ulen, &phys, &ulen, ViewShare,
					 AT_ROUND_TO_PAGE, protect);
      if (ret != STATUS_SUCCESS)
	__seterrno_from_nt_status (ret);
d1430 16
a1445 2
  else
    base = MapViewOfFileEx (h, access, 0, offset, size, address);
d1450 3
a1452 2
      system_printf ("requested %p != %p mem alloc base %p, state %p, size %d, %E",
		     address, base, m.AllocationBase, m.State, m.RegionSize);
d1457 5
a1461 8
/*
 * Call to re-create all the file mappings in a forked
 * child. Called from the child in initialization. At this
 * point we are passed a valid mmapped_areas map, and all the
 * HANDLE's are valid for the child, but none of the
 * mapped areas are in our address space. We need to iterate
 * through the map, doing the MapViewOfFile calls.
 */
a1465 7

  debug_printf ("recreate_mmaps_after_fork, mmapped_areas %p", mmapped_areas);

  /* Check if a mmapped area was ever created */
  if (mmapped_areas == NULL)
    return 0;

d1468 2
a1469 2
  for (int list_idx = 0;
       (map_list = mmapped_areas->get_list (list_idx));
d1477 4
a1480 4

	  debug_printf ("fd %d, h %x, access %x, offset %D, size %u, address %p",
	      rec->get_fd (), rec->get_handle (), rec->get_access (),
	      rec->get_offset (), rec->get_size (), rec->get_address ());
d1484 1
a1484 1
						rec->get_access (),
d1487 1
a1487 1
						rec->get_size (),
d1493 7
a1499 1
	  if (rec->get_access () == FILE_MAP_COPY)
d1501 54
a1554 59
	      for (char *address = rec->get_address ();
		   address < rec->get_address () + rec->get_size ();
		   address += getpagesize ())
		if (rec->access (address)
		    && !ReadProcessMemory (parent, address, address,
					   getpagesize (), NULL))
		  {
		    DWORD old_prot;
		    DWORD last_error = GetLastError ();

		    if (last_error != ERROR_PARTIAL_COPY
			&& last_error != ERROR_NOACCESS
			|| !wincap.virtual_protect_works_on_shared_pages ())
		      {
			system_printf ("ReadProcessMemory failed for "
				       "MAP_PRIVATE address %p, %E",
				       rec->get_address ());
			return -1;
		      }
		    if (!VirtualProtectEx (parent,
					   address, getpagesize (),
					   PAGE_READONLY, &old_prot))
		      {
			system_printf ("VirtualProtectEx failed for "
				       "MAP_PRIVATE address %p, %E",
				       rec->get_address ());
			return -1;
		      }
		    else
		      {
			BOOL ret;
			DWORD dummy_prot;

			ret = ReadProcessMemory (parent, address, address,
						 getpagesize (), NULL);
			if (!VirtualProtectEx(parent,
					      address, getpagesize (),
					      old_prot, &dummy_prot))
			  system_printf ("WARNING: VirtualProtectEx to "
					 "return to previous state "
					 "in parent failed for "
					 "MAP_PRIVATE address %p, %E",
					 rec->get_address ());
			if (!VirtualProtect (address, getpagesize (),
					     old_prot, &dummy_prot))
			  system_printf ("WARNING: VirtualProtect to copy "
					 "protection to child failed for"
					 "MAP_PRIVATE address %p, %E",
					 rec->get_address ());
			if (!ret)
			  {
			    system_printf ("ReadProcessMemory (2nd try) "
					   "failed for "
					   "MAP_PRIVATE address %p, %E",
					   rec->get_address ());
			    return -1;
			  }
		      }
		  }
a1555 1
	  rec->fixup_page_map ();
@


1.113
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d980 92
@


1.112
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d1206 1
a1206 1
      (void) VirtualQuery (address, &m, sizeof (m));
@


1.111
log
@	* mmap.cc (mmap64): Make granularity an automatic variable.
@
text
@d97 1
a97 1
    void fixup_page_map (void);
@


1.110
log
@	* mmap.cc (mmap64): Avoid compiler warning.
	* ntea.cc (NTReadEA): Ditto.
	* hires.h (hires_base): Remove useless usecs function.
@
text
@d509 1
a509 1
  static DWORD granularity = getshmlba ();
@


1.109
log
@white space and minor comment cleanup.
@
text
@d541 1
a541 1
  fhandler_base *fh;
@


1.108
log
@	* cygerrno.h (__seterrno_from_nt_status): Define. Always set Win32
	error code as well as errno. Use throughout where errno is set from
	NT status.
	(set_errno): Evaluate val only once.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fix typo in
	debug output.
	* fhandler_mem.cc (fhandler_dev_mem::open): Rely on
	__seterrno_from_nt_status setting Win32 error code in debug output.
	* fhandler_proc.cc (format_proc_uptime): Ditto.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	* sysconf.cc (sysconf): Ditto.
@
text
@d258 1
a258 1
        set_errno (EINVAL);
d556 1
a556 1
        {
d603 1
a603 1
         new length otherwise, in contrast to POSIX.  Allow mapping
d607 1
a607 1
        {
d624 1
a624 1
         This simplifes fhandler::mmap's job. */
d626 1
a626 1
        flags &= ~MAP_AUTOGROW;
d678 1
a678 1
	  					     u_addr, u_len,
d1076 1
a1076 1
         PAGE_READWRITE.  So, first we call CreateFileMapping with
d1083 1
a1083 1
        {
d1113 1
a1113 1
      NTSTATUS ret = NtMapViewOfSection (h, INVALID_HANDLE_VALUE, &base, 0L, 
d1117 1
a1117 1
        {
d1195 1
a1195 1
      NTSTATUS ret = NtMapViewOfSection (h, INVALID_HANDLE_VALUE, &base, 0L, 
d1199 1
a1199 1
        __seterrno_from_nt_status (ret);
@


1.107
log
@	* mmap.cc (mmap64): Handle MAP_AUTOGROW flag.
	(fhandler_disk_file::mmap): Ditto. Clean conditional for readability.
	* include/sys/mman.h: Add MAP_AUTOGROW flag.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d1118 1
a1118 1
	  __seterrno_from_win_error (RtlNtStatusToDosError (ret));
d1199 1
a1199 1
        __seterrno_from_win_error (RtlNtStatusToDosError (ret));
@


1.106
log
@	* fhandler_clipboard.cc (fhandler_dev_clipboard::write): Never set
	errno to 0.
	(fhandler_dev_clipboard::read): Ditto.
	* fhandler_windows.cc (fhandler_windows::read): Ditto.
	* scandir.cc (scandir): Ditto.
	* syscalls.cc (_fstat64_r): Ditto.
	(_fstat_r): Ditto.
	(_stat64_r): Ditto.
	(_stat_r): Ditto.

	* mmap.cc (mmap64): Fix /dev/zero mapping.
@
text
@d590 1
d592 4
a595 3
	 handle that POSIX like.  FIXME: Still looking for a good idea
	 to allow that nevertheless. */
      if (gran_off >= fsiz)
d603 2
a604 1
         new length otherwise, in contrast to POSIX. */
d607 20
a626 1
	gran_len = fsiz;
d1044 1
d1063 25
a1087 1
	h = CreateFileMapping (get_handle (), &sec_none, protect, 0, 0, namebuf);
d1090 4
a1093 3
    h = CreateFileMapping (get_handle (), &sec_none, protect, 0,
			   get_handle () == INVALID_HANDLE_VALUE ? len : 0,
			   NULL);
d1101 2
a1102 1
  DWORD high = off >> 32, low = off & UINT32_MAX;
@


1.105
log
@	* fhandler.h (class fhandler_base): Declare fixup_mmap_after_fork
	with additional flags parameter.  Change offset parameter to _off64_t.
	(class fhandler_disk_file): Ditto.
	(class fhandler_dev_mem): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::fixup_mmap_after_fork):
	Accomodate new parameters.
	* mmap.cc: Include ntdll.h.
	(class mmap_record): Add flags member.
	(mmap_record::mmap_record): Add flags parameter.
	(mmap_record::get_flags): New method.
	(class map): Add next_anon_addr member to store next anonymous mapping
	address suggestion.
	(map::get_next_anon_addr): New method.
	(map::set_next_anon_addr): New method.
	(mmap64): Don't align offset and length to granularity in case of
	MAP_ANONYMOUS on NT.  Check for already existing mapping only on 9x.
	Call mmap_record::mmap_record with additional flags argument.
	(fhandler_base::fixup_mmap_after_fork): Accomodate new parameters.
	(fhandler_disk_file::mmap): Use NtMapViewOfSection with
	AT_ROUND_TO_PAGE flag for anonymous mappings on NT.  If addr is NULL,
	try to map adjacent to previous mapping.
	(fhandler_disk_file::fixup_mmap_after_fork): Add flags argument.
	Change offset parameter to _off64_t.  Use NtMapViewOfSection to
	re-create anonymous mappings on NT.
	(fixup_mmaps_after_fork): Accomodate new parameters when calling
	fhandler's fixup_mmaps_after_fork function.
	* ntdll.h (AT_ROUND_TO_PAGE): New define.
@
text
@a540 16
  /* 9x only: If MAP_FIXED is requested on a non-granularity boundary,
     change request so that this looks like a request with offset
     addr % granularity. */
  if (wincap.share_mmaps_only_by_name () && fd == -1 && (flags & MAP_FIXED)
      && ((DWORD)addr % granularity) && !off)
    off = (DWORD)addr % granularity;
  /* Map always in multipliers of `granularity'-sized chunks.
     Not necessary for anonymous maps on NT. */
  _off64_t gran_off = off;
  DWORD gran_len = len;
  if (wincap.share_mmaps_only_by_name () || fd != -1)
    {
      gran_off = off & ~(granularity - 1);
      gran_len = howmany (off + len, granularity) * granularity - gran_off;
    }

d543 1
d555 2
a556 21
      if (fh->get_device () == FH_FS)
	{
	  DWORD high;
	  DWORD low = GetFileSize (fh->get_handle (), &high);
	  _off64_t fsiz = ((_off64_t)high << 32) + low;
	  /* Don't allow mappings beginning beyond EOF since Windows can't
	     handle that POSIX like.  FIXME: Still looking for a good idea
	     to allow that nevertheless. */
	  if (gran_off >= fsiz)
	    {
	      set_errno (ENXIO);
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				   "mmap");
	      return MAP_FAILED;
	    }
	  fsiz -= gran_off;
	  if (gran_len > fsiz)
	    gran_len = fsiz;
	}
      else if (fh->get_device () == FH_ZERO)
	{
d568 39
@


1.104
log
@	* mmap.cc (mmap64): Handle MAP_FIXED request on non-granulation
	boundary.
@
text
@d25 1
d62 1
d70 2
a71 1
    mmap_record (int fd, HANDLE h, DWORD ac, _off64_t o, DWORD s, caddr_t b) :
d75 1
d90 1
d136 1
d143 2
d541 5
a545 3
  /* If MAP_FIXED is requested on a non-granularity boundary, change request
     so that this looks like a request with offset addr % granularity. */
  if (fd == -1 && (flags & MAP_FIXED) && ((DWORD)addr % granularity) && !off)
d547 9
a555 3
  /* Map always in multipliers of `granularity'-sized chunks. */
  _off64_t gran_off = off & ~(granularity - 1);
  DWORD gran_len = howmany (off + len, granularity) * granularity - gran_off;
d590 5
a594 2
	/* mmap /dev/zero is like MAP_ANONYMOUS. */
	fd = -1;
d619 2
a620 4
  /* First check if this mapping matches into the chunk of another
     already performed mapping. Only valid for MAP_ANON in a special
     case of MAP_PRIVATE. */
  if (map_list && fd == -1 && off == 0 && !(flags & MAP_FIXED))
d622 4
a625 3
      mmap_record *rec;
      if ((rec = map_list->search_record (off, len)) != NULL
          && rec->get_access () == access)
d627 3
a629 1
	  if ((off = rec->map_pages (off, len)) == (_off64_t)-1)
d631 12
a642 4
	      syscall_printf ("-1 = mmap()");
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK|WRITE_LOCK,
	      			   "mmap");
	      return MAP_FAILED;
a643 4
	  caddr_t ret = rec->get_address () + off;
	  syscall_printf ("%x = mmap() succeeded", ret);
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
	  return ret;
d645 1
a645 8
    }
  if (map_list && fd == -1 && (flags & MAP_FIXED))
    {
      caddr_t u_addr;
      DWORD u_len;
      long record_idx = -1;
      if ((record_idx = map_list->search_record ((caddr_t)addr, len, u_addr,
      						 u_len, record_idx)) >= 0)
d647 6
a652 3
	  mmap_record *rec = map_list->get_record (record_idx);
	  if (u_addr > (caddr_t)addr || u_addr + len < (caddr_t)addr + len
	      || rec->get_access () != access)
d654 22
a675 12
	      /* Partial match only, or access mode doesn't match. */
	      /* FIXME: Handle partial mappings gracefully if adjacent
	         memory is available. */
	      set_errno (EINVAL);
	      syscall_printf ("-1 = mmap()");
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				   "mmap");
	      return MAP_FAILED;
	    }
	  if (!rec->map_pages ((caddr_t)addr, len))
	    {
	      syscall_printf ("-1 = mmap()");
d678 1
a678 1
	      return MAP_FAILED;
a679 4
	  caddr_t ret = (caddr_t)addr;
	  syscall_printf ("%x = mmap() succeeded", ret);
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
	  return ret;
d701 1
a701 1
  mmap_record mmap_rec (fd, h, access, gran_off, gran_len, base);
d988 3
a990 2
fhandler_base::fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
				      DWORD size, void *address)
d1052 19
a1070 1
  if (*addr)
d1116 3
a1118 2
fhandler_disk_file::fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
					   DWORD size, void *address)
d1121 28
a1148 1
  void *base = MapViewOfFileEx (h, access, 0, offset, size, address);
d1197 1
@


1.103
log
@	* mmap.cc (class mmap_record): Declare new map_pages method with
	address parameter.
	(mmap_record::map_pages): New method with address parameter.
	(mmap64): Evaluate access mode before checking if already existing
	mapping can be used.
	Only use existing mapping if requested access mode matches the one
	in the existing mapping.
	Add check for existing mapping for MAP_FIXED case.
@
text
@d533 4
d622 1
a622 1
  if (map_list && fd == -1 && off == 0 && (flags & MAP_FIXED))
@


1.102
log
@copyright
@
text
@d96 1
d239 39
d579 15
d602 2
a603 1
      if ((rec = map_list->search_record (off, len)) != NULL)
d608 2
a609 1
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK|WRITE_LOCK, "mmap");
d618 34
a651 15

  DWORD access = (prot & PROT_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ;
  /* copy-on-write doesn't work at all on 9x using anonymous maps.
     Workaround: Anonymous mappings always use normal READ or WRITE
		 access and don't use named file mapping.
     copy-on-write doesn't also work properly on 9x with real files.
     While the changes are not propagated to the file, they are
     visible to other processes sharing the same file mapping object.
     Workaround: Don't use named file mapping.  That should work since
		 sharing file mappings only works reliable using named
		 file mapping on 9x.
  */
  if ((flags & MAP_PRIVATE)
      && (wincap.has_working_copy_on_write () || fd != -1))
    access = FILE_MAP_COPY;
@


1.101
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.100
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d16 1
a20 1
#include "cygerrno.h"
@


1.99
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d800 1
a800 1
        {
@


1.98
log
@	* mmap.cc (mmap_record::alloc_page_map): Mark pages as allocated even
	on Windows 9x, FWIW.
@
text
@d181 1
a181 1
	syscall_printf ("VirtualProtect(%x,%D) failed: %E", base_address_, off);
d186 1
a186 1
	syscall_printf ("VirtualProtect(%x,%D) failed: %E",
d246 1
a246 1
    syscall_printf ("-1 = unmap_pages (): %E");
d708 1
a708 2
  syscall_printf ("addr = %x, len = %u, flags = %x",
		  addr, len, flags);
d754 1
a754 1
		syscall_printf ("%d = msync(): %E", ret);
d838 1
a838 1
      syscall_printf ("-1 = mprotect (): %E");
@


1.97
log
@	* mmap.cc (mprotect): When MAP_WRITE protection is requested, use
	READWRITE or WRITECOPY protection, whatever has been used when the
	page has been allocated initially.
@
text
@d171 3
d177 1
a178 2
      off -= offset_;
      len = PAGE_CNT (len) * getpagesize ();
d182 3
a184 3
      if (off + len < size_to_map_
	  && !VirtualProtect (base_address_ + off + len,
			      size_to_map_ - len - off,
d187 1
a187 5
			base_address_ + off + len, size_to_map_ - len - off);
      off /= getpagesize ();
      len /= getpagesize ();
      while (len-- > 0)
	MAP_SET (off + len);
d189 5
@


1.96
log
@	* mmap.cc (class mmap_record): Fix return type of get_offset.
	(mmap_record::fixup_page_map): Fix off by one error.
	(list::search_record): Use long as type of "start" argument in both,
	declaration and definition.  Use long as type for local variable "i".
@
text
@d789 16
d809 1
a809 1
	new_prot = PAGE_EXECUTE_READWRITE;
d813 1
a813 1
	new_prot = PAGE_READWRITE;
@


1.95
log
@	* miscfuncs.cc (check_invalid_virtual_addr): Assure the last page
	in the range is always tested.  Add appropriate const.
	* mmap.cc (mmap_record::aloc_fh): Remove unused static path_conf object.
@
text
@d85 1
a85 1
    DWORD get_offset () const { return offset_; }
d276 1
a276 1
    VirtualProtect (base_address_ + off * getpagesize (), getpagesize (),
d361 1
a361 1
	     _off_t start)
d365 1
a365 1
  for (int i = start + 1; i < nrecs; ++i)
@


1.94
log
@	* miscfuncs.cc (check_invalid_virtual_addr): New function.
	* winsup.h (check_invalid_virtual_addr): Declare.
	* mmap.cc (munmap): Call check_invalid_virtual_addr instead of
	IsBadReadPtr.
@
text
@a297 1
  static path_conv pc; // should be thread safe - CGF
@


1.93
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d644 1
a644 1
      || IsBadReadPtr (addr, len))
@


1.92
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.91
log
@	Substitute 0x7fffffff and 0xffffffff by INT32_MAX and UINT32_MAX
	throughout, except in assembler code.
@
text
@d95 1
a95 1
    BOOL unmap_pages (caddr_t addr, DWORD len);
d233 1
a233 1
BOOL
d251 2
a252 2
      return FALSE;
  return TRUE;
d863 1
a863 1
BOOL
d972 1
a972 1
BOOL
d1024 1
a1024 1
	  BOOL ret = fh->fixup_mmap_after_fork (rec->get_handle (),
@


1.90
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d923 1
a923 1
  DWORD high = off >> 32, low = off & 0xffffffff;
@


1.89
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d42 1
a42 1
  
d44 1
a44 1
  
d321 1
a321 1
        new_recs = (mmap_record *)
d327 1
a327 1
        return NULL;
d428 1
a428 1
        new_lists = (list *) cmalloc (HEAP_MMAP, 5 * sizeof (list));
d432 1
a432 1
        return NULL;
d447 1
a447 1
        lists[i] = lists[i + 1];
d671 1
a671 1
      						   u_len, record_idx)) >= 0)
d677 1
a677 1
	         unmap it from the system in full length... */
d680 1
a680 1
	      		  rec->get_address (),
d738 1
a738 1
      	   (rec = map_list->get_record (record_idx));
d749 1
a749 1
	      			   flags);
d1015 1
a1015 1
      	   (rec = map_list->get_record (record_idx));
@


1.88
log
@	* syscalls.cc (getshmlba): New function.
	* external.cc (cygwin_internal): Add CW_GET_SHMLBA handling.
	* mmap.cc (mmap64): Call getshmlba to evaluate granularity.
	* winsup.h (getshmlba): Add declaration.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_SHMLBA.
@
text
@d903 1
a903 1
      char namebuf[MAX_PATH];
@


1.87
log
@	* mmap.cc (munmap): Use correct address and length parameters when
	calling fhandler's munmap.
@
text
@d458 1
a458 7
  static DWORD granularity;
  if (!granularity)
    {
      SYSTEM_INFO si;
      GetSystemInfo (&si);
      granularity = si.dwAllocationGranularity;
    }
@


1.86
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d682 2
a683 1
	      /* The whole record has been unmapped, so... */
d685 3
a687 1
	      fh->munmap (rec->get_handle (), (caddr_t)addr, len);
d690 1
a690 1
	      /* ...delete the record. */
@


1.85
log
@	* mmap.cc (mmap64): Change address types from caddr_t to void *
	according to SUSv3.
	(mmap): Ditto.
	(munmap): Ditto.
	(msync): Ditto.
	(mprotect): Ditto.  Move to before the fhandler methods.
	* include/sys/mman.h: Change prototypes accordingly.
@
text
@d17 1
a18 1
#include "path.h"
a58 1
    int devtype_;
d64 1
a69 1
       devtype_ (0),
d76 1
d78 1
a78 1
	  devtype_ = cygheap->fdtab[fd]->get_device ();
d83 1
a83 1
    DWORD get_device () const { return devtype_; }
d298 1
d304 1
a304 1
  return cygheap->fdtab.build_fhandler (-1, get_device ());
d513 1
a513 1
      if (fh->get_device () == FH_DISK)
@


1.84
log
@	* mmap.cc: Restructure. Add, remove and rewrite comments throughout
	for better readability.  Change function names for better
	understanding.
	(MAP_SET): Accomodate name change from map_map_ to page_map_.
	(MAP_CLR): Ditto.
	(MAP_ISSET): Ditto.
	(mmap_record::page_map_): Rename from page_map_.
	(mmap_record::get_map): Remove.
	(mmap_record::alloc_page_map): Rename from alloc_map. Return bool
	indicating success of cygheap memory allocation.
	(mmap_record::free_page_map): Rename from free_map.
	(mmap_record::fixup_page_map): Rename from fixup_map.
	(mmap_record::find_unused_pages): Rename from find_empty.
	(mmap_record::map_pages): Rename from map_map.
	(mmap_record::unmap_pages): Rename from unmap_map.
	(class list): Make all class members private.
	(list::list): Remove.
	(list::~list): Remove.
	(list::get_fd): New attribute reader.
	(list::get_hash): Ditto.
	(list::get_record): Ditto.
	(list::add_record): Manage all allocation for mmap_records.  Check
	for failed memory allocation and return NULL if so.
	(list::set): New function.
	(list::del_record): Rename from erase. Return true if last mmap_record
	has been deleted, false otherwise. Check for legal incoming index
	value.
	(list::erase): Remove erase/0.
	(list::search_record): Rename from match.
	(map::map): Remove.
	(map::~map): Remove.
	(map::add_list): Manage all allocation for lists.  Check for failed
	memory allocation and return NULL if so.
	(map::get_list): New method.
	(map::del_list): Rename from erase. Check for legal incoming index
	value.
	(mmap64): Check for failed mmap_record memory allocation.  Return
	with MAP_FAILED and errno set to ENOMEM if so.
	(munmap): Rearrange loop using new list and mmap_record accessor
	functions.  Rename loop index variables for better understanding.
	Check if list can be deleted after last mmap_record in it has been
	deleted.
	(msync): Rearrange loop using new list and mmap_record accessor
	functions.  Rename loop index variables for better understanding.
	(fixup_mmaps_after_fork): Ditto.
@
text
@d451 2
a452 2
extern "C" caddr_t
mmap64 (caddr_t addr, size_t len, int prot, int flags, int fd, _off64_t off)
d579 1
a579 1
  caddr_t base = addr;
d634 2
a635 2
extern "C" caddr_t
mmap (caddr_t addr, size_t len, int prot, int flags, int fd, _off_t off)
d643 1
a643 1
munmap (caddr_t addr, size_t len)
d675 1
a675 1
      while ((record_idx = map_list->search_record(addr, len, u_addr,
d683 1
a683 1
	      fh->munmap (rec->get_handle (), addr, len);
d706 1
a706 1
msync (caddr_t addr, size_t len, int flags)
d743 1
a743 1
	  if (rec->access (addr))
d747 1
a747 1
		if (!rec->access (addr + i))
d750 2
a751 1
	      int ret = fh->msync (rec->get_handle (), addr, len, flags);
d775 56
a987 56
}

/* Set memory protection */

extern "C" int
mprotect (caddr_t addr, size_t len, int prot)
{
  DWORD old_prot;
  DWORD new_prot = 0;

  syscall_printf ("mprotect (addr %x, len %u, prot %x)", addr, len, prot);

  if (!wincap.virtual_protect_works_on_shared_pages ()
      && addr >= (caddr_t)0x80000000 && addr <= (caddr_t)0xBFFFFFFF)
    {
      syscall_printf ("0 = mprotect (9x: No VirtualProtect on shared memory)");
      return 0;
    }

  switch (prot)
    {
      case PROT_READ | PROT_WRITE | PROT_EXEC:
      case PROT_WRITE | PROT_EXEC:
	new_prot = PAGE_EXECUTE_READWRITE;
	break;
      case PROT_READ | PROT_WRITE:
      case PROT_WRITE:
	new_prot = PAGE_READWRITE;
	break;
      case PROT_READ | PROT_EXEC:
	new_prot = PAGE_EXECUTE_READ;
	break;
      case PROT_READ:
	new_prot = PAGE_READONLY;
	break;
      case PROT_EXEC:
	new_prot = PAGE_EXECUTE;
	break;
      case PROT_NONE:
	new_prot = PAGE_NOACCESS;
	break;
      default:
	syscall_printf ("-1 = mprotect (): invalid prot value");
	set_errno (EINVAL);
	return -1;
     }

  if (VirtualProtect (addr, len, new_prot, &old_prot) == 0)
    {
      __seterrno ();
      syscall_printf ("-1 = mprotect (): %E");
      return -1;
    }

  syscall_printf ("0 = mprotect ()");
  return 0;
@


1.83
log
@* cygheap.h (enum cygheap_types): Add HEAP_MMAP.
(CYGHEAPSIZE): Add another 64K.
* mmap.cc: Use cmalloc, ccalloc and crealloc with HEAP_MMAP type throughout.
@
text
@d30 3
a32 3
#define MAP_SET(n)	(map_map_[(n)/PGBITS] |= (1L << ((n) % PGBITS)))
#define MAP_CLR(n)	(map_map_[(n)/PGBITS] &= ~(1L << ((n) % PGBITS)))
#define MAP_ISSET(n)	(map_map_[(n)/PGBITS] & (1L << ((n) % PGBITS)))
d34 19
a52 5
/*
 * Simple class used to keep a record of all current
 * mmap areas in a process. Needed so that
 * they can be duplicated after a fork().
 */
d64 1
a64 1
    DWORD *map_map_;
d75 1
a75 1
       map_map_ (NULL)
a80 3
    /* Default Copy constructor/operator=/destructor are ok */

    /* Simple accessors */
d88 8
a95 8
    DWORD *get_map () const { return map_map_; }
    void alloc_map (_off64_t off, DWORD len);
    void free_map () { if (map_map_) cfree (map_map_); }

    DWORD find_empty (DWORD pages);
    _off64_t map_map (_off64_t off, DWORD len);
    BOOL unmap_map (caddr_t addr, DWORD len);
    void fixup_map (void);
d102 39
d142 1
a142 1
mmap_record::find_empty (DWORD pages)
d162 2
a163 2
void
mmap_record::alloc_map (_off64_t off, DWORD len)
d166 5
a170 2
  map_map_ = (DWORD *) ccalloc (HEAP_MMAP, MAPSIZE (PAGE_CNT (size_to_map_)),
			        sizeof (DWORD));
d191 1
d195 1
a195 1
mmap_record::map_map (_off64_t off, DWORD len)
d200 1
a200 1
     Otherwise it's job is now done by alloc_map(). */
d215 1
a215 1
  debug_printf ("map_map (fd=%d, off=%D, len=%u)", fdesc_, off, len);
d218 1
a218 1
  if ((off = find_empty (len)) == (DWORD)-1)
d234 1
a234 1
mmap_record::unmap_map (caddr_t addr, DWORD len)
d243 1
a243 1
    syscall_printf ("-1 = unmap_map (): %E");
d250 1
a250 1
    if (map_map_[--len])
d256 1
a256 1
mmap_record::fixup_map ()
a288 2
static fhandler_disk_file fh_paging_file;

a312 29
class list {
public:
  mmap_record *recs;
  int nrecs, maxrecs;
  int fd;
  DWORD hash;
  list ();
  ~list ();
  mmap_record *add_record (mmap_record r, _off64_t off, DWORD len);
  void erase (int i);
  void erase ();
  mmap_record *match (_off64_t off, DWORD len);
  long match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
	      long start);
};

list::list ()
: nrecs (0), maxrecs (10), fd (0), hash (0)
{
  recs = (mmap_record *) cmalloc (HEAP_MMAP, 10 * sizeof (mmap_record));
}

list::~list ()
{
  for (mmap_record *rec = recs; nrecs-- > 0; ++rec)
    rec->free_map ();
  cfree (recs);
}

d318 9
d328 1
a328 1
      recs = (mmap_record *) crealloc (recs, maxrecs * sizeof (mmap_record));
d331 2
a332 1
  recs[nrecs].alloc_map (off, len);
d338 1
a338 1
list::match (_off64_t off, DWORD len)
d344 1
a344 1
	if (recs[i].find_empty (len) != (DWORD)-1)
d360 1
a360 1
list::match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
d382 1
a382 1
list::erase (int i)
d384 4
a387 4
  recs[i].free_map ();
  for (; i < nrecs-1; i++)
    recs[i] = recs[i+1];
  nrecs--;
d390 2
a391 2
void
list::erase ()
d393 10
a402 24
  erase (nrecs-1);
}

class map {
public:
  list **lists;
  int nlists, maxlists;
  map ();
  ~map ();
  list *get_list_by_fd (int fd);
  list *add_list (list *l, int fd);
  void erase (int i);
};

map::map ()
{
  lists = (list **) cmalloc (HEAP_MMAP, 10 * sizeof (list *));
  nlists = 0;
  maxlists = 10;
}

map::~map ()
{
  cfree (lists);
d410 7
a416 8
#if 0 /* The fd isn't sufficient since it could already be another file. */
    if (lists[i]->fd == fd
#else /* so we use the name hash value to identify the file unless
	 it's not an anonymous mapping. */
    if ((fd == -1 && lists[i]->fd == -1)
	|| (fd != -1 && lists[i]->hash == cygheap->fdtab[fd]->get_namehash ()))
#endif
      return lists[i];
d421 1
a421 1
map::add_list (list *l, int fd)
a422 3
  l->fd = fd;
  if (fd != -1)
    l->hash = cygheap->fdtab[fd]->get_namehash ();
d425 7
d433 1
a433 1
      lists = (list **) crealloc (lists, maxlists * sizeof (list *));
d435 2
a436 2
  lists[nlists++] = l;
  return lists[nlists-1];
d440 1
a440 1
map::erase (int i)
d442 7
a448 3
  for (; i < nlists-1; i++)
    lists[i] = lists[i+1];
  nlists--;
a450 10
/*
 * Code to keep a record of all mmap'ed areas in a process.
 * Needed to duplicate tham in a child of fork().
 * mmap_record classes are kept in an STL list in an STL map, keyed
 * by file descriptor. This is *NOT* duplicated across a fork(), it
 * needs to be specially handled by the fork code.
 */

static map *mmapped_areas;

d482 1
a482 1
      mmapped_areas = new map;
d549 1
a549 1
      if ((rec = map_list->match (off, len)) != NULL)
d551 1
a551 1
	  if ((off = rec->map_map (off, len)) == (_off64_t)-1)
d593 2
a594 3
  /* Now we should have a successfully mmapped area.
     Need to save it so forked children can reproduce it.
  */
d605 1
a605 1
      map_list = new list;
a613 1
      map_list = mmapped_areas->add_list (map_list, fd);
d617 11
a627 1
  mmap_record *rec = map_list->add_record (mmap_rec, off, len > gran_len ? gran_len : len);
d666 8
d675 2
a676 4
  for (int it = 0; it < mmapped_areas->nlists; ++it)
    {
      list *map_list = mmapped_areas->lists[it];
      if (map_list)
d678 7
a684 3
	  long li = -1;
	  caddr_t u_addr;
	  DWORD u_len;
d686 2
a687 4
	  while ((li = map_list->match(addr, len, u_addr, u_len, li)) >= 0)
	    {
	      mmap_record *rec = map_list->recs + li;
	      if (rec->unmap_map (u_addr, u_len))
d689 4
a692 6
		  fhandler_base *fh = rec->alloc_fh ();
		  fh->munmap (rec->get_handle (), addr, len);
		  rec->free_fh (fh);

		  /* Delete the entry. */
		  map_list->erase (li);
d733 4
a736 1
  for (int it = 0; it < mmapped_areas->nlists; ++it)
d738 4
a741 2
      list *map_list = mmapped_areas->lists[it];
      if (map_list != 0)
d743 1
a743 1
	  for (int li = 0; li < map_list->nrecs; ++li)
d745 16
a760 20
	      mmap_record *rec = map_list->recs + li;
	      if (rec->access (addr))
		{
		  /* Check whole area given by len. */
		  for (DWORD i = getpagesize (); i < len; ++i)
		    if (!rec->access (addr + i))
		      goto invalid_address_range;
		  fhandler_base *fh = rec->alloc_fh ();
		  int ret = fh->msync (rec->get_handle (), addr, len, flags);
		  rec->free_fh (fh);

		  if (ret)
		    syscall_printf ("%d = msync(): %E", ret);
		  else
		    syscall_printf ("0 = msync()");

		  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK,
				       "msync");
		  return 0;
		}
d1009 4
a1012 1
  for (int it = 0; it < mmapped_areas->nlists; ++it)
d1014 4
a1017 2
      list *map_list = mmapped_areas->lists[it];
      if (map_list)
d1019 16
a1034 2
	  int li;
	  for (li = 0; li < map_list->nrecs; ++li)
d1036 29
a1064 24
	      mmap_record *rec = map_list->recs + li;

	      debug_printf ("fd %d, h %x, access %x, offset %D, size %u, address %p",
		  rec->get_fd (), rec->get_handle (), rec->get_access (),
		  rec->get_offset (), rec->get_size (), rec->get_address ());

	      fhandler_base *fh = rec->alloc_fh ();
	      BOOL ret = fh->fixup_mmap_after_fork (rec->get_handle (),
						    rec->get_access (),
						    rec->get_offset (),
						    rec->get_size (),
						    rec->get_address ());
	      rec->free_fh (fh);

	      if (!ret)
		return -1;
	      if (rec->get_access () == FILE_MAP_COPY)
		{
		  for (char *address = rec->get_address ();
		       address < rec->get_address () + rec->get_size ();
		       address += getpagesize ())
		    if (rec->access (address)
			&& !ReadProcessMemory (parent, address, address,
					       getpagesize (), NULL))
d1066 2
a1067 2
			DWORD old_prot;
			DWORD last_error = GetLastError ();
d1069 17
a1085 3
			if (last_error != ERROR_PARTIAL_COPY
			    && last_error != ERROR_NOACCESS
			    || !wincap.virtual_protect_works_on_shared_pages ())
d1087 2
a1088 1
			    system_printf ("ReadProcessMemory failed for "
a1092 39
			if (!VirtualProtectEx (parent,
					       address, getpagesize (),
					       PAGE_READONLY, &old_prot))
			  {
			    system_printf ("VirtualProtectEx failed for "
					   "MAP_PRIVATE address %p, %E",
					   rec->get_address ());
			    return -1;
			  }
			else
			  {
			    BOOL ret;
			    DWORD dummy_prot;

			    ret = ReadProcessMemory (parent, address, address,
						     getpagesize (), NULL);
			    if (!VirtualProtectEx(parent,
						  address, getpagesize (),
						  old_prot, &dummy_prot))
			      system_printf ("WARNING: VirtualProtectEx to "
					     "return to previous state "
					     "in parent failed for "
					     "MAP_PRIVATE address %p, %E",
					     rec->get_address ());
			    if (!VirtualProtect (address, getpagesize (),
						 old_prot, &dummy_prot))
			      system_printf ("WARNING: VirtualProtect to copy "
					     "protection to child failed for"
					     "MAP_PRIVATE address %p, %E",
					     rec->get_address ());
			    if (!ret)
			      {
				system_printf ("ReadProcessMemory (2nd try) "
					       "failed for "
					       "MAP_PRIVATE address %p, %E",
					       rec->get_address ());
				return -1;
			      }
			  }
d1094 1
a1094 2
		}
	      rec->fixup_map ();
d1096 1
@


1.82
log
@	* mmap.cc (mmap64): Avoid crash if file size is less than requested
	map length.
@
text
@d79 1
a79 1
    void free_map () { if (map_map_) free (map_map_); }
d116 2
a117 2
  map_map_ = (DWORD *) calloc (MAPSIZE (PAGE_CNT (size_to_map_)),
			       sizeof (DWORD));
d280 1
a280 1
  recs = (mmap_record *) malloc (10 * sizeof (mmap_record));
d287 1
a287 1
  free (recs);
d296 1
a296 1
      recs = (mmap_record *) realloc (recs, maxrecs * sizeof (mmap_record));
d376 1
a376 1
  lists = (list **) malloc (10 * sizeof (list *));
d383 1
a383 1
  free (lists);
d411 1
a411 1
      lists = (list **) realloc (lists, maxlists * sizeof (list *));
@


1.81
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d603 1
a603 1
  mmap_record *rec = map_list->add_record (mmap_rec, off, len);
@


1.80
log
@	* mmap.cc: Use proper format specifiers for _off64_t and size_t in
	format strings passed to syscall_printf () and debug_printf ()
	throughout.
@
text
@d335 1
a335 1
      high = recs[i].get_address () 
d568 1
a568 1
  
d846 1
a846 1
  		"len:%u, addr:%x)", base, h, access, off, len, *addr);
@


1.79
log
@	* mmap.cc (list::match): Add parameters to return valid address and
	length back to munmap().  Evaluate intersection between given
	area and mapped area and return it, if any.
	(mmap64): On regular files, don't allow mappings beginning beyond
	EOF.  Return with errno set to ENXIO instead.
	(munmap): Rewrite SUSv3 conformant.  Check if given memory area is
	valid.  Unmap all maps inside given memory area.  Don't return error
	if no mapping has been unmapped.
@
text
@d126 1
a126 1
	syscall_printf ("VirtualProtect(%x,%d) failed: %E", base_address_, off);
d131 1
a131 1
	syscall_printf ("VirtualProtect(%x,%d) failed: %E",
d161 1
a161 1
  debug_printf ("map_map (fd=%d, off=%D, len=%d)", fdesc_, off, len);
d438 1
a438 1
  syscall_printf ("addr %x, len %d, prot %x, flags %x, fd %d, off %D",
d621 1
a621 1
  syscall_printf ("munmap (addr %x, len %d)", addr, len);
d678 1
a678 1
  syscall_printf ("addr = %x, len = %d, flags = %x",
d846 1
a846 1
  		"len:%d, addr:%x)", base, h, access, off, len, *addr);
d910 1
a910 1
  syscall_printf ("mprotect (addr %x, len %d, prot %x)", addr, len, prot);
d988 1
a988 1
	      debug_printf ("fd %d, h %x, access %x, offset %d, size %d, address %p",
@


1.78
log
@	* mmap.cc (fhandler_disk_file::mmap): Fix address test.
@
text
@d273 2
a274 1
  long match (caddr_t addr, DWORD len, long start);
d327 2
a328 1
list::match (caddr_t addr, DWORD len, _off_t start)
d330 2
d333 12
a344 4
    if (addr >= recs[i].get_address ()
	&& addr + len <= recs[i].get_address ()
			 + (PAGE_CNT (recs[i].get_size ()) * getpagesize ()))
      return i;
d501 10
d616 1
a616 2
/* munmap () removes an mmapped area.  It insists that base area
   requested is the same as that mmapped, error if not. */
d623 3
a625 2
  /* Error conditions according to SUSv2 */
  if (((DWORD)addr % getpagesize ()) || !len)
a632 1
  /* Check if a mmap'ed area was ever created */
a635 1
      set_errno (EINVAL);
d637 1
a637 1
      return -1;
d640 2
a641 2
  /* Iterate through the map, looking for the mmapped area.
     Error if not found. */
d649 4
a652 1
	  if ((li = map_list->match(addr, len, li)) >= 0)
d655 1
a655 1
	      if (rec->unmap_map (addr, len))
a663 3
	      syscall_printf ("0 = munmap(): %x", addr);
	      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
	      return 0;
a667 3
  set_errno (EINVAL);
  syscall_printf ("-1 = munmap(): EINVAL");

d669 2
a670 1
  return -1;
@


1.77
log
@	* mmap.cc (mmap64): Allow MAP_FIXED with pagesize granularity (4K).
	If a non-zero addr is given, align it to the next lower 64K boundary.
	(fhandler_disk_file::mmap): If a non-zero address is given, try
	mapping using the given address first.  If it fails and flags is not
	MAP_FIXED, try again with NULL address.
@
text
@d823 1
a823 1
  if (addr)
@


1.76
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d441 1
a441 1
      || ((flags & MAP_FIXED) && ((DWORD)addr % granularity))
a471 2
  caddr_t base = addr;
  HANDLE h;
d541 7
a547 1
  h = fh->mmap (&base, gran_len, access, flags, gran_off);
d820 9
a828 3
  void *base = MapViewOfFileEx (h, access, high, low, len,
			       (flags & MAP_FIXED) ? *addr : NULL);
  debug_printf ("%x = MapViewOfFileEx (h:%x, access:%x, 0, off:%D, len:%d, addr:%x)", base, h, access, off, len, (flags & MAP_FIXED) ? *addr : NULL);
@


1.75
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@a15 1
#include <errno.h>
@


1.74
log
@whitespace cleanup
@
text
@d48 1
a48 1
    __off64_t offset_;
d54 1
a54 1
    mmap_record (int fd, HANDLE h, DWORD ac, __off64_t o, DWORD s, caddr_t b) :
d79 1
a79 1
    void alloc_map (__off64_t off, DWORD len);
d83 1
a83 1
    __off64_t map_map (__off64_t off, DWORD len);
d114 1
a114 1
mmap_record::alloc_map (__off64_t off, DWORD len)
d141 2
a142 2
__off64_t
mmap_record::map_map (__off64_t off, DWORD len)
d172 1
a172 1
      return (__off64_t)-1;
d270 1
a270 1
  mmap_record *add_record (mmap_record r, __off64_t off, DWORD len);
d273 1
a273 1
  mmap_record *match (__off64_t off, DWORD len);
d291 1
a291 1
list::add_record (mmap_record r, __off64_t off, DWORD len)
d305 1
a305 1
list::match (__off64_t off, DWORD len)
d327 1
a327 1
list::match (caddr_t addr, DWORD len, __off32_t start)
d425 1
a425 1
mmap64 (caddr_t addr, size_t len, int prot, int flags, int fd, __off64_t off)
d469 1
a469 1
  __off64_t gran_off = off & ~(granularity - 1);
d491 1
a491 1
	  __off64_t fsiz = ((__off64_t)high << 32) + low;
d516 1
a516 1
	  if ((off = rec->map_map (off, len)) == (__off64_t)-1)
d586 1
a586 1
mmap (caddr_t addr, size_t len, int prot, int flags, int fd, __off32_t off)
d588 1
a588 1
  return mmap64 (addr, len, prot, flags, fd, (__off64_t)off);
d736 1
a736 1
		     int flags, __off64_t off)
d767 1
a767 1
			  int flags, __off64_t off)
@


1.73
log
@Do some minor reformatting of 'extern "C"' use throughout.
* autoload.cc (GetSystemTimes): Define new autoload function.
* fhandler_proc.cc (proc_listing): Add cpuinfo and partitions entries.
(fhandler_proc::fill_filebuf): Add PROC_CPUINFO and PROC_PARTITIONS cases.
(format_proc_uptime): Use GetSystemTimes if available.
(read_value): New macro.
(print): New macro.
(cpuid): New function.
(can_set_flag): New function.
(format_proc_cpuinfo): New function.
(format_proc_partitions): New function.
@
text
@d126 1
a126 1
          !VirtualProtect (base_address_, off, PAGE_NOACCESS, &old_prot))
d146 1
a146 1
     
d774 2
a775 2
        protect = PAGE_READWRITE;
        break;
d777 2
a778 2
        protect = PAGE_READONLY;
        break;
d992 1
a992 1
			    		   "MAP_PRIVATE address %p, %E",
d1016 1
a1016 1
			      		     "return to previous state "
@


1.72
log
@	* mmap.cc (mmap64): Fix returned address by taking the granularity
	into account.
@
text
@d424 1
a424 2
extern "C"
caddr_t
d585 1
a585 2
extern "C"
caddr_t
d594 1
a594 2
extern "C"
int
d654 1
a654 2
extern "C"
int
d877 1
a877 2
extern "C"
int
@


1.71
log
@	* mmap.cc (mprotect): Add missing break.
@
text
@d580 1
a580 1
  caddr_t ret = rec->get_address () + off;
@


1.70
log
@	* mmap.cc (mmap_record::alloc_map): De-inline.  Add offset and length
	parameter.  Only protect pages actually unused currently.  Do job
	of map_map() when initializing a map.
	(mmap_record::map_map): Reduce functionality for the reuse case
	of private anonymous mapping.
	(mmap_record::fixup_map): Format change.
	(list::add_record): Add offset and length parameter to call
	mmap_record::alloc_map() correctly.
	(mmap64): Rename `l' variable to `map_list'.  Accomodate above changes.
	(munmap): Rename `l' variable to `map_list'.
	(msync): Ditto.
	(fhandler_disk_file::mmap): Streamline code.
	(mprotect): Ditto.
	(fixup_mmaps_after_fork): Rename `l' variable to `map_list'.
@
text
@d912 1
@


1.69
log
@	* mmap.cc (fixup_mmaps_after_fork): Add ERROR_NOACCESS to the list of
	ReadProcessMemory() error codes that trigger a retry with temporary
	PAGE_READONLY access.  Note that this can occur on NT 4.0.
@
text
@d79 1
a79 14

    void alloc_map ()
      {
	/* Allocate one bit per page */
	map_map_ = (DWORD *) calloc (MAPSIZE (PAGE_CNT (size_to_map_)),
				     sizeof (DWORD));
	if (wincap.virtual_protect_works_on_shared_pages ())
	  {
	    DWORD old_prot;
	    if (!VirtualProtect (base_address_, size_to_map_,
				 PAGE_NOACCESS, &old_prot))
	      syscall_printf ("-1 = alloc_map (): %E");
	  }
      }
d113 28
d144 4
a163 12
  if (fdesc_ == -1 && !off)
    {
      off = find_empty (len);
      if (off != (DWORD)-1)
	{
	  if (wincap.virtual_protect_works_on_shared_pages ()
	      && !VirtualProtect (base_address_ + off * getpagesize (),
				  len * getpagesize (), prot, &old_prot))
	    {
	      __seterrno ();
	      return (__off64_t)-1;
	    }
d165 2
a166 8
	  while (len-- > 0)
	    MAP_SET (off + len);
	  return off * getpagesize ();
	}
      return 0L;
    }
  off -= offset_;
  DWORD start = off / getpagesize ();
d168 1
a168 1
      && !VirtualProtect (base_address_ + start * getpagesize (),
d175 3
a177 3
  for (; len-- > 0; ++start)
    MAP_SET (start);
  return off;
d223 2
a224 4
    VirtualProtect (base_address_ + off * getpagesize (),
		    getpagesize (),
		    MAP_ISSET (off - 1) ? prot : PAGE_NOACCESS,
		    &old_prot);
d270 1
a270 1
  mmap_record *add_record (mmap_record r);
d291 1
a291 1
list::add_record (mmap_record r)
d299 1
a299 1
  recs[nrecs].alloc_map ();
d418 1
a418 1
 * by file descriptor. This is *NOT* duplicated accross a fork(), it
d507 1
a507 1
  list *l = mmapped_areas->get_list_by_fd (fd);
d512 1
a512 1
  if (l && fd == -1 && off == 0 && !(flags & MAP_FIXED))
d515 1
a515 1
      if ((rec = l->match (off, len)) != NULL)
d563 1
a563 1
  if (l == 0)
d566 2
a567 2
      l = new list;
      if (l == 0)
d575 1
a575 1
      l = mmapped_areas->add_list (l, fd);
d579 1
a579 9
  mmap_record *rec = l->add_record (mmap_rec);
  if ((off = rec->map_map (off, len)) == (__off64_t)-1)
    {
      fh->munmap (h, base, gran_len);
      l->erase ();
      syscall_printf ("-1 = mmap()");
      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
      return MAP_FAILED;
    }
d625 2
a626 2
      list *l = mmapped_areas->lists[it];
      if (l)
d629 1
a629 1
	  if ((li = l->match(addr, len, li)) >= 0)
d631 1
a631 1
	      mmap_record *rec = l->recs + li;
d639 1
a639 1
		  l->erase (li);
d688 2
a689 2
      list *l = mmapped_areas->lists[it];
      if (l != 0)
d691 1
a691 1
	  for (int li = 0; li < l->nrecs; ++li)
d693 1
a693 1
	      mmap_record *rec = l->recs + li;
d709 2
a710 1
		  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d775 12
a786 6
  if (access & FILE_MAP_COPY)
    protect = PAGE_WRITECOPY;
  else if (access & FILE_MAP_WRITE)
    protect = PAGE_READWRITE;
  else
    protect = PAGE_READONLY;
d897 1
a897 3
  if (prot == PROT_NONE)
    new_prot = PAGE_NOACCESS;
  else
d899 23
a921 19
      switch (prot)
	{
	  case PROT_READ | PROT_WRITE | PROT_EXEC:
	    new_prot = PAGE_EXECUTE_READWRITE;
	    break;
	  case PROT_READ | PROT_WRITE:
	    new_prot = PAGE_READWRITE;
	    break;
	  case PROT_READ | PROT_EXEC:
	    new_prot = PAGE_EXECUTE_READ;
	    break;
	  case PROT_READ:
	    new_prot = PAGE_READONLY;
	    break;
	  default:
	    syscall_printf ("-1 = mprotect (): invalid prot value");
	    set_errno (EINVAL);
	    return -1;
	 }
d957 2
a958 2
      list *l = mmapped_areas->lists[it];
      if (l)
d961 1
a961 1
	  for (li = 0; li < l->nrecs; ++li)
d963 1
a963 1
	      mmap_record *rec = l->recs + li;
@


1.68
log
@	* autoload.cc: Fix copyright date.
	* fhandler_dsp.cc: Ditto.
	* mmap.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* signal.cc: Ditto.
	* syscalls.cc: Ditto.
	* uname.cc: Ditto.
	* wait.cc: Ditto.
@
text
@d989 1
d991 3
a993 2
			if (GetLastError () != ERROR_PARTIAL_COPY ||
			    !wincap.virtual_protect_works_on_shared_pages ())
@


1.68.2.1
log
@merge from trunk
@
text
@d46 1
a51 1
    device dev;
d57 1
a63 1
	dev.devn = 0;
d65 1
a65 1
	  dev = cygheap->fdtab[fd]->dev;
d73 1
a73 1
    device& get_device () { return dev; }
d489 1
a489 1
      if (fh->get_device () == FH_FS)
@


1.68.2.2
log
@trunk merge
@
text
@a988 1
			DWORD last_error = GetLastError ();
d990 2
a991 3
			if (last_error != ERROR_PARTIAL_COPY
			    && last_error != ERROR_NOACCESS
			    || !wincap.virtual_protect_works_on_shared_pages ())
@


1.68.2.3
log
@merge from trunk
@
text
@d79 14
a92 1
    void alloc_map (__off64_t off, DWORD len);
a125 28
void
mmap_record::alloc_map (__off64_t off, DWORD len)
{
  /* Allocate one bit per page */
  map_map_ = (DWORD *) calloc (MAPSIZE (PAGE_CNT (size_to_map_)),
			       sizeof (DWORD));
  if (wincap.virtual_protect_works_on_shared_pages ())
    {
      DWORD old_prot;

      off -= offset_;
      len = PAGE_CNT (len) * getpagesize ();
      if (off > 0 &&
          !VirtualProtect (base_address_, off, PAGE_NOACCESS, &old_prot))
	syscall_printf ("VirtualProtect(%x,%d) failed: %E", base_address_, off);
      if (off + len < size_to_map_
	  && !VirtualProtect (base_address_ + off + len,
			      size_to_map_ - len - off,
			      PAGE_NOACCESS, &old_prot))
	syscall_printf ("VirtualProtect(%x,%d) failed: %E",
			base_address_ + off + len, size_to_map_ - len - off);
      off /= getpagesize ();
      len /= getpagesize ();
      while (len-- > 0)
	MAP_SET (off + len);
    }
}

a128 4
  /* Used ONLY if this mapping matches into the chunk of another already
     performed mapping in a special case of MAP_ANON|MAP_PRIVATE.
     
     Otherwise it's job is now done by alloc_map(). */
d145 12
d158 8
a165 2
  if ((off = find_empty (len)) == (DWORD)-1)
    return 0L;
d167 1
a167 1
      && !VirtualProtect (base_address_ + off * getpagesize (),
d174 3
a176 3
  while (len-- > 0)
    MAP_SET (off + len);
  return off * getpagesize ();
d222 4
a225 2
    VirtualProtect (base_address_ + off * getpagesize (), getpagesize (),
		    MAP_ISSET (off - 1) ? prot : PAGE_NOACCESS, &old_prot);
d271 1
a271 1
  mmap_record *add_record (mmap_record r, __off64_t off, DWORD len);
d292 1
a292 1
list::add_record (mmap_record r, __off64_t off, DWORD len)
d300 1
a300 1
  recs[nrecs].alloc_map (off, len);
d419 1
a419 1
 * by file descriptor. This is *NOT* duplicated across a fork(), it
d508 1
a508 1
  list *map_list = mmapped_areas->get_list_by_fd (fd);
d513 1
a513 1
  if (map_list && fd == -1 && off == 0 && !(flags & MAP_FIXED))
d516 1
a516 1
      if ((rec = map_list->match (off, len)) != NULL)
d564 1
a564 1
  if (!map_list)
d567 2
a568 2
      map_list = new list;
      if (!map_list)
d576 1
a576 1
      map_list = mmapped_areas->add_list (map_list, fd);
d580 9
a588 1
  mmap_record *rec = map_list->add_record (mmap_rec, off, len);
d634 2
a635 2
      list *map_list = mmapped_areas->lists[it];
      if (map_list)
d638 1
a638 1
	  if ((li = map_list->match(addr, len, li)) >= 0)
d640 1
a640 1
	      mmap_record *rec = map_list->recs + li;
d648 1
a648 1
		  map_list->erase (li);
d697 2
a698 2
      list *map_list = mmapped_areas->lists[it];
      if (map_list != 0)
d700 1
a700 1
	  for (int li = 0; li < map_list->nrecs; ++li)
d702 1
a702 1
	      mmap_record *rec = map_list->recs + li;
d718 1
a718 2
		  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK,
				       "msync");
d783 6
a788 12
  switch (access)
    {
      case FILE_MAP_WRITE:
        protect = PAGE_READWRITE;
        break;
      case FILE_MAP_READ:
        protect = PAGE_READONLY;
        break;
      default:
	protect = PAGE_WRITECOPY;
	break;
    }
d899 3
a901 1
  switch (prot)
d903 19
a921 23
      case PROT_READ | PROT_WRITE | PROT_EXEC:
      case PROT_WRITE | PROT_EXEC:
	new_prot = PAGE_EXECUTE_READWRITE;
	break;
      case PROT_READ | PROT_WRITE:
      case PROT_WRITE:
	new_prot = PAGE_READWRITE;
	break;
      case PROT_READ | PROT_EXEC:
	new_prot = PAGE_EXECUTE_READ;
	break;
      case PROT_READ:
	new_prot = PAGE_READONLY;
      case PROT_EXEC:
	new_prot = PAGE_EXECUTE;
	break;
      case PROT_NONE:
	new_prot = PAGE_NOACCESS;
	break;
      default:
	syscall_printf ("-1 = mprotect (): invalid prot value");
	set_errno (EINVAL);
	return -1;
d957 2
a958 2
      list *map_list = mmapped_areas->lists[it];
      if (map_list)
d961 1
a961 1
	  for (li = 0; li < map_list->nrecs; ++li)
d963 1
a963 1
	      mmap_record *rec = map_list->recs + li;
@


1.68.2.4
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d18 1
a19 1
#include "fhandler.h"
d65 1
a65 1
	  dev = cygheap->fdtab[fd]->dev ();
a246 1
  static path_conv pc; // should be thread safe - CGF
d252 1
a252 1
  return build_fh_dev (get_device ());
@


1.68.2.5
log
@merge from trunk
@
text
@a912 1
	break;
@


1.68.2.6
log
@merge from trunk
@
text
@d581 1
a581 1
  caddr_t ret = rec->get_address () + (off - gran_off);
@


1.68.2.7
log
@merge from trunk
@
text
@d126 1
a126 1
	  !VirtualProtect (base_address_, off, PAGE_NOACCESS, &old_prot))
d146 1
a146 1

d425 2
a426 1
extern "C" caddr_t
d587 2
a588 1
extern "C" caddr_t
d597 2
a598 1
extern "C" int
d658 2
a659 1
extern "C" int
d779 2
a780 2
	protect = PAGE_READWRITE;
	break;
d782 2
a783 2
	protect = PAGE_READONLY;
	break;
d882 2
a883 1
extern "C" int
d998 1
a998 1
					   "MAP_PRIVATE address %p, %E",
d1022 1
a1022 1
					     "return to previous state "
@


1.68.2.8
log
@merge from trunk
@
text
@d47 1
a47 1
    _off64_t offset_;
d54 1
a54 1
    mmap_record (int fd, HANDLE h, DWORD ac, _off64_t o, DWORD s, caddr_t b) :
d79 1
a79 1
    void alloc_map (_off64_t off, DWORD len);
d83 1
a83 1
    _off64_t map_map (_off64_t off, DWORD len);
d114 1
a114 1
mmap_record::alloc_map (_off64_t off, DWORD len)
d141 2
a142 2
_off64_t
mmap_record::map_map (_off64_t off, DWORD len)
d172 1
a172 1
      return (_off64_t)-1;
d271 1
a271 1
  mmap_record *add_record (mmap_record r, _off64_t off, DWORD len);
d274 1
a274 1
  mmap_record *match (_off64_t off, DWORD len);
d292 1
a292 1
list::add_record (mmap_record r, _off64_t off, DWORD len)
d306 1
a306 1
list::match (_off64_t off, DWORD len)
d328 1
a328 1
list::match (caddr_t addr, DWORD len, _off_t start)
d426 1
a426 1
mmap64 (caddr_t addr, size_t len, int prot, int flags, int fd, _off64_t off)
d470 1
a470 1
  _off64_t gran_off = off & ~(granularity - 1);
d492 1
a492 1
	  _off64_t fsiz = ((_off64_t)high << 32) + low;
d517 1
a517 1
	  if ((off = rec->map_map (off, len)) == (_off64_t)-1)
d587 1
a587 1
mmap (caddr_t addr, size_t len, int prot, int flags, int fd, _off_t off)
d589 1
a589 1
  return mmap64 (addr, len, prot, flags, fd, (_off64_t)off);
d737 1
a737 1
		     int flags, _off64_t off)
d768 1
a768 1
			  int flags, _off64_t off)
@


1.68.2.9
log
@merge from trunk
@
text
@d16 1
d275 1
a275 2
  long match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
	      long start);
d328 1
a328 2
list::match (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
	     _off_t start)
a329 2
  caddr_t low, high;

d331 4
a334 12
    {
      low = (addr >= recs[i].get_address ()) ? addr : recs[i].get_address ();
      high = recs[i].get_address () 
	     + (PAGE_CNT (recs[i].get_size ()) * getpagesize ());
      high = (addr + len < high) ? addr + len : high;
      if (low < high)
	{
	  m_addr = low;
	  m_len = high - low;
	  return i;
	}
    }
d443 1
a443 1
      || ((flags & MAP_FIXED) && ((DWORD)addr % getpagesize ()))
d474 2
a492 10
	  /* Don't allow mappings beginning beyond EOF since Windows can't
	     handle that POSIX like.  FIXME: Still looking for a good idea
	     to allow that nevertheless. */
	  if (gran_off >= fsiz)
	    {
	      set_errno (ENXIO);
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK,
				   "mmap");
	      return MAP_FAILED;
	    }
d545 1
a545 7
  caddr_t base = addr;
  /* This shifts the base address to the next lower 64K boundary.
     The offset is re-added when evaluating the return value. */
  if (base)
    base -= off - gran_off;
  
  HANDLE h = fh->mmap (&base, gran_len, access, flags, gran_off);
d592 2
a593 1
/* munmap () removes all mmapped pages between addr and addr+len. */
d600 2
a601 3
  /* Error conditions according to SUSv3 */
  if (!addr || ((DWORD)addr % getpagesize ()) || !len
      || IsBadReadPtr (addr, len))
d609 1
d613 1
d615 1
a615 1
      return 0;
d618 2
a619 2
  /* Iterate through the map, unmap pages between addr and addr+len
     in all maps. */
d627 1
a627 4
	  caddr_t u_addr;
	  DWORD u_len;

	  while ((li = map_list->match(addr, len, u_addr, u_len, li)) >= 0)
d630 1
a630 1
	      if (rec->unmap_map (u_addr, u_len))
d639 3
d646 3
d650 1
a650 2
  syscall_printf ("0 = munmap(): %x", addr);
  return 0;
d818 3
a820 9
  void *base = NULL;
  /* If a non-zero address is given, try mapping using the given address first.
     If it fails and flags is not MAP_FIXED, try again with NULL address. */
  if (*addr)
    base = MapViewOfFileEx (h, access, high, low, len, *addr);
  if (!base && !(flags & MAP_FIXED))
    base = MapViewOfFileEx (h, access, high, low, len, NULL);
  debug_printf ("%x = MapViewOfFileEx (h:%x, access:%x, 0, off:%D, "
  		"len:%d, addr:%x)", base, h, access, off, len, *addr);
@


1.68.2.10
log
@merge from trunk
@
text
@d126 1
a126 1
	syscall_printf ("VirtualProtect(%x,%D) failed: %E", base_address_, off);
d131 1
a131 1
	syscall_printf ("VirtualProtect(%x,%D) failed: %E",
d161 1
a161 1
  debug_printf ("map_map (fd=%d, off=%D, len=%u)", fdesc_, off, len);
d336 1
a336 1
      high = recs[i].get_address ()
d439 1
a439 1
  syscall_printf ("addr %x, len %u, prot %x, flags %x, fd %d, off %D",
d569 1
a569 1

d622 1
a622 1
  syscall_printf ("munmap (addr %x, len %u)", addr, len);
d679 1
a679 1
  syscall_printf ("addr = %x, len = %u, flags = %x",
d847 1
a847 1
		"len:%u, addr:%x)", base, h, access, off, len, *addr);
d911 1
a911 1
  syscall_printf ("mprotect (addr %x, len %u, prot %x)", addr, len, prot);
d989 1
a989 1
	      debug_printf ("fd %d, h %x, access %x, offset %D, size %u, address %p",
@


1.68.2.11
log
@merge from trunk
@
text
@d79 1
a79 1
    void free_map () { if (map_map_) cfree (map_map_); }
d116 2
a117 2
  map_map_ = (DWORD *) ccalloc (HEAP_MMAP, MAPSIZE (PAGE_CNT (size_to_map_)),
			        sizeof (DWORD));
d281 1
a281 1
  recs = (mmap_record *) cmalloc (HEAP_MMAP, 10 * sizeof (mmap_record));
d288 1
a288 1
  cfree (recs);
d297 1
a297 1
      recs = (mmap_record *) crealloc (recs, maxrecs * sizeof (mmap_record));
d377 1
a377 1
  lists = (list **) cmalloc (HEAP_MMAP, 10 * sizeof (list *));
d384 1
a384 1
  cfree (lists);
d412 1
a412 1
      lists = (list **) crealloc (lists, maxlists * sizeof (list *));
d604 1
a604 1
  mmap_record *rec = map_list->add_record (mmap_rec, off, len > gran_len ? gran_len : len);
@


1.68.2.12
log
@merge from trunk
@
text
@d30 3
a32 3
#define MAP_SET(n)	(page_map_[(n)/PGBITS] |= (1L << ((n) % PGBITS)))
#define MAP_CLR(n)	(page_map_[(n)/PGBITS] &= ~(1L << ((n) % PGBITS)))
#define MAP_ISSET(n)	(page_map_[(n)/PGBITS] & (1L << ((n) % PGBITS)))
d34 5
a38 19
/* Used for accessing the page file (anonymous mmaps). */
static fhandler_disk_file fh_paging_file;

/* Class structure used to keep a record of all current mmap areas
   in a process.  Needed for bookkeeping all mmaps in a process and
   for duplicating all mmaps after fork() since mmaps are not propagated
   to child processes by Windows.  All information must be duplicated
   by hand, see fixup_mmaps_after_fork().
  
   The class structure:
  
   One member of class map per process, global variable mmapped_areas.
   Contains a dynamic class list array.  Each list entry represents all
   mapping to a file, keyed by file descriptor and file name hash.
   Each list entry contains a dynamic class mmap_record array.  Each
   mmap_record represents exactly one mapping.  For each mapping, there's
   an additional so called `page_map'.  It's an array of bits, one bit
   per mapped memory page.  The bit is set if the page is accessible,
   unset otherwise. */
d49 1
a49 1
    DWORD *page_map_;
d60 1
a60 1
       page_map_ (NULL)
d67 3
d77 8
a84 8

    bool alloc_page_map (_off64_t off, DWORD len);
    void free_page_map () { if (page_map_) cfree (page_map_); }
    void fixup_page_map (void);

    DWORD find_unused_pages (DWORD pages);
    _off64_t map_pages (_off64_t off, DWORD len);
    BOOL unmap_pages (caddr_t addr, DWORD len);
a90 39
class list
{
  private:
    mmap_record *recs;
    int nrecs, maxrecs;
    int fd;
    DWORD hash;

  public:
    int get_fd () const { return fd; }
    DWORD get_hash () const { return hash; }
    mmap_record *get_record (int i) { return i >= nrecs ? NULL : recs + i; }

    void set (int nfd);
    mmap_record *add_record (mmap_record r, _off64_t off, DWORD len);
    bool del_record (int i);
    void free_recs () { if (recs) cfree (recs); }
    mmap_record *search_record (_off64_t off, DWORD len);
    long search_record (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
		long start);
};

class map
{
  private:
    list *lists;
    int nlists, maxlists;

  public:
    list *get_list (int i) { return i >= nlists ? NULL : lists + i; }
    list *get_list_by_fd (int fd);
    list *add_list (int fd);
    void del_list (int i);
};

/* This is the global map structure pointer.  It's allocated once on the
   first call to mmap64(). */
static map *mmapped_areas;

d92 1
a92 1
mmap_record::find_unused_pages (DWORD pages)
d112 2
a113 2
bool
mmap_record::alloc_page_map (_off64_t off, DWORD len)
d116 2
a117 5
  if (!(page_map_ = (DWORD *) ccalloc (HEAP_MMAP,
				       MAPSIZE (PAGE_CNT (size_to_map_)),
				       sizeof (DWORD))))
    return false;

a137 1
  return true;
d141 1
a141 1
mmap_record::map_pages (_off64_t off, DWORD len)
d146 1
a146 1
     Otherwise it's job is now done by alloc_page_map(). */
d161 1
a161 1
  debug_printf ("map_pages (fd=%d, off=%D, len=%u)", fdesc_, off, len);
d164 1
a164 1
  if ((off = find_unused_pages (len)) == (DWORD)-1)
d180 1
a180 1
mmap_record::unmap_pages (caddr_t addr, DWORD len)
d189 1
a189 1
    syscall_printf ("-1 = unmap_pages (): %E");
d196 1
a196 1
    if (page_map_[--len])
d202 1
a202 1
mmap_record::fixup_page_map ()
d235 2
d262 29
a295 9
      mmap_record *new_recs;
      if (maxrecs == 0)
        new_recs = (mmap_record *)
			cmalloc (HEAP_MMAP, 5 * sizeof (mmap_record));
      else
	new_recs = (mmap_record *)
			crealloc (recs, (maxrecs + 5) * sizeof (mmap_record));
      if (!new_recs)
        return NULL;
d297 1
a297 1
      recs = new_recs;
d300 1
a300 2
  if (!recs[nrecs].alloc_page_map (off, len))
    return NULL;
d306 1
a306 1
list::search_record (_off64_t off, DWORD len)
d312 1
a312 1
	if (recs[i].find_unused_pages (len) != (DWORD)-1)
d328 1
a328 1
list::search_record (caddr_t addr, DWORD len, caddr_t &m_addr, DWORD &m_len,
d350 1
a350 1
list::set (int nfd)
d352 4
a355 4
  if ((fd = nfd) != -1)
    hash = cygheap->fdtab[fd]->get_namehash ();
  nrecs = maxrecs = 0;
  recs = NULL;
d358 18
a375 2
bool
list::del_record (int i)
d377 8
a384 10
  if (i < nrecs)
    {
      recs[i].free_page_map ();
      for (; i < nrecs - 1; i++)
	recs[i] = recs[i + 1];
      nrecs--;
    }
  /* Return true if the list is empty which allows the caller to remove
     this list from the list array. */
  return !nrecs;
d392 8
a399 7
    /* The fd isn't sufficient since it could already be the fd of another
       file.  So we use the name hash value to identify the file unless
       it's an anonymous mapping in which case the fd (-1) is sufficient. */
    if ((fd == -1 && lists[i].get_fd () == -1)
	|| (fd != -1
	    && lists[i].get_hash () == cygheap->fdtab[fd]->get_namehash ()))
      return lists + i;
d404 1
a404 1
map::add_list (int fd)
d406 3
a410 7
      list *new_lists;
      if (maxlists == 0)
        new_lists = (list *) cmalloc (HEAP_MMAP, 5 * sizeof (list));
      else
	new_lists = (list *) crealloc (lists, (maxlists + 5) * sizeof (list));
      if (!new_lists)
        return NULL;
d412 1
a412 1
      lists = new_lists;
d414 2
a415 2
  lists[nlists].set (fd);
  return lists + nlists++;
d419 1
a419 1
map::del_list (int i)
d421 3
a423 7
  if (i < nlists)
    {
      lists[i].free_recs ();
      for (; i < nlists - 1; i++)
        lists[i] = lists[i + 1];
      nlists--;
    }
d426 12
a437 2
extern "C" void *
mmap64 (void *addr, size_t len, int prot, int flags, int fd, _off64_t off)
d467 1
a467 1
      mmapped_areas = (map *) ccalloc (HEAP_MMAP, 1, sizeof (map));
d534 1
a534 1
      if ((rec = map_list->search_record (off, len)) != NULL)
d536 1
a536 1
	  if ((off = rec->map_pages (off, len)) == (_off64_t)-1)
d564 1
a564 1
  caddr_t base = (caddr_t)addr;
d578 3
a580 2
  /* At this point we should have a successfully mmapped area.
     Now it's time for bookkeeping stuff. */
d591 1
a591 1
      map_list = mmapped_areas->add_list (fd);
d600 1
d604 1
a604 11
  mmap_record *rec = map_list->add_record (mmap_rec, off,
					   len > gran_len ? gran_len : len);
  if (!rec)
    {
      fh->munmap (h, base, gran_len);
      set_errno (ENOMEM);
      syscall_printf ("-1 = mmap(): ENOMEM");
      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
      return MAP_FAILED;
    }

d611 2
a612 2
extern "C" void *
mmap (void *addr, size_t len, int prot, int flags, int fd, _off_t off)
d620 1
a620 1
munmap (void *addr, size_t len)
a642 8
  list *map_list;
  for (int list_idx = 0;
       (map_list = mmapped_areas->get_list (list_idx));
       ++list_idx)
    {
      long record_idx = -1;
      caddr_t u_addr;
      DWORD u_len;
d644 4
a647 2
      while ((record_idx = map_list->search_record((caddr_t)addr, len, u_addr,
      						   u_len, record_idx)) >= 0)
d649 5
a653 2
	  mmap_record *rec = map_list->get_record (record_idx);
	  if (rec->unmap_pages (u_addr, u_len))
d655 6
a660 4
	      /* The whole record has been unmapped, so... */
	      fhandler_base *fh = rec->alloc_fh ();
	      fh->munmap (rec->get_handle (), (caddr_t)addr, len);
	      rec->free_fh (fh);
d662 2
a663 7
	      /* ...delete the record. */
	      if (map_list->del_record (record_idx--))
		{
		  /* Yay, the last record has been removed from the list,
		     we can remove the list now, too. */
		  mmapped_areas->del_list (list_idx--);
		  break;
d677 1
a677 1
msync (void *addr, size_t len, int flags)
d704 1
a704 4
  list *map_list;
  for (int list_idx = 0;
       (map_list = mmapped_areas->get_list (list_idx));
       ++list_idx)
d706 2
a707 4
      mmap_record *rec;
      for (int record_idx = 0;
      	   (rec = map_list->get_record (record_idx));
	   ++record_idx)
d709 1
a709 1
	  if (rec->access ((caddr_t)addr))
d711 20
a730 17
	      /* Check whole area given by len. */
	      for (DWORD i = getpagesize (); i < len; ++i)
		if (!rec->access ((caddr_t)addr + i))
		  goto invalid_address_range;
	      fhandler_base *fh = rec->alloc_fh ();
	      int ret = fh->msync (rec->get_handle (), (caddr_t)addr, len,
	      			   flags);
	      rec->free_fh (fh);

	      if (ret)
		syscall_printf ("%d = msync(): %E", ret);
	      else
		syscall_printf ("0 = msync()");

	      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK,
				   "msync");
	      return 0;
a743 56
/* Set memory protection */

extern "C" int
mprotect (void *addr, size_t len, int prot)
{
  DWORD old_prot;
  DWORD new_prot = 0;

  syscall_printf ("mprotect (addr %x, len %u, prot %x)", addr, len, prot);

  if (!wincap.virtual_protect_works_on_shared_pages ()
      && addr >= (caddr_t)0x80000000 && addr <= (caddr_t)0xBFFFFFFF)
    {
      syscall_printf ("0 = mprotect (9x: No VirtualProtect on shared memory)");
      return 0;
    }

  switch (prot)
    {
      case PROT_READ | PROT_WRITE | PROT_EXEC:
      case PROT_WRITE | PROT_EXEC:
	new_prot = PAGE_EXECUTE_READWRITE;
	break;
      case PROT_READ | PROT_WRITE:
      case PROT_WRITE:
	new_prot = PAGE_READWRITE;
	break;
      case PROT_READ | PROT_EXEC:
	new_prot = PAGE_EXECUTE_READ;
	break;
      case PROT_READ:
	new_prot = PAGE_READONLY;
	break;
      case PROT_EXEC:
	new_prot = PAGE_EXECUTE;
	break;
      case PROT_NONE:
	new_prot = PAGE_NOACCESS;
	break;
      default:
	syscall_printf ("-1 = mprotect (): invalid prot value");
	set_errno (EINVAL);
	return -1;
     }

  if (VirtualProtect (addr, len, new_prot, &old_prot) == 0)
    {
      __seterrno ();
      syscall_printf ("-1 = mprotect (): %E");
      return -1;
    }

  syscall_printf ("0 = mprotect ()");
  return 0;
}

d903 56
d979 1
a979 4
  list *map_list;
  for (int list_idx = 0;
       (map_list = mmapped_areas->get_list (list_idx));
       ++list_idx)
d981 2
a982 4
      mmap_record *rec;
      for (int record_idx = 0;
      	   (rec = map_list->get_record (record_idx));
	   ++record_idx)
d984 8
d993 18
a1010 29
	  debug_printf ("fd %d, h %x, access %x, offset %D, size %u, address %p",
	      rec->get_fd (), rec->get_handle (), rec->get_access (),
	      rec->get_offset (), rec->get_size (), rec->get_address ());

	  fhandler_base *fh = rec->alloc_fh ();
	  BOOL ret = fh->fixup_mmap_after_fork (rec->get_handle (),
						rec->get_access (),
						rec->get_offset (),
						rec->get_size (),
						rec->get_address ());
	  rec->free_fh (fh);

	  if (!ret)
	    return -1;
	  if (rec->get_access () == FILE_MAP_COPY)
	    {
	      for (char *address = rec->get_address ();
		   address < rec->get_address () + rec->get_size ();
		   address += getpagesize ())
		if (rec->access (address)
		    && !ReadProcessMemory (parent, address, address,
					   getpagesize (), NULL))
		  {
		    DWORD old_prot;
		    DWORD last_error = GetLastError ();

		    if (last_error != ERROR_PARTIAL_COPY
			&& last_error != ERROR_NOACCESS
			|| !wincap.virtual_protect_works_on_shared_pages ())
d1012 2
a1013 18
			system_printf ("ReadProcessMemory failed for "
				       "MAP_PRIVATE address %p, %E",
				       rec->get_address ());
			return -1;
		      }
		    if (!VirtualProtectEx (parent,
					   address, getpagesize (),
					   PAGE_READONLY, &old_prot))
		      {
			system_printf ("VirtualProtectEx failed for "
				       "MAP_PRIVATE address %p, %E",
				       rec->get_address ());
			return -1;
		      }
		    else
		      {
			BOOL ret;
			DWORD dummy_prot;
d1015 12
a1026 17
			ret = ReadProcessMemory (parent, address, address,
						 getpagesize (), NULL);
			if (!VirtualProtectEx(parent,
					      address, getpagesize (),
					      old_prot, &dummy_prot))
			  system_printf ("WARNING: VirtualProtectEx to "
					 "return to previous state "
					 "in parent failed for "
					 "MAP_PRIVATE address %p, %E",
					 rec->get_address ());
			if (!VirtualProtect (address, getpagesize (),
					     old_prot, &dummy_prot))
			  system_printf ("WARNING: VirtualProtect to copy "
					 "protection to child failed for"
					 "MAP_PRIVATE address %p, %E",
					 rec->get_address ());
			if (!ret)
d1028 1
a1028 2
			    system_printf ("ReadProcessMemory (2nd try) "
					   "failed for "
d1033 30
d1064 2
a1065 1
		  }
a1066 1
	  rec->fixup_page_map ();
@


1.67
log
@	* mmap.cc (fixup_mmaps_after_fork): Copy protection to child process.
	Change ambiguous debug output.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
@


1.66
log
@	* mmap.cc (mmap_record::access): Change argument type to caddr_t
	for strictness.
	(mprotect): Protect against calling VirtualProtect() for shared
	pages on 9x/Me.
	(fixup_mmaps_after_fork): If ReadProcessMemory() fails, try to
	change protection of parent page to PAGE_READONLY, then try again.
	Revert protection afterwards.
@
text
@d1009 3
a1011 1
			    BOOL ret, ret2;
d1014 4
a1017 5
			    ret2 = VirtualProtectEx(parent,
			    			    address, getpagesize (),
						    old_prot, &old_prot);
			    if (!ret2)
			      system_printf ("WARNING: VirtualProtectEx to"
d1022 6
d1030 2
a1031 1
				system_printf ("ReadProcessMemory FAILED for "
@


1.65
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@d99 1
a99 1
    int access (char *address);
d229 1
a229 1
mmap_record::access (char *address)
d892 7
d958 1
a958 1
      if (l != 0)
d988 41
a1028 3
			system_printf ("ReadProcessMemory failed for MAP_PRIVATE address %p, %E",
				       rec->get_address ());
			return -1;
@


1.65.12.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d46 1
a51 1
    device dev;
d57 1
a63 1
	dev.devn = 0;
d65 1
a65 1
	  dev = cygheap->fdtab[fd]->dev;
d73 1
a73 1
    device& get_device () { return dev; }
d489 1
a489 1
      if (fh->get_device () == FH_FS)
@


1.64
log
@	* errno.cc (errmap): Map ERROR_INVALID_ADDRESS to new errno code
	EOVERFLOW.
	(_sys_errlist): Add entries for EILSEQ and EOVERFLOW.
	(strerror): Ditto.
	* mmap.cc (map_map): Set errno in case of error.
	(mmap64): Remove setting errno explicitely to ENOMEM.
@
text
@d871 7
d971 1
a971 5
		{
		  system_printf ("base address fails to match requested address %p",
				 rec->get_address ());
		  return -1;
		}
@


1.63
log
@	* mmap.cc (map_map): Add debug output.
	(mmap64): Evaluate gran_len correctly even if offset isn't 0.
@
text
@d154 1
a154 1
	      debug_printf ("-1 = map_map (): %E");
d170 1
a170 1
      debug_printf ("-1 = map_map (): %E");
d520 1
a520 2
	      set_errno (ENOMEM);
	      syscall_printf ("-1 = mmap(): ENOMEM");
d585 1
a585 2
      set_errno (ENOMEM);
      syscall_printf ("-1 = mmap(): ENOMEM");
@


1.62
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d143 1
d472 1
a472 1
  DWORD gran_len = howmany (len, granularity) * granularity;
@


1.61
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d28 2
a29 2
#define PGBITS		(sizeof(DWORD)*8)
#define MAPSIZE(pages)	howmany((pages),PGBITS)
d83 1
a83 1
	map_map_ = (DWORD *) calloc (MAPSIZE(PAGE_CNT (size_to_map_)),
d194 1
a194 1
  for (len = MAPSIZE(PAGE_CNT (size_to_map_)); len > 0; )
d280 1
a280 1
  recs = (mmap_record *) malloc (10 * sizeof(mmap_record));
d365 1
a365 1
  lists = (list **) malloc (10 * sizeof(list *));
@


1.60
log
@	* mmap.cc (list::match): Check using pagesize aligned size.
@
text
@d451 1
a451 1
  SetResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d461 1
a461 1
	  ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d484 1
a484 1
	  ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d521 1
a521 1
	      ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK|WRITE_LOCK, "mmap");
d526 1
a526 1
	  ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d550 1
a550 1
      ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d573 1
a573 1
	  ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d587 1
a587 1
      ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d592 1
a592 1
  ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d620 1
a620 1
  SetResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d626 1
a626 1
      ReleaseResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d652 1
a652 1
	      ReleaseResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d661 1
a661 1
  ReleaseResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d683 1
a683 1
  SetResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d689 1
a689 1
      ReleaseResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d719 1
a719 1
		  ReleaseResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d731 1
a731 1
  ReleaseResourceLock(LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d810 1
a810 1
	h = CreateFileMapping (get_handle(), &sec_none, protect, 0, 0, namebuf);
@


1.59
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d26 1
a26 1
#define PAGE_CNT(bytes) howmany(bytes,getpagesize())
d29 1
a29 1
#define MAPSIZE(pages)	howmany(pages,PGBITS)
d318 2
a319 1
	    && off + len <= recs[i].get_offset () + recs[i].get_size ())
d331 2
a332 1
	&& addr + len <= recs[i].get_address () + recs[i].get_size ())
@


1.58
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@a22 1
#include "sigproc.h"
@


1.57
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d970 1
a970 1
	        {
d975 1
a975 1
		        && !ReadProcessMemory (parent, address, address,
d982 1
a982 1
	        }
@


1.56
log
@* dtable.cc (dtable::build_fhandler_from_name): Just pass posix path along to
set_name via return_and_clear_normalized_path.
(dtable::build_fhandler): New method with const char * argument.
(dtable::reset_unix_path_name): Eliminate.
(dtable::dup_worker): Use correct build_fhandler method.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* dtable.h (dtable::build_fhandler): New method.
(dtable::reset_unix_path_name): Eliminate.
* fhandler.cc (fhandler_base::set_name): Assume that unix_name has already been
cmalloced.
(fhandler_base::reset_unix_path_name): Eliminate.
(fhandler_base::~fhandler_base): Coercion for cfree.
* fhandler.h (fhandler_base::unix_path_name): Make const char *.
(fhandler_base::win32_path_name): Ditto.
(fhandler_base::reset_unix_path_name): Eliminate.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Accommodate const char
*ness of win32_path_name.
* fhandler_socket.cc (fhandler_socket::fstat): Accommodate new set_name
requirements.
* path.cc (path_conv::return_and_clear_normalized_path): New method.
(path_conv::clear_normalized_path): Eliminate.
(path_conv::~path_conv): Ditto.
(path_conv::check): Accommodate new build_fhandler method.
* path.h (path_conv::~path_conv): Eliminate.
(path_conv::clear_normalized_path): Ditto.
(path_conv::return_and_clear_normalized_path): Declare new method.
@
text
@a22 1
#include "sync.h"
@


1.55
log
@	* mmap.cc (mmap_record::map_map): Return -1 if VirtualProtect fails.
	(list::erase): New method with no argument.  Erase latest record
	added.
	(mmap64): Fail if map_map() fails.
@
text
@d254 1
a254 1
  return cygheap->fdtab.build_fhandler (-1, get_device (), NULL);
@


1.54
log
@	* mmap.cc (msync): Check area given by addr and len for being a
	contigeous mmap'd region.
@
text
@d154 4
a157 1
	    syscall_printf ("-1 = map_map (): %E");
d170 4
a173 1
    syscall_printf ("-1 = map_map (): %E");
d274 1
d346 6
d517 7
a523 1
	  off = rec->map_map (off, len);
d581 9
a589 1
  off = rec->map_map (off, len);
@


1.53
log
@	* fork.cc (fork_child): Call fixup_mmaps_after_fork() before
	closing parent process handle.  Call fixup_mmaps_after_fork()
	with parent process handle as parameter.
	* mmap.cc (mmap_record::access): New method.
	(fixup_mmaps_after_fork): Take process handle as parameter.
	In case of FILE_MAP_COPY access, copy valid memory regions to child.
	* pinfo.h (fixup_mmaps_after_fork): Change prototype accordingly.
@
text
@d677 1
a677 1
	      if (rec->get_address () == addr)
d679 4
d695 3
a697 3
	     }
	 }
     }
d699 1
@


1.52
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d101 1
d223 9
d900 1
a900 1
fixup_mmaps_after_fork ()
d938 14
@


1.51
log
@* sync.h (new_muto): Just accept an argument which denotes the name of the
muto.  Use this argument to construct static storage.
* cygheap.cc (cygheap_init): Reflect above change.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* cygheap.h (cwdstuff): Change name of lock element to make it less generic.
* path.cc (cwdstuff::get_hash): Ditto.
(cwdstuff::get_initial): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* sigproc.cc (proc_subproc): Ditto.
* debug.cc (lock_debug): Change to method.  Use method rather than macro
throughout.
* tty.h (tty_min::kill_pgrp): Declare new method.
* fhandler_termios.cc (tty_min::kill_pgrp): New method.
(fhandler_termios::line_edit): Use new method for killing process.
* dcrt0.cc (do_exit): Ditto.
* dtable.cc (dtable::get_debugger_info): New method for inheriting dtable info
from a debugger.
* tty.cc (tty_init): Attempt to grab file handle info from parent debugger, if
appropriate.  # dtable.cc (dtable::stdio_init): Make this a method.
(dtable::init_std_file_from_handle): Don't set fd unless it's not open.
(dtable::build_fhandler_from_name): Move name setting to
dtable::build_fhandler.
(dtable::build_fhandler): Add win32 name parameter.
* dcrt0.cc (dll_crt0_1): Change to use dtable stdio_init.
* dtable.h (dtable): Reflect build_fhandler parameter change.
* mmap.cc (mmap_record::alloc_fh): Don't set name parameter in build_fhandler.
* net.cc (fdsock): Remove set_name call since it is now handled by
build_fhandler.
* sigproc.cc (proc_subproc): Release muto as early as possible.
@
text
@d50 1
a50 1
    DWORD offset_;
d56 1
a56 1
    mmap_record (int fd, HANDLE h, DWORD ac, DWORD o, DWORD s, caddr_t b) :
d98 1
a98 1
    DWORD map_map (DWORD off, DWORD len);
d127 2
a128 2
DWORD
mmap_record::map_map (DWORD off, DWORD len)
d258 2
a259 2
  mmap_record *match (DWORD off, DWORD len);
  __off32_t match (caddr_t addr, DWORD len, __off32_t start);
d290 1
a290 1
list::match (DWORD off, DWORD len)
d310 1
a310 1
__off32_t
d317 1
a317 1
  return ILLEGAL_SEEK;
d403 1
a403 1
mmap (caddr_t addr, size_t len, int prot, int flags, int fd, __off32_t off)
d405 1
a405 1
  syscall_printf ("addr %x, len %d, prot %x, flags %x, fd %d, off %d",
d447 1
a447 1
  DWORD gran_off = off & ~(granularity - 1);
d467 3
a469 1
	  DWORD fsiz = GetFileSize (fh->get_handle (), NULL);
d559 7
d601 1
a601 1
	  __off32_t li = ILLEGAL_SEEK;
d707 1
a707 1
		     int flags, __off32_t off)
d738 1
a738 1
			  int flags, __off32_t off)
d781 2
a782 1
  void *base = MapViewOfFileEx (h, access, 0, off, len,
d784 1
a784 1
  debug_printf ("%x = MapViewOfFileEx (h:%x, access:%x, 0, off:%d, len:%d, addr:%x)", base, h, access, off, len, (flags & MAP_FIXED) ? *addr : NULL);
@


1.50
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d238 1
a238 1
  return cygheap->fdtab.build_fhandler (-1, get_device (), "", 0);
@


1.49
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001 Red Hat, Inc.
@


1.48
log
@	* mmap.cc (mmap_record::find_empty): Add input parameter check.
@
text
@d259 1
a259 1
  off_t match (caddr_t addr, DWORD len, off_t start);
d310 2
a311 2
off_t
list::match (caddr_t addr, DWORD len, off_t start)
d317 1
a317 1
  return (off_t)-1;
d403 1
a403 1
mmap (caddr_t addr, size_t len, int prot, int flags, int fd, off_t off)
d592 1
a592 1
	  off_t li = -1;
d698 1
a698 1
		     int flags, off_t off)
d729 1
a729 1
			  int flags, off_t off)
@


1.47
log
@Eliminate excess whitespace.
@
text
@d112 2
@


1.46
log
@* mmap.cc (mmap): Assign 'fh' from cygheap_fdget.  Use 'fh' everywhere.
@
text
@d506 1
a506 1
     		 sharing file mappings only works reliable using named
@


1.45
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d448 1
a448 1
  fhandler_base *fh = NULL;
d462 2
a463 1
      if (cfd->get_device () == FH_DISK)
d470 1
a470 1
      else if (cfd->get_device () == FH_ZERO)
@


1.44
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d455 2
a456 1
      if (cygheap->fdtab.not_open (fd))
a457 1
	  set_errno (EBADF);
d462 1
a462 2
      fh = cygheap->fdtab[fd];
      if (fh->get_device () == FH_DISK)
d469 1
a469 1
      else if (fh->get_device () == FH_ZERO)
@


1.43
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d220 1
a220 1
static fhandler_disk_file fh_paging_file (NULL);
@


1.42
log
@        * mmap.cc (mmap): Move setting the access after evaluating fd.
        Remove useless comment.  Explain copy-on-write problem of 9x
        more detailed.  Don't set access to FILE_MAP_COPY on 9x only
        when anonymous mapping is requested.
        (fhandler_disk_file::mmap): Remove useless device check.
        Add debug output.
@
text
@d19 1
@


1.41
log
@        * mmap.cc (mmap): Don't reuse anonymous memory in MAP_FIXED case.
@
text
@a424 8
  DWORD access = (prot & PROT_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ;
  /* copy-on-write doesn't work correctly on 9x. To have at least read
     access we use *READ mapping on 9x when appropriate. It will still
     fail when needing write access, though. */
  if ((flags & MAP_PRIVATE) && (wincap.has_working_copy_on_write ()
  				|| (prot & ~PROT_READ)))
    access = FILE_MAP_COPY;

a426 14
#if 0
  /* Windows 95 does not have fixed addresses */
  /*
   * CV: This assumption isn't correct. See Microsoft Platform SDK, Memory,
   * description of call `MapViewOfFileEx'.
   */
  if ((!wincap.is_winnt ()) && (flags & MAP_FIXED))
    {
      set_errno (EINVAL);
      syscall_printf ("-1 = mmap(): win95 and MAP_FIXED");
      return MAP_FAILED;
    }
#endif

d497 15
a743 1
      && get_device () == FH_DISK
d754 1
d771 1
a771 1

@


1.41.2.1
log
@Merged changes from HEAD
@
text
@d425 8
d435 14
a518 15
  DWORD access = (prot & PROT_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ;
  /* copy-on-write doesn't work at all on 9x using anonymous maps.
     Workaround: Anonymous mappings always use normal READ or WRITE
		 access and don't use named file mapping.
     copy-on-write doesn't also work properly on 9x with real files.
     While the changes are not propagated to the file, they are
     visible to other processes sharing the same file mapping object.
     Workaround: Don't use named file mapping.  That should work since
     		 sharing file mappings only works reliable using named
		 file mapping on 9x.
  */
  if ((flags & MAP_PRIVATE)
      && (wincap.has_working_copy_on_write () || fd != -1))
    access = FILE_MAP_COPY;

d751 1
a761 1
      debug_printf ("named sharing");
d778 1
a778 1
  debug_printf ("%x = MapViewOfFileEx (h:%x, access:%x, 0, off:%d, len:%d, addr:%x)", base, h, access, off, len, (flags & MAP_FIXED) ? *addr : NULL);
@


1.41.2.2
log
@Merged changes from HEAD
@
text
@a18 1
#include "path.h"
@


1.41.2.3
log
@Merged changes from HEAD
@
text
@a111 2
  if (pages > mapped_pages)
    return (DWORD)-1;
d220 1
a220 1
static fhandler_disk_file fh_paging_file;
d448 1
a448 1
  fhandler_base *fh;
d455 1
a455 2
      cygheap_fdget cfd (fd);
      if (cfd < 0)
d457 1
d462 1
a462 1
      fh = cfd;
d506 1
a506 1
		 sharing file mappings only works reliable using named
@


1.41.2.4
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
d50 1
a50 1
    __off64_t offset_;
d56 1
a56 1
    mmap_record (int fd, HANDLE h, DWORD ac, __off64_t o, DWORD s, caddr_t b) :
d98 1
a98 1
    __off64_t map_map (__off64_t off, DWORD len);
d127 2
a128 2
__off64_t
mmap_record::map_map (__off64_t off, DWORD len)
d238 1
a238 1
  return cygheap->fdtab.build_fhandler (-1, get_device (), NULL);
d258 2
a259 2
  mmap_record *match (__off64_t off, DWORD len);
  long match (caddr_t addr, DWORD len, long start);
d290 1
a290 1
list::match (__off64_t off, DWORD len)
d310 2
a311 2
long
list::match (caddr_t addr, DWORD len, __off32_t start)
d317 1
a317 1
  return -1;
d403 1
a403 1
mmap64 (caddr_t addr, size_t len, int prot, int flags, int fd, __off64_t off)
d405 1
a405 1
  syscall_printf ("addr %x, len %d, prot %x, flags %x, fd %d, off %D",
d447 1
a447 1
  __off64_t gran_off = off & ~(granularity - 1);
d467 1
a467 3
	  DWORD high;
	  DWORD low = GetFileSize (fh->get_handle (), &high);
	  __off64_t fsiz = ((__off64_t)high << 32) + low;
a556 7
extern "C"
caddr_t
mmap (caddr_t addr, size_t len, int prot, int flags, int fd, __off32_t off)
{
  return mmap64 (addr, len, prot, flags, fd, (__off64_t)off);
}

d592 1
a592 1
	  long li = -1;
d698 1
a698 1
		     int flags, __off64_t off)
d729 1
a729 1
			  int flags, __off64_t off)
d772 1
a772 2
  DWORD high = off >> 32, low = off & 0xffffffff;
  void *base = MapViewOfFileEx (h, access, high, low, len,
d774 1
a774 1
  debug_printf ("%x = MapViewOfFileEx (h:%x, access:%x, 0, off:%D, len:%d, addr:%x)", base, h, access, off, len, (flags & MAP_FIXED) ? *addr : NULL);
@


1.41.2.5
log
@Merged changes from HEAD
@
text
@d23 2
a100 1
    int access (char *address);
d153 1
a153 4
	    {
	      debug_printf ("-1 = map_map (): %E");
	      return (__off64_t)-1;
	    }
d166 1
a166 4
    {
      debug_printf ("-1 = map_map (): %E");
      return (__off64_t)-1;
    }
a221 9
int
mmap_record::access (char *address)
{
  if (address < base_address_ || address >= base_address_ + size_to_map_)
    return 0;
  DWORD off = (address - base_address_) / getpagesize ();
  return MAP_ISSET (off);
}

d238 1
a238 1
  return cygheap->fdtab.build_fhandler (-1, get_device ());
a257 1
  void erase ();
a328 6
void
list::erase ()
{
  erase (nrecs-1);
}

d494 1
a494 7
	  if ((off = rec->map_map (off, len)) == (__off64_t)-1)
	    {
	      set_errno (ENOMEM);
	      syscall_printf ("-1 = mmap(): ENOMEM");
	      ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK|WRITE_LOCK, "mmap");
	      return MAP_FAILED;
	    }
d552 1
a552 9
  if ((off = rec->map_map (off, len)) == (__off64_t)-1)
    {
      fh->munmap (h, base, gran_len);
      l->erase ();
      set_errno (ENOMEM);
      syscall_printf ("-1 = mmap(): ENOMEM");
      ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
      return MAP_FAILED;
    }
d667 1
a667 1
	      if (rec->access (addr))
a668 4
		  /* Check whole area given by len. */
		  for (DWORD i = getpagesize (); i < len; ++i)
		    if (!rec->access (addr + i))
		      goto invalid_address_range;
d681 3
a683 3
	    }
	}
    }
a684 1
invalid_address_range:
d890 1
a890 1
fixup_mmaps_after_fork (HANDLE parent)
a926 14
		}
	      if (rec->get_access () == FILE_MAP_COPY)
		{
		  for (char *address = rec->get_address ();
		       address < rec->get_address () + rec->get_size ();
		       address += getpagesize ())
		    if (rec->access (address)
			&& !ReadProcessMemory (parent, address, address,
					       getpagesize (), NULL))
		      {
			system_printf ("ReadProcessMemory failed for MAP_PRIVATE address %p, %E",
				       rec->get_address ());
			return -1;
		      }
@


1.41.2.6
log
@Merged changes from HEAD
@
text
@d26 1
a26 1
#define PAGE_CNT(bytes) howmany((bytes),getpagesize())
d29 1
a29 1
#define MAPSIZE(pages)	howmany((pages),PGBITS)
d318 1
a318 2
	    && off + len <= recs[i].get_offset ()
			 + (PAGE_CNT (recs[i].get_size ()) * getpagesize ()))
d330 1
a330 2
	&& addr + len <= recs[i].get_address ()
			 + (PAGE_CNT (recs[i].get_size ()) * getpagesize ()))
@


1.41.2.7
log
@Merged changes from HEAD
@
text
@d451 1
a451 1
  SetResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d461 1
a461 1
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d484 1
a484 1
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d521 1
a521 1
	      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK|WRITE_LOCK, "mmap");
d526 1
a526 1
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d550 1
a550 1
      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d573 1
a573 1
	  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d587 1
a587 1
      ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d592 1
a592 1
  ReleaseResourceLock (LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
d620 1
a620 1
  SetResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d626 1
a626 1
      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d652 1
a652 1
	      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d661 1
a661 1
  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "munmap");
d683 1
a683 1
  SetResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d689 1
a689 1
      ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d719 1
a719 1
		  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d731 1
a731 1
  ReleaseResourceLock (LOCK_MMAP_LIST, WRITE_LOCK | READ_LOCK, "msync");
d810 1
a810 1
	h = CreateFileMapping (get_handle (), &sec_none, protect, 0, 0, namebuf);
@


1.40
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d506 1
a506 1
  if (l && fd == -1 && off == 0)
@


1.39
log
@Update copyrights.
@
text
@d86 1
a86 1
	if (iswinnt)
d147 1
a147 1
	  if (iswinnt
d160 1
a160 1
  if (iswinnt
d177 1
a177 1
  if (iswinnt
d195 1
a195 1
  if (!iswinnt)
d429 2
a430 1
  if ((flags & MAP_PRIVATE) && (iswinnt || (prot & ~PROT_READ)))
d441 1
a441 1
  if ((!iswinnt) && (flags & MAP_FIXED))
d749 1
a749 1
  if (!iswinnt
@


1.38
log
@* child_info.h: Modify magic number.
* dcrt0.cc (_cygwin_testing): Define.
(_dll_crt0): Set _cygwin_testing if CYGWIN_TESTING environment variable exists.
Don't issue "conflicting versions" error if _cygwin_testing is true.
* shared.cc (shared_name): Use _cygwin_testing global rather than testing the
environment.
* syscalls.cc (_write): Remove debugging info.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001 Cygnus Solutions.
@


1.37
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d65 1
a65 1
        if (fd >= 0 && !cygheap->fdtab.not_open (fd))
d83 2
a84 2
        /* Allocate one bit per page */
        map_map_ = (DWORD *) calloc (MAPSIZE(PAGE_CNT (size_to_map_)),
d90 1
a90 1
	                         PAGE_NOACCESS, &old_prot))
d92 1
a92 1
          }
d114 2
a115 2
        DWORD cnt;
        for (cnt = 0; cnt < pages; ++cnt)
d118 1
a118 1
        if (cnt >= pages)
d146 1
a146 1
        {
d148 2
a149 2
              && !VirtualProtect (base_address_ + off * getpagesize (),
	                          len * getpagesize (), prot, &old_prot))
d162 1
a162 1
		          len * getpagesize (), prot, &old_prot))
d179 1
a179 1
		          len * getpagesize (), PAGE_NOACCESS, &old_prot))
d214 1
a214 1
	            getpagesize (),
d312 1
a312 1
        && addr + len <= recs[i].get_address () + recs[i].get_size ())
d357 1
a357 1
         it's not an anonymous mapping. */
d359 1
a359 1
        || (fd != -1 && lists[i]->hash == cygheap->fdtab[fd]->get_namehash ()))
d484 1
a484 1
        {
d492 1
a492 1
        fd = -1;
d541 7
a547 7
        {
          fh->munmap (h, base, gran_len);
          set_errno (ENOMEM);
          syscall_printf ("-1 = mmap(): ENOMEM");
          ReleaseResourceLock(LOCK_MMAP_LIST, READ_LOCK | WRITE_LOCK, "mmap");
          return MAP_FAILED;
        }
d600 1
a600 1
	        {
d602 1
a602 1
                  fh->munmap (rec->get_handle (), addr, len);
d664 1
a664 1
                  int ret = fh->msync (rec->get_handle (), addr, len, flags);
d667 1
a667 1
                  if (ret)
d669 1
a669 1
                  else
d701 1
a701 1
                     int flags, off_t off)
d732 1
a732 1
                          int flags, off_t off)
d754 1
a754 1
         mapping of the same file. Even that uprising isn't bullet
d759 1
a759 1
        namebuf[i] = cyg_tolower (namebuf [i]);
d776 1
a776 1
                               (flags & MAP_FIXED) ? *addr : NULL);
d781 4
a784 4
        {
          __seterrno ();
          syscall_printf ("-1 = mmap(): MapViewOfFileEx failed with %E");
        }
d786 1
a786 1
        {
d788 2
a789 2
          syscall_printf ("-1 = mmap(): address shift with MAP_FIXED given");
        }
d909 4
a912 4
					            rec->get_access (),
					            rec->get_offset (),
					            rec->get_size (),
					            rec->get_address ());
@


1.36
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d86 1
a86 1
	if (os_being_run == winNT)
d147 1
a147 1
	  if (os_being_run == winNT
d160 1
a160 1
  if (os_being_run == winNT
d177 1
a177 1
  if (os_being_run == winNT
d195 1
a195 1
  if (os_being_run != winNT)
d429 1
a429 1
  if ((flags & MAP_PRIVATE) && (os_being_run == winNT || (prot & ~PROT_READ)))
d440 1
a440 1
  if ((os_being_run != winNT) && (flags & MAP_FIXED))
d748 1
a748 1
  if (os_being_run != winNT
@


1.35
log
@        * mmap.cc (fhandler_disk_file::mmap): Try to open file mappings
        by a unified name when running under 9x/ME. If that failes, create
        the file mapping using the unified name.
@
text
@d17 1
a24 1
#include "security.h"
@


1.34
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d25 1
d743 26
a768 7
  HANDLE h = CreateFileMapping (get_handle (),
  				&sec_none,
				protect,
				0,
  				get_handle () == INVALID_HANDLE_VALUE ? len : 0,
				NULL);
  if (h == 0)
@


1.33
log
@forced commit
@
text
@d431 1
a431 1
  SetResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d455 1
a455 1
	  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d478 1
a478 1
	  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d512 1
a512 1
	  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d521 1
a521 1
      ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d544 1
a544 1
          ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d555 1
a555 1
  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d576 1
a576 1
  SetResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," munmap");
d582 1
a582 1
      ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," munmap");
d608 1
a608 1
	      ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," munmap");
d617 1
a617 1
  ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," munmap");
d639 1
a639 1
  SetResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," msync");
d645 1
a645 1
      ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," msync");
d671 1
a671 1
		  ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," msync");
d682 1
a682 1
  ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," msync");
@


1.32
log
@        * mmap.cc (mmap): Drop usage of the same memory area if the same
        region of the same file is mapped twice.
@
text
@@


1.31
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d502 3
a504 3
     already performed mapping. Only valid for MAP_SHARED and for
     MAP_ANON in a special case of MAP_PRIVATE. */
  if (l && ((flags & MAP_SHARED) || (fd == -1 && off == 0)))
@


1.30
log
@        * mmap.cc: Move fh_paging_file from some functions to be
        a global static variable.
        (class mmap_record): Add `devtype_' member to remember
        the device type of the file. Add declaration for methods
        `get_device', `alloc_fh' and `free_fh'.
        (mmap_record::mmap_record): Initialize `devtype_' correctly.
        (mmap_record::alloc_fh): New method.
        (mmap_record::free_fh): Ditto.
        (munmap): Use new mmap_record::alloc_fh and mmap_record::free_fh
        methods to create a correct fhandler.
        (msync): Ditto.
        (fixup_mmaps_after_fork): Ditto.
@
text
@d64 2
a65 2
        if (fd >= 0 && !fdtab.not_open (fd))
	  devtype_ = fdtab[fd]->get_device ();
d234 1
a234 1
  return fdtab.build_fhandler (-1, get_device (), "", 0);
d358 1
a358 1
        || (fd != -1 && lists[i]->hash == fdtab[fd]->get_namehash ()))
d369 1
a369 1
    l->hash = fdtab[fd]->get_namehash ();
d474 1
a474 1
      if (fdtab.not_open (fd))
d481 1
a481 1
      fh = fdtab[fd];
@


1.29
log
@       * mmap.cc (mmap): Fix conditional for previous patch.
@
text
@d20 1
d46 1
d55 12
a66 2
       fdesc_ (fd), mapping_handle_ (h), access_mode_ (ac), offset_ (o),
       size_to_map_ (s), base_address_ (b) , map_map_ (NULL) { ; }
d73 1
d99 3
d218 26
a466 1
  fhandler_disk_file fh_paging_file (NULL);
d592 1
a592 1
      if (l != 0)
a593 12
	  int fd = l->fd;
	  fhandler_disk_file fh_paging_file (NULL);
	  fhandler_base *fh;

	  if (fd == -1 || fdtab.not_open (fd))
	    {
	      fh_paging_file.set_io_handle (INVALID_HANDLE_VALUE);
	      fh = &fh_paging_file;
	    }
	  else
	    fh = fdtab[fd];

d600 1
d602 1
a656 12
	  int fd = l->fd;
	  fhandler_disk_file fh_paging_file (NULL);
	  fhandler_base *fh;

	  if (fd == -1 || fdtab.not_open (fd))
	    {
	      fh_paging_file.set_io_handle (INVALID_HANDLE_VALUE);
	      fh = &fh_paging_file;
	    }
	  else
	    fh = fdtab[fd];

d662 1
d664 1
d887 8
a894 12
	      BOOL ret;
	      fhandler_disk_file fh_paging_file (NULL);
	      fhandler_base *fh;
	      if (rec->get_fd () == -1) /* MAP_ANONYMOUS */
		fh = &fh_paging_file;
	      else
	        fh = fdtab[rec->get_fd ()];
	      ret = fh->fixup_mmap_after_fork (rec->get_handle (),
					       rec->get_access (),
					       rec->get_offset (),
					       rec->get_size (),
					       rec->get_address ());
@


1.28
log
@        * mmap.cc (mmap): Outflank copy-on-write problem on 9x by
        setting access mode to FILE_MAP_READ when read access is requested.
@
text
@d386 1
a386 1
  if ((flags & MAP_PRIVATE) && (os_being_run == winNT || !(prot & PROT_READ)))
@


1.27
log
@        * mmap.cc (map::get_list_by_fd): Avoid calling `get_namehash' when
        file descriptor is -1.
@
text
@d383 4
a386 1
  if (flags & MAP_PRIVATE)
@


1.26
log
@        * mmap.cc (fhandler_disk_file::mmap): Use `addr' correctly.
	* fhandler_mem.cc (fhandler_dev_mem::mmap): Ditto.
@
text
@d316 1
a316 1
        || lists[i]->hash == fdtab[fd]->get_namehash ())
@


1.25
log
@        * mmap.cc (mmap): Check for reusing a mapping only on MAP_SHARED
        and on MAP_PRIVATE|MAP_ANON in the special case of offset 0.
@
text
@d732 1
a732 1
                               (flags & MAP_FIXED) ? addr : NULL);
d734 1
a734 1
  if (!base || ((flags & MAP_FIXED) && base != addr))
@


1.24
log
@        * mmap.cc (class list): Add member `hash'.
        (list::list): Initialize `hash'.
        (list::get_list_by_fd): Use filepath hash value to get the correct
        mapping list if it's not an anonymous mapping.
        (map::add_list): Initialize `hash' with filepath hash value.
        (mmap): Check for reusing a mapping only on MAP_SHARED.
@
text
@d458 3
a460 2
     already performed mapping. Only for MAP_SHARED mapping. */
  if (l && (flags & MAP_SHARED))
@


1.23
log
@        * mmap.cc (mmap_record::fixup_map): New method to duplicate
        the memory protection in a just forked child.
        (mmap): Realign gran_len to page boundary only on anonymous
        mapping before saving in the mmap_record.
        (munmap): Cleanup code.
        (msync): Ditto.
        (fixup_mmaps_after_fork): Ditto. Call mmap_record::fixup_map now.
@
text
@d207 1
d217 1
a219 3
  nrecs = 0;
  maxrecs = 10;
  fd = 0;
d311 7
a317 1
    if (lists[i]->fd == fd)
d326 2
d455 2
d458 2
a459 3
     already performed mapping. */
  list *l = mmapped_areas->get_list_by_fd (fd);
  if (l)
d463 1
a463 1
        {
@


1.22
log
@        * mmap.cc (mmap): Remove obsolete check for MAP_SHARED|MAP_ANON as
        being invalid.
@
text
@d85 1
d175 27
d475 2
a476 1
  gran_len = PAGE_CNT (gran_len) * getpagesize ();
d536 1
a536 2
  int it;
  for (it = 0; it < mmapped_areas->nlists; ++it)
d541 12
d554 1
a554 1
	  while ((li = l->match(addr, len, li)) >= 0)
a558 11
                  int fd = l->fd;
                  fhandler_disk_file fh_paging_file (NULL);
                  fhandler_base *fh;

                  if (fd == -1 || fdtab.not_open (fd))
                    {
                      fh_paging_file.set_io_handle (INVALID_HANDLE_VALUE);
                      fh = &fh_paging_file;
                    }
                  else
                    fh = fdtab[fd];
d609 1
a609 2
  int it;
  for (it = 0; it < mmapped_areas->nlists; ++it)
d614 13
a626 2
	  int li;
	  for (li = 0; li < l->nrecs; ++li)
d628 2
a629 2
	      mmap_record rec = l->recs[li];
	      if (rec.get_address () == addr)
d631 1
a631 13
                  int fd = l->fd;
                  fhandler_disk_file fh_paging_file (NULL);
                  fhandler_base *fh;

                  if (fd == -1 || fdtab.not_open (fd))
                    {
                      fh_paging_file.set_io_handle (INVALID_HANDLE_VALUE);
                      fh = &fh_paging_file;
                    }
                  else
                    fh = fdtab[fd];

                  int ret = fh->msync (rec.get_handle (), addr, len, flags);
d848 1
a848 1
	      mmap_record rec = l->recs[li];
d851 2
a852 2
		  rec.get_fd (), rec.get_handle (), rec.get_access (),
		  rec.get_offset (), rec.get_size (), rec.get_address ());
d857 1
a857 1
	      if (rec.get_fd () == -1) /* MAP_ANONYMOUS */
d860 6
a865 6
	        fh = fdtab[rec.get_fd ()];
	      ret = fh->fixup_mmap_after_fork (rec.get_handle (),
					       rec.get_access (),
					       rec.get_offset (),
					       rec.get_size (),
					       rec.get_address ());
d869 1
a869 1
				 rec.get_address ());
d872 1
@


1.21
log
@        * mmap.cc (mmap_record::find_empty): Fix loop condition.
@
text
@a338 1
      || ((flags & MAP_SHARED) && (flags & MAP_ANONYMOUS))
d411 2
a412 11
        {
	  /* mmap /dev/zero is like MAP_ANONYMOUS. */
	  if (flags & MAP_SHARED)
	    {
	      set_errno (EINVAL);
	      syscall_printf ("-1 = mmap(): EINVAL");
	      ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
	      return MAP_FAILED;
	    }
          fd = -1;
	}
@


1.20
log
@        * mmap.cc (fhandler_disk_file::mmap): Call CreateFileMapping with
        len != 0 only when performing an anonymous mapping.
@
text
@d93 1
a93 1
  for (start = 0; start < mapped_pages - pages; ++start)
@


1.19
log
@        * mmap.cc (mmap): Initialize fh to avoid compiler warnings.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000 Cygnus Solutions.
d692 6
a697 1
  HANDLE h = CreateFileMapping (get_handle(), &sec_none, protect, 0, len, NULL);
@


1.18
log
@        * mmap.cc (mmap): Add more parameter checking. Change error output
        in case of EINVAL. Treat mmapping /dev/zero like MAP_ANONYMOUS.
@
text
@d389 1
a389 1
  fhandler_base *fh;
@


1.17
log
@        * mmap.cc: include <unistd.h>. Define some bit operations for
        the new page map.
        (mmap_record): Change type of base_address_ to caddr_t.
        Add map_map_ member. Add several methods to manipulate map_map_.
        (mmap_record::alloc_map): New method.
        (mmap_record::free_map): Ditto.
        (mmap_record::find_empty): Ditto.
        (mmap_record::map_map): Ditto.
        (mmap_record::unmap_map): Ditto.
        (list::add_record): Change return type to `mmap_record *'.
        Allocate page map.
        (list::match): New method.
        (mmap): Partly rewritten to take care for the new page map. Add some
        parameter checking.
        (munmap): Ditto.
@
text
@a334 4
  DWORD access = (prot & PROT_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ;
  if (flags & MAP_PRIVATE)
    access = FILE_MAP_COPY;

d337 3
d344 1
a344 1
      syscall_printf ("-1 = mmap(): Invalid parameters");
d348 4
a383 16
  /* First check if this mapping matches into the chunk of another
     already performed mapping. */
  list *l = mmapped_areas->get_list_by_fd (fd);
  if (l)
    {
      mmap_record *rec;
      if ((rec = l->match (off, len)) != NULL)
        {
	  off = rec->map_map (off, len);
	  caddr_t ret = rec->get_address () + off;
	  syscall_printf ("%x = mmap() succeeded", ret);
	  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
	  return ret;
	}
    }

d393 1
a393 6
  if (fd == -1)
    {
      fh_paging_file.set_io_handle (INVALID_HANDLE_VALUE);
      fh = &fh_paging_file;
    }
  else
d410 33
@


1.16
log
@        * fhandler.h (fhandler_base): New method `fixup_mmap_after_fork'.
        (fhandler_disk_file: Ditto.
        (fhandler_dev_mem): Ditto.
        * fhandler_mem.cc (fhandler_dev_mem::open): Set OBJ_INHERIT attribute
        for device\physicalmemory handle.
        (fhandler_dev_mem::mmap): Ditto.
        * fhandler_mem.cc (fhandler_dev_mem::fixup_mmap_after_fork): New method.
        * mmap.cc (mmap_record): Add private `fdesc_' member. Change constructor
        accordingly.
        (get_fd): New method.
        (mmap): Use new mmap_record constructor.
        (fhandler_base::fixup_mmap_after_fork): New method.
        (fhandler_disk_file::fixup_mmap_after_fork): Ditto.
        (fixup_mmaps_after_fork): Call `fixup_mmap_after_fork' of appropriate
        fhandler class.
@
text
@d12 1
d25 9
d48 2
a49 1
    void *base_address_;
d52 1
a52 1
    mmap_record (int fd, HANDLE h, DWORD ac, DWORD o, DWORD s, void *b) :
d54 1
a54 1
       size_to_map_ (s), base_address_ (b) { ; }
d64 21
a84 1
    void *get_address () const { return base_address_; }
d87 87
d181 1
a181 1
  void add_record (mmap_record r);
d183 2
d197 2
d202 1
a202 1
void
d210 35
a244 1
  recs[nrecs++] = r;
d250 1
d327 8
d339 10
d361 1
a361 1
      return (caddr_t) -1;
d373 2
a374 1
	  return (caddr_t) -1;
d378 23
d406 1
a406 1
  if ((flags & MAP_ANONYMOUS) || fd == -1)
a409 2
      /* Ensure that fd is recorded as -1 */
      fd = -1;
d419 1
a419 1
	  return (caddr_t) -1;
d422 7
d431 1
a431 1
  h = fh->mmap (&base, len, access, flags, off);
d439 1
a439 1
  /* Now we should have a successfully mmaped area.
d442 2
a443 1
  mmap_record mmap_rec (fd, h, access, off, len, base);
a447 1
  list *l = mmapped_areas->get_list_by_fd (fd);
d454 1
a454 1
          fh->munmap (h, base, len);
d464 4
a467 3
  l->add_record (mmap_rec);

  syscall_printf ("%x = mmap() succeeded", base);
d469 1
a469 1
  return base;
d481 8
d508 2
a509 1
	  for (int li = 0; li < l->nrecs; ++li)
d511 3
a513 3
	      mmap_record rec = l->recs[li];
	      if (rec.get_address () == addr && rec.get_size () == len)
		{
d525 1
a525 1
                  fh->munmap (rec.get_handle (), addr, len);
a528 3
		  syscall_printf ("0 = munmap(): %x", addr);
		  ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," munmap");
		  return 0;
d530 6
a535 3
	     }
	 }
     }
@


1.15
log
@* mmap.cc (munmap): Check that mmap and munmap length match.
@
text
@d33 1
d41 2
a42 2
    mmap_record (HANDLE h, DWORD ac, DWORD o, DWORD s, void *b) :
       mapping_handle_ (h), access_mode_ (ac), offset_ (o),
d48 1
d211 2
d238 1
a238 1
  mmap_record mmap_rec (h, access, off, len, base);
d441 8
d513 9
d599 17
a615 11
	      debug_printf ("h %x, access %x, offset %d, size %d, address %p",
		  rec.get_handle (), rec.get_access (), rec.get_offset (),
		  rec.get_size (), rec.get_address ());

	      /* Now re-create the MapViewOfFileEx call */
	      void *base = MapViewOfFileEx (rec.get_handle (),
					    rec.get_access (), 0,
					    rec.get_offset (),
					    rec.get_size (),
					    rec.get_address ());
	      if (base != rec.get_address ())
d617 1
a617 1
		  system_printf ("base address %p fails to match requested address %p",
@


1.14
log
@Throughout use myself->ppid_handle rather than parent_alive.
* child_info.h (child_info): Eliminate parent_alive.
* dcrt0.cc (dll_crt0_1): Call fork_init for debugging pid creation.
* fork.cc (fork_child): Reflect change to fixup_mmaps_after_fork arguments.
(slow_pid_reuse): New function to grab last 'n' pids to prevent pid reuse.
(fork_parent): Move last_fork_proc into slow_pid_reuse.  Handle fork_pids
debugging.  Eliminate unnecessary call to set_child_mmap_ptr.
(fork_init): New debugging function.
* mmap.cc (fixup_mmaps_after_fork): Renamed from recreate_mmaps_after_fork.
Rely on copied data after a fork.
(set_child_mmap_ptr): Eliminate.
* pinfo.h (_pinfo): Eliminate parent_alive, mmap_ptr and reflect above changes.
* spawn.cc (spawn_guts): Eliminate vestiges of "old way" of sending new hProc
to parent process.
@
text
@d291 1
a291 2
	  int li;
	  for (li = 0; li < l->nrecs; ++li)
d294 1
a294 1
	      if (rec.get_address () == addr)
@


1.13
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d159 1
a159 1
static NO_COPY map *mmapped_areas;
d188 1
a188 1
  if (mmapped_areas == 0)
d192 1
a192 1
      if (mmapped_areas == 0)
d274 1
a274 1
  if (mmapped_areas == 0)
d276 1
a276 1
      syscall_printf ("-1 = munmap(): mmapped_areas == 0");
d347 1
a347 1
  if (mmapped_areas == 0)
d349 1
a349 1
      syscall_printf ("-1 = msync(): mmapped_areas == 0");
d552 1
a552 1
 * point we are passed a valid mmaped_areas map, and all the
d559 1
a559 1
recreate_mmaps_after_fork (void *param)
a560 2
  map *areas = (map *)param;
  void *base;
d562 1
a562 1
  debug_printf ("recreate_mmaps_after_fork, mmapped_areas %p", areas);
d565 1
a565 1
  if (areas == 0)
d569 1
a569 4

  int it;

  for (it = 0; it < areas->nlists; ++it)
d571 1
a571 1
      list *l = areas->lists[it];
d584 5
a588 5
	      base = MapViewOfFileEx (rec.get_handle (),
				      rec.get_access (), 0,
				      rec.get_offset (),
				      rec.get_size (),
				      rec.get_address ());
d595 3
a597 6
	     }
	  }
      }

  /* Now set our mmap record in case the child forks. */
  mmapped_areas = areas;
a599 1

a600 9
}

/* Set a child mmap ptr from our static one. Used to set child mmap
   pointer for fork. */

void __stdcall
set_child_mmap_ptr (_pinfo *child)
{
  child->mmap_ptr = (void *) mmapped_areas;
@


1.12
log
@        * fhandler.h (fhandler_dev_mem): Add methods mmap, munmap and msync.
        Add `unit' member.
        * fhandler_mem.cc (fhandler_dev_mem): Initialize `unit' as well.
        (init): Care for differences between /dev/mem, /dev/kmem (not
        implemented yet) and /dev/port.
        (open): Change debug message to reflect the device.
        (mmap): New function.
        (munmap): Ditto.
        (msync): Ditto.
        (fstat): Use unit when setting st_dev in stat structure.
        * mmap.cc (mmap): Handle MAP_ANONYMOUS flag.
        Change error handling slightly.
        * path.cc (get_device_number): Handle /dev/port.
@
text
@a18 1
#include "thread.h"
@


1.11
log
@        =====================================
        These changes require rebuilding all.
        =====================================
        * fhandler.h: Add mmap(), munmap() and msync() to fhandler_base
        and fhandler_disk_file.
        * mmem.cc (mmap): Eliminated device dependent implementation details.
        These are moved to the appropriate fhandler class.
        (munmap): Ditto.
        (msync): Ditto.
        (fhandler_base::mmap): New method.
        (fhandler_base::munmap): Ditto.
        (fhandler_base::msync): Ditto.
        (fhandler_disk_file::mmap): Ditto.
        (fhandler_disk_file::munmap): Ditto.
        (fhandler_disk_file::msync): Ditto.
@
text
@d206 1
a206 1
  if (fd == -1)
d466 10
a475 2
      __seterrno ();
      syscall_printf ("-1 = mmap(): MapViewOfFileEx failed with %E");
@


1.10
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d169 4
d175 1
d177 4
d187 1
d201 4
a204 13
  DWORD access = (prot & PROT_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ;
  if (flags & MAP_PRIVATE)
    access = FILE_MAP_COPY;
  DWORD protect;

  if (access & FILE_MAP_COPY)
    protect = PAGE_WRITECOPY;
  else if (access & FILE_MAP_WRITE)
    protect = PAGE_READWRITE;
  else
    protect = PAGE_READONLY;

  HANDLE hFile;
d207 4
a210 1
    hFile = (HANDLE) 0xFFFFFFFF;
d221 1
a221 1
      hFile = fdtab[fd]->get_handle ();
d224 3
a226 2
  HANDLE h = CreateFileMapping (hFile, &sec_none, protect, 0, len, NULL);
  if (h == 0)
a227 2
      __seterrno ();
      syscall_printf ("-1 = mmap(): CreateFileMapping failed with %E");
d229 1
a229 28
      return (caddr_t) -1;
    }

  void *base;

  if (flags & MAP_FIXED)
    {
      base = MapViewOfFileEx (h, access, 0, off, len, addr);
      if (base != addr)
	{
	  __seterrno ();
	  syscall_printf ("-1 = mmap(): MapViewOfFileEx failed with %E");
	  CloseHandle (h);
	  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
	  return (caddr_t) -1;
	}
    }
  else
    {
      base = MapViewOfFile (h, access, 0, off, len);
      if (base == 0)
	{
	  __seterrno ();
	  syscall_printf ("-1 = mmap(): MapViewOfFile failed with %E");
	  CloseHandle (h);
	  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
	  return (caddr_t) -1;
	}
a234 1

a239 1

d246 7
a252 8
	{
	  UnmapViewOfFile (base);
	  CloseHandle (h);
	  set_errno (ENOMEM);
	  syscall_printf ("-1 = mmap(): ENOMEM");
	  ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
	  return (caddr_t) -1;
	}
d261 1
a261 1
  return (caddr_t) base;
d298 13
a310 3
		  /* Unmap the area */
		  UnmapViewOfFile (addr);
		  CloseHandle (rec.get_handle ());
d320 1
a321 1

d337 150
a488 1
      syscall_printf ("-1 = msync: %E");
a491 1
  syscall_printf ("0 = msync");
@


1.9
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d23 1
@


1.8
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d213 1
a213 1
          ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d238 1
a238 1
          ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d250 1
a250 1
          ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d276 1
a276 1
          ReleaseResourceLock(LOCK_MMAP_LIST,READ_LOCK|WRITE_LOCK," mmap");
d330 1
a330 1
                  ReleaseResourceLock(LOCK_MMAP_LIST,WRITE_LOCK|READ_LOCK," munmap");
@


1.7
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d16 1
d18 4
a22 1
#include "cygerrno.h"
@


1.6
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d18 1
@


1.5
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d16 2
a17 1

@


1.4
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d203 1
a203 1
      if (dtable.not_open (fd))
d210 1
a210 1
      hFile = dtable[fd]->get_handle ();
@


1.3
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d11 1
a16 1
#include "winsup.h"
@


1.2
log
@* mmap.cc (list::erase): Increment loop counter.
(map::erase): Likewise.
@
text
@d471 1
a471 1
set_child_mmap_ptr (pinfo *child)
@


1.1
log
@Initial revision
@
text
@d86 1
a86 1
  while (i < nrecs-1)
d140 1
a140 1
  while (i < nlists-1)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
