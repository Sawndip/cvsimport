head	1.70;
access;
symbols
	cygwin-1_7_35-release:1.70
	cygwin-1_7_34-release:1.70
	cygwin-1_7_33-release:1.70
	cygwin-1_7_32-release:1.70
	cygwin-1_7_31-release:1.70
	cygwin-1_7_30-release:1.70
	cygwin-1_7_29-release:1.70
	cygwin-1_7_29-release-branchpoint:1.70.0.2
	cygwin-pre-user-db:1.70
	cygwin-1_7_28-release:1.70
	cygwin-1_7_27-release:1.70
	cygwin-1_7_26-release:1.70
	cygwin-1_7_25-release:1.70
	cygwin-1_7_24-release:1.67
	cygwin-1_7_23-release:1.67
	cygwin-1_7_22-release:1.67
	cygwin-1_7_21-release:1.67
	cygwin-1_7_20-release:1.67
	cygwin-1_7_19-release:1.67
	cygwin-64bit-postmerge:1.67
	cygwin-64bit-premerge-branch:1.66.0.2
	cygwin-64bit-premerge:1.66
	cygwin-1_7_18-release:1.66
	post-ptmalloc3:1.65.2.7
	pre-ptmalloc3:1.65.2.6
	cygwin-1_7_17-release:1.65
	cygwin-64bit-branch:1.65.0.2
	cygwin-1_7_16-release:1.65
	cygwin-1_7_15-release:1.64
	cygwin-1_7_14_2-release:1.64
	cygwin-1_7_14-release:1.64
	cygwin-1_7_12-release:1.64
	cygwin-1_7_11-release:1.64
	cygwin-1_7_10-release:1.64
	signal-rewrite:1.64.0.2
	pre-notty:1.60
	cygwin-1_7_9-release:1.56
	cv-post-1_7_9:1.56.0.6
	cygwin-1_7_8-release:1.56
	cygwin-1_7_7-release:1.56
	cygwin-1_7_5-release:1.56
	cygwin-1_7_4-release:1.56
	cygwin-1_7_3-release:1.56
	cygwin-1_7_2-release:1.56
	fifo_doover3:1.56.0.4
	cygwin-1_7_1-release:1.56
	prefifo:1.56
	cv-branch-2:1.56.0.2
	pre-ripout-set_console_state_for_spawn:1.55
	EOL_registry_mounts:1.54
	preoverlapped:1.54
	drop_9x_support_start:1.54
	cr-0x5f1:1.53.0.4
	cv-branch:1.53.0.2
	pre-ptymaster-archetype:1.52
	cr-0x3b58:1.50.0.4
	cr-0x5ef:1.50.0.2
	after-mmap-privanon-noreserve:1.49
	after-mmap-revamp:1.49
	before-mmap-revamp:1.49
	cgf-more-exit-sync:1.48
	post_wait_sig_exit:1.48
	pre_wait_sig_exit:1.47
	reparent-point:1.41
	noreparent:1.41.0.2
	cr-0x5e6:1.40.0.2
	cr-0x9e:1.39.0.4
	cr-0x9d:1.39.0.2
	cgf-deleteme:1.38.0.2
	pre-sigrewrite:1.37
	corinna-01:1.37
	cr-0x9c:1.36.0.4
	cr-0x9b:1.36.0.2
	cr-0x99:1.35
	Z-emcb-cygwin_daemon:1.34.0.2
	w32api-2_2:1.32
	mingw-runtime-2_4:1.32
	pre-cgf-merge:1.36
	cgf-dev-branch:1.31.0.12
	predaemon:1.25
	cygwin_daemon_merge_HEAD:1.25
	pregp02r1:1.25.0.30
	cygnus_cvs_20020108_pre:1.25
	Z-cygwin_daemon_merge-new_HEAD:1.28
	Z-cygwin_daemon_merge_HEAD:1.28
	cygwin_daemon:1.23.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.70
date	2013.08.31.10.21.48;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2013.08.30.21.02.02;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2013.08.30.20.01.10;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2012.05.21.19.45.12;	author corinna;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2011.08.09.12.00.27;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.21.17.52.05;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.21.15.23.24;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.18.08.43.49;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.16.10.27.14;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2011.05.10.15.39.02;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.05.11.15.28;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2006.10.31.18.41.16;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.12.13.59.17;	author corinna;	state Exp;
branches
	1.53.4.1;
next	1.52;

1.52
date	2006.03.13.21.10.14;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.18.20.40.52;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.26.19.34.59;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.25.19.53.52;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2005.09.14.18.30.21;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2005.09.12.03.55.16;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2005.09.10.01.37.20;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.02.17.35.22;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.02.17.12.36;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.02.04.51.09;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.02.04.46.51;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.07.18.27.54;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.31.22.02.15;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.22.19.25.56;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.07.04.13.41;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2002.10.22.16.18.55;	author cgf;	state Exp;
branches
	1.31.12.1;
next	1.30;

1.30
date	2002.10.21.01.00.57;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.19.00.35.20;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.09.19.06.50;	author cgf;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.18.03.34.05;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.29.00.46.25;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.15.12.53.30;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.15.12.25.00;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.12.22.15.47;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.25.16.36.12;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.03.20.16.23;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.03.20.14.06;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.65.2.1
date	2012.11.08.17.25.47;	author corinna;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2013.01.21.13.52.06;	author corinna;	state Exp;
branches;
next	1.65.2.3;

1.65.2.3
date	2013.01.29.11.40.45;	author corinna;	state Exp;
branches;
next	1.65.2.4;

1.65.2.4
date	2013.02.04.15.43.12;	author corinna;	state Exp;
branches;
next	1.65.2.5;

1.65.2.5
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	1.65.2.6;

1.65.2.6
date	2013.02.12.13.25.41;	author corinna;	state Exp;
branches;
next	1.65.2.7;

1.65.2.7
date	2013.02.27.08.36.58;	author corinna;	state Exp;
branches;
next	1.65.2.8;

1.65.2.8
date	2013.03.07.17.33.59;	author corinna;	state Exp;
branches;
next	;

1.53.4.1
date	2006.11.08.10.00.06;	author corinna;	state Exp;
branches;
next	;

1.38.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	;

1.31.12.1
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.31.12.2;

1.31.12.2
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.31.12.3;

1.31.12.3
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.31.12.4;

1.31.12.4
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.31.12.5;

1.31.12.5
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	1.31.12.6;

1.31.12.6
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.23.4.1
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2002.06.13.14.34.06;	author rbcollins;	state Exp;
branches;
next	1.23.4.4;

1.23.4.4
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.70
log
@	* heap.cc (RAISEHEAP_SIZE): New definition.
	(user_heap_info::sbrk): Make failed commit an error condition again.
	Only reserve RAISEHEAP_SIZE sized chunk for further heap reservations
	by default.
@
text
@/* heap.cc: Cygwin heap manager.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "cygerrno.h"
#include "shared_info.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "child_info.h"
#include "ntdll.h"
#include <sys/param.h>

#define assert(x)

static ptrdiff_t page_const;

/* Minimum size of the base heap. */
#define MINHEAP_SIZE (4 * 1024 * 1024)
/* Chunksize of subsequent heap reservations. */
#define RAISEHEAP_SIZE (1 * 1024 * 1024)

static uintptr_t
eval_start_address ()
{
#ifdef __x86_64__
  /* On 64 bit, we choose a fixed address outside the 32 bit area.  The
     executable starts at 0x1:00400000L, the Cygwin DLL starts at
     0x1:80040000L, other rebased DLLs are located in the region from
     0x2:00000000L up to 0x4:00000000L, -auto-image-based DLLs are located
     in the region from 0x4:00000000L up to 0x6:00000000L.
     So we let the heap start at 0x6:00000000L. */
  uintptr_t start_address = 0x600000000L;
#else
  /* Starting with Vista, Windows performs heap ASLR.  This spoils the entire
     region below 0x20000000 for us, because that region is used by Windows
     to randomize heap and stack addresses.  Therefore we put our heap into a
     safe region starting at 0x20000000.  This should work right from the start
     in 99% of the cases. */
  uintptr_t start_address = 0x20000000L;
  if ((uintptr_t) NtCurrentTeb () >= 0xbf000000L)
    {
      /* However, if we're running on a /3GB enabled 32 bit system or on
	 a 64 bit system, and the executable is large address aware, then
	 we know that we have spare 1 Gig (32 bit) or even 2 Gigs (64 bit)
	 virtual address space.  This memory region is practically unused
	 by Windows, only PEB and TEBs are allocated top-down here.  We use
	 the current TEB address as very simple test that this is a large
	 address aware executable.
	 The above test for an address beyond 0xbf000000 is supposed to
	 make sure that we really have 3GB on a 32 bit system.  XP and
	 later support smaller large address regions, but then it's not
	 that interesting for us to use it for the heap.
	 If the region is big enough, the heap gets allocated at its
	 start.  What we get are 0.999 or 1.999 Gigs of free contiguous
	 memory for heap, thread stacks, and shared memory regions. */
      start_address = 0x80000000L;
    }
#endif
  return start_address;
}

static SIZE_T
eval_initial_heap_size ()
{
  PIMAGE_DOS_HEADER dosheader;
  PIMAGE_NT_HEADERS ntheader;
  SIZE_T size;

  dosheader = (PIMAGE_DOS_HEADER) GetModuleHandle (NULL);
  ntheader = (PIMAGE_NT_HEADERS) ((PBYTE) dosheader + dosheader->e_lfanew);
  /* LoaderFlags is an obsolete DWORD member of the PE/COFF file header.
     It's value is ignored by the loader, so we're free to use it for
     Cygwin.  If it's 0, we default to the usual 384 Megs on 32 bit and
     512 on 64 bit.  Otherwise, we use it as the default initial heap size
     in megabyte.  Valid values are between 4 and 2048/8388608 Megs. */

  size = ntheader->OptionalHeader.LoaderFlags;
#ifdef __x86_64__
  if (size == 0)
    size = 512;
  else if (size < 4)
    size = 4;
  else if (size > 8388608)
    size = 8388608;
#else
  if (size == 0)
    size = 384;
  else if (size < 4)
    size = 4;
  else if (size > 2048)
    size = 2048;
#endif
  return size << 20;
}

/* Initialize the heap at process start up.  */
void
user_heap_info::init ()
{
  const DWORD alloctype = MEM_RESERVE;
  /* If we're the forkee, we must allocate the heap at exactly the same place
     as our parent.  If not, we (almost) don't care where it ends up.  */

  page_const = wincap.page_size ();
  if (!base)
    {
      uintptr_t start_address = eval_start_address ();
      PVOID largest_found = NULL;
      SIZE_T largest_found_size = 0;
      SIZE_T ret;
      MEMORY_BASIC_INFORMATION mbi;

      chunk = eval_initial_heap_size ();
      do
	{
	  base = VirtualAlloc ((LPVOID) start_address, chunk, alloctype,
			       PAGE_NOACCESS);
	  if (base)
	    break;

	  /* Ok, so we are at the 1% which didn't work with 0x20000000 out
	     of the box.  What we do now is to search for the next free
	     region which matches our desired heap size.  While doing that,
	     we keep track of the largest region we found, including the
	     region starting at 0x20000000. */
	  while ((ret = VirtualQuery ((LPCVOID) start_address, &mbi,
				      sizeof mbi)) != 0)
	    {
	      if (mbi.State == MEM_FREE)
		{
		  if (mbi.RegionSize >= chunk)
		    break;
		  if (mbi.RegionSize > largest_found_size)
		    {
		      largest_found = mbi.BaseAddress;
		      largest_found_size = mbi.RegionSize;
		    }
		}
	      /* Since VirtualAlloc only reserves at allocation granularity
		 boundaries, we round up here, too.  Otherwise we might end
		 up at a bogus page-aligned address. */
	      start_address = roundup2 (start_address + mbi.RegionSize,
					wincap.allocation_granularity ());
	    }
	  if (!ret)
	    {
	      /* In theory this should not happen.  But if it happens, we have
		 collected the information about the largest available region
		 in the above loop.  So, next we squeeze the heap into that
		 region, unless it's smaller than the minimum size. */
	      if (largest_found_size >= MINHEAP_SIZE)
		{
		  chunk = largest_found_size;
		  base = VirtualAlloc (largest_found, chunk, alloctype,
				       PAGE_NOACCESS);
		}
	      /* Last resort (but actually we are probably broken anyway):
		 Use the minimal heap size and let the system decide. */
	      if (!base)
		{
		  chunk = MINHEAP_SIZE;
		  base = VirtualAlloc (NULL, chunk, alloctype, PAGE_NOACCESS);
		}
	    }
	}
      while (!base && ret);
      if (base == NULL)
	api_fatal ("unable to allocate heap, heap_chunk_size %ly, %E",
		   chunk);
      ptr = top = base;
      max = (char *) base + chunk;
    }
  else
    {
      /* total size commited in parent */
      SIZE_T allocsize = (char *) top - (char *) base;

      /* Loop until we've managed to reserve an adequate amount of memory. */
      SIZE_T reserve_size = chunk * ((allocsize + (chunk - 1)) / chunk);

      /* With ptmalloc3 there's a good chance that there has been no memory
	 allocated on the heap.  If we don't check that, reserve_size will
	 be 0 and from there, the below loop will end up overallocating due
	 to integer overflow. */
      if (!reserve_size)
	reserve_size = chunk;

      char *p;
      while (1)
	{
	  p = (char *) VirtualAlloc (base, reserve_size, alloctype,
				     PAGE_READWRITE);
	  if (p)
	    break;
	  if ((reserve_size -= page_const) < allocsize)
	    break;
	}
      if (!p && in_forkee && !fork_info->abort (NULL))
	api_fatal ("couldn't allocate heap, %E, base %p, top %p, "
		   "reserve_size %ld, allocsize %ld, page_const %d",
		   base, top,
		   reserve_size, allocsize, page_const);
      if (p != base)
	api_fatal ("heap allocated at wrong address %p (mapped) "
		   "!= %p (expected)", p, base);
      if (allocsize && !VirtualAlloc (base, allocsize,
				      MEM_COMMIT, PAGE_READWRITE))
	api_fatal ("MEM_COMMIT failed, %E");
    }

  /* CV 2012-05-21: Moved printing heap size here from strace::activate.
     The value printed in strace.activate was always wrong, because at the
     time it's called, cygheap points to cygheap_dummy.  Above all, the heap
     size has not been evaluated yet, except in a forked child.  Since
     heap_init is called early, the heap size is printed pretty much at the
     start of the strace output, so there isn't anything lost. */
  debug_printf ("heap base %p, heap top %p, heap size %ly (%lu)",
		base, top, chunk, chunk);
  page_const--;
  // malloc_init ();
}

#define pround(n) (((size_t)(n) + page_const) & ~page_const)
/* Linux defines n to be intptr_t, newlib defines it to be ptrdiff_t.
   It shouldn't matter much, though, since the function is not standarized
   and sizeof(ptrdiff_t) == sizeof(intptr_t) anyway. */
extern "C" void *
sbrk (ptrdiff_t n)
{
  return cygheap->user_heap.sbrk (n);
}

void __reg2 *
user_heap_info::sbrk (ptrdiff_t n)
{
/* FIXME: This function no longer handles "split heaps". */

  char *newtop, *newbrk;
  SIZE_T commitbytes, newbrksize, reservebytes;

  if (n == 0)
    return ptr;					/* Just wanted to find current ptr
						   address */

  newbrk = (char *) ptr + n;			/* Where new cptr will be */
  newtop = (char *) pround (newbrk);		/* Actual top of allocated memory -
						   on page boundary */

  if (newtop == top)
    goto good;

  if (n < 0)
    {						/* Freeing memory */
      assert (newtop < top);
      n = (char *) top - newtop;
      /* FIXME: This doesn't work if we cross a virtual memory reservation
	 border.  If that happens, we have to free the space in multiple
	 VirtualFree calls, aligned to the former reservation borders. */
      if (VirtualFree (newtop, n, MEM_DECOMMIT)) /* Give it back to OS */
	goto good;
      goto err;					/*  Didn't take */
    }

  assert (newtop > top);

  /* Find the number of bytes to commit, rounded up to the nearest page. */
  commitbytes = pround (newtop - (char *) top);

  /* Need to grab more pages from the OS.  If this fails it may be because
     we have used up previously reserved memory.  Or, we're just plumb out
     of memory.  Only attempt to commit memory that we know we've previously
     reserved.  */
  if (newtop <= max)
    {
      if (VirtualAlloc (top, commitbytes, MEM_COMMIT, PAGE_READWRITE))
	goto good;
      goto err;
    }

  /* The remainder of the existing heap is too small to fulfill the memory
     request.  We have to extend the heap, so we reserve some more memory
     and then commit the remainder of the old heap, if any, and the rest of
     the required space from the extended heap. */

  /* For subsequent chunks following the base heap, reserve either 1 Megs
     per chunk, or the requested amount if it's bigger than 1 Megs. */
  reservebytes = commitbytes - ((char *) max - (char *) top);
  commitbytes -= reservebytes;
  if ((newbrksize = RAISEHEAP_SIZE) < reservebytes)
    newbrksize = reservebytes;

  if (VirtualAlloc (max, newbrksize, MEM_RESERVE, PAGE_NOACCESS)
      || VirtualAlloc (max, newbrksize = reservebytes, MEM_RESERVE,
		       PAGE_NOACCESS))
    {
      /* Now commit the requested memory.  Windows keeps all virtual
	 reservations separate, so we can't commit the two regions in a single,
	 combined call or we suffer an ERROR_INVALID_ADDRESS.  The same error
	 is returned when trying to VirtualAlloc 0 bytes, which would occur if
	 the existing heap was already full. */
      if ((!commitbytes || VirtualAlloc (top, commitbytes, MEM_COMMIT,
					 PAGE_READWRITE))
	  && VirtualAlloc (max, reservebytes, MEM_COMMIT, PAGE_READWRITE))
	{
	  max = (char *) max + pround (newbrksize);
	  goto good;
	}
      /* If committing the memory failed, we must free the extendend reserved
         region, otherwise any other try to fetch memory (for instance by using
	 mmap) may fail just because we still reserve memory we don't even know
	 about. */
      VirtualFree (max, newbrksize, MEM_RELEASE);
    }

err:
  set_errno (ENOMEM);
  return (void *) -1;

good:
  void *oldbrk = ptr;
  ptr = newbrk;
  top = newtop;
  return oldbrk;
}
@


1.69
log
@* cygheap.h (user_heap_info::sbrk): Declare new function.
(user_heap_info::init): Ditto.
* heap.cc (user_heap_info::init): Rename from heap_init().  Avoid explictly
using cygheap->user_heap.
(sbrk): Use user_heap_info method via cygheap->user_heap.
(user_heap_info::sbrk): Renamed from sbrk().  Eliminate explicit use of
cygheap->user_heap.  Change some pointer arithmetic to use (char *) for
consistency.
* shared.cc (shared_info::initialize): Change heap_init call to
cygheap->user_heap.init.
@
text
@d27 1
d29 2
d283 6
a288 3
  if (newtop <= max && VirtualAlloc (top, commitbytes, MEM_COMMIT,
				     PAGE_READWRITE))
      goto good;
d295 2
a296 2
  /* Reserve either the maximum of the standard heap chunk size
     or the requested amount.  Then attempt to actually allocate it.  */
d299 1
a299 1
  if ((newbrksize = chunk) < reservebytes)
@


1.68
log
@	* heap.cc (sbrk): Add a FIXME comment to VirtualFree call.  Fix memory
	reservation and commit strategy when more memory is requested than
	available on the heap.  Release newly reserved memory if commiting
	it fails.  Add more comments to explain what we do.
@
text
@d105 1
a105 1
heap_init ()
d112 1
a112 1
  if (!cygheap->user_heap.base)
d120 1
a120 1
      cygheap->user_heap.chunk = eval_initial_heap_size ();
d123 3
a125 4
	  cygheap->user_heap.base = VirtualAlloc ((LPVOID) start_address,
						  cygheap->user_heap.chunk,
						  alloctype, PAGE_NOACCESS);
	  if (cygheap->user_heap.base)
d138 1
a138 1
		  if (mbi.RegionSize >= cygheap->user_heap.chunk)
d160 3
a162 4
		  cygheap->user_heap.chunk = largest_found_size;
		  cygheap->user_heap.base =
			VirtualAlloc (largest_found, cygheap->user_heap.chunk,
				      alloctype, PAGE_NOACCESS);
d166 1
a166 1
	      if (!cygheap->user_heap.base)
d168 2
a169 4
		  cygheap->user_heap.chunk = MINHEAP_SIZE;
		  cygheap->user_heap.base =
			VirtualAlloc (NULL, cygheap->user_heap.chunk,
				      alloctype, PAGE_NOACCESS);
d173 2
a174 2
      while (!cygheap->user_heap.base && ret);
      if (cygheap->user_heap.base == NULL)
d176 3
a178 4
		   cygheap->user_heap.chunk);
      cygheap->user_heap.ptr = cygheap->user_heap.top = cygheap->user_heap.base;
      cygheap->user_heap.max = (char *) cygheap->user_heap.base
			       + cygheap->user_heap.chunk;
a181 1
      SIZE_T chunk = cygheap->user_heap.chunk;	/* allocation chunk */
d183 1
a183 2
      SIZE_T allocsize = (char *) cygheap->user_heap.top -
			 (char *) cygheap->user_heap.base;
a185 1
      char *p;
d187 1
d195 1
d198 2
a199 2
	  p = (char *) VirtualAlloc (cygheap->user_heap.base, reserve_size,
				     alloctype, PAGE_READWRITE);
d208 1
a208 1
		   cygheap->user_heap.base, cygheap->user_heap.top,
d210 1
a210 1
      if (p != cygheap->user_heap.base)
d212 2
a213 2
		   "!= %p (expected)", p, cygheap->user_heap.base);
      if (allocsize && !VirtualAlloc (cygheap->user_heap.base, allocsize,
d225 1
a225 2
		cygheap->user_heap.base, cygheap->user_heap.top,
		cygheap->user_heap.chunk, cygheap->user_heap.chunk);
a230 3

/* FIXME: This function no longer handles "split heaps". */

d237 8
d249 2
a250 1
    return cygheap->user_heap.ptr;		/* Just wanted to find current cygheap->user_heap.ptr address */
d252 1
a252 1
  newbrk = (char *) cygheap->user_heap.ptr + n;	/* Where new cygheap->user_heap.ptr will be */
d256 1
a256 1
  if (newtop == cygheap->user_heap.top)
d261 2
a262 2
      assert (newtop < cygheap->user_heap.top);
      n = (char *) cygheap->user_heap.top - newtop;
d271 1
a271 1
  assert (newtop > cygheap->user_heap.top);
d274 1
a274 1
  commitbytes = pround (newtop - (char *) cygheap->user_heap.top);
d280 3
a282 6
  if (newtop <= cygheap->user_heap.max)
    {
      if (VirtualAlloc (cygheap->user_heap.top, commitbytes,
			MEM_COMMIT, PAGE_READWRITE) != NULL)
	goto good;
    }
d284 1
a284 1
  /* The remainder of the existing heap is too small to fulfil the memory
d291 1
a291 2
  reservebytes = commitbytes - ((ptrdiff_t) cygheap->user_heap.max
				- (ptrdiff_t) cygheap->user_heap.top);
d293 1
a293 1
  if ((newbrksize = cygheap->user_heap.chunk) < reservebytes)
d296 3
a298 4
  if (VirtualAlloc (cygheap->user_heap.max, newbrksize,
		    MEM_RESERVE, PAGE_NOACCESS)
      || VirtualAlloc (cygheap->user_heap.max, newbrksize = reservebytes,
		       MEM_RESERVE, PAGE_NOACCESS))
d305 3
a307 4
      if ((!commitbytes || VirtualAlloc (cygheap->user_heap.top, commitbytes,
					 MEM_COMMIT, PAGE_READWRITE))
	  && VirtualAlloc (cygheap->user_heap.max, reservebytes,
			   MEM_COMMIT, PAGE_READWRITE))
d309 1
a309 2
	  cygheap->user_heap.max = (char *) cygheap->user_heap.max
				   + pround (newbrksize);
d316 1
a316 1
      VirtualFree (cygheap->user_heap.max, newbrksize, MEM_RELEASE);
d324 3
a326 3
  void *oldbrk = cygheap->user_heap.ptr;
  cygheap->user_heap.ptr = newbrk;
  cygheap->user_heap.top = newtop;
@


1.67
log
@	* Merge in cygwin-64bit-branch.
@
text
@d248 1
a248 1
  SIZE_T commitbytes, newbrksize;
d264 3
d283 2
a284 1
      if (VirtualAlloc (cygheap->user_heap.top, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
d288 6
a293 2
  /* Couldn't allocate memory.  Maybe we can reserve some more.
     Reserve either the maximum of the standard cygwin_shared->heap_chunk_size ()
d295 31
a325 14
  if ((newbrksize = cygheap->user_heap.chunk) < commitbytes)
    newbrksize = commitbytes;

   if ((VirtualAlloc (cygheap->user_heap.top, newbrksize,
		      MEM_RESERVE, PAGE_NOACCESS)
	|| VirtualAlloc (cygheap->user_heap.top, newbrksize = commitbytes,
			 MEM_RESERVE, PAGE_NOACCESS))
       && VirtualAlloc (cygheap->user_heap.top, commitbytes,
			MEM_COMMIT, PAGE_READWRITE) != NULL)
     {
	cygheap->user_heap.max = (char *) cygheap->user_heap.max
				 + pround (newbrksize);
	goto good;
     }
@


1.66
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d25 1
a25 1
static unsigned page_const;
d32 9
d65 1
d69 1
a69 1
static unsigned
d73 2
a74 2
  PIMAGE_NT_HEADERS32 ntheader;
  unsigned size;
d77 1
a77 1
  ntheader = (PIMAGE_NT_HEADERS32) ((PBYTE) dosheader + dosheader->e_lfanew);
d80 4
a83 3
     Cygwin.  If it's 0, we default to the usual 384 Megs.  Otherwise,
     we use it as the default initial heap size in megabyte.  Valid values
     are between 4 and 2048 Megs. */
d85 8
d99 1
d116 1
a116 1
      size_t largest_found_size = 0;
d179 1
a179 1
	api_fatal ("unable to allocate heap, heap_chunk_size %p, %E",
d187 1
a187 1
      DWORD chunk = cygheap->user_heap.chunk;	/* allocation chunk */
d189 2
a190 2
      DWORD allocsize = (char *) cygheap->user_heap.top -
			(char *) cygheap->user_heap.base;
d194 8
a201 1
      DWORD reserve_size = chunk * ((allocsize + (chunk - 1)) / chunk);
d213 1
a213 1
		   "reserve_size %d, allocsize %d, page_const %d",
d217 4
a220 2
	api_fatal ("heap allocated at wrong address %p (mapped) != %p (expected)", p, cygheap->user_heap.base);
      if (allocsize && !VirtualAlloc (cygheap->user_heap.base, allocsize, MEM_COMMIT, PAGE_READWRITE))
d230 1
a230 1
  debug_printf ("heap base %p, heap top %p, heap size %p (%u)",
d241 3
d245 1
a245 1
sbrk (int n)
d248 1
a248 1
  unsigned commitbytes, newbrksize;
d265 2
a266 3
	goto good;				/*  Didn't take */
      else
	goto err;
d290 6
a295 3
   if ((VirtualAlloc (cygheap->user_heap.top, newbrksize, MEM_RESERVE, PAGE_NOACCESS)
	|| VirtualAlloc (cygheap->user_heap.top, newbrksize = commitbytes, MEM_RESERVE, PAGE_NOACCESS))
       && VirtualAlloc (cygheap->user_heap.top, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
d297 2
a298 1
	cygheap->user_heap.max = (char *) cygheap->user_heap.max + pround (newbrksize);
@


1.65
log
@	* strace.cc (strace::activate): Move printing heap size from here...
	* heap.cc (heap_init_info): ...to here.  Explain why.  Print heap
	size in hex and decimal.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.65.2.1
log
@	* cygheap.h (struct user_heap_info): Change type of chunk to SIZE_T.
	Remove unused slop member.
	* fork.cc (fork): Rename esp to stackp.  Add 64 bit asm expression to
	fetch stack pointer.
	(child_copy): Use platform independent types.
	* heap.cc (eval_start_address): Add comment. Disable 3GB code on 64 bit.
	(eval_initial_heap_size): Use platform independent types.  Fix debug
	printf format strings.
	(sbrk): Add comment.  Change argument type according to newlib
	definition.  Use platform independent types.  Drop unneeded else and
	move comment to the right spot.
	* hookapi.cc (PEHeaderFromHModule): Return PVOID.  Add comment to
	explain why.  Add bool parameter to return if target executable is
	64 bit or not.
	(rvadelta_get): New inline function to fetch section address platform
	independent.
	(rvadelta32, rvadelta64): Platform dependent wrappers.
	(rvadelta): Change to macro calling the platform dependent rvadelta
	wrappers.
	(putmem): Define platform dependent THUNK_FUNC_TYPE and use throughout.
	(RedirectIAT): Add comment.
	(get_export): Add comment.
	(find_first_notloaded_dll): Allow to fetch information in a platform
	and target independent way.
	(hook_or_detect_cygwin): Ditto.  Recognize the cyg64win1.dll file name
	as well.
	* kernel32.cc (CreateFileMappingW): Cast to avoid compiler warning.

	* fhandler.h (class fhandler_dev_tape): Replace mt_evt with an
	OVERLAPPED structure ov.
	* mtinfo.h (class mtinfo_part): Define members as int32_t rather than
	long.  Change member function declarations accordingly.
	(class mtinfo_drive): Ditto.  Store OVERLAPPED pointer rather than
	holding the full structure.  Add comment to explain why.
	* fhandler_tape.cc: Accommodate above changes throughout.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
a36 5

  /* FIXME: Is the start_address still valid for 64 bit?  Given that 
     executables on 64 bit start at the usual address, I think so, but
     this has to be re-evaluated. */

a37 1
#ifndef __x86_64__
a55 1
#endif
d63 1
a63 1
  PIMAGE_NT_HEADERS ntheader;
d67 1
a67 1
  ntheader = (PIMAGE_NT_HEADERS) ((PBYTE) dosheader + dosheader->e_lfanew);
a72 3

  /* FIXME: Different numbers for 64 bit? */

d96 1
a96 1
      SIZE_T largest_found_size = 0;
d159 1
a159 1
	api_fatal ("unable to allocate heap, heap_chunk_size %ly, %E",
d167 1
a167 1
      SIZE_T chunk = cygheap->user_heap.chunk;	/* allocation chunk */
d169 2
a170 2
      SIZE_T allocsize = (char *) cygheap->user_heap.top -
			 (char *) cygheap->user_heap.base;
d174 1
a174 1
      SIZE_T reserve_size = chunk * ((allocsize + (chunk - 1)) / chunk);
d186 1
a186 1
		   "reserve_size %ld, allocsize %ld, page_const %d",
d190 2
a191 4
	api_fatal ("heap allocated at wrong address %p (mapped) "
		   "!= %p (expected)", p, cygheap->user_heap.base);
      if (allocsize && !VirtualAlloc (cygheap->user_heap.base, allocsize,
				      MEM_COMMIT, PAGE_READWRITE))
d201 1
a201 1
  debug_printf ("heap base %p, heap top %p, heap size %ly (%lu)",
a211 3
/* Linux defines n to be intptr_t, newlib defines it to be ptrdiff_t.
   It shouldn't matter much, though, since the function is not standarized
   and sizeof(ptrdiff_t) == sizeof(intptr_t) anyway. */
d213 1
a213 1
sbrk (ptrdiff_t n)
d216 1
a216 1
  SIZE_T commitbytes, newbrksize;
d233 3
a235 2
	goto good;
      goto err;					/*  Didn't take */
d259 3
a261 6
   if ((VirtualAlloc (cygheap->user_heap.top, newbrksize,
		      MEM_RESERVE, PAGE_NOACCESS)
	|| VirtualAlloc (cygheap->user_heap.top, newbrksize = commitbytes,
			 MEM_RESERVE, PAGE_NOACCESS))
       && VirtualAlloc (cygheap->user_heap.top, commitbytes,
			MEM_COMMIT, PAGE_READWRITE) != NULL)
d263 1
a263 2
	cygheap->user_heap.max = (char *) cygheap->user_heap.max
				 + pround (newbrksize);
@


1.65.2.2
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.65.2.3
log
@	* heap.cc (eval_start_address): Change address and comment for 64 bit.
	(eval_initial_heap_size): Change return type to SIZE_T.  Use different
	values for 64 bit.
@
text
@a31 7
#ifdef __x86_64__
  /* On 64 bit, we choose a nice address outside the 32 bit area.  The
     Cygwin DLL starts at 0x200000000L, so let's start at 0x400000000L
     with the heap.  There's enough room for other DLLs in the space
     in between. */
  uintptr_t start_address = 0x400000000L;
#else
d37 5
d43 1
d66 1
a66 1
static SIZE_T
d71 1
a71 1
  SIZE_T size;
d77 5
a81 3
     Cygwin.  If it's 0, we default to the usual 384 Megs on 32 bit and
     512 on 64 bit.  Otherwise, we use it as the default initial heap size
     in megabyte.  Valid values are between 4 and 2048/8388608 Megs. */
a83 8
#ifdef __x86_64__
  if (size == 0)
    size = 512;
  else if (size < 4)
    size = 4;
  else if (size > 8388608)
    size = 8388608;
#else
a89 1
#endif
@


1.65.2.4
log
@	* autoload.cc (LoadDLLfuncEx3): Adjust address computation required
	by latest change to the 64 bit code.
	* cygmalloc.h (MALLOC_ALIGNMENT): Set to 16 on x86_64.
	* cygtls.h: Set struct alignment to 8 on x86_64.  Move inclusion of
	other header files outside of alignment-enforced code area.  Drop
	inclusion of security.h entirely.
	(_cygtls::get_signal_arrived): Use NULL SECURITY_ATTRIBUTES rather than
	&sec_none_nih.
	* gendef (_cygtls::lock): Fix stack alignment.
	* heap.cc (page_const): Change type to ptrdiff_t, otherwise negation
	operator in pround creates broken bitmask.
	* shared.cc (page_const): Add cast to ptrdiff_t.
	* tlsoffsets64.h: Regenerate.
@
text
@d25 1
a25 1
static ptrdiff_t page_const;
@


1.65.2.5
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d33 4
a36 4
  /* On 64 bit, we choose a fixed address outside the 32 bit area.  The
     executable starts at 0x1:00400000L, the Cygwin DLL starts at
     0x1:80040000L, other DLLs are located in the space from 0x2:00000000L
     up to 0x4:00000000L, so we let the heap start at 0x4:00000000L. */
@


1.65.2.6
log
@	* heap.cc (eval_start_address): Move heap to 0x6:00000000.  Change
	comment to explain why.
	* mmap.cc (MMAP_STORAGE_LOW): Accommodate above change.
@
text
@d35 3
a37 5
     0x1:80040000L, other rebased DLLs are located in the region from
     0x2:00000000L up to 0x4:00000000L, -auto-image-based DLLs are located
     in the region from 0x4:00000000L up to 0x6:00000000L.
     So we let the heap start at 0x6:00000000L. */
  uintptr_t start_address = 0x600000000L;
@


1.65.2.7
log
@	* configure.ac (MALLOC_OFILES): Add ptmalloc3.o.
	* configure: Regenerate.
	* cygmalloc.h: Declare pt* functions rather than dl* functions.
	(mmap64): Declare.
	(mmap): Define as mmap64.
	(__malloc_lock): Drop macro.
	(__malloc_unlock): Ditto.
	(MSPACES): Define.
	(ONLY_MSPACES): Define.
	* debug.h: Include malloc.h rather than otherwise unused dlmalloc.h.
	* fork.cc (frok::parent): Drop malloc locking since that's performed
	by malloc_atfork now.
	* heap.cc (heap_init): Accommodate the fact that there's a chance
	that no heap space has been allocated at fork time.
	* malloc-private.h: New file from ptmalloc3, having malloc-machine.h
	and malloc-2.8.3.h folded in.
	* malloc.cc: Replaced by new file from ptmalloc3.
	* malloc_wrapper.cc: Throughout, remove malloc locks and call pt*
	functions rather than dl* functions.
	* pinfo.cc (winpids::set): Drop malloc locking.
	* ptmalloc3.cc: New file from ptmalloc3.
@
text
@a190 6
      /* With ptmalloc3 there's a good chance that there has been no memory
	 allocated on the heap.  If we don't check that, reserve_size will
	 be 0 and from there, the below loop will end up overallocating due
	 to integer overflow. */
      if (!allocsize)
	allocsize = chunk;
@


1.65.2.8
log
@	* heap.cc (heap_init): Fix setting reserved_size value when using
	ptmalloc3 to avoid too much pagefile pressure at fork time.
@
text
@a190 4

      /* Loop until we've managed to reserve an adequate amount of memory. */
      char *p;
      SIZE_T reserve_size = chunk * ((allocsize + (chunk - 1)) / chunk);
d195 2
a196 2
      if (!reserve_size)
	reserve_size = chunk;
d198 3
@


1.64
log
@	* heap.cc (eval_initial_heap_size): New function fetching the heap
	size from the LoaderFlags field in the PE/COFF header.
	(heap_init): Call eval_initial_heap_size rather than
	cygwin_shared->heap_chunk_size to fetch the initial heap size.
	* shared.cc (shared_info::heap_chunk_size): Remove.
	* shared_info.h (class shared_info): Drop heap_chunk member.
	(CURR_SHARED_MAGIC): Update.
@
text
@d195 9
a203 2
  debug_printf ("heap base %p, heap top %p", cygheap->user_heap.base,
		cygheap->user_heap.top);
@


1.63
log
@	* heap.cc (eval_start_address): Simplify test for large address
	awareness of executable, which works for 32 and 64 bit systems.
	Change comment accordingly.
@
text
@d59 24
d100 1
a100 1
      cygheap->user_heap.chunk = cygwin_shared->heap_chunk_size ();
@


1.62
log
@	* heap.cc (eval_start_address): New static function to evaluate the
	best start address for the application heap.
	(heap_init): Call eval_start_address to fetch the start value for
	start_address.  Move preceeding comment to eval_start_address.
@
text
@d20 1
d38 1
a38 1
  if (wincap.is_wow64 ())
d40 15
a54 13
      /* However, if we're running on a 64 bit system, we test here if the
	 executable is large address aware.  If so, the application gets a
	 4 Gigs virtual address space, with almost all of the upper 2 Gigs
	 being unused by Windows (only PEB and TEBs are allocated here,
	 apparently).  So what we do here is to test if the large address
	 awareness flag is set in the file header and, if so, allocate our
	 heap in that region.  What we get are 1.999 Gigs free for heap,
	 thread stacks, and shared memory regions. */
      PIMAGE_DOS_HEADER idh = (PIMAGE_DOS_HEADER) GetModuleHandle (NULL);
      PIMAGE_NT_HEADERS32 inh = (PIMAGE_NT_HEADERS32)
				((PBYTE) idh + idh->e_lfanew);
      if (inh->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)
	start_address = 0x80000000L;
@


1.61
log
@	* heap.cc (heap_init): Change type of largest_found to PVOID.  Start
	querying memory at 0x20000000.  Use largest_found pointer when trying
	to allocate largest free memory area found.
@
text
@d28 28
d67 1
a67 7
      /* Starting with Vista, Windows performs heap ASLR.  This spoils
	 the entire region below 0x20000000 for us, because that region
	 is used by Windows to randomize heap and stack addresses.
	 Therefore we put our heap into a safe region starting at 0x20000000.
	 This should work right from the start in 99% of the cases.  But,
	 there's always a but.  Read on... */
      uintptr_t start_address = 0x20000000L;
@


1.60
log
@whitespace elimination
@
text
@d46 1
a46 1
      uintptr_t largest_found = 0;
d63 2
a64 2
	     we keep track of the largest region we found. */
	  start_address += wincap.allocation_granularity ();
d74 1
a74 1
		      largest_found = (uintptr_t) mbi.BaseAddress;
d94 1
a94 2
			VirtualAlloc ((LPVOID) start_address,
				      cygheap->user_heap.chunk,
@


1.59
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d79 1
a79 1
	         boundaries, we round up here, too.  Otherwise we might end
@


1.58
log
@	* heap.cc (heap_init): Rewrite initial heap allocation to use addresses
	beyond 0x20000000.  Explain why and how.
	* shared.cc (shared_info::heap_slop_size): Remove.
	* shared_info.h (class shared_info): Remove heap_slop_inited and
	heap_slop members.  Remove heap_slop_size declaration.
	(CURR_SHARED_MAGIC): Update.
	* wincap.cc: Throughout, drop heapslop.
	* wincap.h (struct wincaps): Drop heapslop.
@
text
@d136 1
a136 1
      if (!p && in_forkee && !fork_info->handle_failure (GetLastError ()))
@


1.57
log
@	* fhandler_proc.cc (format_proc_uptime): Don't call GetSystemInfo.
	Fetch CPU count from wincap.
	(format_proc_stat): Ditto.
	* globals.cc (system_info): Move to wincap.
	* heap.cc (heap_init): Fetch page size from wincap.
	* syscalls.cc (getpagesize): Fetch allocation granularity from wincap.
	(getsystempagesize): Fetch page size from wincap.
	* wincap.cc (wincap_2003): Default is_server to false.
	(wincapc::init): Call GetSystemInfo here.  Always set is_server value.
	* wincap.h (class wincapc): Add system_info as private member.
	(wincapc::cpu_count): New public method.
	(wincapc::page_size): Ditto.
	(wincapc::allocation_granularity): Ditto.
@
text
@d20 1
d34 1
a34 1
     as our parent.  If not, we don't care where it ends up.  */
d39 12
d52 1
a52 13
      /* For some obscure reason Vista and 2003 sometimes reserve space after
	 calls to CreateProcess overlapping the spot where the heap has been
	 allocated.  This apparently spoils fork.  The behaviour looks quite
	 arbitrary.  Experiments on Vista show a memory size of 0x37e000 or
	 0x1fd000 overlapping the usual heap by at most 0x1ed000.  So what
	 we do here is to allocate the heap with an extra slop of (by default)
	 0x400000 and set the appropriate pointers to the start of the heap
	 area + slop.  A forking child then creates its heap at the new start
	 address and without the slop factor.  Since this is not entirely
	 foolproof we add a registry setting "heap_slop_in_mb" so the slop
	 factor can be influenced by the user if the need arises. */
      cygheap->user_heap.slop = cygwin_shared->heap_slop_size ();
      while (cygheap->user_heap.chunk >= MINHEAP_SIZE)
d54 3
a56 6
	  /* Initialize page mask and default heap size.  Preallocate a heap
	   * to assure contiguous memory.  */
	  cygheap->user_heap.base =
	    VirtualAlloc (NULL, cygheap->user_heap.chunk
	    			+ cygheap->user_heap.slop,
			  alloctype, PAGE_NOACCESS);
d59 49
a107 1
	  cygheap->user_heap.chunk -= 1 * 1024 * 1024;
d109 1
d111 2
a112 4
	api_fatal ("unable to allocate heap, heap_chunk_size %p, slop %p, %E",
		   cygheap->user_heap.chunk, cygheap->user_heap.slop);
      cygheap->user_heap.base = (void *) ((char *) cygheap->user_heap.base
      						   + cygheap->user_heap.slop);
@


1.56
log
@	* heap.cc (heap_init): Fix typo in comment.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d35 1
a35 1
  page_const = system_info.dwPageSize;
@


1.55
log
@Remove unneeded header files from source files throughout.
@
text
@d44 1
a44 1
	 0x200000 and set the appropriate pointers to the start of the heap
@


1.54
log
@	* cygheap.h (struct user_heap_info): Add slop member.
	* heap.cc (heap_init): Add slop factor to heap allocation.  Add
	comment.
	* mmap.cc (MapViewNT): Allocate memory maps top down.
	(fhandler_dev_zero::mmap): Ditto.
	* shared.cc (shared_info::heap_slop_size): New method.
	(shared_info::heap_chunk_size): Don't use debug_printf at early stage.
	* shared_info.h (SHARED_INFO_CB): Accomodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop member.  Declare heap_slop_size.
	* wincap.h: Define heapslop throughout.
	* wincap.cc: Ditto.
@
text
@a12 3
#include "sigproc.h"
#include "pinfo.h"
#include "heap.h"
a13 1
#include "security.h"
a17 2
#include "registry.h"
#include "cygwin_version.h"
@


1.53
log
@	* heap.cc (heap_init): Only commit if allocsize is not zero.
@
text
@d44 12
a59 1
	  cygheap->user_heap.ptr = cygheap->user_heap.top =
d61 3
a63 1
	    VirtualAlloc (NULL, cygheap->user_heap.chunk, alloctype, PAGE_NOACCESS);
d69 7
a75 3
	api_fatal ("unable to allocate heap, heap_chunk_size %d, %E",
		   cygheap->user_heap.chunk);
      cygheap->user_heap.max = (char *) cygheap->user_heap.base + cygheap->user_heap.chunk;
@


1.53.4.1
log
@	* dtable.cc (build_fh_pc): Add missing DEV_SD1_MAJOR case (Thanks to
	Joe Loh for noticing).

	* cygheap.h (struct user_heap_info): Add slop member.
	* heap.cc (heap_init): Add slop factor to heap allocation.  Add
	comment.
	* mmap.cc (MapViewNT): Allocate memory maps top down.
	(fhandler_dev_zero::mmap): Ditto.
	* shared.cc (shared_info::heap_slop_size): New method.
	(shared_info::heap_chunk_size): Don't use debug_printf at early stage.
	* shared_info.h (SHARED_INFO_CB): Accomodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop member.  Declare heap_slop_size.
	* wincap.h: Define heapslop throughout.
	* wincap.cc: Ditto.
@
text
@a43 12
      /* For some obscure reason Vista and 2003 sometimes reserve space after
	 calls to CreateProcess overlapping the spot where the heap has been
	 allocated.  This apparently spoils fork.  The behaviour looks quite
	 arbitrary.  Experiments on Vista show a memory size of 0x37e000 or
	 0x1fd000 overlapping the usual heap by at most 0x1ed000.  So what
	 we do here is to allocate the heap with an extra slop of (by default)
	 0x200000 and set the appropriate pointers to the start of the heap
	 area + slop.  A forking child then creates its heap at the new start
	 address and without the slop factor.  Since this is not entirely
	 foolproof we add a registry setting "heap_slop_in_mb" so the slop
	 factor can be influenced by the user if the need arises. */
      cygheap->user_heap.slop = cygwin_shared->heap_slop_size ();
d48 1
d50 1
a50 3
	    VirtualAlloc (NULL, cygheap->user_heap.chunk
	    			+ cygheap->user_heap.slop,
			  alloctype, PAGE_NOACCESS);
d56 3
a58 7
	api_fatal ("unable to allocate heap, heap_chunk_size %p, slop %p, %E",
		   cygheap->user_heap.chunk, cygheap->user_heap.slop);
      cygheap->user_heap.base = (void *) ((char *) cygheap->user_heap.base
      						   + cygheap->user_heap.slop);
      cygheap->user_heap.ptr = cygheap->user_heap.top = cygheap->user_heap.base;
      cygheap->user_heap.max = (char *) cygheap->user_heap.base
			       + cygheap->user_heap.chunk;
@


1.52
log
@* child_info.h (child_info_fork::handle_failure): Declare new function.
(child_info_fork::retry): New field.
* dcrt0.cc (__api_fatal_exit_val): Define.
(child_info_fork::handle_failure): Define new function.
(__api_fatal): Exit using __api_fatal_exit_val value.
* environ.cc (set_fork_retry): Set fork_retry based on CYGWIN environment
variable.
(parse_thing): Add "fork_retry" setting.
* fork.cc (fork_retry): Define.
(frok::parent): Reorganize to allow retry of failed child creation if child
signalled that it was ok to do so.
* heap.cc (heap_init): Signal parent via handle_failure when VirtualAlloc
fails.
* pinfo.h (EXITCODE_RETRY): Declare.
* sigproc.cc (child_info::sync): Properly exit with failure condition if called
for fork and didn't see subproc_ready.
* spawn.cc (spawn_guts): Use windows pid as first argument.
* winsup.h: Remove obsolete NEW_MACRO_VARARGS define.
(__api_fatal_exit_val): Declare.
(set_api_fatal_return): Define.
(in_dllentry): Declare.
* exceptions.cc (inside_kernel): Remove unneeded in_dllentry declaration.
@
text
@d86 1
a86 1
      if (!VirtualAlloc (cygheap->user_heap.base, allocsize, MEM_COMMIT, PAGE_READWRITE))
@


1.51
log
@* heap.cc (heap_init): Remove Sleep.
@
text
@d24 1
d79 1
a79 1
      if (!p)
@


1.50
log
@* dcrt0.cc (__api_fatal): Simplify to just use strace mechamisms.
(do_exit): Move minimal_printf...
* pinfo.cc (pinfo::exit): ...into here.
* strace.cc (strace::vprntf): Guarantee output to the console when
system_printf/api_fatal.
* heap.cc (heap_init): Wait a second before issuing an error when
ERROR_INVALID_ADDRESS since this is probably due to a CTRL-C handler sneaking
in, using the memory that we want to use for the heap, and, eventually exiting.
@
text
@d79 4
a82 8
	{
	  if (GetLastError () == ERROR_INVALID_ADDRESS)
	    Sleep (2000);
	  api_fatal ("couldn't allocate heap, %E, base %p, top %p, "
		     "reserve_size %d, allocsize %d, page_const %d",
		     cygheap->user_heap.base, cygheap->user_heap.top,
		     reserve_size, allocsize, page_const);
	}
@


1.49
log
@* heap.cc: Remove spurious getpagesize declaration.
* exceptions.cc (ctrl_c_handler): Distinguish CTRL-BREAK from CTRL-C in some
cases.
@
text
@d79 8
a86 4
	api_fatal ("couldn't allocate heap, %E, base %p, top %p, "
		   "reserve_size %d, allocsize %d, page_const %d",
		   cygheap->user_heap.base, cygheap->user_heap.top,
		   reserve_size, allocsize, page_const);
@


1.48
log
@* heap.cc (heap_init): Revert 2005-09-11 patch as it seems to inexplicably
cause problems with emacs.
@
text
@a28 2
extern "C" size_t getpagesize ();

@


1.47
log
@* heap.cc (heap_init): Allocate heap from top down as a hedge against
subsequent ERROR_INVALID_ADDRESS in forked processes when CTRL-C is pressed.
@
text
@d37 1
d51 1
a51 1
	    VirtualAlloc (NULL, cygheap->user_heap.chunk, MEM_RESERVE | MEM_TOP_DOWN, PAGE_NOACCESS);
d74 1
a74 1
				     MEM_RESERVE, PAGE_READWRITE);
@


1.46
log
@* heap.cc (heap_init): Be slightly more aggressive when trying to allocate
heap.  Change fatal error to avoid confusion with cygheap.
* spawn.cc (linebuf::finish): New function.
(linebuf::add): Cosmetic change.
(spawn_guts): Only avoid building windows command line if the program being
executed was actually mounted with -X.  Don't return E2BIG if we hit the 32K
size and we're executing a detected cygwin program.  Just silently truncate the
windows command line, instead.
@
text
@d50 1
a50 1
	    VirtualAlloc (NULL, cygheap->user_heap.chunk, MEM_RESERVE, PAGE_NOACCESS);
@


1.45
log
@Grr.  REVERT erroneous checkin.  AGAIN.
@
text
@d76 1
a76 1
	  if ((reserve_size -= page_const) <= allocsize)
d80 1
a80 1
	api_fatal ("couldn't allocate cygwin heap, %E, base %p, top %p, "
@


1.44
log
@* Makefile.in (CXXFLAGS): Use 'override' to correctly set flags to generate
dependencies when invoked from top-level make.
@
text
@a36 1
static int seen = 0;
a39 1
seen++;
d76 1
a76 1
	  if ((reserve_size -= page_const) < allocsize)
d80 1
a80 1
	api_fatal ("couldn't allocate heap, %E, base %p, top %p, "
@


1.43
log
@revert inexplicable previous checkin
@
text
@d37 1
d41 1
d78 1
a78 1
	  if ((reserve_size -= page_const) <= allocsize)
d82 1
a82 1
	api_fatal ("couldn't allocate cygwin heap, %E, base %p, top %p, "
@


1.42
log
@bad_addresses
@
text
@a36 1
static int seen = 0;
a39 1
seen++;
d76 1
a76 1
	  if ((reserve_size -= page_const) < allocsize)
d80 1
a80 1
	api_fatal ("couldn't allocate heap, %E, base %p, top %p, "
@


1.41
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d37 1
d41 1
d78 1
a78 1
	  if ((reserve_size -= page_const) <= allocsize)
d82 1
a82 1
	api_fatal ("couldn't allocate cygwin heap, %E, base %p, top %p, "
@


1.40
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d148 1
a148 1
        || VirtualAlloc (cygheap->user_heap.top, newbrksize = commitbytes, MEM_RESERVE, PAGE_NOACCESS))
@


1.39
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.38
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@a33 1

a65 2
      /* round up by chunk size */
      DWORD reserve_size = chunk * ((allocsize + (chunk - 1)) / chunk);
d69 2
a70 1
      for (;;)
d79 5
d85 1
a85 1
	api_fatal ("heap allocated but not at %p", cygheap->user_heap.base);
d93 1
a93 1
  malloc_init ();
@


1.38.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d34 1
d67 2
d72 1
a72 2
      DWORD reserve_size = chunk * ((allocsize + (chunk - 1)) / chunk);
      while (1)
a80 5
      if (!p)
	api_fatal ("couldn't allocate cygwin heap, %E, base %p, top %p, "
		   "reserve_size %d, allocsize %d, page_const %d",
		   cygheap->user_heap.base, cygheap->user_heap.top,
		   reserve_size, allocsize, page_const);
d82 1
a82 1
	api_fatal ("heap allocated at wrong address %p (mapped) != %p (expected)", p, cygheap->user_heap.base);
d90 1
a90 1
  // malloc_init ();
@


1.37
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@a99 1
  sigframe thisframe (mainthread);
@


1.36
log
@* cygheap.cc (_csbrk): More left coercion cleanup.
* fhandler_tty.cc (fhandler_tty_slave::read): Ditto.
(fhandler_tty_slave::write): Ditto.
* fhandler_windows.cc (fhandler_windows::read): Ditto.
* heap.cc (sbrk): Ditto.
@
text
@d18 1
a19 1
#include "path.h"
@


1.35
log
@* net.cc (free_char_list): Delete.
(dup_addr_list): Delete.
(dup_char_list): Delete.
(free_hostent_ptr): Delete.
(free_protoent_ptr): Delete.
(free_servent_ptr): Delete.
(DWORD_round): New function.
(strlen_round): New function.  Returns strlen rounded up to word size.
(dup_ent): New, generic function to duplicate a {host,proto,serv}ent structure.
(gen_ent): New macro.  Generates a generic dup_{host,proto,serv}ent_ptr
function.
(cygwin_getservbyname): Remove call to free_servent_ptr, pass servent_buf to
dup_servent_ptr.
(cygwin_getservbyport): Ditto.
(cygwin_gethostbyname): Ditto for hostent.
(cygwin_gethostbyaddr): Ditto.
(cygwin_getprotobyname): Ditto for protoent.
(cygwin_getprotobynumber): Ditto.
@
text
@d149 1
a149 1
	(char *) cygheap->user_heap.max += pround (newbrksize);
@


1.34
log
@* exceptions.cc (sigreturn): Don't clobber ebp in recursive signal calls.
@
text
@a141 1

d149 1
a149 1
	(char *) cygheap->user_heap.max += newbrksize;
@


1.33
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d59 1
d105 1
a105 1
    return cygheap->user_heap.ptr;			/* Just wanted to find current cygheap->user_heap.ptr address */
d126 3
d130 8
a137 5
   * we have used up previously reserved memory.  Or, we're just plumb out
   * of memory.  */
  commitbytes = pround (newtop - (char *) cygheap->user_heap.top);
  if (VirtualAlloc (cygheap->user_heap.top, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
    goto good;
d140 2
a141 2
     Reserve either the maximum of the standard cygwin_shared->heap_chunk_size () or the requested
     amount.  Then attempt to actually allocate it.  */
d146 7
a152 3
  if ((VirtualAlloc (cygheap->user_heap.top, newbrksize, MEM_RESERVE, PAGE_NOACCESS) != NULL) &&
      (VirtualAlloc (cygheap->user_heap.top, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL))
    goto good;
@


1.32
log
@* heap.cc (heap_init): Remove debugging code.
@
text
@a11 1
#include <errno.h>
@


1.31
log
@* cygheap.cc (cygheap_fixup_in_child): Use user_heap element in cygheap.
(init_cheap): Ditto for declaration.
* fork.cc (fork_parent): Use user_heap element in cygheap.
* heap.h (inheap): Ditto.
* heap.cc (sbrk): Ditto.
(heap_init): Ditto.  Reorganize to shrink heap chunk as required and record new
value in cygheap.
* dcrt0.cc (dll_crt0_1): More "move the cygthread init" games.
* shared.cc (open_shared): Rework memory protection to properly deal with
relocated shared segment.
(shared_info::heap_chunk_size): Rename element to 'heap_chunk'.
* shared_info.h (shared_info): Ditto for declaration.
* strace.cc (strace::hello): Report on heap chunk size from cygheap since it
may shrink.
@
text
@a71 2
MEMORY_BASIC_INFORMATION m;
(void) VirtualQuery (cygheap->user_heap.base, &m, sizeof (m));
a80 12
      if (p == NULL)
{
system_printf ("unable to allocate heap %p, chunk %u, reserve %u, alloc %u, %E",
cygheap->user_heap.base, cygheap->user_heap.chunk,
reserve_size, allocsize);
system_printf ("base %p mem alloc base %p, state %p, size %d, %E",
cygheap->user_heap.base, m.AllocationBase, m.State, m.RegionSize);
error_start_init ("h:/gdbtest/gdb.exe < con > con"); try_to_debug ();
	api_fatal ("unable to allocate heap %p, chunk %u, reserve %u, alloc %u, %E",
		   cygheap->user_heap.base, cygheap->user_heap.chunk,
		   reserve_size, allocsize);
}
@


1.31.12.1
log
@merge from trunk
@
text
@d72 2
d83 12
@


1.31.12.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d19 1
a20 1
#include "fhandler.h"
@


1.31.12.3
log
@merge from trunk
@
text
@d12 1
@


1.31.12.4
log
@merge from trunk
@
text
@a58 1
      cygheap->user_heap.max = (char *) cygheap->user_heap.base + cygheap->user_heap.chunk;
d104 1
a104 1
    return cygheap->user_heap.ptr;		/* Just wanted to find current cygheap->user_heap.ptr address */
d125 3
a127 1
  /* Find the number of bytes to commit, rounded up to the nearest page. */
d129 2
a130 10

  /* Need to grab more pages from the OS.  If this fails it may be because
     we have used up previously reserved memory.  Or, we're just plumb out
     of memory.  Only attempt to commit memory that we know we've previously
     reserved.  */
  if (newtop <= cygheap->user_heap.max)
    {
      if (VirtualAlloc (cygheap->user_heap.top, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
	goto good;
    }
d133 2
a134 2
     Reserve either the maximum of the standard cygwin_shared->heap_chunk_size ()
     or the requested amount.  Then attempt to actually allocate it.  */
d139 3
a141 7
   if ((VirtualAlloc (cygheap->user_heap.top, newbrksize, MEM_RESERVE, PAGE_NOACCESS)
        || VirtualAlloc (cygheap->user_heap.top, newbrksize = commitbytes, MEM_RESERVE, PAGE_NOACCESS))
       && VirtualAlloc (cygheap->user_heap.top, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
     {
	(char *) cygheap->user_heap.max += newbrksize;
	goto good;
     }
@


1.31.12.5
log
@merge from trunk
@
text
@d142 1
d150 1
a150 1
	(char *) cygheap->user_heap.max += pround (newbrksize);
@


1.31.12.6
log
@merge from trunk
@
text
@d149 1
a149 1
	cygheap->user_heap.max = (char *) cygheap->user_heap.max + pround (newbrksize);
@


1.30
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@d23 2
d32 2
d43 19
a61 1
  if (cygheap->heapbase)
d63 1
a63 1
      DWORD chunk = cygwin_shared->heap_chunk_size ();	/* allocation chunk */
d65 2
a66 1
      DWORD allocsize = (char *) cygheap->heaptop - (char *) cygheap->heapbase;
d72 2
d76 1
a76 1
	  p = (char *) VirtualAlloc (cygheap->heapbase, reserve_size,
d84 14
a97 5
	api_fatal ("1. unable to allocate heap %p, heap_chunk_size %d, pid %d, %E",
		   cygheap->heapbase, cygwin_shared->heap_chunk_size (), myself->pid);
      if (p != cygheap->heapbase)
	api_fatal ("heap allocated but not at %p", cygheap->heapbase);
      if (!VirtualAlloc (cygheap->heapbase, allocsize, MEM_COMMIT, PAGE_READWRITE))
a99 11
  else
    {
      /* Initialize page mask and default heap size.  Preallocate a heap
       * to assure contiguous memory.  */
      cygheap->heapptr = cygheap->heaptop = cygheap->heapbase =
	VirtualAlloc (NULL, cygwin_shared->heap_chunk_size (), MEM_RESERVE,
		     PAGE_NOACCESS);
      if (cygheap->heapbase == NULL)
	api_fatal ("2. unable to allocate heap, heap_chunk_size %d, %E",
		   cygwin_shared->heap_chunk_size ());
    }
d101 2
a102 2
  debug_printf ("heap base %p, heap top %p", cygheap->heapbase,
		cygheap->heaptop);
d119 1
a119 1
    return cygheap->heapptr;			/* Just wanted to find current cygheap->heapptr address */
d121 1
a121 1
  newbrk = (char *) cygheap->heapptr + n;	/* Where new cygheap->heapptr will be */
d125 1
a125 1
  if (newtop == cygheap->heaptop)
d130 2
a131 2
      assert (newtop < cygheap->heaptop);
      n = (char *) cygheap->heaptop - newtop;
d138 1
a138 1
  assert (newtop > cygheap->heaptop);
d143 2
a144 2
  commitbytes = pround (newtop - (char *) cygheap->heaptop);
  if (VirtualAlloc (cygheap->heaptop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
d151 1
a151 1
  if ((newbrksize = cygwin_shared->heap_chunk_size ()) < commitbytes)
d154 2
a155 2
  if ((VirtualAlloc (cygheap->heaptop, newbrksize, MEM_RESERVE, PAGE_NOACCESS) != NULL) &&
      (VirtualAlloc (cygheap->heaptop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL))
d163 3
a165 3
  void *oldbrk = cygheap->heapptr;
  cygheap->heapptr = newbrk;
  cygheap->heaptop = newtop;
@


1.29
log
@* cygthread.cc: Bump number of cygthreads up to accommodate applications which
use ttys.
@
text
@d89 1
a89 1
_sbrk (int n)
@


1.28
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d63 1
a63 1
      if (! VirtualAlloc (cygheap->heapbase, allocsize, MEM_COMMIT, PAGE_READWRITE))
@


1.27
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d71 1
a71 1
	VirtualAlloc(NULL, cygwin_shared->heap_chunk_size (), MEM_RESERVE,
d89 1
a89 1
_sbrk(int n)
d107 1
a107 1
      assert(newtop < cygheap->heaptop);
d109 1
a109 1
      if (VirtualFree(newtop, n, MEM_DECOMMIT)) /* Give it back to OS */
d115 1
a115 1
  assert(newtop > cygheap->heaptop);
d121 1
a121 1
  if (VirtualAlloc(cygheap->heaptop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
d131 2
a132 2
  if ((VirtualAlloc(cygheap->heaptop, newbrksize, MEM_RESERVE, PAGE_NOACCESS) != NULL) &&
      (VirtualAlloc(cygheap->heaptop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL))
@


1.26
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.25
log
@Eliminate excess whitespace.
@
text
@a13 1
#include "sync.h"
@


1.24
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d73 1
a73 1
	    	     PAGE_NOACCESS);
d80 1
a80 1
      		cygheap->heaptop);
@


1.23
log
@* cygheap.cc (cygheap_fixup_in_child): Clear cygheap->base so that heap is not
forced to start at the same place in execed process.
* heap.cc: Remove brk* macros for clarity throughout.
* heap.h: Ditto.
* shared.cc (shared_info::initialize): Move heap_chunk test into
heap_chunk_size().
(heap_chunk_size): Check for chunk size here.  Don't go to registry if
heap_chunk_in_mb is already set.
* smallprint.c (console_printf): Add Windows 95 concessions.
@
text
@d21 1
@


1.23.4.1
log
@Merged changes from HEAD
@
text
@a20 1
#include "path.h"
@


1.23.4.2
log
@Merged changes from HEAD
@
text
@d73 1
a73 1
		     PAGE_NOACCESS);
d80 1
a80 1
		cygheap->heaptop);
@


1.23.4.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d14 1
@


1.23.4.4
log
@Merged changes from HEAD
@
text
@d71 1
a71 1
	VirtualAlloc (NULL, cygwin_shared->heap_chunk_size (), MEM_RESERVE,
d89 1
a89 1
_sbrk (int n)
d107 1
a107 1
      assert (newtop < cygheap->heaptop);
d109 1
a109 1
      if (VirtualFree (newtop, n, MEM_DECOMMIT)) /* Give it back to OS */
d115 1
a115 1
  assert (newtop > cygheap->heaptop);
d121 1
a121 1
  if (VirtualAlloc (cygheap->heaptop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
d131 2
a132 2
  if ((VirtualAlloc (cygheap->heaptop, newbrksize, MEM_RESERVE, PAGE_NOACCESS) != NULL) &&
      (VirtualAlloc (cygheap->heaptop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL))
@


1.22
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d39 1
a39 1
  if (brkbase)
d41 1
a41 1
      DWORD chunk = brkchunk;	/* allocation chunk */
d43 1
a43 1
      DWORD allocsize = (char *) brktop - (char *) brkbase;
d51 1
a51 1
	  p = (char *) VirtualAlloc (brkbase, reserve_size,
d60 4
a63 4
		   brkbase, brkchunk, myself->pid);
      if (p != brkbase)
	api_fatal ("heap allocated but not at %p", brkbase);
      if (! VirtualAlloc (brkbase, allocsize, MEM_COMMIT, PAGE_READWRITE))
d70 4
a73 2
      brk = brktop = brkbase = VirtualAlloc(NULL, brkchunk, MEM_RESERVE, PAGE_NOACCESS);
      if (brkbase == NULL)
d75 1
a75 1
		   brkchunk);
d78 2
a79 1
  debug_printf ("heap base %p, heap top %p", brkbase, brktop);
d96 1
a96 1
    return brk;			/* Just wanted to find current brk address */
d98 3
a100 3
  newbrk = (char *) brk + n;	/* Where new brk will be */
  newtop = (char *) pround (newbrk); /* Actual top of allocated memory -
				   on page boundary */
d102 1
a102 1
  if (newtop == brktop)
d106 3
a108 3
    {				/* Freeing memory */
      assert(newtop < brktop);
      n = (char *) brktop - newtop;
d110 1
a110 1
	goto good;		/*  Didn't take */
d115 1
a115 1
  assert(newtop > brktop);
d120 2
a121 2
  commitbytes = pround (newtop - (char *) brktop);
  if (VirtualAlloc(brktop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL)
d125 1
a125 1
     Reserve either the maximum of the standard brkchunk or the requested
d128 1
a128 1
  if ((newbrksize = brkchunk) < commitbytes)
d131 2
a132 2
  if ((VirtualAlloc(brktop, newbrksize, MEM_RESERVE, PAGE_NOACCESS) != NULL) &&
      (VirtualAlloc(brktop, commitbytes, MEM_COMMIT, PAGE_READWRITE) != NULL))
d140 3
a142 3
  void *oldbrk = brk;
  brk = newbrk;
  brktop = newtop;
@


1.21
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d19 4
@


1.20
log
@forced commit
@
text
@d22 1
a22 1
static unsigned page_const = 0;
@


1.19
log
@Update copyrights.
@
text
@@


1.18
log
@* syscalls.cc (_link): Make sure that newpath does not exist.  Set errno if it
does.
* cygheap.cc (init_cheap): Don't specify a load address for the heap.  It
doesn't work on #!*& Windows 9x.
(cygheap_init): Move GetUserName to memory_init.
* dcrt0.cc (dll_crt0_1): Call new memory_init functin, eliminate call to
heap_init.
* heap.cc (heap_init): Improve error output.
* heap.h: Correct some declarations.
* shared.cc (mount_table_init): Remove.
(memory_init): Renamed from shared_init.  Reorganize to accomodate strange
Windows 9x problems with cygheap/heap interaction.
* shared_info.h: Rename shared_init to memory_init.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.17
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d55 2
a56 2
	api_fatal ("1. unable to allocate heap, heap_chunk_size %d, pid %d, %E",
		   brkchunk, myself->pid);
@


1.16
log
@        * heap.cc (heap_init): Fix extern declaration of getpagesize.
	* syscalls.cc (getpagesize): Fix another typo.
@
text
@d34 1
a34 1
  page_const = getpagesize ();
@


1.15
log
@        * syscalls.cc (getpagesize): Save pagesize in global variable to
        avoid calling GetSystemInfo too often.
        * heap.cc (getpagesize): Eliminate.
        (heap_init): Use getpagesize function from syscalls.cc.
@
text
@d24 2
a33 1
  extern size_t getpagesize ();
@


1.14
log
@* child_info: Bump child_info "version".
(child_info): Move some fields from child_info_spawn to here.
* cygheap.cc: Make cygheap pointers NOCOPY.
* dcrt0.cc (dll_crt0_1): Copy cygwin heap here regardless of whether we've been
forked or execed.
* dtable.cc (dtable::fixup_after_fork): Just release close-on-exec fds.
* exceptions.cc (stackdump): Respond to C warning.
* fork.cc: Reorganize to minimize stack copying.
(fork_child): New function.
(fork_parent): Ditto.
(sync_with_child): Don't suspend the forkee.
(sync_with_parent): Ditto.  Make into a function.
* heap.cc (heap_init): Add some debugging output.
* path.cc (path_conv::check): Add an assertion.
(has_suffix): Ditto.
* security.cc (get_pw_sid): Defend against NULL.
* sigproc.cc (proc_subproc): Fix debugging output.
(wait_sig): Ditto.
* strace.cc: Make statics NO_COPY throughout.
(strace::vsprntf): Defend against NULL.
@
text
@a23 8
static  __inline__ int
getpagesize(void)
{
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    return (int)si.dwPageSize;
}

d32 2
a33 1
  page_const = getpagesize();
@


1.13
log
@* spawn.cc (av::dup_maybe): Make function void rather than void *.
* environ.cc (environ_init): Remember to reparse CYGWIN if envp is
supplied.
* heap.cc (_sbrk): Remember frame for signal handling.
* syscalls.cc (read_handler): Eliminate.
(_read): Move read_handler code here.  Reorganize for one path through
'ready_for_read'.
@
text
@d78 1
@


1.12
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d89 1
@


1.11
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@a17 1
#include "tty.h"
@


1.10
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d18 2
@


1.9
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d17 1
a18 5
#define brksize ((char *) user_data->heaptop - (char *) user_data->heapbase)
#define brk (user_data->heapptr)
#define brkbase (user_data->heapbase)
#define brktop (user_data->heaptop)
#define brkchunk (cygwin_shared->heap_chunk_size ())
@


1.8
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d13 3
a16 1
#include "cygerrno.h"
@


1.7
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d14 1
@


1.6
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d13 1
@


1.5
log
@Revert errnoneous commit.
@
text
@d11 1
a12 1
#include "winsup.h"
@


1.4
log
@* exceptions.cc (stack_info::walk): Use method to find offset.
(handle_exceptions): Be more assertive in finding ebp for use under W2K.
Create a dummy stack frame for cases where program is dying and a stack dump is
being output.
(sig_handle): Fill out a GetThreadContext for use with a user-generated "core
dump".
@
text
@a22 2
HANDLE cygwin_heap;

d39 1
a41 1

d49 1
a49 1
      void *p;
d52 2
a53 1
	  p = MapViewOfFileEx (cygwin_heap, FILE_MAP_COPY, 0L, 0L, 0L, brkbase);
d56 1
a56 1
	  if ((reserve_size -= (page_const + 1)) <= allocsize)
d64 1
a64 1
      if (!VirtualAlloc (brkbase, allocsize, MEM_COMMIT, PAGE_READWRITE))
a68 1
      page_const = getpagesize() - 1;
d71 1
a71 6
      cygwin_heap = CreateFileMapping ((HANDLE) 0xffffffff, &sec_all, PAGE_WRITECOPY | SEC_RESERVE, 0L, brkchunk, NULL);
      if (cygwin_heap == NULL)
	api_fatal ("2. unable to allocate shared memory for heap, heap_chunk_size %d, %E", brkchunk);
      
      brk = brktop = brkbase = MapViewOfFile (cygwin_heap, 0, 0L, 0L, 0);
//    brk = brktop = brkbase = VirtualAlloc(NULL, brkchunk, MEM_RESERVE, PAGE_NOACCESS);
d77 1
@


1.3
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d23 2
a40 1
  page_const = getpagesize();
d43 1
d51 1
a51 1
      char *p;
d54 1
a54 2
	  p = (char *) VirtualAlloc (brkbase, reserve_size,
				     MEM_RESERVE, PAGE_READWRITE);
d57 1
a57 1
	  if ((reserve_size -= page_const) <= allocsize)
d65 1
a65 1
      if (! VirtualAlloc (brkbase, allocsize, MEM_COMMIT, PAGE_READWRITE))
d70 1
d73 6
a78 1
      brk = brktop = brkbase = VirtualAlloc(NULL, brkchunk, MEM_RESERVE, PAGE_NOACCESS);
a83 1
  page_const--;
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Cygnus Solutions.
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static int __inline
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
