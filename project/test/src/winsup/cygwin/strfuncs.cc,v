head	1.54;
access;
symbols
	cygwin-1_7_35-release:1.54
	cygwin-1_7_34-release:1.54
	cygwin-1_7_33-release:1.54
	cygwin-1_7_32-release:1.54
	cygwin-1_7_31-release:1.54
	cygwin-1_7_30-release:1.54
	cygwin-1_7_29-release:1.54
	cygwin-1_7_29-release-branchpoint:1.54.0.2
	cygwin-pre-user-db:1.54
	cygwin-1_7_28-release:1.54
	cygwin-1_7_27-release:1.54
	cygwin-1_7_26-release:1.54
	cygwin-1_7_25-release:1.52
	cygwin-1_7_24-release:1.52
	cygwin-1_7_23-release:1.52
	cygwin-1_7_22-release:1.52
	cygwin-1_7_21-release:1.51
	cygwin-1_7_20-release:1.51
	cygwin-1_7_19-release:1.51
	cygwin-64bit-postmerge:1.50
	cygwin-64bit-premerge-branch:1.50.0.2
	cygwin-64bit-premerge:1.50
	cygwin-1_7_18-release:1.50
	post-ptmalloc3:1.49.2.1
	pre-ptmalloc3:1.49.2.1
	cygwin-1_7_17-release:1.49
	cygwin-64bit-branch:1.49.0.2
	cygwin-1_7_16-release:1.49
	cygwin-1_7_15-release:1.48
	cygwin-1_7_14_2-release:1.48
	cygwin-1_7_14-release:1.48
	cygwin-1_7_12-release:1.48
	cygwin-1_7_11-release:1.47
	cygwin-1_7_10-release:1.47
	signal-rewrite:1.47.0.2
	pre-notty:1.47
	cygwin-1_7_9-release:1.45
	cv-post-1_7_9:1.45.0.2
	cygwin-1_7_8-release:1.45
	cygwin-1_7_7-release:1.44
	cygwin-1_7_5-release:1.43
	cygwin-1_7_4-release:1.43
	cygwin-1_7_3-release:1.43
	cygwin-1_7_2-release:1.43
	fifo_doover3:1.39.0.2
	cygwin-1_7_1-release:1.39
	prefifo:1.33
	cv-branch-2:1.32.0.2
	pre-ripout-set_console_state_for_spawn:1.14
	EOL_registry_mounts:1.12;
locks; strict;
comment	@// @;


1.54
date	2013.11.25.11.38.08;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2013.11.24.12.13.36;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2013.07.19.17.28.34;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.50;

1.50
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.02.20.17.27;	author corinna;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.02.15.28.35;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.19.09.41.54;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.23.11.07.35;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.24.12.29.49;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.23.16.43.17;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.22.22.31.31;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.18.16.07.22;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.02.11.42.04;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.28.12.10.32;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.23.17.13.55;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.23.11.31.00;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.22.09.44.32;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.22.15.01.03;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.30.21.18.43;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.03.19.04.07;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.03.17.23.39;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.31.03.59.38;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2009.05.14.19.49.37;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.13.15.00.06;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.08.20.28.20;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.08.19.38.33;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.07.16.22.55;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.07.12.13.37;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.06.10.50.11;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.01.09.49.25;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.26.10.26.57;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.25.13.54.41;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.25.09.02.22;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.24.18.20.01;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.24.16.42.36;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.24.12.18.34;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.14.10.21.22;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.07.18.45.59;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.02.22.51.19;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.25.18.32.23;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.06.22.04.16;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.06.18.24.50;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.05.17.37.10;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.04.12.00.19;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.31.20.26.01;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.23.16.26.28;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.12.12.48.01;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.02.14.21.53;	author cgf;	state Exp;
branches;
next	;

1.49.2.1
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.54
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@/* strfuncs.cc: string functions

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <sys/param.h>
#include <wchar.h>
#include <ntdll.h>
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"

/* Transform characters invalid for Windows filenames to the Unicode private
   use area in the U+f0XX range.  The affected characters are all control
   chars 1 <= c <= 31, as well as the characters " * : < > ? |.  The backslash
   is affected as well, but we can't transform it as long as we accept Win32
   paths as input. */
static const WCHAR tfx_chars[] = {
	    0, 0xf000 |   1, 0xf000 |   2, 0xf000 |   3,
 0xf000 |   4, 0xf000 |   5, 0xf000 |   6, 0xf000 |   7,
 0xf000 |   8, 0xf000 |   9, 0xf000 |  10, 0xf000 |  11,
 0xf000 |  12, 0xf000 |  13, 0xf000 |  14, 0xf000 |  15,
 0xf000 |  16, 0xf000 |  17, 0xf000 |  18, 0xf000 |  19,
 0xf000 |  20, 0xf000 |  21, 0xf000 |  22, 0xf000 |  23,
 0xf000 |  24, 0xf000 |  25, 0xf000 |  26, 0xf000 |  27,
 0xf000 |  28, 0xf000 |  29, 0xf000 |  30, 0xf000 |  31,
	  ' ',          '!', 0xf000 | '"',          '#',
	  '$',          '%',          '&',           39,
	  '(',          ')', 0xf000 | '*',          '+',
	  ',',          '-',          '.',          '\\',
	  '0',          '1',          '2',          '3',
	  '4',          '5',          '6',          '7',
	  '8',          '9', 0xf000 | ':',          ';',
 0xf000 | '<',          '=', 0xf000 | '>', 0xf000 | '?',
	  '@@',          'A',          'B',          'C',
	  'D',          'E',          'F',          'G',
	  'H',          'I',          'J',          'K',
	  'L',          'M',          'N',          'O',
	  'P',          'Q',          'R',          'S',
	  'T',          'U',          'V',          'W',
	  'X',          'Y',          'Z',          '[',
	  '\\',          ']',          '^',          '_',
	  '`',          'a',          'b',          'c',
	  'd',          'e',          'f',          'g',
	  'h',          'i',          'j',          'k',
	  'l',          'm',          'n',          'o',
	  'p',          'q',          'r',          's',
	  't',          'u',          'v',          'w',
	  'x',          'y',          'z',          '{',
 0xf000 | '|',          '}',          '~',          127
};

/* This is the table for the reverse functionality in sys_cp_wcstombs.
   It differs deliberately in two code places (space and dot) to allow
   converting back space and dot on filesystems only supporting DOS
   filenames. */
static const WCHAR tfx_rev_chars[] = {
	    0, 0xf000 |   1, 0xf000 |   2, 0xf000 |   3,
 0xf000 |   4, 0xf000 |   5, 0xf000 |   6, 0xf000 |   7,
 0xf000 |   8, 0xf000 |   9, 0xf000 |  10, 0xf000 |  11,
 0xf000 |  12, 0xf000 |  13, 0xf000 |  14, 0xf000 |  15,
 0xf000 |  16, 0xf000 |  17, 0xf000 |  18, 0xf000 |  19,
 0xf000 |  20, 0xf000 |  21, 0xf000 |  22, 0xf000 |  23,
 0xf000 |  24, 0xf000 |  25, 0xf000 |  26, 0xf000 |  27,
 0xf000 |  28, 0xf000 |  29, 0xf000 |  30, 0xf000 |  31,
 0xf000 | ' ',          '!', 0xf000 | '"',          '#',
	  '$',          '%',          '&',           39,
	  '(',          ')', 0xf000 | '*',          '+',
	  ',',          '-', 0xf000 | '.',          '\\',
	  '0',          '1',          '2',          '3',
	  '4',          '5',          '6',          '7',
	  '8',          '9', 0xf000 | ':',          ';',
 0xf000 | '<',          '=', 0xf000 | '>', 0xf000 | '?',
	  '@@',          'A',          'B',          'C',
	  'D',          'E',          'F',          'G',
	  'H',          'I',          'J',          'K',
	  'L',          'M',          'N',          'O',
	  'P',          'Q',          'R',          'S',
	  'T',          'U',          'V',          'W',
	  'X',          'Y',          'Z',          '[',
	  '\\',          ']',          '^',          '_',
	  '`',          'a',          'b',          'c',
	  'd',          'e',          'f',          'g',
	  'h',          'i',          'j',          'k',
	  'l',          'm',          'n',          'o',
	  'p',          'q',          'r',          's',
	  't',          'u',          'v',          'w',
	  'x',          'y',          'z',          '{',
 0xf000 | '|',          '}',          '~',          127
};

void
transform_chars (PWCHAR path, PWCHAR path_end)
{
  for (; path <= path_end; ++path)
    if (*path < 128)
      *path = tfx_chars[*path];
}

/* The SJIS, JIS and eucJP conversion in newlib does not use UTF as
   wchar_t character representation.  That's unfortunate for us since
   we require UTF for the OS.  What we do here is to have our own
   implementation of the base functions for the conversion using
   the MulitByteToWideChar/WideCharToMultiByte functions. */

/* FIXME: We can't support JIS (ISO-2022-JP) at all right now.  It's a
   stateful charset encoding.  The translation from mbtowc to
   MulitByteToWideChar is quite complex.  Given that we support SJIS and
   eucJP, the both most used Japanese charset encodings, this shouldn't
   be such a big problem. */

/* GBK, eucKR, and Big5 conversions are not available so far in newlib. */

static int
__db_wctomb (struct _reent *r, char *s, wchar_t wchar, UINT cp)
{
  if (s == NULL)
    return 0;

  if (wchar < 0x80)
    {
      *s = (char) wchar;
      return 1;
    }

  BOOL def_used = false;
  int ret = WideCharToMultiByte (cp, WC_NO_BEST_FIT_CHARS, &wchar, 1, s,
				 2, NULL, &def_used);
  if (ret > 0 && !def_used)
    return ret;

  r->_errno = EILSEQ;
  return -1;
}

extern "C" int
__sjis_wctomb (struct _reent *r, char *s, wchar_t wchar, const char *charset,
	       mbstate_t *state)
{
  return __db_wctomb (r,s, wchar, 932);
}

extern "C" int
__eucjp_wctomb (struct _reent *r, char *s, wchar_t wchar, const char *charset,
	       mbstate_t *state)
{
  /* Unfortunately, the Windows eucJP codepage 20932 is not really 100%
     compatible to eucJP.  It's a cute approximation which makes it a
     doublebyte codepage.
     The JIS-X-0212 three byte codes (0x8f,0xa1-0xfe,0xa1-0xfe) are folded
     into two byte codes as follows: The 0x8f is stripped, the next byte is
     taken as is, the third byte is mapped into the lower 7-bit area by
     masking it with 0x7f.  So, for instance, the eucJP code 0x8f,0xdd,0xf8
     becomes 0xdd,0x78 in CP 20932.

     To be really eucJP compatible, we have to map the JIS-X-0212 characters
     between CP 20932 and eucJP ourselves. */
  if (s == NULL)
    return 0;

  if (wchar < 0x80)
    {
      *s = (char) wchar;
      return 1;
    }

  BOOL def_used = false;
  int ret = WideCharToMultiByte (20932, WC_NO_BEST_FIT_CHARS, &wchar, 1, s,
				 3, NULL, &def_used);
  if (ret > 0 && !def_used)
    {
      /* CP20932 representation of JIS-X-0212 character? */
      if (ret == 2 && (unsigned char) s[1] <= 0x7f)
	{
	  /* Yes, convert to eucJP three byte sequence */
	  s[2] = s[1] | 0x80;
	  s[1] = s[0];
	  s[0] = 0x8f;
	  ++ret;
	}
      return ret;
    }

  r->_errno = EILSEQ;
  return -1;
}

extern "C" int
__gbk_wctomb (struct _reent *r, char *s, wchar_t wchar, const char *charset,
	       mbstate_t *state)
{
  return __db_wctomb (r,s, wchar, 936);
}

extern "C" int
__kr_wctomb (struct _reent *r, char *s, wchar_t wchar, const char *charset,
	       mbstate_t *state)
{
  return __db_wctomb (r,s, wchar, 949);
}

extern "C" int
__big5_wctomb (struct _reent *r, char *s, wchar_t wchar, const char *charset,
	       mbstate_t *state)
{
  return __db_wctomb (r,s, wchar, 950);
}

static int
__db_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n, UINT cp,
	     mbstate_t *state)
{
  wchar_t dummy;
  int ret;

  if (s == NULL)
    return 0;  /* not state-dependent */

  if (n == 0)
    return -2;

  if (pwc == NULL)
    pwc = &dummy;

  if (state->__count == 0)
    {
      if (*(unsigned char *) s < 0x80)
	{
	  *pwc = *(unsigned char *) s;
	  return *s ? 1 : 0;
	}
      size_t cnt = MIN (n, 2);
      ret = MultiByteToWideChar (cp, MB_ERR_INVALID_CHARS, s, cnt, pwc, 1);
      if (ret)
	return cnt;
      if (n == 1)
	{
	  state->__count = n;
	  state->__value.__wchb[0] = *s;
	  return -2;
	}
      /* These Win32 functions are really crappy.  Assuming n is 2 but the
	 first byte is a singlebyte charcode, the function does not convert
	 that byte and return 1, rather it just returns 0.  So, what we do
	 here is to check if the first byte returns a valid value... */
      else if (MultiByteToWideChar (cp, MB_ERR_INVALID_CHARS, s, 1, pwc, 1))
	return 1;
      r->_errno = EILSEQ;
      return -1;
    }
  state->__value.__wchb[state->__count] = *s;
  ret = MultiByteToWideChar (cp, MB_ERR_INVALID_CHARS,
			     (const char *) state->__value.__wchb, 2, pwc, 1);
  if (!ret)
    {
      r->_errno = EILSEQ;
      return -1;
    }
  state->__count = 0;
  return 1;
}

extern "C" int
__sjis_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
	       const char *charset, mbstate_t *state)
{
  return __db_mbtowc (r, pwc, s, n, 932, state);
}

extern "C" int
__eucjp_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
		const char *charset, mbstate_t *state)
{
  /* See comment in __eucjp_wctomb above. */
  wchar_t dummy;
  int ret = 0;

  if (s == NULL)
    return 0;  /* not state-dependent */

  if (n == 0)
    return -2;

  if (pwc == NULL)
    pwc = &dummy;

  if (state->__count == 0)
    {
      if (*(unsigned char *) s < 0x80)
	{
	  *pwc = *(unsigned char *) s;
	  return *s ? 1 : 0;
	}
      if (*(unsigned char *) s == 0x8f)	/* JIS-X-0212 lead byte? */
	{
	  /* Yes.  Store sequence in mbstate and handle in the __count != 0
	     case at the end of the function. */
	  size_t i;
	  for (i = 0; i < 3 && i < n; i++)
	    state->__value.__wchb[i] = s[i];
	  if ((state->__count = i) < 3)	/* Incomplete sequence? */
	    return -2;
	  ret = 3;
	  goto jis_x_0212;
	}
      size_t cnt = MIN (n, 2);
      if (MultiByteToWideChar (20932, MB_ERR_INVALID_CHARS, s, cnt, pwc, 1))
	return cnt;
      if (n == 1)
	{
	  state->__count = 1;
	  state->__value.__wchb[0] = *s;
	  return -2;
	}
      else if (MultiByteToWideChar (20932, MB_ERR_INVALID_CHARS, s, 1, pwc, 1))
	return 1;
      r->_errno = EILSEQ;
      return -1;
    }
  state->__value.__wchb[state->__count++] = *s;
  ret = 1;
jis_x_0212:
  if (state->__value.__wchb[0] == 0x8f)
    {
      if (state->__count == 2)
	{
	  if (n == 1)
	    return -2;
	  state->__value.__wchb[state->__count] = s[1];
	  ret = 2;
	}
      /* Ok, we have a full JIS-X-0212 sequence in mbstate.  Convert it
	 to the CP 20932 representation and feed it to MultiByteToWideChar. */
      state->__value.__wchb[0] = state->__value.__wchb[1];
      state->__value.__wchb[1] = state->__value.__wchb[2] & 0x7f;
    }
  if (!MultiByteToWideChar (20932, MB_ERR_INVALID_CHARS,
			    (const char *) state->__value.__wchb, 2, pwc, 1))
    {
      r->_errno = EILSEQ;
      return -1;
    }
  state->__count = 0;
  return ret;
}

extern "C" int
__gbk_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
	       const char *charset, mbstate_t *state)
{
  return __db_mbtowc (r, pwc, s, n, 936, state);
}

extern "C" int
__kr_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
	       const char *charset, mbstate_t *state)
{
  return __db_mbtowc (r, pwc, s, n, 949, state);
}

extern "C" int
__big5_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
	       const char *charset, mbstate_t *state)
{
  return __db_mbtowc (r, pwc, s, n, 950, state);
}

/* Our own sys_wcstombs/sys_mbstowcs functions differ from the
   wcstombs/mbstowcs API in three ways:

   - The UNICODE private use area is used in filenames to specify
     characters not allowed in Windows filenames ('*', '?', etc).
     The sys_wcstombs converts characters in the private use area
     back to the corresponding ASCII chars.

   - If a wide character in a filename has no representation in the current
     multibyte charset, then usually you wouldn't be able to access the
     file.  To fix this problem, sys_wcstombs creates a replacement multibyte
     sequences for the non-representable wide-char.  The sequence starts with
     an ASCII CAN (0x18, Ctrl-X), followed by the UTF-8 representation of the
     character.  The sys_(cp_)mbstowcs function detects ASCII CAN characters
     in the input multibyte string and converts the following multibyte
     sequence in by treating it as an UTF-8 char.  If that fails, the ASCII
     CAN was probably standalone and it gets just copied over as ASCII CAN.

   - Three cases have to be distinguished for the return value:

     - dst == NULL; len is ignored, the return value is the number of bytes
       required for the string without the trailing NUL, just like the return
       value of the wcstombs function.

     - dst != NULL, len == (size_t) -1; the return value is the size in bytes
       of the destination string without the trailing NUL.  If the incoming
       wide char string was not NUL-terminated, the target string won't be
       NUL-terminated either.

     - dst != NULL; len != (size_t) -1; the return value is the size in bytes
       of the destination string without the trailing NUL.  The target string
       will be NUL-terminated, no matter what.  If the result is truncated due
       to buffer size, it's a bug in Cygwin and the buffer in the calling
       function should be raised.
*/
size_t __reg3
sys_cp_wcstombs (wctomb_p f_wctomb, const char *charset, char *dst, size_t len,
		 const wchar_t *src, size_t nwc)
{
  char buf[10];
  char *ptr = dst;
  wchar_t *pwcs = (wchar_t *) src;
  size_t n = 0;
  mbstate_t ps;
  save_errno save;

  memset (&ps, 0, sizeof ps);
  if (dst == NULL)
    len = (size_t) -1;
  while (n < len && nwc-- > 0)
    {
      wchar_t pw = *pwcs;
      int bytes;
      unsigned char cwc;

      /* Convert UNICODE private use area.  Reverse functionality for the
	 ASCII area <= 0x7f (only for path names) is transform_chars above.
	 Reverse functionality for invalid bytes in a multibyte sequence is
	 in sys_cp_mbstowcs below. */
      if ((pw & 0xff00) == 0xf000
	  && (((cwc = (pw & 0xff)) <= 0x7f && tfx_rev_chars[cwc] >= 0xf000)
	      || (cwc >= 0x80 && MB_CUR_MAX > 1)))
	{
	  buf[0] = (char) cwc;
	  bytes = 1;
	}
      else
	{
	  bytes = f_wctomb (_REENT, buf, pw, charset, &ps);
	  if (bytes == -1 && *charset != 'U'/*TF-8*/)
	    {
	      /* Convert chars invalid in the current codepage to a sequence
		 ASCII CAN; UTF-8 representation of invalid char. */
	      buf[0] = 0x18; /* ASCII CAN */
	      bytes = __utf8_wctomb (_REENT, buf + 1, pw, charset, &ps);
	      if (bytes == -1)
		{
		  ++pwcs;
		  ps.__count = 0;
		  continue;
		}
	      ++bytes; /* Add the ASCII CAN to the byte count. */
	      if (ps.__count == -4 && nwc > 0)
		{
		  /* First half of a surrogate pair. */
		  ++pwcs;
		  if ((*pwcs & 0xfc00) != 0xdc00) /* Invalid second half. */
		    {
		      ++pwcs;
		      ps.__count = 0;
		      continue;
		    }
		  bytes += __utf8_wctomb (_REENT, buf + bytes, *pwcs, charset,
					  &ps);
		  nwc--;
		}
	    }
	}
      if (n + bytes <= len)
	{
	  n += bytes;
	  if (dst)
	    {
	      for (int i = 0; i < bytes; ++i)
		*ptr++ = buf[i];
	    }
	  if (*pwcs++ == 0x00)
	    break;
	}
      else
	break;
    }
  if (n && dst && len != (size_t) -1)
    {
      n = (n < len) ? n : len - 1;
      dst[n] = '\0';
    }

  return n;
}

size_t __reg3
sys_wcstombs (char *dst, size_t len, const wchar_t * src, size_t nwc)
{
  return sys_cp_wcstombs (cygheap->locale.wctomb, cygheap->locale.charset,
			  dst, len, src, nwc);
}

/* Allocate a buffer big enough for the string, always including the
   terminating '\0'.  The buffer pointer is returned in *dst_p, the return
   value is the number of bytes written to the buffer, as usual.
   The "type" argument determines where the resulting buffer is stored.
   It's either one of the cygheap_types values, or it's "HEAP_NOTHEAP".
   In the latter case the allocation uses simple calloc.

   Note that this code is shared by cygserver (which requires it via
   __small_vsprintf) and so when built there plain calloc is the
   only choice.  */
size_t __reg3
sys_wcstombs_alloc (char **dst_p, int type, const wchar_t *src, size_t nwc)
{
  size_t ret;

  ret = sys_wcstombs (NULL, (size_t) -1, src, nwc);
  if (ret > 0)
    {
      size_t dlen = ret + 1;

      if (type == HEAP_NOTHEAP)
	*dst_p = (char *) calloc (dlen, sizeof (char));
      else
	*dst_p = (char *) ccalloc ((cygheap_types) type, dlen, sizeof (char));
      if (!*dst_p)
	return 0;
      ret = sys_wcstombs (*dst_p, dlen, src, nwc);
    }
  return ret;
}

/* sys_cp_mbstowcs is actually most of the time called as sys_mbstowcs with
   a 0 codepage.  If cp is not 0, the codepage is evaluated and used for the
   conversion.  This is so that fhandler_console can switch to an alternate
   charset, which is the charset returned by GetConsoleCP ().  Most of the
   time this is used for box and line drawing characters. */
size_t __reg3
sys_cp_mbstowcs (mbtowc_p f_mbtowc, const char *charset, wchar_t *dst,
		 size_t dlen, const char *src, size_t nms)
{
  wchar_t *ptr = dst;
  unsigned const char *pmbs = (unsigned const char *) src;
  size_t count = 0;
  size_t len = dlen;
  int bytes;
  mbstate_t ps;
  save_errno save;

  memset (&ps, 0, sizeof ps);
  if (dst == NULL)
    len = (size_t)-1;
  while (len > 0 && nms > 0)
    {
      /* ASCII CAN handling. */
      if (*pmbs == 0x18)
	{
	  /* Sanity check: If this is a lead CAN byte for a following UTF-8
	     sequence, there must be at least two more bytes left, and the
	     next byte must be a valid UTF-8 start byte.  If the charset
	     isn't UTF-8 anyway, try to convert the following bytes as UTF-8
	     sequence. */
	  if (nms > 2 && pmbs[1] >= 0xc2 && pmbs[1] <= 0xf4 && *charset != 'U'/*TF-8*/)
	    {
	      bytes = __utf8_mbtowc (_REENT, ptr, (const char *) pmbs + 1,
				     nms - 1, charset, &ps);
	      if (bytes < 0)
		{
		  /* Invalid UTF-8 sequence?  Treat the ASCII CAN character as
		     stand-alone ASCII CAN char. */
		  bytes = 1;
		  if (dst)
		    *ptr = 0x18;
		  memset (&ps, 0, sizeof ps);
		}
	      else
		{
		  ++bytes; /* Count CAN byte */
		  if (bytes > 1 && ps.__count == 4)
		    {
		      /* First half of a surrogate. */
		      wchar_t *ptr2 = dst ? ptr + 1 : NULL;
		      int bytes2 = __utf8_mbtowc (_REENT, ptr2,
						  (const char *) pmbs + bytes,
						  nms - bytes, charset, &ps);
		      if (bytes2 < 0)
			memset (&ps, 0, sizeof ps);
		      else
			{
			  bytes += bytes2;
			  ++count;
			  ptr = dst ? ptr + 1 : NULL;
			  --len;
			}
		    }
		}
	    }
	  /* Otherwise it's just a simple ASCII CAN. */
	  else
	    {
	      bytes = 1;
	      if (dst)
		*ptr = 0x18;
	    }
	}
      else if ((bytes = f_mbtowc (_REENT, ptr, (const char *) pmbs, nms,
				  charset, &ps)) < 0)
	{
	  /* The technique is based on a discussion here:
	     http://www.mail-archive.com/linux-utf8@@nl.linux.org/msg00080.html

	     Invalid bytes in a multibyte secuence are converted to
	     the private use area which is already used to store ASCII
	     chars invalid in Windows filenames.  This technque allows
	     to store them in a symmetric way. */
	  bytes = 1;
	  if (dst)
	    *ptr = L'\xf000' | *pmbs;
	  memset (&ps, 0, sizeof ps);
	}

      if (bytes > 0)
	{
	  pmbs += bytes;
	  nms -= bytes;
	  ++count;
	  ptr = dst ? ptr + 1 : NULL;
	  --len;
	}
      else
	{
	  if (bytes == 0)
	    ++count;
	  break;
	}
    }

  if (count && dst)
    {
      count = (count < dlen) ? count : dlen - 1;
      dst[count] = L'\0';
    }

  return count;
}

size_t __reg3
sys_mbstowcs (wchar_t * dst, size_t dlen, const char *src, size_t nms)
{
  return sys_cp_mbstowcs (cygheap->locale.mbtowc, cygheap->locale.charset,
			  dst, dlen, src, nms);
}

/* Same as sys_wcstombs_alloc, just backwards. */
size_t __reg3
sys_mbstowcs_alloc (wchar_t **dst_p, int type, const char *src, size_t nms)
{
  size_t ret;

  ret = sys_mbstowcs (NULL, (size_t) -1, src, nms);
  if (ret > 0)
    {
      size_t dlen = ret + 1;

      if (type == HEAP_NOTHEAP)
	*dst_p = (wchar_t *) calloc (dlen, sizeof (wchar_t));
      else
	*dst_p = (wchar_t *) ccalloc ((cygheap_types) type, dlen,
				      sizeof (wchar_t));
      if (!*dst_p)
	return 0;
      ret = sys_mbstowcs (*dst_p, dlen, src, nms);
    }
  return ret;
}

/* Copy string, until c or <nul> is encountered.
   NUL-terminate the destination string (s1).
   Return pointer to terminating byte in dst string.  */
char * __stdcall
strccpy (char *__restrict s1, const char **__restrict s2, char c)
{
  while (**s2 && **s2 != c)
    *s1++ = *((*s2)++);
  *s1 = 0;

  MALLOC_CHECK;
  return s1;
}

static WCHAR hex_wchars[] = L"0123456789abcdef";

NTSTATUS NTAPI
RtlInt64ToHexUnicodeString (ULONGLONG value, PUNICODE_STRING dest,
			    BOOLEAN append)
{
  USHORT len = append ? dest->Length : 0;
  if (dest->MaximumLength - len < 16 * (int) sizeof (WCHAR))
    return STATUS_BUFFER_OVERFLOW;
  wchar_t *end = (PWCHAR) ((PBYTE) dest->Buffer + len);
  register PWCHAR p = end + 16;
  while (p-- > end)
    {
      *p = hex_wchars[value & 0xf];
      value >>= 4;
    }
  dest->Length += 16 * sizeof (WCHAR);
  return STATUS_SUCCESS;
}
@


1.53
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d684 1
a684 1
strccpy (char *s1, const char **s2, char c)
@


1.52
log
@* common.din: Export GetCommandLine{A,W}.
* kernel32.cc: Add includes needed for GetCommandLine functions.
(ucmd): New function.
(cygwin_GetCommandLineW): Ditto.
(cygwin_GetCommandLineA): Ditto.
* spawn.cc (child_info_spawn::worker): Rename one_line -> cmd.  Use lb_wcs
macro to generate a wide character version of the line buffer.  Remove
duplicate printing of command line.  Don't access members of linebuf directly.
* winf.h: Use pragma once.
(linebuf): Make storage private.
(linebuf::operator size_t): New operator.  Return size of buf.
(linebuf::operator wchar_t): New operator.
(linebuf::wcs): New function.
(lb_wcs): New macro.
* include/cygwin/version.h: Bump API minor number to 268.
* strfuncs.cc: Clarify descriptive file comment.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
a15 1
#include <winnls.h>
@


1.51
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d1 1
a1 1
/* strfuncs.cc: misc funcs that don't belong anywhere else
@


1.50
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d413 1
a413 1
size_t __stdcall
d499 1
a499 1
size_t __stdcall
d516 1
a516 1
size_t __stdcall
d542 1
a542 1
size_t __stdcall
d651 1
a651 1
size_t __stdcall
d659 1
a659 1
size_t __stdcall
@


1.49
log
@	* fhandler.h (class fhandler_dev_clipboard): Remove member eof.
	* fhandler_clipboard.cc: Throughout remove handling of eof member.
	(fhandler_dev_clipboard::write): Handle EOF condition immediately,
	rather than pushing it erroneously to the next read call.  Rearrange
	code.  Fix bug in CF_UNICODETEXT case which potentially dropped single
	bytes at the end of the buffer.  Add comment.
	* strfuncs.cc (sys_cp_wcstombs): Allow returning non-NUL-terminated
	buffer if dst != NULL and len == (size_t) -1.  Extend leading comment
	to explain what's returned in more detail.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.49.2.1
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.48
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d396 17
a412 3
   - The functions always create 0-terminated results, no matter what.
     If the result is truncated due to buffer size, it's a bug in Cygwin
     and the buffer in the calling function should be raised. */
d490 1
a490 1
  if (n && dst)
@


1.47
log
@whitespace elimination
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d14 1
d242 1
a242 1
      size_t cnt = min (n, 2);
d316 1
a316 1
      size_t cnt = min (n, 2);
@


1.46
log
@Eliminate trailing whitespace in some files.

* dll_init.cc (dll_list::alloc): Reset 'p' in forked process.
* select.cc (select_stuff::wait): Move cleanup() closer to WFMO to minimize
unavoidable (?) race.
@
text
@d28 1
a28 1
            0, 0xf000 |   1, 0xf000 |   2, 0xf000 |   3,
d36 7
a42 7
          ' ',          '!', 0xf000 | '"',          '#',
          '$',          '%',          '&',           39,
          '(',          ')', 0xf000 | '*',          '+',
          ',',          '-',          '.',          '\\',
          '0',          '1',          '2',          '3',
          '4',          '5',          '6',          '7',
          '8',          '9', 0xf000 | ':',          ';',
d44 15
a58 15
          '@@',          'A',          'B',          'C',
          'D',          'E',          'F',          'G',
          'H',          'I',          'J',          'K',
          'L',          'M',          'N',          'O',
          'P',          'Q',          'R',          'S',
          'T',          'U',          'V',          'W',
          'X',          'Y',          'Z',          '[',
          '\\',          ']',          '^',          '_',
          '`',          'a',          'b',          'c',
          'd',          'e',          'f',          'g',
          'h',          'i',          'j',          'k',
          'l',          'm',          'n',          'o',
          'p',          'q',          'r',          's',
          't',          'u',          'v',          'w',
          'x',          'y',          'z',          '{',
d67 1
a67 1
            0, 0xf000 |   1, 0xf000 |   2, 0xf000 |   3,
d76 6
a81 6
          '$',          '%',          '&',           39,
          '(',          ')', 0xf000 | '*',          '+',
          ',',          '-', 0xf000 | '.',          '\\',
          '0',          '1',          '2',          '3',
          '4',          '5',          '6',          '7',
          '8',          '9', 0xf000 | ':',          ';',
d83 15
a97 15
          '@@',          'A',          'B',          'C',
          'D',          'E',          'F',          'G',
          'H',          'I',          'J',          'K',
          'L',          'M',          'N',          'O',
          'P',          'Q',          'R',          'S',
          'T',          'U',          'V',          'W',
          'X',          'Y',          'Z',          '[',
          '\\',          ']',          '^',          '_',
          '`',          'a',          'b',          'c',
          'd',          'e',          'f',          'g',
          'h',          'i',          'j',          'k',
          'l',          'm',          'n',          'o',
          'p',          'q',          'r',          's',
          't',          'u',          'v',          'w',
          'x',          'y',          'z',          '{',
d419 1
a419 1
         ASCII area <= 0x7f (only for path names) is transform_chars above.
@


1.45
log
@	* exec.cc (strccpy): Move function from here...
	* strfuncs.cc (strccpy): ...to here.
	* string.h (strccpy): Declare.
	* winsup.h (strccpy): Drop declaration.
@
text
@d603 1
a603 1
	     chars invalid in Windows filenames.  This technque allows 
@


1.44
log
@	* path.h (get_nt_native_path): Add third parameter to declaration and
	declare with regparms.
	* path.cc (get_nt_native_path): Add third parameter to allow conversion
	of leading and trailing dots and spaces on filesystems only supporting
	filenames following DOS rules.
	(path_conv::get_nt_native_path): Call get_nt_native_path according to
	fs.has_dos_filenames_only flag.
	(getfileattr): Accommodate new parameter to get_nt_native_path.
	(symlink_info::check): Revamp fs_update_called handling to call
	fs.update only once per call.  Call get_nt_native_path according to
	fs.has_dos_filenames_only flag.  Streamline filesystem dependent code
	not to be called more than once unnecessarily.  Drop code tweaking
	incoming path for broken filesystems only allowing DOS pathnames.
	Rely on changed get_nt_native_path instead.
	* mount.cc (fillout_mntent): Accommodate new parameter to
	get_nt_native_path.
	* strfuncs.cc (tfx_rev_chars): New conversion table with comment.
	(sys_cp_wcstombs): Use tfx_rev_chars rather than tfx_chars.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d666 14
@


1.43
log
@	* nlsfuncs.cc (check_codepage): Move from syscalls.cc here.
	(internal_setlocale): Ditto.
	(initial_setlocale): Ditto.
	(setlocale): Ditto.
	* strfuncs.cc (__sjis_wctomb): Revert previous patch.
	(__sjis_mbtowc): Ditto.
	* syscalls.cc: Move setlocale-related functions to nlsfuncs.cc.
@
text
@d26 1
a26 2
   paths as input.
   The reverse functionality is in function sys_cp_wcstombs. */
d62 39
d423 1
a423 1
	  && (((cwc = (pw & 0xff)) <= 0x7f && tfx_chars[cwc] >= 0xf000)
@


1.42
log
@	* strfuncs.cc (__sjis_wctomb): Special handling for characters which
	differ between SJIS and Windows codepage 932, if charset is "SJIS".
	(__sjis_mbtowc): Ditto.
	(_jis_wctomb): Remove.
	(__jis_mbtowc): Remove.
@
text
@a110 17
  if (*charset == 'S')
    {
      /* SJIS is not exactly CP932.  Two ASCII code points are converted
	 differently. */
      if (wchar == L'\x00a5')	 /* SJIS has Yen sign in place of Backslash */
	{
	  if (s)
	    *s = '\x5c';
	  return 1;
	}
      else if (wchar == L'\x203e') /* SJIS has Overline in place of Tilde */
	{
	  if (s)
	    *s = '\x7e';
	  return 1;
	}
    }
d238 1
a238 11
  int ret = __db_mbtowc (r, pwc, s, n, 932, state);
  if (*charset == 'S' && pwc && ret == 1)
    {
      /* CP932 is not exactly SJIS.  Two ASCII code points are converted
	 differently. */
      if (*s == '\x5c')		/* SJIS has Yen sign in place of Backslash */
      	*pwc = L'\x00a5';
      else if (*s == '\x7e')	/* SJIS has Overline in place of Tilde */
	*pwc = L'\x203e';
    }
  return ret;
@


1.41
log
@	* Makefile.in (DLL_OFILES): Add nlsfunc.o and strfmon.o.
	* autoload.cc (LocaleNameToLCID): Define.
	* cygwin.din (strfmon): Export.
	* nlsfuncs.cc: New file.  Define a lot of internal functions called
	from setlocale.
	(wcscoll): Implement locale-aware here, using CompareStringW function.
	(strcoll): Ditto.
	(wcsxfrm): Implement locale-aware here, usingLCMapStringW function.
	(strxfrm): Ditto.
	(__set_charset_from_locale): Replace __set_charset_from_codepage.
	Return Linux-compatible charset.
	* strfuncs.cc (__set_charset_from_codepage): Remove.
	* wchar.h (__set_charset_from_codepage): Drop definition.
	* wincap.h (wincaps::has_localenames): New element.
	* wincap.cc: Implement above element throughout.
	* libc/strfmon.c: New file.
	* libc/strptime.cc: Remove locale constant strings in favor of
	access to locale-specifc data.
	(strptime): Point _CurrentTimeLocale to locale-specific data.
	Throughout use correct locale-specific format fields for all
	locale-specific formats.
	* include/monetary.h: New file.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d111 17
a131 8
__jis_wctomb (struct _reent *r, char *s, wchar_t wchar, const char *charset,
	       mbstate_t *state)
{
  /* FIXME: See comment at start of file. */
  return __ascii_wctomb (r, s, wchar, charset, state);
}

extern "C" int
d255 11
a265 9
  return __db_mbtowc (r, pwc, s, n, 932, state);
}

extern "C" int
__jis_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
	       const char *charset, mbstate_t *state)
{
  /* FIXME: See comment at start of file. */
  return __ascii_mbtowc (r, pwc, s, n, charset, state);
@


1.40
log
@	* strfuncs.cc: Remove needless includes.
@
text
@a354 81
/* Convert Windows codepage to a setlocale compatible character set code.
   Called from newlib's setlocale() with codepage set to 0, if the
   charset isn't given explicitely in the POSIX compatible locale specifier.
   The function also returns a pointer to the corresponding _mbtowc_r
   function. */
extern "C" mbtowc_p
__set_charset_from_codepage (UINT cp, char *charset)
{
  if (cp == 0)
    cp = GetACP ();
  switch (cp)
    {
    case 437:
    case 720:
    case 737:
    case 775:
    case 850:
    case 852:
    case 855:
    case 857:
    case 858:
    case 862:
    case 866:
    case 874:
    case 1125:
    case 1250:
    case 1251:
    case 1252:
    case 1253:
    case 1254:
    case 1255:
    case 1256:
    case 1257:
    case 1258:
    case 20866:
    case 21866:
      __small_sprintf (charset, "CP%u", cp);
      return __cp_mbtowc;
    case 28591:
    case 28592:
    case 28593:
    case 28594:
    case 28595:
    case 28596:
    case 28597:
    case 28598:
    case 28599:
    case 28603:
    case 28605:
      __small_sprintf (charset, "ISO-8859-%u", cp - 28590);
      return __iso_mbtowc;
    case 932:
      strcpy (charset, "SJIS");
      return __sjis_mbtowc;
    case 936:
      strcpy (charset, "GBK");
      return __gbk_mbtowc;
    case 949:
    case 51949:
      strcpy (charset, "EUCKR");
      return __kr_mbtowc;
    case 950:
      strcpy (charset, "BIG5");
      return __big5_mbtowc;
    case 50220:
      strcpy (charset, "JIS");
      return __jis_mbtowc;
    case 20932:
    case 51932:
      strcpy (charset, "EUCJP");
      return __eucjp_mbtowc;
    case 65001:
      strcpy (charset, "UTF-8");
      return __utf8_mbtowc;
    default:
      break;
    }
  strcpy (charset, "ASCII");
  return __ascii_mbtowc;
}

@


1.39
log
@	* miscfuncs.h (transform_chars): Declare.  Define inline variation here.
	* mount.cc (mount_info::from_fstab): Remove extern declaration of
	transform_chars.
	* path.cc (tfx_chars): Move to strfuncs.cc.
	(transform_chars): Ditto.
	* strfunc.cc (tfx_chars): Moved here from path.cc.
	(transform_chars): Ditto.
	(sys_cp_wcstombs): Make UNICODE private use area conversion roundtrip
	save for all characters.
	(sys_cp_mbstowcs): Ditto, by removing special case for UTF-8 sequences
	representing U+f0XX UNICODE chars.  Fix typo in comment.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
a16 2
#include "cygerrno.h"
#include "security.h"
a20 1
#include "tls_pbuf.h"
@


1.38
log
@	* fhandler.h (class dev_console): Constify charset parameter of
	str_to_con.
	* fhandler_console.cc (dev_console::con_to_str): Simplify.  Always
	default to the current internal locale.
	(dev_console::get_console_cp): Always use codepage 437 for alternate
	charset.
	(dev_console::str_to_con): Constify charset parameter.
	(fhandler_console::write_normal): Always use codepage 437 for alternate
	charset.  Otherwise always default to the current internal locale.
	Replace ASCII SO with ASCII CAN.
	* strfuncs.cc: Tweka comments according to below changes.
	(sys_cp_wcstombs): Constify charset parameter.  Convert all wchar_t
	values in the Unicode private use area U+F0xx to the singlebyte
	counterpart.  Drop special handling creating ASCII SO sequence from
	U+DCxx value.  Rearrange for performance.  Replace ASCII SO with
	ASCII CAN.
	(sys_cp_mbstowcs): Constify charset parameter.  Replace ASCII SO with
	ASCII CAN.  Drop special case for U+DCxx ASCII SO sequences.  Always
	create a replacement from the Unicode private use area U+F0xx for
	invalid byte values in a multibyte sequence.  Do the same for wchar_t
	values from the U+F0xx range to make them roundtrip safe.
	* wchar.h (sys_cp_wcstombs): Constify charset parameter.
	(sys_cp_mbstowcs): Ditto.
@
text
@d25 49
d478 1
d481 6
a486 4
         ASCII area <= 0x7f (only for path names) is transform_chars in
	 path.cc.  Reverse functionality for invalid bytes in a multibyte
	 sequence is in sys_cp_mbstowcs. */
      if ((pw & 0xff00) == 0xf000 && ((pw & 0xff) <= 0x7f || MB_CUR_MAX > 1))
d488 1
a488 1
	  buf[0] = pw & 0xff;
d490 1
a490 1
      	}
d658 1
a658 2
				  charset, &ps)) < 0
	       || (bytes == 3 && pmbs[0] == 0xef && (pmbs[1] & 0xf4) == 0x80))
d665 1
a665 1
	     chars invalid in Windows filenames.  This techinque allows 
@


1.37
log
@	* strfuncs.cc (__set_charset_from_codepage): Fetch current ANSI
	codepage if cp is 0.
@
text
@d313 1
a313 2
   function.  Also called from fhandler_console::write_normal() if the
   "Alternate Charset" has been switched on by an escape sequence. */
d402 2
a403 2
     an ASCII SO (0x0e, Ctrl-N), followed by the UTF-8 representation of the
     character.  The sys_(cp_)mbstowcs function detects ASCII SO characters
d406 1
a406 1
     SO was probably standalone and it gets just copied over as ASCII SO.
d412 1
a412 1
sys_cp_wcstombs (wctomb_p f_wctomb, char *charset, char *dst, size_t len,
d428 7
a434 6
      /* Convert UNICODE private use area.  Reverse functionality (only for
	 path names) is transform_chars in path.cc. */
      if ((pw & 0xff00) == 0xf000)
	pw &= 0xff;
      int bytes = f_wctomb (_REENT, buf, pw, charset, &ps);
      if (bytes == -1 && (pw & 0xff00) == 0xdc00)
d436 4
a439 10
	  /* Reverse functionality of the single invalid second half of a
	     surrogate pair in the 0xDCxx range specifying an invalid byte
	     value when converting from MB to WC.
	     The comment in sys_cp_mbstowcs below explains it. */
	  buf[0] = 0x0e; /* ASCII SO */
	  buf[1] = 0xff;
	  buf[2] = (char) (pw & 0xff);
	  bytes = 3;
	}
      else if (bytes == -1 && *charset != 'U'/*TF-8*/)
d441 2
a442 5
	  /* Convert chars invalid in the current codepage to a sequence
	     ASCII SO; UTF-8 representation of invalid char. */
	  buf[0] = 0x0e; /* ASCII SO */
	  bytes = __utf8_wctomb (_REENT, buf + 1, pw, charset, &ps);
	  if (bytes == -1)
d444 5
a448 9
	      ++pwcs;
	      ps.__count = 0;
	      continue;
	    }
	  ++bytes; /* Add the ASCII SO to the byte count. */
	  if (ps.__count == -4 && nwc > 0) /* First half of a surrogate pair. */
	    {
	      ++pwcs;
	      if ((*pwcs & 0xfc00) != 0xdc00) /* Invalid second half. */
d454 15
a468 2
	      bytes += __utf8_wctomb (_REENT, buf + bytes, *pwcs, charset, &ps);
	      nwc--;
d538 2
a539 2
sys_cp_mbstowcs (mbtowc_p f_mbtowc, char *charset, wchar_t *dst, size_t dlen,
		 const char *src, size_t nms)
d554 2
a555 2
      /* ASCII SO handling. */
      if (*pmbs == 0x0e)
d557 1
a557 1
	  /* Sanity check: If this is a lead SO byte for a following UTF-8
d568 2
a569 2
		  /* Invalid UTF-8 sequence?  Treat the ASCII SO character as
		     stand-alone ASCII SO char. */
d572 1
a572 1
		    *ptr = 0x0e;
d577 1
a577 1
		  ++bytes; /* Count SO byte */
d597 1
a597 10
	  /* Sequence for an invalid byte originally created in the next outer
	     else branch below.  This must be converted back to a 0xDCxx value
	     as well. */
	  else if (nms > 2 && pmbs[1] == 0xff)
	    {
	      bytes = 3;
	      if (dst)
		*ptr = L'\xdc80' | pmbs[2];
	    }
	  /* Otherwise it's just a simple ASCII SO. */
d602 1
a602 1
		*ptr = 0x0e;
d607 1
a607 1
	       && *pmbs >= 0x80)
d609 1
a609 4
	  /* This should probably be handled in f_mbtowc which can operate
	     on sequences rather than individual characters.
	     The technique is based on a discussion here:

d612 4
a615 4
	     This is hardly perfect.  Windows doesn't do anything sensical with
	     characters converted to this format.  It does allow processing of
	     src to continue, however, which, since there is no way to signal
	     decoding errors, seems like the best we can do. */
d618 1
a618 1
	    *ptr = L'\xdc80' | *pmbs;
@


1.36
log
@	* strfuncs.cc (sys_cp_wcstombs): Convert lone surrogate pair
	second halves to unambiguous ASCII SO sequence.  When converting
	chars invalid in current codepage to ASCII SO sequence, make
	sure to check for surrogate pair second half only if ct least
	one wide characters is left.  Decrement nwc if valid second half has
	been converted.
	(sys_cp_mbstowcs): Improve ASCII SO handling.  Never break from loop
	if invalid character has been found.  Recognize ASCII SO sequence
	representing originally invalid mulitbyte char converted into a
	lone surrogate pair second half.  Convert accordingly.
@
text
@d310 1
a310 1
   Called from newlib's setlocale() with the current ANSI codepage, if the
d318 2
@


1.35
log
@	* strfuncs.cc (sys_cp_mbstowcs): Reset shift state after handling
	invalid multibyte sequence.
@
text
@d438 4
a441 2
	  buf[0] = (char) (pw & 0xff);
	  bytes = 1;
d456 1
a456 1
	  if (ps.__count == -4) /* First half of a surrogate pair. */
d466 1
d552 54
a605 12
      /* ASCII SO.  Sanity check: If this is a lead SO byte for a following
	 UTF-8 sequence, there must be at least two more bytes left, and the
	 next byte must be a valid UTF-8 start byte.  If the charset isn't
	 UTF-8 anyway, try to convert the following bytes as UTF-8 sequence. */
      if (*pmbs == 0x0e && nms > 2 && pmbs[1] >= 0xc2
	  && pmbs[1] <= 0xf4 && *charset != 'U'/*TF-8*/)
	{
	  pmbs++;
	  --nms;
	  bytes = __utf8_mbtowc (_REENT, ptr, (const char *) pmbs, nms,
				 charset, &ps);
	  if (bytes < 0)
a606 2
	      /* Invalid UTF-8 sequence?  Treat the ASCII SO character as
		 stand-alone ASCII SO char. */
a609 18
	      memset (&ps, 0, sizeof ps);
	      break;
	    }
	  if (bytes == 0)
	    break;
	  if (ps.__count == 4) /* First half of a surrogate. */
	    {
	      wchar_t *ptr2 = dst ? ptr + 1 : NULL;
	      int bytes2 = __utf8_mbtowc (_REENT, ptr2,
					  (const char *) pmbs + bytes,
					  nms - bytes, charset, &ps);
	      if (bytes2 < 0)
		break;
	      pmbs += bytes2;
	      nms -= bytes2;
	      ++count;
	      ptr = dst ? ptr + 1 : NULL;
	      --len;
d626 1
a629 1
	  bytes = 1;
@


1.34
log
@* cygwin/strfuncs.cc (__set_charset_from_codepage): Add codepages 20866
(KOI8-R) and 21866 (KOI8-U).

* doc/setup2.sgml (setup-locale-charsetlist): Add KOI8-R and KOI8-U to list of
supported charsets.
@
text
@d603 1
@


1.33
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d342 2
@


1.32
log
@	* strfuncs.cc (sys_cp_mbstowcs): Fix condition.
@
text
@d154 1
a154 1
  
d224 1
a224 1
  
d440 1
a440 1
        {
d463 1
a463 1
        }
d465 8
a472 8
        {
          n += bytes;
          if (dst)
            {
              for (int i = 0; i < bytes; ++i)
                *ptr++ = buf[i];
            }
          if (*pwcs++ == 0x00)
d474 1
a474 1
        }
d476 1
a476 1
        break;
d561 1
a561 1
	         stand-alone ASCII SO char. */
d564 1
a564 1
	      	*ptr = 0x0e;
d605 4
a608 4
        {
          pmbs += bytes;
          nms -= bytes;
          ++count;
d610 2
a611 2
          --len;
        }
@


1.31
log
@	* strfuncs.cc (sys_cp_wcstombs): Implement reverse functionality
	of the change to sys_cp_mbstowcs from 2009-05-30.
	(sys_cp_mbstowcs): Slightly reformat.  Fix comment to accommodate
	change to sys_cp_wcstombs.  Don't write to *ptr if dst is NULL.
@
text
@d587 1
a587 1
	       && *pmbs > '\x80')
@


1.30
log
@* strfuncs.cc (sys_cp_mbstowcs): Treat src as unsigned char *.  Convert failure
of f_mbtowc into a single malformed utf-16 value.
@
text
@d430 10
a439 3
      /* Convert chars invalid in the current codepage to a sequence
         ASCII SO; UTF-8 representation of invalid char. */
      if (bytes == -1 && *charset != 'U'/*TF-8*/)
d441 2
d573 2
a574 1
	      int bytes2 = __utf8_mbtowc (_REENT, ptr2, (const char *) pmbs + bytes,
d585 3
a587 1
      else if ((bytes = f_mbtowc (_REENT, ptr, (const char *) pmbs, nms, charset, &ps)) < 0 && *pmbs > '\x80')
d596 5
a600 7
	     characters converted to this format and (currently) we don't convert
	     them back into their original single byte form.  It does allow
	     processing of src to continue, however, which, since there is no
	     way to signal decoding errors, seems like the best we can do.

	  */
	  *ptr = L'\xdc80' | *pmbs;
@


1.29
log
@	* cygheap.cc (cygheap_init): Set Cygwin default locale values.
	* cygheap.h (struct cygheap_locale): New structure.
	(struct user_heap_info): Add cygheap_locale member locale.
	* dcrt0.cc (dll_crt0_1): Revert to calling _setlocale_r so that only
	the applications locale is reverted to "C".
	* environ.cc (environ_init): Remove unused got_lc variable.
	* fhandler.h (class dev_console): Remove now unsed locale variables.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove
	setting dev_console's locale members.
	(dev_console::con_to_str): Use internal locale settings.  Default to
	__ascii_wctomb if charset is "ASCII".
	(fhandler_console::write_normal): Ditto.
	* strfuncs.cc (__ascii_wctomb): Drop declaration.
	(__db_wctomb): Use fixed value 2 instead of not
	necessarily matching MB_CUR_MAX.
	(__eucjp_wctomb): Use 3 instead of MB_CUR_MAX.
	(sys_cp_wcstombs): Remove special case for "C" locale.
	(sys_wcstombs): Implement here.  Use internal locale data stored on
	cygheap.
	(sys_cp_mbstowcs): Remove special case for "C" locale.
	(sys_mbstowcs): Implement here.  Use internal locale data stored on
	cygheap.
	* syscalls.cc (internal_setlocale): New function to set cygheap locale
	data and to reset CWD posix path.
	(setlocale): Just call internal_setlocale from here if necessary.
	* wchar.h (__ascii_wctomb): Declare.
	(sys_wcstombs): Don't define inline, just declare.
	(sys_mbstowcs): Ditto.
@
text
@d526 1
a526 1
  char *pmbs = (char *) src;
d542 2
a543 2
      if (*pmbs == 0x0e && nms > 2 && *(unsigned char *) (pmbs + 1) >= 0xc2
	  && *(unsigned char *) (pmbs + 1) <= 0xf4 && *charset != 'U'/*TF-8*/)
d547 2
a548 1
	  bytes = __utf8_mbtowc (_REENT, ptr, pmbs, nms, charset, &ps);
d564 1
a564 1
	      int bytes2 = __utf8_mbtowc (_REENT, ptr2, pmbs + bytes,
d575 19
a593 2
      else
	bytes = f_mbtowc (_REENT, ptr, pmbs, nms, charset, &ps);
@


1.28
log
@	* cygheap.h (cwdstuff): Convert to class.  Make posix and dir private.
	(cwdstuff::get_posix): New method.
	(cwdstuff::reset_posix): New method.
	* dcrt0.cc (dll_crt0_1): Call setlocale rather than _setlocale_r.
	* environ.cc (environ_init): Ditto.  Prefer "C" locale over current
	codepage default locale.
	* path.cc (chdir): Use cwdstuff::get_posix method instead of accessing
	cwdstuff::posix directly.
	(cwdstuff::set): Defer creating posix path to first usage.
	(cwdstuff::get_posix): Create posix path if it's empty, and return it.
	(cwdstuff::get): Create posix path if it's empty.
	* strfuncs.cc (sys_cp_wcstombs): Use UTF-8 conversion in the "C"
	locale.
	(sys_cp_mbstowcs): Ditto.
	* syscalls.cc (gen_full_path_at): Fetch CWD posix path locked.
	(setlocale): Implement here.  Reset CWD posix path.
@
text
@d53 1
a53 1
				 MB_CUR_MAX, NULL, &def_used);
a67 2
extern "C" int __ascii_wctomb (struct _reent *, char *, wchar_t, const char *,
			       mbstate_t *);
d102 1
a102 1
				 MB_CUR_MAX, NULL, &def_used);
a418 2
  if (f_wctomb == __ascii_wctomb)
    f_wctomb = __utf8_wctomb;
d478 7
a532 2
  if (f_mbtowc == __ascii_mbtowc)
    f_mbtowc = __utf8_mbtowc;
d601 7
@


1.27
log
@	* strfuncs.cc (sys_cp_wcstombs): save and restore previous errno value.
	(sys_cp_mbstowcs): Ditto.
@
text
@d421 2
d530 2
@


1.26
log
@	* strfuncs.cc (sys_cp_wcstombs): Set errno to 0 before converting
	wide char to SO/UTF-8 sequence.
@
text
@d419 1
a435 1
	  _REENT->_errno = 0;
d526 1
@


1.25
log
@	* strfuncs.cc: Change WCHAR to wchar_t in multibyte<->widechar
	conversion functions throughout.
	* wchar.h: Ditto in declarations.  Guard them __INSIDE_CYGWIN__.
@
text
@d435 1
@


1.24
log
@	* fhandler.h (class dev_console): Add members con_mbtowc, con_wctomb,
	and con_charset.
	(dev_console::str_to_con): Take mbtowc function pointer and charset
	as additional parameters.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Initialize
	aforementioned new members.  Explain why.
	(dev_console::con_to_str): Remove useless comment.  Call new
	sys_cp_wcstombs function rather than sys_wcstombs.
	(dev_console::str_to_con): Take mbtowc function pointer and charset
	as additional parameters.  Call sys_cp_mbstowcs accordingly.
	(fhandler_console::write_normal): Only initialize f_mbtowc and charset
	once.  Accommodate changed str_to_con.
	* strfuncs.cc (sys_cp_wcstombs): Renamed from sys_wcstombs.  Take
	wctomb function pointer and charset as parameters.  Use throughout.
	(sys_cp_mbstowcs): Take wctomb function pointer and charset as
	parameters instead of codepage.  Remove matching local variables and
	their initialization.
	* wchar.h (ENCODING_LEN): Define as in newlib.
	(__mbtowc): Use mbtowc_p typedef for declaration.
	(wctomb_f): New type.
	(wctomb_p): New type.
	(__wctomb): Declare.
	(__utf8_wctomb): Use wctomb_f typedef for declaration.
	(sys_cp_wcstombs): Move declaration from winsup.h here.
	(sys_wcstombs): Ditto.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Ditto.
	(sys_mbstowcs): Ditto.
	(sys_mbstowcs_alloc): Ditto.
	* winsup.h: Move declaration of sys_FOO functions to wchar.h.  Include
	wchar.h instead.
@
text
@d412 1
a412 1
		 const PWCHAR src, size_t nwc)
d490 1
a490 1
sys_wcstombs_alloc (char **dst_p, int type, const PWCHAR src, size_t nwc)
d516 1
a516 1
sys_cp_mbstowcs (mbtowc_p f_mbtowc, char *charset, PWCHAR dst, size_t dlen,
d596 1
a596 1
sys_mbstowcs_alloc (PWCHAR *dst_p, int type, const char *src, size_t nms)
d606 1
a606 1
	*dst_p = (PWCHAR) calloc (dlen, sizeof (WCHAR));
d608 2
a609 1
	*dst_p = (PWCHAR) ccalloc ((cygheap_types) type, dlen, sizeof (WCHAR));
d626 1
a626 1
  PWCHAR end = (PWCHAR) ((PBYTE) dest->Buffer + len);
@


1.23
log
@	* strfuncs.cc: Add comment to explain why we can't support JIS
	for now.
	(__db_wctomb): Alwaus use WC_NO_BEST_FIT_CHARS.
	(__jis_wctomb): Just call __ascii_wctomb from here.
	(__eucjp_wctomb): Convert to standalone implementation to fix up the
	difference between eucJP and CP 20932 affecting JIS-X-0212 characters.
	Explain.
	(__kr_wctomb): Use codepage 949.
	(__db_mbtowc): Reorder code slightly.  Always use MB_ERR_INVALID_CHARS
	in call to MultiByteToWideChar.  Fix a problem with singlebyte
	sequences.  Fix a bug in '\0' handling.  Reset state->__count on
	successful return from non-zero state.
	(__jis_mbtowc): Just call __ascii_mbtowc from here.
	(__eucjp_mbtowc): Convert to standalone implementation to fix up the
	difference between eucJP and CP 20932 affecting JIS-X-0212 characters.
	(__kr_mbtowc): Use codepage 949.
	(__set_charset_from_codepage): Handle codepage 20932 as eucJP.
@
text
@d315 2
a316 3
   function.  This is used below in the sys_cp_mbstowcs function which
   is called directly from fhandler_console if the "Alternate Charset" has
   been switched on by an escape sequence. */
d411 2
a412 1
sys_wcstombs (char *dst, size_t len, const PWCHAR src, size_t nwc)
d430 1
a430 1
      int bytes = _wctomb_r (_REENT, buf, pw, &ps);
d433 1
a433 1
      if (bytes == -1 && *__locale_charset () != 'U'/*TF-8*/)
d436 1
a436 1
	  bytes = __utf8_wctomb (_REENT, buf + 1, pw, __locale_charset (), &ps);
d453 1
a453 2
	      bytes += __utf8_wctomb (_REENT, buf + bytes, *pwcs,
				      __locale_charset (), &ps);
d516 2
a517 1
sys_cp_mbstowcs (UINT cp, PWCHAR dst, size_t dlen, const char *src, size_t nms)
a524 6
  char charsetbuf[32];
  char *charset = __locale_charset ();
  mbtowc_p f_mbtowc = __mbtowc;

  if (cp)
    f_mbtowc = __set_charset_from_codepage (cp, charset = charsetbuf);
@


1.22
log
@	* strfuncs.cc (sys_cp_mbstowcs): Check if ASCII SO is followed by at
	least two chars and the next byte is a valid UTF-8 start byte before
	trying to convert the followup bytes as UTF-8 sequence.
@
text
@d25 1
a25 1
/* The SJIS, JIS and EUCJP conversion in newlib does not use UTF as
d31 6
d52 2
a53 2
  int ret = WideCharToMultiByte (cp, cp > 50000 ? 0 : WC_NO_BEST_FIT_CHARS,
				 &wchar, 1, s, MB_CUR_MAX, NULL, &def_used);
d68 2
d74 2
a75 1
  return __db_wctomb (r,s, wchar, 50220);
d82 39
a120 1
  return __db_wctomb (r,s, wchar, 51932);
d134 1
a134 1
  return __db_wctomb (r,s, wchar, 51949);
d145 2
a146 2
__db_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
	     UINT cp, mbstate_t *state)
a148 1
  char buf[2];
a149 3
  
  if (pwc == NULL)
    pwc = &dummy;
d156 3
d167 2
a168 2
      ret = MultiByteToWideChar (cp, cp > 50000 ? 0 : MB_ERR_INVALID_CHARS,
				 s, 2, pwc, 1);
d170 1
a170 1
	return *s ? 2 : 0;
d173 1
a173 1
	  state->__count = 1;
d177 6
a182 13
      else
	{
	  /* These Win32 functions are really crappy.  Assuming n is 2
	     but the first byte is a singlebyte charcode, the function
	     does not convert that byte and return 1, rather it just
	     returns 0.  So, what we do here is to check if the first
	     byte returns a valid value... */
	  ret = MultiByteToWideChar (cp,
				     cp > 50000 ? 0 : MB_ERR_INVALID_CHARS,
				     s, 1, pwc, 1);
	  if (ret)
	    return *s ? 1 : 0;
	}
d186 3
a188 6
  if (!*s)
    return -2;
  buf[0] = state->__value.__wchb[0];
  buf[1] = *s;
  ret = MultiByteToWideChar (cp, cp > 50000 ? 0 : MB_ERR_INVALID_CHARS,
			     buf, 2, pwc, 1);
d194 2
a195 1
  return ret;
d209 2
a210 1
  return __db_mbtowc (r, pwc, s, n, 50220, state);
d215 1
a215 1
	       const char *charset, mbstate_t *state)
d217 71
a287 1
  return __db_mbtowc (r, pwc, s, n, 51932, state);
d301 1
a301 1
  return __db_mbtowc (r, pwc, s, n, 51949, state);
d376 1
@


1.21
log
@	* strfuncs.cc (__set_charset_from_codepage): Revert to translating
	codepage 936 to "GBK".
@
text
@d428 6
a433 2
      /* ASCII SO.  Convert following UTF-8 sequence (if not UTF-8 anyway). */
      if (*pmbs == 0x0e && *charset != 'U'/*TF-8*/)
@


1.20
log
@	* strfuncs.cc (sys_wcstombs): Don't convert ASCII SO into two
	ASCII SO's.
@
text
@d31 1
a31 1
/* GB2312, eucKR, and Big5 conversions are not available so far in newlib. */
d256 1
a256 1
      strcpy (charset, "GB2312");
@


1.19
log
@	* strfuncs.cc (__kr_wctomb): Use codepage 51949 rather than 50949.
	(__kr_mbtowc): Ditto.
	(__set_charset_from_codepage): Ditto.  Translate codepage 936 to
	"GB2312" and drop the charset name "GBK".
@
text
@d323 2
a324 3
         ASCII SO; UTF-8 representation of invalid char.
	 Do the same for ASCII SO itself. */
      if ((bytes == -1 || pw == 0x0e) && *__locale_charset () != 'U'/*TF-8*/)
@


1.18
log
@	* strfuncs.cc (__kr_wctomb): Use codepage 50949 rather than 949.
	(__kr_mbtowc): Ditto.
	(__set_charset_from_codepage): Translate codepages 949 and 50949 to
	"EUCKR" and drop the charset name "CP949".
@
text
@d31 1
a31 1
/* GBK, eucKR, and Big5 conversions are not available so far in newlib. */
d87 1
a87 1
  return __db_wctomb (r,s, wchar, 50949);
d193 1
a193 1
  return __db_mbtowc (r, pwc, s, n, 50949, state);
d256 1
a256 1
      strcpy (charset, "GBK");
d259 1
a259 1
    case 50949:
@


1.17
log
@	* strfuncs.cc (sys_cp_mbstowcs): Don't read beyond src + nms.
@
text
@d31 1
a31 1
/* GBK, CP949, and Big5 conversions are not available so far in newlib. */
d87 1
a87 1
  return __db_wctomb (r,s, wchar, 949);
d193 1
a193 1
  return __db_mbtowc (r, pwc, s, n, 949, state);
d259 2
a260 1
      strcpy (charset, "CP949");
@


1.16
log
@	* ctype.cc (_CTYPE_DATA_0_127): Add _B class to TAB character.
	(__ctype_default): New character class array for default ASCII
	character set.
	(__ctype_iso): New array of character class array for ISO charsets.
	(__ctype_cp): Ditto for singlebyte Windows codepages.
	(tolower): Implement as distinct function to support any singlebyte
	charset.
	(toupper): Ditto.
	(__set_ctype): New function to copy singlebyte character classes
	corresponding to current charset to ctype_b array.
	Align copyright text to upstream.
	* dcrt0.cc (dll_crt0_1): Reset current locale to "C" per POSIX.
	* environ.cc (set_file_api_mode): Remove.
	(codepage_init): Remove.
	(parse_thing): Remove "codepage" setting.
	(environ_init): Set locale according to environment settings, or
	to current codepage, before converting environment to multibyte.
	* fhandler.h (fhandler_console::write_replacement_char): Drop argument.
	* fhandler_console.cc (dev_console::str_to_con): Call sys_cp_mbstowcs
	rather than MultiByteToWideChar.
	(fhandler_console::write_replacement_char): Always print a funny
	half filled square if a character isn't in the current charset.
	(fhandler_console::write_normal): Convert to using __mbtowc
	rather than next_char.
	* fork.cc (frok::child): Drop call to set_file_api_mode.
	* globals.cc (enum codepage_type) Remove.
	(current_codepage): Remove.
	* miscfuncs.cc (cygwin_wcslwr): Unused, dangerous.  Remove.
	(cygwin_wcsupr): Ditto.
	(is_cp_multibyte): Remove.
	(next_char): Remove.
	* miscfuncs.h (is_cp_multibyte): Drop declaration.
	(next_char): Ditto.
	* strfuncs.cc (get_cp): Remove.
	(__db_wctomb): New function to implement _wctomb_r functionality for
	doublebyte charsets using WideCharToMultiByte.
	(__sjis_wctomb): New function to replace unusable newlib function.
	(__jis_wctomb): Ditto.
	(__eucjp_wctomb): Ditto.
	(__gbk_wctomb): New function.
	(__kr_wctomb): Ditto.
	(__big5_wctomb): Ditto.
	(__db_mbtowc): New function to implement _mbtowc_r functionality for
	doublebyte charsets using MultiByteToWideChar.
	(__sjis_mbtowc): New function to replace unusable newlib function.
	(__jis_mbtowc): Ditto.
	(__eucjp_mbtowc): Ditto.
	(__gbk_mbtowc): New function.
	(__kr_mbtowc): New function
	(__big5_mbtowc): New function
	(__set_charset_from_codepage): New function.
	(sys_wcstombs): Reimplement, basically using same wide char to multibyte
	conversion as newlib's application level functions.  Plus extras.
	Add lengthy comment to explain.  Change return type to size_t.
	(sys_wcstombs_alloc): Just use sys_wcstombs.  Change return type to
	size_t.
	(sys_cp_mbstowcs): Replace sys_mbstowcs, take additional codepage
	argument.  Explain why.  Change return type to size_t.
	(sys_mbstowcs_alloc): Just use sys_mbstowcs.  Change return type to
	size_t.
	* wchar.h: Declare internal functions implemented in strfuncs.cc.
	(wcscasecmp): Remove.
	(wcsncasecmp): Remove.
	(wcslwr): Remove.
	(wcsupr): Remove.
	* winsup.h (codepage_init): Remove declaration.
	(get_cp): Ditto.
	(sys_wcstombs): Align declaration to new implementation.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Add declaration.
	(sys_mbstowcs): Define as inline function.
	(sys_mbstowcs_alloc): Align declaration to new implementation.
	(set_file_api_mode): Remove declaration.
	* include/ctype.h (isblank): Redefine to use _B character class.
	(toupper): Remove ASCII-only definition.
	(tolower): Ditto.
@
text
@d426 1
a426 1
  while (len > 0)
d432 1
@


1.15
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d23 1
d25 54
a78 2
UINT
get_cp ()
d80 1
a80 3
  if (!active_codepage)
    codepage_init ("ansi");
  return active_codepage;
d83 3
a85 5
/* tlen is always treated as the maximum buffer size, including the '\0'
   character.  sys_wcstombs will always return a 0-terminated result, no
   matter what. */
int __stdcall
sys_wcstombs (char *tgt, int tlen, const PWCHAR src, int slen)
d87 16
d104 9
d114 1
a114 13
  /* Convert UNICODE private use area.  Reverse functionality (only for
     path names) is transform_chars in path.cc. */
  if (slen < 0)
    slen = wcslen (src) + 1;
  WCHAR sbuf[slen];
  memcpy (sbuf, src, slen * sizeof (WCHAR));
  const unsigned char *end = (unsigned char *) (sbuf + slen);
  for (unsigned char *s = ((unsigned char *) sbuf) + 1; s < end;
       s += sizeof (WCHAR))
    if (*s == 0xf0)
      *s = 0;
  ret = WideCharToMultiByte (get_cp (), 0, sbuf, slen, tgt, tlen, NULL, NULL);
  if (ret && tgt)
d116 41
a156 2
      ret = (ret < tlen) ? ret : tlen - 1;
      tgt[ret] = '\0';
d161 210
d372 1
a372 1
   terminating '\0'.  The buffer pointer is returned in *tgt_p, the return
d381 2
a382 2
int __stdcall
sys_wcstombs_alloc (char **tgt_p, int type, const PWCHAR src, int slen)
d384 1
a384 1
  int ret;
d386 2
a387 2
  ret = WideCharToMultiByte (get_cp (), 0, src, slen, NULL, 0 ,NULL, NULL);
  if (ret)
d389 1
a389 1
      size_t tlen = (slen == -1) ? ret : ret + 1;
d392 1
a392 1
	*tgt_p = (char *) calloc (tlen, sizeof (char));
d394 2
a395 2
	*tgt_p = (char *) ccalloc ((cygheap_types) type, tlen, sizeof (char));
      if (!*tgt_p)
d397 1
a397 1
      ret = sys_wcstombs (*tgt_p, tlen, src, slen);
d402 7
a408 2
int __stdcall
sys_mbstowcs (PWCHAR tgt, int tlen, const char *src, int slen)
d410 17
a426 2
  int ret = MultiByteToWideChar (get_cp (), 0, src, slen, tgt, tlen);
  if (ret && tgt)
d428 47
a474 2
      ret = (ret < tlen) ? ret : tlen - 1;
      tgt[ret] = L'\0';
d476 8
a483 1
  return ret;
d487 2
a488 2
int __stdcall
sys_mbstowcs_alloc (PWCHAR *tgt_p, int type, const char *src, int slen)
d490 1
a490 1
  int ret;
d492 2
a493 2
  ret = MultiByteToWideChar (get_cp (), 0, src, slen, NULL, 0);
  if (ret)
d495 1
a495 1
      size_t tlen = (slen == -1 ? ret : ret + 1);
d498 1
a498 1
	*tgt_p = (PWCHAR) calloc (tlen, sizeof (WCHAR));
d500 2
a501 2
	*tgt_p = (PWCHAR) ccalloc ((cygheap_types) type, tlen, sizeof (WCHAR));
      if (!*tgt_p)
d503 1
a503 1
      ret = sys_mbstowcs (*tgt_p, tlen, src, slen);
@


1.14
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Drop
	explicit transformation of special DOS chars.
	* strfuncs.cc (sys_wcstombs): Always transform UNICODE private use area
	back to ASCII.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
a23 3
codepage_type current_codepage = ansi_cp;
UINT active_codepage = 0;

@


1.13
log
@Remove unneeded header files from source files throughout.
@
text
@d14 1
d43 12
a54 1
  ret = WideCharToMultiByte (get_cp (), 0, src, slen, tgt, tlen, NULL, NULL);
@


1.12
log
@	* Fix copyright dates.
@
text
@a13 1
#include <winbase.h>
@


1.11
log
@* cygtls.cc (_cygtls::init_exception_handler): Semi-revert to making only
ourselves the exception handler and nothing else.
* exceptions.cc (open_stackdumpfile): Use correct format specifiers for unicode
when printing nameof stackdump file.
(stack_info::walk): Stop walking if ebp points into cygwin itself.
(_cygtls::handle_exceptions): Detect when signal is masked and treat as if it
was not caught.  Reinitialize exception handler to known state to avoid
subsequent attempts to call Windows exception handlers if an exception occurs
in a signal handler.  Revert to a 'return 0' rather than using a goto.
* strfuncs.cc (sys_wcstombs_alloc): Minor formatting tweak.
* winsup.h: Fix comment typo.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.10
log
@	* dcrt0.cc (initial_env): Only use local buffer "buf" if DEBUGGING is
	enabled.  Replace calls to GetEnvironmentVariable by calls to
	GetEnvironmentVariableA for clarity.  Call GetEnvironmentVariableA
	with NULL buffer.
	(cygbench): Ditto, drop local buffer.
	* environ.cc (getearly): Call GetEnvironmentVariableA.
	(environ_init): Retrieve unicode environment and convert to current
	codepage locally.
	(getwinenveq): Ditto.
	* exceptions.cc (try_to_debug): Accommodate new sys_mbstowcs calling
	convention.
	* fhandler_clipboard.cc (set_clipboard): Call sys_mbstowcs to retrieve
	required buffer length.
	* fork.cc (frok::child): Call GetEnvironmentVariableA.
	* miscfuncs.cc: Accommodate changed arguments in calls to sys_mbstowcs.
	* sec_auth.cc: Ditto.
	* strfuncs.cc (sys_wcstombs_alloc): Fix formatting.
	(sys_mbstowcs): Change arguments to allow specifying a source string
	length.
	(sys_mbstowcs_alloc): Ditto.
	* uinfo.cc (cygheap_user::ontherange): Accommodate changed arguments in
	calls to sys_mbstowcs.
	* winsup.h (sys_mbstowcs): Adjust declaration.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d70 1
a70 1
      size_t tlen = (slen == -1 ? ret : ret + 1);
@


1.9
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d67 1
a67 1
  ret = WideCharToMultiByte (get_cp (), 0, src, slen, NULL, 0,NULL, NULL);
d84 1
a84 1
sys_mbstowcs (PWCHAR tgt, const char *src, int len)
d86 7
a92 2
  int res = MultiByteToWideChar (get_cp (), 0, src, -1, tgt, len);
  return res;
d97 1
a97 1
sys_mbstowcs_alloc (PWCHAR *tgt_p, int type, const char *src)
d101 1
a101 1
  ret = MultiByteToWideChar (get_cp (), 0, src, -1, NULL, 0);
d104 2
d107 1
a107 1
	*tgt_p = (PWCHAR) calloc (ret, sizeof (WCHAR));
d109 1
a109 1
	*tgt_p = (PWCHAR) ccalloc ((cygheap_types) type, ret, sizeof (WCHAR));
d112 1
a112 1
      ret = sys_mbstowcs (*tgt_p, src, ret);
@


1.8
log
@	* miscfuncs.cc (next_char): Fix typos in comment.
	* strfuncs.cc: Remove cygserver guards.
@
text
@d58 1
a58 1
   
d60 1
a60 1
   __small_vsprintf) and so when built there plain calloc is the 
d73 1
a73 1
        *tgt_p = (char *) calloc (tlen, sizeof (char));
d75 1
a75 1
      	*tgt_p = (char *) ccalloc ((cygheap_types) type, tlen, sizeof (char));
d77 1
a77 1
        return 0;
d100 1
a100 1
        *tgt_p = (PWCHAR) calloc (ret, sizeof (WCHAR));
d102 1
a102 1
      	*tgt_p = (PWCHAR) ccalloc ((cygheap_types) type, ret, sizeof (WCHAR));
d104 1
a104 1
        return 0;
@


1.7
log
@	* fhandler.h (fhandler_console::trunc_buf): Add to use as cache for
	truncated multibyte characters on input.
	(fhandler_console::write_replacement_char): Declare new method.
	* fhandler_console.cc (CONVERT_LIMIT): Raise to 64K.
	(fhandler_console::fhandler_console): Initialize trunc_buf.
	(ERR): Define as independent value again.
	(fhandler_console::write_replacement_char): New method to print
	replacement chars.
	(fhandler_console::write_normal): Add handling for truncated multibyte
	sequences.  Call next_char instead of pathetic CharNextExA function.
	Don't change src, rather just work with found later on.
	* miscfuncs.cc (is_cp_multibyte): Move here from strfuncs.cc.
	Don't call Windows function, restrict to well-known ANSI/OEM codepages
	and UTF-8.
	(next_char): Call CharNextExA only for doublebyte codepages.
	Implement for UTF-8 here.
	* strfuncs.cc (is_cp_multibyte): Move to miscfuncs.cc.
	* winsup.h (next_char): Declare.
	* include/limits.h (MB_LEN_MAX): Set to maximum value of MB_CUR_MAX
	as defined by newlib for now.
@
text
@a26 4
#ifdef __OUTSIDE_CYGWIN__
#define codepage_init(cp)	(active_codepage = GetACP ())
#endif

a71 1
#ifndef __OUTSIDE_CYGWIN__
a72 1
#endif
a73 1
#ifndef __OUTSIDE_CYGWIN__
a75 1
#endif
a98 1
#ifndef __OUTSIDE_CYGWIN__
a99 1
#endif
a100 1
#ifndef __OUTSIDE_CYGWIN__
a102 1
#endif
@


1.6
log
@	* autoload.cc (CharToOemA): Remove.
	(CharNextExA): Define.
	* environ.cc (codepage_init): Un-static.  Set active_codepage to
	active codepage.  Default to ansi regardless of buf pointer.
	* fhandler.h (dev_console::get_console_cp): New method.
	(dev_console::con_to_str): Change declaration according to new
	implementation.
	(dev_console::str_to_con): Ditto.
	* fhandler_console.cc (cp_convert): Remove.
	(dev_console::con_to_str): Redefine to take WCHAR as incoming console
	char.
	(dev_console::get_console_cp): Return correct codepage according to
	alternate_charset_active setting.
	(dev_console::str_to_con): Redefine to create WCHAR buffer for console
	output.
	(fhandler_console::read): Read console input as WCHARs.
	(base_chars): Fix typo in comment.
	(fhandler_console::char_command): Save and restore console output
	buffer using UNICODE functions.
	(fhandler_console::write_normal): Convert to write output in UNICODE.
	Use CharNextExA to recognize multibyte characters in input.  Workaround
	problem with UTF-8 and MultiByteToWideChar.  Simplify the loop for
	printing "normal" characters.
	* strfuncs.cc (active_codepage): New variable to store active codepage.
	(get_cp): Call codepage_init() if active_codepage is uninitialized.
	Just return active_codepage.
	(is_cp_multibyte): New function.
	* winsup.h (active_codepage): Declare.
	(codepage_init): Declare.
	(is_cp_multibyte): Declare.
@
text
@a38 8
bool
is_cp_multibyte (UINT cp)
{
  CPINFO cpi; 
  GetCPInfo (cp, &cpi);
  return cpi.MaxCharSize > 1;
}

@


1.5
log
@	* smallprint.cc (__small_vsprintf): Use HEAP_NOTHEAP for type.
	* strfuncs.cc (sys_wcstombs_alloc): Guard use of ccalloc
	to !__OUTSIDE_CYGWIN__ for use in cygserver.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d25 5
d34 11
a44 10
  switch (current_codepage)
    {
      case oem_cp:
	return GetOEMCP ();
      case utf8_cp:
	return CP_UTF8;
      case ansi_cp:
      default:
	return GetACP ();
    }
@


1.4
log
@	* dcrt0.cc (dll_crt0_1): Use GetCommandLineW and convert to current
	codepage.
	* environ.cc (set_file_api_mode): Always set file api to ANSI if not
	using the OEM codepage.
	(codepage_init): Allow "utf8" codepage.
	* fhandler_clipboard.cc (set_clipboard): Convert clipbuf to void and
	cast as needed.  Always convert input to wide char and write
	CF_UNICODETEXT to clipboard.
	(fhandler_dev_clipboard::read): Read CF_UNICODETEXT from clipboard and
	convert to current codepage if CYGWIN_NATIVE format is not available.
	* fhandler_console.cc: Drop redundant undef.
	* smallprint.cc (__small_vsprintf): Convert PWCHAR and UNICODE_STRING
	to current codepage for printing.
	* strfuncs.cc: Use PWCHAR throughout.
	(get_cp): Return CP_UTF8 for utf8_cp codepage setting.
	(sys_wcstombs): Allow NULL target buffer.
	(sys_wcstombs_alloc): New function.
	(sys_mbstowcs_alloc): Ditto.
	* winsup.h (codepage_type): Add utf8_cp.
	(HEAP_NOTHEAP): Define.
	(sys_wcstombs_alloc): Declare.
	(sys_mbstowcs_alloc): Declare.
@
text
@d63 5
a67 1
   In the latter case the allocation uses simple calloc. */
d78 1
d80 1
d82 1
d85 1
d109 1
d111 1
d113 1
d116 1
@


1.3
log
@	* cygheap.h (struct cwdstuff): Drop hash member.  Drop get_hash,
	get_initial, and fixup_after_exec declarations.
	Convert win32 to UNICODE_STRING.
	(cwdstuff::get_drive): Convert win32 path in current codepage.
	(cwdstuff::set): Take native NT path.
	* ntdll.h (struct _TEB): Typedef.
	* path.cc (mount_info::conv_to_posix_path): Add variant taking
	wide char DOS paths.
	(symlink_info::posixify): Simplify concatenating cwd and relative path.
	(hash_path_name): Drop special relative path handling.
	(chdir): Drop special "drive only" handling.  Call cwdstuff::set with
	native path.
	(cwdstuff::get_hash): Remove.
	(windows_system_directory): Remove.
	(_upp): Remove.
	(get_user_proc_parms): Make inline.  Get PEB pointer by calling
	NtCurrentTeb.
	(cwdstuff::init): Simplify.
	(cwdstuff::set): Rework to handle incoming native NT path.  Workaround
	a Vista problem with CWD handle in the user process parameter block.
	(cwdstuff::get): Simplify locking.  Accommodate type change of win32.
	* shared_info.h (mount_info): Add declaration for new conv_to_posix_path
	method.
	* strfuncs.cc (sys_wcstombs): Return correct length of created
	multi-byte string.
@
text
@d13 1
d17 6
d29 10
a38 1
  return current_codepage == ansi_cp ? GetACP() : GetOEMCP();
d45 1
a45 1
sys_wcstombs (char *tgt, int tlen, const WCHAR *src, int slen)
d50 1
a50 1
  if (ret)
d58 27
d86 1
a86 1
sys_mbstowcs (WCHAR *tgt, const char *src, int len)
d92 20
@


1.2
log
@	* ntdll.h: Add descriptive comments to special Rtl functions.
	(STATUS_OBJECT_PATH_NOT_FOUND): Define.
	(STATUS_BUFFER_OVERFLOW): Define.
	(FILE_SUPERSEDED): Define.
	(FILE_OPENED): Define.
	(FILE_CREATED): Define.
	(FILE_OVERWRITTEN): Define.
	(FILE_EXISTS): Define.
	(FILE_DOES_NOT_EXIST): Define.
	(PIO_APC_ROUTINE): Typedef.
	(NtFsControlFile): Fix parameter types to use PIO_APC_ROUTINE.
	(NtWriteFile): Declare.
	(RtlInt64ToHexUnicodeString): Declare.
	* strfuncs.cc: Include ntdll.h.
	(RtlInt64ToHexUnicodeString): New function.
	* syscalls.cc (try_to_bin): Rewrite using native NT functions.
	Only try to create recycle bin after unsuccessfully trying to move
	file.  Also try to create special files in recycle bin so that Windows
	Explorer isn't unnecessarily stampeded.
@
text
@d35 4
a38 1
    tgt[ret < tlen ? ret : tlen - 1] = '\0';
@


1.1
log
@* dcrt0.cc (codepage_type): Remove definition.
* strfuncs.cc: Move it here.  New file with bits of miscfuncs.cc.
* miscfuncs.cc: Remove wide character stuff.
@
text
@d15 1
d45 20
@

