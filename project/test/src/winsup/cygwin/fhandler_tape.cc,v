head	1.97;
access;
symbols
	cygwin-1_7_35-release:1.97
	cygwin-1_7_34-release:1.96
	cygwin-1_7_33-release:1.95.2.1
	cygwin-1_7_32-release:1.95
	cygwin-1_7_31-release:1.95
	cygwin-1_7_30-release:1.95
	cygwin-1_7_29-release:1.95
	cygwin-1_7_29-release-branchpoint:1.95.0.2
	cygwin-pre-user-db:1.95
	cygwin-1_7_28-release:1.95
	cygwin-1_7_27-release:1.95
	cygwin-1_7_26-release:1.95
	cygwin-1_7_25-release:1.94
	cygwin-1_7_24-release:1.89
	cygwin-1_7_23-release:1.89
	cygwin-1_7_22-release:1.89
	cygwin-1_7_21-release:1.89
	cygwin-1_7_20-release:1.89
	cygwin-1_7_19-release:1.89
	cygwin-64bit-postmerge:1.88
	cygwin-64bit-premerge-branch:1.87.0.2
	cygwin-64bit-premerge:1.87
	cygwin-1_7_18-release:1.87
	post-ptmalloc3:1.83.2.7
	pre-ptmalloc3:1.83.2.7
	cygwin-1_7_17-release:1.85
	cygwin-64bit-branch:1.83.0.2
	cygwin-1_7_16-release:1.82
	cygwin-1_7_15-release:1.79
	cygwin-1_7_14_2-release:1.79
	cygwin-1_7_14-release:1.79
	cygwin-1_7_12-release:1.79
	cygwin-1_7_11-release:1.78
	cygwin-1_7_10-release:1.78
	signal-rewrite:1.76.0.2
	pre-notty:1.76
	cygwin-1_7_9-release:1.73
	cv-post-1_7_9:1.73.0.2
	cygwin-1_7_8-release:1.73
	cygwin-1_7_7-release:1.73
	cygwin-1_7_5-release:1.73
	cygwin-1_7_4-release:1.73
	cygwin-1_7_3-release:1.73
	cygwin-1_7_2-release:1.73
	fifo_doover3:1.72.0.2
	cygwin-1_7_1-release:1.71
	prefifo:1.70
	cv-branch-2:1.70.0.2
	pre-ripout-set_console_state_for_spawn:1.68
	EOL_registry_mounts:1.66
	preoverlapped:1.65
	drop_9x_support_start:1.65
	cr-0x5f1:1.64.0.8
	cv-branch:1.64.0.6
	pre-ptymaster-archetype:1.64
	cr-0x3b58:1.64.0.4
	cr-0x5ef:1.64.0.2
	after-mmap-privanon-noreserve:1.62
	after-mmap-revamp:1.62
	before-mmap-revamp:1.62
	cgf-more-exit-sync:1.62
	post_wait_sig_exit:1.60
	pre_wait_sig_exit:1.60
	reparent-point:1.53
	noreparent:1.53.0.2
	cr-0x5e6:1.49.0.2
	cr-0x9e:1.36.0.6
	cr-0x9d:1.36.0.4
	cgf-deleteme:1.36.0.2
	pre-sigrewrite:1.35
	corinna-01:1.35
	cr-0x9c:1.34.0.6
	cr-0x9b:1.34.0.4
	cr-0x99:1.34
	Z-emcb-cygwin_daemon:1.34.0.2
	w32api-2_2:1.32
	mingw-runtime-2_4:1.32
	pre-cgf-merge:1.34
	cgf-dev-branch:1.32.0.18
	predaemon:1.28
	cygwin_daemon_merge_HEAD:1.28
	pregp02r1:1.27.0.2
	cygnus_cvs_20020108_pre:1.25
	Z-cygwin_daemon_merge-new_HEAD:1.31
	Z-cygwin_daemon_merge_HEAD:1.31
	cygwin_daemon:1.16.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.97
date	2015.02.25.17.50.13;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2014.08.22.09.21.30;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2013.10.24.17.51.41;	author corinna;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2013.08.30.17.39.11;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2013.08.26.16.14.40;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2013.08.21.20.28.12;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2013.08.20.20.17.14;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2013.08.19.10.24.37;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2012.11.26.13.28.52;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2012.10.13.12.34.18;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2012.08.15.19.07.41;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2012.06.28.19.25.22;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2011.11.14.01.29.48;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2011.05.04.12.23.00;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2008.07.15.11.42.45;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2008.04.18.20.13.37;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.28.16.45.34;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.26.15.59.39;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.14.15.54.33;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2005.09.28.19.22.22;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.28.19.02.50;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2005.07.05.07.28.52;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.22.19.59.19;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.28.23.59.44;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.27.01.57.37;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.16.21.52.06;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2004.09.09.11.35.15;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.03.01.53.12;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.20.13.40.35;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.12.12.28.59;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.20.11.01.22;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2004.04.19.19.29.10;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.19.13.07.55;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.09.20.39.19;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.31.19.34.27;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.31.12.04.07;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.26.21.43.48;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.15.11.37.36;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.14.18.01.45;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.13.18.15.06;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.02.13.07.47;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches
	1.32.16.1
	1.32.18.1;
next	1.31;

1.31
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.02.03.13.22;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.16.23.28.56;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.16.20.17.23;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.16.16.28.39;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.16.14.53.26;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.05.04.21.41;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.22.20.13.00;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.15.09.17.10;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.31.22.20.59;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.31.19.59.16;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.23.19.33.44;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.16.21.42.55;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.95.2.1
date	2014.11.13.12.53.01;	author corinna;	state Exp;
branches;
next	;

1.83.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.83.2.2;

1.83.2.2
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.83.2.3;

1.83.2.3
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.83.2.4;

1.83.2.4
date	2012.11.08.17.25.48;	author corinna;	state Exp;
branches;
next	1.83.2.5;

1.83.2.5
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.83.2.6;

1.83.2.6
date	2012.12.10.11.45.48;	author corinna;	state Exp;
branches;
next	1.83.2.7;

1.83.2.7
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.83.2.8;

1.83.2.8
date	2013.03.01.16.32.33;	author corinna;	state Exp;
branches;
next	;

1.32.16.1
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.32.16.2;

1.32.16.2
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	;

1.32.18.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.32.18.2;

1.32.18.2
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.32.18.3;

1.32.18.3
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.32.18.4;

1.32.18.4
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.16.4.1
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.97
log
@	* fhandler_tape.cc (fhandler_dev_tape::_lock): Add cw_sig_restart to
	cygwait call.
	* thread.cc (pthread_mutex::lock): Ditto.
	(semaphore::_timedwait): Fix formatting.
	(semaphore::_wait): Ditto.
	* thread.h (fast_mutex::lock): Ditto.

	...and fix ChangeLog accordingly.
@
text
@/* fhandler_tape.cc.  See fhandler.h for a description of the fhandler
   classes.

   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "cygtls.h"
#include <stdlib.h>
#include <sys/mtio.h>
#include <sys/param.h>
#include <devioctl.h>
#include <ntddstor.h>
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "shared_info.h"
#include "sigproc.h"
#include "child_info.h"

/* Media changes and bus resets are sometimes reported and the function
   hasn't been executed.  We repeat all functions which return with one
   of these error codes. */
#define TAPE_FUNC(func) while ((lasterr = (func)) == ERROR_MEDIA_CHANGED) \
			  { \
			    initialize (drive, false); \
			    part (partition)->initialize (0); \
			  }

#define IS_BOT(err) ((err) == ERROR_BEGINNING_OF_MEDIA)

#define IS_EOF(err) ((err) == ERROR_FILEMARK_DETECTED \
		     || (err) == ERROR_SETMARK_DETECTED)

#define IS_SM(err)  ((err) == ERROR_SETMARK_DETECTED)

#define IS_EOD(err) ((err) == ERROR_END_OF_MEDIA \
		     || (err) == ERROR_EOM_OVERFLOW \
		     || (err) == ERROR_NO_DATA_DETECTED)

#define IS_EOM(err) ((err) == ERROR_END_OF_MEDIA \
		     || (err) == ERROR_EOM_OVERFLOW)

/**********************************************************************/
/* mtinfo_part */

void
mtinfo_part::initialize (int64_t nblock)
{
  block = nblock;
  if (block == 0)
    file = fblock = 0;
  else
    file = fblock = -1;
  smark = false;
  emark = no_eof;
}

/**********************************************************************/
/* mtinfo_drive */

void
mtinfo_drive::initialize (int num, bool first_time)
{
  drive = num;
  partition = 0;
  block = -1;
  lock = unlocked;
  if (first_time)
    {
      buffer_writes (true);
      async_writes (false);
      two_fm (false);
      fast_eom (false);
      auto_lock (false);
      sysv (false);
      nowait (false);
    }
  for (int i = 0; i < MAX_PARTITION_NUM; ++i)
    part (i)->initialize ();
}

int
mtinfo_drive::get_dp (HANDLE mt)
{
  DWORD len = sizeof _dp;
  TAPE_FUNC (GetTapeParameters (mt, GET_TAPE_DRIVE_INFORMATION, &len, &_dp));
  return error ("get_dp");
}

int
mtinfo_drive::get_mp (HANDLE mt)
{
  DWORD len = sizeof _mp;
  TAPE_FUNC (GetTapeParameters (mt, GET_TAPE_MEDIA_INFORMATION, &len, &_mp));
  return error ("get_mp");
}

int
mtinfo_drive::open (HANDLE mt)
{
  /* First access after opening the device can return BUS RESET, but we
     need the drive parameters, so just try again. */
  while (get_dp (mt) == ERROR_BUS_RESET)
    ;
  get_mp (mt);
  get_pos (mt);
  if (partition < MAX_PARTITION_NUM && part (partition)->block != block)
    part (partition)->initialize (block);
  /* The following rewind in position 0 solves a problem which appears
   * in case of multi volume archives (at least on NT4): The last ReadFile
   * on the previous medium returns ERROR_NO_DATA_DETECTED.  After media
   * change, all subsequent ReadFile calls return ERROR_NO_DATA_DETECTED,
   * too.  The call to set_pos apparently reset some internal flags.
   * FIXME:  Is that really true or based on a misinterpretation? */
  if (!block)
    {
      debug_printf ("rewind in position 0");
      set_pos (mt, TAPE_REWIND, 0, false);
    }
  return error ("open");
}

int
mtinfo_drive::close (HANDLE mt, bool rewind)
{
  lasterr = 0;
  if (GetTapeStatus (mt) == ERROR_NO_MEDIA_IN_DRIVE)
    dirty = clean;
  if (dirty >= has_written)
    {
      /* If an async write is still pending, wait for completion. */
      if (dirty == async_write_pending)
	lasterr = async_wait (mt, NULL);
      if (!lasterr)
	{
	  /* if last operation was writing, write a filemark */
	  debug_printf ("writing filemark");
	  write_marks (mt, TAPE_FILEMARKS, two_fm () ? 2 : 1);
	  if (two_fm () && !lasterr && !rewind) /* Backspace over 2nd fmark. */
	    {
	      set_pos (mt, TAPE_SPACE_FILEMARKS, -1, false);
	      if (!lasterr)
		part (partition)->fblock = 0; /* That's obvious, isn't it? */
	    }
	}
    }
  else if (dirty == has_read && !rewind)
    {
      if (sysv ())
	{
	  /* Under SYSV semantics, the tape is moved past the next file mark
	     after read. */
	  if (part (partition)->emark == no_eof)
	    set_pos (mt, TAPE_SPACE_FILEMARKS, 1, false);
	  else if (part (partition)->emark == eof_hit)
	    part (partition)->emark = eof;
	}
      else
	{
	  /* Under BSD semantics, we must check if the filemark has been
	     inadvertendly crossed.  If so cross the filemark backwards
	     and position the tape right before EOF. */
	  if (part (partition)->emark == eof_hit)
	    set_pos (mt, TAPE_SPACE_FILEMARKS, -1, false);
	}
    }
  if (rewind)
    {
      debug_printf ("rewinding");
      set_pos (mt, TAPE_REWIND, 0, false);
    }
  if (auto_lock () && lock == auto_locked)
    prepare (mt, TAPE_UNLOCK);
  dirty = clean;
  return error ("close");
}

int
mtinfo_drive::read (HANDLE mt, LPOVERLAPPED pov, void *ptr, size_t &ulen)
{
  BOOL ret;
  DWORD bytes_read = 0;

  if (GetTapeStatus (mt) == ERROR_NO_MEDIA_IN_DRIVE)
    return lasterr = ERROR_NO_MEDIA_IN_DRIVE;
  if (lasterr == ERROR_BUS_RESET)
    {
      ulen = 0;
      goto out;
    }
  /* If an async write is still pending, wait for completion. */
  if (dirty == async_write_pending)
    lasterr = async_wait (mt, NULL);
  dirty = clean;
  if (part (partition)->emark == eof_hit)
    {
      part (partition)->emark = eof;
      lasterr = ulen = 0;
      goto out;
    }
  else if (part (partition)->emark == eod_hit)
    {
      part (partition)->emark = eod;
      lasterr = ulen = 0;
      goto out;
    }
  else if (part (partition)->emark == eod)
    {
      lasterr = ERROR_NO_DATA_DETECTED;
      ulen = (size_t) -1;
      goto out;
    }
  else if (part (partition)->emark == eom_hit)
    {
      part (partition)->emark = eom;
      lasterr = ulen = 0;
      goto out;
    }
  else if (part (partition)->emark == eom)
    {
      lasterr = ERROR_END_OF_MEDIA;
      ulen = (size_t) -1;
      goto out;
    }
  part (partition)->smark = false;
  if (auto_lock () && lock < auto_locked)
    prepare (mt, TAPE_LOCK, true);
  ov = pov;
  ov->Offset = ov->OffsetHigh = 0;
  ret = ReadFile (mt, ptr, ulen, &bytes_read, ov);
  lasterr = ret ? 0 : GetLastError ();
  if (lasterr == ERROR_IO_PENDING)
    lasterr = async_wait (mt, &bytes_read);
  ulen = (size_t) bytes_read;
  if (bytes_read > 0)
    {
      int32_t blocks_read = mp ()->BlockSize == 0
			    ? 1 : howmany (bytes_read, mp ()->BlockSize);
      block += blocks_read;
      part (partition)->block += blocks_read;
      if (part (partition)->fblock >= 0)
	part (partition)->fblock += blocks_read;
    }
  if (IS_EOF (lasterr))
    {
      block++;
      part (partition)->block++;
      if (part (partition)->file >= 0)
	part (partition)->file++;
      part (partition)->fblock = 0;
      part (partition)->smark = IS_SM (lasterr);
      part (partition)->emark = bytes_read > 0 ? eof_hit : eof;
      lasterr = 0;
    }
  else if (IS_EOD (lasterr))
    {
      if (part (partition)->emark == eof)
	part (partition)->emark = IS_EOM (lasterr) ? eom : eod;
      else
	{
	  part (partition)->emark = IS_EOM (lasterr) ? eom_hit : eod_hit;
	  lasterr = 0;
	}
    }
  else
    {
      part (partition)->emark = no_eof;
      /* This happens if the buffer is too small when in variable block
	 size mode.  Linux returns ENOMEM here.  We're doing the same. */
      if (lasterr == ERROR_MORE_DATA)
	lasterr = ERROR_NOT_ENOUGH_MEMORY;
    }
  if (!lasterr)
    dirty = has_read;
out:
  return error ("read");
}

int
mtinfo_drive::async_wait (HANDLE mt, DWORD *bytes_written)
{
  DWORD written;

  bool ret = GetOverlappedResult (mt, ov, &written, TRUE);
  if (bytes_written)
    *bytes_written = written;
  return ret ? 0 : GetLastError ();
}

int
mtinfo_drive::write (HANDLE mt, LPOVERLAPPED pov, const void *ptr, size_t &len)
{
  BOOL ret;
  DWORD bytes_written = 0;
  int async_err = 0;

  if (GetTapeStatus (mt) == ERROR_NO_MEDIA_IN_DRIVE)
    return lasterr = ERROR_NO_MEDIA_IN_DRIVE;
  if (lasterr == ERROR_BUS_RESET)
    {
      len = 0;
      return error ("write");
    }
  if (dirty == async_write_pending)
    async_err = async_wait (mt, &bytes_written);
  dirty = clean;
  part (partition)->smark = false;
  if (auto_lock () && lock < auto_locked)
    prepare (mt, TAPE_LOCK, true);
  ov = pov;
  ov->Offset = ov->OffsetHigh = 0;
  ret = WriteFile (mt, ptr, len, &bytes_written, ov);
  lasterr = ret ? 0: GetLastError ();
  if (lasterr == ERROR_IO_PENDING)
    {
      if (async_writes () && mp ()->BlockSize == 0)
	dirty = async_write_pending;
      else
	/* Wait for completion if a non-async write. */
	lasterr = async_wait (mt, &bytes_written);
    }
  len = (size_t) bytes_written;
  if (bytes_written > 0)
    {
      int32_t blocks_written = mp ()->BlockSize == 0
			       ? 1 : howmany (bytes_written, mp ()->BlockSize);
      block += blocks_written;
      part (partition)->block += blocks_written;
      if (part (partition)->fblock >= 0)
	part (partition)->fblock += blocks_written;
    }
  if (!lasterr && async_err)
    lasterr = async_err;
  if (lasterr == ERROR_EOM_OVERFLOW)
    part (partition)->emark = eom;
  else if (lasterr == ERROR_END_OF_MEDIA)
    ; // FIXME?: part (partition)->emark = eom_hit;
  else
    {
      part (partition)->emark = no_eof;
      if (!lasterr)
	dirty = has_written;
      else if (lasterr == ERROR_IO_PENDING)
	dirty = async_write_pending;
    }
  return error ("write");
}

int
mtinfo_drive::get_pos (HANDLE mt, int32_t *ppartition, int64_t *pblock)
{
  DWORD p;
  ULARGE_INTEGER b;

  TAPE_FUNC (GetTapePosition (mt, TAPE_LOGICAL_POSITION, &p,
			      &b.LowPart, &b.HighPart));
  if (lasterr == ERROR_INVALID_FUNCTION)
    TAPE_FUNC (GetTapePosition (mt, TAPE_ABSOLUTE_POSITION, &p,
				&b.LowPart, &b.HighPart));
  if (!lasterr)
    {
      if (p > 0)
	partition = (int32_t) p - 1;
      block = (int64_t) b.QuadPart;
      if (ppartition)
	*ppartition= partition;
      if (pblock)
	*pblock = block;
    }
  else
    {
      partition = 0;
      block = -1;
    }
  return error ("get_pos");
}

int
mtinfo_drive::_set_pos (HANDLE mt, int mode, int64_t count, int partition,
			BOOL dont_wait)
{
  /* If an async write is still pending, wait for completion. */
  if (dirty == async_write_pending)
    lasterr = async_wait (mt, NULL);
  dirty = clean;
  LARGE_INTEGER c = { QuadPart:count };
  TAPE_FUNC (SetTapePosition (mt, mode, partition, c.LowPart, c.HighPart,
			      dont_wait));
  return lasterr;
}

int
mtinfo_drive::set_pos (HANDLE mt, int mode, int64_t count, bool sfm_func)
{
  int err = 0;
  int64_t undone = count;
  BOOL dont_wait = FALSE;

  switch (mode)
    {
      case TAPE_SPACE_RELATIVE_BLOCKS:
      case TAPE_SPACE_FILEMARKS:
      case TAPE_SPACE_SETMARKS:
	if (!count)
	  {
	    lasterr = 0;
	    goto out;
	  }
	break;
      case TAPE_ABSOLUTE_BLOCK:
      case TAPE_LOGICAL_BLOCK:
      case TAPE_REWIND:
	dont_wait = nowait () ? TRUE : FALSE;
	break;
    }
  if (mode == TAPE_SPACE_FILEMARKS)
    {
      while (!err && undone > 0)
	if (!(err = _set_pos (mt, mode, 1, 0, FALSE)) || IS_SM (err))
	  --undone;
      while (!err && undone < 0)
	if (!(err = _set_pos (mt, mode, -1, 0, FALSE)) || IS_SM (err))
	  ++undone;
    }
  else
    err = _set_pos (mt, mode, count, 0, dont_wait);
  switch (mode)
    {
      case TAPE_ABSOLUTE_BLOCK:
      case TAPE_LOGICAL_BLOCK:
	get_pos (mt);
	part (partition)->initialize (block);
	break;
      case TAPE_REWIND:
	if (!err)
	  {
	    block = 0;
	    part (partition)->initialize (0);
	  }
	else
	  {
	    get_pos (mt);
	    part (partition)->initialize (block);
	  }
	break;
      case TAPE_SPACE_END_OF_DATA:
	get_pos (mt);
	part (partition)->initialize (block);
	part (partition)->emark = IS_EOM (err) ? eom : eod;
	break;
      case TAPE_SPACE_FILEMARKS:
	if (!err || IS_SM (err))
	  {
	    get_pos (mt);
	    part (partition)->block = block;
	    if (count > 0)
	      {
		if (part (partition)->file >= 0)
		  part (partition)->file += count - undone;
		part (partition)->fblock = 0;
		part (partition)->smark = IS_SM (err);
	      }
	    else
	      {
		if (part (partition)->file >= 0)
		  part (partition)->file += count - undone;
		part (partition)->fblock = -1;
		part (partition)->smark = false;
	      }
	    if (sfm_func)
	      err = set_pos (mt, mode, count > 0 ? -1 : 1, false);
	    else
	      part (partition)->emark = count > 0 ? eof : no_eof;
	  }
	else if (IS_EOD (err))
	  {
	    get_pos (mt);
	    part (partition)->block = block;
	    if (part (partition)->file >= 0)
	      part (partition)->file += count - undone;
	    part (partition)->fblock = -1;
	    part (partition)->smark = false;
	    part (partition)->emark = IS_EOM (err) ? eom : eod;
	  }
	else if (IS_BOT (err))
	  {
	    block = 0;
	    part (partition)->initialize (0);
	  }
	else
	  {
	    get_pos (mt);
	    part (partition)->initialize (block);
	  }
	break;
      case TAPE_SPACE_RELATIVE_BLOCKS:
	if (!err)
	  {
	    block += count;
	    part (partition)->block += count;
	    if (part (partition)->fblock >= 0)
	      part (partition)->fblock += count;
	    part (partition)->smark = false;
	    part (partition)->emark = no_eof;
	  }
	else if (IS_EOF (err))
	  {
	    get_pos (mt);
	    part (partition)->block = block;
	    if (part (partition)->file >= 0)
	      part (partition)->file += count > 0 ? 1 : -1;
	    part (partition)->fblock = count > 0 ? 0 : -1;
	    part (partition)->smark = (count > 0 && IS_SM (err));
	    part (partition)->emark = count > 0 ? eof : no_eof;
	  }
	else if (IS_EOD (err))
	  {
	    get_pos (mt);
	    part (partition)->fblock = block - part (partition)->block;
	    part (partition)->block = block;
	    part (partition)->smark = false;
	    part (partition)->emark = IS_EOM (err) ? eom : eod;
	  }
	else if (IS_BOT (err))
	  {
	    block = 0;
	    part (partition)->initialize (0);
	  }
	break;
      case TAPE_SPACE_SETMARKS:
	get_pos (mt);
	part (partition)->block = block;
	if (!err)
	  {
	    part (partition)->file = -1;
	    part (partition)->fblock = -1;
	    part (partition)->smark = true;
	  }
	break;
    }
  lasterr = err;
out:
  return error ("set_pos");
}

int
mtinfo_drive::create_partitions (HANDLE mt, int32_t count)
{
  if (dp ()->MaximumPartitionCount <= 1)
    return ERROR_INVALID_PARAMETER;
  if (set_pos (mt, TAPE_REWIND, 0, false))
    goto out;
  partition = 0;
  part (partition)->initialize (0);
  debug_printf ("Format tape with %s partition(s)", count <= 0 ? "one" : "two");
  if (get_feature (TAPE_DRIVE_INITIATOR))
    {
      TAPE_FUNC (CreateTapePartition (mt, TAPE_INITIATOR_PARTITIONS,
				      count <= 0 ? 0 : 2, (DWORD) count));
    }
  else if (get_feature (TAPE_DRIVE_SELECT))
    {
      TAPE_FUNC (CreateTapePartition (mt, TAPE_SELECT_PARTITIONS,
				      count <= 0 ? 0 : 2, 0));
    }
  else if (get_feature (TAPE_DRIVE_FIXED))
    {
      /* This is supposed to work for Tandberg SLR drivers up to version
	 1.6 which missed to set the TAPE_DRIVE_INITIATOR flag.  According
	 to Tandberg, CreateTapePartition(TAPE_FIXED_PARTITIONS) apparently
	 does not ignore the dwCount parameter.  Go figure! */
      TAPE_FUNC (CreateTapePartition (mt, TAPE_FIXED_PARTITIONS,
				      count <= 0 ? 0 : 2, (DWORD) count));
    }
  else
    lasterr = ERROR_INVALID_PARAMETER;
out:
  return error ("partition");
}

int
mtinfo_drive::set_partition (HANDLE mt, int32_t count)
{
  if (count < 0 || (uint32_t) count >= MAX_PARTITION_NUM)
    lasterr = ERROR_INVALID_PARAMETER;
  else if ((DWORD) count >= dp ()->MaximumPartitionCount)
    lasterr = ERROR_IO_DEVICE;
  else
    {
      uint64_t part_block = part (count)->block >= 0 ? part (count)->block : 0;
      int err = _set_pos (mt, TAPE_LOGICAL_BLOCK, part_block, count + 1, FALSE);
      if (err)
	{
	  int64_t sav_block = block;
	  int32_t sav_partition = partition;
	  get_pos (mt);
	  if (sav_partition != partition)
	    {
	      if (partition < MAX_PARTITION_NUM
		  && part (partition)->block != block)
		part (partition)->initialize (block);
	    }
	  else if (sav_block != block && partition < MAX_PARTITION_NUM)
	    part (partition)->initialize (block);
	  lasterr = err;
	}
      else
	{
	  partition = count;
	  if (part (partition)->block == -1)
	    part (partition)->initialize (0);
	}
    }
  return error ("set_partition");
}

int
mtinfo_drive::write_marks (HANDLE mt, int marktype, DWORD count)
{
  /* If an async write is still pending, wait for completion. */
  if (dirty == async_write_pending)
    {
      lasterr = async_wait (mt, NULL);
      dirty = has_written;
    }
  if (marktype != TAPE_SETMARKS)
    dirty = clean;
  if (marktype == TAPE_FILEMARKS
      && !get_feature (TAPE_DRIVE_WRITE_FILEMARKS))
    {
      if (get_feature (TAPE_DRIVE_WRITE_LONG_FMKS))
	marktype = TAPE_LONG_FILEMARKS;
      else
	marktype = TAPE_SHORT_FILEMARKS;
    }
  TAPE_FUNC (WriteTapemark (mt, marktype, count, FALSE));
  int err = lasterr;
  if (!err)
    {
      block += count;
      part (partition)->block += count;
      if (part (partition)->file >= 0)
	part (partition)->file += count;
      part (partition)->fblock = 0;
      part (partition)->emark = eof;
      part (partition)->smark = (marktype == TAPE_SETMARKS);
    }
  else
    {
      int64_t sav_block = block;
      int32_t sav_partition = partition;
      get_pos (mt);
      if (sav_partition != partition)
	{
	  if (partition < MAX_PARTITION_NUM
	      && part (partition)->block != block)
	    part (partition)->initialize (block);
	}
      else if (sav_block != block && partition < MAX_PARTITION_NUM)
	part (partition)->initialize (block);
      lasterr = err;
    }
  return error ("write_marks");
}

int
mtinfo_drive::erase (HANDLE mt, int mode)
{
  switch (mode)
    {
      case TAPE_ERASE_SHORT:
	if (!get_feature (TAPE_DRIVE_ERASE_SHORT))
	  mode = TAPE_ERASE_LONG;
	break;
      case TAPE_ERASE_LONG:
	if (!get_feature (TAPE_DRIVE_ERASE_LONG))
	  mode = TAPE_ERASE_SHORT;
	break;
    }
  TAPE_FUNC (EraseTape (mt, mode, nowait () ? TRUE : FALSE));
  part (partition)->initialize (0);
  return error ("erase");
}

int
mtinfo_drive::prepare (HANDLE mt, int action, bool is_auto)
{
  BOOL dont_wait = FALSE;

  /* If an async write is still pending, wait for completion. */
  if (dirty == async_write_pending)
    lasterr = async_wait (mt, NULL);
  dirty = clean;
  if (action == TAPE_UNLOAD || action == TAPE_LOAD || action == TAPE_TENSION)
    dont_wait = nowait () ? TRUE : FALSE;
  TAPE_FUNC (PrepareTape (mt, action, dont_wait));
  /* Reset buffer after all successful preparations but lock and unlock. */
  switch (action)
    {
      case TAPE_FORMAT:
      case TAPE_UNLOAD:
      case TAPE_LOAD:
	initialize (drive, false);
	break;
      case TAPE_TENSION:
	part (partition)->initialize (0);
	break;
      case TAPE_LOCK:
	lock = lasterr ? lock_error : is_auto ? auto_locked : locked;
	break;
      case TAPE_UNLOCK:
	lock = lasterr ? lock_error : unlocked;
	break;
    }
  return error ("prepare");
}

int
mtinfo_drive::set_compression (HANDLE mt, int32_t count)
{
  if (!get_feature (TAPE_DRIVE_SET_COMPRESSION))
    return ERROR_INVALID_PARAMETER;
  TAPE_SET_DRIVE_PARAMETERS sdp =
    {
      dp ()->ECC,
      (BOOLEAN) (count ? TRUE : FALSE),
      dp ()->DataPadding,
      dp ()->ReportSetmarks,
      dp ()->EOTWarningZoneSize
    };
  TAPE_FUNC (SetTapeParameters (mt, SET_TAPE_DRIVE_INFORMATION, &sdp));
  int err = lasterr;
  if (!err)
    dp ()->Compression = sdp.Compression;
  else
    get_dp (mt);
  lasterr = err;
  return error ("set_compression");
}

int
mtinfo_drive::set_blocksize (HANDLE mt, DWORD count)
{
  TAPE_SET_MEDIA_PARAMETERS smp = {count};
  TAPE_FUNC (SetTapeParameters (mt, SET_TAPE_MEDIA_INFORMATION, &smp));
  /* Make sure to update blocksize info! */
  return lasterr ? error ("set_blocksize") : get_mp (mt);
}

int
mtinfo_drive::get_status (HANDLE mt, struct mtget *get)
{
  int notape = 0;
  DWORD tstat;

  if (!get)
    return ERROR_INVALID_PARAMETER;

  if ((tstat = GetTapeStatus (mt)) == ERROR_NO_MEDIA_IN_DRIVE
      || get_mp (mt) == ERROR_NO_MEDIA_IN_DRIVE)
    notape = 1;

  memset (get, 0, sizeof *get);

  get->mt_type = MT_ISUNKNOWN;

  if (!notape && get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
    get->mt_dsreg = (mp ()->BlockSize << MT_ST_BLKSIZE_SHIFT)
		    & MT_ST_BLKSIZE_MASK;
  else
    get->mt_dsreg = (dp ()->DefaultBlockSize << MT_ST_BLKSIZE_SHIFT)
		    & MT_ST_BLKSIZE_MASK;

  DWORD size = sizeof (GET_MEDIA_TYPES) + 10 * sizeof (DEVICE_MEDIA_INFO);
  void *buf = alloca (size);
  if (DeviceIoControl (mt, IOCTL_STORAGE_GET_MEDIA_TYPES_EX,
		       NULL, 0, buf, size, &size, NULL)
      || GetLastError () == ERROR_MORE_DATA)
    {
      PGET_MEDIA_TYPES gmt = (PGET_MEDIA_TYPES) buf;
      for (DWORD i = 0; i < gmt->MediaInfoCount; ++i)
	{
	  PDEVICE_MEDIA_INFO dmi = &gmt->MediaInfo[i];
	  get->mt_type = dmi->DeviceSpecific.TapeInfo.MediaType;
#define TINFO DeviceSpecific.TapeInfo
	  if (dmi->TINFO.MediaCharacteristics & MEDIA_CURRENTLY_MOUNTED)
	    {
	      get->mt_type = dmi->DeviceSpecific.TapeInfo.MediaType;
	      if (dmi->TINFO.BusType == BusTypeScsi)
		get->mt_dsreg |=
		  (dmi->TINFO.BusSpecificData.ScsiInformation.DensityCode
		   << MT_ST_DENSITY_SHIFT)
		  & MT_ST_DENSITY_MASK;
	      break;
	    }
#undef TINFO
	}
    }

  if (!notape)
    {
      get->mt_resid = (partition & 0xffff)
		      | ((mp ()->PartitionCount & 0xffff) << 16);
      get->mt_fileno = part (partition)->file;
      get->mt_blkno = part (partition)->fblock;

      if (get->mt_blkno != 0)
	/* nothing to do */;
      else if (get->mt_fileno == 0)
	get->mt_gstat |= GMT_BOT (-1);
      else
	get->mt_gstat |= GMT_EOF (-1);
      if (part (partition)->emark >= eod_hit)
	get->mt_gstat |= GMT_EOD (-1);
      if (part (partition)->emark >= eom_hit)
	get->mt_gstat |= GMT_EOT (-1);

      if (part (partition)->smark)
	get->mt_gstat |= GMT_SM (-1);

      get->mt_gstat |= GMT_ONLINE (-1);

      if (mp ()->WriteProtected)
	get->mt_gstat |= GMT_WR_PROT (-1);

      get->mt_capacity = mp ()->Capacity.QuadPart;
      get->mt_remaining = mp ()->Remaining.QuadPart;
  }

  if (notape)
    get->mt_gstat |= GMT_DR_OPEN (-1);

  if (buffer_writes ())
    get->mt_gstat |= GMT_IM_REP_EN (-1);	/* TODO: Async writes */

  if (tstat == ERROR_DEVICE_REQUIRES_CLEANING)
    get->mt_gstat |= GMT_CLN (-1);

  /* Cygwin specials: */
  if (dp ()->ReportSetmarks)
    get->mt_gstat |= GMT_REP_SM (-1);
  if (dp ()->DataPadding)
    get->mt_gstat |= GMT_PADDING (-1);
  if (dp ()->ECC)
    get->mt_gstat |= GMT_HW_ECC (-1);
  if (dp ()->Compression)
    get->mt_gstat |= GMT_HW_COMP (-1);
  if (two_fm ())
    get->mt_gstat |= GMT_TWO_FM (-1);
  if (fast_eom ())
    get->mt_gstat |= GMT_FAST_MTEOM (-1);
  if (auto_lock ())
    get->mt_gstat |= GMT_AUTO_LOCK (-1);
  if (sysv ())
    get->mt_gstat |= GMT_SYSV (-1);
  if (nowait ())
    get->mt_gstat |= GMT_NOWAIT (-1);
  if (async_writes ())
    get->mt_gstat |= GMT_ASYNC (-1);

  get->mt_erreg = 0;				/* FIXME: No softerr counting */

  get->mt_minblksize = dp ()->MinimumBlockSize;
  get->mt_maxblksize = dp ()->MaximumBlockSize;
  get->mt_defblksize = dp ()->DefaultBlockSize;
  get->mt_featureslow = dp ()->FeaturesLow;
  get->mt_featureshigh = dp ()->FeaturesHigh;
  get->mt_eotwarningzonesize = dp ()->EOTWarningZoneSize;

  return 0;
}

int
mtinfo_drive::set_options (HANDLE mt, int32_t options)
{
  int32_t what = (options & MT_ST_OPTIONS);
  bool call_setparams = false;
  bool set;
  TAPE_SET_DRIVE_PARAMETERS sdp =
    {
      dp ()->ECC,
      dp ()->Compression,
      dp ()->DataPadding,
      dp ()->ReportSetmarks,
      dp ()->EOTWarningZoneSize
    };

  lasterr = 0;
  switch (what)
    {
      case 0:
	if (options == 0 || options == 1)
	  {
	    buffer_writes ((options == 1));
	  }
	break;
      case MT_ST_BOOLEANS:
	buffer_writes (!!(options & MT_ST_BUFFER_WRITES));
	async_writes (!!(options & MT_ST_ASYNC_WRITES));
	two_fm (!!(options & MT_ST_TWO_FM));
	fast_eom (!!(options & MT_ST_FAST_MTEOM));
	auto_lock (!!(options & MT_ST_AUTO_LOCK));
	sysv (!!(options & MT_ST_SYSV));
	nowait (!!(options & MT_ST_NOWAIT));
	if (get_feature (TAPE_DRIVE_SET_ECC))
	  sdp.ECC = !!(options & MT_ST_ECC);
	if (get_feature (TAPE_DRIVE_SET_PADDING))
	  sdp.DataPadding = !!(options & MT_ST_PADDING);
	if (get_feature (TAPE_DRIVE_SET_REPORT_SMKS))
	  sdp.ReportSetmarks = !!(options & MT_ST_REPORT_SM);
	if (sdp.ECC != dp ()->ECC || sdp.DataPadding != dp ()->DataPadding
	    || sdp.ReportSetmarks != dp ()->ReportSetmarks)
	  call_setparams = true;
	break;
      case MT_ST_SETBOOLEANS:
      case MT_ST_CLEARBOOLEANS:
	set = (what == MT_ST_SETBOOLEANS);
	if (options & MT_ST_BUFFER_WRITES)
	  buffer_writes (set);
	if (options & MT_ST_ASYNC_WRITES)
	  async_writes (set);
	if (options & MT_ST_TWO_FM)
	  two_fm (set);
	if (options & MT_ST_FAST_MTEOM)
	  fast_eom (set);
	if (options & MT_ST_AUTO_LOCK)
	  auto_lock (set);
	if (options & MT_ST_SYSV)
	  sysv (set);
	if (options & MT_ST_NOWAIT)
	  nowait (set);
	if (options & MT_ST_ECC)
	  sdp.ECC = set;
	if (options & MT_ST_PADDING)
	  sdp.DataPadding = set;
	if (options & MT_ST_REPORT_SM)
	  sdp.ReportSetmarks = set;
	if (sdp.ECC != dp ()->ECC || sdp.DataPadding != dp ()->DataPadding
	    || sdp.ReportSetmarks != dp ()->ReportSetmarks)
	  call_setparams = true;
	break;
      case MT_ST_EOT_WZ_SIZE:
	if (get_feature (TAPE_DRIVE_SET_EOT_WZ_SIZE))
	  {
	    sdp.EOTWarningZoneSize = (options & ~MT_ST_OPTIONS);
	    if (sdp.EOTWarningZoneSize != dp ()->EOTWarningZoneSize)
	      call_setparams = true;
	  }
	break;
    }
  if (call_setparams)
    {
      TAPE_FUNC (SetTapeParameters (mt, SET_TAPE_DRIVE_INFORMATION, &sdp));
      int err = lasterr;
      if (!err)
	{
	  dp ()->ECC = sdp.ECC;
	  dp ()->DataPadding = sdp.DataPadding;
	  dp ()->ReportSetmarks = sdp.ReportSetmarks;
	}
      else
	get_dp (mt);
      lasterr = err;
    }
  return error ("set_options");
}

int
mtinfo_drive::ioctl (HANDLE mt, unsigned int cmd, void *buf)
{
  __try
    {
      if (cmd == MTIOCTOP)
	{
	  struct mtop *op = (struct mtop *) buf;
	  if (lasterr == ERROR_BUS_RESET)
	    {
	      /* If a bus reset occurs, block further access to this device
		 until the user rewinds, unloads or in any other way tries
		 to maintain a well-known tape position. */
	      if (op->mt_op != MTREW && op->mt_op != MTOFFL
		  && op->mt_op != MTRETEN && op->mt_op != MTERASE
		  && op->mt_op != MTSEEK && op->mt_op != MTEOM)
		return ERROR_BUS_RESET;
	      /* Try to maintain last lock state after bus reset. */
	      if (lock >= auto_locked && PrepareTape (mt, TAPE_LOCK, FALSE))
		{
		  debug_printf ("Couldn't relock drive after bus reset.");
		  lock = unlocked;
		}
	    }
	  switch (op->mt_op)
	    {
	      case MTRESET:
		break;
	      case MTFSF:
		set_pos (mt, TAPE_SPACE_FILEMARKS, op->mt_count, false);
		break;
	      case MTBSF:
		set_pos (mt, TAPE_SPACE_FILEMARKS, -op->mt_count, false);
		break;
	      case MTFSR:
		set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS, op->mt_count, false);
		break;
	      case MTBSR:
		set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS, -op->mt_count, false);
		break;
	      case MTWEOF:
		write_marks (mt, TAPE_FILEMARKS, op->mt_count);
		break;
	      case MTREW:
		set_pos (mt, TAPE_REWIND, 0, false);
		break;
	      case MTOFFL:
	      case MTUNLOAD:
		prepare (mt, TAPE_UNLOAD);
		break;
	      case MTNOP:
		lasterr = 0;
		break;
	      case MTRETEN:
		if (!get_feature (TAPE_DRIVE_TENSION))
		  lasterr = ERROR_INVALID_PARAMETER;
		else if (!set_pos (mt, TAPE_REWIND, 0, false))
		  prepare (mt, TAPE_TENSION);
		break;
	      case MTBSFM:
		set_pos (mt, TAPE_SPACE_FILEMARKS, -op->mt_count, true);
		break;
	      case MTFSFM:
		set_pos (mt, TAPE_SPACE_FILEMARKS, op->mt_count, true);
		break;
	      case MTEOM:
		if (fast_eom () && get_feature (TAPE_DRIVE_END_OF_DATA))
		  set_pos (mt, TAPE_SPACE_END_OF_DATA, 0, false);
		else
		  set_pos (mt, TAPE_SPACE_FILEMARKS, 32767, false);
		break;
	      case MTERASE:
		erase (mt, TAPE_ERASE_LONG);
		break;
	      case MTRAS1:
	      case MTRAS2:
	      case MTRAS3:
		lasterr = ERROR_INVALID_PARAMETER;
		break;
	      case MTSETBLK:
		if (!get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
		  {
		    lasterr = ERROR_INVALID_PARAMETER;
		    break;
		  }
		if ((DWORD) op->mt_count == mp ()->BlockSize)
		  {
		    /* Nothing has changed. */
		    lasterr = 0;
		    break;
		  }
		if ((op->mt_count == 0 && !get_feature (TAPE_DRIVE_VARIABLE_BLOCK))
		    || (op->mt_count > 0
			&& ((DWORD) op->mt_count < dp ()->MinimumBlockSize
			    || (DWORD) op->mt_count > dp ()->MaximumBlockSize)))
		  {
		    lasterr = ERROR_INVALID_PARAMETER;
		    break;
		  }
		if (set_blocksize (mt, op->mt_count)
		    && lasterr == ERROR_INVALID_FUNCTION)
		  lasterr = ERROR_INVALID_BLOCK_LENGTH;
		break;
	      case MTSEEK:
		if (get_feature (TAPE_DRIVE_LOGICAL_BLK))
		  set_pos (mt, TAPE_LOGICAL_BLOCK, op->mt_count, false);
		else if (!get_pos (mt))
		  set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS,
			   op->mt_count - block, false);
		break;
	      case MTTELL:
		if (!get_pos (mt))
		  op->mt_count = (int) block;
		break;
	      case MTFSS:
		set_pos (mt, TAPE_SPACE_SETMARKS, op->mt_count, false);
		break;
	      case MTBSS:
		set_pos (mt, TAPE_SPACE_SETMARKS, -op->mt_count, false);
		break;
	      case MTWSM:
		write_marks (mt, TAPE_SETMARKS, op->mt_count);
		break;
	      case MTLOCK:
		prepare (mt, TAPE_LOCK);
		break;
	      case MTUNLOCK:
		prepare (mt, TAPE_UNLOCK);
		break;
	      case MTLOAD:
		prepare (mt, TAPE_LOAD);
		break;
	      case MTCOMPRESSION:
		set_compression (mt, op->mt_count);
		break;
	      case MTSETPART:
		set_partition (mt, op->mt_count);
		break;
	      case MTMKPART:
		create_partitions (mt, op->mt_count);
		break;
	      case MTSETDRVBUFFER:
		set_options (mt, op->mt_count);
		break;
	      case MTSETDENSITY:
	      default:
		lasterr = ERROR_INVALID_PARAMETER;
		break;
	    }
	}
      else if (cmd == MTIOCGET)
	get_status (mt, (struct mtget *) buf);
      else if (cmd == MTIOCPOS && !get_pos (mt))
	((struct mtpos *) buf)->mt_blkno = (long) block;
    }
  __except (NO_ERROR)
    {
      lasterr = ERROR_NOACCESS;
    }
  __endtry
  return lasterr;
}

/**********************************************************************/
/* mtinfo */

void
mtinfo::initialize ()
{
  for (unsigned i = 0; i < MAX_DRIVE_NUM; ++i)
    drive (i)->initialize (i, true);
}

/**********************************************************************/
/* fhandler_dev_tape */

#define mt	(cygwin_shared->mt)

#define lock(err_ret_val) if (!_lock (false)) return (err_ret_val);

inline bool
fhandler_dev_tape::_lock (bool cancelable)
{
  /* O_NONBLOCK is only valid in a read or write call.  Only those are
     cancelable. */
  DWORD timeout = cancelable && is_nonblocking () ? 0 : INFINITE;
  switch (cygwait (mt_mtx, timeout,
		   cw_sig | cw_sig_restart | cw_cancel | cw_cancel_self))
    {
    case WAIT_OBJECT_0:
      return true;
    case WAIT_TIMEOUT:
      set_errno (EAGAIN);
      return false;
    default:
      __seterrno ();
      return false;
    }
}

inline int
fhandler_dev_tape::unlock (int ret)
{
  ReleaseMutex (mt_mtx);
  return ret;
}

fhandler_dev_tape::fhandler_dev_tape ()
  : fhandler_dev_raw ()
{
  debug_printf ("unit: %d", dev ().get_minor ());
}

int
fhandler_dev_tape::open (int flags, mode_t)
{
  int ret;

  if (driveno () >= MAX_DRIVE_NUM)
    {
      set_errno (ENOENT);
      return 0;
    }
  if (!(mt_mtx = CreateMutex (&sec_all, !!(flags & O_CLOEXEC), NULL)))
    {
      __seterrno ();
      return 0;
    }

  /* The O_SYNC flag is not supported by the tape driver.  Use the
     MT_ST_BUFFER_WRITES and MT_ST_ASYNC_WRITES flags in the drive
     settings instead.  In turn, the MT_ST_BUFFER_WRITES is translated
     into O_SYNC, which controls the FILE_WRITE_THROUGH flag in the
     NtCreateFile call in fhandler_base::open. */
  flags &= ~O_SYNC;
  if (!mt.drive (driveno ())->buffer_writes ())
    flags |= O_SYNC;

  ret = fhandler_dev_raw::open (flags);
  if (ret)
    {
      mt.drive (driveno ())->open (get_handle ());

      /* In append mode, seek to beginning of next filemark */
      if (flags & O_APPEND)
	mt.drive (driveno ())->set_pos (get_handle (),
					 TAPE_SPACE_FILEMARKS, 1, true);

      if (!(flags & O_DIRECT))
	{
	  devbufsiz = mt.drive (driveno ())->dp ()->MaximumBlockSize;
	  devbufalign = 1;
	  devbufalloc = devbuf = new char [devbufsiz];
	}
    }
  else
    ReleaseMutex (mt_mtx);
  return ret;
}

int
fhandler_dev_tape::close ()
{
  int ret = 0;
  int cret = 0;

  if (!have_execed)
    {
      lock (-1);
      ret = mt.drive (driveno ())->close (get_handle (), is_rewind_device ());
      if (ret)
	__seterrno_from_win_error (ret);
      cret = fhandler_dev_raw::close ();
      unlock (0);
    }
  if (ov.hEvent)
    CloseHandle (ov.hEvent);
  CloseHandle (mt_mtx);
  return ret ? -1 : cret;
}

void __reg3
fhandler_dev_tape::raw_read (void *ptr, size_t &ulen)
{
  char *buf = (char *) ptr;
  size_t len = ulen;
  size_t block_size;
  size_t bytes_to_read;
  size_t bytes_read = 0;
  int ret = 0;

  if (lastblk_to_read ())
    {
      lastblk_to_read (false);
      ulen = 0;
      return;
    }
  if (!_lock (true))
    {
      ulen = (size_t) -1;
      return;
    }
  block_size = mt.drive (driveno ())->mp ()->BlockSize;
  if (devbuf)
    {
      if (devbufend > devbufstart)
	{
	  bytes_to_read = MIN (len, devbufend - devbufstart);
	  debug_printf ("read %lu bytes from buffer (rest %lu)",
			bytes_to_read, devbufend - devbufstart - bytes_to_read);
	  memcpy (buf, devbuf + devbufstart, bytes_to_read);
	  len -= bytes_to_read;
	  bytes_read += bytes_to_read;
	  buf += bytes_to_read;
	  devbufstart += bytes_to_read;
	  if (devbufstart == devbufend)
	    devbufstart = devbufend = 0;
	  /* If a switch to variable block_size occured, just return the buffer
	     remains until the buffer is empty, then proceed with usual variable
	     block size handling (one block per read call). */
	  if (!block_size)
	    len = 0;
	}
      if (len > 0)
	{
	  if (!ov.hEvent
	      && !(ov.hEvent = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
	    debug_printf ("Creating event failed, %E");
	  size_t block_fit = !block_size ? len : rounddown(len,  block_size);
	  if (block_fit)
	    {
	      debug_printf ("read %lu bytes from tape (rest %lu)",
			    block_fit, len - block_fit);
	      ret = mt.drive (driveno ())->read (get_handle (), &ov, buf,
						 block_fit);
	      if (ret)
		__seterrno_from_win_error (ret);
	      else if (block_fit)
		{
		  len -= block_fit;
		  bytes_read += block_fit;
		  buf += block_fit;
		  /* Only one block in each read call, please. */
		  if (!block_size)
		    len = 0;
		}
	      else {
		len = 0;
		if (bytes_read)
		  lastblk_to_read (true);
	      }
	    }
	  if (!ret && len > 0)
	    {
	      debug_printf ("read %lu bytes from tape (one block)", block_size);
	      ret = mt.drive (driveno ())->read (get_handle (), &ov, devbuf,
						 block_size);
	      if (ret)
		__seterrno_from_win_error (ret);
	      else if (block_size)
		{
		  devbufstart = len;
		  devbufend = block_size;
		  bytes_read += len;
		  memcpy (buf, devbuf, len);
		}
	      else if (bytes_read)
		lastblk_to_read (true);
	    }
	}
    }
  else
    {
      if (!ov.hEvent
	  && !(ov.hEvent = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
	debug_printf ("Creating event failed, %E");
      bytes_read = ulen;
      ret = mt.drive (driveno ())->read (get_handle (), &ov, ptr, bytes_read);
    }
  ulen = (ret ? (size_t) -1 : bytes_read);
  unlock ();
}

ssize_t __reg3
fhandler_dev_tape::raw_write (const void *ptr, size_t len)
{
  if (!_lock (true))
    return -1;
  if (!ov.hEvent && !(ov.hEvent = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
    debug_printf ("Creating event failed, %E");
  int ret = mt.drive (driveno ())->write (get_handle (), &ov, ptr, len);
  if (ret)
    __seterrno_from_win_error (ret);
  return unlock (ret ? -1 : (int) len);
}

off_t
fhandler_dev_tape::lseek (off_t offset, int whence)
{
#if 1
  /* On Linux lseek on tapes is a no-op.  For now, let's keep the old code
     intact but commented out, should incompatibilities arise. */
  return 0;
#else
  struct mtop op;
  struct mtpos pos;
  DWORD block_size;
  off_t ret = ILLEGAL_SEEK;

  lock (ILLEGAL_SEEK);

  debug_printf ("lseek (%s, %D, %d)", get_name (), offset, whence);

  block_size = mt.drive (driveno ())->mp ()->BlockSize;
  if (block_size == 0)
    {
      set_errno (EIO);
      goto out;
    }

  if (ioctl (MTIOCPOS, &pos))
    goto out;

  switch (whence)
    {
      case SEEK_END:
	op.mt_op = MTFSF;
	op.mt_count = 1;
	if (ioctl (MTIOCTOP, &op))
	  goto out;
	break;
      case SEEK_SET:
	if (whence == SEEK_SET && offset < 0)
	  {
	    set_errno (EINVAL);
	    goto out;
	  }
	break;
      case SEEK_CUR:
	break;
      default:
	set_errno (EINVAL);
	goto out;
    }

  op.mt_op = MTFSR;
  op.mt_count = offset / block_size
		- (whence == SEEK_SET ? pos.mt_blkno : 0);

  if (op.mt_count < 0)
    {
      op.mt_op = MTBSR;
      op.mt_count = -op.mt_count;
    }

  if (ioctl (MTIOCTOP, &op) || ioctl (MTIOCPOS, &pos))
    goto out;

  ret = pos.mt_blkno * block_size;

out:
  return unlock (ret);
#endif
}

int __reg2
fhandler_dev_tape::fstat (struct stat *buf)
{
  int ret;

  if (driveno () >= MAX_DRIVE_NUM)
    {
      set_errno (ENOENT);
      return -1;
    }
  if (!(ret = fhandler_base::fstat (buf)))
    buf->st_blocks = 0;
  return ret;
}

int
fhandler_dev_tape::dup (fhandler_base *child, int flags)
{
  lock (-1);
  fhandler_dev_tape *fh = (fhandler_dev_tape *) child;
  if (!DuplicateHandle (GetCurrentProcess (), mt_mtx,
			GetCurrentProcess (), &fh->mt_mtx,
			0, TRUE, DUPLICATE_SAME_ACCESS))
    {
      debug_printf ("dup(%s) failed, mutex handle %p, %E",
		    get_name (), mt_mtx);
      __seterrno ();
      return unlock (-1);
    }
  fh->ov.hEvent = NULL;
  if (ov.hEvent &&
      !DuplicateHandle (GetCurrentProcess (), ov.hEvent,
			GetCurrentProcess (), &fh->ov.hEvent,
			0, TRUE, DUPLICATE_SAME_ACCESS))
    {
      debug_printf ("dup(%s) failed, event handle %p, %E",
		    get_name (), ov.hEvent);
      __seterrno ();
      return unlock (-1);
    }
  return unlock (fhandler_dev_raw::dup (child, flags));
}

void
fhandler_dev_tape::fixup_after_fork (HANDLE parent)
{
  fhandler_dev_raw::fixup_after_fork (parent);
  fork_fixup (parent, mt_mtx, "mt_mtx");
  if (ov.hEvent)
    fork_fixup (parent, ov.hEvent, "ov.hEvent");
}

void
fhandler_dev_tape::set_close_on_exec (bool val)
{
  fhandler_dev_raw::set_close_on_exec (val);
  set_no_inheritance (mt_mtx, val);
  if (ov.hEvent)
    set_no_inheritance (ov.hEvent, val);
}

int
fhandler_dev_tape::ioctl (unsigned int cmd, void *buf)
{
  int ret = 0;
  lock (-1);
  if (cmd == MTIOCTOP || cmd == MTIOCGET || cmd == MTIOCPOS)
    {
      ret = mt.drive (driveno ())->ioctl (get_handle (), cmd, buf);
      if (ret)
	__seterrno_from_win_error (ret);
      return unlock (ret ? -1 : 0);
    }
  return unlock (fhandler_dev_raw::ioctl (cmd, buf));
}
@


1.96
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d5 1
a5 1
   2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d1163 2
a1164 1
  switch (cygwait (mt_mtx, timeout, cw_sig | cw_cancel | cw_cancel_self))
@


1.95
log
@	* fhandler.h (fhandler_dev_zero::lseek): Convert to inline method.
	(class fhandler_dev_random): Drop dummy_offset.
	(fhandler_dev_random::lseek): Convert to inline method.
	(fhandler_dev_dsp::lseek): Ditto.
	* fhandler_dsp.cc (fhandler_dev_dsp::lseek): Drop here.
	* fhandler_random.cc (fhandler_dev_random::open): Drop setting
	dummy_offset.
	(fhandler_dev_random::lseek): Drop here.
	* fhandler_tape.cc (fhandler_dev_tape::lseek): Make no-op, but keep
	old code for reference.
	* fhandler_zero.cc (fhandler_dev_zero::lseek): Drop here.
@
text
@d5 1
a5 1
   2010, 2011, 2012, 2013 Red Hat, Inc.
d980 1
a980 4
  myfault efault;
  if (efault.faulted ())
    return ERROR_NOACCESS;
  if (cmd == MTIOCTOP)
d982 1
a982 2
      struct mtop *op = (struct mtop *) buf;
      if (lasterr == ERROR_BUS_RESET)
d984 2
a985 9
	  /* If a bus reset occurs, block further access to this device
	     until the user rewinds, unloads or in any other way tries
	     to maintain a well-known tape position. */
	  if (op->mt_op != MTREW && op->mt_op != MTOFFL
	      && op->mt_op != MTRETEN && op->mt_op != MTERASE
	      && op->mt_op != MTSEEK && op->mt_op != MTEOM)
	    return ERROR_BUS_RESET;
	  /* Try to maintain last lock state after bus reset. */
	  if (lock >= auto_locked && PrepareTape (mt, TAPE_LOCK, FALSE))
d987 13
a999 2
	      debug_printf ("Couldn't relock drive after bus reset.");
	      lock = unlocked;
d1001 53
a1053 59
	}
      switch (op->mt_op)
	{
	  case MTRESET:
	    break;
	  case MTFSF:
	    set_pos (mt, TAPE_SPACE_FILEMARKS, op->mt_count, false);
	    break;
	  case MTBSF:
	    set_pos (mt, TAPE_SPACE_FILEMARKS, -op->mt_count, false);
	    break;
	  case MTFSR:
	    set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS, op->mt_count, false);
	    break;
	  case MTBSR:
	    set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS, -op->mt_count, false);
	    break;
	  case MTWEOF:
	    write_marks (mt, TAPE_FILEMARKS, op->mt_count);
	    break;
	  case MTREW:
	    set_pos (mt, TAPE_REWIND, 0, false);
	    break;
	  case MTOFFL:
	  case MTUNLOAD:
	    prepare (mt, TAPE_UNLOAD);
	    break;
	  case MTNOP:
	    lasterr = 0;
	    break;
	  case MTRETEN:
	    if (!get_feature (TAPE_DRIVE_TENSION))
	      lasterr = ERROR_INVALID_PARAMETER;
	    else if (!set_pos (mt, TAPE_REWIND, 0, false))
	      prepare (mt, TAPE_TENSION);
	    break;
	  case MTBSFM:
	    set_pos (mt, TAPE_SPACE_FILEMARKS, -op->mt_count, true);
	    break;
	  case MTFSFM:
	    set_pos (mt, TAPE_SPACE_FILEMARKS, op->mt_count, true);
	    break;
	  case MTEOM:
	    if (fast_eom () && get_feature (TAPE_DRIVE_END_OF_DATA))
	      set_pos (mt, TAPE_SPACE_END_OF_DATA, 0, false);
	    else
	      set_pos (mt, TAPE_SPACE_FILEMARKS, 32767, false);
	    break;
	  case MTERASE:
	    erase (mt, TAPE_ERASE_LONG);
	    break;
	  case MTRAS1:
	  case MTRAS2:
	  case MTRAS3:
	    lasterr = ERROR_INVALID_PARAMETER;
	    break;
	  case MTSETBLK:
	    if (!get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
	      {
d1056 64
a1119 5
	      }
	    if ((DWORD) op->mt_count == mp ()->BlockSize)
	      {
		/* Nothing has changed. */
		lasterr = 0;
d1121 2
a1122 6
	      }
	    if ((op->mt_count == 0 && !get_feature (TAPE_DRIVE_VARIABLE_BLOCK))
		|| (op->mt_count > 0
		    && ((DWORD) op->mt_count < dp ()->MinimumBlockSize
			|| (DWORD) op->mt_count > dp ()->MaximumBlockSize)))
	      {
d1125 1
a1125 50
	      }
	    if (set_blocksize (mt, op->mt_count)
		&& lasterr == ERROR_INVALID_FUNCTION)
	      lasterr = ERROR_INVALID_BLOCK_LENGTH;
	    break;
	  case MTSEEK:
	    if (get_feature (TAPE_DRIVE_LOGICAL_BLK))
	      set_pos (mt, TAPE_LOGICAL_BLOCK, op->mt_count, false);
	    else if (!get_pos (mt))
	      set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS,
		       op->mt_count - block, false);
	    break;
	  case MTTELL:
	    if (!get_pos (mt))
	      op->mt_count = (int) block;
	    break;
	  case MTFSS:
	    set_pos (mt, TAPE_SPACE_SETMARKS, op->mt_count, false);
	    break;
	  case MTBSS:
	    set_pos (mt, TAPE_SPACE_SETMARKS, -op->mt_count, false);
	    break;
	  case MTWSM:
	    write_marks (mt, TAPE_SETMARKS, op->mt_count);
	    break;
	  case MTLOCK:
	    prepare (mt, TAPE_LOCK);
	    break;
	  case MTUNLOCK:
	    prepare (mt, TAPE_UNLOCK);
	    break;
	  case MTLOAD:
	    prepare (mt, TAPE_LOAD);
	    break;
	  case MTCOMPRESSION:
	    set_compression (mt, op->mt_count);
	    break;
	  case MTSETPART:
	    set_partition (mt, op->mt_count);
	    break;
	  case MTMKPART:
	    create_partitions (mt, op->mt_count);
	    break;
	  case MTSETDRVBUFFER:
	    set_options (mt, op->mt_count);
	    break;
	  case MTSETDENSITY:
	  default:
	    lasterr = ERROR_INVALID_PARAMETER;
	    break;
d1127 4
d1132 5
a1136 5
  else if (cmd == MTIOCGET)
    get_status (mt, (struct mtget *) buf);
  else if (cmd == MTIOCPOS && !get_pos (mt))
    ((struct mtpos *) buf)->mt_blkno = (long) block;

@


1.95.2.1
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d5 1
a5 1
   2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d980 4
a983 1
  __try
d985 2
a986 1
      if (cmd == MTIOCTOP)
d988 9
a996 2
	  struct mtop *op = (struct mtop *) buf;
	  if (lasterr == ERROR_BUS_RESET)
d998 2
a999 13
	      /* If a bus reset occurs, block further access to this device
		 until the user rewinds, unloads or in any other way tries
		 to maintain a well-known tape position. */
	      if (op->mt_op != MTREW && op->mt_op != MTOFFL
		  && op->mt_op != MTRETEN && op->mt_op != MTERASE
		  && op->mt_op != MTSEEK && op->mt_op != MTEOM)
		return ERROR_BUS_RESET;
	      /* Try to maintain last lock state after bus reset. */
	      if (lock >= auto_locked && PrepareTape (mt, TAPE_LOCK, FALSE))
		{
		  debug_printf ("Couldn't relock drive after bus reset.");
		  lock = unlocked;
		}
d1001 60
a1060 3
	  switch (op->mt_op)
	    {
	      case MTRESET:
d1062 4
a1065 23
	      case MTFSF:
		set_pos (mt, TAPE_SPACE_FILEMARKS, op->mt_count, false);
		break;
	      case MTBSF:
		set_pos (mt, TAPE_SPACE_FILEMARKS, -op->mt_count, false);
		break;
	      case MTFSR:
		set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS, op->mt_count, false);
		break;
	      case MTBSR:
		set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS, -op->mt_count, false);
		break;
	      case MTWEOF:
		write_marks (mt, TAPE_FILEMARKS, op->mt_count);
		break;
	      case MTREW:
		set_pos (mt, TAPE_REWIND, 0, false);
		break;
	      case MTOFFL:
	      case MTUNLOAD:
		prepare (mt, TAPE_UNLOAD);
		break;
	      case MTNOP:
d1068 6
a1073 24
	      case MTRETEN:
		if (!get_feature (TAPE_DRIVE_TENSION))
		  lasterr = ERROR_INVALID_PARAMETER;
		else if (!set_pos (mt, TAPE_REWIND, 0, false))
		  prepare (mt, TAPE_TENSION);
		break;
	      case MTBSFM:
		set_pos (mt, TAPE_SPACE_FILEMARKS, -op->mt_count, true);
		break;
	      case MTFSFM:
		set_pos (mt, TAPE_SPACE_FILEMARKS, op->mt_count, true);
		break;
	      case MTEOM:
		if (fast_eom () && get_feature (TAPE_DRIVE_END_OF_DATA))
		  set_pos (mt, TAPE_SPACE_END_OF_DATA, 0, false);
		else
		  set_pos (mt, TAPE_SPACE_FILEMARKS, 32767, false);
		break;
	      case MTERASE:
		erase (mt, TAPE_ERASE_LONG);
		break;
	      case MTRAS1:
	      case MTRAS2:
	      case MTRAS3:
d1076 50
a1125 70
	      case MTSETBLK:
		if (!get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
		  {
		    lasterr = ERROR_INVALID_PARAMETER;
		    break;
		  }
		if ((DWORD) op->mt_count == mp ()->BlockSize)
		  {
		    /* Nothing has changed. */
		    lasterr = 0;
		    break;
		  }
		if ((op->mt_count == 0 && !get_feature (TAPE_DRIVE_VARIABLE_BLOCK))
		    || (op->mt_count > 0
			&& ((DWORD) op->mt_count < dp ()->MinimumBlockSize
			    || (DWORD) op->mt_count > dp ()->MaximumBlockSize)))
		  {
		    lasterr = ERROR_INVALID_PARAMETER;
		    break;
		  }
		if (set_blocksize (mt, op->mt_count)
		    && lasterr == ERROR_INVALID_FUNCTION)
		  lasterr = ERROR_INVALID_BLOCK_LENGTH;
		break;
	      case MTSEEK:
		if (get_feature (TAPE_DRIVE_LOGICAL_BLK))
		  set_pos (mt, TAPE_LOGICAL_BLOCK, op->mt_count, false);
		else if (!get_pos (mt))
		  set_pos (mt, TAPE_SPACE_RELATIVE_BLOCKS,
			   op->mt_count - block, false);
		break;
	      case MTTELL:
		if (!get_pos (mt))
		  op->mt_count = (int) block;
		break;
	      case MTFSS:
		set_pos (mt, TAPE_SPACE_SETMARKS, op->mt_count, false);
		break;
	      case MTBSS:
		set_pos (mt, TAPE_SPACE_SETMARKS, -op->mt_count, false);
		break;
	      case MTWSM:
		write_marks (mt, TAPE_SETMARKS, op->mt_count);
		break;
	      case MTLOCK:
		prepare (mt, TAPE_LOCK);
		break;
	      case MTUNLOCK:
		prepare (mt, TAPE_UNLOCK);
		break;
	      case MTLOAD:
		prepare (mt, TAPE_LOAD);
		break;
	      case MTCOMPRESSION:
		set_compression (mt, op->mt_count);
		break;
	      case MTSETPART:
		set_partition (mt, op->mt_count);
		break;
	      case MTMKPART:
		create_partitions (mt, op->mt_count);
		break;
	      case MTSETDRVBUFFER:
		set_options (mt, op->mt_count);
		break;
	      case MTSETDENSITY:
	      default:
		lasterr = ERROR_INVALID_PARAMETER;
		break;
	    }
a1126 4
      else if (cmd == MTIOCGET)
	get_status (mt, (struct mtget *) buf);
      else if (cmd == MTIOCPOS && !get_pos (mt))
	((struct mtpos *) buf)->mt_blkno = (long) block;
d1128 5
a1132 5
  __except (NO_ERROR)
    {
      lasterr = ERROR_NOACCESS;
    }
  __endtry
@


1.94
log
@	* fhandler_tape.cc (mtinfo_drive::open): Handle bus reset gracefully
	after opening the device.
@
text
@d1371 5
d1434 1
@


1.93
log
@	* mtinfo.h (class mtinfo_part): Change type of block numbers to int64_t.
	(mtinfo_part::initialize): Ditto for nblock parameter in declaration.
	(class mtinfo_drive): Change type of block number to int64_t.  Change
	all parameters indicating a block number to int64_t in method
	declarations.
	* fhandler_tape.cc (mtinfo_part::initialize): Ditto in definition.
	(mtinfo_drive::get_pos): Ditto.  Replace low and high with a
	ULARGE_INTEGER and use it's components in call to GetTapePosition.
	Store full value in block.
	(mtinfo_drive::_set_pos): Change type of count parameter to int64_t.
	Change call to SetTapePosition accordingly.
	(mtinfo_drive::set_pos): Change type of count parameter to int64_t.
	Change local variables holding block numbers accordingly.
	(mtinfo_drive::get_status): Don't bail out early if fetching media
	parameters fails.
	(mtinfo_drive::ioctl): Add explicit cast matching receiving type in
	MTTELL and MTIOCPOS calls.
@
text
@d110 4
a113 1
  get_dp (mt);
@


1.92
log
@	* fhandler_tape.cc (mtinfo_drive::create_partitions): Allow partitioning
	of drives supporting select partitions.
	(mtinfo_drive::get_status): Fill in current partition and number of
	partitions on tape into mt_resid.
	* include/cygwin/mtio.h (struct mtget): Align mt_resid comment to
	aforementioned change.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d56 1
a56 1
mtinfo_part::initialize (int32_t nblock)
d356 1
a356 1
mtinfo_drive::get_pos (HANDLE mt, int32_t *ppartition, int32_t *pblock)
d358 2
a359 1
  DWORD p, low, high;
d361 2
a362 1
  TAPE_FUNC (GetTapePosition (mt, TAPE_LOGICAL_POSITION, &p, &low, &high));
d364 2
a365 1
    TAPE_FUNC (GetTapePosition (mt, TAPE_ABSOLUTE_POSITION, &p, &low, &high));
d370 1
a370 1
      block = (int32_t) low;
d385 1
a385 1
mtinfo_drive::_set_pos (HANDLE mt, int mode, int32_t count, int partition,
d392 2
a393 1
  TAPE_FUNC (SetTapePosition (mt, mode, partition, count, count < 0 ? -1 : 0,
d399 1
a399 1
mtinfo_drive::set_pos (HANDLE mt, int mode, int32_t count, bool sfm_func)
d402 1
a402 1
  int32_t undone = count;
d596 1
a596 1
      int part_block = part (count)->block >= 0 ? part (count)->block : 0;
d600 2
a601 2
	  int sav_block = block;
	  int sav_partition = partition;
d656 2
a657 2
      int sav_block = block;
      int sav_partition = partition;
d765 2
a766 1
  if ((tstat = GetTapeStatus (mt)) == ERROR_NO_MEDIA_IN_DRIVE)
a768 3
  if (get_mp (mt))
    return lasterr;

d1087 1
a1087 1
	      op->mt_count = block;
d1128 1
a1128 1
    ((struct mtpos *) buf)->mt_blkno = block;
@


1.91
log
@	* fhandler_tape.cc (mtinfo_drive::create_partitions): Fix long-standing
	bug disabling creation of two partitions on drives supporting initiator
	partitions.
	(mtinfo_drive::set_blocksize): Update media information after setting
	blocksize succeeded.
	(mtinfo_drive::get_status): Fetch fresh media information.
@
text
@d563 5
d806 2
a807 1
      get->mt_resid = partition;
@


1.90
log
@	* fhandler_tape.cc (mtinfo_drive::set_pos): Remove unneeded linebreak.
	(mtinfo_drive::get_status): Drop using get_ll when it's not required.
@
text
@d560 2
a561 3
      if (count <= 0)
	TAPE_FUNC (CreateTapePartition (mt, TAPE_INITIATOR_PARTITIONS,
					count <= 0 ? 0 : 2, (DWORD) count));
d743 2
a744 1
  return error ("set_blocksize");
d759 3
@


1.89
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d395 1
a395 2
mtinfo_drive::set_pos (HANDLE mt, int mode, int32_t count,
		       bool sfm_func)
d821 2
a822 2
      get->mt_capacity = get_ll (mp ()->Capacity);
      get->mt_remaining = get_ll (mp ()->Remaining);
@


1.88
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1240 1
a1240 1
void __stdcall
d1342 1
a1342 1
ssize_t __stdcall
@


1.87
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d56 1
a56 1
mtinfo_part::initialize (long nblock)
d185 1
a185 1
mtinfo_drive::read (HANDLE mt, HANDLE mt_evt, void *ptr, size_t &ulen)
d234 3
a236 3
  ov.Offset = ov.OffsetHigh = 0;
  ov.hEvent = mt_evt;
  ret = ReadFile (mt, ptr, ulen, &bytes_read, &ov);
d243 2
a244 2
      long blocks_read = mp ()->BlockSize == 0
			 ? 1 : howmany (bytes_read, mp ()->BlockSize);
d290 1
a290 1
  bool ret = GetOverlappedResult (mt, &ov, &written, TRUE);
d297 1
a297 1
mtinfo_drive::write (HANDLE mt, HANDLE mt_evt, const void *ptr, size_t &len)
d316 3
a318 3
  ov.Offset = ov.OffsetHigh = 0;
  ov.hEvent = mt_evt;
  ret = WriteFile (mt, ptr, len, &bytes_written, &ov);
d331 2
a332 2
      long blocks_written = mp ()->BlockSize == 0
			 ? 1 : howmany (bytes_written, mp ()->BlockSize);
d356 1
a356 1
mtinfo_drive::get_pos (HANDLE mt, long *ppartition, long *pblock)
d366 2
a367 2
	partition = (long) p - 1;
      block = (long) low;
d382 1
a382 1
mtinfo_drive::_set_pos (HANDLE mt, int mode, long count, int partition,
d395 1
a395 1
mtinfo_drive::set_pos (HANDLE mt, int mode, long count,
d399 1
a399 1
  long undone = count;
d550 1
a550 1
mtinfo_drive::create_partitions (HANDLE mt, long count)
d581 1
a581 1
mtinfo_drive::set_partition (HANDLE mt, long count)
d583 1
a583 1
  if (count < 0 || (unsigned long) count >= MAX_PARTITION_NUM)
d718 1
a718 1
mtinfo_drive::set_compression (HANDLE mt, long count)
d725 1
a725 1
      count ? TRUE : FALSE,
d741 1
a741 1
mtinfo_drive::set_blocksize (HANDLE mt, long count)
d771 5
a775 1
  if (wincap.has_ioctl_storage_get_media_types_ex ())
d777 2
a778 5
      DWORD size = sizeof (GET_MEDIA_TYPES) + 10 * sizeof (DEVICE_MEDIA_INFO);
      void *buf = alloca (size);
      if (DeviceIoControl (mt, IOCTL_STORAGE_GET_MEDIA_TYPES_EX,
			   NULL, 0, buf, size, &size, NULL)
	  || GetLastError () == ERROR_MORE_DATA)
d780 4
a783 2
	  PGET_MEDIA_TYPES gmt = (PGET_MEDIA_TYPES) buf;
	  for (DWORD i = 0; i < gmt->MediaInfoCount; ++i)
a784 1
	      PDEVICE_MEDIA_INFO dmi = &gmt->MediaInfo[i];
d786 7
a792 11
#define TINFO DeviceSpecific.TapeInfo
	      if (dmi->TINFO.MediaCharacteristics & MEDIA_CURRENTLY_MOUNTED)
		{
		  get->mt_type = dmi->DeviceSpecific.TapeInfo.MediaType;
		  if (dmi->TINFO.BusType == BusTypeScsi)
		    get->mt_dsreg |=
		      (dmi->TINFO.BusSpecificData.ScsiInformation.DensityCode
		       << MT_ST_DENSITY_SHIFT)
		      & MT_ST_DENSITY_MASK;
		  break;
		}
a793 1
	    }
d870 1
a870 1
mtinfo_drive::set_options (HANDLE mt, long options)
d872 1
a872 1
  long what = (options & MT_ST_OPTIONS);
d1234 2
a1235 2
  if (mt_evt)
    CloseHandle (mt_evt);
d1267 1
a1267 1
	  debug_printf ("read %d bytes from buffer (rest %d)",
d1284 2
a1285 1
	  if (!mt_evt && !(mt_evt = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
d1290 1
a1290 1
	      debug_printf ("read %d bytes from tape (rest %d)",
d1292 2
a1293 2
	      ret = mt.drive (driveno ())->read (get_handle (), mt_evt, buf,
						  block_fit);
d1313 3
a1315 3
	      debug_printf ("read %d bytes from tape (one block)", block_size);
	      ret = mt.drive (driveno ())->read (get_handle (), mt_evt, devbuf,
						  block_size);
d1332 2
a1333 1
      if (!mt_evt && !(mt_evt = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
d1336 1
a1336 2
      ret = mt.drive (driveno ())->read (get_handle (), mt_evt, ptr,
					  bytes_read);
d1347 1
a1347 1
  if (!mt_evt && !(mt_evt = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
d1349 1
a1349 1
  int ret = mt.drive (driveno ())->write (get_handle (), mt_evt, ptr, len);
d1355 2
a1356 2
_off64_t
fhandler_dev_tape::lseek (_off64_t offset, int whence)
d1361 1
a1361 1
  _off64_t ret = ILLEGAL_SEEK;
d1365 1
a1365 1
  debug_printf ("lseek (%s, %d, %d)", get_name (), offset, whence);
d1419 1
a1419 1
fhandler_dev_tape::fstat (struct __stat64 *buf)
d1442 1
a1442 1
      debug_printf ("dup(%s) failed, mutex handle %x, %E",
d1447 4
a1450 4
  fh->mt_evt = NULL;
  if (mt_evt &&
      !DuplicateHandle (GetCurrentProcess (), mt_evt,
			GetCurrentProcess (), &fh->mt_evt,
d1453 2
a1454 2
      debug_printf ("dup(%s) failed, event handle %x, %E",
		    get_name (), mt_evt);
d1466 2
a1467 2
  if (mt_evt)
    fork_fixup (parent, mt_evt, "mt_evt");
d1475 2
a1476 2
  if (mt_evt)
    set_no_inheritance (mt_evt, val);
@


1.86
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d4 2
a5 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2010, 2011, 2012 Red Hat, Inc.
d1420 1
a1420 1
int
@


1.85
log
@	* fhandler.h (class fhandler_dev_raw): Add members devbufalloc and
	devbufalign.
	(class fhandler_dev_floppy): Remove member bytes_per_sector;
	* fhandler_floppy.cc (bytes_per_sector): Define as devbufalign.
	(fhandler_dev_floppy::open): Set devbufalign to a multiple of the
	sector size and handle devbuf allocation and alignment in !O_DIRECT
	case here.  Change comment accordingly.
	Call FSCTL_ALLOW_EXTENDED_DASD_IO for partitions as well.
	(fhandler_dev_floppy::raw_write): Fix comment.  Rewrite and fix
	writing behaviour when application uses read and lseek.
	(fhandler_dev_floppy::lseek): Use rounddown macro.  Call
	SetFilePointerEx rather than the old SetFilePointer.
	(fhandler_dev_floppy::ioctl): Reformat switch.  Call
	IOCTL_DISK_UPDATE_PROPERTIES rather than IOCTL_DISK_UPDATE_DRIVE_SIZE
	in BLKRRPART case.  Support BLKIOMIN, BLKIOOPT, BLKPBSZGET and
	BLKALIGNOFF.
	* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Initialize
	all devbuf-related members.
	(fhandler_dev_raw::~fhandler_dev_raw): Delete devbufalloc rather than
	devbuf.
	(fhandler_dev_raw::open): Drop allocating devbuf.
	(fhandler_dev_raw::dup): Allocate devbufalloc and set devbuf to support
	new sector-aligned devbuf handling.
	(fhandler_dev_raw::fixup_after_exec): Ditto.
	* fhandler_tape.cc (fhandler_dev_tape::open): Ditto, set devbufalign
	to 1.
	* include/cygwin/fs.h (BLKIOMIN): Define.
	(BLKIOOPT): Define.
	(BLKALIGNOFF): Define.
	(BLKPBSZGET): Define.
@
text
@a17 1
#ifdef __MINGW64_VERSION_MAJOR
a19 3
#else
#include <ddk/ntddstor.h>
#endif
@


1.84
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d1217 2
a1218 1
	  devbuf = new char [devbufsiz];
a1219 1
      devbufstart = devbufend = 0;
@


1.83
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d1153 1
a1153 1
  switch (cancelable_wait (mt_mtx, timeout, cw_sig | cw_cancel | cw_cancel_self))
@


1.83.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d1361 2
a1362 2
off_t
fhandler_dev_tape::lseek (off_t offset, int whence)
d1367 1
a1367 1
  off_t ret = ILLEGAL_SEEK;
d1425 1
a1425 1
fhandler_dev_tape::fstat (struct stat *buf)
@


1.83.2.2
log
@Pull in changes from HEAD
@
text
@d1153 1
a1153 1
  switch (cygwait (mt_mtx, timeout, cw_sig | cw_cancel | cw_cancel_self))
@


1.83.2.3
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d1217 1
a1217 2
	  devbufalign = 1;
	  devbufalloc = devbuf = new char [devbufsiz];
d1219 1
@


1.83.2.4
log
@	* cygheap.h (struct user_heap_info): Change type of chunk to SIZE_T.
	Remove unused slop member.
	* fork.cc (fork): Rename esp to stackp.  Add 64 bit asm expression to
	fetch stack pointer.
	(child_copy): Use platform independent types.
	* heap.cc (eval_start_address): Add comment. Disable 3GB code on 64 bit.
	(eval_initial_heap_size): Use platform independent types.  Fix debug
	printf format strings.
	(sbrk): Add comment.  Change argument type according to newlib
	definition.  Use platform independent types.  Drop unneeded else and
	move comment to the right spot.
	* hookapi.cc (PEHeaderFromHModule): Return PVOID.  Add comment to
	explain why.  Add bool parameter to return if target executable is
	64 bit or not.
	(rvadelta_get): New inline function to fetch section address platform
	independent.
	(rvadelta32, rvadelta64): Platform dependent wrappers.
	(rvadelta): Change to macro calling the platform dependent rvadelta
	wrappers.
	(putmem): Define platform dependent THUNK_FUNC_TYPE and use throughout.
	(RedirectIAT): Add comment.
	(get_export): Add comment.
	(find_first_notloaded_dll): Allow to fetch information in a platform
	and target independent way.
	(hook_or_detect_cygwin): Ditto.  Recognize the cyg64win1.dll file name
	as well.
	* kernel32.cc (CreateFileMappingW): Cast to avoid compiler warning.

	* fhandler.h (class fhandler_dev_tape): Replace mt_evt with an
	OVERLAPPED structure ov.
	* mtinfo.h (class mtinfo_part): Define members as int32_t rather than
	long.  Change member function declarations accordingly.
	(class mtinfo_drive): Ditto.  Store OVERLAPPED pointer rather than
	holding the full structure.  Add comment to explain why.
	* fhandler_tape.cc: Accommodate above changes throughout.
@
text
@d60 1
a60 1
mtinfo_part::initialize (int32_t nblock)
d189 1
a189 1
mtinfo_drive::read (HANDLE mt, LPOVERLAPPED pov, void *ptr, size_t &ulen)
d238 3
a240 3
  ov = pov;
  ov->Offset = ov->OffsetHigh = 0;
  ret = ReadFile (mt, ptr, ulen, &bytes_read, ov);
d247 2
a248 2
      int32_t blocks_read = mp ()->BlockSize == 0
			    ? 1 : howmany (bytes_read, mp ()->BlockSize);
d294 1
a294 1
  bool ret = GetOverlappedResult (mt, ov, &written, TRUE);
d301 1
a301 1
mtinfo_drive::write (HANDLE mt, LPOVERLAPPED pov, const void *ptr, size_t &len)
d320 3
a322 3
  ov = pov;
  ov->Offset = ov->OffsetHigh = 0;
  ret = WriteFile (mt, ptr, len, &bytes_written, ov);
d335 2
a336 2
      int32_t blocks_written = mp ()->BlockSize == 0
			       ? 1 : howmany (bytes_written, mp ()->BlockSize);
d360 1
a360 1
mtinfo_drive::get_pos (HANDLE mt, int32_t *ppartition, int32_t *pblock)
d370 2
a371 2
	partition = (int32_t) p - 1;
      block = (int32_t) low;
d386 1
a386 1
mtinfo_drive::_set_pos (HANDLE mt, int mode, int32_t count, int partition,
d399 1
a399 1
mtinfo_drive::set_pos (HANDLE mt, int mode, int32_t count,
d403 1
a403 1
  int32_t undone = count;
d554 1
a554 1
mtinfo_drive::create_partitions (HANDLE mt, int32_t count)
d585 1
a585 1
mtinfo_drive::set_partition (HANDLE mt, int32_t count)
d587 1
a587 1
  if (count < 0 || (uint32_t) count >= MAX_PARTITION_NUM)
d722 1
a722 1
mtinfo_drive::set_compression (HANDLE mt, int32_t count)
d729 1
a729 1
      (BOOLEAN) (count ? TRUE : FALSE),
d745 1
a745 1
mtinfo_drive::set_blocksize (HANDLE mt, DWORD count)
d877 1
a877 1
mtinfo_drive::set_options (HANDLE mt, int32_t options)
d879 1
a879 1
  int32_t what = (options & MT_ST_OPTIONS);
d1241 2
a1242 2
  if (ov.hEvent)
    CloseHandle (ov.hEvent);
d1274 1
a1274 1
	  debug_printf ("read %ld bytes from buffer (rest %ld)",
d1291 1
a1291 2
	  if (!ov.hEvent
	      && !(ov.hEvent = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
d1296 1
a1296 1
	      debug_printf ("read %ld bytes from tape (rest %ld)",
d1298 2
a1299 2
	      ret = mt.drive (driveno ())->read (get_handle (), &ov, buf,
						 block_fit);
d1319 3
a1321 3
	      debug_printf ("read %ld bytes from tape (one block)", block_size);
	      ret = mt.drive (driveno ())->read (get_handle (), &ov, devbuf,
						 block_size);
d1338 1
a1338 2
      if (!ov.hEvent
	  && !(ov.hEvent = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
d1341 2
a1342 1
      ret = mt.drive (driveno ())->read (get_handle (), &ov, ptr, bytes_read);
d1353 1
a1353 1
  if (!ov.hEvent && !(ov.hEvent = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
d1355 1
a1355 1
  int ret = mt.drive (driveno ())->write (get_handle (), &ov, ptr, len);
d1371 1
a1371 1
  debug_printf ("lseek (%s, %D, %d)", get_name (), offset, whence);
d1448 1
a1448 1
      debug_printf ("dup(%s) failed, mutex handle %p, %E",
d1453 4
a1456 4
  fh->ov.hEvent = NULL;
  if (ov.hEvent &&
      !DuplicateHandle (GetCurrentProcess (), ov.hEvent,
			GetCurrentProcess (), &fh->ov.hEvent,
d1459 2
a1460 2
      debug_printf ("dup(%s) failed, event handle %p, %E",
		    get_name (), ov.hEvent);
d1472 2
a1473 2
  if (ov.hEvent)
    fork_fixup (parent, ov.hEvent, "ov.hEvent");
d1481 2
a1482 2
  if (ov.hEvent)
    set_no_inheritance (ov.hEvent, val);
@


1.83.2.5
log
@Pull in changes from HEAD
@
text
@d18 1
d21 3
@


1.83.2.6
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d1270 1
a1270 1
	  debug_printf ("read %lu bytes from buffer (rest %lu)",
d1293 1
a1293 1
	      debug_printf ("read %lu bytes from tape (rest %lu)",
d1316 1
a1316 1
	      debug_printf ("read %lu bytes from tape (one block)", block_size);
@


1.83.2.7
log
@Pull in changes from HEAD
@
text
@d4 2
a5 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012, 2013 Red Hat, Inc.
d1421 1
a1421 1
int __reg2
@


1.83.2.8
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d771 1
a771 5
  DWORD size = sizeof (GET_MEDIA_TYPES) + 10 * sizeof (DEVICE_MEDIA_INFO);
  void *buf = alloca (size);
  if (DeviceIoControl (mt, IOCTL_STORAGE_GET_MEDIA_TYPES_EX,
		       NULL, 0, buf, size, &size, NULL)
      || GetLastError () == ERROR_MORE_DATA)
d773 5
a777 2
      PGET_MEDIA_TYPES gmt = (PGET_MEDIA_TYPES) buf;
      for (DWORD i = 0; i < gmt->MediaInfoCount; ++i)
d779 2
a780 4
	  PDEVICE_MEDIA_INFO dmi = &gmt->MediaInfo[i];
	  get->mt_type = dmi->DeviceSpecific.TapeInfo.MediaType;
#define TINFO DeviceSpecific.TapeInfo
	  if (dmi->TINFO.MediaCharacteristics & MEDIA_CURRENTLY_MOUNTED)
d782 1
d784 12
a795 6
	      if (dmi->TINFO.BusType == BusTypeScsi)
		get->mt_dsreg |=
		  (dmi->TINFO.BusSpecificData.ScsiInformation.DensityCode
		   << MT_ST_DENSITY_SHIFT)
		  & MT_ST_DENSITY_MASK;
	      break;
a796 1
#undef TINFO
@


1.82
log
@	* fhandler_serial.cc: Fix includes for IOCTL codes to support Mingw64.
	* fhandler_tape.cc: Ditto.
	* flock.cc (allow_others_to_sync): Use PISECURITY_DESCRIPTOR since
	PSECURITY_DESCRIPTOR is supposed to be the opaque type.
	* ntdll.h: Remove CreateDisposition flags again, now that they are
	defined in Mingw64's ntdef.h.  Ditto for Create/Open flags.
@
text
@a1149 4
  HANDLE w4[3] = { mt_mtx, signal_arrived, NULL };
  DWORD cnt = 2;
  if (cancelable && (w4[2] = pthread::get_cancel_event ()) != NULL)
    cnt = 3;
d1153 1
a1153 2
restart:
  switch (WaitForMultipleObjects (cnt, w4, FALSE, timeout))
a1156 8
    case WAIT_OBJECT_0 + 1:
      if (_my_tls.call_signal_handler ())
	goto restart;
      set_errno (EINTR);
      return false;
    case WAIT_OBJECT_0 + 2:
      pthread::static_cancel_self ();
      /*NOTREACHED*/
@


1.81
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d18 4
d23 1
@


1.80
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d1145 4
d1153 1
a1153 1
  switch (cancelable_wait (mt_mtx, timeout, cw_sig | cw_cancel | cw_cancel_self))
d1157 8
@


1.79
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@a1144 4
  HANDLE w4[3] = { mt_mtx, signal_arrived, NULL };
  DWORD cnt = 2;
  if (cancelable && (w4[2] = pthread::get_cancel_event ()) != NULL)
    cnt = 3;
d1149 1
a1149 1
  switch (WaitForMultipleObjects (cnt, w4, FALSE, timeout))
a1152 8
    case WAIT_OBJECT_0 + 1:
      if (_my_tls.call_signal_handler ())
	goto restart;
      set_errno (EINTR);
      return false;
    case WAIT_OBJECT_0 + 2:
      pthread::static_cancel_self ();
      /*NOTREACHED*/
@


1.78
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d5 1
a5 1
   2008, 2010, 2011 Red Hat, Inc.
d1281 1
a1281 1
	  bytes_to_read = min (len, devbufend - devbufstart);
@


1.77
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d26 1
d1240 1
a1240 1
  if (!hExeced)
@


1.76
log
@whitespace elimination
@
text
@d1447 1
a1447 1
fhandler_dev_tape::dup (fhandler_base *child)
d1471 1
a1471 1
  return unlock (fhandler_dev_raw::dup (child));
@


1.75
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d1452 1
a1452 1
  			GetCurrentProcess (), &fh->mt_mtx,
@


1.74
log
@	* fhandler.h (fhandler_dev_tape::_lock): Add bool parameter.
	* fhandler_tape.cc (lock): Call _lock with false argument.
	(_lock): Take bool cancelable parameter.  Handle O_NONBLOCK.
	Make cancelable if cancelabe parameter is true.
	(fhandler_dev_tape::raw_read): Call _lock with true argument.
	(fhandler_dev_tape::raw_write): Ditto.
@
text
@d1183 1
a1183 1
  debug_printf ("unit: %d", dev ().minor);
@


1.73
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d5 1
a5 1
   2008, 2010 Red Hat, Inc.
d1139 1
a1139 1
#define lock(err_ret_val) if (!_lock ()) return err_ret_val;
d1142 1
a1142 1
fhandler_dev_tape::_lock ()
d1144 15
a1158 5
  HANDLE obj[2] = { mt_mtx, signal_arrived };
  BOOL ret = WaitForMultipleObjects (2, obj, FALSE, INFINITE) == WAIT_OBJECT_0;
  if (!ret)
    {
      debug_printf ("signal_arrived"); \
d1160 10
a1170 1
  return ret;
d1270 1
a1270 1
  if (!_lock ())
d1358 2
a1359 1
  lock (-1);
@


1.72
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d5 1
a5 1
   2008 Red Hat, Inc.
d1177 1
a1177 1
  if (!(mt_mtx = CreateMutex (&sec_all, TRUE, NULL)))
@


1.71
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d1431 3
a1433 2
  if (!DuplicateHandle (hMainProc, mt_mtx, hMainProc, &fh->mt_mtx, 0, TRUE,
			DUPLICATE_SAME_ACCESS))
d1442 3
a1444 2
      !DuplicateHandle (hMainProc, mt_evt, hMainProc, &fh->mt_evt, 0, TRUE,
			DUPLICATE_SAME_ACCESS))
@


1.70
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d1235 1
a1235 1
void
d1336 1
a1336 1
int
@


1.69
log
@	* fhandler_tape.cc (mtinfo::initialize): Remove synchronization stuff.
	Just initialize drive data.
	* mtinfo.h (MTINFO_MAGIC): Remove.
	(MTINFO_VERSION): Remove.
	(class mtinfo): Remove magic and version members.
	* shared.cc (shared_info::initialize): Move call to
	get_session_parent_dir so that the dir creation is only called once.
	Move call to mt.initialize so that it's called only by the first
	process creating the shared memory.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add obcaseinsensitivity member.
@
text
@d804 6
a809 5
      if (get->mt_blkno == 0)
	if (get->mt_fileno == 0)
	  get->mt_gstat |= GMT_BOT (-1);
	else
	  get->mt_gstat |= GMT_EOF (-1);
@


1.68
log
@	* fhandler.h (-struct wsa_event): Move to wsa_event.h.  Include
	wsa_event.h instead.
	* fhandler_socket.cc (NUM_SOCKS): Move to wsa_event.h.
	(wsa_events): Move from DLL shared area to cygwin_shared shared
	memory.  Accommodate throughout.
	(socket_serial_number): Ditto.
	* fhandler_tape.cc (mt): Ditto.
	(mtinfo_init): Remove.
	(mt): Define as cygwin_shared->mt.
	* flock.cc (FLOCK_PARENT_DIR_ACCESS): Remove.
	(FLOCK_INODE_DIR_ACCESS): Move up in file.
	(FLOCK_MUTANT_ACCESS): Ditto.
	(FLOCK_EVENT_ACCESS): Ditto.
	(get_lock_parent_dir): Remove.
	(inode_t::inode_t): Call get_shared_parent_dir to get parent dir handle.
	Add a "flock-" prefix to file's lock directory name for clarity.
	* mtinfo.h (mtinfo_init): Drop declaration.
	* net.cc (last_used_bindresvport): Move from DLL shared area to
	cygwin_shared shared memory.
	(cygwin_bindresvport_sa): Accommodate above change.
	* sec_helper.cc (_everyone_sd): Move here from flock.cc.
	* security.h (SD_MIN_SIZE): Ditto.
	(everyone_sd): Ditto.
	* shared.cc (cygwin_shared_area): Remove.
	(cygwin_shared_h): New handle.
	(get_shared_parent_dir): New static function.
	(shared_name): Drop session_local argument.  Call get_shared_parent_dir
	here.  Add cygwin-shared subdir to object name.
	(offsets): Reinstantiate SH_CYGWIN_SHARED member.
	(open_shared): Revert change from 2007-03-29 for systems supporting
	SeCreateGlobalPrivilege.
	(shared_info::initialize): Call mtinfo's initialize here.
	(memory_init): Drop call to mtinfo_init.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add members for global socket and tape info
	sharing.
	(enum shared_locations): Reinstantiate SH_CYGWIN_SHARED.
	(get_shared_parent_dir): Declare.
	(shared_name): Drop session_local argument from declaration.
	* wsa_event.h: New file.  Move definitions of NUM_SOCKS and
	struct wsa_event here.
@
text
@d4 2
a5 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.
d1129 2
a1130 27
  char name[MAX_PATH];
  HANDLE mtx;

  shared_name (name, "mtinfo_mutex", 0);
  if (!(mtx = CreateMutex (&sec_all_nih, FALSE, name)))
    api_fatal ("CreateMutex '%s', %E.  Terminating.", name);
  WaitForSingleObject (mtx, INFINITE);
  if (!magic)
    {
      magic = MTINFO_MAGIC;
      version = MTINFO_VERSION;
      for (unsigned i = 0; i < MAX_DRIVE_NUM; ++i)
	drive (i)->initialize (i, true);
      ReleaseMutex (mtx);
      CloseHandle (mtx);
    }
  else
    {
      ReleaseMutex (mtx);
      CloseHandle (mtx);
      if (magic != MTINFO_MAGIC)
	api_fatal ("MT magic number screwed up: %lu, should be %lu",
		   magic, MTINFO_MAGIC);
      if (version != MTINFO_VERSION)
	system_printf ("MT version number mismatch: %lu, should be %lu",
		       version, MTINFO_VERSION);
    }
@


1.67
log
@Remove unneeded header files from source files throughout.
@
text
@a24 1
#include "mtinfo.h"
a1156 8
static mtinfo mt __attribute__((section (".cygwin_dll_common"), shared));

void __stdcall
mtinfo_init ()
{
  mt.initialize ();
}

d1160 2
@


1.66
log
@	* fhandler_tape.cc (mtinfo::initialize): Use MAX_PATH instead of
	CYG_MAX_PATH.
	* fhandler_tty.cc (fhandler_pty_master::ptsname): Set buffer size to
	TTY_NAME_MAX.
	* syscalls.cc (ttyname): Eliminate the `+ 1' from the name buffer size
	since TTY_NAME_MAX already counts the trailing NUL.
	* libc/bsdlib.cc (openpty): Set pts buffer size to TTY_NAME_MAX.
@
text
@a13 2
#include <sys/termios.h>
#include <unistd.h>
a17 2
#include "cygerrno.h"
#include "perprocess.h"
@


1.65
log
@	* cygheap.h (struct init_cygheap): Remove shared_h and mt_h members.
	* fhandler_tape.cc (mt): Define as DLL shared area in
	.cygwin_dll_common instead of as dynamically allocated area.
	Change referencing throughout.
	* mtinfo.h (mt_h): Remove entirely.
	(mt): Remove extern declaration.
	* shared.cc (cygwin_shared_area): New global cygwin_shared
	variable located in .cygwin_dll_common.
	(offsets): Define shared region addresses descending from
	cygwin_shared_address.
	(open_shared): Replace usage of SH_CYGWIN_SHARED by SH_USER_SHARED.
	(memory_init): Set cygwin_shared just by pointing to cygwin_shared_area.
	* shared_info.h (shared_locations): Remove SH_CYGWIN_SHARED and
	SH_MTINFO.
	(cygwin_shared_address): Define as DLL start address.
	* tty.h (tty_min::tty_min): Remove constructor.
@
text
@d1133 1
a1133 1
  char name[CYG_MAX_PATH];
@


1.64
log
@whitespace cleanup to force snapshot.
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
d1162 1
a1162 1
mtinfo *mt;
d1167 1
a1167 4
  shared_locations sh_mtinfo = SH_MTINFO;
  mt = (mtinfo *) open_shared ("mtinfo", MTINFO_VERSION, cygheap->mt_h, sizeof (mtinfo), sh_mtinfo);
  ProtectHandleINH (cygheap->mt_h);
  mt->initialize ();
d1223 1
a1223 1
  if (!mt->drive (driveno ())->buffer_writes ())
d1229 1
a1229 1
      mt->drive (driveno ())->open (get_handle ());
d1233 1
a1233 1
	mt->drive (driveno ())->set_pos (get_handle (),
d1238 1
a1238 1
	  devbufsiz = mt->drive (driveno ())->dp ()->MaximumBlockSize;
d1257 1
a1257 1
      ret = mt->drive (driveno ())->close (get_handle (), is_rewind_device ());
d1290 1
a1290 1
  block_size = mt->drive (driveno ())->mp ()->BlockSize;
d1320 1
a1320 1
	      ret = mt->drive (driveno ())->read (get_handle (), mt_evt, buf,
d1342 1
a1342 1
	      ret = mt->drive (driveno ())->read (get_handle (), mt_evt, devbuf,
d1363 1
a1363 1
      ret = mt->drive (driveno ())->read (get_handle (), mt_evt, ptr,
d1376 1
a1376 1
  int ret = mt->drive (driveno ())->write (get_handle (), mt_evt, ptr, len);
d1394 1
a1394 1
  block_size = mt->drive (driveno ())->mp ()->BlockSize;
d1511 1
a1511 1
      ret = mt->drive (driveno ())->ioctl (get_handle (), cmd, buf);
@


1.63
log
@	* fhandler.cc (fhandler_base::open_9x): Handle O_SYNC and O_DIRECT
	flags.
	(fhandler_base::open): Ditto.
	* fhandler_floppy.cc (fhandler_dev_floppy::open): Don't allocate devbuf
	in O_DIRECT case.
	* fhandler_raw.cc (fhandler_dev_raw::ioctl): Don't allow buffer
	changes in O_DIRECT case.  Allow returning a buffer size 0, which
	indicates O_DIRECT.
	* fhandler_tape.cc (fhandler_dev_tape::open): Use O_SYNC flag to
	hand down the !buffer_writes case.  Don't allocate devbuf in O_DIRECT
	case.
	(fhandler_dev_tape::raw_read): Don't mess with devbuf if it's NULL.
	* include/fcntl.h: Define _FDIRECT, O_DIRECT, O_DSYNC and O_RSYNC.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d1240 1
a1240 1
        {
d1469 1
a1469 1
  			DUPLICATE_SAME_ACCESS))
d1479 1
a1479 1
  			DUPLICATE_SAME_ACCESS))
@


1.62
log
@	Revert erroneous checkin.
@
text
@d1219 7
a1225 3
  /* The O_TEXT flag is used to indicate write-through (non buffered writes)
     to the underlying fhandler_dev_raw::open call. */
  flags &= ~O_TEXT;
d1227 2
a1228 1
    flags |= O_TEXT;
d1239 5
a1243 2
      devbufsiz = mt->drive (driveno ())->dp ()->MaximumBlockSize;
      devbuf = new char [devbufsiz];
d1294 1
a1294 1
  if (devbufend > devbufstart)
d1296 19
a1314 22
      bytes_to_read = min (len, devbufend - devbufstart);
      debug_printf ("read %d bytes from buffer (rest %d)",
		    bytes_to_read, devbufend - devbufstart - bytes_to_read);
      memcpy (buf, devbuf + devbufstart, bytes_to_read);
      len -= bytes_to_read;
      bytes_read += bytes_to_read;
      buf += bytes_to_read;
      devbufstart += bytes_to_read;
      if (devbufstart == devbufend)
	devbufstart = devbufend = 0;
      /* If a switch to variable block_size occured, just return the buffer
	 remains until the buffer is empty, then proceed with usual variable
	 block size handling (one block per read call). */
      if (!block_size)
	len = 0;
    }
  if (len > 0)
    {
      if (!mt_evt && !(mt_evt = CreateEvent (&sec_none, TRUE, FALSE, NULL)))
	debug_printf ("Creating event failed, %E");
      size_t block_fit = !block_size ? len : rounddown(len,  block_size);
      if (block_fit)
d1316 4
a1319 7
	  debug_printf ("read %d bytes from tape (rest %d)",
			block_fit, len - block_fit);
	  ret = mt->drive (driveno ())->read (get_handle (), mt_evt, buf,
					      block_fit);
	  if (ret)
	    __seterrno_from_win_error (ret);
	  else if (block_fit)
d1321 16
a1336 5
	      len -= block_fit;
	      bytes_read += block_fit;
	      buf += block_fit;
	      /* Only one block in each read call, please. */
	      if (!block_size)
d1338 3
d1342 1
a1342 14
	  else {
	    len = 0;
	    if (bytes_read)
	      lastblk_to_read (true);
	  }
	}
      if (!ret && len > 0)
	{
	  debug_printf ("read %d bytes from tape (one block)", block_size);
	  ret = mt->drive (driveno ())->read (get_handle (), mt_evt, devbuf,
					      block_size);
	  if (ret)
	    __seterrno_from_win_error (ret);
	  else if (block_size)
d1344 14
a1357 4
	      devbufstart = len;
	      devbufend = block_size;
	      bytes_read += len;
	      memcpy (buf, devbuf, len);
a1358 2
	  else if (bytes_read)
	    lastblk_to_read (true);
d1361 8
@


1.61
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d1445 1
a1445 1
fhandler_dev_tape::dup (fhandler_base *child, HANDLE from_proc)
d1449 1
a1449 1
  if (!DuplicateHandle (from_proc, mt_mtx, hMainProc, &fh->mt_mtx, 0, TRUE,
d1459 1
a1459 1
      !DuplicateHandle (from_proc, mt_evt, hMainProc, &fh->mt_evt, 0, TRUE,
d1467 1
a1467 1
  return unlock (fhandler_dev_raw::dup (child, from_proc));
@


1.60
log
@	* fhandler_tape.cc (fhandler_dev_tape::close): Don't do "extra stuff"
	when we know we're execing.
@
text
@d1445 1
a1445 1
fhandler_dev_tape::dup (fhandler_base *child)
d1449 1
a1449 1
  if (!DuplicateHandle (hMainProc, mt_mtx, hMainProc, &fh->mt_mtx, 0, TRUE,
d1459 1
a1459 1
      !DuplicateHandle (hMainProc, mt_evt, hMainProc, &fh->mt_evt, 0, TRUE,
d1467 1
a1467 1
  return unlock (fhandler_dev_raw::dup (child));
@


1.59
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d1246 2
a1247 1
  int ret, cret;
d1249 9
a1257 2
  lock (-1);
  ret = mt->drive (driveno ())->close (get_handle (), is_rewind_device ());
d1261 1
a1261 4
  if (ret)
    __seterrno_from_win_error (ret);
  cret = fhandler_dev_raw::close ();
  return unlock (ret ? -1 : cret);
@


1.58
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d1131 1
a1131 1
mtinfo::initialize (void)
d1244 1
a1244 1
fhandler_dev_tape::close (void)
@


1.57
log
@	* fhandler.h (class fhandler_dev_tape): Add declaration for
	fixup_after_fork and set_close_on_exec.
	* fhandler_tape.cc (fhandler_dev_tape::open): Create mt_mtx mutex
	inheritable.
	(fhandler_dev_tape::close): Close mt_mtx.
	(fhandler_dev_tape::dup): Duplicate mt_mtx and mt_evt as necessary.
	(fhandler_dev_tape::fixup_after_fork): New method.
	(fhandler_dev_tape::set_close_on_exec): New method.
@
text
@d13 1
d971 3
a975 2
      if (__check_invalid_read_ptr (buf, sizeof (struct mtop)))
	return ERROR_NOACCESS;
d1120 3
a1122 12
    {
      if (__check_null_invalid_struct (buf, sizeof (struct mtget)))
	return ERROR_NOACCESS;
      get_status (mt, (struct mtget *) buf);
    }
  else if (cmd == MTIOCPOS)
    {
      if (__check_null_invalid_struct (buf, sizeof (struct mtpos)))
	return ERROR_NOACCESS;
      if (!get_pos (mt))
	((struct mtpos *) buf)->mt_blkno = block;
    }
@


1.56
log
@* shared_info.h (cygwin_shared_address): Bump to a higher value to avoid
collision with large data areas.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Accommodate changes to
open_shared arguments.
* fhandler_tape.cc (mtinfo_init): Ditto.
* pinfo.cc (pinfo::init): Use open_shared rather than win32 mmap calls.
* shared.cc (user_shared_initialize): Ditto.
(memory_init): Ditto.
(open_shared): Change to allow use a smore general mmap handler.
* shared_info.h (shared_locations): Add SH_JUSTCREATE, SH_JUSTOPEN.
(open_shared): Change declaration to match new usage.
* autoload.cc (LoadDLLfuncEx2): Define in terms of LoadDLLfuncEx3.
(LoadDLLfuncEx3): New macro.
@
text
@d1221 1
a1221 1
  if (!(mt_mtx = CreateMutex (&sec_all, FALSE, NULL)))
d1259 1
d1450 19
d1472 18
@


1.55
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@d1174 2
a1175 1
  mt = (mtinfo *) open_shared ("mtinfo", MTINFO_VERSION, cygheap->mt_h, sizeof (mtinfo), SH_MTINFO);
@


1.54
log
@* fhandler_tape.cc (get_ll): This is a generally useful function so move it
* winsup.h (get_ll): to here
* security.cc (get_token_group_sidlist): Use get_ll to figure out the long long
version of the luid since QuadPart is not part of the standard Windows API.
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.53
log
@	* fhandler_tape.cc (fhandler_dev_tape::open): Fix typo.
@
text
@a38 3
/* Convert LARGE_INTEGER into long long */
#define get_ll(pl)  (((long long) (pl).HighPart << 32) | (pl).LowPart)

@


1.52
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d1244 1
a1244 1
      devbuf = new char (devbufsiz);
@


1.51
log
@	* fhandler_tape.cc (fhandler_dev_tape::raw_read): Use ?: instead of
	if/else.
	(fhandler_dev_tape::raw_write): Return -1 in case of error.
@
text
@d1310 1
a1310 1
	debug_printf ("Creating event failed: %E");
d1362 1
a1362 1
    debug_printf ("Creating event failed: %E");
@


1.50
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d1353 1
a1353 4
  if (ret)
    ulen = (size_t) -1;
  else
    ulen = bytes_read;
d1366 1
a1366 1
  return unlock (len);
@


1.49
log
@	* cygheap.h (struct init_cygheap): Add mt_h member.
	* fhandler_tape.cc (mt_h): Drop in favor of cygheap based handle.
	(mtinfo_init): Use cygheap->mt_h handle.  Protect it.
@
text
@d145 1
a145 1
        {
d160 1
a160 1
        {
d169 1
a169 1
        {
d268 1
a268 1
        part (partition)->emark = IS_EOM (lasterr) ? eom : eod;
d270 1
a270 1
        {
d281 1
a281 1
        lasterr = ERROR_NOT_ENOUGH_MEMORY;
d327 1
a327 1
        dirty = async_write_pending;
d352 1
a352 1
        dirty = has_written;
d354 1
a354 1
        dirty = async_write_pending;
d373 1
a373 1
        *ppartition= partition;
d375 1
a375 1
        *pblock = block;
d411 1
a411 1
        if (!count)
d420 1
a420 1
        dont_wait = nowait () ? TRUE : FALSE;
d440 1
a440 1
        break;
d442 1
a442 1
        if (!err)
d457 1
a457 1
        break;
d472 1
a472 1
	        if (part (partition)->file >= 0)
d536 1
a536 1
        break;
d540 1
a540 1
        if (!err)
d546 1
a546 1
        break;
d566 1
a566 1
        TAPE_FUNC (CreateTapePartition (mt, TAPE_INITIATOR_PARTITIONS,
d572 1
a572 1
         1.6 which missed to set the TAPE_DRIVE_INITIATOR flag.  According
d603 1
a603 1
	          && part (partition)->block != block)
d611 1
a611 1
        {
d713 1
a713 1
        break;
d715 1
a715 1
        lock = lasterr ? lock_error : unlocked;
d816 1
a816 1
        get->mt_gstat |= GMT_EOD (-1);
d818 1
a818 1
        get->mt_gstat |= GMT_EOT (-1);
d821 1
a821 1
        get->mt_gstat |= GMT_SM (-1);
d898 1
a898 1
        break;
d916 1
a916 1
        break;
d919 1
a919 1
        set = (what == MT_ST_SETBOOLEANS);
d943 1
a943 1
        break;
d951 1
a951 1
        break;
d958 1
a958 1
        {
d976 1
a976 1
        return ERROR_NOACCESS;
d979 1
a979 1
        {
d993 1
a993 1
        }
d1123 1
a1123 1
        return ERROR_NOACCESS;
d1129 1
a1129 1
        return ERROR_NOACCESS;
d1155 1
a1155 1
        drive (i)->initialize (i, true);
d1167 1
a1167 1
        system_printf ("MT version number mismatch: %lu, should be %lu",
d1300 1
a1300 1
        devbufstart = devbufend = 0;
d1302 1
a1302 1
         remains until the buffer is empty, then proceed with usual variable
d1305 1
a1305 1
        len = 0;
d1313 1
a1313 1
        {
d1327 1
a1327 1
	        len = 0;
d1336 1
a1336 1
        {
@


1.48
log
@	* fhandler.cc (fhandler_base::open): Remove special DEV_FLOPPY_MAJOR
	treatment.
	* fhandler_raw.cc (fhandler_dev_raw::open): Simplify write-only case.
	* fhandler_tape.cc (fhandler_dev_tape::raw_write): Add accidentally
	dropped condition.
@
text
@a1171 1
HANDLE mt_h;
d1177 2
a1178 1
  mt = (mtinfo *) open_shared ("mtinfo", MTINFO_VERSION, mt_h, sizeof (mtinfo), SH_MTINFO);
@


1.47
log
@	* errno.cc (errmap): Handle ERROR_IO_PENDING.
	* fhandler.cc (fhandler_base::open): Make tape I/O asynchronous.
	* fhandler.h (class fhandler_dev_tape): Add mt_evt member.
	* fhandler_tape.cc (mtinfo_drive::initialize): Initialize async_writes.
	(mtinfo_drive::close): Handle async writes.
	(mtinfo_drive::read): Add mt_evt parameter.  Use overlapped I/O.
	(mtinfo_drive::async_wait): New function.
	(mtinfo_drive::write): Add mt_evt parameter.  Use overlapped I/O.
	Handle async writes.
	(mtinfo_drive::_set_pos): Handle async writes.
	(mtinfo_drive::set_partition): Ditto.
	(mtinfo_drive::prepare): Ditto.
	(mtinfo_drive::get_status): Drop useless "else".  Handle async_writes
	flag.
	(mtinfo_drive::set_options): Handle async_writes flags.
	(fhandler_dev_tape::close): Close mt_evt handle.
	(fhandler_dev_tape::raw_read): Create mt_evt handle and use in call
	to mtinfo_drive::read.
	(fhandler_dev_tape::raw_write): Create mt_evt handle and use in call
	to mtinfo_drive::write.
	* mtinfo.h (MTINFO_VERSION): Bump.
	(enum dirty_state): Add async_write_pending state.
	(class mtinfo_drive): Add OVERLAPPED struct "ov".  Add async_writes
	flag.
	(mtinfo_drive::async_wait): Add declaration.
	(mtinfo_drive::read): Add mt_evt parameter.
	(mtinfo_drive::write): Ditto.

	* registry.cc (load_registry_hive): Call enable_restore_privilege
	instead of set_process_privilege.
@
text
@d1367 1
@


1.46
log
@	* fhandler_tape.cc (mtinfo_drive::_set_pos): Take additional dont_wait
	parameter.  Use in call to SetTapePosition.
	(mtinfo_drive::set_pos): Accomodate _set_pos calls to above change.
	(mtinfo_drive::set_partition): Ditto.
	* mtinfo.h (mtinfo_drive::_set_pos): Change declaration accordingly.
@
text
@d84 1
d139 1
a139 1
  if (dirty == has_written)
d141 4
a144 4
      /* if last operation was writing, write a filemark */
      debug_printf ("writing filemark");
      write_marks (mt, TAPE_FILEMARKS, two_fm () ? 2 : 1);
      if (two_fm () && !lasterr && !rewind) /* Backspace over 2nd filemark. */
d146 9
a154 3
	  set_pos (mt, TAPE_SPACE_FILEMARKS, -1, false);
	  if (!lasterr)
	    part (partition)->fblock = 0; /* That's obvious, isn't it? */
d189 1
a189 1
mtinfo_drive::read (HANDLE mt, void *ptr, size_t &ulen)
d201 3
d238 3
a240 1
  ret = ReadFile (mt, ptr, ulen, &bytes_read, 0);
d242 2
d290 12
a301 1
mtinfo_drive::write (HANDLE mt, const void *ptr, size_t &len)
d305 1
d314 2
d320 3
a322 1
  ret = WriteFile (mt, ptr, len, &bytes_written, 0);
d324 8
d342 2
d353 2
d389 4
a394 1
  dirty = clean;
d623 6
d693 3
d838 1
a838 1
  else if (tstat == ERROR_DEVICE_REQUIRES_CLEANING)
d860 2
d901 1
d922 2
d1259 2
d1309 2
d1316 2
a1317 1
	  ret = mt->drive (driveno ())->read (get_handle (), buf, block_fit);
d1338 1
a1338 1
	  ret = mt->drive (driveno ())->read (get_handle (), devbuf,
d1364 3
a1366 1
  int ret = mt->drive (driveno ())->write (get_handle (), ptr, len);
@


1.45
log
@	* fhandler.h (class fhandler_dev_raw): Move status bits into protected
	bitfield struct type status_flags.  Drop unused has_written bit.
	Add accessor methods.
	(fhandler_dev_raw::clear): Remove.
	(fhandler_dev_raw::reset_devbuf): Remove.
	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Use accessor method
	for is_writing.
	* fhandler_raw.cc: Use status accessor methods throughout.
	(fhandler_dev_raw::clear): Remove.
	(fhandler_dev_raw::fhandler_dev_raw): Drop clear call.
	(fhandler_dev_raw::~fhandler_dev_raw): Ditto.
	* fhandler_tape.cc: Use mtinfo::status accessor methods throughout.
	(mtinfo_drive::close): Fix conditional to enable BSD semantics
	correctly.
	(mtinfo_drive::get_status): Rename from mtinfo_drive::status.
	* mtinfo.h (class mtinfo_drive): Move status bits into private bitfield
	struct type status_flags.  Add accessor methods.
	Rename status method to get_status.
@
text
@d344 2
a345 2
mtinfo_drive::_set_pos (HANDLE mt, int mode, long count,
			int partition)
d347 2
a348 2
  TAPE_FUNC (SetTapePosition (mt, mode, partition, count,
			      count < 0 ? -1 : 0, FALSE));
d381 1
a381 1
	if (!(err = _set_pos (mt, mode, 1, 0)) || IS_SM (err))
d384 1
a384 1
	if (!(err = _set_pos (mt, mode, -1, 0)) || IS_SM (err))
d388 1
a388 1
    err = _set_pos (mt, mode, count, dont_wait);
d549 1
a549 1
      int err = _set_pos (mt, TAPE_LOGICAL_BLOCK, part_block, count + 1);
@


1.44
log
@	* fhandler_tape.cc (mtinfo::initialize): Fix fatal error message.
@
text
@d83 6
a88 6
      buffer_writes = true;
      two_fm = false;
      fast_eom = false;
      auto_lock = false;
      sysv = false;
      nowait = false;
d142 2
a143 2
      write_marks (mt, TAPE_FILEMARKS, two_fm ? 2 : 1);
      if (two_fm && !lasterr && !rewind) /* Backspace over the 2nd filemark. */
d150 1
a150 1
  else if (dirty == has_read && sysv && !rewind)
d152 1
a152 1
      if (sysv)
d175 1
a175 1
  if (auto_lock && lock == auto_locked)
d226 1
a226 1
  if (auto_lock && lock < auto_locked)
d290 1
a290 1
  if (auto_lock && lock < auto_locked)
d375 1
a375 1
        dont_wait = nowait ? TRUE : FALSE;
d632 1
a632 1
  TAPE_FUNC (EraseTape (mt, mode, nowait ? TRUE : FALSE));
d644 1
a644 1
    dont_wait = nowait ? TRUE : FALSE;
d699 1
a699 1
mtinfo_drive::status (HANDLE mt, struct mtget *get)
d781 1
a781 1
  if (buffer_writes)
d796 1
a796 1
  if (two_fm)
d798 1
a798 1
  if (fast_eom)
d800 1
a800 1
  if (auto_lock)
d802 1
a802 1
  if (sysv)
d804 1
a804 1
  if (nowait)
d840 1
a840 1
	    buffer_writes = (options == 1);
d844 6
a849 6
	buffer_writes = !!(options & MT_ST_BUFFER_WRITES);
	two_fm = !!(options & MT_ST_TWO_FM);
	fast_eom = !!(options & MT_ST_FAST_MTEOM);
	auto_lock = !!(options & MT_ST_AUTO_LOCK);
	sysv = !!(options & MT_ST_SYSV);
	nowait = !!(options & MT_ST_NOWAIT);
d864 1
a864 1
	  buffer_writes = set;
d866 1
a866 1
	  two_fm = set;
d868 1
a868 1
	  fast_eom = set;
d870 1
a870 1
	  auto_lock = set;
d872 1
a872 1
	  sysv = set;
d874 1
a874 1
	  nowait = set;
d977 1
a977 1
	    if (fast_eom && get_feature (TAPE_DRIVE_END_OF_DATA))
d1065 1
a1065 1
      status (mt, (struct mtget *) buf);
d1172 1
a1172 1
  if (!mt->drive (driveno ())->buffered_writes ())
d1216 1
a1216 1
  if (lastblk_to_read)
d1218 1
a1218 1
      lastblk_to_read = 0;
d1268 1
a1268 1
	      lastblk_to_read = 1;
d1286 1
a1286 1
	    lastblk_to_read = 1;
@


1.43
log
@	* fhandler_tape.cc (mtinfo_drive::get_pos): Only set partition if
	GetTapePosition returned a non-zero partition number.
	(mtinfo_drive::create_partitions): Reinitialize to partition 0.
	Support TAPE_DRIVE_INITIATOR and TAPE_DRIVE_FIXED partitioning.
	(mtinfo_drive::set_partition): Initialize new partition.
	(mtinfo_drive::status): Readd accidentally dropped setting of mt_resid.

	* net.cc (wsock_event::prepare): Always print debug output in case
	of error.
@
text
@d1089 1
a1089 1
    api_fatal ("CreateMutex '%s'(%p), %E.  Terminating.", name);
@


1.42
log
@	* errno.cc (errmap): Map ERROR_SHARING_VIOLATION to EBUSY,
	ERROR_EOM_OVERFLOW and ERROR_NO_DATA_DETECTED to EIO.  Add mappings
	for ERROR_NO_MEDIA_IN_DRIVE, ERROR_DEVICE_REQUIRES_CLEANING and
	ERROR_DEVICE_DOOR_OPEN.
	* fhandler.h (class fhandler_dev_raw): Drop varblkop member.
	(fhandler_dev_raw::is_eom): De-virtualize.
	(fhandler_dev_raw::is_eof): Ditto.
	(class fhandler_dev_tape): Drop lasterr and dp member.  Add mt_mtx
	member.  Drop all private methods formerly used by ioctl.
	(fhandler_dev_tape::is_rewind_device): Use get_minor for clarity.
	(fhandler_dev_tape::driveno): New method.
	(fhandler_dev_tape::drive_init): New method.
	(fhandler_dev_tape::clear): Remove method.
	(fhandler_dev_tape::is_eom): Ditto.
	(fhandler_dev_tape::is_eof): Ditto.
	(fhandler_dev_tape::write_file): Ditto.
	(fhandler_dev_tape::read_file): Ditto.
	(fhandler_dev_tape::_lock): New method.
	(fhandler_dev_tape::unlock): New method.
	(fhandler_dev_tape::raw_read): New method.
	(fhandler_dev_tape::raw_write): New method.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): New method.
	(fhandler_dev_raw::is_eof): New method.
	(fhandler_dev_raw::open): Allow setting write through option by
	using the O_TEXT flag as ... flag.
	(fhandler_dev_raw::writebuf): Remove usage of varblkop and other
	tape specific code.
	(fhandler_dev_raw::raw_read): Ditto.
	(fhandler_dev_raw::dup): Ditto.
	* fhandler_tape.cc: Rewrite tape operations entirely.  Implement
	new tape driver classes mtinfo, mtinfo_drive and mtinfo_part.
	Reduce fhandler_dev_tape methods to mostly just calling appropriate
	mtinfo_drive methods.
	(mtinfo_init): New function adding the mtinfo shared memory area.
	* mtinfo.h: New file, containing the definition of the new tape
	driver classes.
	* shared.cc: Include mtinfo.h.
	(offsets): Add entry for mtinfo shared memory area.
	(memory_init): Call mtinfo_init.
	* shared_info.h (shared_locations): Add SH_MTINFO shared location.
	* include/cygwin/mtio.h: Change and add various comments.  Add GMT_xxx
	macros for new generic flags.  Add MT_ST_xxx bitfield definitions
	for MTSETDRVBUFFER ioctl.
	* include/cygwin/version.h: Bump API minor version number.
@
text
@d327 2
a328 1
      partition = (long) (p > 0 ? p - 1 : p);
d515 2
d518 17
a534 2
  TAPE_FUNC (CreateTapePartition (mt, TAPE_SELECT_PARTITIONS,
				  count <= 0 ? 1 : 2, 0));
d566 5
a570 1
	partition = count;
d752 1
@


1.41
log
@	Fix ChangeLog dates.

	* fhandler.h (fhandler_dev_tape::tape_get_pos): Declare with extra
	parameter for partition number.
	(fhandler_dev_tape::_tape_set_pos): Ditto.
	(fhandler_dev_tape::tape_partition): New method.
	(fhandler_dev_tape::tape_set_partition): New method.
	* fhandler_tape.cc (fhandler_dev_tape::open): Call private methods
	directly instead of ioctl.
	(fhandler_dev_tape::ioctl): Use long erase on MTERASE by default.
	Don't use absolute positioning on MTSEEK.  Call tape_set_partition
	on MTSETPART, tape_partition on MTMKPART.
	(fhandler_dev_tape::tape_get_pos): Add partition number parameter.
	Prefer logical position information over absolute position information.
	Return partition number.
	(fhandler_dev_tape::_tape_set_pos): Add partition number parameter.
	Use in SetTapePosition.
	(fhandler_dev_tape::tape_set_pos): Remove special TAPE_ABSOLUTE_BLOCK
	handling.
	(fhandler_dev_tape::tape_erase): Rewind before erasing.
	(fhandler_dev_tape::tape_status): Rearrange slightly. Try to get a
	MediaType even if no tape is loaded. Store active partition in
	mt_resid as on Linux.
	(fhandler_dev_tape::tape_partition): New method.
	(fhandler_dev_tape::tape_set_partition): New method.
	* include/cygwin/mtio.h: Fix copyright. Add comment to explain
	mt_resid content.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d17 1
d26 3
d33 5
a37 8
/* FIXME: Note that this is wrong!  The correct behaviour after getting
   an ERROR_BUS_RESET is to raise a flag and then to block any access,
   except for MTREW, MTOFFL, MT_RETEN, MTERASE, MTSEEK and MTEOM, and
   to set errno to EIO in all other cases. */
#define TAPE_FUNC(func) do { \
			  lasterr = (func); \
			} while (lasterr == ERROR_MEDIA_CHANGED \
				 || lasterr == ERROR_BUS_RESET)
d42 8
a49 1
#define IS_EOM(err) ((err) == ERROR_END_OF_MEDIA \
d53 17
a69 2
#define IS_EOF(err) ((err) == ERROR_FILEMARK_DETECTED \
		     || (err) == ERROR_SETMARK_DETECTED)
d72 1
a72 1
/* fhandler_dev_tape */
d75 1
a75 1
fhandler_dev_tape::clear (void)
d77 31
a107 2
  lasterr = 0;
  fhandler_dev_raw::clear ();
d111 1
a111 1
fhandler_dev_tape::is_eom (int win_error)
d113 17
a129 4
  int ret = IS_EOM (win_error);
  if (ret)
    debug_printf ("end of medium");
  return ret;
d133 1
a133 1
fhandler_dev_tape::is_eof (int win_error)
d135 44
a178 4
  int ret = IS_EOF (win_error);
  if (ret)
    debug_printf ("end of file");
  return ret;
d181 2
a182 3
BOOL
fhandler_dev_tape::write_file (const void *buf, DWORD to_write,
			       DWORD *written, int *err)
d185 1
d187 75
a261 1
  do
d263 10
a272 8
      *err = 0;
      if (!(ret = WriteFile (get_handle (), buf, to_write, written, 0)))
	*err = GetLastError ();
    }
  while (*err == ERROR_MEDIA_CHANGED || *err == ERROR_BUS_RESET);
  syscall_printf ("%d (err %d) = WriteFile (%d, %d, write %d, written %d, 0)",
		  ret, *err, get_handle (), buf, to_write, *written);
  return ret;
d275 2
a276 2
BOOL
fhandler_dev_tape::read_file (void *buf, DWORD to_read, DWORD *read, int *err)
d279 1
d281 28
a308 1
  do
d310 5
a314 8
      *err = 0;
      if (!(ret = ReadFile (get_handle (), buf, to_read, read, 0)))
	*err = GetLastError ();
    }
  while (*err == ERROR_MEDIA_CHANGED || *err == ERROR_BUS_RESET);
  syscall_printf ("%d (err %d) = ReadFile (%d, %d, to_read %d, read %d, 0)",
		  ret, *err, get_handle (), buf, to_read, *read);
  return ret;
d317 2
a318 2
fhandler_dev_tape::fhandler_dev_tape ()
  : fhandler_dev_raw ()
d320 20
a339 1
  debug_printf ("unit: %d", dev ().minor);
d343 2
a344 1
fhandler_dev_tape::open (int flags, mode_t)
d346 5
a350 1
  int ret;
d352 7
a358 1
  devbufsiz = 1L;
d360 29
a388 2
  ret = fhandler_dev_raw::open (flags);
  if (ret)
d390 116
a505 3
      DWORD varlen;
      struct mtget get;
      unsigned long block;
d507 13
a519 2
      TAPE_FUNC (GetTapeParameters (get_handle (), GET_TAPE_DRIVE_INFORMATION,
				    (varlen = sizeof dp, &varlen), &dp));
d521 12
a532 21
      if (!tape_status (&get))
        {
	  long blksize = (get.mt_dsreg & MT_ST_BLKSIZE_MASK)
	  		 >> MT_ST_BLKSIZE_SHIFT;
	  /* Tape drive supports and is set to variable block size. */
	  if (blksize == 0)
	    devbufsiz = get.mt_maxblksize;
	  else
	    devbufsiz = blksize;
	  varblkop = blksize == 0;
	}

      if (devbufsiz > 1L)
	devbuf = new char [devbufsiz];

      /* The following rewind in position 0 solves a problem which appears
       * in case of multi volume archives: The last ReadFile on first medium
       * returns ERROR_NO_DATA_DETECTED. After media change, all subsequent
       * ReadFile calls return ERROR_NO_DATA_DETECTED, too.
       * The call to tape_set_pos seems to reset some internal flags. */
      if (!tape_get_pos (&block) && !block)
d534 12
a545 2
	  debug_printf ("rewinding");
	  tape_set_pos (TAPE_REWIND, 0);
d547 5
d553 31
a583 1
      if (flags & O_APPEND)
d585 3
a587 2
	  /* In append mode, seek to beginning of next filemark */
	  tape_set_pos (TAPE_SPACE_FILEMARKS, 1, true);
d589 3
d593 1
a593 2

  return ret;
d597 1
a597 1
fhandler_dev_tape::close (void)
d599 1
a599 4
  struct mtop op;
  int ret = 0;

  if (is_writing)
d601 8
a608 9
      ret = writebuf ();
      if (has_written && !eom_detected)
	{
	  /* if last operation was writing, write a filemark */
	  debug_printf ("writing filemark");
	  op.mt_op = MTWEOF;
	  op.mt_count = 1;
	  ioctl (MTIOCTOP, &op);
	}
d610 4
d615 4
a618 2
  // To protected reads on signaling (e.g. Ctrl-C)
  eof_detected = 1;
d620 6
a625 1
  if (is_rewind_device ())
d627 14
a640 2
      debug_printf ("rewinding");
      tape_set_pos (TAPE_REWIND, 0);
d642 2
d645 6
a650 1
  if (ret)
d652 15
a666 3
      fhandler_dev_raw::close ();
      return ret;
    }
d668 6
a673 1
  return fhandler_dev_raw::close ();
d677 1
a677 1
fhandler_dev_tape::fstat (struct __stat64 *buf)
d679 2
a680 1
  int ret;
d682 2
a683 3
  if (!(ret = fhandler_base::fstat (buf)))
    {
      struct mtget get;
d685 2
a686 3
      if (!ioctl (MTIOCGET, &get))
	buf->st_blocks = get.mt_capacity / buf->st_blksize;
    }
d688 1
a688 2
  return ret;
}
d690 1
a690 5
_off64_t
fhandler_dev_tape::lseek (_off64_t offset, int whence)
{
  struct mtop op;
  struct mtpos pos;
d692 6
a697 1
  debug_printf ("lseek (%s, %d, %d)", get_name (), offset, whence);
d699 1
a699 3
  writebuf ();

  if (ioctl (MTIOCPOS, &pos))
d701 25
a725 1
      return ILLEGAL_SEEK;
d728 1
a728 1
  switch (whence)
d730 27
a756 19
      case SEEK_END:
	op.mt_op = MTFSF;
	op.mt_count = 1;
	if (ioctl (MTIOCTOP, &op))
	  return -1;
	break;
      case SEEK_SET:
	if (whence == SEEK_SET && offset < 0)
	  {
	    set_errno (EINVAL);
	    return -1;
	  }
	break;
      case SEEK_CUR:
	break;
      default:
	set_errno (EINVAL);
	return -1;
    }
d758 2
a759 3
  op.mt_op = MTFSR;
  op.mt_count = offset / devbufsiz
		- (whence == SEEK_SET ? pos.mt_blkno : 0);
d761 2
a762 5
  if (op.mt_count < 0)
    {
      op.mt_op = MTBSR;
      op.mt_count = -op.mt_count;
    }
d764 28
a791 2
  if (ioctl (MTIOCTOP, &op) || ioctl (MTIOCPOS, &pos))
    return -1;
d793 1
a793 1
  return (pos.mt_blkno * devbufsiz);
d797 1
a797 1
fhandler_dev_tape::dup (fhandler_base *child)
d799 11
a809 1
  fhandler_dev_tape *fhc = (fhandler_dev_tape *) child;
d811 75
a885 3
  fhc->lasterr = lasterr;
  fhc->dp = dp;
  return fhandler_dev_raw::dup (child);
d889 1
a889 1
fhandler_dev_tape::ioctl (unsigned int cmd, void *buf)
a890 3
  int ret = NO_ERROR;
  unsigned long block;

d893 2
d896 18
a913 6

      if (!op)
	ret = ERROR_INVALID_PARAMETER;
      else
	switch (op->mt_op)
	  {
d917 1
a917 1
	    ret = tape_set_pos (TAPE_SPACE_FILEMARKS, op->mt_count);
d920 1
a920 1
	    ret = tape_set_pos (TAPE_SPACE_FILEMARKS, -op->mt_count);
d923 1
a923 1
	    ret = tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS, op->mt_count);
d926 1
a926 1
	    ret = tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS, -op->mt_count);
d929 1
a929 6
	    if (tape_get_feature (TAPE_DRIVE_WRITE_FILEMARKS))
	      ret = tape_write_marks (TAPE_FILEMARKS, op->mt_count);
	    else if (tape_get_feature (TAPE_DRIVE_WRITE_LONG_FMKS))
	      ret = tape_write_marks (TAPE_LONG_FILEMARKS, op->mt_count);
	    else
	      ret = tape_write_marks (TAPE_SHORT_FILEMARKS, op->mt_count);
d932 1
a932 1
	    ret = tape_set_pos (TAPE_REWIND, 0);
d936 1
a936 1
	    ret = tape_prepare (TAPE_UNLOAD);
d939 1
a939 1
	    reset_devbuf ();
d942 4
a945 4
	    if (!tape_get_feature (TAPE_DRIVE_END_OF_DATA))
	      ret = ERROR_INVALID_PARAMETER;
	    else if (!(ret = tape_set_pos (TAPE_REWIND, 0, false)))
	      ret = tape_prepare (TAPE_TENSION);
d948 1
a948 1
	    ret = tape_set_pos (TAPE_SPACE_FILEMARKS, -op->mt_count, true);
d951 1
a951 1
	    ret = tape_set_pos (TAPE_SPACE_FILEMARKS, op->mt_count, true);
d954 2
a955 2
	    if (tape_get_feature (TAPE_DRIVE_END_OF_DATA))
	      ret = tape_set_pos (TAPE_SPACE_END_OF_DATA, 0);
d957 1
a957 1
	      ret = tape_set_pos (TAPE_SPACE_FILEMARKS, 32767);
d960 1
a960 1
	    ret = tape_erase (TAPE_ERASE_LONG);
d965 1
a965 1
	    ret = ERROR_INVALID_PARAMETER;
d968 1
a968 1
	    if (!tape_get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
d970 1
a970 1
		ret = ERROR_INVALID_PARAMETER;
d973 1
a973 2
	    if ((devbuf && (size_t) op->mt_count == devbufsiz)
		|| (!devbuf && op->mt_count == 0))
d976 1
a976 1
		ret = 0;
d979 1
a979 2
	    if ((op->mt_count == 0
		 && !tape_get_feature (TAPE_DRIVE_VARIABLE_BLOCK))
d981 2
a982 2
		    && ((DWORD) op->mt_count < dp.MinimumBlockSize
			|| (DWORD) op->mt_count > dp.MaximumBlockSize)))
d984 1
a984 1
		ret = ERROR_INVALID_PARAMETER;
d987 3
a989 32
	    if (devbuf && devbufend - devbufstart > 0
		&& (op->mt_count == 0
		    || (op->mt_count > 0
			&& (size_t) op->mt_count < devbufend - devbufstart)))
	      {
		/* Not allowed if still data in devbuf. */
		ret = ERROR_INVALID_BLOCK_LENGTH; /* EIO */
		break;
	      }
	    if (!(ret = tape_set_blocksize (op->mt_count)))
	      {
		char *buf = NULL;
		if (op->mt_count > 1L && !(buf = new char [op->mt_count]))
		  {
		    ret = ERROR_OUTOFMEMORY;
		    break;
		  }
		if (devbufsiz > 1L && op->mt_count > 1L)
		  {
		    memcpy (buf, devbuf + devbufstart,
			    devbufend - devbufstart);
		    devbufend -= devbufstart;
		  }
		else
		  devbufend = 0;
		devbufstart = 0;
		delete [] devbuf;
		devbuf = buf;
		devbufsiz = op->mt_count;
		varblkop = op->mt_count == 0;
	      }
	    reset_devbuf ();
d992 5
a996 5
	    if (tape_get_feature (TAPE_DRIVE_LOGICAL_BLK))
	      ret = tape_set_pos (TAPE_LOGICAL_BLOCK, op->mt_count);
	    else if (!(ret = tape_get_pos (&block)))
	      ret = tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS,
				  op->mt_count - block);
d999 1
a999 1
	    if (!(ret = tape_get_pos (&block)))
d1003 1
a1003 1
	    ret = tape_set_pos (TAPE_SPACE_SETMARKS, op->mt_count);
d1006 1
a1006 1
	    ret = tape_set_pos (TAPE_SPACE_SETMARKS, -op->mt_count);
d1009 1
a1009 2
	    ret = tape_write_marks (TAPE_SETMARKS, op->mt_count);
	    reset_devbuf ();
d1012 1
a1012 1
	    ret = tape_prepare (TAPE_LOCK);
d1015 1
a1015 1
	    ret = tape_prepare (TAPE_UNLOCK);
d1018 1
a1018 1
	    ret = tape_prepare (TAPE_LOAD);
d1021 1
a1021 1
	    ret = tape_compression (op->mt_count);
d1024 1
a1024 2
	    ret = tape_set_partition (op->mt_count);
	    reset_devbuf ();
d1027 4
a1030 2
	    ret = tape_partition (op->mt_count);
	    reset_devbuf ();
a1032 2
	  case MTSETDRVBUFFER:
	    reset_devbuf ();
d1034 1
a1034 1
	    ret = ERROR_INVALID_PARAMETER;
d1036 1
a1036 1
	  }
d1039 5
a1043 1
    ret = tape_status ((struct mtget *) buf);
d1046 3
a1048 2
      ret = ERROR_INVALID_PARAMETER;
      if (buf && (ret = tape_get_pos (&block)))
a1050 2
  else
    return fhandler_dev_raw::ioctl (cmd, buf);
d1052 1
a1052 8
  if (ret != NO_ERROR)
    {
      SetLastError (ret);
      __seterrno ();
      return -1;
    }

  return 0;
d1055 2
a1056 3
/* ------------------------------------------------------------------ */
/*                  Private functions used by `ioctl'                 */
/* ------------------------------------------------------------------ */
d1058 2
a1059 2
int
fhandler_dev_tape::tape_error (const char *txt)
d1061 27
a1087 3
  if (lasterr)
    debug_printf ("%s: error: %d", txt, lasterr);
  return lasterr;
d1090 5
a1094 2
int
fhandler_dev_tape::tape_write_marks (int marktype, DWORD len)
d1096 2
a1097 3
  syscall_printf ("write_tapemark");
  TAPE_FUNC (WriteTapemark (get_handle (), marktype, len, FALSE));
  return tape_error ("tape_write_marks");
d1100 2
a1101 5
int
fhandler_dev_tape::tape_get_pos (unsigned long *block,
				 unsigned long *partition)
{
  DWORD part, low, high;
d1103 1
a1103 7
  lasterr = ERROR_INVALID_PARAMETER;
  if (tape_get_feature (TAPE_DRIVE_GET_LOGICAL_BLK))
    TAPE_FUNC (GetTapePosition (get_handle (), TAPE_LOGICAL_POSITION,
				&part, &low, &high));
  else if (tape_get_feature (TAPE_DRIVE_GET_ABSOLUTE_BLK))
    TAPE_FUNC (GetTapePosition (get_handle (), TAPE_ABSOLUTE_POSITION,
				&part, &low, &high));
d1105 6
a1110 1
  if (!tape_error ("tape_get_pos"))
d1112 2
a1113 4
      if (block)
	*block = low;
      if (partition)
        *partition = part > 0 ? part - 1 : part;
d1115 2
d1118 5
a1122 1
  return lasterr;
d1125 2
a1126 2
int
fhandler_dev_tape::_tape_set_pos (int mode, long count, int partition)
d1128 1
a1128 10
  TAPE_FUNC (SetTapePosition (get_handle (), mode, partition, count,
			      count < 0 ? -1 : 0, FALSE));
  /* Reset buffer after successful repositioning. */
  if (!lasterr || IS_EOF (lasterr) || IS_EOM (lasterr))
    {
      reset_devbuf ();
      eof_detected = IS_EOF (lasterr);
      eom_detected = IS_EOM (lasterr);
    }
  return lasterr;
d1132 1
a1132 1
fhandler_dev_tape::tape_set_pos (int mode, long count, bool sfm_func)
d1134 3
a1136 1
  switch (mode)
d1138 2
a1139 8
      case TAPE_SPACE_RELATIVE_BLOCKS:
      case TAPE_SPACE_FILEMARKS:
        if (!count)
	  {
	    lasterr = 0;
	    return tape_error ("tape_set_pos");
	  }
	break;
d1141 1
a1141 2
  _tape_set_pos (mode, count);
  switch (mode)
d1143 2
a1144 4
      case TAPE_SPACE_FILEMARKS:
	if (!lasterr && sfm_func)
	  return tape_set_pos (mode, count > 0 ? -1 : 1, false);
	break;
d1146 14
a1159 2
  return tape_error ("tape_set_pos");
}
d1161 3
a1163 15
int
fhandler_dev_tape::tape_erase (int mode)
{
  if (tape_set_pos (TAPE_REWIND, 0))
    return lasterr;
  switch (mode)
    {
      case TAPE_ERASE_SHORT:
	if (!tape_get_feature (TAPE_DRIVE_ERASE_SHORT))
	  mode = TAPE_ERASE_LONG;
	break;
      case TAPE_ERASE_LONG:
	if (!tape_get_feature (TAPE_DRIVE_ERASE_LONG))
	  mode = TAPE_ERASE_SHORT;
	break;
d1165 3
a1167 5
  TAPE_FUNC (EraseTape (get_handle (), mode, false));
  /* Reset buffer after successful tape erasing. */
  if (!lasterr)
    reset_devbuf ();
  return tape_error ("tape_erase");
d1171 1
a1171 1
fhandler_dev_tape::tape_prepare (int action)
d1173 1
a1173 6
  TAPE_FUNC (PrepareTape (get_handle (), action, FALSE));
  /* Reset buffer after all successful preparations but lock and unlock. */
  if (!lasterr && action != TAPE_LOCK && action != TAPE_UNLOCK)
    reset_devbuf ();
  return tape_error ("tape_prepare");
}
d1175 6
a1180 9
int
fhandler_dev_tape::tape_set_blocksize (long count)
{
  TAPE_SET_MEDIA_PARAMETERS mp;

  mp.BlockSize = count;
  TAPE_FUNC (SetTapeParameters (get_handle (), SET_TAPE_MEDIA_INFORMATION,
  				&mp));
  return tape_error ("tape_set_blocksize");
d1183 2
a1184 2
int
fhandler_dev_tape::tape_status (struct mtget *get)
d1186 6
a1191 3
  DWORD varlen;
  TAPE_GET_MEDIA_PARAMETERS mp;
  int notape = 0;
d1193 31
a1223 23
  if (!get)
    return ERROR_INVALID_PARAMETER;

  /* Setting varlen to sizeof DP is by intention, actually!  Never set
     it to sizeof MP which seems to be more correct but results in a
     ERROR_MORE_DATA error at least on W2K. */
  TAPE_FUNC (GetTapeParameters (get_handle (), GET_TAPE_MEDIA_INFORMATION,
				(varlen = sizeof dp, &varlen), &mp));
  if (lasterr)
    notape = 1;

  memset (get, 0, sizeof *get);

  get->mt_type = MT_ISUNKNOWN;

  if (!notape && tape_get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
    get->mt_dsreg = (mp.BlockSize << MT_ST_BLKSIZE_SHIFT)
		    & MT_ST_BLKSIZE_MASK;
  else
    get->mt_dsreg = (dp.DefaultBlockSize << MT_ST_BLKSIZE_SHIFT)
		    & MT_ST_BLKSIZE_MASK;

  if (wincap.has_ioctl_storage_get_media_types_ex ())
d1225 31
a1255 8
      DWORD size = sizeof (GET_MEDIA_TYPES) + 10 * sizeof (DEVICE_MEDIA_INFO);
      void *buf = alloca (size);
      if (DeviceIoControl (get_handle (), IOCTL_STORAGE_GET_MEDIA_TYPES_EX,
			   NULL, 0, buf, size, &size, NULL)
	  || GetLastError () == ERROR_MORE_DATA)
	{
	  PGET_MEDIA_TYPES gmt = (PGET_MEDIA_TYPES) buf;
	  for (DWORD i = 0; i < gmt->MediaInfoCount; ++i)
d1257 4
a1260 14
	      PDEVICE_MEDIA_INFO dmi = &gmt->MediaInfo[i];
	      get->mt_type = dmi->DeviceSpecific.TapeInfo.MediaType;
#define TINFO DeviceSpecific.TapeInfo
	      if (dmi->TINFO.MediaCharacteristics & MEDIA_CURRENTLY_MOUNTED)
		{
		  get->mt_type = dmi->DeviceSpecific.TapeInfo.MediaType;
		  if (dmi->TINFO.BusType == BusTypeScsi)
		    get->mt_dsreg |=
		      (dmi->TINFO.BusSpecificData.ScsiInformation.DensityCode
		       << MT_ST_DENSITY_SHIFT)
		      & MT_ST_DENSITY_MASK;
		  break;
		}
#undef TINFO
d1262 2
d1266 6
a1271 2
  if (notape)
    get->mt_gstat |= GMT_DR_OPEN (-1);
d1273 8
a1280 6
  if (!notape)
    {
      if (tape_get_feature (TAPE_DRIVE_GET_LOGICAL_BLK)
          || tape_get_feature (TAPE_DRIVE_GET_ABSOLUTE_BLK))
	tape_get_pos ((unsigned long *) &get->mt_blkno,
		      (unsigned long *) &get->mt_resid);
d1282 7
a1288 2
      if (!get->mt_blkno)
	get->mt_gstat |= GMT_BOT (-1);
d1290 1
a1290 1
      get->mt_gstat |= GMT_ONLINE (-1);
d1292 1
a1292 2
      if (tape_get_feature (TAPE_DRIVE_WRITE_PROTECT) && mp.WriteProtected)
	get->mt_gstat |= GMT_WR_PROT (-1);
d1294 5
a1298 5
      if (tape_get_feature (TAPE_DRIVE_TAPE_CAPACITY))
	get->mt_capacity = get_ll (mp.Capacity);

      if (tape_get_feature (TAPE_DRIVE_TAPE_REMAINING))
	  get->mt_remaining = get_ll (mp.Remaining);
d1301 2
a1302 2
  if (tape_get_feature (TAPE_DRIVE_COMPRESSION) && dp.Compression)
    get->mt_gstat |= GMT_HW_COMP (-1);
d1304 21
a1324 2
  if (tape_get_feature (TAPE_DRIVE_ECC) && dp.ECC)
    get->mt_gstat |= GMT_HW_ECC (-1);
d1326 3
a1328 2
  if (tape_get_feature (TAPE_DRIVE_PADDING) && dp.DataPadding)
    get->mt_gstat |= GMT_PADDING (-1);
d1330 5
a1334 2
  if (tape_get_feature (TAPE_DRIVE_REPORT_SMKS) && dp.ReportSetmarks)
    get->mt_gstat |= GMT_IM_REP_EN (-1);
d1336 2
a1337 1
  get->mt_erreg = lasterr;
d1339 1
a1339 6
  get->mt_minblksize = dp.MinimumBlockSize;
  get->mt_maxblksize = dp.MaximumBlockSize;
  get->mt_defblksize = dp.DefaultBlockSize;
  get->mt_featureslow = dp.FeaturesLow;
  get->mt_featureshigh = dp.FeaturesHigh;
  get->mt_eotwarningzonesize = dp.EOTWarningZoneSize;
d1341 2
a1342 1
  return 0;
d1346 1
a1346 1
fhandler_dev_tape::tape_compression (long count)
d1348 1
a1348 1
  TAPE_SET_DRIVE_PARAMETERS dps;
d1350 8
a1357 13
  if (!tape_get_feature (TAPE_DRIVE_COMPRESSION))
    return ERROR_INVALID_PARAMETER;

  dps.ECC = dp.ECC;
  dps.Compression = count ? TRUE : FALSE;
  dps.DataPadding = dp.DataPadding;
  dps.ReportSetmarks = dp.ReportSetmarks;
  dps.EOTWarningZoneSize = dp.EOTWarningZoneSize;
  TAPE_FUNC (SetTapeParameters (get_handle (), SET_TAPE_DRIVE_INFORMATION,
				&dps));
  if (!lasterr)
    dp.Compression = dps.Compression;
  return tape_error ("tape_compression");
d1361 1
a1361 1
fhandler_dev_tape::tape_partition (long count)
d1363 2
a1364 11
  if (dp.MaximumPartitionCount <= 1)
    return ERROR_INVALID_PARAMETER;
  if (tape_set_pos (TAPE_REWIND, 0))
    return lasterr;
  if (count <= 0)
    debug_printf ("Formatting tape with one partition");
  else
    debug_printf ("Formatting tape with two partitions");
  TAPE_FUNC (CreateTapePartition (get_handle (), TAPE_SELECT_PARTITIONS,
				   count <= 0 ? 1 : 2, 0));
  return tape_error ("tape_partition");
d1368 1
a1368 1
fhandler_dev_tape::tape_set_partition (long count)
d1370 10
a1379 5
  if (count < 0 || (unsigned long) count >= dp.MaximumPartitionCount)
    lasterr = ERROR_INVALID_PARAMETER;
  else
    lasterr = _tape_set_pos (TAPE_LOGICAL_BLOCK, 0, count + 1);
  return tape_error ("tape_set_partition");
@


1.40
log
@	* errno.cc (errmap): Map ERROR_BEGINNING_OF_MEDIA and
	ERROR_SETMARK_DETECTED to EIO instead of ESPIPE.
	Handle ERROR_FILEMARK_DETECTED.
	* fhandler_tape.cc (TAPE_FUNC): Add comment that ERROR_BUS_RESET
	has still to be handled correctly.
	(fhandler_dev_tape::open): Accomodate fact that get.mt_dsreg
	also contains density code.
	(fhandler_dev_tape::ioctl): Rearrange slightly.  Reset devbuf also on
	MTNOP, MTWSM, MTSETBLK, MTSETDRVBUFFER, MTSETPART and MTMKPART.
	(fhandler_dev_tape::tape_set_pos): Rearrange.  Match behaviour to
	the Linux tape driver.
	(fhandler_dev_tape::tape_status): Call IOCTL_STORAGE_GET_MEDIA_TYPES_EX
	if available.  Return device type and density code in appropriate
	mtget members.
	* wincap.h (wincaps::has_ioctl_storage_get_media_types_ex): New element.
	* wincap.cc: Implement above element throughout.
	* include/cygwin/mtio.h: Add tape device types as returned by
	IOCTL_STORAGE_GET_MEDIA_TYPES_EX.
	(MT_TAPE_INFO): Use above type codes.
	(struct mtget): Change mt_dsreg comment.
@
text
@d127 1
d129 1
a129 3
      struct mtop op;
      struct mtpos pos;
      DWORD varlen;
d134 1
a134 1
      if (!ioctl (MTIOCGET, &get))
d154 1
a154 1
      if ((!ioctl (MTIOCPOS, &pos)) && (!pos.mt_blkno))
d157 1
a157 2
	  op.mt_op = MTREW;
	  ioctl (MTIOCTOP, &op);
d163 1
a163 3
	  op.mt_op = MTFSFM;
	  op.mt_count = 1;
	  ioctl (MTIOCTOP, &op);
d195 1
a195 2
      op.mt_op = MTREW;
      ioctl (MTIOCTOP, &op);
d352 1
a352 1
	    ret = tape_erase (TAPE_ERASE_SHORT);
d415 2
a416 3
	    if (tape_get_feature (TAPE_DRIVE_ABSOLUTE_BLK)
	        || tape_get_feature (TAPE_DRIVE_LOGICAL_BLK))
	      ret = tape_set_pos (TAPE_ABSOLUTE_BLOCK, op->mt_count);
d448 3
d452 3
d505 2
a506 1
fhandler_dev_tape::tape_get_pos (unsigned long *ret)
a510 11
  if (tape_get_feature (TAPE_DRIVE_GET_ABSOLUTE_BLK))
    {
      TAPE_FUNC (GetTapePosition (get_handle (), TAPE_ABSOLUTE_POSITION,
				  &part, &low, &high));
      /* Workaround bug in Tandberg SLR device driver, which pretends
         to support reporting of absolute blocks but instead returns
	 ERROR_INVALID_FUNCTION. */
      if (lasterr != ERROR_INVALID_FUNCTION)
	goto out;
      dp.FeaturesLow &= ~TAPE_DRIVE_GET_ABSOLUTE_BLK;
    }
d514 3
d518 7
a524 3
out:
  if (!tape_error ("tape_get_pos") && ret)
    *ret = low;
d530 1
a530 1
fhandler_dev_tape::_tape_set_pos (int mode, long count)
d532 1
a532 1
  TAPE_FUNC (SetTapePosition (get_handle (), mode, 0, count,
a556 4
      case TAPE_ABSOLUTE_BLOCK:
        if (!tape_get_feature (TAPE_DRIVE_ABSOLUTE_BLK))
	  mode = TAPE_LOGICAL_BLOCK;
	break;
a564 11
      case TAPE_ABSOLUTE_BLOCK:
	/* Workaround bug in Tandberg SLR device driver, which pretends
	   to support absolute block positioning but instead returns
	   ERROR_INVALID_FUNCTION. */
	if (lasterr == ERROR_INVALID_FUNCTION && mode == TAPE_ABSOLUTE_BLOCK)
	  {
	    dp.FeaturesHigh &= TAPE_DRIVE_HIGH_FEATURES
			       | ~TAPE_DRIVE_ABSOLUTE_BLK;
	    _tape_set_pos (TAPE_LOGICAL_BLOCK, count);
	  }
	  break;
d572 2
d635 1
a635 7
  if (!notape && tape_get_feature (TAPE_DRIVE_TAPE_REMAINING))
    {
      get->mt_remaining = get_ll (mp.Remaining);
      get->mt_resid = get->mt_remaining >> 10;
    }

  if (tape_get_feature (TAPE_DRIVE_SET_BLOCK_SIZE) && !notape)
d641 1
d654 1
d664 1
d675 4
a678 3
      if (tape_get_feature (TAPE_DRIVE_GET_ABSOLUTE_BLK)
	  || tape_get_feature (TAPE_DRIVE_GET_LOGICAL_BLK))
	tape_get_pos ((unsigned long *) &get->mt_blkno);
d690 3
d739 25
@


1.39
log
@	* errno.cc (errmap): Handle ERROR_BUS_RESET.
	* fhandler.h (fhandler_dev_raw::write_file): New method, created
	from former static function.
	(fhandler_dev_raw::read_file): Ditto.
	(reset_devbuf): New inline method.
	(class fhandler_dev_tape): Add TAPE_GET_DRIVE_PARAMETERS
	member `dp'.
	(fhandler_dev_tape::write_file): New method.
	(fhandler_dev_tape::read_file): Ditto.
	(fhandler_dev_tape::tape_get_feature): Convert to inline method.
	(fhandler_dev_tape::tape_error): New method, created from former
	static function.
	(fhandler_dev_tape::tape_get_blocksize): Remove declaration.
	* fhandler_raw.cc (fhandler_dev_raw::write_file): New method, created
	from former static function.
	(fhandler_dev_raw::read_file): Ditto.
	(fhandler_dev_raw::writebuf): Accomodate the fact that no devbuf
	exists under variable block size condition.
	(fhandler_dev_raw::raw_read): Ditto. Add local p pointer to simplify
	pointer arithmetic.
	(fhandler_dev_raw::raw_write): Always set devbufend to 0 when starting
	with writing. Accomodate the fact that no devbuf exists under
	variable block size condition.
	* fhandler_tape.cc: Various formatting changes.
	(TAPE_FUNC): New macro. Use throughout as tape function loop.
	(get_ll): Convert into macro.
	(IS_EOM): New macro.
	(IS_EOF): New macro.
	(fhandler_dev_tape::is_eom): Use IS_EOM macro.
	(fhandler_dev_tape::is_eof): Use IS_EOF macro.
	(fhandler_dev_tape::write_file): New method.
	(fhandler_dev_tape::read_file): New method.
	(fhandler_dev_tape::open): Get drive information block here once.
	(fhandler_dev_tape::lseek): Remove unneeded duplicate code.
	(fhandler_dev_tape::dup): Duplicate drive information block.
	(fhandler_dev_tape::ioctl): Remove drvbuf in variable block size mode.
	Return ERROR_INVALID_BLOCK_LENGTH instead of ERROR_MORE_DATA if
	buffer contains data which would get lost on buffer size changing.
	Use absolute tape positioning also if drive only supports logical
	block positioning.
	(fhandler_dev_tape::tape_error): New method, created from former
	static function.
	(fhandler_dev_tape::tape_get_pos): Allow logical block reporting.
	Workaround tape driver bug.
	(fhandler_dev_tape::_tape_set_pos): Reset device buffer and flags
	after successful repositioning.
	(fhandler_dev_tape::tape_set_pos): Allow logical block positioning.
	Workaround tape driver bug.
	(fhandler_dev_tape::tape_erase): Use dp instead of calling
	GetTapeParameters.
	(fhandler_dev_tape::tape_prepare): Ditto.
	(fhandler_dev_tape::tape_get_blocksize): Remove.
	(fhandler_dev_tape::tape_set_blocksize): Don't call tape_get_blocksize.
	Error handling already done in fhandler_dev_tape::ioctl.
	(fhandler_dev_tape::tape_status): Remove local `dp' variable.
	Accomodate logical tape reporting.  Call tape_get_feature instead
	of accessing feature words directly.
	(fhandler_dev_tape::tape_compression): Use dp instead of calling
	GetTapeParameters.  Fix resetting datcompression.
@
text
@d15 1
d17 1
d29 4
d136 10
a145 6
	/* Tape drive supports and is set to variable block size. */
	if (get.mt_dsreg == 0)
	  devbufsiz = get.mt_maxblksize;
	else
	  devbufsiz = get.mt_dsreg;
	varblkop = get.mt_dsreg == 0;
d332 1
d336 1
d365 53
a417 57
	    {
	      if (!tape_get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
		{
		  ret = ERROR_INVALID_PARAMETER;
		  break;
		}
	      if ((devbuf && (size_t) op->mt_count == devbufsiz)
	          || (!devbuf && op->mt_count == 0))
		{
		  /* Nothing has changed. */
		  ret = 0;
		  break;
		}
	      if ((op->mt_count == 0
		   && !tape_get_feature (TAPE_DRIVE_VARIABLE_BLOCK))
		  || (op->mt_count > 0
		      && ((DWORD) op->mt_count < dp.MinimumBlockSize
			  || (DWORD) op->mt_count > dp.MaximumBlockSize)))
		{
		  ret = ERROR_INVALID_PARAMETER;
		  break;
		}
	      if (devbuf && devbufend - devbufstart > 0
	          && (op->mt_count == 0
		      || (op->mt_count > 0
		          && (size_t) op->mt_count < devbufend - devbufstart)))
		{
		  /* Not allowed if still data in devbuf. */
		  ret = ERROR_INVALID_BLOCK_LENGTH; /* EIO */
		  break;
		}
	      if (!(ret = tape_set_blocksize (op->mt_count)))
		{
		  char *buf = NULL;
		  if (op->mt_count > 1L && !(buf = new char [op->mt_count]))
		    {
		      ret = ERROR_OUTOFMEMORY;
		      break;
		    }
		  if (devbufsiz > 1L && op->mt_count > 1L)
		    {
		      memcpy (buf, devbuf + devbufstart,
			      devbufend - devbufstart);
		      devbufend -= devbufstart;
		    }
		  else
		    devbufend = 0;
		  devbufstart = 0;
		  delete [] devbuf;
		  devbuf = buf;
		  devbufsiz = op->mt_count;
		  varblkop = op->mt_count == 0;
		}
	    }
	    break;
	  case MTSETDENSITY:
	    ret = ERROR_INVALID_PARAMETER;
a430 3
	  case MTSETDRVBUFFER:
	    ret = ERROR_INVALID_PARAMETER;
	    break;
d439 1
a449 3
	  case MTUNLOAD:
	    ret = tape_prepare (TAPE_UNLOAD);
	    break;
d455 3
a549 2
  unsigned long pos, tgtpos;

d553 2
a554 6
	if (tape_get_pos (&pos))
	  return lasterr;

	tgtpos = pos + count;

	while (count && (_tape_set_pos (mode, count), IS_EOF (lasterr)))
d556 2
a557 3
	    if (tape_get_pos (&pos))
	      return lasterr;
	    count = tgtpos - pos;
a558 4

	if (lasterr == ERROR_BEGINNING_OF_MEDIA && !tgtpos)
	  lasterr = NO_ERROR;

d560 8
d569 2
a570 34
	if (count < 0)
	  {
	    if (pos > 0)
	      {
		if (!_tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS, -1)
		    || (sfm_func))
		  ++count;
		_tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS, 1);
	      }

	    while (!_tape_set_pos (mode, -1) && count++ < 0)
	      ;

	    if (lasterr == ERROR_BEGINNING_OF_MEDIA)
	      {
		if (!count)
		  lasterr = NO_ERROR;
	      }
	    else if (!sfm_func)
	      _tape_set_pos (mode, 1);
	  }
	else
	  {
	    if (sfm_func)
	      {
		if (_tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS, 1)
		    == ERROR_FILEMARK_DETECTED)
		  ++count;
		_tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS, -1);
	      }

	    if (!_tape_set_pos (mode, count) && sfm_func)
	      _tape_set_pos (mode, -1);
	  }
a572 3
	if (!tape_get_feature (TAPE_DRIVE_ABSOLUTE_BLK))
	  mode = TAPE_LOGICAL_BLOCK;
	_tape_set_pos (mode, count);
a582 5
      case TAPE_SPACE_SETMARKS:
      case TAPE_SPACE_END_OF_DATA:
      case TAPE_REWIND:
	_tape_set_pos (mode, count);
	break;
a583 1

d658 2
a659 1
    get->mt_dsreg = mp.BlockSize;
d661 28
a688 2
    get->mt_dsreg = dp.DefaultBlockSize;

@


1.38
log
@	* fhandler_raw.cc (fhandler_dev_raw::raw_read): When reading with
	variable block size, read only one block, read directly into user
	supplied buffer, return ENOMEM if user supplied buffer is smaller
	than size of next block to read.  Use read2 instead of bytes_to_read
	to count number of bytes read.
	* fhandler_tape.cc (fhandler_dev_tape::open): Add debug output.
@
text
@d24 18
d55 1
a55 3
  int ret = ((win_error == ERROR_END_OF_MEDIA)
	  || (win_error == ERROR_EOM_OVERFLOW)
	  || (win_error == ERROR_NO_DATA_DETECTED));
d64 1
a64 2
  int ret = ((win_error == ERROR_FILEMARK_DETECTED)
	  || (win_error == ERROR_SETMARK_DETECTED));
d70 35
d124 4
d173 1
a173 1
      if ((has_written) && (! eom_detected))
a226 3
  eom_detected = eof_detected = 0;
  lastblk_to_read = 0;
  devbufstart = devbufend = 0;
d277 1
d291 1
a291 1
      if (! op)
d327 1
a327 1
	    if (! tape_get_feature (TAPE_DRIVE_END_OF_DATA))
d329 1
a329 1
	    else if (! (ret = tape_set_pos (TAPE_REWIND, 0, false)))
d354 1
a354 3
	      long min, max;

	      if (! tape_get_feature (TAPE_DRIVE_SET_BLOCK_SIZE))
d359 2
a360 4
	      ret = tape_get_blocksize (&min, NULL, &max, NULL);
	      if (ret)
		  break;
	      if (devbuf && (size_t) op->mt_count == devbufsiz && !varblkop)
d362 1
d369 2
a370 1
		      && (op->mt_count < min || op->mt_count > max)))
d375 4
a378 2
	      if (devbuf && op->mt_count > 0
		  && (size_t) op->mt_count < devbufend - devbufstart)
d380 2
a381 1
		  ret = ERROR_MORE_DATA;
d384 1
a384 1
	      if (! (ret = tape_set_blocksize (op->mt_count)))
a385 9
		  size_t size = 0;
		  if (op->mt_count == 0)
		    {
		      struct mtget get;
		      if ((ret = tape_status (&get)) != NO_ERROR)
			break;
		      size = get.mt_maxblksize;
		      ret = NO_ERROR;
		    }
d387 1
a387 1
		  if (size > 1L && !(buf = new char [size]))
d392 1
a392 1
		  if (devbufsiz > 1L && size > 1L)
a399 2
		  if (devbufsiz > 1L)
		    delete [] devbuf;
d401 1
d403 1
a403 1
		  devbufsiz = size;
d412 6
a417 10
	    if (tape_get_feature (TAPE_DRIVE_ABSOLUTE_BLK))
	      {
		ret = tape_set_pos (TAPE_ABSOLUTE_BLOCK, op->mt_count);
		break;
	      }
	    if (! (ret = tape_get_pos (&block)))
	      {
		ret = tape_set_pos (TAPE_SPACE_RELATIVE_BLOCKS,
				 op->mt_count - block);
	      }
d420 1
a420 1
	    if (! (ret = tape_get_pos (&block)))
d482 2
a483 2
static int
tape_error (DWORD lasterr, const char *txt)
a486 1

d494 2
a495 8
  while (((lasterr = WriteTapemark (get_handle (),
				    marktype,
				    len,
				    FALSE)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;

  return tape_error (lasterr, "tape_write_marks");
d503 18
a520 8
  while (((lasterr = GetTapePosition (get_handle (),
				      TAPE_ABSOLUTE_POSITION,
				      &part,
				      &low,
				      &high)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;
  if (! tape_error (lasterr, "tape_get_pos") && ret)
d526 2
a527 1
static int _tape_set_pos (HANDLE hTape, int mode, long count)
d529 10
a538 12
  int err;

  while (((err = SetTapePosition (hTape,
				  mode,
				  1,
				  count,
				  count < 0 ? -1 : 0,
				  FALSE)) == ERROR_MEDIA_CHANGED)
	 || (err == ERROR_BUS_RESET))
    ;

  return err;
d549 1
a549 3
	lasterr = tape_get_pos (&pos);

	if (lasterr)
d554 1
a554 4
	while (((lasterr = _tape_set_pos (get_handle (),
					  mode,
					  count)) == ERROR_FILEMARK_DETECTED)
	       || (lasterr == ERROR_SETMARK_DETECTED))
d556 1
a556 2
	    lasterr = tape_get_pos (&pos);
	    if (lasterr)
d561 1
a561 1
	if (lasterr == ERROR_BEGINNING_OF_MEDIA && ! tgtpos)
d570 1
a570 3
		if ((! _tape_set_pos (get_handle (),
				  TAPE_SPACE_RELATIVE_BLOCKS,
				  -1))
d573 1
a573 1
		_tape_set_pos (get_handle (), TAPE_SPACE_RELATIVE_BLOCKS, 1);
d576 1
a576 2
	    while (! (lasterr = _tape_set_pos (get_handle (), mode, -1))
		   && count++ < 0)
d581 1
a581 1
		if (! count)
d584 2
a585 2
	    else if (! sfm_func)
	      lasterr = _tape_set_pos (get_handle (), mode, 1);
d591 2
a592 3
		if (_tape_set_pos (get_handle (),
				   TAPE_SPACE_RELATIVE_BLOCKS,
				   1) == ERROR_FILEMARK_DETECTED)
d594 1
a594 1
		_tape_set_pos (get_handle (), TAPE_SPACE_RELATIVE_BLOCKS, -1);
d597 2
a598 3
	    if (! (lasterr = _tape_set_pos (get_handle (), mode, count))
		&& sfm_func)
	      lasterr = _tape_set_pos (get_handle (), mode, -1);
d601 14
a615 1
      case TAPE_ABSOLUTE_BLOCK:
d618 1
a618 1
	lasterr = _tape_set_pos (get_handle (), mode, count);
d622 1
a622 1
  return tape_error (lasterr, "tape_set_pos");
a627 10
  DWORD varlen;
  TAPE_GET_DRIVE_PARAMETERS dp;

  while (((lasterr = GetTapeParameters (get_handle (),
					GET_TAPE_DRIVE_INFORMATION,
					(varlen = sizeof dp, &varlen),
					&dp)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;

d631 1
a631 1
	if (! lasterr && ! (dp.FeaturesLow & TAPE_DRIVE_ERASE_SHORT))
d635 1
a635 1
	if (! lasterr && ! (dp.FeaturesLow & TAPE_DRIVE_ERASE_LONG))
d639 5
a643 2

  return tape_error (EraseTape (get_handle (), mode, false), "tape_erase");
d649 5
a653 66
  while (((lasterr = PrepareTape (get_handle (),
				  action,
				  FALSE)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;
  return tape_error (lasterr, "tape_prepare");
}

bool
fhandler_dev_tape::tape_get_feature (DWORD parm)
{
  DWORD varlen;
  TAPE_GET_DRIVE_PARAMETERS dp;

  while (((lasterr = GetTapeParameters (get_handle (),
					GET_TAPE_DRIVE_INFORMATION,
					(varlen = sizeof dp, &varlen),
					&dp)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;

  if (lasterr)
    return false;

  return ((parm & TAPE_DRIVE_HIGH_FEATURES)
	  ? ((dp.FeaturesHigh & parm) != 0)
	  : ((dp.FeaturesLow & parm) != 0));
}

int
fhandler_dev_tape::tape_get_blocksize (long *min, long *def, long *max, long *cur)
{
  DWORD varlen;
  TAPE_GET_DRIVE_PARAMETERS dp;
  TAPE_GET_MEDIA_PARAMETERS mp;

  while (((lasterr = GetTapeParameters (get_handle (),
					GET_TAPE_DRIVE_INFORMATION,
					(varlen = sizeof dp, &varlen),
					&dp)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;

  if (lasterr)
    return tape_error (lasterr, "tape_get_blocksize");

  while (((lasterr = GetTapeParameters (get_handle (),
					GET_TAPE_MEDIA_INFORMATION,
					(varlen = sizeof dp, &varlen),
					&mp)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;

  if (lasterr)
    return tape_error (lasterr, "tape_get_blocksize");

  if (min)
    *min = (long) dp.MinimumBlockSize;
  if (def)
    *def = (long) dp.DefaultBlockSize;
  if (max)
    *max = (long) dp.MaximumBlockSize;
  if (cur)
    *cur = (long) mp.BlockSize;

  return tape_error (lasterr, "tape_get_blocksize");
a658 1
  long min, max;
a660 8
  lasterr = tape_get_blocksize (&min, NULL, &max, NULL);

  if (lasterr)
    return lasterr;

  if (count != 0 && (count < min || count > max))
    return tape_error (ERROR_INVALID_PARAMETER, "tape_set_blocksize");

d662 3
a664 16

  return tape_error (SetTapeParameters (get_handle (),
					SET_TAPE_MEDIA_INFORMATION,
					&mp),
		     "tape_set_blocksize");
}

static long long
get_ll (PLARGE_INTEGER i)
{
  long long l = 0;

  l = i->HighPart;
  l <<= 32;
  l |= i->LowPart;
  return l;
a670 1
  TAPE_GET_DRIVE_PARAMETERS dp;
d674 1
a674 1
  if (! get)
d677 1
a677 8
  while (((lasterr = GetTapeParameters (get_handle (),
					GET_TAPE_DRIVE_INFORMATION,
					(varlen = sizeof dp, &varlen),
					&dp)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;

  /* Setting varlen to sizeof DP is by intention, actually! Never set
d680 3
a682 4
  if ((lasterr) || (lasterr = GetTapeParameters (get_handle (),
						 GET_TAPE_MEDIA_INFORMATION,
						 (varlen = sizeof dp, &varlen),
						 &mp)))
d689 1
a689 1
  if (! notape && (dp.FeaturesLow & TAPE_DRIVE_TAPE_REMAINING))
d691 1
a691 1
      get->mt_remaining = get_ll (&mp.Remaining);
d695 1
a695 1
  if ((dp.FeaturesHigh & TAPE_DRIVE_SET_BLOCK_SIZE) && ! notape)
d703 1
a703 1
  if (! notape)
d705 2
a706 1
      if (dp.FeaturesLow & TAPE_DRIVE_GET_ABSOLUTE_BLK)
d709 1
a709 1
      if (! get->mt_blkno)
d714 1
a714 1
      if ((dp.FeaturesLow & TAPE_DRIVE_WRITE_PROTECT) && mp.WriteProtected)
d717 2
a718 2
      if (dp.FeaturesLow & TAPE_DRIVE_TAPE_CAPACITY)
	get->mt_capacity = get_ll (&mp.Capacity);
d721 1
a721 1
  if ((dp.FeaturesLow & TAPE_DRIVE_COMPRESSION) && dp.Compression)
d724 1
a724 1
  if ((dp.FeaturesLow & TAPE_DRIVE_ECC) && dp.ECC)
d727 1
a727 1
  if ((dp.FeaturesLow & TAPE_DRIVE_PADDING) && dp.DataPadding)
d730 1
a730 1
  if ((dp.FeaturesLow & TAPE_DRIVE_REPORT_SMKS) && dp.ReportSetmarks)
a747 2
  DWORD varlen;
  TAPE_GET_DRIVE_PARAMETERS dpg;
d750 1
a750 11
  while (((lasterr = GetTapeParameters (get_handle (),
					GET_TAPE_DRIVE_INFORMATION,
					(varlen = sizeof dpg, &varlen),
					&dpg)) == ERROR_MEDIA_CHANGED)
	 || (lasterr == ERROR_BUS_RESET))
    ;

  if (lasterr)
    return tape_error (lasterr, "tape_compression");

  if (! (dpg.FeaturesLow & TAPE_DRIVE_COMPRESSION))
d753 10
a762 18
  if (count)
    {
      dps.ECC = dpg.ECC;
      dps.Compression = count ? TRUE : FALSE;
      dps.DataPadding = dpg.DataPadding;
      dps.ReportSetmarks = dpg.ReportSetmarks;
      dps.EOTWarningZoneSize = dpg.EOTWarningZoneSize;
      lasterr = SetTapeParameters (get_handle (),
				   SET_TAPE_DRIVE_INFORMATION,
				   &dps);

      if (lasterr)
	return tape_error (lasterr, "tape_compression");

      dpg.Compression = dps.Compression;
    }

  return 0;
@


1.37
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d93 1
@


1.36
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.35
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d276 1
a276 1
	    else if (! (ret = tape_set_pos (TAPE_REWIND, 0, FALSE)))
d280 1
a280 1
	    ret = tape_set_pos (TAPE_SPACE_FILEMARKS, -op->mt_count, TRUE);
d283 1
a283 1
	    ret = tape_set_pos (TAPE_SPACE_FILEMARKS, op->mt_count, TRUE);
d500 1
a500 1
fhandler_dev_tape::tape_set_pos (int mode, long count, BOOLEAN sfm_func)
d606 1
a606 1
  return tape_error (EraseTape (get_handle (), mode, FALSE), "tape_erase");
d620 1
a620 1
BOOLEAN
d634 1
a634 1
    return FALSE;
@


1.34
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d19 1
a20 1
#include "path.h"
d55 2
a56 2
fhandler_dev_tape::fhandler_dev_tape (int unit)
  : fhandler_dev_raw (FH_TAPE, unit)
d58 1
a58 1
  debug_printf ("unit: %d", unit);
d62 1
a62 1
fhandler_dev_tape::open (path_conv *real_path, int flags, mode_t)
d68 1
a68 1
  ret = fhandler_dev_raw::open (real_path, flags);
d91 1
a91 1
      if ((! ioctl (MTIOCPOS, &pos)) && (! pos.mt_blkno))
d148 1
a148 1
fhandler_dev_tape::fstat (struct __stat64 *buf, path_conv *pc)
d152 1
a152 1
  if (!(ret = fhandler_base::fstat (buf, pc)))
@


1.33
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@a13 1
#include <errno.h>
@


1.32
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d164 2
a165 2
__off64_t
fhandler_dev_tape::lseek (__off64_t offset, int whence)
@


1.32.18.1
log
@merge from trunk
@
text
@d56 2
a57 2
fhandler_dev_tape::fhandler_dev_tape ()
  : fhandler_dev_raw ()
d59 1
a59 1
  debug_printf ("unit: %d", dev.minor);
d92 1
a92 1
      if ((!ioctl (MTIOCPOS, &pos)) && (!pos.mt_blkno))
@


1.32.18.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d20 1
a21 1
#include "fhandler.h"
d59 1
a59 1
  debug_printf ("unit: %d", dev ().minor);
d63 1
a63 1
fhandler_dev_tape::open (int flags, mode_t)
d69 1
a69 1
  ret = fhandler_dev_raw::open (flags);
d149 1
a149 1
fhandler_dev_tape::fstat (struct __stat64 *buf)
d153 1
a153 1
  if (!(ret = fhandler_base::fstat (buf)))
@


1.32.18.3
log
@merge from trunk
@
text
@d164 2
a165 2
_off64_t
fhandler_dev_tape::lseek (_off64_t offset, int whence)
@


1.32.18.4
log
@merge from trunk
@
text
@d14 1
@


1.32.16.1
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d56 2
a57 2
fhandler_dev_tape::fhandler_dev_tape ()
  : fhandler_dev_raw (FH_TAPE)
d59 1
a59 1
  debug_printf ("unit: %d", dev.minor);
d92 1
a92 1
      if ((!ioctl (MTIOCPOS, &pos)) && (!pos.mt_blkno))
@


1.32.16.2
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d57 1
a57 1
  : fhandler_dev_raw ()
@


1.31
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d122 1
a122 1
	  debug_printf ("writing filemark\n");
d134 1
a134 1
      debug_printf ("rewinding\n");
d170 1
a170 1
  debug_printf ("lseek (%s, %d, %d)\n", get_name (), offset, whence);
d447 1
a447 1
    debug_printf ("%s: error: %d\n", txt, lasterr);
d455 1
a455 1
  syscall_printf ("write_tapemark\n");
@


1.30
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d350 2
a351 2
		      memcpy(buf, devbuf + devbufstart,
			     devbufend - devbufstart);
@


1.29
log
@* fhandler.cc (fhandler_base::fstat): Move dev and ino calculation into caller.
* syscalls.cc (stat_worker): Calculate dev and ino calculation here, if zero.
* fhandler_proc.cc (fhandler_proc::fhandler_proc): Minor reorg for debugging.
* fhandler_process.cc (fhandler_process::exists): Return 0 on nonexistence.
(fhandler_process::fstat): Simplify pid logic.
* fhandler_tape.cc (fhandler_dev_tape::fstat): Minor reformatting.
@
text
@a13 1
#include <fcntl.h>
@


1.28
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d158 2
a159 4
      if (! ioctl (MTIOCGET, &get))
	{
	  buf->st_blocks = get.mt_capacity / buf->st_blksize;
	}
@


1.27
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d150 1
a150 1
fhandler_dev_tape::fstat (struct stat *buf, path_conv *pc)
d167 2
a168 2
__off32_t
fhandler_dev_tape::lseek (__off32_t offset, int whence)
@


1.26
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001 Red Hat, Inc.
@


1.25
log
@	* fhandler_raw.cc (fhandler_dev_raw::clear): Don't reset unit.
	* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Add debug
	output.
@
text
@d167 2
a168 2
off_t
fhandler_dev_tape::lseek (off_t offset, int whence)
d182 1
a182 1
      return (off_t) -1;
@


1.24
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d60 1
@


1.23
log
@        * fhandler_raw.cc (fhandler_dev_raw::open): Eliminate compatibility
        code since no Win32 device names are used anymore.
        * fhandler_tape.cc (fhandler_dev_tape::tape_set_blocksize): Allow
        0 as blocksize to indicate variable blocksize.
        * path.cc (win32_device_name): Generate NT internal device names
        using upper/lower case names for readability.
        Generate \DosDevices\<letter>: device name for mount table
        compatibility devices.
@
text
@a59 1
  set_cb (sizeof *this);
@


1.22
log
@        * fhandler_tape.cc (fhandler_dev_tape::tape_status): Report
        EOTWarningZoneSize in get->mt_eotwarningzonesize.
        * include/cygwin/mtio.h: Define DEFTAPE.
        (struct mtget): Add member `mt_eotwarningzonesize'. Add a comment.
        * include/cygwin/version.h: Bump API minor version to 47.
@
text
@d695 1
a695 1
  if (count < min || count > max)
@


1.21
log
@	* autoload.cc: Add load statement for `NtOpenFile'.
	* fhandler.h (fhandler_dev_raw::get_unit): New method.
	(fhandler_dev_tape::norewind): Eliminate.
	(fhandler_dev_tape::is_rewind_device): New method.
	* fhandler_raw.cc (fhandler_dev_raw::open): Open new
	fixed device name devices using NT internal method.
	Keep calling fhandler_base::open() for old mount table
	device mapping compatibility devices.
	(fhandler_dev_raw::fstat): Eliminate.  Settings are done
	by fhandler_base::fstat() already.
	* fhandler_tape.cc: Remove `norewind' usage throughout.
	* ntdll.h: Define FILE_SYNCHRONOUS_IO_NONALERT.
	Define struct _IO_STATUS_BLOCK.
	Declare NtOpenFile().
	* path.cc (get_raw_device_number): Add new approach for
	using fixed device names.
	(win32_device_name): Ditto.
	(get_device_number): Ditto.  Require POSIX path to begin
	with "/dev/".
	(mount_info::conv_to_win32_path): Call win32_device_name()
	instead of get_device_number() after evaluating mount points
	to allow changing the win32 destination path again.
	* security.cc (str2buf2uni): Remove `static' to be able to
	call function from fhandler_dev_raw::open().
	* wincap.cc: Set flag has_raw_devices appropriately.
	* wincap.h: Add flag has_raw_devices.
@
text
@d798 1
@


1.20
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@a31 1
  norewind = 0;
a67 1
  norewind = (real_path->get_unitn () >= 128);
d133 1
a133 1
  if (! norewind)
d154 1
a154 1
  if (!(ret = fhandler_dev_raw::fstat (buf, pc)))
a227 1
  fhc->norewind = norewind;
@


1.19
log
@Add second path_conv * argument to fstat()s throughout.
* fhandler.h: Change read and fstat to regparm/stdcall throughout.
(fhandler_base::fstat): Just declare.  Don't define.
(fhandler_disk_file::fstat_helper): Declare.
* fhandler.cc (fhandler_base::fstat): Move here from fhandler.h, adapt from
former stat_dev().
(fhandler_disk_file::fstat): Move most of the disk-file-specific logic from
stat_worker to here.  Use fstat_helper to derive final fstat output.
(fhandler_disk_file::fstat_helper): New method, renamed from former fstat
method.
(num_entries): Moved here from syscalls.cc.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Use base class to initialize most
stuff.  Invert has_physical_mem_access test for establishing permissions.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Eliminate unneed test and memory
clearing.  Use base class to initialize most stuff.
* syscalls.cc (stat_dev): Eliminate.
(stat_worker): Simply call fstat method to generate fstat output.  Move all
device specific code to appropriate fstats.
* dir.cc (opendir): Pass correct arg to stat_worker to allow following
symlinks.
@
text
@d58 2
a59 1
fhandler_dev_tape::fhandler_dev_tape (const char *name, int unit) : fhandler_dev_raw (FH_TAPE, name, unit)
@


1.18
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d151 1
a151 1
fhandler_dev_tape::fstat (struct stat *buf)
d155 1
a155 1
  if (! (ret = fhandler_dev_raw::fstat (buf)))
@


1.17
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d64 1
a64 1
fhandler_dev_tape::open (const char *path, int flags, mode_t)
a66 1
  int minor;
d68 1
a68 7
  if (get_device_number (path, minor) != FH_TAPE)
    {
      set_errno (EINVAL);
      return -1;
    }

  norewind = (minor >= 128);
d71 1
a71 1
  ret = fhandler_dev_raw::open (path, flags);
d78 1
a78 1
      if (! ioctl (MTIOCGET, &get))
@


1.16
log
@Update copyrights.
@
text
@d22 1
a24 1
#include "path.h"
@


1.16.4.1
log
@Merged changes from HEAD
@
text
@a21 1
#include "path.h"
d24 1
@


1.16.4.2
log
@Merged changes from HEAD
@
text
@d32 1
d58 1
a58 2
fhandler_dev_tape::fhandler_dev_tape (int unit)
  : fhandler_dev_raw (FH_TAPE, unit)
d60 1
a60 1
  debug_printf ("unit: %d", unit);
d64 1
a64 1
fhandler_dev_tape::open (path_conv *real_path, int flags, mode_t)
d67 1
d69 7
d78 1
a78 1
  ret = fhandler_dev_raw::open (real_path, flags);
d85 1
a85 1
      if (!ioctl (MTIOCGET, &get))
d141 1
a141 1
  if (is_rewind_device ())
d158 1
a158 1
fhandler_dev_tape::fstat (struct stat *buf, path_conv *pc)
d162 1
a162 1
  if (!(ret = fhandler_base::fstat (buf, pc)))
d236 1
d704 1
a704 1
  if (count != 0 && (count < min || count > max))
a806 1
  get->mt_eotwarningzonesize = dp.EOTWarningZoneSize;
@


1.16.4.3
log
@Merged changes from HEAD
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001, 2002 Red Hat, Inc.
d150 1
a150 1
fhandler_dev_tape::fstat (struct __stat64 *buf, path_conv *pc)
d167 2
a168 2
__off64_t
fhandler_dev_tape::lseek (__off64_t offset, int whence)
d182 1
a182 1
      return ILLEGAL_SEEK;
@


1.16.4.4
log
@Merged changes from HEAD
@
text
@d14 1
d158 4
a161 2
      if (!ioctl (MTIOCGET, &get))
	buf->st_blocks = get.mt_capacity / buf->st_blksize;
@


1.16.4.5
log
@Merged changes from HEAD
@
text
@d350 2
a351 2
		      memcpy (buf, devbuf + devbufstart,
			      devbufend - devbufstart);
@


1.15
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d4 1
a4 1
   Copyright 1999, 2000 Cygnus Solutions.
@


1.14
log
@forced commit
@
text
@a16 1

d20 1
@


1.13
log
@        * fhandler_tape.cc (fhandler_dev_tape::tape_erase): Set size
        parameter to value expected by GetTapeParameters().
@
text
@@


1.12
log
@        * fhandler_tape.cc (fhandler_dev_tape::tape_status): Set size
        parameter to value expected by GetTapeParameters().
@
text
@d673 1
a673 1
					(varlen = sizeof mp, &varlen),
@


1.11
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d744 3
d749 1
a749 1
						 (varlen = sizeof mp, &varlen),
@


1.10
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@a18 1
#include "cygheap.h"
d22 2
@


1.9
log
@        * fhandler.h (fhandler_dev_raw): Add definition for method
        `fixup_after_fork'.
        * fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Add
        `set_need_fixup_after_fork' call.
        (fhandler_dev_raw::~fhandler_dev_raw): Revert to user space
        allocation.
        (fhandler_dev_raw::open): Ditto.
        (fhandler_dev_raw::dup): Ditto. Reset buffer pointer.
        (fhandler_dev_raw::fixup_after_fork): New function.
        * fhandler_tape.cc (fhandler_dev_tape::open): Revert to user space
        memory allocation.
        (fhandler_dev_tape::ioctl): Ditto. Change behaviour on MTSETBLK when
        new size is 1.
@
text
@d21 1
@


1.8
log
@        * fhandler_tape.cc (fhandler_dev_tape::open): Fix memory allocation.
        Use Cygwin heap instead of user heap.
        (fhandler_dev_tape::ioctl): Ditto.
@
text
@d92 1
a92 1
	devbuf = (char *) cmalloc (HEAP_BUF, devbufsiz);
d352 2
a353 2
		  char *buf = (char *) cmalloc (HEAP_BUF, size);
		  if (!buf)
d358 1
a358 1
		  if (devbuf)
d360 2
a361 1
		      memcpy(buf,devbuf + devbufstart, devbufend - devbufstart);
a362 1
		      cfree (devbuf);
d366 2
@


1.7
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d19 1
d92 1
a92 1
	devbuf = new char [ devbufsiz ];
d352 1
a352 1
		  char *buf = new char [ size ];
d362 1
a362 1
		      delete [] devbuf;
@


1.6
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d83 4
a86 4
        /* Tape drive supports and is set to variable block size. */
        if (get.mt_dsreg == 0)
          devbufsiz = get.mt_maxblksize;
        else
d88 1
a88 1
        varblkop = get.mt_dsreg == 0;
d327 3
a329 3
                   && !tape_get_feature (TAPE_DRIVE_VARIABLE_BLOCK))
                  || (op->mt_count > 0
                      && (op->mt_count < min || op->mt_count > max)))
d335 1
a335 1
                  && (size_t) op->mt_count < devbufend - devbufstart)
d342 9
a350 9
                  size_t size = 0;
                  if (op->mt_count == 0)
                    {
                      struct mtget get;
                      if ((ret = tape_status (&get)) != NO_ERROR)
                        break;
                      size = get.mt_maxblksize;
                      ret = NO_ERROR;
                    }
d352 5
a356 5
                  if (!buf)
                    {
                      ret = ERROR_OUTOFMEMORY;
                      break;
                    }
d368 1
a368 1
                  varblkop = op->mt_count == 0;
@


1.5
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d20 2
@


1.4
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d19 1
@


1.3
log
@        * fhandler.h (class fhandler_dev_raw): Add private member `varblkop'
        to be set when variable blocksize mode is on.
        * fhandler_raw.cc: Eliminate `\n' from trace output.
        (clear): Set `varblkop' to 0.
        (dup): Copy varblkop as well.
        (writebuf): Care for variable blocksize.
        (open): Ditto.
        (raw_read): Ditto.
        (raw_write): Ditto.
        * fhandler_tape.cc (open): Ditto.
        (ioctl): Ditto. Some cleanups.
@
text
@d12 1
a16 1
#include "winsup.h"
@


1.2
log
@        * fhandler_tape.cc (fhandler_dev_tape::ioctl): Check
        for filemark feature on MTWEOF operation.
@
text
@d80 4
a83 1
	{
d85 1
a85 1
	}
d88 1
a88 3
	{
	  devbuf = new char [ devbufsiz ];
	}
d90 1
a90 2
      /*
       * The following rewind in position 0 solves a problem which appears
d93 2
a94 3
       * ReadFile calls return ERROR_NO_DATA_DETECTED, too!
       * The call to tape_set_pos seems to reset some internal flags!
      */
d282 3
a284 8
	      {
		ret = ERROR_INVALID_PARAMETER;
		break;
	      }
	    if (! (ret = tape_set_pos (TAPE_REWIND, 0, FALSE)))
	      {
		ret = tape_prepare (TAPE_TENSION);
	      }
d294 1
a294 3
	      {
		ret = tape_set_pos (TAPE_SPACE_END_OF_DATA, 0);
	      }
d296 1
a296 3
	      {
		ret = tape_set_pos (TAPE_SPACE_FILEMARKS, 32767);
	      }
d317 2
d320 1
d323 4
a326 1
	      if (op->mt_count < min || op->mt_count > max)
d331 2
a332 1
	      if (devbuf && (size_t) op->mt_count == devbufsiz)
d334 1
a334 6
		  ret = 0;
		  break;
		}
	      if (devbuf && (size_t) op->mt_count < devbufend - devbufstart)
		{
		  ret = ERROR_INVALID_PARAMETER;
d339 15
a353 1
		  char *buf = new char [ op->mt_count ];
d361 5
a365 6
		    {
		      devbufend = 0;
		    }
		    devbufstart = 0;
		    devbuf = buf;
		    devbufsiz = op->mt_count;
@


1.1
log
@Initial revision
@
text
@d266 6
a271 1
	    ret = tape_write_marks (TAPE_FILEMARKS, op->mt_count);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
