head	1.43;
access;
symbols
	cygwin-1_7_35-release:1.43
	cygwin-1_7_34-release:1.43
	cygwin-1_7_33-release:1.43
	cygwin-1_7_32-release:1.43
	cygwin-1_7_31-release:1.43
	cygwin-1_7_30-release:1.43
	cygwin-1_7_29-release:1.43
	cygwin-1_7_29-release-branchpoint:1.43.0.2
	cygwin-pre-user-db:1.43
	cygwin-1_7_28-release:1.43
	cygwin-1_7_27-release:1.43
	cygwin-1_7_26-release:1.43
	cygwin-1_7_25-release:1.42
	cygwin-1_7_24-release:1.42
	cygwin-1_7_23-release:1.42
	cygwin-1_7_22-release:1.42
	cygwin-1_7_21-release:1.42
	cygwin-1_7_20-release:1.42
	cygwin-1_7_19-release:1.42
	cygwin-64bit-postmerge:1.41
	cygwin-64bit-premerge-branch:1.41.0.2
	cygwin-64bit-premerge:1.41
	cygwin-1_7_18-release:1.41
	post-ptmalloc3:1.40.4.1
	pre-ptmalloc3:1.40.4.1
	cygwin-1_7_17-release:1.40
	cygwin-64bit-branch:1.40.0.4
	cygwin-1_7_16-release:1.40
	cygwin-1_7_15-release:1.40
	cygwin-1_7_14_2-release:1.40
	cygwin-1_7_14-release:1.40
	cygwin-1_7_12-release:1.40
	cygwin-1_7_11-release:1.40
	cygwin-1_7_10-release:1.40
	signal-rewrite:1.40.0.2
	pre-notty:1.40
	cygwin-1_7_9-release:1.39
	cv-post-1_7_9:1.39.0.2
	cygwin-1_7_8-release:1.39
	cygwin-1_7_7-release:1.38
	cygwin-1_7_5-release:1.38
	cygwin-1_7_4-release:1.38
	cygwin-1_7_3-release:1.38
	cygwin-1_7_2-release:1.38
	fifo_doover3:1.38.0.4
	cygwin-1_7_1-release:1.38
	prefifo:1.38
	cv-branch-2:1.38.0.2
	pre-ripout-set_console_state_for_spawn:1.38
	EOL_registry_mounts:1.37
	preoverlapped:1.37
	drop_9x_support_start:1.37
	cr-0x5f1:1.37.0.8
	cv-branch:1.37.0.6
	pre-ptymaster-archetype:1.37
	cr-0x3b58:1.37.0.4
	cr-0x5ef:1.37.0.2
	after-mmap-privanon-noreserve:1.37
	after-mmap-revamp:1.37
	before-mmap-revamp:1.37
	cgf-more-exit-sync:1.36
	post_wait_sig_exit:1.36
	pre_wait_sig_exit:1.36
	reparent-point:1.33
	noreparent:1.33.0.4
	cr-0x5e6:1.33.0.2
	cr-0x9e:1.28.0.6
	cr-0x9d:1.28.0.4
	cgf-deleteme:1.28.0.2
	pre-sigrewrite:1.27
	corinna-01:1.27
	cr-0x9c:1.26.0.6
	cr-0x9b:1.26.0.4
	cr-0x99:1.26
	Z-emcb-cygwin_daemon:1.26.0.2
	w32api-2_2:1.25
	mingw-runtime-2_4:1.25
	pre-cgf-merge:1.26
	cgf-dev-branch:1.25.0.2
	predaemon:1.17
	cygwin_daemon_merge_HEAD:1.17
	pregp02r1:1.17.0.8
	cygnus_cvs_20020108_pre:1.17
	Z-cygwin_daemon_merge-new_HEAD:1.20
	Z-cygwin_daemon_merge_HEAD:1.20
	cygwin_daemon:1.13.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.43
date	2013.11.24.12.13.36;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.21.04.38.29;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.01.14.35.12;	author corinna;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2010.09.01.18.24.11;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.07.18.45.59;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.05.04.31.00;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.27.01.57.38;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.26.04.15.09;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.16.04.18.50;	author cgf;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	2004.05.15.16.10.41;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.15.16.09.04;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.09.04.04.24;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.03.19.41.28;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.14.07.09.22;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.14.09.21.55;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.10.12.32.47;	author corinna;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.12.30.22.38.13;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.13.18.16.33;	author cgf;	state Exp;
branches
	1.23.16.1;
next	1.22;

1.22
date	2002.10.10.05.31.43;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.23.00.31.31;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.01.16.20.31;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.05.04.01.43;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.06.09.28.13;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.06.22.36.08;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.28.00.06.35;	author cgf;	state Exp;
branches
	1.15.10.1;
next	1.14;

1.14
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.11.20.01.01;	author cgf;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.24.22.26.53;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.18.21.11.25;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.27.17.30.48;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.26.22.33.54;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.09.13.28.11;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.05.33.09;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.38;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.40.4.1
date	2013.01.21.13.52.11;	author corinna;	state Exp;
branches;
next	;

1.33.4.1
date	2004.11.16.15.16.57;	author cgf;	state Exp;
branches;
next	;

1.25.2.1
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.23.16.1
date	2003.01.01.18.16.37;	author cgf;	state Exp;
branches;
next	;

1.15.10.1
date	2001.12.06.22.43.50;	author cgf;	state Exp;
branches;
next	;

1.13.4.1
date	2002.01.04.03.56.11;	author rbcollins;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.01.15.12.52.52;	author rbcollins;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2002.06.13.14.34.14;	author rbcollins;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.08.01.20.34.07;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.43
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@/* window.cc: hidden windows for signals/itimer support

   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2010, 2011
   Red Hat, Inc.

   Written by Sergey Okhapkin <sos@@prospect.com.ru>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <sys/time.h>
#define USE_SYS_TYPES_FD_SET
#include <winsock2.h>
#include "perprocess.h"
#include "cygtls.h"
#include "sync.h"
#include "wininfo.h"

wininfo NO_COPY winmsg;

muto NO_COPY wininfo::_lock;

int __reg3
wininfo::process (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#ifndef NOSTRACE
  strace.wm (uMsg, wParam, lParam);
#endif
  switch (uMsg)
    {
    case WM_PAINT:
      return 0;
    case WM_DESTROY:
      PostQuitMessage (0);
      return 0;
    case WM_ASYNCIO:
      if (WSAGETSELECTEVENT (lParam) == FD_OOB)
	raise (SIGURG);
      else
	raise (SIGIO);
      return 0;
    default:
      return DefWindowProcW (hwnd, uMsg, wParam, lParam);
    }
}

static LRESULT CALLBACK
process_window_events (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  return winmsg.process (hwnd, uMsg, wParam, lParam);
}

/* Handle windows events.  Inherits ownership of the wininfo lock */
DWORD __reg1 WINAPI
wininfo::winthread ()
{
  MSG msg;
  WNDCLASSW wc;
  static NO_COPY WCHAR classname[] = L"CygwinWndClass";

  _lock.grab ();
  /* Register the window class for the main window. */

  wc.style = 0;
  wc.lpfnWndProc = (WNDPROC) process_window_events;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = user_data->hmodule;
  wc.hIcon = NULL;
  wc.hCursor = NULL;
  wc.hbrBackground = NULL;
  wc.lpszMenuName = NULL;
  wc.lpszClassName = classname;

  if (!RegisterClassW (&wc))
    api_fatal ("cannot register window class, %E");

  /* Create hidden window. */
  hwnd = CreateWindowExW (0, classname, classname, WS_POPUP, CW_USEDEFAULT,
			  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			  (HWND) NULL, (HMENU) NULL, user_data->hmodule,
			  (LPVOID) NULL);
  if (!hwnd)
    api_fatal ("couldn't create window, %E");
  release ();

  int ret;
  while ((ret = (int) GetMessageW (&msg, hwnd, 0, 0)) > 0)
    DispatchMessageW (&msg);

  return 0;
}

static DWORD WINAPI
winthread (VOID *arg)
{
  return  ((wininfo *) arg)->winthread ();
}

wininfo::operator
HWND ()
{
  if (hwnd)
    return hwnd;

  lock ();
  if (!hwnd)
    {
      _lock.upforgrabs ();
      cygthread *h = new cygthread (::winthread, this, "win");
      h->SetThreadPriority (THREAD_PRIORITY_HIGHEST);
      h->zap_h ();
      lock ();
    }
  release ();
  return hwnd;
}

void
wininfo::lock ()
{
  _lock.init ("wininfo_lock")->acquire ();
}

void
wininfo::release ()
{
  _lock.release ();
}
@


1.42
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@a15 2
#include <wingdi.h>
#include <winuser.h>
@


1.41
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d29 1
a29 1
int __stdcall
d60 1
a60 1
DWORD WINAPI
@


1.40
log
@	Throughout, use user32 UNICODE functions rather than ANSI functions.
	* autoload.cc: Convert all definitions for ANSI user32 functions to
	definitions for the corresponding UNICODE function.
	(SendMessageA): Remove.
	(SendNotifyMessageW): Define.
	* fhandler_windows.cc (fhandler_windows::write): Use SendNotifyMessageW
	call rather than SendMessage to make function always return immediately.
	(fhandler_windows::read): Make function interruptible and a cancellation
	point.  Handle O_NONBLOCK.
	* select.cc (peek_serial): Don't wait for signal_arrived here.
	* window.cc (wininfo::winthread): Call CreateWindowExW directly rather
	than CreateWindow wrapper.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2010,
   2011 Red Hat, Inc.
@


1.40.4.1
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2010, 2011
   Red Hat, Inc.
@


1.39
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d3 2
a4 1
   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
d49 1
a49 1
      return DefWindowProc (hwnd, uMsg, wParam, lParam);
d64 2
a65 2
  WNDCLASS wc;
  static NO_COPY char classname[] = "CygwinWndClass";
d81 1
a81 1
  if (!RegisterClass (&wc))
d85 4
a88 4
  hwnd = CreateWindow (classname, classname, WS_POPUP, CW_USEDEFAULT,
			   CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			   (HWND) NULL, (HMENU) NULL, user_data->hmodule,
			   (LPVOID) NULL);
d93 3
a95 2
  while (GetMessage (&msg, hwnd, 0, 0) == TRUE)
    DispatchMessage (&msg);
@


1.38
log
@Remove unneeded header files from source files throughout.
@
text
@d114 1
a114 1
      cygthread *h = new cygthread (::winthread, 0, this, "win");
@


1.37
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@a14 3
#include <stdlib.h>
#include <signal.h>
#include <limits.h>
a18 2
#include <unistd.h>
#include "cygerrno.h"
a19 2
#include "security.h"
#include "thread.h"
@


1.36
log
@* sync.h (muto::operator int): New operator.
(locker): Remove unused class.
(new_muto): Delete.
(new_muto1): Ditto.
(new_muto_name): Ditto.
* cygheap.cc (cygheap_setup_for_child): Reflect use of static storage for muto
rather than pointer.
(_csbrk): Ditto.
(_cmalloc): Ditto.
(_cmalloc): Ditto.
(_cfree): Ditto.
* cygheap.h (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_drive): Ditto.
* cygmalloc.h (__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* cygtls.cc (sentry::lock): Ditto.
(sentry::sentry): Ditto.
(~sentry): Ditto.
(_cygtls::init): Ditto.
* dcrt0.cc: Ditto.
(cygwin_atexit): Ditto.
(cygwin_exit): Ditto.
* debug.cc (lock_debug::locker): Ditto.
(lock_debug::lock_debug): Ditto.
(lock_debug::unlock): Ditto.
(debug_init): Ditto.
* dtable.cc (dtable::init_lock): Ditto.
* dtable.h (dtable::lock_cs): Ditto.
(dtable::lock): Ditto.
(dtable::unlock): Ditto.
* exceptions.cc (mask_sync): Ditto.
(sighold): Ditto.
(set_process_mask_delta): Ditto.
(set_signal_mask): Ditto.
(events_init): Ditto.
* grp.cc (pwdgrp::pwdgrp): Ditto.
* malloc_wrapper.cc (mallock): Ditto.
(malloc_init): Ditto.
* path.cc (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::init): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* pwdgrp.h (pwdgrp::pglock): Ditto.
(pwdgrp::refresh): Ditto.
* sigproc.cc (sync_proc_subproc): Ditto.
(get_proc_lock): Ditto.
(proc_subproc): Ditto.
(_cygtls::remove_wq): Ditto.
(proc_terminate): Ditto.
(sigproc_init): Ditto.
* timer.cc (lock_timer_tracker::protect): Ditto.
(lock_timer_tracker::lock_timer_tracker): Ditto.
(lock_timer_tracker::~lock_timer_tracker): Ditto.
* wininfo.cc (wininfo::_lock;): Ditto.
(wininfo::winthread): Ditto.
(operator HWND): Ditto.
(wininfo::lock): Ditto.
(wininfo::release): Ditto.
* wininfo.h (wininfo::_lock;): Ditto.
@
text
@d121 1
a121 1
      cygthread *h = new cygthread (::winthread, this, "win");
@


1.35
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@d33 1
a33 1
muto NO_COPY *wininfo::_lock;
d73 1
a73 1
  _lock->grab ();
d120 1
a120 1
      _lock->upforgrabs ();
d133 1
a133 1
  new_muto (_lock)->acquire ();
d139 1
a139 1
  _lock->release ();
@


1.34
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d33 1
a33 6
muto NO_COPY *wininfo::lock;

wininfo::wininfo ()
{
  new_muto_name (lock, "!winlock");
}
a47 17
    case WM_TIMER:
      if (wParam == timer_active)
	{
	  UINT elapse = itv.it_interval.tv_sec * 1000 +
			itv.it_interval.tv_usec / 1000;
	  KillTimer (hwnd, timer_active);
	  if (!elapse)
	    timer_active = 0;
	  else
	    {
	      timer_active = SetTimer (hwnd, 1, elapse, NULL);
	      start_time = GetTickCount ();
	      itv.it_value = itv.it_interval;
	    }
	  raise (SIGALRM);
	}
      return 0;
d73 1
a73 1
  lock->grab ();
d97 1
a97 1
  lock->release ();
d117 1
a117 1
  lock->acquire ();
d120 1
a120 1
      lock->upforgrabs ();
d124 1
a124 1
      lock->acquire ();
d126 1
a126 1
  lock->release ();
d130 2
a131 51
extern "C" int
setitimer (int which, const struct itimerval *value, struct itimerval *oldvalue)
{
  if (which != ITIMER_REAL)
    {
      set_errno (ENOSYS);
      return -1;
    }
  return winmsg.setitimer (value, oldvalue);
}

/* FIXME: Very racy */
int __stdcall
wininfo::setitimer (const struct itimerval *value, struct itimerval *oldvalue)
{
  /* Check if we will wrap */
  if (itv.it_value.tv_sec >= (long) (UINT_MAX / 1000))
    {
      set_errno (EINVAL);
      return -1;
    }
  if (timer_active)
    {
      KillTimer (winmsg, timer_active);
      timer_active = 0;
    }
  if (oldvalue)
    *oldvalue = itv;
  if (value == NULL)
    {
      set_errno (EFAULT);
      return -1;
    }
  itv = *value;
  UINT elapse = itv.it_value.tv_sec * 1000 + itv.it_value.tv_usec / 1000;
  if (elapse == 0)
    if (itv.it_value.tv_usec)
      elapse = 1;
    else
      return 0;
  if (!(timer_active = SetTimer (winmsg, 1, elapse, NULL)))
    {
      __seterrno ();
      return -1;
    }
  start_time = GetTickCount ();
  return 0;
}

extern "C" int
getitimer (int which, struct itimerval *value)
d133 1
a133 66
  if (which != ITIMER_REAL)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (value == NULL)
    {
      set_errno (EFAULT);
      return -1;
    }
  return winmsg.getitimer (value);
}

/* FIXME: racy */
int __stdcall
wininfo::getitimer (struct itimerval *value)
{
  *value = itv;
  if (!timer_active)
    {
      value->it_value.tv_sec = 0;
      value->it_value.tv_usec = 0;
      return 0;
    }

  UINT elapse, val;

  elapse = GetTickCount () - start_time;
  val = itv.it_value.tv_sec * 1000 + itv.it_value.tv_usec / 1000;
  val -= elapse;
  value->it_value.tv_sec = val / 1000;
  value->it_value.tv_usec = val % 1000;
  return 0;
}

extern "C" unsigned int
alarm (unsigned int seconds)
{
  int ret;
  struct itimerval newt, oldt;

  newt.it_value.tv_sec = seconds;
  newt.it_value.tv_usec = 0;
  newt.it_interval.tv_sec = 0;
  newt.it_interval.tv_usec = 0;
  setitimer (ITIMER_REAL, &newt, &oldt);
  ret = oldt.it_value.tv_sec;
  if (ret == 0 && oldt.it_value.tv_usec)
    ret = 1;
  return ret;
}

extern "C" useconds_t
ualarm (useconds_t value, useconds_t interval)
{
  struct itimerval timer, otimer;

  timer.it_value.tv_sec = 0;
  timer.it_value.tv_usec = value;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = interval;

  if (setitimer (ITIMER_REAL, &timer, &otimer) < 0)
    return (u_int)-1;

  return (otimer.it_value.tv_sec * 1000000) + otimer.it_value.tv_usec;
d136 2
a137 2
bool
has_visible_window_station (void)
d139 1
a139 16
  HWINSTA station_hdl;
  USEROBJECTFLAGS uof;
  DWORD len;

  /* Check if the process is associated with a visible window station.
     These are processes running on the local desktop as well as processes
     running in terminal server sessions.
     Processes running in a service session not explicitely associated
     with the desktop (using the "Allow service to interact with desktop"
     property) are running in an invisible window station. */
  if ((station_hdl = GetProcessWindowStation ())
      && GetUserObjectInformationA (station_hdl, UOI_FLAGS, &uof,
				    sizeof uof, &len)
      && (uof.dwFlags & WSF_VISIBLE))
    return true;
  return false;
@


1.33
log
@* cygthread.cc (cygthread::is): Eliminate.
* cygthread.h (cygthread::is): Eliminate declaratin.
* fhandler_console.cc (fhandler_console::read): Only wait for signal_arrived in
the main thread.
* fhandler_socket.cc: Include new "wininfo.h".
(fhandler_socket::ioctl): Use 'winmsg' rather than 'gethwnd()'.
* sync.cc (muto::grab): Define new function.
(muto::acquire): Use tls pointer rather than tid.
(muto::acquired): Ditto.
(muto::reset): Delete.
(muto::release): Ditto.  Also implement "close on last release".
* sync.h (muto::tid): Delete.
(muto::tls): New field.
(muto::ismine): Delete.
(muto::owner): Delete.
(muto::unstable): Delete.
(muto::reset): Delete.
(muto::upforgrabs): New method.
(muto::grab): Ditto.
(new_muto_name): New define.
* wininfo.h: New file.
(wininfo): New class.
* window.cc: Rework throughout to use winfo class for controlling invisible
window operation.
(gethwnd): Delete definition.
* winsup.h (gethwnd): Delete declaration.
@
text
@a25 1
#include "cygthread.h"
@


1.33.4.1
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d26 1
@


1.32
log
@revert previous not-ready-for-primetime checkin.
@
text
@d27 4
d32 1
a32 4
static NO_COPY UINT timer_active = 0;
static NO_COPY struct itimerval itv;
static NO_COPY DWORD start_time;
static NO_COPY HWND ourhwnd = NULL;
d34 9
a42 2
static LRESULT CALLBACK
WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
d61 1
a61 3
	    {
	      timer_active = 0;
	    }
d82 5
a86 1
static HANDLE window_started;
d88 3
a90 2
static DWORD WINAPI
Winmain (VOID *)
d96 1
d100 1
a100 1
  wc.lpfnWndProc = (WNDPROC) WndProc;
d111 1
a111 4
    {
      system_printf ("Cannot register window class, %E");
      return FALSE;
    }
d114 7
a120 14
  ourhwnd = CreateWindow (classname, classname, WS_POPUP, CW_USEDEFAULT,
			  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			  (HWND) NULL, (HMENU) NULL, user_data->hmodule,
			  (LPVOID) NULL);

  SetEvent (window_started);

  if (!ourhwnd)
    {
      system_printf ("Cannot create window");
      return FALSE;
    }

  /* Start the message loop. */
d122 1
a122 1
  while (GetMessage (&msg, ourhwnd, 0, 0) == TRUE)
d128 2
a129 2
HWND __stdcall
gethwnd ()
d131 2
a132 2
  if (ourhwnd != NULL)
    return ourhwnd;
d134 5
a138 1
  cygthread *h;
d140 11
a150 7
  window_started = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  h = new cygthread (Winmain, NULL, "win");
  h->SetThreadPriority (THREAD_PRIORITY_HIGHEST);
  WaitForSingleObject (window_started, INFINITE);
  CloseHandle (window_started);
  h->zap_h ();
  return ourhwnd;
a155 2
  UINT elapse;

d161 7
d176 1
a176 1
      KillTimer (gethwnd (), timer_active);
d187 1
a187 1
  elapse = itv.it_value.tv_sec * 1000 + itv.it_value.tv_usec / 1000;
d193 1
a193 1
  if (!(timer_active = SetTimer (gethwnd (), 1, elapse, NULL)))
a204 2
  UINT elapse, val;

d215 7
d229 3
@


1.31
log
@* cygheap.h: Remove some parameter names from declarations throughout.
(cygheap::set): Reflect changes in declaration for arguments and return value
from previous checkin.
@
text
@a26 3
#include "sync.h"
static DWORD WINAPI winthread (VOID *);
#include "wininfo.h"
d28 4
a31 1
wininfo NO_COPY winmsg;
d33 2
a34 9
muto NO_COPY *wininfo::lock;

wininfo::wininfo ()
{
  new_muto_name (lock, "!winlock");
}

int __stdcall
wininfo::process (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
d53 3
a55 1
	    timer_active = 0;
d76 1
a76 5
static LRESULT CALLBACK
process_window_events (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  return winmsg.process (hwnd, uMsg, wParam, lParam);
}
a77 1
/* Handle windows events.  Inherits ownership of the wininfo lock */
d79 1
a79 1
winthread (VOID *arg)
d88 1
a88 1
  wc.lpfnWndProc = (WNDPROC) process_window_events;
d99 4
a102 1
    api_fatal ("cannot register window class, %E");
a103 1
  wininfo *wi = (wininfo *) arg;
d105 12
a116 7
  wi->hwnd = CreateWindow (classname, classname, WS_POPUP, CW_USEDEFAULT,
			   CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			   (HWND) NULL, (HMENU) NULL, user_data->hmodule,
			   (LPVOID) NULL);
  if (!wi->hwnd)
    api_fatal ("couldn't create window, %E");
  wi->lock->release ();
d118 3
a120 1
  while (GetMessage (&msg, (HWND) arg, 0, 0) == TRUE)
d126 2
a127 2
wininfo::operator
HWND ()
d129 2
a130 11
  if (hwnd)
    return hwnd;

console_printf ("hwnd is NULL\n");
  lock->acquire ();
  if (hwnd)
    {
console_printf ("hwnd acquired %p\n", hwnd);
      lock->release ();
      return  hwnd;
    }
d132 1
a132 1
console_printf ("creating window\n");
d134 2
a135 1
  cygthread *h = new cygthread (winthread, this, "win");
d137 2
d140 1
a140 3
  while (!hwnd)
    low_priority_sleep (0);
  return hwnd;
d146 2
a152 7
  return winmsg.setitimer (value, oldvalue);
}

/* FIXME: Very racy */
int __stdcall
wininfo::setitimer (const struct itimerval *value, struct itimerval *oldvalue)
{
d161 1
a161 1
      KillTimer (winmsg, timer_active);
d172 1
a172 1
  UINT elapse = itv.it_value.tv_sec * 1000 + itv.it_value.tv_usec / 1000;
d178 1
a178 1
  if (!(timer_active = SetTimer (winmsg, 1, elapse, NULL)))
d190 2
a201 7
  return winmsg.getitimer (value);
}

/* FIXME: racy */
int __stdcall
wininfo::getitimer (struct itimerval *value)
{
a208 3

  UINT elapse, val;

@


1.30
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d27 3
d31 1
a31 4
static NO_COPY UINT timer_active = 0;
static NO_COPY struct itimerval itv;
static NO_COPY DWORD start_time;
static NO_COPY HWND ourhwnd = NULL;
d33 9
a41 2
static LRESULT CALLBACK
WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
d60 1
a60 3
	    {
	      timer_active = 0;
	    }
d81 5
a85 1
static HANDLE window_started;
d87 1
d89 1
a89 1
Winmain (VOID *)
d98 1
a98 1
  wc.lpfnWndProc = (WNDPROC) WndProc;
d109 1
a109 4
    {
      system_printf ("Cannot register window class, %E");
      return FALSE;
    }
d111 1
d113 7
a119 12
  ourhwnd = CreateWindow (classname, classname, WS_POPUP, CW_USEDEFAULT,
			  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			  (HWND) NULL, (HMENU) NULL, user_data->hmodule,
			  (LPVOID) NULL);

  SetEvent (window_started);

  if (!ourhwnd)
    {
      system_printf ("Cannot create window");
      return FALSE;
    }
d121 1
a121 3
  /* Start the message loop. */

  while (GetMessage (&msg, ourhwnd, 0, 0) == TRUE)
d127 2
a128 2
HWND __stdcall
gethwnd ()
d130 11
a140 2
  if (ourhwnd != NULL)
    return ourhwnd;
d142 1
a142 1
  cygthread *h;
d144 1
a144 2
  window_started = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  h = new cygthread (Winmain, NULL, "win");
a145 2
  WaitForSingleObject (window_started, INFINITE);
  CloseHandle (window_started);
d147 3
a149 1
  return ourhwnd;
a154 2
  UINT elapse;

d160 7
d175 1
a175 1
      KillTimer (gethwnd (), timer_active);
d186 1
a186 1
  elapse = itv.it_value.tv_sec * 1000 + itv.it_value.tv_usec / 1000;
d192 1
a192 1
  if (!(timer_active = SetTimer (gethwnd (), 1, elapse, NULL)))
a203 2
  UINT elapse, val;

d214 7
d228 3
@


1.29
log
@* window.cc (Winmain): Show windows error code in error output when
RegisterClass fails.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.28
log
@* cygthread.cc (cygthread::stub): Revert previous change and again subsume
cygthread::stub2.  Just return from function now since ExitThread is guaranteed
by automatic _threadinfo wrapper.  Define as per ThreadProc convention.
(cygthread::stub2): Remove.
(cygthread::simplestub): Perform similar operations to cygthread::stub.
(cygthread::simplestub2): Remove.
* cygthread.h (cygthread::stub): Declare as per ThreadProc convention.
(cygthread::stub2): Remove declaration.
(cygthread::simplestub): Declare as per ThreadProc convention.
(cygthread::simplestub2): Remove declaration.
* cygtls.h (_threadinfo::call): Define first argument as per ThreadProc
convention.
(_threadinfo::call2): Ditto.
(_tlsbase): Define as char * pointer.
(_tlstop): New definition.
(_main_tls): Define here.
* dcrt0.cc (alloc_stack): Revert previous change which called init_thread since
information would be overwritten by fork later anyway.
(dll_crt0_1): Use _tlsbase and _tlstop for setting stack bottom, top.
* exceptions.cc: Move _main_tls declaration to cygtls.h.
(_threadinfo::call): Define first argument as per ThreadProc convention.
(_threadinfo::call2): Call ExitThread with thread function return value.
(_threadinfo::init_thread): Don't initialize cygtls to zero if input arg is
NULL.
* fork.cc (fork_child): Reset _main_tls here.  Reinitialize parts of _my_tls
after copying data from parent.
* init.cc (threadfunc_fe): New function.  Front-end for all threads created in
cygwin processes.
(munge_threadfunc): New function.
(dll_entry): Call munge_threadfunc to force the call of a thread wrapper.
* thread.cc (pthread::thread_init_wrapper): Perform similar operations to
cygthread::stub.
(pthread::thread_init_wrapper2): Remove.
* thread.h (pthread::thread_init_wrapper): Declare as per ThreadProc
convention.
(pthread::thread_init_wrapper2): Remove declaration.
* window.cc (Winmain): Just return from function now since ExitThread is
guaranteed by automatic _threadinfo wrapper.
@
text
@d100 1
a100 1
      system_printf ("Cannot register window class");
@


1.27
log
@	* exceptions.cc (ctrl_c_handler): Don't send SIGHUP on
	CTRL_LOGOFF_EVENT to processes running in invisible Windows Stations.
	* window.cc (has_visible_window_station): New function.
	* winsup.h: Add declaration for has_visible_window_station.
@
text
@d123 1
a123 1
  ExitThread (0);
@


1.26
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d250 20
@


1.25
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@a15 1
#include <errno.h>
@


1.25.2.1
log
@merge from trunk
@
text
@d16 1
@


1.24
log
@* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
@


1.23
log
@* cygthread.cc (cygthread::stub): Don't create event for long-running threads.
Initialize thread_sync event here which is used to Suspend using an event
rather than relying on SuspendThread/ResumeThread.
(cygthread::init): Save handle to runner thread for future termination.
(cygthread::cygthread): Only resume thread when it is actually suspended.
Otherwise signal thread completion event.
(cygthread::terminate): Forcibly terminate runner thread and any helper
threads.  Call DisableThreadLibrary calls if execing.
* cygthread.h (cygthread::thread_sync): Declare.
* dcrt0.cc (do_exit): Eliminate calls to obsolete window_terminate and
shared_terminate.
* exceptions.cc (events_terminate): Don't bother closing title_mutex since it
is going away anyway.
* pinfo.cc (_pinfo::exit): Call cygthread::terminate to ensure that threads are
shut down before process exit or otherwise strange races seem to occur.
* shared.cc (shared_terminate): Eliminate.
* shared.h (shared_terminate): Eliminate declaration.
* winsup.h (window_terminate): Eliminate declaration.
* spawn.cc (spawn_guts): Call cygthread::terminate early in process if execing.
Call DisableThreadLibrary calls if execing.
* window.cc (Winmain): Call ExitThread to force exit.
(window_terminate): Eliminate.
* dcrt0.cc (do_exit): Track exit state more closely.
@
text
@d151 1
a151 1
      set_errno (EINVAL);
@


1.23.16.1
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
* exceptions.cc (events_init): Display name of mutex on failure.
* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@d151 1
a151 1
      set_errno (ENOSYS);
@


1.22
log
@* window.cc (gethwnd): Use SetThreadPriority method.
@
text
@d124 1
a124 1
  return msg.wParam;
a141 7
}

void __stdcall
window_terminate ()
{
  if (ourhwnd)
    SendMessage (ourhwnd, WM_DESTROY, 0, 0);
@


1.21
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d106 4
a109 4
  ourhwnd = CreateWindow (classname, classname,
	WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
	CW_USEDEFAULT, CW_USEDEFAULT, (HWND) NULL,
	(HMENU) NULL, user_data->hmodule, (LPVOID) NULL);
d122 1
a122 3
    {
      DispatchMessage (&msg);
    }
d137 1
a137 1
  SetThreadPriority (*h, THREAD_PRIORITY_HIGHEST);
d140 1
@


1.20
log
@* Makefile.in (DLL_OFILES): Add cygthread.o.
* dcrt0.cc (dll_crt0_1): Eliminate various thread initialization functions in
favor of new cygthread class.
* debug.cc: Remove thread manipulation functions.
* debug.h: Ditto.
* external.cc (cygwin_internal): Use cygthread method for determining thread
name.  Remove capability for setting thread name.
* fhandler_console.cc (fhandler_console::read): Use cygthread method rather
than iscygthread function.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Use cygthread
methods to create threads.
(fhandler_tty_common::__acquire_output_mutex): Use cygthread method to retrieve
thread name.
* select.cc (pipeinf): Use cygthread pointer rather than handle.
(start_thread_pipe): Ditto.
(pipe_cleanup): Ditto.
(serialinf): Ditto.
(start_thread_serial): Ditto.
(serial_cleanup): Ditto.
(socketinf): Ditto.
(start_thread_socket): Ditto.
(socket_cleanup): Ditto.
* sigproc.cc (hwait_sig): Ditto.
(hwait_subproc): Ditto.
(proc_terminate): Ditto.
(sigproc_terminate): Ditto.
(sigproc_init): Initialize cygthread hwait_sig pointer.
(subproc_init): Initialize cygthread hwait_subproc pointer.
(wait_sig): Rely on cygthread HANDLE operator.
* strace.cc (strace::vsprntf): Use cygthread::name rather than threadname.
* window.cc (gethwnd): Use cygthread method to initialize thread.
@
text
@d67 1
a67 1
      if (WSAGETSELECTEVENT(lParam) == FD_OOB)
@


1.19
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d27 1
d135 1
a135 1
  HANDLE hThread;
d138 2
a139 10
  hThread = makethread (Winmain, NULL, 0, "win");
  if (!hThread)
    {
      system_printf ("Cannot start window thread");
    }
  else
    {
      SetThreadPriority (hThread, THREAD_PRIORITY_HIGHEST);
      CloseHandle (hThread);
    }
@


1.18
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001 Red Hat, Inc.
@


1.17
log
@	* ioctl.cc (ioctl): Make third argument optional.
	* include/sys/ioctl.h: Ditto in declaration.
	* dtable.cc (dtable::init_std_file_from_handle): Revert previous
	bogus patch.
	* window.cc (WndProc): Raise SIGURG instead of SIGIO in case of FD_OOB
	message.
@
text
@d67 1
a67 1
        raise (SIGURG);
@


1.16
log
@* path.cc (path_conv::check): Don't complain if /dev/x/foo when x doesn't
exist.
(mount_info::conv_to_win32_path): Keep translating when a /cygdrive is found.
Don't attempt to translate to a device name when devn == FH_CYGDRIVE.
(cygwin_conv_to_win32_path): Set buffer to empty on error.
(cygwin_conv_to_full_win32_path): Ditto.
* window.cc: Include unistd.h to verify definitions.
@
text
@d21 2
d66 4
a69 1
      raise (SIGIO);
@


1.15
log
@* cygwin.din (ualarm): New export.
* dcrt0.cc (_dll_crt0): Add experimental tls storage declaration.
(dll_crt0): Ditto.
* debug.cc (thread_stub): Ditto.
* thread.cc: Minor cleanup.
(__pthread_create): Add experimental tls storage declaration.
* miscfuncs.cc: Define tls index.
* winsup.h: Declare experimental tls storage.
* window.cc (alarm): Use old timer return from setitimer.
(ualarm): New function.
@
text
@d21 1
@


1.15.10.1
log
@* path.cc (path_conv::check): Don't complain if /dev/x/foo when x doesn't
exist.
(mount_info::conv_to_win32_path): Keep translating when a /cygdrive is found.
Don't attempt to translate to a device name when devn == FH_CYGDRIVE.
(cygwin_conv_to_win32_path): Set buffer to empty on error.
(cygwin_conv_to_full_win32_path): Ditto.
* window.cc: Include unistd.h to verify definitions.
@
text
@a20 1
#include <unistd.h>
@


1.14
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d153 1
a153 2
extern "C"
int
d197 1
a197 2
extern "C"
int
d222 2
a223 2
  value->it_value.tv_sec = val/1000;
  value->it_value.tv_usec = val%1000;
d227 1
a227 2
extern "C"
unsigned int
a232 2
  getitimer (ITIMER_REAL, &oldt);

d237 1
a237 1
  setitimer (ITIMER_REAL, &newt, NULL);
d243 17
@


1.13
log
@Update copyrights.
@
text
@d77 1
a77 1
  static const NO_COPY char classname[] = "CygwinWndClass";
@


1.13.4.1
log
@Merged changes from HEAD
@
text
@a20 1
#include <unistd.h>
d77 1
a77 1
  static NO_COPY char classname[] = "CygwinWndClass";
d153 2
a154 1
extern "C" int
d198 2
a199 1
extern "C" int
d224 2
a225 2
  value->it_value.tv_sec = val / 1000;
  value->it_value.tv_usec = val % 1000;
d229 2
a230 1
extern "C" unsigned int
d236 2
d242 1
a242 1
  setitimer (ITIMER_REAL, &newt, &oldt);
a247 17

extern "C" useconds_t
ualarm (useconds_t value, useconds_t interval)
{
  struct itimerval timer, otimer;

  timer.it_value.tv_sec = 0;
  timer.it_value.tv_usec = value;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = interval;

  if (setitimer (ITIMER_REAL, &timer, &otimer) < 0)
    return (u_int)-1;

  return (otimer.it_value.tv_sec * 1000000) + otimer.it_value.tv_usec;
}

@


1.13.4.2
log
@Merged changes from HEAD
@
text
@a20 2
#define USE_SYS_TYPES_FD_SET
#include <winsock2.h>
d64 1
a64 4
      if (WSAGETSELECTEVENT(lParam) == FD_OOB)
        raise (SIGURG);
      else
	raise (SIGIO);
@


1.13.4.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
d67 1
a67 1
	raise (SIGURG);
@


1.13.4.4
log
@Merged changes from HEAD
@
text
@a26 1
#include "cygthread.h"
d134 1
a134 1
  cygthread *h;
d137 10
a146 2
  h = new cygthread (Winmain, NULL, "win");
  SetThreadPriority (*h, THREAD_PRIORITY_HIGHEST);
@


1.12
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000 Cygnus Solutions.
@


1.11
log
@forced commit
@
text
@d77 1
a77 1
  static char classname[] = "CygwinWndClass";
@


1.10
log
@Fix spacing, copyrights.
@
text
@@


1.9
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d59 1
a59 1
	  raise(SIGALRM);
d172 1
a172 1
      KillTimer (gethwnd(), timer_active);
d189 1
a189 1
  if (!(timer_active = SetTimer (gethwnd(), 1, elapse, NULL)))
@


1.8
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d17 1
d22 2
@


1.7
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d20 1
@


1.6
log
@* testsuite/winsup.api/winsup.exp: ignore stdout by default
* testsuite/winsup.api/crlf.c: non-verbose by default

* winsup.h: prune out windows headers we don't normally need
* assert.cc: add wingdi.h and winuser.h
* fhandler_console.cc: ditto
* fhandler_windows.cc: ditto
* select.cc: ditto
* spawn.cc: ditto
* strace.cc: ditto
* tty.cc: ditto
* window.cc: ditto
* hinfo.cc: add winsock.h
* syscalls.cc: add winnls.h
* uinfo.cc: ditto

* include/windows.h: optimize non-inclusion of repeat headers
@
text
@d13 1
a17 1
#include "winsup.h"
@


1.5
log
@* windows.cc (setitimer): Round up when < 1000 usecs.
@
text
@d18 2
@


1.4
log
@        * window.cc (setitimer): Check for overflow condition
        in tv_sec.
@
text
@d179 4
a182 1
    return 0;
@


1.3
log
@Throughout use strace class in place of individual functions and variables.
* cygwin.din: Eliminate _strace_wm.
* sigproc.cc (wait_sig): Temporarily add more debugging output.
* include/cygwin/version.h: Bump minor api to reflect export change.
@
text
@d16 1
d154 6
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d27 1
a27 1
  _strace_wm (uMsg, wParam, lParam);
@


1.1
log
@Initial revision
@
text
@d66 1
a66 1
Winmain (VOID *arg)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
