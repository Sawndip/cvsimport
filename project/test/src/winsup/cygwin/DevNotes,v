head	1.33;
access;
symbols
	cygwin-1_7_35-release:1.33
	cygwin-1_7_34-release:1.33
	cygwin-1_7_33-release:1.30.2.3
	cygwin-1_7_32-release:1.30.2.3
	cygwin-1_7_31-release:1.30.2.3
	cygwin-1_7_30-release:1.30.2.3
	cygwin-1_7_29-release:1.30.2.2
	cygwin-1_7_29-release-branchpoint:1.30.0.2
	cygwin-pre-user-db:1.30
	cygwin-1_7_28-release:1.30
	cygwin-1_7_27-release:1.30
	cygwin-1_7_26-release:1.30
	cygwin-1_7_25-release:1.30
	cygwin-1_7_24-release:1.30
	cygwin-1_7_23-release:1.30
	cygwin-1_7_22-release:1.30
	cygwin-1_7_21-release:1.30
	cygwin-1_7_20-release:1.29
	cygwin-1_7_19-release:1.29
	cygwin-64bit-postmerge:1.29
	cygwin-64bit-premerge-branch:1.29.0.2
	cygwin-64bit-premerge:1.29
	cygwin-1_7_18-release:1.29
	post-ptmalloc3:1.20.2.6
	pre-ptmalloc3:1.20.2.6
	cygwin-1_7_17-release:1.22
	cygwin-64bit-branch:1.20.0.2
	cygwin-1_7_16-release:1.17
	cygwin-1_7_15-release:1.7;
locks; strict;
comment	@# @;


1.33
date	2014.04.26.17.38.22;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2014.03.29.21.16.09;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2014.02.16.01.48.24;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.07.15.37.11;	author cgf;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2013.01.31.05.26.46;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.14.18.10.28;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.11.15.36.40;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.02.18.46.55;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.28.18.06.17;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.21.19.32.43;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.21.18.52.00;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.17.17.29.21;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.15.19.07.41;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2012.08.09.19.58.52;	author cgf;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2012.07.23.04.36.48;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2012.07.04.02.26.52;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2012.06.26.05.23.10;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.17.20.50.22;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2012.06.03.18.02.45;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2012.06.03.02.59.19;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2012.05.17.02.18.41;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2012.05.16.01.56.41;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.14.22.42.55;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.12.20.26.43;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.12.19.17.16;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.08.22.38.42;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.08.15.06.43;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2012.05.07.15.28.40;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2012.05.07.15.05.56;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.04.03.00.43;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2012.05.02.16.48.13;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2012.05.02.16.39.39;	author cgf;	state Exp;
branches;
next	;

1.30.2.1
date	2014.02.21.02.43.26;	author cgf;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2014.03.29.21.15.45;	author cgf;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2014.05.19.11.47.53;	author corinna;	state Exp;
branches;
next	;

1.20.2.1
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2012.10.16.15.18.37;	author corinna;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2013.01.09.16.27.19;	author corinna;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2013.01.14.12.57.04;	author corinna;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2013.01.17.17.17.10;	author corinna;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2013.02.05.15.30.11;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.33
log
@* DevNotes: Add entry cgf-000026.
* fhandler.h (fhandler_console::save_top): Save top of screen coordinates.
* fhandler_console.cc (dev::save_restore): Record top of screen coordinates.
Clear entire buffer when restoring saved buffer and try to position the cursor
on the save relative place on the screen.
@
text
@2014-04-26  cgf-000026

Forgot to clear to the end of screen when restoring a screen buffer.
That worked, for some reason, with Take Command but not with normal
consoles.  I don't remember why I didn't resize the screen like a Linux
X terminal emulator but that might have made things work a little
better.  Right now, there is a scroll bar for apps like less or vi and
that doesn't feel right.

2014-03-29  cgf-000025

Reorganized _cygtls::signal_debugger to avoid sending anything to the
debugger if we've seen an exception.  I think it used to work that way
and I changed it without noting why.  It sure seems like, if we don't do
this, gdb will see two signals and, it really does, when there has been
a Windows-recognized exception.

2014-02-15  cgf-000024

Wow.  It's hard getting the screen handling stuff working correctly when
there is a screen buffer larger than screen size and vice versa.  These
changes attempt to use SetConsoleWindowInfo whenever possible so that
the contents of the screen buffer are never wiped out.  They also fix
some previously misbehaving "scroll the screen" commands.

2013-06-07  cgf-000023

Given the fact that the signal thread never exits there is no need
for exit_thread to ever block.  So, nuke this code.

2013-01-31  cgf-000022

While researching the lftp behavior reported here:

http://cygwin.com/ml/cygwin/2013-01/msg00390.html

after a frenzy of rewriting sigflush handling to avoid blocking in the
signal thread (which is now and should ever have been illegal), it
dawned on me that we're not supposed to be flushing the tty input buffer
every time a signal is received.  We're supposed to do this only when
the user hits a character (e.g., CTRL-C) which initiates a signal
action.  So, I removed sigflush from sigpacket::process and moved it to
tc ()->kill_pgrp ().  This function should only be called to send
signals related to the tty so this should have the desired effect.

2013-01-11  cgf-000021

Apparently I got the signal handling semantics of select() wrong again
even though I would have sworn that I tested this on Linux and Windows.

select() is apparently *always* interrupted by a signal and *never*
restarts.  Hopefully, between the comment added to the code and this
note, I'll not make this mistake again.

2013-01-02  cgf-000020

(This entry should have been checked in with the changes but... I forgot)

This is a fairly big revamp of the way that windows signals are handled.
The intent is that all signal decisions should be made by the signal
thread; not by the exception handler.

This required the ability to pass information from the exception handler
to the signal thread so, a si_cyg field was added to siginfo_t.  This
contains information needed to generate a "core dump".  Hmm.  Haven't
checked to see if this breaks Cygwin's hardly-ever-used real core dump
facility.

Anyway, I moved signal_exit back into exceptions.cc and removed it from
the sigpacket class.  This function is now treated like a signal handler
function - Cygwin will cause it to be dispatched in the context of
whatever thread caught the signal.  signal_exit also makes the
determination about when to write a stackdump.

The signal-handler thread will no longer ever attempt to exit.  It will
just keep processing signals (it will not process real signals after
Cygwin stops shutting down, however).  This should make it impossible
for the signal thread to ever block waiting for the process lock since
it now never grabs the process lock.  The signal-handler thread will
notify gdb when it gets a signal now but, in theory, gdb should see the
context of the thread which received the signal, not the signal-handler
thread.

2012-12-28  cgf-000019

(I forgot to mention that cgf-000018 was reverted.  Although I never saw
a hang from this, I couldn't convince myself that one wasn't possible.)

This fix attempts to correct a deadlock where, when a true Windows
signal arrives, Windows creates a thread which "does stuff" and attempts
to exit.  In the process of exiting Cygwin grabs the process lock.  If
the signal thread has seen the signal and wants to exit, it can't
because the newly-created thread now holds it.  But, since the new
thread is relying on the signal thread to release its process lock,
it exits and the process lock is never released.

To fix this, I removed calls to _cygtls::signal_exit in favor of
flagging that we were exiting by setting signal_exit_code (almost forgot
to mark that NO_COPY: that would have been fun).  The new function
setup_signal_exit() now handles setting things up so that ReadFile loop
in wait_sig will do the right thing when it terminates.  This function
may just Sleep indefinitely if a signal is being sent from a thread
other than the signal thread.  wait_sig() was changed so that it will
essentially drop into asychronous-read-mode when a signal which exits
has been detected.  The ReadFile loop is exited when we know that the
process is supposed to be exiting and there is nothing else in the
signal queue.

Although I never actually saw this happen, exit_thread() was also
changed to release the process lock and just sleep indefintely if it is
detected that we are exiting.

2012-12-21  cgf-000018

Re: cgf-000017

It occurred to me that just getting the process lock during
DLL_THREAD_DETACH in dll_entry() might be adequate to fix this
problem.  It's certainly much less intrusive.

There are potential deadlock problems with grabbing a lock in
this code, though, so this check-in will be experimental.

2012-12-21  cgf-000017

The changes in this set are to work around the issue noted here:

http://cygwin.com/ml/cygwin/2012-12/threads.html#00140

The problem is, apparently, that the return value of an ExitThread()
will take precedence over the return value of TerminateProcess/ExitProcess
if the thread is the last one exiting.  That's rather amazing...

For the fix, I replaced all calls to ExitThread with exit_thread().  The
exit_thread function, creates a handle to the current thread and sends
it to a packet via sig_send(__SIGTHREADEXIT).  Then it acquires the
process lock and calls ExitThread.

wait_sig will then wait for the handle, indicating that the thread has
exited, and, when that has happened, removes the process lock on behalf
of the now-defunct thread.  wait_sig will now also avoid actually
exiting since it could trigger the same problem.

Holding process_lock should prevent threads from exiting while a Cygwin
process is shutting down.  They will just block forever in that case -
just like wait_sig.

2012-08-17  cgf-000016

While debugging another problem I finally noticed that
sigpacket::process was unconditionally calling tls->set_siginfo prior to
calling setup_handler even though setup_handler could fail.  In the
event of two successive signals, that would cause the second signal's
info to overwrite the first even though the signal handler for the first
would eventually be called.  Doh.

Fixing this required passing the sigpacket si field into setup_handler.
Making setup_handler part of the sigpacket class seemed to make a lot of
sense so that's what I did.  Then I passed the si element into
interrupt_setup so that the infodata structure could be filled out prior
to arming the signal.

The other changes checked in here eliminate the ResetEvent for
signal_arrived since previous changes to cygwait should handle the
case of spurious signal_arrived detection.  Since signal_arrived is
not a manual-reset event, we really should just let the appropriate
WFMO handle it.  Otherwise, there is a race where a signal comes in
a "split second" after WFMO responds to some other event.  Resetting
the signal_arrived would cause any subsequent WFMO to never be
triggered.  My current theory is that this is what is causing:

http://cygwin.com/ml/cygwin/2012-08/msg00310.html

2012-08-15  cgf-000015

RIP cancelable_wait.  Yay.

2012-08-09  cgf-000014

So, apparently I got it somewhat right before wrt signal handling.
Checking on linux, it appears that signals will be sent to a thread
which can accept the signal.  So resurrecting and extending the
"find_tls" function is in order.  This function will return the tls
of any thread which 1) is waiting for a signal with sigwait*() or
2) has the signal unmasked.

In redoing this it became obvious that I had the class designation wrong
for the threadlist handling so I moved the manipulation of the global
threadlist into the cygheap where it logically belongs.

2012-07-21  cgf-000013

These changes reflect a revamp of the "wait for signal" functionality
which has existed in Cygwin through several signal massages.

We now create a signal event only when a thread is waiting for a signal
and arm it only for that thread.  The "set_signal_arrived" function is
used to establish the event and set it in a location referencable by
the caller.

I still do not handle all of the race conditions.  What happens when
a signal comes in just after a WF?O succeeds for some other purpose?  I
suspect that it will arm the next WF?O call and the subsequent call to
call_signal_handler could cause a function to get an EINTR when possibly
it shouldn't have.

I haven't yet checked all of the test cases for the URL listed in the
previous entry.

Baby steps.

2012-06-12  cgf-000012

These changes are the preliminary for redoing the way threads wait for
signals.  The problems are shown by the test case mentioned here:

http://cygwin.com/ml/cygwin/2012-05/msg00434.html

I've known that the signal handling in threads wasn't quite right for
some time.  I lost all of my thread signal tests in the great "rm -r"
debacle of a few years ago and have been less than enthusiastic about
redoing everything (I had PCTS tests and everything).  But it really is
time to redo this signal handling to make it more like it is supposed to
be.

This change should not introduce any new behavior.  Things should
continue to behave as before.  The major differences are a change in the
arguments to cancelable_wait and cygwait now uses cancelable_wait and,
so, the returns from cygwait now mirror cancelable_wait.

The next change will consolidate cygwait and cancelable_wait into one
cygwait function.

2012-06-02  cgf-000011

The refcnt handling was tricky to get right but I had convinced myself
that the refcnt's were always incremented/decremented under a lock.
Corinna's 2012-05-23 change to refcnt exposed a potential problem with
dup handling where the fdtab could be updated while not locked.

That should be fixed by this change but, on closer examination, it seems
like there are many places where it is possible for the refcnt to be
updated while the fdtab is not locked since the default for
cygheap_fdget is to not lock the fdtab (and that should be the default -
you can't have read holding a lock).

Since refcnt was only ever called with 1 or -1, I broke it up into two
functions but kept the Interlocked* operation.  Incrementing a variable
should not be as racy as adding an arbitrary number to it but we have
InterlockedIncrement/InterlockedDecrement for a reason so I kept the
Interlocked operation here.

In the meantime, I'll be mulling over whether the refcnt operations are
actually safe as they are.  Maybe just ensuring that they are atomically
updated is enough since they control the destruction of an fh.  If I got
the ordering right with incrementing and decrementing then that should
be adequate.

2012-06-02  cgf-000010

<1.7.16>
- Fix emacs problem which exposed an issue with Cygwin's select() function.
  If a signal arrives while select is blocking and the program longjmps
  out of the signal handler then threads and memory may be left hanging.
  Fixes: http://cygwin.com/ml/cygwin/2012-05/threads.html#00275
</1.7.16>

This was try #4 or #5 to get select() signal handling working right.
It's still not there but it should now at least not leak memory or
threads.

I mucked with the interface between cygwin_select and select_stuff::wait
so that the "new" loop in select_stuff::wait() was essentially moved
into the caller.  cygwin_select now uses various enum states to decide
what to do.  It builds the select linked list at the beginning of the
loop, allowing wait() to tear everything down and restart.  This is
necessary before calling a signal handler because the signal handler may
longjmp away.

I initially had this all coded up to use a special signal_cleanup
callback which could be called when a longjmp is called in a signal
handler.  And cygwin_select() set up and tore down this callback.  Once
I got everything compiling it, of course, dawned on me that just because
you call a longjmp in a signal handler it doesn't mean that you are
jumping *out* of the signal handler.  So, if the signal handler invokes
the callback and returns it will be very bad for select().  Hence, this
slower, but hopefully more correct implementation.

(I still wonder if some sort of signal cleanup callback might still
be useful in the future)

TODO: I need to do an audit of other places where this problem could be
occurring.

As alluded to above, select's signal handling is still not right.  It
still acts as if it could call a signal handler from something other
than the main thread but, AFAICT, from my STC, this doesn't seem to be
the case.  It might be worthwhile to extend cygwait to just magically
figure this out and not even bother using w4[0] for scenarios like this.

2012-05-16  cgf-000009

<1.7.16>
- Fix broken console mouse handling.  Reported here:
  http://cygwin.com/ml/cygwin/2012-05/msg00360.html
</1.7.16>

I did a cvs annotate on smallprint.cc and see that the code to translate
%characters > 127 to 0x notation was in the 1.1 revision.  Then I
checked the smallprint.c predecessor.  It was in the 1.1 version of that
program too, which means that this odd change has probably been around
since <= 2000.

Since __small_sprintf is supposed to emulate sprintf, I got rid of the
special case handling.  This may affect fhandler_socket::bind.  If so, we
should work around this problem there rather than keeping this strange
hack in __small_printf.

2012-05-14  cgf-000008

<1.7.16>
- Fix hang when zero bytes are written to a pty using
  Windows WriteFile or equivalent.  Fixes:
  http://cygwin.com/ml/cygwin/2012-05/msg00323.html
</1.7.16>

cgf-000002, as usual, fixed one thing while breaking another.  See
Larry's predicament in: http://goo.gl/oGEr2 .

The problem is that zero byte writes to the pty pipe caused the dread
end-of-the-world-as-we-know-it problem reported on the mailing list
where ReadFile reads zero bytes even though there is still more to read
on the pipe.  This is because that change caused a 'record' to be read
and a record can be zero bytes.

I was never really keen about using a throwaway buffer just to get a
count of the number of characters available to be read in the pty pipe.
On closer reading of the documentation for PeekNamedPipe it seemed like
the sixth argument to PeekNamedPipe should return what I needed without
using a buffer.  And, amazingly, it did, except that the problem still
remained - a zero byte message still screwed things up.

So, we now detect the case where there is zero bytes available as a
message but there are bytes available in the pipe.  In that scenario,
return the bytes available in the pipe rather than the message length of
zero.  This could conceivably cause problems with pty pipe handling in
this scenario but since the only way this scenario could possibly happen
is when someone is writing zero bytes using WriteFile to a pty pipe, I'm
ok with that.

2012-05-14  cgf-000007

<1.7.16>
- Fix invocation of strace from a cygwin process.  Fixes:
  http://cygwin.com/ml/cygwin/2012-05/msg00292.html
</1.7.16>

The change in cgf-000004 introduced a problem for processes which load
cygwin1.dll dynamically.  strace.exe is the most prominent example of
this.

Since the parent handle is now closed for "non-Cygwin" processes, when
strace.exe tried to dynamically load cygwin1.dll, the handle was invalid
and child_info_spawn::handle_spawn couldn't use retrieve information
from the parent.  This eventually led to a strace_printf error due to an
attempt to dereference an unavailable cygheap.  Probably have to fix
this someday.  You shouldn't use the cygheap while attempting to print
an error about the inavailability of said cygheap.

This was fixed by saving the parent pid in child_info_spawn and calling
OpenProcess for the parent pid and using that handle iff a process is
dynamically loaded.

2012-05-12  cgf-000006

<1.7.16>
- Fix hang when calling pthread_testcancel in a canceled thread.
  Fixes some of: http://cygwin.com/ml/cygwin/2012-05/msg00186.html
</1.7.16>

This should fix the first part of the reported problem in the above
message.  The cancel seemed to actually be working but, the fprintf
eventually ended up calling pthread_testcancel.  Since we'd gotten here
via a cancel, it tried to recursively call the cancel handler causing a
recursive loop.

2012-05-12  cgf-000005

<1.7.16>
- Fix pipe creation problem which manifested as a problem creating a
fifo.  Fixes: http://cygwin.com/ml/cygwin/2012-05/msg00253.html
</1.7.16>

My change on 2012-04-28 introduced a problem with fifos.  The passed
in name was overwritten.  This was because I wasn't properly keeping
track of the length of the generated pipe name when there was a
name passed in to fhandler_pipe::create.

There was also another problem in fhandler_pipe::create.  Since fifos
use PIPE_ACCESS_DUPLEX and PIPE_ACCESS_DUPLEX is an or'ing of
PIPE_ACCESS_INBOUND and PIPE_ACCESS_OUTBOUND, using PIPE_ACCESS_OUTBOUND
as a "never-used" option for PIPE_ADD_PID in fhandler.h was wrong.  So,
fifo creation attempted to add the pid of a pipe to the name which is
wrong for fifos.

2012-05-08  cgf-000004

The change for cgf-000003 introduced a new problem:
http://cygwin.com/ml/cygwin/2012-05/msg00154.html
http://cygwin.com/ml/cygwin/2012-05/msg00157.html

Since a handle associated with the parent is no longer being duplicated
into a non-cygwin "execed child", Windows is free to reuse the pid of
the parent when the parent exits.  However, since we *did* duplicate a
handle pointing to the pid's shared memory area into the "execed child",
the shared memory for the pid was still active.

Since the shared memory was still available, if a new process reuses the
previous pid, Cygwin would detect that the shared memory was not created
and had a "PID_REAPED" flag.  That was considered an error, and, so, it
would set procinfo to NULL and pinfo::thisproc would die since this
situation is not supposed to occur.

I fixed this in two ways:

1) If a shared memory region has a PID_REAPED flag then zero it and
reuse it.  This should be safe since you are not really supposed to be
querying the shared memory region for anything after PID_REAPED has been
set.

2) Forego duping a copy of myself_pinfo if we're starting a non-cygwin
child for exec.

It seems like 2) is a common theme and an audit of all of the handles
that are being passed to non-cygwin children is in order for 1.7.16.

The other minor modification that was made in this change was to add the
pid of the failing process to fork error output.  This helps slightly
when looking at strace output, even though in this case it was easy to
find what was failing by looking for '^---' when running the "stv"
strace dumper.  That found the offending exception quickly.

2012-05-07  cgf-000003

<1.7.15>
Don't make Cygwin wait for all children of a non-cygwin child program.
Fixes: http://cygwin.com/ml/cygwin/2012-05/msg00063.html,
       http://cygwin.com/ml/cygwin/2012-05/msg00075.html
</1.7.15>

This problem is due to a recent change which added some robustness and
speed to Cygwin's exec/spawn handling by not trying to force inheritance
every time a process is started.  See ChangeLog entries starting on
2012-03-20, and multiple on 2012-03-21.

Making the handle inheritable meant that, as usual, there were problems
with non-Cygwin processes.  When Cygwin "execs" a non-Cygwin process N,
all of its N + 1, N + 2, ...  children will also inherit the handle.
That means that Cygwin will wait until all subprocesses have exited
before it returns.

I was willing to make this a restriction of starting non-Cygwin
processes but the problem with allowing that is that it can cause the
creation of a "limbo" pid when N exits and N + 1 and friends are still
around.  In this scenario, Cygwin dutifully notices that process N has
died and sets the exit code to indicate that but N's parent will wait on
rd_proc_pipe and will only return when every N + ...  windows process
has exited.

The removal of cygheap::pid_handle was not related to the initial
problem that I set out to fix.  The change came from the realization
that we were duping the current process handle into the child twice and
only needed to do it once.  The current process handle is used by exec
to keep the Windows pid "alive" so that it will not be reused.  So, now
we just close parent in child_info_spawn::handle_spawn iff we're not
execing.

In debugging this it bothered me that 'ps' identified a nonactive pid as
active.  Part of the reason for this was the 'parent' handle in
child_info was opened in non-Cygwin processes, keeping the pid alive.
That has been kluged around (more changes after 1.7.15) but that didn't
fix the problem.  On further investigation, this seems to be caused by
the fact that the shared memory region pid handles were still being
passed to non-cygwin children, keeping the pid alive in a limbo-like
fashion.  This was easily fixed by having pinfo::init() consider a
memory region with PID_REAPED as not available.  A more robust fix
should be considered for 1.7.15+ where these handles are not passed
to non-cygwin processes.

This fixed the problem where a pid showed up in the list after a user
does something like: "bash$ cmd /c start notepad" but, for some reason,
it does not fix the problem where "bash$ setsid cmd /c start notepad".
That bears investigation after 1.7.15 is released but it is not a
regression and so is not a blocker for the release.

2012-05-03  cgf-000002

<1.7.15>
Fix problem where too much input was attempted to be read from a
pty slave.  Fixes: http://cygwin.com/ml/cygwin/2012-05/msg00049.html
</1.7.15>

My change on 2012/04/05 reintroduced the problem first described by:
http://cygwin.com/ml/cygwin/2011-10/threads.html#00445

The problem then was, IIRC, due to the fact that bytes sent to the pty
pipe were not written as records.  Changing pipe to PIPE_TYPE_MESSAGE in
pipe.cc fixed the problem since writing lines to one side of the pipe
caused exactly that the number of characters to be read on the other
even if there were more characters in the pipe.

To debug this, I first replaced fhandler_tty.cc with the 1.258,
2012/04/05 version.  The test case started working when I did that.

So, then, I replaced individual functions, one at a time, in
fhandler_tty.cc with their previous versions.  I'd expected this to be a
problem with fhandler_pty_master::process_slave_output since that had
seen the most changes but was surprised to see that the culprit was
fhandler_pty_slave::read().

The reason was that I really needed the bytes_available() function to
return the number of bytes which would be read in the next operation
rather than the number of bytes available in the pipe.  That's because
there may be a number of lines available to be read but the number of
bytes which will be read by ReadFile should reflect the mode of the pty
and, if there is a line to read, only the number of bytes in the line
should be seen as available for the next read.

Having bytes_available() return the number of bytes which would be read
seemed to fix the problem but it could subtly change the behavior of
other callers of this function.  However, I actually think this is
probably a good thing since they probably should have been seeing the
line behavior.

2012-05-02  cgf-000001

<1.7.15>
Fix problem setting parent pid to 1 when process with children execs
itself.  Fixes: http://cygwin.com/ml/cygwin/2012-05/msg00009.html
</1.7.15>

Investigating this problem with strace showed that ssh-agent was
checking the parent pid and getting a 1 when it shouldn't have.  Other
stuff looked ok so I chose to consider this a smoking gun.

Going back to the version that the OP said did not have the problem, I
worked forward until I found where the problem first occurred -
somewhere around 2012-03-19.  And, indeed, the getppid call returned the
correct value in the working version.  That means that this stopped
working when I redid the way the process pipe was inherited around
this time period.

It isn't clear why (and I suspect I may have to debug this further at
some point) this hasn't always been a problem but I made the obvious fix.
We shouldn't have been setting ppid = 1 when we're about to pass off to
an execed process.

As I was writing this, I realized that it was necessary to add some
additional checks.  Just checking for "have_execed" isn't enough.  If
we've execed a non-cygwin process then it won't know how to deal with
any inherited children.  So, always set ppid = 1 if we've execed a
non-cygwin process.
@


1.32
log
@* DevNotes: Add entry cgf-000025.
* exceptions.cc (_cygtls::signal_debugger): Reorganize to avoid contacting the
debugger if we have already done so via the exception handler.  Eliminate need
for goto.  Remove an ifdef in favor of just allocating a larger buffer.
@
text
@d1 9
@


1.31
log
@* DevNotes: Add entry cgf-000024.
* fhandler.h (dev_console::state): Remove trailing underscore.
(dev_console::args): Ditto.
(dev_console::nargs): Ditto.
(dev_console::info): Eliminate subclass.
(dev_console::dwEnd): New field.
(dev_console::scroll_window): New function.
(dev_console::is_fullscreen): Ditto.
(dev_console::fillin): Rename from fillin_info.
(fhandler_console::scroll_buffer): Rename from scroll_screen.
* fhandler_console.cc: Throughout s/dev_state\.info/dev_state/g.  Accommodate
other name changes.
(dev_console::fillin): Accommodate rename.  Notice max x/y written to.  Forgo
memset if GetConsoleScreenBufferInfo fails.
(fhandler_console::scroll_buffer): Accommodate rename.  Don't treat y
coordinate of zero as top of screen.
(dev_console::is_fullscreen): New function.
(dev_console::scroll_window): Ditto.
(fhandler_console::clear_screen): Just scroll the screen when clearing the
screen in a state where the screen buffer is bigger than the screen.
(fhandler_console::char_command): Try harder to get 'S' and 'T' working in the
presence of a screen buffer.  Use temporary 'n' variable rather than
dev_state.args[0].  Use GNU ?: shortcut method.
@
text
@d1 8
@


1.30
log
@* DevNotes: Add entry cgf-000023.
* sigproc.cc (exit_thread): Remove now-unneeded sleep code.
@
text
@d1 8
@


1.30.2.1
log
@* DevNotes: Add entry cgf-000024.
* fhandler.h (dev_console::state): Remove trailing underscore.
(dev_console::args): Ditto.
(dev_console::nargs): Ditto.
(dev_console::info): Eliminate subclass.
(dev_console::dwEnd): New field.
(dev_console::scroll_window): New function.
(dev_console::is_fullscreen): Ditto.
(dev_console::fillin): Rename from fillin_info.
(fhandler_console::scroll_buffer): Rename from scroll_screen.
* fhandler_console.cc: Throughout s/dev_state\.info/dev_state/g.  Accommodate
other name changes.
(dev_console::fillin): Accommodate rename.  Notice max x/y written to.  Forgo
memset if GetConsoleScreenBufferInfo fails.
(fhandler_console::scroll_buffer): Accommodate rename.  Don't treat y
coordinate of zero as top of screen.
(dev_console::is_fullscreen): New function.
(dev_console::scroll_window): Ditto.
(fhandler_console::clear_screen): Just scroll the screen when clearing the
screen in a state where the screen buffer is bigger than the screen.
(fhandler_console::char_command): Try harder to get 'S' and 'T' working in the
presence of a screen buffer.  Use temporary 'n' variable rather than
dev_state.args[0].  Use GNU ?: shortcut method.
@
text
@a0 8
2014-02-15  cgf-000024

Wow.  It's hard getting the screen handling stuff working correctly when
there is a screen buffer larger than screen size and vice versa.  These
changes attempt to use SetConsoleWindowInfo whenever possible so that
the contents of the screen buffer are never wiped out.  They also fix
some previously misbehaving "scroll the screen" commands.

@


1.30.2.2
log
@* DevNotes: Add entry cgf-000025.
* exceptions.cc (_cygtls::signal_debugger): Reorganize to avoid contacting the
debugger if we have already done so via the exception handler.  Eliminate need
for goto.  Remove an ifdef in favor of just allocating a larger buffer.
@
text
@a0 8
2014-03-29  cgf-000025

Reorganized _cygtls::signal_debugger to avoid sending anything to the
debugger if we've seen an exception.  I think it used to work that way
and I changed it without noting why.  It sure seems like, if we don't do
this, gdb will see two signals and, it really does, when there has been
a Windows-recognized exception.

@


1.30.2.3
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@a0 9
2014-04-26  cgf-000026

Forgot to clear to the end of screen when restoring a screen buffer.
That worked, for some reason, with Take Command but not with normal
consoles.  I don't remember why I didn't resize the screen like a Linux
X terminal emulator but that might have made things work a little
better.  Right now, there is a scroll bar for apps like less or vi and
that doesn't feel right.

@


1.29
log
@* DevNotes: Add entry cgf-000022.
* cygtls.h (_cygtls::func): Define as a sa_sigaction style function.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(_cygtls::interrupt_setup): Fix coercion to accommodate 'func' change.
(ctrl_c_handler): Use tty kill_pgrp to send a signal.
(sigpacket::process): Don't process sigflush here.
(_cygtls::call_signal_handler): Reorganize to avoid a race.  Always call
sa_sigaction style function.
* fhandler_termios.cc (is_flush_sig): Define new function.
(tty_min::kill_pgrp): Handle tty flush when signal detected.
(fhandler_termios::bg_check): Be slightly more paranoid about checking for
valid tty.
(fhandler_termios::sigflush): Don't flush unless tty owner.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Use tty kill_pgrp to send
signal.
(fhandler_pty_master::ioctl): Ditto.
* signal.cc (killsys): Delete definition.
* sigproc.h (killsys): Delete declaration.
* include/cygwin/signal.h (siginfo_t): Simplify union/struct nesting slightly.
Implement mechanism to allow cygwin data passing.
@
text
@d1 5
@


1.28
log
@fix typo
@
text
@d1 15
@


1.27
log
@* DevNotes: Add entry cgf-000021.
* select.cc (select): Unconditionally return when a signal is detected.
(select_stuff::wait): Ditto.
@
text
@d95 1
a95 1
exited, and, when that has happened, remove the process lock on behalf
@


1.26
log
@* DevNotes: Add entry cgf-000020, relating to previous checkin.
@
text
@d1 9
@


1.25
log
@* DevNotes: Add entry cgf-000019.
* dcrt0.cc (do_exit): Just set exit_state to ES_EVENTS_TERMINATE and nuke call
to events_terminate which just set a superfluous flag.
* sigproc.cc (signal_exit_code): New variable.
(setup_signal_exit): Define new function.
(_cygtls::signal_exit): Remove accommodations for closing the signal pipe
handle.
(exit_thread): Just sleep if we're exiting.
(wait_sig): If signal_exit_code is set, just handle bookkeeping signals and
exit ReadFile loop if there is nothing more to process.  Call signal_exit at
end if signal_exit_code is non-zero.
* sigproc.h (setup_signal_exit): Declare new function.
* exceptions.cc (sigpacket::process): Use setup_signal_exit to control exiting
due to a signal.
(exception::handle): Ditto.  Query exit_state rather than defunct exit_already
to determine if we are exiting.
* globals.cc (ES_SIGNAL_EXIT): New enum.
* sync.h (lock_process::release): New function for explicitly unlocking muto.
(lock_process::~lock_process): Use release method.
@
text
@d1 29
@


1.24
log
@* DevNotes: Add entry cgf-000018.
* init.cc (dll_entry): Grab process lock before exiting to ensure that thread
doesn't exit before parent if parent is exiting.
* _cygtls.cc (_cygtls::call2): Revert previous 2012-12-21 change.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
* sigproc.cc (exit_thread): Ditto.
(wait_sig): Ditto.
* sync.cc (muto::release): Ditto.
* sync.h (muto::release): Ditto.
* sigproc.h (__SIGTHREADEXIT): Delete enum.
(exit_thread): Delete declaration.
@
text
@d1 29
@


1.23
log
@* DevNotes: Add entry cgf-000017.
* _cygtls.cc (_cygtls::call2): Use new exit_thread function in place of
ExitThread.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
(pthread_mutex::unlock): Set tid to NULL rather than 0.
(pthread_spinlock::unlock): Ditto.
* pinfo.cc (commune_process): Actually call lock_process constructor.
* sigproc.cc (exit_thread): New function.
(wait_sig): Handle __SIGTHREADEXIT case.  Don't just block rather than
returning from this function.
* sigproc.h (__SIGTHREADEXIT): New enum.
(exit_thread): Declare.
* sync.cc (muto::release): Accept a tls command-line argument.
* sync.h (muto::release): Accept a tls command-line parameter.  Default to
&_my_tls.
@
text
@d1 11
@


1.22
log
@* DevNotes: Add entry cgf-000016.
* cygtls.h (_cygtls::push): Inline.
(_cygtls::interrupt_now): Change signal number argument to siginfo_t argument.
(_cygtls::interrupt_setup): Ditto.
(_cygtls::set_siginfo): Delete declaration.
(_cygtls::reset_signal_arrived): Don't reset signal_arrived signal.  Just reset
flag.
* exceptions.cc (_cygtls::interrupt_now): Reflect argument changes.  Pass si to
interrupt_setup.
(_cygtls::interrupt_setup): Reflect argument changes.  Fill out tls infodata
here using passed-in si.  Use si.si_signo instead of sig.
(sigpacket::setup_handler): Move this function into sigpacket class.  Use si
field from the class as appropriate.
(sigpacket::process): Don't call tls->set_siginfo here since setup_handler
could fail.  Eliminate now-unneeded sig argument.
* sigproc.h (sigpacket::setup_handler): Move setup_handler to this class.
@
text
@d1 24
@


1.21
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d1 26
@


1.20
log
@* DevNotes: Add entry cgf-000014.
* cygheap.cc (tls_sentry): Move here, rename from 'sentry' in cygtls.cc
(tls_sentry::lock): Ditto.
(nthreads): Move from cygtls.cc
(THREADLIST_CHUNK): Ditto.
(cygheap_init): Call init_tls_list().
(init_cygheap::init_tls_list): Define new function.
(init_cygheap::add_tls): Ditto.
(init_cygheap::remove_tls): Ditto.
(init_cygheap::find_tls): Ditto.  Semi-resurrect from _cygtls::find_tls.
* cygheap.h (init_cygheap::init_tls_list): Declare new function.
(init_cygheap::add_tls): Ditto.
(init_cygheap::remove_tls): Ditto.
(init_cygheap::find_tls): Ditto.
* cygtls.cc (sentry): Delete.
(sentry::lock): Ditto.
(nthreads): Ditto.
(THREADLIST_CHUNK): Ditto.
(_cygtls::init): Delete definition.
(_cygtls::init_thread): Call cygheap->add_tls() to add thread to global list.
(_cygtls::remove): cygheap->remove_tls() to remove thread from global list.
* cygtls.h (_cygtls::init): Delete declaration.
* dcrt0.cc (dll_crt0_0): Delete call to _cygtls::init().
* exceptions.cc (sigpacket::process): When no thread is specified, try to find
one via cygheap->find_tls.
@
text
@d1 4
@


1.20.2.1
log
@Pull in changes from HEAD
@
text
@a0 4
2012-08-15  cgf-000015

RIP cancelable_wait.  Yay.

@


1.20.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@a0 26
2012-08-17  cgf-000016

While debugging another problem I finally noticed that
sigpacket::process was unconditionally calling tls->set_siginfo prior to
calling setup_handler even though setup_handler could fail.  In the
event of two successive signals, that would cause the second signal's
info to overwrite the first even though the signal handler for the first
would eventually be called.  Doh.

Fixing this required passing the sigpacket si field into setup_handler.
Making setup_handler part of the sigpacket class seemed to make a lot of
sense so that's what I did.  Then I passed the si element into
interrupt_setup so that the infodata structure could be filled out prior
to arming the signal.

The other changes checked in here eliminate the ResetEvent for
signal_arrived since previous changes to cygwait should handle the
case of spurious signal_arrived detection.  Since signal_arrived is
not a manual-reset event, we really should just let the appropriate
WFMO handle it.  Otherwise, there is a race where a signal comes in
a "split second" after WFMO responds to some other event.  Resetting
the signal_arrived would cause any subsequent WFMO to never be
triggered.  My current theory is that this is what is causing:

http://cygwin.com/ml/cygwin/2012-08/msg00310.html

@


1.20.2.3
log
@Pull in changes from HEAD
@
text
@a0 93
2013-01-02  cgf-000020

(This entry should have been checked in with the changes but... I forgot)

This is a fairly big revamp of the way that windows signals are handled.
The intent is that all signal decisions should be made by the signal
thread; not by the exception handler.

This required the ability to pass information from the exception handler
to the signal thread so, a si_cyg field was added to siginfo_t.  This
contains information needed to generate a "core dump".  Hmm.  Haven't
checked to see if this breaks Cygwin's hardly-ever-used real core dump
facility.

Anyway, I moved signal_exit back into exceptions.cc and removed it from
the sigpacket class.  This function is now treated like a signal handler
function - Cygwin will cause it to be dispatched in the context of
whatever thread caught the signal.  signal_exit also makes the
determination about when to write a stackdump.

The signal-handler thread will no longer ever attempt to exit.  It will
just keep processing signals (it will not process real signals after
Cygwin stops shutting down, however).  This should make it impossible
for the signal thread to ever block waiting for the process lock since
it now never grabs the process lock.  The signal-handler thread will
notify gdb when it gets a signal now but, in theory, gdb should see the
context of the thread which received the signal, not the signal-handler
thread.

2012-12-28  cgf-000019

(I forgot to mention that cgf-000018 was reverted.  Although I never saw
a hang from this, I couldn't convince myself that one wasn't possible.)

This fix attempts to correct a deadlock where, when a true Windows
signal arrives, Windows creates a thread which "does stuff" and attempts
to exit.  In the process of exiting Cygwin grabs the process lock.  If
the signal thread has seen the signal and wants to exit, it can't
because the newly-created thread now holds it.  But, since the new
thread is relying on the signal thread to release its process lock,
it exits and the process lock is never released.

To fix this, I removed calls to _cygtls::signal_exit in favor of
flagging that we were exiting by setting signal_exit_code (almost forgot
to mark that NO_COPY: that would have been fun).  The new function
setup_signal_exit() now handles setting things up so that ReadFile loop
in wait_sig will do the right thing when it terminates.  This function
may just Sleep indefinitely if a signal is being sent from a thread
other than the signal thread.  wait_sig() was changed so that it will
essentially drop into asychronous-read-mode when a signal which exits
has been detected.  The ReadFile loop is exited when we know that the
process is supposed to be exiting and there is nothing else in the
signal queue.

Although I never actually saw this happen, exit_thread() was also
changed to release the process lock and just sleep indefintely if it is
detected that we are exiting.

2012-12-21  cgf-000018

Re: cgf-000017

It occurred to me that just getting the process lock during
DLL_THREAD_DETACH in dll_entry() might be adequate to fix this
problem.  It's certainly much less intrusive.

There are potential deadlock problems with grabbing a lock in
this code, though, so this check-in will be experimental.

2012-12-21  cgf-000017

The changes in this set are to work around the issue noted here:

http://cygwin.com/ml/cygwin/2012-12/threads.html#00140

The problem is, apparently, that the return value of an ExitThread()
will take precedence over the return value of TerminateProcess/ExitProcess
if the thread is the last one exiting.  That's rather amazing...

For the fix, I replaced all calls to ExitThread with exit_thread().  The
exit_thread function, creates a handle to the current thread and sends
it to a packet via sig_send(__SIGTHREADEXIT).  Then it acquires the
process lock and calls ExitThread.

wait_sig will then wait for the handle, indicating that the thread has
exited, and, when that has happened, remove the process lock on behalf
of the now-defunct thread.  wait_sig will now also avoid actually
exiting since it could trigger the same problem.

Holding process_lock should prevent threads from exiting while a Cygwin
process is shutting down.  They will just block forever in that case -
just like wait_sig.

@


1.20.2.4
log
@Pull in changes from HEAD
@
text
@a0 9
2013-01-11  cgf-000021

Apparently I got the signal handling semantics of select() wrong again
even though I would have sworn that I tested this on Linux and Windows.

select() is apparently *always* interrupted by a signal and *never*
restarts.  Hopefully, between the comment added to the code and this
note, I'll not make this mistake again.

@


1.20.2.5
log
@Pull in changes from HEAD
@
text
@d95 1
a95 1
exited, and, when that has happened, removes the process lock on behalf
@


1.20.2.6
log
@Pull in changes from HEAD
@
text
@a0 15
2013-01-31  cgf-000022

While researching the lftp behavior reported here:

http://cygwin.com/ml/cygwin/2013-01/msg00390.html

after a frenzy of rewriting sigflush handling to avoid blocking in the
signal thread (which is now and should ever have been illegal), it
dawned on me that we're not supposed to be flushing the tty input buffer
every time a signal is received.  We're supposed to do this only when
the user hits a character (e.g., CTRL-C) which initiates a signal
action.  So, I removed sigflush from sigpacket::process and moved it to
tc ()->kill_pgrp ().  This function should only be called to send
signals related to the tty so this should have the desired effect.

@


1.19
log
@Change "set_thread_waiting" to "set_signal_arrived" throughout.
@
text
@d1 13
@


1.18
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d7 1
a7 1
and arm it only for that thread.  The "set_thread_waiting" function is
@


1.17
log
@fix typo
@
text
@d1 21
@


1.16
log
@fix typo
@
text
@d31 1
a31 1
ilke there are many places where it is possible for the refcnt to be
@


1.15
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d11 1
a11 1
redoing everything (I had PCTS tests and everyting).  But it really is
@


1.14
log
@* DevNotes: Add entry cgf-000011.
* fhandler.h (fhandler_base::refcnt): Delete.
(fhandler_base::inc_refcnt): New function.
(fhandler_base::dec_refcnt): New function.
* cygheap.h (cygheap_fdnew::~cygheap_fdnew): Accommodate split of refcnt to
inc_refcnt/dec_refcnt.
(cygheap_fdget::cygheap_fdget): Ditto.
(cygheap_fdget::~cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable::release): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::init_std_file_from_handle): Ditto.
(dtable::dup3): On success, return with fdtab locked.
* dtable.h (dtable): Add dup_finish as a friend.
* syscalls.cc (dup_finish): Define new function.  Increment refcnt while fdtab
is locked.
(dup2): Use common dup_finish() to perform dup operation.
(dup3): Ditto.
@
text
@d1 22
@


1.13
log
@* DevNotes: Add entry cgf-000010.
* select.cc (set_handle_or_return_if_not_open): Remove unneeded final backslash
from definition.
(cygwin_select): Reorganize to incorporate outer retry loop.  Move remaining
time recalculation here for retry case.  Use select_stuff::wait_states for loop
control.
(select_stuff::cleanup): Avoid unneeded initialization.
(select_stuff::wait): Modify definition to return select_stuff::wait_states.
Eliminate is_cancelable.  Don't element 1 of an array if it is a cancel handle.
Remove loop.  Rely on being called from enclosing loop in cygwin_select.
Remove time recalculation when restarting.  Try harder to always return from
the bottom.
* select.h (select_stuff::wait_state): New enum.
(select_stuff::wait): Modify declaration to return select_stuff::wait_states.
@
text
@d1 25
@


1.12
log
@* DevNotes: Add entry cgf-000009.
* smallprint.cc (__small_vsprintf): Always treat '%c' and '%C' as characters.
Don't decode them if they are > 127.
(__small_vswprintf): Ditto.
@
text
@d1 42
@


1.11
log
@* DevNotes: Add entry cgf-000008.
* fhandler_tty.cc (bytes_available): Simplify by returning the number of bytes
available in the message unless that is zero.
@
text
@d1 18
@


1.10
log
@* DevNotes: Add entry cgf-000007.
* child_info.h (child_info_spawn::parent_winpid): Declare new field.
(child_info_spawn::get_parent_handle): Declare new function.
* dcrt0.cc (child_info_spawn::get_parent_handle): Define new function.
(child_info_spawn::handle_spawn): Recreate parent handle if possible when
dynamically loaded.  Don't mess with parent handle if it's NULL.
* spawn.cc (child_info_spawn::worker): Set parent_winpid appropriately.
@
text
@d1 32
@


1.9
log
@* DevNotes: Add entry cgf-000006.
* thread.cc (pthread::pop_cleanup_handler): Set cancel state to disabled to
avoid recursively waiting for cancel.
@
text
@d1 23
@


1.8
log
@* DevNotes: Add entry cgf-000005.
* fhandler.h (PIPE_ADD_PID): Redefine to something we actually DON'T use.
* pipe.cc (fhandler_pipe::create): Avoid clearing all open_mode bits when
checking for PIPE_ADD_PID.  Properly keep track of len so that passed in name
is not overwritten.
@
text
@d1 13
@


1.7
log
@Add url for reported mailing list problem
@
text
@d1 19
@


1.6
log
@* DevNotes: Add entry cgf-000004.
* pinfo.cc (pinfo::init): Reuse shared memory if the state is marked with
PID_REAPED.
* spawn.cc (child_info_spawn::worker): Don't duplicate myself_pinfo into
non-cygwin child.
* fork.cc (frok::parent): Improve error output.
@
text
@d3 3
a5 1
The change associated with cgf-000003 introduced a new problem.
d149 1
a149 1
some poit) this hasn't always been a problem but I made the obvious fix.
@


1.5
log
@Add additional observation to cgf-000003
@
text
@d1 36
a36 1
2012-05-03  cgf-000003
@


1.4
log
@* DevNotes: Add entry cgf-000003.
* cygheap.h (init_cygheap::pid_handle): Delete.
* dcrt0.cc (child_info_spawn::handle_spawn): Keep parent open if we have
execed.
* pinfo.cc (pinfo::thisproc): Remove pid_handle manipulations.
(pinfo::init): Don't consider a reaped process to be available.
* spawn.cc (child_info_spawn::worker): Remove pid_handle manipulations.  Make
wr_proc_pipe and parent noninheritable when starting a program which doesn't
use the Cygwin DLL.  Conditionally reset wr_proc_pipe to inheritable if
CreateProcess fails.  Inject wr_proc_pipe handle into non-Cygwin process.
Consider a non-cygwin process to be 'synced'.
@
text
@d44 3
a46 1
memory region with PID_REAPED as not available.
@


1.3
log
@* DevNotes: Add entry cgf-000002.
* fhandler_tty.cc (bytes_available): Revert to previous Oct-2011 behavior where
a dummy buffer is used to determine how many bytes will be read.
(fhandler_pty_master::ioctl): Correct coercion in assignment.
@
text
@d1 51
@


1.2
log
@.
@
text
@d1 39
@


1.1
log
@* ChangeNotes: New file.  Add entry cgf-000001.
* sigproc.cc (proc_terminate): Don't set parent pid of child to 1 if we've
execed since the execed process is still considered the parent.
* child_info.h: Bump copyright.
@
text
@d3 4
a6 2
This fix was due to a bug report on the Cygwin mailing list:
http://cygwin.com/ml/cygwin/2012-05/msg00009.html
d8 3
a10 3
strace showed that ssh-agent was checking the parent pid and getting a 1
when it shouldn't have.  Other stuff looked ok so I chose to consider
this a smoking gun.
@

