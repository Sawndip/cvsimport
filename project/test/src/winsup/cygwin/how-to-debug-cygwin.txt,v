head	1.12;
access;
symbols
	cygwin-1_7_35-release:1.12
	cygwin-1_7_34-release:1.12
	cygwin-1_7_33-release:1.12
	cygwin-1_7_32-release:1.12
	cygwin-1_7_31-release:1.12
	cygwin-1_7_30-release:1.12
	cygwin-1_7_29-release:1.12
	cygwin-1_7_29-release-branchpoint:1.12.0.18
	cygwin-pre-user-db:1.12
	cygwin-1_7_28-release:1.12
	cygwin-1_7_27-release:1.12
	cygwin-1_7_26-release:1.12
	cygwin-1_7_25-release:1.12
	cygwin-1_7_24-release:1.12
	cygwin-1_7_23-release:1.12
	cygwin-1_7_22-release:1.12
	cygwin-1_7_21-release:1.12
	cygwin-1_7_20-release:1.12
	cygwin-1_7_19-release:1.12
	cygwin-64bit-postmerge:1.12
	cygwin-64bit-premerge-branch:1.12.0.16
	cygwin-64bit-premerge:1.12
	cygwin-1_7_18-release:1.12
	post-ptmalloc3:1.12
	pre-ptmalloc3:1.12
	cygwin-1_7_17-release:1.12
	cygwin-64bit-branch:1.12.0.14
	cygwin-1_7_16-release:1.12
	cygwin-1_7_15-release:1.12
	cygwin-1_7_14_2-release:1.12
	cygwin-1_7_14-release:1.12
	cygwin-1_7_12-release:1.12
	cygwin-1_7_11-release:1.12
	cygwin-1_7_10-release:1.12
	signal-rewrite:1.12.0.12
	pre-notty:1.12
	cygwin-1_7_9-release:1.12
	cv-post-1_7_9:1.12.0.10
	cygwin-1_7_8-release:1.12
	cygwin-1_7_7-release:1.12
	cygwin-1_7_5-release:1.12
	cygwin-1_7_4-release:1.12
	cygwin-1_7_3-release:1.12
	cygwin-1_7_2-release:1.12
	fifo_doover3:1.12.0.8
	cygwin-1_7_1-release:1.12
	prefifo:1.12
	cv-branch-2:1.12.0.6
	pre-ripout-set_console_state_for_spawn:1.12
	EOL_registry_mounts:1.12
	preoverlapped:1.12
	drop_9x_support_start:1.12
	cr-0x5f1:1.12.0.4
	cv-branch:1.12.0.2
	pre-ptymaster-archetype:1.12
	cr-0x3b58:1.11.0.4
	cr-0x5ef:1.11.0.2
	after-mmap-privanon-noreserve:1.11
	after-mmap-revamp:1.11
	before-mmap-revamp:1.11
	cgf-more-exit-sync:1.11
	post_wait_sig_exit:1.11
	pre_wait_sig_exit:1.11
	reparent-point:1.9
	noreparent:1.9.0.18
	cr-0x5e6:1.9.0.14
	cr-0x9e:1.9.0.12
	cr-0x9d:1.9.0.10
	cgf-deleteme:1.9.0.8
	pre-sigrewrite:1.9
	corinna-01:1.9
	cr-0x9c:1.9.0.6
	cr-0x9b:1.9.0.4
	cr-0x99:1.9
	Z-emcb-cygwin_daemon:1.9.0.2
	w32api-2_2:1.9
	mingw-runtime-2_4:1.9
	pre-cgf-merge:1.9
	cgf-dev-branch:1.9.0.16
	predaemon:1.6
	cygwin_daemon_merge_HEAD:1.6
	pregp02r1:1.6.0.2
	cygnus_cvs_20020108_pre:1.5
	Z-cygwin_daemon_merge-new_HEAD:1.9
	Z-cygwin_daemon_merge_HEAD:1.9
	cygwin_daemon:1.2.0.2;
locks; strict;
comment	@# @;


1.12
date	2006.05.28.21.39.37;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.06.21.09.35;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.25.05.03.53;	author joshuadfranklin;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.13.21.15.10;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.13.21.13.37;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.13.21.08.13;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.30.02.44.21;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.10.03.35.54;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.05.03.16.58;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.09.18.12.51;	author duda;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.16.02.56.48;	author cgf;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.09.14.17.43.17;	author duda;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.02.28.12.53.25;	author rbcollins;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.07.13.21.44.07;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Put an underscore in front of the "active" in "strace.active".
@
text
@Copyright 2001, 2002, 2005 Red Hat Inc., Egor Duda

So, your favorite program has crashed?  And did you say something about
'stackdump'?  Or it just prints its output from left to right and
upside-down?  Well, you can file an angry bug report and wait until some
of the core developers try to reproduce your problem, try to find what's
the matter with your program and cygwin and fix the bug, if any.  But
you can do something better than that.  You can debug the problem
yourself, and even if you can't fix it, your analysis may be very
helpful.  Here's the (incomplete) howto on cygwin debugging.

1.  First things first

    The first thing you'll need to do is to build cygwin1.dll and your
    crashed application from sources.  To debug them you'll need debug
    information, which is normally stripped from executables.  You probably
    also want to build a version of the dll with more debugging capabilities
    by reconfiguring your build directory, specifying the --enable-debugging
    option to configure.

2. Creating a known-working cygwin debugging environment

   - create a separate directory, say, c:\cygdeb, and put known-working
     cygwin1.dll and gdb.exe in it.
   - create a wrapper c:\cygdeb\debug_wrapper.cmd:

========= debug_wrapper.cmd =========
rem setting CYGWIN_TESTING environment variable makes cygwin application
rem not to interfere with other already running cygwin applications.
set CYGWIN_TESTING=1
c:\cygdeb\gdb.exe -nw %1 %2
===================================

3. Using cygwin's JIT debugging facility

   add 'error_start=c:\cygdeb\debug_wrapper.cmd' to CYGWIN environment
   variable. When some application encounters critical error, cygwin will stop
   it and execute debug_wrapper.cmd, which will run gdb and make it to attach to
   the crashed application.

4. Strace

   You can run your program under 'strace' utility, described if user's manual.
   If you know where the problem approximately is, you can add a bunch of
   additional debug_printf()s in the source code and see what they print in
   strace log. There's one common problem with this method, that some bugs
   may mysteriously disappear once the program is run under strace. Then the
   bug is likely a race condition. strace has two useful options to deal with
   such situation: -b enables buffering of output and reduces additional
   timeouts introduced by strace, and -m option allows you to mask certain
   classes of *_printf() functions, reducing timeouts even more.

   Note that strace does not use the cygwin DLL and so any process that it
   starts does not inherit a cygwin environment.  It is equivalent to starting
   a program from the command prompt.

5. Problems at early startup

   Sometimes, something crashes at the very early stages of application
   initialization, when JIT debugging facility is not yet active. Ok, there's
   another environment variable that may help. Create program_wrapper.cmd:

========= program_wrapper.cmd =========
rem setting CYGWIN_SLEEP environment variable makes cygwin application
rem to sleep for x milliseconds at startup
set CYGWIN_SLEEP=20000
c:\some\path\bad_program.exe some parameters
===================================

   Now, run program_wrapper.cmd. It should print running program pid.
   After starting program_wrapper.cmd you've got 20 seconds to open another
   window, cd to c:\cygdeb in it, run gdb there and in gdb prompt type

   (gdb) attach <pid>

   where <pid> is the pid that program_wrapper.cmd have printed.
   After that you can normally step through the code in cygwin1.dll and
   bad_program.exe

6. More problems at early startup

   You can also set a CYGWIN_DEBUG variable to force the debugger to pop up
   only when a certain program is run:

set CYGWIN_DEBUG=cat.exe:gdb.exe

   This will force gdb.exe to start when the program name contains the string
   "cat.exe".  The ':gdb.exe' isn't really needed, since it is the default.
   It is just there to show how you can specify a program to run when the
   program starts.  You can optionally set a breakpoint on "break_here"
   once the debugger pops up and then you can single step through the
   initialization process.

   Note that it bears repeating that both of the above options are *only*
   available when configuring cygwin with --enable-debugging.

7. Heap corruption

   If your program crashes at malloc() or free() or when it references some
   malloc()'ed memory, it looks like heap corruption. You can configure and
   build special version of cygwin1.dll which includes heap sanity checking.
   To do it, just add --enable-malloc-debugging option to configure. Be warned,
   however, that this version of dll is _very_ slow (10-100 times slower than
   normal), so use it only when absolutely necessary.

8. Program dies when running under strace

   If your program crashes when you run it using strace but runs ok (or has a
   different problem) otherwise, then there may be a problem in one of the
   strace *_printf statements.  Usually this is caused by a change in arguments
   resulting in a %s being used with something other than a pointer to a
   string.

   To debug this scenario, do something like this:

    bash$ gdb -nw yourapp.exe
    (gdb) dll cygwin1
    (gdb) l dll_crt0_1
    (gdb) b <<first line in the function>>
    (gdb) run
    (gdb) set strace._active=1
    (gdb) continue

   The program will then run in "strace mode", calling each strace *_printf,
   just like it does when run under the strace program.  Eventually, the
   program will crash, probably in small_printf.  At that point, a 'bt'
   command should show you the offending call to strace_printf with the
   improper format string.
@


1.11
log
@fix breakpoint example
@
text
@d121 1
a121 1
    (gdb) set strace.active=1
@


1.10
log
@* how-to-debug-cygwin.txt: Fix typo.
@
text
@d1 1
a1 1
Copyright 2001, 2002 Red Hat Inc., Egor Duda
d119 1
a119 1
    (gdb) bp <<first line in the function>>
@


1.9
log
@add initial information
@
text
@d85 1
a85 1
set CYGWIN_DEBUG=cat.exe=gdb.exe
d88 1
a88 1
   "cat.exe".  The '=gdb.exe' isn't really needed, since it is the default.
@


1.8
log
@cleanup a tad
@
text
@d90 3
a92 1
   program starts.
@


1.7
log
@* dcrt0.cc (dll_crt0_1): Delay closing of some handles until cygheap has been
set up.
(break_here): New function, for debugging.
(initial_env): Add program name to "Sleeping" message.  Implement new
"CYGWIN_DEBUG" environment variable option.
* exceptions.cc (debugger_command): Add argument to dumper call.
* strace.cc (strace::hello): Use winpid if cygwin pid is unavailable.
(strace::vsprntf): Ditto.
@
text
@d1 1
a1 1
Copyright 2001 Red Hat Inc., Egor Duda
d12 3
a14 1
1.  The first thing you'll need to do is to build cygwin1.dll and your
d21 2
a22 1
2. Create known-working cygwin debugging environment.
d34 2
a35 1
3. Try to use cygwin's JIT debugging facility:
d41 2
a42 1
4. Strace.
d57 2
a58 1
5. Problems at early startup.
d80 2
d95 2
a96 1
6. Heap corruption.
d104 2
a105 1
7. Program dies when running under strace.
@


1.6
log
@add more words
@
text
@d74 13
@


1.5
log
@whitespace cleanup
@
text
@d3 15
a17 12
So, your favorite program has crashed? And did you say something about
'stackdump'? Or it just prints its output from left to right and upside-down?
Well, you can file an angry bug report and wait until some of the core
developers try to reproduce your problem, try to find what's the matter
with your program and cygwin and fix the bug, if any. But you can do something
better than that. You can debug the problem yourself, and even if you can't
fix it, your analysis may be very helpful. Here's the (incomplete) howto on
cygwin debugging.

1. The first thing you'll need to do is to build cygwin1.dll and your crashed
application from sources. To debug them you'll need debug information, which
is normally stripped from executables.
d20 3
a22 3
- create a separate directory, say, c:\cygdeb, and put known-working
  cygwin1.dll and gdb.exe in it.
- create a wrapper c:\cygdeb\debug_wrapper.cmd:
d32 4
a35 4
- add 'error_start=c:\cygdeb\debug_wrapper.cmd' to CYGWIN environment
  variable. When some application encounters critical error, cygwin will stop
  it and execute debug_wrapper.cmd, which will run gdb and make it to attach to
  the crashed application.
d38 13
a50 9
  You can run your program under 'strace' utility, described if user's manual.
  If you know where the problem approximately is, you can add a bunch of
  additional debug_printf()s in the source code and see what they print in
  strace log. There's one common problem with this method, that some bugs
  may mysteriously disappear once the program is run under strace. Then the
  bug is likely a race condition. strace has two useful options to deal with
  such situation: -b enables buffering of output and reduces additional
  timeouts introduced by strace, and -m option allows you to mask certain
  classes of *_printf() functions, reducing timeouts even more.
d53 3
a55 3
  Sometimes, something crashes at the very early stages of application
  initialization, when JIT debugging facility is not yet active. Ok, there's
  another environment variable that may help. Create program_wrapper.cmd:
d64 9
a72 9
  Now, run program_wrapper.cmd. It should print running program pid.
  After starting program_wrapper.cmd you've got 20 seconds to open another
  window, cd to c:\cygdeb in it, run gdb there and in gdb prompt type

  (gdb) attach <pid>

  where <pid> is the pid that program_wrapper.cmd have printed.
  After that you can normally step through the code in cygwin1.dll and
  bad_program.exe
d75 6
a80 6
  If your program crashes at malloc() or free() or when it references some
  malloc()'ed memory, it looks like heap corruption. You can configure and
  build special version of cygwin1.dll which includes heap sanity checking.
  To do it, just add --enable-malloc-debugging option to configure. Be warned,
  however, that this version of dll is _very_ slow (10-100 times slower than
  normal), so use it only when absolutely necessary.
d83 21
a103 21
  If your program crashes when you run it using strace but runs ok (or has a
  different problem) otherwise, then there may be a problem in one of the
  strace *_printf statements.  Usually this is caused by a change in arguments
  resulting in a %s being used with something other than a pointer to a
  string.

  To debug this scenario, do something like this:

   bash$ gdb -nw yourapp.exe
   (gdb) dll cygwin1
   (gdb) l dll_crt0_1
   (gdb) bp <<first line in the function>>
   (gdb) run
   (gdb) set strace.active=1
   (gdb) continue

  The program will then run in "strace mode", calling each strace *_printf,
  just like it does when run under the strace program.  Eventually, the
  program will crash, probably in small_printf.  At that point, a 'bt'
  command should show you the offending call to strace_printf with the
  improper format string.
@


1.4
log
@Add strace debugging section.
@
text
@d56 1
a56 1
 
@


1.3
log
@fix typos
@
text
@d9 1
a9 1
fix it, your analysis may be very helpful. Here's the (incomplete) howto on 
d14 1
a14 1
is normally stripped from executables. 
d36 2
a37 2
  If you know where the problem approximately is, you can add a bunch of 
  additional debug_printf()s in the source code and see what they print in 
d45 1
a45 1
5. Problems at early startup. 
d56 1
a56 1
  
d74 23
@


1.2
log
@minor typo fixes.
@
text
@d3 1
a3 1
So, your favourite program has crashed? And did you say something about
d9 1
a9 1
fix it, your analysis may be very helpful. Here's the (incoplete) howto on 
d22 1
a22 1
rem setting CYGWIN_TESTING environement variable makes cygwin application
d39 1
a39 1
  may misteriously disappear once the program is run under strace. Then the
d51 1
a51 1
rem setting CYGWIN_SLEEP environement variable makes cygwin application
d73 1
a73 1
  normal), so use it only when absolutely neccessary.
@


1.2.2.1
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
So, your favorite program has crashed? And did you say something about
d9 1
a9 1
fix it, your analysis may be very helpful. Here's the (incomplete) howto on
d14 1
a14 1
is normally stripped from executables.
d22 1
a22 1
rem setting CYGWIN_TESTING environment variable makes cygwin application
d36 2
a37 2
  If you know where the problem approximately is, you can add a bunch of
  additional debug_printf()s in the source code and see what they print in
d39 1
a39 1
  may mysteriously disappear once the program is run under strace. Then the
d45 1
a45 1
5. Problems at early startup.
d51 1
a51 1
rem setting CYGWIN_SLEEP environment variable makes cygwin application
d56 1
a56 1

d73 1
a73 24
  normal), so use it only when absolutely necessary.

7. Program dies when running under strace.
  If your program crashes when you run it using strace but runs ok (or has a
  different problem) otherwise, then there may be a problem in one of the
  strace *_printf statements.  Usually this is caused by a change in arguments
  resulting in a %s being used with something other than a pointer to a
  string.

  To debug this scenario, do something like this:

   bash$ gdb -nw yourapp.exe
   (gdb) dll cygwin1
   (gdb) l dll_crt0_1
   (gdb) bp <<first line in the function>>
   (gdb) run
   (gdb) set strace.active=1
   (gdb) continue

  The program will then run in "strace mode", calling each strace *_printf,
  just like it does when run under the strace program.  Eventually, the
  program will crash, probably in small_printf.  At that point, a 'bt'
  command should show you the offending call to strace_printf with the
  improper format string.
@


1.2.2.2
log
@Merged changes from HEAD
@
text
@d3 12
a14 15
So, your favorite program has crashed?  And did you say something about
'stackdump'?  Or it just prints its output from left to right and
upside-down?  Well, you can file an angry bug report and wait until some
of the core developers try to reproduce your problem, try to find what's
the matter with your program and cygwin and fix the bug, if any.  But
you can do something better than that.  You can debug the problem
yourself, and even if you can't fix it, your analysis may be very
helpful.  Here's the (incomplete) howto on cygwin debugging.

1.  The first thing you'll need to do is to build cygwin1.dll and your
    crashed application from sources.  To debug them you'll need debug
    information, which is normally stripped from executables.  You probably
    also want to build a version of the dll with more debugging capabilities
    by reconfiguring your build directory, specifying the --enable-debugging
    option to configure.
d17 3
a19 3
   - create a separate directory, say, c:\cygdeb, and put known-working
     cygwin1.dll and gdb.exe in it.
   - create a wrapper c:\cygdeb\debug_wrapper.cmd:
d29 4
a32 4
   add 'error_start=c:\cygdeb\debug_wrapper.cmd' to CYGWIN environment
   variable. When some application encounters critical error, cygwin will stop
   it and execute debug_wrapper.cmd, which will run gdb and make it to attach to
   the crashed application.
d35 9
a43 13
   You can run your program under 'strace' utility, described if user's manual.
   If you know where the problem approximately is, you can add a bunch of
   additional debug_printf()s in the source code and see what they print in
   strace log. There's one common problem with this method, that some bugs
   may mysteriously disappear once the program is run under strace. Then the
   bug is likely a race condition. strace has two useful options to deal with
   such situation: -b enables buffering of output and reduces additional
   timeouts introduced by strace, and -m option allows you to mask certain
   classes of *_printf() functions, reducing timeouts even more.

   Note that strace does not use the cygwin DLL and so any process that it
   starts does not inherit a cygwin environment.  It is equivalent to starting
   a program from the command prompt.
d46 3
a48 3
   Sometimes, something crashes at the very early stages of application
   initialization, when JIT debugging facility is not yet active. Ok, there's
   another environment variable that may help. Create program_wrapper.cmd:
d57 9
a65 9
   Now, run program_wrapper.cmd. It should print running program pid.
   After starting program_wrapper.cmd you've got 20 seconds to open another
   window, cd to c:\cygdeb in it, run gdb there and in gdb prompt type

   (gdb) attach <pid>

   where <pid> is the pid that program_wrapper.cmd have printed.
   After that you can normally step through the code in cygwin1.dll and
   bad_program.exe
d68 6
a73 6
   If your program crashes at malloc() or free() or when it references some
   malloc()'ed memory, it looks like heap corruption. You can configure and
   build special version of cygwin1.dll which includes heap sanity checking.
   To do it, just add --enable-malloc-debugging option to configure. Be warned,
   however, that this version of dll is _very_ slow (10-100 times slower than
   normal), so use it only when absolutely necessary.
d76 21
a96 21
   If your program crashes when you run it using strace but runs ok (or has a
   different problem) otherwise, then there may be a problem in one of the
   strace *_printf statements.  Usually this is caused by a change in arguments
   resulting in a %s being used with something other than a pointer to a
   string.

   To debug this scenario, do something like this:

    bash$ gdb -nw yourapp.exe
    (gdb) dll cygwin1
    (gdb) l dll_crt0_1
    (gdb) bp <<first line in the function>>
    (gdb) run
    (gdb) set strace.active=1
    (gdb) continue

   The program will then run in "strace mode", calling each strace *_printf,
   just like it does when run under the strace program.  Eventually, the
   program will crash, probably in small_printf.  At that point, a 'bt'
   command should show you the offending call to strace_printf with the
   improper format string.
@


1.2.2.3
log
@Merged changes from HEAD
@
text
@d1 1
a1 1
Copyright 2001, 2002 Red Hat Inc., Egor Duda
d12 1
a12 3
1.  First things first

    The first thing you'll need to do is to build cygwin1.dll and your
d19 1
a19 2
2. Creating a known-working cygwin debugging environment

d31 1
a31 2
3. Using cygwin's JIT debugging facility

d37 1
a37 2
4. Strace

d52 1
a52 2
5. Problems at early startup

d74 1
a74 19
6. More problems at early startup

   You can also set a CYGWIN_DEBUG variable to force the debugger to pop up
   only when a certain program is run:

set CYGWIN_DEBUG=cat.exe=gdb.exe

   This will force gdb.exe to start when the program name contains the string
   "cat.exe".  The '=gdb.exe' isn't really needed, since it is the default.
   It is just there to show how you can specify a program to run when the
   program starts.  You can optionally set a breakpoint on "break_here"
   once the debugger pops up and then you can single step through the
   initialization process.

   Note that it bears repeating that both of the above options are *only*
   available when configuring cygwin with --enable-debugging.

7. Heap corruption

d82 1
a82 2
8. Program dies when running under strace

@


1.1
log
@Hints and tips on debugging cygwin
@
text
@d12 1
a12 1
1. The first thing you'll need to do is to build cygwin1.dll and crashed your
d18 1
a18 1
  cygwin1.dll, gdb.exe in it.
d36 1
a36 1
  If you know, where the problem approximately is, you can add a bunch of 
@

