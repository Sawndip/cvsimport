head	1.110;
access;
symbols
	cygwin-1_7_35-release:1.110
	cygwin-1_7_34-release:1.110
	cygwin-1_7_33-release:1.100.2.2
	cygwin-1_7_32-release:1.100.2.1
	cygwin-1_7_31-release:1.100.2.1
	cygwin-1_7_30-release:1.100.2.1
	cygwin-1_7_29-release:1.100
	cygwin-1_7_29-release-branchpoint:1.100.0.2
	cygwin-pre-user-db:1.101
	cygwin-1_7_28-release:1.100
	cygwin-1_7_27-release:1.100
	cygwin-1_7_26-release:1.100
	cygwin-1_7_25-release:1.98
	cygwin-1_7_24-release:1.98
	cygwin-1_7_23-release:1.98
	cygwin-1_7_22-release:1.98
	cygwin-1_7_21-release:1.98
	cygwin-1_7_20-release:1.95
	cygwin-1_7_19-release:1.94
	cygwin-64bit-postmerge:1.92
	cygwin-64bit-premerge-branch:1.91.0.2
	cygwin-64bit-premerge:1.91
	cygwin-1_7_18-release:1.91
	post-ptmalloc3:1.82.2.11
	pre-ptmalloc3:1.82.2.11
	cygwin-1_7_17-release:1.83
	cygwin-64bit-branch:1.82.0.2
	cygwin-1_7_16-release:1.82
	cygwin-1_7_15-release:1.81
	cygwin-1_7_14_2-release:1.81
	cygwin-1_7_14-release:1.81
	cygwin-1_7_12-release:1.81
	cygwin-1_7_11-release:1.81
	cygwin-1_7_10-release:1.76
	signal-rewrite:1.72.0.2
	pre-notty:1.68
	cygwin-1_7_9-release:1.58
	cv-post-1_7_9:1.58.0.2
	cygwin-1_7_8-release:1.58
	cygwin-1_7_7-release:1.58
	cygwin-1_7_5-release:1.58
	cygwin-1_7_4-release:1.58
	cygwin-1_7_3-release:1.58
	cygwin-1_7_2-release:1.58
	fifo_doover3:1.57.0.2
	cygwin-1_7_1-release:1.55
	prefifo:1.55
	cv-branch-2:1.55.0.2
	pre-ripout-set_console_state_for_spawn:1.53
	EOL_registry_mounts:1.52
	preoverlapped:1.43
	drop_9x_support_start:1.42
	cr-0x5f1:1.41.0.4
	cv-branch:1.41.0.2
	pre-ptymaster-archetype:1.41
	cr-0x3b58:1.39.0.4
	cr-0x5ef:1.39.0.2
	after-mmap-privanon-noreserve:1.37
	after-mmap-revamp:1.37
	before-mmap-revamp:1.37
	cgf-more-exit-sync:1.37
	post_wait_sig_exit:1.37
	pre_wait_sig_exit:1.37
	reparent-point:1.31
	noreparent:1.31.0.2
	cr-0x5e6:1.30.0.2
	cr-0x9e:1.27.0.6
	cr-0x9d:1.27.0.4
	cgf-deleteme:1.27.0.2
	pre-sigrewrite:1.25
	corinna-01:1.24
	cr-0x9c:1.22.0.6
	cr-0x9b:1.22.0.4
	cr-0x99:1.22
	Z-emcb-cygwin_daemon:1.22.0.2
	w32api-2_2:1.20
	mingw-runtime-2_4:1.20
	pre-cgf-merge:1.22
	cgf-dev-branch:1.20.0.2
	predaemon:1.11
	cygwin_daemon_merge_HEAD:1.11
	pregp02r1:1.11.0.22
	cygnus_cvs_20020108_pre:1.11
	Z-cygwin_daemon_merge-new_HEAD:1.14
	Z-cygwin_daemon_merge_HEAD:1.14
	cygwin_daemon:1.5.0.4;
locks; strict;
comment	@// @;


1.110
date	2015.01.16.16.19.37;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2014.11.28.12.10.12;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2014.11.21.21.41.37;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2014.11.20.16.23.14;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2014.08.21.09.04.09;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2014.08.18.18.24.06;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2014.04.23.15.26.13;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2014.02.11.17.45.09;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2014.02.08.20.57.27;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2013.11.25.11.38.08;	author corinna;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2013.11.24.12.13.34;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2013.06.08.16.39.52;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2013.06.08.14.42.44;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2013.06.08.14.38.20;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2013.06.06.15.29.41;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2013.05.21.18.53.23;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.92;

1.92
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.23.14.06.06;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.23.02.06.44;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2013.01.23.02.02.36;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.20.22.59.58;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2012.12.21.21.30.56;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2012.12.21.19.32.43;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2012.12.21.18.52.00;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2012.08.16.23.34.44;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2012.06.27.13.35.48;	author corinna;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2012.02.15.21.34.06;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2012.02.13.15.23.03;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2012.02.13.13.12.37;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2012.02.11.17.37.02;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2012.02.10.20.56.22;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2012.01.09.14.19.56;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2011.11.23.18.56.57;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2011.10.30.04.50.35;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2011.08.13.10.28.15;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2011.08.12.16.55.35;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.07.06.21.24;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.06.16.33.30;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2011.05.20.19.00.51;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2011.05.20.18.15.12;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2011.05.20.07.39.20;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2011.05.20.07.23.11;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2011.05.17.15.37.01;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2011.05.16.09.55.17;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2011.05.15.19.04.41;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2011.05.15.18.49.39;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.04.12.23.35;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2009.12.21.09.38.25;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.24.12.18.34;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2008.07.14.19.58.16;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.22.21.04.16;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.25.18.32.23;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.11.16.39.06;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.06.22.04.16;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.06.18.24.50;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.01.13.11.57;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.12.12.12.23;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2007.08.02.14.21.53;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.23.10.51.59;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.19.09.15.26;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.07.15.49.08;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.20.20.34.28;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.20.20.19.55;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.19.14.56.48;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.06.20.05.01;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.13.18.17.29;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.25.22.45.09;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.17.13.34.26;	author phumblet;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.26.11.32.20;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.25.10.54.31;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.12.04.15.31;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.10.21.28.02;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.27.08.28.37;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.28.02.04.16;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.21.03.18.46;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2003.01.10.03.13.45;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.22.04.43.47;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.15.04.35.13;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.30.21.05.17;	author cgf;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.08.30.15.47.09;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.08.17.03.20;	author scottc;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.26.05.29.41;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.30.06.19.58;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.28.00.06.35;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.22.11.31.39;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.20.05.08.21;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.28.02.19.57;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.19.03.12.44;	author dj;	state Exp;
branches;
next	;

1.100.2.1
date	2014.05.19.11.47.54;	author corinna;	state Exp;
branches;
next	1.100.2.2;

1.100.2.2
date	2014.11.13.12.53.03;	author corinna;	state Exp;
branches;
next	;

1.82.2.1
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.82.2.2;

1.82.2.2
date	2012.11.09.14.58.16;	author corinna;	state Exp;
branches;
next	1.82.2.3;

1.82.2.3
date	2012.11.29.08.59.19;	author corinna;	state Exp;
branches;
next	1.82.2.4;

1.82.2.4
date	2013.01.09.16.27.21;	author corinna;	state Exp;
branches;
next	1.82.2.5;

1.82.2.5
date	2013.01.21.13.52.06;	author corinna;	state Exp;
branches;
next	1.82.2.6;

1.82.2.6
date	2013.01.21.15.02.04;	author corinna;	state Exp;
branches;
next	1.82.2.7;

1.82.2.7
date	2013.01.29.18.29.35;	author corinna;	state Exp;
branches;
next	1.82.2.8;

1.82.2.8
date	2013.01.29.22.15.13;	author corinna;	state Exp;
branches;
next	1.82.2.9;

1.82.2.9
date	2013.01.30.19.42.17;	author corinna;	state Exp;
branches;
next	1.82.2.10;

1.82.2.10
date	2013.02.05.15.04.37;	author corinna;	state Exp;
branches;
next	1.82.2.11;

1.82.2.11
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	1.82.2.12;

1.82.2.12
date	2013.03.14.12.09.52;	author corinna;	state Exp;
branches;
next	1.82.2.13;

1.82.2.13
date	2013.03.15.13.33.55;	author corinna;	state Exp;
branches;
next	;

1.20.2.1
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	;

1.15.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.5.4.1
date	2002.01.04.03.56.09;	author rbcollins;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.06.27.11.30.15;	author scottc;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.08.12.14.06.34;	author scottc;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.08.30.22.08.50;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.110
log
@	* gendef: Export _sigbe on 64 bit as well.
	* malloc_wrapper.cc (free): In malloc_printf, call caller_return_address
	instead of __builtin_return_address.
	(malloc): Ditto.
	(realloc): Ditto.
	(calloc): Ditto.
	* miscfuncs.cc (__caller_return_address): New function.
	* miscfuncs.h (caller_return_address): New macro calling
	__caller_return_address.
	(__caller_return_address): Add prototype.
@
text
@/* miscfuncs.cc: misc funcs that don't belong anywhere else

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <sys/uio.h>
#include <assert.h>
#include <alloca.h>
#include <limits.h>
#include <sys/param.h>
#include <wchar.h>
#include "cygtls.h"
#include "ntdll.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "pinfo.h"
#include "exception.h"
#include "sigproc.h"

long tls_ix = -1;

const unsigned char case_folded_lower[] = {
   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
  32, '!', '"', '#', '$', '%', '&',  39, '(', ')', '*', '+', ',', '-', '.', '/',
 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',
 '@@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[',  92, ']', '^', '_',
 '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', 127,
 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
};

const unsigned char case_folded_upper[] = {
   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
  32, '!', '"', '#', '$', '%', '&',  39, '(', ')', '*', '+', ',', '-', '.', '/',
 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',
 '@@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[',  92, ']', '^', '_',
 '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', 127,
 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
};

const char isalpha_array[] = {
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,   0,   0,   0,   0,   0,
   0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
};

extern "C" int __stdcall
cygwin_wcscasecmp (const wchar_t *ws, const wchar_t *wt)
{
  UNICODE_STRING us, ut;

  RtlInitUnicodeString (&us, ws);
  RtlInitUnicodeString (&ut, wt);
  return RtlCompareUnicodeString (&us, &ut, TRUE);
}

extern "C" int __stdcall
cygwin_wcsncasecmp (const wchar_t  *ws, const wchar_t *wt, size_t n)
{
  UNICODE_STRING us, ut;
  size_t ls = 0, lt = 0;

  while (ws[ls] && ls < n)
    ++ls;
  RtlInitCountedUnicodeString (&us, ws, ls * sizeof (WCHAR));
  while (wt[lt] && lt < n)
    ++lt;
  RtlInitCountedUnicodeString (&ut, wt, lt * sizeof (WCHAR));
  return RtlCompareUnicodeString (&us, &ut, TRUE);
}

extern "C" int __stdcall
cygwin_strcasecmp (const char *cs, const char *ct)
{
  UNICODE_STRING us, ut;
  ULONG len;

  len = (strlen (cs) + 1) * sizeof (WCHAR);
  RtlInitEmptyUnicodeString (&us, (PWCHAR) alloca (len), len);
  us.Length = sys_mbstowcs (us.Buffer, us.MaximumLength, cs) * sizeof (WCHAR);
  len = (strlen (ct) + 1) * sizeof (WCHAR);
  RtlInitEmptyUnicodeString (&ut, (PWCHAR) alloca (len), len);
  ut.Length = sys_mbstowcs (ut.Buffer, ut.MaximumLength, ct) * sizeof (WCHAR);
  return RtlCompareUnicodeString (&us, &ut, TRUE);
}

extern "C" int __stdcall
cygwin_strncasecmp (const char *cs, const char *ct, size_t n)
{
  UNICODE_STRING us, ut;
  ULONG len;
  size_t ls = 0, lt = 0;

  while (cs[ls] && ls < n)
    ++ls;
  len = (ls + 1) * sizeof (WCHAR);
  RtlInitEmptyUnicodeString (&us, (PWCHAR) alloca (len), len);
  us.Length = sys_mbstowcs (us.Buffer, ls + 1, cs, ls) * sizeof (WCHAR);
  while (ct[lt] && lt < n)
    ++lt;
  len = (lt + 1) * sizeof (WCHAR);
  RtlInitEmptyUnicodeString (&ut, (PWCHAR) alloca (len), len);
  ut.Length = sys_mbstowcs (ut.Buffer, lt + 1, ct, lt)  * sizeof (WCHAR);
  return RtlCompareUnicodeString (&us, &ut, TRUE);
}

extern "C" char *
strlwr (char *string)
{
  UNICODE_STRING us;
  size_t len = (strlen (string) + 1) * sizeof (WCHAR);

  us.MaximumLength = len; us.Buffer = (PWCHAR) alloca (len);
  us.Length = sys_mbstowcs (us.Buffer, len, string) * sizeof (WCHAR)
	      - sizeof (WCHAR);
  RtlDowncaseUnicodeString (&us, &us, FALSE);
  sys_wcstombs (string, len / sizeof (WCHAR), us.Buffer);
  return string;
}

extern "C" char *
strupr (char *string)
{
  UNICODE_STRING us;
  size_t len = (strlen (string) + 1) * sizeof (WCHAR);

  us.MaximumLength = len; us.Buffer = (PWCHAR) alloca (len);
  us.Length = sys_mbstowcs (us.Buffer, len, string) * sizeof (WCHAR)
	      - sizeof (WCHAR);
  RtlUpcaseUnicodeString (&us, &us, FALSE);
  sys_wcstombs (string, len / sizeof (WCHAR), us.Buffer);
  return string;
}

int __reg2
check_invalid_virtual_addr (const void *s, unsigned sz)
{
  MEMORY_BASIC_INFORMATION mbuf;
  const void *end;

  for (end = (char *) s + sz; s < end;
       s = (char *) mbuf.BaseAddress + mbuf.RegionSize)
    if (!VirtualQuery (s, &mbuf, sizeof mbuf))
      return EINVAL;
  return 0;
}

static char __attribute__ ((noinline))
dummytest (volatile char *p)
{
  return *p;
}

ssize_t
check_iovec (const struct iovec *iov, int iovcnt, bool forwrite)
{
  if (iovcnt < 0 || iovcnt > IOV_MAX)
    {
      set_errno (EINVAL);
      return -1;
    }

  __try
    {

      size_t tot = 0;

      while (iovcnt != 0)
	{
	  if (iov->iov_len > SSIZE_MAX || (tot += iov->iov_len) > SSIZE_MAX)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }

	  volatile char *p = ((char *) iov->iov_base) + iov->iov_len - 1;
	  if (!iov->iov_len)
	    /* nothing to do */;
	  else if (!forwrite)
	    *p  = dummytest (p);
	  else
	    dummytest (p);

	  iov++;
	  iovcnt--;
	}

      assert (tot <= SSIZE_MAX);

      return (ssize_t) tot;
    }
  __except (EFAULT)
  __endtry
  return -1;
}

/* Try hard to schedule another thread.  
   Remember not to call this in a lock condition or you'll potentially
   suffer starvation.  */
void
yield ()
{
  int prio = GetThreadPriority (GetCurrentThread ());
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
  /* MSDN implies that SleepEx will force scheduling of other threads.
     Unlike SwitchToThread() the documentation does not mention other
     cpus so, presumably (hah!), this + using a lower priority will
     stall this thread temporarily and cause another to run.
     (stackoverflow and others seem to confirm that setting this thread
     to a lower priority and calling Sleep with a 0 paramenter will
     have this desired effect)  */
  Sleep (0L);
  SetThreadPriority (GetCurrentThread (), prio);
}

/* Get a default value for the nice factor.  When changing these values,
   have a look into the below function nice_to_winprio.  The values must
   match the layout of the static "priority" array. */
int
winprio_to_nice (DWORD prio)
{
  switch (prio)
    {
      case REALTIME_PRIORITY_CLASS:
	return -20;
      case HIGH_PRIORITY_CLASS:
	return -16;
      case ABOVE_NORMAL_PRIORITY_CLASS:
	return -8;
      case NORMAL_PRIORITY_CLASS:
	return 0;
      case BELOW_NORMAL_PRIORITY_CLASS:
	return 8;
      case IDLE_PRIORITY_CLASS:
	return 16;
    }
  return 0;
}

/* Get a Win32 priority matching the incoming nice factor.  The incoming
   nice is limited to the interval [-NZERO,NZERO-1]. */
DWORD
nice_to_winprio (int &nice)
{
  static const DWORD priority[] =
    {
      REALTIME_PRIORITY_CLASS,		/*  0 */
      HIGH_PRIORITY_CLASS,		/*  1 */
      HIGH_PRIORITY_CLASS,
      HIGH_PRIORITY_CLASS,
      HIGH_PRIORITY_CLASS,
      HIGH_PRIORITY_CLASS,
      HIGH_PRIORITY_CLASS,
      HIGH_PRIORITY_CLASS,		/*  7 */
      ABOVE_NORMAL_PRIORITY_CLASS,	/*  8 */
      ABOVE_NORMAL_PRIORITY_CLASS,
      ABOVE_NORMAL_PRIORITY_CLASS,
      ABOVE_NORMAL_PRIORITY_CLASS,
      ABOVE_NORMAL_PRIORITY_CLASS,
      ABOVE_NORMAL_PRIORITY_CLASS,
      ABOVE_NORMAL_PRIORITY_CLASS,
      ABOVE_NORMAL_PRIORITY_CLASS,	/* 15 */
      NORMAL_PRIORITY_CLASS,		/* 16 */
      NORMAL_PRIORITY_CLASS,
      NORMAL_PRIORITY_CLASS,
      NORMAL_PRIORITY_CLASS,
      NORMAL_PRIORITY_CLASS,
      NORMAL_PRIORITY_CLASS,
      NORMAL_PRIORITY_CLASS,
      NORMAL_PRIORITY_CLASS,		/* 23 */
      BELOW_NORMAL_PRIORITY_CLASS,	/* 24 */
      BELOW_NORMAL_PRIORITY_CLASS,
      BELOW_NORMAL_PRIORITY_CLASS,
      BELOW_NORMAL_PRIORITY_CLASS,
      BELOW_NORMAL_PRIORITY_CLASS,
      BELOW_NORMAL_PRIORITY_CLASS,
      BELOW_NORMAL_PRIORITY_CLASS,
      BELOW_NORMAL_PRIORITY_CLASS,	/* 31 */
      IDLE_PRIORITY_CLASS,		/* 32 */
      IDLE_PRIORITY_CLASS,
      IDLE_PRIORITY_CLASS,
      IDLE_PRIORITY_CLASS,
      IDLE_PRIORITY_CLASS,
      IDLE_PRIORITY_CLASS,
      IDLE_PRIORITY_CLASS,
      IDLE_PRIORITY_CLASS		/* 39 */
    };
  if (nice < -NZERO)
    nice = -NZERO;
  else if (nice > NZERO - 1)
    nice = NZERO - 1;
  DWORD prio = priority[nice + NZERO];
  return prio;
}

/* Minimal overlapped pipe I/O implementation for signal and commune stuff. */

BOOL WINAPI
CreatePipeOverlapped (PHANDLE hr, PHANDLE hw, LPSECURITY_ATTRIBUTES sa)
{
  int ret = fhandler_pipe::create (sa, hr, hw, 0, NULL,
				   FILE_FLAG_OVERLAPPED);
  if (ret)
    SetLastError (ret);
  return ret == 0;
}

BOOL WINAPI
ReadPipeOverlapped (HANDLE h, PVOID buf, DWORD len, LPDWORD ret_len,
		    DWORD timeout)
{
  OVERLAPPED ov;
  BOOL ret;

  memset (&ov, 0, sizeof ov);
  ov.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
  ret = ReadFile (h, buf, len, NULL, &ov);
  if (ret || GetLastError () == ERROR_IO_PENDING)
    {
      if (!ret && WaitForSingleObject (ov.hEvent, timeout) != WAIT_OBJECT_0)
	CancelIo (h);
      ret = GetOverlappedResult (h, &ov, ret_len, FALSE);
    }
  CloseHandle (ov.hEvent);
  return ret;
}

BOOL WINAPI
WritePipeOverlapped (HANDLE h, LPCVOID buf, DWORD len, LPDWORD ret_len,
		     DWORD timeout)
{
  OVERLAPPED ov;
  BOOL ret;

  memset (&ov, 0, sizeof ov);
  ov.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
  ret = WriteFile (h, buf, len, NULL, &ov);
  if (ret || GetLastError () == ERROR_IO_PENDING)
    {
      if (!ret && WaitForSingleObject (ov.hEvent, timeout) != WAIT_OBJECT_0)
	CancelIo (h);
      ret = GetOverlappedResult (h, &ov, ret_len, FALSE);
    }
  CloseHandle (ov.hEvent);
  return ret;
}

bool
NT_readline::init (POBJECT_ATTRIBUTES attr, PCHAR in_buf, ULONG in_buflen)
{
  NTSTATUS status;
  IO_STATUS_BLOCK io;

  status = NtOpenFile (&fh, SYNCHRONIZE | FILE_READ_DATA, attr, &io,
                       FILE_SHARE_VALID_FLAGS,
                       FILE_SYNCHRONOUS_IO_NONALERT
                       | FILE_OPEN_FOR_BACKUP_INTENT);
  if (!NT_SUCCESS (status))
    {
      paranoid_printf ("NtOpenFile(%S) failed, status %y",
		       attr->ObjectName, status);
      return false;
    }
  buf = in_buf;
  buflen = in_buflen;
  got = end = buf;
  len = 0;
  line = 1;
  return true;
}

PCHAR 
NT_readline::gets ()
{
  IO_STATUS_BLOCK io;

  while (true)
    {
      /* len == 0 indicates we have to read from the file. */
      if (!len)
	{
	  if (!NT_SUCCESS (NtReadFile (fh, NULL, NULL, NULL, &io, got,
				       (buflen - 2) - (got - buf), NULL, NULL)))
	    return NULL;
	  len = io.Information;
	  /* Set end marker. */
	  got[len] = got[len + 1] = '\0';
	  /* Set len to the absolute len of bytes in buf. */
	  len += got - buf;
	  /* Reset got to start reading at the start of the buffer again. */
	  got = end = buf;
	}
      else
	{
	  got = end + 1;
	  ++line;
	}
      /* Still some valid full line? */
      if (got < buf + len)
	{
	  if ((end = strchr (got, '\n')))
	    {
	      end[end[-1] == '\r' ? -1 : 0] = '\0';
	      return got;
	    }
	  /* Last line missing a \n at EOF? */
	  if (len < buflen - 2)
	    {
	      len = 0;
	      return got;
	    }
	}
      /* We have to read once more.  Move remaining bytes to the start of
         the buffer and reposition got so that it points to the end of
         the remaining bytes. */
      len = buf + len - got;
      memmove (buf, got, len);
      got = buf + len;
      buf[len] = buf[len + 1] = '\0';
      len = 0;
    }
}

/* backslashify: Convert all forward slashes in src path to back slashes
   in dst path.  Add a trailing slash to dst when trailing_slash_p arg
   is set to 1. */

void
backslashify (const char *src, char *dst, bool trailing_slash_p)
{
  const char *start = src;

  while (*src)
    {
      if (*src == '/')
	*dst++ = '\\';
      else
	*dst++ = *src;
      ++src;
    }
  if (trailing_slash_p
      && src > start
      && !isdirsep (src[-1]))
    *dst++ = '\\';
  *dst++ = 0;
}

/* slashify: Convert all back slashes in src path to forward slashes
   in dst path.  Add a trailing slash to dst when trailing_slash_p arg
   is set to 1. */

void
slashify (const char *src, char *dst, bool trailing_slash_p)
{
  const char *start = src;

  while (*src)
    {
      if (*src == '\\')
	*dst++ = '/';
      else
	*dst++ = *src;
      ++src;
    }
  if (trailing_slash_p
      && src > start
      && !isdirsep (src[-1]))
    *dst++ = '/';
  *dst++ = 0;
}

/* Return an address from the import jmp table of main program.  */
void * __reg1
__import_address (void *imp)
{
  __try
    {
      if (*((uint16_t *) imp) == 0x25ff)
	{
	  const char *ptr = (const char *) imp;
#ifdef __x86_64__
	  const uintptr_t *jmpto = (uintptr_t *)
				   (ptr + 6 + *(int32_t *)(ptr + 2));
#else
	  const uintptr_t *jmpto = (uintptr_t *) *((uintptr_t *) (ptr + 2));
#endif
	  return (void *) *jmpto;
	}
    }
  __except (NO_ERROR) {}
  __endtry
  return NULL;
}

/* Helper function to generate the correct caller address.  For external
   calls, the return address on the stack is _sigbe.  In that case the
   actual caller return address is on the cygtls stack.  Use this function
   via the macro caller_return_address. */
extern "C" void _sigbe ();

void *
__caller_return_address (void *builtin_ret_addr)
{
  return builtin_ret_addr == &_sigbe
	 ? (void *) _my_tls.retaddr () : builtin_ret_addr;
}

/* CygwinCreateThread.

   Replacement function for CreateThread.  What we do here is to remove
   parameters we don't use and instead to add parameters we need to make
   the function pthreads compatible. */

struct pthread_wrapper_arg
{
  LPTHREAD_START_ROUTINE func;
  PVOID arg;
  PBYTE stackaddr;
  PBYTE stackbase;
  PBYTE stacklimit;
};

DWORD WINAPI
pthread_wrapper (PVOID arg)
{
  /* Just plain paranoia. */
  if (!arg)
    return ERROR_INVALID_PARAMETER;

  /* The process is now threaded.  Note for later usage by arc4random. */
  __isthreaded = 1;

  /* Fetch thread wrapper info and free from cygheap. */
  pthread_wrapper_arg wrapper_arg = *(pthread_wrapper_arg *) arg;
  cfree (arg);

  /* Set stack values in TEB */
  PTEB teb = NtCurrentTeb ();
  teb->Tib.StackBase = wrapper_arg.stackbase;
  teb->Tib.StackLimit = wrapper_arg.stacklimit ?: wrapper_arg.stackaddr;
  /* Set DeallocationStack value.  If we have an application-provided stack,
     we set DeallocationStack to NULL, so NtTerminateThread does not deallocate
     any stack.  If we created the stack in CygwinCreateThread, we set
     DeallocationStack to the stackaddr of our own stack, so it's automatically
     deallocated when the thread is terminated. */
  PBYTE dealloc_addr = (PBYTE) teb->DeallocationStack;
  teb->DeallocationStack = wrapper_arg.stacklimit ? wrapper_arg.stackaddr
						  : NULL;
  /* Store the OS-provided DeallocationStack address in wrapper_arg.stackaddr.
     The below assembler code will release the OS stack after switching to our
     new stack. */
  wrapper_arg.stackaddr = dealloc_addr;

  /* Initialize new _cygtls. */
  _my_tls.init_thread (wrapper_arg.stackbase - CYGTLS_PADSIZE,
		       (DWORD (*)(void*, void*)) wrapper_arg.func);
#ifndef __x86_64__
  /* Copy exception list over to new stack.  I'm not quite sure how the
     exception list is extended by Windows itself.  What's clear is that it
     always grows downwards and that it starts right at the stackbase.
     Therefore we first count the number of exception records and place
     the copy at the stackbase, too, so there's still a lot of room to
     extend the list up to where our _cygtls region starts. */
  _exception_list *old_start = (_exception_list *) teb->Tib.ExceptionList;
  unsigned count = 0;
  teb->Tib.ExceptionList = NULL;
  for (_exception_list *e_ptr = old_start;
       e_ptr && e_ptr != (_exception_list *) -1;
       e_ptr = e_ptr->prev)
    ++count;
  if (count)
    {
      _exception_list *new_start = (_exception_list *) wrapper_arg.stackbase
						       - count;
      teb->Tib.ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)
			       new_start;
      while (true)
	{
	  new_start->handler = old_start->handler;
	  if (old_start->prev == (_exception_list *) -1)
	    {
	      new_start->prev = (_exception_list *) -1;
	      break;
	    }
	  new_start->prev = new_start + 1;
	  new_start = new_start->prev;
	  old_start = old_start->prev;
	}
    }
#endif
#ifdef __x86_64__
  __asm__ ("\n\
	   movq  %[WRAPPER_ARG], %%rbx	# Load &wrapper_arg into rbx	\n\
	   movq  (%%rbx), %%r12		# Load thread func into r12	\n\
	   movq  8(%%rbx), %%r13	# Load thread arg into r13	\n\
	   movq  16(%%rbx), %%rcx	# Load stackaddr into rcx	\n\
	   movq  24(%%rbx), %%rsp	# Load stackbase into rsp	\n\
	   subq  %[CYGTLS], %%rsp	# Subtract CYGTLS_PADSIZE	\n\
	   				# (here we are 16 bytes aligned)\n\
	   subq  $32, %%rsp		# Subtract another 32 bytes	\n\
	   				# (shadow space for arg regs)	\n\
	   xorq  %%rbp, %%rbp		# Set rbp to 0			\n\
	   # We moved to the new stack.					\n\
	   # Now it's safe to release the OS stack.			\n\
	   movl  $0x8000, %%r8d		# dwFreeType: MEM_RELEASE	\n\
	   xorl  %%edx, %%edx		# dwSize:     0			\n\
	   # dwAddress is already in the correct arg register rcx	\n\
	   call  VirtualFree						\n\
	   # All set.  We can copy the thread arg from the safe		\n\
	   # register r13 and then just call the function.		\n\
	   movq  %%r13, %%rcx		# Move thread arg to 1st arg reg\n\
	   call  *%%r12			# Call thread func		\n"
	   : : [WRAPPER_ARG] "r" (&wrapper_arg),
	       [CYGTLS] "i" (CYGTLS_PADSIZE));
#else
  __asm__ ("\n\
	   movl  %[WRAPPER_ARG], %%ebx	# Load &wrapper_arg into ebx	\n\
	   movl  (%%ebx), %%eax		# Load thread func into eax	\n\
	   movl  4(%%ebx), %%ecx	# Load thread arg into ecx	\n\
	   movl  8(%%ebx), %%edx	# Load stackaddr into edx	\n\
	   movl  12(%%ebx), %%ebx	# Load stackbase into ebx	\n\
	   subl  %[CYGTLS], %%ebx	# Subtract CYGTLS_PADSIZE	\n\
	   subl  $4, %%ebx		# Subtract another 4 bytes	\n\
	   movl  %%ebx, %%esp		# Set esp			\n\
	   xorl  %%ebp, %%ebp		# Set ebp to 0			\n\
	   # Make gcc 3.x happy and align the stack so that it is	\n\
	   # 16 byte aligned right before the final call opcode.	\n\
	   andl  $-16, %%esp		# 16 byte align			\n\
	   addl  $-12, %%esp		# 12 bytes + 4 byte arg = 16	\n\
	   # Now we moved to the new stack.  Save thread func address	\n\
	   # and thread arg on new stack				\n\
	   pushl %%ecx			# Push thread arg onto stack	\n\
	   pushl %%eax			# Push thread func onto stack	\n\
	   # Now it's safe to release the OS stack.			\n\
	   pushl $0x8000		# dwFreeType: MEM_RELEASE	\n\
	   pushl $0x0			# dwSize:     0			\n\
	   pushl %%edx			# lpAddress:  stackaddr		\n\
	   call _VirtualFree@@12		# Shoot				\n\
	   # All set.  We can pop the thread function address from	\n\
	   # the stack and call it.  The thread arg is still on the	\n\
	   # stack in the expected spot.				\n\
	   popl  %%eax			# Pop thread_func address	\n\
	   call  *%%eax			# Call thread func		\n"
	   : : [WRAPPER_ARG] "r" (&wrapper_arg),
	       [CYGTLS] "i" (CYGTLS_PADSIZE));
#endif
  /* pthread::thread_init_wrapper calls pthread::exit, which
     in turn calls ExitThread, so we should never arrive here. */
  api_fatal ("Dumb thinko in pthread handling.  Whip the developer.");
}

#ifdef __x86_64__
/* The memory region used for thread stacks */
#define THREAD_STORAGE_LOW	0x080000000L
#define THREAD_STORAGE_HIGH	0x100000000L
/* We provide the stacks always in 1 Megabyte slots */
#define THREAD_STACK_SLOT	0x100000L	/* 1 Meg */
/* Maximum stack size returned from the pool. */
#define THREAD_STACK_MAX	0x20000000L	/* 512 Megs */

class thread_allocator
{
  UINT_PTR current;
public:
  thread_allocator () : current (THREAD_STORAGE_HIGH) {}
  PVOID alloc (SIZE_T size)
  {
    SIZE_T real_size = roundup2 (size, THREAD_STACK_SLOT);
    BOOL overflow = FALSE;
    PVOID real_stackaddr = NULL;

    /* If an application requests a monster stack, we fulfill this request
       from outside of our pool, top down. */
    if (real_size > THREAD_STACK_MAX)
      return VirtualAlloc (NULL, real_size, MEM_RESERVE | MEM_TOP_DOWN,
			   PAGE_READWRITE);
    /* Simple round-robin.  Keep looping until VirtualAlloc succeeded, or
       until we overflowed and hit the current address. */
    for (UINT_PTR addr = current - real_size;
	 !real_stackaddr && (!overflow || addr >= current);
	 addr -= THREAD_STACK_SLOT)
      {
	if (addr < THREAD_STORAGE_LOW)
	  {
	    addr = THREAD_STORAGE_HIGH - real_size;
	    overflow = TRUE;
	  }
	real_stackaddr = VirtualAlloc ((PVOID) addr, real_size,
				       MEM_RESERVE, PAGE_READWRITE);
	if (!real_stackaddr)
	  {
	    /* So we couldn't grab this space.  Let's check the state.
	       If this area is free, simply try the next lower 1 Meg slot.
	       Otherwise, shift the next try down to the AllocationBase
	       of the current address, minus the requested slot size.
	       Add THREAD_STACK_SLOT since that's subtracted in the next
	       run of the loop anyway. */
	    MEMORY_BASIC_INFORMATION mbi;
	    VirtualQuery ((PVOID) addr, &mbi, sizeof mbi);
	    if (mbi.State != MEM_FREE)
	      addr = (UINT_PTR) mbi.AllocationBase - real_size
						    + THREAD_STACK_SLOT;
	  }
      }
    /* If we got an address, remember it for the next allocation attempt. */
    if (real_stackaddr)
      current = (UINT_PTR) real_stackaddr;
    return real_stackaddr;
  }
};

thread_allocator thr_alloc NO_COPY;
#endif

HANDLE WINAPI
CygwinCreateThread (LPTHREAD_START_ROUTINE thread_func, PVOID thread_arg,
		    PVOID stackaddr, ULONG stacksize, ULONG guardsize,
		    DWORD creation_flags, LPDWORD thread_id)
{
  PVOID real_stackaddr = NULL;
  ULONG real_stacksize = 0;
  ULONG real_guardsize = 0;
  pthread_wrapper_arg *wrapper_arg;
  HANDLE thread = NULL;

  wrapper_arg = (pthread_wrapper_arg *) ccalloc (HEAP_STR, 1,
						sizeof *wrapper_arg);
  if (!wrapper_arg)
    {
      SetLastError (ERROR_OUTOFMEMORY);
      return NULL;
    }
  wrapper_arg->func = thread_func;
  wrapper_arg->arg = thread_arg;

  if (stackaddr)
    {
      /* If the application provided the stack, just use it. */
      wrapper_arg->stackaddr = (PBYTE) stackaddr;
      wrapper_arg->stackbase = (PBYTE) stackaddr + stacksize;
    }
  else
    {
      PBYTE real_stacklimit;

      /* If not, we have to create the stack here. */
      real_stacksize = roundup2 (stacksize, wincap.page_size ());
      real_guardsize = roundup2 (guardsize, wincap.page_size ());
      /* Add the guardsize to the stacksize */
      real_stacksize += real_guardsize;
      /* If we use the default Windows guardpage method, we have to take
	 the 2 pages dead zone into account. */
      if (real_guardsize == wincap.page_size ())
	  real_stacksize += 2 * wincap.page_size ();
      /* Now roundup the result to the next allocation boundary. */
      real_stacksize = roundup2 (real_stacksize,
				 wincap.allocation_granularity ());
      /* Reserve stack. */
#ifdef __x86_64__
      real_stackaddr = thr_alloc.alloc (real_stacksize);
#else
      /* FIXME? If the TOP_DOWN method tends to collide too much with
	 other stuff, we should provide our own mechanism to find a
	 suitable place for the stack.  Top down from the start of
	 the Cygwin DLL comes to mind. */
      real_stackaddr = VirtualAlloc (NULL, real_stacksize,
				     MEM_RESERVE | MEM_TOP_DOWN,
				     PAGE_READWRITE);
#endif
      if (!real_stackaddr)
	return NULL;
      /* Set up committed region.  Two cases: */
      if (real_guardsize != wincap.page_size ())
	{
	  /* If guardsize is set to something other than the page size, we
	     commit the entire stack and, if guardsize is > 0, we set up a
	     POSIX guardpage.  We don't set up a Windows guardpage. */
	  if (!VirtualAlloc (real_stackaddr, real_guardsize, MEM_COMMIT,
			     PAGE_NOACCESS))
	    goto err;
	  real_stacklimit = (PBYTE) real_stackaddr + real_guardsize;
	  if (!VirtualAlloc (real_stacklimit, real_stacksize - real_guardsize,
			     MEM_COMMIT, PAGE_READWRITE))
	    goto err;
	}
      else
	{
	  /* If guardsize is exactly the page_size, we can assume that the
	     application will behave Windows conformant in terms of stack usage.
	     We can especially assume that it never allocates more than one
	     page at a time (alloca/_chkstk).  Therefore, this is the default
	     case which allows a Windows compatible stack setup with a
	     reserved region, a guard page, and a commited region.  We don't
	     need to set up a POSIX guardpage since Windows already handles
	     stack overflow: Trying to extend the stack into the last three
	     pages of the stack results in a SEGV.
	     We always commit 64K here, starting with the guardpage. */
	  real_stacklimit = (PBYTE) real_stackaddr + real_stacksize
				- wincap.allocation_granularity ();
	  if (!VirtualAlloc (real_stacklimit, wincap.page_size (), MEM_COMMIT,
			     PAGE_READWRITE | PAGE_GUARD))
	    goto err;
	  real_stacklimit += wincap.page_size ();
	  if (!VirtualAlloc (real_stacklimit, wincap.allocation_granularity ()
					 - wincap.page_size (), MEM_COMMIT,
			     PAGE_READWRITE))
	    goto err;
      	}
      wrapper_arg->stackaddr = (PBYTE) real_stackaddr;
      wrapper_arg->stackbase = (PBYTE) real_stackaddr + real_stacksize;
      wrapper_arg->stacklimit = real_stacklimit;
    }
  /* Use the STACK_SIZE_PARAM_IS_A_RESERVATION parameter so only the
     minimum size for a thread stack is reserved by the OS.  Note that we
     reserve a 256K stack, not 64K, otherwise the thread creation might
     crash the process due to a stack overflow. */
  thread = CreateThread (&sec_none_nih, 4 * PTHREAD_STACK_MIN,
			 pthread_wrapper, wrapper_arg,
			 creation_flags | STACK_SIZE_PARAM_IS_A_RESERVATION,
			 thread_id);

err:
  if (!thread && real_stackaddr)
    {
      /* Don't report the wrong error even though VirtualFree is very unlikely
	 to fail. */
      DWORD err = GetLastError ();
      VirtualFree (real_stackaddr, 0, MEM_RELEASE);
      SetLastError (err);
    }
  return thread;
}

#ifdef __x86_64__
// TODO: The equivalent newlib functions only work for SYSV ABI so far.
#undef RtlFillMemory
#undef RtlCopyMemory
extern "C" void NTAPI RtlFillMemory (PVOID, SIZE_T, BYTE);
extern "C" void NTAPI RtlCopyMemory (PVOID, const VOID *, SIZE_T);

extern "C" void *
memset (void *s, int c, size_t n)
{
  RtlFillMemory (s, n, c);
  return s;
}

extern "C" void *
memcpy(void *__restrict dest, const void *__restrict src, size_t n)
{
  RtlCopyMemory (dest, src, n);
  return dest;
}
#endif
@


1.109
log
@	* cygheap.cc (init_cygheap::find_tls): Add comment.
	* cygtls.cc (well_known_dlls): Rephrase comment.
	(bloda_detect): New function.
	(_cygtls::call2): Call init_thread and bloda_detect for non-pthread
	threads only.
	(_cygtls::remove): Move remove_tls and remove_wq calls up to run first.
	* miscfuncs.cc (struct pthread_wrapper_arg): Rename from struct
	thread_wrapper_arg.
	(pthread_wrapper): Rename from thread_wrapper and drop "static".  Fix
	comment.  Drop call to _cygtls::remove.  Call api_fatal rather than
	ExitThread.  Explain why.
	* miscfuncs.h (pthread_wrapper): Declare pthread_wrapper.
	* thread.cc (pthread::exit): Add a FIXME comment.  Call _cygtls::remove
	before calling ExitThread.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d537 13
@


1.108
log
@	* init.cc (dll_entry): Revert previous patch.  This requires another
	solution.
	* miscfuncs.cc (thread_wrapper): Ditto.
	* sigproc.cc (exit_thread): Disable sending a signal for synchronization
	with process exit.  Explain why.  Keep code in for later inspection,
	should the problem show up again.
	(sig_send): Use "tls", rather than "tid" as name for _cygtls arg.
@
text
@d543 1
a543 1
struct thread_wrapper_arg
d552 2
a553 2
static DWORD WINAPI
thread_wrapper (PVOID arg)
d559 1
a559 1
  /* The process is now threaded.  Note the fact for later usage. */
d563 1
a563 1
  thread_wrapper_arg wrapper_arg = *(thread_wrapper_arg *) arg;
a565 3
  /* Remove _cygtls from this stack since it won't be used anymore. */
  _my_tls.remove (0);

d676 3
a678 2
  /* Never return from here. */
  ExitThread (0);
d752 1
a752 1
  thread_wrapper_arg *wrapper_arg;
d755 1
a755 1
  wrapper_arg = (thread_wrapper_arg *) ccalloc (HEAP_STR, 1,
d847 1
a847 1
			 thread_wrapper, wrapper_arg,
@


1.107
log
@	* init.cc (dll_entry): Call _my_tls.remove with INFINITE wait period
	to avoid SEGVs and subsequent hangs in _cygtls::find_tls.
	* miscfuncs.cc (thread_wrapper): Ditto.
@
text
@d567 1
a567 1
  _my_tls.remove (INFINITE);
@


1.106
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d567 1
a567 1
  _my_tls.remove (0);
@


1.105
log
@	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.
@
text
@d205 2
a206 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d208 1
a208 1
  size_t tot = 0;
d210 1
a210 3
  while (iovcnt != 0)
    {
      if (iov->iov_len > SSIZE_MAX || (tot += iov->iov_len) > SSIZE_MAX)
d212 16
a227 2
	  set_errno (EINVAL);
	  return -1;
d230 1
a230 7
      volatile char *p = ((char *) iov->iov_base) + iov->iov_len - 1;
      if (!iov->iov_len)
	/* nothing to do */;
      else if (!forwrite)
	*p  = dummytest (p);
      else
	dummytest (p);
d232 1
a232 2
      iov++;
      iovcnt--;
d234 3
a236 4

  assert (tot <= SSIZE_MAX);

  return (ssize_t) tot;
d518 5
a522 6
  myfault efault;
  if (efault.faulted ())
    return NULL;
  if (*((uint16_t *) imp) != 0x25ff)
    return NULL;
  const char *ptr = (const char *) imp;
d524 2
a525 1
  const uintptr_t *jmpto = (uintptr_t *) (ptr + 6 + *(int32_t *)(ptr + 2));
d527 1
a527 1
  const uintptr_t *jmpto = (uintptr_t *) *((uintptr_t *) (ptr + 2));
d529 6
a534 1
  return (void *) *jmpto;
@


1.104
log
@	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.
@
text
@a514 2
  if (*((uint16_t *) imp) != 0x25ff)
    return NULL;
d518 2
@


1.103
log
@	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.
@
text
@d149 2
a150 2
extern "C" char * __stdcall
cygwin_strlwr (char *string)
d163 2
a164 2
extern "C" char * __stdcall
cygwin_strupr (char *string)
@


1.102
log
@	* ldap.cc (rediscover_thread): Give argument a useful name.
	* miscfuncs.cc (NT_readline::init): It's a really bad idea trying to
	print a pointer to a PUNICODE_STRING as PUNICODE_STRING.  Fix it.
	* uinfo.cc (cygheap_domain_info::init): Print status codes as hex
	values in debug output.
@
text
@d199 1
a199 1
  if (iovcnt <= 0 || iovcnt > IOV_MAX)
@


1.101
log
@	* miscfuncs.h (class NT_readline): New class to implement line-wise
	reading from file using native NT functions.
	* miscfuncs.cc (NT_readline::init): New method.
	* mount.cc (mount_info::from_fstab): Utilize NT_readline to read
	fstab files.
@
text
@d400 1
a400 1
		       &attr->ObjectName, status);
@


1.100
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d387 76
@


1.100.2.1
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d199 1
a199 1
  if (iovcnt < 0 || iovcnt > IOV_MAX)
@


1.100.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d149 2
a150 2
extern "C" char *
strlwr (char *string)
d163 2
a164 2
extern "C" char *
strupr (char *string)
d205 3
a207 2
  __try
    {
d209 1
a209 1
      size_t tot = 0;
d211 3
a213 1
      while (iovcnt != 0)
d215 3
a217 5
	  if (iov->iov_len > SSIZE_MAX || (tot += iov->iov_len) > SSIZE_MAX)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }
d219 7
a225 7
	  volatile char *p = ((char *) iov->iov_base) + iov->iov_len - 1;
	  if (!iov->iov_len)
	    /* nothing to do */;
	  else if (!forwrite)
	    *p  = dummytest (p);
	  else
	    dummytest (p);
d227 3
a229 3
	  iov++;
	  iovcnt--;
	}
d231 1
a231 1
      assert (tot <= SSIZE_MAX);
d233 1
a233 5
      return (ssize_t) tot;
    }
  __except (EFAULT)
  __endtry
  return -1;
d439 6
a444 5
  __try
    {
      if (*((uint16_t *) imp) == 0x25ff)
	{
	  const char *ptr = (const char *) imp;
d446 1
a446 2
	  const uintptr_t *jmpto = (uintptr_t *)
				   (ptr + 6 + *(int32_t *)(ptr + 2));
d448 1
a448 1
	  const uintptr_t *jmpto = (uintptr_t *) *((uintptr_t *) (ptr + 2));
d450 1
a450 6
	  return (void *) *jmpto;
	}
    }
  __except (NO_ERROR) {}
  __endtry
  return NULL;
@


1.99
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d796 1
a796 1
memcpy(void *dest, const void *src, size_t n)
@


1.98
log
@* miscfuncs.cc (yield): Revert (after researching) to calling SleepEx with 0.
We don't want to actually sleep when calling this function.
@
text
@a19 3
#include <wingdi.h>
#include <winuser.h>
#include <winnls.h>
@


1.97
log
@revert accidentally checked in files
@
text
@d239 3
a241 5
/* Try hard to schedule another thread.

   Note: Don't call yield under _cygtls::lock conditions.  It results in
   potential starvation, especially on a single-CPU system, because
   _cygtls::lock also calls yield when waiting for the lock. */
d247 8
a254 10
  for (int i = 0; i < 2; i++)
    {
      /* MSDN implies that SleepEx will force scheduling of other threads.
	 Unlike SwitchToThread() the documentation does not mention other
	 cpus so, presumably (hah!), this + using a lower priority will
	 stall this thread temporarily and cause another to run.
	 Note: Don't use 0 timeout.  This takes a lot of CPU if something
	 goes wrong. */
      SleepEx (1L, false);
    }
@


1.96
log
@* cygwait.cc (cygwait): Remove lock around sig retrieval since this code is
essentially guarded by thread-specific signal_arrived.
* exceptions.cc (_cygtls::handle_SIGCONT): Simplify.  Eliminate lock/unlock
since code is guarded by signal_arrived.
@
text
@d254 4
a257 2
	 stall this thread temporarily and cause another to run.  */
      SleepEx (0L, false);
@


1.95
log
@	* exceptions.cc (_cygtls::handle_SIGCONT): Simplify loop waiting for
	sig_handle_tty_stop to wake up.  Make sure to unlock before calling
	yield to avoid starvation of sig_handle_tty_stop.  Add comments.
	* miscfuncs.cc (yield): Explain why yield should never be called under
	_cygtls::lock conditions.  Call SleepEx with 1ms timeout.  Explain why.
@
text
@d254 2
a255 4
	 stall this thread temporarily and cause another to run.
	 Note: Don't use 0 timeout.  This takes a lot of CPU if something
	 goes wrong. */
      SleepEx (1L, false);
@


1.94
log
@	* globals.cc (__isthreaded): New global variable.  Explain what it's
	used for.
	* miscfuncs.cc (thread_wrapper): Set __isthreaded to 1 here.
@
text
@d239 5
a243 1
/* Try hard to schedule another thread. */
d251 7
a257 5
      /* MSDN implies that SleepEx(0,...) will force scheduling of other
	 threads.  Unlike SwitchToThread() the documentation does not mention
	 other cpus so, presumably (hah!), this + using a lower priority will
	 stall this thread temporarily and cause another to run.  */
      SleepEx (0, false);
@


1.93
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d476 3
@


1.92
log
@	* Merge in cygwin-64bit-branch.
@
text
@d180 1
a180 1
int __stdcall
@


1.91
log
@* miscfuncs.cc (__import_address): On second thought, the chance that this
pointer could be NULL is very low so don't bother checking for it.
@
text
@d35 1
a35 1
const char case_folded_lower[] NO_COPY = {
d54 1
a54 1
const char case_folded_upper[] NO_COPY = {
d73 1
a73 1
const char isalpha_array[] NO_COPY = {
d285 1
a285 1
  static const DWORD priority[] NO_COPY =
d446 3
d450 1
d470 1
a470 1
thread_wrapper (VOID *arg)
d503 1
a503 1

d536 26
a561 1

d563 1
a563 1
	   movl  %[WRAPPER_ARG], %%ebx # Load &wrapper_arg into ebx	\n\
d592 1
d597 63
d703 5
a707 2
      /* Reserve stack.
	 FIXME? If the TOP_DOWN method tends to collide too much with
d714 1
d759 3
a761 5
     minimum size for a thread stack is reserved by the OS.  This doesn't
     work on Windows 2000, but we deallocate the OS stack in thread_wrapper
     anyway, so this should be a problem only in a tight memory condition.
     Note that we reserve a 256K stack, not 64K, otherwise the thread creation
     might crash the process due to a stack overflow. */
d778 22
@


1.90
log
@* miscfuncs.cc (__import_address): Avoid NULL explicitly.
@
text
@d440 1
a440 1
  if (!imp || *((uint16_t *) imp) != 0x25ff)
@


1.89
log
@* miscfuncs.cc (__import_address): Avoid treating random instructions as import
jump.
* malloc_wrapper.cc (malloc_init): Remove comment about 64-bit.
@
text
@d440 1
a440 1
  if (*((uint16_t *) imp) != 0x25ff)
@


1.88
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d440 5
@


1.87
log
@* malloc_wrapper.cc: Change 'use_internal_malloc' to 'use_internal' throughout.
(export_malloc_called): Delete.
(internal_malloc_determined): New variable.
(malloc_init): Control calculation of internal/external malloc based on
'internal_malloc_determined'.  Use import_address() to determine if malloc in
user_data is ours or not.
* miscfuncs.cc (thread_wrapper): Make static.
(__import_address): Define new function.
* miscfuncs.h (import_address): New define.
(__import_address): Declare new function.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d437 1
a437 1
void * __attribute__ ((regparm (1)))
@


1.86
log
@Revert the reversion and go with implementation described in cgf-000017, with
some modifications.
* init.cc (dll_entry): Revert previous change.
* miscfuncs.cc: Include sigproc.h for exit_thread declaration.
* winsup.h (ExitThread): Define as 'exit_thread' to ensure no accidental use.
* sigproc.cc (exit_thread): New function.
(wait_sig): Handle __SIGTHREADEXIT case.  Don't just block rather than
returning from this function.
* sigproc.h (__SIGTHREADEXIT): New enum.
(exit_thread): Declare.
* sync.cc (muto::release): Accept a tls command-line argument.
* sync.h (muto::release): Accept a tls command-line parameter.  Default to
&_my_tls.
* cygerrno.h (__set_errno): Define as extern so that no function code is ever
emitted.
* cygserver_ipc.h (cygserver_ipc.h): Ditto.
* miscfuncs.h (transform_chars): Ditto.
* path.h (has_attribute): Ditto.
* security.h (privilege_luid): Ditto.
* winsup.h (flush_file_buffers): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d436 9
d460 1
a460 1
DWORD WINAPI
@


1.85
log
@* DevNotes: Add entry cgf-000018.
* init.cc (dll_entry): Grab process lock before exiting to ensure that thread
doesn't exit before parent if parent is exiting.
* _cygtls.cc (_cygtls::call2): Revert previous 2012-12-21 change.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
* sigproc.cc (exit_thread): Ditto.
(wait_sig): Ditto.
* sync.cc (muto::release): Ditto.
* sync.h (muto::release): Ditto.
* sigproc.h (__SIGTHREADEXIT): Delete enum.
(exit_thread): Delete declaration.
@
text
@d31 1
@


1.84
log
@* DevNotes: Add entry cgf-000017.
* _cygtls.cc (_cygtls::call2): Use new exit_thread function in place of
ExitThread.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
(pthread_mutex::unlock): Set tid to NULL rather than 0.
(pthread_spinlock::unlock): Ditto.
* pinfo.cc (commune_process): Actually call lock_process constructor.
* sigproc.cc (exit_thread): New function.
(wait_sig): Handle __SIGTHREADEXIT case.  Don't just block rather than
returning from this function.
* sigproc.h (__SIGTHREADEXIT): New enum.
(exit_thread): Declare.
* sync.cc (muto::release): Accept a tls command-line argument.
* sync.h (muto::release): Accept a tls command-line parameter.  Default to
&_my_tls.
@
text
@a29 1
#include "sigproc.h"
d549 1
a549 1
  exit_thread (0);
@


1.83
log
@whitespace cleanup
@
text
@d30 1
d550 1
a550 1
  ExitThread (0);
@


1.82
log
@	* miscfuncs.cc (WritePipeOverlapped): Define second parameter LPCVOID,
	rather than PCVOID.
	* miscfuncs.h (WritePipeOverlapped): Ditto.
@
text
@d519 27
a545 27
	   movl  %[WRAPPER_ARG], %%ebx # Load &wrapper_arg into ebx  \n\
	   movl  (%%ebx), %%eax        # Load thread func into eax   \n\
	   movl  4(%%ebx), %%ecx       # Load thread arg into ecx    \n\
	   movl  8(%%ebx), %%edx       # Load stackaddr into edx     \n\
	   movl  12(%%ebx), %%ebx      # Load stackbase into ebx     \n\
	   subl  %[CYGTLS], %%ebx      # Subtract CYGTLS_PADSIZE     \n\
	   subl  $4, %%ebx             # Subtract another 4 bytes    \n\
	   movl  %%ebx, %%esp          # Set esp                     \n\
	   xorl  %%ebp, %%ebp          # Set ebp to 0                \n\
	   # Make gcc 3.x happy and align the stack so that it is    \n\
	   # 16 byte aligned right before the final call opcode.     \n\
	   andl  $-16, %%esp           # 16 byte align               \n\
	   addl  $-12, %%esp           # 12 bytes + 4 byte arg = 16  \n\
	   # Now we moved to the new stack.  Save thread func address\n\
	   # and thread arg on new stack                             \n\
	   pushl %%ecx                 # Push thread arg onto stack  \n\
	   pushl %%eax                 # Push thread func onto stack \n\
	   # Now it's safe to release the OS stack.                  \n\
	   pushl $0x8000               # dwFreeType: MEM_RELEASE     \n\
	   pushl $0x0                  # dwSize:     0               \n\
	   pushl %%edx                 # lpAddress:  stackaddr       \n\
	   call _VirtualFree@@12        # Shoot                       \n\
	   # All set.  We can pop the thread function address from   \n\
	   # the stack and call it.  The thread arg is still on the  \n\
	   # stack in the expected spot.                             \n\
	   popl  %%eax                 # Pop thread_func address     \n\
	   call  *%%eax                # Call thread func            \n"
@


1.82.2.1
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d519 27
a545 27
	   movl  %[WRAPPER_ARG], %%ebx # Load &wrapper_arg into ebx	\n\
	   movl  (%%ebx), %%eax		# Load thread func into eax	\n\
	   movl  4(%%ebx), %%ecx	# Load thread arg into ecx	\n\
	   movl  8(%%ebx), %%edx	# Load stackaddr into edx	\n\
	   movl  12(%%ebx), %%ebx	# Load stackbase into ebx	\n\
	   subl  %[CYGTLS], %%ebx	# Subtract CYGTLS_PADSIZE	\n\
	   subl  $4, %%ebx		# Subtract another 4 bytes	\n\
	   movl  %%ebx, %%esp		# Set esp			\n\
	   xorl  %%ebp, %%ebp		# Set ebp to 0			\n\
	   # Make gcc 3.x happy and align the stack so that it is	\n\
	   # 16 byte aligned right before the final call opcode.	\n\
	   andl  $-16, %%esp		# 16 byte align			\n\
	   addl  $-12, %%esp		# 12 bytes + 4 byte arg = 16	\n\
	   # Now we moved to the new stack.  Save thread func address	\n\
	   # and thread arg on new stack				\n\
	   pushl %%ecx			# Push thread arg onto stack	\n\
	   pushl %%eax			# Push thread func onto stack	\n\
	   # Now it's safe to release the OS stack.			\n\
	   pushl $0x8000		# dwFreeType: MEM_RELEASE	\n\
	   pushl $0x0			# dwSize:     0			\n\
	   pushl %%edx			# lpAddress:  stackaddr		\n\
	   call _VirtualFree@@12		# Shoot				\n\
	   # All set.  We can pop the thread function address from	\n\
	   # the stack and call it.  The thread arg is still on the	\n\
	   # stack in the expected spot.				\n\
	   popl  %%eax			# Pop thread_func address	\n\
	   call  *%%eax			# Call thread func		\n"
@


1.82.2.2
log
@	* miscfuncs.cc (case_folded_lower): Change to unsigned char to avoid
	compiler warnings.
	(case_folded_upper): Ditto.
	(thread_wrapper): Add assembler code for x86_64.
	* winsup.h (case_folded_lower): Change to unsigned char.
	(case_folded_upper): Ditto.
	(cyg_tolower): Add cast to avoid compiler warnings.
	(cyg_toupper): Add cast to avoid compiler warnings.
@
text
@d34 1
a34 1
const unsigned char case_folded_lower[] NO_COPY = {
d53 1
a53 1
const unsigned char case_folded_upper[] NO_COPY = {
d517 1
a517 24
#ifdef __x86_64__
  __asm__ ("\n\
	   movq  %[WRAPPER_ARG], %%rbx	# Load &wrapper_arg into rbx	\n\
	   movq  (%%rbx), %%r12		# Load thread func into r12	\n\
	   movq  8(%%rbx), %%r13	# Load thread arg into r13	\n\
	   movq  16(%%rbx), %%rcx	# Load stackaddr into rcx	\n\
	   movq  24(%%rbx), %%rsp	# Load stackbase into rsp	\n\
	   subq  %[CYGTLS], %%rsp	# Subtract CYGTLS_PADSIZE	\n\
	   subq  $40, %%rsp		# Subtract another 40 bytes	\n\
	   				# (8 bytes + 32 bytes shadow)	\n\
	   xorq  %%rbp, %%rbp		# Set rbp to 0			\n\
	   # We moved to the new stack.					\n\
	   # Now it's safe to release the OS stack.			\n\
	   movl  $0x8000, %%r8d		# dwFreeType: MEM_RELEASE	\n\
	   xorl  %%edx, %%edx		# dwSize:     0			\n\
	   # stackaddr is already in the correct register rcx!		\n\
	   call  VirtualFree						\n\
	   # All set.  We can copy the thread function address and the	\n\
	   # thread arg from the stack and just call the function.	\n\
	   movq  %%r13, %%rcx		# Move thread arg to 1st arg reg\n\
	   call  *%%r12			# Call thread func		\n"
	   : : [WRAPPER_ARG] "r" (&wrapper_arg),
	       [CYGTLS] "i" (CYGTLS_PADSIZE));
#else
d519 1
a519 1
	   movl  %[WRAPPER_ARG], %%ebx	# Load &wrapper_arg into ebx	\n\
a547 1
#endif
@


1.82.2.3
log
@	* miscfuncs.cc (thread_wrapper): Use PVOID instead of VOID *.
	Fix stack alignment before calling VirtualFree.  Fix comments.
@
text
@d451 1
a451 1
thread_wrapper (PVOID arg)
d525 2
a526 3
	   				# (here we are 16 bytes aligned)\n\
	   subq  $32, %%rsp		# Subtract another 32 bytes	\n\
	   				# (shadow space for arg regs)	\n\
d532 1
a532 1
	   # dwAddress is already in the correct arg register rcx	\n\
d534 2
a535 2
	   # All set.  We can copy the thread arg from the safe		\n\
	   # register r13 and then just call the function.		\n\
@


1.82.2.4
log
@Pull in changes from HEAD
@
text
@a30 1
#include "sigproc.h"
@


1.82.2.5
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a435 9
/* Return an address from the import jmp table of main program.  */
void * __reg1
__import_address (void *imp)
{
  const char *ptr = (const char *) imp;
  const uintptr_t *jmpto = (uintptr_t *) *((uintptr_t *) (ptr + 2));
  return (void *) *jmpto;
}

d451 1
a451 1
static DWORD WINAPI
@


1.82.2.6
log
@	* miscfuncs.cc (__import_address): Fix address computation for 64 bit.
@
text
@a440 4
#ifdef __x86_64__
  /* On 64 bit, the jmp address is pc relative. */
  const uintptr_t *jmpto = (uintptr_t *) (ptr + 6 + *(int32_t *)(ptr + 2));
#else
a441 1
#endif
@


1.82.2.7
log
@	* cygtls.h (_tlsbase): Temporary workaround for GCC bug.
	(_tlsbase): Ditto.
	* cygwin64.din: Set BASE temporariliy to address < 32 bit to workaround
	GDB bug.
	* dcrt0.cc (child_info_fork::alloc_stack): Temporary workaround for GCC
	bug.
	(dll_crt0_1): Ditto.
	* miscfuncs.cc (memset): Temporary workaround missing MSABI function in
	newlib.
	(memcpy): Ditto.
	* include/cygwin/config.h (__getreent): Drop definition for x86_64 to
	workaround GCC bug.
@
text
@a707 22

#ifdef __x86_64__
// TODO: The equivalent newlib functions only work for SYSV ABI so far.
extern "C" void *
memset (void *s, int c, size_t n)
{
  char *cs = (char *) s;
  while (n-- > 0)
    *cs++ = c;
  return s;
}

extern "C" void *
memcpy(void *dest, const void *src, size_t n)
{
  char *dp = (char *) dest;
  const char *sp = (const char *) src;
  while (n-- > 0)
    *dp++ = *sp++;
  return dest;
}
#endif
@


1.82.2.8
log
@	* cygtls.h: Cleanup x86_64 related comment.
	(_tlsbase): Change return type to PVOID.
	(_tlstop): Ditto.
	(_my_tls): Accommodate above change.
	* dcrt0.cc (child_info_fork::alloc_stack): Revert previous patch, but
	keep cast to PVOID.
	(dll_crt0_1): Ditto.
	* exception.h: Define _exception_list as _EXCEPTION_REGISTRATION_RECORD
	on x86_64.
	(_except_list): Define in terms of NtCurrentTeb() on x86_64.
	* miscfuncs.cc (__import_address): Handle 32 bit absolute addressing
	in IAT on x86_64.
	* include/cygwin/config.h (___getreent): New inline function on
	x86_64.  Define __getreent in terms of ___getreent on x86_64.  Fix
	comment accordingly.
@
text
@a439 17
#ifdef __x86_64__
  bool pcrel;
  /* FIXME in ld?  How's 32 bit absolute addressing supposed to work
     after rebasing an executable to an address > 32 bit?!? */
  if ((*((uint32_t *) imp) & 0xffffff) == 0x2524ff)
    pcrel = false;
  else if (*((uint16_t *) imp) == 0x25ff)
    pcrel = true;
  else
    return NULL;
#else
  if (*((uint16_t *) imp) != 0x25ff)
    return NULL;
#endif
  myfault efault;
  if (efault.faulted ())
    return NULL;
d442 2
a443 5
  const uintptr_t *jmpto;
  if (pcrel)
    jmpto = (uintptr_t *) (ptr + 6 + *(int32_t *)(ptr + 2));
  else
    jmpto = (uintptr_t *) (uintptr_t) *((uint32_t *)(ptr + 3));
@


1.82.2.9
log
@	* Makefile.in ($(LIB_NAME)): Add --target option to mkimport call.
	* gendef: Drop -w option.  Make callto sigfe function pc-relative
	on x86_64.
	* miscfuncs.cc (__import_address): Drop comment and misguide attempt
	to handle absolute addressing in x86_64 mode.
	* mkimport: Add --target option.  Handle x86_64 target, especially
	create pc-relative jmp calls.
@
text
@d440 11
d453 1
d459 5
a463 1
  const uintptr_t *jmpto = (uintptr_t *) (ptr + 6 + *(int32_t *)(ptr + 2));
@


1.82.2.10
log
@	* miscfuncs.cc (RtlFillMemory): Declare.
	(RtlCopyMemory): Declare.
	(memset): Just call RtlFillMemory.
	(memcpy): Just call RtlCopyMemory.
	* mmap.cc (class mmap_record): Drop enforced packing.  Reorder members
	to allow tight packing on 32 as well as on 64 bit.
	* include/sys/dirent.h: Don't enforced structure packing on x86_64.
	(__DIRENT_COOKIE): Use different value on 64 bit.
@
text
@a714 5
#undef RtlFillMemory
#undef RtlCopyMemory
extern "C" void NTAPI RtlFillMemory (PVOID, SIZE_T, BYTE);
extern "C" void NTAPI RtlCopyMemory (PVOID, const VOID *, SIZE_T);

d718 3
a720 1
  RtlFillMemory (s, n, c);
d727 4
a730 1
  RtlCopyMemory (dest, src, n);
@


1.82.2.11
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d35 1
a35 1
const unsigned char case_folded_lower[] = {
d54 1
a54 1
const unsigned char case_folded_upper[] = {
d73 1
a73 1
const char isalpha_array[] = {
d285 1
a285 1
  static const DWORD priority[] =
a595 63
#ifdef __x86_64__
/* The memory region used for thread stacks */
#define THREAD_STORAGE_LOW	0x080000000L
#define THREAD_STORAGE_HIGH	0x100000000L
/* We provide the stacks always in 1 Megabyte slots */
#define THREAD_STACK_SLOT	0x100000L	/* 1 Meg */
/* Maximum stack size returned from the pool. */
#define THREAD_STACK_MAX	0x20000000L	/* 512 Megs */

class thread_allocator
{
  UINT_PTR current;
public:
  thread_allocator () : current (THREAD_STORAGE_HIGH) {}
  PVOID alloc (SIZE_T size)
  {
    SIZE_T real_size = roundup2 (size, THREAD_STACK_SLOT);
    BOOL overflow = FALSE;
    PVOID real_stackaddr = NULL;

    /* If an application requests a monster stack, we fulfill this request
       from outside of our pool, top down. */
    if (real_size > THREAD_STACK_MAX)
      return VirtualAlloc (NULL, real_size, MEM_RESERVE | MEM_TOP_DOWN,
			   PAGE_READWRITE);
    /* Simple round-robin.  Keep looping until VirtualAlloc succeeded, or
       until we overflowed and hit the current address. */
    for (UINT_PTR addr = current - real_size;
	 !real_stackaddr && (!overflow || addr >= current);
	 addr -= THREAD_STACK_SLOT)
      {
	if (addr < THREAD_STORAGE_LOW)
	  {
	    addr = THREAD_STORAGE_HIGH - real_size;
	    overflow = TRUE;
	  }
	real_stackaddr = VirtualAlloc ((PVOID) addr, real_size,
				       MEM_RESERVE, PAGE_READWRITE);
	if (!real_stackaddr)
	  {
	    /* So we couldn't grab this space.  Let's check the state.
	       If this area is free, simply try the next lower 1 Meg slot.
	       Otherwise, shift the next try down to the AllocationBase
	       of the current address, minus the requested slot size.
	       Add THREAD_STACK_SLOT since that's subtracted in the next
	       run of the loop anyway. */
	    MEMORY_BASIC_INFORMATION mbi;
	    VirtualQuery ((PVOID) addr, &mbi, sizeof mbi);
	    if (mbi.State != MEM_FREE)
	      addr = (UINT_PTR) mbi.AllocationBase - real_size
						    + THREAD_STACK_SLOT;
	  }
      }
    /* If we got an address, remember it for the next allocation attempt. */
    if (real_stackaddr)
      current = (UINT_PTR) real_stackaddr;
    return real_stackaddr;
  }
};

thread_allocator thr_alloc NO_COPY;
#endif

d639 2
a640 5
      /* Reserve stack. */
#ifdef __x86_64__
      real_stackaddr = thr_alloc.alloc (real_stacksize);
#else
      /* FIXME? If the TOP_DOWN method tends to collide too much with
a646 1
#endif
@


1.82.2.12
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d758 5
a762 3
     minimum size for a thread stack is reserved by the OS.  Note that we
     reserve a 256K stack, not 64K, otherwise the thread creation might
     crash the process due to a stack overflow. */
@


1.82.2.13
log
@	* gendef (_sigfe): 16-byte align xmm0 storage and use movdqa.
	(_sigbe): Fix alignment before calling yield.  Use movdqa to save and
	restore xmm0.
	(sigdelayed): Use movdqa to save and restore xmm0.
	(_ZN7_cygtls4lockEv): Change absolute values to hex.
	(stabilize_sig_stack): Ditto.
	(setjmp): Add comment to explain usage of movdqu.
	(__sjfault): Ditto.
	(__ljfault): Ditto.
	(longjmp): Ditto. Access return value using 32 bit opcodes only.
	* miscfuncs.cc (thread_wrapper): Don't attempt to copy exception
	handler list on x86_64.
@
text
@d503 1
a503 1
#ifndef __x86_64__
a535 1
#endif
@


1.81
log
@	* miscfuncs.cc: Revert change from 2012-02-13 which used the
	Windows-provided stack rather than an own stack created in
	CygwinCreateThread.
	(struct thread_wrapper_arg): Rename commitsize to stacklimit.
	(CygwinCreateThread): Rename commitsize to real_stacklimit.
@
text
@d368 1
a368 1
WritePipeOverlapped (HANDLE h, PCVOID buf, DWORD len, LPDWORD ret_len,
@


1.80
log
@	* miscfuncs.cc (struct thread_wrapper_arg): Convert char * to PBYTE.
	Change related casts throughout.
	(thread_wrapper): Only do the thread change if the application provided
	the stack.  Otherwise, just use the Windows-provided stack.  Set up
	POSIX guardpage here, if necessary.  Move related comment from
	CygwinCreateThread here.
	(CygwinCreateThread): Never allocate and set up own stack here.  Just
	compute stack size to reserve and use value in CreateThread call if
	stack hasn't been provided by the application.
@
text
@d447 1
a447 1
  ULONG guardsize;
d461 4
d466 33
a498 35

  if (!wrapper_arg.stackaddr)
    {
      /* The simple case: Windows-provided stack. */

      /* If guardsize is exactly the page_size, we can assume that the
	 application will behave Windows conformant in terms of stack usage.
	 We can especially assume that it never allocates more than one
	 page at a time (alloca/_chkstk).  Therefore, this is the default
	 case which allows a Windows compatible stack setup with a
	 reserved region, a guard page, and a commited region.  We don't
	 need to set up a POSIX guardpage since Windows already handles
	 stack overflow: Trying to extend the stack into the last three
	 pages of the stack results in a SEGV. */
      if (wrapper_arg.guardsize != wincap.page_size ())
	{
	  /* However, if guardsize is set to something other than the
	     page size, we commit the entire stack, remove the Windows
	     guardpage and, if guardsize is > 0, set up a POSIX guardpage. */
	  DWORD old_prot;
	  ULONG stacksize = (uintptr_t) teb->Tib.StackBase
			    - (uintptr_t) teb->DeallocationStack;

	  VirtualAlloc (teb->DeallocationStack, stacksize,
			MEM_COMMIT, PAGE_READWRITE);
	  VirtualProtect (teb->DeallocationStack, stacksize,
			  PAGE_READWRITE, &old_prot);
	  VirtualProtect (teb->DeallocationStack, wrapper_arg.guardsize,
			  PAGE_NOACCESS, &old_prot);
	  teb->Tib.StackLimit = (PVOID) ((PBYTE) teb->DeallocationStack
					 + wrapper_arg.guardsize);
	}
      wrapper_arg.func (wrapper_arg.arg);
    }
  else
d500 5
a504 34
      /* The tricky case: Application-provided stack. */

      /* Remove _cygtls from this stack since it won't be used anymore. */
      _my_tls.remove (0);

      /* Set stack values in TEB */
      teb->Tib.StackBase = wrapper_arg.stackbase;
      teb->Tib.StackLimit = wrapper_arg.stackaddr;
      /* Set DeallocationStack value.  If we have an application-provided
	 stack, we set DeallocationStack to NULL, so NtTerminateThread does
	 not deallocate any stack. Store the OS-provided DeallocationStack
	 address in wrapper_arg.stackaddr.  The below assembler code will
	 release the OS stack after switching to our new stack. */
      wrapper_arg.stackaddr = (PBYTE) teb->DeallocationStack;
      teb->DeallocationStack = NULL;

      /* Initialize new _cygtls. */
      _my_tls.init_thread (wrapper_arg.stackbase - CYGTLS_PADSIZE,
			   (DWORD (*)(void*, void*)) wrapper_arg.func);

      /* Copy exception list over to new stack.  I'm not quite sure how the
	 exception list is extended by Windows itself.  What's clear is that it
	 always grows downwards and that it starts right at the stackbase.
	 Therefore we first count the number of exception records and place
	 the copy at the stackbase, too, so there's still a lot of room to
	 extend the list up to where our _cygtls region starts. */
      _exception_list *old_start = (_exception_list *) teb->Tib.ExceptionList;
      unsigned count = 0;
      teb->Tib.ExceptionList = NULL;
      for (_exception_list *e_ptr = old_start;
	   e_ptr && e_ptr != (_exception_list *) -1;
	   e_ptr = e_ptr->prev)
	++count;
      if (count)
d506 2
a507 5
	  _exception_list *new_start = (_exception_list *) wrapper_arg.stackbase
							   - count;
	  teb->Tib.ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)
				   new_start;
	  while (true)
d509 2
a510 9
	      new_start->handler = old_start->handler;
	      if (old_start->prev == (_exception_list *) -1)
		{
		  new_start->prev = (_exception_list *) -1;
		  break;
		}
	      new_start->prev = new_start + 1;
	      new_start = new_start->prev;
	      old_start = old_start->prev;
d512 3
d516 1
d518 30
a547 31
      __asm__ ("\n\
	       movl  %[WRAPPER_ARG], %%ebx # Load &wrapper_arg into ebx  \n\
	       movl  (%%ebx), %%eax        # Load thread func into eax   \n\
	       movl  4(%%ebx), %%ecx       # Load thread arg into ecx    \n\
	       movl  8(%%ebx), %%edx       # Load stackaddr into edx     \n\
	       movl  12(%%ebx), %%ebx      # Load stackbase into ebx     \n\
	       subl  %[CYGTLS], %%ebx      # Subtract CYGTLS_PADSIZE     \n\
	       subl  $4, %%ebx             # Subtract another 4 bytes    \n\
	       movl  %%ebx, %%esp          # Set esp                     \n\
	       xorl  %%ebp, %%ebp          # Set ebp to 0                \n\
	       # Make gcc 3.x happy and align the stack so that it is    \n\
	       # 16 byte aligned right before the final call opcode.     \n\
	       andl  $-16, %%esp           # 16 byte align               \n\
	       addl  $-12, %%esp           # 12 bytes + 4 byte arg = 16  \n\
	       # Now we moved to the new stack.  Save thread func address\n\
	       # and thread arg on new stack                             \n\
	       pushl %%ecx                 # Push thread arg onto stack  \n\
	       pushl %%eax                 # Push thread func onto stack \n\
	       # Now it's safe to release the OS stack.                  \n\
	       pushl $0x8000               # dwFreeType: MEM_RELEASE     \n\
	       pushl $0x0                  # dwSize:     0               \n\
	       pushl %%edx                 # lpAddress:  stackaddr       \n\
	       call _VirtualFree@@12        # Shoot                       \n\
	       # All set.  We can pop the thread function address from   \n\
	       # the stack and call it.  The thread arg is still on the  \n\
	       # stack in the expected spot.                             \n\
	       popl  %%eax                 # Pop thread_func address     \n\
	       call  *%%eax                # Call thread func            \n"
	       : : [WRAPPER_ARG] "r" (&wrapper_arg),
		   [CYGTLS] "i" (CYGTLS_PADSIZE));
    }
d557 1
d561 1
d581 3
a583 1
      /* If not, we let CreateThread reserve the stack. */
d595 70
a664 1
      wrapper_arg->guardsize = real_guardsize;
d666 1
a666 11
  /* Use the STACK_SIZE_PARAM_IS_A_RESERVATION parameter.  This doesn't
     work on Windows 2000, but either we deallocate the OS stack in
     thread_wrapper anyway, or the reservation is rounded to the next Meg.
     Nothing to worry about.
     Note that we reserve a 256K stack as minimum size, not 64K, otherwise
     the thread creation might crash the process due to a stack overflow. */
  return CreateThread (&sec_none_nih, stackaddr ? 4 * PTHREAD_STACK_MIN
						: real_stacksize,
		       thread_wrapper, wrapper_arg,
		       creation_flags | STACK_SIZE_PARAM_IS_A_RESERVATION,
		       thread_id);
@


1.79
log
@	* Makefile.in (clean): Remove non-existant regexp dir.

	* collate.h: New header.
	(__collate_range_cmp): Declare.
	(__collate_load_error): Define.
	* glob.cc: Pull in latest version from FreeBSD.  Simplify and reduce
	Cygwin-specific changes.
	* regex/regcomp.c: Include collate.h on Cygwin as well.
	(__collate_range_cmp): Move from here...
	* nlsfuncs.cc (__collate_range_cmp): ...to here.

	* miscfuncs.cc (thread_wrapper): Fix typo in comment.
	(CygwinCreateThread): Take dead zone of Windows stack into account.
	Change the way how the stack is commited and how to handle guardpages.
	Explain how and why.
	* thread.h (PTHREAD_DEFAULT_STACKSIZE): Change definition.  Explain why.
@
text
@d445 3
a447 3
  char *stackaddr;
  char *stackbase;
  char *commitaddr;
d461 5
a465 2
  /* Remove _cygtls from this stack since it won't be used anymore. */
  _my_tls.remove (0);
d467 30
a496 35
  /* Set stack values in TEB */
  PTEB teb = NtCurrentTeb ();
  teb->Tib.StackBase = wrapper_arg.stackbase;
  teb->Tib.StackLimit = wrapper_arg.commitaddr ?: wrapper_arg.stackaddr;
  /* Set DeallocationStack value.  If we have an application-provided stack,
     we set DeallocationStack to NULL, so NtTerminateThread does not deallocate
     any stack.  If we created the stack in CygwinCreateThread, we set
     DeallocationStack to the stackaddr of our own stack, so it's automatically
     deallocated when the thread is terminated. */
  char *dealloc_addr = (char *) teb->DeallocationStack;
  teb->DeallocationStack = wrapper_arg.commitaddr ? wrapper_arg.stackaddr
						  : NULL;
  /* Store the OS-provided DeallocationStack address in wrapper_arg.stackaddr.
     The below assembler code will release the OS stack after switching to our
     new stack. */
  wrapper_arg.stackaddr = dealloc_addr;

  /* Initialize new _cygtls. */
  _my_tls.init_thread (wrapper_arg.stackbase - CYGTLS_PADSIZE,
		       (DWORD (*)(void*, void*)) wrapper_arg.func);

  /* Copy exception list over to new stack.  I'm not quite sure how the
     exception list is extended by Windows itself.  What's clear is that it
     always grows downwards and that it starts right at the stackbase.
     Therefore we first count the number of exception records and place
     the copy at the stackbase, too, so there's still a lot of room to
     extend the list up to where our _cygtls region starts. */
  _exception_list *old_start = (_exception_list *) teb->Tib.ExceptionList;
  unsigned count = 0;
  teb->Tib.ExceptionList = NULL;
  for (_exception_list *e_ptr = old_start;
       e_ptr && e_ptr != (_exception_list *) -1;
       e_ptr = e_ptr->prev)
    ++count;
  if (count)
d498 34
a531 5
      _exception_list *new_start = (_exception_list *) wrapper_arg.stackbase
						       - count;
      teb->Tib.ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)
			       new_start;
      while (true)
d533 5
a537 2
	  new_start->handler = old_start->handler;
	  if (old_start->prev == (_exception_list *) -1)
d539 9
a547 2
	      new_start->prev = (_exception_list *) -1;
	      break;
a548 3
	  new_start->prev = new_start + 1;
	  new_start = new_start->prev;
	  old_start = old_start->prev;
d550 31
a581 31

  __asm__ ("\n\
	   movl  %[WRAPPER_ARG], %%ebx # Load &wrapper_arg into ebx  \n\
	   movl  (%%ebx), %%eax        # Load thread func into eax   \n\
	   movl  4(%%ebx), %%ecx       # Load thread arg into ecx    \n\
	   movl  8(%%ebx), %%edx       # Load stackaddr into edx     \n\
	   movl  12(%%ebx), %%ebx      # Load stackbase into ebx     \n\
	   subl  %[CYGTLS], %%ebx      # Subtract CYGTLS_PADSIZE     \n\
	   subl  $4, %%ebx             # Subtract another 4 bytes    \n\
	   movl  %%ebx, %%esp          # Set esp                     \n\
	   xorl  %%ebp, %%ebp          # Set ebp to 0                \n\
	   # Make gcc 3.x happy and align the stack so that it is    \n\
	   # 16 byte aligned right before the final call opcode.     \n\
	   andl  $-16, %%esp           # 16 byte align               \n\
	   addl  $-12, %%esp           # 12 bytes + 4 byte arg = 16  \n\
	   # Now we moved to the new stack.  Save thread func address\n\
	   # and thread arg on new stack                             \n\
	   pushl %%ecx                 # Push thread arg onto stack  \n\
	   pushl %%eax                 # Push thread func onto stack \n\
	   # Now it's safe to release the OS stack.                  \n\
	   pushl $0x8000               # dwFreeType: MEM_RELEASE     \n\
	   pushl $0x0                  # dwSize:     0               \n\
	   pushl %%edx                 # lpAddress:  stackaddr       \n\
	   call _VirtualFree@@12        # Shoot                       \n\
	   # All set.  We can pop the thread function address from   \n\
	   # the stack and call it.  The thread arg is still on the  \n\
	   # stack in the expected spot.                             \n\
	   popl  %%eax                 # Pop thread_func address     \n\
	   call  *%%eax                # Call thread func            \n"
	   : : [WRAPPER_ARG] "r" (&wrapper_arg),
	       [CYGTLS] "i" (CYGTLS_PADSIZE));
a590 1
  PVOID real_stackaddr = NULL;
a593 1
  HANDLE thread = NULL;
d608 2
a609 2
      wrapper_arg->stackaddr = (char *) stackaddr;
      wrapper_arg->stackbase = (char *) stackaddr + stacksize;
d613 1
a613 3
      char *commitaddr;

      /* If not, we have to create the stack here. */
d625 1
a625 70
      /* Reserve stack.
	 FIXME? If the TOP_DOWN method tends to collide too much with
	 other stuff, we should provide our own mechanism to find a
	 suitable place for the stack.  Top down from the start of
	 the Cygwin DLL comes to mind. */
      real_stackaddr = VirtualAlloc (NULL, real_stacksize,
				     MEM_RESERVE | MEM_TOP_DOWN,
				     PAGE_READWRITE);
      if (!real_stackaddr)
	return NULL;
      /* Set up committed region.  Two cases: */
      if (real_guardsize != wincap.page_size ())
	{
	  /* If guardsize is set to something other than the page size, we
	     commit the entire stack and, if guardsize is > 0, we set up a
	     POSIX guardpage.  We don't set up a Windows guardpage. */
	  if (!VirtualAlloc (real_stackaddr, real_guardsize, MEM_COMMIT,
			     PAGE_NOACCESS))
	    goto err;
	  commitaddr = (char *) real_stackaddr + real_guardsize;
	  if (!VirtualAlloc (commitaddr, real_stacksize - real_guardsize,
			     MEM_COMMIT, PAGE_READWRITE))
	    goto err;
	}
      else
	{
	  /* If guardsize is exactly the page_size, we can assume that the
	     application will behave Windows conformant in terms of stack usage.
	     We can especially assume that it never allocates more than one
	     page at a time (alloca/_chkstk).  Therefore, this is the default
	     case which allows a Windows compatible stack setup with a
	     reserved region, a guard page, and a commited region.  We don't
	     need to set up a POSIX guardpage since Windows already handles
	     stack overflow: Trying to extend the stack into the last three
	     pages of the stack results in a SEGV.
	     We always commit 64K here, starting with the guardpage. */
	  commitaddr = (char *) real_stackaddr + real_stacksize
				- wincap.allocation_granularity ();
	  if (!VirtualAlloc (commitaddr, wincap.page_size (), MEM_COMMIT,
			     PAGE_READWRITE | PAGE_GUARD))
	    goto err;
	  commitaddr += wincap.page_size ();
	  if (!VirtualAlloc (commitaddr, wincap.allocation_granularity ()
					 - wincap.page_size (), MEM_COMMIT,
			     PAGE_READWRITE))
	    goto err;
      	}
      wrapper_arg->stackaddr = (char *) real_stackaddr;
      wrapper_arg->stackbase = (char *) real_stackaddr + real_stacksize;
      wrapper_arg->commitaddr = commitaddr;
    }
  /* Use the STACK_SIZE_PARAM_IS_A_RESERVATION parameter so only the
     minimum size for a thread stack is reserved by the OS.  This doesn't
     work on Windows 2000, but we deallocate the OS stack in thread_wrapper
     anyway, so this should be a problem only in a tight memory condition.
     Note that we reserve a 256K stack, not 64K, otherwise the thread creation
     might crash the process due to a stack overflow. */
  thread = CreateThread (&sec_none_nih, 4 * PTHREAD_STACK_MIN,
			 thread_wrapper, wrapper_arg,
			 creation_flags | STACK_SIZE_PARAM_IS_A_RESERVATION,
			 thread_id);

err:
  if (!thread && real_stackaddr)
    {
      /* Don't report the wrong error even though VirtualFree is very unlikely
	 to fail. */
      DWORD err = GetLastError ();
      VirtualFree (real_stackaddr, 0, MEM_RELEASE);
      SetLastError (err);
d627 11
a637 1
  return thread;
@


1.78
log
@	* miscfuncs.cc (DEFAULT_STACKSIZE): Remove.
	(CygwinCreateThread): Simplify code by assuming that now stack-related
	input values are undefined.  Set stack protection to PAGE_READWRITE,
	as is default on Windows.  Add lengthy comment to explain POSIX
	guardpage.
	* thread.cc (pthread_attr::pthread_attr): Initialize stacksize as
	PTHREAD_DEFAULT_STACKSIZE.  Initialize guardsize as
	PTHREAD_DEFAULT_GUARDSIZE.
	* thread.h (PTHREAD_DEFAULT_STACKSIZE): Define.  Add comment to explain.
	(PTHREAD_DEFAULT_GUARDSIZE): Define.
@
text
@d530 1
a530 1
	   andl  $-16, %%esp           # 16 bit align                \n\
d581 2
d588 4
d605 37
a641 22
      /* Set up committed region.  In contrast to the OS we commit 64K and
	 set up just a single guard page at the end. */
      char *commitaddr = (char *) real_stackaddr
				  + real_stacksize
				  - wincap.allocation_granularity ();
      if (!VirtualAlloc (commitaddr, wincap.page_size (), MEM_COMMIT,
			 PAGE_READWRITE | PAGE_GUARD))
	goto err;
      commitaddr += wincap.page_size ();
      if (!VirtualAlloc (commitaddr, wincap.allocation_granularity ()
				     - wincap.page_size (), MEM_COMMIT,
			 PAGE_READWRITE))
	goto err;
      /* If the guardsize is != 0 (which is the default), set up a POSIX
      	 guardpage at the end of the stack. This isn't the same as the
	 Windows guardpage, which is used to convert reserved stack to
	 commited stack if necessary.  Rather, the POSIX guardpage consists
	 of one or more memory pages with NOACCESS protection.  It's supposed
	 to safeguard memory areas beyond the stack against stack overflow. */
      if (real_guardsize)
	VirtualAlloc (real_stackaddr, real_guardsize, MEM_COMMIT,
		      PAGE_NOACCESS);
@


1.77
log
@	* miscfuncs.cc (DEFAULT_STACKSIZE): Set to 1 Megs.  Drop comment about
	RLIMIT_STACK.

	* registry.cc (get_registry_hive_path): Expect the user hive path to
	be never longer than MAX_PATH.  Don't prepend native NT path prefix
	here.  Add comment.
	(load_registry_hive): Prepend native NT path prefix here.  Additionally
	try to load user's classes hive.
	* uinfo.cc (cygheap_user::env_userprofile): Reduce size of
	userprofile_env_buf to MAX_PATH.  Add comment.
@
text
@a551 2
#define DEFAULT_STACKSIZE (1024 * 1024)

a572 4
  /* Set stacksize. */
  real_stacksize = stacksize ?: DEFAULT_STACKSIZE;
  if (real_stacksize < PTHREAD_STACK_MIN)
    real_stacksize = PTHREAD_STACK_MIN;
d577 1
a577 1
      wrapper_arg->stackbase = (char *) stackaddr + real_stacksize;
d582 4
a585 11
      real_stacksize = roundup2 (real_stacksize, wincap.page_size ());
      /* If no guardsize has been specified by the application, use the
	 system pagesize as default. */
      real_guardsize = (guardsize != (ULONG) -1)
		       ? guardsize : wincap.page_size ();
      if (real_guardsize)
	real_guardsize = roundup2 (real_guardsize, wincap.page_size ());
      /* Add the guardsize to the stacksize, but only if the stacksize and
	 the guardsize have been explicitely specified. */
      if (stacksize || guardsize != (ULONG) -1)
	real_stacksize += real_guardsize;
d596 1
a596 1
				     PAGE_EXECUTE_READWRITE);
d605 1
a605 1
			 PAGE_EXECUTE_READWRITE | PAGE_GUARD))
d610 1
a610 1
			 PAGE_EXECUTE_READWRITE))
d612 6
@


1.76
log
@	* miscfuncs.cc (thread_wrapper): Make sure stack is 16 byte aligned
	to make gcc-3 compiled pthread applications happy.
@
text
@d552 1
a552 2
/* FIXME: This should be settable via setrlimit (RLIMIT_STACK). */
#define DEFAULT_STACKSIZE (512 * 1024)
@


1.75
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d528 4
@


1.74
log
@* fhandler.h (fhandler_pipe::create): Rename from the misnamed
"create_selectable".  Change return to DWORD.
(fhandler_pty_common::pipesize): New constant.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Reflect create_selectable
name change.
* miscfuncs.cc (CreatePipeOverlapped): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Rename from the misnamed "create_selectable".  Return
DWORD.  Only set pipe size to default when it is passed in as zero.
* fhandler_tty.cc (fhandler_pty_master::setup): Ditto.  Use
fhandler_pty_common::pipesize rather than a raw constant.
* tty.cc (tty::not_allocated): Ditto.
* sigproc.cc (sigproc_init): Use create_selectable to create the signal pipe to
get a more appropriate message based pipe.
@
text
@d350 1
a350 1
{             
d352 2
a353 2
  BOOL ret;   
            
d362 1
a362 1
    }     
d364 3
a366 3
  return ret; 
}             
            
d371 2
a372 2
  OVERLAPPED ov; 
  BOOL ret; 
d382 1
a382 1
    }     
@


1.73
log
@* fhandler.h (fhandler_pipe::create_selectable): Remove optional argument, take
an options argument for CreateNamedPipe/CreateFile.  Change handle arguments to
expect pointers.
(fhandler_fifo::fifo_state): Delete.
(fhandler_fifo::dummy_client): Ditto.
(fhandler_fifo::open_nonserver): Ditto.
(fhandler_fifo::wait_state): Ditto.
(fhandler_fifo::raw_write): Ditto.
(fhandler_fifo::read_ready): New field.
(fhandler_fifo::write_ready): Ditto.
(fhandler_fifo::wait): Modify argument.
(fhandler_fifo::fifo_name): Add a new argument.
(fhandler_fifo::fixup_after_fork): New function.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove initialization of
expunged elements.  Initialize new handles to NULL.
(fhandler_fifo::open_nonserver): Delete.
(fnevent): New macro for creating a named event.
(fnpipe): New macro for creating a unique named pipe name.
(create_pipe): New macro for simplification of named pipe creation.
(fhandler_fifo::fifo_name): Use new argument when creating a shared name.
(fhandler_fifo::open): Rewrite.  Use events to synchronize.
(pure_debug_printf): New macro, active only when DEBUGGING.
(fhandler_fifo::wait): Rewrite to wait for new fifo events which are supplied
as a parameter.
(fhandler_fifo::raw_read): Rewrite to use handle mechanism to detect
client-side disconnect.
(fhandler_fifo::raw_write): Delete.
(fhandler_fifo::close): Remove accommodations for expunged fields.  Close event
handles.
(fhandler_fifo::dup): Remove accommodations for expunged fields.  Duplicate
event handles.
(fhandler_fifo::fixup_after_fork): New function.  Perform fixups on event
handles.
(fhandler_fifo::set_close_on_exec): Remove accommodations for expunged fields.
Set inheritance for new handle fields.
* miscfuncs.cc (CreatePipeOverlapped): Accommodate changes in
fhandler_pipe::create_selectable.
* tty.cc (tty::not_allocated): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create_selectable): Accept an extra open_mode argument.  Pass
arguments by reference and allow opening one end of the pipe at a time.
* sys/strace.h (debug_only_printf): Define new macro which calls debug_printf
only when DEBUGGING is defined.
@
text
@d340 2
a341 2
  int ret = fhandler_pipe::create_selectable (sa, hr, hw, 0, NULL,
					      FILE_FLAG_OVERLAPPED);
@


1.72
log
@	* miscfuncs.cc (CreatePipeOverlapped): New function.
	(ReadPipeOverlapped): Ditto.
	(WritePipeOverlapped): Ditto.
	* miscfuncs.h: Declare new functions.
	* pinfo.cc (commune_process): Call WritePipeOverlapped instead of
	WriteFile.  Set timeout to 1 sec.
	(_pinfo::commune_request): Call ReadPipeOverlapped instead of ReadFile.
	Set timeout to 0.5 secs.
	* sigproc.cc (sig_send): Create pipe using CreatePipeOverlapped.
@
text
@d340 2
a341 1
  int ret = fhandler_pipe::create_selectable (sa, *hr, *hw, 0);
@


1.71
log
@* miscfuncs.cc (create_pipe): Delete obsolete function.
* miscfuncs.h (create_pipe): Delete define.
* pipe.c (fhandler_pipe::create_selectable): Delete obsolete comment.
@
text
@d335 51
@


1.70
log
@	* miscfuncs.cc (yield): Drop thread priority only once.
@
text
@a334 14
#undef CreatePipe
bool
create_pipe (PHANDLE hr,PHANDLE hw, LPSECURITY_ATTRIBUTES sa, DWORD n)
{
  for (int i = 0; i < 10; i++)
    if (CreatePipe (hr, hw, sa, n))
      return true;
    else if (GetLastError () == ERROR_PIPE_BUSY && i < 9)
      Sleep (10);
    else
      break;
  return false;
}

@


1.69
log
@* exceptions.cc (CALL_HANDLER_RETRY_INNER): Rename to reflect different
functionality.
(CALL_HANDLER_RETRY_OUTER): New define.
(setup_handler): Add outer loop to signal handler to try harder to deliver the
signal.
* miscfuncs.cc (yield): Drop priority and use SleepEx() to force thread
rescheduling rather than relying on SwitchToThread().
@
text
@d242 2
a245 2
      int prio = GetThreadPriority (GetCurrentThread ());
      SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
a250 1
      SetThreadPriority (GetCurrentThread (), prio);
d252 1
@


1.68
log
@whitespace elimination
@
text
@d238 1
d242 11
a252 2
  for (int i = 0; i < 3; i++)
    SwitchToThread ();
@


1.67
log
@	* miscfuncs.cc (CygwinCreateThread): Fix condition for adding the
	guardsize to the stacksize.  Fix accompanying comment.
@
text
@d513 1
a513 1
  
d552 3
a554 3
         FIXME? If the TOP_DOWN method tends to collide too much with
	 other stuff, we should provide our own mechanism to find a 
	 suitable place for the stack.  Top down from the start of 
@


1.66
log
@	* miscfuncs.cc (CygwinCreateThread): Add accidentally missing comment.
@
text
@d544 3
a546 5
      /* If the default stacksize is used and guardsize has not been specified,
	 don't add a guard page to the size.  Same if stacksize is only
	 PTHREAD_STACK_MIN. */
      if (stacksize && guardsize != (ULONG) -1
	  && real_stacksize > PTHREAD_STACK_MIN)
@


1.65
log
@	* miscfuncs.cc (thread_wrapper): Remove statements added for debugging
	purposes.
@
text
@d530 1
@


1.64
log
@	* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
	(class child_info_fork): Remove stacksize, add stackaddr and guardsize
	members.
	* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Partial rewrite
	to regenerate the stack exactly as in the parent.
	(child_info_fork::alloc_stack): Set stackaddr to 0, rather than
	stacksize.
	(dll_crt0_1): Check for stackaddr before changing the stack addresses
	in the TEB.
	* fork.cc (frok::child): Check for stackaddr here.
	(frok::parent): Set ch.stackaddr and ch.guardsize if not called from
	the main thread.
	* init.cc (dll_entry): Replace pointer to NT_TIB with pointer to TEB.
	Fix incorrectly changed address test before removing _my_tls.
	Set StackLimit to NULL on Windows 2000.  Explain why.
	* miscfuncs.cc (struct thread_wrapper_arg): Store stackbase rather
	than stacksize, store commitaddr, remove guardsize.  Store all pointers
	as char * for easier address arithmetic.
	(thread_wrapper): Rewrite to remove OS stack before calling thread
	function.  Add lots of comments to explain what we do.
	(CygwinCreateThread): Reserve our own stack in case we got no
	application stack.  Add comments.
	* ntdll.h (struct _TEB): Extend defintion up to DeallocationStack
	member.
	* thread.cc (pthread_attr::pthread_attr): Use "(size_t) -1"
	rather then 0xffffffff.
	* wincap.h (wincaps::has_stack_size_param_is_a_reservation): New
	element.
	* wincap.cc: Implement above element throughout.
@
text
@a413 2
  _cygtls *tls;
  tls = &_my_tls;
@


1.63
log
@	* miscfuncs.cc (thread_wrapper): Remove unused _cygtls record.
	* mmap.cc (is_mmapped_region): Avoid crash if no mmaps exist.
@
text
@d29 2
d397 3
a399 3
  PVOID stackaddr;
  ULONG stacksize;
  ULONG guardsize;
d405 1
d409 1
d413 58
a470 27
  if (wrapper_arg.stackaddr)
    {
      /* If the application provided the stack, we must make sure that
	 it's actually used by the thread function.  So what we do here is
	 to compute the stackbase of the application-provided stack, move
	 _my_tls to the stackbase, and change the stack pointer accordingly. */
      _my_tls.remove (0);
      wrapper_arg.stackaddr = (PVOID) ((PBYTE) wrapper_arg.stackaddr
					       + wrapper_arg.stacksize);
      _tlsbase = (char *) wrapper_arg.stackaddr;
      wrapper_arg.stackaddr = (PVOID) ((PBYTE) wrapper_arg.stackaddr
					       - CYGTLS_PADSIZE);
      _tlstop = (char *) wrapper_arg.stackaddr;
      _my_tls.init_thread ((char *) wrapper_arg.stackaddr,
			   (DWORD (*)(void*, void*)) wrapper_arg.func);
      wrapper_arg.stackaddr = (PVOID) (_tlstop - sizeof (PVOID));
      __asm__ ("\n\
	       movl  %[WRAPPER_ARG], %%ebx # Load &wrapper_arg into ebx  \n\
	       movl  (%%ebx), %%eax        # Load thread func into eax   \n\
	       movl  4(%%ebx), %%ecx       # Load thread arg into ecx    \n\
	       movl  8(%%ebx), %%edx       # Load stackbase into edx     \n\
	       xorl  %%ebp, %%ebp          # Set ebp to 0                \n\
	       movl  %%edx, %%esp          # Set esp to stackbase        \n\
	       pushl %%ecx                 # Push thread arg onto stack  \n\
	       pushl %%eax                 # Push thread func onto stack \n\
	       jmp  *%%eax                 # Jump to thread func         \n"
	       : : [WRAPPER_ARG] "r" (&wrapper_arg));
a471 14
    }
  if (wrapper_arg.guardsize)
    {
      /* Set up POSIX guard pages.  Note that this is not the same as the
	 PAGE_GUARD protection.  Rather, the POSIX guard pages are a
	 PAGE_NOACCESS protected area which is supposed to guard against
	 stack overflow and to trigger a SIGSEGV if that happens. */
      PNT_TIB tib = &NtCurrentTeb ()->Tib;
      wrapper_arg.stackaddr = (PVOID) ((PBYTE) tib->StackBase
				       - wrapper_arg.stacksize);
      if (!VirtualAlloc (wrapper_arg.stackaddr, wrapper_arg.guardsize,
			 MEM_COMMIT, PAGE_NOACCESS))
	system_printf ("VirtualAlloc, %E");
    }
d473 27
a499 9
	   movl  %[WRAPPER_ARG], %%ebx     # Load &wrapper_arg into ebx  \n\
	   movl  (%%ebx), %%eax            # Load thread func into eax   \n\
	   movl  4(%%ebx), %%ecx           # Load thread arg into ecx    \n\
	   pushl %%ecx                     # Push thread arg onto stack  \n\
	   pushl %%eax                     # Push thread func onto stack \n\
	   jmp  *%%eax                     # Jump to thread func         \n"
	   : : [WRAPPER_ARG] "r" (&wrapper_arg));
  /* Never reached. */
  return ERROR_INVALID_FUNCTION;
d510 1
d514 1
d532 2
a533 3
      wrapper_arg->stackaddr = stackaddr;
      wrapper_arg->stacksize = real_stacksize;
      real_stacksize = PTHREAD_STACK_MIN;
d541 1
a541 1
      real_guardsize = (guardsize != 0xffffffff)
d546 4
a549 2
	 don't add a guard page to the size. */
      if (stacksize && guardsize != 0xffffffff)
d554 49
a602 3

      wrapper_arg->stacksize = real_stacksize;
      wrapper_arg->guardsize = real_guardsize;
d604 1
a604 6
  /* Use the STACK_SIZE_PARAM_IS_A_RESERVATION parameter to make sure the
     stack size is exactly the size we want. */
  return CreateThread (&sec_none_nih, real_stacksize, thread_wrapper,
		       wrapper_arg,
		       creation_flags | STACK_SIZE_PARAM_IS_A_RESERVATION,
		       thread_id);
@


1.62
log
@	* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Check if the
	requested stack is application-provided within the user heap or an
	mmapped region.  If so, just use it.  Add comment to explain why.
	* miscfuncs.cc (thread_wrapper): If an application-provided stack
	has been given, implement cygtls area at the stackbase.  Fix comment.
	* mmap.cc (is_mmapped_region): New function.
	* winsup.h (is_mmapped_region): Declare.
@
text
@d415 1
@


1.61
log
@	* miscfuncs.cc (thread_wrapper): Add comments to assembler code.
@
text
@d413 5
a417 7
	 to compute the stackbase of the application-provided stack and
	 change the stack pointer accordingly.

	 NOTE: _my_tls is on the stack created by CreateThread!  It's
	       unlikely the tls structure will ever exceed 64K, but if
	       so, we have to raise the size of the stack in the call
	       to CreateThread, too. */
d419 5
a423 2
					       + wrapper_arg.stacksize
					       - sizeof (PVOID));
@


1.60
log
@	* cygwin.din (pthread_attr_getguardsize): Export.
	(pthread_attr_setguardsize): Export.
	(pthread_attr_setstack): Export.
	(pthread_attr_setstackaddr): Export.
	* init.cc (dll_entry): Remove wow64_test_stack_marker.  Check for
	unusual stack address by testing stack addresses from current TEB.
	Check validity of _my_tls by testing if it's within the stack as
	given in current TEB.
	* miscfuncs.cc (struct thread_wrapper_arg): New structure used to
	push all required information to thread_wrapper function.
	(thread_wrapper): Wrapper function for actual thread function.
	If an application stack has been given, change %ebp and %esp so that
	the thread function runs on that stack.  If the thread has been created
	by CygwinCreateThread, set up the POSIX guard pages if necessary.
	(CygwinCreateThread): New function.
	* miscfuncs.h (CygwinCreateThread): Declare.
	* ntdll.h (struct _TEB): Define all members up to Peb.
	* posix.sgml (std-susv4): Move pthread_attr_getguardsize,
	pthread_attr_setguardsize and pthread_attr_setstack here.
	(std-deprec): Add pthread_attr_setstackaddr.
	* sysconf.cc (sca): Set _SC_THREAD_ATTR_STACKADDR to
	_POSIX_THREAD_ATTR_STACKADDR.
	* thread.cc (pthread::precreate): Copy pthread_attr stackaddr and
	guardsize members.
	(pthread::create): Call CygwinCreateThread.
	(pthread_attr::pthread_attr): Initialize guardsize.
	(pthread_attr_setstack): New function.
	(pthread_attr_setstackaddr): New function.
	(pthread_attr_setguardsize): New function.
	(pthread_attr_getguardsize): New function.
	(pthread_getattr_np): Copy attr.guardsize.
	* thread.h (pthread_attr): Add member guardsize.
	* include/pthread.h (pthread_attr_getguardsize): Declare.
	(pthread_attr_setguardsize): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d424 10
a433 9
	       movl %[WRAPPER_ARG], %%ebx \n\
	       movl (%%ebx), %%eax \n\
	       movl 4(%%ebx), %%ecx \n\
	       movl 8(%%ebx), %%edx \n\
	       xorl %%ebp, %%ebp \n\
	       movl %%edx, %%esp \n\
	       pushl %%ecx \n\
	       pushl %%eax \n\
	       jmp  *%%eax \n" : : [WRAPPER_ARG] "r" (&wrapper_arg));
d450 7
a456 6
	   movl %[WRAPPER_ARG], %%ebx \n\
	   movl (%%ebx), %%eax \n\
	   movl 4(%%ebx), %%ecx \n\
	   pushl %%ecx \n\
	   pushl %%eax \n\
	   jmp  *%%eax \n" : : [WRAPPER_ARG] "r" (&wrapper_arg));
@


1.59
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2011 Red Hat, Inc.
d18 1
d25 4
d384 135
@


1.58
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
a314 4
  if (!wincap.has_extended_priority_class ()
      && (prio == BELOW_NORMAL_PRIORITY_CLASS
	  || prio == ABOVE_NORMAL_PRIORITY_CLASS))
    prio = NORMAL_PRIORITY_CLASS;
@


1.57
log
@	Throughout, revert ill-conceived replacement of hMainThread with
	GetCurrentThread/NtCurrentThread.
	* dcrt0.cc (dll_crt0_0): Duplicate main thread handle to hMainThread
	again.
@
text
@d231 2
a232 2
extern "C" int
low_priority_sleep (DWORD secs)
d234 2
a235 34
  HANDLE thisthread = GetCurrentThread ();
  int curr_prio = GetThreadPriority (thisthread);
  bool staylow;
  if (secs != INFINITE)
    staylow = false;
  else
    {
      secs = 0;
      staylow = true;
    }

  if (!secs)
    {
      for (int i = 0; i < 3; i++)
	SwitchToThread ();
    }
  else
    {
      int new_prio;
      if (GetCurrentThreadId () == cygthread::main_thread_id)
	new_prio = THREAD_PRIORITY_LOWEST;
      else
	new_prio = GetThreadPriority (hMainThread);

      if (curr_prio != new_prio)
	/* Force any threads in normal priority to be scheduled */
	SetThreadPriority (thisthread, new_prio);
      Sleep (secs);

      if (!staylow && curr_prio != new_prio)
	SetThreadPriority (thisthread, curr_prio);
    }

  return curr_prio;
@


1.56
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d256 1
a256 1
	new_prio = GetThreadPriority (GetCurrentThread ());
@


1.55
log
@	* ctype.cc (_CTYPE_DATA_0_127): Add _B class to TAB character.
	(__ctype_default): New character class array for default ASCII
	character set.
	(__ctype_iso): New array of character class array for ISO charsets.
	(__ctype_cp): Ditto for singlebyte Windows codepages.
	(tolower): Implement as distinct function to support any singlebyte
	charset.
	(toupper): Ditto.
	(__set_ctype): New function to copy singlebyte character classes
	corresponding to current charset to ctype_b array.
	Align copyright text to upstream.
	* dcrt0.cc (dll_crt0_1): Reset current locale to "C" per POSIX.
	* environ.cc (set_file_api_mode): Remove.
	(codepage_init): Remove.
	(parse_thing): Remove "codepage" setting.
	(environ_init): Set locale according to environment settings, or
	to current codepage, before converting environment to multibyte.
	* fhandler.h (fhandler_console::write_replacement_char): Drop argument.
	* fhandler_console.cc (dev_console::str_to_con): Call sys_cp_mbstowcs
	rather than MultiByteToWideChar.
	(fhandler_console::write_replacement_char): Always print a funny
	half filled square if a character isn't in the current charset.
	(fhandler_console::write_normal): Convert to using __mbtowc
	rather than next_char.
	* fork.cc (frok::child): Drop call to set_file_api_mode.
	* globals.cc (enum codepage_type) Remove.
	(current_codepage): Remove.
	* miscfuncs.cc (cygwin_wcslwr): Unused, dangerous.  Remove.
	(cygwin_wcsupr): Ditto.
	(is_cp_multibyte): Remove.
	(next_char): Remove.
	* miscfuncs.h (is_cp_multibyte): Drop declaration.
	(next_char): Ditto.
	* strfuncs.cc (get_cp): Remove.
	(__db_wctomb): New function to implement _wctomb_r functionality for
	doublebyte charsets using WideCharToMultiByte.
	(__sjis_wctomb): New function to replace unusable newlib function.
	(__jis_wctomb): Ditto.
	(__eucjp_wctomb): Ditto.
	(__gbk_wctomb): New function.
	(__kr_wctomb): Ditto.
	(__big5_wctomb): Ditto.
	(__db_mbtowc): New function to implement _mbtowc_r functionality for
	doublebyte charsets using MultiByteToWideChar.
	(__sjis_mbtowc): New function to replace unusable newlib function.
	(__jis_mbtowc): Ditto.
	(__eucjp_mbtowc): Ditto.
	(__gbk_mbtowc): New function.
	(__kr_mbtowc): New function
	(__big5_mbtowc): New function
	(__set_charset_from_codepage): New function.
	(sys_wcstombs): Reimplement, basically using same wide char to multibyte
	conversion as newlib's application level functions.  Plus extras.
	Add lengthy comment to explain.  Change return type to size_t.
	(sys_wcstombs_alloc): Just use sys_wcstombs.  Change return type to
	size_t.
	(sys_cp_mbstowcs): Replace sys_mbstowcs, take additional codepage
	argument.  Explain why.  Change return type to size_t.
	(sys_mbstowcs_alloc): Just use sys_mbstowcs.  Change return type to
	size_t.
	* wchar.h: Declare internal functions implemented in strfuncs.cc.
	(wcscasecmp): Remove.
	(wcsncasecmp): Remove.
	(wcslwr): Remove.
	(wcsupr): Remove.
	* winsup.h (codepage_init): Remove declaration.
	(get_cp): Ditto.
	(sys_wcstombs): Align declaration to new implementation.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Add declaration.
	(sys_mbstowcs): Define as inline function.
	(sys_mbstowcs_alloc): Align declaration to new implementation.
	(set_file_api_mode): Remove declaration.
	* include/ctype.h (isblank): Redefine to use _B character class.
	(toupper): Remove ASCII-only definition.
	(tolower): Ditto.
@
text
@d256 1
a256 1
	new_prio = GetThreadPriority (hMainThread);
@


1.54
log
@	* miscfuncs.cc (cygwin_strncasecmp): Fix bug which results in
	prematurely truncated strings.  Simplify target length argument to
	sys_mbstowcs.
@
text
@a143 20
extern "C" wchar_t * __stdcall
cygwin_wcslwr (wchar_t *string)
{
  UNICODE_STRING us;

  RtlInitUnicodeString (&us, string);
  RtlDowncaseUnicodeString (&us, &us, FALSE);
  return string;
}

extern "C" wchar_t * __stdcall
cygwin_wcsupr (wchar_t *string)
{
  UNICODE_STRING us;

  RtlInitUnicodeString (&us, string);
  RtlUpcaseUnicodeString (&us, &us, FALSE);
  return string;
}

a171 112
/* FIXME?  We only support standard ANSI/OEM codepages according to
   http://www.microsoft.com/globaldev/reference/cphome.mspx as well
   as UTF-8 and codepage 1361, which is also mentioned as valid
   doublebyte codepage in MSDN man pages (e.g. IsDBCSLeadByteEx).
   Everything else will be hosed. */

bool
is_cp_multibyte (UINT cp)
{
  switch (cp)
    {
    case 932:
    case 936:
    case 949:
    case 950:
    case 1361:
    case 65001:
      return true;
    }
  return false;
}

/* OMYGOD!  CharNextExA is not UTF-8 aware!  It only works fine with
   double byte charsets.  So we have to do it ourselves for UTF-8.

   While being at it, we do more.  If a double-byte or multibyte
   sequence is truncated due to an early end, we need a way to recognize
   it.  The reason is that multiple buffered write statements might
   accidentally stop and start in the middle of a single character byte
   sequence.  If we have to interpret the byte sequences (as in
   fhandler_console), we would print wrong output in these cases.

   So we have four possible return values here:

   ret = end      if str >= end
   ret = NULL	  if we encounter an invalid byte sequence
   ret = str      if we encounter the start byte of a truncated byte sequence
   ret = str + n  if we encounter a vaild byte sequence
*/

const unsigned char *
next_char (UINT cp, const unsigned char *str, const unsigned char *end)
{
  const unsigned char *ret = NULL;

  if (str >= end)
    return end;

  switch (cp)
    {
    case 932:
    case 936:
    case 949:
    case 950:
    case 1361:
      if (*str <= 0x7f)
	ret = str + 1;
      else if (str == end - 1 && IsDBCSLeadByteEx (cp, *str))
	ret = str;
      else
	ret = (const unsigned char *) CharNextExA (cp, (const CHAR *) str, 0);
      break;
    case CP_UTF8:
      switch (str[0] >> 4)
	{
	case 0x0 ... 0x7:	/* One byte character. */
	  ret = str + 1;
	  break;
	case 0x8 ... 0xb:	/* Followup byte.  Invalid as first byte. */
	  ret = NULL;
	  break;
	case 0xc ... 0xd:	/* Two byte character. */
	  /* Check followup bytes for validity. */
	  if (str >= end - 1)
	    ret = str;
	  else if (str[1] <= 0xbf)
	    ret = str + 2;
	  else
	    ret = NULL;
	  break;
	case 0xe:		/* Three byte character. */
	  if (str >= end - 2)
	    ret = str;
	  else if ((str[1] & 0xc0) == 0x80 && (str[2] & 0xc0) == 0x80
		   && (str[0] != 0xe0 || str[1] >= 0xa0)
		   && (str[0] != 0xed || str[1] <= 0x9f))
	    ret = str + 3;
	  else
	    ret = NULL;
	  break;
	case 0xf:		/* Four byte character. */
	  if (str[0] >= 0xf8)
	    ret = NULL;
	  else if (str >= end - 3)
	    ret = str;
	  else if ((str[1] & 0xc0) == 0x80 && (str[2] & 0xc0) == 0x80
		   && (str[3] & 0xc0) == 0x80
		   && (str[0] == 0xf0 || str[1] >= 0x90)
		   && (str[0] == 0xf4 || str[1] <= 0x8f))
	    ret = str + 4;
	  else
	    ret = NULL;
	  break;
	}
      break;
    default:
      ret = str + 1;
      break;
    }
  return ret;
}

@


1.53
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@d133 1
a133 1
  len = ls * sizeof (WCHAR);
d135 1
a135 2
  us.Length = sys_mbstowcs (us.Buffer, us.MaximumLength / sizeof (WCHAR),
			    cs, ls) * sizeof (WCHAR);
d138 1
a138 1
  len = lt * sizeof (WCHAR);
d140 1
a140 2
  ut.Length = sys_mbstowcs (ut.Buffer, ut.MaximumLength / sizeof (WCHAR),
			    ct, lt)  * sizeof (WCHAR);
@


1.52
log
@* dtable.cc: Define various device-related string constants as wide character
constants.
(dtable::init_std_file_from_handle): Reorganize pipe handling to try to catch
special tty case.
(build_fh_name_worker): Declare for common use.
(build_fh_name): Define char version.
(build_fh_name): Define (currently unused) UNICODE_STRING version.
(decode_tty): Detect if pipe is actually a cygwin tty, returning the tty name
in the buffer.
(handle_to_fn): Reorganize to use wide characters.
* dtable.h (build_fh_name): Declare (currently unused) UNICODE_STRING version.
* fhandler_tty.cc (fhandler_pty_master::setup): Use
fhandler_pipe::create_selectable to create a pipe with a given name.
* pipe.cc (pipe_handler): Make returned handle inheritable.
(fhandler_pipe::create_selectable): Take an optional name.  Use a standard
cygwin introducer for the name.
* path.cc (path_conv::check): Make first argument const.
* path.h (path_conv::check): Ditto for declaration.
(path_conv::path_conv): Ditto for UNICODE_STRING version.
@
text
@d13 1
a13 2
#include "cygerrno.h"
#include <sys/errno.h>
a21 1
#include "cygthread.h"
d501 48
@


1.51
log
@	* dcrt0.cc (initial_env): Only use local buffer "buf" if DEBUGGING is
	enabled.  Replace calls to GetEnvironmentVariable by calls to
	GetEnvironmentVariableA for clarity.  Call GetEnvironmentVariableA
	with NULL buffer.
	(cygbench): Ditto, drop local buffer.
	* environ.cc (getearly): Call GetEnvironmentVariableA.
	(environ_init): Retrieve unicode environment and convert to current
	codepage locally.
	(getwinenveq): Ditto.
	* exceptions.cc (try_to_debug): Accommodate new sys_mbstowcs calling
	convention.
	* fhandler_clipboard.cc (set_clipboard): Call sys_mbstowcs to retrieve
	required buffer length.
	* fork.cc (frok::child): Call GetEnvironmentVariableA.
	* miscfuncs.cc: Accommodate changed arguments in calls to sys_mbstowcs.
	* sec_auth.cc: Ditto.
	* strfuncs.cc (sys_wcstombs_alloc): Fix formatting.
	(sys_mbstowcs): Change arguments to allow specifying a source string
	length.
	(sys_mbstowcs_alloc): Ditto.
	* uinfo.cc (cygheap_user::ontherange): Accommodate changed arguments in
	calls to sys_mbstowcs.
	* winsup.h (sys_mbstowcs): Adjust declaration.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.50
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d119 1
a119 1
  us.Length = sys_mbstowcs (us.Buffer, cs, us.MaximumLength) * sizeof (WCHAR);
d122 1
a122 1
  ut.Length = sys_mbstowcs (ut.Buffer, ct, ut.MaximumLength) * sizeof (WCHAR);
d137 2
a138 2
  us.Length = MultiByteToWideChar (get_cp (), 0, cs, ls, us.Buffer,
				   us.MaximumLength)  * sizeof (WCHAR);
d143 2
a144 2
  ut.Length = MultiByteToWideChar (get_cp (), 0, ct, lt, ut.Buffer,
				   ut.MaximumLength)  * sizeof (WCHAR);
d175 1
a175 1
  us.Length = sys_mbstowcs (us.Buffer, string, len) * sizeof (WCHAR)
d189 1
a189 1
  us.Length = sys_mbstowcs (us.Buffer, string, len) * sizeof (WCHAR)
@


1.49
log
@	* dcrt0.cc (dll_crt0_1): Fix typo in call to sys_wcstombs.
	* miscfuncs.cc (next_char): Initialize ret to keep gcc happy.
@
text
@d220 1
a220 1
   
d227 1
a227 1
   
d252 1
a252 1
        ret = str + 1;
@


1.48
log
@	* miscfuncs.cc (next_char): Fix typos in comment.
	* strfuncs.cc: Remove cygserver guards.
@
text
@d239 1
a239 1
  const unsigned char *ret;
@


1.47
log
@	* fhandler.h (fhandler_console::trunc_buf): Add to use as cache for
	truncated multibyte characters on input.
	(fhandler_console::write_replacement_char): Declare new method.
	* fhandler_console.cc (CONVERT_LIMIT): Raise to 64K.
	(fhandler_console::fhandler_console): Initialize trunc_buf.
	(ERR): Define as independent value again.
	(fhandler_console::write_replacement_char): New method to print
	replacement chars.
	(fhandler_console::write_normal): Add handling for truncated multibyte
	sequences.  Call next_char instead of pathetic CharNextExA function.
	Don't change src, rather just work with found later on.
	* miscfuncs.cc (is_cp_multibyte): Move here from strfuncs.cc.
	Don't call Windows function, restrict to well-known ANSI/OEM codepages
	and UTF-8.
	(next_char): Call CharNextExA only for doublebyte codepages.
	Implement for UTF-8 here.
	* strfuncs.cc (is_cp_multibyte): Move to miscfuncs.cc.
	* winsup.h (next_char): Declare.
	* include/limits.h (MB_LEN_MAX): Set to maximum value of MB_CUR_MAX
	as defined by newlib for now.
@
text
@d222 1
a222 1
   sequence is trucated due to an early end, we need a way to recognize
d226 1
a226 1
   fhandler_console, we would print wrong output in these cases.
@


1.46
log
@	* miscfuncs.cc (cygwin_wcsncasecmp): Never access more than n
	characters.
	(cygwin_strncasecmp): Ditto.  Fix for strings longer than n.
@
text
@d20 2
a21 1
#include <winbase.h>
d196 112
@


1.45
log
@	* dcrt0.cc: Include string.h.
	(initial_env): Use small_printf's %P specifier.
	* dll_init.cc (dll_list::alloc): Use PATH_MAX instead of CYG_MAX_PATH
	for path name buffer size.
	* dll_init.h (struct dll): Ditto.
	* environ.cc: Include string.h.
	(win_env::add_cache): Use temporary local buffer for path conversion.
	(posify): Ditto.
	* exceptions.cc (try_to_debug): Use CreateProcessW to allow long path
	names.
	* miscfuncs.cc: Drop unused implementations of strcasematch and
	strncasematch.
	(ch_case_eq): Drop.
	(strcasestr): Drop.
	(cygwin_wcscasecmp): New function.
	(cygwin_wcsncasecmp): New function.
	(cygwin_strcasecmp): New function.
	(cygwin_strncasecmp): New function.
	(cygwin_wcslwr): New function.
	(cygwin_wcsupr): New function.
	(cygwin_strlwr): New function.
	(cygwin_strupr): New function.
	* ntdll.h (RtlDowncaseUnicodeString): Declare.
	(RtlUpcaseUnicodeString): Declare.
	(RtlInt64ToHexUnicodeString): Fix typo in comment.
	* string.h: Disable not NLS aware implementations of strcasematch
	and strncasematch.
	(cygwin_strcasecmp): Declare.
	(strcasecmp): Define as cygwin_strcasecmp.
	(cygwin_strncasecmp): Declare.
	(strncasecmp): Define as cygwin_strncasecmp.
	(strcasematch):Define using cygwin_strcasecmp.
	(strncasematch):Define using cygwin_strncasecmp.
	(cygwin_strlwr): Declare.
	(strlwr): Define as cygwin_strlwr.
	(cygwin_strupr): Declare.
	(strupr): Define as cygwin_strupr.
	* wchar.h: New file.
	* wincap.cc (wincapc::init): Use "NT" as fix OS string.
	* winsup.h (strcasematch): Drop declaration.
	(strncasematch): Ditto.
	(strcasestr): Ditto.
@
text
@d20 2
d99 1
d101 6
a106 7
  n *= sizeof (WCHAR);
  RtlInitUnicodeString (&us, ws);
  if (us.Length > n)
    us.Length = n;
  RtlInitUnicodeString (&ut, wt);
  if (ut.Length > n)
    ut.Length = n;
d130 5
a134 3
  
  n *= sizeof (WCHAR);
  len = (strlen (cs) + 1) * sizeof (WCHAR);
d136 5
a140 4
  us.Length = sys_mbstowcs (us.Buffer, cs, us.MaximumLength) * sizeof (WCHAR);
  if (us.Length > n)
    us.Length = n;
  len = (strlen (ct) + 1) * sizeof (WCHAR);
d142 2
a143 3
  ut.Length = sys_mbstowcs (ut.Buffer, ct, ut.MaximumLength) * sizeof (WCHAR);
  if (ut.Length > n)
    ut.Length = n;
@


1.44
log
@* dcrt0.cc (codepage_type): Remove definition.
* strfuncs.cc: Move it here.  New file with bits of miscfuncs.cc.
* miscfuncs.cc: Remove wide character stuff.
@
text
@d17 1
d19 1
d22 1
d83 9
a91 1
#define ch_case_eq(ch1, ch2) (cyg_tolower(ch1) == cyg_tolower(ch2))
d93 14
a106 1
#if 0
a107 1
/* Return TRUE if two strings match up to length n */
d109 1
a109 1
strncasematch (const char *s1, const char *s2, size_t n)
d111 2
a112 2
  if (s1 == s2)
    return 1;
d114 7
a120 8
  n++;
  while (--n && *s1)
    {
      if (!ch_case_eq (*s1, *s2))
	return 0;
      s1++; s2++;
    }
  return !n || *s2 == '\0';
a122 1
/* Return TRUE if two strings match */
d124 31
a154 1
strcasematch (const char *s1, const char *s2)
d156 1
a156 2
  if (s1 == s2)
    return 1;
d158 3
a160 7
  while (*s1)
    {
      if (!ch_case_eq (*s1, *s2))
	return 0;
      s1++; s2++;
    }
  return *s2 == '\0';
a161 1
#endif
d164 1
a164 1
strcasestr (const char *searchee, const char *lookfor)
d166 2
a167 6
  if (*searchee == 0)
    {
      if (*lookfor)
	return NULL;
      return (char *) searchee;
    }
d169 7
a175 7
  while (*searchee)
    {
      int i = 0;
      while (1)
	{
	  if (lookfor[i] == 0)
	    return (char *) searchee;
d177 5
a181 6
	  if (!ch_case_eq (lookfor[i], searchee[i]))
	    break;
	  lookfor++;
	}
      searchee++;
    }
d183 6
a188 1
  return NULL;
@


1.43
log
@	* exceptions.cc (dummy_ctrl_c_handler): Remove.
	(init_console_handler): Drop has_null_console_handler_routine checks.
	* fhandler_raw.cc (fhandler_dev_raw::open): Drop has_raw_devices check.
	* fhandler_serial.cc (fhandler_serial::open): Drop
	.supports_reading_modem_output_lines check.
	* miscfuncs.cc (low_priority_sleep): Drop has_switch_to_thread check.
	* shared.cc (open_shared): Drop needs_memory_protection checks.
	* spawn.cc (spawn_guts): Drop start_proc_suspended check.
	* uname.cc (uname): Drop has_valid_processorlevel check.
	* wincap.cc: Remove has_raw_devices, has_valid_processorlevel,
	supports_reading_modem_output_lines, needs_memory_protection,
	has_switch_to_thread, start_proc_suspended and
	has_null_console_handler_routine throughout.
	* wincap.h: Ditto.
@
text
@a17 2
#include <winbase.h>
#include <winnls.h>
d164 1
a204 29
UINT
get_cp ()
{
  return current_codepage == ansi_cp ? GetACP() : GetOEMCP();
}

/* tlen is always treated as the maximum buffer size, including the '\0'
   character.  sys_wcstombs will always return a 0-terminated result, no
   matter what. */
int __stdcall
sys_wcstombs (char *tgt, int tlen, const WCHAR *src, int slen)
{
  int ret;

  ret = WideCharToMultiByte (get_cp (), 0, src, slen, tgt, tlen, NULL, NULL);
  if (ret)
    tgt[ret < tlen ? ret : tlen - 1] = '\0';
  return ret;
}

int __stdcall
sys_mbstowcs (WCHAR *tgt, const char *src, int len)
{
  int res = MultiByteToWideChar (get_cp (), 0, src, -1, tgt, len);
  if (!res)
    debug_printf ("MultiByteToWideChar %E");
  return res;
}

@


1.42
log
@	* fhandler_proc.cc: Drop superfluous definition of _WIN32_WINNT.
	* miscfuncs.cc: Ditto.
	* sched.cc: Ditto.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d249 1
a249 1
  if (!secs && wincap.has_switch_to_thread ())
@


1.41
log
@white space
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
a11 1
#define _WIN32_WINNT 0x400
@


1.40
log
@	* dtable.cc (handle_to_fn): Accomodate new argument order in call to
	sys_wcstombs.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Call sys_wcstombs
	instead of just wcstombs to accomodate OEM codepages.
	* miscfuncs.cc (sys_wcstombs): Split len argument in source and target
	length.  Always 0-terminate result in target string.
	* security.cc (lsa2wchar): Remove unused function.
	(lsa2str): Ditto.
	(get_lsa_srv_inf): Ditto.
	(get_logon_server): Accomodate new argument order in call to
	sys_wcstombs.
	(get_user_groups): Ditto.
	(get_user_local_groups): Ditto.
	(get_priv_list): Call sys_wcstombs directly instead of lsa2str.
	* uinfo.cc (cygheap_user::ontherange): Accomodate new argument order
	in call to sys_wcstombs.
	* winsup.h (sys_wcstombs): Change prototype to match new argument order.
@
text
@d220 1
a220 1
  
@


1.39
log
@	* winsup.h (flush_file_buffers): Define as inline function.
	* miscfuncs.cc (flush_file_buffers): Remove.
@
text
@d213 3
d217 1
a217 1
sys_wcstombs (char *tgt, const WCHAR *src, int len)
d219 6
a224 1
  return WideCharToMultiByte (get_cp (), 0, src, -1, tgt, len, NULL, NULL);
@


1.38
log
@	* winsup.h (flush_file_buffers): Declare new function.
	(FLushFileBuffers): New define.
	* miscfuncs.cc (flush_file_buffers): Define new function.
@
text
@a363 11

#undef FlushFileBuffers
bool
flush_file_buffers (HANDLE h)
{
  DWORD ftype = GetFileType (h);
  /* Per MSDN, FlushFileBuffers on named pipes might block.  This is the last
     we want it to do, especially when printing debug output  as when calling
     system_printf. */
  return (ftype != FILE_TYPE_PIPE) ? FlushFileBuffers (h) : true;
}
@


1.37
log
@* winsup.h (create_pipe): Declare new function.
(CreatePipe): New define.
* miscfuncs.cc (create_pipe): Define new function.
@
text
@d364 11
@


1.36
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d350 14
@


1.35
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d196 1
a196 1
	(void) dummytest (p);
@


1.34
log
@copyright
@
text
@d22 1
a149 70
check_null_str (const char *name)
{
  if (name && !IsBadStringPtr (name, CYG_MAX_PATH))
    return 0;

  return EFAULT;
}

int __stdcall
check_null_empty_str (const char *name)
{
  if (name && !IsBadStringPtr (name, CYG_MAX_PATH))
    return !*name ? ENOENT : 0;

  return EFAULT;
}

int __stdcall
check_null_empty_str_errno (const char *name)
{
  int __err;
  if ((__err = check_null_empty_str (name)))
    set_errno (__err);
  return __err;
}

int __stdcall
check_null_str_errno (const char *name)
{
  int __err;
  if ((__err = check_null_str (name)))
    set_errno (__err);
  return __err;
}

int __stdcall
__check_null_invalid_struct (void *s, unsigned sz)
{
  if (s && !IsBadWritePtr (s, sz))
    return 0;

  return EFAULT;
}

int __stdcall
__check_null_invalid_struct_errno (void *s, unsigned sz)
{
  int err;
  if ((err = __check_null_invalid_struct (s, sz)))
    set_errno (err);
  return err;
}

int __stdcall
__check_invalid_read_ptr (const void *s, unsigned sz)
{
  if (s && !IsBadReadPtr (s, sz))
    return 0;
  return EFAULT;
}

int __stdcall
__check_invalid_read_ptr_errno (const void *s, unsigned sz)
{
  if (s && !IsBadReadPtr (s, sz))
    return 0;
  return set_errno (EFAULT);
}

int __stdcall
d162 2
a163 2
ssize_t
check_iovec_for_read (const struct iovec *iov, int iovcnt)
d165 1
a165 30
  if (iovcnt <= 0 || iovcnt > IOV_MAX)
    {
      set_errno (EINVAL);
      return -1;
    }

  if (__check_invalid_read_ptr_errno (iov, iovcnt * sizeof (*iov)))
    return -1;

  size_t tot = 0;

  while (iovcnt != 0)
    {
      if (iov->iov_len > SSIZE_MAX || (tot += iov->iov_len) > SSIZE_MAX)
	{
	  set_errno (EINVAL);
	  return -1;
	}

      if (iov->iov_len
	  && __check_null_invalid_struct_errno (iov->iov_base, iov->iov_len))
	return -1;

      iov += 1;
      iovcnt -= 1;
    }

  assert (tot <= SSIZE_MAX);

  return (ssize_t) tot;
a166 1

d168 1
a168 1
check_iovec_for_write (const struct iovec *iov, int iovcnt)
d176 2
a177 1
  if (__check_invalid_read_ptr_errno (iov, iovcnt * sizeof (*iov)))
d190 7
a196 3
      if (iov->iov_len
	  && __check_invalid_read_ptr_errno (iov->iov_base, iov->iov_len))
	return -1;
d198 2
a199 2
      iov += 1;
      iovcnt -= 1;
@


1.33
log
@white space
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.32
log
@	* cygwin.din: Export getpriority and setpriority.
	* fork.cc (fork_parent): Copy parent's nice value into child.
	* spawn.cc (spawn_guts): Ditto.
	* miscfuncs.cc (winprio_to_nice): New function.
	(nice_to_winprio): Ditto.
	* pinfo.cc (pinfo_init): If parent is not a Cygwin process, set
	default nice value according to current Win32 priority class.
	* pinfo.h (class _pinfo): Add nice member.
	* syscalls.cc (setpriority): New function, only implementing
	PRIO_PROCESS for now.
	(getpriority): Ditto.
	(nice): Just call setpriority.
	* wincap.h (wincaps::has_extended_priority_class): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h: Add prototypes for winprio_to_nice and nice_to_winprio.
	* include/limits.h (NZERO): New define.
	* include/cygwin/types.h (id_t): New datatype.
	* include/cygwin/version.h: Bump API minor version.
	* include/sys/resource.h: Add PRIO_XXX defines and prototypes for
	getpriority and setpriority.
@
text
@d386 1
a386 1
DWORD 
@


1.31
log
@2004-06-17  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.cc (fhandler_base::open_9x): Do not check for null name.
        Move debug_printf to common code line.
        (fhandler_base::open): Ditto. Initialize upath. Remove second argument
        of pc.get_nt_native_path.
        * path.h (path_conv::get_nt_native_path): Remove second argument.
        * path.cc (path_conv::get_nt_native_path): Ditto. Call str2uni_cat.
        * security.h (str2buf2uni_cat): Delete declaration.
        (str2uni_cat): New declaration.
        * security.cc (str2buf2uni): Get length from sys_mbstowcs call.
        (str2buf2uni_cat): Delete function.
        (str2uni_cat): New function.
        * miscfuncs.cc (sys_mbstowcs): Add debug_printf.
@
text
@d359 84
@


1.30
log
@	* miscfuncs.cc (check_invalid_virtual_addr): Assure the last page
	in the range is always tested.  Add appropriate const.
	* mmap.cc (mmap_record::aloc_fh): Remove unused static path_conf object.
@
text
@d315 4
a318 1
  return MultiByteToWideChar (get_cp (), 0, src, -1, tgt, len);
@


1.29
log
@	* miscfuncs.cc (check_invalid_virtual_addr): New function.
	* winsup.h (check_invalid_virtual_addr): Declare.
	* mmap.cc (munmap): Call check_invalid_virtual_addr instead of
	IsBadReadPtr.
@
text
@d221 1
a221 1
  void *end;
d223 2
a224 1
  for (end = (char *) s + sz; s < end; s = (char *) s + mbuf.RegionSize)
@


1.28
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d217 12
@


1.27
log
@* miscfuncs.cc (low_priority_sleep): Correct thinko which caused SetPriority to
be called unnecessarily.
* thread.cc (pthread::init_main_thread): Call new create_cancel_event function.
(pthread::precreate): Ditto.
(pthread::postcreate): Remove cancel_event creation.
(pthread::create_cancel_event): Define new function.
* thread.h (pthread::create_cancel_event): Declare new function.
@
text
@d321 1
a321 1
      for (int i = 0; i < 10; i++)
@


1.26
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d337 1
a337 1
      if (!staylow || curr_prio == new_prio)
@


1.25
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d305 1
a305 1
extern "C" int __stdcall
@


1.24
log
@* miscfuncs.cc (low_priority_sleep): Make a "C" function.
* winsup.h (low_priority_sleep): Revert previous change to declaration.
@
text
@d150 1
a150 1
  if (name && !IsBadStringPtr (name, MAX_PATH))
d159 1
a159 1
  if (name && !IsBadStringPtr (name, MAX_PATH))
@


1.23
log
@	* miscfunc.cc (__check_invalid_read_ptr): New function.
	* winsup.h: Declare.
@
text
@d305 1
a305 1
int __stdcall
@


1.22
log
@* syscalls.cc (mount): Don't check win32_path when doing cygdrive mount.
@
text
@d202 8
@


1.21
log
@* miscfuncs.cc (low_priority_sleep): Sleep at same priority as main thread.
* sigproc.cc (wait_sig): Keep looping if there are more signals to consider and
we are flushing signals.
(sig_send): Put nonsync signals in the correct bucket.
@
text
@d11 1
d20 1
d311 21
a331 5
  int main_prio = GetThreadPriority (hMainThread);
  if (curr_prio != main_prio)
    /* Force any threads in normal priority to be scheduled */
    SetThreadPriority (thisthread, main_prio);
  Sleep (secs);
a332 2
  if (!staylow || curr_prio == main_prio)
    SetThreadPriority (thisthread, curr_prio);
@


1.20
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d309 2
a310 1
  if (curr_prio != THREAD_PRIORITY_NORMAL)
d312 1
a312 1
    SetThreadPriority (thisthread, THREAD_PRIORITY_NORMAL);
d315 1
a315 1
  if (!staylow || curr_prio == THREAD_PRIORITY_NORMAL)
@


1.20.2.1
log
@merge from trunk
@
text
@d309 1
a309 2
  int main_prio = GetThreadPriority (hMainThread);
  if (curr_prio != main_prio)
d311 1
a311 1
    SetThreadPriority (thisthread, main_prio);
d314 1
a314 1
  if (!staylow || curr_prio == main_prio)
@


1.20.2.2
log
@merge from trunk
@
text
@a10 1
#define _WIN32_WINNT 0x400
a18 1
#include "cygthread.h"
d309 5
a313 21
  if (!secs && wincap.has_switch_to_thread ())
    {
      for (int i = 0; i < 10; i++)
	SwitchToThread ();
    }
  else
    {
      int new_prio;
      if (GetCurrentThreadId () == cygthread::main_thread_id)
	new_prio = THREAD_PRIORITY_LOWEST;
      else
	new_prio = GetThreadPriority (hMainThread);

      if (curr_prio != new_prio)
	/* Force any threads in normal priority to be scheduled */
	SetThreadPriority (thisthread, new_prio);
      Sleep (secs);

      if (!staylow || curr_prio == new_prio)
	SetThreadPriority (thisthread, curr_prio);
    }
d315 2
@


1.19
log
@* cygthread.cc (cygthread::cygthread): Be more noisy about odd condition.
* miscfuncs.cc (low_priority_sleep): Sleep in regular priority if that's what
we're currently running at.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.18
log
@* exceptions.cc (sigthread::get_winapi_lock): Just do standard 'give up
timeslice' wait.
(setup_handler): Revamp YA to attempt to deliver signal multiple times on
failure rather than punting to wait_sig.
* miscfuncs.cc (low_priority_sleep): Accept INFINITE sleep to mean "don't reset
the priority after setting it to idle".  Return previous priority.
* winsup.h (SLEEP_0_STAY_LOW): Define.
(low_priority_sleep): Return an int.
* sigproc.h: Define WAIT_SIG_PRIORITY here.
* sigproc.cc: Remove WAIT_SIG_PRIORITY definition.
@
text
@d309 4
a312 3
  /* Force any threads in normal priority to be scheduled */
  SetThreadPriority (thisthread, THREAD_PRIORITY_NORMAL);
  Sleep (0);
d314 1
a314 3
  SetThreadPriority (thisthread, THREAD_PRIORITY_IDLE);
  Sleep (secs);
  if (!staylow)
@


1.17
log
@* exceptions.cc (setup_handler): Add debugging output.  Set thread priority to
idle if pending signals to allow other threads to get into interruptible state.
* miscfuncs.cc (sys_mbstowcs): Save current thread in variable to avoid an OS
call.
* wait.cc (wait_sig): Reset thread priority each time through loop since the
priority may have been set down to deal with pending signals.
@
text
@d295 1
a295 1
void __stdcall
d300 13
d315 3
a317 1
  SetThreadPriority (thisthread, curr_prio);
@


1.16
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Red Hat, Inc.
d298 3
a300 2
  DWORD prio = GetThreadPriority (GetCurrentThread ());
  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_IDLE);
d302 1
a302 1
  SetThreadPriority (GetCurrentThread (), prio);
@


1.15
log
@* external.cc (cygwin_internal): Implement CW_CMDLINE.
* pinfo.h (SIGCOMMUNE): New signal type.
(commune_result): New structure for commune functions.
(picom): New enum for commune functions.
(_pinfo::hello_pid): New.  Pid who's communicating with me.
(_pinfo::tothem): New.  Handle of communicating pipe.
(_pinfo::fromthem): Ditto.
(_pinfo::commune_recv): Declare.
(_pinfo::commune_send): Declare.
(_pinfo::alive): Declare.
(_pinfo::cmdline): Declare.
(_pinfo::lock): Declare.
* pinfo.cc (set_myself): Initialize new _pinfo lock.
(_pinfo::alive): Define.  Determines if process still exists.
(_pinfo::commune_recv): Define.  Receive info from another cooperating process.
(_pinfo::commune_send): Define.  Send info to another cooperating process.
(_pinfo::cmdline): Define.  Determine command line of a given process.
* include/sys/cygwin.h (CW_CMDLINE): Define.
*sigproc.cc (talktome): Communicate with any processes who want to talk to me.
(wait_sig): Honor __SIGCOMMUNE.
* fhandler.cc (fhandler_virtual::fixup_after_exec): Declare.
* fhandler_proc.cc: Use malloc/free/realloc throughout rather than cmalloc
since buffers don't need to be propagated to subprocesses.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
(fhandler_virtual::fixup_after_exec): Define.
* fhandler_process.cc: Ditto for malloc/free/realloc.
(process_listin): Add "cmdline".
(fhandler_process::fill_filebuf): Implement PROCESS_CMDLINE.
* miscfuncs.cc (isalpha_array): New array populated with xor values for alpha
characters to switch from one case to another.
* string.h (cygwin_strcasematch): New asm implementation of case match.
* string.h (cygwin_nstrcasematch): New asm implementation of counted case
match.
@
text
@d294 9
@


1.15.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d60 19
d81 2
d115 1
@


1.14
log
@* miscfuncs.cc (check_iovec_for_read): Don't check buffer when zero length
iov_len.
(check_iovec_for_write): Ditto.
* fhandler.h (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* fhandler.cc (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* syscalls.cc (_read): Delegate to readv(2).
(_write): Ditto, mutatis mutandi.
(readv): Rewrite, based on the old _read code, to use the new
fhandler_base::readv method.  Improve access mode handling and ensure all calls
reach the final strace statement.
(writev): Ditto, mutatis mutandi.
* include/sys/uio.h (struct iovec): Change field types to match SUSv3.
* winsup.h (check_iovec_for_read): New function.
(check_iovec_for_write): Ditto.
* miscfuncs.cc (check_iovec_for_read): Ditto.
(check_iovec_for_write): Ditto.
@
text
@d60 19
d81 2
d115 1
@


1.13
log
@	* winsup.h (__check_null_invalid_struct): Make ptr argument non-const.
	(__check_null_invalid_struct_errno): Ditto.
	* miscfuncs.cc (__check_null_invalid_struct): Ditto.
	(__check_null_invalid_struct_errno): Ditto.
	(__check_invalid_read_ptr_errno): Remove superfluous cast.
	* net.cc (get): Set appropriate errno if fd is not a socket.
	(cygwin_sendto): Fix parameter checking.
	(cygwin_recvfrom): Ditto.
	(cygwin_setsockopt): Ditto.
	(cygwin_getsockopt): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_gethostbyaddr): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_bind): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_listen): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_send): Ditto.
	(cygwin_shutdown): Ditto.  Move sigframe to fhandler_socket.
	(cygwin_recvmsg): Fix parameter checking.  Add tracing.
	(cygwin_sendmsg): Ditto.
	* fhandler_socket.cc (fhandler_socket::shutdown): Add sigframe.
	* resource.cc (setrlimit): Fix parameter checking.
@
text
@d14 3
d183 70
@


1.12
log
@* autoload (noload): Avoid clobbering bx register.
* environ.cc (codepage_init): Use case insensitive match.
* fhandler_console.cc (cp_get_internal): Delete.
(con_to_str): Use get_cp to derive code page.
(str_to_con): Ditto.
* miscfuncs.cc (get_cp): New function.
(sys_wcstombs): New function.  Converted from macro.
(sys_mbstowcs): Ditto.
* winsup.h: Reflect above changes.
@
text
@d157 1
a157 1
__check_null_invalid_struct (const void *s, unsigned sz)
d159 1
a159 1
  if (s && !IsBadWritePtr ((void *) s, sz))
d166 1
a166 1
__check_null_invalid_struct_errno (const void *s, unsigned sz)
d177 1
a177 1
  if (s && !IsBadReadPtr ((void *) s, sz))
@


1.11
log
@* debug.cc (makethread): Eliminate unneeded function call.
* miscfuncs.cc (tls_ix): Predefine.
* perthread.h (set_reent): Eliminate.
(get_reent): Ditto.
* winbase.h (my_tlsalloc): Use global stack base pointer.  Set newly allocated
location to NULL.
(my_tlssetvalue): Use global stack base pointer.
(my_tlsgetvalue): Ditto.
@
text
@d14 2
d180 18
@


1.10
log
@* cygwin.din (ualarm): New export.
* dcrt0.cc (_dll_crt0): Add experimental tls storage declaration.
(dll_crt0): Ditto.
* debug.cc (thread_stub): Ditto.
* thread.cc: Minor cleanup.
(__pthread_create): Add experimental tls storage declaration.
* miscfuncs.cc: Define tls index.
* winsup.h: Declare experimental tls storage.
* window.cc (alarm): Use old timer return from setitimer.
(ualarm): New function.
@
text
@d15 1
a15 1
long tls_ix;
@


1.9
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d15 1
a15 1
/********************** String Helper Functions ************************/
@


1.8
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d119 9
d141 9
@


1.7
log
@	* miscfuncs.cc (__check_invalid_read_ptr_errno): Return error, if any.
@
text
@d121 2
a122 2
  if (!name || IsBadStringPtr (name, MAX_PATH))
    return EFAULT;
d124 1
a124 4
  if (!*name)
    return ENOENT;

  return 0;
d139 2
a140 2
  if (!s || IsBadWritePtr ((void *) s, sz))
    return EFAULT;
d142 1
a142 1
  return 0;
d148 4
a151 4
  int __err;
  if ((__err = __check_null_invalid_struct (s, sz)))
    set_errno (__err);
  return __err;
d157 3
a159 4
  if (!s || IsBadReadPtr ((void *) s, sz))
    return set_errno (EFAULT);

  return 0;
@


1.6
log
@* miscfuncs.cc (+__check_invalid_read_ptr_errno): New function.
* syscalls.c (_write): Validate that write buffer is accessible for reading,
not writing.
* winsup.h: Declare new function, increase regparmization of check_* functions.
@
text
@d161 1
a161 1
    set_errno (EFAULT);
@


1.5
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d156 9
@


1.5.4.1
log
@Merged changes from HEAD
@
text
@d15 1
a15 1
long tls_ix = -1;
d119 1
a119 1
check_null_str (const char *name)
d121 2
a122 5
  if (name && !IsBadStringPtr (name, MAX_PATH))
    return 0;

  return EFAULT;
}
d124 2
a125 5
int __stdcall
check_null_empty_str (const char *name)
{
  if (name && !IsBadStringPtr (name, MAX_PATH))
    return !*name ? ENOENT : 0;
d127 1
a127 1
  return EFAULT;
a139 9
check_null_str_errno (const char *name)
{
  int __err;
  if ((__err = check_null_str (name)))
    set_errno (__err);
  return __err;
}

int __stdcall
d142 2
a143 2
  if (s && !IsBadWritePtr ((void *) s, sz))
    return 0;
d145 1
a145 1
  return EFAULT;
d151 4
a154 12
  int err;
  if ((err = __check_null_invalid_struct (s, sz)))
    set_errno (err);
  return err;
}

int __stdcall
__check_invalid_read_ptr_errno (const void *s, unsigned sz)
{
  if (s && !IsBadReadPtr ((void *) s, sz))
    return 0;
  return set_errno (EFAULT);
@


1.5.4.2
log
@Merged changes from HEAD
@
text
@a13 2
#include <winbase.h>
#include <winnls.h>
a177 18
}

UINT
get_cp ()
{
  return current_codepage == ansi_cp ? GetACP() : GetOEMCP();
}

int __stdcall
sys_wcstombs (char *tgt, const WCHAR *src, int len)
{
  return WideCharToMultiByte (get_cp (), 0, src, -1, tgt, len, NULL, NULL);
}

int __stdcall
sys_mbstowcs (WCHAR *tgt, const char *src, int len)
{
  return MultiByteToWideChar (get_cp (), 0, src, -1, tgt, len);
@


1.5.4.3
log
@Merged changes from HEAD
@
text
@d157 1
a157 1
__check_null_invalid_struct (void *s, unsigned sz)
d159 1
a159 1
  if (s && !IsBadWritePtr (s, sz))
d166 1
a166 1
__check_null_invalid_struct_errno (void *s, unsigned sz)
d177 1
a177 1
  if (s && !IsBadReadPtr (s, sz))
@


1.5.4.4
log
@Merged changes from HEAD
@
text
@a13 3
#include <sys/uio.h>
#include <assert.h>
#include <limits.h>
a179 70
}

ssize_t
check_iovec_for_read (const struct iovec *iov, int iovcnt)
{
  if (iovcnt <= 0 || iovcnt > IOV_MAX)
    {
      set_errno (EINVAL);
      return -1;
    }

  if (__check_invalid_read_ptr_errno (iov, iovcnt * sizeof (*iov)))
    return -1;

  size_t tot = 0;

  while (iovcnt != 0)
    {
      if (iov->iov_len > SSIZE_MAX || (tot += iov->iov_len) > SSIZE_MAX)
	{
	  set_errno (EINVAL);
	  return -1;
	}

      if (iov->iov_len
	  && __check_null_invalid_struct_errno (iov->iov_base, iov->iov_len))
	return -1;

      iov += 1;
      iovcnt -= 1;
    }

  assert (tot <= SSIZE_MAX);

  return (ssize_t) tot;
}

ssize_t
check_iovec_for_write (const struct iovec *iov, int iovcnt)
{
  if (iovcnt <= 0 || iovcnt > IOV_MAX)
    {
      set_errno (EINVAL);
      return -1;
    }

  if (__check_invalid_read_ptr_errno (iov, iovcnt * sizeof (*iov)))
    return -1;

  size_t tot = 0;

  while (iovcnt != 0)
    {
      if (iov->iov_len > SSIZE_MAX || (tot += iov->iov_len) > SSIZE_MAX)
	{
	  set_errno (EINVAL);
	  return -1;
	}

      if (iov->iov_len
	  && __check_invalid_read_ptr_errno (iov->iov_base, iov->iov_len))
	return -1;

      iov += 1;
      iovcnt -= 1;
    }

  assert (tot <= SSIZE_MAX);

  return (ssize_t) tot;
@


1.4
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d132 5
a136 5
{ 
  int __err; 
  if ((__err = check_null_empty_str (name))) 
    set_errno (__err); 
  return __err; 
d150 5
a154 5
{ 
  int __err; 
  if ((__err = __check_null_invalid_struct (s, sz))) 
    set_errno (__err); 
  return __err; 
@


1.3
log
@Change check_null_empty_path* to check_null_empty_str* throughout.
* path.cc (path_conv::check): Add signal protection here since retrieving info
about remote shares can take some time.
* path.h (check_null_empty_str_errno): Convert to a function prototype.
* path.cc (check_null_empty_str): Move to miscfuncs.cc.
* miscfuncs.cc (check_null_empty_str_errno): New function.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(check_null_empty_str): Change from VirtualQuery to IsBadWritePtr.
* thread.cc (check_valid_pointer): Ditto.
* resource.cc (getrlimit): Use check_null_invalid_struct macro for checking
validity of pointer.
(setrlimit): Ditto.
@
text
@d17 1
a17 1
char case_folded_lower[] = {
d36 1
a36 1
char case_folded_upper[] = {
@


1.2
log
@forced commit
@
text
@d12 2
d116 39
@


1.1
log
@* Makefile.in: add miscfuncs.cc
* miscfuncs.cc: new, miscellaneous functions
* winsup.h: define table-driven tolower/toupper
* environ.cc: use them
* fhandler_console.cc: ditto
* fhandler_termios: ditto
* path.cc: ditto
(strncasematch, strcasematch, strcasestr): move to miscfuncs.cc
@
text
@@

