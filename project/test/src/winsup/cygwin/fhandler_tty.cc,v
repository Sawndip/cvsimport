head	1.292;
access;
symbols
	cygwin-1_7_35-release:1.290
	cygwin-1_7_34-release:1.289
	cygwin-1_7_33-release:1.287.2.1
	cygwin-1_7_32-release:1.287
	cygwin-1_7_31-release:1.287
	cygwin-1_7_30-release:1.287
	cygwin-1_7_29-release:1.287
	cygwin-1_7_29-release-branchpoint:1.287.0.2
	cygwin-pre-user-db:1.287
	cygwin-1_7_28-release:1.287
	cygwin-1_7_27-release:1.286
	cygwin-1_7_26-release:1.286
	cygwin-1_7_25-release:1.284
	cygwin-1_7_24-release:1.284
	cygwin-1_7_23-release:1.284
	cygwin-1_7_22-release:1.282
	cygwin-1_7_21-release:1.282
	cygwin-1_7_20-release:1.280
	cygwin-1_7_19-release:1.280
	cygwin-64bit-postmerge:1.278
	cygwin-64bit-premerge-branch:1.277.0.2
	cygwin-64bit-premerge:1.277
	cygwin-1_7_18-release:1.277
	post-ptmalloc3:1.268.2.9
	pre-ptmalloc3:1.268.2.9
	cygwin-1_7_17-release:1.273
	cygwin-64bit-branch:1.268.0.2
	cygwin-1_7_16-release:1.266
	cygwin-1_7_15-release:1.260
	cygwin-1_7_14_2-release:1.259
	cygwin-1_7_14-release:1.259
	cygwin-1_7_12-release:1.258
	cygwin-1_7_11-release:1.256
	cygwin-1_7_10-release:1.254
	signal-rewrite:1.239.0.2
	pre-notty:1.229
	cygwin-1_7_9-release:1.216
	cv-post-1_7_9:1.216.0.2
	cygwin-1_7_8-release:1.216
	cygwin-1_7_7-release:1.203
	cygwin-1_7_5-release:1.197
	cygwin-1_7_4-release:1.196
	cygwin-1_7_3-release:1.196
	cygwin-1_7_2-release:1.193
	fifo_doover3:1.191.0.2
	cygwin-1_7_1-release:1.190
	prefifo:1.189
	cv-branch-2:1.187.0.2
	pre-ripout-set_console_state_for_spawn:1.182
	EOL_registry_mounts:1.181
	preoverlapped:1.175
	drop_9x_support_start:1.174
	cr-0x5f1:1.174.0.2
	cv-branch:1.173.0.2
	pre-ptymaster-archetype:1.166
	cr-0x3b58:1.162.0.4
	cr-0x5ef:1.162.0.2
	after-mmap-privanon-noreserve:1.153
	after-mmap-revamp:1.153
	before-mmap-revamp:1.153
	cgf-more-exit-sync:1.148
	post_wait_sig_exit:1.146
	pre_wait_sig_exit:1.145
	reparent-point:1.136
	noreparent:1.136.0.2
	cr-0x5e6:1.133.0.2
	cr-0x9e:1.125.0.6
	cr-0x9d:1.125.0.4
	cgf-deleteme:1.125.0.2
	pre-sigrewrite:1.114
	corinna-01:1.114
	cr-0x9c:1.105.2.1.0.2
	cr-0x9b:1.105.0.2
	cr-0x99:1.102
	Z-emcb-cygwin_daemon:1.102.0.2
	w32api-2_2:1.90
	mingw-runtime-2_4:1.90
	pre-cgf-merge:1.106
	cgf-dev-branch:1.89.0.2
	predaemon:1.57
	cygwin_daemon_merge_HEAD:1.57
	pregp02r1:1.56.0.30
	cygnus_cvs_20020108_pre:1.56
	Z-cygwin_daemon_merge-new_HEAD:1.73
	Z-cygwin_daemon_merge_HEAD:1.73
	cygwin_daemon:1.49.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.292
date	2015.03.05.13.58.02;	author corinna;	state Exp;
branches;
next	1.291;

1.291
date	2015.03.05.12.57.34;	author corinna;	state Exp;
branches;
next	1.290;

1.290
date	2015.02.25.16.46.57;	author corinna;	state Exp;
branches;
next	1.289;

1.289
date	2014.11.13.18.37.15;	author corinna;	state Exp;
branches;
next	1.288;

1.288
date	2014.08.27.11.42.17;	author corinna;	state Exp;
branches;
next	1.287;

1.287
date	2013.12.17.19.05.26;	author cgf;	state Exp;
branches
	1.287.2.1;
next	1.286;

1.286
date	2013.10.24.15.26.21;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2013.10.22.20.41.09;	author cgf;	state Exp;
branches;
next	1.284;

1.284
date	2013.07.31.15.19.18;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2013.07.26.17.27.59;	author cgf;	state Exp;
branches;
next	1.282;

1.282
date	2013.06.08.14.42.44;	author cgf;	state Exp;
branches;
next	1.281;

1.281
date	2013.06.08.14.38.19;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2013.05.08.00.10.08;	author cgf;	state Exp;
branches;
next	1.279;

1.279
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.278;

1.278
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.277;

1.277
date	2013.01.31.05.26.46;	author cgf;	state Exp;
branches;
next	1.276;

1.276
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2012.11.26.13.28.53;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2012.11.08.17.27.00;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2012.10.15.17.12.17;	author cgf;	state Exp;
branches;
next	1.272;

1.272
date	2012.10.15.14.36.48;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2012.10.12.01.19.04;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2012.08.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.269;

1.269
date	2012.08.15.19.07.41;	author cgf;	state Exp;
branches;
next	1.268;

1.268
date	2012.07.30.03.44.40;	author cgf;	state Exp;
branches
	1.268.2.1;
next	1.267;

1.267
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2012.07.06.13.49.52;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2012.07.04.06.01.16;	author cgf;	state Exp;
branches;
next	1.264;

1.264
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.262;

1.262
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2012.05.16.01.56.41;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2012.05.04.03.00.43;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2012.04.05.02.54.51;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.257;

1.257
date	2012.03.03.21.35.30;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2012.02.14.11.27.43;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2012.02.07.16.54.14;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2011.12.13.04.11.46;	author cgf;	state Exp;
branches;
next	1.252;

1.252
date	2011.12.09.16.02.56;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2011.12.04.18.32.00;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2011.11.23.18.56.57;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2011.11.14.01.29.48;	author cgf;	state Exp;
branches;
next	1.247;

1.247
date	2011.11.08.06.26.15;	author cgf;	state Exp;
branches;
next	1.246;

1.246
date	2011.11.07.20.05.48;	author cgf;	state Exp;
branches;
next	1.245;

1.245
date	2011.10.30.04.50.35;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2011.10.23.19.01.47;	author cgf;	state Exp;
branches;
next	1.243;

1.243
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.242;

1.242
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2011.10.11.23.20.38;	author cgf;	state Exp;
branches;
next	1.240;

1.240
date	2011.10.10.04.05.29;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2011.07.25.15.19.35;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2011.07.22.18.50.42;	author corinna;	state Exp;
branches;
next	1.237;

1.237
date	2011.07.21.20.21.46;	author cgf;	state Exp;
branches;
next	1.236;

1.236
date	2011.07.11.00.03.55;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2011.07.04.05.08.28;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2011.06.22.07.58.01;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2011.06.22.07.37.49;	author corinna;	state Exp;
branches;
next	1.232;

1.232
date	2011.06.14.21.48.43;	author cgf;	state Exp;
branches;
next	1.231;

1.231
date	2011.06.13.23.49.00;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2011.06.04.00.12.29;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.226;

1.226
date	2011.05.06.19.13.22;	author cgf;	state Exp;
branches;
next	1.225;

1.225
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2011.05.05.19.43.03;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2011.05.04.13.06.10;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2011.05.03.07.58.13;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2011.05.02.18.41.10;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2011.04.29.09.48.24;	author corinna;	state Exp;
branches;
next	1.219;

1.219
date	2011.04.28.09.30.36;	author corinna;	state Exp;
branches;
next	1.218;

1.218
date	2011.04.18.11.26.36;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2011.04.17.19.56.25;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2010.11.29.20.51.38;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2010.11.18.18.55.10;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2010.10.24.18.50.57;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2010.10.24.15.26.05;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2010.10.23.18.11.20;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2010.10.23.18.07.08;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2010.09.29.15.08.49;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2010.09.29.03.57.24;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2010.09.28.10.13.19;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2010.09.20.22.28.57;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2010.09.20.20.25.50;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2010.09.13.11.17.35;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2010.09.01.18.24.10;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2010.07.30.18.04.22;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2010.05.26.13.10.55;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2010.05.07.15.03.27;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2010.04.21.19.36.39;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2010.04.19.20.00.18;	author corinna;	state Exp;
branches;
next	1.198;

1.198
date	2010.04.19.19.52.43;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2010.04.12.13.28.06;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2010.04.02.16.16.53;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2010.04.02.15.41.27;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2010.04.02.14.11.45;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2010.01.13.11.06.21;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2009.07.03.18.05.51;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2009.06.14.23.42.09;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2009.05.06.17.16.33;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2009.01.21.17.14.37;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2008.08.27.21.55.19;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2008.07.26.19.35.21;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2008.06.19.19.50.47;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2008.03.22.21.04.16;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2008.02.07.18.59.40;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2007.12.05.16.50.18;	author corinna;	state Exp;
branches;
next	1.177;

1.177
date	2007.11.28.16.45.34;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2007.02.23.15.15.49;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches
	1.174.2.1;
next	1.173;

1.173
date	2006.07.03.15.29.10;	author corinna;	state Exp;
branches
	1.173.2.1;
next	1.172;

1.172
date	2006.06.12.14.56.31;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2006.06.03.21.44.01;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2006.06.03.20.32.07;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2006.06.03.07.17.53;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2006.06.03.06.35.10;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2006.06.02.15.41.34;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2006.05.22.04.50.54;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2006.05.20.04.59.53;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2006.05.20.04.19.47;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2006.03.18.19.17.21;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2006.01.12.04.41.06;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2006.01.08.21.34.00;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2005.12.29.21.10.50;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2005.12.29.20.46.34;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2005.12.19.04.34.13;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2005.12.13.14.47.18;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2005.12.13.09.07.12;	author corinna;	state Exp;
branches;
next	1.155;

1.155
date	2005.12.13.05.43.30;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2005.12.13.02.02.51;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2005.11.24.02.34.31;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2005.11.17.16.17.17;	author corinna;	state Exp;
branches;
next	1.151;

1.151
date	2005.11.14.05.36.16;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2005.09.28.19.22.23;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2005.09.28.19.02.50;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2005.09.14.14.27.55;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2005.08.18.20.17.10;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2005.08.17.16.10.48;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2005.08.05.16.11.21;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2005.07.06.20.05.01;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2005.06.30.02.52.14;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2005.05.29.00.05.49;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2005.05.02.00.17.45;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2004.11.26.04.15.07;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2004.10.07.08.03.24;	author corinna;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2004.07.22.20.39.08;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2004.05.20.17.32.12;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2004.05.17.15.27.56;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2004.05.12.01.44.11;	author phumblet;	state Exp;
branches;
next	1.130;

1.130
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2004.02.02.20.33.09;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2004.01.21.06.28.34;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2003.12.30.01.57.16;	author cgf;	state Exp;
branches
	1.125.2.1
	1.125.6.1;
next	1.124;

1.124
date	2003.12.27.17.41.17;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2003.12.27.01.59.29;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2003.12.27.00.25.02;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2003.12.12.20.46.03;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2003.12.11.06.12.41;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2003.12.10.04.08.50;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2003.12.10.03.19.19;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2003.12.08.06.27.05;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2003.12.08.00.21.16;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2003.10.24.01.13.22;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2003.10.22.10.07.58;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2003.10.10.19.11.21;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2003.10.01.12.36.39;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2003.09.27.03.14.07;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.27.02.36.50;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2003.09.25.03.51.50;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2003.09.18.18.54.48;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2003.09.12.06.41.53;	author cgf;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2003.09.07.18.27.54;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2003.09.07.02.22.58;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2003.08.25.18.21.07;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2003.07.03.21.22.17;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2003.07.02.03.16.00;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2003.06.07.15.12.23;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2003.04.20.01.36.15;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2003.04.19.02.04.55;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2003.03.13.08.18.15;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2003.03.04.04.07.34;	author cgf;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2003.03.03.15.15.49;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2003.02.13.02.52.40;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2002.12.27.05.31.30;	author cgf;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2002.12.27.03.54.59;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2002.12.27.03.50.29;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2002.12.21.04.38.12;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2002.12.20.01.38.55;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.17.03.49.34;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2002.12.05.16.24.52;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2002.11.30.22.23.01;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2002.11.26.20.32.39;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2002.11.04.01.10.38;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2002.10.20.04.15.50;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2002.10.16.04.54.08;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2002.10.09.05.55.40;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2002.09.22.12.04.15;	author scottc;	state Exp;
branches;
next	1.72;

1.72
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.08.19.35.41;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2002.08.31.03.41.43;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.31.03.35.50;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2002.08.06.05.08.55;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2002.08.02.02.10.24;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2002.08.01.16.20.31;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2002.07.13.20.00.26;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.18.20.27.49;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.28.14.25.53;	author rbcollins;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.22.19.33.41;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.29.05.28.24;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.06.01.04.24;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.24.21.50.44;	author cgf;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2001.09.20.20.58.29;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.01.05.38.46;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.01.05.17.34;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.15.07.49.15;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.14.07.41.45;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.21.03.20.01;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.18.21.18.59;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.16.17.09.19;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.13.18.05.52;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.08.15.16.49;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.28.23.48.28;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.27.06.27.28;	author duda;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.24.02.07.58;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.19.18.27.36;	author duda;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.18.18.05.01;	author duda;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.17.01.45.40;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.12.21.27.42;	author duda;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.11.01.58.23;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.04.15.34.25;	author duda;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.17.01.42.04;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.18.23.46.10;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.07.01.18.37;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.29.02.06.49;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.12.05.47.12;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.03.13.02.09;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.02.19.26.01;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.12.05.06.43;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.12.06.29.54;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.12.04.44.37;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.09.21.04.05;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.05.33.09;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.287.2.1
date	2014.11.13.12.53.01;	author corinna;	state Exp;
branches;
next	;

1.268.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.268.2.2;

1.268.2.2
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.268.2.3;

1.268.2.3
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.268.2.4;

1.268.2.4
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	1.268.2.5;

1.268.2.5
date	2012.11.08.18.51.28;	author corinna;	state Exp;
branches;
next	1.268.2.6;

1.268.2.6
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.268.2.7;

1.268.2.7
date	2012.12.10.11.45.48;	author corinna;	state Exp;
branches;
next	1.268.2.8;

1.268.2.8
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.268.2.9;

1.268.2.9
date	2013.02.05.15.30.12;	author corinna;	state Exp;
branches;
next	1.268.2.10;

1.268.2.10
date	2013.03.14.16.11.42;	author corinna;	state Exp;
branches;
next	1.268.2.11;

1.268.2.11
date	2013.04.13.19.15.24;	author corinna;	state Exp;
branches;
next	;

1.174.2.1
date	2008.03.04.22.30.28;	author corinna;	state Exp;
branches;
next	;

1.173.2.1
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	;

1.136.2.1
date	2004.11.18.00.48.40;	author cgf;	state Exp;
branches;
next	;

1.125.2.1
date	2004.01.15.18.29.37;	author cgf;	state Exp;
branches;
next	;

1.125.6.1
date	2004.01.21.06.28.00;	author cgf;	state Exp;
branches;
next	1.125.6.2;

1.125.6.2
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	;

1.105.2.1
date	2003.09.19.03.55.54;	author cgf;	state Exp;
branches;
next	;

1.93.2.1
date	2003.03.16.23.38.18;	author cgf;	state Exp;
branches;
next	;

1.89.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2003.02.05.14.25.08;	author cgf;	state Exp;
branches;
next	1.89.2.3;

1.89.2.3
date	2003.02.13.03.14.06;	author cgf;	state Exp;
branches;
next	1.89.2.4;

1.89.2.4
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.89.2.5;

1.89.2.5
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.89.2.6;

1.89.2.6
date	2003.03.04.17.26.32;	author cgf;	state Exp;
branches;
next	1.89.2.7;

1.89.2.7
date	2003.03.19.19.59.54;	author cgf;	state Exp;
branches;
next	1.89.2.8;

1.89.2.8
date	2003.05.10.17.20.53;	author cgf;	state Exp;
branches;
next	1.89.2.9;

1.89.2.9
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.89.2.10;

1.89.2.10
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.89.2.11;

1.89.2.11
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.89.2.12;

1.89.2.12
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.89.2.13;

1.89.2.13
date	2003.09.14.01.35.37;	author cgf;	state Exp;
branches;
next	;

1.88.2.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.88.2.2;

1.88.2.2
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.88.2.3;

1.88.2.3
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.88.2.4;

1.88.2.4
date	2002.12.29.06.14.14;	author cgf;	state Exp;
branches;
next	1.88.2.5;

1.88.2.5
date	2003.01.04.21.55.31;	author cgf;	state Exp;
branches;
next	1.88.2.6;

1.88.2.6
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	;

1.49.2.1
date	2001.09.25.06.31.04;	author rbcollins;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2001.09.29.10.47.58;	author rbcollins;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.49.2.5;

1.49.2.5
date	2002.02.28.12.42.17;	author rbcollins;	state Exp;
branches;
next	1.49.2.6;

1.49.2.6
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.49.2.7;

1.49.2.7
date	2002.06.13.14.34.06;	author rbcollins;	state Exp;
branches;
next	1.49.2.8;

1.49.2.8
date	2002.06.17.21.35.33;	author scottc;	state Exp;
branches;
next	1.49.2.9;

1.49.2.9
date	2002.06.24.12.31.24;	author scottc;	state Exp;
branches;
next	1.49.2.10;

1.49.2.10
date	2002.07.02.10.58.18;	author scottc;	state Exp;
branches;
next	1.49.2.11;

1.49.2.11
date	2002.07.03.15.35.43;	author scottc;	state Exp;
branches;
next	1.49.2.12;

1.49.2.12
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.49.2.13;

1.49.2.13
date	2002.08.01.20.34.06;	author scottc;	state Exp;
branches;
next	1.49.2.14;

1.49.2.14
date	2002.08.02.02.23.44;	author scottc;	state Exp;
branches;
next	1.49.2.15;

1.49.2.15
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	1.49.2.16;

1.49.2.16
date	2002.09.03.13.52.07;	author scottc;	state Exp;
branches;
next	1.49.2.17;

1.49.2.17
date	2002.09.12.10.07.49;	author scottc;	state Exp;
branches;
next	1.49.2.18;

1.49.2.18
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.292
log
@	* tty.h (tty::set_master_ctl_closed): Rename from set_master_closed.
	(tty::is_master_closed): Drop method.
	* fhandler_tty.cc (fhandler_pty_slave::open): Remove code prematurely
	bailing out if master control thread is not running.
	(fhandler_pty_slave::read): Don't generate SIGHUP if master control
	thread is not running.
	(fhandler_pty_master::close): Rearrange code to avoid stopping master
	control thread twice in multi-threaded scenarios.
@
text
@/* fhandler_tty.cc

   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <sys/param.h>
#include <cygwin/kd.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "sigproc.h"
#include "pinfo.h"
#include "ntdll.h"
#include "cygheap.h"
#include "shared_info.h"
#include "cygthread.h"
#include "child_info.h"
#include <asm/socket.h>
#include "cygwait.h"

#define close_maybe(h) \
  do { \
    if (h && h != INVALID_HANDLE_VALUE) \
      CloseHandle (h); \
  } while (0)

/* pty master control pipe messages */
struct pipe_request {
  DWORD pid;
};

struct pipe_reply {
  HANDLE from_master;
  HANDLE to_master;
  DWORD error;
};

bool
bytes_available (DWORD& n, HANDLE h)
{
  DWORD navail, nleft;
  navail = nleft = 0;
  bool succeeded = PeekNamedPipe (h, NULL, 0, NULL, &navail, &nleft);
  if (succeeded)
    /* nleft should always be the right choice unless something has written 0
       bytes to the pipe.  In that pathological case we return the actual number
       of bytes available in the pipe. See cgf-000008 for more details.  */
    n = nleft ?: navail;
  else
    {
      termios_printf ("PeekNamedPipe(%p) failed, %E", h);
      n = 0;
    }
  debug_only_printf ("n %u, nleft %u, navail %u", n, nleft, navail);
  return succeeded;
}

bool
fhandler_pty_common::bytes_available (DWORD &n)
{
  return ::bytes_available (n, get_handle ());
}

#ifdef DEBUGGING
static class mutex_stack
{
public:
  const char *fn;
  int ln;
  const char *tname;
} ostack[100];

static int osi;
#endif /*DEBUGGING*/

void
fhandler_pty_master::flush_to_slave ()
{
  if (get_readahead_valid () && !(get_ttyp ()->ti.c_lflag & ICANON))
    accept_input ();
}

DWORD
fhandler_pty_common::__acquire_output_mutex (const char *fn, int ln,
					     DWORD ms)
{
  if (strace.active ())
    strace.prntf (_STRACE_TERMIOS, fn, "(%d): pty output_mutex (%p): waiting %d ms", ln, output_mutex, ms);
  if (ms == INFINITE)
    ms = 100;
  DWORD res = WaitForSingleObject (output_mutex, ms);
  if (res == WAIT_OBJECT_0)
    {
#ifndef DEBUGGING
      if (strace.active ())
	strace.prntf (_STRACE_TERMIOS, fn, "(%d): pty output_mutex: acquired", ln, res);
#else
      ostack[osi].fn = fn;
      ostack[osi].ln = ln;
      ostack[osi].tname = cygthread::name ();
      termios_printf ("acquired for %s:%d, osi %d", fn, ln, osi);
      osi++;
#endif
    }
  return res;
}

void
fhandler_pty_common::__release_output_mutex (const char *fn, int ln)
{
  if (ReleaseMutex (output_mutex))
    {
#ifndef DEBUGGING
      if (strace.active ())
	strace.prntf (_STRACE_TERMIOS, fn, "(%d): pty output_mutex(%p) released", ln, output_mutex);
#else
      if (osi > 0)
	osi--;
      termios_printf ("released(%p) at %s:%d, osi %d", output_mutex, fn, ln, osi);
      termios_printf ("  for %s:%d (%s)", ostack[osi].fn, ostack[osi].ln, ostack[osi].tname);
      ostack[osi].ln = -ln;
#endif
    }
#ifdef DEBUGGING
  else if (osi > 0)
    {
      system_printf ("couldn't release output mutex but we seem to own it, %E");
      try_to_debug ();
    }
#endif
}

/* Process pty input. */

void
fhandler_pty_master::doecho (const void *str, DWORD len)
{
  if (!WriteFile (echo_w, str, len, &len, NULL))
    termios_printf ("Write to echo pipe failed, %E");
}

int
fhandler_pty_master::accept_input ()
{
  DWORD bytes_left;
  int ret = 1;

  WaitForSingleObject (input_mutex, INFINITE);

  bytes_left = eat_readahead (-1);

  if (!bytes_left)
    {
      termios_printf ("sending EOF to slave");
      get_ttyp ()->read_retval = 0;
    }
  else
    {
      char *p = rabuf;
      DWORD rc;
      DWORD written = 0;

      paranoid_printf ("about to write %u chars to slave", bytes_left);
      rc = WriteFile (get_output_handle (), p, bytes_left, &written, NULL);
      if (!rc)
	{
	  debug_printf ("error writing to pipe %p %E", get_output_handle ());
	  get_ttyp ()->read_retval = -1;
	  ret = -1;
	}
      else
	{
	  get_ttyp ()->read_retval = 1;
	  p += written;
	  bytes_left -= written;
	  if (bytes_left > 0)
	    {
	      debug_printf ("to_slave pipe is full");
	      puts_readahead (p, bytes_left);
	      ret = 0;
	    }
	}
    }

  SetEvent (input_available_event);
  ReleaseMutex (input_mutex);
  return ret;
}

bool
fhandler_pty_master::hit_eof ()
{
  if (get_ttyp ()->was_opened && !get_ttyp ()->slave_alive ())
    {
      /* We have the only remaining open handle to this pty, and
	 the slave pty has been opened at least once.  We treat
	 this as EOF.  */
      termios_printf ("all other handles closed");
      return 1;
    }
  return 0;
}

/* Process pty output requests */

int
fhandler_pty_master::process_slave_output (char *buf, size_t len, int pktmode_on)
{
  size_t rlen;
  char outbuf[OUT_BUFFER_SIZE + 1];
  DWORD n;
  DWORD echo_cnt;
  int column = 0;
  int rc = 0;

  flush_to_slave ();

  if (len == 0)
    goto out;

  if (need_nl)
    {
      /* We need to return a left over \n character, resulting from
	 \r\n conversion.  Note that we already checked for FLUSHO and
	 output_stopped at the time that we read the character, so we
	 don't check again here.  */
      if (buf)
	buf[0] = '\n';
      need_nl = 0;
      rc = 1;
      goto out;
    }

  for (;;)
    {
      /* Set RLEN to the number of bytes to read from the pipe.  */
      rlen = len;
      if (get_ttyp ()->ti.c_oflag & OPOST && get_ttyp ()->ti.c_oflag & ONLCR)
	{
	  /* We are going to expand \n to \r\n, so don't read more than
	     half of the number of bytes requested.  */
	  rlen /= 2;
	  if (rlen == 0)
	    rlen = 1;
	}
      if (rlen > sizeof outbuf)
	rlen = sizeof outbuf;

      n = echo_cnt = 0;
      for (;;)
	{
	  /* Check echo pipe first. */
	  if (::bytes_available (echo_cnt, echo_r) && echo_cnt > 0)
	    break;
	  if (!bytes_available (n))
	    goto err;
	  if (n)
	    break;
	  if (hit_eof ())
	    goto out;
	  /* DISCARD (FLUSHO) and tcflush can finish here. */
	  if ((get_ttyp ()->ti.c_lflag & FLUSHO || !buf))
	    goto out;

	  if (is_nonblocking ())
	    {
	      set_errno (EAGAIN);
	      rc = -1;
	      goto out;
	    }
	  pthread_testcancel ();
	  if (cygwait (NULL, 10, cw_sig_eintr) == WAIT_SIGNALED
	      && !_my_tls.call_signal_handler ())
	    {
	      set_errno (EINTR);
	      rc = -1;
	      goto out;
	    }
	  flush_to_slave ();
	}

      /* If echo pipe has data (something has been typed or pasted), prefer
         it over slave output. */
      if (echo_cnt > 0)
      	{
	  if (!ReadFile (echo_r, outbuf, rlen, &n, NULL))
	    {
	      termios_printf ("ReadFile on echo pipe failed, %E");
	      goto err;
	    }
	}
      else if (!ReadFile (get_handle (), outbuf, rlen, &n, NULL))
	{
	  termios_printf ("ReadFile failed, %E");
	  goto err;
	}

      termios_printf ("bytes read %u", n);
      get_ttyp ()->write_error = 0;

      if (get_ttyp ()->ti.c_lflag & FLUSHO || !buf)
	continue;

      char *optr;
      optr = buf;
      if (pktmode_on)
	*optr++ = TIOCPKT_DATA;

      if (!(get_ttyp ()->ti.c_oflag & OPOST))	// post-process output
	{
	  memcpy (optr, outbuf, n);
	  optr += n;
	}
      else					// raw output mode
	{
	  char *iptr = outbuf;

	  while (n--)
	    {
	      switch (*iptr)
		{
		case '\r':
		  if ((get_ttyp ()->ti.c_oflag & ONOCR) && column == 0)
		    {
		      iptr++;
		      continue;
		    }
		  if (get_ttyp ()->ti.c_oflag & OCRNL)
		    *iptr = '\n';
		  else
		    column = 0;
		  break;
		case '\n':
		  if (get_ttyp ()->ti.c_oflag & ONLCR)
		    {
		      *optr++ = '\r';
		      column = 0;
		    }
		  if (get_ttyp ()->ti.c_oflag & ONLRET)
		    column = 0;
		  break;
		default:
		  column++;
		  break;
		}

	      /* Don't store data past the end of the user's buffer.  This
		 can happen if the user requests a read of 1 byte when
		 doing \r\n expansion.  */
	      if (optr - buf >= (int) len)
		{
		  if (*iptr != '\n' || n != 0)
		    system_printf ("internal error: %u unexpected characters", n);
		  need_nl = 1;
		  break;
		}

	      *optr++ = *iptr++;
	    }
	}
      rc = optr - buf;
      break;

    err:
      if (GetLastError () == ERROR_BROKEN_PIPE)
	rc = 0;
      else
	{
	  __seterrno ();
	  rc = -1;
	}
      break;
    }

out:
  termios_printf ("returning %d", rc);
  return rc;
}

/* pty slave stuff */

fhandler_pty_slave::fhandler_pty_slave (int unit)
  : fhandler_pty_common (), inuse (NULL)
{
  if (unit >= 0)
    dev ().parse (DEV_PTYS_MAJOR, unit);
}

int
fhandler_pty_slave::open (int flags, mode_t)
{
  HANDLE pty_owner, from_master_local, to_master_local;
  HANDLE *handles[] =
  {
    &from_master_local, &input_available_event, &input_mutex, &inuse,
    &output_mutex, &to_master_local, &pty_owner,
    NULL
  };

  for (HANDLE **h = handles; *h; h++)
    **h = NULL;

  _tc = cygwin_shared->tty[get_minor ()];

  tcinit (false);

  cygwin_shared->tty.attach (get_minor ());

  /* Create synchronisation events */
  char buf[MAX_PATH];

  const char *errmsg = NULL;

  if (!(output_mutex = get_ttyp ()->open_output_mutex (MAXIMUM_ALLOWED)))
    {
      errmsg = "open output mutex failed, %E";
      goto err;
    }
  if (!(input_mutex = get_ttyp ()->open_input_mutex (MAXIMUM_ALLOWED)))
    {
      errmsg = "open input mutex failed, %E";
      goto err;
    }
  shared_name (buf, INPUT_AVAILABLE_EVENT, get_minor ());
  if (!(input_available_event = OpenEvent (MAXIMUM_ALLOWED, TRUE, buf)))
    {
      errmsg = "open input event failed, %E";
      goto err;
    }

  /* FIXME: Needs a method to eliminate tty races */
  {
    /* Create security attribute.  Default permissions are 0620. */
    security_descriptor sd;
    sd.malloc (sizeof (SECURITY_DESCRIPTOR));
    RtlCreateSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
    SECURITY_ATTRIBUTES sa = { sizeof (SECURITY_ATTRIBUTES), NULL, TRUE };
    if (!create_object_sd_from_attribute (NULL, myself->uid, myself->gid,
					  S_IFCHR | S_IRUSR | S_IWUSR | S_IWGRP,
					  sd))
      sa.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR) sd;
    acquire_output_mutex (INFINITE);
    inuse = get_ttyp ()->create_inuse (&sa);
    get_ttyp ()->was_opened = true;
    release_output_mutex ();
  }

  if (!get_ttyp ()->from_master () || !get_ttyp ()->to_master ())
    {
      errmsg = "pty handles have been closed";
      set_errno (EACCES);
      goto err_no_errno;
    }

  /* Three case for duplicating the pipe handles:
     - Either we're the master.  In this case, just duplicate the handles.
     - Or, we have the right to open the master process for handle duplication.
       In this case, just duplicate the handles.
     - Or, we have to ask the master process itself.  In this case, send our
       pid to the master process and check the reply.  The reply contains
       either the handles, or an error code which tells us why we didn't
       get the handles. */
  if (myself->pid == get_ttyp ()->master_pid)
    {
      /* This is the most common case, just calling openpty. */
      termios_printf ("dup handles within myself.");
      pty_owner = GetCurrentProcess ();
    }
  else
    {
      pinfo p (get_ttyp ()->master_pid);
      if (!p)
	termios_printf ("*** couldn't find pty master");
      else
	{
	  pty_owner = OpenProcess (PROCESS_DUP_HANDLE, FALSE, p->dwProcessId);
	  if (pty_owner)
	    termios_printf ("dup handles directly since I'm the owner");
	}
    }
  if (pty_owner)
    {
      if (!DuplicateHandle (pty_owner, get_ttyp ()->from_master (),
			    GetCurrentProcess (), &from_master_local, 0, TRUE,
			    DUPLICATE_SAME_ACCESS))
	{
	  termios_printf ("can't duplicate input from %u/%p, %E",
			  get_ttyp ()->master_pid, get_ttyp ()->from_master ());
	  __seterrno ();
	  goto err_no_msg;
	}
      if (!DuplicateHandle (pty_owner, get_ttyp ()->to_master (),
			  GetCurrentProcess (), &to_master_local, 0, TRUE,
			  DUPLICATE_SAME_ACCESS))
	{
	  errmsg = "can't duplicate output, %E";
	  goto err;
	}
      if (pty_owner != GetCurrentProcess ())
	CloseHandle (pty_owner);
    }
  else
    {
      pipe_request req = { GetCurrentProcessId () };
      pipe_reply repl;
      DWORD len;

      __small_sprintf (buf, "\\\\.\\pipe\\cygwin-%S-pty%d-master-ctl",
		       &cygheap->installation_key, get_minor ());
      termios_printf ("dup handles via master control pipe %s", buf);
      if (!CallNamedPipe (buf, &req, sizeof req, &repl, sizeof repl,
			  &len, 500))
	{
	  errmsg = "can't call master, %E";
	  goto err;
	}
      from_master_local = repl.from_master;
      to_master_local = repl.to_master;
      if (!from_master_local || !to_master_local)
	{
	  SetLastError (repl.error);
	  errmsg = "error duplicating pipes, %E";
	  goto err;
	}
    }
  VerifyHandle (from_master_local);
  VerifyHandle (to_master_local);

  termios_printf ("duplicated from_master %p->%p from pty_owner",
		  get_ttyp ()->from_master (), from_master_local);
  termios_printf ("duplicated to_master %p->%p from pty_owner",
		  get_ttyp ()->to_master (), to_master_local);

  set_io_handle (from_master_local);
  set_output_handle (to_master_local);

  fhandler_console::need_invisible ();
  set_open_status ();
  return 1;

err:
  if (GetLastError () == ERROR_FILE_NOT_FOUND)
    set_errno (ENXIO);
  else
    __seterrno ();
err_no_errno:
  termios_printf (errmsg);
err_no_msg:
  for (HANDLE **h = handles; *h; h++)
    if (**h && **h != INVALID_HANDLE_VALUE)
      CloseHandle (**h);
  return 0;
}

void
fhandler_pty_slave::open_setup (int flags)
{
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  myself->set_ctty (this, flags);
  report_tty_counts (this, "opened", "");
  fhandler_base::open_setup (flags);
}

void
fhandler_pty_slave::cleanup ()
{
  /* This used to always call fhandler_pty_common::close when we were execing
     but that caused multiple closes of the handles associated with this pty.
     Since close_all_files is not called until after the cygwin process has
     synced or before a non-cygwin process has exited, it should be safe to
     just close this normally.  cgf 2006-05-20 */
  report_tty_counts (this, "closed", "");
  fhandler_base::cleanup ();
}

int
fhandler_pty_slave::close ()
{
  termios_printf ("closing last open %s handle", ttyname ());
  if (inuse && !CloseHandle (inuse))
    termios_printf ("CloseHandle (inuse), %E");
  if (!ForceCloseHandle (input_available_event))
    termios_printf ("CloseHandle (input_available_event<%p>), %E", input_available_event);
  if ((unsigned) myself->ctty == FHDEV (DEV_PTYS_MAJOR, get_minor ()))
    fhandler_console::free_console ();	/* assumes that we are the last pty closer */
  return fhandler_pty_common::close ();
}

int
fhandler_pty_slave::init (HANDLE h, DWORD a, mode_t)
{
  int flags = 0;

  a &= GENERIC_READ | GENERIC_WRITE;
  if (a == GENERIC_READ)
    flags = O_RDONLY;
  if (a == GENERIC_WRITE)
    flags = O_WRONLY;
  if (a == (GENERIC_READ | GENERIC_WRITE))
    flags = O_RDWR;

  int ret = open_with_arch (flags);

  if (ret && !cygwin_finished_initializing && !being_debugged ())
    {
      /* This only occurs when called from dtable::init_std_file_from_handle
	 We have been started from a non-Cygwin process.  So we should become
	 pty process group leader.
	 TODO: Investigate how SIGTTIN should be handled with pure-windows
	 programs. */
      pinfo p (tc ()->getpgid ());
      /* We should only grab this when the process group owner for this
	 pty is a non-cygwin process or we've been started directly
	 from a non-Cygwin process with no Cygwin ancestry.  */
      if (!p || ISSTATE (p, PID_NOTCYGWIN))
	{
	  termios_printf ("Setting process group leader to %d since %W(%d) is not a cygwin process",
			  myself->pgid, p->progname, p->pid);
	  tc ()->setpgid (myself->pgid);
	}
    }

  if (h != INVALID_HANDLE_VALUE)
    CloseHandle (h);	/* Reopened by open */

  return ret;
}

ssize_t __stdcall
fhandler_pty_slave::write (const void *ptr, size_t len)
{
  DWORD n;
  ssize_t towrite = len;

  bg_check_types bg = bg_check (SIGTTOU);
  if (bg <= bg_eof)
    return (ssize_t) bg;

  termios_printf ("pty%d, write(%p, %lu)", get_minor (), ptr, len);

  push_process_state process_state (PID_TTYOU);

  while (len)
    {
      n = MIN (OUT_BUFFER_SIZE, len);
      char *buf = (char *)ptr;
      ptr = (char *) ptr + n;
      len -= n;

      while (tc ()->output_stopped)
	cygwait (10);

      /* Previous write may have set write_error to != 0.  Check it here.
	 This is less than optimal, but the alternative slows down pty
	 writes enormously. */
      if (get_ttyp ()->write_error)
	{
	  set_errno (get_ttyp ()->write_error);
	  towrite = -1;
	  get_ttyp ()->write_error = 0;
	  break;
	}

      BOOL res = WriteFile (get_output_handle (), buf, n, &n, NULL);
      if (!res)
	{
	  DWORD err = GetLastError ();
	  termios_printf ("WriteFile failed, %E");
	  switch (err)
	    {
	    case ERROR_NO_DATA:
	      err = ERROR_IO_DEVICE;
	    default:
	      __seterrno_from_win_error (err);
	    }
	  raise (SIGHUP);		/* FIXME: Should this be SIGTTOU? */
	  towrite = -1;
	  break;
	}
    }
  return towrite;
}

void __reg3
fhandler_pty_slave::read (void *ptr, size_t& len)
{
  ssize_t totalread = 0;
  int vmin = 0;
  int vtime = 0;	/* Initialized to prevent -Wuninitialized warning */
  size_t readlen;
  DWORD bytes_in_pipe;
  char buf[INP_BUFFER_SIZE];
  DWORD time_to_wait;

  bg_check_types bg = bg_check (SIGTTIN);
  if (bg <= bg_eof)
    {
      len = (size_t) bg;
      return;
    }

  termios_printf ("read(%p, %lu) handle %p", ptr, len, get_handle ());

  push_process_state process_state (PID_TTYIN);

  if (is_nonblocking () || !ptr) /* Indicating tcflush(). */
    time_to_wait = 0;
  else if ((get_ttyp ()->ti.c_lflag & ICANON))
    time_to_wait = INFINITE;
  else
    {
      vmin = get_ttyp ()->ti.c_cc[VMIN];
      if (vmin > INP_BUFFER_SIZE)
	vmin = INP_BUFFER_SIZE;
      vtime = get_ttyp ()->ti.c_cc[VTIME];
      if (vmin < 0)
	vmin = 0;
      if (vtime < 0)
	vtime = 0;
      if (!vmin && !vtime)
	time_to_wait = 0;
      else
	time_to_wait = !vtime ? INFINITE : 100 * vtime;
    }

  while (len)
    {
      switch (cygwait (input_available_event, time_to_wait))
	{
	case WAIT_OBJECT_0:
	  break;
	case WAIT_SIGNALED:
	  if (totalread > 0)
	    goto out;
	  termios_printf ("wait catched signal");
	  set_sig_errno (EINTR);
	  totalread = -1;
	  goto out;
	case WAIT_CANCELED:
	  process_state.pop ();
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	case WAIT_TIMEOUT:
	  termios_printf ("wait timed out, time_to_wait %u", time_to_wait);
	  /* No error condition when called from tcflush. */
	  if (!totalread && ptr)
	    {
	      set_sig_errno (EAGAIN);
	      totalread = -1;
	    }
	  goto out;
	default:
	  termios_printf ("wait for input event failed, %E");
	  if (!totalread)
	    {
	      __seterrno ();
	      totalread = -1;
	    }
	  goto out;
	}
      /* Now that we know that input is available we have to grab the
	 input mutex. */
      switch (cygwait (input_mutex, 1000))
	{
	case WAIT_OBJECT_0:
	case WAIT_ABANDONED_0:
	  break;
	case WAIT_SIGNALED:
	  if (totalread > 0)
	    goto out;
	  termios_printf ("wait for mutex caught signal");
	  set_sig_errno (EINTR);
	  totalread = -1;
	  goto out;
	case WAIT_CANCELED:
	  process_state.pop ();
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	case WAIT_TIMEOUT:
	  termios_printf ("failed to acquire input mutex after input event "
			  "arrived");
	  /* If we have a timeout, we can simply handle this failure to
	     grab the mutex as an EAGAIN situation.  Otherwise, if this
	     is an infinitely blocking read, restart the loop. */
	  if (time_to_wait != INFINITE)
	    {
	      if (!totalread)
		{
		  set_sig_errno (EAGAIN);
		  totalread = -1;
		}
	      goto out;
	    }
	  continue;
	default:
	  termios_printf ("wait for input mutex failed, %E");
	  if (!totalread)
	    {
	      __seterrno ();
	      totalread = -1;
	    }
	  goto out;
	}
      if (!bytes_available (bytes_in_pipe))
	raise (SIGHUP);

      /* On first peek determine no. of bytes to flush. */
      if (!ptr && len == UINT_MAX)
	len = (size_t) bytes_in_pipe;

      if (ptr && !bytes_in_pipe && !vmin && !time_to_wait)
	{
	  ReleaseMutex (input_mutex);
	  len = (size_t) bytes_in_pipe;
	  return;
	}

      readlen = MIN (bytes_in_pipe, MIN (len, sizeof (buf)));

#if 0
      /* Why on earth is the read length reduced to vmin, even if more bytes
	 are available *and* len is bigger *and* the local buf is big enough?
	 Disable this code for now, it looks like a remnant of old. */
      if (ptr && vmin && readlen > (unsigned) vmin)
	readlen = vmin;
#endif

      DWORD n = 0;
      if (readlen)
	{
	  termios_printf ("reading %lu bytes (vtime %d)", readlen, vtime);
	  if (!ReadFile (get_handle (), buf, readlen, &n, NULL))
	    {
	      termios_printf ("read failed, %E");
	      raise (SIGHUP);
	      bytes_in_pipe = 0;
	      ptr = NULL;
	    }
	  else
	    {
	      /* MSDN states that 5th prameter can be used to determine total
		 number of bytes in pipe, but for some reason this number doesn't
		 change after successful read. So we have to peek into the pipe
		 again to see if input is still available */
	      if (!bytes_available (bytes_in_pipe))
		raise (SIGHUP);
	      if (n)
		{
		  len -= n;
		  totalread += n;
		  if (ptr)
		    {
		      memcpy (ptr, buf, n);
		      ptr = (char *) ptr + n;
		    }
		}
	    }
	}

      if (!bytes_in_pipe)
	ResetEvent (input_available_event);

      ReleaseMutex (input_mutex);

      if (!ptr)
	{
	  if (!bytes_in_pipe)
	    break;
	  continue;
	}

      if (get_ttyp ()->read_retval < 0)	// read error
	{
	  set_errno (-get_ttyp ()->read_retval);
	  totalread = -1;
	  break;
	}
      if (get_ttyp ()->read_retval == 0)	//EOF
	{
	  termios_printf ("saw EOF");
	  break;
	}
      if (get_ttyp ()->ti.c_lflag & ICANON || is_nonblocking ())
	break;
      if (vmin && totalread >= vmin)
	break;

      /* vmin == 0 && vtime == 0:
       *   we've already read all input, if any, so return immediately
       * vmin == 0 && vtime > 0:
       *   we've waited for input 10*vtime ms in WFSO(input_available_event),
       *   no matter whether any input arrived, we shouldn't wait any longer,
       *   so return immediately
       * vmin > 0 && vtime == 0:
       *   here, totalread < vmin, so continue waiting until more data
       *   arrive
       * vmin > 0 && vtime > 0:
       *   similar to the previous here, totalread < vmin, and timer
       *   hadn't expired -- WFSO(input_available_event) != WAIT_TIMEOUT,
       *   so "restart timer" and wait until more data arrive
       */

      if (vmin == 0)
	break;
    }
out:
  termios_printf ("%d=read(%p, %lu)", totalread, ptr, len);
  len = (size_t) totalread;
}

int
fhandler_pty_slave::dup (fhandler_base *child, int flags)
{
  /* This code was added in Oct 2001 for some undisclosed reason.
     However, setting the controlling tty on a dup causes rxvt to
     hang when the parent does a dup since the controlling pgid changes.
     Specifically testing for -2 (ctty has been setsid'ed) works around
     this problem.  However, it's difficult to see scenarios in which you
     have a dup'able fd, no controlling tty, and not having run setsid.
     So, we might want to consider getting rid of the set_ctty in tty-like dup
     methods entirely at some point */
  if (myself->ctty != -2)
    myself->set_ctty (this, flags);
  report_tty_counts (child, "duped slave", "");
  return 0;
}

int
fhandler_pty_master::dup (fhandler_base *child, int)
{
  report_tty_counts (child, "duped master", "");
  return 0;
}

int
fhandler_pty_slave::tcgetattr (struct termios *t)
{
  *t = get_ttyp ()->ti;
  return 0;
}

int
fhandler_pty_slave::tcsetattr (int, const struct termios *t)
{
  acquire_output_mutex (INFINITE);
  get_ttyp ()->ti = *t;
  release_output_mutex ();
  return 0;
}

int
fhandler_pty_slave::tcflush (int queue)
{
  int ret = 0;

  termios_printf ("tcflush(%d) handle %p", queue, get_handle ());

  if (queue == TCIFLUSH || queue == TCIOFLUSH)
    {
      size_t len = UINT_MAX;
      read (NULL, len);
      ret = ((int) len) >= 0 ? 0 : -1;
    }
  if (queue == TCOFLUSH || queue == TCIOFLUSH)
    {
      /* do nothing for now. */
    }

  termios_printf ("%d=tcflush(%d)", ret, queue);
  return ret;
}

int
fhandler_pty_slave::ioctl (unsigned int cmd, void *arg)
{
  termios_printf ("ioctl (%x)", cmd);
  int res = fhandler_termios::ioctl (cmd, arg);
  if (res <= 0)
    return res;

  if (myself->pgid && get_ttyp ()->getpgid () != myself->pgid
      && (unsigned) myself->ctty == FHDEV (DEV_PTYS_MAJOR, get_minor ())
      && (get_ttyp ()->ti.c_lflag & TOSTOP))
    {
      /* background process */
      termios_printf ("bg ioctl pgid %d, tpgid %d, %s", myself->pgid,
		      get_ttyp ()->getpgid (), myctty ());
      raise (SIGTTOU);
    }

  int retval;
  switch (cmd)
    {
    case TIOCGWINSZ:
    case TIOCSWINSZ:
      break;
    case TIOCGPGRP:
      {
	pid_t pid = this->tcgetpgrp ();
	if (pid < 0)
	  retval = -1;
	else
	  {
	    *((pid_t *) arg) = pid;
	    retval = 0;
	  }
      }
      goto out;
    case TIOCSPGRP:
      retval = this->tcsetpgrp ((pid_t) (intptr_t) arg);
      goto out;
    case FIONREAD:
      {
	DWORD n;
	if (!bytes_available (n))
	  {
	    set_errno (EINVAL);
	    retval = -1;
	  }
	else
	  {
	    *(int *) arg = (int) n;
	    retval = 0;
	  }
      }
      goto out;
    default:
      return fhandler_base::ioctl (cmd, arg);
    }

  acquire_output_mutex (INFINITE);

  get_ttyp ()->cmd = cmd;
  get_ttyp ()->ioctl_retval = 0;
  switch (cmd)
    {
    case TIOCGWINSZ:
      get_ttyp ()->arg.winsize = get_ttyp ()->winsize;
      *(struct winsize *) arg = get_ttyp ()->arg.winsize;
      get_ttyp ()->winsize = get_ttyp ()->arg.winsize;
      break;
    case TIOCSWINSZ:
      if (get_ttyp ()->winsize.ws_row != ((struct winsize *) arg)->ws_row
	  || get_ttyp ()->winsize.ws_col != ((struct winsize *) arg)->ws_col)
	{
	  get_ttyp ()->arg.winsize = *(struct winsize *) arg;
	  get_ttyp ()->winsize = *(struct winsize *) arg;
	  get_ttyp ()->kill_pgrp (SIGWINCH);
	}
      break;
    }

  release_output_mutex ();
  retval = get_ttyp ()->ioctl_retval;
  if (retval < 0)
    {
      set_errno (-retval);
      retval = -1;
    }

out:
  termios_printf ("%d = ioctl(%x)", retval, cmd);
  return retval;
}

int __reg2
fhandler_pty_slave::fstat (struct stat *st)
{
  fhandler_base::fstat (st);

  bool to_close = false;
  if (!input_available_event)
    {
      char buf[MAX_PATH];
      shared_name (buf, INPUT_AVAILABLE_EVENT, get_minor ());
      input_available_event = OpenEvent (READ_CONTROL, TRUE, buf);
      if (input_available_event)
	to_close = true;
    }
  if (!input_available_event
      || get_object_attribute (input_available_event, &st->st_uid, &st->st_gid,
			       &st->st_mode))
    {
      /* If we can't access the ACL, or if the tty doesn't actually exist,
	 then fake uid and gid to strict, system-like values. */
      st->st_mode = S_IFCHR | S_IRUSR | S_IWUSR;
      st->st_uid = 18;
      st->st_gid = 544;
    }
  if (to_close)
    CloseHandle (input_available_event);
  return 0;
}

/* Helper function for fchmod and fchown, which just opens all handles
   and signals success via bool return. */
bool
fhandler_pty_slave::fch_open_handles (bool chown)
{
  char buf[MAX_PATH];
  DWORD write_access = WRITE_DAC | (chown ? WRITE_OWNER : 0);

  _tc = cygwin_shared->tty[get_minor ()];
  shared_name (buf, INPUT_AVAILABLE_EVENT, get_minor ());
  input_available_event = OpenEvent (READ_CONTROL | write_access,
				     TRUE, buf);
  output_mutex = get_ttyp ()->open_output_mutex (write_access);
  input_mutex = get_ttyp ()->open_input_mutex (write_access);
  inuse = get_ttyp ()->open_inuse (write_access);
  if (!input_available_event || !output_mutex || !input_mutex || !inuse)
    {
      __seterrno ();
      return false;
    }
  return true;
}

/* Helper function for fchmod and fchown, which sets the new security
   descriptor on all objects representing the pty. */
int
fhandler_pty_slave::fch_set_sd (security_descriptor &sd, bool chown)
{
  security_descriptor sd_old;

  get_object_sd (input_available_event, sd_old);
  if (!set_object_sd (input_available_event, sd, chown)
      && !set_object_sd (output_mutex, sd, chown)
      && !set_object_sd (input_mutex, sd, chown)
      && !set_object_sd (inuse, sd, chown))
    return 0;
  set_object_sd (input_available_event, sd_old, chown);
  set_object_sd (output_mutex, sd_old, chown);
  set_object_sd (input_mutex, sd_old, chown);
  set_object_sd (inuse, sd_old, chown);
  return -1;
}

/* Helper function for fchmod and fchown, which closes all object handles in
   the pty. */
void
fhandler_pty_slave::fch_close_handles ()
{
  close_maybe (get_io_handle ());
  close_maybe (get_output_handle ());
  close_maybe (input_available_event);
  close_maybe (output_mutex);
  close_maybe (input_mutex);
  close_maybe (inuse);
}

int __reg1
fhandler_pty_slave::fchmod (mode_t mode)
{
  int ret = -1;
  bool to_close = false;
  security_descriptor sd;
  uid_t uid;
  gid_t gid;

  if (!input_available_event)
    {
      to_close = true;
      if (!fch_open_handles (false))
	goto errout;
    }
  sd.malloc (sizeof (SECURITY_DESCRIPTOR));
  RtlCreateSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
  if (!get_object_attribute (input_available_event, &uid, &gid, NULL)
      && !create_object_sd_from_attribute (NULL, uid, gid, S_IFCHR | mode, sd))
    ret = fch_set_sd (sd, false);
errout:
  if (to_close)
    fch_close_handles ();
  return ret;
}

int __reg2
fhandler_pty_slave::fchown (uid_t uid, gid_t gid)
{
  int ret = -1;
  bool to_close = false;
  mode_t mode = 0;
  uid_t o_uid;
  gid_t o_gid;
  security_descriptor sd;

  if (uid == ILLEGAL_UID && gid == ILLEGAL_GID)
    return 0;
  if (!input_available_event)
    {
      to_close = true;
      if (!fch_open_handles (true))
	goto errout;
    }
  sd.malloc (sizeof (SECURITY_DESCRIPTOR));
  RtlCreateSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
  if (!get_object_attribute (input_available_event, &o_uid, &o_gid, &mode))
    {
      if ((uid == ILLEGAL_UID || uid == o_uid)
	  && (gid == ILLEGAL_GID || gid == o_gid))
	ret = 0;
      else if (!create_object_sd_from_attribute (input_available_event,
						 uid, gid, S_IFCHR | mode, sd))
	ret = fch_set_sd (sd, true);
    }
errout:
  if (to_close)
    fch_close_handles ();
  return ret;
}

/*******************************************************
 fhandler_pty_master
*/
fhandler_pty_master::fhandler_pty_master (int unit)
  : fhandler_pty_common (), pktmode (0), master_ctl (NULL),
    master_thread (NULL), from_master (NULL), to_master (NULL),
    echo_r (NULL), echo_w (NULL), dwProcessId (0), need_nl (0)
{
  if (unit >= 0)
    dev ().parse (DEV_PTYM_MAJOR, unit);
  else if (!setup ())
    {
      dev ().parse (FH_ERROR);
      return;
    }
  set_name ("/dev/ptmx");
}

int
fhandler_pty_master::open (int flags, mode_t)
{
  set_open_status ();
  dwProcessId = GetCurrentProcessId ();
  return 1;
}

void
fhandler_pty_master::open_setup (int flags)
{
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  char buf[sizeof ("opened pty master for ptyNNNNNNNNNNN")];
  __small_sprintf (buf, "opened pty master for pty%d", get_minor ());
  report_tty_counts (this, buf, "");
  fhandler_base::open_setup (flags);
}

off_t
fhandler_pty_common::lseek (off_t, int)
{
  set_errno (ESPIPE);
  return -1;
}

int
fhandler_pty_common::close ()
{
  termios_printf ("pty%d <%p,%p> closing", get_minor (), get_handle (), get_output_handle ());
  if (!ForceCloseHandle (input_mutex))
    termios_printf ("CloseHandle (input_mutex<%p>), %E", input_mutex);
  if (!ForceCloseHandle (output_mutex))
    termios_printf ("CloseHandle (output_mutex<%p>), %E", output_mutex);
  if (!ForceCloseHandle1 (get_handle (), from_pty))
    termios_printf ("CloseHandle (get_handle ()<%p>), %E", get_handle ());
  if (!ForceCloseHandle1 (get_output_handle (), to_pty))
    termios_printf ("CloseHandle (get_output_handle ()<%p>), %E", get_output_handle ());

  return 0;
}

void
fhandler_pty_master::cleanup ()
{
  report_tty_counts (this, "closing master", "");
  if (archetype)
    from_master = to_master = NULL;
  fhandler_base::cleanup ();
}

int
fhandler_pty_master::close ()
{
  termios_printf ("closing from_master(%p)/to_master(%p) since we own them(%u)",
		  from_master, to_master, dwProcessId);
  if (cygwin_finished_initializing)
    {
      if (master_ctl && get_ttyp ()->master_pid == myself->pid)
	{
	  char buf[MAX_PATH];
	  pipe_request req = { (DWORD) -1 };
	  pipe_reply repl;
	  DWORD len;

	  __small_sprintf (buf, "\\\\.\\pipe\\cygwin-%S-pty%d-master-ctl",
			   &cygheap->installation_key, get_minor ());
	  acquire_output_mutex (INFINITE);
	  if (master_ctl)
	    {
	      CallNamedPipe (buf, &req, sizeof req, &repl, sizeof repl, &len,
			     500);
	      CloseHandle (master_ctl);
	      master_thread->detach ();
	      get_ttyp ()->set_master_ctl_closed ();
	      master_ctl = NULL;
	    }
	  release_output_mutex ();
	}
    }

  if (!ForceCloseHandle (from_master))
    termios_printf ("error closing from_master %p, %E", from_master);
  if (!ForceCloseHandle (to_master))
    termios_printf ("error closing from_master %p, %E", to_master);
  from_master = to_master = NULL;
  ForceCloseHandle (echo_r);
  ForceCloseHandle (echo_w);
  echo_r = echo_w = NULL;

  fhandler_pty_common::close ();

  if (have_execed || get_ttyp ()->master_pid != myself->pid)
    termios_printf ("not clearing: %d, master_pid %d", have_execed, get_ttyp ()->master_pid);
  if (!ForceCloseHandle (input_available_event))
    termios_printf ("CloseHandle (input_available_event<%p>), %E", input_available_event);

  return 0;
}

ssize_t __stdcall
fhandler_pty_master::write (const void *ptr, size_t len)
{
  ssize_t ret;
  char *p = (char *) ptr;
  termios ti = tc ()->ti;

  bg_check_types bg = bg_check (SIGTTOU);
  if (bg <= bg_eof)
    return (ssize_t) bg;

  push_process_state process_state (PID_TTYOU);
  line_edit_status status = line_edit (p++, len, ti, &ret);
  if (status > line_edit_signalled && status != line_edit_pipe_full)
    ret = -1;
  return ret;
}

void __reg3
fhandler_pty_master::read (void *ptr, size_t& len)
{
  bg_check_types bg = bg_check (SIGTTIN);
  if (bg <= bg_eof)
    {
      len = (size_t) bg;
      return;
    }
  push_process_state process_state (PID_TTYIN);
  len = (size_t) process_slave_output ((char *) ptr, len, pktmode);
}

int
fhandler_pty_master::tcgetattr (struct termios *t)
{
  *t = cygwin_shared->tty[get_minor ()]->ti;
  return 0;
}

int
fhandler_pty_master::tcsetattr (int, const struct termios *t)
{
  cygwin_shared->tty[get_minor ()]->ti = *t;
  return 0;
}

int
fhandler_pty_master::tcflush (int queue)
{
  int ret = 0;

  termios_printf ("tcflush(%d) handle %p", queue, get_handle ());

  if (queue == TCIFLUSH || queue == TCIOFLUSH)
    ret = process_slave_output (NULL, OUT_BUFFER_SIZE, 0);
  else if (queue == TCIFLUSH || queue == TCIOFLUSH)
    {
      /* do nothing for now. */
    }

  termios_printf ("%d=tcflush(%d)", ret, queue);
  return ret;
}

int
fhandler_pty_master::ioctl (unsigned int cmd, void *arg)
{
  int res = fhandler_termios::ioctl (cmd, arg);
  if (res <= 0)
    return res;

  switch (cmd)
    {
    case TIOCPKT:
      pktmode = *(int *) arg;
      break;
    case TIOCGWINSZ:
      *(struct winsize *) arg = get_ttyp ()->winsize;
      break;
    case TIOCSWINSZ:
      if (get_ttyp ()->winsize.ws_row != ((struct winsize *) arg)->ws_row
	  || get_ttyp ()->winsize.ws_col != ((struct winsize *) arg)->ws_col)
	{
	  get_ttyp ()->winsize = *(struct winsize *) arg;
	  get_ttyp ()->kill_pgrp (SIGWINCH);
	}
      break;
    case TIOCGPGRP:
      *((pid_t *) arg) = this->tcgetpgrp ();
      break;
    case TIOCSPGRP:
      return this->tcsetpgrp ((pid_t) (intptr_t) arg);
    case FIONREAD:
      {
	DWORD n;
	if (!::bytes_available (n, to_master))
	  {
	    set_errno (EINVAL);
	    return -1;
	  }
	*(int *) arg = (int) n;
      }
      break;
    default:
      return fhandler_base::ioctl (cmd, arg);
    }
  return 0;
}

int
fhandler_pty_master::ptsname_r (char *buf, size_t buflen)
{
  char tmpbuf[TTY_NAME_MAX];

  __ptsname (tmpbuf, get_minor ());
  if (buflen <= strlen (tmpbuf))
    {
      set_errno (ERANGE);
      return ERANGE;
    }
  strcpy (buf, tmpbuf);
  return 0;
}

void
fhandler_pty_common::set_close_on_exec (bool val)
{
  // Cygwin processes will handle this specially on exec.
  close_on_exec (val);
}

void
fhandler_pty_slave::fixup_after_fork (HANDLE parent)
{
  // fork_fixup (parent, inuse, "inuse");
  // fhandler_pty_common::fixup_after_fork (parent);
  report_tty_counts (this, "inherited", "");
}

void
fhandler_pty_slave::fixup_after_exec ()
{
  if (!close_on_exec ())
    fixup_after_fork (NULL);
}

/* This thread function handles the master control pipe.  It waits for a
   client to connect.  Then it checks if the client process has permissions
   to access the tty handles.  If so, it opens the client process and
   duplicates the handles into that process.  If that fails, it sends a reply
   with at least one handle set to NULL and an error code.  Last but not
   least, the client is disconnected and the thread waits for the next client.

   A special case is when the master side of the tty is about to be closed.
   The client side is the fhandler_pty_master::close function and it sends
   a PID -1 in that case.  On Vista and later a check is performed that the
   request to leave really comes from the master process itself.  On earlier
   OSes there's no function to check for the PID of the client process so
   we have to trust the client side.

   Since there's always only one pipe instance, there's a chance that clients
   have to wait to connect to the master control pipe.  Therefore the client
   calls to CallNamedPipe should have a big enough timeout value.  For now this
   is 500ms.  Hope that's enough. */

DWORD
fhandler_pty_master::pty_master_thread ()
{
  bool exit = false;
  GENERIC_MAPPING map = { EVENT_QUERY_STATE, EVENT_MODIFY_STATE, 0,
			  EVENT_QUERY_STATE | EVENT_MODIFY_STATE };
  pipe_request req;
  DWORD len;
  security_descriptor sd;
  HANDLE token;
  PRIVILEGE_SET ps;
  DWORD pid;
  NTSTATUS status;

  termios_printf ("Entered");
  while (!exit && (ConnectNamedPipe (master_ctl, NULL)
		   || GetLastError () == ERROR_PIPE_CONNECTED))
    {
      pipe_reply repl = { NULL, NULL, 0 };
      bool deimp = false;
      NTSTATUS allow = STATUS_ACCESS_DENIED;
      ACCESS_MASK access = EVENT_MODIFY_STATE;
      HANDLE client = NULL;

      if (!ReadFile (master_ctl, &req, sizeof req, &len, NULL))
	{
	  termios_printf ("ReadFile, %E");
	  goto reply;
	}
      /* This function is only available since Vista, unfortunately.
	 In earlier OSes we simply have to believe that the client
	 has no malicious intent (== sends arbitrary PIDs). */
      if (!GetNamedPipeClientProcessId (master_ctl, &pid))
	pid = req.pid;
      if (get_object_sd (input_available_event, sd))
	{
	  termios_printf ("get_object_sd, %E");
	  goto reply;
	}
      cygheap->user.deimpersonate ();
      deimp = true;
      if (!ImpersonateNamedPipeClient (master_ctl))
	{
	  termios_printf ("ImpersonateNamedPipeClient, %E");
	  goto reply;
	}
      status = NtOpenThreadToken (GetCurrentThread (), TOKEN_QUERY, TRUE,
				  &token);
      if (!NT_SUCCESS (status))
	{
	  termios_printf ("NtOpenThreadToken, %y", status);
	  SetLastError (RtlNtStatusToDosError (status));
	  goto reply;
	}
      len = sizeof ps;
      status = NtAccessCheck (sd, token, access, &map, &ps, &len, &access,
			      &allow);
      NtClose (token);
      if (!NT_SUCCESS (status))
	{
	  termios_printf ("NtAccessCheck, %y", status);
	  SetLastError (RtlNtStatusToDosError (status));
	  goto reply;
	}
      if (!RevertToSelf ())
	{
	  termios_printf ("RevertToSelf, %E");
	  goto reply;
	}
      if (req.pid == (DWORD) -1)	/* Request to finish thread. */
	{
	  /* Pre-Vista: Just believe in the good of the client process.
	     Post-Vista: Check if the requesting process is the master
	     process itself. */
	  if (pid == (DWORD) -1 || pid == GetCurrentProcessId ())
	    exit = true;
	  goto reply;
	}
      if (NT_SUCCESS (allow))
	{
	  client = OpenProcess (PROCESS_DUP_HANDLE, FALSE, pid);
	  if (!client)
	    {
	      termios_printf ("OpenProcess, %E");
	      goto reply;
	    }
	  if (!DuplicateHandle (GetCurrentProcess (), from_master,
			       client, &repl.from_master,
			       0, TRUE, DUPLICATE_SAME_ACCESS))
	    {
	      termios_printf ("DuplicateHandle (from_master), %E");
	      goto reply;
	    }
	  if (!DuplicateHandle (GetCurrentProcess (), to_master,
				client, &repl.to_master,
				0, TRUE, DUPLICATE_SAME_ACCESS))
	    {
	      termios_printf ("DuplicateHandle (to_master), %E");
	      goto reply;
	    }
	}
reply:
      repl.error = GetLastError ();
      if (client)
	CloseHandle (client);
      if (deimp)
	cygheap->user.reimpersonate ();
      sd.free ();
      termios_printf ("Reply: from %p, to %p, error %u",
		      repl.from_master, repl.to_master, repl.error );
      if (!WriteFile (master_ctl, &repl, sizeof repl, &len, NULL))
	termios_printf ("WriteFile, %E");
      if (!DisconnectNamedPipe (master_ctl))
	termios_printf ("DisconnectNamedPipe, %E");
    }
  termios_printf ("Leaving");
  return 0;
}

static DWORD WINAPI
pty_master_thread (VOID *arg)
{
  return ((fhandler_pty_master *) arg)->pty_master_thread ();
}

bool
fhandler_pty_master::setup ()
{
  int res;
  security_descriptor sd;
  SECURITY_ATTRIBUTES sa = { sizeof (SECURITY_ATTRIBUTES), NULL, TRUE };

  /* Find an unallocated pty to use. */
  int unit = cygwin_shared->tty.allocate (from_master, get_output_handle ());
  if (unit < 0)
    return false;

  ProtectHandle1 (get_output_handle (), to_pty);

  tty& t = *cygwin_shared->tty[unit];
  _tc = (tty_min *) &t;

  tcinit (true);		/* Set termios information.  Force initialization. */

  const char *errstr = NULL;
  DWORD pipe_mode = PIPE_NOWAIT;

  if (!SetNamedPipeHandleState (get_output_handle (), &pipe_mode, NULL, NULL))
    termios_printf ("can't set output_handle(%p) to non-blocking mode",
		    get_output_handle ());

  char pipename[sizeof("ptyNNNN-from-master")];
  __small_sprintf (pipename, "pty%d-to-master", unit);
  res = fhandler_pipe::create (&sec_none, &get_io_handle (), &to_master,
			       fhandler_pty_common::pipesize, pipename, 0);
  if (res)
    {
      errstr = "output pipe";
      goto err;
    }

  ProtectHandle1 (get_io_handle (), from_pty);

  __small_sprintf (pipename, "pty%d-echoloop", unit);
  res = fhandler_pipe::create (&sec_none, &echo_r, &echo_w,
			       fhandler_pty_common::pipesize, pipename, 0);
  if (res)
    {
      errstr = "echo pipe";
      goto err;
    }

  /* Create security attribute.  Default permissions are 0620. */
  sd.malloc (sizeof (SECURITY_DESCRIPTOR));
  RtlCreateSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
  if (!create_object_sd_from_attribute (NULL, myself->uid, myself->gid,
					S_IFCHR | S_IRUSR | S_IWUSR | S_IWGRP,
					sd))
    sa.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR) sd;

  /* Carefully check that the input_available_event didn't already exist.
     This is a measure to make sure that the event security descriptor
     isn't occupied by a malicious process.  We must make sure that the
     event's security descriptor is what we expect it to be. */
  if (!(input_available_event = t.get_event (errstr = INPUT_AVAILABLE_EVENT,
					     &sa, TRUE))
      || GetLastError () == ERROR_ALREADY_EXISTS)
    goto err;

  char buf[MAX_PATH];
  errstr = shared_name (buf, OUTPUT_MUTEX, unit);
  if (!(output_mutex = CreateMutex (&sa, FALSE, buf)))
    goto err;

  errstr = shared_name (buf, INPUT_MUTEX, unit);
  if (!(input_mutex = CreateMutex (&sa, FALSE, buf)))
    goto err;

  /* Create master control pipe which allows the master to duplicate
     the pty pipe handles to processes which deserve it. */
  __small_sprintf (buf, "\\\\.\\pipe\\cygwin-%S-pty%d-master-ctl",
		   &cygheap->installation_key, unit);
  master_ctl = CreateNamedPipe (buf, PIPE_ACCESS_DUPLEX
				     | FILE_FLAG_FIRST_PIPE_INSTANCE,
				PIPE_WAIT | PIPE_TYPE_MESSAGE
				| PIPE_READMODE_MESSAGE
				| (wincap.has_pipe_reject_remote_clients ()
				   ? PIPE_REJECT_REMOTE_CLIENTS : 0),
				1, 4096, 4096, 0, &sec_all_nih);
  if (master_ctl == INVALID_HANDLE_VALUE)
    {
      errstr = "pty master control pipe";
      goto err;
    }
  master_thread = new cygthread (::pty_master_thread, this, "ptym");
  if (!master_thread)
    {
      errstr = "pty master control thread";
      goto err;
    }

  t.set_from_master (from_master);
  t.set_to_master (to_master);
  t.winsize.ws_col = 80;
  t.winsize.ws_row = 25;
  t.master_pid = myself->pid;

  dev ().parse (DEV_PTYM_MAJOR, unit);

  termios_printf ("this %p, pty%d opened - from_pty %p, to_pty %p", this, unit,
		  get_io_handle (), get_output_handle ());
  return true;

err:
  __seterrno ();
  close_maybe (get_io_handle ());
  close_maybe (get_output_handle ());
  close_maybe (input_available_event);
  close_maybe (output_mutex);
  close_maybe (input_mutex);
  close_maybe (from_master);
  close_maybe (to_master);
  close_maybe (echo_r);
  close_maybe (echo_w);
  close_maybe (master_ctl);
  termios_printf ("pty%d open failed - failed to create %s", unit, errstr);
  return false;
}

void
fhandler_pty_master::fixup_after_fork (HANDLE parent)
{
  DWORD wpid = GetCurrentProcessId ();
  fhandler_pty_master *arch = (fhandler_pty_master *) archetype;
  if (arch->dwProcessId != wpid)
    {
      tty& t = *get_ttyp ();
      if (myself->pid == t.master_pid)
	{
	  t.set_from_master (arch->from_master);
	  t.set_to_master (arch->to_master);
	}
      arch->dwProcessId = wpid;
    }
  from_master = arch->from_master;
  to_master = arch->to_master;
  report_tty_counts (this, "inherited master", "");
}

void
fhandler_pty_master::fixup_after_exec ()
{
  if (!close_on_exec ())
    fixup_after_fork (spawn_info->parent);
  else
    from_master = to_master = NULL;
}
@


1.291
log
@	* fhandler.h (fhandler_base::get_echo_handle): New virtual method.
	(class fhandler_pty_master): Add echo_r and echo_w handles constituting
	read and write side of new echo pipe.
	* select.cc (peek_pipe): On pty masters, check additionally if input
	from the echo pipe is available.
	* fhandler_tty.cc (fhandler_pty_master::doecho): Drop output_mutex
	locking.  Write output to echo pipe.
	(fhandler_pty_master::process_slave_output): Check if input is available
	in echo pipe and prefer to read from it, if so.
	(fhandler_pty_slave::write): Drop output_mutex locking.
	(fhandler_pty_master::fhandler_pty_master): Initialize echo pipe
	handles to NULL.
	(fhandler_pty_master::close): Close and NULL echo pipe handles.
	(fhandler_pty_master::setup): Create echo pipe, close in case of error.
@
text
@a464 6
  if (get_ttyp ()->is_master_closed ())
    {
      errmsg = "*** master is closed";
      set_errno (EAGAIN);
      goto err_no_errno;
    }
a740 6
	  if (get_ttyp ()->is_master_closed ())
	    {
	      raise (SIGHUP);
	      totalread = 0;
	      goto out;
	    }
d1306 11
a1316 3
	  CallNamedPipe (buf, &req, sizeof req, &repl, sizeof repl, &len, 500);
	  CloseHandle (master_ctl);
	  master_thread->detach ();
a1332 5
  else
    {
      get_ttyp ()->set_master_closed ();
      SetEvent (input_available_event);
    }
@


1.290
log
@	* fhandler_tty.cc (fhandler_pty_slave::read): Having no input is not an
	error condition for tcflush.
@
text
@d148 2
a149 4
  acquire_output_mutex (INFINITE);
  if (!WriteFile (to_master, str, len, &len, NULL))
    termios_printf ("Write to %p failed, %E", to_master);
  release_output_mutex ();
d222 1
d259 1
a259 1
      n = 0;
d262 3
d292 11
a302 1
      if (!ReadFile (get_handle (), outbuf, rlen, &n, NULL))
a667 1
      acquire_output_mutex (INFINITE);
a676 1
	  release_output_mutex ();
a680 1
      release_output_mutex ();
d1240 1
a1240 1
    dwProcessId (0), need_nl (0)
d1329 3
d1675 9
d1754 2
@


1.289
log
@	* fhandler.h (fhandler_termios::line_edit): Add parameter to return
	written bytes.
	* fhandler_termios.cc (fhandler_termios::tcinit): Fix formatting.
	(fhandler_termios::line_edit): Return bytes actually written.  Write
	in 32 byte chunks in non-canonical mode to reduce number of WriteFile
	calls.  Don't just eat unwritten bytes in case of an error condition.
	Especially, don't report them back to the caller as written.
	* fhandler_tty.cc (fhandler_pty_slave::read): Disable code reducing
	the number of bytes read from the pipe to vmin.  Add comment.
	(fhandler_pty_master::write): Convert ret to ssize_t type.  Just call
	line_edit once, not in a loop once for each byte.  Return bytes written
	as returned by line_edit.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d758 2
a759 1
	  if (!totalread)
@


1.288
log
@	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.
@
text
@d832 4
d838 1
d1338 1
a1338 1
  int i;
d1347 4
a1350 12

  for (i = 0; i < (int) len; i++)
    {
      line_edit_status status = line_edit (p++, 1, ti);
      if (status > line_edit_signalled)
	{
	  if (status != line_edit_pipe_full)
	    i = -1;
	  break;
	}
    }
  return i;
@


1.287
log
@* fhandler.h (fhandler_pty_master::~fhandler_pty_master): Delete.
* fhandler_tty.cc (fhandler_pty_master::~fhandler_pty_master): Ditto.
@
text
@d1105 1
a1105 1
fhandler_pty_slave::fch_open_handles ()
d1108 1
d1112 1
a1112 1
  input_available_event = OpenEvent (READ_CONTROL | WRITE_DAC | WRITE_OWNER,
d1114 3
a1116 3
  output_mutex = get_ttyp ()->open_output_mutex (WRITE_DAC | WRITE_OWNER);
  input_mutex = get_ttyp ()->open_input_mutex (WRITE_DAC | WRITE_OWNER);
  inuse = get_ttyp ()->open_inuse (WRITE_DAC | WRITE_OWNER);
d1170 1
a1170 1
      if (!fch_open_handles ())
d1199 1
a1199 1
      if (!fch_open_handles ())
@


1.287.2.1
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d1105 1
a1105 1
fhandler_pty_slave::fch_open_handles (bool chown)
a1107 1
  DWORD write_access = WRITE_DAC | (chown ? WRITE_OWNER : 0);
d1111 1
a1111 1
  input_available_event = OpenEvent (READ_CONTROL | write_access,
d1113 3
a1115 3
  output_mutex = get_ttyp ()->open_output_mutex (write_access);
  input_mutex = get_ttyp ()->open_input_mutex (write_access);
  inuse = get_ttyp ()->open_inuse (write_access);
d1169 1
a1169 1
      if (!fch_open_handles (false))
d1198 1
a1198 1
      if (!fch_open_handles (true))
@


1.286
log
@* external.cc (fillout_pinfo): If start_time is 0, wait a while before
returning the pinfo structure.
* fhandler.cc (fhandler_base::open_setup): Convert from inline.
* fhandler.h (fhandler_base::open_setup): Declare.
* fhandler_console.cc (fhandler_console::open_setup): Always call
fhandler_base::open_setup.
* fhandler_tty.cc (fhandler_pty_slave::open_setup): Ditto.
(fhandler_pty_master::open_setup): Ditto.
@
text
@a1328 9
/* This is just to catch error conditions.  Since the constructor
   actually opens some handles, and stat() does not open an fd, they need
   to be closed when the fhandler goes away. */
fhandler_pty_master::~fhandler_pty_master ()
{
  if (from_master && to_master)
    close_with_arch ();
}

@


1.285
log
@* fhandler.h (fhandler_base::cleanup): Mark as extern rather than inline.
* fhandler_base.cc (fhandler_base::cleanup): Define.
* fhandler_tty.cc (fhandler_pty_slave::cleanup): Call fhandler_base::cleanup.
(fhandler_pty_master::cleanup): Ditto.
@
text
@d565 1
d1251 1
@


1.284
log
@* fhandler_tty.cc: Revert accidental checkin.
* update-copyright: Ditto.
@
text
@d576 1
d1281 1
@


1.283
log
@cygwin directory changes:
	* environ.cc (tty_is_gone): Delete.
	(known): Delete tty, add wincmdln.
	* globals.cc: Reorganize list of environment bools, remove explicit =
	false for slight load time optimization.
	(wincmdln): New global.
	* spawn.cc (child_info_spawn::worker): Honor wincmdln.

doc directory changes:
	* new-features.sgml (ov-new1.7.23): Add new section.  Mention wincmdln.
	* cygwinenv.xml: Mention wincmdln.
@
text
@d99 1
a99 1
  if (0 && ms == INFINITE)
a147 3
  static char buf[128 * 1024];
  int buflen = process_slave_output (buf, sizeof (buf), false);
  puts_readahead (buf, buflen);
@


1.282
log
@revert accidentally checked in files
@
text
@d99 1
a99 1
  if (ms == INFINITE)
d148 3
@


1.281
log
@* cygwait.cc (cygwait): Remove lock around sig retrieval since this code is
essentially guarded by thread-specific signal_arrived.
* exceptions.cc (_cygtls::handle_SIGCONT): Simplify.  Eliminate lock/unlock
since code is guarded by signal_arrived.
@
text
@d99 1
a99 1
  if (0 && ms == INFINITE)
a147 3
  static char buf[128 * 1024];
  int buflen = process_slave_output (buf, sizeof (buf), false);
  puts_readahead (buf, buflen);
@


1.280
log
@* fhandler_tty.cc (fhandler_pty_common::__acquire_output_mutex): Never wait an
INFINITE amount of time.  Instead default to 1/10 second.
(fhandler_pty_slave::open): Just default to INFINITE wait rather than
(now) waiting longer than previously.
@
text
@d99 1
a99 1
  if (ms == INFINITE)
d148 3
@


1.279
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d99 2
d440 1
a440 1
    acquire_output_mutex (500);
@


1.278
log
@	* Merge in cygwin-64bit-branch.
@
text
@d687 1
a687 1
void __stdcall
d1153 1
a1153 1
int __stdcall
d1179 1
a1179 1
int __stdcall
d1358 1
a1358 1
void __stdcall
@


1.277
log
@* DevNotes: Add entry cgf-000022.
* cygtls.h (_cygtls::func): Define as a sa_sigaction style function.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(_cygtls::interrupt_setup): Fix coercion to accommodate 'func' change.
(ctrl_c_handler): Use tty kill_pgrp to send a signal.
(sigpacket::process): Don't process sigflush here.
(_cygtls::call_signal_handler): Reorganize to avoid a race.  Always call
sa_sigaction style function.
* fhandler_termios.cc (is_flush_sig): Define new function.
(tty_min::kill_pgrp): Handle tty flush when signal detected.
(fhandler_termios::bg_check): Be slightly more paranoid about checking for
valid tty.
(fhandler_termios::sigflush): Don't flush unless tty owner.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Use tty kill_pgrp to send
signal.
(fhandler_pty_master::ioctl): Ditto.
* signal.cc (killsys): Delete definition.
* sigproc.h (killsys): Delete declaration.
* include/cygwin/signal.h (siginfo_t): Simplify union/struct nesting slightly.
Implement mechanism to allow cygwin data passing.
@
text
@a47 6
int
fhandler_pty_slave::get_unit ()
{
  return dev ().get_minor ();
}

d173 1
a173 1
      paranoid_printf ("about to write %d chars to slave", bytes_left);
d349 1
a349 1
		    system_printf ("internal error: %d unexpected characters", n);
d399 1
a399 1
  _tc = cygwin_shared->tty[get_unit ()];
d403 1
a403 1
  cygwin_shared->tty.attach (get_unit ());
d420 1
a420 1
  shared_name (buf, INPUT_AVAILABLE_EVENT, get_unit ());
d444 1
a444 1
  if (!get_ttyp ()->from_master || !get_ttyp ()->to_master)
d485 1
a485 1
      if (!DuplicateHandle (pty_owner, get_ttyp ()->from_master,
d490 1
a490 1
			  get_ttyp ()->master_pid, get_ttyp ()->from_master);
d494 1
a494 1
      if (!DuplicateHandle (pty_owner, get_ttyp ()->to_master,
d511 1
a511 1
		       &cygheap->installation_key, get_unit ());
d532 1
a532 1
		  get_ttyp ()->from_master, from_master_local);
d534 1
a534 1
		  get_ttyp ()->to_master, to_master_local);
d584 1
a584 1
  if ((unsigned) myself->ctty == FHDEV (DEV_PTYS_MAJOR, get_unit ()))
d632 2
a633 1
  DWORD n, towrite = len;
d639 1
a639 1
  termios_printf ("pty%d, write(%x, %d)", get_unit (), ptr, len);
d660 1
a660 1
	  towrite = (DWORD) -1;
d680 1
a680 1
	  towrite = (DWORD) -1;
d690 1
a690 1
  int totalread = 0;
d705 1
a705 1
  termios_printf ("read(%x, %d) handle %p", ptr, len, get_handle ());
d834 1
a834 1
	  termios_printf ("reading %d bytes (vtime %d)", readlen, vtime);
d910 1
a910 1
  termios_printf ("%d=read(%x, %d)", totalread, ptr, len);
d985 1
a985 1
      && (unsigned) myself->ctty == FHDEV (DEV_PTYS_MAJOR, get_unit ())
d1013 1
a1013 1
      retval = this->tcsetpgrp ((pid_t) arg);
d1070 1
a1070 1
fhandler_pty_slave::fstat (struct __stat64 *st)
d1078 1
a1078 1
      shared_name (buf, INPUT_AVAILABLE_EVENT, get_unit ());
d1105 2
a1106 2
  _tc = cygwin_shared->tty[get_unit ()];
  shared_name (buf, INPUT_AVAILABLE_EVENT, get_unit ());
d1159 2
a1160 2
  __uid32_t uid;
  __gid32_t gid;
d1180 1
a1180 1
fhandler_pty_slave::fchown (__uid32_t uid, __gid32_t gid)
d1185 2
a1186 2
  __uid32_t o_uid;
  __gid32_t o_gid;
d1245 1
a1245 1
  __small_sprintf (buf, "opened pty master for pty%d", get_unit ());
d1249 2
a1250 2
_off64_t
fhandler_pty_common::lseek (_off64_t, int)
d1259 1
a1259 1
  termios_printf ("pty%d <%p,%p> closing", get_unit (), get_handle (), get_output_handle ());
d1283 1
a1283 1
  termios_printf ("closing from_master(%p)/to_master(%p) since we own them(%d)",
d1295 1
a1295 1
			   &cygheap->installation_key, get_unit ());
d1374 1
a1374 1
  *t = cygwin_shared->tty[get_unit ()]->ti;
d1381 1
a1381 1
  cygwin_shared->tty[get_unit ()]->ti = *t;
d1430 1
a1430 1
      return this->tcsetpgrp ((pid_t) arg);
d1453 1
a1453 1
  __ptsname (tmpbuf, get_unit ());
d1554 1
a1554 1
	  termios_printf ("NtOpenThreadToken, %p", status);
d1564 1
a1564 1
	  termios_printf ("NtAccessCheck, %p", status);
d1612 1
a1612 1
      termios_printf ("Reply: from %p, to %p, error %lu",
d1697 2
a1698 1
  master_ctl = CreateNamedPipe (buf, PIPE_ACCESS_DUPLEX,
d1700 4
a1703 2
				| PIPE_READMODE_MESSAGE, 1, 4096, 4096,
				0, &sec_all_nih);
d1716 2
a1717 2
  t.from_master = from_master;
  t.to_master = to_master;
d1752 2
a1753 2
	  t.from_master = arch->from_master;
	  t.to_master = arch->to_master;
@


1.276
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d1056 1
a1056 1
	  killsys (-get_ttyp ()->getpgid (), SIGWINCH);
d1428 1
a1428 1
	  killsys (-get_ttyp ()->getpgid (), SIGWINCH);
@


1.275
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d1074 1
a1074 1
int __stdcall
@


1.274
log
@* fhandler_termios.cc (fhandler_termios::line_edit): Don't do special character
handling when stopped by CTRL-S.
* fhandler_tty.cc (bytes_available): Add arguments to debug_only_printf call.
* sigproc.cc (proc_subproc): Simplify some if logic.
@
text
@a1489 4
#ifndef __MINGW64_VERSION_MAJOR
extern "C" BOOL WINAPI GetNamedPipeClientProcessId (HANDLE, PULONG);
#endif

@


1.273
log
@* fhandler_tty.cc (fhandler_pty_slave::write): Fix potential exit from loop
with write mutex held.  Delete redundant mutex release.  Clear tty error once
we've grabbed it.
@
text
@d70 1
a70 1
  debug_only_printf ("n %u, nleft %u, navail %u");
@


1.272
log
@* fhandler_tty.cc (fhandler_pty_slave::write): DWORD -> BOOL.
@
text
@d666 2
a685 1
	  release_output_mutex ();
@


1.271
log
@* fhandler_termios.cc (fhandler_termios::line_edit): Don't manipulate
output_mutex on CTRL-S/CTRL-Q to avoid a deadlock.
* fhandler_tty.cc (fhandler_pty_slave::write): Loop when output_stopped is
detected before acquiring output_mutex.  Acquire output_mutex in the loop for
each write.
* tty.h: Remove some obsolete defines.
(tty_min::output_stopped): Make 'bool'.
@
text
@d669 1
a669 1
      DWORD res = WriteFile (get_output_handle (), buf, n, &n, NULL);
@


1.270
log
@whitespace cleanup
@
text
@a647 2
  acquire_output_mutex (INFINITE);

d655 4
d669 3
a671 1
      if (WriteFile (get_output_handle (), buf, n, &n, NULL) == FALSE)
d684 1
a687 1
  release_output_mutex ();
@


1.269
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d94 1
a94 1
{ 
@


1.268
log
@* cygwait.cc (cancelable_wait): Add some debugging-only output.
* exceptions.cc (sig_handle_tty_stop): Make sure that incyg is cleared when
exiting if we have no parent process.  Only wait for signal_arrived.
(sigpacket::process): Make continue_now a bool.  Delay sending signal_arrived
until the end.  Make code more defensive to avoid calling signal handler when
stopped.  Only set signal_arrived when stopped.
* sigproc.cc (sig_hold): Rename from sigCONT.  Make static.
(sig_send): Accommodate sigCONT -> sig_hold rename.
(wait_sig): Ditto.
* sigproc.h (sigCONT): Delete declaration.
* fhandler_console.cc (fhandler_console::write): Use new '%0c' facility to
print characters.  Change to paranoid to avoid excessive strace output.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Make frequent strace
printf "paranoid" to help cut down on strace output size.
* signal.cc (sigsuspend): Add standard syscall strace output.
(sigpause): Ditto.
(pause): Ditto.
* cygtls.h (_cygtls::reset_signal_arrived): New function.
@
text
@d284 1
a284 1
	  if (cancelable_wait (NULL, 10, cw_sig_eintr) == WAIT_SIGNALED
@


1.268.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d1070 1
a1070 1
fhandler_pty_slave::fstat (struct stat *st)
d1159 2
a1160 2
  uid_t uid;
  gid_t gid;
d1180 1
a1180 1
fhandler_pty_slave::fchown (uid_t uid, gid_t gid)
d1185 2
a1186 2
  uid_t o_uid;
  gid_t o_gid;
d1249 2
a1250 2
off_t
fhandler_pty_common::lseek (off_t, int)
@


1.268.2.2
log
@Pull in changes from HEAD
@
text
@d284 1
a284 1
	  if (cygwait (NULL, 10, cw_sig_eintr) == WAIT_SIGNALED
@


1.268.2.3
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d94 1
a94 1
{
d648 2
a656 4
      while (tc ()->output_stopped)
	cygwait (10);
      acquire_output_mutex (INFINITE);

a663 2
	  get_ttyp ()->write_error = 0;
	  release_output_mutex ();
d667 1
a667 3
      BOOL res = WriteFile (get_output_handle (), buf, n, &n, NULL);
      release_output_mutex ();
      if (!res)
d683 1
@


1.268.2.4
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d48 6
d405 1
a405 1
  _tc = cygwin_shared->tty[get_minor ()];
d409 1
a409 1
  cygwin_shared->tty.attach (get_minor ());
d426 1
a426 1
  shared_name (buf, INPUT_AVAILABLE_EVENT, get_minor ());
d517 1
a517 1
		       &cygheap->installation_key, get_minor ());
d590 1
a590 1
  if ((unsigned) myself->ctty == FHDEV (DEV_PTYS_MAJOR, get_minor ()))
d644 1
a644 1
  termios_printf ("pty%d, write(%x, %d)", get_minor (), ptr, len);
d990 1
a990 1
      && (unsigned) myself->ctty == FHDEV (DEV_PTYS_MAJOR, get_minor ())
d1083 1
a1083 1
      shared_name (buf, INPUT_AVAILABLE_EVENT, get_minor ());
d1110 2
a1111 2
  _tc = cygwin_shared->tty[get_minor ()];
  shared_name (buf, INPUT_AVAILABLE_EVENT, get_minor ());
d1250 1
a1250 1
  __small_sprintf (buf, "opened pty master for pty%d", get_minor ());
d1264 1
a1264 1
  termios_printf ("pty%d <%p,%p> closing", get_minor (), get_handle (), get_output_handle ());
d1300 1
a1300 1
			   &cygheap->installation_key, get_minor ());
d1379 1
a1379 1
  *t = cygwin_shared->tty[get_minor ()]->ti;
d1386 1
a1386 1
  cygwin_shared->tty[get_minor ()]->ti = *t;
d1458 1
a1458 1
  __ptsname (tmpbuf, get_minor ());
@


1.268.2.5
log
@	* tty.h (class tty): Store from_master and to_master HANDLEs in
	unions to make sure the storage is 64 bit compatible.  Add comment to
	explain why.
	(from_master): Convert to read accessor method.
	(to_master): Ditto.
	(set_from_master): New method to store HANDLE value 64 bit clean.
	(set_to_master): Ditto.
	* fhandler_tty.cc: Fix debug printfs to work in 64 bit mode as well.
	Change usage of from_master and to_master throughout to accommodate
	aforementioned change.
	* fhandler_termios.cc (fhandler_termios::ioctl): Add cast to avoid
	compiler warning.

	Pull in changes from HEAD.
@
text
@d64 1
a64 1
  debug_only_printf ("n %u, nleft %u, navail %u", n, nleft, navail);
d444 1
a444 1
  if (!get_ttyp ()->from_master () || !get_ttyp ()->to_master ())
d485 1
a485 1
      if (!DuplicateHandle (pty_owner, get_ttyp ()->from_master (),
d490 1
a490 1
			  get_ttyp ()->master_pid, get_ttyp ()->from_master ());
d494 1
a494 1
      if (!DuplicateHandle (pty_owner, get_ttyp ()->to_master (),
d532 1
a532 1
		  get_ttyp ()->from_master (), from_master_local);
d534 1
a534 1
		  get_ttyp ()->to_master (), to_master_local);
d1012 1
a1012 1
      retval = this->tcsetpgrp ((pid_t) (intptr_t) arg);
d1429 1
a1429 1
      return this->tcsetpgrp ((pid_t) (intptr_t) arg);
d1716 2
a1717 2
  t.set_from_master (from_master);
  t.set_to_master (to_master);
d1752 2
a1753 2
	  t.set_from_master (arch->from_master);
	  t.set_to_master (arch->to_master);
@


1.268.2.6
log
@Pull in changes from HEAD
@
text
@d1484 4
@


1.268.2.7
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d173 1
a173 1
      paranoid_printf ("about to write %u chars to slave", bytes_left);
d349 1
a349 1
		    system_printf ("internal error: %u unexpected characters", n);
d638 1
a638 1
  termios_printf ("pty%d, write(%p, %lu)", get_minor (), ptr, len);
d704 1
a704 1
  termios_printf ("read(%p, %lu) handle %p", ptr, len, get_handle ());
d833 1
a833 1
	  termios_printf ("reading %lu bytes (vtime %d)", readlen, vtime);
d909 1
a909 1
  termios_printf ("%d=read(%p, %lu)", totalread, ptr, len);
d1282 1
a1282 1
  termios_printf ("closing from_master(%p)/to_master(%p) since we own them(%u)",
d1553 1
a1553 1
	  termios_printf ("NtOpenThreadToken, %y", status);
d1563 1
a1563 1
	  termios_printf ("NtAccessCheck, %y", status);
d1611 1
a1611 1
      termios_printf ("Reply: from %p, to %p, error %u",
@


1.268.2.8
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1068 1
a1068 1
int __reg2
@


1.268.2.9
log
@Pull in changes from HEAD
@
text
@d1050 1
a1050 1
	  get_ttyp ()->kill_pgrp (SIGWINCH);
d1422 1
a1422 1
	  get_ttyp ()->kill_pgrp (SIGWINCH);
@


1.268.2.10
log
@	* fhandler_tty.cc (fhandler_pty_master::setup): Add
	PIPE_REJECT_REMOTE_CLIENTS to pipe mode on systems supporting it.  Add
	FILE_FLAG_FIRST_PIPE_INSTANCE to pipe open mode.
	* pipe.cc (fhandler_pipe::create): Ditto.  Fix subsequent comment
	accordingly.
	* wincap.h (wincaps::has_pipe_reject_remote_clients): New element.
	* wincap.cc: Implement above element throughout.
	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Temporarily define until
	Mingw64 headers define it.
@
text
@d1696 1
a1696 2
  master_ctl = CreateNamedPipe (buf, PIPE_ACCESS_DUPLEX
				     | FILE_FLAG_FIRST_PIPE_INSTANCE,
d1698 2
a1699 4
				| PIPE_READMODE_MESSAGE
				| (wincap.has_pipe_reject_remote_clients ()
				   ? PIPE_REJECT_REMOTE_CLIENTS : 0),
				1, 4096, 4096, 0, &sec_all_nih);
@


1.268.2.11
log
@	* fhandler_tty.cc (fhandler_pty_slave::write): Change type of towrite to
	ssize_t.
	(fhandler_pty_slave::read): Ditto for totalread.
@
text
@d632 1
a632 2
  DWORD n;
  ssize_t towrite = len;
d659 1
a659 1
	  towrite = -1;
d679 1
a679 1
	  towrite = -1;
d689 1
a689 1
  ssize_t totalread = 0;
@


1.267
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d179 1
a179 1
      termios_printf ("about to write %d chars to slave", bytes_left);
@


1.266
log
@	* fhandler_registry.cc (RegOpenUserClassesRoot): Only define when
	building against w32api headers.
	(RegOpenCurrentUser): Ditto.
	* fhandler_tty.cc (GetNamedPipeClientProcessId): Ditto.
	* ntdll.h (enum _PROCESSINFOCLASS): Add ProcessImageFileName.
	(RtlInitAnsiString): Declare.
	(RtlUnicodeStringToAnsiSize): Declare.
	* sched.cc (GetForegroundWindow): Ditto.
	* sec_helper.cc (SECURITY_NT_NON_UNIQUE): Define as
	SECURITY_NT_NON_UNIQUE_RID when building against w32api headers.
	(cygsid::get_sid): Use SECURITY_NT_NON_UNIQUE rather than
	SECURITY_NT_NON_UNIQUE_RID.
	(__sec_user): Use PISECURITY_DESCRIPTOR rather than PSECURITY_DESCRIPTOR
	to allow valid pointer arithmetic.
	(_recycler_sd): Ditto.
	(_everyone_sd): Ditto.
@
text
@d284 1
a284 1
	  if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0
@


1.265
log
@* fhandler_tty.cc (fhandler_pty_slave::read): Remove duplicate assignment to
bytes_in_pipe found by Clang.
@
text
@d1485 1
d1487 1
@


1.264
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@a837 1
	      bytes_in_pipe = 0;
@


1.263
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d284 1
a284 1
	  if (cancelable_wait (NULL, 10, cw_sig_eintr) == WAIT_SIGNALED
@


1.262
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d284 1
a284 1
	  if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0
@


1.261
log
@* DevNotes: Add entry cgf-000008.
* fhandler_tty.cc (bytes_available): Simplify by returning the number of bytes
available in the message unless that is zero.
@
text
@d29 1
d741 1
a741 1
	case WAIT_OBJECT_0 + 1:
d748 1
a748 1
	case WAIT_OBJECT_0 + 2:
d776 1
a776 1
	case WAIT_OBJECT_0 + 1:
d779 1
a779 1
	  termios_printf ("wait for mutex catched signal");
d783 1
a783 1
	case WAIT_OBJECT_0 + 2:
@


1.260
log
@* DevNotes: Add entry cgf-000002.
* fhandler_tty.cc (bytes_available): Revert to previous Oct-2011 behavior where
a dummy buffer is used to determine how many bytes will be read.
(fhandler_pty_master::ioctl): Correct coercion in assignment.
@
text
@d56 9
a64 6
  char buf[INP_BUFFER_SIZE];
  /* Apparently need to pass in a dummy buffer to read a real "record" from
     the pipe.  So buf is used and then discarded just so we can see how many
     bytes will be read by the next ReadFile().  */
  bool succeeded = PeekNamedPipe (h, buf, sizeof (buf), &n, NULL, NULL);
  if (!succeeded)
d69 1
a69 1
  debug_only_printf ("%u bytes available", n);
@


1.259
log
@* fhandler.h (fhandler_pty_common::bytes_available): Declare new function.
(fhandler_pty_master::flush_to_slave): Ditto.
* fhandler_tty.cc (bytes_available): Define new function.
(fhandler_pty_common::bytes_available): Ditto.
(handler_pty_master::flush_to_slave): Ditto.
(fhandler_pty_master::process_slave_output): Call flush_to_slave () here.  Use
bytes_available () rather than PeekNamedPipe.  Cleanup sloppy logic.
(fhandler_pty_slave::read): Use bytes_available () rather than PeekNamedPipe.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_master::ioctl): Ditto.
(fhandler_pty_master::cleanup): Remove ancient #if 0.
* select.cc (peek_pipe): Call flush_to_slave whenever we're checking for a pty
master.
@
text
@d56 5
a60 1
  bool succeeded = PeekNamedPipe (h, NULL, 0, NULL, &n, NULL);
d1436 1
a1436 1
	*(int *) arg = (DWORD) n;
@


1.258
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d53 19
d84 7
d93 1
a93 1
					   DWORD ms)
d223 2
a240 1

d256 12
a267 1
      HANDLE handle = get_io_handle ();
d269 1
a269 7
      n = 0; // get_readahead_into_buffer (outbuf, len);
      if (!n)
	{
	  /* Doing a busy wait like this is quite inefficient, but nothing
	     else seems to work completely.  Windows should provide some sort
	     of overlapped I/O for pipes, or something, but it doesn't.  */
	  while (1)
d271 3
a273 27
	      if (!PeekNamedPipe (handle, NULL, 0, NULL, &n, NULL))
		{
		  termios_printf ("PeekNamedPipe(%p) failed, %E", handle);
		  goto err;
		}
	      if (n > 0)
		break;
	      if (hit_eof ())
		goto out;
	      /* DISCARD (FLUSHO) and tcflush can finish here. */
	      if ((get_ttyp ()->ti.c_lflag & FLUSHO || !buf))
		goto out;

	      if (is_nonblocking ())
		{
		  set_errno (EAGAIN);
		  rc = -1;
		  goto out;
		}
	      pthread_testcancel ();
	      if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0
		  && !_my_tls.call_signal_handler ())
		{
		  set_errno (EINTR);
		  rc = -1;
		  goto out;
		}
d275 3
a277 2

	  if (!ReadFile (handle, outbuf, rlen, &n, NULL))
d279 3
a281 2
	      termios_printf ("ReadFile failed, %E");
	      goto err;
d283 7
a687 1
  char peek_buf[INP_BUFFER_SIZE];
d804 2
a805 6
      if (!PeekNamedPipe (get_handle (), peek_buf, sizeof (peek_buf), &bytes_in_pipe, NULL, NULL))
	{
	  termios_printf ("PeekNamedPipe failed, %E");
	  raise (SIGHUP);
	  bytes_in_pipe = 0;
	}
d841 2
a842 6
	      if (!PeekNamedPipe (get_handle (), peek_buf, 1, &bytes_in_pipe, NULL, NULL))
		{
		  termios_printf ("PeekNamedPipe failed, %E");
		  raise (SIGHUP);
		  bytes_in_pipe = 0;
		}
d1010 2
a1011 2
	int n;
	if (!PeekNamedPipe (get_handle (), NULL, 0, NULL, (DWORD *) &n, NULL))
d1018 1
a1018 1
	    *(int *) arg = n;
a1275 5
#if 0
  while (accept_input () > 0)
    continue;
#endif

d1426 2
a1427 2
	int n;
	if (!PeekNamedPipe (to_master, NULL, 0, NULL, (DWORD *) &n, NULL))
d1432 1
a1432 1
	*(int *) arg = n;
@


1.257
log
@* fhandler_console.cc (fhandler_console::dup): Only set ctty when we haven't
specifically called setsid.
* fhandler_tty.cc (fhandler_pty_slave::dup): Ditto.  Also add comment
documenting research into rxvt problem.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Don't check specifically
for myself->ctty == -1.  Test for > 0 as that is the correct test.
(fhandler_termios::sigflush): Ditto.
@
text
@d14 1
d627 1
a627 1
      n = min (OUT_BUFFER_SIZE, len);
d806 1
a806 1
      readlen = min (bytes_in_pipe, min (len, sizeof (buf)));
@


1.256
log
@	* cygheap.cc (init_cygheap::init_installation_root): Convert function
	init_installation_root into a cygheap method.
	* cygheap.h (struct init_cygheap): Move installation_root,
	installation_key, and installation_key_buf from shared
	.cygwin_dll_common DLL section to cygheap.  Declare new method
	init_installation_root.
	* dtable.cc (handle_to_fn): Accommodate the move of installation strings
	to the cygheap.
	* external.cc (cygwin_internal): Ditto.
	* fhandler_console.cc (fhandler_console::open_shared_console): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Ditto.
	* fhandler_tty.cc: Ditto, throughout.
	* mount.cc (mount_info::init): Ditto.
	* pipe.cc (fhandler_pipe::create): Ditto.
	* shared.cc: Ditto, throughout.
	(installation_root): Remove.
	(installation_key): Move to cygheap.
	(installation_key_buf): Ditto.
	(installation_root_inited): Remove.
	(SPIN_WAIT): Remove.
	(init_installation_root): Move to cygheap.
	(memory_init): Call cygheap->init_installation_root right after
	cygheap->user.init.  Drop call of init_installation_root function.
	* shared_info.h (init_installation_root): Drop declaration.
	(installation_root): Ditto.
	(installation_key): Ditto.
	* uinfo.cc (pwdgrp::load): Accommodate the move of installation strings
	to the cygheap.
@
text
@d901 10
a910 1
  myself->set_ctty (this, flags);
@


1.255
log
@* cygheap.cc (init_cygheap::manage_console_count): Delete.
* cygheap.h (init_cygheap::manage_console_count): Ditto.
(init_cygheap::console_count): Ditto.
* fhandler.h (fhandler_console::has_a): Ditto.
(fhandler_console::free_console): Declare new function.
* fhandler_console.cc (fhandler_console::free_console): Define new function.
(fhandler_console::open_setup): Delete call to manage_console_count.
(fhandler_console::close): Ditto.  Replace with call to free_console().
* fhandler_tty.cc (fhandler_pty_slave::open): Delete call to
manage_console_count.
(fhandler_pty_slave::cleanup): Ditto.
(fhandler_pty_slave::close): Call fhandler_console::free_console() if this is
our controlling tty.
* pinfo.cc (_pinfo::set_ctty): Skip function if tty in question == our ctty.
Delete call to manage_console_count.
* syscalls.cc (close_all_files): Avoid locking and avoid setting errno when
iterating over fds.
@
text
@d491 1
a491 1
		       &installation_key, get_unit ());
d1275 1
a1275 1
			   &installation_key, get_unit ());
d1678 1
a1678 1
		   &installation_key, unit);
@


1.254
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d519 1
a520 2
  if (cygheap->manage_console_count ("fhandler_pty_slave::open", 1) == 1)
    fhandler_console::need_invisible ();
a541 1
  cygheap->manage_console_count ("fhandler_pty_slave::open_setup", 1);
a552 1
  cygheap->manage_console_count ("fhandler_pty_slave::close", -1);
d564 2
a901 1
  cygheap->manage_console_count ("fhandler_pty_slave::dup", 1);
@


1.253
log
@* cygthread.h (cygthread::name): Very minor formatting tweak.
* exceptions.cc (_cygtls::call_signal_handler): Add paranoid debugging output.
* sigproc.h (cygwait): Call signal handler when signal is detected and loop as
appropriate.
* fhandler.h (fhandler_base_overlapped::wait_return): Remove overlapped_signal.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove restartable
signal accommodations in light of cygwait improvements.
(fhandler_base_overlapped::raw_read): Remove now-obsolete signal loop behavior.
(fhandler_base_overlapped::raw_write): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* ioctl.cc (ioctl): Add standard syscall introducer and leaver debug output.
@
text
@d1204 1
a1204 1
      return; 
d1305 2
a1306 2
/* This is just to catch error conditions.  Since the constructor 
   ctually opens some handles, and stat() does not open an fd, they need
@


1.252
log
@Rename cygWFMO to cygwait throughout and use the magic of polymorphism to "wait
for stuff".
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use simplified arg
form of cygwait.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_audio.cc (fhandler_dev_dsp::Audio_out::waitforspac): Ditto.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* select.cc (cygwin_select): Ditto.
* sigproc.h (cygwait): Rename from cygWFMO.  Define two argument and single
argument forms of this function.
* fhandler_tty.cc (fhandler_pty_slave::open): Use method to query if tty is
open.
(fhandler_pty_slave::read): Send SIGHUP when master is detected as closed.
(fhandler_pty_common::close): Close input_available_event in callers since
master may need to signal it first.
(fhandler_pty_master::close): Lie and set input_available_event when closing,
then close input_available_event.
(fhandler_pty_slave::close): Close input_available_event explicitly here.
* tty.h (tty::is_master_closed): Declare new method.
@
text
@a719 2
	  if (_my_tls.call_signal_handler ())
	    continue;
a754 2
	  if (_my_tls.call_signal_handler ())
	    continue;
@


1.251
log
@* sigproc.cc (cygWFMO): Don't assume that cancellable event is always
available.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::waitforspace): Use cygWFMO
instead of WaitForMultipleObjects.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto for degenerate case.
@
text
@d431 1
a431 1
  if (get_ttyp ()->master_pid < 0)
d565 2
d707 1
a707 1
      switch (cygWFMO (1, time_to_wait, input_available_event))
d710 6
d749 1
a749 1
      switch (cygWFMO (1, 1000, input_mutex))
d822 1
a822 9
	      raise (SIGHUP);
	    }
	  /* MSDN states that 5th prameter can be used to determine total
	     number of bytes in pipe, but for some reason this number doesn't
	     change after successful read. So we have to peek into the pipe
	     again to see if input is still available */
	  if (!PeekNamedPipe (get_handle (), peek_buf, 1, &bytes_in_pipe, NULL, NULL))
	    {
	      termios_printf ("PeekNamedPipe failed, %E");
d825 1
d827 1
a827 1
	  if (n)
d829 5
a833 3
	      len -= n;
	      totalread += n;
	      if (ptr)
d835 13
a847 2
		  memcpy (ptr, buf, n);
		  ptr = (char *) ptr + n;
a1249 3
  if (!ForceCloseHandle (input_available_event))
    termios_printf ("CloseHandle (input_available_event<%p>), %E", input_available_event);

d1299 6
a1304 1
    get_ttyp ()->set_master_closed ();
@


1.250
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d705 1
a705 4
      HANDLE w4[3] = { input_available_event, signal_arrived,
		       pthread::get_cancel_event () };
      DWORD cnt = w4[2] ? 3 : 2;
      switch (WaitForMultipleObjects (cnt, w4, FALSE, time_to_wait))
d741 1
a741 2
      w4[0] = input_mutex;
      switch (WaitForMultipleObjects (cnt, w4, FALSE, 1000))
@


1.249
log
@* fhandler.h (fhandler_pipe::create): Rename from the misnamed
"create_selectable".  Change return to DWORD.
(fhandler_pty_common::pipesize): New constant.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Reflect create_selectable
name change.
* miscfuncs.cc (CreatePipeOverlapped): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Rename from the misnamed "create_selectable".  Return
DWORD.  Only set pipe size to default when it is passed in as zero.
* fhandler_tty.cc (fhandler_pty_master::setup): Ditto.  Use
fhandler_pty_common::pipesize rather than a raw constant.
* tty.cc (tty::not_allocated): Ditto.
* sigproc.cc (sigproc_init): Use create_selectable to create the signal pipe to
get a more appropriate message based pipe.
@
text
@d1036 1
a1036 1
  termios_printf ("%d = ioctl (%x)", retval, cmd);
d1682 1
a1682 1
  master_thread = new cygthread (::pty_master_thread, this, "pty_master");
@


1.248
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d1633 2
a1634 2
  res = fhandler_pipe::create_selectable (&sec_none, &get_io_handle (),
					  &to_master, 128 * 1024, pipename, 0);
@


1.247
log
@* fhandler.h (__ptsname): New macro.
* dtable.cc (decode_tty): Use __ptsname to generate the slave pty name.
* fhandler_tty.cc (fhandler_pty_master::ptsname_r): Ditto.
* bsdlib.cc: Add needed includes for openpty() changes.
(openpty): Use __ptsname to generate the slave pty name.  Close slave fd when
aslave == NULL.
@
text
@d550 5
a554 5
  /* This used to always call fhandler_pty_common::close when hExeced but that
     caused multiple closes of the handles associated with this pty.  Since
     close_all_files is not called until after the cygwin process has synced
     or before a non-cygwin process has exited, it should be safe to just
     close this normally.  cgf 2006-05-20 */
d1289 2
a1290 2
  if (hExeced || get_ttyp ()->master_pid != myself->pid)
    termios_printf ("not clearing: %d, master_pid %d", hExeced, get_ttyp ()->master_pid);
@


1.246
log
@* cygwin.din (ptsname_r): Export.
* fhandler.cc (fhandler_base::ptsname_r): Define.
* fhandler.h (fhandler_base::ptsname): Delete.
(fhandler_base::ptsname_r): Declare.
(fhandler_pty_master::ptsname_r): Declare.
* fhandler_tty.cc (fhandler_pty_master::ptsname): Delete.
(fhandler_pty_master::ptsname_r): New reentrant function derived from previous
ptsname.
* syscalls.cc (ptsname_r): Implement new function with functionality similar to
Linux.
(ptsname): Use ptsname_r () to fill out buf.
* include/cygwin/stdlib.h (ptsname_r): Declare.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 255 to reflect
export of ptsname_r.
* pinfo.cc (pinfo::wait): Return bool rather than int.
* pinfo.h (info::wait): Ditto.
(pinfo::reattach): Define !defined(_SIGPROC_H) case for consistency.
* sigproc.cc (child_info_spawn::reattach_children): Use correct dwProcessId
rather than pid when duplicating handle.
@
text
@d1427 1
a1427 1
  __small_sprintf (tmpbuf, "/dev/pty%d", get_unit ());
@


1.245
log
@* fhandler.h (fhandler_pipe::create_selectable): Remove optional argument, take
an options argument for CreateNamedPipe/CreateFile.  Change handle arguments to
expect pointers.
(fhandler_fifo::fifo_state): Delete.
(fhandler_fifo::dummy_client): Ditto.
(fhandler_fifo::open_nonserver): Ditto.
(fhandler_fifo::wait_state): Ditto.
(fhandler_fifo::raw_write): Ditto.
(fhandler_fifo::read_ready): New field.
(fhandler_fifo::write_ready): Ditto.
(fhandler_fifo::wait): Modify argument.
(fhandler_fifo::fifo_name): Add a new argument.
(fhandler_fifo::fixup_after_fork): New function.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove initialization of
expunged elements.  Initialize new handles to NULL.
(fhandler_fifo::open_nonserver): Delete.
(fnevent): New macro for creating a named event.
(fnpipe): New macro for creating a unique named pipe name.
(create_pipe): New macro for simplification of named pipe creation.
(fhandler_fifo::fifo_name): Use new argument when creating a shared name.
(fhandler_fifo::open): Rewrite.  Use events to synchronize.
(pure_debug_printf): New macro, active only when DEBUGGING.
(fhandler_fifo::wait): Rewrite to wait for new fifo events which are supplied
as a parameter.
(fhandler_fifo::raw_read): Rewrite to use handle mechanism to detect
client-side disconnect.
(fhandler_fifo::raw_write): Delete.
(fhandler_fifo::close): Remove accommodations for expunged fields.  Close event
handles.
(fhandler_fifo::dup): Remove accommodations for expunged fields.  Duplicate
event handles.
(fhandler_fifo::fixup_after_fork): New function.  Perform fixups on event
handles.
(fhandler_fifo::set_close_on_exec): Remove accommodations for expunged fields.
Set inheritance for new handle fields.
* miscfuncs.cc (CreatePipeOverlapped): Accommodate changes in
fhandler_pipe::create_selectable.
* tty.cc (tty::not_allocated): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create_selectable): Accept an extra open_mode argument.  Pass
arguments by reference and allow opening one end of the pipe at a time.
* sys/strace.h (debug_only_printf): Define new macro which calls debug_printf
only when DEBUGGING is defined.
@
text
@d1422 2
a1423 2
char *
fhandler_pty_master::ptsname ()
d1425 1
a1425 1
  static char buf[TTY_NAME_MAX];
d1427 8
a1434 2
  __small_sprintf (buf, "/dev/pty%d", get_unit ());
  return buf;
@


1.244
log
@* fhandler_tty.cc (fhandler_pty_slave::read): Use consistent way for testing
ReadFile return.
* pipe.cc (fhandler_pipe::create_selectable): Open the write side of the pipe
in message-mode to force writing as "chunks".  Explain why.
@
text
@d1627 2
a1628 2
  res = fhandler_pipe::create_selectable (&sec_none, get_io_handle (),
					  to_master, 128 * 1024, pipename);
@


1.243
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@d815 1
a815 1
	  if (ReadFile (get_handle (), buf, readlen, &n, NULL) == FALSE)
@


1.242
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d362 1
a362 1
    dev ().parse (DEV_TTYS_MAJOR, unit);
d956 1
a956 1
      && (unsigned) myself->ctty == FHDEV (DEV_TTYS_MAJOR, get_unit ())
d1194 1
a1194 1
    dev ().parse (DEV_TTYM_MAJOR, unit);
d1196 5
a1200 1
    dev ().parse (FH_ERROR);
d1689 1
a1689 1
  dev ().parse (DEV_TTYM_MAJOR, unit);
@


1.241
log
@* cygwin.din: Remove some _tc* exports.  Add tcgetsid().
* dtable.cc (fh_alloc): Revert ill-advised setting of major/minor.  Use new
is_dev_tty to remember that this device was opened as /dev/tty.
* fhandler.cc (fhandler_base::fstat): Remove leftover debugging statement.
(fhandler_base::tcgetsid): New function.
* fhandler.h ((fhandler_base::tcgetsid): Declare new function.
(fhandler_base::is_dev_tty): Ditto.
(fhandler_termios::opened_as_dev_tty): Declare new field.
(fhandler_termios::is_dev_tty): Declare new function.
(fhandler_termios::tcgetsid): Ditto.
(fhandler_pty_common::use_archetype): Move here from subclass.
(fhandler_pty_slave::use_archetype): Move up.
(fhandler_pty_master::use_archetype): Ditto.
* fhandler_console.cc (fhandler_console::ioctl): Rename second argument from
`buf' to `arg' for consistency.  Call ioctl_termios for common fhandler_termios
ioctl handling.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call ioctl_termios for common
fhandler_termios ioctl handling.
(fhandler_pty_master::ioctl): Ditto.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Implement new function.
(fhandler_termios::ioctl_termios): Ditto.  Implements TIOCSCTTY handling.
* syscalls.cc (stat_worker): Set /dev/tty device info when appropriate.
* termios.cc (tcgetpgrp): Avoid extraneous "isatty" check.
(tcgetsid): Implement new function.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 253.
* include/sys/termios.h (TIOCSCTTY): Define.
@
text
@d542 1
a542 1
  myself->set_ctty (get_ttyp (), flags, this);
d617 1
a617 1
  termios_printf ("tty%d, write(%x, %d)", get_unit (), ptr, len);
d894 1
a894 1
fhandler_pty_slave::dup (fhandler_base *child)
d896 1
d903 1
a903 1
fhandler_pty_master::dup (fhandler_base *child)
d951 1
a951 1
  int res = ioctl_termios (cmd, (int) arg);
d1188 9
a1196 3
fhandler_pty_master::fhandler_pty_master ()
  : fhandler_pty_common (), pktmode (0), need_nl (0), dwProcessId (0)
{
a1201 13
  /* Note that allocate returns with the tty lock set if it was successful. */
  int unit = cygwin_shared->tty.allocate ();
  if (unit < 0)
    return 0;

  dev().parse (DEV_TTYM_MAJOR, unit);
  if (!setup ())
    {
      lock_ttys::release ();
      return 0;
    }
  lock_ttys::release ();
  set_flags ((flags & ~O_TEXT) | O_BINARY);
a1202 1

d1204 2
d1207 6
a1212 2
  char buf[sizeof ("opened pty master for ttyNNNNNNNNNNN")];
  __small_sprintf (buf, "opened pty master for tty%d", get_unit ());
a1213 1
  return 1;
d1226 1
a1226 1
  termios_printf ("tty%d <%p,%p> closing", get_unit (), get_handle (), get_output_handle ());
d1246 2
a1274 4
      if (!ForceCloseHandle (from_master))
	termios_printf ("error closing from_master %p, %E", from_master);
      if (!ForceCloseHandle (to_master))
	termios_printf ("error closing from_master %p, %E", to_master);
d1276 7
d1293 9
d1376 1
a1376 1
  int res = ioctl_termios (cmd, (int) arg);
d1423 1
a1423 1
  __small_sprintf (buf, "/dev/tty%d", get_unit ());
d1602 9
a1610 2
  tty& t = *cygwin_shared->tty[get_unit ()];
  _tc = (tty_min *)&t;
a1616 13
  /* Create communication pipes */
  char pipename[sizeof("ptyNNNN-from-master")];
  __small_sprintf (pipename, "pty%d-from-master", get_unit ());
  res = fhandler_pipe::create_selectable (&sec_none, from_master,
					  get_output_handle (), 128 * 1024,
					  pipename);
  if (res)
    {
      errstr = "input pipe";
      goto err;
    }

  ProtectHandle1 (get_output_handle (), to_pty);
d1621 2
a1622 1
  __small_sprintf (pipename, "pty%d-to-master", get_unit ());
a1631 1
  need_nl = 0;
d1651 1
a1651 1
  errstr = shared_name (buf, OUTPUT_MUTEX, t.get_unit ());
d1655 1
a1655 1
  errstr = shared_name (buf, INPUT_MUTEX, t.get_unit ());
d1662 1
a1662 1
		   &installation_key, get_unit ());
d1685 3
a1687 1
  termios_printf ("tty%d opened - from_pty %p, to_pty %p", t.get_unit (),
d1701 1
a1701 2
  termios_printf ("tty%d open failed - failed to create %s", t.get_unit (),
		  errstr);
@


1.240
log
@* fhandler_tty.cc (fhandler_pty_slave::open): Clarify debugging output.
(fhandler_pty_slave::open): Change ENOENT to ENXIO when can't open a tty.
@
text
@d148 1
a148 1
	  debug_printf ("error writing to pipe %E");
d950 3
d1364 4
@


1.239
log
@	* fhandler_console.cc (fhandler_console::ioctl): Fetch console events
	using PeekConsoleInput and return only key down events in buf.
	* fhandler_tty.cc (fhandler_pty_slave::ioctl): Always return EINVAL
	if PeekNamedPipe fails.
	(fhandler_pty_master::ioctl): Ditto.
@
text
@d460 1
a460 1
	    termios_printf ("dup handles directly since I'm allmighty.");
d525 4
a528 1
  __seterrno ();
@


1.238
log
@	* fhandler_tty.cc (fhandler_pty_slave::ioctl): Drop FIONBIO case.
	Handle FIONREAD.
	(fhandler_pty_master::ioctl): Ditto.  Call fhandler_base::ioctl to
	decode default condition.
	* fhandler_console.cc (fhandler_console::ioctl): Handle FIONREAD.
@
text
@d984 1
a984 1
	    __seterrno ();
d1384 1
a1384 1
	    __seterrno ();
@


1.237
log
@Corinna Vinschen <corinna@@vinschen.de>
* fhandler.cc: Add #include for asm/socket.h for dealing with FIONREAD.
(fhandler_base::ioctl): Special-case errno for FIONREAD.
* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Rename parameter for consistency.
Call fhandler_base::ioctl to decode default condition.
* fhandler_serial.cc (fhandler_serial::ioctl): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call fhandler_base::ioctl to
decode default condition.
* fhandler_windows.cc (fhandler_windows::ioctl): Ditto.
@
text
@d27 1
a963 4
    case FIONBIO:
      set_nonblocking (*(int *) arg);
      retval = 0;
      goto out;
d979 15
d1379 10
a1388 2
    case FIONBIO:
      set_nonblocking (*(int *) arg);
d1391 1
a1391 2
      set_errno (EINVAL);
      return -1;
@


1.236
log
@* fhandler_tty.cc (fhandler_pty_slave::ioctl): Remove erroneous support for
TIOCLINUX for pty.  Get rid of unneeded EINVAL handling in wake of tty removal.
Remove now-unneeded variable.
@
text
@d983 1
a983 2
      set_errno (EINVAL);
      return -1;
@


1.235
log
@* fhandler.cc (fhandler_base::open_with_arch): Call close_on_exec last to avoid
setting close_on_exec for archetype.
* fhandler_tty.cc (fhandler_pty_master::setup): Protect {from,to}_pty handles.
Use consistent naming in debug output.  Use inheritable handles and...
(fhandler_pty_master::fixup_after_fork): ...avoid duplicating handles here.
(fhandler_pty_slave::open): Don't set close_on_exec flag here.
@
text
@a961 3
    case TIOCLINUX:
    case KDGKBMETA:
    case KDSKBMETA:
a990 1
  int val;
a1006 11
    case TIOCLINUX:
      val = *(unsigned char *) arg;
      if (val != 6)
	get_ttyp ()->ioctl_retval = -EINVAL;
      break;
    case KDGKBMETA:
      get_ttyp ()->ioctl_retval = -EINVAL;
      break;
    case KDSKBMETA:
      get_ttyp ()->ioctl_retval = -EINVAL;
      break;
@


1.234
log
@	* fhandler_tty.cc (fhandler_pty_master::setup): Create pty pipes
	non-inheritable.
@
text
@a516 1
  set_close_on_exec (!!(flags & O_CLOEXEC));
d539 1
a539 1
  cygheap->manage_console_count ("fhandler_pty_slave::setup", 1);
d1588 1
a1588 1
  res = fhandler_pipe::create_selectable (&sec_none_nih, from_master,
d1597 1
d1603 1
a1603 1
  res = fhandler_pipe::create_selectable (&sec_none_nih, get_io_handle (),
d1611 1
d1666 1
a1666 1
  termios_printf ("tty%d opened - from_slave %p, to_slave %p", t.get_unit (),
a1692 6
      if (!DuplicateHandle (parent, arch->from_master, GetCurrentProcess (),
			    &arch->from_master, 0, false, DUPLICATE_SAME_ACCESS))
	system_printf ("couldn't duplicate from_parent(%p), %E", arch->from_master);
      if (!DuplicateHandle (parent, arch->to_master, GetCurrentProcess (),
			    &arch->to_master, 0, false, DUPLICATE_SAME_ACCESS))
	system_printf ("couldn't duplicate to_parent(%p), %E", arch->from_master);
@


1.233
log
@	* fhandler_tty.cc (fhandler_pty_master::setup): Fix crash in debug
	output.
@
text
@d1589 1
a1589 1
  res = fhandler_pipe::create_selectable (&sec_none, from_master,
d1603 1
a1603 1
  res = fhandler_pipe::create_selectable (&sec_none, get_io_handle (),
@


1.232
log
@* cygheap.h (init_cygheap::ctty_on_hold): Remove conditionalized variable.
* dcrt0.cc (do_exit): Remove code which handled CYGWIN=tty style ttys.
* devices.in: Remove "/dev/ttym".
* dtable.cc: Rename tty to pty where appropriate throughout.
(dtable::stdio_init): Use new t->is_console rather than using now-deleted hwnd
element in tty structure.
(dtable::init_std_file_from_handle): Remove code which handled CYGWIN=tty style
ttys.
(fh_alloc): Ditto.
* fhandler.h: Rename tty to pty where appropriate.
(fhandler_pty_common): Delete output_done_event, ioctl_request_event,
ioctl_done_event.
(fhandler_pty_master::setup): Delete argument.
(fhandler_tty_master): Delete.
(fhandler_union): Delete __tty_master.
* fhandler_console.cc (use_tty): Delete.
(fhandler_console::get_tty_stuff): Set is_console to true rather than calling
sethwnd.
(fhandler_console::send_winch_maybe): Remove CYGWIN=tty considerations.
(fhandler_console::input_tcsetattr): Ditto.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use new t->is_console
rather than using now-deleted hwnd element in tty structure.
* fhandler_tty.cc: Rename tty to pty where appropriate throughout.
(tty_master): Delete.
(process_input): Ditto.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::*): Ditto.
(fhandler_pty_master::process_slave_output): Remove CYGWIN=tty considerations.
(fhandler_pty_slave::open): Ditto for *_done_event.
(fhandler_pty_slave::write): Ditto.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_slave::fch_open_handles): Ditto.
(fhandler_pty_slave::fch_set_sd): Ditto.
(fhandler_pty_slave::fch_close_handles): Ditto.
(fhandler_pty_common::close): Ditto.
(fhandler_pty_master::setup): Ditto.  Remove now-unneeded ispty parameter.
(fhandler_pty_master::open): Reflect argument removal for tty::allocate.
* select.cc: Rename tty to pty where appropriate throughout.
* sigproc.cc (proc_subproc): Remove CYGWIN=tty considerations.
* tty.cc (ttyslot): Accommodate CYGWIN=tty removal.
(tty_list::init_session): Ditto.
(tty_list::attach): Ditto.
(tty::create_master): Delete.
(tty_list::terminate): Ditto.
(tty_list::allocate): Delete "with_console" parameter.  Remove CYGWIN=tty
considerations.
(tty::init): Set is_console = false.  Use 'false' for was_opened since it is a
boolean.
* tty.h (*_{DONE,REQUEST}_EVENT): Delete.
(tty_min::is_console): Declare new field which replaces hwnd.
(tty_min::gethwnd): Delete.
(tty_min::sethwnd): Ditto.
(tty_list::allocate): Delete parameter.
(tty_list::terminate): Delete declaration.
* include/sys/cygwin.h (PID_USETTY): Redefine to PID_UNUSED1 and change comment
to reflect its availability.
@
text
@d1679 2
a1680 1
  termios_printf ("tty%d open failed - failed to create %s", errstr);
@


1.231
log
@* fhandler_tty_slave.cc (fhandler_tty_slave::fhandler_tty_slave): Revert
previous change since unit 0 is perfectly valid.
@
text
@a44 13
/* tty master stuff */

fhandler_tty_master NO_COPY *tty_master;

static void WINAPI process_input (void *) __attribute__((noreturn));		// Input queue thread
static void WINAPI process_output (void *) __attribute__((noreturn));		// Output queue thread
static void WINAPI process_ioctl (void *) __attribute__((noreturn));		// Ioctl requests thread

fhandler_tty_master::fhandler_tty_master ()
  : fhandler_pty_master (), console (NULL)
{
}

d46 1
a46 1
fhandler_tty_slave::get_unit ()
a50 35
void
fhandler_tty_master::set_winsize (bool sendSIGWINCH)
{
  winsize w;
  console->ioctl (TIOCGWINSZ, &w);
  get_ttyp ()->winsize = w;
  if (sendSIGWINCH)
    tc ()->kill_pgrp (SIGWINCH);
}

int
fhandler_tty_master::init ()
{
  termios_printf ("Creating master for tty%d", get_unit ());

  if (init_console ())
    {
      termios_printf ("can't create fhandler");
      return -1;
    }

  if (!setup (false))
    return 1;

  set_winsize (false);

  set_close_on_exec (true);

  new cygthread (process_input, cygself, "ttyin");
  new cygthread (process_ioctl, cygself, "ttyioctl");
  new cygthread (process_output, cygself, "ttyout");

  return 0;
}

d64 1
a64 1
fhandler_tty_common::__acquire_output_mutex (const char *fn, int ln,
d68 1
a68 1
    strace.prntf (_STRACE_TERMIOS, fn, "(%d): tty output_mutex (%p): waiting %d ms", ln, output_mutex, ms);
d74 1
a74 1
	strace.prntf (_STRACE_TERMIOS, fn, "(%d): tty output_mutex: acquired", ln, res);
d87 1
a87 1
fhandler_tty_common::__release_output_mutex (const char *fn, int ln)
d93 1
a93 1
	strace.prntf (_STRACE_TERMIOS, fn, "(%d): tty output_mutex(%p) released", ln, output_mutex);
d111 1
a111 1
/* Process tty input. */
a118 1
//  WaitForSingleObject (output_done_event, INFINITE);
a169 15
static void WINAPI
process_input (void *)
{
  char rawbuf[INP_BUFFER_SIZE];

  while (1)
    {
      size_t nraw = INP_BUFFER_SIZE;
      tty_master->console->read ((void *) rawbuf, nraw);
      if (tty_master->line_edit (rawbuf, nraw, tty_master->get_ttyp ()->ti)
	  == line_edit_signalled)
	tty_master->console->eat_readahead (-1);
    }
}

d184 1
a184 1
/* Process tty output requests */
a249 6
	      if (is_tty_master ())
		{
		  Sleep (10);
		  continue;
		}

a274 2
      if (output_done_event != NULL)
	  SetEvent (output_done_event);
d355 1
a355 22
static void WINAPI
process_output (void *)
{
  char buf[OUT_BUFFER_SIZE * 2];

  for (;;)
    {
      int n = tty_master->process_slave_output (buf, OUT_BUFFER_SIZE, 0);
      if (n > 0)
	{
	  n = tty_master->console->write ((void *) buf, (size_t) n);
	  tty_master->get_ttyp ()->write_error = n == -1 ? get_errno () : 0;
	}
      else
	{
	  if (n < 0)
	    termios_printf ("ReadFile %E");
	  ExitThread (0);
	}
    }
}

d357 2
a358 24
/* Process tty ioctl requests */

static void WINAPI
process_ioctl (void *)
{
  while (1)
    {
      WaitForSingleObject (tty_master->ioctl_request_event, INFINITE);
      termios_printf ("ioctl() request");
      tty *ttyp = tty_master->get_ttyp ();
      ttyp->ioctl_retval =
      tty_master->console->ioctl (ttyp->cmd,
				  (ttyp->cmd == KDSKBMETA)
				  ? (void *) ttyp->arg.value
				  : (void *) &ttyp->arg);
      SetEvent (tty_master->ioctl_done_event);
    }
}

/**********************************************************************/
/* Tty slave stuff */

fhandler_tty_slave::fhandler_tty_slave (int unit)
  : fhandler_tty_common (), inuse (NULL)
a363 2
/* FIXME: This function needs to close handles when it has
   a failing condition. */
d365 1
a365 1
fhandler_tty_slave::open (int flags, mode_t)
d367 1
a367 1
  HANDLE tty_owner, from_master_local, to_master_local;
d371 1
a371 2
    &ioctl_done_event, &ioctl_request_event, &output_done_event,
    &output_mutex, &to_master_local, &tty_owner,
a386 8
  /* output_done_event may or may not exist.  It will exist if the tty
     was opened by fhandler_tty_master::init, normally called at
     startup if use_tty is non-zero.  It will not exist if this is a
     pty opened by fhandler_pty_master::open.  In the former case, tty
     output is handled by a separate thread which controls output.  */
  shared_name (buf, OUTPUT_DONE_EVENT, get_unit ());
  output_done_event = OpenEvent (MAXIMUM_ALLOWED, TRUE, buf);

a405 7
  /* The ioctl events may or may not exist.  See output_done_event,
     above.  */
  shared_name (buf, IOCTL_REQUEST_EVENT, get_unit ());
  ioctl_request_event = OpenEvent (MAXIMUM_ALLOWED, TRUE, buf);
  shared_name (buf, IOCTL_DONE_EVENT, get_unit ());
  ioctl_done_event = OpenEvent (MAXIMUM_ALLOWED, TRUE, buf);

d425 1
a425 1
      errmsg = "tty handles have been closed";
d448 1
a448 1
      tty_owner = GetCurrentProcess ();
d454 1
a454 1
	termios_printf ("*** couldn't find tty master");
d457 2
a458 2
	  tty_owner = OpenProcess (PROCESS_DUP_HANDLE, FALSE, p->dwProcessId);
	  if (tty_owner)
d462 1
a462 1
  if (tty_owner)
d464 1
a464 1
      if (!DuplicateHandle (tty_owner, get_ttyp ()->from_master,
d473 1
a473 1
      if (!DuplicateHandle (tty_owner, get_ttyp ()->to_master,
d480 2
a481 2
      if (tty_owner != GetCurrentProcess ())
	CloseHandle (tty_owner);
d489 1
a489 1
      __small_sprintf (buf, "\\\\.\\pipe\\cygwin-%S-tty%d-master-ctl",
d510 1
a510 1
  termios_printf ("duplicated from_master %p->%p from tty_owner",
d512 1
a512 1
  termios_printf ("duplicated to_master %p->%p from tty_owner",
d520 1
a520 2
  if (cygheap->manage_console_count ("fhandler_tty_slave::open", 1) == 1
      && !output_done_event)
d536 1
a536 1
fhandler_tty_slave::open_setup (int flags)
d540 1
a540 1
  cygheap->manage_console_count ("fhandler_tty_slave::setup", 1);
d545 1
a545 1
fhandler_tty_slave::cleanup ()
d547 2
a548 2
  /* This used to always call fhandler_tty_common::close when hExeced but that
     caused multiple closes of the handles associated with this tty.  Since
d552 1
a552 1
  cygheap->manage_console_count ("fhandler_tty_slave::close", -1);
d557 1
a557 1
fhandler_tty_slave::close ()
d562 1
a562 1
  return fhandler_tty_common::close ();
d566 1
a566 1
fhandler_tty_slave::init (HANDLE h, DWORD a, mode_t)
d584 1
a584 1
	 tty process group leader.
d589 1
a589 1
	 tty is a non-cygwin process or we've been started directly
d606 1
a606 1
fhandler_tty_slave::write (const void *ptr, size_t len)
d628 1
a628 1
	 This is less than optimal, but the alternative slows down tty
a651 8

      if (output_done_event != NULL)
	{
	  DWORD rc;
	  DWORD x = n * 1000;
	  rc = WaitForSingleObject (output_done_event, x);
	  termios_printf ("waited %d ms for output_done_event, WFSO %d", x, rc);
	}
d658 1
a658 1
fhandler_tty_slave::read (void *ptr, size_t& len)
d891 1
a891 1
fhandler_tty_slave::dup (fhandler_base *child)
d893 1
a893 1
  cygheap->manage_console_count ("fhandler_tty_slave::dup", 1);
d906 1
a906 1
fhandler_tty_slave::tcgetattr (struct termios *t)
d913 1
a913 1
fhandler_tty_slave::tcsetattr (int, const struct termios *t)
d922 1
a922 1
fhandler_tty_slave::tcflush (int queue)
d944 1
a944 1
fhandler_tty_slave::ioctl (unsigned int cmd, void *arg)
a999 2
      if (ioctl_request_event)
	SetEvent (ioctl_request_event);
a1000 2
      if (ioctl_done_event)
	WaitForSingleObject (ioctl_done_event, INFINITE);
d1008 2
a1009 12
	  if (ioctl_request_event)
	    {
	      get_ttyp ()->ioctl_retval = -EINVAL;
	      SetEvent (ioctl_request_event);
	    }
	  else
	    {
	      get_ttyp ()->winsize = *(struct winsize *) arg;
	      killsys (-get_ttyp ()->getpgid (), SIGWINCH);
	    }
	  if (ioctl_done_event)
	    WaitForSingleObject (ioctl_done_event, INFINITE);
d1014 2
a1015 9
      if (val != 6 || !ioctl_request_event || !ioctl_done_event)
	  get_ttyp ()->ioctl_retval = -EINVAL;
      else
	{
	  get_ttyp ()->arg.value = val;
	  SetEvent (ioctl_request_event);
	  WaitForSingleObject (ioctl_done_event, INFINITE);
	  *(unsigned char *) arg = (unsigned char) (get_ttyp ()->arg.value);
	}
d1018 1
a1018 9
      if (ioctl_request_event)
	{
	  SetEvent (ioctl_request_event);
	  if (ioctl_done_event)
	    WaitForSingleObject (ioctl_done_event, INFINITE);
	  *(int *) arg = get_ttyp ()->arg.value;
	}
      else
	get_ttyp ()->ioctl_retval = -EINVAL;
d1021 1
a1021 9
      if (ioctl_request_event)
	{
	  get_ttyp ()->arg.value = (int) arg;
	  SetEvent (ioctl_request_event);
	  if (ioctl_done_event)
	    WaitForSingleObject (ioctl_done_event, INFINITE);
	}
      else
	get_ttyp ()->ioctl_retval = -EINVAL;
d1039 1
a1039 1
fhandler_tty_slave::fstat (struct __stat64 *st)
d1070 1
a1070 1
fhandler_tty_slave::fch_open_handles ()
a1085 7
  /* These members are optional, no error checking */
  shared_name (buf, OUTPUT_DONE_EVENT, get_unit ());
  output_done_event = OpenEvent (WRITE_DAC | WRITE_OWNER, TRUE, buf);
  shared_name (buf, IOCTL_REQUEST_EVENT, get_unit ());
  ioctl_request_event = OpenEvent (WRITE_DAC | WRITE_OWNER, TRUE, buf);
  shared_name (buf, IOCTL_DONE_EVENT, get_unit ());
  ioctl_done_event = OpenEvent (WRITE_DAC | WRITE_OWNER, TRUE, buf);
d1090 1
a1090 1
   descriptor on all objects representing the tty. */
d1092 1
a1092 1
fhandler_tty_slave::fch_set_sd (security_descriptor &sd, bool chown)
d1100 1
a1100 7
      && !set_object_sd (inuse, sd, chown)
      && (!output_done_event
	  || !set_object_sd (output_done_event, sd, chown))
      && (!ioctl_request_event
	  || !set_object_sd (ioctl_request_event, sd, chown))
      && (!ioctl_done_event
	  || !set_object_sd (ioctl_done_event, sd, chown)))
a1105 6
  if (!output_done_event)
      set_object_sd (output_done_event, sd_old, chown);
  if (!ioctl_request_event)
      set_object_sd (ioctl_request_event, sd_old, chown);
  if (!ioctl_done_event)
      set_object_sd (ioctl_done_event, sd_old, chown);
d1110 1
a1110 1
   the tty. */
d1112 1
a1112 1
fhandler_tty_slave::fch_close_handles ()
a1115 3
  close_maybe (output_done_event);
  close_maybe (ioctl_done_event);
  close_maybe (ioctl_request_event);
d1123 1
a1123 1
fhandler_tty_slave::fchmod (mode_t mode)
d1149 1
a1149 1
fhandler_tty_slave::fchown (__uid32_t uid, __gid32_t gid)
d1187 1
a1187 1
  : fhandler_tty_common (), pktmode (0), need_nl (0), dwProcessId (0)
d1195 1
a1195 1
  int unit = cygwin_shared->tty.allocate (false);
d1200 1
a1200 1
  if (!setup (true))
d1218 1
a1218 1
fhandler_tty_common::lseek (_off64_t, int)
d1225 1
a1225 1
fhandler_tty_common::close ()
a1227 6
  if (output_done_event && !CloseHandle (output_done_event))
    termios_printf ("CloseHandle (output_done_event), %E");
  if (ioctl_done_event && !CloseHandle (ioctl_done_event))
    termios_printf ("CloseHandle (ioctl_done_event), %E");
  if (ioctl_request_event && !CloseHandle (ioctl_request_event))
    termios_printf ("CloseHandle (ioctl_request_event), %E");
d1268 1
a1268 1
	  __small_sprintf (buf, "\\\\.\\pipe\\cygwin-%S-tty%d-master-ctl",
d1279 1
a1279 1
  fhandler_tty_common::close ();
d1404 1
a1404 1
fhandler_tty_common::set_close_on_exec (bool val)
d1411 1
a1411 1
fhandler_tty_slave::fixup_after_fork (HANDLE parent)
d1414 1
a1414 1
  // fhandler_tty_common::fixup_after_fork (parent);
d1419 1
a1419 1
fhandler_tty_slave::fixup_after_exec ()
a1424 15
int
fhandler_tty_master::init_console ()
{
  console = (fhandler_console *) build_fh_dev (*console_dev, "/dev/ttym_console");
  if (console == NULL)
    {
      termios_printf ("console creation failed?");
      return -1;
    }

  console->init (NULL, GENERIC_READ | GENERIC_WRITE, O_BINARY);
  cygheap->manage_console_count ("fhandler_tty_master::init_console", -1, true);
  return 0;
}

d1572 1
a1572 1
fhandler_pty_master::setup (bool ispty)
d1587 5
a1591 5
  char pipename[sizeof("ttyNNNN-from-master")];
  __small_sprintf (pipename, "tty%d-from-master", get_unit ());
  res = fhandler_pipe::create_selectable (ispty ? &sec_none : &sec_none_nih,
					  from_master, get_output_handle (),
					  128 * 1024, pipename);
d1602 3
a1604 4
  __small_sprintf (pipename, "tty%d-to-master", get_unit ());
  res = fhandler_pipe::create_selectable (ispty ? &sec_none : &sec_none_nih,
					  get_io_handle (), to_master,
					  128 * 1024, pipename);
a1620 13
  /* Create synchronisation events */

  if (!ispty)
    {
      if (!(output_done_event = t.get_event (errstr = OUTPUT_DONE_EVENT, &sa)))
	goto err;
      if (!(ioctl_done_event = t.get_event (errstr = IOCTL_DONE_EVENT, &sa)))
	goto err;
      if (!(ioctl_request_event = t.get_event (errstr = IOCTL_REQUEST_EVENT,
					       &sa)))
	goto err;
    }

d1641 1
a1641 1
  __small_sprintf (buf, "\\\\.\\pipe\\cygwin-%S-tty%d-master-ctl",
a1660 2
  // /* screws up tty master */ ProtectHandle1INH (output_mutex, output_mutex);
  // /* screws up tty master */ ProtectHandle1INH (input_mutex, input_mutex);
a1672 3
  close_maybe (output_done_event);
  close_maybe (ioctl_done_event);
  close_maybe (ioctl_request_event);
d1687 1
a1687 1
  fhandler_tty_master *arch = (fhandler_tty_master *) archetype;
@


1.230
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@d475 1
a475 1
  if (unit > 0)
@


1.229
log
@whitespace elimination
@
text
@d475 1
a475 1
  if (unit >= 0)
@


1.228
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Only raise SIGPIPE
when writing.
* fhandler.h: Include "tty.h".
(fhandler_termios::_tc): Rename from tc.
(fhandler_termios::tc): New method.
(fhandler_termios::tcinit): Remove an argument.
(fhandler_termios::get_ttyp): Use method to retrieve value.
(fhandler_console::console_state): Move here.
(fhandler_console::dev_state): Delete.
(fhandler_console::shared_console_info): Define.
(fhandler_console::open_shared_console): Move this function under
fhandler_console umbrella.
(fhandler_console::tc): Define.  Return static value.
(fhandler_console::focus_aware): Accommodate deletion of dev_state.
(fhandler_console): Add tty_list::get_cttyp as a friend.
* fhandler_console.cc (dev_state): Redefine as a pointer within
shared_console_info and change dev-> to dev.  throughout.
(fhandler_console::shared_console_info): Move into fhandler_console.
(fhandler_console::open_shared_console): Move into fhandler_console change
argument to simple bool.
(enum_windows): Accommodate changes to console_state and open_shared_console.
(console_unit::console_unit): Ditto.
(fhandler_console::get_tty_stuff): Accommodate change to dev_state.
(tty_list::get_cttyp): Accommodate change to
handler_console::shared_console_info.
(fhandler_console::read): Accommodate change from tc to tc ().
(fhandler_console::set_input_state): Ditto.
(fhandler_console::open): Accommodate tcinit argument change and change from tc
to tc().
(fhandler_console::input_tcsetattr): Accomodate change from tc to tc().
(fhandler_console::input_tcsetattr): Ditto.
(fhandler_console::write_normal): Ditto.
(fhandler_console::init): Ditto.
(fhandler_console::igncr_enabled): Ditto.
* fhandler_termios.cc (fhandler_termios::tcinit): Remove first argument.
Expect tc() to have been set up first.  Use tc() rather than tc.
(fhandler_termios::tcsetpgrp): Accomodate change from tc to tc().
(fhandler_termios::tcgetpgrp): Ditto.
(fhandler_termios::bg_check): Ditto.
(fhandler_termios::line_edit: Ditto.
(fhandler_tty_master::set_winsize): Ditto.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::init): Ditto.
(fhandler_pty_master::write): Ditto.
(fhandler_pty_master::setup): Ditto.  Accommodate change in arguments to
tcinit.
(fhandler_tty_slave::fch_open_handles): Set _tc directly.
(tty_min::is_orphaned_process_group): Don't assume that parent pid exists.
* pinfo.cc (_pinfo::set_ctty): Reset myself->{pgid,sid} here if we were started
by a non-Cygwin process but the tty exists.
* shared_info.h (console_state): Delete from here.
* tty.h: Make multiple inclusion safe.
@
text
@d1236 1
a1236 1
         then fake uid and gid to strict, system-like values. */
d1693 1
a1693 1
      	{
@


1.227
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d71 1
a71 1
    tc->kill_pgrp (SIGWINCH);
d496 3
a498 1
  tcinit (cygwin_shared->tty[get_unit ()], false);
d721 1
a721 1
      pinfo p (tc->getpgid ());
d729 1
a729 1
	  tc->setpgid (myself->pgid);
d1253 1
a1253 1
  tc = cygwin_shared->tty[get_unit ()];
d1501 1
a1501 1
  termios ti = tc->ti;
d1801 1
d1803 1
a1803 1
  tcinit (&t, true);		/* Set termios information.  Force initialization. */
@


1.226
log
@* fhandler.h (fhandler_dev_dsp): Cosmetic change.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Put back
Sleep(10) for tty_master case.
* sigproc.cc (stopped_or_terminated): Don't consider a pid which has been
reaped to be terminated.
@
text
@d61 1
a61 1
  return dev () == FH_TTY ? myself->ctty : dev ().minor;
d303 1
a303 1
		  termios_printf ("PeekNamedPipe failed, %E");
d472 1
a472 1
fhandler_tty_slave::fhandler_tty_slave (int ntty)
d475 2
a476 2
  if (ntty >= 0)
    dev ().parse (DEV_TTYS_MAJOR, ntty);
d1089 2
a1090 1
      && myself->ctty == get_unit () && (get_ttyp ()->ti.c_lflag & TOSTOP))
d1394 2
a1395 2
  int ntty = cygwin_shared->tty.allocate (false);
  if (ntty < 0)
d1398 1
a1398 1
  dev().devn = FHDEV (DEV_TTYM_MAJOR, ntty);
d1635 4
a1638 1
    return -1;
d1864 1
a1864 1
  errstr = shared_name (buf, OUTPUT_MUTEX, t.ntty);
d1868 1
a1868 1
  errstr = shared_name (buf, INPUT_MUTEX, t.ntty);
d1900 1
a1900 1
  termios_printf ("tty%d opened - from_slave %p, to_slave %p", t.ntty,
@


1.225
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d315 4
a318 1
		continue;
@


1.224
log
@	* pinfo.h (class push_process_state): New class to push a process state
	flag temporarily into myself->process_state.
	* fhandler_console.cc (fhandler_console::read): Add push_process_state
	handler.
	(fhandler_console::write): Call bg_check from here.  Add
	push_process_state handler.
	* fhandler_tty.cc (fhandler_tty_slave::write): Ditto.
	(fhandler_tty_slave::read): Ditto.
	(fhandler_pty_master::write): Ditto.
	(fhandler_pty_master::read): Ditto.
	* syscalls.cc (readv): Remove bg_check call and setting process state.
	(writev): Ditto.
@
text
@d116 1
a116 1
    strace.prntf (_STRACE_TERMIOS, fn, "(%d): tty output_mutex: waiting %d ms", ln, ms);
d141 1
a141 1
	strace.prntf (_STRACE_TERMIOS, fn, "(%d): tty output_mutex released", ln);
d145 1
a145 1
      termios_printf ("released at %s:%d, osi %d", fn, ln, osi);
d302 4
a305 1
		goto err;
d313 4
a330 1
		
d333 5
a337 2
	  if (ReadFile (handle, outbuf, rlen, &n, NULL) == FALSE)
	    goto err;
d343 1
a343 1
	SetEvent (output_done_event);
d432 6
a437 1
      if (n <= 0)
a442 2
      n = tty_master->console->write ((void *) buf, (size_t) n);
      tty_master->get_ttyp ()->write_error = n == -1 ? get_errno () : 0;
d469 1
a469 1
fhandler_tty_slave::fhandler_tty_slave ()
d471 4
a474 1
{}
a489 2
  const char *errmsg = NULL;

a492 12
  if (get_device () == FH_TTY)
    dev().tty_to_real_device ();
  fhandler_tty_slave *arch = (fhandler_tty_slave *) cygheap->fdtab.find_archetype (pc.dev);
  if (arch)
    {
      *this = *(fhandler_tty_slave *) arch;
      termios_printf ("copied fhandler_tty_slave archetype");
      set_flags ((flags & ~O_TEXT) | O_BINARY);
      cygheap->manage_console_count ("fhandler_tty_slave::open<arch>", 1);
      goto out;
    }

a496 1
  set_flags ((flags & ~O_TEXT) | O_BINARY);
d508 2
a650 13

  // FIXME: Do this better someday
  arch = (fhandler_tty_slave *) cmalloc_abort (HEAP_ARCHETYPES, sizeof (*this));
  *((fhandler_tty_slave **) cygheap->fdtab.add_archetype ()) = arch;
  archetype = arch;
  *arch = *this;

out:
  usecount = 0;
  arch->usecount++;
  report_tty_counts (this, "opened", "");
  myself->set_ctty (get_ttyp (), flags, arch);

d664 11
a674 2
int
fhandler_tty_slave::close ()
a681 2

  archetype->usecount--;
d683 1
d685 3
a687 10
  if (archetype->usecount)
    {
#ifdef DEBUGGING
      if (archetype->usecount < 0)
	system_printf ("error: usecount %d", archetype->usecount);
#endif
      termios_printf ("just returning because archetype usecount is != 0");
      return 0;
    }

d695 1
a695 1
fhandler_tty_slave::init (HANDLE f, DWORD a, mode_t)
d707 1
a707 1
  int ret = open (flags);
d728 2
a729 2
  if (f != INVALID_HANDLE_VALUE)
    CloseHandle (f);	/* Reopened by open */
a1029 17
  fhandler_tty_slave *arch = (fhandler_tty_slave *) archetype;
  /* In dtable::dup_worker, the path_conv member has already been assigned
     from "this" to "child".  Part of this assigment (path_conv::operator=)
     is to allocate memory for the strings "path" and "normalized_path from
     cygheap.  The below `child = *arch' statement will overwrite child's
     path_conv again, this time from "*arch".  By doing that, it will allocate
     new strings from cygheap, overwriting the old pointer values.  Thus, the
     old allocated strings are lost, and we're leaking memory for each tty dup,
     unless we free the strings here.
     FIXME: We can't redefine path_conv::operator= so that it frees the old
     strings.  Probably it would be most helpful to copy only the required
     members from *arch, rather than copying everything. */
  child->pc.free_strings ();
  *(fhandler_tty_slave *) child = *arch;
  child->set_flags (get_flags ());
  child->usecount = 0;
  arch->usecount++;
d1031 1
a1031 1
  report_tty_counts (child, "duped", "");
a1037 7
  fhandler_tty_master *arch = (fhandler_tty_master *) archetype;
  /* See comment in fhandler_tty_slave::dup. */
  child->pc.free_strings ();
  *(fhandler_tty_master *) child = *arch;
  child->set_flags (get_flags ());
  child->usecount = 0;
  arch->usecount++;
d1404 1
a1404 6
  /* FIXME: Do this better someday */
  fhandler_pty_master *arch = (fhandler_tty_master *) cmalloc_abort (HEAP_ARCHETYPES, sizeof (*this));
  *((fhandler_pty_master **) cygheap->fdtab.add_archetype ()) = arch;
  archetype = arch;
  *arch = *this;
  arch->dwProcessId = GetCurrentProcessId ();
a1405 2
  usecount = 0;
  arch->usecount++;
d1444 6
a1456 2
  archetype->usecount--;
  report_tty_counts (this, "closing master", "");
a1457 11
  if (archetype->usecount)
    {
#ifdef DEBUGGING
      if (archetype->usecount < 0)
	system_printf ("error: usecount %d", archetype->usecount);
#endif
      termios_printf ("just returning because archetype usecount is != 0");
      return 0;
    }

  fhandler_tty_master *arch = (fhandler_tty_master *) archetype;
d1459 1
a1459 1
		  arch->from_master, arch->to_master, arch->dwProcessId);
d1462 1
a1462 1
      if (arch->master_ctl && get_ttyp ()->master_pid == myself->pid)
d1472 2
a1473 2
	  CloseHandle (arch->master_ctl);
	  arch->master_thread->detach ();
d1475 4
a1478 4
      if (!ForceCloseHandle (arch->from_master))
	termios_printf ("error closing from_master %p, %E", arch->from_master);
      if (!ForceCloseHandle (arch->to_master))
	termios_printf ("error closing from_master %p, %E", arch->to_master);
d1629 1
a1629 1
  console = (fhandler_console *) build_fh_dev (*console_dev, "/dev/ttym");
d1779 2
a1780 2
pty_master_thread (VOID *arg)           
{ 
d1782 1
a1782 1
} 
@


1.223
log
@	* fhandler.h (class fhandler_base): Remove uninterruptible_io status
	flag.
	(fhandler_base::ready_for_read): Remove declaration.
	(fhandler_socket::ready_for_read): Ditto.
	(fhandler_pipe::ready_for_read): Ditto.
	(fhandler_tty_master::is_slow): Remove.
	* fhandler_console.cc (fhandler_console::open): Drop setting
	uninterruptible_io.
	* fhandler_serial.cc (fhandler_serial::open): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Ditto.
	(fhandler_tty_master::init_console): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
	(fhandler_pipe::open): Ditto.
	(_pipe): Ditto.
	* select.cc (fhandler_pipe::ready_for_read): Remove.
	(fhandler_base::ready_for_read): Remove.
	* syscalls.cc (readv): Drop unneeded wait variable.  Remove entire test
	which might lead to calling ready_for_read.  Remove now unused label
	out.
@
text
@d749 4
d755 2
d816 7
d825 2
d866 1
d904 1
d1545 6
d1567 7
@


1.222
log
@	* fhandler_tty.cc (fhandler_tty_slave::read): Set WFMO timeout to 0 for
	nonblocking case.  Drop useless waiter variable.  Rewrite wait for
	input_available_event to use a switch statement.  Handle timeout and
	failure more gracefully.  Make restartable and cancelable.  Rewrite
	wait for input_mutex to use WFMO and a switch statement.  Handle
	timeout and failure more gracefully.  Make restartable and cancelable.
@
text
@d459 1
a459 3
{
  uninterruptible_io (true);
}
a1652 1
  console->uninterruptible_io (true);
@


1.221
log
@	* fhndler_tty.cc (andler_pty_master::process_slave_output): Make
	interruptible and cancelable.  Fix nonblocking case.
@
text
@a810 2
  DWORD rc;
  HANDLE w4[2];
d814 1
a814 1
  if (!ptr) /* Indicating tcflush(). */
a833 4
  w4[0] = signal_arrived;
  w4[1] = input_available_event;

  DWORD waiter = time_to_wait;
d836 4
a839 3
      rc = WaitForMultipleObjects (2, w4, FALSE, waiter);

      if (rc == WAIT_TIMEOUT)
d841 1
a841 1
	  termios_printf ("wait timed out, waiter %u", waiter);
d843 28
d872 4
a875 2

      if (rc == WAIT_FAILED)
d877 2
a878 1
	  termios_printf ("wait for input event failed, %E");
d880 1
a880 6
	}

      if (rc == WAIT_OBJECT_0)
	{
	  /* if we've received signal after successfully reading some data,
	     just return all data successfully read */
d882 4
a885 1
	    break;
d887 22
a908 7
	  len = (size_t) -1;
	  return;
	}

      rc = WaitForSingleObject (input_mutex, 1000);
      if (rc == WAIT_FAILED)
	{
d910 6
a915 6
	  break;
	}
      else if (rc == WAIT_TIMEOUT)
	{
	  termios_printf ("failed to acquire input mutex after input event arrived");
	  break;
a1015 3

      if (n)
	waiter = time_to_wait;
d1017 1
@


1.220
log
@	* advapi32.cc (AccessCheck): Remove.
	(PrivilegeCheck): Remove.
	(OpenThreadToken): Remove.
	* fhandler_tty.cc: Replace above functions throughout with their
	ntdll.dll equivalent.
	* security.cc: Ditto.
@
text
@d308 1
a308 1
	      if (n == 0 && (get_ttyp ()->ti.c_lflag & FLUSHO || !buf))
d310 1
a310 1
	      if (n == 0 && is_nonblocking ())
d314 9
a322 1
		  break;
d324 1
a324 2

	      Sleep (10);
@


1.219
log
@	* advapi32.cc (InitializeAcl): Remove.
	(AddAce): Remove.
	(FindFirstFreeAce): Remove.
	(GetAce): Remove.
	(InitializeSecurityDescriptor): Remove.
	(OpenProcessToken): Remove.
	* dcrt0.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* fhandler_tty.cc: Ditto.
	* flock.cc: Ditto.
	* pinfo.cc: Ditto.  Drop unnecessary error handling.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@a1646 1
  BOOL ret;
d1648 1
d1651 2
a1652 1
  while (!exit && (ConnectNamedPipe (master_ctl, NULL) || GetLastError () == ERROR_PIPE_CONNECTED))
d1656 1
a1656 1
      BOOL allow = FALSE;
d1682 3
a1684 1
      if (!OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, TRUE, &token))
d1686 2
a1687 1
	  termios_printf ("OpenThreadToken, %E");
d1691 4
a1694 3
      ret = AccessCheck (sd, token, access, &map, &ps, &len, &access, &allow);
      CloseHandle (token);
      if (!ret)
d1696 2
a1697 1
	  termios_printf ("AccessCheck, %E");
d1714 1
a1714 1
      if (allow)
@


1.218
log
@	* Fix various copyrights.
@
text
@d532 1
a532 1
    InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
d1308 1
a1308 1
  InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
d1337 1
a1337 1
  InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
d1799 1
a1799 1
  InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION);
@


1.217
log
@* cygheap.h (init_cygheap::ctty): Use base class so that console can join in
the fun.
* dtable.cc (dtable::stdio_init): Remove special-case call to set_console_ctty
().
* exceptions.cc (sigpacket::process): Conditionally flush terminal input on
certain signals.
* fhandler.h (fhandler_console::get_tty_stuff): Make non-static.
(fhandler_termios::get_ttyp): Move here.
(fhandler_termios::sigflush): Declare.
(fhandler_tty_common::get_ttyp): Delete.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass this as "arch"
argument.
(set_console_ctty): Delete.
(tty_list::get_tty): Just return pointer to shared console region, delaying
get_tty_stuff until open().
(fhandler_console::init): Treat NULL handle as signifying that console should
be opened with O_NOCTTY flag.  Rename handle argument to the more common 'h'.
* fhandler_termios.cc (fhandler_termios::sigflush): Define.
* fhandler_tty.cc (handler_tty_master::init_console): Pass NULL as first
argument to fhandler_console::init.
* pinfo.cc (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
Add extra debugging.
* pinfo.h (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
* sigproc.cc (handle_sigsuspend): Don't special-case non-main threads.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
@


1.216
log
@	* fhandler_tty.cc (fhandler_tty_slave::dup): Free path_conv strings
	to avoid memory leak.  Add comment.
	(fhandler_pty_master::dup): Ditto.
	* path.h (path_conv::free_strings): New method.
@
text
@d1609 1
a1609 1
  console->init (INVALID_HANDLE_VALUE, GENERIC_READ | GENERIC_WRITE, O_BINARY);
@


1.215
log
@	* fhandler_tty.cc (fhandler_tty_slave::fchown): Initialize mode to 0.
@
text
@d982 12
d1007 2
@


1.214
log
@* dcrt0.cc (do_exit): Don't set thread termination until all fds have been
closed since an fd may rely on a thread.
* fhandler_tty.cc: Reformat comment.
(fhandler_pty_master::pty_master_thread): Refuse ERROR_PIPE_CONNECTED state as
an error.
* globals.cc (exit_states): Reorder ES_THREADTERM.
* path.cc (find_fast_cwd_pointers): Remove excessively wordy DEBUGGING output.
@
text
@d1309 1
a1309 1
  mode_t mode;
@


1.213
log
@* exceptions.cc (try_to_debug): Improve comment.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Add a comment.
@
text
@d1617 3
a1619 4
   Since there's
   always only one pipe instance, there's a chance that clients have to
   wait to connect to the master control pipe.  Therefore the client calls
   to CallNamedPipe should have a big enough timeout value.  For now this
d1637 1
a1637 1
  while (!exit && ConnectNamedPipe (master_ctl, NULL))
@


1.212
log
@* fhandler_tty.cc (fhandler_pty_master::open): Remove debugging printf.
@
text
@d1350 2
a1351 2
  int ntty;
  ntty = cygwin_shared->tty.allocate (false);
d1364 2
a1365 2
  //
  // FIXME: Do this better someday
@


1.211
log
@* fhandler.h (fhandler_termios::tcinit): Make second argument non-optional.
* fhandler_console.cc (fhandler_console::open): Specify second argument to
tcinit.
* fhandler_termios.cc (fhandler_termios::tcinit): Rename second argument.  Set
pgid to 0 if this is a pty master.
(fhandler_termios::tcgetpgrp): Just return value of pgid.  It will be zero if
not initialized.
* fhandler_tty.cc (fhandler_tty_slave::open): Specify second argument to
tcinit.
(fhandler_tty_slave::ioctl): Implement TIOCGPRP/TIOCSPGRP.  Fix switch
indentation.
(fhandler_tty_master::ioctl): Implement TIOCGPRP/TIOCSPGRP.
* include/sys/termios.h (TIOCGPGRP): Define similarly to Linux.
* include/sys/termios.h (TIOCSPGRP): Ditto.
@
text
@a1366 1
small_printf ("tty%d myself->sid %d myself->pid %d this->tcgetpgrp %d\n", get_unit (), myself->sid, myself->pid, this->tcgetpgrp ());
@


1.210
log
@* fhandler_tty.cc (fhandler_tty_slave::init): Revert to using tc->setpgid since
previous change broke some use cases.
@
text
@d487 1
a487 1
  tcinit (cygwin_shared->tty[get_unit ()]);
d1068 15
d1367 1
d1529 25
a1553 20
      case TIOCPKT:
	pktmode = *(int *) arg;
	break;
      case TIOCGWINSZ:
	*(struct winsize *) arg = get_ttyp ()->winsize;
	break;
      case TIOCSWINSZ:
	if (get_ttyp ()->winsize.ws_row != ((struct winsize *) arg)->ws_row
	    || get_ttyp ()->winsize.ws_col != ((struct winsize *) arg)->ws_col)
	  {
	    get_ttyp ()->winsize = *(struct winsize *) arg;
	    killsys (-get_ttyp ()->getpgid (), SIGWINCH);
	  }
	break;
      case FIONBIO:
	set_nonblocking (*(int *) arg);
	break;
      default:
	set_errno (EINVAL);
	return -1;
@


1.209
log
@* fhandler_tty.cc (fhandler_tty_slave::init): Add debugging.  Use tcsetpgrp to
potentially set pgid since it is smarter about deciding if a process is in the
background.
* include/sys/cygwin.h (PID_ORPHANED): Actually delete as planned.
(PID_NOTCYGWIN): Correctly define.
@
text
@d729 1
a729 1
	  tcsetpgrp (myself->pgid);
@


1.208
log
@	* fhandler_tty.cc (fhandler_pty_master::setup): Always create master
	thread.
@
text
@d726 5
a730 1
	tc->setpgid (myself->pgid);
@


1.207
log
@* include/sys/cygwin.h (PID_NOTCYGWIN): New enum.
* spawn.cc (spawn_guts): Set a flag when a process is not a cygwin process.
* fhandler_tty.cc (fhandler_tty_slave::init): Remove previous change.  Try a
different method to determine when we should become the process group owner.
* signal.cc (kill0): Remove archaic code which dealt with never-set flag.
@
text
@d1799 9
a1807 1
  if (ispty)
d1809 8
a1816 19
      /* Create master control pipe which allows the master to duplicate
	 the pty pipe handles to processes which deserve it. */
      __small_sprintf (buf, "\\\\.\\pipe\\cygwin-%S-tty%d-master-ctl",
		       &installation_key, get_unit ());
      master_ctl = CreateNamedPipe (buf, PIPE_ACCESS_DUPLEX,
				    PIPE_WAIT | PIPE_TYPE_MESSAGE
				    | PIPE_READMODE_MESSAGE, 1, 4096, 4096,
				    0, &sec_all_nih);
      if (master_ctl == INVALID_HANDLE_VALUE)
	{
	  errstr = "pty master control pipe";
	  goto err;
	}
      master_thread = new cygthread (::pty_master_thread, this, "pty_master");
      if (!master_thread)
	{
	  errstr = "pty master control thread";
	  goto err;
	}
@


1.206
log
@* fhandler_tty.cc (fhandler_tty_slave::init): Add additional checks to
determine when a process should grab control of a tty's pgid.  Use
being_debugged() for consistency.
* debug.h (being_debugged): Remove vestige of win9x accommodation.
@
text
@d714 1
a714 6
  /* We should only grab this when the parent process owns the pgid
  (which could happen when a cygwin process starts a DOS process which
  starts a cygwin process or when we are being started directly from a
  windows process, e.g., from the CMD prompt.  */
  if (ret && !cygwin_finished_initializing && !being_debugged ()
      && (myself->ppid == 1 || myself->ppid == tc->getpgid ()))
d721 6
a726 1
      tc->setpgid (myself->pgid);
@


1.205
log
@	* fhandler.h (class fhandler_base): Change inheritance of fstat_helper
	and fstat_by_...  methods to private.
	(fhandler_base::fstat_helper): Drop all redundant arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call
	to fstat_by_nfs_ea here.  Drop fetching basic file information.
	Drop setting file attributes.  Accommodate change in fstat_helper call.
	(fhandler_base::fstat_by_name): Simplify.  Only fetch directory
	information to get the inode number.  Drop setting file attributes.
	Accommodate change in fstat_helper call.
	(fhandler_base::fstat_fs): Call fstat_by_nfs_ea if on NFS.
	(fhandler_base::fstat_helper): Drop all redundant arguments.  Use
	information already collected in the fhandler.  Move heading comment
	into code and drop dwFileAttributes comment.
	* mmap.cc (mmap64): Call fstat_fs rather than fstat_by_handle.
	* mount.cc (fs_info::update): Note that has_buggy_basic_info is unused.
	* path.cc (symlink_info::check_reparse_point): Add comment.
	(symlink_info::check): Fetch FileNetworkOpenInformation rather than
	FileBasicInformation throughout, except on NFS.  Explain why.  Store
	FILE_NETWORK_OPEN_INFORMATION in conv_hdl.  Remove
	FILE_ATTRIBUTE_DIRECTORY attribute in conv_hdl for reparse point
	symlinks.
	* path.h (class path_conv_handle): Add FILE_NETWORK_OPEN_INFORMATION
	member _fnoi.
	(path_conv_handle::fnoi): New accessor method for _fnoi.
	(path_conv::fnoi): New accessor method for cubv_hdl._fnoi.

	* fhandler_tty.cc (fhandler_tty_slave::init): Use tty::setpgid method.
@
text
@d713 7
a719 1
  if (ret && !cygwin_finished_initializing && !IsDebuggerPresent ())
@


1.204
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d720 1
a720 1
      tc->pgid = myself->pgid;
@


1.203
log
@* cygthread.h (LPVOID_THREAD_START_ROUTINE): Define.
(cygthread::create): Rename from cygthread::cygthread.
(cygthread::cygthread): Define new constructor which accepts
LPVOID_THREAD_START_ROUTINE as the first argument.  Call cygthread::create.
* cygthread.cc (cygthread::create): Rename from cygthread::cygthread.  Use
'arglen' rather than 'n' since 'n' is no longer supplied.
* fhandler_tty.cc (process_input): Define as void/noreturn.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::init): Don't "zap_h" cygthreads which are noreturn.  It's
now implied.
@
text
@d92 3
a94 3
  new cygthread (process_input, 0, cygself, "ttyin");
  new cygthread (process_ioctl, 0, cygself, "ttyioctl");
  new cygthread (process_output, 0, cygself, "ttyout");
d1808 1
a1808 1
      master_thread = new cygthread (::pty_master_thread, 0, this, "pty_master");
@


1.202
log
@	* fhandler.h (class fhandler_pty_master): Add master_thread member.
	* fhandler_tty.cc (fhandler_pty_master::close): Properly detach from
	master thread.
	(fhandler_pty_master::setup): Store cygthread pointer of pty master
	control thread in master_thread.  Don't zap thread handle.
@
text
@d49 3
a51 3
static DWORD WINAPI process_input (void *);		// Input queue thread
static DWORD WINAPI process_output (void *);		// Output queue thread
static DWORD WINAPI process_ioctl (void *);		// Ioctl requests thread
d92 3
a94 12
  cygthread *h;
  h = new cygthread (process_input, 0, cygself, "ttyin");
  h->SetThreadPriority (THREAD_PRIORITY_HIGHEST);
  h->zap_h ();

  h = new cygthread (process_ioctl, 0, cygself, "ttyioctl");
  h->SetThreadPriority (THREAD_PRIORITY_HIGHEST);
  h->zap_h ();

  h = new cygthread (process_output, 0, cygself, "ttyout");
  h->SetThreadPriority (THREAD_PRIORITY_HIGHEST);
  h->zap_h ();
d219 1
a219 1
static DWORD WINAPI
d408 1
a408 1
static DWORD WINAPI
d430 1
a430 1
static DWORD WINAPI
@


1.201
log
@	* fhandler_tty.cc (fhandler_tty_slave::init): Disable grabbing
	process group ownership of tty in case we're being debugged.
@
text
@d1432 1
a1805 1
      cygthread *h;
d1817 2
a1818 2
      h = new cygthread (::pty_master_thread, 0, this, "pty_master");
      if (!h)
a1822 1
      h->zap_h ();
@


1.200
log
@	* fhandler_termios.cc (tcinit): Remove previously applied change.
	Replace with...
	* fhandler_tty.cc (fhandler_tty_slave::init): Become process group
	leader if called from dtable::init_std_file_from_handle.  Add comment
	to explain.
@
text
@d722 1
a722 1
  if (ret && !cygwin_finished_initializing)
@


1.199
log
@	* fhandler_tty.cc (fhandler_tty_slave::fch_set_sd): Remove commented out
	code.
@
text
@d722 9
@


1.198
log
@	* autoload.cc (GetNamedPipeClientProcessId): Define.
	* fhandler.h (fhandler_tty_slave::fch_open_handles): Declare private.
	(fhandler_tty_slave::fch_close_handles): Ditto.
	(fhandler_tty_slave::cygserver_attach_tty): Drop declaration.
	(fhandler_tty_slave::fstat): Declare public.
	(fhandler_tty_slave::fchmod): Declare public.
	(fhandler_tty_slave::fchown): Declare public.
	(class fhandler_pty_master): Add master_ctl handle.
	(fhandler_pty_master::pty_master_thread): Declare public.
	* fhandler_termios.cc (fhandler_termios::tcinit): If the process
	is started from a non-Cygwin process, make it tty process group
	leader.
	* fhandler_tty.cc: Throughout accommodate additional security related
	arguments in calls to functions creating or opening objects.
	(close_maybe): Move to start of file to reuse it
	in other methods.
	(struct pipe_request): Define.
	(struct pipe_reply): Define.
	(fhandler_tty_slave::open): Throughout, try to open synchronization
	objects with MAXIMUM_ALLOWED permissions.  Drop call to cygserver.
	Try to duplicate pipe handles via master_ctl pipe if duplicating
	directly doesn't work.
	(fhandler_tty_slave::cygserver_attach_tty): Remove.
	(fhandler_tty_slave::init): Close unused incoming pipe handle.
	(fhandler_pty_master::close): Send exit message to master control
	thread and close master_ctl handle.
	(fhandler_pty_master::pty_master_thread): New method, implementing the
	master control thread.
	(pty_master_thread): Static helper to start master control thread.
	(fhandler_pty_master::setup): Simplify creating pipe inheritance.
	Make sure we're the one creating the input_available_event.  Add
	comment to explain why.  Create master_ctl pipe and start master
	control thread.  Close master_ctl handle in case of error.
	* security.cc (alloc_sd): Add code to handle tty objects.  Add comments
	to explain what exactly is required.
	(get_object_sd): New function.
	(get_object_attribute): New function.
	(create_object_sd_from_attribute): New function.
	(set_object_sd): New function.
	(set_object_attribute): New function.
	(set_file_attribute): Change attribute type to mode_t.
	* security.h (set_file_attribute): Change attribute type to mode_t.
	(get_object_sd): Declare.
	(get_object_attribute): Declare.
	(create_object_sd_from_attribute): Declare.
	(set_object_sd): Declare.
	(set_object_attribute): Declare.
	* tty.cc (tty::slave_alive): Implement directly instead of via alive.
	(tty::exists): Open mutex handle with READ_CONTROL access.
	(tty::alive): Remove.
	(tty::open_output_mutex): Convert to inline method.
	(tty::open_input_mutex): Ditto.
	(tty::open_mutex): Take additional ACCESS_MASK parameter for the
	mutex open access mask.
	(tty::open_inuse): New method.
	(tty::create_inuse): Take PSECURITY_ATTRIBUTES parameter.  Drop fmt
	name parameter.  Always create TTY_SLAVE_ALIVE event.
	(tty::get_event): Take additional PSECURITY_ATTRIBUTES parameter for
	CreateEvent.
	* tty.h (class tty): Change declarations according to aforementioned
	changes.
	(tty::open_output_mutex): Implement as inline method.
	(tty::open_input_mutex): Ditto.
@
text
@d1213 1
a1213 3
  if (/*!set_object_sd (get_io_handle (), sd, chown)
      && !set_object_sd (get_output_handle (), sd, chown)
      && */ !set_object_sd (input_available_event, sd, chown)
a1223 2
  /*set_object_sd (get_io_handle (), sd_old, chown);
  set_object_sd (get_output_handle (), sd_old, chown);*/
@


1.197
log
@	* fhandler_tty.cc (fhandler_tty_slave::open): Add code to duplicate
	handles within a single process to simplify openpty case.
	(fhandler_tty_slave::cygserver_attach_tty): Correctly send Windows PID
	to cygserver, rather than the Cygwin PID.
@
text
@d22 1
a24 1
#include "cygserver.h"
d28 17
d510 1
a510 1
  output_done_event = OpenEvent (EVENT_ALL_ACCESS, TRUE, buf);
d512 1
a512 1
  if (!(output_mutex = get_ttyp ()->open_output_mutex ()))
d517 1
a517 1
  if (!(input_mutex = get_ttyp ()->open_input_mutex ()))
d523 1
a523 1
  if (!(input_available_event = OpenEvent (EVENT_ALL_ACCESS, TRUE, buf)))
d532 1
a532 1
  ioctl_request_event = OpenEvent (EVENT_ALL_ACCESS, TRUE, buf);
d534 1
a534 1
  ioctl_done_event = OpenEvent (EVENT_ALL_ACCESS, TRUE, buf);
d538 9
d548 1
a548 1
    inuse = get_ttyp ()->create_inuse (TTY_SLAVE_ALIVE);
d560 22
a581 10
  if (myself->pid == get_ttyp ()->master_pid
      || cygserver_running == CYGSERVER_UNAVAIL
      || !cygserver_attach_tty (&from_master_local, &to_master_local))
    {
      if (get_ttyp ()->master_pid < 0)
	{
	  errmsg = "*** master is closed";
	  set_errno (EAGAIN);
	  goto err_no_errno;
	}
d584 1
a584 12
	{
	  errmsg = "*** couldn't find tty master";
	  set_errno (EAGAIN);
	  goto err_no_errno;
	}
      HANDLE tty_owner;
      if (myself->pid == get_ttyp ()->master_pid)
	{
	  /* This is the most common case, just calling openpty. */
	  termios_printf ("dup handles within myself.");
	  tty_owner = GetCurrentProcess ();
	}
a586 1
	  termios_printf ("cannot dup handles via server. using old method.");
d588 2
a589 7
	  if (tty_owner == NULL)
	    {
	      termios_printf ("can't open tty (%d) handle process %d",
			      get_unit (), get_ttyp ()->master_pid);
	      __seterrno ();
	      goto err_no_msg;
	    }
d591 3
a593 1

a602 2

      VerifyHandle (from_master_local);
a609 1
      VerifyHandle (to_master_local);
d613 26
d709 1
a709 25
fhandler_tty_slave::cygserver_attach_tty (LPHANDLE from_master_ptr,
					  LPHANDLE to_master_ptr)
{
  if (!from_master_ptr || !to_master_ptr)
    return 0;

  pinfo p (get_ttyp ()->master_pid);
  if (!p)
    return 0;

  client_request_attach_tty req (p->dwProcessId,
				 (HANDLE) get_ttyp ()->from_master,
				 (HANDLE) get_ttyp ()->to_master);

  if (req.make_request () == -1 || req.error_code ())
    return 0;

  *from_master_ptr = req.from_master ();
  *to_master_ptr = req.to_master ();

  return 1;
}

int
fhandler_tty_slave::init (HANDLE, DWORD a, mode_t)
d721 6
a726 1
  return open (flags);
d1147 171
d1416 12
d1574 140
a1713 5
#define close_maybe(h) \
  do { \
    if (h && h != INVALID_HANDLE_VALUE) \
      CloseHandle (h); \
  } while (0)
d1719 3
a1729 1

d1732 3
a1734 3
  res = fhandler_pipe::create_selectable (&sec_none_nih, from_master,
					  get_output_handle (), 128 * 1024,
					  pipename);
a1739 7
  /* Only ptys should create inheritable handles by default.  ttys are
     parcelled out on an as-needed basis and handle inheritance differently. */
  if (ispty && !SetHandleInformation (get_output_handle (), HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))
    {
      errstr = "inheritable get_output_handle ()";
      goto err;
    }
d1746 3
a1748 2
  res = fhandler_pipe::create_selectable (&sec_none_nih, get_io_handle (),
					  to_master, 128 * 1024, pipename);
a1753 7
  /* Only ptys should create inheritable handles by default.  ttys are
     parcelled out on an as-needed basis and handle inheritance differently. */
  if (ispty && !SetHandleInformation (get_io_handle (), HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))
    {
      errstr = "inheritable get_io_handle ()";
      goto err;
    }
d1757 7
a1763 6
  /* We do not allow others to open us (for handle duplication)
     but rely on cygheap->inherited_ctty for descendant processes.
     In the future the cygserver may allow access by others. */

  if (cygserver_running == CYGSERVER_UNKNOWN)
    cygserver_init ();
d1769 1
a1769 1
      if (!(output_done_event = t.get_event (errstr = OUTPUT_DONE_EVENT)))
d1771 1
a1771 1
      if (!(ioctl_done_event = t.get_event (errstr = IOCTL_DONE_EVENT)))
d1773 2
a1774 1
      if (!(ioctl_request_event = t.get_event (errstr = IOCTL_REQUEST_EVENT)))
d1778 7
a1784 1
  if (!(input_available_event = t.get_event (errstr = INPUT_AVAILABLE_EVENT, TRUE)))
d1789 1
a1789 1
  if (!(output_mutex = CreateMutex (&sec_all, FALSE, buf)))
d1793 1
a1793 1
  if (!(input_mutex = CreateMutex (&sec_all, FALSE, buf)))
d1796 25
d1845 1
@


1.196
log
@	* fhandler_tty.cc (fhandler_tty_slave::close): Revert previous change.
@
text
@d534 2
a535 1
  if (cygserver_running == CYGSERVER_UNAVAIL
d551 2
a552 4
      termios_printf ("cannot dup handles via server. using old method.");
      HANDLE tty_owner = OpenProcess (PROCESS_DUP_HANDLE, FALSE,
				      p->dwProcessId);
      if (tty_owner == NULL)
d554 15
a568 4
	  termios_printf ("can't open tty (%d) handle process %d",
			  get_unit (), get_ttyp ()->master_pid);
	  __seterrno ();
	  goto err_no_msg;
d590 2
a591 1
      CloseHandle (tty_owner);
d669 5
a673 1
  client_request_attach_tty req ((DWORD) get_ttyp ()->master_pid,
@


1.195
log
@* dtable.cc (dtable::init_std_file_from_handle): Avoid adding fh to fdtab until
we know that it is good.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Handle error
conditions more consistently.  Avoid handle leakage on error.
@
text
@d632 1
a632 2
  if (archetype)
    archetype->usecount--;
d635 1
a635 1
  if (archetype && archetype->usecount)
@


1.194
log
@	* fhandler_tty.cc (fhandler_tty_slave::close): Avoid potential crash
	if former open call has been unsuccessful.
@
text
@d453 14
d497 2
a498 3
      termios_printf ("open output mutex failed, %E");
      __seterrno ();
      return 0;
d502 2
a503 3
      termios_printf ("open input mutex failed, %E");
      __seterrno ();
      return 0;
d508 2
a509 3
      termios_printf ("open input event failed, %E");
      __seterrno ();
      return 0;
d529 1
a529 1
      termios_printf ("tty handles have been closed");
d531 1
a531 1
      return 0;
a533 4
  HANDLE from_master_local;
  HANDLE to_master_local;
  from_master_local = to_master_local = NULL;

d539 1
d541 1
a541 2
	  termios_printf ("*** master is closed");
	  return 0;
d546 1
d548 1
a548 2
	  termios_printf ("*** couldn't find tty master");
	  return 0;
d558 1
a558 1
	  return 0;
d568 1
a568 1
	  return 0;
d576 2
a577 3
	  termios_printf ("can't duplicate output, %E");
	  __seterrno ();
	  return 0;
d610 10
@


1.193
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d616 2
a617 1
  archetype->usecount--;
d620 1
a620 1
  if (archetype->usecount)
@


1.192
log
@	* fhandler_tty.cc (fhandler_tty_master::init): Don't erase all default
	termios settings of slave console.
@
text
@d584 1
@


1.191
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
a67 4
  termios ti;
  memset (&ti, 0, sizeof (ti));
  console->tcsetattr (0, &ti);

@


1.190
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d559 1
a559 1
			    hMainProc, &from_master_local, 0, TRUE,
d570 1
a570 1
			  hMainProc, &to_master_local, 0, TRUE,
d1462 1
a1462 1
      if (!DuplicateHandle (parent, arch->from_master, hMainProc,
d1465 1
a1465 1
      if (!DuplicateHandle (parent, arch->to_master, hMainProc,
@


1.189
log
@* dcrt0.cc (jit_debug): New global.
(initial_env): Set jit_debug when we are automatically starting a gdb process.
* dtable.cc (dtable::get_debugger_info): Don't tty tricks when we are being
debugged by our own captive gdb, as determined by jit_debug == true.
(dtable::init_std_file_from_handle): Detect errors when initializing a tty
early rather than at random points later.
* fhandler.h (fhandler_*::init): Return int to indicate success/failure.
* fhandler.cc (fhandler_base::init): Reflect change in return value.
* pipe.cc (fhandler_pipe::init): Ditto.
(fhandler_pipe::create_selectable): Don't say we're retrying when we aren't.
* fhandler_console.cc (fhandler_console::init): Ditto.  Return success/failure.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
(fhandler_tty_slave::open): Make debugging output more detailed.
* tty.cc (tty_list::terminate): Don't close I/O handles before all slaves have
checked in.
(tty::slave_alive): Make a non-inlined function.  Check if tty pipe handles can
be created as an additional exists check.
* tty.h (tty::slave_alive): Just define here.
@
text
@d674 1
a674 1
int
d1205 1
a1205 1
int
@


1.188
log
@* errno.cc (errmap): Add mapping for ERROR_IO_INCOMPLETE.
* fhandler.cc (fhandler_base::fcntl): Fix comment.
(fhandler_base::wait_overlapped): Accept an optional len parameter.  Use the
len parameter when WriteFile fails with ERROR_IO_PENDING.  Make debug output
less alarming.
(fhandler_base::write_overlapped): Pass len to wait_overlapped.
* fhandler.h (fhandler_base::wait_overlapped): Add an optional argument
denoting the number of characters intended to be written.
* fhandler_tty.cc (fhandler_pty_master::close): Don't close archetype handles
when cygwin is still initializing since the handles aren't actually opened at
that point.
@
text
@d562 2
a563 1
	  termios_printf ("can't duplicate input, %E");
d658 1
a658 1
void
d671 1
a671 1
  open (flags);
@


1.187
log
@* fhandler_console.cc (fhandler_console::ioctl): Properly treat TIOCLINUX
argument as a char.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use coercion to properly set
char value.
@
text
@d1187 7
a1193 4
  if (!ForceCloseHandle (arch->from_master))
    termios_printf ("error closing from_master %p, %E", arch->from_master);
  if (!ForceCloseHandle (arch->to_master))
    termios_printf ("error closing from_master %p, %E", arch->to_master);
@


1.186
log
@ChangeLog:

	* configure.in: Remove --enable-server option.  Allways add the
	cygserver directory to $SUBDIRS.
	* configure: Regenerate.

cygwin/ChangeLog:

	Remove USE_SERVER define.  Accommodate throughout.
	* configure.in: Remove --enable-server option.
	* configure: Regenerate.
	* environ.cc: Remove CYGWIN=server setting.

cygserver/ChangeLog:

	* client.cc (allow_server): Remove variable.
	(client_request_get_version::client_request_get_version): Drop checking
	allow_server.

utils/ChangeLog:

	* passwd.c: Remove CYGWIN=server requirement from usage text.

doc/ChangeLog:

	* cygserver.sgml: Remove the "How to use the Cygserver services"
	section.
	* cygwinenv.sgml: Move "(no)server" to the removed options section.
	* faq-programming.xml: Remove CYGWIN=server requirement for running
	the Cygwin testsuite.
	* ntsec.sgml: Ditto for using `passwd -R'.
@
text
@d1051 1
a1051 1
	  *(unsigned char *) arg = get_ttyp ()->arg.value & 0xFF;
@


1.185
log
@* fhandler_tty.cc (close_maybe): Check for both types of invalid handle before
attempting CloseHandle.
(fhandler_pty_master::setup): Only set inheritance on pty handles, not tty
handles.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
a530 1
#ifdef USE_SERVER
a532 1
#endif
a546 1
#ifdef USE_SERVER
a547 1
#endif
a640 3
#ifndef USE_SERVER
  return 0;
#else
a654 1
#endif
a1394 1
#ifdef USE_SERVER
a1396 1
#endif
@


1.184
log
@* fhandler_tty.cc (fhandler_pty_master::setup): Reorganize so that all
operations for each end of the pipe are grouped together.
@
text
@d1342 1
a1342 1
    if (h) \
a1358 4
  /* FIXME: should this be sec_none_nih? */

  /* Create communication pipes */

d1369 3
a1371 1
  if (!SetHandleInformation (get_output_handle (), HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))
d1389 3
a1391 1
  if (!SetHandleInformation (get_io_handle (), HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))
@


1.183
log
@	* fhandler_tty.cc (fhandler_pty_master::setup): Fix pipe inheritance.
@
text
@d1365 1
a1365 1
  res = fhandler_pipe::create_selectable (&sec_all, from_master,
d1373 9
d1384 1
a1384 1
  res = fhandler_pipe::create_selectable (&sec_all, get_io_handle (),
d1391 5
a1395 4

  if (!SetNamedPipeHandleState (get_output_handle (), &pipe_mode, NULL, NULL))
    termios_printf ("can't set output_handle(%p) to non-blocking mode",
		    get_output_handle ());
a1431 14
  if (!DuplicateHandle (hMainProc, from_master, hMainProc, &from_master, 0, false,
			DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
    {
      errstr = "non-inheritable from_master";
      goto err;
    }

  if (!DuplicateHandle (hMainProc, to_master, hMainProc, &to_master, 0, false,
			DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
    {
      errstr = "non-inheritable to_master";
      goto err;
    }

@


1.182
log
@Remove unneeded header files from source files throughout.
@
text
@d1365 1
a1365 1
  res = fhandler_pipe::create_selectable (&sec_all_nih, from_master,
d1375 1
a1375 1
  res = fhandler_pipe::create_selectable (&sec_all_nih, get_io_handle (),
@


1.181
log
@	* Fix copyright dates.
@
text
@a12 4
#include <wingdi.h>
#include <winuser.h>
#include <stdio.h>
#include <unistd.h>
a13 2
#include <ctype.h>
#include <limits.h>
@


1.180
log
@* dtable.cc: Define various device-related string constants as wide character
constants.
(dtable::init_std_file_from_handle): Reorganize pipe handling to try to catch
special tty case.
(build_fh_name_worker): Declare for common use.
(build_fh_name): Define char version.
(build_fh_name): Define (currently unused) UNICODE_STRING version.
(decode_tty): Detect if pipe is actually a cygwin tty, returning the tty name
in the buffer.
(handle_to_fn): Reorganize to use wide characters.
* dtable.h (build_fh_name): Declare (currently unused) UNICODE_STRING version.
* fhandler_tty.cc (fhandler_pty_master::setup): Use
fhandler_pipe::create_selectable to create a pipe with a given name.
* pipe.cc (pipe_handler): Make returned handle inheritable.
(fhandler_pipe::create_selectable): Take an optional name.  Use a standard
cygwin introducer for the name.
* path.cc (path_conv::check): Make first argument const.
* path.h (path_conv::check): Ditto for declaration.
(path_conv::path_conv): Ditto for UNICODE_STRING version.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
@


1.179
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set access to
	read/write of handle is connected to a tty or console.
	* fhandler_dsp.cc (fhandler_dev_dsp::dup): Set open flags correctly
	after duplicating from archetype.
	* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
	(fhandler_pty_master::dup): Ditto.
@
text
@d1355 1
d1366 9
a1374 1
  if (!CreatePipe (&from_master, &get_output_handle (), &sec_all, 128 * 1024))
d1380 4
a1383 1
  if (!CreatePipe (&get_io_handle (), &to_master, &sec_all, 128 * 1024))
d1395 1
a1395 1
  /* We do not open allow the others to open us (for handle duplication)
@


1.178
log
@	* fhandler_tty.cc (fhandler_tty_slave::open): Use MAX_PATH instead of
	CYG_MAX_PATH for event name buffer size.
	(fhandler_pty_master::setup): Use MAX_PATH instead of CYG_MAX_PATH for
	mutex name buffer size.
	* netdb.cc: Drop old comment.
	(open_system_file): Set path buffer size to MAX_PATH instead of
	CYG_MAX_PATH.  Drop conversion to posix path.  Open file using win32
	path.

	Fix typo in ChangeLog.
@
text
@d931 1
d944 1
@


1.177
log
@	* fhandler_tape.cc (mtinfo::initialize): Use MAX_PATH instead of
	CYG_MAX_PATH.
	* fhandler_tty.cc (fhandler_pty_master::ptsname): Set buffer size to
	TTY_NAME_MAX.
	* syscalls.cc (ttyname): Eliminate the `+ 1' from the name buffer size
	since TTY_NAME_MAX already counts the trailing NUL.
	* libc/bsdlib.cc (openpty): Set pts buffer size to TTY_NAME_MAX.
@
text
@d481 1
a481 1
  char buf[CYG_MAX_PATH];
d1405 1
a1405 1
  char buf[CYG_MAX_PATH];
@


1.176
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d1303 1
a1303 1
  static char buf[32];
@


1.175
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@d604 1
a604 1
  arch = (fhandler_tty_slave *) cmalloc (HEAP_ARCHETYPES, sizeof (*this));
d1130 1
a1130 1
  fhandler_pty_master *arch = (fhandler_tty_master *) cmalloc (HEAP_ARCHETYPES, sizeof (*this));
@


1.174
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
d538 1
a538 2
  if (!wincap.has_security ()
      || cygserver_running == CYGSERVER_UNAVAIL
d1386 2
a1387 5
  if (wincap.has_security ())
    {
      if (cygserver_running == CYGSERVER_UNKNOWN)
	cygserver_init ();
    }
@


1.174.2.1
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set access to
	read/write if handle is connected to a tty or console.
	* fhandler_dsp.cc (fhandler_dev_dsp::dup): Set open flags correctly
	after duplicating from archetype.
	* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
	(fhandler_pty_master::dup): Ditto.
@
text
@a931 1
  child->set_flags (get_flags ());
a943 1
  child->set_flags (get_flags ());
@


1.173
log
@	* fhandler.h (class dev_console): Add `metabit' indicating the
	current meta key mode.
	* fhandler_console.cc (fhandler_console::read): Set the top bit of
	the character if metabit is true.
	* fhandler_console.cc (fhandler_console::ioctl): Implement
	KDGKBMETA and KDSKBMETA commands.
	* fhandler_tty.cc (process_ioctl): Support KDSKBMETA.
	(fhandler_tty_slave::ioctl): Send KDGKBMETA and KDSKBMETA to the
	master.
	* include/cygwin/kd.h: New file for the meta key mode.
	* include/sys/kd.h: New file.
@
text
@d1024 1
d1056 1
a1056 1
      int val = *(unsigned char *) arg;
@


1.173.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@a1023 1
  int val;
d1055 1
a1055 1
      val = *(unsigned char *) arg;
@


1.172
log
@* fhandler_tty.cc (fhandler_pty_master::close): Always close
from_master/to_master since we always have copies of these handles.
@
text
@d20 1
d439 6
a444 3
      tty_master->get_ttyp ()->ioctl_retval =
      tty_master->console->ioctl (tty_master->get_ttyp ()->cmd,
			     (void *) &tty_master->get_ttyp ()->arg);
d1008 2
d1066 22
@


1.171
log
@* cygthread.cc (cygthread::terminate_thread): In debugging output, use name of
thread being terminated rather than thread doing terminating.
* fhandler.h (fhandler_pty_master::slave): Delete.
(fhandler_pty_master::get_unit): Ditto.
(fhandler_pty_master::setup): Change argument declaration to accommodate new
usage.
* fhandler_tty.cc (fhandler_tty_master::init): Remove obsolete slave
assignment.  Pass argument to setup indicating that this is a tty.
(fhandler_tty_slave::open): Use dev() method rather than referencing pc.dev
directly.
(fhandler_pty_master::open): Don't create archetype based on ptym device
number.  Set device number to use DEV_TTYM_MAJOR and tty number.  Pass argument
to setup indicating that this is a pty.
(fhandler_pty_master::setup): Change single argument to a flag indicating
whether we're creating a pty and use appropriately.  Calculate 't' variable
here rather than in caller.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Use dev() method rather than
referencing pc.dev directly.
@
text
@d1169 6
a1174 12
  if (arch->dwProcessId != GetCurrentProcessId ())
    termios_printf ("not closing from_master(%p)/to_master(%p) since we don't own them(%d)",
		    arch->from_master, arch->to_master, arch->dwProcessId);
  else
    {
      termios_printf ("closing from_master(%p)/to_master(%p) since we own them(%d)",
		      arch->from_master, arch->to_master, arch->dwProcessId);
      if (!ForceCloseHandle (arch->from_master))
	termios_printf ("error closing from_master %p, %E", arch->from_master);
      if (!ForceCloseHandle (arch->to_master))
	termios_printf ("error closing from_master %p, %E", arch->to_master);
    }
@


1.170
log
@* dcrt0.cc (dll_crt0_0): Call tty_list::init_session here.
(dll_crt0_1): Reflect renaming from tty_init to tty::init_session.
(do_exit): Reflect moving of tty_terminate into tty_list.
* exceptions.cc (events_init): Move tty_mutex stuff elsewhere.
* fhandler_console.cc (set_console_title): Use lock_ttys class.
* fhandler_termios.cc (fhandler_termios::bg_check): Make debug output more
accurate.
* fhandler_tty.cc (fhandler_tty_slave::open): Reflect move of attach_tty into
tty_list class.  Don't attempt to grab master end of pty if master doesn't
exist.
(fhandler_pty_master::open): Reflect move of allocate_tty into tty_list class.
Use lock_ttys::release to release mutex.  Improve debugging output.
(fhandler_pty_master::setup): Remove if 0'ed block.  Fix argument to
SetNamedPipeHandleState.
* pinfo.cc (_pinfo::set_ctty): Lock ttys before setting sid/pgid.  Improve
debugging.  Add temporary debugging.
* tty.cc (tty_list::init_session): New function.
(tty::init_session): Rename from tty_init.  Reflect move of attach_tty to
tty_list class.
(tty::create_master): Rename from create_tty_master.
(tty_list::attach): Rename from attach_tty.  Reflect renaming of connect_tty to
connect.  Ditto for allocate_tty.
(tty_terminate): Delete.
(tty_list::terminate): Subsume tty_terminate.  Use lock_ttys rather than
manipulating mutex directly.
(tty_list::allocate): Rename from allocate_tty.  Use lock_ttys rather than
manipulating mutex directly.  Don't set sid here since linux apparently doesn't
do this.  Reflect move of create_tty_master into tty.
(lock_ttys::lock_ttys): Define new constructor.
(lock_ttys::release): New function.
* tty.h (tty::exists): Return false immediately if !master_pid.
(tty::set_master_closed): Define new function.
(tty::create_master): Ditto.
(tty::init_session): Ditto.
(tty_list::mutex): New field.
(tty_list::allocate): Define new function.
(tty_list::connect): Ditto.
(tty_list::attach): Ditto.
(tty_list::init_session): Ditto.
(lock_ttys): New class.
(tty_init): Delete declaration.
(tty_terminate): Ditto.
(attach_tty): Ditto.
(create_tty_master): Ditto.
@
text
@a64 1
  slave = dev ();
d77 1
a77 1
  if (!setup (*cygwin_shared->tty[get_unit ()]))
d460 1
a460 1
    pc.dev.tty_to_real_device ();
a1085 9
  fhandler_pty_master *arch = (fhandler_tty_master *) cygheap->fdtab.find_archetype (pc.dev);
  if (arch)
    {
      *this = *(fhandler_pty_master *) arch;
      termios_printf ("copied fhandler_pty_master archetype");
      set_flags ((flags & ~O_TEXT) | O_BINARY);
      goto out;
    }

d1091 2
a1092 3
  slave = *ttys_dev;
  slave.setunit (ntty);
  if (!setup (*cygwin_shared->tty[ntty]))
d1102 1
a1102 1
  arch = (fhandler_tty_master *) cmalloc (HEAP_ARCHETYPES, sizeof (*this));
a1107 1
out:
d1329 1
a1329 1
fhandler_pty_master::setup (tty& t)
d1331 2
d1373 1
a1373 1
  if (get_major () == DEV_TTYM_MAJOR)
@


1.169
log
@* fhandler_tty.cc (fhandler_pty_master::close): Don't close handles if we don't
own them.
(fhandler_pty_master::setup): Make sure that original handle is closed when
changing inheritance.
(fhandler_pty_master::fixup_after_fork): Set from_master/to_master to arch
value always.
(fhandler_pty_master::fixup_after_exec): Clear from_master/to_master when
close_on_exec.
@
text
@d474 1
a474 1
  attach_tty (get_unit ());
d540 6
d1096 2
a1097 1
  int ntty = cygwin_shared->tty.allocate_tty (false);
d1105 1
a1105 1
      ReleaseMutex (tty_mutex);	// lock was set in allocate_tty
d1108 1
a1108 1
  ReleaseMutex (tty_mutex);	// lock was set in allocate_tty
d1122 3
a1124 2
  report_tty_counts (this, "opened master", "");
  termios_printf ("opened pty master tty%d", get_unit ());
d1195 4
a1198 2
  if (!hExeced && get_ttyp ()->master_pid == myself->pid)
    get_ttyp ()->init ();
a1349 5
#if 0 // CGF: don't think this is needed since it is handled by the constructor
  input_handle = io_handle = output_done_event = ioctl_done_event =
    ioctl_request_event = input_available_event = output_mutex = input_mutex NULL;
#endif

d1363 1
a1363 1
  if (!SetNamedPipeHandleState (&get_output_handle (), &pipe_mode, NULL, NULL))
@


1.168
log
@* cygheap.cc (init_cygheap::close_ctty): Remove obsolete code.
* dcrt0.cc (child_info_spawn::handle_spawn): Signal ready after we've run
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Add debugging output.
* fhandler_tty.cc (fhandler_pty_master::doecho): Use class version of
to_master.
(fhandler_tty_common::close): Remove obsolete code.
(fhandler_tty_slave::fixup_after_exec): Don't close, since this is done in
dtable's fixup_after_exec.  (revisit later?)
(fhandler_pty_master::fixup_after_exec): Ditto.
@
text
@d1173 12
a1184 4
  if (!ForceCloseHandle (arch->from_master))
    termios_printf ("error closing from_master %p, %E", arch->from_master);
  if (!ForceCloseHandle (arch->to_master))
    termios_printf ("error closing from_master %p, %E", arch->to_master);
d1401 1
a1401 1
			DUPLICATE_SAME_ACCESS))
d1408 1
a1408 1
			DUPLICATE_SAME_ACCESS))
d1463 2
d1473 2
@


1.167
log
@* fhandler.cc (fhandler_base::fixup_after_exec): Declare here.
* fhandler.h (fhandler_base::fixup_after_exec): Make non-inline.
(fhandler_termios::fixup_after_fork): Delete declaration.
(fhandler_termios::fixup_after_exec): Ditto.
(fhandler_tty_common::inuse): Remove.
(fhandler_tty_common::dup): Delete declaration.
(fhandler_tty_common::fixup_after_fork): Ditto.
(fhandler_tty_slave::fixup_after_exec): Declare new function.
(fhandler_pty_master::dwProcessId): New variable.
(fhandler_pty_master::from_master): Ditto.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::setup): New function.
(fhandler_pty_master::fixup_after_fork): Ditto.
(fhandler_pty_master::fixup_after_exec): Ditto.
* fhandler_termios.cc (fhandler_termios::fixup_after_exec): Delete definition.
(fhandler_termios::fixup_after_fork): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Use fhandler_pty_master setup
function rather than obsolete tty::common_init.  Delete obsolete inuse setting.
(fhandler_tty_slave::fhandler_tty_slave): Set inuse to NULL here.
(fhandler_tty_slave::open): Change debugging output for clarity.  Check for
different things when doing a sanity check on the tty.  Reflect the fact that
master_pid now is the cygwin pid rather than the windows pid.  Use "arch"
rather than "archetype" for consistency.
(fhandler_tty_slave::close): Close inuse here.
(fhandler_tty_slave::dup): Remove old if 0'ed code.
(fhandler_pty_master::dup): New function.  Handles pty master archetype.
(fhandler_pty_master::fhandler_pty_master): Zero pty_master specific fields.
(fhandler_pty_master::open): Implement using archetypes, similar to slave.  Use
fhandler_pty_master setup function rather than obsolete tty::common_init.
Don't set inuse.
(fhandler_tty_common::close): Don't deal with inuse.  Delete old if 0'ed code.
(fhandler_pty_master::close): Implement using archetypes.  Close from_master
and to_master.
(fhandler_tty_common::set_close_on_exec): Just set close_on_exec flag here
since everything uses archetypes now.
(fhandler_tty_common::fixup_after_fork): Delete definition.
(fhandler_tty_slave::fixup_after_exec): Define new function.
(fhandler_pty_master::setup): New function, derived from tty::common_init.
(fhandler_pty_master::fixup_after_fork): New function.
(shared_info.h): Reset SHARED_INFO_CB to reflect new tty size.
* tty.cc (tty_list::terminate): Close individual handles from tty_master.
(tty::master_alive): Delete.
(tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* tty.h (tty::from_slave): Delete.
(tty::to_slave): Ditto.
(tty::common_init): Delete declaration.
(tty::make_pipes): Ditto.
(tty::master_pid): Define as pid_t since it is now a cygwin pid.
@
text
@d167 2
a168 2
  if (!WriteFile (get_ttyp ()->to_master, str, len, &len, NULL))
    termios_printf ("Write to %p failed, %E", get_ttyp ()->to_master);
a522 2
  /* Duplicate tty handles.  */

d583 1
a583 1
      get_ttyp ()->from_master, from_master_local);
d585 1
a585 1
      get_ttyp ()->to_master, to_master_local);
a1145 9
#if 0 // CGF - DELETME
  /* Send EOF to slaves if master side is closed */
  if (!get_ttyp ()->master_alive ())
    {
      termios_printf ("no more masters left. sending EOF");
      SetEvent (input_available_event);
    }
#endif

d1299 1
a1299 3
  if (close_on_exec ())
    close ();
  else
d1428 2
d1461 1
a1461 3
  if (close_on_exec ())
    close ();
  else
@


1.166
log
@* child_info.h (_CI_SAW_CTRL_C): New enum.
(CURR_CHILD_INFO_MAGIC): Reset.
(saw_ctrl_c): New function.
(set_saw_ctrl_c): Ditto.
* sigproc.cc (child_info::proc_retry): Return EXITCODE_OK if we get
STATUS_CONTROL_C_EXIT and we actually saw a CTRL-C.
* spawn.cc (dwExeced): Delete.
(chExeced): New variable.
(spawn_guts): Set chExeced;
* exceptions.cc (dwExeced): Delete declaration.
(chExeced): Declare.
(ctrl_c_handler): Detect if we're an exec stub process and set a flag, if so.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Add extra
DEBUGGING test.
* pinfo.cc: Fix comment.
@
text
@d31 1
d33 1
a33 1
/* Tty master stuff */
d78 2
a79 1
  cygwin_shared->tty[get_unit ()]->common_init (this);
a82 1
  inuse = get_ttyp ()->create_inuse (TTY_MASTER_ALIVE);
d450 1
a450 1
  : fhandler_tty_common ()
d466 1
a466 1
      termios_printf ("copied tty fhandler archetype");
d525 1
a525 1
  if (!get_ttyp ()->from_slave || !get_ttyp ()->to_slave)
d542 7
d553 1
a553 2
				      get_ttyp ()->master_pid);
      termios_printf ("tty own handle %p",tty_owner);
d605 1
a605 1
  archetype->usecount++;
d636 2
a928 3
#if 0 // CGF: Remove this again as it screws up expect
  myself->set_ctty (get_ttyp (), openflags, arch);
#endif
d933 1
a933 1
fhandler_tty_common::dup (fhandler_base *child)
d935 5
a939 85
  fhandler_tty_slave *fts = (fhandler_tty_slave *) child;
  int errind;

  fts->tcinit (get_ttyp ());

  attach_tty (get_unit ());

  HANDLE nh;

  if (output_done_event == NULL)
    fts->output_done_event = NULL;
  else if (!DuplicateHandle (hMainProc, output_done_event, hMainProc,
			     &fts->output_done_event, 0, 1,
			     DUPLICATE_SAME_ACCESS))
    {
      errind = 1;
      goto err;
    }
  if (ioctl_request_event == NULL)
    fts->ioctl_request_event = NULL;
  else if (!DuplicateHandle (hMainProc, ioctl_request_event, hMainProc,
			     &fts->ioctl_request_event, 0, 1,
			     DUPLICATE_SAME_ACCESS))
    {
      errind = 2;
      goto err;
    }
  if (ioctl_done_event == NULL)
    fts->ioctl_done_event = NULL;
  else if (!DuplicateHandle (hMainProc, ioctl_done_event, hMainProc,
			     &fts->ioctl_done_event, 0, 1,
			     DUPLICATE_SAME_ACCESS))
    {
      errind = 3;
      goto err;
    }
  if (!DuplicateHandle (hMainProc, input_available_event, hMainProc,
			&fts->input_available_event, 0, 1,
			DUPLICATE_SAME_ACCESS))
    {
      errind = 4;
      goto err;
    }
  if (!DuplicateHandle (hMainProc, output_mutex, hMainProc,
			&fts->output_mutex, 0, 1,
			DUPLICATE_SAME_ACCESS))
    {
      errind = 5;
      goto err;
    }
  if (!DuplicateHandle (hMainProc, input_mutex, hMainProc,
			&fts->input_mutex, 0, 1,
			DUPLICATE_SAME_ACCESS))
    {
      errind = 6;
      goto err;
    }
  if (!DuplicateHandle (hMainProc, get_handle (), hMainProc,
			&nh, 0, 1,
			DUPLICATE_SAME_ACCESS))
    {
      errind = 7;
      goto err;
    }
  fts->set_io_handle (nh);

  if (!DuplicateHandle (hMainProc, get_output_handle (), hMainProc,
			&nh, 0, 1,
			DUPLICATE_SAME_ACCESS))
    {
      errind = 8;
      goto err;
    }
  fts->set_output_handle (nh);

  if (inuse == NULL)
    fts->inuse = NULL;
  else if (!DuplicateHandle (hMainProc, inuse, hMainProc,
			     &fts->inuse, 0, 1,
			     DUPLICATE_SAME_ACCESS))
    {
      errind = 9;
      goto err;
    }

a940 5

err:
  __seterrno ();
  termios_printf ("dup %d failed in DuplicateHandle, %E", errind);
  return -1;
d1076 1
a1076 1
  : fhandler_tty_common ()
d1083 9
d1098 5
a1102 1
  cygwin_shared->tty[ntty]->common_init (this);
a1103 1
  inuse = get_ttyp ()->create_inuse (TTY_MASTER_ALIVE);
d1106 7
d1114 4
a1138 2
  if (inuse && !CloseHandle (inuse))
    termios_printf ("CloseHandle (inuse), %E");
d1148 1
d1155 1
a1159 5
  if (!hExeced)
    {
      inuse = NULL;
      set_io_handle (NULL);
    }
d1170 2
d1173 1
a1173 3
  if (get_ttyp ()->master_alive ())
    fhandler_tty_common::close ();
  else
d1175 3
a1177 6
      termios_printf ("freeing tty%d (%d)", get_unit (), get_ttyp ()->ntty);
#if 0
      if (get_ttyp ()->to_slave)
	ForceCloseHandle1 (get_ttyp ()->to_slave, to_slave);
      if (get_ttyp ()->from_slave)
	ForceCloseHandle1 (get_ttyp ()->from_slave, from_slave);
d1179 3
a1181 4
      if (get_ttyp ()->from_master)
	CloseHandle (get_ttyp ()->from_master);
      if (get_ttyp ()->to_master)
	CloseHandle (get_ttyp ()->to_master);
d1183 6
a1188 1
      fhandler_tty_common::close ();
d1190 2
a1191 3
      if (!hExeced)
	get_ttyp ()->init ();
    }
d1295 2
a1296 26
  if (archetype)
    close_on_exec (val);
  else
    {
      if (output_done_event)
	set_no_inheritance (output_done_event, val);
      if (ioctl_request_event)
	set_no_inheritance (ioctl_request_event, val);
      if (ioctl_done_event)
	set_no_inheritance (ioctl_done_event, val);
      if (inuse)
	set_no_inheritance (inuse, val);
      set_no_inheritance (output_mutex, val);
      set_no_inheritance (input_mutex, val);
      set_no_inheritance (input_available_event, val);
      set_no_inheritance (output_handle, val);
#ifndef DEBUGGING
      fhandler_base::set_close_on_exec (val);
#else
      /* FIXME: This is a duplication from fhandler_base::set_close_on_exec.
	 It is here because we need to specify the "from_pty" stuff here or
	 we'll get warnings from ForceCloseHandle when debugging. */
      set_no_inheritance (get_io_handle (), val);
      close_on_exec (val);
#endif
    }
d1302 1
d1308 1
a1308 1
fhandler_tty_common::fixup_after_fork (HANDLE parent)
d1310 4
a1313 29
  fhandler_termios::fixup_after_fork (parent);
  if (output_done_event)
    fork_fixup (parent, output_done_event, "output_done_event");
  if (ioctl_request_event)
    fork_fixup (parent, ioctl_request_event, "ioctl_request_event");
  if (ioctl_done_event)
    fork_fixup (parent, ioctl_done_event, "ioctl_done_event");
  if (output_mutex)
    fork_fixup (parent, output_mutex, "output_mutex");
  if (input_mutex)
    fork_fixup (parent, input_mutex, "input_mutex");
  if (input_available_event)
    fork_fixup (parent, input_available_event, "input_available_event");
  fork_fixup (parent, inuse, "inuse");
}

void
fhandler_pty_master::set_close_on_exec (bool val)
{
  fhandler_tty_common::set_close_on_exec (val);

  /* FIXME: There is a console handle leak here. */
  if (get_ttyp ()->master_pid == GetCurrentProcessId ())
    {
      get_ttyp ()->from_slave = get_handle ();
      get_ttyp ()->to_slave = get_output_handle ();
      termios_printf ("from_slave %p, to_slave %p", get_handle (),
		      get_output_handle ());
    }
d1328 149
@


1.165
log
@* fhandler_tty.cc (fhandler_tty::close): Remove problematic hExeced guard.
@
text
@d151 7
@


1.164
log
@* fhandler_tty.cc (fhandler_tty_slave::open): Reinstate call to need_invisible
on first pty open.
@
text
@d601 6
a606 3
  if (!hExeced)
    {
      cygheap->manage_console_count ("fhandler_tty_slave::close", -1);
d608 2
a609 2
      archetype->usecount--;
      report_tty_counts (this, "closed", "");
d611 2
a612 2
      if (archetype->usecount)
	{
d614 2
a615 2
	  if (archetype->usecount < 0)
	    system_printf ("error: usecount %d", archetype->usecount);
d617 2
a618 3
	  termios_printf ("just returning because archetype usecount is != 0");
	  return 0;
	}
@


1.163
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Regenerate.
(child_info::retry): Move here from fork subclass.
(child_info::exit_code): New field.
(child_info::retry_count): Max retry count for process start.
(child_info::proc_retry): Declare new function.
(child_info_fork::retry): Move to parent.
(child_info_fork::fork_retry): Ditto.
* dcrt0.cc (child_info::fork_retry): Rename and move.
(child_info_fork::handle_failure): Move.
(dll_crt0_0): Initialize console handler based on whether we have a controlling
tty or not.  Avoid nonsensical check for fork where it can never occur.
* environ.cc (set_proc_retry): Rename from set_fork_retry.  Set retry_count in
child_info.
(parse_thing): Reflect above change.
* exceptions.cc (dummy_ctrl_c_handler): Remove unused variable name.
(ctrl_c_handler): Always return TRUE for the annoying CTRL_LOGOFF_EVENT.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Remove call to
init_console_handler.
* fhandler_tty.cc (fhandler_tty_slave::open): Just call mange_console_count
here and let it decide what to do with initializing console control handling.
* fork.cc (fork_retry): Remove definition.
(frok::parent): Define static errbuf and use in error messages (not thread safe
yet).  Close pi.hThread as soon as possible.  Protect pi.hProcess as soon as
possible.  Don't set retry_count.  That happens automatically in the
constructor now.  Accommodate name change from fork_retry to proc_retry.
* init.cc (dll_entry): Turn off ctrl-c handling early until we know how it is
supposed to be handled.
* pinfo.cc (_pinfo::dup_proc_pipe): Remember original proc pipe value for
failure error message.  Tweak debug message slightly.
* sigproc.cc (child_info::retry_count): Define.
(child_info::child_info): Initialize retry count.
(child_info::sync): Set exit code if process dies before synchronization.
(child_info::proc_retry): Rename from child_info_fork::fork_retry.  Use
previously derived exit code.  Be more defensive about what is classified as an
error exit.
(child_info_fork::handle_failure): Move here from dcrt0.cc.
* spawn.cc (spawn_guts): Maintain error mode when starting new process to avoid
annoying pop ups.  Move deimpersonate call within new loop.  Move envblock
freeing to end.  Loop if process dies prematurely with bad exit code.
* syscalls.cc (init_console_handler): Remove hopefully unneeded call to
init_console_handler.
@
text
@d579 3
a581 1
  cygheap->manage_console_count ("fhandler_tty_slave::open", 1);
@


1.162
log
@copyright
@
text
@d579 1
a579 3
  if (cygheap->manage_console_count ("fhandler_tty_slave::open", 1) == 1
      && !output_done_event && fhandler_console::need_invisible ())
    init_console_handler (TRUE);
@


1.161
log
@* fhandler_tty.cc (fhandler_tty_slave::dup): Don't assign a controlling
terminal to a process when duped.  Linux doesn't do this, so we won't either.
@
text
@d3 2
a4 1
   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.160
log
@* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Use strace
method rather than accessing field directly.
(fhandler_tty_common::__release_output_mutex): Ditto.
@
text
@d910 1
d912 1
@


1.159
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@d121 1
a121 1
      if (strace.active)
d140 1
a140 1
      if (strace.active)
@


1.158
log
@* fhandler.h (fhandler_pipe::fixup_in_child): Declare new function.
(fhandler_console::invisible_console): Declare new variable.
(fhandler_console::need_invisible): Ditto.
(fhandler_console::has_a): Ditto.
* fhandler_console.cc (set_console_state_for_spawn): Eliminate return value.
Set up an invisible console if necessary prior to spawning.
(fhandler_console::invisible_console): Define.
* fhandler_tty.cc (fhandler_tty_slave::open): Use
fhandler_console::invisible_console to setup an invisible console.
* pipe.cc (fhandler_pipe::fixup_in_child): Define new function from
fixup_after_exec.
(fhandler_pipe::fixup_after_exec): Use fixup_in_child when appropriate.
(fhandler_pipe::fixup_after_fork): Ditto.
* spawn.cc (handle): Reorganize and modernize a little.
(spawn_guts): Rely on set_console_state_for_spawn to set the console into the
right state but don't create the process with "detached" flag if we have no
controlling tty since that confuses 'cmd'.
* dtable.cc (dtable::stdio_init): Don't set console as controlling terminal if
we have an invisible console.
* sigproc.cc (child_info::sync): Use correct name in ForceCloseHandle1.
@
text
@d115 1
a115 1
  if (strace.active)
@


1.157
log
@* fhandler_tty.cc (fhandler_tty::open): Enhance comment.
@
text
@d579 2
a580 46
      && !GetConsoleCP () && !output_done_event
      && wincap.pty_needs_alloc_console ())
    {
      BOOL b;
      HWINSTA h, horig;
      /* The intent here is to allocate an "invisible" console if we have no
	 controlling tty or to reuse the existing console if we already have
	 a tty.  So, first get the old windows station.  If there is no controlling
	 terminal, create a new windows station and then set it as the current
	 windows station.  The subsequent AllocConsole will then be allocated
	 invisibly.  But, after doing that we have to restore any existing windows
	 station or, strangely, characters will not be displayed in any windows
	 drawn on the current screen.  We only do this if we have changed to
	 a new windows station and if we had an existing windows station previously.
	 We also close the previously opened work station even though AllocConsole
	 is now "using" it.  This doesn't seem to cause any problems.

	 Things to watch out for if you make changes in this code:

	 - Flashing, black consoles showing up when you start, e.g., ssh in
	   an xterm.
	 - Non-displaying of characters in rxvt or xemacs if you start a
	   process using setsid: bash -lc "setsid rxvt".  */

      h = horig = GetProcessWindowStation ();
      if (myself->ctty == -1)
        {
	  h = CreateWindowStation (NULL, 0, WINSTA_ALL_ACCESS, &sec_none_nih);
	  termios_printf ("CreateWindowStation %p, %E", h);
	  if (h)
	    {
	      b = SetProcessWindowStation (h);
	      termios_printf ("SetProcessWindowStation %d, %E", b);
	    }
	}
      b = AllocConsole ();	// will cause flashing if workstation
				// stuff fails
      if (horig && h && h != horig)
	{
	  SetProcessWindowStation (horig);
	  CloseHandle (h);
	}
      termios_printf ("%d = AllocConsole (), %E", b);
      if (b)
	init_console_handler (TRUE);
    }
@


1.156
log
@	* fhandler_tty.cc (fhandler_tty::open): Close newly created window
	station after switching to original window station.
@
text
@d593 9
a602 1
	 Phew.  */
@


1.155
log
@* fhandler_tty.cc (fhandler_tty::open): Add a comment.
@
text
@d608 5
a612 2
      if (horig && h != horig)
	SetProcessWindowStation (horig);
@


1.154
log
@* times.cc (systime): Correct precision referenced in comment.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't free original windows
station since that will cause strange problems displaying fonts.  Reset windows
station to original station after creating console.
* times.cc (hires_ms::usecs): Only reprime when calculated time is less than
system time.
@
text
@d584 11
@


1.153
log
@* fhandler_tty.cc (fhandler_tty_slave::open): Reset the current windows station
whenever ctty == -1 regardles of whetehr there's a windows station already
assigned.  Close the old windows station in this situation.
* pinfo.cc (_pinfo::set_ctty): Reinstate incrementing of console count when
recording ctty so that the current tty is always around.
@
text
@d583 2
a584 1
      HWINSTA horig = GetProcessWindowStation ();
d587 1
a587 1
	  HWINSTA h = CreateWindowStation (NULL, 0, GENERIC_READ | GENERIC_WRITE, &sec_none_nih);
a593 2
	  if (horig)
	    CloseWindowStation (horig);
d597 2
@


1.152
log
@	* fhandler_tty.cc (fhandler_tty_slave::open):  Don't expect that
	service applications have no window station attached.
@
text
@d583 2
a584 1
      if (!GetProcessWindowStation ())
d593 2
@


1.151
log
@* fhandler.h (fhandler_console::fixup_after_fork_exec): Declare new function.
(fhandler_console::fixup_after_fork): Use fixup_after_fork_exec.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Delete definition.
(fhandler_console::fixup_after_fork_exec): Rename from fixup_after_exec.
* pinfo.cc (_pinfo::set_ctty): Don't play with console count here.
* syscalls.cc (close_all_files): Don't close cygheap ctty if hExeced since the
child will be copying information from us.
(setsid): Use myctty() rather than raw ctty #.
@
text
@d580 1
a580 1
      && wincap.pty_needs_alloc_console () && !GetProcessWindowStation ())
d583 9
a591 6
      HWINSTA h = CreateWindowStation (NULL, 0, GENERIC_READ | GENERIC_WRITE, &sec_none_nih);
      termios_printf ("CreateWindowStation %p, %E", h);
      if (h)
	{
	  b = SetProcessWindowStation (h);
	  termios_printf ("SetProcessWindowStation %d, %E", b);
@


1.150
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d453 1
a453 2
  fhandler_tty_slave *arch = (fhandler_tty_slave *)
    cygheap->fdtab.find_archetype (pc.dev);
@


1.149
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d460 1
a460 1
      cygheap->open_fhs++;
d579 2
a580 1
  if (cygheap->open_fhs++ == 0 && !GetConsoleCP () && !output_done_event
d607 1
a607 1
  report_tty_counts (this, "opened", "incremented ", "");
d618 1
a618 2
      if (!--cygheap->open_fhs && myself->ctty == -1)
	FreeConsole ();
d621 1
a621 1
      report_tty_counts (this, "closed", "decremented ", "");
d924 2
a925 2
  cygheap->open_fhs++;
  report_tty_counts (child, "duped", "incremented ", "");
d1073 2
a1074 2
      termios_printf ("bg ioctl pgid %d, tpgid %d, ctty %d",
		      myself->pgid, get_ttyp ()->getpgid (), myself->ctty);
d1392 1
a1392 1
  report_tty_counts (this, "inherited", "", "");
d1437 1
a1437 1
  cygheap->open_fhs--;		/* handled when individual fds are opened */
@


1.148
log
@	Revert erroneous checkin.
@
text
@d84 1
a84 1
  h = new cygthread (process_input, cygself, "ttyin");
d88 1
a88 1
  h = new cygthread (process_ioctl, cygself, "ttyioctl");
d92 1
a92 1
  h = new cygthread (process_output, cygself, "ttyout");
@


1.147
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d918 1
a918 1
fhandler_tty_slave::dup (fhandler_base *child, HANDLE from_proc)
a920 3
  if (!arch)	/* Might happen on descriptor passing */
    return !((fhandler_tty_slave *) child)->open (get_flags (), 0);

d931 1
a931 1
fhandler_tty_common::dup (fhandler_base *child, HANDLE from_proc)
d944 1
a944 1
  else if (!DuplicateHandle (from_proc, output_done_event, hMainProc,
d953 1
a953 1
  else if (!DuplicateHandle (from_proc, ioctl_request_event, hMainProc,
d962 1
a962 1
  else if (!DuplicateHandle (from_proc, ioctl_done_event, hMainProc,
d969 1
a969 1
  if (!DuplicateHandle (from_proc, input_available_event, hMainProc,
d976 1
a976 1
  if (!DuplicateHandle (from_proc, output_mutex, hMainProc,
d983 1
a983 1
  if (!DuplicateHandle (from_proc, input_mutex, hMainProc,
d990 1
a990 1
  if (!DuplicateHandle (from_proc, get_handle (), hMainProc,
d999 1
a999 1
  if (!DuplicateHandle (from_proc, get_output_handle (), hMainProc,
d1010 1
a1010 1
  else if (!DuplicateHandle (from_proc, inuse, hMainProc,
@


1.146
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d918 1
a918 1
fhandler_tty_slave::dup (fhandler_base *child)
d921 3
d934 1
a934 1
fhandler_tty_common::dup (fhandler_base *child)
d947 1
a947 1
  else if (!DuplicateHandle (hMainProc, output_done_event, hMainProc,
d956 1
a956 1
  else if (!DuplicateHandle (hMainProc, ioctl_request_event, hMainProc,
d965 1
a965 1
  else if (!DuplicateHandle (hMainProc, ioctl_done_event, hMainProc,
d972 1
a972 1
  if (!DuplicateHandle (hMainProc, input_available_event, hMainProc,
d979 1
a979 1
  if (!DuplicateHandle (hMainProc, output_mutex, hMainProc,
d986 1
a986 1
  if (!DuplicateHandle (hMainProc, input_mutex, hMainProc,
d993 1
a993 1
  if (!DuplicateHandle (hMainProc, get_handle (), hMainProc,
d1002 1
a1002 1
  if (!DuplicateHandle (hMainProc, get_output_handle (), hMainProc,
d1013 1
a1013 1
  else if (!DuplicateHandle (hMainProc, inuse, hMainProc,
@


1.145
log
@* fhandler.h (fhandler_tty_common::lseek): Declare new method.
(fhandler_tty_slave::lseek): Delete old method.
(fhandler_tty_master::lseek): Delete old method.
* fhandler_tty.cc (fhandler_tty_common::lseek): Define new method.
@
text
@a914 1
  return;
a1284 1
  return;
@


1.144
log
@* dcrt0.cc (dll_crt0_1): Tweak debugging stuff.
* fhandler_tty.cc (fhandler_tty_common::close): Rearrange the code so that the
master end of the input and output pipes is closed before signalling an EOF
event to the slave.
(fhandler_pty_master::close): Likewise.
@
text
@d1183 7
@


1.143
log
@	* fhandler_tty.cc (fhandler_tty_slave::tcflush): Return either 0 or -1.
@
text
@d1199 4
a1212 4
  if (!ForceCloseHandle1 (get_handle (), from_pty))
    termios_printf ("CloseHandle (get_handle ()<%p>), %E", get_handle ());
  if (!ForceCloseHandle1 (get_output_handle (), to_pty))
    termios_printf ("CloseHandle (get_output_handle ()<%p>), %E", get_output_handle ());
a1228 1
  fhandler_tty_common::close ();
d1230 3
a1232 1
  if (!get_ttyp ()->master_alive ())
d1245 3
@


1.142
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d1054 1
a1054 1
      ret = ((int) len) >= 0;
@


1.141
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d170 1
a170 1
  (void) WaitForSingleObject (input_mutex, INFINITE);
@


1.140
log
@* cygerrno.h: Make multi-inclusion safe.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Deal with EINTR.
* dcrt0.cc (dll_crt0_0): Accommodate init_console_handler argument change.
* winsup.h: Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* exceptions.cc (init_console_handler): Ditto.  Ignore console events if we're
not attached to a terminal.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* wincap.cc: Implement has_null_console_handler_routine throughout.
* wincap.h: Ditto.
@
text
@d615 4
a618 2
  if (!--cygheap->open_fhs && myself->ctty == -1)
    FreeConsole ();
d620 2
a621 2
  archetype->usecount--;
  report_tty_counts (this, "closed", "decremented ", "");
d623 2
a624 2
  if (archetype->usecount)
    {
d626 2
a627 2
      if (archetype->usecount < 0)
	system_printf ("error: usecount %d", archetype->usecount);
d629 3
a631 2
      termios_printf ("just returning because archetype usecount is != 0");
      return 0;
d1214 5
a1218 2
  inuse = NULL;
  set_io_handle (NULL);
d1244 2
a1245 1
      get_ttyp ()->init ();
@


1.139
log
@* fhandler_tty.cc (fhandler_tty_slave:tcflush): Use signed comparison.
@
text
@d594 1
a594 1
	init_console_handler ();
@


1.138
log
@* fhandler_tty.cc (fhandler_tty_slave::read): Actually read input when vmin ==
vtime == 0.
@
text
@d1051 1
a1051 1
      ret = len >= 0;
@


1.137
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d818 1
a818 1
      if (ptr && !vmin && !time_to_wait)
@


1.136
log
@	* fhandler_tty.cc (fhandler_tty_slave::read): Use previously
	evaluated time_to_wait value.
@
text
@d774 4
a777 1
	break;
@


1.136.2.1
log
@checkpoint
@
text
@d774 1
a774 4
	{
	  termios_printf ("wait timed out, waiter %u", waiter);
	  break;
	}
@


1.135
log
@	* fhandler_tty.cc (fhandler_tty_slave::open): Use requested flag
	values also when copying fhandler from archetype.
@
text
@d768 1
a768 1
  DWORD waiter = !ptr ? 0 : INFINITE;
@


1.134
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d459 1
@


1.133
log
@* tty.cc (tty_list::allocate_tty): Leave tty_mutex armed on successful return
from !with_console
* fhandler_tty.cc (fhandler_pty_master::open): Release tty_mutex here after all
initialization is done.
@
text
@d302 1
a302 1
	        goto out;
d590 1
a590 1
			    	// stuff fails
d812 1
a812 1
        len = (size_t) bytes_in_pipe;
d850 1
a850 1
	        {
d867 1
a867 1
        }
d1417 1
a1417 1
  cygheap->open_fhs--;  	/* handled when individual fds are opened */
@


1.132
log
@Change the name "title_mutex" to "tty_mutex" throughout.
* tty.h (tty_list::allocate_tty): Turn argument into a boolean.
* tty.cc (tty_list::init): Protect entire allocation operation with tty_mutex
(formerly title_mutex) to protect against allocation races.
@
text
@d1167 1
@


1.131
log
@2004-05-12  Pierre Humblet <pierre.humblet@@ieee.org>

	* tty.h: Remove the %d or %x from all cygtty strings.
	(tty::open_output_mutex): Only declare.
	(tty::open_input_mutex): Ditto.
	(tty::open_mutex): New definition.
	* fhandlet_tty.cc (fhandler_tty_slave::open): Declare buf with
	size CYG_MAX_PATH and replace __small_printf calls by shared_name.
	* tty.cc (tty::create_inuse): Ditto.
	(tty::get_event): Ditto.
	(tty::common_init): Ditto.
	(tty::open_output_mutex): New method definition.
	(tty::open_input_mutex): Ditto.
	(tty::open_mutex): New method.
@
text
@d1160 1
a1160 1
  int ntty = cygwin_shared->tty.allocate_tty (0);
@


1.130
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d469 1
a469 1
  char buf[40];
d476 1
a476 1
  __small_sprintf (buf, OUTPUT_DONE_EVENT, get_unit ());
d491 1
a491 1
  __small_sprintf (buf, INPUT_AVAILABLE_EVENT, get_unit ());
d501 1
a501 1
  __small_sprintf (buf, IOCTL_REQUEST_EVENT, get_unit ());
d503 1
a503 1
  __small_sprintf (buf, IOCTL_DONE_EVENT, get_unit ());
@


1.129
log
@Throughout, change name from set_inheritance to set_no_inheritance to better
reflect input arguments of this function.
* cygheap.h (CYGHEAPSIZE): Increase size of cygheap to something closer to the
21st century.
@
text
@d443 1
a443 1
  set_r_no_interrupt (1);
d1337 1
a1337 1
fhandler_tty_common::set_close_on_exec (int val)
d1340 1
a1340 1
    set_close_on_exec_flag (val);
d1362 1
a1362 1
      set_close_on_exec_flag (val);
d1394 1
a1394 1
fhandler_pty_master::set_close_on_exec (int val)
d1417 1
a1417 1
  console->set_r_no_interrupt (1);
@


1.128
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d1344 1
a1344 1
	set_inheritance (output_done_event, val);
d1346 1
a1346 1
	set_inheritance (ioctl_request_event, val);
d1348 1
a1348 1
	set_inheritance (ioctl_done_event, val);
d1350 5
a1354 5
	set_inheritance (inuse, val);
      set_inheritance (output_mutex, val);
      set_inheritance (input_mutex, val);
      set_inheritance (input_available_event, val);
      set_inheritance (output_handle, val);
d1361 1
a1361 1
      set_inheritance (get_io_handle (), val);
@


1.127
log
@* fhandler_tty.cc (fhandler_tty::ioctl): Semi-revert 2003-09-26 change for
TIOCSWINSZ.  It is not an error for ioctl_request_event to be missing.
* sigproc.cc (pending_signals::save): New function.
(pending_signals::restore): Ditto.
(sig_clear): Save/restore current queue pointer.
(wait_sig): Delete signals marked as such.
* sigproc.h (__SIGDELETE): New enum.
@
text
@d556 1
d565 1
@


1.126
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002, 2003 Red Hat, Inc.
d1105 6
a1110 2
	  if (!ioctl_request_event)
	    get_ttyp ()->ioctl_retval = -EINVAL;
a1112 2
	      get_ttyp ()->arg.winsize = *(struct winsize *) arg;
	      SetEvent (ioctl_request_event);
a1114 2
	      if (ioctl_done_event)
		WaitForSingleObject (ioctl_done_event, INFINITE);
d1116 2
@


1.125
log
@Move open_fhs from fhandler.h to cygheap.h for easier tracking.  Accommodate
this change throughout.
* dtable.cc (dtable::add_archetype): Use correct count when iterating through
*active* archetypes.
* dtable.cc (dtable::fixup_after_exec): Close handle if close_on_exec and
archetype exists since archetype currently does not set windows close-on-exec
flag (FIXME).
* fhandler_tty.cc (fhandler_tty_slave::open): Change debugging output slightly.
(fhandler_tty_slave::close): Ditto.
(fhandler_tty_slave::fixup_after_fork): Just report on inherited use counts
since since archetype currently does not set windows close-on-exec flag
(FIXME).
* pinfo.cc (_pinfo::set_ctty): Change debugging output slightly.
* cygheap.cc (cygheap_init): Remove open_fhs accommodation and use count
reporting.
* perthread.h (vfork_save::fhctty): New element.
* perthread.h (vfork_save::open_fhs): New element.
* fork.cc (vfork): Muck around with ctty and open_fhs stuff, both of which are
now saved in the vfork_save structure.
@
text
@d1112 1
a1112 1
	      kill (-get_ttyp ()->getpgid (), SIGWINCH);
d1310 1
a1310 1
	    kill (-get_ttyp ()->getpgid (), SIGWINCH);
@


1.125.6.1
log
@* fhandler_tty.cc (fhandler_tty::ioctl): Semi-revert 2003-09-26 change for
TIOCSWINSZ.  It is not an error for ioctl_request_event to be missing.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d1105 3
a1107 2
	  get_ttyp ()->arg.winsize = *(struct winsize *) arg;
	  if (ioctl_request_event)
d1109 1
a1109 1
	      get_ttyp ()->ioctl_retval = -EINVAL;
a1110 3
	    }
	  else
	    {
d1113 2
a1115 2
	  if (ioctl_done_event)
	    WaitForSingleObject (ioctl_done_event, INFINITE);
@


1.125.6.2
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a555 1
      VerifyHandle (from_master_local);
a563 1
      VerifyHandle (to_master_local);
@


1.125.2.1
log
@* gentls_offsets: Reinstate unlink of temp files.
@
text
@d1112 1
a1112 1
	      killsys (-get_ttyp ()->getpgid (), SIGWINCH);
d1310 1
a1310 1
	    killsys (-get_ttyp ()->getpgid (), SIGWINCH);
@


1.124
log
@* fhandler.h (fhandler_tty_slave::archetype): Make public.
(report_tty_counts): New macro.  Use throughout for reporting tty use counts.
* dtable.cc (dtable::vfork_child_dup): Add debugging output for usecount
increment.  Increment open_fhs if appropriate.
(dtable::vfork_parent_restore): "Close" artificially bumped ctty.
(dtable::vfork_child_fixup): Close ctty since it was bumped prior to vfork.
Save open_fhs around close since the closing of these handles has no effect on
the console.
* fhandler_tty.cc (fhandler_tty_slave::open): Reorganize calls to allow for
easier tracking of usecount modification.
(fhandler_tty_slave::open): Ditto.
@
text
@d458 2
a459 2
      termios_printf ("copied tty fhandler from cygheap");
      fhandler_console::open_fhs++;
d576 2
a577 3
  if (fhandler_console::open_fhs++ == 0 && !GetConsoleCP ()
      && !output_done_event && wincap.pty_needs_alloc_console ()
      && !GetProcessWindowStation ())
d612 1
a612 1
  if (!--fhandler_console::open_fhs && myself->ctty == -1)
d622 1
a622 1
	system_printf ("usecount %d", archetype->usecount);
d624 1
a624 1
      termios_printf ("just returning because archetype usecount is > 0");
d628 1
a628 1
  termios_printf ("closing last open %s handle", pc.dev.name);
d916 1
a916 1
  fhandler_console::open_fhs++;
d1366 2
a1367 3
  fhandler_console::open_fhs++;
  termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
  fhandler_tty_common::fixup_after_fork (parent);
d1412 1
a1412 1
  fhandler_console::open_fhs--;  /* handled when individual fds are opened */
@


1.123
log
@* fhandler.h (fhandler_tty_master::fixup_after_fork): Remove declaration.
(fhandler_tty_master::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Fix so that children do not
inherit master tty handles.
(fhandler_tty_master::fixup_after_fork): Remove, since it was never used.
(fhandler_tty_master::fixup_after_exec): Ditto.
* pinfo.cc (_pinfo::set_ctty): Increment open_fhs when ctty is set.
* cygheap.cc (cygheap_init): Ditto.
* syscalls.cc (setsid): *Always* call close on opened ctty since the archetype
is associated with the ctty and it counts as an opened handle.
* tty.cc (tty::common_init): Don't protect input/output mutex since it confuses
subsequent fork/execs when CYGWIN=tty.
@
text
@d604 1
a605 2
  termios_printf ("%s opened, incremented open_fhs %d, archetype usecount %d",
		  pc.dev.name, fhandler_console::open_fhs, archetype->usecount);
d615 5
a619 3
  termios_printf ("decremented open_fhs %d, archetype usecount %d",
		  fhandler_console::open_fhs, archetype->usecount);
  if (--archetype->usecount)
a912 1
  fhandler_console::open_fhs++;
d915 1
d917 2
a918 1
  child->usecount = 0;
a919 2
  termios_printf ("incremented open_fhs %d, archetype usecount %d",
		  fhandler_console::open_fhs, archetype->usecount);
@


1.122
log
@* exceptions.cc (try_to_debug): Fix off-by-one problem when resetting
environment variable after error_start detected.
* fhandler_tty_slave.cc (fhandler_tty_slave::close): Clarify debug message.
* syscalls.cc (setsid): Don't increment usecount here, since it will be
automatically decremented on close.
@
text
@d81 1
a1403 14
}

void
fhandler_tty_master::fixup_after_fork (HANDLE child)
{
  fhandler_pty_master::fixup_after_fork (child);
  console->fixup_after_fork (child);
}

void
fhandler_tty_master::fixup_after_exec (HANDLE)
{
  console->close ();
  init_console ();
@


1.121
log
@* dtable.cc (dtable::delete_archetype): Add debugging.
(dtable::release): Move archetype deletion here.
(dtable::vfork_child_dup): Increment ctty usecount to catch later
close_all_files case in parent/child.
(dtable::vfork_child_fixup): Avoid using cygheap->foo where this should really
be using local references.  Call close on archetyped handles since the handles
haven't had the noninherit flag set.
* fhandler_tty.cc (fhandler_tty_slave::close): Remove archetype deletion code.
Add defensive error message when DEBUGGING.
(fhandler_tty_common::set_close_on_exec): Use more robust method for checking
whether to set handles into noninherit if there is an archetype associated with
the fhandler.
@
text
@d623 1
a623 1
      termios_printf ("just exiting because archetype usecount is > 0");
@


1.120
log
@* cygheap.h (cygheap_types): Add HEAP_ARCHETYPES.
(init_cheap::ctty): Change to pointer.
* dtable.h (dtable::find_archetype): Declare new function.
(dtable::add_archetype): Declare new function.
(dtable::delete_archetype): Declare new function.
(dtable::narchetypes): Declare.
(dtable::farchetypes): Declare.
(dtable::initial_archetype_size): Declare.
(dtable::dtable): Initialize new fields.
(dtable::initial_archetype_size): Declare.
* dtable.cc (dtable::find_archetype): Define new function.
(dtable::add_archetype): Define new function.
(dtable::delete_archetype): Define new function.
(dtable::initial_archetype_size): Define.
* fhandler.h (fhandler_base::archetype): Declare.
(fhandler_base::usecount): Declare.
* fhandler.cc (fhandler_base::fhandler_base): Initialize new fields.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass NULL to third
argument of set_ctty.
* fhandler_tty.cc (fhandler_tty_slave::open): Accommodate new archetype method
to create only one instance of a tty.
(fhandler_tty_slave::close): Don't close handles unless archetype usecount is
zero.  When that happens, close archetype too.
(fhandler_tty_slave::dup): Just copy archetype.  Set use count appropriately.
Set ctty, if appropriate.
(fhandler_tty_common::dup): Remove slave considerations.
(fhandler_tty_common::set_close_on_exec): Remove cygheap->ctty considerations.
* pinfo.cc (_pinfo::set_ctty): Accommodate new archetype methods.
* pinfo.h (_pinfo::set_ctty): Make third argument explicit.
* syscalls.cc (close_all_files): Decrement controlling tty use count before
closing all handles to allow controlling tty to be closed.  Remove previous
controlling tty considerations.
@
text
@d619 4
d628 1
a628 4
  fhandler_tty_slave *arch = (fhandler_tty_slave *) archetype;
  int res = fhandler_tty_common::close ();
  cygheap->fdtab.delete_archetype (arch);
  return res;
d914 1
a914 1
  archetype->usecount++;
d1335 1
a1335 1
  if (get_major () == DEV_TTYS_MAJOR)
@


1.119
log
@remove debug output
@
text
@d450 1
a450 3
  if (get_device () != FH_TTY)
    /* nothing to do */;
  else if (!cygheap->ctty.get_io_handle ())
d452 3
a454 1
  else
d456 2
a457 1
      *this = cygheap->ctty;
d459 1
a459 2
      termios_printf ("copied tty fhandler from cygheap");
      return 1;
d522 3
a524 2
  HANDLE from_master_local = NULL;
  HANDLE to_master_local = NULL;
a572 1
  myself->set_ctty (get_ttyp (), flags, this);
d593 13
a605 2
  termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
  termios_printf ("tty%d opened", get_unit ());
d615 13
a627 4
  termios_printf ("decremented open_fhs %d", fhandler_console::open_fhs);
  if (myself->ctty >= 0 && get_io_handle () == cygheap->ctty.get_io_handle ())
    return 0;
  return fhandler_tty_common::close ();
d911 8
a918 2
  termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
  return fhandler_tty_common::dup (child);
a926 7
  if (get_io_handle () == cygheap->ctty.get_io_handle ())
    {
      *fts = cygheap->ctty;
      termios_printf ("duped ctty");
      return 0;
    }

a1008 3
  if (get_major () == DEV_TTYS_MAJOR)
    myself->set_ctty (get_ttyp (), openflags, fts);

d1334 1
a1334 2
  if (get_major () == DEV_TTYS_MAJOR
      && get_io_handle () == cygheap->ctty.get_io_handle ())
@


1.118
log
@* fhandler_tty.cc (fhandler_tty_common::dup): Just copy cygheap->ctty to child
if duping the current ctty.
(fhandler_tty_common::close): Move debugging statement earlier in function.
(fhandler_tty_slave::close): Return success when closing ctty.
* syscalls.cc (close_all_files): Avoid calling fhandler_tty_slave close method
so that open_fhs will not be decremented when closing cygheap ctty.
(setsid): Ditto.
* dcrt0.cc (do_exit): Reorganize to avoid leaving a critical section active
after vfork.
* fhandler.h (fhandler_tty_slave::get_unit): Remove regparm parameter since it
can't work in a virtualized function.
@
text
@a900 1
debug_printf ("get_io_handle %p, cygheap->ctty.get_io_handle %p",get_io_handle (),cygheap->ctty.get_io_handle ());
@


1.117
log
@* fhandler.h (fhandler_tty_slave::ttyname): Use name from pc since it is
guaranteed to be accurate.
* fhandler_tty.cc (fhandler_tty_slave::open): Increment open_fhs appropriate
when copying ctty.
(fhandler_tty_slave::close): Remove special case handling for exit_state.  Use
ctty < 0 check instead.
(fhandler_tty_common::close): Set io_handle to NULL after closing.
* syscalls.cc (close_all_files): Specifically close cygheap->ctty, if
appropriate.
@
text
@d606 1
a606 1
    return 1;
d901 8
d992 1
a992 1
    myself->set_ctty (get_ttyp (), openflags, (fhandler_tty_slave *) this);
d1158 1
d1186 1
a1187 3

  inuse = NULL;
  termios_printf ("tty%d <%p,%p> closed", get_unit (), get_handle (), get_output_handle ());
@


1.116
log
@* spawn.cc (spawn_guts): Change type back to 'int' after erroneous change
below.
@
text
@d457 1
d605 1
a605 1
  if (!exit_state && get_io_handle () == cygheap->ctty.get_io_handle ())
d1176 2
@


1.115
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@a1308 9
#ifndef DEBUGGING
  fhandler_base::set_close_on_exec (val);
#else
  /* FIXME: This is a duplication from fhandler_base::set_close_on_exec.
     It is here because we need to specify the "from_pty" stuff here or
     we'll get warnings from ForceCloseHandle when debugging. */
  set_inheritance (get_io_handle (), val);
  set_close_on_exec_flag (val);
#endif
d1326 9
@


1.114
log
@* fhandler_tty.cc (fhandler_tty_slave::ioctl): Properly set return value in
FIONBIO case.
@
text
@d450 11
a463 1
  tc->set_ctty (get_unit (), flags);
d508 1
a508 1
    get_ttyp ()->was_opened = TRUE;
d521 2
a522 1
  HANDLE from_master_local, to_master_local;
d571 1
d604 2
a902 1
  tc->set_ctty (get_unit (), openflags);
d981 4
d1318 18
a1335 12
  if (output_done_event)
    set_inheritance (output_done_event, val);
  if (ioctl_request_event)
    set_inheritance (ioctl_request_event, val);
  if (ioctl_done_event)
    set_inheritance (ioctl_done_event, val);
  if (inuse)
    set_inheritance (inuse, val);
  set_inheritance (output_mutex, val);
  set_inheritance (input_mutex, val);
  set_inheritance (input_available_event, val);
  set_inheritance (output_handle, val);
@


1.113
log
@	* Makefile.in: Add $(LIBSERVER) rule.
	* cygserver.h: Moved from include/cygwin to here.
	* cygserver_ipc.h: Moved from ../cygserver to here.
	* cygserver_shm.h: Ditto.
	* cygwin.din: Add shmat, shmctl, shmdt and shmget.
	* fhandler_tty.cc (fhandler_tty_slave::open): Don't warn about handle
	dup'ing if not build with USE_SERVER.
	* shm.cc: Include cygerrno.h unconditionally.
	(shmat): Set errno to ENOSYS and return -1 if not build with
	USE_SERVER.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.
	* woutsup.h: Remove.
	* include/cygwin/cygserver_process.h: Moved to ../cygserver directory.
	* include/cygwin/cygserver_transport.h: Ditto.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1028 1
d1037 1
d1091 1
a1091 3

out:
  int retval = get_ttyp ()->ioctl_retval;
d1097 2
@


1.112
log
@* fhandler_tty.cc (fhandler_tty_slave::open): Don't create a new window station
if one already exists.
@
text
@d28 1
a28 1
#include "cygwin/cygserver.h"
d519 1
d521 1
a521 1

@


1.111
log
@* Makefile.in: Add YA method for generating devices.cc.
* child_info.h: YA update of another magic number.
* gendevices: New file.
* devices.in: New file.
* devices.cc: Regenerate.
* devices.shilka: Remove.
* devices.h: Correctly define device pointers.
(device): Remove now obsolete fields.
(device::native): Renamed from device::fmt.
* dtable.cc (build_fh_dev): Simplify in light of new unit parsing scheme.
(build_fh_pc): Ditto.
* path.cc (win32_device_name): Ditto.
* fhandler.h (fhandler_base::get_native_name): Reflect renaming of fmt to
native.
* fhandler_tty.cc (fhandler_tty_mster::init): Initialize slave device prior to
reporting unit.
@
text
@d562 2
a563 1
      && !output_done_event && wincap.pty_needs_alloc_console ())
@


1.110
log
@* fhandler_tty.cc (fhandler_tty_slave::ioctl): Properly set ioctl_request event
when window size changes.  Store failing errno in ioctl_retval (needed?).
@
text
@d63 1
a64 2

  slave = dev ();
@


1.109
log
@* fhandler_console.c (fhandler_console::read): Record the state of the SHIFT,
CTRL and ALT keys at the time of the last keyboard input event.
(fhandler_console::ioctl): Handle requests to retrieve the keyboard modifiers
via the TIOCLINUX command.
* fhandler_tty.c (fhandler_tty_slave::read): Ditto.
* include/sys/termios.h (TIOCLINUX): New macro definition.
@
text
@d1060 3
a1062 2
	  get_ttyp ()->arg.winsize = *(struct winsize *) arg;
	  if (ioctl_request_event)
d1064 1
a1064 1
	      get_ttyp ()->ioctl_retval = -1;
a1065 3
	    }
	  else
	    {
d1068 2
a1070 2
	  if (ioctl_done_event)
	    WaitForSingleObject (ioctl_done_event, INFINITE);
d1074 4
a1077 2
      int val = * (unsigned char *) arg;
      if (val == 6 && ioctl_request_event && ioctl_done_event)
d1079 1
a1079 1
	  get_ttyp ()->arg.value = val; 
d1082 1
a1082 6
	  * (unsigned char *) arg = get_ttyp ()->arg.value & 0xFF;
	}
      else
	{
	  get_ttyp ()->ioctl_retval = -1;
	  set_errno (EINVAL);
d1090 8
a1097 2
  termios_printf ("%d = ioctl (%x)", get_ttyp ()->ioctl_retval, cmd);
  return get_ttyp ()->ioctl_retval;
d1254 1
a1254 1
	pktmode = * (int *) arg;
d1263 1
a1263 1
	    get_ttyp ()->winsize = * (struct winsize *) arg;
@


1.108
log
@* include/tzfile.h: Add some missing entries.
@
text
@d1031 1
d1073 15
@


1.107
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d1128 1
a1128 1
      termios_printf ("no more masters left. sending EOF" );
@


1.106
log
@	* fhandler_tty.cc (fhandler_pty_master::process_slave_output):
	Handle buf == NULL as flushing the buffer.
	(fhandler_tty_slave::read): Handle ptr == NULL as flushing the buffer.
	(fhandler_tty_slave::tcflush): Implement input queue flushing by
	calling read with NULL buffer.
	(fhandler_pty_master::tcflush): Ditto, calling process_slave_output.
	* termios.cc (tcflush): Check for legal `queue' value.  Return
	EINVAL otherwise.
@
text
@d21 1
a22 1
#include "path.h"
d39 7
a45 2
fhandler_tty_master::fhandler_tty_master (int unit)
  : fhandler_pty_master (FH_TTYM, unit), console (NULL)
d47 1
d61 1
a61 1
fhandler_tty_master::init (int ntty)
d63 3
a65 1
  termios_printf ("Creating master for tty%d", ntty);
d77 1
a77 3
  ttynum = ntty;

  cygwin_shared->tty[ttynum]->common_init (this);
a439 6
fhandler_tty_slave::fhandler_tty_slave (int num)
  : fhandler_tty_common (FH_TTYS, num)
{
  set_r_no_interrupt (1);
}

d441 1
a441 1
  : fhandler_tty_common (FH_TTYS, 0)
d449 1
a449 1
fhandler_tty_slave::open (path_conv *, int flags, mode_t)
d451 1
a451 1
  tcinit (cygwin_shared->tty[ttynum]);
d453 2
a454 2
  attach_tty (ttynum);
  tc->set_ctty (ttynum, flags);
d465 1
a465 1
  __small_sprintf (buf, OUTPUT_DONE_EVENT, ttynum);
d480 1
a480 1
  __small_sprintf (buf, INPUT_AVAILABLE_EVENT, ttynum);
d490 1
a490 1
  __small_sprintf (buf, IOCTL_REQUEST_EVENT, ttynum);
d492 1
a492 1
  __small_sprintf (buf, IOCTL_DONE_EVENT, ttynum);
d528 1
a528 1
			  ttynum, get_ttyp ()->master_pid);
d580 1
a580 1
  termios_printf ("tty%d opened", ttynum);
d621 1
a621 1
  int mode = 0;
d625 1
a625 1
    mode = O_RDONLY;
d627 1
a627 1
    mode = O_WRONLY;
d629 1
a629 1
    mode = O_RDWR;
d631 1
a631 1
  open (0, mode);
d639 1
a639 1
  termios_printf ("tty%d, write(%x, %d)", ttynum, ptr, len);
a884 1
  fts->ttynum = ttynum;
d887 2
a888 2
  attach_tty (ttynum);
  tc->set_ctty (ttynum, openflags);
d1019 1
a1019 1
      && myself->ctty == ttynum && (get_ttyp ()->ti.c_lflag & TOSTOP))
d1086 2
a1087 2
fhandler_pty_master::fhandler_pty_master (DWORD devtype, int unit)
  : fhandler_tty_common (devtype, unit)
d1092 1
a1092 1
fhandler_pty_master::open (path_conv *, int flags, mode_t)
d1094 2
a1095 2
  ttynum = cygwin_shared->tty.allocate_tty (0);
  if (ttynum < 0)
d1098 3
a1100 1
  cygwin_shared->tty[ttynum]->common_init (this);
d1105 1
a1105 1
  termios_printf ("opened pty master tty%d<%p>", ttynum, this);
d1140 1
a1140 1
  termios_printf ("tty%d <%p,%p> closed", ttynum, get_handle (), get_output_handle ());
d1155 1
a1155 1
      termios_printf ("freeing tty%d (%d)", ttynum, get_ttyp ()->ntty);
d1202 1
a1202 1
  *t = cygwin_shared->tty[ttynum]->ti;
d1209 1
a1209 1
  cygwin_shared->tty[ttynum]->ti = *t;
d1261 1
a1261 1
fhandler_pty_master::ptsname (void)
d1265 1
a1265 1
  __small_sprintf (buf, "/dev/tty%d", ttynum);
d1354 1
a1354 1
  console = (fhandler_console *) cygheap->fdtab.build_fhandler (-1, FH_CONSOLE, "/dev/ttym");
@


1.105
log
@* dcrt0.cc (_dll_crt0): Accommodate breaking apart of early_stuff_init.
* exceptions.cc (early_stuff_init): Delete.
(init_console_handler): New function - top half of early_stuff_init.
(init_global_security): New function - bottom half of early_stuff_init.
(sig_handle): Avoid special hExeced test for SIGINT.  Just terminate the
captive process.
(signal_exit): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't allocate a console if one
already seems to exist.  Properly initialize ctrl-c handling if we do allocate
a console.
* winsup.h (early_stuff_init): Delete declaration.
(init_console_handler): New declaration.
(init_global_security): New declaration.
@
text
@d255 2
a256 1
      buf[0] = '\n';
d294 3
d316 1
a316 1
      if (get_ttyp ()->ti.c_lflag & FLUSHO)
d704 3
a706 1
  if ((get_ttyp ()->ti.c_lflag & ICANON))
d727 1
a727 1
  DWORD waiter = INFINITE;
d770 5
a774 1
      if (!vmin && !time_to_wait)
d783 1
a783 1
      if (vmin && readlen > (unsigned) vmin)
d809 5
a813 2
	      memcpy (ptr, buf, n);
	      ptr = (char *) ptr + n;
d822 7
d993 1
a993 1
fhandler_tty_slave::tcflush (int)
d995 17
a1011 1
  return 0;
d1213 1
a1213 1
fhandler_pty_master::tcflush (int)
d1215 13
a1227 1
  return 0;
@


1.105.2.1
log
@* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Handle buf ==
NULL as flushing the buffer.
(fhandler_tty_slave::read): Handle ptr == NULL as flushing the buffer.
(fhandler_tty_slave::tcflush): Implement input queue flushing by calling read
with NULL buffer.
(fhandler_pty_master::tcflush): Ditto, calling process_slave_output.
* termios.cc (tcflush): Check for legal `queue' value.  Return EINVAL
otherwise.
* syscalls.cc (gethostid): Add lpFreeBytesAvailable argument to
GetDiskFreeSpaceEx call since NT4 requires it.
@
text
@d255 1
a255 2
      if (buf)
	buf[0] = '\n';
a292 3
	      /* DISCARD (FLUSHO) and tcflush can finish here. */
	      if (n == 0 && (get_ttyp ()->ti.c_lflag & FLUSHO || !buf))
	        goto out;
d312 1
a312 1
      if (get_ttyp ()->ti.c_lflag & FLUSHO || !buf)
d700 1
a700 3
  if (!ptr) /* Indicating tcflush(). */
    time_to_wait = 0;
  else if ((get_ttyp ()->ti.c_lflag & ICANON))
d721 1
a721 1
  DWORD waiter = !ptr ? 0 : INFINITE;
d764 1
a764 5
      /* On first peek determine no. of bytes to flush. */
      if (!ptr && len == UINT_MAX)
        len = (size_t) bytes_in_pipe;

      if (ptr && !vmin && !time_to_wait)
d773 1
a773 1
      if (ptr && vmin && readlen > (unsigned) vmin)
d799 2
a800 5
	      if (ptr)
	        {
		  memcpy (ptr, buf, n);
		  ptr = (char *) ptr + n;
		}
a808 7
      if (!ptr)
	{
	  if (!bytes_in_pipe)
	    break;
	  continue;
        }

d973 1
a973 1
fhandler_tty_slave::tcflush (int queue)
d975 1
a975 17
  int ret = 0;

  termios_printf ("tcflush(%d) handle %p", queue, get_handle ());

  if (queue == TCIFLUSH || queue == TCIOFLUSH)
    {
      size_t len = UINT_MAX;
      read (NULL, len);
      ret = len >= 0;
    }
  if (queue == TCOFLUSH || queue == TCIOFLUSH)
    {
      /* do nothing for now. */
    }

  termios_printf ("%d=tcflush(%d)", ret, queue);
  return ret;
d1177 1
a1177 1
fhandler_pty_master::tcflush (int queue)
d1179 1
a1179 13
  int ret = 0;

  termios_printf ("tcflush(%d) handle %p", queue, get_handle ());

  if (queue == TCIFLUSH || queue == TCIOFLUSH)
    ret = process_slave_output (NULL, OUT_BUFFER_SIZE, 0);
  else if (queue == TCIFLUSH || queue == TCIOFLUSH)
    {
      /* do nothing for now. */
    }

  termios_printf ("%d=tcflush(%d)", ret, queue);
  return ret;
@


1.104
log
@* cygheap.cc (_csbrk): More left coercion cleanup.
* fhandler_tty.cc (fhandler_tty_slave::read): Ditto.
(fhandler_tty_slave::write): Ditto.
* fhandler_windows.cc (fhandler_windows::read): Ditto.
* heap.cc (sbrk): Ditto.
@
text
@d558 2
a559 2
  if (fhandler_console::open_fhs++ == 0 && !output_done_event
      && wincap.pty_needs_alloc_console ())
d570 4
a573 2
			    // stuff fails
      termios_printf ("%d = AllocConsole ()", b);
@


1.103
log
@Remove left coercion throughout.
@
text
@d765 1
a765 1
	  (ssize_t) len = bytes_in_pipe;
d845 1
a845 1
  (ssize_t) len = totalread;
d1156 1
a1156 1
  (ssize_t) len = process_slave_output ((char *) ptr, len, pktmode);
@


1.102
log
@Throughout, change USE_CYGSERVER to USE_SERVER.
* Makefile.in (LIBSERVER): Define and use.
* configure.in: Set LIBSERVER as appropriate.
* environ.cc: Rename allow_daemon to allow_server.  Only recognize when
USE_SERVER is defined.
@
text
@d740 1
a740 1
	  (ssize_t) len = -1;
@


1.101
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d510 1
a510 1
#ifdef USE_CYGSERVER
d592 1
a592 1
#ifndef USE_CYGSERVER
@


1.100
log
@* fhandler_tty.cc (fhandler_tty_slave::open): Conditionalize a little more of
the cygserver stuff so that ttys actually work.
@
text
@d558 2
a559 1
  if (!output_done_event)
d561 11
a571 16
      if (fhandler_console::open_fhs++ == 0
	  && wincap.pty_needs_alloc_console ())
	{
	  BOOL b;
	  HWINSTA h = CreateWindowStation (NULL, 0, GENERIC_READ | GENERIC_WRITE, &sec_none_nih);
	  termios_printf ("CreateWindowStation %p, %E", h);
	  if (h)
	    {
	      b = SetProcessWindowStation (h);
	      termios_printf ("SetProcessWindowStation %d, %E", b);
	    }
	  b = AllocConsole ();	// will cause flashing if workstation
	  			// stuff fails
	  termios_printf ("%d = AllocConsole ()", b);
	}
      termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
d573 1
d582 3
a584 6
  if (!output_done_event)
    {
      if (!--fhandler_console::open_fhs && myself->ctty == -1)
	FreeConsole ();
      termios_printf ("decremented open_fhs %d", fhandler_console::open_fhs);
    }
d852 2
a853 5
  if (!output_done_event)
    {
      fhandler_console::open_fhs++;
      termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
    }
d1247 2
a1248 5
  if (!output_done_event)
    {
      fhandler_console::open_fhs++;
      termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
    }
d1308 1
@


1.99
log
@* Makefile.in: Remove cygserver stuff.
* acconfig.h: Add USE_CYGSERVER define.
* config.h.in: Regenerate.
* configure.in: Add --enable-server setting.
* configure: Regenerate.
* fhandler_tty.cc (fhandler_tty_slave::open): Conditionalize compilation of
cygserver stuff.
* fork.cc (fork_child): Ditto.
* shm.cc: Ditto.
* tty.cc (tty::common_init): Ditto.
* dcrt0.cc: Use bool rather than BOOL for CYGWIN environment variable
definitions.
* environ.cc: Ditto.
* ntea.cc: Ditto.
* security.cc: Ditto.
* security.h: Ditto.
* syscalls.cc (check_posix_perm): Remove externs that were already declared in
a header.
* winsup.h: Ditto.  Declare _MT_SAFE here.  Delete it someday since cygwin
should always be _MT_SAFE.
@
text
@d510 1
a511 1
#ifdef USE_CYGSERVER
d513 1
a513 1
      || !cygserver_attach_tty (&from_master_local, &to_master_local)
a514 1
)
d598 3
a603 1
#ifdef USE_CYGSERVER
a612 1
#endif
d615 1
@


1.98
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d510 6
a515 3
  if (!wincap.has_security () ||
      cygserver_running == CYGSERVER_UNAVAIL ||
      !cygserver_attach_tty (&from_master_local, &to_master_local))
d602 1
d612 2
@


1.97
log
@* fhandler_tty.cc (fhandler_tty_slave::close): Free the console when last tty
closes.
@
text
@a16 1
#include <errno.h>
@


1.96
log
@* wincap.h (wincaps:pty_needs_alloc_console): New element.
(wincapc:pty_needs_alloc_console): New function.
* wincap.cc: Add pty_needs_alloc_console throughout.
* fhandler_tty.cc (fhandler_tty_slave::open): Open an "invisible" console on
first pty allocation.
@
text
@d586 2
a587 1
      fhandler_console::open_fhs--;
@


1.95
log
@* fhandler_tty.cc (fhandler_tty_slave::open): Allocate a console whenever a pty
is allocated.
@
text
@d12 2
d559 2
a560 1
      if (fhandler_console::open_fhs++ == 0)
d562 10
a571 1
	  BOOL b = AllocConsole ();
@


1.94
log
@* syscalls.cc (rename): Assume that DELETE_ON_CLOSE works on Win9x.
* fhandler_tty.cc (fhandler_tty_slave::close): Fix typo in debug output.
@
text
@d557 5
a561 1
      fhandler_console::open_fhs++;
@


1.93
log
@* fhandler.h (fhandler_tty_slave::close): Declare new function.
(fhandler_tty_slave::dup): Declare new function.
(fhandler_tty_slave::fixup_after_function): Declare new function.
* fhandler_tty.cc (fhandler_tty_slave_open): Only increment
fhandler_console::open_fhs when associated with a pty.
(fhandler_tty_slave::close): Define new function.  Decrement
fhandler_console::open_fhs when associated with a pty.
(fhandler_tty_slave::dup): Define new function.  Increment
fhandler_console::open_fhs when associated with a pty.
(fhandler_tty_slave::fixup_after_fork): Define new function.  Increment
fhandler_console::open_fhs when associated with a pty.
@
text
@d571 1
a571 1
      termios_printf ("decremeted open_fhs %d", fhandler_console::open_fhs);
@


1.93.2.1
log
@* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
@
text
@d568 1
a568 1
  if (!output_done_event && !cygheap->fdtab.in_vfork_cleanup ())
d571 1
a571 1
      termios_printf ("decremented open_fhs %d", fhandler_console::open_fhs);
@


1.92
log
@* fhandler_tty.cc (fhandler_pty_slave::open): Grudgingly increment
fhandler_console::open_fhs here.
(fhandler_pty_slave::close): Ditto for close.
@
text
@d555 5
a559 1
  fhandler_console::open_fhs++;
d566 11
d833 11
a1086 1
  fhandler_console::open_fhs++;
d1228 11
@


1.91
log
@* spawn.cc (linebuf::~linebuf): Resurrect commented out (for debugging?) code.
@
text
@d555 1
d1061 1
@


1.90
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d214 3
a216 1
      (void) tty_master->line_edit (rawbuf, nraw, tty_master->get_ttyp ()->ti);
@


1.89
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d1069 1
a1069 1
  this->fhandler_tty_common::close ();
d1179 1
a1179 1
  this->fhandler_base::set_close_on_exec (val);
d1204 1
a1204 1
  this->fhandler_termios::fixup_after_fork (parent);
d1223 1
a1223 1
  this->fhandler_tty_common::set_close_on_exec (val);
d1238 1
a1238 1
  this->fhandler_pty_master::fixup_after_fork (child);
@


1.89.2.1
log
@merge from trunk
@
text
@d38 2
a39 2
fhandler_tty_master::fhandler_tty_master ()
  : fhandler_pty_master (), console (NULL)
a42 6
int
fhandler_tty_slave::get_unit ()
{
  return dev == FH_TTY ? myself->ctty : dev.minor;
}

d54 1
a54 1
fhandler_tty_master::init ()
d56 1
a56 3
  termios_printf ("Creating master for tty%d", get_unit ());

  slave = dev;
d68 3
a70 1
  cygwin_shared->tty[get_unit ()]->common_init (this);
d427 6
d434 1
a434 1
  : fhandler_tty_common ()
d444 1
a444 1
  tcinit (cygwin_shared->tty[get_unit ()]);
d446 2
a447 2
  attach_tty (get_unit ());
  tc->set_ctty (get_unit (), flags);
d458 1
a458 1
  __small_sprintf (buf, OUTPUT_DONE_EVENT, get_unit ());
d473 1
a473 1
  __small_sprintf (buf, INPUT_AVAILABLE_EVENT, get_unit ());
d483 1
a483 1
  __small_sprintf (buf, IOCTL_REQUEST_EVENT, get_unit ());
d485 1
a485 1
  __small_sprintf (buf, IOCTL_DONE_EVENT, get_unit ());
d519 1
a519 1
			  get_unit (), get_ttyp ()->master_pid);
d553 1
a553 1
  termios_printf ("tty%d opened", get_unit ());
d598 1
a598 1
  termios_printf ("tty%d, write(%x, %d)", get_unit (), ptr, len);
d820 1
d823 2
a824 2
  attach_tty (get_unit ());
  tc->set_ctty (get_unit (), openflags);
d939 1
a939 1
      && myself->ctty == get_unit () && (get_ttyp ()->ti.c_lflag & TOSTOP))
d1006 2
a1007 2
fhandler_pty_master::fhandler_pty_master ()
  : fhandler_tty_common ()
d1014 2
a1015 2
  int ntty = cygwin_shared->tty.allocate_tty (0);
  if (ntty < 0)
d1018 1
a1018 3
  slave = *ttys_dev;
  slave.setunit (ntty);
  cygwin_shared->tty[ntty]->common_init (this);
d1023 1
a1023 1
  termios_printf ("opened pty master tty%d", get_unit ());
d1058 1
a1058 1
  termios_printf ("tty%d <%p,%p> closed", get_unit (), get_handle (), get_output_handle ());
d1073 1
a1073 1
      termios_printf ("freeing tty%d (%d)", get_unit (), get_ttyp ()->ntty);
d1120 1
a1120 1
  *t = cygwin_shared->tty[get_unit ()]->ti;
d1127 1
a1127 1
  cygwin_shared->tty[get_unit ()]->ti = *t;
d1167 1
a1167 1
fhandler_pty_master::ptsname ()
d1171 1
a1171 1
  __small_sprintf (buf, "/dev/tty%d", get_unit ());
d1252 1
a1252 2
  console = (fhandler_console *)
    cygheap->fdtab.build_fhandler (-1, *console_dev, "/dev/ttym");
@


1.89.2.2
log
@merge from trunk
@
text
@d1070 1
a1070 1
  fhandler_tty_common::close ();
d1180 1
a1180 1
  fhandler_base::set_close_on_exec (val);
d1205 1
a1205 1
  fhandler_termios::fixup_after_fork (parent);
d1224 1
a1224 1
  fhandler_tty_common::set_close_on_exec (val);
d1239 1
a1239 1
  fhandler_pty_master::fixup_after_fork (child);
@


1.89.2.3
log
@merge from trunk
@
text
@d220 1
a220 3
      if (tty_master->line_edit (rawbuf, nraw, tty_master->get_ttyp ()->ti)
	  == line_edit_signalled)
	tty_master->console->eat_readahead (-1);
@


1.89.2.4
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d20 1
a21 1
#include "fhandler.h"
d46 1
a46 1
  return dev () == FH_TTY ? myself->ctty : dev ().minor;
d64 1
a64 1
  slave = dev ();
d444 1
a444 1
fhandler_tty_slave::open (int flags, mode_t)
d1013 1
a1013 1
fhandler_pty_master::open (int flags, mode_t)
d1255 2
a1256 1
  console = (fhandler_console *) build_fh_dev (*console_dev, "/dev/ttym");
@


1.89.2.5
log
@merge from trunk
@
text
@d582 1
a582 1
  int flags = 0;
d586 1
a586 1
    flags = O_RDONLY;
d588 1
a588 1
    flags = O_WRONLY;
d590 1
a590 1
    flags = O_RDWR;
d592 1
a592 1
  open (flags);
@


1.89.2.6
log
@merge from trunk
@
text
@a554 5
  if (!output_done_event)
    {
      fhandler_console::open_fhs++;
      termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
    }
a560 11
fhandler_tty_slave::close ()
{
  if (!output_done_event)
    {
      fhandler_console::open_fhs--;
      termios_printf ("decremeted open_fhs %d", fhandler_console::open_fhs);
    }
  return fhandler_tty_common::close ();
}

int
a816 11
fhandler_tty_slave::dup (fhandler_base *child)
{
  if (!output_done_event)
    {
      fhandler_console::open_fhs++;
      termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
    }
  return fhandler_tty_common::dup (child);
}

int
a1201 11
}

void
fhandler_tty_slave::fixup_after_fork (HANDLE parent)
{
  if (!output_done_event)
    {
      fhandler_console::open_fhs++;
      termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
    }
  fhandler_tty_common::fixup_after_fork (parent);
@


1.89.2.7
log
@merge from trunk
@
text
@d571 1
a571 1
      termios_printf ("decremented open_fhs %d", fhandler_console::open_fhs);
@


1.89.2.8
log
@merge from trunk
@
text
@a11 2
#include <wingdi.h>
#include <winuser.h>
d557 1
a557 15
      if (fhandler_console::open_fhs++ == 0
	  && wincap.pty_needs_alloc_console ())
	{
	  BOOL b;
	  HWINSTA h = CreateWindowStation (NULL, 0, GENERIC_READ | GENERIC_WRITE, &sec_none_nih);
	  termios_printf ("CreateWindowStation %p, %E", h);
	  if (h)
	    {
	      b = SetProcessWindowStation (h);
	      termios_printf ("SetProcessWindowStation %d, %E", b);
	    }
	  b = AllocConsole ();	// will cause flashing if workstation
	  			// stuff fails
	  termios_printf ("%d = AllocConsole ()", b);
	}
@


1.89.2.9
log
@merge from trunk
@
text
@d17 1
d511 3
a513 5
#ifdef USE_CYGSERVER
  if (!wincap.has_security ()
      || cygserver_running == CYGSERVER_UNAVAIL
      || !cygserver_attach_tty (&from_master_local, &to_master_local))
#endif
d586 1
a586 2
      if (!--fhandler_console::open_fhs && myself->ctty == -1)
	FreeConsole ();
a595 3
#ifndef USE_CYGSERVER
  return 0;
#else
a607 1

a608 1
#endif
@


1.89.2.10
log
@merge from trunk
@
text
@d558 1
a558 2
  if (fhandler_console::open_fhs++ == 0 && !output_done_event
      && wincap.pty_needs_alloc_console ())
d560 16
a575 11
      BOOL b;
      HWINSTA h = CreateWindowStation (NULL, 0, GENERIC_READ | GENERIC_WRITE, &sec_none_nih);
      termios_printf ("CreateWindowStation %p, %E", h);
      if (h)
	{
	  b = SetProcessWindowStation (h);
	  termios_printf ("SetProcessWindowStation %d, %E", b);
	}
      b = AllocConsole ();	// will cause flashing if workstation
			    // stuff fails
      termios_printf ("%d = AllocConsole ()", b);
a576 1
  termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
d585 6
a590 3
  if (!--fhandler_console::open_fhs && myself->ctty == -1)
    FreeConsole ();
  termios_printf ("decremented open_fhs %d", fhandler_console::open_fhs);
d858 5
a862 2
  fhandler_console::open_fhs++;
  termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
d1257 5
a1261 2
  fhandler_console::open_fhs++;
  termios_printf ("incremented open_fhs %d", fhandler_console::open_fhs);
a1320 1
  fhandler_console::open_fhs--;  /* handled when individual fds are opened */
@


1.89.2.11
log
@merge from trunk
@
text
@d510 1
a510 1
#ifdef USE_SERVER
d592 1
a592 1
#ifndef USE_SERVER
@


1.89.2.12
log
@merge from trunk
@
text
@d740 1
a740 1
	  len = (size_t) -1;
d765 1
a765 1
	  len = (size_t) bytes_in_pipe;
d845 1
a845 1
  len = (size_t) totalread;
d1157 1
a1157 1
  len = (size_t) process_slave_output ((char *) ptr, len, pktmode);
@


1.89.2.13
log
@merge from trunk
@
text
@d558 2
a559 2
  if (fhandler_console::open_fhs++ == 0 && !GetConsoleCP ()
      && !output_done_event && wincap.pty_needs_alloc_console ())
d570 2
a571 4
			    	// stuff fails
      termios_printf ("%d = AllocConsole (), %E", b);
      if (b)
	init_console_handler ();
@


1.88
log
@* fhandler.h (fhandler_tty_master::set_winsize): Declare new function.
* fhandler_console.cc (fhandler_console::send_winch_maybe): If appropriate,
call tty master function to handle screen size change.
* fhandler_tty.cc (fhandler_tty_master::set_winsize): New function.
(fhandler_tty_master::init): Call set_winsize to set initial screen size.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
@


1.88.2.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d1252 1
a1252 2
  console = (fhandler_console *)
    cygheap->fdtab.build_fhandler (-1, *console_dev, "/dev/ttym");
@


1.88.2.2
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d38 2
a39 2
fhandler_tty_master::fhandler_tty_master ()
  : fhandler_pty_master (FH_TTYM), console (NULL)
d54 1
a54 1
fhandler_tty_master::init ()
d56 1
a56 1
  termios_printf ("Creating master for tty%d", dev.minor);
d68 3
a70 1
  cygwin_shared->tty[dev.minor]->common_init (this);
d427 6
d434 1
a434 1
  : fhandler_tty_common (FH_TTYS)
d444 1
a444 1
  tcinit (cygwin_shared->tty[dev.minor]);
d446 2
a447 2
  attach_tty (dev.minor);
  tc->set_ctty (dev.minor, flags);
d458 1
a458 1
  __small_sprintf (buf, OUTPUT_DONE_EVENT, dev.minor);
d473 1
a473 1
  __small_sprintf (buf, INPUT_AVAILABLE_EVENT, dev.minor);
d483 1
a483 1
  __small_sprintf (buf, IOCTL_REQUEST_EVENT, dev.minor);
d485 1
a485 1
  __small_sprintf (buf, IOCTL_DONE_EVENT, dev.minor);
d519 1
a519 1
			  dev.minor, get_ttyp ()->master_pid);
d553 1
a553 1
  termios_printf ("tty%d opened", dev.minor);
d598 1
a598 1
  termios_printf ("tty%d, write(%x, %d)", dev.minor, ptr, len);
d820 1
d823 2
a824 2
  attach_tty (dev.minor);
  tc->set_ctty (dev.minor, openflags);
d939 1
a939 1
      && myself->ctty == dev.minor && (get_ttyp ()->ti.c_lflag & TOSTOP))
d1006 2
a1007 2
fhandler_pty_master::fhandler_pty_master (DWORD devtype)
  : fhandler_tty_common (devtype)
d1014 2
a1015 2
  int ntty = cygwin_shared->tty.allocate_tty (0);
  if (ntty < 0)
d1018 1
a1018 2
  dev.setunit (ntty);
  cygwin_shared->tty[ntty]->common_init (this);
d1023 1
a1023 1
  termios_printf ("opened pty master tty%d<%p>", dev.minor, this);
d1058 1
a1058 1
  termios_printf ("tty%d <%p,%p> closed", dev.minor, get_handle (), get_output_handle ());
d1073 1
a1073 1
      termios_printf ("freeing tty%d (%d)", dev.minor, get_ttyp ()->ntty);
d1120 1
a1120 1
  *t = cygwin_shared->tty[dev.minor]->ti;
d1127 1
a1127 1
  cygwin_shared->tty[dev.minor]->ti = *t;
d1167 1
a1167 1
fhandler_pty_master::ptsname ()
d1171 1
a1171 1
  __small_sprintf (buf, "/dev/tty%d", dev.minor);
@


1.88.2.3
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d39 1
a39 1
  : fhandler_pty_master (), console (NULL)
d426 1
a426 1
  : fhandler_tty_common ()
d997 2
a998 2
fhandler_pty_master::fhandler_pty_master ()
  : fhandler_tty_common ()
@


1.88.2.4
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@a42 6
int
fhandler_tty_slave::get_unit ()
{
  return dev == FH_TTYS ? myself->ctty : dev.minor;
}

d56 1
a56 1
  termios_printf ("Creating master for tty%d", get_unit ());
d68 1
a68 1
  cygwin_shared->tty[get_unit ()]->common_init (this);
d436 1
a436 1
  tcinit (cygwin_shared->tty[get_unit ()]);
d438 2
a439 2
  attach_tty (get_unit ());
  tc->set_ctty (get_unit (), flags);
d450 1
a450 1
  __small_sprintf (buf, OUTPUT_DONE_EVENT, get_unit ());
d465 1
a465 1
  __small_sprintf (buf, INPUT_AVAILABLE_EVENT, get_unit ());
d475 1
a475 1
  __small_sprintf (buf, IOCTL_REQUEST_EVENT, get_unit ());
d477 1
a477 1
  __small_sprintf (buf, IOCTL_DONE_EVENT, get_unit ());
d511 1
a511 1
			  get_unit (), get_ttyp ()->master_pid);
d545 1
a545 1
  termios_printf ("tty%d opened", get_unit ());
d590 1
a590 1
  termios_printf ("tty%d, write(%x, %d)", get_unit (), ptr, len);
d814 2
a815 2
  attach_tty (get_unit ());
  tc->set_ctty (get_unit (), openflags);
d930 1
a930 1
      && myself->ctty == get_unit () && (get_ttyp ()->ti.c_lflag & TOSTOP))
d1015 1
a1015 1
  termios_printf ("opened pty master tty%d<%p>", get_unit (), this);
d1050 1
a1050 1
  termios_printf ("tty%d <%p,%p> closed", get_unit (), get_handle (), get_output_handle ());
d1065 1
a1065 1
      termios_printf ("freeing tty%d (%d)", get_unit (), get_ttyp ()->ntty);
d1112 1
a1112 1
  *t = cygwin_shared->tty[get_unit ()]->ti;
d1119 1
a1119 1
  cygwin_shared->tty[get_unit ()]->ti = *t;
d1163 1
a1163 1
  __small_sprintf (buf, "/dev/tty%d", get_unit ());
@


1.88.2.5
log
@* fhandler_tty.cc (fhandler_tty_slave::get_unit): Fix test for tty unit number
based on whether this is just a /dev/tty or a /dev/ttyN.
@
text
@d46 1
a46 1
  return dev == FH_TTY ? myself->ctty : dev.minor;
@


1.88.2.6
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@a63 2
  slave = dev;

d1015 1
a1015 2
  slave = *ttys_dev;
  slave.setunit (ntty);
d1021 1
a1021 1
  termios_printf ("opened pty master tty%d", get_unit ());
@


1.87
log
@* fhandler_tty.cc (fhandler_tty_master::init): Set initial size of tty to that
of console in which tty is operating.
(process_input): Semi-revert previous change.  Need to just use current
terminfo settings since this function is running in a thread, blocked when the
terminfo changes.
@
text
@d43 10
a66 3
  winsize w;
  console->ioctl (TIOCGWINSZ, &w);
  this->ioctl (TIOCSWINSZ, &w);
d72 2
d1146 1
a1146 1
	* (struct winsize *) arg = get_ttyp ()->winsize;
@


1.86
log
@* fhandler.h (fhandler_termios::line_edit): Replace third argument with
passed-in termios struct.
* fhandler_console.cc (fhandler_console::read): Prior to loop, make a copy of
current termios for passing to line_edit prior so that all characters are
processed consistently.
* fhandler_tty.cc (fhandler_pty_master::write): Ditto.
(process_input): Make a copy of curent termios prior to read for use in
subsequent line_edit.
* fhandler_termios.cc (fhandler_termios::line_edit): Replace third parameter
with passed-in termios struct and use it throughout rather than the data from
the current fhandler_termios class.
@
text
@d57 3
a203 1
      termios ti = tty_master->get_ttyp ()->ti;
d205 1
a205 1
      (void) tty_master->line_edit (rawbuf, nraw, ti);
@


1.85
log
@* fhandler.h (line_edit_status): Reorganize so that tests for error condition
can be < or >.
* fhandler_tty.cc (fhandler_pty_master::write): Don't return after sending a
signal.
* fhandler_termios.cc (fhandler_termios::line_edit): Trivial change to use
built-in bool types.
@
text
@d201 1
d203 1
a203 1
      (void) tty_master->line_edit (rawbuf, nraw);
d1084 3
a1086 1
  for (i=0; i < (int) len; i++)
d1088 1
a1088 1
      line_edit_status status = line_edit (p++, 1);
@


1.84
log
@* fhandler.h (line_edit_status): Add a new element.
* fhandler_termios.cc (fhandler_termios::line_edit): After accept_input, handle
both potential error condition and pipe full conditions.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Return -1 on error.
(fhandler_pty_master::write): Handle pipe full condition.
@
text
@d1086 6
a1091 5
      if (status == line_edit_ok || status == line_edit_input_done)
	continue;
      if (status != line_edit_pipe_full)
	i = -1;
      break;
@


1.83
log
@* fhandler_termios.cc (fhandler_termios::line_edit): Return line_edit_error and
remove last char from readahead buffer if accept_input() fails.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Return 0 and restore
readahead buffer when tty slave pipe is full.
@
text
@d172 1
d1081 1
a1081 1
  size_t i;
d1083 7
a1089 2
  for (i=0; i<len; i++)
    if (line_edit (p++, 1) == line_edit_error)
d1091 1
@


1.82
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d148 2
a149 4
  DWORD bytes_left, written;
  DWORD n;
  DWORD rc;
  char* p;
d151 1
a151 1
  rc = WaitForSingleObject (input_mutex, INFINITE);
d153 1
a153 2
  bytes_left = n = eat_readahead (-1);
  p = rabuf;
d155 1
a155 1
  if (n != 0)
d157 17
a173 1
      while (bytes_left > 0)
d175 1
a175 11
	  termios_printf ("about to write %d chars to slave", bytes_left);
	  rc = WriteFile (get_output_handle (), p, bytes_left, &written, NULL);
	  if (!rc)
	    {
	      debug_printf ("error writing to pipe %E");
	      get_ttyp ()->read_retval = -1;
	      break;
	    }
	  else
	    get_ttyp ()->read_retval = 1;

d181 2
a182 4
	      SetEvent (input_available_event);
	      ReleaseMutex (input_mutex);
	      Sleep (10);
	      rc = WaitForSingleObject (input_mutex, INFINITE);
d186 1
a186 5
  else
    {
      termios_printf ("sending EOF to slave");
      get_ttyp ()->read_retval = 0;
    }
d189 1
a189 1
  return 1;
@


1.81
log
@* fhandler.h (fhandler_termios::line_edit): Change return from an int to an
enum to allow the function to return an error.
* fhandler_console.cc (fhandler_console::read): Update the line_edit call to
use the new enum.
* fhandler_termios.cc (fhandler_termios::line_edit): Change return from an int
to an enum to allow the function to return an error.  Put put_readahead call
before doecho for future patch.
* fhandler_tty.cc (fhandler_pty_master::write): Change to call line_edit one
character at a time, and stop if an error occurs.
@
text
@d202 2
a203 2
      int nraw = tty_master->console->read ((void *) rawbuf,
				      (size_t) INP_BUFFER_SIZE);
d637 2
a638 2
int __stdcall
fhandler_tty_slave::read (void *ptr, size_t len)
d695 2
a696 1
	  return -1;
d720 2
a721 1
	  return bytes_in_pipe;
d800 2
a801 1
  return totalread;
d1091 2
a1092 2
int __stdcall
fhandler_pty_master::read (void *ptr, size_t len)
d1094 2
a1095 1
  return process_slave_output ((char *) ptr, len, pktmode);
@


1.80
log
@* fhandler_tty.cc (fhandler_pty_master::accept_input): Move read_retval
assignment to prevent race condition.  Remove read_retval from return
statement.
@
text
@d170 1
a170 1
	  else 
d1080 6
a1085 2
  (void) line_edit ((char *) ptr, len);
  return len;
@


1.79
log
@* fhandler_tty.cc (fhandler_pty_master::accept_input): Just use a normal Sleep
or suffer amazing pauses when other tty apps are running.
(fhandler_pty_master::process_slave_output): Ditto.
@
text
@a155 1
  get_ttyp ()->read_retval = 0;
d167 1
d170 3
a172 1
	  get_ttyp ()->read_retval += written;
d186 4
a189 1
    termios_printf ("sending EOF to slave");
d192 1
a192 1
  return get_ttyp ()->read_retval;
@


1.78
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d178 1
a178 1
	      low_priority_sleep (10);
d282 1
a282 1
	      low_priority_sleep (10);
@


1.77
log
@* fhandler_tty.cc (fhandler_tty_slave::ioctl): Do nothing if the new window
size is equal to the old one.  Send SIGWINCH if slave connected to a pseudo
tty.
(fhandler_pty_master::ioctl): Do nothing if the new window size is equal to the
old one.
@
text
@d178 1
a178 1
	      Sleep (10);
d282 1
a282 1
	      Sleep (10);
@


1.76
log
@Rename _kill() to kill() throughout.  Rename _raise() to raise() throughout.
Rename _pid() to pid() throughout.
* Makefile.in: Compile some objects with -fomit-frame-pointer.
* cygwin.din: Reverse aliasing for _kill.
* syscalls.cc (_getpid_r): New function, implemented for newlib compatibility.
* shared.cc (open_shared): Remove reserving of memory since previous change
eliminate the need for this hack.
@
text
@d952 1
a952 1
      * (struct winsize *) arg = get_ttyp ()->arg.winsize;
d958 17
a974 6
      get_ttyp ()->ioctl_retval = -1;
      get_ttyp ()->arg.winsize = * (struct winsize *) arg;
      if (ioctl_request_event)
	SetEvent (ioctl_request_event);
      if (ioctl_done_event)
	WaitForSingleObject (ioctl_done_event, INFINITE);
d1117 6
a1122 2
	get_ttyp ()->winsize = * (struct winsize *) arg;
	kill (-get_ttyp ()->getpgid (), SIGWINCH);
@


1.75
log
@* fhandler_tty.cc (fhandler_tty_slave::read): Attempt #527 to properly
implement VMIN/VTIME.
@
text
@d615 1
a615 1
	  _raise (SIGHUP);		/* FIXME: Should this be SIGTTOU? */
d707 1
a707 1
	  _raise (SIGHUP);
d729 1
a729 1
	      _raise (SIGHUP);
d738 1
a738 1
	      _raise (SIGHUP);
d926 1
a926 1
      _raise (SIGTTOU);
d1107 1
a1107 1
	_kill (-get_ttyp ()->getpgid (), SIGWINCH);
@


1.74
log
@* cygthread.cc (cygthread::stub): Don't create an event for "cygself" threads.
Assume that they exit via an ExitThread call.
* cygthread.h (cygthread::SetThreadPriority): New function.
(cygthread::zap_h): New function.
* dcrt0.cc (do_exit): Move cygthread::terminate earlier and establish
exit_state guard.
* fhandler.h (fhandler_tty_master::output_thread): Delete.
* fhandler_tty.cc (fhandler_tty_master::init): Set priority for threads via
method.  Zap handles when done.  Don't treat process_output specially.
(process_output): Call ExitThread directly.
(fhandler_tty_master::fixup_after_fork): Don't worry about output_thread.
(fhandler_tty_master::fixup_after_exec): Ditto.
* sigproc.cc (proc_terminate): Don't detach from hwait_subproc.  Just let it
exit.
(sigproc_init): Close thread handle after initialization.
(wait_sig): Use GetCurrentThread() as SetThreadPriority call rather than
*event* handle.  Call ExitThread directly on termination.
(wait_subproc): Call ExitThread directly on termination.
* tty.cc (tty_list::terminate): Don't attempt t detach from output_thread.
@
text
@a634 1
  DWORD n;
d636 1
a636 1
  int vmin = INT_MAX;
d648 3
a650 1
  if (!(get_ttyp ()->ti.c_lflag & ICANON))
d660 4
a663 1
      time_to_wait = vtime == 0 ? INFINITE : 100 * vtime;
a664 2
  else
    time_to_wait = INFINITE;
d669 1
d672 11
a682 1
      rc = WaitForMultipleObjects (2, w4, FALSE, time_to_wait);
d692 1
a692 7
      else if (rc == WAIT_FAILED)
	{
	  termios_printf ("wait for input event failed, %E");
	  break;
	}
      else if (rc == WAIT_TIMEOUT)
	break;
d710 7
d718 5
d768 1
a768 1
      if (totalread >= vmin && (vmin > 0 || totalread > 0))
d788 3
@


1.73
log
@2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	GNUify non-GNU formatted functions calls throughout.

2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Remove macro.
	(server_shmmgr::segment_t::~segment_t): Remove calls to with_strerr.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::new_segment): Ditto.
	* shm.cc (with_strerr): Remove macro.
	(client_shmmgr::shmdt): Remove calls to with_strerr.
	(client_shmmgr::attach): Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h: Move to "include/cygwin/ipc.h".
	* include/sys/msg.h: Move to "include/cygwin/msg.h".
	* include/sys/sem.h: Move to "include/cygwin/sem.h".
	* include/sys/shm.h: Move to "include/cygwin/shm.h".
	* include/cygwin/ipc.h: New file.
	* include/cygwin/msg.h: Ditto.
	* include/cygwin/sem.h: Ditto.
	* include/cygwin/shm.h: Ditto.
	* cygserver_shm.h: Update includes.
	* msg.cc: Ditto.
	* sem.cc: Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h (safe_delete): Make a templated function.
	* cygserver.cc (~server_request): Update use of safe_delete.
	(main): Ditto.
	* cygserver_client.cc (client_request::handle_request): Ditto.
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::remove): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	* cygserver_shm.cc (server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* shm.cc (client_shmmgr::shmdt): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.

2002-08-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Replace #include <new> with an explicit
	definition of the placement new operator.
	(safe_delete): Remove unnecessary ## operator.

2002-07-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr): Remove `cleanup_t'
	friend declaration.
	(cleanup_t::cleanup_t): Use the segment's shmid as the key rather
	than the segment pointer itself.
	(cleanup_t::segptr): Remove method.
	(cleanup_t::shmid): New method.
	(cleanup_t::cleanup): Update for new key value.
	(server_shmmgr::find (segment_t *)): Remove method.
	* include/cygwin/cygserver_process.h (cleanup_routine::key): Make
	method const.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_process.h
	(cleanup_routine::_key): New field.
	(cleanup_routine::cleanup_routine): Initialise new field with new
	argument.
	(cleanup_routine::operator==): New method.
	(cleanup_routine::key): New method.
	(cleanup_routine::cleanup): Make argument non-const.
	(process::is_active): New method.
	(process::remove): Ditto.
	(process::check_exit_code): Rename method.
	* cygserver_process.cc (process::add): Reorganize code.
	(process::remove): New method.
	(process::check_exit_code): Rename method.
	(process::cleanup): Use new `process::is_active' method.
	(process_cache::process): Ditto.
	(process_cache::sync_wait_array): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr): Make `cleanup_t' a friend.
	(segment_t::detach): Make argument non-const.  Remove cleanup
	object from client if appropriate.
	(cleanup_t::_segptr): Remove field.
	(cleanup_t::cleanup_t): Initialise parent explicitly.  Remove
	field.
	(cleanup_t::segptr): New method.
	(cleanup_t::cleanup): Add error checking and reporting.
	(server_shmmgr::shmdt): Make argument non-const.
	(server_shmmgr::find (segment_t *)): New method.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::client_request_shutdown):
	Comment out verbose tracing statement.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Ditto.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	* cygserver_shm.cc (client_request_shm::client_request_shm):
	Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc (transport_layer_pipes::listen):
	Set `_is_listening_endpoint' appropriately.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::listen): Change return type.
	(transport_layer_base::connect): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(transport_layer_pipes::listen): Change return type.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::_sec_none_nih): Remove unused field.
	(transport_layer_pipes::_is_listening_endpoint): New field.
	* cygserver_transport_pipes.cc: Synchronize with sockets code.
	(transport_layer_pipes::transport_layer_pipes): Initialise new
	field.  Separate out asserts.
	(transport_layer_pipes::listen): Change return type.  Add asserts.
	(transport_layer_pipes::accept): Add asserts.
	(transport_layer_pipes::read): Change conditional to an assert.
	Add assert.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Change return type.  Change
	conditional to an assert.  Add asserts.  Rationalize error code
	slightly.
	(transport_layer_pipes::impersonate_client): Add asserts.
	* include/cygwin/cygserver_transport_sockets.h
	(transport_layer_sockets::listen): Change return type.
	(transport_layer_sockets::connect): Ditto.
	(transport_layer_sockets::_addr): Change type of field.
	(transport_layer_sockets::_addr_len): Ditto.
	(transport_layer_sockets::_is_accepted_endpoint): New field.
	(transport_layer_sockets::_is_listening_endpoint): Ditto.
	* cygserver_transport_sockets.cc
	(MAX_CONNECT_RETRY): New constant.
	(transport_layer_sockets::transport_layer_sockets): Initialise new
	fields.  Only initialise the socket address where necessary.
	(transport_layer_sockets::listen): Change return type.  Rewrite.
	(transport_layer_sockets::accept): Add asserts.  Add tracing
	statements.  Use a local variable to hold the accepted address.
	(transport_layer_sockets::close): Add tracing statements.  Unlink
	the UNIX domain socket file as appropriate.  Close the socket
	cleanly.
	(transport_layer_sockets::read): Rewrite method.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Change return type.  Rewrite.
	* cygserver.cc (server_submission_loop::request_loop): Run the
	listening thread at high priority with special handling for
	shutdown.
	(main): Print the request error code rather than errno in shutdown
	request code.  Install signal handlers with sigaction(2) to avoid
	setting SA_RESTART.  Check value of the listen method call, now it
	has one.
	* cygserver_client.cc (client_request::make_request): Check new
	return value on connect method call.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::_sd): Rename field.
	(cygserver_transport_pipes::_sec_none_nih): Ditto.
	(cygserver_transport_pipes::_sec_all_nih): Ditto.
	(cygserver_transport_pipes::_pipe_name): Ditto.
	(cygserver_transport_pipes::_hPipe): Ditto.
	(cygserver_transport_pipes::_is_accepted_endpoint): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::transport_layer_pipes): Rename fields.
	(transport_layer_pipes::init_security): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.
	(transport_layer_pipes::close): Ditto.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::_fd): Rename field.
	(cygserver_transport_sockets::_addr): Ditto.
	(cygserver_transport_sockets::_addr_len): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::transport_layer_sockets): Rename fields.
	(transport_layer_sockets::listen): Ditto.
	(transport_layer_sockets::accept): Ditto.
	(transport_layer_sockets::close): Ditto.
	(transport_layer_sockets::read): Ditto.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Fix use of %p format.
	* shm.cc (client_shmmgr::shmat): Ditto.
	(client_shmmgr::shmctl): Ditto.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::attach): Ditto.

2002-07-14  Christopher Faylor  <cgf@@redhat.com>

	* woutsup.h (system_printf): Remove extraneous semicolon from macro
	definition.

2002-07-14  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(transport_layer_pipes::connect): Use ProtectHandle in DLL code.
	(transport_layer_pipes::close): Use ForceCloseHandle in DLL code.

2002-07-13  Nicholas Wourms  <nwourms@@netscape.com>

	* threaded_queue.h (class queue_submission_loop): Correct friend
	declaration for GCC 3.1.1.
	* include/cygwin/cygserver_process.h (class process): Ditto.
	(class process_cache): Ditto.

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::shmdt): Only call
	delete_segment if the segment exists [sic].

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Include <new> rather than <new.h> for gcc 3.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: New file extracted from "woutsup.h".
	* woutsup.h: Move the "safe" new/delete macros into the new
	"safe_memory.h" header file and include that here.
	* cygserver_client.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(client_request::make_request): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* cygserver_transport.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(create_server_transport): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* shm.cc: Include "safe_memory.h".
	(client_shmmgr::instance): Use the "safe" new/delete macros.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::new_segment): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_process (process::process): Add the client's cygpid
	and winpid to all tracing statements as appropriate.
	(process::exit_code): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::shmat): Ditto.
	(server_shmmgr::shmdt): Ditto.
	(server_shmmgr::shmctl): Add a process object argument and remove
	the explicit cygpid argument.  Add the client's cygpid and winpid
	to all tracing statements as appropriate.
	(server_shmmgr::shmget): Ditto.
	(client_request_shm::serve): Update for the new signature of the
	shmctl and shmget methods.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::serve): Don't set the
	shutdown flag directly, but send a SIGINT, as the signal handler
	sets the flag and the signal breaks the pause(2) in the main loop.
	(print_usage): Add new options.
	(main): Add new --cleanup-threads and --request-threads options to
	set the number of threads used by the daemon.  Use pause(2) rather
	the win32 Sleep in the main loop.
	* shm.cc (shmat): Add sigframe.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Automatically detach processes from any
	segments they are attached to at exit.
	(class server_shmmgr::attach_t): New class.
	(server_shmmgr::segment_t::IS_DELETED): Rename and make private.
	(server_shmmgr::segment_t::_sequence): Make private.
	(server_shmmgr::segment_t::_flg): Ditto.
	(server_shmmgr::segment_t::_hFileMap): Ditto.
	(server_shmmgr::segment_t::_attach_head): New private field.
	(server_shmmgr::segment_t::segment_t): Initialise new fields.
	Make non-inline.
	(server_shmmgr::segment_t::~segment_t): New method.
	(server_shmmgr::segment_t::is_deleted): Ditto.
	(server_shmmgr::segment_t::is_pending_delete): Ditto.
	(server_shmmgr::segment_t::mark_deleted): Ditto.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::segment_t::find): Ditto.
	(class server_shmmgr::cleanup_t): New class.
	(server_shmmgr::_shm_atts): New private field.
	(server_shmmgr::shmat): Add a process object argument to replace
	the removed process_cache, cygpid and winpid arguments.  Remove
	the process_cache manipulations.  Move body of code to the
	segment_t::attach method.  Increment _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmdt): Add a process object argument to replace
	the removed cygpid argument.  Move body of code to the
	segment_t::detach method.  Decrement _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmget): Use the new segment_t::is_deleted method.
	(server_shmmgr::server_shmmgr): Initialise the new _shm_atts
	field.
	(server_shmmgr::delete_segment): Remove the CloseHandle code, as
	this is now done in the segment_t destructor.
	(client_request_shm::serve): Look up the client's process object
	and pass to the server_shmmgr::shmat and server_shmmgr::shmdt
	methods rather than passing the cache, winpid and cygpid.
	* cygserver_process.h: Add a cygpid to the process object to make
	it more useful and then pass process objects rather than winpids
	where possible.
	(cleanup_routine::cleanup): Change argument to be a pointer to a
	process object.
	(class process): Re-order fields for no discernible reason.
	(process::_cygpid): New field.
	(process::process): Add a cygpid argument.
	(process::winpid): New method.
	(process::cygpid): Ditto.
	(process::add): Make public, as it always should have been.
	(process_cache::process): Add a cygpid argument.
	* cygserver_process.cc (process::process): Add a cygpid argument
	and use it to initialise the `_cygpid' field.  Re-order
	initialisers to match new field order.
	(process::cleanup): Pass `this' rather than just the winpid to
	cleanup_routine::cleanup.
	(process_cache::process): Add a cygpid argument and pass it to the
	process object constructor.
	* include/sys/shm.h (shmatt_t): Make unsigned as per SUSv3.
	(shm_info::shm_atts): New field.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr::segment_t): Add `_'
	prefix to the names of all fields.

2002-07-10  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* msg.cc: New file of stub functions, no functionality.
	* sem.cc: Ditto.
	* shm.cc (client_shmmgr::shmctl): Add support for an out shm_info
	buffer for the SHM_INFO command.
	(client_shmmgr::shmget): Use %X to print keys.
	* include/sys/ipc.h: Comment all fields and values.
	(IPC_PRIVATE): Change to be non-negative.
	* include/sys/msg.h: New file with SUSv3 and ipcs(8) interfaces.
	* include/sys/sem.h: Ditto.
	* include/sys/shm.h: Comment all fields and values.
	(struct shm_info): New struct.
	* cygserver_shm.h (client_request_shm::shminfo): Rename.
	(client_request_shm::shm_info): New method.
	(client_request_shm::_parameters.out.hFileMap): Move into union.
	(client_request_shm::_parameters.out.shminfo): Rename.
	(client_request_shm::_parameters.out.shm_info): New field.
	* cygserver_shm.cc (server_shmmgr::_shm_ids): Rename.
	(server_shmmgr::_shm_tot): New field.
	(server_shmmgr::shmctl): Rename `out_shminfo' argument.  Add
	`out_shm_info' argument.  Fill in the `out_shm_info' argument in
	the SHM_INFO command.
	(server_shmmgr::shmget): Check `shmflg' against the mode of
	existing segments as per Stevens 1990, p. 123.
	(server_shmmgr::server_shmmgr): Initialise the new `_shm_tot'
	field.
	(server_shmmgr::new_segment): Set ENOMEM if CreateFileMapping
	fails.  Pass `size' to new_segment.
	(server_shmmgr::new_segment): Add size argument and use it to
	check against and update the new `_shm_tot' field.
	(server_shmmgr::delete_segment): Update the new `_shm_tot' field.
	* Makefile.in (DLL_OFILES): Add new DLL object files.

2002-07-09  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc: The main change is to make the
	client try harder to connect to the server if it's previously
	connected, and so has good grounds for believing that the server
	is running.
	(MAX_WAIT_NAMED_PIPE_RETRY): Change to be an enumerator.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::accept): Use interlocked operators on
	`pipe_instance'.
	(transport_layer_pipes::close): Rearrange so that FlushFileBuffers
	and DisconnectNamedPipe are only called for accepted endpoints.
	Use interlocked operators on `pipe_instance'.
	(transport_layer_pipes::read): Use set_errno where required.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Add local static variable
	`assume_cygserver'.  Set it if a connection is made to cygserver,
	clear it if a connection is not made even after retrying.  If set,
	ignore all errors from CreateFile and retry the connection.  Catch
	the situation where WaitNamedPipe fails to wait [sic] and add a
	`Sleep (0)' so that the server gets a chance to run.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* dcrt0.cc: Only check for cygserver if and when required.
	(dll_crt0_1): Remove call to `cygserver_init ()'.
	* fhandler_tty.cc (fhandler_tty_slave::open): Change the cygserver
	logic to allow for the fact that `cygserver_init ()' may not yet
	have been called.
	(fhandler_tty_slave::cygserver_attach_tty): Tweak the cygserver
	request logic to conform to the practice elsewhere in the code.
	* tty.cc (tty::common_init): Add an explicit call to
	`cygserver_init ()' if it hasn't already been called.
	* include/cygwin/cygserver.h (CYGSERVER_UNAVAIL): Rename from
	`CYGSERVER_DEAD'.
	(client_request_get_version::check_version): Make available in
	cygserver as well the DLL.
	(check_cygserver_available): Ditto.  Remove `check_version_too'
	argument.
	(cygserver_init): Ditto.  And likewise.
	* cygserver_client.cc (client_request_get_version::check_version):
	Make available in cygserver as well the DLL.
	(client_request::make_request): This may now be called without
	`cygserver_init ()' having been called first.  Detect this and
	call it as required.  Add tracing.
	(check_cygserver_available): Make available in cygserver as well
	the DLL.  Remove `check_version_too' argument and always check the
	version information.  And since this is called from within
	`cygserver_init ()', force `cygserver_running' before calling
	`client_request::make_request ()'.
	(cygserver_init): Make available in cygserver as well the DLL.
	Remove `check_version_too' argument.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Implement the ipcs(8) interfaces, IPC_INFO,
	SHM_STAT and SHM_INFO.
	(server_shmmgr::segment_t::sequence): New static field.
	(server_shmmgr::segment_t::key): Remove field, use the new
	ds.shm_perm.key field instead.
	(server_shmmgr::segment_t::shmid): Remove field.
	(server_shmmgr::segment_t::intid): New field.
	(server_shmmgr::segment_t::segment_t): Use the `key' argument to
	initialise `ds.shm_perm.key'.  Change from using `shmid' to
	`intid'.
	(server_shmmgr::_shmseg_cnt): Renamed from `_shmid_cnt'.
	(server_shmmgr::_intid_max): Renamed from `_shmid_max.
	(server_shmmgr::shmat): Move the out arguments to the start of the
	argument list.  Rename the `pid' argument as `cygpid'.  Add
	tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmctl): Add separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add support for the ipcs(8)
	interfaces.  Add tracing.  Pass an intid to `find ()', not a
	shmid.
	(server_shmmgr::shmdt): Rename the `pid' argument as `cygpid'.
	Add tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmget): Add a separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add tracing.
	(server_shmmgr::server_shmmgr): Update for new field names.
	(server_shmmgr::find_by_key): Update for the new `ds.shm_perm.key'
	field.
	(server_shmmgr::find): Update to use the new `segment_t::intid'
	field.
	(server_shmmgr::new_segment): Rename the `pid' argument as
	`cygpid'.  Check that the requested size is within bounds.  Handle
	new error result from `new_segment (key, HANDLE)'.
	(server_shmmgr::new_segment): Work with intids, not shmids.  Check
	that the new intid is within bounds.  Update for new field names.
	(server_shmmgr::delete_segment): Pass an intid to `find ()', not a
	shmid.  Update for new field names.
	(client_request_shm::serve): Check that the incoming message
	length is the size of the `_parameters.in' struct, not of the
	whole in/out parameter union.  Likewise, set the outgoing message
	length to the size of the `_parameters.out' struct.  Update for
	the new server_shmmgr interfaces.
	* include/sys/ipc.h (ipc_perm::key): New field.
	* include/sys/shm.h (SHM_INFO): New constant.
	* cygserver_ipc.h (IPCMNI): New constant.
	(ipc_int2ext): Add `sequence' argument and munge this into the
	external ipc id.
	(ipc_ext2int_subsys): Unmunge the sequence number from the
	external ipc id.
	(ipc_ext2int): Ditto.
	(ipc_inc_id): Remove.
	(ipc_dec_id): Remove.
	* cygserver_shm.h (SHMMAX): New constant.
	(SHMMIN): Ditto.
	(SHMMNI): Ditto.
	(SHMSEG): Ditto.
	(SHMALL): Ditto.
	(client_request_shm::_parameters): Re-arrange as a union of two
	separate structs, one for in arguments, the other for out.
	(client_request_shm::shmid): Update for the new parameter layout.
	(client_request_shm::ds): Ditto.
	(client_request_shm::info): New method.
	* shm.cc (client_shmmgr::_shmat_cnt): New static field.
	(client_shmmgr::shmat): Add locking.  Add tracing.
	(client_shmmgr::shmctl): Update for ipcs(8) commands.  Add
	tracing.  Add more argument checking.
	(client_shmmgr::shmdt): Add locking.  Add tracing.  Update the new
	`_shmat_cnt' field.
	(client_shmmgr::shmget): Add tracing.
	(client_shmmgr::fixup_shms_after_fork): Add tracing.  Add
	consistency checking.
	(client_shmmgr::attach): Add more tracing.
	(client_shmmgr::new_segment): Update the new `_shmat_cnt' field.
	(client_request_shm::client_request_shm): Update for the new
	parameter layout.  Set the outgoing message length to the size of
	the `_parameters.in' struct, not of the whole in/out parameter
	union.

2002-07-02  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* shm.cc: Remove the use of a static client_shmmgr object.
	(client_shmmgr::_instance): New static variable.
	(client_shmmgr::instance): Allocate a new shmmgr on the heap,
	rather than using a local static object.

2002-07-01  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport.cc (create_server_transport): Fix
	cut-and-paste error.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Don't
	bother with the client request activity marker when compiled with
	debugging output.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(MAX_WAIT_NAMED_PIPE_RETRY): New constant.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::close): The `pipe' field is now either
	NULL or a valid handle, and it should never have the value
	`INVALID_HANDLE_VALUE'.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::connect): Ditto.  New, but still bogus,
	retry logic.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::server_shmmgr): All fields have
	to be initialized now that the singleton is no longer static.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::_instance): New static field.
	(server_shmmgr::_instance_once): Ditto.
	(server_shmmgr::initialise_instance): New static method.
	(server_shmmgr::instance): Use a pthread_once_t rather than
	relying on a local static variable.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: Remove all uses of the C++ new and delete operators
	throughout cygserver until they are fully thread-safe.
	(safe_new0): New macro to replace the C++ new operator.
	(safe_new): Ditto.
	(safe_delete): New macro to replace the C++ delete operator.
	* cygserver_client.cc (client_request::handle_request): Replace
	all uses of the C++ new and delete operators with the new macros
	from "woutsup.h".
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::new_segment): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* cygserver_transport.cc (create_server_transport): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::accept): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
	(threaded_queue::stop): Replace sleep(3) with win32 Sleep.
	* cygserver.cc (~server_request): Replace all uses of the C++ new
	and delete operators with the new macros from "woutsup.h".
	(server_submission_loop::request_loop): Ditto.
	(main): Ditto.  Replace sleep(3) with win32 Sleep.  Replace
	iostreams with FILEs.
	(print_usage): Replace iostreams with FILEs.
	(print_version): Ditto.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Rename local variable
	`accept_fd' to avoid shadowing the `fd' field.

2002-06-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygwin_ipc.h: Moved (back) to "include/sys/ipc.h".
	* cygwin_shm.h: Moved (back) to "include/sys/shm.h".
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.
	* cygserver_shm.h: Update for new header file locations.
	* ipc.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::make_request): Comment out
	a verbose tracing statement.
	* cygserver_process.cc (process_cache::sync_wait_array): Fix
	broken assert.
	* include/cygwin/cygserver.h (class client_request): Remove excess
	use of `class' qualifier in declarations.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_ipc.h: New file.
	* cygserver_shm.h: Re-written from scratch.
	* cygserver_shm.cc: Ditto.
	* shm.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* threaded_queue.h (class queue_request): Re-write.
	(threaded_queue_thread_function): Remove.
	(class queue_process_param): Remove.
	(class threaded_queue): Re-write.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	(TInterlockedExchangePointer): New templated function.
	(TInterlockedCompareExchangePointer): Ditto.
	* threaded_queue.cc (worker_function): Remove.
	(class threaded_queue): Re-write.
	(class queue_process_param): Remove.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	* include/cygwin/cygserver_process.h (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver_process.cc (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver.cc (request_count): Remove unused variable.
	(class server_request): Move methods inline.
	(class server_process_param): Remove.
	(class server_request_queue): Remove.
	(request_queue): Move into `main ()' and change type to
	`threaded_queue'.
	(request_loop): Remove.
	(class server_submission_loop): New version of the old
	`server_process_param' class.
	(shutdown_server): New variable.
	(client_request_shutdown::serve): Set `shutdown_server' to trigger
	shutdown.
	(handle_signal): Ditto.
	(main): Install signal handler for SIGINT rather than SIGQUIT.
	Use new interfaces for the `request_queue' and the `cache'.
	Create a `server_submission_loop' and add to the `request_queue'.
	Add check for the `shutdown_server' variable to the main loop.
	* cygserver_shm.cc (client_request_shm::serve): Release the
	process object after use.

2002-06-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Correct
	tracing statement.
	* cygserver_transport_pipes.cc: Remove local definition of
	FILE_FLAG_FIRST_PIPE_INSTANCE constant.
	* cygwin_ipc.h: Update copyright notice.
	* cygwin_shm.h: Ditto.
	* woutsup.h: Add definition of _WIN32_WINNT.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client (client_request::make_request): Replace my
	inappropriate use of set_errno () with error_code () throughout.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Add forward declarations of class
	transport_layer_base and class process_cache to reduce
	dependencies between header files.
	* include/cygwin/cygserver_process.h: Add include of
	"threaded_queue.h".
	* cygserver.cc: Remove unnecessary cygserver header files.
	* cygserver_client.cc: Ditto.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_shm.h: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* dcrt0.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.h: Replace <sys/shm.h> with "cygwin_shm.h" after
	merge from HEAD.
	* cygwin_ipc.h: Update with changes to include/sys/ipc.h lost in
	merge from HEAD.
	* cygwin_shm.h: Ditto.

2002-06-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: The tests for a duplicate server instance are now
	the responsibility of the transport layer.
	(request_loop): Use new `recoverable' flag in call to
	`cygserver_transport::accept ()' and shutdown on an unrecoverable
	error.
	(main): Never call `cygserver_init ()'.  Fake `cygserver_running'
	just for sending a shutdown request.
	* cygserver_client.cc (client_request::send): Comment out
	message-size tracing statements as verbose.
	(client_request::handle): Ditto.
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver_transport.h
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.  Add a `recoverable' out
	flag for error handling.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	(transport_layer_pipes): Change type of the `pipe_name' field.
	Remove the `inited' field, as unnecessary.  Add new
	`is_accepted_endpoint' field.
	* include/cygwin/cygserver_transport.cc
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.cc
	(transport_layer_sockets::listen): #ifdef as cygserver-only.
	(transport_layer_sockets::accept): #ifdef as cygserver-only.
	Analyse any errno from `accept ()' and set `recoverable' as
	appropriate.
	* cygserver_transport_pipes.cc: Add local #define of
	`FILE_FLAG_FIRST_PIPE_INSTANCE'.
	(pipe_instance_lock_once): New variable.
	(pipe_instance_lock): Ditto.
	(pipe_instance): Ditto.
	(initialise_pipe_instance_lock): New function.
	(transport_layer_pipes::transport_layer_pipes): Change
	initialization of `pipe_name'.  Initialize `is_accepted_endpoint'
	as appropriate.  Remove use of `inited'.
	(transport_layer_pipes::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_pipes::revert_to_self): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.  Keep track of how often
	many named pipes have been created, in the `pipe_instance'
	variable, and pass the `FILE_FLAG_FIRST_PIPE_INSTANCE' flag on the
	open of the first instance.  Analyse the error code from
	`CreateNamedPipe ()' and set the `recoverable' flag as
	appropriate.
	(transport_layer_pipes::close): Update the `pipe_instance' count.

2002-06-18  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h (cygserver_running): Add declaration.
	(api_fatal): Eliminate.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): Change return type to
	bool.
	(check_cygserver_available): New function.
	(cygserver_init): Add check_version_too argument.
	* cygserver_client.cc (allow_daemon): Make a bool.
	(client_request_get_version::make_request): See errno on error.
	Remove special case for CYGSERVER_REQUEST_GET_VERSION; this is now
	handled in cygserver_init().
	(client_request_get_version::check_version): Use syscall_printf()
	instead of api_fatal(). Return true if cygserver version is
	compatible.
	(check_cygserver_available): New function; code moved here from
	cygserver_init().
	(cygserver_init): Move some code into check_cygserver_available().
	* cygserver.cc (__set_errno): Copy from debug.cc so that
	set_errno() can be used when __OUTSIDE_CYGWIN__.
	(main): Call cygserver_init() to set up cygserver_running and add
	checks against this to (try and) prevent multiple copies of
	cygserver running simultaneously.  Remember to delete all
	transport connections so that (one day) the transport classes can
	tidy up on cygserver shutdown.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (main): Adjust tracing output for a cleaner display
	when compiled without --enable-debugging.
	* threaded_queue.cc (threaded_queue::cleanup): Ditto.
	(queue_process_param::stop): Ditto.
	* include/cygwin/cygserver.h
	(client_request::make_request): Make non-virtual.
	(client_request::send): Make virtual and protected, not private.
	(client_request_attach_tty::send): New virtual method.
	* cygserver_client.cc: Use the `msglen()' accessor rather than
	`_header.msglen' throughout.
	(client_request_attach_tty::send): New method.
	(client_request::make_request): Remove the explicit close of
	`transport' as it is closed on deletion.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(cygserver_transport::read): Change buffer type to void *.
	(cygserver_transport::write): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::read): Ditto.
	(cygserver_transport_pipes::write): Ditto.
	* cygserver_transport_sockets.cc
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* cygserver_transport_pipes.cc
	(cygserver_transport_pipes::read): Ditto. Set errno on error, to
	match behaviour of cygserver_transport_sockets class.
	(cygserver_transport_pipes::write): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (version): New static variable.
	(server_request_queue::add_connection): Remove my gratuitous use
	of studly caps.
	(setup_privileges): Declare static.
	(handle_signal): Ditto.
	(longopts): Make a local variable of main().
	(opts): Ditto.
	(print_usage): New function.
	(print_version): Ditto (tip of the hat to Joshua Daniel Franklin
	for inspiration here).
	(main): More argument checking.  Add --help and --version options.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::serve): Make pure
	virtual.
	* cygserver.cc (client_request::serve): Remove definition of pure
	virtual method.
	(class client_request_invalid): New class.
	(server_request::process): Use new client_request_invalid
	class. And remove goto's.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (class server_request): Add virtual destructor.
	(server_request_queue::addConnection): New method to replace bad
	virtual add() method.
	(request_loop): Replace call to queue->add() with call to
	queue->addConnection().
	(server_request::server_request): Use field initialization.
	(server_request::~server_request): New virtual destructor.
	(server_request::process): Remove close and delete of
	transport_layer_base object. It is deleted by the server_request's
	own destructor and closed by its own destructor.
	* include/cygwin/cygserver.h
	(client_request::operator request_header): Remove unused method.
	* cygserver_client.cc: Ditto.
	* include/cygwin/cygserver_process.h
	(class cleanup_routine): Add virtual destructor.
	(cleanup_routine::cleanup): Make pure virtual.
	(class process_cache): Make destructor non-virtual.
	(process_cache::add): Ditto.
	* cygserver_process.cc
	(cleanup_routine::~cleanup_routine): New virtual destructor.
	* include/cygwin/cygserver_transport.h
	(class transport_layer_base): Add virtual destructor.
	* cygserver_transport.cc
	(transport_layer_base::~transport_layer_base): New virtual
	destructor.
	* include/cygwin/cygserver_transport_pipes.h
	(class transport_layer_pipes): Add virtual destructor.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::~transport_layer_pipes): New virtual
	destructor.
	(transport_layer_pipes::close): Null out handle after closing.
	* include/cygwin/cygserver_transport_sockets.h
	(class transport_layer_sockets): Add virtual destructor.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::~transport_layer_sockets): New virtual
	destructor.
	(transport_layer_sockets::close): Null out fd after closing.
	* threaded_queue.h (class queue_request): Add virtual destructor.
	(queue_request::process): Make pure virtual.
	* threaded_queue.cc (~queue_request): New virtual destructor.
	(queue_request::process): Remove definition of pure virtual
	method.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::send): Make
	non-virtual.
	(class client_request_attach_tty): Put client- and server-specific
	interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__ guards.
	* cygserver_client.cc: Ditto.
	(cygserver_init): Fix error handling.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: Throughout the code, check and correct level of
	the XXX_printf() functions used. Comment out several of the
	debug_printf() calls with "// verbose:".  Reformat and correct
	typos of some of the XXX_printf() formats.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* shm.cc (hi_ulong): New function to allow printing of a 64-bit
	key with current small_printf implementation.
	(lo_ulong): Ditto.
	(client_request_shm::client_request_shm): Use hi_ulong() and
	lo_ulong() in call to debug_printf().

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Remove #define __INSIDE_CYGWIN__ from around
	<sys/shm.h> as it no longer contains any internal code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h (IPC_PRIVATE): Add cast to key_t.
	(IPC_INFO): New flag for ipcs(8).
	(IPC_RMID IPC_SET IPC_STAT): Renumber.
	* include/sys/shm.h (SHM_RDONLY SHM_RND): Renumber with distinct
	values [sic].
	(class _shmattach): Internal type moved to "cygserver_shm.h".
	(class shmnode): Ditto.
	(class shmid_ds): Ditto.
	(struct shmid_ds): Add spare fields.
	(struct shminfo): New type for IPC_INFO interface.
	* cygserver_shm.h: Remove obsolete #if 0 ... #endif block.
	(class shm_cleanup): Remove unused class.
	(struct _shmattach): Internal type moved from <sys/shm.h>.
	(struct shmnode): Ditto.
	(struct int_shmid_ds): Ditto. Renamed to avoid name clash with
	public interface struct shmid_ds. Use the shmid_bs structure as a
	field.
	* cygserver_shm.cc: Remove obsolete #if 0 ... #endif block.
	(client_request_shm::serve): Update for redefinition of
	int_shmid_ds structure.
	* shm.cc (build_inprocess_shmds): Ditto.
	(fixup_shms_after_fork): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove obsolete #if 0 ... #endif code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Make a pure virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport.cc
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Remove since it is now a pure
	virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (check_and_dup_handle): Only use security code if
	running on NT, i.e. if wincap.has_security().
	(client_request_attach_tty::serve): Add check for has_security().
	* cygserver_process.cc (process_cache::process): Use DWORD winpid
	throughout to avoid win32 vs. cygwin pid confusion.
	(process::process): Ditto.
	* cygserver_shm.cc (client_request_shm::serve): Only use security
	code if running on NT, i.e. if wincap.has_security().
	* cygserver_shm.h (client_request_shm::parameters.in): Replace the
	ambiguous pid field with cygpid and winpid fields.
	(client_request_shm::client_request_shm): Reduce to only two
	client-side constructors: one for SHM_CREATE, another for all the
	other requests.
	* shm.cc (client_request_shm::client_request_shm):
	Ditto. Initialize cygpid and winpid fields here. On NT initialize
	sd_buf here using set_security_attribute() to make use of the euid
	and egid.
	(shmat): Use new client_request_shm constructor.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove security code, now performed in the
	relevant client_request_shm constructor.
	* include/cygwin/cygserver_process.h: (class cleanup_routine):
	Change winpid type to DWORD.
	(class process): Ditto.

2002-06-15  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: New file.
	* cygserver.cc: Use "woutsup.h" and new XXX_printf macros.
	(getfunc): New function, copied verbatim from "strace.cc".
	(__cygserver__printf): New function.
	* cygserver_client.cc: Use "woutsup.h" and new XXX_printf macros.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* threaded_queue.cc: Ditto.
	* shm.cc: Remove trailing \n from XXX_printf format strings.
	* Makefile.in: Remove special __OUTSIDE_CYGWIN__ case for
	cygserver_shm.cc.
@
text
@d39 1
a39 1
  : fhandler_pty_master (FH_TTYM, unit), console (NULL), output_thread (NULL)
d65 11
a75 8
  h = new cygthread (process_input, NULL, "ttyin");
  SetThreadPriority (*h, THREAD_PRIORITY_HIGHEST);

  h = new cygthread (process_ioctl, NULL, "ttyioctl");
  SetThreadPriority (*h, THREAD_PRIORITY_HIGHEST);

  output_thread = new cygthread (process_output, cygself, "ttyout");
  SetThreadPriority (*output_thread, THREAD_PRIORITY_HIGHEST);
d374 1
a374 1
process_output (void *self)
d376 1
a376 1
  char buf[OUT_BUFFER_SIZE*2];
d385 1
a385 3
	  cygthread *t = (cygthread *) self;
	  tty_master->output_thread = NULL;
	  t->exit_thread ();
a1170 1
  output_thread = NULL;		// It's unreachable now
a1177 1
  output_thread = NULL;		// It's unreachable now
@


1.72
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@a26 1
#include "cygwin/cygserver_transport.h"
d492 2
a493 2
      cygserver_running!=CYGSERVER_OK ||
      !cygserver_attach_tty ( &from_master_local, &to_master_local))
d549 3
a551 5
  client_request_attach_tty *request =
	new client_request_attach_tty ((DWORD) GetCurrentProcessId (),
				      (DWORD) get_ttyp ()->master_pid,
				      (HANDLE) get_ttyp ()->from_master,
				      (HANDLE) get_ttyp ()->to_master);
d553 1
a553 2
  if (cygserver_request (request) != 0 ||
	request->header.error_code != 0)
d556 2
a557 13
/*
  struct request_attach_tty req;
  INIT_REQUEST (req, CYGSERVER_REQUEST_ATTACH_TTY);
  req.pid = GetCurrentProcessId ();
  req.master_pid = get_ttyp ()->master_pid;
  req.from_master = get_ttyp ()->from_master;
  req.to_master = get_ttyp ()->to_master;
  if (cygserver_request ((struct request_header*) &req) != 0)
    return 0;
*/
  *from_master_ptr = request->from_master ();
  *to_master_ptr = request->to_master ();
  delete request;
@


1.71
log
@* fhandler_tty.cc (fhandler_tty_slave::open): Don't protect input/output
handles since they are not properly manipulated later.
* tty.cc (tty::make_pipes): Ditto.
@
text
@d711 1
a711 1
      if (!PeekNamedPipe (get_handle (), peek_buf, sizeof(peek_buf), &bytes_in_pipe, NULL, NULL))
@


1.70
log
@* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Set "don't need
ready for read" flag.
(fhandler_tty_slave::read): Don't do anything special with vtime when vmin ==
0.
@
text
@a534 1
  ProtectHandle1INH (from_master_local, from_pty);
a535 1
  ProtectHandle1INH (to_master_local, to_pty);
@


1.69
log
@(inspired by a patch from Egor Duda)
* select.cc (fhandler_tty_slave::ready_for_read): Remove.
* fhandler.h (fhandler_tty_slave::ready_for_read): Remove declaration.
* fhandler_tty.cc (fhandler_tty_slave::read): Don't do anything special with
vtime when vmin == 0.
* autoload.cc (GetConsoleWindow): Correct parameter count.
@
text
@d421 1
@


1.68
log
@* cygthread.cc (cygthread::stub): Accept flag to pass info structure to thread
function.
(cygthread::operator new): Add defense debugging output.
(cygthread::cygthread): Add debugging output.  Set name after thread has been
awakened to avoid a race.
(cygthread::exit_thread): Use handle operator rather than using ev directly.
(cygthread::exit_thread): Reorganize to provide debugging.  Set __name to NULL.
* cygthread.h (cygself): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Use cygself as argument so that
invoked thread can access its own info.
(process_output): Derive cygthread info of thread from thread argument.
* sigproc.cc (sigproc_init): Use cygself as argument so that invoked thread can
access its own info.
(wait_sig): Derive cygthread info of thread from thread argument.
@
text
@d415 1
d670 5
a674 6
      if (vmin < 0) vmin = 0;
      if (vtime < 0) vtime = 0;
      if (vmin == 0)
	time_to_wait = INFINITE;
      else
	time_to_wait = (vtime == 0 ? INFINITE : 100 * vtime);
d913 2
a914 2
  if (myself->pgid && get_ttyp ()->getpgid () != myself->pgid &&
	 myself->ctty == ttynum && (get_ttyp ()->ti.c_lflag & TOSTOP))
@


1.67
log
@* cygthread.cc (cygthread::exit_thread): Define new method.
* cygthread.h (cygthread::exit_thread): Declare new method.
* fhandler.h (fhandler_tty_master::hThread): Delete.
(fhandler_tty_master::output_thread): Define.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Adjust
constructor.
(fhandler_tty_master::init): Use cygthread rather than handle.
(process_output): Use cygthread method to exit.
(fhandler_tty_master::fixup_after_fork): Set output_thread to NULL after fork.
(fhandler_tty_master::fixup_after_exec): Set output_thread to NULL after
spawn/exec.
* tty.cc (tty_list::terminate): Detach from output_thread using cygthread
method.
@
text
@d72 1
a72 1
  output_thread = new cygthread (process_output, NULL, "ttyout");
d372 1
a372 1
process_output (void *)
d383 1
a383 1
	  cygthread *t = tty_master->output_thread;
@


1.66
log
@* Makefile.in (DLL_OFILES): Add cygthread.o.
* dcrt0.cc (dll_crt0_1): Eliminate various thread initialization functions in
favor of new cygthread class.
* debug.cc: Remove thread manipulation functions.
* debug.h: Ditto.
* external.cc (cygwin_internal): Use cygthread method for determining thread
name.  Remove capability for setting thread name.
* fhandler_console.cc (fhandler_console::read): Use cygthread method rather
than iscygthread function.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Use cygthread
methods to create threads.
(fhandler_tty_common::__acquire_output_mutex): Use cygthread method to retrieve
thread name.
* select.cc (pipeinf): Use cygthread pointer rather than handle.
(start_thread_pipe): Ditto.
(pipe_cleanup): Ditto.
(serialinf): Ditto.
(start_thread_serial): Ditto.
(serial_cleanup): Ditto.
(socketinf): Ditto.
(start_thread_socket): Ditto.
(socket_cleanup): Ditto.
* sigproc.cc (hwait_sig): Ditto.
(hwait_subproc): Ditto.
(proc_terminate): Ditto.
(sigproc_terminate): Ditto.
(sigproc_init): Initialize cygthread hwait_sig pointer.
(subproc_init): Initialize cygthread hwait_subproc pointer.
(wait_sig): Rely on cygthread HANDLE operator.
* strace.cc (strace::vsprntf): Use cygthread::name rather than threadname.
* window.cc (gethwnd): Use cygthread method to initialize thread.
@
text
@d40 1
a40 1
  : fhandler_pty_master (FH_TTYM, unit), console (NULL), hThread (NULL)
d72 2
a73 3
  h = new cygthread (process_output, NULL, "ttyout");
  hThread = *h;
  SetThreadPriority (h, THREAD_PRIORITY_HIGHEST);
d379 1
a379 1
      if (n < 0)
d381 5
a385 7
	  termios_printf ("ReadFile %E");
	  ExitThread (0);
	}
      if (n == 0)
	{
	  /* End of file.  */
	  ExitThread (0);
d1186 1
d1194 1
a1194 1
  return;
@


1.65
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d29 1
a46 1
  HANDLE h;
d65 10
a74 32
  h = makethread (process_input, NULL, 0, "ttyin");
  if (h == NULL)
    {
      termios_printf ("can't create input thread");
      return -1;
    }
  else
    {
      SetThreadPriority (h, THREAD_PRIORITY_HIGHEST);
      CloseHandle (h);
    }

  h = makethread (process_ioctl, NULL, 0, "ttyioctl");
  if (h == NULL)
    {
      termios_printf ("can't create ioctl thread");
      return -1;
    }
  else
    {
      SetThreadPriority (h, THREAD_PRIORITY_HIGHEST);
      CloseHandle (h);
    }

  hThread = makethread (process_output, NULL, 0, "ttyout");
  if (hThread != NULL)
    SetThreadPriority (hThread, THREAD_PRIORITY_HIGHEST);
  else
    {
      termios_printf ("can't create output thread");
      return -1;
    }
d106 1
a106 1
      ostack[osi].tname = threadname (0, 0);
@


1.64
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d558 1
a558 1
  ProtectHandle1 (from_master_local, from_pty);
d560 1
a560 1
  ProtectHandle1 (to_master_local, to_pty);
@


1.63
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d457 1
a457 1
  set_flags (flags & ~O_TEXT, O_BINARY);
d1009 1
a1009 1
  set_flags (flags & ~O_TEXT, O_BINARY);
@


1.62
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001 Red Hat, Inc.
@


1.61
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@a12 1
#include <fcntl.h>
d457 1
a457 1
  set_flags (flags);
d1009 1
a1009 1
  set_flags (flags);
@


1.60
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d523 1
a523 1
				         get_ttyp ()->master_pid);
d526 6
a531 6
        {
          termios_printf ("can't open tty (%d) handle process %d",
	 	          ttynum, get_ttyp ()->master_pid);
          __seterrno ();
          return 0;
        }
d533 2
a534 2
      if (!DuplicateHandle (tty_owner, get_ttyp ()->from_master, 
			  hMainProc, &from_master_local, 0, TRUE,
d536 5
a540 5
        {
          termios_printf ("can't duplicate input, %E");
          __seterrno ();
          return 0;
        }
d542 1
a542 1
      if (!DuplicateHandle (tty_owner, get_ttyp ()->to_master, 
d545 5
a549 5
        {
          termios_printf ("can't duplicate output, %E");
          __seterrno ();
          return 0;
        }
d571 1
a571 1
                                        LPHANDLE to_master_ptr)
d576 1
a576 1
  client_request_attach_tty *request = 
@


1.59
log
@* path.cc (path_conv::check): Always set executable bit for executable
extension.
@
text
@a23 1
#include "sync.h"
@


1.58
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* Merged cygwin_daemon into head minus the new shm and ipc exports.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* fhandler_tty.cc (fhandler_tty_slave::open): More debugging.
	(fhandler_tty_slave::read): Fix printf type for the handle.
	* tty.cc (tty::common_init): Add a FIXME for security.

2002-01-29  Robert Collins  <rbtcollins@@hotmail.com>

	* Makefile.in (OBJS): Remove duplicate localtime.o.

2002-01-17  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (check_and_dup_handle): Consolidate the two variants for
	simplicity.
	Add Some basic debug output.
	(client_request_attach_tty::serve): Use the new debug_printf for clarity.
	Mark the duplicated handles as inheritable - fixup_after_fork() doesn't reopen
	tty's.

2002-01-16  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (transport): Correct scope.
	(client_request_attach_tty::serve): Add more debug information.
	Fix erroneous use of transport instead of conn.
	* cygserver_transport_pipes.cc (transport_layer_pipes::close): More debug.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.

Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (server_request::process): Rename client_request_shm_get to
	client_request_shm.
	* cygserver_process.cc (process_cache::add): Rename to add_task.
	Use process_cleanup instead of process_request.
	(process_cache::remove_process): New method.
	(process::process): Initialize new members.
	(process::~process): New member.
	(process::cleanup): New method.
	(process::add_cleanup_routine): New method.
	(process_request::process): Rename to process_cleanup.
	Call the process object's cleanup method and then delete it.
	(process_process_param::request_loop): Remove the signalling process.
	* cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm_get::serve): Handle attach request counting.
	* cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
	(class shm_cleanup): New class.
	* shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm::client_request_shm): New constructor for attach requests.
	(shmat): Use it.
	* include/cygwin/cygserver_process.h (class process_request): Rename to
	process_cleanup.
	(class cleanup_routine): New class.
	(class process): New members and methods to allow calling back when the process
	terminates.

Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* cygserver.cc (request_loop): Make static.
	(main): Use new cache constructor syntax.
	Start cache worker threads.
	Cleanup the cache at shutdown.
	* cygserver_process.cc: Run indent.
	(process_cache::process_cache): Add a trigger to use when adding a process.
	(process_cache::process): Move process_entry to process.
	Insert at the end of the list.
	Trigger the request loop when new process's inserted.
	(process_cache::process_requests): Do it.
	(process_cache::add): New method.
	(process_cache::handle_snapshot): New method.
	(process::process): Merge in the process_entry fields.
	(process::handle): Make a stub function.
	(process::exit_code): New method.
	(process_request::process): New method.
	(process_process_param::request_loop): New method.
	* cygserver_shm.cc: New header dependency - threaded_queue.h.
	* threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
	(queue_process_param::stop): Short spinlock on interruptible threads.
	* threaded_queue.h (class threaded_queue): New constructor.
	* include/cygwin/cygserver_process.h (process_request): New class.
	(process_entry): Remove.
	(process): Merge in process_entry.
	(process_cache): Inherit from threaded_queue.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (class server_process_param): Use new constructor syntax.
	* cygserver_process.cc (process_cache::~process_cache): New function.
	* threaded_queue.cc: Define condition debug_printf.
	Run indent.
	(threaded_queue::cleanup): Move queue_process_param guts to a method.
	(threaded_queue::process_requests): Ditto.
	(queue_process_param::queue_process_param): New method.
	(queue_process_param::~queue_process_param): Ditto.
	(queue_process_param::start): Ditto.
	(queue_process_param::stop): Ditto.
	* threaded_queue.h (class queue_process_param): Add support for
	interruptible request loops.
	* cygwin/include/cygwin/cygserver_process.h (class process_cache): Add
	destructor.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver_client.cc: New flag allow_daemon to disable the daemon completely.
	(cygserver_request): Check it.
	(cygserver_init): Ditto.
	* environ.cc (parse_thing): Add (no)daemon option.

Tue Oct  2 23:00:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* shm.cc: Update to handle include changes from HEAD.

Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
	Rename cygserver_shm_outside.o to cygserver_shm.o.
	* cygserver.cc (server_request::process): Use the new client_request
	constructor.
	* cygserver_client.cc: Remove the #ifdef's stubs for the server method
	within cygwin.
	(client_request_attach_tty::client_request_attach_tty): Use the new
	client_request constructor.
	(client_request_shutdown::client_request_shutdown): Ditto.
	(client_request::client_request): Ditto.
	* cygserver_shm.cc (client_request_shm_get::serve): Remove the
	#ifdef'd stub for in-cygwin builds.
	(client_request_shm_get::client_request_shm_get): Use the new
	client_request constructor, and remove the in-cygwin variants.
	* cygserver_shm.h (class client_request_shm_get): #ifndef test the
	serve method - it's only used in cygserver.
	* shm.cc (client_request_shm_get::client_request_shm_get): New function.
	* include/cygwin/cygserver.h (request_header): New constructor.
	(class client_request): Use it.
	New constructor accepting the header size.
	#ifndef test the server method - it's only used within cygserver.
	(client_request_get_version): #ifdef test the server method.
	(client_request_shutdown): Ditto.
	(client_request_attach_tty): Ditto.

Tue Oct  2  9:57:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: add threaded_queue.o to cygserver.exe.
	* cygserver.cc: Include threaded_queue.h
	(class server_request): Inherit from queue_request.
	(class server_process_param): Inherit from queue_process_param.
	(class server_request_queue): Inherit from threaded_queue.
	(request_loop): Adjust for new types.
	(server_request_queue::process_requests): Remove guts to
	threaded_queue::process_requests.
	(server_request::server_request): Adjust for new types.
	(worker_function): Delete.
	(server_request_queue::create_workers): Delete.
	(server_request_queue::cleanup): Delete.
	(server_request_queue::add): Move guts to threaded_queue::add.
	* threaded_queue.cc: New file.
	* threaded_queue.h: New file.

Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (client_request::serve): New function.
	* cygserver_process.cc: Inlude <pthread.h> for pthread_once.
	(process_cache::process_cache): Initialise a crtiical section for write access.
	(process_cache::process): Use the critical section. Also add missing entries to
	the cache.
	(do_process_init): New function to initalise class process static variables.
	(process::process): Ensure that the process access critical section is
	initialised.
	(process::handle): Close the handle of old process's when they have terminated
	and we are returning the handle for a process with the same pid.
	* cygserver_shm.cc: Run indent.
	Include cygserver_process.h to allow process cache functionality.
	(client_request_shm_get::serve): New parameter for process cache support.
	Use the process cache, not OpenProcess to get a handle to the originating process.
	Fix a handle leak with token_handle.
	* cygserver_shm.h (class client_request_shm_get): Update ::serve for process
	cache support.
	* cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
	* include/cygwin/cygserver.h: Do not implement client_request::serve in the
	header.
	* include/cygwin/cygserver_process.h (class process_cache): Add a write access
	critical section to prevent races when requests from a  multithreaded
	application arrive.

Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_process.o to cygserver.exe.
	* cygserver.cc: Include signal.h and cygwin_version.h.
	Define debug_printf as a macro.
	Define DEBUG to a value.
	(client_request_attach_tty::serve): Add beginning of process cache support.
	Change from #ifdef DEBUG to work with new DEBUG style.
	(client_request_get_version::serve): Add beginning of process cache support.
	(class server_request): New prototype for support of process cache.
	(class queue_process_param): New class to allow request loop threading.
	(class server_request_queue): Add beginning of process cache support.
	Allow request loop threading.
	(request_loop): Thread function for request loops.
	(server_request_queue::process_requests): Initiator for threaded request loops.
	(client_request_shutdown::serve): Add beginning of process cache support.
	(server_request::server_request): Ditto.
	(server_request::process): Use debug_printf. Add beginning of process cache
	support.
	(server_request_queue::cleanup): Kill off any request loop threads.
	(server_request_queue::add): Add beginning of process cache support.
	(handle_signal): Trigger a shutdown.
	(main): Print out some useful info at startup - version, date time.
	Add process cache support.
	Spawn a separate thread for the transport request loop, thus allowing concurrent
	support for multiple transports.
	* cygserver_client.cc (client_request_get_version::serve): Add process cache
	support.
	(client_request_attach_tty::serve): Add process cache support.
	(client_request_shutdown::serve): Add process cache support.
	* cygsserver_process.cc: New file with the process cache support.
	* cygserver_shm.cc: Redefine debug_printf to allow conditional output.
	* cygwin.din: Export shmdt().
	* shm.cc: Run indent.
	Update FIXME's.
	(shmdt): New function.
	* include/cygwin/cygserver.h (class client_request): Add process cache support.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.
	* include/cygwin/cygserver_process.h: New header for process cache support.

Sun Sep 30  8:52:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* include/cygwin/cygserver_transport.h: Add copyright header.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.

Sat Sep 29 20:40:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
	Add cygserver_transport_sockets_outside.o to cygserver.exe.
	* cygserver.cc: Include new include files.
	* cygserver_client.cc: Ditto.
	* cygserver_shm.h: No need to include <sys/socket.h> now.
	* cygerver_transport.cc: Include new include files.
	(transport_layer_base::transport_layer_base): Strip back to a stub.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport_pipes.cc: Include new header
	"cygwin/cygserver_transport_pipes.h".
	* cygserver_transport_sockets.cc: New file.
	* dcrt0.cc: No need to include <sys/socket.h> now.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
	* include/cygwin/cygserver_transport.h: Strip the base class to a stub.
	Remove the cygserver_transport_pipes class.
	* include/cygwin/cygserver_transport_pipes.h: New file.
	* include/cygwin/cygserver_transport_sockets.h: New file.

Tue Sep 25 16:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* autoload.cc: Add dynamic load statement for 'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when obtaining
	handles from the parent process. On failure or 9x use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
	* cygserver.cc: New file.
	* cygserver_client.cc: New file.
	* cygserver_shm.cc: New file.
	* cygserver_shm.h: New file.
	* cygserver_transport.cc: New file.
	* cygserver_transport_pipes.cc: New file.
	* ipc.cc: New file.
	* shm.cc: New file.
	* include/cygwin/cygserver.h: New file.
	* include/cygwin/cygserver_transport.h: New file.
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* thread.cc (semaphore::TryWait): Set errno as required by posix 1003.1.
	(__sem_wait): Ditto.
	(__sem_trywait): Ditto.
@
text
@d692 3
a694 1
      vmin = min (INP_BUFFER_SIZE, get_ttyp ()->ti.c_cc[VMIN]);
@


1.57
log
@* sync.h (new_muto): Just accept an argument which denotes the name of the
muto.  Use this argument to construct static storage.
* cygheap.cc (cygheap_init): Reflect above change.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* cygheap.h (cwdstuff): Change name of lock element to make it less generic.
* path.cc (cwdstuff::get_hash): Ditto.
(cwdstuff::get_initial): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* sigproc.cc (proc_subproc): Ditto.
* debug.cc (lock_debug): Change to method.  Use method rather than macro
throughout.
* tty.h (tty_min::kill_pgrp): Declare new method.
* fhandler_termios.cc (tty_min::kill_pgrp): New method.
(fhandler_termios::line_edit): Use new method for killing process.
* dcrt0.cc (do_exit): Ditto.
* dtable.cc (dtable::get_debugger_info): New method for inheriting dtable info
from a debugger.
* tty.cc (tty_init): Attempt to grab file handle info from parent debugger, if
appropriate.  # dtable.cc (dtable::stdio_init): Make this a method.
(dtable::init_std_file_from_handle): Don't set fd unless it's not open.
(dtable::build_fhandler_from_name): Move name setting to
dtable::build_fhandler.
(dtable::build_fhandler): Add win32 name parameter.
* dcrt0.cc (dll_crt0_1): Change to use dtable stdio_init.
* dtable.h (dtable): Reflect build_fhandler parameter change.
* mmap.cc (mmap_record::alloc_fh): Don't set name parameter in build_fhandler.
* net.cc (fdsock): Remove set_name call since it is now handled by
build_fhandler.
* sigproc.cc (proc_subproc): Release muto as early as possible.
@
text
@d29 2
d515 1
a515 9
  HANDLE tty_owner = OpenProcess (PROCESS_DUP_HANDLE, FALSE,
				     get_ttyp ()->master_pid);
  if (tty_owner == NULL)
    {
      termios_printf ("can't open tty (%d) handle process %d",
		      ttynum, get_ttyp ()->master_pid);
      __seterrno ();
      return 0;
    }
d517 46
a562 22
  HANDLE nh;
  if (!DuplicateHandle (tty_owner, get_ttyp ()->from_master, hMainProc, &nh, 0, TRUE,
			DUPLICATE_SAME_ACCESS))
    {
      termios_printf ("can't duplicate input, %E");
      __seterrno ();
      return 0;
    }
  set_io_handle (nh);
  ProtectHandle1 (nh, from_pty);
  termios_printf ("duplicated from_master %p->%p from tty_owner %p",
		  get_ttyp ()->from_master, nh, tty_owner);
  if (!DuplicateHandle (tty_owner, get_ttyp ()->to_master, hMainProc, &nh, 0, TRUE,
			DUPLICATE_SAME_ACCESS))
    {
      termios_printf ("can't duplicate output, %E");
      __seterrno ();
      return 0;
    }
  set_output_handle (nh);
  ProtectHandle1 (nh, to_pty);
  CloseHandle (tty_owner);
d570 33
d688 1
a688 1
  termios_printf ("read(%x, %d) handle %d", ptr, len, get_handle ());
@


1.56
log
@* fhandler.h (fhandler_serial::fhandler_serial): Change to only accept unit
argument.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
(fhandler_serial::open): Avoid else when previous clause is a return().
* path.cc (get_devn): Alias /dev/ttyS0 -> /dev/com1, etc.
(get_device_number): Reallow standalone "com1" as a valid name for /dev/com1.
@
text
@d976 2
a979 2
  if (!ForceCloseHandle (input_mutex))
    termios_printf ("CloseHandle (input_mutex<%p>), %E", input_mutex);
@


1.55
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d38 2
a39 2
fhandler_tty_master::fhandler_tty_master (int unit) :
	fhandler_pty_master (FH_TTYM, unit), console (NULL), hThread (NULL)
@


1.54
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d622 1
a622 1
int
d1035 1
a1035 1
int
@


1.53
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d39 1
a39 1
	fhandler_pty_master (FH_TTYM, unit)
a40 3
  set_cb (sizeof *this);
  console = NULL;
  hThread = NULL;
a439 4
  set_cb (sizeof *this);
  ttynum = num;
  debug_printf ("unix '%s', win32 '%s'", unix_path_name, win32_path_name);
  inuse = NULL;
a444 2
  set_cb (sizeof *this);
  inuse = NULL;
a946 5
  set_cb (sizeof *this);
  ioctl_request_event = NULL;
  ioctl_done_event = NULL;
  pktmode = need_nl = 0;
  inuse = NULL;
@


1.52
log
@* fhandler.cc (fhandler_base::fork_fixup): Protect dup'ed handle and record it
as non-inheritable for debugging purposes in case there is a subsequent fork or
exec.
* fhandler_tty.cc (fhandler_tty_common::fixup_after_fork): Allow fork_fixup to
call ProtecHandle.
@
text
@d38 2
a39 2
fhandler_tty_master::fhandler_tty_master (const char *name, int unit) :
	fhandler_pty_master (name, FH_TTYM, unit)
d440 2
a441 2
fhandler_tty_slave::fhandler_tty_slave (int num, const char *name) :
	fhandler_tty_common (FH_TTYS, name, num)
d449 2
a450 2
fhandler_tty_slave::fhandler_tty_slave (const char *name) :
	fhandler_tty_common (FH_TTYS, name, 0)
d953 2
a954 2
fhandler_pty_master::fhandler_pty_master (const char *name, DWORD devtype, int unit) :
	fhandler_tty_common (devtype, name, unit)
@


1.51
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d1146 1
a1146 4
    {
      fork_fixup (parent, output_mutex, "output_mutex");
      ProtectHandle (output_mutex);
    }
d1148 1
a1148 4
    {
      fork_fixup (parent, input_mutex, "input_mutex");
      ProtectHandle (input_mutex);
    }
@


1.50
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d459 1
a459 1
fhandler_tty_slave::open (const char *, int flags, mode_t)
d964 1
a964 1
fhandler_pty_master::open (const char *, int flags, mode_t)
@


1.49
log
@* fhandler.h (fhandler_pipe::hit_eof): New method.
(writepipe_exists): New class element.
(orig_pid): Ditto.
(id): Ditto.
(is_slow): Eliminate.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance on
writepipe_exists, if it exists.
(fhandler_pipe::hit_eof): New method, modelled after tty.
(fhandler_pipe::dup): Duplicate writepipe_exists, if it exists.
(make_pipe): Set up a dummy event for pipes on windows 9x.  The nonexistence
of this event means that the write side of the pipe has closed.
(_dup): Move to syscalls.cc
(_dup2): Ditto.

* dtable.cc (dtable::build_fhandler): Fill out set_names here, if appropriate.
* syscalls.cc (_open): Call set_names in build_fhandler.
@
text
@d22 1
a444 5
  /* FIXME: This is wasteful.  We should rewrite the set_name path to eliminate the
     need for double allocates. */
  unix_path_name = (char *) crealloc (unix_path_name, strlen (win32_path_name) + 1);
  strcpy (unix_path_name, win32_path_name);
  unix_path_name[0] = unix_path_name[4] = '/';
@


1.49.2.1
log
@Tue Sep 25 16:22:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc: Add dynamic load statement for
	'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build
	instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when
	obtaining handles from the parent process. On failure or 9x
	use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
										CVS: ----------------------------------------------------------------------
@
text
@a27 3
#include <sys/socket.h>
#include "cygwin/cygserver_transport.h"
#include "cygwin/cygserver.h"
d526 9
a534 1
  HANDLE from_master_local, to_master_local;
d536 22
a557 44
  if (!wincap.has_security () ||
      cygserver_running!=CYGSERVER_OK ||
      !cygserver_attach_tty ( &from_master_local, &to_master_local))
    {
      termios_printf ("cannot dup handles via server. using old method.");

      HANDLE tty_owner = OpenProcess (PROCESS_DUP_HANDLE, FALSE,
				         get_ttyp ()->master_pid);
      if (tty_owner == NULL)
        {
          termios_printf ("can't open tty (%d) handle process %d",
	 	          ttynum, get_ttyp ()->master_pid);
          __seterrno ();
          return 0;
        }

      if (!DuplicateHandle (tty_owner, get_ttyp ()->from_master, 
			  hMainProc, &from_master_local, 0, TRUE,
			    DUPLICATE_SAME_ACCESS))
        {
          termios_printf ("can't duplicate input, %E");
          __seterrno ();
          return 0;
        }
      termios_printf ("duplicated from_master %p->%p from tty_owner %p",
		     get_ttyp ()->from_master, from_master_local, tty_owner);

      if (!DuplicateHandle (tty_owner, get_ttyp ()->to_master, 
			  hMainProc, &to_master_local, 0, TRUE,
			  DUPLICATE_SAME_ACCESS))
        {
          termios_printf ("can't duplicate output, %E");
          __seterrno ();
          return 0;
        }
      termios_printf ("duplicated to_master %p->%p from tty_owner %p",
      		     get_ttyp ()->to_master, to_master_local, tty_owner);
      CloseHandle (tty_owner);
    }

  set_io_handle (from_master_local);
  ProtectHandle1 (from_master_local, from_pty);
  set_output_handle (to_master_local);
  ProtectHandle1 (to_master_local, to_pty);
a561 33
  return 1;
}

int
fhandler_tty_slave::cygserver_attach_tty (LPHANDLE from_master_ptr,
                                        LPHANDLE to_master_ptr)
{
  if (!from_master_ptr || !to_master_ptr)
    return 0;

  client_request_attach_tty *request = 
	new client_request_attach_tty ((DWORD) GetCurrentProcessId (),
				      (DWORD) get_ttyp ()->master_pid,
				      (HANDLE) get_ttyp ()->from_master,
				      (HANDLE) get_ttyp ()->to_master);

  if (cygserver_request (request) != 0 ||
	request->header.error_code != 0)
    return 0;

/*
  struct request_attach_tty req;
  INIT_REQUEST (req, CYGSERVER_REQUEST_ATTACH_TTY);
  req.pid = GetCurrentProcessId ();
  req.master_pid = get_ttyp ()->master_pid;
  req.from_master = get_ttyp ()->from_master;
  req.to_master = get_ttyp ()->to_master;
  if (cygserver_request ((struct request_header*) &req) != 0)
    return 0;
*/
  *from_master_ptr = request->from_master ();
  *to_master_ptr = request->to_master ();
  delete request;
@


1.49.2.2
log
@Sat Sep 29 20:40:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
        Add cygserver_transport_sockets_outside.o to cygserver.exe.
        * cygserver.cc: Include new include files.
        * cygserver_client.cc: Ditto.
        * cygserver_shm.h: No need to include <sys/socket.h> now.
        * cygerver_transport.cc: Include new include files.
        (transport_layer_base::transport_layer_base): Strip back to a stub.
        (transport_layer_base::listen): Ditto.
        (transport_layer_base::accept): Ditto.
        (transport_layer_base::close): Ditto.
        (transport_layer_base::read): Ditto.
        (transport_layer_base::write): Ditto.
        (transport_layer_base::connect): Ditto.
        * cygserver_transport_pipes.cc: Include new header
        "cygwin/cygserver_transport_pipes.h".
        * cygserver_transport_sockets.cc: New file.
        * dcrt0.cc: No need to include <sys/socket.h> now.
        * fhandler_tty.cc: Ditto.
        * tty.cc: Ditto.
        * include/cygwin/cygserver_transport.h: Strip the base class to a stub.
        Remove the cygserver_transport_pipes class.
        * include/cygwin/cygserver_transport_pipes.h: New file.
        * include/cygwin/cygserver_transport_sockets.h: New file.
@
text
@d28 1
@


1.49.2.3
log
@Merged changes from HEAD
@
text
@a21 1
#include "path.h"
d446 5
@


1.49.2.4
log
@Merged changes from HEAD
@
text
@d40 2
a41 2
fhandler_tty_master::fhandler_tty_master (int unit)
  : fhandler_pty_master (FH_TTYM, unit), console (NULL), hThread (NULL)
d43 3
d442 2
a443 2
fhandler_tty_slave::fhandler_tty_slave (int num)
  : fhandler_tty_common (FH_TTYS, num)
d445 4
d451 2
a452 2
fhandler_tty_slave::fhandler_tty_slave ()
  : fhandler_tty_common (FH_TTYS, 0)
d454 2
d461 1
a461 1
fhandler_tty_slave::open (path_conv *, int flags, mode_t)
d680 1
a680 1
int __stdcall
d1002 2
a1003 2
fhandler_pty_master::fhandler_pty_master (DWORD devtype, int unit)
  : fhandler_tty_common (devtype, unit)
d1005 5
d1013 1
a1013 1
fhandler_pty_master::open (path_conv *, int flags, mode_t)
d1098 1
a1098 1
int __stdcall
d1195 4
a1198 1
    fork_fixup (parent, output_mutex, "output_mutex");
d1200 4
a1203 1
    fork_fixup (parent, input_mutex, "input_mutex");
@


1.49.2.5
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

        * fhandler_tty.cc (fhandler_tty_slave::open): More debugging.
        (fhandler_tty_slave::read): Fix printf type for the handle.
        * tty.cc (tty::common_init): Add a FIXME for security.
@
text
@a524 1
      termios_printf ("tty own handle %p",tty_owner);
d541 2
d552 2
a556 5
  termios_printf ("duplicated from_master %p->%p from tty_owner",
      get_ttyp ()->from_master, from_master_local);
  termios_printf ("duplicated to_master %p->%p from tty_owner",
      get_ttyp ()->to_master, to_master_local);

d686 1
a686 1
  termios_printf ("read(%x, %d) handle %p", ptr, len, get_handle ());
@


1.49.2.6
log
@Merged changes from HEAD
@
text
@d1027 2
a1030 2
  if (!ForceCloseHandle (output_mutex))
    termios_printf ("CloseHandle (output_mutex<%p>), %E", output_mutex);
@


1.49.2.7
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
d13 1
d24 1
d459 1
a459 1
  set_flags (flags & ~O_TEXT, O_BINARY);
d524 1
a524 1
				      get_ttyp ()->master_pid);
d527 6
a532 6
	{
	  termios_printf ("can't open tty (%d) handle process %d",
			  ttynum, get_ttyp ()->master_pid);
	  __seterrno ();
	  return 0;
	}
d534 2
a535 2
      if (!DuplicateHandle (tty_owner, get_ttyp ()->from_master,
			    hMainProc, &from_master_local, 0, TRUE,
d537 5
a541 5
	{
	  termios_printf ("can't duplicate input, %E");
	  __seterrno ();
	  return 0;
	}
d543 1
a543 1
      if (!DuplicateHandle (tty_owner, get_ttyp ()->to_master,
d546 5
a550 5
	{
	  termios_printf ("can't duplicate output, %E");
	  __seterrno ();
	  return 0;
	}
d572 1
a572 1
					  LPHANDLE to_master_ptr)
d577 1
a577 1
  client_request_attach_tty *request =
d692 1
a692 3
      vmin = get_ttyp ()->ti.c_cc[VMIN];
      if (vmin > INP_BUFFER_SIZE)
	vmin = INP_BUFFER_SIZE;
d1009 1
a1009 1
  set_flags (flags & ~O_TEXT, O_BINARY);
@


1.49.2.8
log
@	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.
@
text
@d575 5
a579 3
  client_request_attach_tty req ((DWORD) get_ttyp ()->master_pid,
				 (HANDLE) get_ttyp ()->from_master,
				 (HANDLE) get_ttyp ()->to_master);
d581 2
a582 1
  if (req.make_request () != 0 || req.error_code () != 0)
d585 13
a597 2
  *from_master_ptr = req.from_master ();
  *to_master_ptr = req.to_master ();
@


1.49.2.9
log
@	* include/cygwin/cygserver.h: Add forward declarations of class
	transport_layer_base and class process_cache to reduce
	dependencies between header files.
	* include/cygwin/cygserver_process.h: Add include of
	"threaded_queue.h".
	* cygserver.cc: Remove unnecessary cygserver header files.
	* cygserver_client.cc: Ditto.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_shm.h: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* dcrt0.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
@
text
@d27 1
@


1.49.2.10
log
@Merged changes from HEAD
@
text
@d456 1
a456 1
  set_flags ((flags & ~O_TEXT) | O_BINARY);
d994 1
a994 1
  set_flags ((flags & ~O_TEXT) | O_BINARY);
@


1.49.2.11
log
@	* dcrt0.cc: Only check for cygserver if and when required.
	(dll_crt0_1): Remove call to `cygserver_init ()'.
	* fhandler_tty.cc (fhandler_tty_slave::open): Change the cygserver
	logic to allow for the fact that `cygserver_init ()' may not yet
	have been called.
	(fhandler_tty_slave::cygserver_attach_tty): Tweak the cygserver
	request logic to conform to the practice elsewhere in the code.
	* tty.cc (tty::common_init): Add an explicit call to
	`cygserver_init ()' if it hasn't already been called.
	* include/cygwin/cygserver.h (CYGSERVER_UNAVAIL): Rename from
	`CYGSERVER_DEAD'.
	(client_request_get_version::check_version): Make available in
	cygserver as well the DLL.
	(check_cygserver_available): Ditto.  Remove `check_version_too'
	argument.
	(cygserver_init): Ditto.  And likewise.
	* cygserver_client.cc (client_request_get_version::check_version):
	Make available in cygserver as well the DLL.
	(client_request::make_request): This may now be called without
	`cygserver_init ()' having been called first.  Detect this and
	call it as required.  Add tracing.
	(check_cygserver_available): Make available in cygserver as well
	the DLL.  Remove `check_version_too' argument and always check the
	version information.  And since this is called from within
	`cygserver_init ()', force `cygserver_running' before calling
	`client_request::make_request ()'.
	(cygserver_init): Make available in cygserver as well the DLL.
	Remove `check_version_too' argument.
@
text
@d515 2
a516 2
      cygserver_running == CYGSERVER_UNAVAIL ||
      !cygserver_attach_tty (&from_master_local, &to_master_local))
d578 1
a578 1
  if (req.make_request () == -1 || req.error_code ())
@


1.49.2.12
log
@Merged changes from HEAD
@
text
@d557 1
a557 1
  ProtectHandle1INH (from_master_local, from_pty);
d559 1
a559 1
  ProtectHandle1INH (to_master_local, to_pty);
@


1.49.2.13
log
@Merged changes from HEAD
@
text
@a27 1
#include "cygthread.h"
d45 1
d64 32
a95 10
  cygthread *h;
  h = new cygthread (process_input, NULL, "ttyin");
  SetThreadPriority (*h, THREAD_PRIORITY_HIGHEST);

  h = new cygthread (process_ioctl, NULL, "ttyioctl");
  SetThreadPriority (*h, THREAD_PRIORITY_HIGHEST);

  h = new cygthread (process_output, NULL, "ttyout");
  hThread = *h;
  SetThreadPriority (h, THREAD_PRIORITY_HIGHEST);
d127 1
a127 1
      ostack[osi].tname = cygthread::name ();
@


1.49.2.14
log
@Merged changes from HEAD
@
text
@d39 1
a39 1
  : fhandler_pty_master (FH_TTYM, unit), console (NULL), output_thread (NULL)
d71 3
a73 2
  output_thread = new cygthread (process_output, NULL, "ttyout");
  SetThreadPriority (*output_thread, THREAD_PRIORITY_HIGHEST);
d379 1
a379 1
      if (n <= 0)
d381 7
a387 5
	  if (n < 0)
	    termios_printf ("ReadFile %E");
	  cygthread *t = tty_master->output_thread;
	  tty_master->output_thread = NULL;
	  t->exit_thread ();
a1173 1
  output_thread = NULL;		// It's unreachable now
d1181 1
a1181 1
  output_thread = NULL;		// It's unreachable now
@


1.49.2.15
log
@Merged changes from HEAD
@
text
@d71 1
a71 1
  output_thread = new cygthread (process_output, cygself, "ttyout");
d371 1
a371 1
process_output (void *self)
d382 1
a382 1
	  cygthread *t = (cygthread *) self;
@


1.49.2.16
log
@Merged changes from HEAD
@
text
@a413 1
  set_r_no_interrupt (1);
a418 1
  set_r_no_interrupt (1);
d654 6
a659 5
      if (vmin < 0)
	vmin = 0;
      if (vtime < 0)
	vtime = 0;
      time_to_wait = vtime == 0 ? INFINITE : 100 * vtime;
d898 2
a899 2
  if (myself->pgid && get_ttyp ()->getpgid () != myself->pgid
      && myself->ctty == ttynum && (get_ttyp ()->ti.c_lflag & TOSTOP))
@


1.49.2.17
log
@Merged changes from HEAD
@
text
@d534 1
d536 1
@


1.49.2.18
log
@Merged changes from HEAD
@
text
@d696 1
a696 1
      if (!PeekNamedPipe (get_handle (), peek_buf, sizeof (peek_buf), &bytes_in_pipe, NULL, NULL))
@


1.48
log
@* fhandler.cc (fhandler_base::set_inheritance): Just use DUPLICATE_CLOSE_SOURCE
to change inheritance.  Eliminate all other logic dealing with closed handles.
* fhandler.h (fhandler_base::set_inheritance): Reflect above change.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Ditto.
@
text
@d226 1
a226 1
BOOL
@


1.47
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d1122 1
a1122 1
  set_inheritance (get_io_handle (), val, "from_pty");
d1133 2
a1134 2
  set_inheritance (output_mutex, val, "output_mutex");
  set_inheritance (input_mutex, val, "input_mutex");
d1136 1
a1136 1
  set_inheritance (output_handle, val, "to_pty");
@


1.46
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d714 5
a718 5
          /* MSDN states that 5th prameter can be used to determine total
             number of bytes in pipe, but for some reason this number doesn't
             change after successful read. So we have to peek into the pipe
             again to see if input is still available */
          if (!PeekNamedPipe (get_handle (), peek_buf, 1, &bytes_in_pipe, NULL, NULL))
@


1.45
log
@* tty.cc (tty::create_inuse): Eliminate unneeded argument.
* tty.h: Reflect above change.
* fhandler_tty.cc: Reflect argument reduction in tty::create_inuse, throughout.
Always make inuse inheritable.
@
text
@d112 1
a112 1
static int osi = 0;
@


1.44
log
@* debug.cc (mark_closed): Rename from debug_mark_closed and make static.
(setclexec_pid): New function for marking saved handle as close-on-exec.
(delete_handle): New function.
(debug_fixup_after_fork): New function.
* debug.h: Declare new functions, remove obsolete ones.
* fork.cc (debug_fixup_after_fork): Call to cleanup close-on-exec handles.
* fhandler.cc (fhandler_disk_file::close): Minor reorg.
(fhandler_base::set_inheritance): Set flag appropriately for debugging when
close-on-exec so forked process can delete closed handles.
* tty.h (open_output_mutex): Eliminate unneeded argument.
(open_input_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): reflect open_*_mutex argument
changes.
* fhandler.h (fhandler_socket): Make saw_shutdown_* functions type bool.
* tty.cc (tty::get_event): Eliminate unneeded argument.
(tty::common_init): Reflect change to get_event.  Events should always be
inherited.
@
text
@d65 1
a65 1
  inuse = get_ttyp ()->create_inuse (TTY_MASTER_ALIVE, FALSE);
d512 1
a512 1
    inuse = get_ttyp ()->create_inuse (TTY_SLAVE_ALIVE, TRUE);
d975 1
a975 1
  inuse = get_ttyp ()->create_inuse (TTY_MASTER_ALIVE, FALSE);
@


1.43
log
@        * fhandler.cc (fhandler_base::is_nonblocking): New method.
        (fhandler_base::set_nonblocking): Ditto.
        * fhandler.h (fhandler_base): Declare new methods `is_nonblocking' and
        `set_nonblocking'.
        * fhandler_socket.cc (fhandler_socket::ioctl): Use `set_nonblocking'.
        * fhandler_tty.cc (fhandler_pty_master::process_slave_output):
        Use `is_nonblocking'.
        (fhandler_tty_slave::read): Ditto.
        (fhandler_tty_slave::ioctl): Use `set_nonblocking'.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (cygwin_sendto): Fallback to winsock 1 functionality
        in case of nonblocking IO.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * syscalls.cc (_read): Use `is_nonblocking'.
@
text
@d482 1
a482 1
  if (!(output_mutex = get_ttyp ()->open_output_mutex (TRUE)))
d488 1
a488 1
  if (!(input_mutex = get_ttyp ()->open_input_mutex (TRUE)))
@


1.42
log
@        * fhandler.cc (fhandler_base::fcntl): Use new O_NONBLOCK_MASK define.
        * fhandler.h: Move definitions of O_NOSYMLINK, O_DIROPEN and
        OLD_O_NDELAY from winsup.h to here. Add O_NONBLOCK_MASK define.
        * fhandler_socket.cc (fhandler_socket::close): Add hack to allow
        a graceful shutdown even if shutdown() hasn't been called by the
        application. Add debug output.
        (fhandler_socket::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_socket::fcntl): Use new O_NONBLOCK_MASK define. Actually
        set `request' before using it.
        * fhandler_tty.cc: Use new O_NONBLOCK_MASK define throughout.
        (fhandler_tty_slave::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (wsock_event::prepare): Compare WSACreateEvent return code
        with `WSA_INVALID_EVENT' according to MSDN.
        * syscalls.cc (_read): Use new O_NONBLOCK_MASK define.
@
text
@a27 2
#include "cygwin/version.h"
#include "perprocess.h"
d298 1
a298 1
	      if (n == 0 && (get_flags () & O_NONBLOCK_MASK) != 0)
d749 1
a749 2
      if (get_ttyp ()->ti.c_lflag & ICANON ||
	  get_flags () & O_NONBLOCK_MASK)
d915 1
a915 5
      {
	int current = get_flags () & O_NONBLOCK_MASK;
	int new_flags = *(int *) arg ? (!current ? O_NONBLOCK : current) : 0;
	set_flags ((get_flags () & ~O_NONBLOCK_MASK) | new_flags);
      }
d1095 1
a1095 5
	{
	  int current = get_flags () & O_NONBLOCK_MASK;
	  int new_flags = *(int *) arg ? (!current ? O_NONBLOCK : current) : 0;
	  set_flags ((get_flags () & ~O_NONBLOCK_MASK) | new_flags);
	}
@


1.41
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d28 2
d300 1
a300 1
	      if (n == 0 && (get_flags () & (O_NONBLOCK | O_NDELAY)) != 0)
d752 1
a752 1
	  get_flags () & (O_NONBLOCK | O_NDELAY))
d918 5
a922 4
      if (* (int *) arg)
	set_flags (get_flags () | O_NONBLOCK);
      else
	set_flags (get_flags () & ~O_NONBLOCK);
d1102 5
a1106 4
	if (* (int *) arg)
	  set_flags (get_flags () | O_NONBLOCK);
	else
	  set_flags (get_flags () & ~O_NONBLOCK);
@


1.40
log
@* cygheap.cc (cygheap_fixup_in_child): Attempt Win95 workaround.
* dtable.cc (dtable::dup_worker): Add debugging output.
(dtable::vfork_child_dup): Correctly set close_on_exec.
* fhandler.cc (fhandler_base::fork_fixup): Don't mess with handle if there is
no need to get it from the parent.
* fhandler_tty.cc (fhandler_tty_common::close): Add debugging output.
@
text
@d20 1
@


1.39
log
@forced commit
@
text
@d1017 1
a1017 1
  termios_printf ("tty%d closed", ttynum);
@


1.38
log
@* fhandler_tty.cc (fhandler_tty_slave::init): Revert 2001-06-16 change.
* fork.cc (fork_copy): Print more debugging info.
(fork_parent): Change order of arguments to accomdate buggy gcc.
(fork): Ditto.
* syscalls.cc (_unlink): Reorganize to try harder to delete file with
DeleteFile and to recover more gracefully if FILE_FLAG_DELETE_ON_CLOSE doesn't
work properly.
@
text
@@


1.37
log
@* exceptions.cc (sig_handle_tty_stop): Reset PID_STOPPED if not actually
stopping.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Don't set
controlling terminal if just inheriting a handle.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
* signal.cc (kill_worker): Set appropriate errno if proc_exists determines that
process does not really exist.
@
text
@d577 1
a577 1
  open (0, mode | O_NOCTTY);
@


1.36
log
@* fhandler_tty.cc (fhandler_tty_common::dup): Preserve O_NOCTTY when duping a
filehandle.
@
text
@d577 1
a577 1
  open (0, mode);
@


1.35
log
@* cygheap.cc (_cfree): Add regparm attribute.
(_crealloc): Ditto.
* dcrt0.cc (dll_crt0_1): Default to always checking for executable for now.
* dtable.cc (dtable::not_open): Move method.
* dtable.h (dtable): Here.
* exceptions.cc (ctrl_c_handler): Don't expect process group leader to handle a
signal if it doesn't exist.
* fhandler.h (fhandler_base): Make openflags protected.
* localtime.c (tzsetwall): Check for __CYGWIN__ as well as __WIN32__.
* path.cc (path_conv::check): Add some comments.  Change strcat to assignment.
* lib/_cygwin_S_IEXEC.cc (_cygwin_bob__): Eliminate.
* fhandler_tty.cc (fhandler_console::dup): Set controlling terminal if
necessary.
* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
@
text
@d786 1
a786 1
  tc->set_ctty (ttynum, openflags & ~O_NOCTTY);
@


1.34
log
@Throughout, change 'tty_attached' to 'real_tty_attached', for clarity.
Throughout, change 'OutputStopped' to 'output_stopped', for consistency.
* dtable.cc (stdio_init): Set controlling tty if not set by stdio opens.
* exceptions.cc (ctrl_c_handler): Avoid special pgid checking if no tty is
associated with the process.
(Suggested by Tim Baker <dbaker@@direct.ca>)
* external.cc (fillout_pinfo): Return actual tty number for ctty.
* fhandler_console.cc (get_tty_stuff): Set ctty when shared memory is
allocated.  Accept flags input from open().
(set_console_ctty): New function.
(fhandler_console::open): Pass flags to get_tty_stuff and rely on this function
to set the ctty, if appropriate.
* fhandler_termios.cc (fhandler_termios::set_ctty): Move to tty_min class.
* fhandler_tty.cc (fhandler_tty_slave::open): Use tc field to access
set_ctty().
* tty.h (TTY_CONSOLE): Move to include/sys/cygwin.h.
(tty_min): Add set_ctty class here.
* include/sys/cygwin.h (TTY_CONSOLE): New home here.
* path.cc (symlink_info): Make contents an actual buffer.  Pass more flags to
case_check.
(path_conv::check): Reorganize to do parsing based on posix path rather than
native path.
(symlink_info::check): Expect posix path as input.  Translate to native path
here.  Accept path_conv flags.  Stop parsing if not a symlink regardless of
whether previous path was a symlink.
@
text
@d786 1
@


1.33
log
@* tty.cc (tty::make_pipes): Set to_slave pipe mode to nonblocking.
* fhandler_tty.cc (fhandler_pty_master::accept_input): If pipe buffer
is full, give slave a chance to read data.
@
text
@d257 1
a257 1
	 OutputStopped at the time that we read the character, so we
d467 1
a467 1
  set_ctty (ttynum, flags);
@


1.32
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@d170 1
a170 1
  DWORD written;
d173 1
d177 3
a179 1
  n = get_ttyp ()->read_retval = eat_readahead (-1);
d183 21
a203 2
      termios_printf ("about to write %d chars to slave", n);
      rc = WriteFile (get_output_handle (), rabuf, n, &written, NULL);
@


1.31
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d423 4
a426 4
  unix_path_name_ = (char *) crealloc (unix_path_name_, strlen (win32_path_name_) + 1);
  strcpy (unix_path_name_, win32_path_name_);
  unix_path_name_[0] = unix_path_name_[4] = '/';
  debug_printf ("unix '%s', win32 '%s'", unix_path_name_, win32_path_name_);
d437 2
d536 1
d638 1
a638 1
	time_to_wait = (vtime == 0 ? INFINITE : 10 * vtime);
d957 1
@


1.30
log
@* tty.h (tty::create_inuse): Add new parameter to allow non-
inheritable 'inuse' events.
* tty.cc (tty::create_inuse): Use new parameter.
* fhandler_tty.cc (fhandler_tty_master::init): Ditto.
* fhandler_tty.cc (fhandler_pty_master::open): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Create master_alive
event.
* tty.cc (tty_list::terminate): Close master_alive event.
* fhandler_tty.cc (fhandler_tty_common::close): Send EOF to slaves
when master side is closed.
@
text
@d1176 1
a1176 1
  console = (fhandler_console *) fdtab.build_fhandler (-1, FH_CONSOLE, "/dev/ttym");
@


1.29
log
@* fhandler.h (fhandler_tty_slave): Declare new methods.
* select.cc (fhandler_tty_slave::select_read): New method.
* select.cc (fhandler_tty_slave::ready_for_read): Ditto.
* select.cc (verify_tty_slave): New function.
* fhandler_termios.cc (fhandler_termios::line_edit): Empty input
buffer on signal.
* fhandler_tty.cc (fhandler_tty_slave::read): Check for input data
after reading from pipe. Reset event if input pipe is empty.
* tty.h (class tty): Allow creating events with manual reset.
* tty.cc (tty::get_event): Use manual_reset flag.
* tty.cc (tty::common_init): Create input_available_event with
manual reset.
@
text
@d64 2
d487 1
a487 1
    inuse = get_ttyp ()->create_inuse (TTY_SLAVE_ALIVE);
d952 1
a952 1
  inuse = get_ttyp ()->create_inuse (TTY_MASTER_ALIVE);
d974 8
@


1.28
log
@fix spelling error.
@
text
@d617 1
d671 1
a671 1
      if (!PeekNamedPipe (get_handle (), NULL, 0, NULL, &bytes_in_pipe, NULL))
d686 10
d705 2
a706 2
      if (readlen != bytes_in_pipe)
	SetEvent (input_available_event);
@


1.27
log
@* fhandler.h (fhandler_termios::fixup_after_exec): New function.
* fhandler.cc (fhandler_termios::fixup_after_fork): New function.
Fixup output handle.
* fhandler_tty.cc (fhandler_tty_common::fixup_after_fork): Output
handle is now fixed up in fhandler_termios::fixup_after_fork().
@
text
@d645 1
a645 1
	  /* if we've recieved signal after successfully reading some data,
@


1.26
log
@* autoload.cc (noload): Use proper method for multiline strings or newer gcc's
complain.
* exceptions.cc (unused_sig_wrapper): Ditto.
* fhandler.h (fhandler_base): Make get_io_handle and friends return self.
* fhandler_tty.cc (fhandler_pty_common::close_on_exec): Accomodate DEBUGGING
flag to avoid spurious warnings when inheritance is set.
@
text
@d1100 1
a1100 1
  this->fhandler_base::fixup_after_fork (parent);
a1118 1
  fork_fixup (parent, output_handle, "output_handle");
@


1.25
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000 Cygnus Solutions.
d147 1
a147 1
      termios_printf("  for %s:%d (%s)", ostack[osi].fn, ostack[osi].ln, ostack[osi].tname);
d176 1
a176 1
  if ( n != 0 )
d414 1
a414 1
fhandler_tty_slave::fhandler_tty_slave(int num, const char *name) :
d421 1
a421 1
  unix_path_name_ = (char *) crealloc (unix_path_name_, strlen(win32_path_name_) + 1);
d428 1
a428 1
fhandler_tty_slave::fhandler_tty_slave(const char *name) :
d455 1
a455 1
  if (!(output_mutex = get_ttyp()->open_output_mutex (TRUE)))
d461 1
a461 1
  if (!(input_mutex = get_ttyp()->open_input_mutex (TRUE)))
d503 1
a503 1
      termios_printf ("can't open tty(%d) handle process %d",
d532 1
a532 1
  termios_printf("tty%d opened", ttynum);
d558 1
a558 1
  termios_printf("tty%d, write(%x, %d)", ttynum, ptr, len);
d600 1
a600 1
	  termios_printf("waited %d ms for output_done_event, WFSO %d", x, rc);
d630 1
a630 1
        time_to_wait = INFINITE;
d632 1
a632 1
        time_to_wait = (vtime == 0 ? INFINITE : 10 * vtime);
d644 8
a651 8
        {
          /* if we've recieved signal after successfully reading some data,
             just return all data successfully read */
          if (totalread > 0)
            break;
          set_sig_errno (EINTR);
          return -1;
        }
d653 4
a656 4
        {
          termios_printf ("wait for input event failed, %E");
          break;
        }
d658 1
a658 1
        break;
d661 4
a664 4
        {
          termios_printf ("wait for input mutex failed, %E");
          break;
        }
d666 4
a669 4
        {
          termios_printf ("failed to acquire input mutex after input event arrived");
          break;
        }
d673 2
a674 2
          _raise (SIGHUP);
          bytes_in_pipe = 0;
d677 5
a681 5
      if ( readlen )
        {
          termios_printf ("reading %d bytes (vtime %d)", readlen, vtime);
          if (ReadFile (get_handle (), buf, readlen, &n, NULL) == FALSE)
 	    {
d685 8
a692 8
          if (n)
            {
              len -= n;
              totalread += n;
              memcpy (ptr, buf, n);
              ptr = (char *) ptr + n;
            }
        }
d695 1
a695 1
        SetEvent (input_available_event);
d710 2
a711 2
      if ( get_ttyp ()->ti.c_lflag & ICANON ||
           get_flags () & (O_NONBLOCK | O_NDELAY))
d714 1
a714 1
        break;
d716 1
a716 1
      /* vmin == 0 && vtime == 0: 
d721 1
a721 1
       *   so return immediately 
d731 2
a732 1
      if (vmin == 0) break;
d865 2
a866 2
      termios_printf("bg ioctl pgid %d, tpgid %d, ctty %d",
		     myself->pgid, get_ttyp ()->getpgid (), myself->ctty);
d1074 1
d1076 7
d1094 1
a1094 1
  set_inheritance (output_handle, val);
@


1.24
log
@* fhandler.h (class fhandler_tty_common): New mutex and event to
syncronize input on master tty with slave tty.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Use them to
syncronize with slave.
* fhandler_tty.cc (fhandler_tty_slave::read): Use input mutex and
event to syncronize with master. Do not limit amount of data read
from master to vmin value. Interrupt on signal and return already
read data, if any.
* fhandler_tty.cc (fhandler_tty_slave::open): Handle input mutex and
event.
* fhandler_tty.cc (fhandler_tty_common::close): Ditto.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::fixup_after_fork): Ditto.
* fhandler_tty.cc (fhandler_tty_common::dup): Ditto.
* tty.h (tty::open_input_mutex): New function.
* tty.cc (tty::common_init): Create input mutex and event.
@
text
@d197 1
a197 1
      tty_master->line_edit (rawbuf, nraw);
d1003 1
a1003 1
  line_edit ((char *) ptr, len);
@


1.23
log
@* debug.cc (add_handle): Issue warning on attempts to add the same handle more
than once.
* fhandler_tty.cc (fhandler_tty_slave::open): Protect some handles.
(fhandler_tty_common::close): Use proper name when closing handles.
(fhandler_pty_master::close): Don't close to_slave or from_slave since they've
already been closed earlier in the function.
* sigproc.cc (proc_subproc): Don't protect vchild->hProcess.  Expect that the
caller will do this, instead.
* tty.cc (tty_list::terminate): Use proper name when closing handles.
(tty::make_pipes): Protect some handles.
@
text
@d170 3
a172 2
  const char dummy[1] = {'X'};
  const char *buf;
d176 1
a176 3
  if (n != 0)
    buf = rabuf;
  else
d178 2
a179 3
      n = 1;
      buf = dummy;
      termios_printf ("sending EOF to slave");
d181 4
a184 3
  termios_printf ("about to write %d chars to slave", n);
  if (!WriteFile (get_output_handle (), buf, n, &written, NULL))
      return -1;
d461 13
d614 2
d617 3
d621 1
a621 1
  termios_printf("read(%x, %d) handle %d", ptr, len, get_handle ());
d625 1
a625 1
      vmin = get_ttyp ()->ti.c_cc[VMIN];
d627 6
d634 5
d642 51
a692 3
      size_t readlen = min ((unsigned) vmin, min (len, sizeof (buf)));
      termios_printf ("reading %d bytes (vtime %d)",
		      min ((unsigned) vmin, min (len, sizeof (buf))), vtime);
d694 2
a695 1
      n = get_readahead_into_buffer (buf, readlen);
d697 1
a697 5
      if (!n && ReadFile (get_handle (), buf, readlen, &n, NULL) == FALSE)
	{
	  termios_printf ("read failed, %E");
	  _raise (SIGHUP);
	}
d710 2
a711 7
      len -= n;
      totalread += n;
      memcpy (ptr, buf, n);
      ptr = (char *) ptr + n;
      if (get_ttyp ()->ti.c_lflag & ICANON)
	break;
      else if (totalread >= vmin)
d713 2
d716 14
a729 9
      if (!PeekNamedPipe (get_handle (), NULL, 0, NULL, &n, NULL))
	{
	  termios_printf("PeekNamedPipe failed, %E");
	  break;
	}
      if (n == 0)
	{
	  if (get_flags () & (O_NONBLOCK | O_NDELAY))
	    break;
d731 1
a731 23
	  /* We can't enter the blocking Readfile as signals will be lost.
	   * So, poll the pipe for data.
	   * FIXME: try to avoid polling...
	   * FIXME: Current EINTR scheme does not take vmin/vtime into account.
	   */
	  if (!(get_ttyp ()->ti.c_lflag & ICANON))
	    {
	      termios_printf("vmin %d vtime %d", vmin, vtime);
	      if (vmin == 0 && vtime == 0)
		return 0;		// min = 0, time = 0
	      if (vtime == 0)
		continue;		// min > 0, time = 0
	      while (vtime--)
		{
		  PeekNamedPipe (get_handle (), NULL, 0, NULL, &n, NULL);
		  if (n)
		    break;
		  Sleep(10);
		}
	      if (vtime == 0)
		return totalread;
	    }
	}
d777 7
d788 8
a795 1
      errind = 4;
d802 1
a802 1
      errind = 5;
d811 1
a811 1
      errind = 6;
d822 1
a822 1
      errind = 7;
d958 4
d1083 2
d1103 7
@


1.22
log
@* fhandler_tty.cc (fhandler_tty_slave::write): Correct typo which caused
resetting of windows error to ERROR_IO_DEVICE to be ignored.
@
text
@d506 1
d517 1
d891 1
a891 1
  if (!CloseHandle (get_handle ()))
d893 1
a893 1
  if (!CloseHandle (get_output_handle ()))
d913 1
d915 1
a915 1
	CloseHandle (get_ttyp ()->to_slave);
d917 2
a918 1
	CloseHandle (get_ttyp ()->from_slave);
d1044 2
@


1.21
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d574 1
a574 1
	      __seterrno ();
@


1.20
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@a25 1
#include "tty.h"
@


1.19
log
@* exceptions.cc (signal_exit): Reset all mutos owned by the main thread.
* fhandler.h: Define *_output_mutex macros for serializing tty output.
(fhandler_termios): Remove restart_output_event.  Define dummy output mutex
methods.
(fhandler_pty_master): Remove unneeded fixup_after_fork method.
* fhandler_termios.cc (fhandler_termios::line_edit): Acquire output_mutex when
CTRL-S is hit.  Release it on CTRL-Q.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Remove
inappropriate OutputStopped test here.  Just use the output mutex.
(fhandler_pty_master::fhandler_pty_master): Remove obsolete reference to
restart_output_event.
(fhandler_tty_common::close): Ditto.
(fhandler_pty_master::set_close_on_exec): Ditto.
(fhandler_pty_master::fixup_after_fork): Delete.
* tty.cc (tty::common_init): Ditto.
* sync.cc (muto::reset): New method.
* sync.h: Declare above method.
@
text
@d26 2
d290 3
d295 1
a295 6
	{
	  get_ttyp ()->write_retval = n;
	  if (output_done_event != NULL)
	    SetEvent (output_done_event);
	  continue;
	}
d392 1
a392 2
      tty_master->get_ttyp ()->write_retval = n == -1 ? -get_errno () : n;
      SetEvent (tty_master->output_done_event);
d556 10
a588 7

      if (get_ttyp ()->write_retval < 0)
	{
	  set_errno (-get_ttyp ()->write_retval);
	  towrite = (DWORD) -1;
	  break;
	}
d936 1
a936 6
  int x = process_slave_output ((char *) ptr, len, pktmode);

  if (output_done_event != NULL)
    SetEvent (output_done_event);

  return x;
@


1.18
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@a151 6
#define acquire_output_mutex(ms) \
  __acquire_output_mutex (__PRETTY_FUNCTION__, __LINE__, ms);

#define release_output_mutex() \
  __release_output_mutex (__PRETTY_FUNCTION__, __LINE__);

a296 7
      if (get_ttyp ()->OutputStopped)
	{
	  termios_printf ("waiting for restart_output_event");
	  WaitForSingleObject (restart_output_event, INFINITE);
	  termios_printf ("done waiting for restart_output_event");
	}

a855 1
  restart_output_event = NULL;
a883 2
  if (restart_output_event && !CloseHandle (restart_output_event))
    termios_printf ("CloseHandle (restart_output_event), %E");
a1037 1
  set_inheritance (restart_output_event, val);
a1044 8
}

void
fhandler_pty_master::fixup_after_fork (HANDLE child)
{
  this->fhandler_tty_common::fixup_after_fork (child);
  if (restart_output_event)
    fork_fixup (child, restart_output_event, "restart_output_event");
@


1.17
log
@* signal.cc (_raise): New function.
* exceptions.cc (unused_sig_wrapper): Remove _raise.
* sigproc.h (class sigframe): Default frames to skip to zero or suffer from
exuberant optimization.
* fhandler_tty.cc (fhandler_tty::write): Set appropriate errno when WriteFile
to pipe fails.
@
text
@d25 1
d437 1
a437 1
  unix_path_name_ = (char *) realloc (unix_path_name_, strlen(win32_path_name_) + 1);
d1079 2
a1080 3
int
fhandler_tty_master::de_linearize (const char *buf, const char *unix_name,
				   const char *win32_name)
a1081 1
  int res = fhandler_base::de_linearize (buf, unix_name, win32_name);
d1084 1
a1084 1
  return res;
@


1.16
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d571 1
d573 8
a581 1
	  _raise (SIGHUP);		/* FIXME: Should this be SIGTTOU? */
@


1.15
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d19 2
d22 2
a24 1
#include "cygerrno.h"
@


1.14
log
@Correct order in include files.
@
text
@d21 1
@


1.13
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d19 1
a20 1
#include "dtable.h"
@


1.12
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d19 2
@


1.11
log
@* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set length field
correctly when "need_nl".
@
text
@d1077 1
a1077 1
  console = (fhandler_console *) dtable.build_fhandler (-1, FH_CONSOLE, "/dev/ttym");
@


1.10
log
@* strace.cc (strace::prntf): Make second argument the function name, rather
than use special format options.
(strace::vprntf): Ditto.
(getfunc): New function.
* include/sys/strace.h: Reflect above changes.
* smallprint.c (__small_vsprintf): Eliminate '%F' formatting.
* pinfo.cc (set_myself): Modify for new strace::prntf parameter.
* errno.cc (seterrno_from_win_error): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__release_output_mutex): Ditto.
@
text
@d236 1
@


1.9
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d109 1
a109 1
    strace.prntf (_STRACE_TERMIOS, "%F (%d): tty output_mutex: waiting %d ms", fn, ln, ms);
d115 1
a115 1
	strace.prntf (_STRACE_TERMIOS, "%F (%d): tty output_mutex: acquired", fn, ln, res);
d134 1
a134 1
	strace.prntf (_STRACE_TERMIOS, "%F (%d): tty output_mutex released", fn, ln);
@


1.8
log
@* Makefile.in (DLL_OFILES): Sort.
* fhandler_tty.cc (fhandler_tty_slave::send_ioctl_request): Eliminate.
(fhandler_tty_slave::ioctl): Rewrite to avoid races.
@
text
@d11 1
a16 1
#include "winsup.h"
@


1.7
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@a781 12
void
fhandler_tty_slave::send_ioctl_request (void)
{
  if (ioctl_request_event == NULL || ioctl_done_event == NULL) // slave of pty
    return;

  acquire_output_mutex (INFINITE);
  SetEvent (ioctl_request_event);
  WaitForSingleObject (ioctl_done_event, INFINITE);
  release_output_mutex ();
}

d795 19
d820 2
a821 1
      send_ioctl_request ();
d823 2
d830 4
a833 1
      send_ioctl_request ();
a834 9
    case FIONBIO:
      if (* (int *) arg)
	set_flags (get_flags () | O_NONBLOCK);
      else
	set_flags (get_flags () & ~O_NONBLOCK);
      break;
    default:
      set_errno (EINVAL);
      return -1;
d836 4
@


1.6
log
@* fhandler.cc (fhandler_base::get_readahead_into_buffer): New function.
* fhandler.h: Declare new function.  Add extra argument to
process_slave_output.
* fhandler_console.cc (fhandler_console::read): Move read ahead code to new
function.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Move common code
here.
(fhandler_tty_slave::read): Understand readahead.
(fhandler_pty_master::read): Move code to process_slave_output.
* select.cc (peek_pipe): Avoid performing certain checks when non-read and on
inappropriate fh types.
@
text
@a439 1
  debug_printf ("here");
a683 1
  termios_printf ("here");
a867 1
termios_printf ("here %p", this);
@


1.5
log
@* fhandler_console.cc (fhandler_console::read): Don't even think about breaking
on interrupt if executing in a "cygwin" thread.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Streamline,
simplify code.
* sigproc.cc (sig_send): Remove debugging statement.
@
text
@d217 1
a217 1
fhandler_pty_master::process_slave_output (char *buf, size_t len)
d220 1
a220 1
  char outbuf[OUT_BUFFER_SIZE];
d228 12
a241 12
      if (neednl_)
	{
	  /* We need to return a left over \n character, resulting from
	     \r\n conversion.  Note that we already checked for FLUSHO and
	     OutputStopped at the time that we read the character, so we
	     don't check again here.  */
	  buf[0] = '\n';
	  neednl_ = 0;
	  rc = 1;
	  break;
	}

d257 2
a258 4
      /* Doing a busy wait like this is quite inefficient, but nothing
	 else seems to work completely.  Windows should provide some sort
	 of overlapped I/O for pipes, or something, but it doesn't.  */
      while (1)
d260 22
a281 2
	  DWORD avail;
	  if (!PeekNamedPipe (handle, NULL, 0, NULL, &avail, NULL))
a282 5
	  if (avail > 0)
	    break;
	  if (hit_eof ())
	    goto out;
	  Sleep (10);
d285 1
a285 4
      if (ReadFile (handle, outbuf, rlen, &n, NULL) == FALSE)
	goto err;

      termios_printf ("rlen %u", n);
d302 5
d309 2
a310 2
	  memcpy (buf, outbuf, n);
	  rc = n;
d314 1
a314 1
	  char *iptr = outbuf, *optr = buf;
a349 1
		  neednl_ = 1;
d352 1
a357 1
	  rc = optr - buf;
d359 1
a381 1
  int n;
d383 1
a383 1
  while (1)
d385 1
a385 1
      n = tty_master->process_slave_output (buf, OUT_BUFFER_SIZE);
d609 1
d612 4
a615 2
      if (ReadFile (get_handle (), (unsigned *) buf,
		 min ((unsigned) vmin, min (len, sizeof (buf))), &n, NULL) == FALSE)
d620 1
d848 1
a848 1
  pktmode = neednl_ = 0;
d929 1
a929 2
  DWORD n;
  char *cptr = (char *) ptr;
a930 26
  if (!PeekNamedPipe (get_handle (), NULL, 0, NULL, &n, NULL))
    {
      if (GetLastError () == ERROR_BROKEN_PIPE)
	{
	  /* On Unix, a read from a broken pipe returns EOF.  */
	  return 0;
	}
      __seterrno ();
      return -1;
    }
  if (n == 0
      && (get_flags () & (O_NONBLOCK | O_NDELAY)) != 0)
    {
      set_errno (EAGAIN);
      return -1;
    }
  if (pktmode)
    {
      *cptr++ = TIOCPKT_DATA;
      len--;
    }

  int x;
  x = process_slave_output (cptr, len);
  if (x < 0)
    return -1;
d933 1
a933 2
  if (pktmode && x > 0)
    x++;
@


1.4
log
@* environ.cc: Eliminate oldstack CYGWIN option.
* exceptions.cc (sfta): Eliminate obsolete function.
(sgmb): Eliminate obsolete function.
(class stack_info): Remove MS method for walking the stack.
(stack_info::init): Just initialize required fields.
(stack_info::brute_force): Rename to stack_info::walk.
(handle_exceptions): Pass derived frame pointer to sig_send.
(interrupt_setup): Clear saved frame pointer here.
(interrupt_on_return): thestack is no longer a pointer.
(call_handler): Accept a flag to indicate when a signal was sent from other
than the main thread.  Use saved frame pointer for determining where to place
signal handler call.
(sig_handle): Accept "nonmain" argument.  Pass it to call_handler.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Change
debugging output slightly.
* (fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_tty_slave::read): Fix a comment, remove a goto.
* sigproc.cc (sig_send): Accept an optional frame pointer argument for use when
suspending the main process.  sigcomplete_main is an autoreset event now.  Save
frame pointer for non-main operation.
(wait_sig): Make sigcomplete_main an autoreset event.  Eliminate NOSIGQUEUE.
Pass rc to sig_handle to signify if this was a nonmain process.
* sigproc.h: Reflect change to sig_send argument.
* syscalls.cc (swab): Eliminate swab function since it is now available in
newlib.
* winsup.h (signal_dispatch): Change CONTEXT cx to DWORD ebp.
@
text
@d157 2
a158 1
  WriteFile (get_ttyp ()->to_master, str, len, &len, NULL);
d223 1
a223 2

again:
d226 1
a226 1
    return 0;
d228 1
a228 1
  if (neednl_)
d230 11
a240 8
      /* We need to return a left over \n character, resulting from
	 \r\n conversion.  Note that we already checked for FLUSHO and
	 OutputStopped at the time that we read the character, so we
	 don't check again here.  */
      buf[0] = '\n';
      neednl_ = 0;
      return 1;
    }
d242 3
a244 22
  /* Set RLEN to the number of bytes to read from the pipe.  */
  rlen = len;
  if (get_ttyp ()->ti.c_oflag & OPOST && get_ttyp ()->ti.c_oflag & ONLCR)
    {
      /* We are going to expand \n to \r\n, so don't read more than
	 half of the number of bytes requested.  */
      rlen /= 2;
      if (rlen == 0)
	rlen = 1;
    }
  if (rlen > sizeof outbuf)
    rlen = sizeof outbuf;

  HANDLE handle = get_io_handle ();

  /* Doing a busy wait like this is quite inefficient, but nothing
     else seems to work completely.  Windows should provide some sort
     of overlapped I/O for pipes, or something, but it doesn't.  */
  DWORD avail;
  while (1)
    {
      if (! PeekNamedPipe (handle, NULL, 0, NULL, &avail, NULL))
d246 5
a250 4
	  if (GetLastError () == ERROR_BROKEN_PIPE)
	    return 0;
	  __seterrno ();
	  return -1;
d252 4
a255 6
      if (avail > 0)
	break;
      if (hit_eof ())
	return 0;
      Sleep (10);
    }
d257 14
a270 7
  if (ReadFile (handle, outbuf, rlen, &n, NULL) == FALSE)
    {
      if (GetLastError () == ERROR_BROKEN_PIPE)
	return 0;
      __seterrno ();
      return -1;
    }
d272 2
a273 1
  termios_printf ("len=%u", n);
d275 1
a275 7
  if (get_ttyp ()->ti.c_lflag & FLUSHO)
    {
      get_ttyp ()->write_retval = n;
      if (output_done_event != NULL)
	SetEvent (output_done_event);
      goto again;
    }
d277 7
a283 5
  if (get_ttyp ()->OutputStopped)
    {
      termios_printf ("waiting for restart_output_event");
      WaitForSingleObject (restart_output_event, INFINITE);
    }
d285 6
a290 3
  if (get_ttyp ()->ti.c_oflag & OPOST)	// post-process output
    {
      char *iptr = outbuf, *optr = buf;
d292 1
a292 1
      while (n--)
d294 8
a301 1
	  switch (*iptr)
d303 1
a303 2
	    case '\r':
	      if ((get_ttyp ()->ti.c_oflag & ONOCR) && column == 0)
d305 23
a327 2
		  iptr++;
		  continue;
d329 5
a333 7
	      if (get_ttyp ()->ti.c_oflag & OCRNL)
		*iptr = '\n';
	      else
		column = 0;
	      break;
	    case '\n':
	      if (get_ttyp ()->ti.c_oflag & ONLCR)
d335 4
a338 2
		  *optr++ = '\r';
		  column = 0;
a339 7
	      if (get_ttyp ()->ti.c_oflag & ONLRET)
		column = 0;
	      break;
	    default:
	      column++;
	      break;
	    }
d341 1
a341 9
	  /* Don't store data past the end of the user's buffer.  This
	     can happen if the user requests a read of 1 byte when
	     doing \r\n expansion.  */
	  if (optr - buf >= (int) len)
	    {
	      neednl_ = 1;
	      if (*iptr != '\n' || n != 0)
		system_printf ("internal error: %d unexpected characters", n);
	      break;
d343 3
d347 7
a353 1
	  *optr++ = *iptr++;
d355 1
a355 6
      return optr - buf;
    }
  else					// raw output mode
    {
      memcpy (buf, outbuf, n);
      return n;
d357 4
d559 4
a562 2
	  termios_printf("tty%d waiting for output_done", ttynum);
	  WaitForSingleObject (output_done_event, n * 1000);
@


1.3
log
@Throughout use strace class in place of individual functions and variables.
* cygwin.din: Eliminate _strace_wm.
* sigproc.cc (wait_sig): Temporarily add more debugging output.
* include/cygwin/version.h: Bump minor api to reflect export change.
@
text
@d113 4
a116 1
#ifdef DEBUGGING
a123 2
  if (strace.active)
    strace.prntf (_STRACE_TERMIOS, "%F (%d): tty output_mutex: acquired", fn, ln, res);
d132 4
a135 1
#ifdef DEBUGGING
a142 2
  if (strace.active)
    strace.prntf (_STRACE_TERMIOS, "%F (%d): tty output_mutex released", fn, ln);
d293 4
a296 1
    WaitForSingleObject (restart_output_event, INFINITE);
a582 1
    wait:
d621 1
a621 1
	  /* We can't enter to blocking Readfile - signals will be lost!
d632 1
a632 1
		goto wait;		// min > 0, time = 0
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d108 2
a109 2
  if (strace_active)
    strace_printf (_STRACE_TERMIOS, "%F (%d): tty output_mutex: waiting %d ms", fn, ln, ms);
d121 2
a122 2
  if (strace_active)
    strace_printf (_STRACE_TERMIOS, "%F (%d): tty output_mutex: acquired", fn, ln, res);
d139 2
a140 2
  if (strace_active)
    strace_printf (_STRACE_TERMIOS, "%F (%d): tty output_mutex released", fn, ln);
@


1.1
log
@Initial revision
@
text
@d185 1
a185 1
process_input (void *arg)
d349 1
a349 1
process_output (void *arg)
d377 1
a377 1
process_ioctl (void *arg)
d503 1
a503 1
fhandler_tty_slave::init (HANDLE f, DWORD a, mode_t)
d736 1
a736 1
fhandler_tty_slave::tcsetattr (int a, const struct termios *t)
d745 1
a745 1
fhandler_tty_slave::tcflush (int a)
d898 1
a898 1
  if (! PeekNamedPipe (get_handle (), NULL, 0, NULL, &n, NULL))
d919 4
a922 2
  n = process_slave_output (cptr, len);
  if (n < 0)
d926 3
a928 3
  if (pktmode && n > 0)
    n++;
  return n;
d939 1
a939 1
fhandler_pty_master::tcsetattr (int a, const struct termios *t)
d946 1
a946 1
fhandler_pty_master::tcflush (int a)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
