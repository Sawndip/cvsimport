head	1.140;
access;
symbols
	cygwin-1_7_35-release:1.140
	cygwin-1_7_34-release:1.140
	cygwin-1_7_33-release:1.136.2.2
	cygwin-1_7_32-release:1.136.2.1
	cygwin-1_7_31-release:1.136.2.1
	cygwin-1_7_30-release:1.136.2.1
	cygwin-1_7_29-release:1.136.2.1
	cygwin-1_7_29-release-branchpoint:1.136.0.2
	cygwin-pre-user-db:1.136
	cygwin-1_7_28-release:1.136
	cygwin-1_7_27-release:1.135
	cygwin-1_7_26-release:1.135
	cygwin-1_7_25-release:1.133
	cygwin-1_7_24-release:1.133
	cygwin-1_7_23-release:1.133
	cygwin-1_7_22-release:1.133
	cygwin-1_7_21-release:1.133
	cygwin-1_7_20-release:1.133
	cygwin-1_7_19-release:1.133
	cygwin-64bit-postmerge:1.133
	cygwin-64bit-premerge-branch:1.132.0.2
	cygwin-64bit-premerge:1.132
	cygwin-1_7_18-release:1.132
	post-ptmalloc3:1.130.2.3
	pre-ptmalloc3:1.130.2.3
	cygwin-1_7_17-release:1.130
	cygwin-64bit-branch:1.130.0.2
	cygwin-1_7_16-release:1.130
	cygwin-1_7_15-release:1.130
	cygwin-1_7_14_2-release:1.130
	cygwin-1_7_14-release:1.130
	cygwin-1_7_12-release:1.130
	cygwin-1_7_11-release:1.129
	cygwin-1_7_10-release:1.129
	signal-rewrite:1.127.0.2
	pre-notty:1.127
	cygwin-1_7_9-release:1.126
	cv-post-1_7_9:1.126.0.2
	cygwin-1_7_8-release:1.126
	cygwin-1_7_7-release:1.126
	cygwin-1_7_5-release:1.125
	cygwin-1_7_4-release:1.125
	cygwin-1_7_3-release:1.125
	cygwin-1_7_2-release:1.125
	fifo_doover3:1.124.0.2
	cygwin-1_7_1-release:1.124
	prefifo:1.123
	cv-branch-2:1.123.0.2
	pre-ripout-set_console_state_for_spawn:1.122
	EOL_registry_mounts:1.121
	preoverlapped:1.117
	drop_9x_support_start:1.114
	cr-0x5f1:1.112.0.4
	cv-branch:1.112.0.2
	pre-ptymaster-archetype:1.112
	cr-0x3b58:1.101.0.4
	cr-0x5ef:1.102.0.2
	after-mmap-privanon-noreserve:1.95
	after-mmap-revamp:1.95
	before-mmap-revamp:1.95
	cgf-more-exit-sync:1.94
	post_wait_sig_exit:1.92
	pre_wait_sig_exit:1.92
	reparent-point:1.83
	noreparent:1.83.0.2
	cr-0x5e6:1.82.0.2
	cr-0x9e:1.77.0.6
	cr-0x9d:1.77.0.4
	cgf-deleteme:1.77.0.2
	pre-sigrewrite:1.77
	corinna-01:1.76
	cr-0x9c:1.75.0.4
	cr-0x9b:1.75.0.2
	cr-0x99:1.71
	Z-emcb-cygwin_daemon:1.71.0.2
	w32api-2_2:1.67
	mingw-runtime-2_4:1.67
	pre-cgf-merge:1.75
	cgf-dev-branch:1.67.0.16
	predaemon:1.60
	cygwin_daemon_merge_HEAD:1.60
	pregp02r1:1.59.0.2
	cygnus_cvs_20020108_pre:1.56
	Z-cygwin_daemon_merge-new_HEAD:1.66
	Z-cygwin_daemon_merge_HEAD:1.66
	cygwin_daemon:1.46.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.140
date	2014.08.22.09.21.30;	author corinna;	state Exp;
branches;
next	1.139;

1.139
date	2014.08.21.08.46.35;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2014.08.19.19.25.54;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2014.03.09.18.39.14;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2014.01.31.19.27.26;	author corinna;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2013.11.25.11.38.07;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2013.10.30.09.44.47;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2013.04.23.09.44.31;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2012.10.26.15.12.14;	author corinna;	state Exp;
branches;
next	1.130;

1.130
date	2012.03.29.18.02.54;	author corinna;	state Exp;
branches
	1.130.2.1;
next	1.129;

1.129
date	2012.02.02.13.58.20;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2010.07.05.16.59.51;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2010.01.12.10.14.59;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2009.09.26.15.51.53;	author ericb;	state Exp;
branches;
next	1.123;

1.123
date	2008.11.28.09.04.35;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2007.08.16.14.46.23;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2007.07.26.17.30.54;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2007.07.09.17.02.37;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2007.06.29.15.13.00;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2007.02.22.16.32.39;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2007.02.22.16.04.19;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2007.01.17.19.26.57;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2006.11.30.10.17.24;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2006.05.28.15.50.13;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2006.03.03.20.19.26;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2006.02.28.12.20.11;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2006.02.05.10.55.23;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2006.02.04.19.02.42;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2006.02.04.04.31.34;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2006.01.31.08.56.21;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2006.01.27.21.50.39;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2006.01.24.19.03.20;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2006.01.21.02.24.16;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2006.01.19.05.34.39;	author cgf;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2006.01.03.17.44.26;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2006.01.03.15.42.56;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2005.12.19.04.00.41;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2005.12.05.21.02.53;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2005.12.05.20.30.40;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2005.12.05.20.20.17;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2005.10.21.14.08.19;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2005.10.12.20.38.38;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2005.09.29.16.23.20;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2005.08.28.16.30.48;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2005.08.23.03.58.04;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2005.08.20.06.19.54;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2005.08.19.16.18.42;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2005.05.25.04.32.58;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2005.05.13.15.46.05;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2005.05.13.03.21.39;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2005.03.16.21.20.56;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2004.05.03.11.53.07;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2004.04.13.20.36.58;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2004.03.20.00.03.32;	author phumblet;	state Exp;
branches;
next	1.78;

1.78
date	2004.03.14.16.16.45;	author phumblet;	state Exp;
branches;
next	1.77;

1.77
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2003.09.11.14.43.09;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2003.09.10.20.16.00;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2003.09.09.00.21.16;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2003.09.08.04.04.18;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2003.05.11.21.52.09;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.11.00.10.09;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches
	1.67.16.1;
next	1.66;

1.66
date	2002.06.05.16.01.55;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.05.01.42.27;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.01.02.45.38;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.28.01.55.39;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.10.13.38.48;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2002.01.14.20.39.59;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2002.01.13.20.03.03;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2002.01.06.03.32.32;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.04.19.06.01;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.12.05.23.05.15;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.11.22.05.59.07;	author cgf;	state Exp;
branches
	1.53.6.1;
next	1.52;

1.52
date	2001.11.21.06.47.57;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.11.13.21.49.06;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.05.06.09.06;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.05.04.21.41;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.05.00.17.57;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.17.18.10.02;	author cgf;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2001.09.12.17.46.35;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.06.03.39.18;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.03.19.06.58;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.03.16.36.54;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.28.20.38.07;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.07.16.14.59;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.07.15.09.54;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.20.07.24.02;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.24.22.26.49;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.03.02.31.16;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.12.16.24.05;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.18.21.10.11;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.12.21.21.37;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.17.07.09.41;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.02.12.33.50;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.02.11.41.09;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.22.14.51.16;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.21.22.59.11;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.21.21.49.36;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.15.00.13.08;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.14.16.06.52;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.14.05.53.32;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.09.13.32.33;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.10.19.20.11;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.19.20.14.24;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.17.19.18.21;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.25.21.45.04;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.25.21.02.28;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.25.19.48.45;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.25.10.27.36;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.24.20.09.43;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.23.19.25.18;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.22.17.15.47;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.136.2.1
date	2014.03.09.18.39.29;	author cgf;	state Exp;
branches;
next	1.136.2.2;

1.136.2.2
date	2014.11.13.12.52.55;	author corinna;	state Exp;
branches;
next	;

1.130.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.130.2.2;

1.130.2.2
date	2012.10.26.15.13.52;	author corinna;	state Exp;
branches;
next	1.130.2.3;

1.130.2.3
date	2013.01.21.13.52.04;	author corinna;	state Exp;
branches;
next	;

1.102.2.1
date	2006.01.20.18.27.08;	author cgf;	state Exp;
branches;
next	;

1.67.16.1
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.67.16.2;

1.67.16.2
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.67.16.3;

1.67.16.3
date	2003.05.26.19.39.05;	author cgf;	state Exp;
branches;
next	1.67.16.4;

1.67.16.4
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.67.16.5;

1.67.16.5
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.67.16.6;

1.67.16.6
date	2003.09.11.04.47.22;	author cgf;	state Exp;
branches;
next	1.67.16.7;

1.67.16.7
date	2003.09.14.01.35.37;	author cgf;	state Exp;
branches;
next	;

1.53.6.1
date	2001.12.05.23.07.04;	author cgf;	state Exp;
branches;
next	;

1.46.2.1
date	2001.10.02.12.09.53;	author rbcollins;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2002.01.04.03.56.06;	author rbcollins;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2002.01.15.12.52.50;	author rbcollins;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2002.02.28.12.53.23;	author rbcollins;	state Exp;
branches;
next	1.46.2.5;

1.46.2.5
date	2002.06.13.14.34.02;	author rbcollins;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.140
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@/* dir.cc: Posix directory-related routines

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <unistd.h>

#define _COMPILING_NEWLIB
#include <dirent.h>

#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "cygtls.h"
#include "tls_pbuf.h"

extern "C" int
dirfd (DIR *dir)
{
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	return dir->__d_fd;
      syscall_printf ("-1 = dirfd (%p)", dir);
      set_errno (EINVAL);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

/* Symbol kept for backward compatibility.  Don't remove.  Don't declare
   in public header file. */
extern "C" DIR *
__opendir_with_d_ino (const char *name)
{
  return opendir (name);
}

/* opendir: POSIX 5.1.2.1 */
extern "C" DIR *
opendir (const char *name)
{
  fhandler_base *fh;
  DIR *res;

  fh = build_fh_name (name, PC_SYM_FOLLOW);
  if (!fh)
    res = NULL;
  else if (fh->error ())
    {
      set_errno (fh->error ());
      res = NULL;
    }
  else if (fh->exists ())
    res = fh->opendir (-1);
  else
    {
      set_errno (ENOENT);
      res = NULL;
    }

  if (!res && fh)
    delete fh;
  /* Applications calling flock(2) on dirfd(fd) need this... */
  if (res && !fh->nohandle ())
    fh->set_unique_id ();
  return res;
}

extern "C" DIR *
fdopendir (int fd)
{
  DIR *res = NULL;

  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = cfd->opendir (fd);
  return res;
}

static int
readdir_worker (DIR *dir, dirent *de)
{
  int res = 0;

  __try
    {
      if (dir->__d_cookie != __DIRENT_COOKIE)
	{
	  syscall_printf ("%p = readdir (%p)", NULL, dir);
	  res = EBADF;
	  __leave;
	}

      de->d_ino = 0;
      de->d_type = DT_UNKNOWN;
      memset (&de->__d_unused1, 0, sizeof (de->__d_unused1));

      res = ((fhandler_base *) dir->__fh)->readdir (dir, de);

      if (res == ENMFILE)
	{
	  if (!(dir->__flags & dirent_saw_dot))
	    {
	      strcpy (de->d_name, ".");
	      dir->__flags |= dirent_saw_dot;
	      dir->__d_position++;
	      res = 0;
	    }
	  else if (!(dir->__flags & dirent_saw_dot_dot))
	    {
	      strcpy (de->d_name, "..");
	      dir->__flags |= dirent_saw_dot_dot;
	      dir->__d_position++;
	      res = 0;
	    }
	}

      if (!res && !de->d_ino)
	{
	  bool is_dot = false;
	  bool is_dot_dot = false;

	  if (de->d_name[0] == '.')
	    {
	      if (de->d_name[1] == '\0')
		is_dot = true;
	      else if (de->d_name[1] == '.' && de->d_name[2] == '\0')
		is_dot_dot = true;
	    }

	  if (is_dot_dot && !(dir->__flags & dirent_isroot))
	    de->d_ino = readdir_get_ino (((fhandler_base *)
	    				 dir->__fh)->get_name (),
					 true);
	  else
	    {
	      /* Compute d_ino by combining filename hash with directory hash. */
	      de->d_ino = ((fhandler_base *) dir->__fh)->get_ino ();
	      if (!is_dot && !is_dot_dot)
		{
		  PUNICODE_STRING w32name =
		      ((fhandler_base *) dir->__fh)->pc.get_nt_native_path ();
		  DWORD devn = ((fhandler_base *) dir->__fh)->get_device ();
		  /* Paths below /proc don't have a Win32 pendant. */
		  if (isproc_dev (devn))
		    de->d_ino = hash_path_name (de->d_ino, L"/");
		  else if (w32name->Buffer[w32name->Length / sizeof (WCHAR) - 1]
			   != L'\\')
		    de->d_ino = hash_path_name (de->d_ino, L"\\");
		  de->d_ino = hash_path_name (de->d_ino, de->d_name);
		}
	    }
	}
      /* This fills out the old 32 bit d_ino field for old applications,
	 build under Cygwin before 1.5.x. */
      de->__d_internal1 = de->d_ino;
    }
  __except (NO_ERROR)
    {
      res = EFAULT;
    }
  __endtry
  return res;
}

/* readdir: POSIX 5.1.2.1 */
extern "C" struct dirent *
readdir (DIR *dir)
{
  int res = readdir_worker (dir, dir->__d_dirent);
  if (res == 0)
    return dir->__d_dirent;
  if (res != ENMFILE)
    set_errno (res);
  return NULL;
}

extern "C" int
readdir_r (DIR *__restrict dir, dirent *__restrict de, dirent **__restrict ode)
{
  int res = readdir_worker (dir, de);
  if (!res)
    *ode = de;
  else
    {
      *ode = NULL;
      if (res == ENMFILE)
	res = 0;
    }
  return res;
}

/* telldir */
extern "C" long
telldir (DIR *dir)
{
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	return ((fhandler_base *) dir->__fh)->telldir (dir);
      set_errno (EBADF);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

/* telldir was never defined using off_t in POSIX, only in early versions
   of glibc.  We have to keep the function in as entry point for backward
   compatibility. */
extern "C" off_t
telldir64 (DIR *dir)
{
  return (off_t) telldir (dir);
}

/* seekdir */
extern "C" void
seekdir (DIR *dir, long loc)
{
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	{
	  dir->__flags &= dirent_info_mask;
	  ((fhandler_base *) dir->__fh)->seekdir (dir, loc);
	}
      set_errno (EINVAL);	/* Diagnosis */
    }
  __except (EFAULT) {}
  __endtry
}

/* seekdir was never defined using off_t in POSIX, only in early versions
   of glibc.  We have to keep the function in as entry point for backward
   compatibility. */
extern "C" void
seekdir64 (DIR *dir, off_t loc)
{
  seekdir (dir, (long) loc);
}

/* rewinddir: POSIX 5.1.2.1 */
extern "C" void
rewinddir (DIR *dir)
{
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	{
	  dir->__flags &= dirent_info_mask;
	  ((fhandler_base *) dir->__fh)->rewinddir (dir);
	}
      set_errno (EINVAL);	/* Diagnosis */
    }
  __except (EFAULT) {}
  __endtry
}

/* closedir: POSIX 5.1.2.1 */
extern "C" int
closedir (DIR *dir)
{
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	{
	  /* Reset the marker in case the caller tries to use `dir' again.  */
	  dir->__d_cookie = 0;

	  int res = ((fhandler_base *) dir->__fh)->closedir (dir);

	  close (dir->__d_fd);
	  free (dir->__d_dirname);
	  free (dir->__d_dirent);
	  free (dir);
	  syscall_printf ("%R = closedir(%p)", res, dir);
	  return res;
	}
      set_errno (EBADF);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = closedir(%p)", -1, dir);
  return -1;
}

/* mkdir: POSIX 5.4.1.1 */
extern "C" int
mkdir (const char *dir, mode_t mode)
{
  int res = -1;
  fhandler_base *fh = NULL;
  tmp_pathbuf tp;

  __try
    {
      /* POSIX says mkdir("symlink-to-missing/") should create the
	 directory "missing", but Linux rejects it with EEXIST.  Copy
	 Linux behavior for now.  */

      if (!*dir)
	{
	  set_errno (ENOENT);
	  __leave;
	}
      if (isdirsep (dir[strlen (dir) - 1]))
	{
	  /* This converts // to /, but since both give EEXIST, we're okay.  */
	  char *buf;
	  char *p = stpcpy (buf = tp.c_get (), dir) - 1;
	  dir = buf;
	  while (p > dir && isdirsep (*p))
	    *p-- = '\0';
	}
      if (!(fh = build_fh_name (dir, PC_SYM_NOFOLLOW)))
	__leave;   /* errno already set */;

      if (fh->error ())
	{
	  debug_printf ("got %d error from build_fh_name", fh->error ());
	  set_errno (fh->error ());
	}
      else if (has_dot_last_component (dir, true))
	set_errno (fh->exists () ? EEXIST : ENOENT);
      else if (!fh->mkdir (mode))
	res = 0;
      delete fh;
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = mkdir(%s, %d)", res, dir, mode);
  return res;
}

/* rmdir: POSIX 5.5.2.1 */
extern "C" int
rmdir (const char *dir)
{
  int res = -1;
  fhandler_base *fh = NULL;

  __try
    {
      if (!(fh = build_fh_name (dir, PC_SYM_NOFOLLOW)))
	__leave;   /* errno already set */;

      if (fh->error ())
	{
	  debug_printf ("got %d error from build_fh_name", fh->error ());
	  set_errno (fh->error ());
	}
      else if (!fh->exists ())
	set_errno (ENOENT);
      else if (has_dot_last_component (dir, false))
	set_errno (EINVAL);
      else if (isdev_dev (fh->dev ()))
	set_errno (ENOTEMPTY);
      else if (!fh->rmdir ())
	res = 0;
      delete fh;
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = rmdir(%s)", res, dir);
  return res;
}
@


1.139
log
@	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.
@
text
@d31 1
a31 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (dir->__d_cookie != __DIRENT_COOKIE)
d33 3
a36 2
      syscall_printf ("-1 = dirfd (%p)", dir);
      return -1;
d38 3
a40 1
  return dir->__d_fd;
d96 1
a96 3
  myfault efault;
  if (efault.faulted ())
    return EFAULT;
d98 1
a98 1
  if (dir->__d_cookie != __DIRENT_COOKIE)
d100 6
a105 3
      syscall_printf ("%p = readdir (%p)", NULL, dir);
      return EBADF;
    }
d107 3
a109 3
  de->d_ino = 0;
  de->d_type = DT_UNKNOWN;
  memset (&de->__d_unused1, 0, sizeof (de->__d_unused1));
d111 1
a111 1
  int res = ((fhandler_base *) dir->__fh)->readdir (dir, de);
d113 1
a113 3
  if (res == ENMFILE)
    {
      if (!(dir->__flags & dirent_saw_dot))
d115 14
a128 4
	  strcpy (de->d_name, ".");
	  dir->__flags |= dirent_saw_dot;
	  dir->__d_position++;
	  res = 0;
d130 2
a131 1
      else if (!(dir->__flags & dirent_saw_dot_dot))
d133 2
a134 6
	  strcpy (de->d_name, "..");
	  dir->__flags |= dirent_saw_dot_dot;
	  dir->__d_position++;
	  res = 0;
	}
    }
d136 7
a142 4
  if (!res && !de->d_ino)
    {
      bool is_dot = false;
      bool is_dot_dot = false;
d144 5
a148 16
      if (de->d_name[0] == '.')
	{
	  if (de->d_name[1] == '\0')
	    is_dot = true;
	  else if (de->d_name[1] == '.' && de->d_name[2] == '\0')
	    is_dot_dot = true;
	}

      if (is_dot_dot && !(dir->__flags & dirent_isroot))
	de->d_ino = readdir_get_ino (((fhandler_base *) dir->__fh)->get_name (),
				     true);
      else
	{
	  /* Compute d_ino by combining filename hash with directory hash. */
	  de->d_ino = ((fhandler_base *) dir->__fh)->get_ino ();
	  if (!is_dot && !is_dot_dot)
d150 15
a164 10
	      PUNICODE_STRING w32name =
		  ((fhandler_base *) dir->__fh)->pc.get_nt_native_path ();
	      DWORD devn = ((fhandler_base *) dir->__fh)->get_device ();
	      /* Paths below /proc don't have a Win32 pendant. */
	      if (isproc_dev (devn))
		de->d_ino = hash_path_name (de->d_ino, L"/");
	      else if (w32name->Buffer[w32name->Length / sizeof (WCHAR) - 1]
		       != L'\\')
		de->d_ino = hash_path_name (de->d_ino, L"\\");
	      de->d_ino = hash_path_name (de->d_ino, de->d_name);
d167 3
d171 5
a175 4
  /* This fills out the old 32 bit d_ino field for old applications,
     build under Cygwin before 1.5.x. */
  de->__d_internal1 = de->d_ino;

d210 1
a210 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  if (dir->__d_cookie != __DIRENT_COOKIE)
d212 2
a214 1
      return -1;
d216 3
a218 1
  return ((fhandler_base *) dir->__fh)->telldir (dir);
d234 11
a244 8
  myfault efault;
  if (efault.faulted (EFAULT))
    return;

  if (dir->__d_cookie != __DIRENT_COOKIE)
    return;
  dir->__flags &= dirent_info_mask;
  return ((fhandler_base *) dir->__fh)->seekdir (dir, loc);
d260 11
a270 8
  myfault efault;
  if (efault.faulted (EFAULT))
    return;

  if (dir->__d_cookie != __DIRENT_COOKIE)
    return;
  dir->__flags &= dirent_info_mask;
  return ((fhandler_base *) dir->__fh)->rewinddir (dir);
d277 8
a284 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d286 7
a292 2
  if (dir->__d_cookie != __DIRENT_COOKIE)
    {
a293 2
      syscall_printf ("%R = closedir(%p)", -1, dir);
      return -1;
d295 4
a298 12

  /* Reset the marker in case the caller tries to use `dir' again.  */
  dir->__d_cookie = 0;

  int res = ((fhandler_base *) dir->__fh)->closedir (dir);

  close (dir->__d_fd);
  free (dir->__d_dirname);
  free (dir->__d_dirent);
  free (dir);
  syscall_printf ("%R = closedir(%p)", res, dir);
  return res;
d309 5
a313 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  /* POSIX says mkdir("symlink-to-missing/") should create the
     directory "missing", but Linux rejects it with EEXIST.  Copy
     Linux behavior for now.  */
d315 16
a330 16
  if (!*dir)
    {
      set_errno (ENOENT);
      goto done;
    }
  if (isdirsep (dir[strlen (dir) - 1]))
    {
      /* This converts // to /, but since both give EEXIST, we're okay.  */
      char *buf;
      char *p = stpcpy (buf = tp.c_get (), dir) - 1;
      dir = buf;
      while (p > dir && isdirsep (*p))
	*p-- = '\0';
    }
  if (!(fh = build_fh_name (dir, PC_SYM_NOFOLLOW)))
    goto done;   /* errno already set */;
d332 10
a341 4
  if (fh->error ())
    {
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
d343 2
a344 7
  else if (has_dot_last_component (dir, true))
    set_errno (fh->exists () ? EEXIST : ENOENT);
  else if (!fh->mkdir (mode))
    res = 0;
  delete fh;

 done:
d356 4
a359 3
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
d361 14
a374 7
  if (!(fh = build_fh_name (dir, PC_SYM_NOFOLLOW)))
    goto done;   /* errno already set */;

  if (fh->error ())
    {
      debug_printf ("got %d error from build_fh_name", fh->error ());
      set_errno (fh->error ());
d376 2
a377 12
  else if (!fh->exists ())
    set_errno (ENOENT);
  else if (has_dot_last_component (dir, false))
    set_errno (EINVAL);
  else if (isdev_dev (fh->dev ()))
    set_errno (ENOTEMPTY);
  else if (!fh->rmdir ())
    res = 0;

  delete fh;

 done:
@


1.138
log
@	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.
@
text
@d362 1
a362 4
    {
      set_errno (ENOTEMPTY);
      goto done;
    }
@


1.137
log
@* dir.cc (opendir): Propagate any errno from build_fh_name.
@
text
@d36 1
a36 1
      set_errno (EBADF);
d208 4
a211 1
    return 0;
@


1.136
log
@*** empty log message ***
@
text
@d61 5
@


1.136.2.1
log
@* dir.cc (opendir): Propagate any errno from build_fh_name.
@
text
@a60 5
  else if (fh->error ())
    {
      set_errno (fh->error ());
      res = NULL;
    }
@


1.136.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d31 4
a34 1
  __try
d36 1
a36 2
      if (dir->__d_cookie == __DIRENT_COOKIE)
	return dir->__d_fd;
d38 1
a38 1
      set_errno (EINVAL);
d40 1
a40 3
  __except (EFAULT) {}
  __endtry
  return -1;
d96 3
a98 1
  int res = 0;
d100 1
a100 1
  __try
d102 20
a121 1
      if (dir->__d_cookie != __DIRENT_COOKIE)
d123 4
a126 3
	  syscall_printf ("%p = readdir (%p)", NULL, dir);
	  res = EBADF;
	  __leave;
d128 1
d130 4
a133 5
      de->d_ino = 0;
      de->d_type = DT_UNKNOWN;
      memset (&de->__d_unused1, 0, sizeof (de->__d_unused1));

      res = ((fhandler_base *) dir->__fh)->readdir (dir, de);
d135 1
a135 1
      if (res == ENMFILE)
d137 4
a140 14
	  if (!(dir->__flags & dirent_saw_dot))
	    {
	      strcpy (de->d_name, ".");
	      dir->__flags |= dirent_saw_dot;
	      dir->__d_position++;
	      res = 0;
	    }
	  else if (!(dir->__flags & dirent_saw_dot_dot))
	    {
	      strcpy (de->d_name, "..");
	      dir->__flags |= dirent_saw_dot_dot;
	      dir->__d_position++;
	      res = 0;
	    }
d143 4
a146 1
      if (!res && !de->d_ino)
d148 3
a150 4
	  bool is_dot = false;
	  bool is_dot_dot = false;

	  if (de->d_name[0] == '.')
d152 10
a161 27
	      if (de->d_name[1] == '\0')
		is_dot = true;
	      else if (de->d_name[1] == '.' && de->d_name[2] == '\0')
		is_dot_dot = true;
	    }

	  if (is_dot_dot && !(dir->__flags & dirent_isroot))
	    de->d_ino = readdir_get_ino (((fhandler_base *)
	    				 dir->__fh)->get_name (),
					 true);
	  else
	    {
	      /* Compute d_ino by combining filename hash with directory hash. */
	      de->d_ino = ((fhandler_base *) dir->__fh)->get_ino ();
	      if (!is_dot && !is_dot_dot)
		{
		  PUNICODE_STRING w32name =
		      ((fhandler_base *) dir->__fh)->pc.get_nt_native_path ();
		  DWORD devn = ((fhandler_base *) dir->__fh)->get_device ();
		  /* Paths below /proc don't have a Win32 pendant. */
		  if (isproc_dev (devn))
		    de->d_ino = hash_path_name (de->d_ino, L"/");
		  else if (w32name->Buffer[w32name->Length / sizeof (WCHAR) - 1]
			   != L'\\')
		    de->d_ino = hash_path_name (de->d_ino, L"\\");
		  de->d_ino = hash_path_name (de->d_ino, de->d_name);
		}
a163 3
      /* This fills out the old 32 bit d_ino field for old applications,
	 build under Cygwin before 1.5.x. */
      de->__d_internal1 = de->d_ino;
d165 4
a168 5
  __except (NO_ERROR)
    {
      res = EFAULT;
    }
  __endtry
d203 7
a209 9
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	return ((fhandler_base *) dir->__fh)->telldir (dir);
      set_errno (EBADF);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
d225 8
a232 11
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	{
	  dir->__flags &= dirent_info_mask;
	  ((fhandler_base *) dir->__fh)->seekdir (dir, loc);
	}
      set_errno (EINVAL);	/* Diagnosis */
    }
  __except (EFAULT) {}
  __endtry
d248 8
a255 11
  __try
    {
      if (dir->__d_cookie == __DIRENT_COOKIE)
	{
	  dir->__flags &= dirent_info_mask;
	  ((fhandler_base *) dir->__fh)->rewinddir (dir);
	}
      set_errno (EINVAL);	/* Diagnosis */
    }
  __except (EFAULT) {}
  __endtry
d262 5
a266 1
  __try
d268 7
a274 4
      if (dir->__d_cookie == __DIRENT_COOKIE)
	{
	  /* Reset the marker in case the caller tries to use `dir' again.  */
	  dir->__d_cookie = 0;
d276 1
a276 1
	  int res = ((fhandler_base *) dir->__fh)->closedir (dir);
d278 6
a283 13
	  close (dir->__d_fd);
	  free (dir->__d_dirname);
	  free (dir->__d_dirent);
	  free (dir);
	  syscall_printf ("%R = closedir(%p)", res, dir);
	  return res;
	}
      set_errno (EBADF);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = closedir(%p)", -1, dir);
  return -1;
d294 9
a302 1
  __try
d304 14
a317 3
      /* POSIX says mkdir("symlink-to-missing/") should create the
	 directory "missing", but Linux rejects it with EEXIST.  Copy
	 Linux behavior for now.  */
d319 10
a328 16
      if (!*dir)
	{
	  set_errno (ENOENT);
	  __leave;
	}
      if (isdirsep (dir[strlen (dir) - 1]))
	{
	  /* This converts // to /, but since both give EEXIST, we're okay.  */
	  char *buf;
	  char *p = stpcpy (buf = tp.c_get (), dir) - 1;
	  dir = buf;
	  while (p > dir && isdirsep (*p))
	    *p-- = '\0';
	}
      if (!(fh = build_fh_name (dir, PC_SYM_NOFOLLOW)))
	__leave;   /* errno already set */;
d330 1
a330 13
      if (fh->error ())
	{
	  debug_printf ("got %d error from build_fh_name", fh->error ());
	  set_errno (fh->error ());
	}
      else if (has_dot_last_component (dir, true))
	set_errno (fh->exists () ? EEXIST : ENOENT);
      else if (!fh->mkdir (mode))
	res = 0;
      delete fh;
    }
  __except (EFAULT) {}
  __endtry
d342 8
a349 1
  __try
d351 16
a366 2
      if (!(fh = build_fh_name (dir, PC_SYM_NOFOLLOW)))
	__leave;   /* errno already set */;
d368 1
a368 17
      if (fh->error ())
	{
	  debug_printf ("got %d error from build_fh_name", fh->error ());
	  set_errno (fh->error ());
	}
      else if (!fh->exists ())
	set_errno (ENOENT);
      else if (has_dot_last_component (dir, false))
	set_errno (EINVAL);
      else if (isdev_dev (fh->dev ()))
	set_errno (ENOTEMPTY);
      else if (!fh->rmdir ())
	res = 0;
      delete fh;
    }
  __except (EFAULT) {}
  __endtry
@


1.135
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d72 1
a72 1
  if (!fh->nohandle ())
@


1.134
log
@	* devices.in (dev_cygdrive_storage): Map to \Device\Null.
	(dev_storage): Map /dev and /dev/windows to \Device\Null.
	* devices.cc: Regenerate.
	* dir.cc (opendir): Create unique id.  Explain why.
	* fhandler.h (fhandler_dev::get_dev): Implement inline.
	(fhandler_cygdrive::close): Drop declaration.
	(fhandler_cygdrive::get_dev): Implement inline.
	(fhandler_windows::get_hwnd): Ditto.
	(fhandler_windows::set_close_on_exec): Drop declaration.
	(fhandler_windows::fixup_after_fork): Ditto.
	* fhandler_dev.cc (fhandler_dev::open): Call fhandler_disk_file::open
	without O_CREAT flag.  Explain why.  Create \Device\Null handle if
	/dev/ doesn't actually exist.
	(fhandler_dev::close): Drop nohandle case.
	(fhandler_dev::fstatvfs): Drop nohandle check.  Test for fs_got_fs
	instead.  Set ST_RDONLY fs flag for simulated /dev.
	(fhandler_dev::opendir): If /dev doesn't exist, call open() to create
	fake \Device\Null handle.  Don't set nohandle.  Set dir_exists
	correctly.
	(fhandler_dev::rewinddir): Call fhandler_disk_file::rewinddir only if
	/dev is a real directory.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If called for
	the cygdrive dir, call open() to create fake \Device\Null handle.
	Only attach __DIR_mounts buffer to dir if not called for cygdrive dir.
	Don't set nohandle.
	(fhandler_cygdrive::open): Create \Device\Null handle.
	(fhandler_cygdrive::close): Remove.
	(fhandler_cygdrive::fstatvfs): Set ST_RDONLY fs flag.
	* fhandler_windows.cc (fhandler_windows::open): Create \Device\Null
	handle.
	(fhandler_windows::read): Don't add io_handle to WFMO handle array.
	Change subsequent test for return value accordingly.  Fix test for
	"message arrived".
	(fhandler_windows::set_close_on_exec): Remove.
	(fhandler_windows::fixup_after_fork): Remove.
	* path.h (path_conv::set_path): Make sure wide_path is NULL when
	setting a new path.
	* select.cc (peek_windows): Use correct hWnd value, not io_handle.
	(fhandler_windows::select_read): Don't use io_handle as wait object.
	(fhandler_windows::select_write): Ditto.
	(fhandler_windows::select_except): Ditto.
@
text
@d180 1
a180 1
readdir_r (DIR *dir, dirent *de, dirent **ode)
@


1.133
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d71 3
@


1.132
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d207 1
a207 1
extern "C" _off64_t
d210 1
a210 1
  return (_off64_t) telldir (dir);
d231 1
a231 1
seekdir64 (DIR *dir, _off64_t loc)
@


1.131
log
@	* dir.cc (closedir): Fix syscall_printf.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2006, 2007,
   2008, 2009, 2010, 2012 Red Hat, Inc.
@


1.130
log
@	* Makefile.in (DLL_OFILES): Add fhandler_dev.o.
	* devices.h (DEV_DEV_MAJOR): Define.
	(FH_DEV): Redefine in terms of DEV_DEV_MAJOR.
	(ext_dev_storage): Declare.
	(dev_storage_size): Declare.
	(dev_dev_storage): Declare.
	(dev_dev): Define.
	(isdev_dev): Define.
	* devices.in (dev_dev_storage): Activate.
	(ext_dev_storage): Define as externally available pointer to
	dev_storage.
	(dev_storage_size): Define to contain number of dev_storage elements.
	* dir.cc (rmdir): Handle /dev as always not empty.
	* dtable.cc (fh_alloc): Handle DEV_DEV_MAJOR.
	* fhandler.h (fhandler_dev): New class, derived from fhandler_disk_file.
	(fhandler_union): Add fhandler_dev member.
	* fhandler_disk_file.cc (class __DIR_mounts): Handle /dev directory
	to make sure it always exists.
	* fhandler_dev.cc: New file implementing /dev.
	* globals.cc (ro_u_dev): New R/O unicode string.
	* path.cc (path_conv::check): Handle FH_DEV device.
@
text
@d274 1
a274 1
  syscall_printf ("%R = closedir(%p)", res);
@


1.130.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d207 1
a207 1
extern "C" off_t
d210 1
a210 1
  return (off_t) telldir (dir);
d231 1
a231 1
seekdir64 (DIR *dir, off_t loc)
@


1.130.2.2
log
@Pull in changes from HEAD
@
text
@d274 1
a274 1
  syscall_printf ("%R = closedir(%p)", res, dir);
@


1.130.2.3
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.129
log
@	Fix memory and handle leaks due to fdopendir:
	* dir.cc (closedir): Call global close instead of just releasing the
	fhandler.
	* fhandler_disk_file.cc (fhandler_disk_file::closedir): Don't close
	fhandler handle here, rely on global closedir doing the right thing.
	* fhandler_registry.cc (fhandler_registry::readdir): Also delete
	d_hash when closing registry key.
	(fhandler_registry::rewinddir): Ditto.

	Avoid infinite recursion in VirtualStore under UAC:
	* fhandler_registry.cc (VIRT_CLASSES_KEY_PREFIX): Define.
	(VIRT_CLASSES_KEY_SUFFIX): Ditto.
	(VIRT_CLASSES_KEY): Ditto.
	(VIRT_CLASSES_LINKTGT): Ditto.
	(fhandler_registry::exists): Return virt_symlink as file type if
	this is a Classes key under the VirtualStore.
	(fhandler_registry::fstat): Handle virt_symlink.
	(fhandler_registry::readdir): Return DT_LNK as d_type if this is a
	Classes key under the VirtualStore.
	(fhandler_registry::fill_filebuf): Handle Classes symlink.

	Handle user impersonation in /proc/registry access:
	* autoload.cc (RegOpenUserClassesRoot): Define.
	(RegOpenCurrentUser): Define.
	* fhandler_registry.cc (RegOpenUserClassesRoot): Declare function
	missing in w32api.
	(RegOpenCurrentUser): Ditto.
	(fetch_hkey): New function.
	(fhandler_registry::open): Call fetch_hkey to get root registry key.
	(open_key): Ditto.
@
text
@d350 5
@


1.128
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Red Hat, Inc.
d14 1
d270 1
a270 2
  cygheap->fdtab.release (dir->__d_fd);

@


1.127
log
@whitespace elimination
@
text
@d260 1
a260 1
      syscall_printf ("-1 = closedir (%p)", dir);
d274 1
a274 1
  syscall_printf ("%d = closedir (%p)", res);
d323 1
a323 1
  syscall_printf ("%d = mkdir (%s, %d)", res, dir, mode);
d356 1
a356 1
  syscall_printf ("%d = rmdir (%s)", res, dir);
@


1.126
log
@	Align seekdir and telldir API to POSIX definition.
	* Makefile.in (NEW_FUNCTIONS): Remove seekdir and telldir mappings.
	* dir.cc (telldir): Move functionality from telldir64 here.  Use
	long, rather than _off_t.
	(telldir64): Just call telldir.  Only keep for backward compatibility.
	(seekdir): Move functionality from seekdir64 here.  Use long, rather
	than _off_t.
	(seekdir64): Just call seekdir.  Only keep for backward compatibility.
	* fhandler.h: Throughout, change prototypes of seekdir and telldir
	methods to use long, rather than _off64_t.
	* fhandler_disk_file.cc: Change aforementioned methods accordingly.
	* fhandler_netdrive.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* include/sys/dirent.h (struct __DIR): Change __d_position from
	_off_t to long to reflect API change.
	(telldir): Change prototype to use long, rather than off_t.
	(seekdir): Ditto.
@
text
@d306 1
a306 1
        *p-- = '\0';
@


1.125
log
@	* dtable.cc (build_fh_name_worker): Remove.  Move all functionality
	back into build_fh_name.
	(build_fh_name): Drop unused HANDLE parameter.  Drop call to pc.fillin.
	Remove disabled build_fh_name with UNICODE_STRING name parameter.
	* dtable.h (build_fh_name): Drop HANDLE parameter from declaration.
	Remove declaration for build_fh_name with UNICODE_STRING name parameter.
	* path.cc (path_conv::fillin): Remove.
	(symlink_info::check): Fix comment.
	* path.h (path_conv::fillin): Remove declaration.
	* dir.cc: Accommodate change in build_fh_name parameters throughout.
	* sec_acl.cc: Ditto.
	* syscalls.cc: Ditto.

	* ntea.cc (getxattr_worker): Fix debug output.
	(setxattr_worker): Ditto.
	* times.cc (utimens_worker): Ditto.
@
text
@d190 3
a192 2
extern "C" _off64_t
telldir64 (DIR *dir)
d203 5
a207 3
/* telldir */
extern "C" _off_t
telldir (DIR *dir)
d209 1
a209 1
  return telldir64 (dir);
d212 1
d214 1
a214 1
seekdir64 (DIR *dir, _off64_t loc)
d226 3
a228 1
/* seekdir */
d230 1
a230 1
seekdir (DIR *dir, _off_t loc)
d232 1
a232 1
  seekdir64 (dir, (_off64_t)loc);
@


1.124
log
@Fix some POSIX-compliance bugs in link, rename, mkdir.

* syscalls.cc (link): Delete obsolete comment.  Reject directories
and missing source up front.
(rename): Use correct errno for trailing '.'.  Detect empty
strings.  Allow trailing slash to newpath iff oldpath is
directory.
* dir.cc (mkdir): Reject dangling symlink with trailing slash.
* fhandler_disk_file.cc (fhandler_disk_file::link): Reject
trailing slash.
* fhandler.cc (fhandler_base::link): Match Linux errno.
@
text
@d4 1
a4 1
   2008, 2009 Red Hat, Inc.
d57 1
a57 1
  fh = build_fh_name (name, NULL, PC_SYM_FOLLOW);
d302 1
a302 1
  if (!(fh = build_fh_name (dir, NULL, PC_SYM_NOFOLLOW)))
d332 1
a332 1
  if (!(fh = build_fh_name (dir, NULL, PC_SYM_NOFOLLOW)))
@


1.123
log
@	* dir.cc (readdir_worker): Initialize dirent.d_type and __d_unused1.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper):
	Set dirent.d_type based on FILE_ATTRIBUTE_*.
	* include/sys/dirent.h: Define _DIRENT_HAVE_D_TYPE (enables DT_*
	declarations).
	(struct dirent): Add d_type. Adjust __d_unused1 size to preserve layout.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2006, 2007 Red Hat, Inc.
d25 1
d278 1
d284 18
@


1.122
log
@Remove unneeded header files from source files throughout.
@
text
@d96 3
@


1.121
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@a11 1
#include <unistd.h>
a12 1
#include <sys/stat.h>
a16 1
#include "pinfo.h"
a23 2
#include "perprocess.h"
#include "cygwin/version.h"
@


1.120
log
@	* dir.cc (readdir_worker): Convert w32name to PUNICODE_STRING.
	* sec_acl.cc (getacl): Convert debug output to print native NT path.
	* security.cc (set_file_attribute): Ditto.
	* syscalls.cc (try_to_bin): Ditto and fix buggy debug statement.
@
text
@d140 1
a140 1
	  de->d_ino = ((fhandler_base *) dir->__fh)->get_namehash ();
@


1.119
log
@	* dir.cc (readdir_worker): Drop dir parameter from call to
	readdir_get_ino.
	* fhandler.h (fhandler_disk_file::readdir_helper): Switch file name
	parameter to PUNICODE_STRING.
	* fhandler_disk_file.cc: Drop including ntdef.h.
	(class __DIR_mounts): Store mount points in UNICODE.  Additionally
	store cygdrive prefix in unicode here.  Change methods accordingly.
	(__DIR_mounts::eval_ino): Call new stat_worker instead of lstat64.
	(__DIR_mounts::~__DIR_mounts): New destructor to free UNICODE buffers.
	(path_conv::ndisk_links): Rewrite using native NT functions.
	(fhandler_base::fstat_by_handle): Use NAME_MAX instead of CYG_MAX_PATH.
	Always set pfvi->VolumeSerialNumber to non-0.  Remove last resort
	code.
	(fhandler_base::fstat_by_name): Rewrite using native NT functions.
	(fhandler_base::fstat_fs): Always call fstat_by_name if fstat_by_handle
	fails.
	(fhandler_base::fstat_helper): Rely on dwVolumeSerialNumber.
	(fhandler_disk_file::facl): Call fstat_by_name if fstat_by_handle fails.
	(DIR_BUF_SIZE): Define using NAME_MAX instead of CYG_MAX_PATH.
	(__DIR_cache): Remove __name.
	(d_dirname): Remove.
	(fhandler_disk_file::opendir): Drop pathname length check.
	Remove outdated comment.  Use get_name method instead of accessing
	pc.normalized_path directly.
	(readdir_get_ino): Drop unused dir parameter.  Accomodate throughout.
	Allocate fname dynamically.  Call new stat_worker instead of lstat64.
	Call NtOpenFile instead of CreateFile.  Call NtClose instead of
	CloseHandle.
	(fhandler_disk_file::readdir_helper): Use native NT functions.
	Check for volume mount points and use correct inode number.
	(fhandler_disk_file::readdir): Simplify slightly.
	Use get_name instead of pc.normalized_path.
	(fhandler_disk_file::rewinddir): Use RtlInitUnicodeString.
	(fhandler_cygdrive::fstat): Ignore floppy drives.  Set st_nlink
	correctly.
	(fhandler_cygdrive::readdir): Ignore floppy drives.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Accommodate
	change to readdir_get_ino.
	* fhandler_proc.cc (PROC_DIR_COUNT): Define.
	(fhandler_proc::fstat): Evaluate correct link count for /proc.
	* ntdll.h (struct _FILE_DIRECTORY_INFORMATION): Define.
	(NtFsControlFile): Declare.
	(RtlAppendUnicodeToString): Declare.
	(RtlAppendUnicodeStringToString): Declare.
	(RtlCompareUnicodeString): Declare.
	(RtlCopyUnicodeString): Declare.
	(RtlCreateUnicodeStringFromAsciiz): Declare.
	(RtlEqualUnicodeString): Declare.
	(RtlFreeUnicodeString): Declare.
	(RtlInitEmptyUnicodeString): Declare.
	(RtlSecondsSince1970ToTime): Declare.
	(RtlInitEmptyUnicodeString): Define as inline function.
	(RtlInitCountedUnicodeString): Define as inline function.
	* path.cc (path_conv::check): New method with PUNICODE_STRING as path,
	preliminary implementation.
	(mount_info::get_mounts_here): Change to create UNICODE_STRINGs.
	Also copy cygpath prefix into UNICODE_STRING.
	(is_floppy): Drop 9x consideration.
	* path.h: Drop including ntdef.h.
	(path_conv::check): Add declaration.
	(path_conv::path_conv): Add constructor for UNICODE_STRING paths.
	* shared_info.h (mount_info::get_mounts_here): Change declaration.
	* syscalls.cc: Drop forward declaration of stat_worker.
	(stat_worke): Take path_conv as parameter.  Drop nofollow flag.
	(stat64): Create matching path_conv and call stat_worker with it.
	(lstat64): Ditto.
	* winsup.h: Include ntdef.h.
	(stat_worker): Declare.
	(readdir_get_ino): Change declaration.
@
text
@d143 2
a144 1
	      const char *w32name = ((fhandler_base *) dir->__fh)->get_win32_name ();
d148 4
a151 4
		de->d_ino = hash_path_name (de->d_ino, "/");
	      /* A drive's root dir has a trailing backslash already. */
	      else if (w32name[1] != ':' || w32name[2] != '\\' || w32name[3])
		de->d_ino = hash_path_name (de->d_ino, "\\");
@


1.118
log
@	* dir.cc (closedir): Revert change from 2007-06-29.
	* fhandler.h (dirent_valid_fd): Drop.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If opening a
	real dir, use the underlying fhandler to keep track of the directory
	handle.  In fdopendir case use original io_handle from fhandler.  Use
	fhandler's io_handle in subsequent directory functions throughout.
	Create handle non-inheritable and set close-on-exec flag.
	(readdir_get_ino): Drop dirent_isroot case.
	(fhandler_disk_file::readdir): Handle dirent_isroot case here.
	(fhandler_disk_file::rewinddir): Revert change from 2007-07-05.  Use
	NtClose instead of CloseHandle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Drop adding
	dirent_valid_fd flag.  Set close-on-exec flag.
@
text
@d135 1
a135 2
	de->d_ino = readdir_get_ino (dir,
				     ((fhandler_base *) dir->__fh)->get_name (),
@


1.117
log
@	* cygwin.din: Export fdopendir.
	* dir.cc (opendir): Call fhandler's opendir with fd set to -1.
	(fdopendir): New function.
	(seekdir64): Use dirent_info_mask.
	(rewinddir): Ditto.
	(closedir): Only release underlying file descriptor if it has been
	reserved by opendir itself.
	* fhandler.cc (fhandler_base::opendir): Accommodate new parameter.
	* fhandler.h (dirent_states): Add dirent_valid_fd and dirent_info_mask.
	(fhander_XXX::opendir): Add file descriptor parameter.  Use regparms.
	(fhandler_procnet::opendir): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	If called from fdopendir, use existing handle to re-open directory
	with valid flags.  Rename fd to cfd.  Use only if no valid incoming fd.
	(fhandler_cygdrive::opendir): Accommodate new parameter.
	* fhandler_process.cc (fhandler_process::opendir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::opendir): Drop definition.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Accommodate new
	parameter.  Only create new file descriptor entry if called from
	opendir.  Remove duplicated setting of dir->__flags.
	* posix.sgml: Add fdopendir to list of implemented Solaris functions.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/dirent.h: Declare fdopendir.
@
text
@d263 1
a263 5
  /* If the directory has been opened by fdopendir, the descriptor
     entry is used elsewhere in the application and must not be removed
     from the descriptor table. */
  if (!(dir->__flags & dirent_valid_fd))
    cygheap->fdtab.release (dir->__d_fd);
@


1.116
log
@	* dir.cc (rmdir): Move existance check in front of
	has_dot_last_component check.  Simply setting errno in latter case.
@
text
@d64 1
a64 1
    res = fh->opendir ();
d76 11
d218 1
a218 1
  dir->__flags &= (dirent_isroot | dirent_get_d_ino | dirent_set_d_ino);
d239 1
a239 1
  dir->__flags &= (dirent_isroot | dirent_get_d_ino | dirent_set_d_ino);
d263 5
a267 1
  cygheap->fdtab.release (dir->__d_fd);
@


1.115
log
@	Throughout remove all usage of wincap.access_denied_on_delete.
	* dir.cc (rmdir): Add existance check to be errno-compatible with Linux.
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop test for
	non-existent dir on 9x share.
	* syscalls.cc (unlink): Add comment.
	* wincap.cc: Remove access_denied_on_delete flag throughout.
	* wincap.h: Ditto.
@
text
@a309 2
  else if (has_dot_last_component (dir, false))
    set_errno (fh->exists () ? EINVAL : ENOENT);
d312 2
@


1.114
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procnet.o.
	* autoload.cc (GetAdaptersAddresses): Define.
	* devices.h (FH_PROCNET): Define new device.
	* devices.in (dev_procnet_storage): Add "/proc/net" entry.
	* devices.cc: Regenerate.
	* dir.cc (readdir_worker): Use isproc_dev macro.
	* dtable.cc (build_fh_pc): Add FH_PROCNET.
	* fhandler.h (class fhandler_procnet): New class.
	* fhandler_proc.cc: Add "net" subdirectory handling.
	* fhandler_procnet.cc: New file handling "/proc/net" directory.
	* path.cc (isvirtual_dev): Move to path.h.
	* path.h (isproc_dev): New macro to identify /proc files by device.
	(isvirtual_dev): Moved here.  Define using isproc_dev.
	* syscalls.cc (unlink): Use isproc_dev macro.
	* wincap.h (wincapc::has_gaa_prefixes): New element.
	(wincapc::has_gaa_on_link_prefix): New element.
	* wincap.cc: Implement above elements throughout.
	(wincapc::init): Check XP for service pack and set has_gaa_prefixes
	appropriately.
	* include/cygwin/in6.h: Include asm/byteorder.h.
@
text
@d312 2
@


1.113
log
@	* dir.cc (mkdir): Check last path component for "..".
	(rmdir): Don't check last path component for "..".
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop kludge
	which tries to allow deleting the current working directory.
	* path.cc (has_dot_last_component): Add parameter to indicate testing
	for "..".  Take trailing slash into account.
	(symlink_info::posixify): Rely on cygheap->cwd.win32 having a
	useful value.
	(cwdstuff::init): Initialize cygheap->cwd with current working
	directory.  Change to windows_system_directory afterwards.
	(cwdstuff::set): Never call SetCurrentDirectory here.  Just check
	if changing into target directory would be allowed.  Add comment to
	explain why.
	* path.h (has_dot_last_component): Declare with second parameter.
	* pinfo.cc (pinfo::zap_cwd): Remove.
	(pinfo::exit): Drop call to zap_cwd.
	* pinfo.h (class pinfo): Remove declaration of zap_cwd.
	* spawn.cc (spawn_guts): Set current working directory for non-Cygwin
	child applications.  Drop call to zap_cwd.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2006 Red Hat, Inc.
d136 1
a136 1
	      if (devn == FH_PROC || devn == FH_PROCESS || devn == FH_REGISTRY)
@


1.112
log
@white space
@
text
@d280 1
a280 1
  else if (has_dot_last_component (dir))
d310 1
a310 1
  else if (has_dot_last_component (dir))
@


1.111
log
@	* dir.cc (opendir): Fix indentation.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Move storing
	fhandler in file descriptor table to some point very late in function
	to avoid double free'ing.  Add comment to explain what happens.
	Add label free_mounts and don't forget to delete __DIR_mounts structure
	if NtOpenFile fails.
@
text
@d122 1
a122 1
	
d128 1
a128 1
        {
d137 1
a137 1
	        de->d_ino = hash_path_name (de->d_ino, "/");
@


1.110
log
@	* dir.cc (readdir_worker): Use slash as path separator when evaluating
	namehash for paths below /proc.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Use expensive
	inode number evaluation on share names.
@
text
@d64 1
a64 1
      res = fh->opendir ();
@


1.109
log
@	* dir.cc (rewinddir): Keep dirent_get_d_ino and dirent_set_d_ino flags.
@
text
@d134 4
d139 1
a139 1
	      if (w32name[1] != ':' || w32name[2] != '\\' || w32name[3])
@


1.108
log
@* dir.cc (rmdir): Reorganize check for trailing dot to return correct error
when directory does not exist.
@
text
@d224 1
a224 1
  dir->__flags &= dirent_isroot;
@


1.107
log
@* dir.cc (mkdir): Reorganize check for trailing dot to return correct error
when directory exists.
* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Remove special test for
path ending in '.'.
@
text
@a297 6
  if (has_dot_last_component (dir))
    {
      set_errno (EINVAL);
      return -1;
    }

d306 2
d310 1
@


1.106
log
@	* dir.cc (readdir_worker): Add comment about writing old 32 bit d_ino.
	* include/cygwin/version.h: Bump API minor number to 152.
	(CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO): Remove.
@
text
@a267 6
  if (has_dot_last_component (dir))
    {
      set_errno (ENOENT);
      return -1;
    }

d276 2
@


1.105
log
@	* autoload.cc (NtQueryDirectoryFile): Define.
	* dir.cc (__opendir_with_d_ino): Just call opendir.
	(opendir): Remove CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO handling.
	(readdir_worker): Only try generating d_ino if it's 0.
	Utilize namehash of directories fhandler.  Call readdir_get_ino to
	generate d_ino for "..".
	(seekdir64): Keep dirent_set_d_ino flag.
	* fhandler.h (enum dirent_states): Add dirent_get_d_ino.
	(class fhandler_disk_file): Declare new private methods readdir_helper
	and readdir_9x.
	* fhandler_disk_file.cc (path_conv::hasgood_inode): New method to
	evaluate if a filesystem has reliable inode numbers.
	(fhandler_base::fstat_by_handle): Accomodate structure member name
	change from IndexNumber to FileId.
	(fhandler_base::fstat_helper): Call hasgood_inode here.
	(fhandler_disk_file::opendir): Call fhaccess only for real files.
	Don't append '*' to __d_dirname here, move to readdir_9x.  On NT,
	open directory handle here.  Set dirent_get_d_ino and dirent_set_d_ino
	flags according to wincap and filesystem.
	(fhandler_disk_file::readdir_helper): New method to implement readdir
	postprocessing only once.
	(readdir_get_ino_by_handle): New static function.
	(readdir_get_ino): New function to centralize inode number evaluation
	in case inode number hasn't been returned by NtQueryDirectoryFile.
	(fhandler_disk_file::readdir): Move old functionality to readdir_9x.
	Call readdir_9x when on 9x/Me.  Implement NT specific readdir here.
	(fhandler_disk_file::readdir_9x): Move 9x specific readdir here.
	(fhandler_disk_file::seekdir): Accomodate new NT readdir method.
	(fhandler_disk_file::closedir): Ditto.
	(fhandler_cygdrive::fstat): Set d_ino to namehash. Add comment.
	(fhandler_cygdrive::opendir): Call get_namehash to prepare later
	correct evaluation of d_ino.
	(fhandler_cygdrive::readdir): Replace recursion with loop. Evaluate
	drive's d_ino by calling readdir_get_ino.
	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent_saw_dot and
	dirent_saw_dot_dot to avoid seeing . and .. entries twice.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
	* ntdll.h (STATUS_INVALID_PARAMETER): New define.
	(STATUS_INVALID_LEVEL): New define.
	(struct _FILE_INTERNAL_INFORMATION): Rename member IndexNumber to
	FileId (as in Nebbitt).
	* path.h (path_conv::hasgood_inode): Now implemented in
	fhandler_disk_file.cc.
	* wincap.h (wincaps::has_fileid_dirinfo): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (readdir_get_ino): Add declaration.
	* include/sys/dirent.h (struct dirent): Slightly rename structure
	members to accomodate changes.
	Remove __USE_EXPENSIVE_CYGWIN_D_INO handling and declaration of
	__opendir_with_d_ino.
@
text
@d141 2
@


1.104
log
@* dir.cc (readdir_worker): Turn off expensive inode calculation.
@
text
@d45 2
d50 1
a50 4
  DIR *res = opendir (name);
  if (res)
    res->__flags |= dirent_set_d_ino;
  return res;
d71 1
a71 3
  if (res)
    res->__flags |= CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO ? dirent_set_d_ino : 0;
  else if (fh)
d89 1
d110 1
a110 1
  if (!res)
d112 15
a126 10
      /* Compute d_ino by combining filename hash with the directory hash
	 (which was stored in dir->__d_dirhash when opendir was called). */
      if (de->d_name[0] != '.')
	/* relax */;
      else if (de->d_name[1] == '\0')
	dir->__flags |= dirent_saw_dot;
      else if (de->d_name[1] == '.' && de->d_name[2] == '\0')
	dir->__flags |= dirent_saw_dot_dot;
      if (!(dir->__flags & dirent_set_d_ino))
	de->__dirent_internal = 0;
d128 4
a131 10
	{
#if 0
	  size_t len = strlen (dir->__d_dirname) + strlen (de->d_name);
	  char *path = (char *) alloca (len);
	  char *p = strchr (strcpy (path, dir->__d_dirname), '\0');
	  strcpy (p - 1, de->d_name);
	  struct __stat64 st;
	  if (lstat64 (path, &st) == 0)
	    de->__dirent_internal = st.st_ino;
	  else
d133 5
a137 4
#endif
	      de->__dirent_internal = hash_path_name (0, dir->__d_dirname);
	      de->__dirent_internal = hash_path_name (de->__dirent_internal, de->d_name);
#if 0
a138 1
#endif
a139 1
      de->__dirent_internal1 = de->__dirent_internal;
d141 1
d201 1
a201 1
  dir->__flags &= (dirent_isroot | dirent_set_d_ino);
@


1.103
log
@* include/cygwin/version.h: Bump API minor number to 151.
* dir.cc (__opendir_with_d_ino): New function.
(opendir): Set flag if we should be calculating inodes.
(readdir_worker): Calculate d_ino by calling stat if the user has asked for it.
(seekdir64): Maintain all persistent flag settings.
* fhandler.h (dirent_states): Add dirent_set_d_ino.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Reflect changes to
dirent structure.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* include/sys/dirent.h (struct dirent): Coalesce two similar structures.
Remove all threads of the apparently highly confusing references to inodes.
Add support for calculating a real inode if __USE_EXPENSIVE_CYGWIN_D_INO is
defined.
@
text
@d126 1
d136 1
d139 1
d141 1
@


1.102
log
@* dir.cc (readdir_worker): Fill in invalid fields with -1.  Accommodate name
change from __ino32 to __invalid_ino32.
* include/sys/dirent.h (__invalid_ino32): Rename from __ino32.  Don't define
unused d_type macros.
@
text
@d42 10
a51 1
  return dir->__d_dirent->d_fd;
d73 1
a73 1
    /* nothing */;
d112 1
a112 15
  if (res)
    /* error return */;
  else if (!CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO)
    {
      de->__invalid_d_ino = (ino_t) -1;
      de->__invalid_ino32 = (uint32_t) -1;
      if (de->d_name[0] == '.')
	{
	  if (de->d_name[1] == '\0')
	     dir->__flags |= dirent_saw_dot;
	   else if (de->d_name[1] == '.' && de->d_name[2] == '\0')
	     dir->__flags |= dirent_saw_dot_dot;
	 }
    }
  else
d116 9
a124 1
      if (de->d_name[0] == '.')
d126 7
a132 7
	  if (de->d_name[1] == '\0')
	    {
	      de->__invalid_d_ino = dir->__d_dirhash;
	      dir->__flags |= dirent_saw_dot;
	    }
	  else if (de->d_name[1] != '.' || de->d_name[2] != '\0')
	    goto hashit;
d135 2
a136 13
	      dir->__flags |= dirent_saw_dot_dot;
	      char *p, up[strlen (dir->__d_dirname) + 1];
	      strcpy (up, dir->__d_dirname);
	      if (!(p = strrchr (up, '\\')))
		goto hashit;
	      *p = '\0';
	      if (!(p = strrchr (up, '\\')))
		de->__invalid_d_ino = hash_path_name (0, ".");
	      else
		{
		  *p = '\0';
		  de->__invalid_d_ino = hash_path_name (0, up);
		}
d139 1
a139 7
      else
	{
      hashit:
	  __ino64_t dino = hash_path_name (dir->__d_dirhash, "\\");
	  de->__invalid_d_ino = hash_path_name (dino, de->d_name);
	}
      de->__invalid_ino32 = de->__invalid_d_ino;	// for legacy applications
d141 1
d200 1
a200 1
  dir->__flags &= dirent_isroot;
d245 1
a245 1
  cygheap->fdtab.release (dir->__d_dirent->d_fd);
@


1.102.2.1
log
@Only use name change patch in dir.cc.
@
text
@d107 2
a108 2
      de->__invalid_d_ino = (ino_t) 0;
      de->__invalid_ino32 = (uint32_t) 0;
@


1.101
log
@* dir.cc (readdir_worker): Minor code cleanup.
* fhandler_console.cc (beep): Use a more Windows-generic wav file if the beep
is missing.  Use a more foolproof way to find out whether we should be
recreating the missing key.
* registry.h (reg_key::_disposition): New field.
(reg_key::created): New function.
* registry.cc (reg_key::reg_key): Set _disposition to zero by default.
(reg_key::build_key): Fill in _disposition field.
@
text
@d107 2
a108 2
      de->__invalid_d_ino = 0;
      de->__ino32 = 0;
d153 1
a153 1
      de->__ino32 = de->__invalid_d_ino;	// for legacy applications
@


1.100
log
@* dir.cc (readdir_worker): Ensure that saw_dot flags are updated when not
handling inodes.
@
text
@d103 52
a154 51
  if (!res)
    if (!CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO)
      {
	de->__invalid_d_ino = 0;
	de->__ino32 = 0;
	if (de->d_name[0] == '.')
	  {
	    if (de->d_name[1] == '\0')
	       dir->__flags |= dirent_saw_dot;
	     else if (de->d_name[1] == '.' && de->d_name[2] == '\0')
	       dir->__flags |= dirent_saw_dot_dot;
	   }
      }
    else
      {
	/* Compute d_ino by combining filename hash with the directory hash
	   (which was stored in dir->__d_dirhash when opendir was called). */
	if (de->d_name[0] == '.')
	  {
	    if (de->d_name[1] == '\0')
	      {
		de->__invalid_d_ino = dir->__d_dirhash;
		dir->__flags |= dirent_saw_dot;
	      }
	    else if (de->d_name[1] != '.' || de->d_name[2] != '\0')
	      goto hashit;
	    else
	      {
		dir->__flags |= dirent_saw_dot_dot;
		char *p, up[strlen (dir->__d_dirname) + 1];
		strcpy (up, dir->__d_dirname);
		if (!(p = strrchr (up, '\\')))
		  goto hashit;
		*p = '\0';
		if (!(p = strrchr (up, '\\')))
		  de->__invalid_d_ino = hash_path_name (0, ".");
		else
		  {
		    *p = '\0';
		    de->__invalid_d_ino = hash_path_name (0, up);
		  }
	      }
	  }
	else
	  {
	hashit:
	    __ino64_t dino = hash_path_name (dir->__d_dirhash, "\\");
	    de->__invalid_d_ino = hash_path_name (dino, de->d_name);
	  }
	de->__ino32 = de->__invalid_d_ino;	// for legacy applications
      }
@


1.99
log
@* include/sys/dirent.h: Change __deprecated_d_ino to __invalid_d_ino throughout
to make things a little clearer.
* dir.cc (readdir_worker): Reflect above change.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d108 7
d118 1
a118 1
	/* Compute __invalid_d_ino by combining filename hash with the directory hash
@


1.98
log
@* dir.cc (readdir_workdir): Only fill out d_ino when linked into older app.
* include/cygwin/version.h: Bump api minor number to 147, reflecting
obsolescence of d_ino.
(CYGWIN_VERSION_USER_API_VERSION_COMBINED): New convenience macro.
(CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO): New convenience macro.
@
text
@d106 1
a106 1
	de->__deprecated_d_ino = 0;
d111 1
a111 1
	/* Compute __deprecated_d_ino by combining filename hash with the directory hash
d117 1
a117 1
		de->__deprecated_d_ino = dir->__d_dirhash;
d131 1
a131 1
		  de->__deprecated_d_ino = hash_path_name (0, ".");
d135 1
a135 1
		    de->__deprecated_d_ino = hash_path_name (0, up);
d143 1
a143 1
	    de->__deprecated_d_ino = hash_path_name (dino, de->d_name);
d145 1
a145 1
	de->__ino32 = de->__deprecated_d_ino;	// for legacy applications
@


1.97
log
@revert accidental checkin
@
text
@d27 2
d104 43
a146 37
    {
      /* Compute d_ino by combining filename hash with the directory hash
	 (which was stored in dir->__d_dirhash when opendir was called). */
      if (de->d_name[0] == '.')
	{
	  if (de->d_name[1] == '\0')
	    {
	      de->d_ino = dir->__d_dirhash;
	      dir->__flags |= dirent_saw_dot;
	    }
	  else if (de->d_name[1] != '.' || de->d_name[2] != '\0')
	    goto hashit;
	  else
	    {
	      dir->__flags |= dirent_saw_dot_dot;
	      char *p, up[strlen (dir->__d_dirname) + 1];
	      strcpy (up, dir->__d_dirname);
	      if (!(p = strrchr (up, '\\')))
		goto hashit;
	      *p = '\0';
	      if (!(p = strrchr (up, '\\')))
		de->d_ino = hash_path_name (0, ".");
	      else
		{
		  *p = '\0';
		  de->d_ino = hash_path_name (0, up);
		}
	    }
	}
      else
	{
      hashit:
	  __ino64_t dino = hash_path_name (dir->__d_dirhash, "\\");
	  de->d_ino = hash_path_name (dino, de->d_name);
	}
      de->__ino32 = de->d_ino;	// for legacy applications
    }
@


1.96
log
@Remove unneeded whitespace.
* cygtls.cc (_cygtls::set_state): Delete.
(_cygtls::reset_exception): Ditto.
(_cygtls::init_thread): Set initialized state directly here.
(_cygtls::push): Remove exception argument.  Don't treat exceptions specially.
* cygtls.h (_cygtls::push): Ditto.
(_cygtls::isinitialized): Don't treat exceptions specially.
(_cygtls::reset_exception): Delete.
(_cygtls::set_state): Ditto.
(_cygtls::handle_exceptions): Don't push ebp on the stack prior to calling
sig_send.  Just set incyg instead.
(_cygtls::interrupt_setup): Accommodate _cygtls::push argument change.
(_cygtls::interrupt_now): Ditto.
(setup_handler): Don't treat exceptions specially.
* gendef (longjmp): Always zero incyg flag.
@
text
@a101 3
#if 1
    de->d_ino = 0;
#else
a138 1
#endif
@


1.95
log
@* dir.cc (rmdir): Eliminate nonsensical code.
* fork.cc (fork): Move exit debug_printf to last statement.
@
text
@d102 3
d142 1
@


1.94
log
@* dir.cc (mkdir): Abandon use of PC_WRITABLE.
(rmdir): Ditto.
* path.h (PC_WRITABLE): Delete.
* path.cc (path_conv::check): Remove PC_WRITABLE accommodations.  Revisit
later.
@
text
@d308 1
a308 4
      if (fh->error ())
	set_errno (EROFS);
      else
	set_errno (fh->error ());
@


1.93
log
@	* dir.cc (mkdir): Check for trailing /. or /.. component.
	(rmdir): Ditto.
	* path.cc (has_dot_last_component): New function.
	* path.h (has_dot_last_component): Add declaration.
@
text
@d268 1
a268 1
  if (!(fh = build_fh_name (dir, NULL, PC_SYM_NOFOLLOW | PC_WRITABLE)))
d302 1
a302 1
  if (!(fh = build_fh_name (dir, NULL, PC_SYM_NOFOLLOW | PC_WRITABLE)))
d308 4
a311 1
      set_errno (fh->error ());
@


1.92
log
@*dir.cc (readdir_r): Invert sense on error-test.
@
text
@d258 10
d292 10
@


1.91
log
@* dir.cc (readdir_worker): Make static.  Only add '.' and '..' when readdir
fails due to ENMFILE.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Only close handle on
error != ENMFILE.
@
text
@d163 1
a163 1
      if (res != ENMFILE)
@


1.90
log
@* cygerrno.h (geterrno_from_win_error): Change declaration to default to using
GetLastError and EACCESS.
* cygwin.din: Export readdir_r.
* include/cygwin/version.h: Bump API version number to 138.
* syscalls.cc (readdir_worker): New function, renamed from old readdir()
function.
(readdir): Use readdir_worker.
(readdir_r): New function.
* fhandler.h (fhandler_base::readdir): Accommodate second argument indicating
dirent buffer.
(fhandler_disk_file::readdir): Ditto.
(fhandler_cygdrive::readdir): Ditto.
(fhandler_proc::readdir): Ditto.
(fhandler_netdrive::readdir): Ditto.
(fhandler_registry::readdir): Ditto.
(fhandler_process::readdir): Ditto.
* fhandler.cc (fhandler_base::readdir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
* fhandler_cygdrive.cc (fhandler_cygdrive::readdir): Ditto.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
@
text
@d68 1
a68 1
int
d83 1
a83 1
  if (res)
@


1.89
log
@* fhandler.h (dirent_states): Add dirent_isroot, dirent_saw_cygdrive,
dirent_saw_dev.
* dir.cc (opendir): Don't zero __flags here.  Push that responsibility to
opendir methods.
(seekdir): Preserve dirent_isrrot in __flags.
(rewinddir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set dirent_isroot
appropriately.
(fhandler_disk_file::readdir): Fill in "cygdrive" and "dev" if it is the root
dir and they are missing.
* fhandler_process.cc (fhandler_process::opendir): Set __flags here.
* fhandler_virtual.cc (fhandler_virtual::opendir): Set __flags here.
@
text
@d68 2
a69 3
/* readdir: POSIX 5.1.2.1 */
extern "C" struct dirent *
readdir (DIR *dir)
d72 2
a73 2
  if (efault.faulted (EFAULT))
    return NULL;
a76 1
      set_errno (EBADF);
d78 1
a78 1
      return NULL;
d81 1
a81 1
  dirent *res = ((fhandler_base *) dir->__fh)->readdir (dir);
d83 1
a83 1
  if (!res)
d87 1
a87 2
	  res = dir->__d_dirent;
	  strcpy (res->d_name, ".");
d90 1
d94 1
a94 2
	  res = dir->__d_dirent;
	  strcpy (res->d_name, "..");
d97 1
d101 1
a101 1
  if (res)
d105 1
a105 1
      if (res->d_name[0] == '.')
d107 1
a107 1
	  if (res->d_name[1] == '\0')
d109 1
a109 1
	      dir->__d_dirent->d_ino = dir->__d_dirhash;
d112 1
a112 1
	  else if (res->d_name[1] != '.' || res->d_name[2] != '\0')
d123 1
a123 1
		dir->__d_dirent->d_ino = hash_path_name (0, ".");
d127 1
a127 1
		  dir->__d_dirent->d_ino = hash_path_name (0, up);
d135 1
a135 1
	  dir->__d_dirent->d_ino = hash_path_name (dino, res->d_name);
d137 28
a164 1
      res->__ino32 = dir->__d_dirent->d_ino;	// for legacy applications
@


1.88
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d62 1
a62 1
    res->__flags = 0;
d172 1
a172 1
  dir->__flags = 0;
d193 1
a193 1
  dir->__flags = 0;
@


1.87
log
@* fhandler.h (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file:mkdir): New method.
(fhandler_disk_file:rmdir): Ditto.
* dir.cc (mkdir): Implement with fhandlers.
(rmdir): Ditto.
* fhandler.cc (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file::mkdir): New method.
(fhandler_disk_file::rmdir): Ditto.

fhandler_random.cc: white space.
@
text
@d26 1
d31 2
a32 1
  if (check_null_invalid_struct_errno (dir))
d72 2
a73 1
  if (check_null_invalid_struct_errno (dir))
d147 2
a148 1
  if (check_null_invalid_struct_errno (dir))
d166 2
a167 1
  if (check_null_invalid_struct_errno (dir))
d187 2
a188 1
  if (check_null_invalid_struct_errno (dir))
d201 2
a202 1
  if (check_null_invalid_struct_errno (dir))
@


1.86
log
@Remove PC_FULL from path_conv usage throughout.
* path.h (enum pathconv_arg): Change PC_FULL to PC_NOUILL.
* path.cc (path_conv::check): Test for PC_NOFULL rather than !PC_FULL.
(cygwin_conv_to_win32_path): Use PC_NOFULL to force non-absolute path.
@
text
@d224 1
a224 2
  SECURITY_ATTRIBUTES sa = sec_none_nih;
  security_descriptor sd;
d226 2
a227 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW | PC_WRITABLE);
d229 1
a229 1
  if (real_dir.error)
d231 2
a232 2
      set_errno (real_dir.case_clash ? ECASECLASH : real_dir.error);
      goto done;
d234 3
d238 1
a238 22
  nofinalslash (real_dir.get_win32 (), real_dir.get_win32 ());

  if (allow_ntsec && real_dir.has_acls ())
    set_security_attribute (S_IFDIR | ((mode & 07777) & ~cygheap->umask),
			    &sa, sd);

  if (CreateDirectoryA (real_dir.get_win32 (), &sa))
    {
      if (!allow_ntsec && allow_ntea)
	set_file_attribute (false, NULL, real_dir.get_win32 (),
			    S_IFDIR | ((mode & 07777) & ~cygheap->umask));
#ifdef HIDDEN_DOT_FILES
      char *c = strrchr (real_dir.get_win32 (), '\\');
      if ((c && c[1] == '.') || *real_dir.get_win32 () == '.')
	SetFileAttributes (real_dir.get_win32 (), FILE_ATTRIBUTE_HIDDEN);
#endif
      res = 0;
    }
  else
    __seterrno ();

done:
d248 1
d250 2
a251 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW | PC_WRITABLE);
d253 1
a253 7
  if (real_dir.error)
    set_errno (real_dir.error);
  else if (!real_dir.exists ())
    set_errno (ENOENT);
  else if  (!real_dir.isdir ())
    set_errno (ENOTDIR);
  else
d255 2
a256 61
      /* Even own directories can't be removed if R/O attribute is set. */
      if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
	SetFileAttributes (real_dir,
			   (DWORD) real_dir & ~FILE_ATTRIBUTE_READONLY);

      for (bool is_cwd = false; ; is_cwd = true)
	{
	  DWORD err;
	  int rc = RemoveDirectory (real_dir);
	  DWORD att = GetFileAttributes (real_dir);

	  /* Sometimes smb indicates failure when it really succeeds, so check for
	     this case specifically. */
	  if (rc || att == INVALID_FILE_ATTRIBUTES)
	    {
	      /* RemoveDirectory on a samba drive doesn't return an error if the
		 directory can't be removed because it's not empty. Checking for
		 existence afterwards keeps us informed about success. */
	      if (att == INVALID_FILE_ATTRIBUTES)
		{
		  res = 0;
		  break;
		}
	      err = ERROR_DIR_NOT_EMPTY;
	    }
	  else
	    err = GetLastError ();

	  /* This kludge detects if we are attempting to remove the current working
	     directory.  If so, we will move elsewhere to potentially allow the
	     rmdir to succeed.  This means that cygwin's concept of the current working
	     directory != Windows concept but, hey, whaddaregonnado?
	     Note that this will not cause something like the following to work:
		     $ cd foo
		     $ rmdir .
	     since the shell will have foo "open" in the above case and so Windows will
	     not allow the deletion. (Actually it does on 9X.)
	     FIXME: A potential workaround for this is for cygwin apps to *never* call
	     SetCurrentDirectory. */

	  if (strcasematch (real_dir, cygheap->cwd.win32)
	      && !strcasematch ("c:\\", cygheap->cwd.win32)
	      && !is_cwd
	      && SetCurrentDirectory ("c:\\"))
	    continue;

	  /* On 9X ERROR_ACCESS_DENIED is returned
	     if you try to remove a non-empty directory. */
	  if (err == ERROR_ACCESS_DENIED
	      && wincap.access_denied_on_delete ())
	    err = ERROR_DIR_NOT_EMPTY;

	  __seterrno_from_win_error (err);

	  /* Directory still exists, restore its characteristics. */
	  if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
	    SetFileAttributes (real_dir, real_dir);
	  if (is_cwd)
	    SetCurrentDirectory (real_dir);
	  break;
	}
d258 3
d262 1
@


1.85
log
@* cygtls.cc (_cygtls::remove): Eliminate compiler warning.
* dir.cc (mkdir): Check path for writability.
(rmdir): Ditto.  Remove check for special directories.
* path.cc (path_conv::check): Set PATH_RO for virtual devices.  Set error if
read-only and asked for writability.
* path.h (pathconv_arg): Add PC_WRITABLE.
(path_types): Add PATH_RO.
(path_conv::isro): Add (currently unused) check for read-only filesystem.
Return "ENOSHARE" when we know a share doesn't exist.
* include/sys/mount.h: Add MOUNT_RO flag.
* autoload.cc (WNetGetResourceInformationA): Import.
* fhandler_netdrive.cc (fhandler_netdrive::exists): Detect actual existence of
remote system rather than always assuming that it exists.
@
text
@d48 1
a48 1
  fh = build_fh_name (name, NULL, PC_SYM_FOLLOW | PC_FULL);
d267 1
a267 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW | PC_FULL | PC_WRITABLE);
@


1.84
log
@* dir.cc: Rename opendir_* to dirent_* throughout.
(opendir_states): Move and rename.
* fhandler.h (dirent_states): to here.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Use raw readdir when
skipping through entries since it is keeping track of "." and "..".
(fhandler_cygdrive::seekdir): Use fhandler_disk_file::readdir to do everything.
* fhandler_virtual.cc (fhandler_virtual::opendir): Set flag indicating that we
provide .  and ..
(fhandler_virtual::seekdir): Ditto.
(fhandler_virtual::rewinddir): Ditto.
* fhandler_registry.cc (fhandler_registry::rewinddir): Ditto.
@
text
@d227 1
a227 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW);
a265 1
  DWORD devn;
d267 1
a267 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW | PC_FULL);
a270 3
  else if ((devn = real_dir.get_devn ()) == FH_PROC || devn == FH_REGISTRY
	   || devn == FH_PROCESS)
    set_errno (EROFS);
@


1.83
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@a40 8
enum opendir_states
{
  opendir_ok = 0,
  opendir_saw_dot = 1,
  opendir_saw_dot_dot = 2,
  opendir_saw_eof = 4
};

d84 1
a84 1
      if (!(dir->__flags & opendir_saw_dot))
d88 1
a88 1
	  dir->__flags |= opendir_saw_dot;
d91 1
a91 1
      else if (!(dir->__flags & opendir_saw_dot_dot))
d95 1
a95 1
	  dir->__flags |= opendir_saw_dot_dot;
d109 1
a109 1
	      dir->__flags |= opendir_saw_dot;
d115 1
a115 1
	      dir->__flags |= opendir_saw_dot_dot;
@


1.82
log
@	* dir.cc (writable_directory): Remove.
	(mkdir): Remove call to writable_directory.
	* syscalls.cc (unlink): Ditto.
	(rename): Ditto.
	* winsup.h (writable_directory): Remove declaration.
@
text
@d295 1
a295 1
        {
d307 2
a308 2
	      if (att == INVALID_FILE_ATTRIBUTES) 
	        {
d330 1
a330 1
	      && !strcasematch ("c:\\", cygheap->cwd.win32) 
d334 2
a335 2
	  
	  /* On 9X ERROR_ACCESS_DENIED is returned 
d340 1
a340 1
	  
d342 1
a342 1
	  
@


1.81
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@a26 33
/* Cygwin internal */
/* Return whether the directory of a file is writable.  Return 1 if it
   is.  Otherwise, return 0, and set errno appropriately.  */
int __stdcall
writable_directory (const char *file)
{
#if 0
  char dir[strlen (file) + 1];

  strcpy (dir, file);

  const char *usedir;
  char *slash = strrchr (dir, '\\');
  if (slash == NULL)
    usedir = ".";
  else if (slash == dir)
    {
      usedir = "\\";
    }
  else
    {
      *slash = '\0';
      usedir = dir;
    }

  int acc = access (usedir, W_OK);

  return acc == 0;
#else
  return 1;
#endif
}

a243 2
  if (! writable_directory (real_dir.get_win32 ()))
    goto done;
@


1.80
log
@	* dir.cc (mkdir): Call set_file_attribute with additional handle
	argument.
	* fhandler.cc (fhandler_base::fchmod): New method.
	* fhandler.h: Declare fchmod method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): New method.
	(fhandler_base::open_fs): Call set_file_attribute with additional
	handle argument.
	* fhandler_virtual.cc (fhandler_virtual::fchmod): New method.
	* path.cc (symlink_worker): Call set_file_attribute with additional
	handle argument.
	* security.cc (get_nt_object_security): New function.
	(get_nt_object_attribute): Call get_nt_object_security.
	(set_nt_attribute): Add handle argument.  Call get_nt_object_security
	first, read_sd only if that fails.
	(set_file_attribute): Add handle argument.
	* security.h (set_file_attribute): Declare with additional handle
	argument.
	* syscalls.cc (stat_suffixes): Move to beginning of file.
	(chown_worker): Call set_file_attribute with additional handle argument.
	(chmod): Reorganize to call fhandler's fchmod method eventually.
	(fchmod): Ditto.
@
text
@d287 1
a287 1
	set_file_attribute (real_dir.has_acls (), NULL, real_dir.get_win32 (),
@


1.79
log
@2004-03-19  Pierre Humblet <pierre.humblet@@ieee.org>

        * dir.cc (rmdir): Reorganize error handling to reduce indentation.
@
text
@d287 1
a287 1
	set_file_attribute (real_dir.has_acls (), real_dir.get_win32 (),
@


1.78
log
@2004-03-14  Pierre Humblet <pierre.humblet@@ieee.org>

        * dir.cc (rmdir): Construct real_dir with flag PC_FULL.
        Use a loop instead of recursion to handle the current directory.
@
text
@d331 1
d342 6
a347 4
	      if (att != INVALID_FILE_ATTRIBUTES)
		set_errno (ENOTEMPTY);
	      else
		res = 0;
d350 13
a362 25
	    {
	      /* This kludge detects if we are attempting to remove the current working
		 directory.  If so, we will move elsewhere to potentially allow the
		 rmdir to succeed.  This means that cygwin's concept of the current working
		 directory != Windows concept but, hey, whaddaregonnado?
		 FIXME: A potential workaround for this is for cygwin apps to *never* call
		 SetCurrentDirectory. */
	      if (strcasematch (real_dir, cygheap->cwd.win32)
		  && !strcasematch ("c:\\", cygheap->cwd.win32) && !is_cwd)
	        {
		  DWORD err = GetLastError ();
		  if (!SetCurrentDirectory ("c:\\"))
		    SetLastError (err);
		  else 
		    continue;
		}
	      if (res)
	        {
		  if (GetLastError () != ERROR_ACCESS_DENIED
		      || !wincap.access_denied_on_delete ())
		    __seterrno ();
		  else
		    set_errno (ENOTEMPTY);	/* On 9X ERROR_ACCESS_DENIED is
						   returned if you try to remove a
						   non-empty directory. */
d364 19
a382 7
		  /* If directory still exists, restore R/O attribute. */
		  if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
		    SetFileAttributes (real_dir, real_dir);
		  if (is_cwd)
		    SetCurrentDirectory (cygheap->cwd.win32);
		}
	    }
d386 1
@


1.77
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@d311 1
a311 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW);
d329 4
a332 2
      int rc = RemoveDirectory (real_dir);
      DWORD att = GetFileAttributes (real_dir);
d334 3
a336 27
      /* Sometimes smb indicates failure when it really succeeds, so check for
	 this case specifically. */
      if (rc || att == INVALID_FILE_ATTRIBUTES)
	{
	  /* RemoveDirectory on a samba drive doesn't return an error if the
	     directory can't be removed because it's not empty. Checking for
	     existence afterwards keeps us informed about success. */
	  if (att != INVALID_FILE_ATTRIBUTES)
	    set_errno (ENOTEMPTY);
	  else
	    res = 0;
	}
      else
	{
	  /* This kludge detects if we are attempting to remove the current working
	     directory.  If so, we will move elsewhere to potentially allow the
	     rmdir to succeed.  This means that cygwin's concept of the current working
	     directory != Windows concept but, hey, whaddaregonnado?
	     Note that this will not cause something like the following to work:
		     $ cd foo
		     $ rmdir .
	     since the shell will have foo "open" in the above case and so Windows will
	     not allow the deletion.
	     FIXME: A potential workaround for this is for cygwin apps to *never* call
	     SetCurrentDirectory. */
	  if (strcasematch (real_dir, cygheap->cwd.win32)
	      && !strcasematch ("c:\\", cygheap->cwd.win32))
d338 7
a344 5
	      DWORD err = GetLastError ();
	      if (!SetCurrentDirectory ("c:\\"))
		SetLastError (err);
	      else if ((res = rmdir (dir)))
		SetCurrentDirectory (cygheap->cwd.win32);
d346 1
a346 1
	  if (res)
d348 24
a371 7
	      if (GetLastError () != ERROR_ACCESS_DENIED
		  || !wincap.access_denied_on_delete ())
		__seterrno ();
	      else
		set_errno (ENOTEMPTY);	/* On 9X ERROR_ACCESS_DENIED is
					       returned if you try to remove a
					       non-empty directory. */
d373 6
a378 3
	      /* If directory still exists, restore R/O attribute. */
	      if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
		SetFileAttributes (real_dir, real_dir);
d380 1
a382 1

@


1.76
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d266 1
d282 1
a282 1
			    &sa, alloca (4096), 4096);
@


1.75
log
@* dir.cc (rmdir): Add more samba workarounds.
@
text
@d22 1
a23 1
#include "path.h"
a86 1
  path_conv pc;
d89 1
a89 2
  fh = cygheap->fdtab.build_fhandler_from_name (-1, name, NULL, pc,
						PC_SYM_FOLLOW | PC_FULL, NULL);
d92 2
a93 2
  else if (pc.exists ())
      res = fh->opendir (pc);
@


1.74
log
@* fhandler_disk_file.cc (num_entries): Take .  and ..  into account if they do
not exist since cygwin simulates them.
(fhandler_cygdrive::fstat): Ditto.
(fhandler_cygdrive::readdir): Don't do any specific tests on __d_position when
seeing if a drive exists.
@
text
@d330 6
a335 1
      if (RemoveDirectory (real_dir))
d340 1
a340 1
	  if (GetFileAttributes (real_dir) != INVALID_FILE_ATTRIBUTES)
@


1.73
log
@* dir.cc (readdir): Reinstate setting of old ino field for legacy applications.
* dirent.h (dirent): Rename unused field to __ino32.
* passwd.cc (getpwnam_r): Initialize pw_comment field.
@
text
@d132 1
d139 1
@


1.72
log
@Throughout, remove __d_u.__d_data fields from DIR structure.
* include/sys/dirent.h (dirent): Remvoe old_d_ino.
(DIR): Make __d_dirhash a 64 bit value.  Remove __d_data and __d_u.  Add
__flags.
* dir.cc (opendir_states): New enum.
(opendir): Clear new DIR __flags field.
(readdir): Fill in '.' and '..' entries if we hit EOF and we haven't seen them
already.  Nuke setting of old_d_ino.
(rewinddir): Reset DIR __flags field.
(seekdir64): Ditto.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove special
handling of "." and ".." since they are now handled automatically.
@
text
@d177 1
@


1.71
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d74 8
d102 3
a104 1
  if (!res && fh)
d123 17
a139 1
  dirent *res = ((fhandler_base *) dir->__d_u.__d_data.__fh)->readdir (dir);
d148 4
a151 1
	    dir->__d_dirent->d_ino = dir->__d_dirhash;
d156 1
a177 1
  dir->__d_dirent->old_d_ino = dir->__d_dirent->d_ino;	// just truncate
d189 1
a189 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->telldir (dir);
d207 2
a208 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->seekdir (dir, loc);
d227 2
a228 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->rewinddir (dir);
d248 1
a248 1
  int res = ((fhandler_base *) dir->__d_u.__d_data.__fh)->closedir (dir);
@


1.70
log
@	Replace ino_t by __ino64_t throughout.
@
text
@a14 1
#include <errno.h>
@


1.69
log
@* dir.cc (readdir): Fill out new old_d_ino field.
* fhandler.h (fhandler_base::namehash): Define as ino_t.
(fhandler_base::get_namehash): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Accommodate new 64
bit st_ino.
* fhandler_socket.cc (fhandler_socket::fstat): Ditto.
* path.cc (hash_path_name): Return ino_t.
* syscalls.cc (stat64_to_stat32): Convert 64 bit inode to 32 bit.
* winsup.h (hash_path_name): Declare as returning ino_t.
* include/cygwin/stat.h (__stat32): Use 32 bit st_ino.
(__stat64): Use 64 bit st_ino.
* include/cygwin/types.h (__ino64_t): Define.
(__ino32_t): Ditto.
(ino_t): Define appropriately.
@
text
@d145 1
a145 1
	  ino_t dino = hash_path_name (dir->__d_dirhash, "\\");
@


1.68
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@d149 1
@


1.67
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d152 1
a152 1
extern "C" __off64_t
d164 1
a164 1
extern "C" __off32_t
d171 1
a171 1
seekdir64 (DIR *dir, __off64_t loc)
d183 1
a183 1
seekdir (DIR *dir, __off32_t loc)
d185 1
a185 1
  seekdir64 (dir, (__off64_t)loc);
@


1.67.16.1
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d23 1
a24 1
#include "fhandler.h"
d80 1
d83 2
a84 1
  fh = build_fh_name (name, NULL, PC_SYM_FOLLOW | PC_FULL);
d87 2
a88 2
  else if (fh->exists ())
      res = fh->opendir ();
@


1.67.16.2
log
@merge from trunk
@
text
@d150 1
a150 1
extern "C" _off64_t
d162 1
a162 1
extern "C" _off_t
d169 1
a169 1
seekdir64 (DIR *dir, _off64_t loc)
d181 1
a181 1
seekdir (DIR *dir, _off_t loc)
d183 1
a183 1
  seekdir64 (dir, (_off64_t)loc);
@


1.67.16.3
log
@merge from trunk
@
text
@d143 1
a143 1
	  __ino64_t dino = hash_path_name (dir->__d_dirhash, "\\");
a146 1
  dir->__d_dirent->old_d_ino = dir->__d_dirent->d_ino;	// just truncate
@


1.67.16.4
log
@merge from trunk
@
text
@d15 1
@


1.67.16.5
log
@merge from trunk
@
text
@a73 8
enum opendir_states
{
  opendir_ok = 0,
  opendir_saw_dot = 1,
  opendir_saw_dot_dot = 2,
  opendir_saw_eof = 4
};

d92 1
a92 3
  if (res)
    res->__flags = 0;
  else if (fh)
d111 1
a111 17
  dirent *res = ((fhandler_base *) dir->__fh)->readdir (dir);

  if (!res)
    {
      if (!(dir->__flags & opendir_saw_dot))
	{
	  res = dir->__d_dirent;
	  strcpy (res->d_name, ".");
	  dir->__flags |= opendir_saw_dot;
	}
      else if (!(dir->__flags & opendir_saw_dot_dot))
	{
	  res = dir->__d_dirent;
	  strcpy (res->d_name, "..");
	  dir->__flags |= opendir_saw_dot_dot;
	}
    }
d120 1
a120 4
	    {
	      dir->__d_dirent->d_ino = dir->__d_dirhash;
	      dir->__flags |= opendir_saw_dot;
	    }
a124 1
	      dir->__flags |= opendir_saw_dot_dot;
a144 1
      res->__ino32 = dir->__d_dirent->d_ino;	// for legacy applications
d146 1
d158 1
a158 1
  return ((fhandler_base *) dir->__fh)->telldir (dir);
d176 1
a176 2
  dir->__flags = 0;
  return ((fhandler_base *) dir->__fh)->seekdir (dir, loc);
d195 1
a195 2
  dir->__flags = 0;
  return ((fhandler_base *) dir->__fh)->rewinddir (dir);
d215 1
a215 1
  int res = ((fhandler_base *) dir->__fh)->closedir (dir);
@


1.67.16.6
log
@merge from trunk
@
text
@a129 1
	  dir->__d_position++;
a135 1
	  dir->__d_position++;
@


1.67.16.7
log
@merge from trunk
@
text
@d328 1
a328 6
      int rc = RemoveDirectory (real_dir);
      DWORD att = GetFileAttributes (real_dir);

      /* Sometimes smb indicates failure when it really succeeds, so check for
	 this case specifically. */
      if (rc || att == INVALID_FILE_ATTRIBUTES)
d333 1
a333 1
	  if (att != INVALID_FILE_ATTRIBUTES)
@


1.66
log
@* dir.cc (rmdir): Streamline.  Detect attempts to remove directories from
"read-only" virtual devices.  (Suggested by Pavel Tsekov)
* syscalls.cc (unlink): Detect attempts to remove directories from "read-only"
virtual devices.  (From Pavel Tsekov)
@
text
@d243 1
a243 1
  nofinalslash(real_dir.get_win32 (), real_dir.get_win32 ());
@


1.65
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d276 1
d281 4
a284 4
    {
      set_errno (real_dir.error);
      res = -1;
    }
d286 1
a286 4
    {
      set_errno (ENOENT);
      res = -1;
    }
d288 1
a288 4
    {
      set_errno (ENOTDIR);
      res = -1;
    }
d328 1
a328 1
	  if (GetLastError () == ERROR_ACCESS_DENIED)
d330 7
d338 3
a340 6
	      /* On 9X ERROR_ACCESS_DENIED is returned if you try to remove
		 a non-empty directory. */
	      if (wincap.access_denied_on_delete ())
		set_errno (ENOTEMPTY);
	      else
		__seterrno ();
a341 6
	  else
	    __seterrno ();

	  /* If directory still exists, restore R/O attribute. */
	  if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
	    SetFileAttributes (real_dir, real_dir);
@


1.64
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@a11 1
#include <sys/fcntl.h>
@


1.63
log
@* fhandler_disk_file.cc (readdir): Move inode calculation into caller.
(fhandler_cygdrive::readdir): Add "." and "..".
* dir.cc (readdir): Move inode calculation here so that fhandler readdirs can
benefit.
@
text
@a20 1
#include "sigproc.h"
@


1.62
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d116 36
a151 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->readdir (dir);
@


1.61
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d226 1
a226 1
        SetFileAttributes (real_dir.get_win32 (), FILE_ATTRIBUTE_HIDDEN);
@


1.60
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@a20 1
#include "sync.h"
a25 1
#include "perprocess.h"
@


1.59
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d121 2
a122 3
/* telldir */
extern "C" __off32_t
telldir (DIR *dir)
d132 7
a138 1
/* seekdir */
d140 1
a140 1
seekdir (DIR *dir, __off32_t loc)
d148 7
@


1.58
log
@	* dir.cc: Use INVALID_FILE_ATTRIBUTES instead of "(DWORD) -1"
	for file attributes throughout.
	* fhandler.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* syscalls.cc: Ditto.
	* times.cc (utimes): Use path_conv::isdir() instead of explicit
	GetFileAttributes() call.
@
text
@d122 1
a122 1
extern "C" off_t
d135 1
a135 1
seekdir (DIR *dir, off_t loc)
@


1.57
log
@Add copyright stuff
@
text
@d263 1
a263 1
	  if (GetFileAttributes (real_dir) != (DWORD) -1)
@


1.56
log
@* dir.cc (opendir): Guarantee release of alloced fhandler structure on error.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.55
log
@* dir.cc (opendir): Don't attempt to call sub-opendir if ENOENT.
@
text
@d91 2
a92 2
  else if (!pc.exists ())
    set_errno (ENOENT);
d95 2
a96 3
      res = fh->opendir (pc);
      if (!res)
	delete fh;
d98 3
@


1.54
log
@* dir.cc (opendir): Detect error return from build_fhandler_from_name.
@
text
@d91 2
@


1.53
log
@* path.cc (conv_path_list): Fix wild indexing into path due to conflicting
methods for setting src pointer.
* dir.cc (opendir): Only pass path_conv argument to opendir, since name is
already part of the fhandler.
* dtable.cc (dtable::build_fhandler): Accomodate new FH_CYGDRIVE type.
* fhandler.cc (fhandler_base::opendir): Nuke name argument.
* fhandler.h: Add FH_CYGDRIVE to "device" enum.
(fhandler_base::opendir): Nuke name argument.
(fhandler_disk_file::opendir): Ditto.
(fhandler_disk_file::fhandler_disk_file): Declare new method which passes
devtype through.
(fhandler_cygdrive): Add elements for tracking drives.
(fhandler_cygdrive::set_drives): Declare new method.
(fhandler_cygdrive::iscygdrive_root): Declare new method.
(fhandler_cygdrive::opendir): Declare new method.
(fhandler_cygdrive::readdir): Declare new method.
(fhandler_cygdrive::telldir): Declare new method.
(fhandler_cygdrive::seekdir): Declare new method.
(fhandler_cygdrive::rewinddir): Declare new method.
(fhandler_cygdrive::closedir): Declare new method.
(fhandler_cygdrive::fstat): Declare new method.
* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file): Define new
method which passes devtype through.
(fhandler_disk_file::open): Tweak debug output.
(fhandler_disk_file::opendir): Nuke first argument.  Use info from path_conv
and class rather than calling fstat.
(fhandler_cygdrive::set_drives): New method.
(fhandler_cygdrive::iscygdrive_root): New method.
(fhandler_cygdrive::opendir): New method.
(fhandler_cygdrive::readdir): New method.
(fhandler_cygdrive::telldir): New method.
(fhandler_cygdrive::seekdir): New method.
(fhandler_cygdrive::rewinddir): New method.
(fhandler_cygdrive::closedir): New method.
(fhandler_cygdrive::fstat): New method.
* path.cc (iscygdrive_device): Assume cygdriveness is already verified.
(path_conv::check): Treat FH_CYGDRIVE "method" as a special case, setting file
attributes as needed.
(mount_info::conv_to_win32_path): Allow stand-alone /cygdrive, meaning "the
directory which contains all of the drives on the system".
(fillout_mntent): Use cyg_tolower for conversions.
(mount_info::cygdrive_win32_path): Replace unused argument with unit number.
* shared_info.h (mount_info::cygdrive_win32_path): Reflect argument change.
@
text
@d85 1
a85 1
  DIR *res = NULL;
d89 8
a96 3
  res = fh->opendir (pc);
  if (!res)
    delete fh;
@


1.53.6.1
log
@* dir.cc (opendir): Detect error return from build_fhandler_from_name.
@
text
@d85 1
a85 1
  DIR *res;
d89 3
a91 8
  if (!fh)
    res = NULL;
  else
    {
      res = fh->opendir (pc);
      if (!res)
	delete fh;
    }
@


1.52
log
@* Makefile.in (DLL_OFILES): Add fhandler_disk_file.o.
* cygheap.h (cygheap_fdnew::operator =): New operator.
* dir.cc: Add invalid struct checking throughout.  Use methods for all
directory manipulation throughout.
* fhandler.cc: Move fhandler_disk_file stuff to own file.
(fhandler_base::opendir): New method.
(fhandler_base::readdir): New method.
(fhandler_base::telldir): New method.
(fhandler_base::seekdir): New method.
(fhandler_base::rewinddir): New method.
(fhandler_base::closedir): New method.
* fhandler_disk_file.cc: New file.
* fhandler.h (fhandler_base): Declare new virtual methods.
(fhandler_disk_file): Ditto.
(fhandler_cygdrive): New class.
* path.cc (conv_path_list): Use strccpy to break apart path.
@
text
@d89 1
a89 1
  res = fh->opendir (name, pc);
@


1.51
log
@	* dir.cc (mkdir): Add HIDDEN file attribute if file has leading dot
	and HIDDEN_DOT_FILES is defined.
	* fhandler.cc (fhandler_base::open): Ditto.
	* path.cc (symlink): Ditto.
	* syscalls.cc (_rename): Ditto and remove HIDDEN file attribute if
	new filename does not begin with a dot.
@
text
@d68 2
d81 1
a81 1
opendir (const char *dirname)
d83 9
a91 60
  int len;
  DIR *dir;
  DIR *res = 0;
  struct stat statbuf;

  path_conv real_dirname;

  if (stat_worker (dirname, &statbuf, 0, &real_dirname) == -1)
    goto failed;

  if (!(statbuf.st_mode & S_IFDIR))
    {
      set_errno (ENOTDIR);
      goto failed;
    }

  len = strlen (real_dirname);
  if (len > MAX_PATH - 3)
    {
      set_errno (ENAMETOOLONG);
      goto failed;
    }

  if ((dir = (DIR *) malloc (sizeof (DIR))) == NULL)
    {
      set_errno (ENOMEM);
      goto failed;
    }
  if ((dir->__d_dirname = (char *) malloc (len + 3)) == NULL)
    {
      free (dir);
      set_errno (ENOMEM);
      goto failed;
    }
  if ((dir->__d_dirent =
	    (struct dirent *) malloc (sizeof (struct dirent))) == NULL)
    {
      free (dir->__d_dirname);
      free (dir);
      set_errno (ENOMEM);
      goto failed;
    }
  strcpy (dir->__d_dirname, real_dirname.get_win32 ());
  dir->__d_dirent->d_version = __DIRENT_VERSION;
  dir->__d_dirent->d_fd = open (dir->__d_dirname, O_RDONLY | O_DIROPEN);
  /* FindFirstFile doesn't seem to like duplicate /'s. */
  len = strlen (dir->__d_dirname);
  if (len == 0 || SLASH_P (dir->__d_dirname[len - 1]))
    strcat (dir->__d_dirname, "*");
  else
    strcat (dir->__d_dirname, "\\*");  /**/
  dir->__d_cookie = __DIRENT_COOKIE;
  dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
  dir->__d_position = 0;
  dir->__d_dirhash = statbuf.st_ino;

  res = dir;

failed:
  syscall_printf ("%p = opendir (%s)", res, dirname);
d97 1
a97 1
readdir (DIR * dir)
d99 2
a100 3
  WIN32_FIND_DATA buf;
  HANDLE handle;
  struct dirent *res = NULL;
d105 2
a106 51
      syscall_printf ("%p = readdir (%p)", res, dir);
      return res;
    }

  if (dir->__d_u.__d_data.__handle == INVALID_HANDLE_VALUE
      && dir->__d_position == 0)
    {
      handle = FindFirstFileA (dir->__d_dirname, &buf);
      DWORD lasterr = GetLastError ();
      dir->__d_u.__d_data.__handle = handle;
      if (handle == INVALID_HANDLE_VALUE && (lasterr != ERROR_NO_MORE_FILES))
	{
	  seterrno_from_win_error (__FILE__, __LINE__, lasterr);
	  return res;
	}
    }
  else if (dir->__d_u.__d_data.__handle == INVALID_HANDLE_VALUE)
    {
      return res;
    }
  else if (!FindNextFileA (dir->__d_u.__d_data.__handle, &buf))
    {
      DWORD lasterr = GetLastError ();
      (void) FindClose (dir->__d_u.__d_data.__handle);
      dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
      /* POSIX says you shouldn't set errno when readdir can't
	 find any more files; so, if another error we leave it set. */
      if (lasterr != ERROR_NO_MORE_FILES)
	  seterrno_from_win_error (__FILE__, __LINE__, lasterr);
      syscall_printf ("%p = readdir (%p)", res, dir);
      return res;
    }

  /* We get here if `buf' contains valid data.  */
  strcpy (dir->__d_dirent->d_name, buf.cFileName);

  /* Check for Windows shortcut. If it's a Cygwin or U/WIN
     symlink, drop the .lnk suffix. */
  if (buf.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
    {
      char *c = dir->__d_dirent->d_name;
      int len = strlen (c);
      if (strcasematch (c + len - 4, ".lnk"))
	{
	  char fbuf[MAX_PATH + 1];
	  strcpy (fbuf, dir->__d_dirname);
	  strcpy (fbuf + strlen (fbuf) - 1, dir->__d_dirent->d_name);
	  path_conv fpath (fbuf, PC_SYM_NOFOLLOW);
	  if (fpath.issymlink ())
	    c[len - 4] = '\0';
	}
d109 1
a109 36
  /* Compute d_ino by combining filename hash with the directory hash
     (which was stored in dir->__d_dirhash when opendir was called). */
  if (buf.cFileName[0] == '.')
    {
      if (buf.cFileName[1] == '\0')
	dir->__d_dirent->d_ino = dir->__d_dirhash;
      else if (buf.cFileName[1] != '.' || buf.cFileName[2] != '\0')
	goto hashit;
      else
	{
	  char *p, up[strlen (dir->__d_dirname) + 1];
	  strcpy (up, dir->__d_dirname);
	  if (!(p = strrchr (up, '\\')))
	    goto hashit;
	  *p = '\0';
	  if (!(p = strrchr (up, '\\')))
	    dir->__d_dirent->d_ino = hash_path_name (0, ".");
	  else
	    {
	      *p = '\0';
	      dir->__d_dirent->d_ino = hash_path_name (0, up);
	    }
	}
    }
  else
    {
  hashit:
      ino_t dino = hash_path_name (dir->__d_dirhash, "\\");
      dir->__d_dirent->d_ino = hash_path_name (dino, buf.cFileName);
    }

  ++dir->__d_position;
  res = dir->__d_dirent;
  syscall_printf ("%p = readdir (%p) (%s)",
		  &dir->__d_dirent, dir, buf.cFileName);
  return res;
d114 1
a114 1
telldir (DIR * dir)
d116 3
d121 1
a121 1
  return dir->__d_position;
d126 1
a126 1
seekdir (DIR * dir, off_t loc)
d128 3
d133 1
a133 4
  rewinddir (dir);
  while (loc > dir->__d_position)
    if (! readdir (dir))
      break;
d138 1
a138 1
rewinddir (DIR * dir)
d140 2
a141 1
  syscall_printf ("rewinddir (%p)", dir);
d145 1
a145 6
  if (dir->__d_u.__d_data.__handle != INVALID_HANDLE_VALUE)
    {
      (void) FindClose (dir->__d_u.__d_data.__handle);
      dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
    }
  dir->__d_position = 0;
d150 1
a150 1
closedir (DIR * dir)
d152 3
d162 2
a163 7
  if (dir->__d_u.__d_data.__handle != INVALID_HANDLE_VALUE &&
      FindClose (dir->__d_u.__d_data.__handle) == 0)
    {
      __seterrno ();
      syscall_printf ("-1 = closedir (%p)", dir);
      return -1;
    }
d165 1
a165 2
  if (dir->__d_dirent->d_fd >= 0)
    close (dir->__d_dirent->d_fd);
d167 1
a167 2
  /* Reset the marker in case the caller tries to use `dir' again.  */
  dir->__d_cookie = 0;
d172 2
a173 2
  syscall_printf ("0 = closedir (%p)", dir);
  return 0;
@


1.50
log
@Eliminate excess whitespace.
@
text
@d343 5
@


1.49
log
@Add second path_conv * argument to fstat()s throughout.
* fhandler.h: Change read and fstat to regparm/stdcall throughout.
(fhandler_base::fstat): Just declare.  Don't define.
(fhandler_disk_file::fstat_helper): Declare.
* fhandler.cc (fhandler_base::fstat): Move here from fhandler.h, adapt from
former stat_dev().
(fhandler_disk_file::fstat): Move most of the disk-file-specific logic from
stat_worker to here.  Use fstat_helper to derive final fstat output.
(fhandler_disk_file::fstat_helper): New method, renamed from former fstat
method.
(num_entries): Moved here from syscalls.cc.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Use base class to initialize most
stuff.  Invert has_physical_mem_access test for establishing permissions.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Eliminate unneed test and memory
clearing.  Use base class to initialize most stuff.
* syscalls.cc (stat_dev): Eliminate.
(stat_worker): Simply call fstat method to generate fstat output.  Move all
device specific code to appropriate fstats.
* dir.cc (opendir): Pass correct arg to stat_worker to allow following
symlinks.
@
text
@d381 1
a381 1
	    		   (DWORD) real_dir & ~FILE_ATTRIBUTE_READONLY);
@


1.48
log
@* syscalls.cc (stat_worker): Make global.  Accept path_conv parameter for
passing information back to caller.
* winsup.h: Declare stat_worker.
* dir.cc (opendir): Use stat_worker rather than stat and pass path_conv
parameter to stat_worker for later inspection.
* syslog.cc (syslog): Teach syslog about syslog priorities other than LOG_ERR,
LOG_WARNING and LOG_INFO
* path.cc (path_conv::check): Don't perform file system or rootdir checks on
devices.
@
text
@d88 1
a88 1
  if (stat_worker (dirname, &statbuf, 1, &real_dirname) == -1)
@


1.47
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d86 1
a86 1
  path_conv real_dirname (dirname, PC_SYM_FOLLOW | PC_FULL);
d88 1
a88 7
  if (real_dirname.error)
    {
      set_errno (real_dirname.error);
      goto failed;
    }

  if (stat (real_dirname, &statbuf) == -1)
@


1.46
log
@* syscalls.cc (rmdir): Set cwd to some other location if attempting to rmdir
current working directory.
@
text
@d370 1
a370 1
      goto done;
d372 1
a372 3

  /* Does the file exist? */
  if (real_dir.file_attributes () == (DWORD) -1)
d375 1
a375 1
      goto done;
d377 1
a377 3

  /* Is `dir' a directory? */
  if  (!(real_dir.file_attributes () & FILE_ATTRIBUTE_DIRECTORY))
d380 1
a380 17
      goto done;
    }

  /* Even own directories can't be removed if R/O attribute is set. */
  if (real_dir.file_attributes () & FILE_ATTRIBUTE_READONLY)
    SetFileAttributes (real_dir.get_win32 (), real_dir.file_attributes () &
					      ~FILE_ATTRIBUTE_READONLY);

  if (RemoveDirectoryA (real_dir.get_win32 ()))
    {
      /* RemoveDirectory on a samba drive doesn't return an error if the
	 directory can't be removed because it's not empty. Checking for
	 existence afterwards keeps us informed about success. */
      if (GetFileAttributesA (real_dir.get_win32 ()) != (DWORD) -1)
	set_errno (ENOTEMPTY);
      else
	res = 0;
d384 6
a389 13
      /* This kludge detects if we are attempting to remove the current working
         directory.  If so, we will move elsewhere to potentially allow the
	 rmdir to succeed.  This means that cygwin's concept of the current working
	 directory != Windows concept but, hey, whaddaregonnado?
	 Note that this will not cause something like the following to work:
		 $ cd foo
		 $ rmdir .
         since the shell will have foo "open" in the above case and so Windows will
	 not allow the deletion.
	 FIXME: A potential workaround for this is for cygwin apps to *never* call
	 SetCurrentDirectory. */
      if (strcasematch (real_dir, cygheap->cwd.win32)
	  && !strcasematch ("c:\\", cygheap->cwd.win32))
d391 5
a395 3
	  DWORD err = GetLastError ();
	  if (!SetCurrentDirectory ("c:\\"))
	    SetLastError (err);
d397 1
a397 1
	    return rmdir (dir);
d399 1
a399 1
      if (GetLastError() == ERROR_ACCESS_DENIED)
d401 30
a430 5

	  /* On 9X ERROR_ACCESS_DENIED is returned if you try to remove
	     a non-empty directory. */
	  if (wincap.access_denied_on_delete ())
	    set_errno (ENOTEMPTY);
d433 4
a437 6
      else
	__seterrno ();

      /* If directory still exists, restore R/O attribute. */
      if (real_dir.file_attributes () & FILE_ATTRIBUTE_READONLY)
	SetFileAttributes (real_dir.get_win32 (), real_dir.file_attributes ());
a439 1
done:
@


1.46.2.1
log
@Merged changes from HEAD
@
text
@d370 1
a370 1
      res = -1;
d372 3
a374 1
  else if (!real_dir.exists ())
d377 1
a377 1
      res = -1;
d379 3
a381 1
  else if  (!real_dir.isdir ())
d384 17
a400 1
      res = -1;
d404 13
a416 6
      /* Even own directories can't be removed if R/O attribute is set. */
      if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
	SetFileAttributes (real_dir,
	    		   (DWORD) real_dir & ~FILE_ATTRIBUTE_READONLY);

      if (RemoveDirectory (real_dir))
d418 3
a420 5
	  /* RemoveDirectory on a samba drive doesn't return an error if the
	     directory can't be removed because it's not empty. Checking for
	     existence afterwards keeps us informed about success. */
	  if (GetFileAttributes (real_dir) != (DWORD) -1)
	    set_errno (ENOTEMPTY);
d422 1
a422 1
	    res = 0;
d424 1
a424 1
      else
d426 5
a430 30
	  /* This kludge detects if we are attempting to remove the current working
	     directory.  If so, we will move elsewhere to potentially allow the
	     rmdir to succeed.  This means that cygwin's concept of the current working
	     directory != Windows concept but, hey, whaddaregonnado?
	     Note that this will not cause something like the following to work:
		     $ cd foo
		     $ rmdir .
	     since the shell will have foo "open" in the above case and so Windows will
	     not allow the deletion.
	     FIXME: A potential workaround for this is for cygwin apps to *never* call
	     SetCurrentDirectory. */
	  if (strcasematch (real_dir, cygheap->cwd.win32)
	      && !strcasematch ("c:\\", cygheap->cwd.win32))
	    {
	      DWORD err = GetLastError ();
	      if (!SetCurrentDirectory ("c:\\"))
		SetLastError (err);
	      else if ((res = rmdir (dir)))
		SetCurrentDirectory (cygheap->cwd.win32);
	    }
	  if (GetLastError () == ERROR_ACCESS_DENIED)
	    {

	      /* On 9X ERROR_ACCESS_DENIED is returned if you try to remove
		 a non-empty directory. */
	      if (wincap.access_denied_on_delete ())
		set_errno (ENOTEMPTY);
	      else
		__seterrno ();
	    }
d433 3
d437 3
a439 4
	  /* If directory still exists, restore R/O attribute. */
	  if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
	    SetFileAttributes (real_dir, real_dir);
	}
d442 1
@


1.46.2.2
log
@Merged changes from HEAD
@
text
@a67 2
  if (check_null_invalid_struct_errno (dir))
    return -1;
d79 1
a79 1
opendir (const char *name)
d81 42
a122 9
  fhandler_base *fh;
  path_conv pc;
  DIR *res;

  fh = cygheap->fdtab.build_fhandler_from_name (-1, name, NULL, pc,
						PC_SYM_FOLLOW | PC_FULL, NULL);
  if (!fh)
    res = NULL;
  else
d124 4
a127 3
      res = fh->opendir (pc);
      if (!res)
	delete fh;
d129 18
d152 1
a152 1
readdir (DIR *dir)
d154 3
a156 2
  if (check_null_invalid_struct_errno (dir))
    return NULL;
d161 31
a191 2
      syscall_printf ("%p = readdir (%p)", NULL, dir);
      return NULL;
d194 56
a249 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->readdir (dir);
d254 1
a254 1
telldir (DIR *dir)
a255 3
  if (check_null_invalid_struct_errno (dir))
    return -1;

d258 1
a258 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->telldir (dir);
d263 1
a263 1
seekdir (DIR *dir, off_t loc)
a264 3
  if (check_null_invalid_struct_errno (dir))
    return;

d267 4
a270 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->seekdir (dir, loc);
d275 1
a275 1
rewinddir (DIR *dir)
d277 1
a277 2
  if (check_null_invalid_struct_errno (dir))
    return;
d281 6
a286 1
  return ((fhandler_base *) dir->__d_u.__d_data.__fh)->rewinddir (dir);
d291 1
a291 1
closedir (DIR *dir)
a292 3
  if (check_null_invalid_struct_errno (dir))
    return -1;

d300 11
a313 4
  int res = ((fhandler_base *) dir->__d_u.__d_data.__fh)->closedir (dir);

  cygheap->fdtab.release (dir->__d_dirent->d_fd);

d317 2
a318 2
  syscall_printf ("%d = closedir (%p)", res);
  return res;
a348 5
#ifdef HIDDEN_DOT_FILES
      char *c = strrchr (real_dir.get_win32 (), '\\');
      if ((c && c[1] == '.') || *real_dir.get_win32 () == '.')
        SetFileAttributes (real_dir.get_win32 (), FILE_ATTRIBUTE_HIDDEN);
#endif
d387 1
a387 1
			   (DWORD) real_dir & ~FILE_ATTRIBUTE_READONLY);
@


1.46.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
a90 2
  else if (pc.exists ())
      res = fh->opendir (pc);
d93 3
a95 2
      set_errno (ENOENT);
      res = NULL;
a96 3

  if (!res && fh)
    delete fh;
d259 1
a259 1
	  if (GetFileAttributes (real_dir) != INVALID_FILE_ATTRIBUTES)
@


1.46.2.4
log
@Merged changes from HEAD
@
text
@d121 3
a123 2
extern "C" __off64_t
telldir64 (DIR *dir)
d133 1
a133 7
/* telldir */
extern "C" __off32_t
telldir (DIR *dir)
{
  return telldir64 (dir);
}

d135 1
a135 1
seekdir64 (DIR *dir, __off64_t loc)
a142 7
}

/* seekdir */
extern "C" void
seekdir (DIR *dir, __off32_t loc)
{
  seekdir64 (dir, (__off64_t)loc);
@


1.46.2.5
log
@Merged changes from HEAD
@
text
@d12 1
d21 2
d27 1
d118 1
a118 36
  dirent *res = ((fhandler_base *) dir->__d_u.__d_data.__fh)->readdir (dir);

  if (res)
    {
      /* Compute d_ino by combining filename hash with the directory hash
	 (which was stored in dir->__d_dirhash when opendir was called). */
      if (res->d_name[0] == '.')
	{
	  if (res->d_name[1] == '\0')
	    dir->__d_dirent->d_ino = dir->__d_dirhash;
	  else if (res->d_name[1] != '.' || res->d_name[2] != '\0')
	    goto hashit;
	  else
	    {
	      char *p, up[strlen (dir->__d_dirname) + 1];
	      strcpy (up, dir->__d_dirname);
	      if (!(p = strrchr (up, '\\')))
		goto hashit;
	      *p = '\0';
	      if (!(p = strrchr (up, '\\')))
		dir->__d_dirent->d_ino = hash_path_name (0, ".");
	      else
		{
		  *p = '\0';
		  dir->__d_dirent->d_ino = hash_path_name (0, up);
		}
	    }
	}
      else
	{
      hashit:
	  ino_t dino = hash_path_name (dir->__d_dirhash, "\\");
	  dir->__d_dirent->d_ino = hash_path_name (dino, res->d_name);
	}
    }
  return res;
d228 1
a228 1
	SetFileAttributes (real_dir.get_win32 (), FILE_ATTRIBUTE_HIDDEN);
a244 1
  DWORD devn;
d249 4
a252 4
    set_errno (real_dir.error);
  else if ((devn = real_dir.get_devn ()) == FH_PROC || devn == FH_REGISTRY
	   || devn == FH_PROCESS)
    set_errno (EROFS);
d254 4
a257 1
    set_errno (ENOENT);
d259 4
a262 1
    set_errno (ENOTDIR);
d302 1
a302 1
	  if (res)
d304 6
a309 2
	      if (GetLastError () != ERROR_ACCESS_DENIED
		  || !wincap.access_denied_on_delete ())
a310 8
	      else
		set_errno (ENOTEMPTY);	/* On 9X ERROR_ACCESS_DENIED is
					       returned if you try to remove a
					       non-empty directory. */

	      /* If directory still exists, restore R/O attribute. */
	      if (real_dir.has_attribute (FILE_ATTRIBUTE_READONLY))
		SetFileAttributes (real_dir, real_dir);
d312 6
@


1.45
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d404 20
d426 1
@


1.44
log
@Update copyrights.
@
text
@d408 1
a408 1
	  if (!iswinnt)
@


1.43
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Cygnus Solutions.
@


1.42
log
@* cygheap.h (init_cygheap): Move bucket array here from cygheap.cc.
* cygheap.cc: Throughout use bucket array from cygheap.
* sigproc.cc (proc_subproc): Dynamically allocate zombie buffer to save DLL
space.
(sigproc_fixup_after_fork): Free zombie array after a fork.
* sigproc.h (sigproc_fixup_after_fork): Declare.
* dir.cc (mkdir): Expand buffer for security descriptor to 4K to avoid stack
corruption.
* fhandler.cc (fhandler_base::open): Ditto.
* path.cc (symlink): Ditto.
@
text
@d204 1
a204 1
        {
d210 2
a211 2
            c[len - 4] = '\0';
        }
d390 1
a390 1
    					      ~FILE_ATTRIBUTE_READONLY);
d405 1
a405 1
        {
@


1.41
log
@        * dir.cc (opendir): Write version information to __d_dirent->d_version.
@
text
@d342 1
a342 1
			    &sa, alloca (256), 256);
@


1.40
log
@        * cygwin.din: Add `dirfd'.
        * dir.cc (dirfd): New function.
        (opendir): Open a directory file descriptor and save it in
        __d_dirent->d_fd.
        (closedir): Close directory file descriptor.
        * include/cygwin/version.h: Bump API minor version to 44.
@
text
@d130 1
@


1.39
log
@* dir.cc (rmdir): Report ENOENT when file doesn't exist rather than ENOTDIR.
@
text
@d12 1
d65 12
d130 1
d306 3
@


1.38
log
@        * security.cc (alloc_sd): Don't set FILE_DELETE_CHILD for group
        if S_ISVTX attribute is given.
        * dir.cc (mkdir): Allow immediate setting of S_ISUID, S_ISGID and
        S_ISVTX attribute.
        * syscalls.cc (_open): Ditto.
@
text
@d355 7
d363 1
a363 2
  if (real_dir.file_attributes () == (DWORD) -1 ||
      !(real_dir.file_attributes () & FILE_ATTRIBUTE_DIRECTORY))
@


1.37
log
@        * dir.cc (mkdir): Set security attributes correctly for
        CreateDirectoryA () call if ntsec is on. Don't call
        set_file_attributes () then.
        * fhandler.cc (fhandler_base::open): Ditto for CreateFileA () call.
        * path.cc (symlink): Ditto.
        * security.cc (set_security_attribute): New function.
        * security.h: Add declaration for `allow_ntea' and
        `set_security_attribute'.
@
text
@d323 1
a323 1
    set_security_attribute (S_IFDIR | ((mode & 0777) & ~cygheap->umask),
d330 1
a330 1
			    S_IFDIR | ((mode & 0777) & ~cygheap->umask));
@


1.36
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d308 1
d322 5
a326 1
  if (CreateDirectoryA (real_dir.get_win32 (), 0))
d328 3
a330 2
      set_file_attribute (real_dir.has_acls (), real_dir.get_win32 (),
			  S_IFDIR | ((mode & 0777) & ~cygheap->umask));
@


1.35
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d378 1
a378 1
	  if (os_being_run != winNT)
@


1.34
log
@        * dir.cc (readdir): Protect FindNextFileA against INVALID_HANDLE_VALUE.
@
text
@d24 1
a27 1
#include "security.h"
@


1.33
log
@forced commit
@
text
@d162 4
@


1.32
log
@* cygheap.cc (cygheap_root::cygheap_rot): Remove constructor.
(cygheap_root::~cygheap_root): Remove destructor.
(cygheap_root::operator =): Remove.
(cygheap_root::set): New method.
* cygheap.h (cygheap_root): Reflect above changes.  Store root info in
mount-like structure.
(cygheap_root:posix_ok): New method.
(cygheap_root::ischroot_native): Ditto.
(cygheap_root::unchroot): Ditto.
(cygheap_root::exists): Ditto.
(cygheap_root::posix_length): Ditto.
(cygheap_root::posix_path): Ditto.
(cygheap_root::native_length): Ditto.
(cygheap_root::native_path): Ditto.
* dir.cc (opendir): Remove special chroot test.
* path.cc (path_prefix_p): Remove front end.
(normalize_posix_path): Reorganize chroot tests to accomodate new convention of
allowing paths using posix chroot prefix.
(path_conv::check): Pass a "already ran normalize" option to
conv_to_win32_path.  Return if there is an error from this function.
(mount_info::conv_to_win32_path): Add extra argument.  Don't call
normalize_posix_path if caller has already done so.  Substitute chroot setting,
if any, for root translation.  Add chroot checking to final output step.
* shared_info (mount_info): Accomodate additional argument to
conv_to_win32_path.
* syscalls.cc (chroot): Store both normalized posix path and native path in
chroot.
@
text
@@


1.31
log
@        * dir.cc (rmdir): Rearrange slightly to allow removing directories
        even when R/O attribute is set.
@
text
@d81 1
a81 2
  if (stat (cygheap->root.length () ? dirname : real_dirname.get_win32 (),
	    &statbuf) == -1)
d90 1
a90 1
  len = strlen (real_dirname.get_win32 ());
@


1.30
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d346 13
d369 1
a369 1
  else if (GetLastError() == ERROR_ACCESS_DENIED)
d371 15
a385 10
      /* Under Windows 9X or on a samba share, ERROR_ACCESS_DENIED is
	 returned if you try to remove a file. On 9X the same error is
	 returned if you try to remove a non-empty directory. */
     if (real_dir.file_attributes () != (DWORD) -1 &&
	 !(real_dir.file_attributes () & FILE_ATTRIBUTE_DIRECTORY))
       set_errno (ENOTDIR);
     else if (os_being_run != winNT)
       set_errno (ENOTEMPTY);
     else
       __seterrno ();
a386 2
  else
    __seterrno ();
@


1.29
log
@        * dir.cc (mkdir): Check for case clash.
        * environ.cc: Add extern declaration for `pcheck_case'.
        (check_case_init): New function.
        (struct parse_thing): Add "check_case" option.
        * errno.cc (_sys_nerrlist): Add text for ECASECLASH.
        (strerror): Add case branch for ECASECLASH.
        * fhandler.cc (fhandler_disk_file::open): Check for case clash.
        * path.cc: Add global variable `pcheck_case'.
        (struct symlink_info): Add member `case_clash' and method `case_check'.
        (path_prefix_p_): Call `pathnmatch' instead of `strncasematch'.
        (pathnmatch): New funtion.
        (pathmatch): Ditto.
        (path_conv::check): Add handling for case checking.
        (symlink): Check for case clash.
        (symlink_info::check): Add parameter for case checking.
        Handle case checking.
        (symlink_info::case_check): New method.
        (chdir): Don't use unconverted path if pcheck_case==PCHECK_STRICT.
        * path.h: Add extern declarations for `pathmatch' and
        `pathnmatch'.
        (enum case_checking): New enumeration type describing
        the case checking behaviour of path conversion routines.
        (class path_conv): Add member `case_clash'.
        * syscalls.cc (_link): Check for case clash.
@
text
@d28 1
@


1.28
log
@* dir.cc (readdir): Use strcasematch for consistency.
* path.cc (symlink_info): Eliminate known_suffix.
(path_conv::check): Always copy ext_here to end of buffer, if found.
(suffix_scan): Eliminate ext_here, add suffixes_start.
(suffix_scan::has): Eliminate an argument.  Reorganize.  Always return pointer
to end of input path.
(suffix_scan::next): Take a second pass through the suffix list looking for
.lnk.
(symlink_info::check): Eliminate known_suffix usage.
@
text
@d309 1
a309 1
      set_errno (real_dir.error);
@


1.27
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d184 1
a184 1
      if (!strcasecmp (c + len - 4, ".lnk"))
@


1.26
log
@        * dir.cc (readdir): Fix creating path in symlink check.
@
text
@d25 1
@


1.25
log
@        * dir.cc (readdir): Fix shortcut==symlink condition.
        * environ.cc: Add extern decl for `allow_winsymlinks'.
        (struct parse_thing): Add entry for `[no]winsymlinks'.
        * path.cc (symlink): Change to be able to create both,
        symlink==shortcut and symlink==systemfile, dependent of
        the setting of `allow_winsymlinks'.
        * security.cc (cygwin_logon_user): Add debug output.
        * shortcut.c: Add defines from path.h.
        (has_exec_chars): Copy from path.h.
        (check_shortcut): Check for executable file condition if not a
        shortcut.
@
text
@d187 1
a187 1
	  strcat (fbuf + strlen (fbuf) - 1, dir->__d_dirent->d_name);
@


1.24
log
@        * cygerrno.h: Revert previous patch.
        * errno.cc: Ditto.
        * dir.cc: Eliminate `dir_suffixes'.
        (opendir): Remove usage of `dir_suffixes'.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::open): Remove usage of
        `inner_suffixes'.
        * path.cc: Rename `inner_suffixes' to `lnk_suffixes'.
        (path_conv::check): Remove usage of `inner_suffixes'.
        (symlink): Ditto.
        (symlink_info::check): Handle checking for `.lnk' in path_conv
        exclusively here.
        (chdir): Remove usage of `dir_suffixes'.
        * shortcut.c: Eliminate debug_printf lines.
        (check_shortcut): Don't set error except on failing ReadFile.
        * spawn.cc: Remove ".lnk" from `std_suffixes'.
        * syscalls.cc (_unlink): Remove usage of `inner_suffixes'.
        Remove ".lnk" from `stat_suffixes'.
        (_rename): Add check for renaming a symlink to keep the ".lnk"
        suffix after renaming.
@
text
@d177 2
d184 8
a191 1
        c[len - 4] = '\0';
@


1.23
log
@Add copyright year 2001
@
text
@a61 7
suffix_info dir_suffixes[] =
{
  suffix_info ("", 1),
  suffix_info (".lnk", 1),
  suffix_info (NULL)
};

d71 1
a71 1
  path_conv real_dirname (dirname, PC_SYM_FOLLOW | PC_FULL, dir_suffixes);
d327 1
a327 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW, dir_suffixes);
@


1.22
log
@        * Makefile.in: Add `-lshell32 -luuid' to link pass for new-cygwin1.dll.
        * autoload.cc: Add LoadDLLinitfunc for ole32.dll.
        Add LoadDLLfuncEx statements for CoInitialize@@4, CoUninitialize@@0
        and CoCreateInstance@@20.
        * dir.cc (dir_suffixes): New datastructure.
        (readdir): Check for R/O *.lnk files to hide the suffix.
        (opendir): Use `dir_suffixes' in path conversion.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::fstat): Add S_IFLNK flag
        before calling `get_file_attribute'. Take FILE_ATTRIBUTE_READONLY
        into account only if the file is no symlink.
        * path.cc (inner_suffixes): New datastructure.
        (SYMLINKATTR): Eliminated.
        (path_conv::check): Use `inner_suffixes' on inner path components.
        (shortcut_header): New global static variable.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): New function.
        (cmp_shortcut_header): Ditto.
        (symlink): Create symlinks by creating windows shortcuts. Preserve
        the old code.
        (symlink_info::check_shortcut): New method.
        (symlink_info::check_sysfile): Ditto.
        (symlink_info::check): Check for shortcuts. Move code reading
        old system attribute symlinks into symlink_info::check_sysfile().
        (chdir): Use `dir_suffixes' in path conversion.
        * security.cc (get_file_attribute): Check for S_IFLNK flag.
        Force 0777 permissions then.
        * spawn.cc (std_suffixes): Add ".lnk" suffix.
        * syscalls.cc (_unlink): Use `inner_suffixes' in path conversion.
        Check for shortcut symlinks to eliminate R/O attribute before
        calling DeleteFile().
        (stat_suffixes): Add ".lnk" suffix.
        (stat_worker): Force 0777 permissions if file is a symlink.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.21
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d62 7
d78 1
a78 1
  path_conv real_dirname (dirname, PC_SYM_FOLLOW | PC_FULL);
d184 8
d334 1
a334 1
  path_conv real_dir (dir, PC_SYM_NOFOLLOW);
@


1.20
log
@        * dir.cc (rewinddir): Always set __d_position = 0, so next
        call to readdir() will restart the directory scan.
@
text
@d79 1
a79 1
  if (stat (cygheap->rootlen ? dirname : real_dirname.get_win32 (),
@


1.19
log
@* cygheap.h (init_cygheap): New struct holding values that live in the Cygwin
heap.
* child_info.h (child_info): Change pointer type of cygheap to init_cygheap.
* cygheap.cc (init_cheap): Point cygheap_max after contents of cygheap.  Move
some stuff into cygheap.h.
* dir.cc (opendir): Change to use root and rootlen in cygheap rather than in
myself.
(mkdir): Change to use umask in cygheap rather than in myself.
* path.cc: Ditto, throughout.
* syscalls.cc (_open): Ditto.  Change to use umask in cygheap rather than in
myself.
(chroot): Change to allocate root dir on the cygwin heap.
(umask): Change to use umask in cygheap rather than in myself.
(cygwin_bind): Ditto.
* sigproc.cc (proc_subproc): Don't copy umask or root stuff as this happens
automatically now.
* pinfo.h (_pinfo): Migrate stuff out of here and into init_cheap.
* dcrt0.cc (dll_crt0_1): Call cygheap_init later in startup for first cygwin
process.
@
text
@a247 1
      dir->__d_position = 0;
d249 1
@


1.18
log
@        * dir.cc (readdir): Avoid reading from the beginning when
        readdir is called after a previous call has returned NULL.
@
text
@d27 1
d79 1
a79 1
  if (stat (myself->rootlen ? dirname : real_dirname.get_win32 (),
d302 1
a302 1
			  S_IFDIR | ((mode & 0777) & ~myself->umask));
@


1.17
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d148 2
a149 1
  if (dir->__d_u.__d_data.__handle == INVALID_HANDLE_VALUE)
@


1.16
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d26 1
@


1.15
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d78 1
a78 1
            &statbuf) == -1)
d299 1
a299 1
                          S_IFDIR | ((mode & 0777) & ~myself->umask));
d327 2
a328 2
         directory can't be removed because it's not empty. Checking for
         existence afterwards keeps us informed about success. */
d330 1
a330 1
        set_errno (ENOTEMPTY);
d332 1
a332 1
        res = 0;
d337 2
a338 2
         returned if you try to remove a file. On 9X the same error is
         returned if you try to remove a non-empty directory. */
@


1.14
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d16 6
d24 2
a25 3

#define _COMPILING_NEWLIB
#include "dirent.h"
@


1.13
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d17 1
@


1.12
log
@* dir.cc (readdir): Ensure that errno is *only* set when we've run out of
filenames.
* fhandler.cc (fhandler_disk_file::fstat): Use modern method for saving errno,
making it effective for the whole function.
@
text
@d16 1
@


1.11
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d131 1
a131 2
  struct dirent *res = 0;
  int prior_errno;
d140 1
a140 1
  if (dir->__d_u.__d_data.__handle != INVALID_HANDLE_VALUE)
d142 4
a145 1
      if (FindNextFileA (dir->__d_u.__d_data.__handle, &buf) == 0)
d147 1
a147 9
	  prior_errno = get_errno();
	  (void) FindClose (dir->__d_u.__d_data.__handle);
	  dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
	  __seterrno ();
	  /* POSIX says you shouldn't set errno when readdir can't
	     find any more files; if another error we leave it set. */
	  if (get_errno () == ENMFILE)
	      set_errno (prior_errno);
	  syscall_printf ("%p = readdir (%p)", res, dir);
d151 1
a151 1
  else
d153 9
a161 16
      handle = FindFirstFileA (dir->__d_dirname, &buf);

      if (handle == INVALID_HANDLE_VALUE)
	{
	  /* It's possible that someone else deleted or emptied the directory
	     or some such between the opendir () call and here.  */
	  prior_errno = get_errno ();
	  __seterrno ();
	  /* POSIX says you shouldn't set errno when readdir can't
	     find any more files; if another error we leave it set. */
	  if (get_errno () == ENMFILE)
	      set_errno (prior_errno);
	  syscall_printf ("%p = readdir (%p)", res, dir);
	  return res;
	}
      dir->__d_u.__d_data.__handle = handle;
@


1.10
log
@        * shared.h (class pinfo): New members `root' and `rootlen'.
        * syscalls.cc (chroot): Set new root for process.
        * path.cc (getcwd_inner): Add parameter to force use of
        new root from chroot() call.
        (ischrootpath): New macro.
        (normalize_posix_path): Care for changed root dir.
        (normalize_win32_path): Ditto.
        (getcwd_inner): Ditto.
        (chdir): Eliminate trailing path component consisting
        entirely of dots.
        * fork.cc (fork): Copy pinfo members regarding chroot().
        * spawn.cc (_spawnve): Ditto.
        * dir.cc (opendir): Don't use computed win32 path if
        chroot() took place.
@
text
@d11 1
a15 1
#include "winsup.h"
@


1.9
log
@Throughout, eliminate third argument to path_conv and use new PC_* constants
for second argument.
* path.h: Generalize SYMLINK_* constants to PC_*.
(path_conv): Create a new method.  Fold third argument into second.
* dll_init.cc (dll_list::alloc): Try harder to find space to allocate dll
struct.
(dll_dllcrt0): Don't check sanity if we've already called dll_crt0.
* path.cc (path_conv::check): Don't check for a null or empty path unless
specifically told with a flag setting.
(check_null_empty_path): New function, adapted from macro.
* syscalls.cc (_rename): Use already-determined file attributes rather than
checking again.
* lib/cygwin/cygwin_attach.dll.c (cygwin_attach_dll): Use a static per_process
structure since this is apparently supposed to be zeroed.
* lib/cygwin_crt0.c (cygwin_crt0): Zero per_process structure sent to older
DLLs.
@
text
@d70 2
a71 1
  if (stat (real_dirname.get_win32 (), &statbuf) == -1)
@


1.8
log
@* dir.cc (rmdir): Use file attributes that have already been discovered by
path_conv.
@
text
@d62 1
a62 1
  path_conv real_dirname (dirname, SYMLINK_FOLLOW, 1);
d289 1
a289 1
  path_conv real_dir (dir, SYMLINK_NOFOLLOW);
d321 1
a321 1
  path_conv real_dir (dir, SYMLINK_NOFOLLOW);
@


1.7
log
@* dir.cc (rmdir): Use file attributes that have already been discovered
by path_conv.
@
text
@d344 2
a345 1
     if (real_dir.file_attributes () != (DWORD) -1 && !(real_dir.fileattr & FILE_ATTRIBUTE_DIRECTORY))
@


1.6
log
@* dir.cc (rmdir): Use file attributes that have already been discovered by
path_conv.
@
text
@d344 1
a344 1
     if (real_dir.fileattr != (DWORD) -1 && !(real_dir.fileattr & FILE_ATTRIBUTE_DIRECTORY))
@


1.5
log
@        Patch by  Kazuhiro Fujieda <fujieda@@jaist.ac.jp>:
        * dir.cc (rmdir): Correct the manner in checking the target directory.
@
text
@d344 1
a344 2
     int attr = GetFileAttributes (real_dir.get_win32());
     if (attr != -1 && !(attr & FILE_ATTRIBUTE_DIRECTORY))
@


1.4
log
@        * dir.cc (writable_directory): Comment out previous code,
        return always 1 for now.
        (mkdir): Call set_file_attribute explicitely with S_IFDIR mode bit.
        * syscalls.cc (chown_worker): Ditto.
        (chmod): Ditto.
        * security.cc (get_nt_attribute): Fix error in debug output.
        Never set FILE_DELETE_CHILD for files.
        Construct appropriate inherit attribute according to file type.
@
text
@d344 2
a345 1
     if (GetFileAttributes (real_dir.get_win32()) != FILE_ATTRIBUTE_DIRECTORY)
@


1.3
log
@* dir.cc (writable_directory): handle root directories
@
text
@d26 1
d48 3
d304 1
a304 1
                          (mode & 0777) & ~myself->umask);
@


1.2
log
@        * dir.cc (rmdir): Care for misleading error messages
        when trying to remove a directory on a samba share.
        Eliminate superfluous else branch.
        * syscalls.cc (_rename): Additional check for ERROR_FILE_EXISTS
        if MoveFile fails.
@
text
@d34 4
@


1.1
log
@Initial revision
@
text
@a321 2
    res = 0;
  else if (os_being_run != winNT && GetLastError() == ERROR_ACCESS_DENIED)
d323 13
a335 2
      /* Under Windows 95 & 98, ERROR_ACCESS_DENIED is returned
	 if you try to remove a file or a non-empty directory. */
d338 2
d341 1
a341 1
       set_errno (ENOTEMPTY);
a342 2
  else if (GetLastError () == ERROR_DIRECTORY)
    set_errno (ENOTDIR);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
