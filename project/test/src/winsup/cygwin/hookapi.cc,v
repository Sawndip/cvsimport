head	1.31;
access;
symbols
	cygwin-1_7_35-release:1.31
	cygwin-1_7_34-release:1.31
	cygwin-1_7_33-release:1.31
	cygwin-1_7_32-release:1.31
	cygwin-1_7_31-release:1.31
	cygwin-1_7_30-release:1.31
	cygwin-1_7_29-release:1.31
	cygwin-1_7_29-release-branchpoint:1.31.0.2
	cygwin-pre-user-db:1.31
	cygwin-1_7_28-release:1.31
	cygwin-1_7_27-release:1.31
	cygwin-1_7_26-release:1.31
	cygwin-1_7_25-release:1.31
	cygwin-1_7_24-release:1.31
	cygwin-1_7_23-release:1.31
	cygwin-1_7_22-release:1.31
	cygwin-1_7_21-release:1.31
	cygwin-1_7_20-release:1.31
	cygwin-1_7_19-release:1.31
	cygwin-64bit-postmerge:1.31
	cygwin-64bit-premerge-branch:1.30.0.2
	cygwin-64bit-premerge:1.30
	cygwin-1_7_18-release:1.30
	post-ptmalloc3:1.29.2.5
	pre-ptmalloc3:1.29.2.5
	cygwin-1_7_17-release:1.30
	cygwin-64bit-branch:1.29.0.2
	cygwin-1_7_16-release:1.29
	cygwin-1_7_15-release:1.27
	cygwin-1_7_14_2-release:1.27
	cygwin-1_7_14-release:1.27
	cygwin-1_7_12-release:1.26
	cygwin-1_7_11-release:1.23
	cygwin-1_7_10-release:1.23
	signal-rewrite:1.22.0.2
	pre-notty:1.21
	cygwin-1_7_9-release:1.21
	cv-post-1_7_9:1.21.0.2
	cygwin-1_7_8-release:1.21
	cygwin-1_7_7-release:1.19
	cygwin-1_7_5-release:1.19
	cygwin-1_7_4-release:1.19
	cygwin-1_7_3-release:1.19
	cygwin-1_7_2-release:1.19
	fifo_doover3:1.19.0.4
	cygwin-1_7_1-release:1.19
	prefifo:1.19
	cv-branch-2:1.19.0.2
	pre-ripout-set_console_state_for_spawn:1.18
	EOL_registry_mounts:1.17
	preoverlapped:1.12
	drop_9x_support_start:1.12
	cr-0x5f1:1.12.0.2
	cv-branch:1.11.0.2
	pre-ptymaster-archetype:1.11
	cr-0x3b58:1.10.0.4
	cr-0x5ef:1.10.0.2
	after-mmap-privanon-noreserve:1.8
	after-mmap-revamp:1.8
	before-mmap-revamp:1.8
	cgf-more-exit-sync:1.8
	post_wait_sig_exit:1.7
	pre_wait_sig_exit:1.6;
locks; strict;
comment	@// @;


1.31
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.16.23.34.44;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.04.06.04.16;	author cgf;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2012.05.30.14.37.53;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.04.11.09.44;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2012.03.13.17.15.28;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2012.03.09.12.42.14;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2012.03.09.12.37.37;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2011.10.25.16.35.58;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.04.15.25.36;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2011.02.15.15.56.01;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2011.02.09.15.46.00;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.27.01.50.40;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.01.12.37.51;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.20.15.41.08;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.16.15.07.41;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.06.17.16.37;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.23.19.21.21;	author cgf;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2005.12.21.17.14.34;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.16.18.10.10;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.28.20.20.57;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.15.00.02.57;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.08.00.57.12;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.07.03.10.17;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.17.00.51.03;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.06.20.05.01;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.14.17.34.03;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.22.19.00.30;	author cgf;	state Exp;
branches;
next	;

1.29.2.1
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2012.11.08.17.25.47;	author corinna;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2012.12.10.13.40.34;	author corinna;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2013.02.12.11.24.35;	author corinna;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2013.02.15.13.36.36;	author corinna;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2013.03.29.14.07.14;	author corinna;	state Exp;
branches;
next	;

1.11.2.1
date	2006.07.06.19.10.32;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.31
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* hookapi.cc

   Copyright 2005, 2006, 2007, 2008, 2011, 2012, 2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <sys/param.h>
#include "ntdll.h"
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"

#define rva(coerce, base, addr) (coerce) ((char *) (base) + (addr))
#define rvacyg(coerce, addr) rva (coerce, cygwin_hmodule, addr)

struct function_hook
{
  const char *name;	// Function name, e.g. "DirectDrawCreateEx".
  const void *hookfn;	// Address of your function.
  void *origfn;		// Stored by HookAPICalls, the address of the original function.
};

/* Given an HMODULE, returns a pointer to the PE header. */
static PIMAGE_NT_HEADERS
PEHeaderFromHModule (HMODULE hModule, bool &is_64bit)
{
  PIMAGE_NT_HEADERS pNTHeader;

  if (PIMAGE_DOS_HEADER (hModule) ->e_magic != IMAGE_DOS_SIGNATURE)
    pNTHeader = NULL;
  else
    {
      pNTHeader = PIMAGE_NT_HEADERS (PBYTE (hModule)
				     + PIMAGE_DOS_HEADER (hModule) ->e_lfanew);
      if (pNTHeader->Signature != IMAGE_NT_SIGNATURE)
	pNTHeader = NULL;
      else if (pNTHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
      	is_64bit = true;
      else if (pNTHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
      	is_64bit = false;
      else
	pNTHeader = NULL;
    }

  return pNTHeader;
}

static long
rvadelta (PIMAGE_NT_HEADERS pnt, DWORD import_rva, DWORD &max_size)
{
  PIMAGE_SECTION_HEADER section = (PIMAGE_SECTION_HEADER) (pnt + 1);
  for (int i = 0; i < pnt->FileHeader.NumberOfSections; i++)
    if (section[i].VirtualAddress <= import_rva
	&& (section[i].VirtualAddress + section[i].Misc.VirtualSize) > import_rva)
      {
	max_size = section[i].SizeOfRawData
		   - (import_rva - section[i].VirtualAddress);
	return section[i].VirtualAddress - section[i].PointerToRawData;
      }
  return -1;
}

/* This function is only used for the current architecture.
   Just the size of the IMAGE_THUNK_DATA Function member differs. */
static void *
putmem (PIMAGE_THUNK_DATA pi, const void *hookfn)
{
#ifdef __x86_64__
#define THUNK_FUNC_TYPE ULONGLONG
#else
#define THUNK_FUNC_TYPE DWORD
#endif

  DWORD ofl;
  if (!VirtualProtect (pi, sizeof (THUNK_FUNC_TYPE), PAGE_READWRITE, &ofl) )
    return NULL;

  void *origfn = (void *) pi->u1.Function;
  pi->u1.Function = (THUNK_FUNC_TYPE) hookfn;

  VirtualProtect (pi, sizeof (THUNK_FUNC_TYPE), ofl, &ofl);
  return origfn;
}

/* Builds stubs for and redirects the IAT for one DLL (pImportDesc)
   This function is only used for the current architecture. */

static bool
RedirectIAT (function_hook& fh, PIMAGE_IMPORT_DESCRIPTOR pImportDesc,
	     HMODULE hm)
{
  // If no import names table, we can't redirect this, so bail
  if (pImportDesc->OriginalFirstThunk == 0)
      return false;

  /* import address table */
  PIMAGE_THUNK_DATA pt = rva (PIMAGE_THUNK_DATA, hm, pImportDesc->FirstThunk);
  /* import names table */
  PIMAGE_THUNK_DATA pn = rva (PIMAGE_THUNK_DATA, hm, pImportDesc->OriginalFirstThunk);

  /* Scan through the IAT, completing the stubs and redirecting the IAT
     entries to point to the stubs. */
  for (PIMAGE_THUNK_DATA pi = pt; pn->u1.Ordinal; pi++, pn++)
    {
      if (IMAGE_SNAP_BY_ORDINAL (pn->u1.Ordinal) )
	continue;

      /* import by name */
      PIMAGE_IMPORT_BY_NAME pimp = rva (PIMAGE_IMPORT_BY_NAME, hm, pn->u1.AddressOfData);

      if (strcmp (fh.name, (char *) pimp->Name) == 0)
	{
	  fh.origfn = putmem (pi, fh.hookfn);
	  if (!fh.origfn)
	    return false;
	  hook_chain *hc;
	  for (hc = &cygheap->hooks; hc->next; hc = hc->next)
	    continue;
	  hc->next = (hook_chain *) cmalloc_abort (HEAP_1_HOOK, sizeof (hook_chain));
	  hc->next->loc = (void **) pi;
	  hc->next->func = fh.hookfn;
	  hc->next->next = NULL;
	  break;
      }
  }

  return true;
}

/* This function is only used for the current architecture. */
static void
get_export (function_hook& fh)
{
  PIMAGE_DOS_HEADER pdh = (PIMAGE_DOS_HEADER) cygwin_hmodule;
  if (pdh->e_magic != IMAGE_DOS_SIGNATURE)
    return;
  PIMAGE_NT_HEADERS pnt = (PIMAGE_NT_HEADERS) ((char *) pdh + pdh->e_lfanew);
  if (pnt->Signature != IMAGE_NT_SIGNATURE || pnt->FileHeader.SizeOfOptionalHeader == 0)
    return;
  PIMAGE_EXPORT_DIRECTORY pexp =
    rvacyg (PIMAGE_EXPORT_DIRECTORY,
	 pnt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
  if (!pexp)
    return;

  PDWORD pfuncs = rvacyg (PDWORD, pexp->AddressOfFunctions);
  PDWORD pnames = rvacyg (PDWORD, pexp->AddressOfNames);
  for (DWORD i = 0; i < pexp->NumberOfNames; i++)
    if (strcmp (fh.name, rvacyg (char *, pnames[i])) == 0)
      {
	fh.origfn = rvacyg (void *, pfuncs[i]);
	break;
      }
}

static const char *
makename (const char *name, char *&buf, int& i, int inc)
{
  i += inc;
  static const char *testers[] = {"NOTUSED", "64", "32"};
  if (i < 0 || i >= (int) (sizeof (testers) / sizeof (testers[0])))
    return NULL;
  if (i)
    {
      __small_sprintf (buf, "_%s%s", name, testers[i]);
      name = buf;
    }
  return name;
}

static HMODULE
remap (PIMAGE_IMPORT_DESCRIPTOR &pdfirst, long &delta, HANDLE hc,
       DWORD importRVA, DWORD importRVASize, DWORD importRVAMaxSize)
{
  /* If h is not NULL, the calling function only mapped at most the first
     64K of the image.  The IAT is usually at the end of the image, so
     what we do here is to map the IAT into our address space if it doesn't
     reside in the first 64K anyway.  The offset must be a multiple of the
     allocation granularity, though, so we have to map a bit more. */
  HMODULE map;
  DWORD offset = rounddown (importRVA, wincap.allocation_granularity ());
  /* But that's not all, unfortunately.  Apparently there's a difference
     between the importRVASize of applications built with gcc and those
     built with Visual Studio.  When built with gcc, importRVASize contains
     the size of the import RVA table plus the size of the referenced
     string table with the DLL names.  When built with VS, it only contains
     the size of the naked import RVA table.  The following code handles
     the situation.  importRVAMaxSize contains the size of the remainder
     of the section.  If the difference between importRVAMaxSize and
     importRVASize is less than 64K, we just use importRVAMaxSize to
     compute the size of the memory map.  Otherwise the executable may be
     very big.  In that case we only map the import RVA table and ... */
  DWORD size = importRVA - offset + ((importRVAMaxSize - importRVASize
				      <= wincap.allocation_granularity ())
				     ? importRVAMaxSize : importRVASize);
  map = (HMODULE) MapViewOfFile (hc, FILE_MAP_READ, 0, offset, size);
  if (!map)
    return NULL;
  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, map, importRVA - offset);
  /* ... carefully check the required size to fit the string table into
     the map as well.  Allow NAME_MAX bytes for the DLL name, but don't
     go beyond the remainder of the section. */
  if (importRVAMaxSize - importRVASize > wincap.allocation_granularity ())
    {
      DWORD newsize = size;
      for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
	if (pd->Name - delta - offset + (NAME_MAX + 1) > newsize)
	  newsize = pd->Name - delta - offset + (NAME_MAX + 1);
      if (newsize > size)
	{
	  if (newsize > importRVA - offset + importRVAMaxSize)
	    newsize = importRVA - offset + importRVAMaxSize;
	  UnmapViewOfFile (map);
	  map = (HMODULE) MapViewOfFile (hc, FILE_MAP_READ, 0, offset, newsize);
	  if (!map)
	    return NULL;
	  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, map, importRVA - offset);
	}
    }
  delta += offset;
  return map;
}

/* Find first missing dll in a given executable.
   FIXME: This is not foolproof since it doesn't look for dlls in the
   same directory as the given executable, like Windows.  Instead it
   searches for dlls in the context of the current executable.
   It also only finds direct dependencies, not indirect ones. */
const char *
find_first_notloaded_dll (path_conv& pc)
{
  const char *res = "?";
  HANDLE hc = NULL;
  HMODULE hm = NULL;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  HANDLE h;
  NTSTATUS status;
  LARGE_INTEGER size;
  PIMAGE_NT_HEADERS pExeNTHdr;
  DWORD importRVA, importRVASize, importRVAMaxSize;
  HMODULE map;
  long delta;

  status = NtOpenFile (&h, SYNCHRONIZE | GENERIC_READ,
		       pc.get_object_attr (attr, sec_none_nih),
		       &io, FILE_SHARE_VALID_FLAGS,
		       FILE_SYNCHRONOUS_IO_NONALERT
		       | FILE_OPEN_FOR_BACKUP_INTENT
		       | FILE_NON_DIRECTORY_FILE);
  if (!NT_SUCCESS (status))
    goto out;
  /* Just as in hook_or_detect_cygwin below, we have to take big executables
     into account.  That means, we must not try to map the entire file, since
     there's no guarantee that the current process has enough VM in one block
     left for this mapping.  The offset computation below ignores very big
     executables for now.  In theory, since the import RVA table appears to
     be more or less at the end of the data section, independent of the used
     compiler, that shouldn't matter. */
  if (!GetFileSizeEx (h, &size))
    {
      NtClose (h);
      goto out;
    }
  if (size.QuadPart > (LONGLONG) wincap.allocation_granularity ())
    size.LowPart = wincap.allocation_granularity ();
  hc = CreateFileMapping (h, &sec_none_nih, PAGE_READONLY, 0, 0, NULL);
  NtClose (h);
  if (!hc)
    goto out;
  hm = (HMODULE) MapViewOfFile(hc, FILE_MAP_READ, 0, 0, size.LowPart);
  if (!hm)
    goto out;

  bool is_64bit;
  pExeNTHdr = PEHeaderFromHModule (hm, is_64bit);

  if (!pExeNTHdr)
    goto out;

#ifdef __x86_64__
  if (!is_64bit)
#else
  if (is_64bit)
#endif
    goto out;

  importRVA = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
  importRVASize = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
  if (!importRVA)
    goto out;

  delta = rvadelta (pExeNTHdr, importRVA, importRVAMaxSize);
  if (delta < 0)
    goto out;
  importRVA -= delta;
  map = NULL;

  PIMAGE_IMPORT_DESCRIPTOR pdfirst;

  if (importRVA + importRVAMaxSize > wincap.allocation_granularity ())
    {
      map = remap (pdfirst, delta, hc, importRVA, importRVASize,
		   importRVAMaxSize);
      if (!map)
	goto out;
    }
  else
    pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA);

  /* Iterate through each import descriptor, and check if DLL can be loaded. */
  for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
    {
      const char *lib = rva (PSTR, map ?: hm, pd->Name - delta);
      if (!LoadLibraryEx (lib, NULL, DONT_RESOLVE_DLL_REFERENCES
				     | LOAD_LIBRARY_AS_DATAFILE))
	{
	  static char buf[MAX_PATH];
	  strlcpy (buf, lib, MAX_PATH);
	  res = buf;
	}
    }
  if (map)
    UnmapViewOfFile (map);

out:
  if (hm)
    UnmapViewOfFile (hm);
  if (hc)
    CloseHandle (hc);

  return res;
}

// Top level routine to find the EXE's imports and redirect them
void *
hook_or_detect_cygwin (const char *name, const void *fn, WORD& subsys, HANDLE h)
{
  HMODULE hm = fn ? GetModuleHandle (NULL) : (HMODULE) name;
  bool is_64bit;
  PIMAGE_NT_HEADERS pExeNTHdr = PEHeaderFromHModule (hm, is_64bit);

  if (!pExeNTHdr)
    return NULL;

  /* Shortcut.  We don't have to do anything further from here, if the
     executable's architecture doesn't match, unless we want to support
     a mix of 32 and 64 bit Cygwin at one point. */
#ifdef __x86_64__
  if (!is_64bit)
#else
  if (is_64bit)
#endif
    return NULL;

  DWORD importRVA, importRVASize;
  subsys = pExeNTHdr->OptionalHeader.Subsystem;
  importRVA = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
  importRVASize = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
  if (!importRVA)
    return NULL;

  DWORD importRVAMaxSize = 0;
  long delta = fn ? 0 : rvadelta (pExeNTHdr, importRVA, importRVAMaxSize);
  if (delta < 0)
    return NULL;
  importRVA -= delta;

  // Convert imports RVA to a usable pointer
  PIMAGE_IMPORT_DESCRIPTOR pdfirst;
  char *map = NULL;
  if (h && importRVA + importRVAMaxSize > wincap.allocation_granularity ())
    {
      map = (char *) remap (pdfirst, delta, h, importRVA, importRVASize,
			    importRVAMaxSize);
      if (!map)
	return NULL;
    }
  else
    pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA);

  function_hook fh;
  fh.origfn = NULL;
  fh.hookfn = fn;
  char *buf = NULL;
  if (fn)
    buf = (char *) alloca (strlen (name) + sizeof ("_64"));
  int i = 0;
  // Iterate through each import descriptor, and redirect if appropriate
  for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
    {
      if (!ascii_strcasematch (rva (PSTR, map ?: (char *) hm, pd->Name - delta),
			       "cygwin1.dll"))
      	continue;
      if (!fn)
	{
	  /* Just checking if executable used cygwin1.dll. */
	  if (map)
	    UnmapViewOfFile (map);
	  return (void *) "found it";
	}
      i = -1;
      while (!fh.origfn && (fh.name = makename (name, buf, i, 1)))
	RedirectIAT (fh, pd, hm);
      if (fh.origfn)
	break;
    }

  if (map)
    UnmapViewOfFile (map);
  if (!fn)
    return NULL;

  while (!fh.origfn && (fh.name = makename (name, buf, i, -1)))
    get_export (fh);

  return fh.origfn;
}

void
ld_preload ()
{
  char *p = getenv ("LD_PRELOAD");
  if (!p)
    return;
  char *s = (char *) alloca (strlen (p) + 1);
  strcpy (s, p);
  char *here = NULL;
  for (p = strtok_r (s, ":\t\n", &here); p; p = strtok_r (NULL, ":\t\n", &here))
    {
      path_conv lib (p);
      WCHAR libname[lib.get_wide_win32_path_len () + 1];
      if (!LoadLibraryW (lib.get_wide_win32_path (libname)))
	{
	  __seterrno ();
	  api_fatal ("error while loading shared libraries: %s: "
		     "cannot open shared object file: %s", p,
		     strerror (get_errno ()));
	}
    }
}

void
fixup_hooks_after_fork ()
{
  for (hook_chain *hc = &cygheap->hooks; (hc = hc->next); )
    putmem ((PIMAGE_THUNK_DATA) hc->loc, hc->func);
}
@


1.30
log
@whitespace cleanup
@
text
@d3 1
a3 1
   Copyright 2005, 2006, 2007, 2008, 2011, 2012 Red Hat, Inc.
d32 1
a32 1
/* Given an HMODULE, returns a pointer to the PE header */
d34 1
a34 1
PEHeaderFromHModule (HMODULE hModule)
d38 1
a38 1
  if (PIMAGE_DOS_HEADER(hModule) ->e_magic != IMAGE_DOS_SIGNATURE)
d46 6
a63 1
    // if (ascii_strncasematch ((char *) section[i].Name, ".idata", IMAGE_SIZEOF_SHORT_NAME))
d72 2
d77 6
d84 1
a84 1
  if (!VirtualProtect (pi, sizeof (PVOID), PAGE_READWRITE, &ofl) )
d88 1
a88 1
  pi->u1.Function = (DWORD) hookfn;
d90 1
a90 1
  VirtualProtect (pi, sizeof (PVOID), ofl, &ofl);
d94 2
a95 1
/* Builds stubs for and redirects the IAT for one DLL (pImportDesc) */
d139 1
d180 53
d249 4
d274 1
a274 1
  if (size.QuadPart > wincap.allocation_granularity ())
d284 37
a320 2
  PIMAGE_NT_HEADERS pExeNTHdr;
  pExeNTHdr = PEHeaderFromHModule (hm);
d322 2
a323 1
  if (pExeNTHdr)
d325 3
a327 4
      DWORD importRVA;
      DWORD importRVAMaxSize;
      importRVA = pExeNTHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
      if (importRVA)
d329 3
a331 37
	  long delta = rvadelta (pExeNTHdr, importRVA, importRVAMaxSize);
	  if (delta < 0)
	    goto out;
	  importRVA -= delta;

	  DWORD offset = 0;
	  HMODULE map = NULL;
	  if (importRVA + importRVAMaxSize > wincap.allocation_granularity ())
	    {
	      offset = rounddown (importRVA, wincap.allocation_granularity ());
	      DWORD size = importRVA - offset + importRVAMaxSize;
	      map = (HMODULE) MapViewOfFile (hc, FILE_MAP_READ, 0,
					     offset, size);
	      if (!map)
		goto out;
	    }

	  // Convert imports RVA to a usable pointer
	  PIMAGE_IMPORT_DESCRIPTOR pdfirst;
	  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, map ?: hm,
			 importRVA - offset);

	  // Iterate through each import descriptor, and redirect if appropriate
	  for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
	    {
	      const char *lib = rva (PSTR, map ?: hm,
				     pd->Name - delta - offset);
	      if (!LoadLibraryEx (lib, NULL, DONT_RESOLVE_DLL_REFERENCES
					     | LOAD_LIBRARY_AS_DATAFILE))
		{
		  static char buf[MAX_PATH];
		  strlcpy (buf, lib, MAX_PATH);
		  res = buf;
		}
	    }
	  if (map)
	    UnmapViewOfFile (map);
d334 2
d351 2
a352 1
  PIMAGE_NT_HEADERS pExeNTHdr = PEHeaderFromHModule (hm);
d357 8
a364 2
  /* FIXME: This code has to be made 64 bit capable. */
  if (pExeNTHdr->FileHeader.Machine != IMAGE_FILE_MACHINE_I386)
d367 5
a371 5
  subsys =  pExeNTHdr->OptionalHeader.Subsystem;

  DWORD importRVA = pExeNTHdr->OptionalHeader.DataDirectory
		      [IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
  DWORD importRVASize = pExeNTHdr->OptionalHeader.DataDirectory
d376 1
a376 1
  DWORD importRVAMaxSize;
a384 1
  DWORD offset = 0;
d387 2
a388 22
      /* If h is not NULL, the calling function only mapped at most the first
	 64K of the image.  The IAT is usually at the end of the image, so
	 what we do here is to map the IAT into our address space if it doesn't
	 reside in the first 64K anyway.  The offset must be a multiple of the
	 allocation granularity, though, so we have to map a bit more. */
      offset = rounddown (importRVA, wincap.allocation_granularity ());
      /* But that's not all, unfortunately.  Apparently there's a difference
	 between the importRVASize of applications built with gcc and those
	 built with Visual Studio.  When built with gcc, importRVASize contains
	 the size of the import RVA table plus the size of the referenced
	 string table with the DLL names.  When built with VS, it only contains
	 the size of the naked import RVA table.  The following code handles
	 the situation.  importRVAMaxSize contains the size of the remainder
	 of the section.  If the difference between importRVAMaxSize and
	 importRVASize is less than 64K, we just use importRVAMaxSize to
	 compute the size of the memory map.  Otherwise the executable may be
	 very big.  In that case we only map the import RVA table and ... */
      DWORD size = importRVA - offset
		   + ((importRVAMaxSize - importRVASize
		       <= wincap.allocation_granularity ())
		      ? importRVAMaxSize : importRVASize);
      map = (char *) MapViewOfFile (h, FILE_MAP_READ, 0, offset, size);
a390 22
      pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, map, importRVA - offset);
      /* ... carefully check the required size to fit the string table into
	 the map as well.  Allow NAME_MAX bytes for the DLL name, but don't
	 go beyond the remainder of the section. */
      if (importRVAMaxSize - importRVASize > wincap.allocation_granularity ())
	{
	  DWORD newsize = size;
	  for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
	    if (pd->Name - delta - offset + (NAME_MAX + 1) > newsize)
	      newsize = pd->Name - delta - offset + (NAME_MAX + 1);
	  if (newsize > size)
	    {
	      if (newsize > importRVA - offset + importRVAMaxSize)
		newsize = importRVA - offset + importRVAMaxSize;
	      UnmapViewOfFile (map);
	      map = (char *) MapViewOfFile (h, FILE_MAP_READ, 0, offset,
					    newsize);
	      if (!map)
		return NULL;
	      pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, map, importRVA - offset);
	    }
	}
d405 3
a407 3
      if (!ascii_strcasematch (rva (PSTR, map ?: (char *) hm,
				    pd->Name - delta - offset), "cygwin1.dll"))
	continue;
d410 1
d413 1
a413 1
	  return (void *) "found it";	// just checking if executable used cygwin1.dll
@


1.29
log
@* hookapi.cc (find_first_notloaded_dll): Remove unused assignment of
importRVASize found by Clang.
@
text
@d332 1
a332 1
         the map as well.  Allow NAME_MAX bytes for the DLL name, but don't
@


1.29.2.1
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d332 1
a332 1
	 the map as well.  Allow NAME_MAX bytes for the DLL name, but don't
@


1.29.2.2
log
@	* cygheap.h (struct user_heap_info): Change type of chunk to SIZE_T.
	Remove unused slop member.
	* fork.cc (fork): Rename esp to stackp.  Add 64 bit asm expression to
	fetch stack pointer.
	(child_copy): Use platform independent types.
	* heap.cc (eval_start_address): Add comment. Disable 3GB code on 64 bit.
	(eval_initial_heap_size): Use platform independent types.  Fix debug
	printf format strings.
	(sbrk): Add comment.  Change argument type according to newlib
	definition.  Use platform independent types.  Drop unneeded else and
	move comment to the right spot.
	* hookapi.cc (PEHeaderFromHModule): Return PVOID.  Add comment to
	explain why.  Add bool parameter to return if target executable is
	64 bit or not.
	(rvadelta_get): New inline function to fetch section address platform
	independent.
	(rvadelta32, rvadelta64): Platform dependent wrappers.
	(rvadelta): Change to macro calling the platform dependent rvadelta
	wrappers.
	(putmem): Define platform dependent THUNK_FUNC_TYPE and use throughout.
	(RedirectIAT): Add comment.
	(get_export): Add comment.
	(find_first_notloaded_dll): Allow to fetch information in a platform
	and target independent way.
	(hook_or_detect_cygwin): Ditto.  Recognize the cyg64win1.dll file name
	as well.
	* kernel32.cc (CreateFileMappingW): Cast to avoid compiler warning.

	* fhandler.h (class fhandler_dev_tape): Replace mt_evt with an
	OVERLAPPED structure ov.
	* mtinfo.h (class mtinfo_part): Define members as int32_t rather than
	long.  Change member function declarations accordingly.
	(class mtinfo_drive): Ditto.  Store OVERLAPPED pointer rather than
	holding the full structure.  Add comment to explain why.
	* fhandler_tape.cc: Accommodate above changes throughout.
@
text
@d32 3
a34 4
/* Given an HMODULE, returns a pointer to the PE header.
   Return PVOID to make sure the caller handles 32 and 64 bit executables. */
static PVOID
PEHeaderFromHModule (HMODULE hModule, bool &is_64bit)
d38 1
a38 1
  if (PIMAGE_DOS_HEADER (hModule) ->e_magic != IMAGE_DOS_SIGNATURE)
a45 6
      else if (pNTHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
      	is_64bit = true;
      else if (pNTHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
      	is_64bit = false;
      else
	pNTHeader = NULL;
d48 1
a48 1
  return (PVOID) pNTHeader;
d51 2
a52 3
static inline int
rvadelta_get (WORD NumberOfSections, PIMAGE_SECTION_HEADER section,
	      DWORD import_rva, DWORD &max_size)
d54 2
a55 1
  for (int i = 0; i < NumberOfSections; i++)
d58 1
a66 21
static int
rvadelta32 (PIMAGE_NT_HEADERS32 pnt, DWORD import_rva, DWORD &max_size)
{
  PIMAGE_SECTION_HEADER section = (PIMAGE_SECTION_HEADER) (pnt + 1);
  return rvadelta_get (pnt->FileHeader.NumberOfSections, section,
		       import_rva, max_size);
}

static long
rvadelta64 (PIMAGE_NT_HEADERS64 pnt, DWORD import_rva, DWORD &max_size)
{
  PIMAGE_SECTION_HEADER section = (PIMAGE_SECTION_HEADER) (pnt + 1);
  return rvadelta_get (pnt->FileHeader.NumberOfSections, section,
		       import_rva, max_size);
}

#define rvadelta(p,i,m)	(is_64bit ? rvadelta64 ((PIMAGE_NT_HEADERS64) p, i, m) \
				  : rvadelta32 ((PIMAGE_NT_HEADERS32) p, i, m))

/* This function is only used for the current architecture.
   Just the size of the IMAGE_THUNK_DATA Function member differs. */
a69 6
#ifdef __x86_64__
#define THUNK_FUNC_TYPE ULONGLONG
#else
#define THUNK_FUNC_TYPE DWORD
#endif

d71 1
a71 1
  if (!VirtualProtect (pi, sizeof (THUNK_FUNC_TYPE), PAGE_READWRITE, &ofl) )
d75 1
a75 1
  pi->u1.Function = (THUNK_FUNC_TYPE) hookfn;
d77 1
a77 1
  VirtualProtect (pi, sizeof (THUNK_FUNC_TYPE), ofl, &ofl);
d81 1
a81 2
/* Builds stubs for and redirects the IAT for one DLL (pImportDesc)
   This function is only used for the current architecture. */
a124 1
/* This function is only used for the current architecture. */
a180 1
  PVOID pExeNTHdr;
d212 2
a213 2
  bool is_64bit;
  pExeNTHdr = PEHeaderFromHModule (hm, is_64bit);
d218 2
a219 4
      DWORD importRVAMaxSize = 0;

      importRVA = is_64bit ? ((PIMAGE_NT_HEADERS64) pExeNTHdr)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
			   : ((PIMAGE_NT_HEADERS32) pExeNTHdr)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
d276 1
a276 2
  bool is_64bit;
  PVOID pExeNTHdr = PEHeaderFromHModule (hm, is_64bit);
d282 4
a285 3
#define nthdr32		((PIMAGE_NT_HEADERS32) pExeNTHdr)
#define nthdr64		((PIMAGE_NT_HEADERS64) pExeNTHdr)
#define nthdr(x)	(is_64bit ? nthdr64->x : nthdr32->x)
d287 4
a290 21
  DWORD importRVA, importRVASize;
  if (is_64bit)
    {
      subsys =  ((PIMAGE_NT_HEADERS64) pExeNTHdr)->OptionalHeader.Subsystem;
      importRVA =
      	((PIMAGE_NT_HEADERS64) pExeNTHdr)->OptionalHeader.DataDirectory
			    [IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
      importRVASize =
	((PIMAGE_NT_HEADERS64) pExeNTHdr)->OptionalHeader.DataDirectory
			    [IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
    }
  else
    {
      subsys =  ((PIMAGE_NT_HEADERS32) pExeNTHdr)->OptionalHeader.Subsystem;
      importRVA =
      	((PIMAGE_NT_HEADERS32) pExeNTHdr)->OptionalHeader.DataDirectory
			    [IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
      importRVASize =
	((PIMAGE_NT_HEADERS32) pExeNTHdr)->OptionalHeader.DataDirectory
			    [IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
    }
d294 1
a294 1
  DWORD importRVAMaxSize = 0;
d367 1
a367 3
				    pd->Name - delta - offset), "cygwin1.dll")
	  && !ascii_strcasematch (rva (PSTR, map ?: (char *) hm,
				  pd->Name - delta - offset), "cyg64win1.dll"))
@


1.29.2.3
log
@	* hookapi.cc (hook_or_detect_cygwin): Only check for one cygwin DLL
	file name depending on executable target type.  Return value indicating
	executable target type.  Change comment accordingly.
	* path.h (enum path_types): Add FIXME comment to definition of
	PATH_OPEN.  Add PATH_64BITEXEC.
	(iscygexec32): New method.
	(iscygexec64): New method.
	(set_cygexec): Implement additionally with void * parameter to be able
	to set PATH_64BITEXEC if required.
@
text
@d422 4
a425 3
				    pd->Name - delta - offset),
			       is_64bit ? "cyg64win1.dll" : "cygwin1.dll"))
      	continue;
a427 1
	  /* Just checking if executable used cyg{64}win1.dll. */
d430 1
a430 2
	  /* The return value indicates the target CPU. */
	  return (void *) (is_64bit ? 64L : 32L);
@


1.29.2.4
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::open): Cast second parameter
	in roundup2 to same size as first parameter to make sure mask size is
	correct.
	* fhandler_process.cc (format_process_maps): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* hookapi.cc (find_first_notloaded_dll): Add cast.
	* spawn.cc (av::fixup): Ditto.
	* wincap.h: Add comment to explain the folowing change.
	(wincapc::page_size): Return size_t.
	(wincapc::allocation_granularity): Ditto.

	* mmap.cc: Throughout, accommodate the fact that AT_ROUND_TO_PAGE isn't
	support on 64 bit at all.
	(class mmap_allocator): New class to allocate mmap slots on x86_64.
	(mmap_alloc): Define global instant of mmap_allocator.
	(mmap64): Call mmap_alloc.alloc on x86_64.
@
text
@d3 1
a3 1
   Copyright 2005, 2006, 2007, 2008, 2011, 2012, 2013 Red Hat, Inc.
d238 1
a238 1
  if (size.QuadPart > (LONGLONG) wincap.allocation_granularity ())
@


1.29.2.5
log
@	* Makefile.in (toollibdir): Remove.  Revert to using tooldir instead.
	* configure.ac (DLL_NAME): Set to cygwin1.dll in x86_64 case, too.
	* configure: Regenerate.
	* cygwin.sc.in (SEARCH_DIR): Align to 32 bit search dir, use lib, rather
	than lib64.
	* cygwin64.din (LIBRARY): Set name to cygwin1.dll.
	* fhandler_process.cc (struct heap_info): Drop win_heap_info class
	and revert code to former heap_info implementation.
	(format_process_maps): Define heaps back to heap_info
	* hookapi.cc (hook_or_detect_cygwin): Add shortcut so the code does
	not search executable for being a Cygwin executable, if the architecture
	is not matching the current Cygwin.  Always use for "cygwin1.dll".
	* pinfo.cc (commune_process): Drop PICOM_HEAP_INFO code.
	(_pinfo::commune_request): Ditto.
	(_pinfo::win_heap_info): Remove.
	* pinfo.h (enum picom): Remove PICOM_HEAP_INFO.
@
text
@a348 10
  /* Shortcut.  We don't have to do anything further from here, if the
     executable's architecture doesn't match, unless we want to support
     a mix of 32 and 64 bit Cygwin at one point. */
#ifdef __x86_64__
  if (!is_64bit)
#else
  if (is_64bit)
#endif
    return NULL;

d423 1
a423 1
			       "cygwin1.dll"))
@


1.29.2.6
log
@	* autoload.cc: Drop old comment.
	* hookapi.cc (PEHeaderFromHModule): Return PIMAGE_NT_HEADERS.
	(rvadelta): Convert to function and merge in rvadelta_get.
	(remap): New function to have code for remapping big executables
	only once.
	(find_first_notloaded_dll): Simplify.  Don't handle different
	architecture at all.  Call remap.
	(hook_or_detect_cygwin): Ditto.
@
text
@d32 3
a34 2
/* Given an HMODULE, returns a pointer to the PE header. */
static PIMAGE_NT_HEADERS
d55 1
a55 1
  return pNTHeader;
d58 3
a60 2
static long
rvadelta (PIMAGE_NT_HEADERS pnt, DWORD import_rva, DWORD &max_size)
d62 1
a62 2
  PIMAGE_SECTION_HEADER section = (PIMAGE_SECTION_HEADER) (pnt + 1);
  for (int i = 0; i < pnt->FileHeader.NumberOfSections; i++)
d73 19
a199 53
static HMODULE
remap (PIMAGE_IMPORT_DESCRIPTOR &pdfirst, long &delta, HANDLE hc,
       DWORD importRVA, DWORD importRVASize, DWORD importRVAMaxSize)
{
  /* If h is not NULL, the calling function only mapped at most the first
     64K of the image.  The IAT is usually at the end of the image, so
     what we do here is to map the IAT into our address space if it doesn't
     reside in the first 64K anyway.  The offset must be a multiple of the
     allocation granularity, though, so we have to map a bit more. */
  HMODULE map;
  DWORD offset = rounddown (importRVA, wincap.allocation_granularity ());
  /* But that's not all, unfortunately.  Apparently there's a difference
     between the importRVASize of applications built with gcc and those
     built with Visual Studio.  When built with gcc, importRVASize contains
     the size of the import RVA table plus the size of the referenced
     string table with the DLL names.  When built with VS, it only contains
     the size of the naked import RVA table.  The following code handles
     the situation.  importRVAMaxSize contains the size of the remainder
     of the section.  If the difference between importRVAMaxSize and
     importRVASize is less than 64K, we just use importRVAMaxSize to
     compute the size of the memory map.  Otherwise the executable may be
     very big.  In that case we only map the import RVA table and ... */
  DWORD size = importRVA - offset + ((importRVAMaxSize - importRVASize
				      <= wincap.allocation_granularity ())
				     ? importRVAMaxSize : importRVASize);
  map = (HMODULE) MapViewOfFile (hc, FILE_MAP_READ, 0, offset, size);
  if (!map)
    return NULL;
  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, map, importRVA - offset);
  /* ... carefully check the required size to fit the string table into
     the map as well.  Allow NAME_MAX bytes for the DLL name, but don't
     go beyond the remainder of the section. */
  if (importRVAMaxSize - importRVASize > wincap.allocation_granularity ())
    {
      DWORD newsize = size;
      for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
	if (pd->Name - delta - offset + (NAME_MAX + 1) > newsize)
	  newsize = pd->Name - delta - offset + (NAME_MAX + 1);
      if (newsize > size)
	{
	  if (newsize > importRVA - offset + importRVAMaxSize)
	    newsize = importRVA - offset + importRVAMaxSize;
	  UnmapViewOfFile (map);
	  map = (HMODULE) MapViewOfFile (hc, FILE_MAP_READ, 0, offset, newsize);
	  if (!map)
	    return NULL;
	  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, map, importRVA - offset);
	}
    }
  delta += offset;
  return map;
}

d216 1
a216 4
  PIMAGE_NT_HEADERS pExeNTHdr;
  DWORD importRVA, importRVASize, importRVAMaxSize;
  HMODULE map;
  long delta;
d251 1
a251 26
  if (!pExeNTHdr)
    goto out;

#ifdef __x86_64__
  if (!is_64bit)
#else
  if (is_64bit)
#endif
    goto out;

  importRVA = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
  importRVASize = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
  if (!importRVA)
    goto out;

  delta = rvadelta (pExeNTHdr, importRVA, importRVAMaxSize);
  if (delta < 0)
    goto out;
  importRVA -= delta;
  map = NULL;

  PIMAGE_IMPORT_DESCRIPTOR pdfirst;

  if (importRVA + importRVAMaxSize > wincap.allocation_granularity ())
d253 2
a254 7
      map = remap (pdfirst, delta, hc, importRVA, importRVASize,
		   importRVAMaxSize);
      if (!map)
	goto out;
    }
  else
    pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA);
d256 3
a258 6
  /* Iterate through each import descriptor, and check if DLL can be loaded. */
  for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
    {
      const char *lib = rva (PSTR, map ?: hm, pd->Name - delta);
      if (!LoadLibraryEx (lib, NULL, DONT_RESOLVE_DLL_REFERENCES
				     | LOAD_LIBRARY_AS_DATAFILE))
d260 37
a296 3
	  static char buf[MAX_PATH];
	  strlcpy (buf, lib, MAX_PATH);
	  res = buf;
a298 2
  if (map)
    UnmapViewOfFile (map);
d315 1
a315 1
  PIMAGE_NT_HEADERS pExeNTHdr = PEHeaderFromHModule (hm, is_64bit);
d320 29
a358 9
  DWORD importRVA, importRVASize;
  subsys = pExeNTHdr->OptionalHeader.Subsystem;
  importRVA = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
  importRVASize = pExeNTHdr->OptionalHeader.DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
  if (!importRVA)
    return NULL;

d368 1
d371 22
a392 2
      map = (char *) remap (pdfirst, delta, h, importRVA, importRVASize,
			    importRVAMaxSize);
d395 22
d431 2
a432 1
      if (!ascii_strcasematch (rva (PSTR, map ?: (char *) hm, pd->Name - delta),
d437 1
a437 1
	  /* Just checking if executable used cygwin1.dll. */
d440 2
a441 1
	  return (void *) "found it";
@


1.28
log
@	* hookapi.cc (find_first_notloaded_dll): Extend comment.  Fix usage of
	mapped memory.  Shorten static library name buffer to MAX_PATH.  Use
	strlcpy to copy library name to buffer.  Only Unmap "map" if it has been
	Mapped before.
	* pinfo.cc (status_exit): Drop unneeded declaration of
	find_first_notloaded_dll in favor of the declaration in winsup.h.
@
text
@a217 1
      DWORD importRVASize;
a219 1
      importRVASize = pExeNTHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
@


1.27
log
@	* hookapi.cc (rvadelta): Compute max_size using SizeOfRawData rather
	than VirtualSize.
@
text
@d168 2
a169 1
   searches for dlls in the context of the current executable.  */
d230 1
a230 1
	  char *map = NULL;
d235 2
a236 1
	      map = (char *) MapViewOfFile (hc, FILE_MAP_READ, 0, offset, size);
d243 2
a244 1
	  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA - offset);
d249 2
a250 1
	      const char *lib = rva (PSTR, hm, pd->Name - delta - offset);
d254 3
a256 2
		  static char buf[NT_MAX_PATH];
		  res = strcpy (buf, lib);
d259 2
a260 1
	  UnmapViewOfFile (map);
@


1.26
log
@	* hookapi.cc (hook_or_detect_cygwin): Change condition when to use
	importRVAMaxSize or importRVASize for the mapping size.  Make sure
	to map never more than the section size.  Change comments accordingly.
@
text
@d60 1
a60 1
	max_size = section[i].Misc.VirtualSize
@


1.25
log
@	* hookapi.cc (find_first_notloaded_dll): Fix a compiler warning.
@
text
@d313 6
a318 4
	 the size of the naked import RVA table.  importRVAMaxSize contains the
	 size of the reminder of the section.  If that's less than 64K, we're
	 good.  Otherwise the executable is potentially *very* big.  In that
	 case we only map the naked import RVA table and ... */
d320 1
a320 1
		   + ((importRVA - offset + importRVAMaxSize
d328 3
a330 5
         the map as well.  Allow NAME_MAX bytes for the DLL name.  There's a
	 slim chance that the allocation will fail, if the string table is
	 right at the end of the last section in the file, but that's very
	 unlikely. */
      if (importRVA - offset + importRVAMaxSize > wincap.allocation_granularity ())
d336 1
a336 1
	  if (newsize > size )
d338 2
@


1.24
log
@	* hookapi.cc (rvadelta): Add parameter to return maximum available
	size from start of import RVA table to end of section.
	(find_first_notloaded_dll): Take big executables into account.  Use
	offset and size computation as in hook_or_detect_cygwin, just simpler.
	(hook_or_detect_cygwin): Return NULL rather than false througout.
	Change computation of required mapping size to take non-gcc compilers
	into account.  Explain the differences and what we do against them.
	Don't alloca buf if fn is NULL.  Never use buf if fn is NULL.

	Fix name and address in previous ChangeLog entry.
@
text
@d229 1
a229 1
	  char *map;
@


1.23
log
@	* hookapi.cc (hook_or_detect_cygwin): Take additional handle
	to a file mapping as parameter.  If this handle is not NULL,
	create another file mapping for the IAT.
	* spawn.cc (av::fixup): Only map the first 64K of an image and
	keep the mapping handle to use as argument to hook_or_detect_cygwin.
	* winsup.h (hook_or_detect_cygwin): Add mapping handle as default
	parameter in declaration.
@
text
@d3 1
a3 1
   Copyright 2005, 2006, 2007, 2008, 2011 Red Hat, Inc.
d52 1
a52 1
rvadelta (PIMAGE_NT_HEADERS pnt, DWORD import_rva)
d59 5
a63 1
      return section[i].VirtualAddress - section[i].PointerToRawData;
d179 1
d189 14
a202 1

d207 3
a209 2
  hm = (HMODULE) MapViewOfFile(hc, FILE_MAP_READ, 0, 0, 0);
  CloseHandle (hc);
d217 2
d220 1
d223 15
a237 1
	  long delta = rvadelta (pExeNTHdr, importRVA);
d241 1
a241 1
	  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA - delta);
d246 1
a246 1
	      const char *lib = rva (PSTR, hm, pd->Name - delta);
d254 1
d261 2
d275 5
a279 1
    return false;
d288 1
a288 1
    return false;
d290 2
a291 1
  long delta = fn ? 0 : rvadelta (pExeNTHdr, importRVA);
d293 1
a293 1
    return false;
d300 1
a300 1
  if (h && importRVA + importRVASize > wincap.allocation_granularity ())
d308 13
a320 1
      DWORD size = importRVA - offset + importRVASize;
d323 1
a323 1
	return false;
d325 21
d353 3
a355 1
  char *buf = (char *) alloca (strlen (name) + sizeof ("_64"));
d378 2
@


1.22
log
@	Throughout, open console handles with sharing for reading and writing.
	* dcrt0.cc (insert_file): Open file with full sharing allowed.
	* hookapi.cc (find_first_notloaded_dll): Ditto.
	* spawn.cc (av::fixup): Ditto.
@
text
@d13 1
d230 1
a230 1
hook_or_detect_cygwin (const char *name, const void *fn, WORD& subsys)
d242 2
d250 1
d253 19
a271 1
  PIMAGE_IMPORT_DESCRIPTOR pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA - delta);
d281 2
a282 1
      if (!ascii_strcasematch (rva (PSTR, hm, pd->Name - delta), "cygwin1.dll"))
d285 5
a289 1
	return (void *) "found it";	// just checking if executable used cygwin1.dll
d297 3
@


1.21
log
@	* Throughout fix copyright dates.
@
text
@d177 1
a177 1
		       &io, FILE_SHARE_READ | FILE_SHARE_WRITE,
@


1.20
log
@* hookapi.cc (hook_or_detect_cygwin): Prevent i from being considered
uninitialized by gcc.
@
text
@d3 1
a3 1
   Copyright 2005, 2006, 2007, 2008 Red Hat, Inc.
@


1.19
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d255 1
a255 1
  int i;
@


1.18
log
@Remove unneeded header files from source files throughout.
@
text
@d194 1
a194 16
  if (!pExeNTHdr)
    goto out;

  DWORD importRVA;
  importRVA = pExeNTHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
  if (!importRVA)
    goto out;

  long delta = rvadelta (pExeNTHdr, importRVA);

  // Convert imports RVA to a usable pointer
  PIMAGE_IMPORT_DESCRIPTOR pdfirst;
  pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA - delta);

  // Iterate through each import descriptor, and redirect if appropriate
  for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
d196 3
a198 3
      const char *lib = rva (PSTR, hm, pd->Name - delta);
      if (!LoadLibraryEx (lib, NULL, DONT_RESOLVE_DLL_REFERENCES
			             | LOAD_LIBRARY_AS_DATAFILE))
d200 17
a216 2
	  static char buf[NT_MAX_PATH];
	  res = strcpy (buf, lib);
@


1.17
log
@* hookapi.cc (find_first_notloaded_dll): New function.
* pinfo.cc (status_exit): New function.  Issue message when dll not found.  Use
find_first_notloaded_dll to find a nonexistent dll.
(pinfo::maybe_set_exit_code_from_windows): Call status_exit when exit code >=
0xc0000000UL.
* sigproc.cc (child_info::proc_retry): Return exit code when
STATUS_DLL_NOT_FOUND.
* spawn.cc (spawn_guts): Minor cleanup.
* syscalls.cc (close_all_files): Don't actually close stderr filehandle.  Just
make it noninheritable.
* winsup.h (find_first_notloaded_dll): Declare new function.
* ntdll.h: Add several missing NTSTATUS defines.
@
text
@a11 1
#include <imagehlp.h>
a12 1
#include <alloca.h>
a19 1
#include "pinfo.h"
@


1.16
log
@	* string.h: Re-enable inline strcasematch and strncasematch
	implementations and rename to ascii_strcasematch/ascii_strncasematch.
	* dcrt0.cc: Replace str[n]casematch with ascii_str[n]casematch where
	applicable.
	* environ.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
	* winf.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 2005, 2006 Red Hat, Inc.
d12 4
d22 1
a22 3
#include <stdlib.h>
#include <imagehlp.h>
#include <alloca.h>
d163 68
a230 1
// Top level routine to find the EXE's imports, and redirect them
@


1.15
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d58 1
a58 1
    // if (strncasematch ((char *) section[i].Name, ".idata", IMAGE_SIZEOF_SHORT_NAME))
d193 1
a193 1
      if (!strcasematch (rva (PSTR, hm, pd->Name - delta), "cygwin1.dll"))
@


1.14
log
@	* hookapi.cc (ld_preload): Call LoadLibraryW.
	* path.h (path_conv::get_wide_win32_path_len): Define.
@
text
@d110 1
a110 1
	  hc->next = (hook_chain *) cmalloc (HEAP_1_HOOK, sizeof (hook_chain));
@


1.13
log
@	* path.h (path_conv::operator char *): Delete.
	(path_conv::operator const char *): Delete.
	* dlfcn.cc: Throughout, replace path_conv::operator char * and
	path_conv::operator const char * by call to path_conv::get_win32
	for easier transition to UNICODE_PATHs.
	* fhandler_socket.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d222 2
a223 1
      if (!LoadLibrary (lib.get_win32 ()))
@


1.12
log
@* hookapi.cc: Add comment header
(putmem): Make static.
(get_export): Ditto.
(rvadelta): Ditto.  Don't assume that a section which ends where the import_rva
begins is the import list.
* child_info.h: Update copyright.
* fork.cc: Ditto.
@
text
@d222 1
a222 1
      if (!LoadLibrary (lib))
@


1.11
log
@* winsup.h (cygwin_hmodule): Declare.
* exceptions.cc (inside_kernel): Reverse return values to reflect function
name.  Return true if we're in cygwin1.dll or if we're executing in dll_entry.
(_cygtls::interrupt_now): Reflect reversal of inside_kernel return value.
* hookapi.cc (cygwin_hmodule): Remove declaration.
* init.cc (dll_entry): Use in_dllentry global to record that we are executing
in dllentry.
@
text
@d1 10
d51 1
a51 1
long
d57 1
a57 1
	&& (section[i].VirtualAddress + section[i].Misc.VirtualSize) >= import_rva)
d63 1
a63 1
void *
d121 1
a121 1
void
@


1.11.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@a0 10
/* hookapi.cc

   Copyright 2005, 2006 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

d41 1
a41 1
static long
d47 1
a47 1
	&& (section[i].VirtualAddress + section[i].Misc.VirtualSize) > import_rva)
d53 1
a53 1
static void *
d111 1
a111 1
static void
@


1.10
log
@* cygheap.cc (init_cygheap::manage_console_count): Revert previous change.
Handle this a different way.
* external.cc (cygwin_internal): Accommodate extra hook_or_detect_cygwin
argument.
* hookapi.cc (cygwin_internal): Fill in subsys variable with the subsystem of
the executable.
* spawn.cc (av::iscui): New variable.
(spawn_guts): Hide window when we don't have a console and this isn't
NT/XP/2003.
(av::fixup): Set iscui flag.
* winsup.h (hook_or_detect_cygwin): Accommodate extra argument.
@
text
@a113 1
  extern HMODULE cygwin_hmodule;
@


1.9
log
@* hookapi.cc (putmem): Remove query of previous memory protection since we get
that for free the first time we call VirtualProtect.
@
text
@d154 1
a154 1
hook_or_detect_cygwin (const char *name, const void *fn)
d162 2
@


1.8
log
@* hookapi.cc (hook_or_detect_cygwin): Correct inverted test for whether to
allocate a buffer by always allocating a buffer.
@
text
@d56 2
a57 13

  DWORD flOldProtect, flNewProtect, flDontCare;
  MEMORY_BASIC_INFORMATION mbi;

  /* Get the current protection attributes */
  VirtualQuery (pi, &mbi, sizeof (mbi));

  /* Remove ReadOnly and ExecuteRead attributes, add on ReadWrite flag */
  flNewProtect = mbi.Protect;
  flNewProtect &= ~(PAGE_READONLY | PAGE_EXECUTE_READ);
  flNewProtect |= PAGE_READWRITE;

  if (!VirtualProtect (pi, sizeof (PVOID), flNewProtect, &flOldProtect) )
d63 1
a63 1
  VirtualProtect (pi, sizeof (PVOID), flOldProtect, &flDontCare);
@


1.7
log
@* hookapi.cc (hook_or_detect_cygwin): Simplify very slightly.
* spawn.cc (av::fixup): Guard against problems reading an executable which does
not match Microsoft's documentation about PE format.
@
text
@d188 1
a188 1
  char *buf = fn ? NULL : (char *) alloca (strlen (name) + sizeof ("_64"));
@


1.6
log
@* hookapi.cc (rvadelta): Change argument to DWORD to eliminate a compiler
warning.
* path.h (path_conv::set_cygexec): New function.
* spawn.cc (av::iscygwin): Eliminate.
(av::av): Don't initialize iscygwin.
(spawn_guts): Just use real_path.iscygexec for all tests.
(av::fixup): Short circuit test if .exe extension and known cygexec.  Set
cygexec flag appropriately if we find that program uses cygwin1.dll.
@
text
@d188 1
a188 1
  char *buf = fn ? NULL : (char *) alloca (strlen (name) + strlen ("64") + sizeof ("_"));
@


1.5
log
@* dcrt0.cc (initial_env): Don't attempt stracing if dynamically loaded.
(dll_crt0_0): Move console initialization earlier.
* init.cc (dll_entry): Move console initialization here.
* exceptions.cc (init_console_handler): Fully remove any old console handler.
* spawn.cc (spawn_guts): Don't fill out windows argv if we've deduced that this
is a cygwin-using program.
(av::fixup): Always check executables to see if they are using cygwin1.dll.
Don't consider .com files to be scripts.
* hookapi.cc (rvadelta): New function.
(PEHeaderFromHModule): Simplify slightly.
(hook_or_detect_cygwin): Use passed in name argument for "HMODULE" rather than
incorrectly reading current program.  Calculate delta needed to read image data
and file names if this isn't a real "HMODULE".
@
text
@d42 1
a42 1
rvadelta (PIMAGE_NT_HEADERS pnt, long import_rva)
@


1.4
log
@* child_info.h (child_info::sync): Pass pid and HANDLE rather than using pinfo.
(child_info::child_info): Accept an argument controlling whether to create
proc_subproc.
(child_info_spawn::child_info_spawn): Ditto.
* sigproc.cc (child_info::child_info): Ditto.
(child_info_spawn::child_info_spawn): Ditto.
(child_info::sync): Use passed in pid and HANDLE.
* fork.cc (fork_parent): Reflect additional arguments required for
child_info::sync.
* hookapi.cc (hook_or_detect_cygwin): Rename.  Change so that NULL 'fn'
argument just returns "true", indicating that program uses cygwin1.dll.
* spawn.cc (av::win16_exe): New element.
* spawn.cc (av::iscygwin): New element.
(av::fixup): New function.
(spawn_guts): Protect against SEGV.  Use fixup function to detect when it is
safe to wait for a spawned (as opposed to an execed) program.  Reflect changes
in child_info::sync arguments.
* external.cc (cygwin_internal): Reflect function renaming to
hook_or_detect_cygwin.
* cygheap.cc (cygheap_fixup_in_child): Close handle after debug fixup has been
done to prevent false positives in handle collision.
* exceptions.cc (try_to_debug): Notify debugger if already being debugged.
@
text
@d26 1
a26 1
  PIMAGE_NT_HEADERS pNTHeader = NULL;
d29 1
a29 1
    /* nothing */;
d41 12
d167 1
a167 1
  HMODULE hm = GetModuleHandle (NULL);
d178 4
d183 1
a183 1
  PIMAGE_IMPORT_DESCRIPTOR pdfirst = rva (PIMAGE_IMPORT_DESCRIPTOR, hm, importRVA);
d188 1
a188 1
  char *buf = (char *) alloca (strlen (name) + strlen ("64") + sizeof ("_"));
d193 1
a193 1
      if (!strcasematch (rva (PSTR, hm, pd->Name), "cygwin1.dll"))
@


1.3
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d153 1
a153 1
hook_cygwin (const char *name, const void *fn)
d173 3
a175 2
  int i = -1;
  while (!fh.origfn && (fh.name = makename (name, buf, i, 1)))
d177 9
a185 7
      // Iterate through each import descriptor, and redirect if appropriate
      for (PIMAGE_IMPORT_DESCRIPTOR pd = pdfirst; pd->FirstThunk; pd++)
	{
	  PSTR modname = rva (PSTR, hm, pd->Name);
	  if (strcasematch (modname, "cygwin1.dll"))
	    RedirectIAT (fh, pd, hm);
	}
@


1.2
log
@* dcrt0.cc (do_global_dtors): Run DLL dtors.
(__main): Don't rely on atexit to run dtors.
(do_exit): Specifically call do_global_dtors here.
(cygwin_exit): Ditto.
* dll_init.cc (dll_global_dtors): Make global.  Only run dtors once.
(dll_list::init): Just set flag that dtors should be run.  Don't rely on
atexit.
* dll_init.h (dll_global_dtors): Declare.
* exceptions.cc (sigrelse): Define.
* path.h (is_fs_device): New method.
(is_lnk_special): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::link): Use "is_lnk_special" rather
than "is_lnk_symlink".
* syscalls.cc (rename): Ditto.
* hookapi.cc (ld_preload): Use colon as a separator rather than space.
@
text
@d62 1
a62 1
  (void) VirtualProtect (pi, sizeof (PVOID), flOldProtect, &flDontCare);
@


1.1
log
@* Makefile.in (DLL_OFILES): Add hookapi.o.  Eliminate some cruft.
* cygheap.h (cygheap_types): Add new enum: HEAP_1_HOOK.
(hook_chain): New struct.
(init_cygheap::hooks): Define new element.
* cygheap.cc (cygheap_fixup_in_child): Zero hook chain on exec.
* dcrt0.cc (dll_crt0_1): Call ld_preload just before calling main function.
* external.cc (cygwin_internal): Implement CW_HOOK.
* fork.cc (fork_child): Call fixup_hooks_after_fork.
* init.cc (cygwin_hmodule): Reinstate after a long absence.
* include/sys/cygwin.h: Define CW_HOOK.
* hookapi.cc: New file.
* select.cc (start_thread_socket): Add debugging output.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): gcc 4.x accommodation.
* fhandler_socket.cc (fhandler_socket::connect): Make sure that err is
initialized.
@
text
@d200 1
a200 1
  for (p = strtok_r (s, " \t\n", &here); p; p = strtok_r (NULL, " \t\n", &here))
@

