head	1.25;
access;
symbols
	cygwin-1_7_35-release:1.25
	cygwin-1_7_34-release:1.25
	cygwin-1_7_33-release:1.24.2.1
	cygwin-1_7_32-release:1.24.2.1
	cygwin-1_7_31-release:1.24.2.1
	cygwin-1_7_30-release:1.24
	cygwin-1_7_29-release:1.24
	cygwin-1_7_29-release-branchpoint:1.24.0.2
	cygwin-pre-user-db:1.24
	cygwin-1_7_28-release:1.24
	cygwin-1_7_27-release:1.24
	cygwin-1_7_26-release:1.24
	cygwin-1_7_25-release:1.24
	cygwin-1_7_24-release:1.24
	cygwin-1_7_23-release:1.24
	cygwin-1_7_22-release:1.24
	cygwin-1_7_21-release:1.24
	cygwin-1_7_20-release:1.24
	cygwin-1_7_19-release:1.24
	cygwin-64bit-postmerge:1.23
	cygwin-64bit-premerge-branch:1.22.0.2
	cygwin-64bit-premerge:1.22
	cygwin-1_7_18-release:1.22
	post-ptmalloc3:1.21.2.4
	pre-ptmalloc3:1.21.2.4
	cygwin-1_7_17-release:1.22
	cygwin-64bit-branch:1.21.0.2
	cygwin-1_7_16-release:1.20
	cygwin-1_7_15-release:1.19
	cygwin-1_7_14_2-release:1.19
	cygwin-1_7_14-release:1.19
	cygwin-1_7_12-release:1.19
	cygwin-1_7_11-release:1.19
	cygwin-1_7_10-release:1.18
	signal-rewrite:1.17.0.2
	pre-notty:1.17
	cygwin-1_7_9-release:1.16
	cv-post-1_7_9:1.16.0.4
	cygwin-1_7_8-release:1.16
	cygwin-1_7_7-release:1.16
	cygwin-1_7_5-release:1.16
	cygwin-1_7_4-release:1.16
	cygwin-1_7_3-release:1.16
	cygwin-1_7_2-release:1.16
	fifo_doover3:1.16.0.2
	cygwin-1_7_1-release:1.16
	prefifo:1.14
	cv-branch-2:1.14.0.2
	pre-ripout-set_console_state_for_spawn:1.11
	EOL_registry_mounts:1.9;
locks; strict;
comment	@// @;


1.25
date	2014.05.19.10.42.04;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.16.23.34.45;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2012.07.29.21.42.10;	author cgf;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2012.05.17.02.18.41;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2012.02.15.15.33.56;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.30.09.02.30;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.20.14.52.43;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.23.15.48.16;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.23.13.59.13;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.21.12.46.57;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.07.18.45.58;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.14.20.43.28;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.02.22.25.07;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.04.12.00.19;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.31.20.26.01;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.06.18.24.06;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.01.07.39.21;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.31.20.48.17;	author corinna;	state Exp;
branches;
next	;

1.24.2.1
date	2014.07.16.09.54.56;	author corinna;	state Exp;
branches;
next	;

1.21.2.1
date	2012.10.16.15.18.39;	author corinna;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2012.10.24.14.16.29;	author corinna;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2012.10.26.10.49.52;	author corinna;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2012.10.30.16.52.33;	author corinna;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2013.03.12.14.59.58;	author corinna;	state Exp;
branches;
next	1.21.2.6;

1.21.2.6
date	2013.04.08.10.03.11;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.25
log
@	* smallprintf.cc (__small_vsprintf): Add missing break in 'C' case.
@
text
@/* smallprint.cc: small print routines for WIN32

   Copyright 1996, 1998, 2000, 2001, 2002, 2003, 2005, 2006,
	     2007, 2008, 2009, 2012, 2013, 2014
   Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "ntdll.h"
#include "sync.h"
#include <stdlib.h>
#include <ctype.h>
#include <wchar.h>

#define LLMASK	(0xffffffffffffffffULL)
#define LMASK	(0xffffffff)

#define rnarg(dst, base, dosign, len, pad) __rn ((dst), (base), (dosign), va_arg (ap, int32_t), len, pad, LMASK)
#define rnargLL(dst, base, dosign, len, pad) __rn ((dst), (base), (dosign), va_arg (ap, uint64_t), len, pad, LLMASK)

static const char hex_str[] = "0123456789ABCDEF";

class tmpbuf
{
  static WCHAR buf[NT_MAX_PATH];
  static muto lock;
  bool locked;
public:
  operator WCHAR * ()
  {
    if (!locked)
      {
	lock.init ("smallprint_buf")->acquire ();
	locked = true;
      }
    return buf;
  }
  operator char * () {return (char *) ((WCHAR *) *this);}

  tmpbuf (): locked (false) {};
  ~tmpbuf ()
  {
    if (locked)
      lock.release ();
  }
};

WCHAR tmpbuf::buf[NT_MAX_PATH];
muto tmpbuf::lock;

static char __fastcall *
__rn (char *dst, int base, int dosign, long long val, int len, int pad, unsigned long long mask)
{
  /* longest number is ULLONG_MAX, 18446744073709551615, 20 digits */
  unsigned long long uval = 0;
  char res[20];
  int l = 0;

  if (dosign && val < 0)
    {
      *dst++ = '-';
      uval = -val;
    }
  else if (dosign > 0 && val > 0)
    {
      *dst++ = '+';
      uval = val;
    }
  else
    uval = val;

  uval &= mask;

  do
    {
      res[l++] = hex_str[uval % base];
      uval /= base;
    }
  while (uval);

  while (len-- > l)
    *dst++ = pad;

  while (l > 0)
    *dst++ = res[--l];

  return dst;
}

/*
  Meaning of format conversion specifiers.  If 'l' isn't explicitely mentioned,
  it's ignored!

   c       char
   C       WCHAR/wchar_t
   d       signed int, 4 byte
  ld       signed long, 4 byte on 32 bit, 8 byte on 64 bit
   D       signed long long, 8 byte
   E       GetLastError
   o       octal unsigned int, 4 byte
  lo       octal unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   O       octal unsigned long long, 8 byte
   p       address
   P       process name
   R       return value, 4 byte.
  lR       return value, 4 byte on 32 bit, 8 byte on 64 bit.
   s       char *
  ls       char * w/ non-ASCII tweaking
   S       PUNICODE_STRING
  lS       PUNICODE_STRING w/ non-ASCII tweaking
   u       unsigned int, 4 byte
  lu       unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   U       unsigned long long, 8 byte
   W       PWCHAR/wchar_t *
  lW       PWCHAR/wchar_t * w/ non-ASCII tweaking
   x       hex unsigned int, 4 byte
  lx       hex unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   X       hex unsigned long long, 8 byte
   y       0x hex unsigned int, 4 byte
  ly       0x hex unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   Y       0x hex unsigned long long, 8 byte
*/

int
__small_vsprintf (char *dst, const char *fmt, va_list ap)
{
  tmpbuf tmp;
  char *orig = dst;
  const char *s;
  PWCHAR w;
  UNICODE_STRING uw, *us;
  int base = 0;

  DWORD err = GetLastError ();

  intptr_t Rval = 0;
  while (*fmt)
    {
      int i, n = 0x7fff;
      bool l_opt = false;
      if (*fmt != '%')
	*dst++ = *fmt++;
      else
	{
	  int len = 0;
	  char pad = ' ';
	  int addsign = -1;

	  switch (*++fmt)
	  {
	    case '+':
	      addsign = 1;
	      fmt++;
	      break;
	    case '%':
	      *dst++ = *fmt++;
	      continue;
	  }

	  for (;;)
	    {
	      char c = *fmt++;
	      switch (c)
		{
		case '0':
		  if (len == 0)
		    {
		      pad = '0';
		      continue;
		    }
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
		  len = len * 10 + (c - '0');
		  continue;
		case 'l':
		  l_opt = true;
		  continue;
		case 'c':
		  {
		    unsigned char c = (va_arg (ap, int) & 0xff);
		    if (isprint (c) || pad != '0')
		      *dst++ = c;
		    else
		      {
			*dst++ = '0';
			*dst++ = 'x';
			dst = __rn (dst, 16, 0, c, len, pad, LMASK);
		      }
		  }
		  break;
		case 'C':
		  {
		    WCHAR wc = (WCHAR) va_arg (ap, int);
		    char buf[4], *c;
		    sys_wcstombs (buf, 4, &wc, 1);
		    for (c = buf; *c; ++c)
		      *dst++ = *c;
		  }
		  break;
		case 'E':
		  strcpy (dst, "Win32 error ");
		  dst = __rn (dst + sizeof ("Win32 error"), 10, 0, err, len, pad, LMASK);
		  break;
		case 'R':
		  {
#ifdef __x86_64__
		    if (l_opt)
		      Rval = va_arg (ap, int64_t);
		    else
#endif
		      Rval = va_arg (ap, int32_t);
		    dst = __rn (dst, 10, addsign, Rval, len, pad, LMASK);
		  }
		  break;
		case 'd':
		  base = 10;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'u':
		  base = 10;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'o':
		  base = 8;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
		case 'x':
		  base = 16;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
gen_decimal:
		  dst = rnarg (dst, base, addsign, len, pad);
		  break;
		case 'D':
		  base = 10;
		  goto gen_decimalLL;
		case 'U':
		  base = 10;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'O':
		  base = 8;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'Y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
		case 'X':
		  base = 16;
		  addsign = 0;
gen_decimalLL:
		  dst = rnargLL (dst, base, addsign, len, pad);
		  break;
		case 'p':
		  *dst++ = '0';
		  *dst++ = 'x';
#ifdef __x86_64__
		  dst = rnargLL (dst, 16, 0, len, pad);
#else
		  dst = rnarg (dst, 16, 0, len, pad);
#endif
		  break;
		case 'P':
		  if (!GetModuleFileName (NULL, tmp, NT_MAX_PATH))
		    s = "cygwin program";
		  else
		    s = tmp;
		  goto fillin;
		case '.':
		  n = strtol (fmt, (char **) &fmt, 10);
		  if (*fmt++ != 's')
		    goto endfor;
		case 's':
		  s = va_arg (ap, char *);
		  if (s == NULL)
		    s = "(null)";
		fillin:
		  for (i = 0; *s && i < n; i++)
		    if (l_opt && ((*(unsigned char *)s <= 0x1f && *s != '\n')
				  || *(unsigned char *)s >= 0x7f))
		      {
			*dst++ = '\\';
			*dst++ = 'x';
			*dst++ = hex_str[*(unsigned char *)s >> 4];
			*dst++ = hex_str[*(unsigned char *)s++ & 0xf];
		      }
		    else
		      *dst++ = *s++;
		  break;
		case 'W':
		  w = va_arg (ap, PWCHAR);
		  RtlInitUnicodeString (us = &uw, w ?: L"(null)");
		  goto wfillin;
		case 'S':
		  us = va_arg (ap, PUNICODE_STRING);
		  if (!us)
		    RtlInitUnicodeString (us = &uw, L"(null)");
		wfillin:
		  if (l_opt)
		    {
		      for (USHORT i = 0; i < us->Length / sizeof (WCHAR); ++i)
			{
			  WCHAR w = us->Buffer[i];
			  if ((w <= 0x1f && w != '\n') || w >= 0x7f)
			    {
			      *dst++ = '\\';
			      *dst++ = 'x';
			      *dst++ = hex_str[(w >> 12) & 0xf];
			      *dst++ = hex_str[(w >>  8) & 0xf];
			      *dst++ = hex_str[(w >>  4) & 0xf];
			      *dst++ = hex_str[w & 0xf];
			    }
			  else
			    *dst++ = w;
			}
		    }
		  else if (sys_wcstombs (tmp, NT_MAX_PATH, us->Buffer,
				    us->Length / sizeof (WCHAR)))
		    {
		      s = tmp;
		      goto fillin;
		    }
		  break;
		default:
		  *dst++ = '?';
		  *dst++ = fmt[-1];
		}
	    endfor:
	      break;
	    }
	}
    }
  if (Rval < 0)
    {
      dst = stpcpy (dst, ", errno ");
      dst = __rn (dst, 10, false, get_errno (), 0, 0, LMASK);
    }
  *dst = 0;
  SetLastError (err);
  return dst - orig;
}

int
__small_sprintf (char *dst, const char *fmt, ...)
{
  int r;
  va_list ap;
  va_start (ap, fmt);
  r = __small_vsprintf (dst, fmt, ap);
  va_end (ap);
  return r;
}

void
small_printf (const char *fmt, ...)
{
  char buf[16384];
  va_list ap;
  DWORD done;
  int count;

#if 0	/* Turn on to force console errors */
  extern SECURITY_ATTRIBUTES sec_none;
  HANDLE h = CreateFileA ("CONOUT$", GENERIC_READ|GENERIC_WRITE,
		   FILE_SHARE_WRITE | FILE_SHARE_WRITE, &sec_none,
		   OPEN_EXISTING, 0, 0);
  if (h)
    SetStdHandle (STD_ERROR_HANDLE, h);
#endif

  va_start (ap, fmt);
  count = __small_vsprintf (buf, fmt, ap);
  va_end (ap);

  WriteFile (GetStdHandle (STD_ERROR_HANDLE), buf, count, &done, NULL);
  FlushFileBuffers (GetStdHandle (STD_ERROR_HANDLE));
}

#ifdef DEBUGGING
static HANDLE NO_COPY console_handle = NULL;
void
console_printf (const char *fmt, ...)
{
  char buf[16384];
  va_list ap;
  DWORD done;
  int count;

  if (!console_handle)
    console_handle = CreateFileA ("CON", GENERIC_WRITE,
				  FILE_SHARE_READ | FILE_SHARE_WRITE,
				  NULL, OPEN_EXISTING, 0, 0);

  if (console_handle == INVALID_HANDLE_VALUE)
    console_handle = GetStdHandle (STD_ERROR_HANDLE);

  va_start (ap, fmt);
  count = __small_vsprintf (buf, fmt, ap);
  va_end (ap);

  WriteFile (console_handle, buf, count, &done, NULL);
  FlushFileBuffers (console_handle);
}
#endif

#define wrnarg(dst, base, dosign, len, pad) __wrn ((dst), (base), (dosign), va_arg (ap, long), len, pad, LMASK)
#define wrnargLL(dst, base, dosign, len, pad) __wrn ((dst), (base), (dosign), va_arg (ap, unsigned long long), len, pad, LLMASK)

static PWCHAR __fastcall
__wrn (PWCHAR dst, int base, int dosign, long long val, int len, int pad, unsigned long long mask)
{
  /* longest number is ULLONG_MAX, 18446744073709551615, 20 digits */
  unsigned long long uval = 0;
  WCHAR res[20];
  int l = 0;

  if (dosign && val < 0)
    {
      *dst++ = L'-';
      uval = -val;
    }
  else if (dosign > 0 && val > 0)
    {
      *dst++ = L'+';
      uval = val;
    }
  else
    uval = val;

  uval &= mask;

  do
    {
      res[l++] = hex_str[uval % base];
      uval /= base;
    }
  while (uval);

  while (len-- > l)
    *dst++ = pad;

  while (l > 0)
    *dst++ = res[--l];

  return dst;
}

int
__small_vswprintf (PWCHAR dst, const WCHAR *fmt, va_list ap)
{
  tmpbuf tmp;
  PWCHAR orig = dst;
  const char *s;
  PWCHAR w;
  UNICODE_STRING uw, *us;
  int base = 0;

  DWORD err = GetLastError ();

  intptr_t Rval = 0;
  while (*fmt)
    {
      unsigned int n = 0x7fff;
#ifdef __x86_64__
      bool l_opt = false;
#endif
      if (*fmt != L'%')
	*dst++ = *fmt++;
      else
	{
	  int len = 0;
	  WCHAR pad = L' ';
	  int addsign = -1;

	  switch (*++fmt)
	  {
	    case L'+':
	      addsign = 1;
	      fmt++;
	      break;
	    case L'%':
	      *dst++ = *fmt++;
	      continue;
	  }

	  for (;;)
	    {
	      char c = *fmt++;
	      switch (c)
		{
		case L'0':
		  if (len == 0)
		    {
		      pad = L'0';
		      continue;
		    }
		case L'1' ... L'9':
		  len = len * 10 + (c - L'0');
		  continue;
		case L'l':
#ifdef __x86_64__
		  l_opt = true;
#endif
		  continue;
		case L'c':
		case L'C':
		  *dst++ = va_arg (ap, unsigned);
		  break;
		case L'E':
		  wcscpy (dst, L"Win32 error ");
		  dst = __wrn (dst + sizeof ("Win32 error"), 10, 0, err, len, pad, LMASK);
		  break;
		case 'R':
		  {
#ifdef __x86_64__
		    if (l_opt)
		      Rval = va_arg (ap, int64_t);
		    else
#endif
		      Rval = va_arg (ap, int32_t);
		    dst = __wrn (dst, 10, addsign, Rval, len, pad, LMASK);
		  }
		  break;
		case L'd':
		  base = 10;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'u':
		  base = 10;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'o':
		  base = 8;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
		case 'x':
		  base = 16;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
gen_decimal:
		  dst = wrnarg (dst, base, addsign, len, pad);
		  break;
		case 'D':
		  base = 10;
		  goto gen_decimalLL;
		case 'U':
		  base = 10;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'O':
		  base = 8;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'Y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
		case 'X':
		  base = 16;
		  addsign = 0;
gen_decimalLL:
		  dst = wrnargLL (dst, base, addsign, len, pad);
		  break;
		case L'p':
		  *dst++ = L'0';
		  *dst++ = L'x';
#ifdef __x86_64__
		  dst = wrnargLL (dst, 16, 0, len, pad);
#else
		  dst = wrnarg (dst, 16, 0, len, pad);
#endif
		  break;
		case L'P':
		  if (!GetModuleFileNameW (NULL, tmp, NT_MAX_PATH))
		    RtlInitUnicodeString (us = &uw, L"cygwin program");
		  else
		    RtlInitUnicodeString (us = &uw, tmp);
		  goto fillin;
		case L'.':
		  n = wcstoul (fmt, (wchar_t **) &fmt, 10);
		  if (*fmt++ != L's')
		    goto endfor;
		case L's':
		  s = va_arg (ap, char *);
		  if (s == NULL)
		    s = "(null)";
		  sys_mbstowcs (tmp, NT_MAX_PATH, s, n < 0x7fff ? (int) n : -1);
		  RtlInitUnicodeString (us = &uw, tmp);
		  goto fillin;
		  break;
		case L'W':
		  w = va_arg (ap, PWCHAR);
		  RtlInitUnicodeString (us = &uw, w ?: L"(null)");
		  goto fillin;
		case L'S':
		  us = va_arg (ap, PUNICODE_STRING);
		  if (!us)
		    RtlInitUnicodeString (us = &uw, L"(null)");
		fillin:
		  if (us->Length / sizeof (WCHAR) < n)
		    n = us->Length / sizeof (WCHAR);
		  w = us->Buffer;
		  for (unsigned int i = 0; i < n; i++)
		    *dst++ = *w++;
		  break;
		default:
		  *dst++ = L'?';
		  *dst++ = fmt[-1];
		}
	    endfor:
	      break;
	    }
	}
    }
  if (Rval < 0)     
    {
      dst = wcpcpy (dst, L", errno ");
      dst = __wrn (dst, 10, false, get_errno (), 0, 0, LMASK);
    }
  *dst = L'\0';
  SetLastError (err);
  return dst - orig;
}

int
__small_swprintf (PWCHAR dst, const WCHAR *fmt, ...)
{
  int r;
  va_list ap;
  va_start (ap, fmt);
  r = __small_vswprintf (dst, fmt, ap);
  va_end (ap);
  return r;
}
@


1.24
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d4 1
a4 1
	     2007, 2008, 2009, 2012, 2013
d204 1
@


1.24.2.1
log
@Add more missing patches
@
text
@d4 1
a4 1
	     2007, 2008, 2009, 2012, 2013, 2014
a203 1
		  break;
@


1.23
log
@	* Merge in cygwin-64bit-branch.
@
text
@d487 1
d489 1
d524 1
d526 1
@


1.22
log
@whitespace cleanup
@
text
@d4 1
a4 1
	     2007, 2008, 2009, 2012
d23 2
a24 2
#define rnarg(dst, base, dosign, len, pad) __rn ((dst), (base), (dosign), va_arg (ap, long), len, pad, LMASK)
#define rnargLL(dst, base, dosign, len, pad) __rn ((dst), (base), (dosign), va_arg (ap, unsigned long long), len, pad, LLMASK)
d95 34
d137 1
d141 1
a141 1
  long Rval = 0;
a208 1
		case 'd':
d210 7
a216 4
		    long val = va_arg (ap, long);
		    dst = __rn (dst, 10, addsign, val, len, pad, LMASK);
		    if (c == 'R')
		      Rval = val;
d219 7
a225 3
		case 'D':
		  dst = rnargLL (dst, 10, addsign, len, pad);
		  break;
d227 28
a254 1
		  dst = rnarg (dst, 10, 0, len, pad);
d256 3
d260 16
a275 4
		  dst = rnargLL (dst, 10, 0, len, pad);
		  break;
		case 'o':
		  dst = rnarg (dst, 8, 0, len, pad);
d280 3
a282 2
		  /* fall through */
		case 'x':
d284 1
a284 3
		  break;
		case 'X':
		  dst = rnargLL (dst, 16, 0, len, pad);
d358 1
a358 2
      strcpy (dst, ", errno ");
      dst += strlen (", errno ");
d479 1
d483 1
d487 1
d522 1
d532 11
d544 35
a578 1
		  dst = wrnarg (dst, 10, addsign, len, pad);
d580 20
a599 11
		case L'D':
		  dst = wrnargLL (dst, 10, addsign, len, pad);
		  break;
		case L'u':
		  dst = wrnarg (dst, 10, 0, len, pad);
		  break;
		case L'U':
		  dst = wrnargLL (dst, 10, 0, len, pad);
		  break;
		case L'o':
		  dst = wrnarg (dst, 8, 0, len, pad);
d604 3
a606 2
		  /* fall through */
		case L'x':
d608 1
a608 3
		  break;
		case L'X':
		  dst = wrnargLL (dst, 16, 0, len, pad);
d652 5
@


1.21
log
@Add missing file from last checkin.
@
text
@d4 1
a4 1
             2007, 2008, 2009, 2012
d150 1
a150 1
		    unsigned char c = (va_arg (ap, int) & 0xff); 
d154 5
a158 5
                      {
                        *dst++ = '0';
                        *dst++ = 'x';
                        dst = __rn (dst, 16, 0, c, len, pad, LMASK);
                      }
@


1.21.2.1
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d4 1
a4 1
	     2007, 2008, 2009, 2012
d150 1
a150 1
		    unsigned char c = (va_arg (ap, int) & 0xff);
d154 5
a158 5
		      {
			*dst++ = '0';
			*dst++ = 'x';
			dst = __rn (dst, 16, 0, c, len, pad, LMASK);
		      }
@


1.21.2.2
log
@	* smallprint.cc (rnarg): Make type-safe.
	(rnargLL): Ditto.
	(__small_vsprintf): Add comment to document meaning of each possible
	conversion.  Fix 'p' conversion for 64 bit.
@
text
@d23 2
a24 2
#define rnarg(dst, base, dosign, len, pad) __rn ((dst), (base), (dosign), va_arg (ap, uint32_t), len, pad, LMASK)
#define rnargLL(dst, base, dosign, len, pad) __rn ((dst), (base), (dosign), va_arg (ap, uint64_t), len, pad, LLMASK)
a94 26
/*
  Meaning of format conversion specifiers.  If 'l' isn't explicitely mentioned,
  it's ignored!

  c       char
  C       WCHAR/wchar_t
  d       signed int, 4 byte
  D       signed int, 8 byte
  E       GetLastError
  o       octal unsigned int, 4 byte
  O       !!! missing !!!
  p       address (only 4 byte right now)
  P       process name
  R       return value, 4 byte.
  s       char *
  ls      char * w/ non-ASCII tweaking
  S       PUNICODE_STRING
  lS      PUNICODE_STRING w/ non-ASCII tweaking
  u       unsigned int, 4 byte
  U       unsigned int, 8 byte
  W       PWCHAR/wchar_t *
  lW      PWCHAR/wchar_t * w/ non-ASCII tweaking
  x       hex unsigned int, 4 byte
  X       hex unsigned int, 8 byte
*/

d197 1
a197 6
#ifdef __x86_64__
		  dst = rnargLL (dst, 16, 0, len, pad);
#else
		  dst = rnarg (dst, 16, 0, len, pad);
#endif
		  break;
@


1.21.2.3
log
@	* exception.h (stackdump): Change first parameter to PUINT_PTR.
	* exceptions.cc: Define cpu specific macros _GR, _AFMT and _ADDR.
	Use throughout to avoid ifdef's.  Fix debug printfs to work in
	64 bit mode as well, throughout.
	(status_info): Define member code as NTSTATUS.  Add casts where
	necessary throughout.
	(dump_exception): Dump all x86_64 registers if building for it.
	(class stack_info): Define dummy_frame as PUINT_PTR.
	(stack_info::init): Change first parameter to PUINT_PTR.  Rename
	ebp to framep for CPU independent naming.  Drop debp macro.
	(stack_info::walk): Rename ebp to framep for CPU independent naming.
	Disable WOW64 hack in 64 bit mode.
	(stackdump): Change first parameter to PUINT_PTR.  Rename ebp to framep
	for CPU independent naming.
	(_cygtls::inside_kernel): Ignore system_wow64_directory on 64 bit.
	(rtl_unwind): Redefine for x86_64 cpu.
	(_except_list): Drop redundant definition.
	(_cygtls::copy_context): Just use __COPY_CONTEXT_SIZE.
	* sigproc.cc (_cygtls::signal_exit): Conditionalize stackdump call per
	cpu.
	* smallprint.cc (__small_vsprintf): Fix up for 64 bit.  Handle 'l' size
	modifier in 'd', 'o', 'u', 'x' conversion to print "long" values on a
	per cpu base.  Add 'O' conversion.  Change comment accrdingly.
	* include/cygwin/signal.h (struct _uc_fpxreg): Define for 64 bit.
	(struct _uc_xmmreg): Ditto.
	(struct _fpstate): Ditto.
	(struct ucontext): Ditto.
	(struct _uc_fpreg): Define for 32 bit.
	(struct _fpstate): Use struct _uc_fpreg for _st.  Use explicit sized
	types.
	(struct ucontext): Use explicit sized types.
	(__COPY_CONTEXT_SIZE): Cast safely.
	(sigset_t): Define as __uint64_t on 64 bit.  Add FIXME comment in 32
	bit case.
@
text
@d99 20
a118 24
   c       char
   C       WCHAR/wchar_t
   d       signed int, 4 byte
  ld       signed long, 4 byte on 32 bit, 8 byte on 64 bit
   D       signed long long, 8 byte
   E       GetLastError
   o       octal unsigned int, 4 byte
  lo       octal unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   O       octal unsigned long long, 8 byte
   p       address
   P       process name
   R       return value, 4 byte.
   s       char *
  ls       char * w/ non-ASCII tweaking
   S       PUNICODE_STRING
  lS       PUNICODE_STRING w/ non-ASCII tweaking
   u       unsigned int, 4 byte
  lu       unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   U       unsigned long long, 8 byte
   W       PWCHAR/wchar_t *
  lW       PWCHAR/wchar_t * w/ non-ASCII tweaking
   x       hex unsigned int, 4 byte
  lx       hex unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   X       hex unsigned long long, 8 byte
a128 1
  int base = 0;
d132 1
a132 1
  int32_t Rval = 0;
d200 1
d202 4
a205 2
		    Rval = va_arg (ap, int32_t);
		    dst = __rn (dst, 10, addsign, Rval, len, pad, LMASK);
d208 3
a210 7
		case 'd':
		  base = 10;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
d212 1
a212 24
		  base = 10;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'o':
		  base = 8;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'x':
		  base = 16;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
gen_decimal:
		  dst = rnarg (dst, base, addsign, len, pad);
a213 3
		case 'D':
		  base = 10;
		  goto gen_decimalLL;
d215 4
a218 12
		  base = 10;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'O':
		  base = 8;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'X':
		  base = 16;
		  addsign = 0;
gen_decimalLL:
		  dst = rnargLL (dst, base, addsign, len, pad);
d229 6
@


1.21.2.4
log
@	* smallprint.cc (__small_vsprintf): Add 'y' and 'Y' conversion.
	Add description to comment.
	(__small_vswprintf): Align behaviour to __small_vsprintf.
@
text
@a122 3
   y       0x hex unsigned int, 4 byte
  ly       0x hex unsigned long, 4 byte on 32 bit, 8 byte on 64 bit
   Y       0x hex unsigned long long, 8 byte
a232 4
		case 'y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
a253 4
		case 'Y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
d341 2
a342 1
      dst = stpcpy (dst, ", errno ");
a462 1
  int base = 0;
a465 1
  int32_t Rval = 0;
a468 1
      bool l_opt = false;
a502 1
		  l_opt = true;
d512 8
a519 5
		case 'R':
		  {
		    Rval = va_arg (ap, int32_t);
		    dst = __wrn (dst, 10, addsign, Rval, len, pad, LMASK);
		  }
d521 2
a522 36
		case L'd':
		  base = 10;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'u':
		  base = 10;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'o':
		  base = 8;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
		  goto gen_decimal;
		case 'y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
		case 'x':
		  base = 16;
		  addsign = 0;
#ifdef __x86_64__
		  if (l_opt)
		    goto gen_decimalLL;
#endif
gen_decimal:
		  dst = wrnarg (dst, base, addsign, len, pad);
d524 2
a525 20
		case 'D':
		  base = 10;
		  goto gen_decimalLL;
		case 'U':
		  base = 10;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'O':
		  base = 8;
		  addsign = 0;
		  goto gen_decimalLL;
		case 'Y':
		  *dst++ = '0';
		  *dst++ = 'x';
		  /*FALLTHRU*/
		case 'X':
		  base = 16;
		  addsign = 0;
gen_decimalLL:
		  dst = wrnargLL (dst, base, addsign, len, pad);
d530 5
a534 1
#ifdef __x86_64__
a535 3
#else
		  dst = wrnarg (dst, 16, 0, len, pad);
#endif
a578 5
  if (Rval < 0)     
    {
      dst = wcpcpy (dst, L", errno ");
      dst = __wrn (dst, 10, false, get_errno (), 0, 0, LMASK);
    }
@


1.21.2.5
log
@	* smallprint.cc (rnarg): Fix cast to print negative values correctly.
@
text
@d23 1
a23 1
#define rnarg(dst, base, dosign, len, pad) __rn ((dst), (base), (dosign), va_arg (ap, int32_t), len, pad, LMASK)
@


1.21.2.6
log
@	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Use %lu as
	format specifier to match HANDLE size.
	* net.cc (cygwin_sendto): Fix return type to be ssize_t.  Change
	syscall_printf return type format specifier to %lR.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* smallprint.cc (__small_vsprintf): Handle `l' for %R, too.
	(__small_vswprintf): Ditto.
	* syscalls.cc (read): Change syscall_printf return type format specifier
	to %lR.
	(readv): Ditto.
	(pread): Ditto.
	(write): Ditto.
	(writev): Ditto.
	(pwrite): Ditto.
	(lseek64): Enhance comment.
@
text
@d4 1
a4 1
	     2007, 2008, 2009, 2012, 2013
a110 1
  lR       return value, 4 byte on 32 bit, 8 byte on 64 bit.
d140 1
a140 1
  intptr_t Rval = 0;
d209 1
a209 6
#ifdef __x86_64__
		    if (l_opt)
		      Rval = va_arg (ap, int64_t);
		    else
#endif
		      Rval = va_arg (ap, int32_t);
d477 1
a477 1
  intptr_t Rval = 0;
d528 1
a528 6
#ifdef __x86_64__
		    if (l_opt)
		      Rval = va_arg (ap, int64_t);
		    else
#endif
		      Rval = va_arg (ap, int32_t);
@


1.20
log
@* DevNotes: Add entry cgf-000009.
* smallprint.cc (__small_vsprintf): Always treat '%c' and '%C' as characters.
Don't decode them if they are > 127.
(__small_vswprintf): Ditto.
@
text
@d149 11
a159 1
		  *dst++ = (char) (va_arg (ap, int) & 0xff);
@


1.19
log
@* smallprint.cc (tmpbuf): Declare new class holding a static buffer, protected
by a lock.
(__small_vsprintf): Use tmpbuf to hold large buffer.
(__small_vswprintf): Ditto.
@
text
@d149 1
a149 11
		  {
		    int c = va_arg (ap, int);
		    if (c > ' ' && c <= 127)
		      *dst++ = c;
		    else
		      {
			*dst++ = '0';
			*dst++ = 'x';
			dst = __rn (dst, 16, 0, c, len, pad, LMASK);
		      }
		  }
d157 1
a157 8
		      if (isprint (*c))
			*dst++ = *c;
		      else
			{
			  *dst++ = '0';
			  *dst++ = 'x';
			  dst = __rn (dst, 16, 0, *c, len, pad, LMASK);
			}
d431 1
a431 11
		  {
		    unsigned int c = va_arg (ap, unsigned int);
		    if (c > L' ' && c <= 127)
		      *dst++ = c;
		    else
		      {
			*dst++ = L'0';
			*dst++ = L'x';
			dst = __wrn (dst, 16, 0, c, len, pad, LMASK);
		      }
		  }
@


1.18
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d3 2
a4 1
   Copyright 1996, 1998, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009
d15 1
d28 28
d98 1
a98 1
  char tmp[NT_MAX_PATH];
d400 1
a400 1
  WCHAR tmp[NT_MAX_PATH];
@


1.17
log
@whitespace elimination
@
text
@d76 1
d150 1
d152 6
a157 1
		  dst = rnarg (dst, 10, addsign, len, pad);
d251 6
@


1.16
log
@	* smallprint.cc (hex_str): New const string.
	(__rn): Drop str and use hex_str instead.
	(__small_vsprintf): If 'l' modifier has been found, print subsequent
	multibyte or wide char string using the s, S, or W options in extended
	hex value layout.

	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Print WCHAR
	and resulting multibyte filename in extended hex value layout in
	debug output.
@
text
@d193 1
a193 1
		      	*dst++ = '\\';
@


1.15
log
@	* smallprint.cc (__small_vsprintf): Simplify UNICODE string handling
	and allow empty strings.
@
text
@d24 2
a31 1
  static const char str[] = "0123456789ABCDEF";
d51 1
a51 1
      res[l++] = str[uval % base];
d79 1
d115 1
d190 10
a199 1
		    *dst++ = *s++;
d210 24
a233 6
		if (sys_wcstombs (tmp, NT_MAX_PATH, us->Buffer,
				  us->Length / sizeof (WCHAR)))
		  {
		    s = tmp;
		    goto fillin;
		  }
a320 1
  static const WCHAR str[] = L"0123456789ABCDEF";
d340 1
a340 1
      res[l++] = str[uval % base];
@


1.14
log
@	* smallprint.cc (__small_vsprintf): Handle NULL PWCHAR and
	PUNICODE_STRING arguments.
	(__small_vswprintf): Ditto.
@
text
@d198 2
d201 2
a202 9
		    if (!sys_wcstombs (tmp, NT_MAX_PATH, us->Buffer,
				       us->Length / sizeof (WCHAR)))
		      {
			s = "invalid UNICODE_STRING";
			goto fillin;
		      }
		    char *t = tmp;
		    for (i = 0; *t && i < n; i++)
		      *dst++ = *t++;
@


1.13
log
@	* smallprint.cc (__small_vsprintf): Use already available buffer tmp
	in wfillin case.
@
text
@d191 1
a191 2
		  RtlInitUnicodeString (&uw, w);
		  us = &uw;
d195 2
d442 1
a442 1
		  RtlInitUnicodeString (us = &uw, w);
d446 2
@


1.12
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d198 2
a199 4
		    char *tmpbuf;

		    if (!sys_wcstombs_alloc (&tmpbuf, HEAP_NOTHEAP, us->Buffer,
					     us->Length / sizeof (WCHAR)))
d204 3
a206 4
		    char *tmp = tmpbuf;
		    for (i = 0; *tmp && i < n; i++)
		      *dst++ = *tmp++;
		    free (tmpbuf);
@


1.11
log
@	* Makefile.in (DLL_OFILES): Add kernel32.o.
	* autoload.cc (WSACloseEvent): Remove.
	(WSACreateEvent): Remove.
	* cygheap.cc (cygheap_init): Drop initializing shared_prefix.
	* cygheap.h (struct init_cygheap): Drop shared_prefix and
	shared_prefix_buf members.
	* fhandler_socket.cc (sock_shared_name): New static function.
	(search_wsa_event_slot): Convert name buffers to WCHAR.  Call
	NtCreateMutant/NtOpenMutant to create mutexes in session local
	namespace.
	(fhandler_socket::init_events): Ditto.  Fix debug output.
	(fhandler_socket::release_events): Close mutexes using NtClose.
	(fhandler_socket::dup): Ditto.
	* kernel32.cc: New file, implementing Win32 calls in a Cygwin-specific
	way.
	* mmap.cc (MapView): Make static.
	* ntdll.h: Fix status code sorting.
	(STATUS_OBJECT_NAME_EXISTS): Define.
	(SEMAPHORE_QUERY_STATE): Define.
	(CYG_SHARED_DIR_ACCESS): Define.
	(CYG_MUTANT_ACCESS): Define.
	(CYG_EVENT_ACCESS): Define.
	(CYG_SEMAPHORE_ACCESS): Define.
	(enum _PROCESSINFOCLASS): Define ProcessSessionInformation.
	(struct _PROCESS_SESSION_INFORMATION): Define.
	(NtCreateSemaphore): Declare.
	(NtOpenSemaphore): Declare.
	* flock.cc: Use CYG_xxx_ACCESS access masks where appropriate.
	* posix_ipc.cc (ipc_mutex_init): Use native functions to create mutex.
	Create in cygwin-shared subdir.
	(ipc_cond_init): Ditto for event.
	(ipc_mutex_close): Use NtClose.
	(ipc_cond_close): Ditto.
	(mq_open): Drop "cyg" prefix from mqh_uname.
	* shared.cc (CYG_SHARED_DIR_ACCESS): Drop definition here.
	(_cygwin_testing): Declare extern on file level.
	(get_shared_parent_dir): Change name of shared directory.  Add name
	to api_fatal output.
	(get_session_parent_dir): New function.
	(shared_name): Simplify.
	(shared_info::initialize): Call get_session_parent_dir.
	* shared_info.h (get_session_parent_dir): Declare.
	* smallprint.cc (__small_vswprintf): Fix bug in multibyte string
	conversion.
	* thread.cc (semaphore::semaphore): Align semaphore name to object
	names in posix IPC functions.
	* include/cygwin/version.h (CYGWIN_VERSION_SHARED_DATA): Bump.
@
text
@d3 1
a3 1
   Copyright 1996, 1998, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008
d64 1
a64 1
extern "C" int
d226 1
a226 1
extern "C" int
d237 1
a237 1
extern "C" void
d264 1
a264 1
extern "C" void
d332 1
a332 1
extern "C" int
d469 1
a469 1
extern "C" int
@


1.10
log
@Remove unneeded header files from source files throughout.
@
text
@d438 1
a438 1
		  sys_mbstowcs (tmp, NT_MAX_PATH, s, n);
@


1.9
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@a13 1
#include <stdarg.h>
a15 1
#include <wctype.h>
a16 1
#include <limits.h>
@


1.8
log
@	* fcntl.cc (fcntl_worker): Protect with a 'myfault'.

	* path.cc (normalize_posix_path): Treat X:/ as Win32 path, too.

	* smallprint.cc (__wrn): New static function.
	(__small_vswprintf): New function to generate WCHAR strings.
	(__small_swprintf): Ditto.
	* winsup.h (__small_swprintf): Declare.
	(__small_vswprintf): Declare.
@
text
@d454 1
a454 1
		    
@


1.7
log
@* smallprint.cc (__small_vsprintf): Free allocated buffer rather than pointer
into the buffer.
@
text
@d17 2
d291 191
@


1.6
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d3 2
a4 1
   Copyright 1996, 1998, 2000, 2001, 2002, 2003, 2005, 2006, 2007 Red Hat, Inc.
d199 1
a199 1
		    char *tmp;
d201 1
a201 1
		    if (!sys_wcstombs_alloc (&tmp, HEAP_NOTHEAP, us->Buffer,
d207 1
d210 1
a210 1
		    free (tmp);
@


1.5
log
@	* smallprint.cc (__small_vsprintf): Use HEAP_NOTHEAP for type.
	* strfuncs.cc (sys_wcstombs_alloc): Guard use of ccalloc
	to !__OUTSIDE_CYGWIN__ for use in cygserver.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d67 1
a67 1
  char tmp[PATH_MAX];
d172 1
a172 1
		  if (!GetModuleFileName (NULL, tmp, PATH_MAX))
@


1.4
log
@	* dcrt0.cc (dll_crt0_1): Use GetCommandLineW and convert to current
	codepage.
	* environ.cc (set_file_api_mode): Always set file api to ANSI if not
	using the OEM codepage.
	(codepage_init): Allow "utf8" codepage.
	* fhandler_clipboard.cc (set_clipboard): Convert clipbuf to void and
	cast as needed.  Always convert input to wide char and write
	CF_UNICODETEXT to clipboard.
	(fhandler_dev_clipboard::read): Read CF_UNICODETEXT from clipboard and
	convert to current codepage if CYGWIN_NATIVE format is not available.
	* fhandler_console.cc: Drop redundant undef.
	* smallprint.cc (__small_vsprintf): Convert PWCHAR and UNICODE_STRING
	to current codepage for printing.
	* strfuncs.cc: Use PWCHAR throughout.
	(get_cp): Return CP_UTF8 for utf8_cp codepage setting.
	(sys_wcstombs): Allow NULL target buffer.
	(sys_wcstombs_alloc): New function.
	(sys_mbstowcs_alloc): Ditto.
	* winsup.h (codepage_type): Add utf8_cp.
	(HEAP_NOTHEAP): Define.
	(sys_wcstombs_alloc): Declare.
	(sys_mbstowcs_alloc): Declare.
@
text
@d200 1
a200 1
		    if (!sys_wcstombs_alloc (&tmp, PATH_MAX, us->Buffer,
@


1.3
log
@	* dcrt0.cc (initial_env): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	(dll_crt0_1): Allocate new_argv0 with PATH_MAX size.
	* exceptions.cc (debugger_command): Set size to 2 * PATH_MAX + 20;
	(error_start_init): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	* external.cc (fillout_pinfo): Always fill out ep.progname 0-terminated.
	Fill out ep.progname_long.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Allocate
	buffer for executable filename with PATH_MAX size.
	* pinfo.cc: Throughout use PATH_MAX instead of CYG_MAX_PATH.
	* pinfo.h (class _pinfo): Set progname size to PATH_MAX.
	* smallprint.cc: Include limits.h.  Use PATH_MAX instead of CYG_MAX_PATH
	for path name buffer size.
	* strace.cc (strace::vsprntf): Ditto.
	* include/sys/cygwin.h (EXTERNAL_PINFO_VERSION_32_LP): Define.
	(EXTERNAL_PINFO_VERSION): Set to EXTERNAL_PINFO_VERSION_32_LP.
	(struct external_pinfo): Add progname_long member.
	* include/sys/dirent.h: Correctly include limits.h instead of
	sys/limits.h.
@
text
@d198 1
a198 2
		    ANSI_STRING as = { 0, 0, NULL };
		    NTSTATUS status;
d200 2
a201 5
		    if (current_codepage == ansi_cp)
		      status = RtlUnicodeStringToAnsiString (&as, us, TRUE);
		    else
		      status = RtlUnicodeStringToOemString (&as, us, TRUE);
		    if (!NT_SUCCESS (status))
d206 3
a208 6
		    for (i = 0; i < as.Length; ++i)
		      *dst++ = as.Buffer[i];
		    if (current_codepage == ansi_cp)
		      RtlFreeAnsiString (&as);
		    else
		      RtlFreeOemString (&as);
@


1.2
log
@	* smallprint.cc (__small_vsprintf): Add format specifier 'W' for
	PWCHAR arguments.  Move wide char handling after char handling.
@
text
@d16 1
d67 1
a67 1
  char tmp[CYG_MAX_PATH + 1];
d172 1
a172 1
		  if (!GetModuleFileName (NULL, tmp, CYG_MAX_PATH))
@


1.1
log
@	* ntdll.h (RtlFreeAnsiString): Declare.
	* ntdll.h (RtlFreeOemString): Declare.
	* ntdll.h (RtlUnicodeStringToAnsiString): Declare.
	* ntdll.h (RtlUnicodeStringToOemString): Declare.
	* smallprint.cc: Renamed from smallprint.c.  Drop unnecessary
	forward declarations.
	(__small_vsprintf): Add format specifiers 'C' for WCHAR arguments
	and 'S' for PUNICODE_STRING arguments.
@
text
@d69 2
d176 17
d194 2
a196 1
		    PUNICODE_STRING us = va_arg (ap, PUNICODE_STRING);
a216 12
		case '.':
		  n = strtol (fmt, (char **) &fmt, 10);
		  if (*fmt++ != 's')
		    goto endfor;
		case 's':
		  s = va_arg (ap, char *);
		  if (s == NULL)
		    s = "(null)";
		fillin:
		  for (i = 0; *s && i < n; i++)
		    *dst++ = *s++;
		  break;
@

